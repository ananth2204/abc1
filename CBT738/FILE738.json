{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012707000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE738.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE738.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\n'", "DS1TRBAL": "b'Hb'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x08\\x00\\x02\\x05\\t\\x00\\x01\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04N\\x00\\x00\\x01\\t\\x15O\\x01\\t\\x15O\\x10S\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf8@@@'", "ispf": {"version": "04.78", "flags": 0, "createdate": "2009-06-03T00:00:00", "modifydate": "2009-06-03T10:53:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-478"}, "text": "REGULAR CBT TAPE - VERSION 478    FILE:  738\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT478.FILE738\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 33 MEMBERS COUNTED; CUMULATIVE SIZE IS 7,356 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/03/09    10:53:25    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01F\\x00\\x05\\x01\\x04'_\\x01\\t\\x15O\\x10R\\x01p\\x00\\xa5\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@\"", "ispf": {"version": "01.70", "flags": 0, "createdate": "2004-10-01T00:00:00", "modifydate": "2009-06-03T10:52:05", "lines": 368, "newlines": 165, "modlines": 0, "user": "TKMILLE"}, "text": " Last Update: 06/02/2009    Terry Miller\n                            ConocoPhillips\n                            tkmille@ConocoPhillips.com\n\n Modification Level: V01.02.02\n\n Corrected Help screen REORGVSH operands.\n Modified Rexx Exec REORGVSX to eliminate some redundant code.\n Modified Abender source to remove jcl (allow it to assemble)\n   (Thanks to Michael Mayne)\n\n Modification Level: V01.02.01\n\n Added a second invocation Rexx Exec called REORGVSX to\n perform the I/O and work.  Exec REORGVS became a front-end\n exec to invoke an ISPF environment if the user invokes\n REORGVS in the foreground.  REORGVS continues to work\n as it did before if it is invoked in the background with\n the exception that there are now two invocation execs\n (REORGVS which calls REORGVSX to do the work).\n\n Modified Rexx exec REORGVS\n   (requires site tailoring for SYSPROC lib)\n Added one new Rexx exec REORGVSX\n   (requires site tailoring for ISPPLIB and ISPMLIB libs)\n Added three new ISPF panels:  REORGPN1, REORGPN2, REOHGPN1\n Added one   new ISPF message member: REOM00\n Modified the SYSHELP panel for REORGVS\n\n Modification Level: V01.01.08\n\n Updated REXX execs to add the following two\n user tailoring comment:\n 1) Change the length of \"sysid\" to your specification.\n     The default is 3 characters if this is not\n     modified.\n\n Updated REXX exec \"REORGVS5\" to add the following additional\n tailoring comment:\n 2) Change the HLQ of the log dataset to your\n     specification.  The default is HLQ is \"SYS3\".\n\n Modification Level: V01.01.07\n\n Added a REXX exec call BADVSAM which identifies VSAM components\n which are defined with the \"IMBED\", \"REPLICATE\", and \"KEYRANGE\"\n parameters.  Calls program 'IGGCSI00' to look through each ICF\n catalog import connected to the master catalog.\n\n Modification Level: V01.01.06\n\n REORGVS is a REXX facility which allows a user to reorganize VSAM\n clusters without having to know the specifics of the allocation\n parameters and components associated with the cluster.\n\n It was written to reallocate and reorg VSAM clusters which were\n defined with the \"IMBED\" and \"REPLICAT\" parameters which are no\n longer supported by Z/OS 1.5 and higher.  It was written with the\n express purpose of converting these VSAM clusters, but it is also\n very useful in reorganizing clusters.  The user does not need to\n know the file attributes of the cluster or of the associates\n components in order to reorg a cluster.\n\n The facility executes REXX execs and IDCAMS in a background job.\n The REXX facility issues IDCAMS commands to parse out the\n DEFINE parameters and creates IDCAMS commands to reallocate the\n VSAM components.\n\n The reorg facility issues IDCAMS EXPORT and IMPORT FUNCTIONS\n BACKUP/RELOAD the cluster data.\n\n Multiple clusters can be reorged at the same time.  The REXX\n facility uses a random number suffix for the JOBNAME of each\n reorg job that it submits through the internal reader.\n\n The facility handles clusters having alternate indexes and paths.\n\n The facility assumes that RACF is installed as the security product.\n If RACF IS NOT INSTALLED ON YOUR SITE, YOU WILL HAVE TO MODIFY REXX\n EXEC \"REORGVS4\" TO ISSUE THE EQUIVALENT STATEMENTS FOR YOUR SECURITY\n PRODUCT AND CHANGES SOME OF THE \"REORGVSS\" SKELETON).  Alternately,\n you may choose to handle security profiles seperately after the fact.\n\n Please report any bugs to TERRY MILLER at Tkmille@ConocoPhillips.Com\n\n INSTALLATION INSTRUCTIONS:\n\n THE INSTALLATION INTRUCTIONS ARE IN MEMBER \"$INSTALL\"\n\n MEMBER NAMES AND DESCRIPTIONS:\n\n     $$DOC     - THE DOCUMENTATION MEMBER FOR THE \"REORGVS\" FACILITY.\n\n     $CHANGES  - CHANGE LOG OF THIS FACILITY SINCE IT WAS WRITTEN.\n\n     @FILEXXX  - THE CBT INDEX MEMBER FOR THE \"REORGVS\" FACILITY.\n\n     $INSTALL  - THE COMPLETE SET OF INSTALLATION PROCEDURES FOR\n                 THE \"REORGVS\" FACILITY.\n\n      INSTALL  - THE INSTALLATION EXEC. THIS EXEC PROMPTS FOR\n                 RUNTIME INSTALL INFORMATION AND THEN ALLOCATES\n                 THE RUNTIME LIBRARIES.  SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n     INSTALL2  - JCL TO ASSEMBLE THE TWO ASSEMBLER SOURCE PROGRAMS\n                 USED BY THE \"REORGVS\" FACILITY. SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n     INSTALL3  - JCL TO COPY THE \"REORGVS\" REXX EXEC TO YOUR\n                 FACILITY'S SYSPROC LIBRARY. SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n     INSTALL4  - JCL TO COPY THE \"REORGVS\" ISPF HELP PANEL TO YOUR\n                 FACILITY'S SYSHELP LIBRARY. SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n      REORGVS  - THE INVOKING REXX EXEC.  THIS EXEC INVOKES THE\n                 ISPF ENVIRONMENT IF CALLED FROM THE FOREGROUND.\n                 IT ALSO CALLS EXEc REORGVSX.\n\n      REORGVSX - THIS EXEC TAILORS THE SKELETON JCL MEMBER\n                 (\"REORGVSS\") AND SUBMITS THE REORGANIZATION JOB\n                 TO REORGANIZE A VSAM CLUSTER.\n\n                 THIS REXX EXEC WILL BE PLACED INTO A \"SYSPROC\"\n                 LIBRARY DURING THE INSTALL PROCESS WHERE IT CAN\n                 BE INVOKED FROM EITHER FOREGROUND OR BACKGROUND TSO.\n\n                 IF INVOKED FROM THE FOREGROUND, THE USER WILL ENTER\n                 THE REORG PARMS ON AN ISPF PANEL (REORGPN1).\n\n                 USERS CAN NOT ONLY REORGANIZE A VSAM CLUSTER USING\n                 THIS EXEC, BUT THEY CAN ALSO INCREASE OR DECREASE\n                 THE DATA COMPONENT'S PRIMARY AND SECONDARY SPACE\n                 ALLOCATION VALUES BY A SPECIFIED PERCENTAGE.\n\n                 BACKGROUND EXAMPLE INVOCATION SCENARIOS:\n\n                 1) %REORGVS my.vsam.dataset\n                 2) %REORGVS my.vsam.dataset HLQ(SYS5)\n                 3) %REORGVS my.vsam.dataset HLQ(SYS5) PRI(+05)\n                 4) %REORGVS my.vsam.dataset PRI(+10)\n                 5) %REORGVS my.vsam.dataset PRI(+10) SEC(+10)\n                 6) %REORGVS my.vsam.dataset PRI(-50) SEC(-50)\n                 7) REORGVS my.vsam.dataset TEST\n                 8) REORGVS my.vsam.dataset PRI(+10)  SEC(+10) TEST\n\n                 BACKGROUND EXAMPLE EXPLANATIONS:\n\n                 1) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n                 2) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n                       and create work datasets with the HLQ of 'SYS5'.\n                 3) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n                       and create work datasets with the HLQ of 'SYS5'\n                       and increase the data component's primary\n                       allocation units value by 5%\n                 4) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n                       and increase the data component's primary\n                       allocation units value by 10%\n                 5) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n                       and increase the data component's primary\n                       allocation units value by 10% and increase\n                       data component's secondary allocation units\n                       value by 10%. (Note, if the secondary\n                       allocation unit is presently zero, it will\n                       remain 0 after the adjustment).\n                 6) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n                       and decrease the data component's primary\n                       allocation units value by 50% and decrease\n                       data component's secondary allocation units\n                       value by 50%. (Note, if the secondary\n                       allocation unit is presently zero, it will\n                       remain 0 after the adjustment).\n                 7) Test the Reorganization (Simulation pass)\n                       of the Vsam Cluster named\n                       'MY.VSAM.DATASET'.  Does not affect the\n                       Cluster on a TEST pass simulation.\n                 8) Test the Reorganization (Simulation pass) of\n                       the Vsam Cluster named 'MY.VSAM.DATASET'\n                       and of increasing the primary allocation\n                       units by +10% and of increasing the\n                       secondary allocation units by +10%.  Does\n                       not affect the Cluster on a TEST pass\n                       simulation.\n\n      REORGVS1 - THIS REXX EXEC BUILDS IDCAMS \"LISTCAT\" COMMANDS\n                 TO LIST THE CLUSTER AND OBTAIN REALLOCATION\n                 parameters.  IT ALSO BUILDS THE IDCAMS \"EXPORT\"\n                 AND \"IMPORT\" STATEMENTS TO EXPORT/IMPORT THE\n                 CLUSTER DATA IN IDCAMS STEPS.\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      REORGVS2 - THIS REXX EXEC INPUTS AN IDCAMS \"LISTCAT\" SYSPRINT\n                 REPORT AND PARSES OUT THE PARAMETERS TO REALLOCATE\n                 THE VSAM CLUSTER BY BUILDING IDCAMS \"DEFINE CLUSTER\"\n                 COMMANDS.  IF THE CLUSTER HAS ALTERNATE\n                 INDEX ASSOCIATES, IT CREATES IDCAMS \"LISTCAT\"\n                 COMMANDS FOR THE AIX COMPONENTS TO BE PROCESSED\n                 IN AN IDCAMS STEP.\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      REORGVS3 - THIS REXX EXEC INPUTS AN IDCAMS \"LISTCAT\" SYSPRINT\n                 REPORT AND PARSES OUT THE PARAMETERS TO REALLOCATE\n                 THE AIX COMPONENT BY BUILDING IDCAMS \"DEFINE AIX\",\n                 \"DEFINE PATH\", AND \"BLDINDEX\" COMMANDS TO BE\n                 EXECUTED BY AN IDCAMS STEP.\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      REORGVS4 - THIS REXX EXEC INPUTS A RACF \"LISTDSD\" SYSPRINT\n                 REPORT AND PARSES OUT THE PARAMETERS TO RE-ISSUE\n                 THE RACF COMMANDS TO ADD BACK DISCRETE RACF PROFILES\n                 (IF THEY EXIST).\n\n                 THIS EXEC (AND FACILITY) ASSUMES THAT THE INSTALLATION\n                 USES RACF FOR ITS SECURITY PRODUCT.  IF RACF IS\n                 NOT INSTALLED AT YOUR FACILITY, YOU WILL WANT TO\n                 OMIT CERTAIN STEPS FROM YOUR REORGVS SKELETON\n                 LIBRARY (INCLUDING THE ONE WHICH EXECUTES THIS EXEC -\n                 SEE MEMBER \"$$DOC FOR FURTHER INSTRUCTIONS ON THIS).\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      REORGVS5 - THIS REXX EXEC INPUTS A \"GOOD\" OR \"BAD\" PARAMETER\n                 AND LOGS THE REORGANIZATION ENTRY TO A LOG FILE.\n                 THE LOG FILE IS DYNAMICALLY ALLOCATED BEFORE THE\n                 ENTRY IS LOGGED.  THERE WILL BE ONE ENTRY FOR EACH\n                 REORG JOB SUBMITTED. IT WILL EITHER LOG A SUCCESS\n                 OR A FAILURE WITH THE CLUSTER DATASET NAME, EXPORT\n                 IMAGE DATASET NAME, AND THE DATE AND TIME.\n                 THE EXEC CALLS ANOTHER EXEC CALLED \"DYNALC\" TO\n                 DYNAMICALLY ALLOCATE THE LOG FILE.  \"DYNALC\" CALLS\n                 ASSEMBLER PROGRAM \"WAITFOR\" (IF IT CANNOT\n                 ALLOCATE THE LOG FILE ON THE FIRST ATTEMPT) WHICH\n                 IS LINKED INTO THE REORGVS LOAD LIBRARY.\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      REORGVS6 - THIS REXX INPUTS AN IDCAMS EXPORT SYSPRINT REPORT\n                 FILE AND PARSES OUT THE RETURN CODES AND MESSAGES\n                 TO DETERMINE THE RESULT OF THE EXPORT FUNCTION.\n                 EXPORT WILL RETURN A RC=12 WHEN A VSAM CLUSTER IS\n                 EMPTY (WITH MSG \"IDC3351I\" AND FEEDBACK CODE 160).\n                 THIS PROGRAM DOES A SMART ANALYSIS TO CHECK\n                 THE RESULTS OF THE EXPORT COMMAND INSTEAD OF USING\n                 THE RETURN CODE SET BY EXPORT.\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      DYNALC   - THIS REXX EXEC PERFORMS THE DYNALLOCATION FOR THE\n                 LOG FILE ALLOCATION.  IT TRIES UP TO 1800 TIMES TO\n                 DYNAMICALLY ALLOCATE THE LOG FILE IF THE FILE IS\n                 BUSY AND WAITS FOR A 3 SECOND INTERVAL BETWEEN\n                 ALLOCATION ATTEMPTS (FOR A TOTAL ELAPSED WINDOW OF\n                 90 MINUTES BEFORE IT TIMES OUT).  IT CALLS PROGRAM\n                 \"WAITFOR\" BETWEEN ALLOCATION ATTEMPTS TO ACCOMPLISH\n                 THE ECB WAIT INTERVAL IF THE LOG FILE CANNOT BE\n                 ALLOCATED ON THE FIRST ATTEMPT.\n\n                 NO TAILORING IS REQUIRED FOR THIS EXEC.  IT WILL\n                 RESIDE IN \"XXXXXXXX.REORGVS.EXEC\", BUT THIS EXEC\n                 LIBRARY DOES NOT NEED TO BE CONCATENATED TO A\n                 SYSPROC CONCATENATION ALLOCATION.\n\n      REORGPN1 - ISPF PANEL USED TO ENTER THE REORG SPECIFICATIONS\n                 IF THE REORGVS EXEC IS INVOKED FROM THE FOREGROUND.\n\n      REOHGPN1 - ISPF HELP PANEL FOR ISPF PANEL REORGPN1.\n\n      REORGPN2 - ISPF PANEL USED TO DISPLY THE MESSAGE RESULTS FROM\n                 THE CLUSTER REORG IF THE REORGVS EXEC IS INVOKED\n                 FROM THE FOREGROUND.\n\n      REORGVSH - ISPF HELP PANEL FOR THE \"REORGVS\" COMMAND.\n                 THIS MEMBER WILL BE COPIED TO YOUR FACILITY'S\n                 \"SYSHELP\" ISPF LIBRARY DURING THE INSTALL PROCESS\n                 (OPTIONAL INSTALL STEP).\n\n      REORGVSS - SUBMIT JCL SKELETON MEMBER.  THIS MEMBER WILL BE\n                 TAILORED AND SUBMITTED INTO THE INTERNAL READER\n                 BY THE \"REORGVS\" EXEC WHEN IT IS EXECUTED.\n\n                 DO NOT CHANGE THIS MEMBER ONCE IT IS INSTALLED\n                 INTO THE \"XXXXXXXX.REORGVS.CNTL\" JCL LIBRARY !!!!!\n\n      ABENDER  - THIS IS AN ABEND PROGRAM ASSEMBLER SOURCE CODE.\n                 IT IS EXECUTED TO PRODUCE AN ABEND IF ERRORS\n                 OCCUR DURING THE REORGVS PROCESSING.\n\n                 THIS PROGRAM WILL BE ASSEMBLED AND LINKED INTO LOAD\n                 LIBRARY \"XXXXXXXX.REORGVS.LOADLIB\" DURING THE\n                 INSTALL PROCESS.  IT IS USED IN THE \"REORGVSS\"\n                 MEMBER.\n\n      WAITFOR  - STIMER MACRO WAIT PROGRAM IN ASSEMBLER SOURCE CODE.\n                 IT ISSUES AN ECB WAIT FOR AN INTERVAL OF TIME\n                 IF THE LOG FILE CANNOT BE ALLOCATED ON THE FIRST\n                 ATTEMPT.\n\n                 THIS PROGRAM WILL BE ASSEMBLED AND LINKED INTO LOAD\n                 LIBRARY \"XXXXXXXX.REORGVS.LOADLIB\" DURING THE\n                 INSTALL PROCESS.  IT IS CALLED IN THE \"DYNALC\"\n                 REXX EXEC.\n\n      IVPTEST  - SAMPLE JCL TO REORG A VSAM CLUSTER.  CAN BE USED\n                 TO TEST THE FACILITY ONCE IT IS INSTALLED.\n\n     REORGVSJ  - JCL TO RUN THE REORGVS FACILITY IN THE TSO BACKGROUND.\n\n                 (THE \"REORGVS\" EXEC CAN ALSO BE RUN FROM THE TSO\n                  FOREGROUND FROM THE SYSPROC LIBRARY.  THIS IS\n                  WHERE THE INSTALL PROCESS COPIES IT TO).\n\n\n ASSUMPTIONS\n -----------\n\n   THIS FACILITY ASSUMES THE USE OF IBM'S RACF PRODUCT AS A SECURITY\n   PRODUCT.  IF YOUR INSTALLATION USES ANOTHER SECURITY PRODUCT, THIS\n   FACILITY WILL NEED TO BE MODIFIED TO WORK.  THE RACF SECURITY\n   IS USED ONLY TO RE-CREATE RACF DISCRETE DATASET CLASS PROFILES.\n   IF DISCRETE (DISCRET TO A VOLSER) PROFILES ARE NOT BEING USED,\n   THEN THE FOLLOWING NINE STEPS CAN BE OMITTED FROM THE REORG JCL\n   STREAM IN SKELETON MEMBER \"REORGVSS\":\n\n     GETRACF, CHK500, ABEND500, BLDRACF, CHK700, ABEND700,\n     GENPROF, CHK750, ABEND750.\n\n   ALSO, THE FOLLOWING REXX EXEC CAN BE DISCARDED:  REORGVS4\n\n CERTIFICATION\n -------------\n\n BATCH:\n\n   THESE REXX EXECS AND JCL HAVE BEEN RUN IN A Z/OS ENVIRONMENT.\n   THE SOURCE CODE FOR \"ABENDER\" AND \"WAITFOR\" HAVE BEEN ASSEMBLED\n   WITH THE HIGH-LEVEL ASSEMBLER AND TESTED.  THEY DO NOT NEED TO\n   RUN IN AN AUTHORIZED ENVIRONMENT.  THERE ARE NO SPECIAL\n   REQUIREMENTS FOR ASSEMBLING AND LINKING THESE TWO MODULES.\n\n PROBLEM REPORTING\n -----------------\n\n PLEASE REPORT ANY BUGS OR SUGGESTIONS FOR IMPROVEMENT TO:\n        TERRY MILLER AT Tkmille@ConocoPhillips.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHANGES": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00A\\x01\\x054\\x7f\\x01\\t\\x15O\\x10R\\x00\\x88\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2005-12-13T00:00:00", "modifydate": "2009-06-03T10:52:41", "lines": 136, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "                 REORGVS VERSION CHANGE HISTORY\n\n 06/02/2009 - V01.02.02\n\n            - MODIFICATION LEVEL: V01.02.02\n            - CORRECTED HELP SCREEN REORGVSH OPERANDS.\n            - MODIFIED REXX EXEC REORGVSX TO ELIMINATE SOME REDUNDANT\n              CODE.\n              MODIFIED ABENDER SOURCE TO REMOVE JCL (ALLOW IT TO\n              ASSEMBLE).\n                (THANKS TO MICHAEL MAYNE.)\n\n 05/26/2009 - V01.02.01\n\n            - ADDED A SECOND INVOCATION REXX EXEC CALLED REORGVSX TO\n              PERFORM THE I/O AND WORK.  EXEC REORGVS BECAME A FRONT-END\n              EXEC TO INVOKE AN ISPF ENVIRONMENT IF THE USER INVOKES\n              REORGVS IN THE FOREGROUND.  REORGVS CONTINUES TO WORK\n              AS IT DID BEFORE IF IT IS INVOKED IN THE BACKGROUND WITH\n              THE EXCEPTION THAT THERE ARE NOW TWO INVOCATION EXECS\n              (REORGVS WHICH CALLS REORGVSX TO DO THE WORK).\n\n            - MODIFIED REXX EXEC REORGVS\n                (REQUIRES SITE TAILORING FOR SYSPROC LIB)\n              ADDED ONE NEW REXX EXEC REORGVSX\n                (REQUIRES SITE TAILORING FOR ISPPLIB AND ISPMLIB LIBS)\n            - ADDED THREE NEW ISPF PANELS: REORGPN1, REORGPN2, REOHGPN1\n            - ADDED ONE   NEW ISPF MESSAGE MEMBER: REOM00\n            - MODIFIED THE SYSHELP PANEL FOR REORGVS\n\n 09/12/2008 - V01.01.08\n\n            - UPDATED REXX EXECS TO ADD THE FOLLOWING USER\n              TAILORING COMMENT:\n              1) CHANGE THE LENGTH OF \"SYSID\" TO YOUR SPECIFICATION.\n                   THE DEFAULT IS 3 CHARACTERS IF THIS IS NOT\n                   MODIFIED.\n            - ALSO UPDATED REXX EXEC \"REORGVS5\" TO ADD THE ADDITIONAL\n              TAILORING COMMENT:\n              2) CHANGE THE HLQ OF THE LOG DATASET TO YOUR\n                   SPECIFICATION.  THE DEFAULT HLQ IS \"SYS3\".\n\n 09/27/2006 - V01.01.07\n\n           - ADDED A REXX EXEC CALL BADVSAM WHICH IDENTIFIES VSAM\n             COMPONENTS WHICH ARE DEFINED WITH THE \"IMBED\",\n             \"REPLICATE\", AND \"KEYRANGE\" PARAMETERS.  CALLS PROGRAM\n             'IGGCSI00' TO LOOK THROUGH EACH ICF CATALOG IMPORT\n             CONNECTED TO THE MASTER CATALOG.\n\n 08/28/2006 - V01.01.06\n\n           - ADDED A MACRO CALLED \"HOWCALLD\" TO BE USED IN PROGRAMS\n             \"ABENDER\" AND \"WAITFOR\". THE MACRO DETERMINES HOW THE\n             PROGRAMS WERE CALLED BY THE CALLER.\n\n 08/24/2006 - V01.01.05\n\n           - FIXED A BUG IN REXX EXECS \"REORGVS1\", \"REORGVS2\",\n             \"REORGVS3\" AND \"REORGVS4\".\n             IF THERE ARE NO AIX ASSOCIATIONS WITH A CLUSTER, THE\n             DDNAME AIXCMDS AND DEFINE WERE NOT BEING OPENED AND\n             CAUSED A SUBSEQUENT FAILURE IN THE IDCAM STEPS\n             WHICH WERE PROCESSING THESE FILES AS INPUT FILES.\n             A \"WRONG LENGTH RECORD\" MESSAGE WOULD BE ISSUED\n             DUE TO OF THE ABSENCE OF AN EOF (END OF FILE)\n             INDICATOR IN THE INPUT DATASETS.\n\n 05/24/2006 - V01.01.04\n\n           - ELIMINATED THE \"UNIQUE/SUBALLOCATION' KEYWORD PARMS\n             ON THE DEFINE STATEMENTS FOR BOTH CLUSTERS AND\n             ALTERNATE INDEXES.  THESE KEYWORD PARMS ARE NO LONGER\n             COMPATABLE WITH ICF CATALOGS.  ALSO, THE UNIQUE\"\n             KEYWORD IS INCOMPATABLE WITH THE \"REUSE\" PARAMETER.\n\n             IBM NOTE:\n             \"THE UNIQUE KEYWORD WHEN IT WAS ORIGINALLY IMPLEMENTED\n             WAS INTENDED FOR USE WITH VSAM CATALOGS (THE\n             PREDECESSORS TO ICF CATALOGS) TO FORCE THE DATA SET\n             TO HAVE IT'S OWN ENTRY IN THE VTOC, RATHER THAN BEING\n             ALLOCATED FROM A \"VSAM SPACE\".  WHEN ICF CATALOGS\n             CAME ALONG EVERY VSAM DATA SET DEFINED IN AN ICF\n             CATALOG HAS THE UNIQUE KEYWORD, REGARDLESS IF YOU\n             SPECIFY IT OR NOT.  IT'S A REMNANT OF VSAM CATALOGS\n             (IN WHICH SUPPORT WAS DROPPED IN OS/390 2.10 (AND\n             THEY STOPPED FUNCTIONING IN EARLIER RELEASES ON\n             SYSTEMS WITH A SYSTEM DATE LATER THAN JAN 1, 2000) IN\n             SHORT UNIQUE AN OBSOLETE PARAMETER.\"\n\n\n\n 02/23/2006 - V01.01.03\n\n           - CHANGED EXEC \"REORGVS5\" TO SHOW THE LOGFILE DATSET NAME.\n\n 02/16/2006 - V01.01.02\n\n           - INCREASED THE FIELD SIZE OF ALL NUMERIC VALUES FROM\n              FIVE DIGITS TO EIGHT DIGITS.\n\n           - FIXED BUG WITH THE INDEX COMPONENT'S SECONDARY\n              ALLOCATION UNITS. IT WAS USING THE SAME VALUE\n              AS THE PRIMARY ALLOCATION UNITS.\n\n           - ADDED THE FOLLOWING PARAMETERS TO THE CLUSTER\n              DEFINITIONS AS EXPLICITLY STATED:\n\n                 UNORDERED    / ORDERED\n                 UNIQUE       / SUBALLOCATION\n                 NOWRITECHECK / WRITECHECK\n                 NOERASE      / ERASE\n\n           - ADDED A \"TEST\" PARAMETER TO THE \"REORGVS\" EXEC\n              TO ALLOW A TEST SIMULATION (WITH NO FILE UPDATES).\n              (ALSO, DOES NOT DELETE THE WORK DATASETS SO THEY\n               CAN BE ANALYZED).\n\n                  %REORGVS  MY.CLUSTER   TEST\n\n 01/31/2006 - V01.01.01\n\n           - ADDED THE CAPABILITY OF INCREASING OR DECREASING\n              THE CLUSTER'S DATA COMPONENT'S PRIMARY AND/OR\n              SECONDARY SPACE ALLOCATION BY A SPECIFIED\n              PERCENTAGE.  ADDED THE INVOCATION PARAMETERS:\n\n                  PRI(+NNN)  [ OR PRI(-NNN) ]     AND\n                  SEC(+NNN)  [ OR SEC(-NNN) ]\n\n 01/26/2006 - V01.01.00\n\n           - NEW FACILITY OFFERED ON CBT\n\n\n     *****  END OF CHANGE HISTORY LOG  *****\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00(\\x01\\x06\\x02\\x7f\\x01\\t\\x15/\\x11C\\x00\\x99\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2009-06-01T11:43:28", "lines": 153, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "\nInstallation Instructions:\n\n1) After RECEIVING THE XMI file into a Dataset (You have already done\n   that or you would not be looking at this member), go to SPF option\n   6 command line and enter this command:\n\n      EXEC  'XXXXXXXX.REORGVS(INSTALL)'\n\n   Where XXXXXXXX is the HLQ of this dataset.  The INSTALL Rexx exec\n   will tailor and copy the REORGVS members to your runtime libraries\n   after prompting you for these 4 pieces of information:\n\n       1) Output Dataset name containing the PDS members\n          created by the RECEIVE INDS command (and is also\n          the dataset which contains this Rexx Exec).\n       2) The HLQ (High-Level Qualifier) to be used to install\n          the REORGVS runtime libraries.\n       3) The Volser to be used to allocate the runtime\n          libraries and Logfile.\n       4) The Dataset name of the exec library concatenated\n          to ddname SYSPROC to copy the REORGVS exec into\n          for foreground invocation of exec REORGVS.\n\n   After prompting for these 4 pieces of information\n   it will tailor the install file members and the\n   user will then be ready to continue the install of\n   this product.\n\n2) After the INSTALL exec completes, the following members should\n   reside in the following libraries:\n\n        XXXXXXXX.REORGVS.CNTL  (Where XXXXXXXX is HLQ above):\n\n            INSTALL2\n            INSTALL3\n            IVPTEST\n            REORGVSS\n\n        XXXXXXXX.REORGVS.EXEC  (Where XXXXXXXX is HLQ above):\n\n            DYNALC\n            REORGVS\n            REORGVSX\n            REORGVS1\n            REORGVS2\n            REORGVS3\n            REORGVS4\n            REORGVS5\n            REORGVS6\n\n        XXXXXXXX.REORGVS.PANELS (Where XXXXXXXX is HLQ above):\n\n            REOHGPN1\n            REORGPN1\n            REORGPN2\n\n        XXXXXXXX.REORGVS.MSGS   (Where XXXXXXXX is HLQ above):\n\n            REOM00\n\n        XXXXXXXX.REORGVS.SOURCE  should be empty.\n\n        XXXXXXXX.REORGVS.LOADLIB should be empty.\n\n        XXXXXXXX.REORGVS.LOGFILE should be empty.\n\n3) Edit Rexx execs \"REORGVS\", 'REORGVSX', \"REORGVS1\", \"REORGVS2\",\n   'REORGVS3', \"REORGVS4\", \"REORGVS5\" AND \"REORGVS6\" in dataset\n   \"XXXXXXXX.REORGVS.EXEC\" (Used in step 2) above).\n   Tailor the execs to suite your specifications by reading and\n   applying the tailoring instructions in the comment with the\n   eye-catcher of \"Modifications/Tailoring:\" in the exec.\n\n4) Submit the following job to assemble the two programs used by\n   the REORGVS facility.  The assemble and link should recieve\n   a return code 0.  You will have to insert your installation's\n   jobcard before you submit the job.\n\n      SUB  'XXXXXXXX.REORGVS.CNTL(INSTALL2)'\n\n   This job assembles the two programs used by the REORGVS facility.\n\n5) Submit the following job to copy the REORGVS Rexx exec and the\n   REORGVSX Rexx exec into the SYSPROC concatenation library.\n   You will have to insert your installation's jobcard before\n   you submit the job.\n\n      SUB  'XXXXXXXX.REORGVS.CNTL(INSTALL3)'\n\n6) EDIT 'XXXXXXXX.REORGVS.CNTL(REORGVSS)'.  Insert your\n   installation's jobcard before you use the REORGVS facility.\n\n   IMPORTANT NOTE !!!:\n   After inserting your facility's JOBCARD, note the following ...\n\n   DO NOT CHANGE member \"REORGVSS\" !!!!  This member is a skeleton\n   JCL member which will be tailored and submitted at execution time.\n   The symbolic variables in this member are updated by the REORGVS\n   process to reorg VSAM files.  The skeleton jcl should not be\n   changed after it is tailored by step 1) above.\n   These are updated at execution time by the facility to\n   subsitute for the necessary information to perform the REORG.\n\n7) COPY and RENAME MEMBER 'XXXXXXXX.REORGVS.CNTL(REORGVSH)'\n   into your ISPF facility Help library allocated to ddname\n   SYSHELP. Rename the member to REORGVS using the following job.\n   You will have to insert your installation's jobcard before you\n   submit the job.\n\n      SUB  'XXXXXXXX.REORGVS.CNTL(INSTALL4)'\n\n8) COPY the ISPF Panel and Message members into your ISPF\n   panel and messages libraries allocated to ddnames ISPPLIB and\n   ISPMLIB.\n   You will have to insert your installation's jobcard before you\n   submit the job.\n\n      SUB  'XXXXXXXX.REORGVS.CNTL(INSTALL5)'\n\n9) To test the REORGVS facility, update member IVPTEST with the\n   VSAM file which you wish to reorganize and then submit the job.\n   You will have to insert your installation's jobcard before you\n   submit the job.\n\n      SUB  'XXXXXXXX.REORGVS.CNTL(IVPTEST)'\n\n   This job should get a return code zero and also submit a\n   reorg job into the internal reader.  The jobname will be\n   in the form  REORGnnn  where nnn is a random number.\n   (If the TEST parameter is passed, the jobname will be in the\n   form REORGTnn where nn is a random number.)\n   Each REORGVS command issued in the Background TSO step (or\n   in the foreground for that matter) will generate one of these\n   or more of these REORGnnn jobs (or REORGTnn jobs with the\n   TEST paramemter).\n\n   The REORGnnn and REORGTnn jobs should end with a condition\n   code of 0 or 4.\n   Condition code 4's are issued in cases where a Discrete\n   Racf profile does not exist for the VSAM cluster being\n   reorganized.\n\n   You are now ready to use the facility.\n\n   IMPORTANT NOTE !!!\n\n   Do not change member \"REORGVSS\" !!!!  This member is a skeleton\n   JCL member which will be tailored at execution time.  The\n   symbolic variables in this member are updated by the REORGVS\n   process to reorg VSAM files.  The skeleton jcl should not be\n   changed after it is tailored by step 1) above.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE738": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04N\\x00\\x00\\x01\\t\\x15O\\x01\\t\\x15O\\x10S\\x00\"\\x00\"\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf8@@@'", "ispf": {"version": "04.78", "flags": 0, "createdate": "2009-06-03T00:00:00", "modifydate": "2009-06-03T10:53:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "CBT-478"}, "text": "//***FILE 738 is from Terry Miller and contains a facility to       *   FILE 738\n//*           reorganize VSAM clusters without having to code any   *   FILE 738\n//*           of the IDCAMS DEFINE statements.  The facility        *   FILE 738\n//*           parses out the Re-allocation information from IDCAMS  *   FILE 738\n//*           reports and reallocates and EXPORTS/IMPORTS the data  *   FILE 738\n//*           to reorg the file.  The facility also reallocates and *   FILE 738\n//*           re-populates any alternate indexes associated to the  *   FILE 738\n//*           base cluster and rebuilds any Racf Discrete profiles  *   FILE 738\n//*           which existed before the reorganization.              *   FILE 738\n//*                                                                 *   FILE 738\n//*                                                                 *   FILE 738\n//*           email:  tkmille@conocophillips.com                    *   FILE 738\n//*                                                                 *   FILE 738\n//*           Last Revision: 06/02/2009 V01.02.02                   *   FILE 738\n//*                                                                 *   FILE 738\n//*> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <*   FILE 738\n//*                                                                 *   FILE 738\n//*                     Important note  !!!!                        *   FILE 738\n//*                     --------- ----  ----                        *   FILE 738\n//*                                                                 *   FILE 738\n//*  This facility assumes the use of IBM'S RACF product as a       *   FILE 738\n//*  security product.                                              *   FILE 738\n//*  If your installation uses another security product, this       *   FILE 738\n//*  facility will need to be modified to work.  The RACF security  *   FILE 738\n//*  is used only to re-create RACF DISCRETE DATASET CLASS profiles.*   FILE 738\n//*  If discrete (DISCRET TO A VOLSER) profiles are not being used, *   FILE 738\n//*  then the following nine steps can be omitted frm the REORG jcl *   FILE 738\n//*  stream in skeleton member \"REORGVSS\":                          *   FILE 738\n//*                                                                 *   FILE 738\n//*    GETRACF, CHK500, ABEND500, BLDRACF, CHK700, ABEND700,        *   FILE 738\n//*    GENPROF, CHK750, ABEND750.                                   *   FILE 738\n//*                                                                 *   FILE 738\n//*  Also, the following REXX exec can be discarded:  REORGVS4      *   FILE 738\n//*                                                                 *   FILE 738\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ABENDER": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x06\\x01\\x06\\x12\\x8f\\x01\\t\\x15?\\x130\\x00\\x96\\x00@\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2006-05-08T00:00:00", "modifydate": "2009-06-02T13:30:06", "lines": 150, "newlines": 64, "modlines": 0, "user": "TKMILLE"}, "text": "* ------------------------------------------------------------------- *\n*                                                                     *\n*             A   BBBB  EEEEE N   N DDDD  EEEEE RRRR                  *\n*            A A  B   B E     NN  N D   D E     R   R                 *\n*           A   A BBBB  EEEE  N N N D   D EEEE  RRRR                  *\n*           AAAAA B   B E     N  NN D   D E     R  R                  *\n*           A   A BBBB  EEEEE N   N DDDD  EEEEE R   R                 *\n*                                                                     *\n*  THIS SUBROUTINE INPUTS A PARM TO BE USED TO ISSUE A USER ABEND.    *\n*  THE USER ABEND CODE IS PASSED TO THIS PROGRAM IN THE EXECUTION     *\n*  PARAMETER.   IF THE EXECUTION PARAMETER IS INVALID, THE PROGRAM    *\n*  WILL USE '1116' AS THE USER ABEND CODE.                            *\n*                                                                     *\n*  THE SUBROUTINE MAY BE INVOKED IN EITHER 24-BIT OR 31-BIT MODE,     *\n*  EITHER ABOVE OR BELOW THE 16-MEG LINE.                             *\n*                                                                     *\n*  THE SUBROUTINE IS REENTRANT.                                       *\n*                                                                     *\n*  THIS SUBROUTINE IS DESIGNED TO BE CALLED FROM JCL OR FROM ANOTHER  *\n*  PROGRAM (THE LINKAGE WORKS EITHER WAY):                            *\n*                                                                     *\n*  PARAMETER LIST ON ENTRY TO \"ABENDER\":                              *\n*     R1    => ADDRESS OF PARAMETER LIST                              *\n*            1 ... A 2-BYTE LENGTH VALUE (LENGTH OF PARM) S/B=4       *\n*            2 ... A 4-BYTE USER ABEND CODE IN EBCDIC (0000-4095)     *\n*                                                                     *\n*  EXAMPLE CALL FROM ASSEMBLER (DYNAMIC CALL):                        *\n*                                                                     *\n*     LOAD  EP=ABENDER           Load program \"ABENDER\"               *\n*     LR    R15,R0               Load  the entry addr                 *\n*     LA    R1,PARMLENG          Get Parm List Address                *\n*     ST    R1,PARMADDR                                               *\n*     LA    R1,PARMADDR          Point to parameter list              *\n*     BASSM R14,R15                                                   *\n*     DELETE EP=ABENDER          Delete program \"ABENDER\"             *\n*                                                                     *\n*     PARMADDR    DS    F                                             *\n*     PARMLENG    DC    H'4'                                          *\n*     ABENDCOD    DC    ZL4'1024'    (Must be between 0000 and 4095)  *\n*                                                                     *\n*  EXAMPLE CALL FROM COBOL (DYNAMIC CALL):                            *\n*                                                                     *\n*     CALL ABENDER-PROGAM   USING  AP-PARMS.                          *\n*                                                                     *\n*     01  ABENDER-PROGRAM     PIC X(8)  VALUE 'ABENDER '.             *\n*     01  AP-PARMS.                                                   *\n*         03  AP-PARM-LENGTH  PIC S9(4) COMP  VALUE +4.               *\n*         03  AP-ABEND-CODE   PIC 9(4)        VALUE 1024.             *\n*                                                                     *\n*  PROGRAM RESTRICTIONS:                                              *\n*                                                                     *\n*     THE ABEND CODE PASSED TO THIS PROGRAM MUST HAVE VALUES BETWEEN  *\n*     0000 AND 4095.                                                  *\n*                                                                     *\n*  PROGRAM DEFAULTS:                                                  *\n*                                                                     *\n*     IF THE ABEND CODE PASSED TO THIS PROGRAM IS INVALID FOR ANY     *\n*     REASON, THE PROGRAM WIlL USE CODE '1116' AS THE USER ABEND CODE.*\n*                                                                     *\n*  REGISTER USAGE:                                                    *\n*            R2   WORK REGISTER                                       *\n*            R3   WORK REGISTER                                       *\n*            R4   WORK REGISTER                                       *\n*            R5   UNUSED                                              *\n*            R6   SAVE AREA BACKWARD LINK                             *\n*            R7   PARAMETER LIST ADDRESS                              *\n*         R8-R10  UNUSED                                              *\n*            R11  UNUSED                                              *\n*            R12  BASE REGISTER                                       *\n*            R13  SAVE AREA                                           *\n*                                                                     *\n* ------------------------------------------------------------------- *\nABENDER  CSECT\nABENDER  AMODE ANY\nABENDER  RMODE ANY\n         SAVE  (14,12),,ABENDER_ASSEMBLED_ON_&SYSDATE._&SYSTIME\n         LR    R12,R15              Load entry address\n         USING ABENDER,R12          Declare entry base\n         LR    R7,R1                Preserve passed parmlist address\n         LR    R6,R13               Store SAVEAREA Backward link\n         L     R3,=A(STORSIZE)      Size of storage to get and clear\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\nINITOBTN DS    0H                  Initialize the obtained storage area\n         LR    R0,R13               Address of target of move (obtnd)\n         L     R3,=A(STORSIZE)      Length of the target of move\n         XR    R14,R14             From address (irrelevant with len=0)\n         XR    R15,R15              Pad/Length to propagate in odd reg\n         MVCL  R0,R14          Propagate binary zeroes in obtained area\n**********************************************************************\n*   Pick up the passed Abend Code - 4 bytes EBCDIC Zoned Decimal\n*   This program can be called from a Rexx exec (or via jcl\n*   directly) or from another program as a subroutine call.\n*   Determine the caller's method of calling ABENDER.\n*   Macro HOWCALLD will determine how this program was called.\n**********************************************************************\n         L     R4,0(,R7)\n         LR    R1,R7               Restore R1\n         HOWCALLD PARMCALL=PARMCALL , How was I called? Subr or Exec?\n         B     PACKCODE             I was called as a subroutine\nPARMCALL DS    0H\n         CLC   0(2,R4),=H'4'       Abend Code must be 4 bytes EBCDIC\n         BNE   INVLPARM            Invalid abend code passed\n         CLC   2(4,R4),=CL4'0000'  Abend Code must be between 0000-4095\n         BL    INVLPARM            Invalid abend code passed\n         CLC   2(4,R4),=CL4'4095'  Abend Code must be between 0000-4095\n         BNH   SKIPLL              Valid abend code passed\nINVLPARM DS    0H\n         L     R4,F1116            Load Default User Abend Code\n         B     ABENDIT\nSKIPLL   DS    0H\n         LA    R4,2(,R4)           Point to the Abend Code (past ll)\nPACKCODE DS    0H\n         PACK  DOUBLE,0(4,R4)      Pack the Abend Code\n         CVB   R4,DOUBLE           Convert Abend Code to binary\nABENDIT  DS    0H\n         O     R4,X80              Initialize User Abend Code\n         LR    R2,R13              Pointer to storage area\n         LA    R3,STORSIZE         Work area size\n*\n         ABEND (R4)                ABEND with UXXX (passed as parm)\n*\n* If you think you will get to this point, you are sadly mistaken ...\n*\nRETURN   DS    0H\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore Return Address with Amode\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n*\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n**********************************************************************\n            DS    0F\nF1116       DC    F'1116'           Default user abend code\nX80         DC    X'80000000'       Indicate User Abend\n            LTORG\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS  (GETMAINED AREA)\n**********************************************************************\nSTORAREA    DSECT ,                  Reentrant storage\nSAVEAREA    DS    20F\nDOUBLE      DS    D                  CVD/CVB Work Area\nSTORSIZE    EQU   *-STORAREA\n            YREGS\n            END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSEMABE": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00I\\x01\\x06#\\x8f\\x01\\x06#\\x8f\\x11A\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-08-26T00:00:00", "modifydate": "2006-08-26T11:41:49", "lines": 27, "newlines": 27, "modlines": 0, "user": "TKMILLE"}, "text": "//ASSEMABE JOB 'ASSEMBLE AND LINK PROGRAM ABENDER',\n//  MSGLEVEL=1,REGION=0M\n//*\n//ASSEMBLE EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.REORGVS.MACLIB\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.REORGVS(ABENDER)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASSEMBLE),\n//         PARM='LIST,LET,MAP,XREF,REUS,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLIB   DD DISP=SHR,DSN=SMPE.REORGVS.LOADLIB\n//SYSLMOD  DD DISP=SHR,DSN=SMPE.REORGVS.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY ABENDER\n NAME  ABENDER(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASSEMWAI": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x006\\x01\\x06#\\x8f\\x01\\x06#\\x8f\\x11A\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-08-26T00:00:00", "modifydate": "2006-08-26T11:41:36", "lines": 27, "newlines": 27, "modlines": 0, "user": "TKMILLE"}, "text": "//ASSEMWAI JOB 'ASSEMBLE AND LINK PROGRAM WAITFOR',\n//  MSGLEVEL=1,REGION=0M\n//*\n//ASSEMBLE EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.REORGVS.MACLIB\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.REORGVS(WAITFOR)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASSEMBLE),\n//         PARM='LIST,LET,MAP,XREF,REUS,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLIB   DD DISP=SHR,DSN=SMPE.REORGVS.LOADLIB\n//SYSLMOD  DD DISP=SHR,DSN=SMPE.REORGVS.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY WAITFOR\n NAME  WAITFOR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BADVSAM": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00&\\x01\\x06&_\\x01\\x06'\\x0f\\x10@\\x00\\x81\\x00y\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-09-22T00:00:00", "modifydate": "2006-09-27T10:40:26", "lines": 129, "newlines": 121, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = BADVSAM    (Finds VSAM components defined with obsolete */\n/*                        parameters - IMBED, REPLICAT, KEY RANGE)    */\n/*                                                                    */\n/*  PURPOSE:                                                          */\n/*  Rexx BADVSAM uses program IGGCSI00 to find VSAM Datasets defined  */\n/*  with IMBED, REPLICATE, AND KEYRANGE.                              */\n/*                                                                    */\n/*  This exec should be executed in batch mode.                       */\n/**********************************************************************/\nversion_level = \"V01.01.07\"\n\n   work_area  = '00002000'x || copies('00'x,8192-4)\n   badvsam_cnt = 0\n   call find_user_catalog_names\n   do k = 1 to user_catalogs.0\n      say 'Processing ICF Catalog' user_catalogs.k\n      call process_user_catalog\n      say ' '\n   end\nsay ;\nsay \"Total Number of VSAM Components Containing Obsolete Parameters\",\n    \"=>\" badvsam_cnt\nsay ;\nexit\nprocess_user_catalog :\n   true = 1; false = 0\n   finished = false\n   modrsnrc = substr(' ',1,4)\n   CSI_field = copies(' ',200)\n   CSI_field = overlay('**',1)                        /* csifiltk   */\n   CSI_field = overlay(user_catalogs.k,CSI_field,45)  /* csicatnm   */\n   CSI_field = overlay('C',CSI_field,133)             /* csisdtyps  */\n   CSI_field = overlay('Y',CSI_field,151)             /* csis1cat   */\n   CSI_field = overlay('0001'x,CSI_field,153)         /* csinumen   */\n   CSI_field = overlay('VSAMTYPE',CSI_field,155)      /* csifldnm 1 */\n   address linkpgm 'IGGCSI00  modrsnrc  CSI_field work_area'\n   csiusdln = c2d(substr(work_area,9,4))       /* used length */\n   csicflg  = substr(work_area,15,1)\n   if csicflg <> '00'x then\n      signal ERROR\n   csiresum = substr(CSI_field,150,1)\n   i = 65   /* skip catalog info */\n   do until finished\n      dataset_type = substr(work_area,i+1,1)\n      dataset_name = strip(substr(work_area,i+2,44),'T')\n      csieflg = substr(work_area,i,1)\n      if csieflg > 'BF'x then  /* error indicator */\n         i = i +46 + 4\n      else\n         do\n            if c2d(substr(work_area,i+46,2)) <> 8 then\n               do\n                  say 'ERROR value of i is 'i\n                  say substr(work_area,i,60)\n                  say c2x(substr(work_area,i,60))\n                  signal ERROR\n               end\n            if dataset_type <> 'C' then  /* will be D or I */\n               do\n                  VSAM_info = substr(work_area,i+46+6,1)\n                  if bitand(VSAM_info,'34'x) > '00'x then\n                     do\n                        say '      ' dataset_name\n                        badvsam_cnt = badvsam_cnt + 1\n                        if bitand(VSAM_info,'20'x) > '00'x then\n                           say '       .......Imbed'\n                        if bitand(VSAM_info,'10'x) > '00'x then\n                           say '       .......Replicate'\n                        if bitand(VSAM_info,'04'x) > '00'x then\n                           say '       .......Keyrange'\n                     end\n               end\n            i = i + 46 + 8\n         end\n      if i > csiusdln then  /* at the end of the returned info */\n         do\n            if csiresum <> 'Y' then\n               finished = true\n            else\n               do /* get the next control blocks worth */\n               address linkpgm 'IGGCSI00  modrsnrc  CSI_field work_area'\n                  csiusdln = c2d(substr(work_area,9,4))\n                  csicflg  = substr(work_area,15,1)\n                  if csicflg <> '00'x then\n                     signal ERROR\n                  csiresum = substr(CSI_field,150,1)\n                  i = 65\n               end\n         end\n   end\nreturn\nfind_user_catalog_names : procedure expose user_catalogs. work_area\n   catname = master_catalog()\n   modrsnrc = substr(' ',1,4)\n   CSI_field = copies(' ',200)\n   CSI_field = overlay('**',CSI_field,1)          /* csifiltk   */\n   CSI_field = overlay(catname,CSI_field,45)      /* csicatnm   */\n   CSI_field = overlay('U',CSI_field,133)         /* csisdtyps  */\n   CSI_field = overlay('Y',CSI_field,151)         /* csis1cat   */\n   CSI_field = overlay('0000'x,CSI_field,153)     /* csinumen   */\n   address linkpgm 'IGGCSI00  modrsnrc  CSI_field work_area'\n   csiusdln = c2d(substr(work_area,9,4))      /* used length */\n   csicflg  = substr(work_area,15,1)\n   if csicflg <> '00'x then\n      signal ERROR\n   i = 65\n   k = 0\n   do until i > csiusdln  /* this assumes all fit in the work area */\n      k = k + 1\n      user_catalogs.k = strip(substr(work_area,i+2,44),T)\n      i = i + 46 + c2d(substr(work_area,i+46,2))\n   end\n   user_catalogs.0 = k\nreturn\nmaster_catalog : procedure expose work_area\n   modrsnrc = substr(' ',1,4)\n   CSI_field = copies(' ',200)\n   CSI_field = overlay('SYS1.LINKLIB',CSI_field,1) /* csifiltk   */\n   CSI_field = overlay('A',CSI_field,133)          /* csisdtyps  */\n   CSI_field = overlay('Y',CSI_field,151)          /* csis1cat   */\n   CSI_field = overlay('0000'x,CSI_field,153)      /* csinumen   */\n   address linkpgm 'IGGCSI00  modrsnrc  CSI_field work_area'\n   csicflg  = substr(work_area,15,1)\n   if csicflg <> '00'x then\n      signal ERROR\nreturn (strip(substr(work_area,17,44),T))\nError: Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYNALC": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Y\\x01\\x06\\x02o\\x01\\x06\\x03/\\x10U\\x00\\xd6\\x00\\xd9\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2006-01-26T00:00:00", "modifydate": "2006-02-01T10:55:59", "lines": 214, "newlines": 217, "modlines": 0, "user": "TKMILLE"}, "text": "/* REXX      DYNALC                                                   */\n/**********************************************************************/\n/* MODULE  = DYNALC                                                   */\n/*                                                                    */\n/* #\u00a2# AUTHOR                   TERRY MILLER  01/27/2006              */\n/*                                                                    */\n/*  PURPOSE = Dynamic allocation of a DASD dataset to a ddname.       */\n/*                                                                    */\n/*  This exec dynamically allocates a dataset to a particular         */\n/*  DDNAME with a given disposition.  This exec does not allow        */\n/*  more than one dataset to be concatenated to a ddname for          */\n/*  allocation.                                                       */\n/*                                                                    */\n/*  If the allocation fails on the first attempt, the exec will       */\n/*  attempt to allocate the dataset up to the number of times         */\n/*  specified in the ATTEMPTS parameter.  An attempt will be made     */\n/*  at the interval specified in the INTERVAL parameter (in seconds). */\n/*  The minimum interval value is 3 seconds.  The total elapsed       */\n/*  duration time cannot exceed 90 minutes (5400 seconds).            */\n/*                                                                    */\n/*  If the allocation is successful, the variable \"rc\" is set to 0.   */\n/*  See the various return codes below.                               */\n/*                                                                    */\n/*  INPUT PARMS:                                                      */\n/*                                                                    */\n/*   DD(ddname)     = The ddname to be allocated.  If this parameter  */\n/*                    is omitted, the ddname will default to DUMMY.   */\n/*                                                                    */\n/*   DA(dsname)     = The dataset name to be allocted to the          */\n/*                    ddname.  The dataset name should be             */\n/*                    fully qualified, but does not need to be        */\n/*                    enclosed in tics.  If this parameter is         */\n/*                    omitted, the dsname will default to NULLFILE.   */\n/*                                                                    */\n/*   DISP(SHR/MOD/OLD/ = The disposition to be used for the           */\n/*        NEW)           allocation.  If this parameter is omitted,   */\n/*                       the dispostion (status) will default to SHR. */\n/*                       If the DISP(NEW) is specified, the allocation*/\n/*                       will be made with 5 primary cylinders and    */\n/*                       5 secondary cylinders.                       */\n/*                                                                    */\n/*   INTERVAL(nnn)  = The number of seconds to wait between           */\n/*                    allocation attempts (if the dataset is          */\n/*                    not allocated on the first attempt).  If this   */\n/*                    paramter is omitted, the default interval will  */\n/*                    be 3 seconds.  Also, if the INTERVAL value      */\n/*                    passed is less than 3 seconds, it will be reset */\n/*                    to 3 seconds.                                   */\n/*                                                                    */\n/*   ATTEMPTS(nnn)  = The number of attemptsn portion of the          */\n/*                    DSNAME(relgen) passed as an input parm.  If     */\n/*                    this parameter is omitted, it will default to   */\n/*                    1 attempt.  (The result of (INTERVALS*ATTEMPTS) */\n/*                    cannot exceed 5400 seconds (90 minutes).        */\n/*                                                                    */\n/*   DEBUG          = The parameter which causes an interactive trace */\n/*                    of one exec statement at a time.                */\n/*                                                                    */\n/*   OUTPUT PARMS:                                                    */\n/*                                                                    */\n/*   rc       = Return Code from the DYNALC function.  Values are:    */\n/*                                                                    */\n/*      0 - Successful call to DYNALC                                 */\n/*     10 - The dataset to be allocated is not cataloged if the       */\n/*          disposition is SHR, MOD, or OLD.  If the disposition is   */\n/*          NEW, the dataset already exists.                          */\n/*     11 - The DDNAME is invalid (more than 8 characters)            */\n/*     12 - An invalid disposition was passed                         */\n/*     13 - The INTERVAL parameter is more than 6 digits in length    */\n/*          or is not numeric                                         */\n/*     14 - The ATTEMPTS parameter is more than 6 digits in length    */\n/*          or is not numeric                                         */\n/*     15 - The elapsed time allowed for allocation exceeds the limit */\n/*          of 90 minutes (5400 seconds).                             */\n/*     16 - If the allocation failed after the specified number of    */\n/*          times (ATTEMPTS) requested.                               */\n/*                                                                    */\n/*  EXECUTION:  This exec can be called by another REXX exec or by a  */\n/*              clist, or as a stand-alone command.                   */\n/*                                                                    */\n/*  If this exec is called by a clist, the return code will be        */\n/*  contained in the &LASTCC variable.  If it is called by a REXX     */\n/*  exec, it will be contained in the rc variable.                    */\n/*                                                                    */\n/*  Example CLIST Call:                                               */\n/*    DYNALC DD(DD1) DA(MY.DSN) DISP(SHR) INTERVAL(5) ATTEMPTS(2)     */\n/*    IF &LASTCC \u00ac= 0 THEN GOTO ERRORRTN                              */\n/*                                                                    */\n/*  Example REXX Call:                                                */\n/*    \"DYNALC DD(DD1) DA(MY.DSN) DISP(SHR) INTERVAL(5) ATTEMPTS(2)\"   */\n/*    If rc \u00ac= 0 then signal ERRORRTN                                 */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.01\"\nArg parms\nTrace \"O\"\nmsg_stat = Msg(\"OFF\")\n\nGet_parms:\ndebug    = \"\"\nDo I = 1 to words(parms)\n         If word(parms,I) = \"DEB\"       then debug    = \"DEBUG\"\n    Else If word(parms,I) = \"DEBU\"      then debug    = \"DEBUG\"\n    Else If word(parms,I) = \"DEBUG\"     then debug    = \"DEBUG\"\nend\nIf debug = \"DEBUG\"  then  Trace \"?I\"\n\nparse var parms  \"DD(\" dd \")\"\nIf dd    = \"\"    then dd = \"DUMMY\"\n\nparse var parms  \"DA(\" da \")\"\nIf da    = \"\"    then da = \"NULLFILE\"\nda       = Strip(da,both,\"'\")            /* remove enclosed ticks   */\nda       = Strip(da,both,'\"')            /* remove double   ticks   */\n\nparse var parms  \"DISP(\" disp \")\"\nIf disp  = \"\"    then disp = \"SHR\"\n\nparse var parms  \"INTERVAL(\" interval \")\"\nIf interval = \"\"    then interval = 3\n\nparse var parms  \"ATTEMPTS(\" attempts \")\"\nIf attemtps = \"\"    then attempts = 1\n\nrtcd     = 0\nallocnt  = 0\nelapsed  = 0\nwaitint  = 0\n\nCheck_dsn_existence:\n/*  See if the dataset is cataloged                                  */\ncatlged  = Sysdsn(\"'\"da\"'\")\n\nIf disp   = \"NEW\"  then ,\n     If (catlged = \"OK\"  |  catlged = \"UNAVAILABLE DATASET\")   then do\n        rtcd = 10\n        Signal Endup\n     end\n     Else Nop\nElse If (catlged \u00ac= \"OK\"  &  catlged \u00ac= \"UNAVAILABLE DATASET\")  then do\n        rtcd = 10\n        Signal Endup\n     end\n\nIf length(dd) > 8  then do\n   rtcd = 11\n   Signal Endup\nend\n\nSelect\n   When disp    = \"SHR\"                         then Nop\n   When disp    = \"OLD\"                         then Nop\n   When disp    = \"MOD\"                         then Nop\n   When disp    = \"NEW\"                         then Nop\n   Otherwise  do\n      rtcd = 12\n      Signal Endup\n   end\nend\n\nIf datatype(interval,\"W\") = 0  |  length(interval) > 6  then do\n   rtcd = 13\n   Signal Endup\nend\n\nIf interval < 3 then interval = 3\n\nIf datatype(attempts,\"W\") = 0  |  length(attempts) > 6  then do\n   rtcd = 14\n   Signal Endup\nend\n\nIf attemtps < 1 then attemtps = 1\n\nelapsed    = ((attempts - 1) * interval)\n\nIf elapsed > 5400  then do   /* Total elapsed time cannot be > than */\n   rtcd = 15                 /* 5400 seconds (90 minutes)           */\n   Signal Endup\nend\n\nGo_allocate:\nallocnt = allocnt + 1\n\nIf disp  = \"NEW\"   then\n     \"ALLOC FI(\"dd\") DA('\"da\"') REUSE SP(05,05) CYLINDERS\" disp\nElse \"ALLOC FI(\"dd\") DA('\"da\"') REUSE\" disp\n\nalloccc  = rc\n\nIf alloccc = 0   then Signal Endup\nIf disp  = \"NEW\" then Signal Endup\n\nIf allocnt >= attempts then do   /* If the allocated count is > than  */\n   rtcd     = 16                 /* the # of attempts specified,      */\n   Signal Endup                  /* discontinue trying to allocate.   */\nend                              /* Set the rc for allocation failure.*/\n\nIf allocnt  = 1  then do     /* Convert the wait interval to HHMMSS   */\n    waithh  = interval % 3600\n    waitmm  = (interval - (waithh * 3600)) % 60\n    waitss  = interval  - (waithh * 3600) - (waitmm * 60)\n    waithh  = Right(waithh,2,'0')\n    waitmm  = Right(waitmm,2,'0')\n    waitss  = Right(waitss,2,'0')\n    waitint = waithh||waitmm||waitss\nend\n\n\"CALL '$XXXXXXXX.$REORGVS.LOADLIB(WAITFOR)' '\"waitint\"'\"\n\nSignal Go_allocate            /*  again to allocate the dataset.   */\n\nEndup:\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOWCALLD": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x06$\\x0f\\x01\\x06$\\x1f\\x07Y\\x00Y\\x00X\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-08-28T00:00:00", "modifydate": "2006-08-29T07:59:46", "lines": 89, "newlines": 88, "modlines": 0, "user": "TKMILLE"}, "text": "         MACRO ,\n&NAME    HOWCALLD &PARMCALL=\n.********************************************************************\n.*  Determine the caller's method of calling.  If called as a\n.*  subroutine then exit the macro.  If called as an Execute\n.*  Parameter, then branch to the Label &PARMCALL.\n.*\n.*  Reg 1 must contain the original address value that it contained\n.*  on entry to the program calling this macro. Reg 1 is not\n.*  modified by this macro.  This macro generates reentrant code.\n.*\n.*  Assumptions:\n.*    1) This macro will only be able to distinguish the calling\n.*       method if the first parameter's first two bytes are\n.*       EBCDIC characters.  If the first two characters are not\n.*       EBCDIC (i.e Binary or Packed Decimal or some other format),\n.*       this logic will not function properly and the resultant\n.*       branching will be subject to error.\n.*    2) This macro assumes that the user proper has R1 set to the\n.*       value that it contained on entry to the program issueing\n.*       this macro.  Otherwise, the resultant branching will be\n.*       subject to error.\n.*\n.*  Required Operands:\n.*    1) PARMCALL - The branch-to procedure label to branch to if\n.*                  the macro determines that the present program\n.*                  was called via an execution parameter linkage\n.*                  convention. This operand must not be omitted.\n.*\n.*  Example Call:\n.*         HOWCALLD PARMCALL=LABEL1\n.*\n.*  Registers Used:\n.*    R0       - Work register. It will be set to 0 on exit.\n.*    R1       - must have the same value as R1 on entry to the\n.*               present program. It is not altered by this macro.\n.*    R2-R14   - not used.\n.*    R15      - work register altered by this macro. It will be\n.*               set to 0 on exit.\n.*\n.********************************************************************\n.*\n         AIF   ('&PARMCALL' EQ '').MNOTE1\n.*\n         L     15,0(,1)             Load the address of the exec parm\n.*                                  exec parm or subroutine call ?\n         SR    0,0                  Zero Reg  0\n         ICM   0,B'0011',0(15)      Got Parameter or Ex parm Length ?\n         N     0,=X'FFFF7FFF'       Turn off the high order sign bit\n.*                                  since the first 2 bytes of the\n.*                                  EBCDIC parm would be a negative\n.*                                  number as viewed as a binary\n.*                                  number.  Make it a positive value.\n         CH    0,=H'1024'           If hw > 1024, then assume you are\n.*                                  called as a subroutine using\n.*                                  standard subroutine parm list.\n.*                                  If hw value is < 1024 then assume\n.*                                  that you are called using an\n.*                                  Execute parm (ll + parameters).\n         LA    0,0                  Zero Reg  0 w/o affecting cond code\n         LA    15,0                 Zero Reg 15 w/o affecting cond code\n         BNH   &PARMCALL            We have an Execute Parm Call\n.********************************************************************\n.*  I WAS WAS CALLED USING JCL-PARM STYLE LINKAGE\n.*  R1    => ADDRESS OF LINKAGE PARAMETER WHICH POINTS TO:\n.*         1 . A 2-BYTE HW LINKAGE LENGTH (LENGTH OF PARM)\n.*             Followed by the PARM DATA\n.*             EXEC PGM=XXXXXXXX,PARM=\n.*        |\n.*        ------> FullWord1 Address of the Linkage Parameter\n.*                    |\n.*                    ------->  Half-word_Len + PARM (1 - 100 bytes)\n.********************************************************************\n.*  OTHERWISE, I WAS CALLED USING STANDARD SUBROUTINE LINKAGE\n.*  R1    => ADDRESS OF PARM ADDRESS LIST WHICH POINTS TO\n.*           AN ARRAY OF PARM ADDRESSES:\n.*   |\n.*   -------> FullWord1 (PARM ADDRESS for Parameter 1)\n.*   ------->     FullWord2 (PARM ADDRESS for Parameter 2)\n.*                     |   | etc.\n.*                     |   |\n.*                     |   ---> Parameter 2\n.*                     ----> Parameter 1\n.*********************************************************************\n         MEXIT\n.MNOTE1  MNOTE 8,'PARMCALL BRANCH-TO PROCEDURE LABEL WAS OMITTED'\n         MEXIT\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSTALL": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x015\\x001\\x01\\x06\\x02\\x7f\\x01\\t\\x15/\\x115\\x03C\\x03 \\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.53", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2009-06-01T11:35:31", "lines": 835, "newlines": 800, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = INSTALL    (Tailor and Install the REORGVS facility)    */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/30/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/06/2006                         */\n/*                                                                    */\n/*  PURPOSE = This exec will input the REORGVS library and will       */\n/*            tailor the members according to the information         */\n/*            input by the user.  The exec will prompt the user       */\n/*            for the following 4 pieces of information and will      */\n/*            then copy the members into your runtime libraries.      */\n/*                                                                    */\n/*            1) Output Dataset name containing the PDS members       */\n/*               created by the RECEIVE INDS command (and is also     */\n/*               the dataset which contains this Rexx Exec).          */\n/*            2) The HLQ (High-Level Qualifier) to be used to install */\n/*               the REORGVS runtime libraries.                       */\n/*            3) The Volser to be used to allocate the runtime        */\n/*               libraries and Logfile.                               */\n/*            4) The Dataset name of the exec library concatenated    */\n/*               to ddname SYSPROC to copy the REORGVS exec into      */\n/*               for foreground invocation of exec REORGVS.           */\n/*                                                                    */\n/*            After prompting for these three pieces of information   */\n/*            it will tailor the install file members and the         */\n/*            user will then be ready to continue the install of      */\n/*            this product.                                           */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*  User Prompt Inputs:                                               */\n/*                                                                    */\n/*    Receive Dsn  -      The user will be prompted for the PDS       */\n/*                        dataset created (output) by the             */\n/*                        RECEIVE INDS command.                       */\n/*                                                                    */\n/*          HLQ    -      The user will be prompted for the HLQ for   */\n/*                        the runtime libraries.                      */\n/*                                                                    */\n/*   Sysproc Lib   -      The user will be prompted for the SYSPROC   */\n/*                        library dataset name to copy the REORGVS    */\n/*                        Rexx exec into for foreground invocation.   */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Unsuccessful execution of the exec                        */\n/*                                                                    */\n/**********************************************************************/\nArg parms\nTrace \"O\"\nmsg_stat        = Msg(\"OFF\")\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nsysid   = Left(MVSVAR(sysname),3,\" \")\nrtcd               = 0\ninput_file_count   = 0\nmiddle_quals       = \"REORGVS\"\n\nClear\nGet_receive_dataset_Name:\n\ndateg   = Substr(date(u),1,6)||Substr(date(s),1,4)\n\nSay \"***************************************************************\"||,\n\"****************\"\nSay \"*                                                                \",\n    \"            *\"\nSay \"*  \"dateg\"                 R  E  O  R  G  V  S                 \",\n    \" \"time()\"  *\"\nSay \"*  \"sysid\"                 I  N  S  T  A  L  L  A  T  I  O  N    \",\n    \"                *\"\nSay \"***************************************************************\"||,\n\"****************\"\n\nPrompt_for_RECEIVE_Dataset_Name:\n\nSay ;\nSay \"Enter the dataset name created by the RECEIVE INDS command\",\n    \"or enter a\"\nSay \"NULL ENTRY to QUIT\"\nSay ;\nPull receive_dataset\nIf receive_dataset = \"\"         | ,\n   receive_dataset = \"END\"      | ,\n   receive_dataset = \"QUIT\"                      Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nreceive_dataset = STRIP(receive_dataset,both,\"'\") /* remove ticks  */\nreceive_dataset = STRIP(receive_dataset,both,'\"') /* remove quotes */\n\nEdit_RECEIVE_Dataset_Name:\n\ncatlged  = Sysdsn(\"'\"receive_dataset\"'\")\n\nIf catlged =  \"UNAVAILABLE DATASET\"                   Then Do\n   Say ;\n   Say \"RECEIVE dataset entered is allocated to another task ...\"\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \"Free the RECEIVE dataset and Try again later ...\"\n   Signal End_Up\nEnd\n\nIf catlged <> \"OK\"                                    Then Do\n   Say ;\n   Say \"RECEIVE dataset entered is not cataloged or is invalid ...\"\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \"Re-enter the RECEIVE Dataset Name\"\n   Say ;\n   Signal Prompt_for_RECEIVE_Dataset_Name\nEnd\n\n\"ALLOC FI(INSTALL) DA('\"receive_dataset\"') SHR REUSE\"\nalloc_sysproc_rc = rc\n\"FREE  FI(INSTALL)\"\n\nIf alloc_sysproc_rc <> 0 Then Do\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \" File INSTALL could not be allocated.  Re-enter the INSTALL\",\n       \"Dataset Name\"\n   Signal Prompt_for_receive_dataset_Name\nEnd\n\nCheck_for_INSTALL_member:\n\nlistdsi   = LISTDSI(\"'\"receive_dataset\"(INSTALL)'\" DIRECTORY NORECALL)\nlistdsi_rc = rc\n\nIf listdsi_rc <> 0  Then Do\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \" Member INSTALL could not be found in RECEIVE\",\n       \"Dataset\"\n   Say \"Re-enter the RECEIVE Dataset Name\"\n   Signal Prompt_for_receive_dataset_Name\nEnd\n\nPrompt_for_Runtime_HLQ:\n\nSay ;\nSay \"Enter the High-Level Qualifer to use to install REORGVS\",\n    \"or enter a\"\nSay \"NULL ENTRY to QUIT\"\nSay ;\nPull HLQ_name\nIf HLQ_name = \"\"                | ,\n   HLQ_name = \"END\"             | ,\n   HLQ_name = \"QUIT\"                             Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nIf LENGTH(HLQ_name) >  8  Then Do\n   Say \" HLQ length must not exceed 8 characters in length\"\n   Signal Prompt_for_Runtime_HLQ\n   Say ;\nEnd\n\nPrompt_for_Runtime_Volser:\n\nSay ;\nSay \"Enter the Volser to allocate the install runtime libraries\",\n    \"or enter a\"\nSay \"NULL ENTRY to QUIT\"\nSay ;\nPull Volser_runtime\nIf Volser_runtime = \"\"          | ,\n   Volser_runtime = \"END\"       | ,\n   Volser_runtime = \"QUIT\"                       Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nIf LENGTH(Volser_runtime) > 6 Then Do\n   Say \" Volser length must not exceed 6 characters in length\"\n   Signal Prompt_for_Runtime_Volser\n   Say ;\nEnd\n\nPrompt_for_SYSPROC_dataset_Name:\n\nSay ;\nSay \"Enter the SYSPROC dataset name to use to copy the REORGVS exec\",\n    \"into or\"\nSay \"enter a NULL ENTRY to QUIT\"\nSay ;\nPull sysproc_dataset\nIf sysproc_dataset = \"\"         | ,\n   sysproc_dataset = \"END\"      | ,\n   sysproc_dataset = \"QUIT\"                      Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nsysproc_dataset = STRIP(sysproc_dataset,both,\"'\") /* remove ticks  */\nsysproc_dataset = STRIP(sysproc_dataset,both,'\"') /* remove quotes */\n\nEdit_sysproc_dataset_Name:\n\ncatlged  = Sysdsn(\"'\"sysproc_dataset\"'\")\n\nIf catlged <> \"OK\"                                    Then Do\n   Say ;\n   Say \"SYSPROC dataset entered is not cataloged or is invalid ...\"\n   Say \"SYSPROC dataset Dataset Name => '\"sysproc_dataset\"'\"\n   Say \"Re-enter the SYSPROC Dataset Name\"\n   Say ;\n   Signal Prompt_for_sysproc_dataset_Name\nEnd\n\n\"ALLOC FI($$ABC$$$)  DA('\"sysproc_dataset\"') SHR REUSE\"\nalloc_sysproc_rc = rc\n\n\"FREE  FI($$ABC$$$)\"\n\nIf alloc_sysproc_rc <> 0 Then Do\n   Say \" File SYSPROC could not be allocated.  Re-enter the SYSPROC\",\n       \"Dataset Name\"\n   Signal Prompt_for_SYSPROC_dataset_Name\nEnd\n\nAllocate_Runtime_Libraries:\n\nhigh_quals    = HLQ_name||\".\"||middle_quals\n\nexec_lib      = high_quals||\".EXEC\"\ncntl_lib      = high_quals||\".CNTL\"\nsource_lib    = high_quals||\".SOURCE\"\nmaclib        = high_quals||\".MACLIB\"\nloadlib       = high_quals||\".LOADLIB\"\nlogfile       = high_quals||\".LOGFILE\"\npanel_lib     = high_quals||\".PANELS\"\nmsg_lib       = high_quals||\".MSGS\"\n\n\"DELETE '\"||exec_lib||\"'       PURGE\"\n\"DELETE '\"||cntl_lib||\"'       PURGE\"\n\"DELETE '\"||source_lib||\"'     PURGE\"\n\"DELETE '\"||maclib||\"'         PURGE\"\n\"DELETE '\"||loadlib||\"'        PURGE\"\n\"DELETE '\"||logfile||\"'        PURGE\"\n\"DELETE '\"||panel_lib||\"'      PURGE\"\n\"DELETE '\"||msg_lib||\"'        PURGE\"\n\n\"ALLOC DA('\"||exec_lib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(05)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_exec     = rc\nIf alloc_exec     <> 0 Then Do\n   Say \" Error allocating space for the Rexx EXEC library\"\n   Say \" Rexx EXEC library Dataset Name => \" exec_lib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||cntl_lib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_cntl     = rc\nIf alloc_cntl     <> 0 Then Do\n   Say \" Error allocating space for the CNTL library\"\n   Say \" CNTL library Dataset Name => \" cntl_lib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||maclib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_maclib   = rc\nIf alloc_maclib   <> 0 Then Do\n   Say \" Error allocating space for the MACLIB library\"\n   Say \" MACLIB library Dataset Name => \" maclib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||source_lib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_source   = rc\nIf alloc_source   <> 0 Then Do\n   Say \" Error allocating space for the SOURCE library\"\n   Say \" SOURCE library Dataset Name => \" source_lib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||loadlib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(U) LRECL(0) BLKSIZE(32760)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_loadlib  = rc\nIf alloc_loadlib  <> 0 Then Do\n   Say \" Error allocating space for the LOAD library\"\n   Say \" LOAD library Dataset Name => \" loadlib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||logfile||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PS) TRACKS SPACE(05,05)\",\n      \"RECFM(F B) LRECL(150) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_logfile  = rc\nIf alloc_logfile  <> 0 Then Do\n   Say \" Error allocating space for the LOGFILE\"\n   Say \" LOGFILE library Dataset Name => \" logfile\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||panel_lib||\"')      NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_panel    = rc\nIf alloc_panel    <> 0 Then Do\n   Say \" Error allocating space for the ISPF PANEL library\"\n   Say \" ISPF PANEL library Dataset Name => \" panel_lib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||msg_lib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_msg      = rc\nIf alloc_msg      <> 0 Then Do\n   Say \" Error allocating space for the ISPF MSG library\"\n   Say \" ISPF MSG library Dataset Name => \" msg_lib\n   Signal End_Up\n   Say ;\nEnd\n\nAssign_Input_Output_Files:\n\ninput_file_count = input_file_count + 1\n\n\"EXECIO 0 DISKR INPUT    (FINIS\"\n\"EXECIO 0 DISKW OUTPUT   (FINIS\"\n\"FREE FI(INPUT,OUTPUT)\"\n\nSelect\n   When input_file_count  =   1                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n        Signal Allocate_Input_Output_Files\n   End\n   When input_file_count  =   2                    Then Do\n        input_dataset = receive_dataset||\"(REORGVSX)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVSX)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n        Signal Allocate_Input_Output_Files\n   End\n   When input_file_count  =   3                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS1)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS1)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   4                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS2)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS2)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   5                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS3)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS3)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   6                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS4)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS4)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   7                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS5)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS5)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   8                    Then Do\n        input_dataset = receive_dataset||\"(REORGVS6)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(REORGVS6)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   9                    Then Do\n        input_dataset = receive_dataset||\"(DYNALC)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(DYNALC)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   10                   Then Do\n        input_dataset = receive_dataset||\"(BADVSAM)\"\n        output_dataset = HLQ_name||\".REORGVS.EXEC(BADVSAM)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   11                   Then Do\n        input_dataset = receive_dataset||\"(REORGVSS)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(REORGVSS)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   12                   Then Do\n        input_dataset = receive_dataset||\"(INSTALL2)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(INSTALL2)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   13                   Then Do\n        input_dataset = receive_dataset||\"(INSTALL3)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(INSTALL3)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   14                   Then Do\n        input_dataset = receive_dataset||\"(INSTALL4)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(INSTALL4)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   15                   Then Do\n        input_dataset = receive_dataset||\"(INSTALL5)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(INSTALL5)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   16                   Then Do\n        input_dataset = receive_dataset||\"(IVPTEST)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(IVPTEST)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   17                   Then Do\n        input_dataset = receive_dataset||\"(REORGVSJ)\"\n        output_dataset = HLQ_name||\".REORGVS.CNTL(REORGVSJ)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   18                   Then Do\n        input_dataset = receive_dataset||\"(ABENDER)\"\n        output_dataset = HLQ_name||\".REORGVS.SOURCE(ABENDER)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the SOURCE\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   19                   Then Do\n        input_dataset = receive_dataset||\"(WAITFOR)\"\n        output_dataset = HLQ_name||\".REORGVS.SOURCE(WAITFOR)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the SOURCE\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   20                   Then Do\n        input_dataset = receive_dataset||\"(HOWCALLD)\"\n        output_dataset = HLQ_name||\".REORGVS.MACLIB(HOWCALLD)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the MACLIB\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   21                   Then Do\n        input_dataset = receive_dataset||\"(REORGPN1)\"\n        output_dataset = HLQ_name||\".REORGVS.PANELS(REORGPN1)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the PANELS\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   22                   Then Do\n        input_dataset = receive_dataset||\"(REORGPN2)\"\n        output_dataset = HLQ_name||\".REORGVS.PANELS(REORGPN2)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the PANELS\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   23                   Then Do\n        input_dataset = receive_dataset||\"(REOHGPN1)\"\n        output_dataset = HLQ_name||\".REORGVS.PANELS(REOHGPN1)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the PANELS\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   24                   Then Do\n        input_dataset = receive_dataset||\"(REOM00)\"\n        output_dataset = HLQ_name||\".REORGVS.MSGS(REOM00)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the MSGS\",\n               \"runtime library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   Otherwise Do\n        input_file_count  = input_file_count - 1\n        Signal End_Up\n   End\nEnd\n\nAllocate_Input_Output_Files:\n\n\"ALLOC FI(INPUT)   DA('\"input_dataset\"') SHR REUSE\"\nalloc_input_rc = rc\n\nIf alloc_input_rc <> 0 Then Do\n   Say \" RECEIVE INDS File could not be allocated   ...\"\n   Say \" RECEIVE INDS File => '\"input_dataset\"'\"\n   Signal End_Up\nEnd\n\n\"ALLOC FI(OUTPUT)  DA('\"output_dataset\"') SHR REUSE\"\nalloc_output_rc = rc\n\nIf alloc_output_rc <> 0 Then Do\n   Say \" RUNTIME File could not be allocated   ...\"\n   Say \" RUNTIME File => '\"output_dataset\"'\"\n   Signal End_Up\nEnd\n\nSay ;\nSay \"Reading Input Receive Dataset   => '\"||input_dataset||\"'\"\nSay \"Creating Output Runtime Dataset => '\"||output_dataset||\"'\"\nSay ;\n\ninput_count = 0\n\nRead_Input_dataset_Loop:\n\ninput_count = input_count + 1\n\n\"EXECIO 1 DISKR INPUT    (STEM input. \"\nexecio_rc    = rc\nIf execio_rc = 2   Then ,        /* On end of file - Swap Files    */\n   Signal Assign_Input_Output_Files\nIf execio_rc <> 0  Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\"\n       \"INPUT !!!\"\n   Say \"File INPUT was not properly allocated or is invalid\"\n   Say \"Input File =>\" input_dataset\n   Say \"Input File Input count is \" input_count\n   Say \"EXECIO Return Code is \"execio_rc\" !!!\"\n   Say \"Exec INSTALL is Terminated Prematurely      ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nlen_input = LENGTH(input.1)\n\np1  = POS(\"$XXXXXXXX.$\",input.1)\nIf p1  > 0                                         Then Do\n   part_1   = \"\"\n   If p1 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p1 - 1)\n   End\n   part_2   = HLQ_name||\".\"\n   part_3   = SUBSTR(input.1,p1 + 11,len_input - p1 + 11)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\np2  = POS(\"XXXXXXXX.\",input.1)\nIf p2  > 0                                         Then Do\n   part_1   = \"\"\n   If p2 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p2 - 1)\n   End\n   part_2   = HLQ_name||\".\"\n   part_3   = SUBSTR(input.1,p2 + 9,len_input - p2 + 9)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\np3  = POS(\"$MY.SYSPROC.LIB$\",input.1)\nIf p3  > 0                                         Then Do\n   part_1   = \"\"\n   If p3 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p3 - 1)\n   End\n   part_2   = sysproc_dataset\n   part_3   = SUBSTR(input.1,p3 + 16,len_input - p3 + 16)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\np4  = POS(\"$MY.RECEIVE.LIB$\",input.1)\nIf p4  > 0                                         Then Do\n   part_1   = \"\"\n   If p4 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p4 - 1)\n   End\n   part_2   = receive_dataset\n   part_3   = SUBSTR(input.1,p4 + 16,len_input - p4 + 16)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\noutput.1 = input.1\n\nWrite_Output_Record:\n\n\"EXECIO 1 DISKW OUTPUT   (STEM output. \"\nexecio_rc    = rc\nIf execio_rc <> 0  Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\"\n       \"OUTPUT  !!!\"\n   Say \"File OUTPUT was not properly allocated or is invalid\"\n   Say \"or an I/O error was encountered\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execio_rc\" !!!\"\n   Say \"Exec INSTALL is Terminated Prematurely      ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nSignal Read_Input_dataset_Loop\n\nEnd_Up:\n\n\"EXECIO 0 DISKR INPUT    (FINIS\"\n\"EXECIO 0 DISKW OUTPUT   (FINIS\"\n\"FREE FI(INPUT,OUTPUT)\"\n\"FREE DA('\"||exec_lib||\"')\"\n\"FREE DA('\"||cntl_lib||\"')\"\n\"FREE DA('\"||source_lib||\"')\"\n\"FREE DA('\"||maclib||\"')\"\n\"FREE DA('\"||loadlib||\"')\"\n\"FREE DA('\"||logfile||\"')\"\n\nSay ;\nSay \"Number of Runtime Files Output =>\" input_file_count\nSay ;\nSay \"INSTALL exec return code is    =>\" rtcd\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL2": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x06\\x01\\x06\\x02\\x7f\\x01\\x06$\\x9f\\x158\\x007\\x001\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2006-09-06T15:38:06", "lines": 55, "newlines": 49, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL2 JOB ' ASSEMBLE THE TWO SOURCE PROGRAMS              ',\n//     TIME=(2,00),REGION=0M\n//*\n//* ASSEMBLE AND LINK THE \"ABENDER\" AND \"WAITFOR\" PROGRAMS\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//ASMABEND EXEC PGM=IEV90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.MACLIB\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.SOURCE(ABENDER)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASMABEND),\n//         PARM='LIST,LET,MAP,XREF'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//SYSLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY ABENDER\n NAME  ABENDER(R)\n/*\n//ASMAWAIT EXEC PGM=IEV90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.MACLIB\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.SOURCE(WAITFOR)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASMAWAIT),\n//         PARM='LIST,LET,MAP,XREF'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//SYSLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY WAITFOR\n NAME  WAITFOR(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL3": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x18\\x01\\x06\\x02\\x7f\\x01\\t\\x15/\\x11$\\x00\\x13\\x00\\r\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2009-06-01T11:24:18", "lines": 19, "newlines": 13, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL3 JOB ' COPY THE REORGVS EXEC TO YOUR SYSPROC LIBRARY ',\n//     TIME=(2,00),REGION=0M\n//*\n//* COPY THE \"REORGVS\" EXEC AND THE \"REORGVSX\" EXEC INTO YOUR\n//* SYSPROC LIBARARY OF CHOICE.\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//COPYEXEC    EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN1         DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//OUT1        DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT1,INDD=((IN1,R))\n       S M=REORGVS\n       S M=REORGVSX\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL4": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00&\\x01\\x06\\x03/\\x01\\t\\x15/\\x11$\\x00\\x15\\x00\\x17\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2006-02-01T00:00:00", "modifydate": "2009-06-01T11:24:26", "lines": 21, "newlines": 23, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL4 JOB ' INSTALL THE SYSHELP ISPF HELP PANEL           ',\n//     TIME=(2,00),REGION=0M\n//*\n//* COPY THE \"REORGVS\" HELP MEMBER TO YOUR SYSHELP LIBRARY FOR\n//* FOREGROUND HELP INFORMATION.\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//* CHANGE THE SYSHELP LIBRARY NAME TO YOUR FACILITY'S SYSHELP\n//* LIBRARY DATASET NAME.\n//*\n//COPYHELP    EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN1         DD DISP=SHR,DSN=$MY.RECEIVE.LIB$\n//OUT1        DD DISP=SHR,DSN=OUR.SYSHELP.LIBRARY  <= CHANGE THIS LIB\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT1,INDD=((IN1,R))\n       S M=((REORGVSH,REORGVS))\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL5": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x01\\t\\x14o\\x01\\t\\x15/\\x11B\\x00!\\x00\\x15\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-05-26T00:00:00", "modifydate": "2009-06-01T11:42:28", "lines": 33, "newlines": 21, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL5 JOB ' INSTALL THE ISPF PANELS AND MSG MEMBER        ',\n//     TIME=(2,00),REGION=0M\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//* CHANGE THE //OUT1 LIBRARY NAME TO YOUR FACILITY'S ISPPLIB\n//* LIBRARY DATASET NAME OF CHOICE.\n//*\n//* CHANGE THE //OUT2 LIBRARY NAME TO YOUR FACILITY'S ISPMLIB\n//* LIBRARY DATASET NAME OF CHOICE.\n//*\n//COPYPANL    EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN1         DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.PANELS\n//OUT1        DD DISP=SHR,DSN=OUR.ISPPLIB.LIBRARY  <= CHANGE THIS LIB\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT1,INDD=((IN1,R))\n       S M=REORGPN1\n       S M=REOHGPN1\n       S M=REORGPN2\n/*\n//COPYMSG     EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN2         DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.MSGS\n//OUT2        DD DISP=SHR,DSN=OUR.ISPMLIB.LIBRARY  <= CHANGE THIS LIB\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT2,INDD=((IN2,R))\n       S M=REOM00\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IVPTEST": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x001\\x01\\x041\\x7f\\x01\\x06\\x04\\x7f\\x13E\\x00\\x1f\\x00\\x03\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2004-11-12T00:00:00", "modifydate": "2006-02-16T13:45:31", "lines": 31, "newlines": 3, "modlines": 0, "user": "TKMILLE"}, "text": "//IVPTEST  JOB ' REORGVS IVPTEST                               ',\n//     TIME=(2,00),REGION=0M\n//*******************************************************************\n//* POINT TO THE SYSPROC LIBRARY WHICH CONTAINS THE \"REORGVS\" REXX\n//*    EXEC.  THIS FUNCTION CAN ALSO BE CALLED FROM THE FOREGROUND.\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//* EXAMPLE CALLS:\n//*\n//*  %REORGVS MY.VSAM.DATASET\n//*  %REORGVS MY.VSAM.DATASET HLQ(SYS5)\n//*  %REORGVS MY.VSAM.DATASET HLQ(SYS5) PRI(+05)\n//*  %REORGVS MY.VSAM.DATASET PRI(+10)\n//*  %REORGVS MY.VSAM.DATASET PRI(+10)  SEC(+10)\n//*  %REORGVS MY.VSAM.DATASET PRI(-50)  SEC(-50)\n//*  %REORGVS MY.VSAM.DATASET TEST\n//*  %REORGVS MY.VSAM.DATASET PRI(+10)  TEST\n//*\n//*******************************************************************\n//REORGVS    EXEC PGM=IKJEFT01,DYNAMNBR=30\n//* SYSPROC    DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//SYSPROC    DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT   DD SYSOUT=*\n//SYSTSIN    DD *\n %REORGVS  MY.VSAM.CLUSTER.TO.BE.REORGED     <= CHANGE THIS DSNAME\n/*\n//ABENDER   EXEC PGM=ABENDER,PARM='1024',\n//          COND=(0,EQ)\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REOHGPN1": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x18\\x01\\t\\x14o\\x01\\t\\x14o\\x18\\x16\\x004\\x005\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2009-05-26T00:00:00", "modifydate": "2009-05-26T18:16:18", "lines": 52, "newlines": 53, "modlines": 0, "user": "TKMILLE"}, "text": ")ATTR DEFAULT(\u00a6`})\n/**********************************************************************/\n/* PANEL        - REOHGPN1\n/* AUTHOR       - Terry Miller\n/* PURPOSE      - Help Screen #1 for Panel REORGPN1\n/* INVOKED BY   - REORGPN2 ISPF Panel\n/* CREATED      - 05/26/2009   TKMILLE\n/* LAST UPDATED - 05/26/2009   TKMILLE\n/**********************************************************************/\n    ~ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(WHITE)\n    % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(BLUE)\n    ! TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(GREEN)\n    @ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(YELLOW)\n    $ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(RED)\n    \u00ac TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(TURQ)\n    \u00a2 TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(GREEN)\n    } TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(BLUE)\n)BODY\n%-----------------  Vsam Cluster Reorg Help Screen  -------------  REOHGPN1  --~\n%COMMAND  ===>_ZCMD                                           %SCROLL ===>_ZSCR~\n~                                                                              ~\n~ This panel allows the user to specify a Vsam Cluster        ~TIME -%&TIME\n~ to be reorganized. The reorg job is executed in batch mode. ~DATE -%&DATE\n~                                                           JULDATE -%&ZJDATE\n~ Dataset Name:  Enter a Vsam Cluster Name to be reorged.     ~USER -%&ZUSER\n~ DO NOT enclose the name with tics or quotes.\n~\n~ Percentage Change in Primary Allocation.  The user may specify a numeric\n~ value between 0 and 100 to increase or decrease the primary space\n~ allocation for the data component for the cluster name. Default is +0.\n~   Specify:   +nnn   or  -nnn    (nnn is 1 to 3 numeric digits)\n~\n~ Percentage Change in Secondary Allocation.  Same edit rules as the primary\n~ allocation percentage change field above. Default is +0.\n~\n~ HLQ - High-Level Qualifier for the work files.  Enter a 1 to 8 character\n~ hlq for the work files used.  The default is the Userid field.\n~\n~ Test - Y or N (Yes or No).  The value of 'Y' simulates a reorg in test\n~ mode.  The default is 'N' (execute the reorg).\n~\n~     Press%END or RETURN~to EXIT\n)INIT\n &ZSCR     = 'CSR'\n &ZCONT    = REOHGPN1\n &ZHTOP    = REOHGPN1\n &ZUP      = REOHGPN1\n)PROC\n &ZCONT    = REOHGPN1\n &ZHTOP    = REOHGPN1\n &ZUP      = REOHGPN1\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REOM00": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x03\\x01\\t\\x14_\\x01\\t\\x14\\x7f\\tP\\x00\\x16\\x00\\x16\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2009-05-25T00:00:00", "modifydate": "2009-05-27T09:50:03", "lines": 22, "newlines": 22, "modlines": 0, "user": "TKMILLE"}, "text": "REOM000 '                   ' .ALARM=YES\n'                                                                      '\nREOM001 'Clustername Invalid' .ALARM=YES\n'VSAM Cluster Name is Invalid                                          '\nREOM002 'Primary % Invalid  ' .ALARM=YES\n'Percentage of Increase in Primary Space allocation is Invalid         '\nREOM003 'Secondary % Invalid' .ALARM=YES\n'Percentage of Increase in Secondary Space allocation is Invalid       '\nREOM004 'HLQ is Invalid     ' .ALARM=YES\n'Invalid HLQ Value Specified                                           '\nREOM005 'Test is Invalid    ' .ALARM=YES\n'Invalid Test Value Specified                                          '\nREOM006 '                   ' .ALARM=YES\n'                                                                      '\nREOM007 '                   ' .ALARM=YES\n'                                                                      '\nREOM008 '                   ' .ALARM=YES\n'                                                                      '\nREOM009 '                   ' .ALARM=YES\n'                                                                      '\nREOM010 '                   ' .ALARM=YES\n'                                                                      '\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REORGPN1": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x008\\x01\\t\\x14_\\x01\\t\\x14\\x7f\\x11\\x06\\x006\\x00B\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2009-05-25T00:00:00", "modifydate": "2009-05-27T11:06:38", "lines": 54, "newlines": 66, "modlines": 0, "user": "TKMILLE"}, "text": ")ATTR DEFAULT(\u00a6`})\n/**********************************************************************/\n/* PANEL        - REORGPN1\n/* AUTHOR       - Terry Miller\n/* PURPOSE      - Display VSAM Reorg Panel #1\n/* INVOKED BY   - REORGVSX Rexx Exec\n/* CREATED      - 05/26/2009   TKMILLE\n/* LAST UPDATED - 05/27/2009   TKMILLE\n/**********************************************************************/\n  { TYPE(INPUT)  INTENS(HIGH) PAD('_')  CAPS(ON)  COLOR(RED)\n  ~ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(BLUE)\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(WHITE)\n  \u00ac TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(GREEN)\n  \\ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(YELLOW)\n  \u00a2 TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)  CAPS(OFF) COLOR(YELLOW)\n  } TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(GREEN)\n  @ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(TURQ)\n  $ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(WHITE)\n  _ TYPE(INPUT)  INTENS(HIGH)           CAPS(ON)  COLOR(RED)\n  | TYPE(INPUT)  INTENS(HIGH)           CAPS(ON)  COLOR(YELLOW)\n)BODY\n%-------------------  Reorganize a Vsam Dataset  ----------------  REORGPN1  --~\n%COMMAND  ===>_ZCMD                                           %SCROLL ===>_ZSCR~\n@PMSG                                                                          ~\n~                                                             ~TIME -%&TIME\n%Enter the Vsam Cluster Name to be Reorganized%               ~DATE -%&DATE\n%===>|Z                                           ~         JULDATE -%&ZJDATE\n~                                                             ~USER -%&ZUSER\n%Enter the percentage change in the primary space allocation%\n%===>|Z   ~  (+/- nnn    for example: +010  or -05)\n~\n%Enter the percentage change in the secondary space allocation%\n%===>|Z   ~  (+/- nnn    for example: +010  or -05)\n~\n%Enter the HLQ (High-Level Qualifier) to use for the work files%\n%===>|Z       ~\n~\n%Is this a Test Simulation? (\"Y\" or \"N\". \"Y\" will only simulate a reorg).\n%===>|Z~\n~\n%The Submitter must have\\RACF ALTER access for the RACF profile%protecting the\n\\Vsam Dataset Name.%\n~\n~     Press%ENTER~to Proceed\n~     Press%HELP~for Help Screen         Press%END or RETURN~to EXIT\n)INIT\n &ZSCR     = 'CSR'\n .HELP     = REOHGPN1\n &ZHTOP    = REOHGPN1\n .ZVARS    = '(CLUSTER PRIMARY SECONDY HLQ TEST)'\n)REINIT\n)PROC\n VER (&CLUSTER,NB,DSNAME,MSG=REOM001)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGPN2": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x007\\x01\\t\\x14o\\x01\\t\\x14o\\x18\\x16\\x003\\x006\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2009-05-26T00:00:00", "modifydate": "2009-05-26T18:16:37", "lines": 51, "newlines": 54, "modlines": 0, "user": "TKMILLE"}, "text": ")ATTR DEFAULT(\u00a6`})\n/**********************************************************************/\n/* PANEL        - REORGPN2\n/* AUTHOR       - Terry Miller\n/* PURPOSE      - Display VSAM Reorg Results/Messages Panel\n/* INVOKED BY   - REORGVSX Rexx Exec\n/* CREATED      - 05/26/2009   TKMILLE\n/* LAST UPDATED - 05/26/2009   TKMILLE\n/**********************************************************************/\n  { TYPE(INPUT)  INTENS(HIGH) PAD('_')  CAPS(ON)  COLOR(RED)\n  ~ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(BLUE)\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(WHITE)\n  \u00ac TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(GREEN)\n  \\ TYPE(TEXT)   INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(YELLOW)\n  \u00a2 TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)  CAPS(OFF) COLOR(YELLOW)\n  } TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(GREEN)\n  @ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(TURQ)\n  $ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)  CAPS(OFF) COLOR(WHITE)\n  _ TYPE(INPUT)  INTENS(HIGH)           CAPS(ON)  COLOR(RED)\n)BODY\n%-------------------  Reorganization Results     ----------------  REORGPN2  --~\n%COMMAND  ===>_ZCMD                                           %SCROLL ===>_ZSCR~\n$line1                                                                         ~\n$line2                                                                         ~\n$line3                                                                         ~\n$line4                                                                         ~\n$line5                                                                         ~\n$line6                                                                         ~\n$line7                                                                         ~\n$line8                                                                         ~\n$line9                                                                         ~\n$line10                                                                        ~\n$line11                                                                        ~\n$line12                                                                        ~\n$line13                                                                        ~\n$line14                                                                        ~\n$line15                                                                        ~\n$line16                                                                        ~\n$line17                                                                        ~\n$line18                                                                        ~\n$line19                                                                        ~\n$line20                                                                        ~\n~\n~     Press%ENTER~to Reorg Another File    Press%END or RETURN~to EXIT\n)INIT\n&ZSCR     = 'CSR'\n.HELP     = REORGPN2\n&ZHTOP    = REORGPN2\n.CURSOR   = 'ZCMD'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REORGVS": {"ttr": 1553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x00\\t\\x01\\x06\\x01o\\x01\\t\\x14\\x7f\\x11\\x03\\x00\\xca\\x01\\x18\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "2006-01-16T00:00:00", "modifydate": "2009-05-27T11:03:09", "lines": 202, "newlines": 280, "modlines": 0, "user": "TKMILLE"}, "text": "/* REXX  REORGVS                                                      */\n/**********************************************************************/\n/*  MODULE  = REORGVS    (Reorg a VSAM Cluster)                       */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 11/10/2005                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 05/26/2009                         */\n/*                                                                    */\n/*  PURPOSE = This exec wil call exec REORGVSX to present a menu to   */\n/*            the user to reorganize VSAM datasets.                   */\n/*                                                                    */\n/*  ENVIRON = It will invoke itself a second time if it is not called */\n/*            from the SPF environment.                               */\n/*                                                                    */\n/*  PARMS:  DEBUG  = Turns on the interactive REXX debugging option.  */\n/*                                                                    */\n/*  REORGVS Function:                                                 */\n/*                                                                    */\n/*      This exec will call exec REORGVSX to submit a job to          */\n/*      reorganize a VSAM cluster.                                    */\n/*      It will input the cluster dataset name and optionally         */\n/*      the high-level qualifier for the work files.                  */\n/*      It will generate a random number between 1 and 999999         */\n/*      to use in the low-level qualifier for uniqueness.             */\n/*                                                                    */\n/*      If REORGVS is called in the foreground, it will invoke        */\n/*      REORGVSX which will present an ISPF panel to the user         */\n/*      to obtain the parms.  If REORGVS is called in the             */\n/*      background, the user must supply the parms as defined         */\n/*      below.                                                        */\n/*                                                                    */\n/*      REORGVSX will input a stream of jcl to tailor and to          */\n/*      submit in the background.  It will substitute the             */\n/*      variables that the invoker provides to this exec              */\n/*      before submitting the job.  The jcl stream will be            */\n/*      saved in a dataset (&HLQ.$REORGVS.SUBMIT.JCL.FS&FSEQ).        */\n/*                                                                    */\n/*      These skeleton variables will be substited:                   */\n/*        &CLUSTER  (User provided to this exec)                      */\n/*        &HLQ      (User provided to this exec)                      */\n/*        &FSEQ     (Not user provided - this is a random             */\n/*                   number generated within this exec).              */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*          CLUSTERNAME = The dsname of the VSAM Cluster to be        */\n/*                        reorged.  This must be the first parameter. */\n/*                        It is positional in nature and cannot be    */\n/*                        omitted.                                    */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*        HLQ(hlq) = The name of the high-level qualifier to use      */\n/*                   for the work datasets.  The default hlq will     */\n/*                   be the invoker's userid.                         */\n/*                                                                    */\n/*       PRI(+NNN) = This parameter increases or decreases the        */\n/*    or PRI(-NNN)   primary space allocation for the cluster         */\n/*                   (relative to what it was before).                */\n/*                   The syntax is: +nnn or -nnn.  nnn must be        */\n/*                   numeric value between 1 and 999 and must be      */\n/*                   preceded with either a \"+\" or \"-\". nnn           */\n/*                   represents a percentage value of increase or     */\n/*                   decrease against the previous primary            */\n/*                   allocation value.                                */\n/*                                                                    */\n/*       SEC(+NNN) = This parameter increases or decreases the        */\n/*    or SEC(-NNN)   secondary space allocation for the cluster       */\n/*                   (relative to what it was before).                */\n/*                   The syntax is: +nnn or -nnn.  nnn must be        */\n/*                   numeric value between 1 and 999 and must be      */\n/*                   preceded with either a \"+\" or \"-\". nnn           */\n/*                   represents a percentage value of increase or     */\n/*                   decrease against the previous secondary          */\n/*                   allocation value.                                */\n/*                                                                    */\n/*          TEST   = This parameter will cause a test simulation of   */\n/*                   the reorganization.  It will not update the      */\n/*                   cluster or affect it.  It will only generate     */\n/*                   the work files which can be inspected.  This     */\n/*                   is considered a TEST pass execution. Some of     */\n/*                   the jcl skeleton steps will not be executed.     */\n/*                                                                    */\n/*          DEBUG  = The parameter which displays the statements as   */\n/*                   they are executed (invokes TRACE I)              */\n/*                                                                    */\n/*  Example Background Calls:                                         */\n/*                                                                    */\n/*  1) REORGVS my.vsam.dataset)                                       */\n/*  2) REORGVS my.vsam.dataset) HLQ(SYS5)                             */\n/*  3) REORGVS my.vsam.dataset) HLQ(SYS5) PRI(+05)                    */\n/*  4) REORGVS my.vsam.dataset) PRI(+10)                              */\n/*  5) REORGVS my.vsam.dataset) PRI(+10) SEC(+10)                     */\n/*  6) REORGVS my.vsam.dataset) PRI(-50) SEC(-50)                     */\n/*  7) REORGVS my.vsam.dataset) TEST                                  */\n/*  8) REORGVS my.vsam.dataset) PRI(+10) SEC(+10) TEST                */\n/*                                                                    */\n/*  Example Background Call Explanations:                             */\n/*                                                                    */\n/*  1) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*  2) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and create work datasets with the HLQ of 'SYS5'.            */\n/*  3) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and create work datasets with the HLQ of 'SYS5'             */\n/*        and increase the data component's primary                   */\n/*        allocation units value by 5%                                */\n/*  4) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and increase the data component's primary                   */\n/*        allocation units value by 10%                               */\n/*  5) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and increase the data component's primary                   */\n/*        allocation units value by 10% and increase                  */\n/*        data component's secondary allocation units                 */\n/*        value by 10%. (Note, if the secondary                       */\n/*        allocation unit is presently zero, it will                  */\n/*        remain 0 after the adjustment).                             */\n/*  6) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and decrease the data component's primary                   */\n/*        allocation units value by 50% and decrease                  */\n/*        data component's secondary allocation units                 */\n/*        value by 50%. (Note, if the secondary                       */\n/*        allocation unit is presently zero, it will                  */\n/*        remain 0 after the adjustment).                             */\n/*  7) Test the Reorganization (Simulation pass) of the Vsam          */\n/*        Cluster named 'MY.VSAM.DATASET'.  Does not affect the       */\n/*        Cluster on a TEST pass simulation.                          */\n/*  8) Test the Reorganization (Simulation pass) of the Vsam          */\n/*        Cluster named 'MY.VSAM.DATASET' and of increasing the       */\n/*        primary allocation units by +10% and of increasing the      */\n/*        secondary allocation units by +10%.                         */\n/*        Does not affect the Cluster on a TEST pass simulation.      */\n/*                                                                    */\n/*  Installation Tailoring:                                           */\n/*        Do a FIND on \"SYSPROC\".  Change this dataset name to        */\n/*        the SYSPROC dataset name for your installation.             */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful   execution of this exec                       */\n/*   12   - Unsuccessful execution of this exec                       */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.02.01\"\nArg parms\nTrace \"O\"\nrtcd     = 0\nmsg_stat = Msg(\"OFF\")\nenvirnmt = Sysvar(\"sysenv\")\nnesting  = Sysvar(\"sysnest\")\nsysicmd  = Sysvar(\"sysicmd\")\nsyspcmd  = Sysvar(\"syspcmd\")\nsysscmd  = Sysvar(\"sysscmd\")\nsysid    = Left(MVSVAR(sysname),3,\" \")\nAddress \"TSO\"\nsysproc_lib  = \"SYS1.MVSCMD\"     <= CHANGE TO YOUR SYSPROC DSNAME\n\nGet_parms:\n\ndebug    = \"\"\nDo I = 1 to words(parms)\n         If word(parms,I) = \"D\"         then debug    = \"DEBUG\"\n    Else If word(parms,I) = \"DE\"        then debug    = \"DEBUG\"\n    Else If word(parms,I) = \"DEB\"       then debug    = \"DEBUG\"\n    Else If word(parms,I) = \"DEBU\"      then debug    = \"DEBUG\"\n    Else If word(parms,I) = \"DEBUG\"     then debug    = \"DEBUG\"\nend\nIf debug = \"DEBUG\"  then  Trace \"I\"\n\nIf envirnmt = \"BACK\" Then Do\n  \"%REORGVSX\" parms\n  Signal End_Up\nEnd\n\nCheck_for_ISPF_environment:\n\nIf Sysvar(\"SYSISPF\") <> \"ACTIVE\"  Then Do\n/*  Make a recursive call to this exec to invoke the ISPF environment */\n   \"ISPF CMD(%REORGVS\" parms \")\"\n   Return 0\nEnd\n\nAllocate_sysproc:\n\n\"ALLOC FI(SYSPROC) DA('\"sysproc_lib\"' ***) SHR REUSE\"\nsysproc_allocation = tsopext\n\n/* If my new lib is already in the concatenation, back it out  */\nIf POS(\"'\"sysproc_lib\"'\",sysproc_allocation) > 0 Then\n    \"ALLOC FI(SYSPROC) DA(\"sysproc_allocation\") SHR REUSE\"\n\nCall_REORGVS_Application:\n\nAddress \"ISPEXEC\"\n\"SELECT CMD(%REORGVSX\" parms \") NEWAPPL(REOR) PASSLIB\"\n\nAddress \"TSO\"\nIf sysproc_allocation <> \"\" Then\n     \"ALLOC FI(SYSPROC) DA(\"sysproc_allocation\") SHR REUSE\"\nElse \"FREE FI(SYSPROC)\"\n\nEnd_Up:\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVSH": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x14\\x00\\x92\\x02\\x9f\\x01\\t\\x15?\\x112\\x00\\xa7\\x00^\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1992-01-29T00:00:00", "modifydate": "2009-06-02T11:32:14", "lines": 167, "newlines": 94, "modlines": 0, "user": "TKMILLE"}, "text": ")F FUNCTION -\n\n REORGVS is a REXX facility which allows a user to reorganize VSAM\n clusters without having to know the specifics of the allocation\n parameters and components associated with the cluster.\n\n It was written to reallocate and reorg VSAM clusters which were\n defined with the \"IMBED\" and \"REPLICAT\" parameters which are no\n longer supported by Z/OS 1.5 and higher.  It was written with the\n express purpose of converting these VSAM clusters, but it is also\n very useful in reorganizing clusters.  The user does not need to\n know the file attributes of the cluster or of the associated\n components in order to reorg a cluster.\n\n The facility executes REXX execs and IDCAMS in a background job.\n The REXX facility issues IDCAMS commands to parse out the\n DEFINE parameters and creates IDCAMS commands to reallocate the\n VSAM components.\n\n The user enters the parms on ISPF panels if this exec is invoked\n in the Foreground.\n\n The reorg facility issues IDCAMS EXPORT and IMPORT FUNCTIONS to\n BACKUP/RELOAD the cluster data.\n\n Multiple clusters can be reorged at the same time.  The REXX\n facility uses a random number suffix for the JOBNAME of each\n reorg job that it submits through the internal reader to make\n each jobname unique.\n\n The facility handles clusters having alternate indexes and paths.\n\n The facility assumes that RACF is installed as the security product.\n If RACF IS NOT INSTALLED ON YOUR SITE, YOU WILL HAVE TO MODIFY REXX\n EXEC \"REORGVS4\" TO ISSUE THE EQUIVALENT STATEMENTS FOR YOUR SECURITY\n PRODUCT OR JUST REMOVE THE FOLLOWING STEPS FROM THE \"REORGVSS\"\n JCL SKELETON):\n\n     GETRACF, CHK500, ABEND500, BLDRACF, CHK700, ABEND700,\n     GENPROF, CHK750, ABEND750.\n\n You may choose to handle security profiles seperately after the fact.\n\n Please report any bugs to TERRY MILLER at Tkmille@ConocoPhillips.Com\n\n)X SYNTAX  -\n        REORGVS  clustername\n                 (HLQ(hlq)    )\n                 (PRI(+/-nnn) )\n                 (SEC(+/-nnn) )\n                 (TEST        )\n\n  Required - clustername (the Vsam CLuster Component Dataset Name)\n                         Must be the first parameter passed. It is\n                         positional in nature.\n\n  Defaults - HLQ(Userid) (Uses the submitters Userid for the HLQ\n                            for allocating the work datasets.)\n           - PRI(+0)     (Don't adjust the Data Component Primary\n                            allocation units value on the reorg)\n             SEC(+0)     (Don't adjust the Data Component Secondary\n                            allocation units value on the reorg)\n\n)O OPERANDS -\n\n))clustername - The Vsam Cluster to be reorganized.  The dataset\n                name does not need to be enclosed in tics\n                (although it will accept the name enclosed in tics).\n                This operand MUST be specified.  It cannot be\n                omitted.\n\n))PRI(+/-nnn) - The percentage adjustment to either increase or\n                decrease the data component's primary space\n                allocation.  The default is \"PRI(+0)\" (No Adjustment\n                to the primary allocation) if the operand is\n                omitted. This operand does not affect the index\n                component's space allocation or anyt alternate\n                index component's space allocation associated to\n                the cluster. The PRImary adjustment value must\n                contain either a \"+\" or \"-\" as the first character\n                of the operand if specified.\n\n                PRI(+10)  - Increase the primary allocation by a\n                            factor of +10%.\n                PRI(-25)  - Decrease the primary allocation by a\n                            factor of -20%.\n\n))SEC(+/-nnn) - The percentage adjustment to either increase or\n                 decrease the data component's secondary space\n                 allocation.  The default is \"SEC(+0)\" (No Adjustment\n                 to the secondary allocation) if the operand is\n                 omitted. This operand does not affect the index\n                 component's space allocation or anyt alternate\n                 index component's space allocation associated to\n                 the cluster. The SECondary adjustment value must\n                 contain either a \"+\" or \"-\" as the first character\n                 of the operand if specified.\n\n                 SEC(+10)  - Increase the secondary allocation by a\n                             factor of +10%.\n                 SEC(-20)  - Decrease the secondary allocation by a\n                             factor of -20%.\n\n))HLQ(hlq)    - Specifies the High-Level Qualifier to be used for\n                allocating the work datasets.  The default HLQ\n                is the submitter's userid if omitted.  All of the\n                work datasets will be deleted at the end of the\n                reorg job processing except the EXPORT image\n                backup work dataset.  It is saved for future\n                reference/backout purposes.\n\n))TEST        - This parameter will cause a test simulation of the\n                reorganization.  It will not update the VSAM cluster\n                or affect it.  It will only generate the work files\n                which can be inspected.  This is considered a TEST\n                pass execution. Some of the jcl skeleton steps will\n                NOT be executed.\n\n))EXAMPLE CALLS:\n\n     1) REORGVS my.vsam.dataset)\n     2) REORGVS my.vsam.dataset) HLQ(SYS5)\n     3) REORGVS my.vsam.dataset) HLQ(SYS5) PRI(+05)\n     4) REORGVS my.vsam.dataset) PRI(+10)\n     5) REORGVS my.vsam.dataset) PRI(+10) SEC(+10)\n     6) REORGVS my.vsam.dataset) PRI(-50) SEC(-50)\n     7) REORGVS my.vsam.dataset) TEST\n     8) REORGVS my.vsam.dataset) PRI(+10) SEC(+10) TEST\n\n))EXAMPLE EXPLANATIONS:\n\n     1) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n     2) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n           and create work datasets with the HLQ of 'SYS5'.\n     3) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n           and create work datasets with the HLQ of 'SYS5'\n           and increase the data component's primary\n           allocation units value by 5%\n     4) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n           and increase the data component's primary\n           allocation units value by 10%\n     5) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n           and increase the data component's primary\n           allocation units value by 10% and increase\n           data component's secondary allocation units\n           value by 10%. (Note, if the secondary\n           allocation unit is presently, zero, it will\n           remain 0 after the adjustment).\n     6) REORG Vsam Cluster named 'MY.VSAM.DATASET'\n           and decrease the data component's primary\n           allocation units value by 50% and decrease\n           data component's secondary allocation units\n           value by 50%. (Note, if the secondary\n           allocation unit is presently, zero, it will\n           remain 0 after the adjustment).\n     7) Test the Reorganization (Simulation pass) of the Vsam\n           Cluster named 'MY.VSAM.DATASET'.  Does not affect the\n           Cluster on a TEST pass simulation.\n     8) Test the Reorganization (Simulation pass) of the Vsam\n           Cluster named 'MY.VSAM.DATASET' and of increasing the\n           primary allocation units by +10% and of increasing the\n           secondary allocation units by +10%.\n           Does not affect the Cluster on a TEST pass simulation.\n\n\n))END OF HELP\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVSJ": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x06\\x03/\\x01\\x06\\x04\\x7f\\x15&\\x00\\x1f\\x00\\x1d\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-02-01T00:00:00", "modifydate": "2006-02-16T15:26:31", "lines": 31, "newlines": 29, "modlines": 0, "user": "TKMILLE"}, "text": "//REORGVSJ JOB ' JCL TO REORG A VSAM CLUSTER                   ',\n//     TIME=(2,00),REGION=0M\n//*******************************************************************\n//* POINT TO THE SYSPROC LIBRARY WHICH CONTAINS THE \"REORGVS\" REXX\n//*    EXEC.  THIS FUNCTION CAN ALSO BE CALLED FROM THE FOREGROUND.\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//* EXAMPLE CALLS:\n//*\n//*  %REORGVS MY.VSAM.DATASET\n//*  %REORGVS MY.VSAM.DATASET HLQ(SYS5)\n//*  %REORGVS MY.VSAM.DATASET HLQ(SYS5) PRI(+05)\n//*  %REORGVS MY.VSAM.DATASET PRI(+10)\n//*  %REORGVS MY.VSAM.DATASET PRI(+10)  SEC(+10)\n//*  %REORGVS MY.VSAM.DATASET PRI(-50)  SEC(-50)\n//*  %REORGVS MY.VSAM.DATASET TEST\n//*  %REORGVS MY.VSAM.DATASET PRI(+10)  TEST\n//*\n//*******************************************************************\n//REORGVS    EXEC PGM=IKJEFT01,DYNAMNBR=30\n//* SYSPROC    DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//SYSPROC    DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT   DD SYSOUT=*\n//SYSTSIN    DD *\n %REORGVS  MY.VSAM.CLUSTER.TO.BE.REORGED     <= CHANGE THIS DSNAME\n/*\n//ABENDER   EXEC PGM=ABENDER,PARM='1024',\n//          COND=(0,EQ)\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVSS": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x16\\x01\\x051O\\x01\\x06\\x04\\x8f\\x08%\\x01\\xd9\\x00\\xda\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2005-11-10T00:00:00", "modifydate": "2006-02-17T08:25:16", "lines": 473, "newlines": 218, "modlines": 0, "user": "TKMILLE"}, "text": "//REORGVSS JOB ' REORGVS JCL                                   ',\n//     TIME=(2,00),REGION=0M\n//**********************************************************************\n//*  INSERT YOUR INSTALLATION'S JOBCARD BEFORE USING THE \"REORGVS\"\n//*  FACILITY.\n//*\n//*  DO NOT REMOVE THE \"//**//SKIP\" AND \"//**//RESUME\" LINES !!!!\n//*  DO NOT CHANGE THE SYMBOLIC PARAMETERS IN THIS JCL !!!!\n//*    THE SYMBOLICS HAVE AN \"&\" AS THE FIRST CHARACTER OF EACH\n//*    VARIABLE AND ARE SUBSTITUTED BY REXX EXEC \"REORGVS\".\n//*    THE EXEC LOOKS FOR THE FOLLOWING SYMBOLIC VARIABLES:\n//*        &HLQ - THE HIGH-LEVEL QUALIFER FOR THE WORK FILES\n//*       &FSEQ - RANDOM SEQUENCE NUMBER TO MAKE WORK FILES UNIQUE\n//*    &CLUSTER - NAME OF THE VSAM CLUSTER TO BE REORGANIZED\n//**********************************************************************\n//* REALLOCATES AND REORGANIZES A VSAM CLUSTER WITH SAME ATTRIBUTES\n//* AS BEFORE.\n//* ASSUMPTIONS FOR THIS JOB:\n//*   A) THE VSAM CLUSTER MUST BE CATALOGED BEFORE RUNNING THIS JOB.\n//*   B) THE VSAM CLUSTER MUST NOT BE ALLOCATED BEFORE RUNNING THIS\n//*      JOB.\n//* 1) INPUT A VSAM CLUSTER NAME.\n//* 2) PARSE OUT THE ATTRIBUTES NECESSARY TO BUILD THE \"DEFINE CLUSTER\"\n//*      STATEMENTS TO CLONE THE FILES ON ANOTHER VOLUME AND/OR LPAR.\n//* 3) EXECUTE THE IDCAMS DEFINE STATEMENTS TO:\n//*    A)  EXPORT THE CLUSTER TO A WORK FILE BACKUP IMAGE\n//*    B)  REALLOCATE THE CLUSTER (REMOVING IMBED AND REPLICAT PARMS)\n//*    C)  RELOAD THE CORRECTLY ALLOCATED CLUSTER FROM THE WORK FILE.\n//* 4) REALLOCATE THE ALTERNATE INDEXES AND PATHS (IF THEY EXIST).\n//* 5) REBUILD THE ALTERNATE INDEXES (IF THEY EXIST).\n//* 6) RELOAD THE DISCRETE RACF PROFILES (IF THEY EXIST) FOR THE\n//*        CLUSTER TO PROTECT IT AGAIN (ASSUMES THAT YOU USE RACF\n//*        FOR A SECURITY PRODUCT).\n//**********************************************************************\n//* DELETE THE WORK FILES BEFORE THE REORG\n//**********************************************************************\n//DELETE1  EXEC PGM=IDCAMS\n//SYSPRINT DD DUMMY\n//DELETE1.SYSIN  DD *   *** <= DO NOT CHANGE THESE STATEMENTS  ********\n  DELETE  &HLQ.$REORGVS.RACF.PROFILE.SAVE.FS&FSEQ          PURGE\n  DELETE  &HLQ.$REORGVS.EXPORT.IMAGE.FS&FSEQ               PURGE\n  DELETE  &HLQ.$REORGVS.EXPORT.SYSPRINT.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.COMMANDS.FS&FSEQ             PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.AIX.COMMANDS.FS&FSEQ         PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.SYSPRINT.FS&FSEQ             PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.AIX.SYSPRINT.FS&FSEQ         PURGE\n  DELETE  &HLQ.$REORGVS.EXPORT.COMMANDS.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.DEFINE.COMMANDS.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.IMPORT.COMMANDS.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.DEFN.AIX.COMMANDS.FS&FSEQ          PURGE\n  DELETE  &HLQ.$REORGVS.RACF.PROFILE.CMDS.FS&FSEQ          PURGE\n  SET MAXCC = 0\n/*\n//**********************************************************************\n//* BUILD \"LISTC ALL ENT\" IDCAMS COMMANDS FOR THE CLUSTER DEFINITION.\n//* ALSO, BUILD THE IDCAMS \"EXPORT\" AND \"IMPORT\" COMMANDS TO EXPORT\n//* AND IMPORT THE VSAM CLUSTER DATA.\n//**********************************************************************\n//BUILDCMD  EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//LIST      DD *\n&CLUSTER\n//EXPORT    DD DSN=&HLQ.$REORGVS.EXPORT.COMMANDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,CATLG),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//COMMANDS  DD DSN=&HLQ.$REORGVS.LISTC.COMMANDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//IMPORT    DD DSN=&HLQ.$REORGVS.IMPORT.COMMANDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//SYSTSIN   DD *\n %REORGVS1\n//*\n//CHK100    IF (BUILDCMD.RC GT 4 OR BUILDCMD.ABEND)   THEN\n//ABEND100  EXEC PGM=ABENDER,PARM='0100'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**//SKIP   THE FOLLOWING STEPS IF IN TEST MODE ***********************\n//**********************************************************************\n//* EXECUTE THE \"EXPORT\" COMMAND TO EXPORT THE CLUSTER RECORDS\n//**********************************************************************\n//EXPORT   EXEC PGM=IDCAMS\n//* SYSPRINT DD SYSOUT=*\n//SYSPRINT DD DISP=(NEW,CATLG,DELETE),\n//         DSN=&HLQ.$REORGVS.EXPORT.SYSPRINT.FS&FSEQ,\n//         SPACE=(TRK,(001,001),RLSE),UNIT=SYSDA,\n//         DCB=(RECFM=FBA,LRECL=133,BLKSIZE=0,DSORG=PS)\n//SYSUDUMP DD SYSOUT=*\n//SYSUT1   DD DISP=OLD,DSN=&CLUSTER\n//IMAGE    DD DISP=(NEW,CATLG,DELETE),\n//         DSN=&HLQ.$REORGVS.EXPORT.IMAGE.FS&FSEQ,\n//         SPACE=(CYL,(030,030),RLSE),UNIT=SYSDA,\n//         DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=0)\n//SYSIN    DD DISP=SHR,\n//         DSN=&HLQ.$REORGVS.EXPORT.COMMANDS.FS&FSEQ\n//*\n//*CHK150   IF (EXPORT.RC GT 4 OR EXPORT.ABEND)   THEN\n//*ABEND150 EXEC PGM=ABENDER,PARM='0150'\n//*STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//*         ENDIF\n//*\n//**********************************************************************\n//* DISPLAY THE \"EXPORT\" SYSPRINT REPORT\n//**********************************************************************\n//EXPORTPR EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,\n//         DSN=&HLQ.$REORGVS.EXPORT.SYSPRINT.FS&FSEQ\n//SYSUT2   DD SYSOUT=*\n//*\n//CHK200    IF (EXPORTPR.RC GT 4 OR EXPORTPR.ABEND)   THEN\n//ABEND200  EXEC PGM=ABENDER,PARM='0200'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* PARSE OUT THE \"EXPORT\" SYSPRINT REPORT AND DETERMINE THE RESULTS.\n//* CONSIDER 3 POSSIBLITILES FOR THE EXPORT COMPLETION:\n//*  1) THE EXPORT COMPLETED SUCCESSFULLY\n//*  2) THE VSAM CLUSTER WAS EMPTY WITH COND CODE 12 AND FEEDBACK 160\n//*  3) THE EXPORT COMPLETED UNSUCCESSFULLY FOR OTHER REASONS BESIDES\n//*       HAVING AN EMPTY VSAM CLUSTER\n//**********************************************************************\n//EXPPARSE  EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//SYSPRINT  DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.EXPORT.SYSPRINT.FS&FSEQ\n//SYSTSIN   DD *\n %REORGVS6\n//*\n//CHK250    IF (EXPPARSE.RC GT 4 OR EXPPARSE.ABEND)   THEN\n//ABEND250  EXEC PGM=ABENDER,PARM='0250'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**//RESUME THE FOLLOWING STEPS IF IN TEST MODE ***********************\n//**********************************************************************\n//* EXECUTE \"LISTC ALL ENT\" IDCAMS COMMANDS TO PRODUCE A SYSPRINT\n//*       IMAGE PRIOR TO THE REORG.\n//**********************************************************************\n//LISTCAT   EXEC PGM=IDCAMS\n//SYSPRINT  DD DSN=&HLQ.$REORGVS.LISTC.SYSPRINT.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FBA,LRECL=133,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(010,010),RLSE)\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.LISTC.COMMANDS.FS&FSEQ\n/*\n//CHK300    IF (LISTCAT.RC GT 4 OR LISTCAT.ABEND)   THEN\n//ABEND300  EXEC PGM=ABENDER,PARM='0300'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* PRINT THE \"PRIOR IMAGE\" LISTCAT SYSPRINT REPORT FOR THE CLUSTER\n//**********************************************************************\n//LISTCATP EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,\n//         DSN=&HLQ.$REORGVS.LISTC.SYSPRINT.FS&FSEQ\n//SYSUT2   DD SYSOUT=*\n//*\n//CHK350    IF (LISTCATP.RC GT 4 OR LISTCATP.ABEND)   THEN\n//ABEND350  EXEC PGM=ABENDER,PARM='0350'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* READ THE IDCAMS SYSPRINT FILE TO PICK UP THE CLUSTER DEFINITION\n//*   ATTRIBUTES.  BUILD \"DELETE\" AND \"DEFINE CLUSTER\" DEFINITION\n//*   STATEMENTS TO DELETE AND REALLOCATE THE VSAM CLUSTER.\n//**********************************************************************\n//GENDEFIN  EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//SYSPRINT  DD DISP=SHR,DSN=&HLQ.$REORGVS.LISTC.SYSPRINT.FS&FSEQ\n//REPORT    DD SYSOUT=*\n//PARMFILE  DD DISP=SHR,DSN=&HLQ.$REORGVS.PARMFILE.FS&FSEQ\n//DEFINES   DD DSN=&HLQ.$REORGVS.DEFINE.COMMANDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//AIXCMDS   DD DSN=&HLQ.$REORGVS.LISTC.AIX.COMMANDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//SYSTSIN   DD *\n %REORGVS2\n//*\n//CHK400    IF (GENDEFIN.RC GT 4 OR GENDEFIN.ABEND)   THEN\n//ABEND400  EXEC PGM=ABENDER,PARM='0400'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* EXECUTE THE \"LISTC ALL ENT(AIXDSN)\" IDCAMS STATEMENTS\n//*       TO LIST THE CATALOG AIX COMPONENTS.\n//**********************************************************************\n//LISTCAIX  EXEC PGM=IDCAMS\n//SYSPRINT  DD DSN=&HLQ.$REORGVS.LISTC.AIX.SYSPRINT.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FBA,LRECL=133,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(010,010),RLSE)\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.LISTC.AIX.COMMANDS.FS&FSEQ\n//*\n//CHK420    IF (LISTCAIX.RC GT 4 OR LISTCAIX.ABEND)   THEN\n//ABEND420  EXEC PGM=ABENDER,PARM='0420'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* READ THE IDCAMS SYSPRINT FILE TO PICK UP THE AIX DEFINITION\n//*   ATTRIBUTES.  BUILD \"DELETE\" AND \"DEFINE AIX\" DEFINITION\n//*   STATEMENTS TO DELETE AND REALLOCATE THE AIX COMPONENTS.\n//*   ALSO BUILD THE \"DEFINE PATH\" ASSOCIATIONS FOR EACH AIX\n//*   COMPONENT.\n//**********************************************************************\n//GENDFAIX  EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//SYSPRINT  DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.LISTC.AIX.SYSPRINT.FS&FSEQ\n//REPORT    DD SYSOUT=*\n//DEFINES   DD DSN=&HLQ.$REORGVS.DEFN.AIX.COMMANDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//SYSTSIN   DD *\n %REORGVS3\n//*\n//CHK430    IF (GENDFAIX.RC GT 4 OR GENDFAIX.ABEND)   THEN\n//ABEND430  EXEC PGM=ABENDER,PARM='0430'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* PRINT THE \"PRIOR IMAGE\" LISTCAT SYSPRINT REPORT FOR THE CLUSTER\n//**********************************************************************\n//LISTCATA EXEC PGM=IEBGENER\n//SYSPRINT DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,\n//         DSN=&HLQ.$REORGVS.LISTC.AIX.SYSPRINT.FS&FSEQ\n//SYSUT2   DD SYSOUT=*\n//*\n//CHK450    IF (LISTCATA.RC GT 4 OR LISTCATA.ABEND)   THEN\n//ABEND450  EXEC PGM=ABENDER,PARM='0450'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//GETRACF   EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD DSN=&HLQ.$REORGVS.RACF.PROFILE.SAVE.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=133,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//SYSTSIN   DD *\n LISTDSD DA('&CLUSTER') ALL\n/*\n//CHK500    IF (GETRACF.RC GT 4 OR GETRACF.ABEND)   THEN\n//ABEND500  EXEC PGM=ABENDER,PARM='0500'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**//SKIP   THE FOLLOWING STEPS IF IN TEST MODE ***********************\n//**********************************************************************\n//* EXECUTE THE \"DELETE\" AND \"DEFINE CLUSTER\" IDCAMS STATEMENTS\n//*       TO DELETE AND REALLOCATE THE CLUSTER.\n//**********************************************************************\n//DEFNCLUS  EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.DEFINE.COMMANDS.FS&FSEQ\n//*\n//CHK550    IF (DEFNCLUS.RC GT 4 OR DEFNCLUS.ABEND)   THEN\n//ABEND550  EXEC PGM=ABENDER,PARM='0550'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* EXECUTE THE \"IMPORT\" COMMAND TO IMPORT THE CLUSTER RECORDS.\n//**********************************************************************\n//IMPORT    EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//IMAGE     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.EXPORT.IMAGE.FS&FSEQ\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.IMPORT.COMMANDS.FS&FSEQ\n//*\n//CHK600    IF (IMPORT.RC GT 4 OR IMPORT.ABEND)   THEN\n//ABEND600  EXEC PGM=ABENDER,PARM='0600'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* EXECUTE THE \"DELETE\" AND \"DEFINE AIX\" IDCAMS STATEMENTS\n//*       TO DELETE AND REALLOCATE THE AIX COMPONENTS AND\n//*       EXECUTE THE \"DEFINE PATH\" ASSOCIATIONS FOR EACH AIX.\n//**********************************************************************\n//DEFNAIX   EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.DEFN.AIX.COMMANDS.FS&FSEQ\n//*\n//CHK650    IF (DEFNAIX.RC GT 4 OR DEFNAIX.ABEND)   THEN\n//ABEND650  EXEC PGM=ABENDER,PARM='0650'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**//RESUME THE FOLLOWING STEPS IF IN TEST MODE ***********************\n//**********************************************************************\n//* BUILD THE RACF DISCRETE PROFILE ADD, ALTER, AND PERMIT COMMANDS\n//* (IF A DISCRETE RACF PROFILE EXISTS).\n//**********************************************************************\n//BLDRACF   EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//SYSPRINT  DD DISP=SHR,DSN=&HLQ.$REORGVS.RACF.PROFILE.SAVE.FS&FSEQ\n//COMMANDS  DD DSN=&HLQ.$REORGVS.RACF.PROFILE.CMDS.FS&FSEQ,\n//          DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//          DCB=(RECFM=FB,LRECL=080,BLKSIZE=0,DSORG=PS),\n//          SPACE=(TRK,(001,001),RLSE)\n//SYSTSIN   DD *\n %REORGVS4\n/*\n//CHK700    IF (BLDRACF.RC GT 4 OR BLDRACF.ABEND)   THEN\n//ABEND700  EXEC PGM=ABENDER,PARM='0700'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**//SKIP   THE FOLLOWING STEPS IF IN TEST MODE ***********************\n//**********************************************************************\n//*REBUILD THE RACF DISCRETE PROFILE (IF ONE EXISTS).\n//**********************************************************************\n//GENPROF  EXEC PGM=IKJEFT01,DYNAMNBR=30,COND=EVEN\n//SYSPROC  DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DISP=SHR,DSN=&HLQ.$REORGVS.RACF.PROFILE.CMDS.FS&FSEQ\n/*\n//CHK750    IF (GENPROF.RC GT 4 OR GENPROF.ABEND)   THEN\n//ABEND750  EXEC PGM=ABENDER,PARM='0750'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* EXECUTE \"LISTC ALL ENT\" IDCAMS COMMANDS TO PRODUCE A SYSPRINT\n//*       IMAGE AFTER THE THE REORG.\n//**********************************************************************\n//LISTCAT2  EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.LISTC.COMMANDS.FS&FSEQ\n/*\n//CHK800    IF (LISTCAT2.RC GT 4 OR LISTCAT2.ABEND)   THEN\n//ABEND800  EXEC PGM=ABENDER,PARM='0800'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* EXECUTE \"LISTC ALL ENT\" IDCAMS COMMANDS TO PRODUCE A SYSPRINT\n//*       IMAGE OF THE AIX COMPONENTS AFTER THE THE REORG.\n//**********************************************************************\n//LISTAIX2  EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DISP=SHR,\n//          DSN=&HLQ.$REORGVS.LISTC.AIX.COMMANDS.FS&FSEQ\n/*\n//CHK820    IF (LISTAIX2.RC GT 4 OR LISTAIX2.ABEND)   THEN\n//ABEND820  EXEC PGM=ABENDER,PARM='0820'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* IF THE IMPORT FUNCTION IS SUCCESSFUL, THEN LOG THE ENTRY IN THE\n//* LOGFILE (SYS3.$REORGVS.LOGFILE).  THE LOGFILE IS DYNAMICALLY\n//* ALLOCATED TO ALLOW MULTIPLE REORG JOBS TO RUN AT ONE TIME.\n//* (THERE WILL NOT BE A FILE ALLOCATION IN THE JCL FOR FILE\n//* LOGFILE).\n//**********************************************************************\n//LOGITGD   EXEC PGM=IKJEFT01,DYNAMNBR=30,COND=(4,LT)\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//LIST      DD *\n&CLUSTER\n//EXPORT    DD DSN=&HLQ.$REORGVS.EXPORT.IMAGE.FS&FSEQ,\n//          DISP=SHR\n//SYSTSIN   DD *\n %REORGVS5  GOOD\n//*\n//CHK850    IF (LOGITGD.RC GT 4 OR LOGITGD.ABEND)   THEN\n//ABEND850  EXEC PGM=ABENDER,PARM='0850'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//*\n//**********************************************************************\n//* IF THE IMPORT FUNCTION IS UNSUCCESSFUL, THEN LOG THE ENTRY IN THE\n//* LOGFILE (SYS3.$REORGVS.LOGFILE).  THE LOGFILE IS DYNAMICALLY\n//* ALLOCATED TO ALLOW MULTIPLE REORG JOBS TO RUN AT ONE TIME.\n//* (THERE WILL NOT BE A FILE ALLOCATION IN THE JCL FOR FILE\n//* LOGFILE).\n//**********************************************************************\n//LOGITB    IF (RC GT 4 OR ABEND)                              THEN\n//LOGITBAD  EXEC PGM=IKJEFT01,DYNAMNBR=30\n//SYSPROC   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.EXEC\n//          DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSTSPRT  DD SYSOUT=*\n//LIST      DD *\n&CLUSTER\n//EXPORT    DD DSN=&HLQ.$REORGVS.EXPORT.IMAGE.FS&FSEQ,\n//          DISP=SHR\n//SYSTSIN   DD *\n %REORGVS5  BAD\n//*\n//CHK900    IF (LOGITBAD.RC GT 4 OR LOGITBAD.ABEND)   THEN\n//ABEND900  EXEC PGM=ABENDER,PARM='0900'\n//STEPLIB   DD DISP=SHR,DSN=$XXXXXXXX.$REORGVS.LOADLIB\n//          ENDIF\n//          ENDIF\n//*\n//**********************************************************************\n//* DELETE THESE WORK FILES EVEN UPON ABEND\n//**********************************************************************\n//DELETE2  EXEC PGM=IDCAMS,COND=EVEN\n//SYSPRINT DD DUMMY\n//SYSIN    DD *   *** <= DO NOT CHANGE THESE STATEMENTS  ********\n  DELETE  &HLQ.$REORGVS.EXPORT.COMMANDS.FS&FSEQ            PURGE\n  SET MAXCC = 0\n/*\n//**********************************************************************\n//* DELETE MORE WORK FILES AFTER THE REORG IS SUCCESSFUL\n//* KEEP &HLQ.$REORGVS.EXPORT.IMAGE.FS&FSEQ FILE.  DON'T DELETE.\n//**********************************************************************\n//DELETE3  EXEC PGM=IDCAMS\n//SYSPRINT DD DUMMY\n//SYSIN    DD *   *** <= DO NOT CHANGE THESE STATEMENTS  ********\n  DELETE  &HLQ.$REORGVS.PARMFILE.FS&FSEQ                   PURGE\n  DELETE  &HLQ.$REORGVS.SUBMIT.JCL.FS&FSEQ                 PURGE\n  DELETE  &HLQ.$REORGVS.EXPORT.SYSPRINT.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.COMMANDS.FS&FSEQ             PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.AIX.COMMANDS.FS&FSEQ         PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.SYSPRINT.FS&FSEQ             PURGE\n  DELETE  &HLQ.$REORGVS.LISTC.AIX.SYSPRINT.FS&FSEQ         PURGE\n  DELETE  &HLQ.$REORGVS.IMPORT.COMMANDS.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.DEFINE.COMMANDS.FS&FSEQ            PURGE\n  DELETE  &HLQ.$REORGVS.DEFN.AIX.COMMANDS.FS&FSEQ          PURGE\n  DELETE  &HLQ.$REORGVS.RACF.PROFILE.SAVE.FS&FSEQ          PURGE\n  DELETE  &HLQ.$REORGVS.RACF.PROFILE.CMDS.FS&FSEQ          PURGE\n  SET MAXCC = 0\n/*\n//* END OF JOB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVSX": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01C\\x00\\x17\\x01\\t\\x14_\\x01\\t\\x15?\\x13&\\x03\\x0e\\x028\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.67", "flags": 0, "createdate": "2009-05-25T00:00:00", "modifydate": "2009-06-02T13:26:17", "lines": 782, "newlines": 568, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVSX   (Reorg a VSAM Cluster)                       */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 11/10/2005                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 06/02/2009                         */\n/*  Called by Exec         REORGVS                                    */\n/*                                                                    */\n/*  PURPOSE                                                           */\n/*                                                                    */\n/*      This exec will submit a job to reorg a VSAM cluster.          */\n/*      It will input the cluster dataset name and optionally         */\n/*      the high-level qualifier for the work files.                  */\n/*      It will generate a random number between 1 and 999999         */\n/*      to use in the low-level qualifier for uniqueness.             */\n/*                                                                    */\n/*      The exec can be called from the background or in the          */\n/*      foreground.  If it is called from the background, the         */\n/*      execution parameters must be passed according to the example  */\n/*      background-supplied parms rules noted below and the           */\n/*      background example calls noted below.  If called from the     */\n/*      foreground, the execution paramters will be coded on an       */\n/*      ISPF panel.                                                   */\n/*                                                                    */\n/*      This exec will input a stream of jcl to tailor and to         */\n/*      submit in the background.  It will substitute the             */\n/*      variables that the invoker provides to this exec              */\n/*      before submitting the job.  The jcl stream will be            */\n/*      saved in a dataset (&HLQ.$REORGVS.SUBMIT.JCL.FS&FSEQ).        */\n/*                                                                    */\n/*      These skeleton variables will be substited:                   */\n/*        &CLUSTER  (User provided to this exec)                      */\n/*        &HLQ      (User provided to this exec)                      */\n/*        &FSEQ     (Not user provided - this is a random             */\n/*                   number generated within this exec).              */\n/*                                                                    */\n/*  BACKGROUND-SUPPLIED PARMS:                                        */\n/*  (Required Parms):                                                 */\n/*  (Required Parms):                                                 */\n/*          CLUSTERNAME = The VSAM Cluster Dataset to be reorged.     */\n/*                        This must be the first parameter.           */\n/*                        It is positional in nature and cannot be    */\n/*                        omitted.                                    */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*        HLQ(hlq) = The name of the high-level qualifier to use      */\n/*                   for the work datasets.  The default hlq will     */\n/*                   be the invoker's userid.                         */\n/*                                                                    */\n/*       PRI(+NNN) = This parameter increases or decreases the        */\n/*    or PRI(-NNN)   primary space allocation for the cluster         */\n/*                   (relative to what it was before).                */\n/*                   The syntax is: +nnn or -nnn.  nnn must be        */\n/*                   numeric value between 1 and 999 and must be      */\n/*                   preceded with either a \"+\" or \"-\". nnn           */\n/*                   represents a percentage value of increase or     */\n/*                   decrease against the previous primary            */\n/*                   allocation value.                                */\n/*                                                                    */\n/*       SEC(+NNN) = This parameter increases or decreases the        */\n/*    or SEC(-NNN)   secondary space allocation for the cluster       */\n/*                   (relative to what it was before).                */\n/*                   The syntax is: +nnn or -nnn.  nnn must be        */\n/*                   numeric value between 1 and 999 and must be      */\n/*                   preceded with either a \"+\" or \"-\". nnn           */\n/*                   represents a percentage value of increase or     */\n/*                   decrease against the previous secondary          */\n/*                   allocation value.                                */\n/*                                                                    */\n/*          TEST   = This parameter will cause a test simulation of   */\n/*                   the reorganization.  It will not update the      */\n/*                   cluster or affect it.  It will only generate     */\n/*                   the work files which can be inspected.  This     */\n/*                   is considered a TEST pass execution. Some of     */\n/*                   the jcl skeleton steps will not be executed.     */\n/*                                                                    */\n/*          DEBUG  = The parameter which displays the statements as   */\n/*                   they are executed (invokes TRACE I)              */\n/*                                                                    */\n/*  Background Example Calls:                                         */\n/*                                                                    */\n/*  1) REORGVSX my.vsam.dataset)                                      */\n/*  2) REORGVSX my.vsam.dataset) HLQ(SYS5)                            */\n/*  3) REORGVSX my.vsam.dataset) HLQ(SYS5) PRI(+05)                   */\n/*  4) REORGVSX my.vsam.dataset) PRI(+10)                             */\n/*  5) REORGVSX my.vsam.dataset) PRI(+10) SEC(+10)                    */\n/*  6) REORGVSX my.vsam.dataset) PRI(-50) SEC(-50)                    */\n/*  7) REORGVSX my.vsam.dataset) TEST                                 */\n/*  8) REORGVSX my.vsam.dataset) PRI(+10) SEC(+10) TEST               */\n/*                                                                    */\n/*  Background Example Explanations:                                  */\n/*                                                                    */\n/*  1) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*  2) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and create work datasets with the HLQ of 'SYS5'.            */\n/*  3) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and create work datasets with the HLQ of 'SYS5'             */\n/*        and increase the data component's primary                   */\n/*        allocation units value by 5%                                */\n/*  4) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and increase the data component's primary                   */\n/*        allocation units value by 10%                               */\n/*  5) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and increase the data component's primary                   */\n/*        allocation units value by 10% and increase                  */\n/*        data component's secondary allocation units                 */\n/*        value by 10%. (Note, if the secondary                       */\n/*        allocation unit is presently zero, it will                  */\n/*        remain 0 after the adjustment).                             */\n/*  6) REORG Vsam Cluster named 'MY.VSAM.DATASET'                     */\n/*        and decrease the data component's primary                   */\n/*        allocation units value by 50% and decrease                  */\n/*        data component's secondary allocation units                 */\n/*        value by 50%. (Note, if the secondary                       */\n/*        allocation unit is presently zero, it will                  */\n/*        remain 0 after the adjustment).                             */\n/*  7) Test the Reorganization (Simulation pass) of the Vsam          */\n/*        Cluster named 'MY.VSAM.DATASET'.  Does not affect the       */\n/*        Cluster on a TEST pass simulation.                          */\n/*  8) Test the Reorganization (Simulation pass) of the Vsam          */\n/*        Cluster named 'MY.VSAM.DATASET' and of increasing the       */\n/*        primary allocation units by +10% and of increasing the      */\n/*        secondary allocation units by +10%.                         */\n/*        Does not affect the Cluster on a TEST pass simulation.      */\n/*                                                                    */\n/*  Installation Tailoring:                                           */\n/*        Do a FIND on \"ISPPLIB\" and \"ISPMLIB\". Change these          */\n/*        datasets names to the names for your installation.          */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of this exec                         */\n/*   12   - Invalid or missing parms or JCL Skeleton File allocation  */\n/*          error.                                                    */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.02.02\"\nArg parms\nTrace \"O\"\nmsg_stat        = Msg(\"OFF\")\nenvirnmt        = SYSVAR(\"sysenv\")\nnesting         = SYSVAR(\"sysnest\")\nsysicmd         = SYSVAR(\"sysicmd\")\nsyspcmd         = SYSVAR(\"syspcmd\")\nsysscmd         = SYSVAR(\"sysscmd\")\nuserid          = Userid()\nrtcd            = 0\npanel_end       = \"N\"\nsysid           = Left(MVSVAR(sysname),3,\" \")\nprocessing_mode = \"EXECUTION\"\nparmfile_count  = 0\ninput_count     = 0\ncluster         = \"\"\nhlq             = userid\nprim_alc_adjust = 0\nsec_alc_adjust  = 0\nprimary_lit     = \"\"\nsecondary_lit   = \"\"\nskip_lines      = \"N\"\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n   Select\n     When ABBREV('DEBUG',WORD(parms,i),3) = 1  & ,\n        i > 1                                      Then Do\n          debug = \"DEBUG\"\n          parms = DELWORD(parms,i,1)\n     End\n     When WORD(parms,i)  = \"TEST\"                  Then Do\n          processing_mode = \"TEST\"\n          parms = DELWORD(parms,i,1)\n     End\n     Otherwise Nop\n   End\nEnd\n\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\n\"NEWSTACK\"\n\nIf envirnmt <> \"BACK\" Then Do\n  Signal Make_spf_library_allocations\nEnd\n\ncluster  = WORD(parms,1)\nparms    = DELWORD(parms,i,1)\n\nParse var parms \"DSN(\" parse_value \")\"\nIf parse_value <> \"\" then cluster = parse_value\n\nParse var parms \"CLUSTER(\" parse_value \")\"\nIf parse_value <> \"\" then cluster = parse_value\n\ncluster  = STRIP(cluster,both,\"'\")      /* remove enclosed ticks    */\ncluster  = STRIP(cluster,both,'\"')      /* remove enclosed quotes   */\n\nIf LENGTH(cluster) = 0 Then Do\n   Say ;\n   Say \"VSAM Cluster Dataset Name Was Omitted ...\"\n   Say \"REORGVS SYNTAX:  REORGVS Clustername \"\n   rtcd = 12\n   Signal Check_for_Errors\nEnd\n\nIf LENGTH(cluster) > 44  Then Do\n   Say ;\n   Say \"Invalid VSAM Cluster Dataset Name Specified ...\"\n   Say \"VSAM Cluster Dataset Name => '\"cluster\"'\"\n   Say \"REORGVS SYNTAX:  REORGVS Clustername \"\n   rtcd = 12\n   Signal Check_for_Errors\nEnd\n\n/*  See if the VSAM Cluser dataset is cataloged                  */\n\nCall Check_Cataloged\n\nIf catlged <> \"OK\" & catlged <> \"UNAVAILABLE DATASET\" Then Do\n   Say ;\n   Say \"Cluster Dataset is not cataloged ...\"\n   Say \"Cluster Dataset Name => '\"cluster\"'\"\n   rtcd = 12\n   Signal Check_for_Errors\nEnd\n\nhlq      =  Userid\n\nParse var parms \"HLQ(\" parse_value \")\"\nIf parse_value <> \"\" then hlq = parse_value\n\nIf length(hlq) > 8 & hlq <> USerid  Then Do\n   Say ;\n   Say \"Invalid HLQ Value Specified ...\"\n   Say \"REORGVS SYNTAX:  REORGVS Clustername HLQ(hlq)  \"\n   rtcd = 12\n   Signal Check_for_Errors\nEnd\n\nParse var parms \"PRIMARY(\" parse_value \")\"\nIf parse_value <> \"\" & prim_alc_adjust = 0        Then Do\n   prim_alc_adjust = parse_value\nEnd\n\nParse var parms \"PRI(\" parse_value \")\"\nIf parse_value <> \"\" & prim_alc_adjust = 0        Then Do\n   prim_alc_adjust = parse_value\nEnd\n\nParse var parms \"SECONDARY(\" parse_value \")\"\nIf parse_value <> \"\" & sec_alc_adjust = 0         Then Do\n   sec_alc_adjust = parse_value\nEnd\n\nParse var parms \"SEC(\" parse_value \")\"\nIf parse_value <> \"\" & sec_alc_adjust = 0         Then Do\n   sec_alc_adjust = parse_value\nEnd\n\nCall Check_prim_Sec\n\nIf rtcd <> 0      Then Do\n   Say pmsg\n   Say qmsg\n   Say rmsg\n   Signal Check_for_Errors\nEnd\n\nSignal Allocate_Files\n\nMake_spf_library_allocations:\n\nAddress 'ISPEXEC'\n\n\"LIBDEF ISPPLIB DATASET ID('OUR.ISPF.ISPPLIB')\" <= CHANGE TO YOUR LIB\n\"LIBDEF ISPMLIB DATASET ID('OUR.ISPF.ISPMLIB')\" <= CHANGE TO YOUR LIB\n\nAddress 'TSO'\n\nPut_variables_into_appl_pool:\n\nAddress 'ISPEXEC'\nzplace  = 'ASIS'\n'VPUT (ZPLACE)  PROFILE'\nvputrc  = rc\n\nReorg_Vsam_Dataset:\n\nAddress 'ISPEXEC'\n'VGET (CLUSTER PRIMARY SECONDY HLQ TEST)  PROFILE'\nvgetrc  = rc\nAddress 'TSO'\n\nIf primary = \"\" then primary = \"+0\"\nIf secondy = \"\" then secondy = \"+0\"\nIf hlq     = \"\" then hlq     = Userid\nIf test    = \"\" then test    = \"N\"\ncsrfield   = \"CLUSTER\"\n\nDisplay_Vsam_Reorg_Screen:\n\nCall Get_date_and_time\n\nzcmd     = \"\"\nAddress 'ISPEXEC'\n\"DISPLAY PANEL(REORGPN1) CURSOR(\"csrfield\")\"\nrtcd     = rc\nAddress 'TSO'\n\n/*  rtcd = 8 when the END or RETURN key was depressed               */\nIf rtcd = 8         Then Do\n   panel_end = \"Y\"\n   Signal End_up\nEnd\n\npmsg     = \"\"\n\ncluster = STRIP(cluster,both,\"'\")       /* remove enclosed ticks    */\ncluster = STRIP(cluster,both,'\"')       /* remove enclosed quotes   */\n\nIf LENGTH(cluster) = 0 Then Do\n   csrfield = \"CLUSTER\"\n   pmsg = \"VSAM Cluster Dataset Name Was Omitted ...\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nIf LENGTH(cluster) > 44 Then Do\n   csrfield = \"CLUSTER\"\n   pmsg = \"Invalid VSAM Cluster Dataset Name Specified - Too Long\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nCall Check_Cataloged\n\nIf catlged <> \"OK\" & catlged <> \"UNAVAILABLE DATASET\" Then Do\n   csrfield = \"CLUSTER\"\n   pmsg = \"Cluster Dataset is not cataloged ...\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nIf LENGTH(primary) > 4   Then Do\n   csrfield = \"PRIMARY\"\n   pmsg = \"Invalid PRIMARY allocation increase percentage specified\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nIf LENGTH(secondy) > 4   Then Do\n   csrfield = \"SECONDY\"\n   pmsg = \"Invalid SECONDARY allocation increase percentage specified\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nprim_alc_adjust  = primary\nsec_alc_adjust   = secondy\n\nCall Check_prim_Sec\n\nIf rtcd <> 0      Then Do\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nIf LENGTH(hlq) > 8   Then Do\n   csrfield = \"HLQ\"\n   pmsg = \"Invalid HLQ Value Specified ...\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nIf test <> \"Y\" & test <> \"N\" Then Do\n   csrfield = \"TEST\"\n   pmsg = \"Invalid Test Value Specified ...\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nIf Test = \"Y\" Then Do\n   processing_mode = \"TEST\"\nEnd\n\nAddress 'ISPEXEC'\n'VPUT (CLUSTER PRIMARY SECONDY HLQ TEST)             PROFILE'\nvputrc  = rc\nIf vputrc <> 0  Then Do\n   Say \"Error stowing the REOR* Profile Variables\"\n   Say \"VPUT return code =>\" vputrc\n   Signal End_up\nEnd\nAddress 'TSO'\n\nAllocate_Files:\n\nfseq          = \"0\"||random(00001,99999)\nPARMFILE_File = hlq||\".$REORGVS.PARMFILE.FS\"||STRIP(fseq)\nJCL_File      = \"SMPE.REORGVS.CNTL(REORGVSS)\"\nSUBMIT_File   = hlq||\".$REORGVS.SUBMIT.JCL.FS\"||STRIP(fseq)\n\nOutput_Parmfile_Record:\n\n\"DELETE  '\"||PARMFILE_File||\"' PURGE\"\n\"ALLOC FI(PARMFILE) DA('\"||PARMFILE_File||\"') NEW REUSE\",\n      \"SPACE(1,1)  TRACKS  DSORG(PS) RECFM(F B) LRECL(80)\",\n      \"BLKSIZE(0)\"\nalloc_pf_rc = rc\n\nIf alloc_pf_rc <> 0 Then Do\n   Queue \" \"\n   Queue \"Could not allocate the PARMFILE OUTPUT DATASET ...\"\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   Queue \"Allocation Return Code is =>\" alloc_pf_rc\n   rtcd = 12\n   Signal End_Up\nEnd\n\nIf primary_lit = \"\" & secondary_lit = \"\" Then Do\n   \"EXECIO 0 DISKW PARMFILE (FINIS \"\n   Signal Check_for_Errors\nEnd\n\nparmfile.1  = primary_lit||\" \"||secondary_lit\n\nparmfile_count = parmfile_count + 1\n\n\"EXECIO 1 DISKW PARMFILE (STEM parmfile. FINIS \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Queue \" \"\n   Queue \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"PARMFILE !!!\"\n   Queue \"File PARMFILE was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Queue \"EXECIO Return Code is \"execiorc\" !!!\"\n   rtcd = 12\n   Signal Check_for_Errors\nEnd\n\n\"FREE  FI(PARMFILE) DA('\"||PARMFILE_File||\"')\"\n\nCheck_for_Errors:\n\n/********* Debugging Start ****************************************/\n/* Queue \"&CLUSTER  =\" cluster                                    */\n/* Queue \"&HLQ      =\" hlq                                        */\n/* Queue \"&FSEQ     =\" fseq                                       */\n/* Queue \"&PRI      =\" primary_lit                                */\n/* Queue \"&SEC      =\" secondary_lit                              */\n/* Queue \"Parmfile  =\" PARMFILE_File                              */\n/* Queue \"JCL_File  =\" JCL_File                                   */\n/* Queue \"Submit File =\" SUBMIT_File                              */\n/********* Debugging End   ****************************************/\n\nIf rtcd > 0 & envirnmt  = \"BACK\" Then Do\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   Signal End_Up\nEnd\n\nIf rtcd > 0 & envirnmt <> \"BACK\" Then Do\n   pmsg = \"Exec REORGVS is Terminated Prematurely      ...\"\n   Signal Display_Vsam_Reorg_Screen\nEnd\n\nAllocate_JCL_Skeleton_File:\n\n\"ALLOC FI(JCLFILE) DA('\"JCL_File\"')  SHR REUSE\"\nalloc_jf_rc = rc\n\nIf alloc_jf_rc <> 0 Then Do\n   Queue \" \"\n   Queue \"Could not allocate the JCL Skeleton Input File ...\"\n   Queue \"JCL Skeleton File is =>\" JCL_File\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   rtcd = 12\n   Signal End_Up\nEnd\n\n\"DELETE  '\"||SUBMIT_File||\"' PURGE\"\n\"ALLOC FI(SUBMITFL) DA('\"||SUBMIT_File||\"') NEW REUSE\",\n      \"SPACE(1,1)  TRACKS  DSORG(PS) RECFM(F B) LRECL(80)\",\n      \"BLKSIZE(0)\"\nalloc_sf_rc = rc\n\nIf alloc_sf_rc <> 0 Then Do\n   Queue \" \"\n   Queue \"Could not allocate the SUBMIT JCL OUTPUT SAVE FILE ...\"\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   Queue \"Allocation Return Code is =>\" alloc_sf_rc\n   rtcd = 12\n   Signal End_Up\nEnd\n\n\"NEWSTACK\"\n\nRead_JCL_Loop:\n\n\"EXECIO 1 DISKR JCLFILE  (STEM jclfile. \"\nexeciorc     = rc\nIf execiorc  = 2   Then ,        /* On end of file - Submit JCL */\n   Signal Submit_VSAM_Reorg_Job\nIf execiorc <> 0   Then Do\n   Queue \" \"\n   Queue \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"JCLFILE !!!\"\n   Queue \"JCL Skeleton File is =>\" JCL_File\n   Queue \"EXECIO Return Code is \"execiorc\" !!!\"\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\ninput_count = input_count + 1\n\nSelect\n  When input_count = 1 & processing_mode = \"TEST\"           Then Do\n       jclfile.1 = Overlay(\"T\",jclfile.1,8,1)\n       jclfile.1 = Overlay(Right(fseq,2,\"0\"),jclfile.1,9,2)\n       jobname = Substr(jclfile.1,3,8)\n  End\n  When input_count = 1                                      Then Do\n       jclfile.1 = Overlay(Right(fseq,3,\"0\"),jclfile.1,8,3)\n       jobname = Substr(jclfile.1,3,8)\n  End\n  Otherwise Nop\nEnd\n\nCheck_for_Test_Mode_Bypass:\n\nIf SUBSTR(jclfile.1,1,10) = \"//**//SKIP\"     Then Do\n   skip_lines = \"Y\"\n   Signal Read_JCL_Loop\nEnd\n\nIf SUBSTR(jclfile.1,1,12) = \"//**//RESUME\"   Then Do\n   skip_lines = \"N\"\n   Signal Read_JCL_Loop\nEnd\n\nIf skip_lines = \"Y\" & processing_mode = \"TEST\"   Then Do\n   Signal Read_JCL_Loop\nEnd\n\nSubstitute_Skeleton_Variables:\n\nlen_jcl1 = length(jclfile.1)\n\ncluster_pos    = POS(\"&CLUSTER\",jclfile.1)\nIf cluster_pos > 0  Then Do\n   cluster_end  = cluster_pos  + 8\n   jcl_part1 = SUBSTR(jclfile.1,1,cluster_pos - 1)\n   jcl_part2 = SUBSTR(jclfile.1,cluster_end, len_jcl1 - cluster_end )\n   jclfile.1 = jcl_part1||cluster||jcl_part2\n   jclfile.1 = Left(jclfile.1,80,\" \")\nEnd\n\nhlq_pos    = POS(\"&HLQ\",jclfile.1)\nIf hlq_pos > 0  Then Do\n   hlq_end   = hlq_pos  + 4\n   jcl_part1 = SUBSTR(jclfile.1,1,hlq_pos - 1)\n   jcl_part2 = SUBSTR(jclfile.1,hlq_end, len_jcl1 - hlq_end )\n   jclfile.1 = jcl_part1||hlq||jcl_part2\n   jclfile.1 = Left(jclfile.1,80,\" \")\nEnd\n\nfseq_pos    = POS(\"&FSEQ\",jclfile.1)\nIf fseq_pos > 0  Then Do\n   fseq_end   = fseq_pos  + 5\n   jcl_part1 = SUBSTR(jclfile.1,1,fseq_pos - 1)\n   jcl_part2 = SUBSTR(jclfile.1,fseq_end, len_jcl1 - fseq_end )\n   jclfile.1 = jcl_part1||fseq||jcl_part2\n   jclfile.1 = Left(jclfile.1,80,\" \")\nEnd\n\nQueue  jclfile.1         /* Send Tailored JCL Line to the Queue  */\n\nSignal Read_JCL_Loop\n\nSubmit_VSAM_Reorg_Job:\n\n\"EXECIO 0 DISKR JCLFILE  (FINIS\"\n\"FREE FI(JCLFILE)  DA('\"JCL_File\"')\"\n\nQUEUE \"\"   /* Add a null line to indicate the end of information */\n\n\"EXECIO * DISKW SUBMITFL (FINIS     \"\nexeciorc     = rc\n\"DELSTACK\"\n\nIf execiorc <> 0   Then Do\n   Queue ;\n   Queue \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"SUBMITFL !!!\"\n   Queue \"EXECIO Return Code is \"execiorc\" !!!\"\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nBuild_Internal_Reader_JCL_Stream:\n\n\"EXECIO 0 DISKW SUBMITFL (FINIS\"\n\"FREE FI(SUBMITFL) DA('\"||SUBMIT_File||\"')\"\n\n\"ALLOC FI(SYSUT1) DA('\"||SUBMIT_File||\"')  SHR REUSE\"\n\"ALLOC FI(SYSUT2) SYSOUT(A) WRITER(INTRDR)  REUSE\"\nalloc_sf_rc = rc\nIf alloc_sf_rc <> 0 Then Do\n   Queue \" \"\n   Queue \"Could not allocate the INTRDR JCL Submit Stream ...\"\n   Queue \"Allocation Return Code is =>\" alloc_sf_rc\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   rtcd = 12\n   Signal End_Up\nEnd\n\n\"ALLOC FI(SYSIN)    DUMMY                      REUSE\"\n\"ALLOC FI(SYSPRINT) DUMMY                      REUSE\"\n\"ALLOC FI(SYSUDUMP) DUMMY                      REUSE\"\n\n/* Address \"LINKMVS\" \"IEBGENER\" */\n\"TSOEXEC CALL *(IEBGENER)\"\n\nIEBGENER_rc   = rc\nIf IEBGENER_rc <> 0   Then Do\n   Queue \" \"\n   Queue \"ERROR Submitting the JCL stream into the Internal Reader ...\"\n   Queue \"IEBGENER Return Code is =>\" IEBGENER_rc\n   Queue \"Exec REORGVS is Terminated Prematurely    ...\"\n   rtcd = 12\n   Signal End_Up\nEnd\n\n\"FREE DA('\"||SUBMIT_File||\"')\"\n\"FREE FI(SYSUT1 SYSUT2 SYSIN SYSPRINT SYSUDUMP)\"\n\nQueue \" \"\nQueue \"REORGVS Exec - Submit Reorganization Job ...\"\nQueue \" \"\nQueue \"version_level                =>\" version_level\nQueue \" \"\nQueue \"Exec REORGVS - Processing Mode is\" processing_mode \"mode\"\n\nIf processing_mode = \"TEST\" Then Do\n   Queue \" \"\n   Queue \"All Update steps will be bypassed in TEST mode ...\"\nEnd\n\nQueue \" \"\nIf processing_mode = \"TEST\" Then Do\n   Queue \"Job\" jobname \"has been submitted to test the reorg of cluster\"\n   Queue \"  '\"cluster\"'\"\nEnd\nElse Do\n   Queue \"Job\" jobname \"has been submitted to reorg VSAM cluster\"\n   Queue \"  '\"cluster\"'\"\nEnd\nQueue \"Work datasets begin with HLQ's '\"hlq\".$REORGVS' ... \"\nQueue \"Work datasets end with LLQ    'FS\"fseq\"' ...  \"\nQueue \" \"\nQueue \"SUBMIT JCL for cluster '\"cluster\"' saved on \"sysid\" in dataset\"\nQueue \" '\"hlq\".$REORGVS.SUBMIT.JCLFILE.FS\"fseq\"' ...\"\nQueue \" \"\nQueue \"Backup Image of cluster '\"cluster\"' saved on \"sysid\" in dataset\"\nQueue \" '\"hlq\".$REORGVS.EXPORT.IMAGE.FS\"fseq\"' ...\"\nQueue \" \"\nSignal End_Up\n\nGet_date_and_time:\n/*  Date and Time Retrieval internal subroutine                      */\ntime     = time()\nsdate    = date(u)\nIf substr(sdate,7,2) > '70' then cen = '19'\nElse                             cen = '20'\ndate     = ''substr(sdate,1,6)''cen''substr(sdate,7,2)''\njuldate  = ''cen''date(julian)''\nReturn\n\nCheck_Cataloged:\ncatlged  = SYSDSN(\"'\"cluster\"'\")\nReturn\n\nCheck_Prim_Sec:\nrtcd = 0\nIf prim_alc_adjust <> 0                                 Then Do\n   len_pri = LENGTH(prim_alc_adjust)\n   pri_num = SUBSTR(prim_alc_adjust,2,len_pri - 1)\n   If SUBSTR(prim_alc_adjust,1,1) <> \"+\" & ,\n      SUBSTR(prim_alc_adjust,1,1) <> \"-\"           Then Do\n      pmsg = \"Leading Plus (+) or Minus (-) Sign Omitted\",\n          \"on Primary Allocation % Adjustment parm\"\n      zedsmsg = \"Value passed is =>\" prim_alc_adjust\n      zedlmsg = \"Syntax is => PRI(+NNN) or PRI(-NNN)\"\n      csrfield = \"PRIMARY\"\n      rtcd = 12\n      Return\n   End\n   If DATATYPE(pri_num,\"W\") = 0 | LENGTH(pri_num) > 3   Then Do\n      pmsg = \"Invalid Primary Allocation Adjustment % parm Passed =>\",\n           prim_alc_adjust\n      zedsmsg = \"Syntax is => PRI(+NNN) or PRI(-NNN)\"\n      zedlmsg = \"Adjustment Value must be numeric and must not exceed\",\n           \"3 digits in length\"\n      csrfield = \"PRIMARY\"\n      rtcd = 12\n      Return\n   End\nEnd\n\nprimary_lit  = \"PRI(\"||prim_alc_adjust||\")\"\n\nIf sec_alc_adjust <> 0                                  Then Do\n   len_sec = LENGTH(sec_alc_adjust)\n   sec_num = SUBSTR(sec_alc_adjust,2,len_sec - 1)\n   If SUBSTR(sec_alc_adjust,1,1) <> \"+\" & ,\n      SUBSTR(sec_alc_adjust,1,1) <> \"-\"            Then Do\n      pmsg = \"Leading Plus (+) or Minus (-) Sign Omitted\",\n          \"on Secondary Allocation % Adjustment parm\"\n      zedsmsg = \"Value passed is =>\" sec_alc_adjust\n      zedlmsg = \"Syntax is => SEC(+NNN) or SEC(-NNN)\"\n      csrfield = \"SECONDY\"\n      rtcd = 12\n      Return\n   End\n   If DATATYPE(sec_num,\"W\") = 0 | LENGTH(sec_num) > 3   Then Do\n      pmsg = \"Invalid Secondary Allocation Adjustment % parm Passed =>\",\n           sec_alc_adjust\n      zedsmsg = \"Syntax is => SEC(+NNN) or SEC(-NNN)\"\n      zedlmsg = \"Adjustment Value must be numeric and must not exceed\",\n           \"3 digits in length\"\n      csrfield = \"SECONDY\"\n      rtcd = 12\n      Return\n   End\nEnd\n\nsecondary_lit  = \"SEC(\"||sec_alc_adjust||\")\"\n\nReturn\n\nEnd_Up:\n\nAddress 'TSO'\n\"EXECIO 0 DISKR JCL      (FINIS\"\n\"EXECIO 0 DISKW SUBMITFL (FINIS\"\n\"FREE  FI(PARMFILE) DA('\"||PARMFILE_File||\"')\"\n\"FREE FI(SUBMITFL) DA('\"||SUBMIT_File||\"')\"\n\"FREE DA('\"||SUBMIT_File||\"')\"\n\"FREE FI(SYSUT1 SYSUT2 SYSIN SYSPRINT SYSUDUMP)\"\n\npmsg = \"REORGVS exec return code is =>\" rtcd\nQueue \" \"\nQueue pmsg\nQueue \"\"\n\nIf envirnmt  = \"BACK\" & panel_end = \"N\" Then Do\n   Do i = 1 to Queued()\n      Pull line.i\n         Say line.i\n   End\nEnd\n\nIf envirnmt <> \"BACK\" & panel_end = \"N\" Then Do\n   Do i = 1 To 20\n      Interpret 'LINE'i' = \"\"'\n   End\n   Do i = 1 To Queued()\n      Pull line.i\n      Interpret 'LINE'i' = LINE.'i\n   End\n   zcmd     = ''\n   Address 'ISPEXEC'\n   \"DISPLAY PANEL(REORGPN2)\"\n   rtcd     = rc\n   Address 'TSO'\n   If rtcd <> 8  Then Signal Reorg_Vsam_Dataset\n   Address 'ISPEXEC'\n   \"LIBDEF ISPPLIB\"\n   \"LIBDEF ISPMLIB\"\n   Address 'TSO'\nEnd\n\n\"DELSTACK\"\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVS1": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x01\\x01\\x06\\x01o\\x01\\x08&\\x0f\\x12%\\x00\\xb9\\x00\\xa3\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2006-01-16T00:00:00", "modifydate": "2008-09-16T12:25:01", "lines": 185, "newlines": 163, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVS1   (Recreate a VSAM Cluster - Used with the     */\n/*                        REORGVS exec).                              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/04/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/16/2008                         */\n/*                                                                    */\n/*  PURPOSE = This exec will build IDCAMS commands to recreate a      */\n/*            VSAM cluster.  It will build the \"LISTC ALL ENT\"        */\n/*            commands to generate an IDCAMS catalog listing          */\n/*            SYSPRINT report and it will also build IDCAMS           */\n/*            \"EXPORT\" commands to export and reimport the cluster    */\n/*            data.                                                   */\n/*                                                                    */\n/*            Input File LIST must be preallocated prior to the       */\n/*            execution of this exec.  This file contains the         */\n/*            dataset names of the VSAM clusters to be reallocated.   */\n/*                                                                    */\n/*            File EXPORT is the IDCAMS Export image dataset name.    */\n/*                                                                    */\n/*            File COMMANDS contains the IDCAMS commands generated by */\n/*            this exec.                                              */\n/*                                                                    */\n/*            Output Files EXPORT, COMMANDS, and IMPORT               */\n/*            must be preallocated prior to the execution of this     */\n/*            exec.                                                   */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*                                                                    */\n/*  Modifications/Tailoring:                                          */\n/*                                                                    */\n/*  Make the following modification before storing this Rexx exec.    */\n/*                                                                    */\n/*  1)        Change the length of \"sysid\" to your specification.     */\n/*            The default is 3 characters if this is not              */\n/*            modified.                                               */\n/*                                                                    */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Invalid input or output files or the files were not       */\n/*          preallocated properly.                                    */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.08\"\nArg parms\nTrace \"O\"\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nuserid        = Userid()\nrtcd          = 0\nsysid         = Left(MVSVAR(sysname),3,\" \")\ninput_count   = 0\n\nGet_Input_Datasets:\n\n\"EXECIO 1 DISKR LIST     (STEM list. \"\nexeciorc     = rc\nIf execiorc  = 2   Then ,        /* On end of file - Finish up  */\n   Signal End_Up\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"LIST !!!\"\n   Say \"File LIST was not properly preallocated or is invalid\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS1 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\ninput_count = input_count + 1\n\ndsn     = STRIP(WORD(list.1,1))\n\nOutput_EXPORT_Out_Record:\n\nexport.1    = \"  EXPORT '\"||STRIP(dsn)||\"'   +\"\nexport.2    = \"          OUTFILE(IMAGE)  TEMPORARY\"\nexport.3    = \"                                   \"\nexport.4    = \"  SET MAXCC=0\"\n\n\"EXECIO 4 DISKW EXPORT (STEM export. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"EXPORT !!!\"\n   Say \"File EXPORT was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS1 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\n\nOutput_LISTC_Record:\n\ncommands.1  = \"  LISTC ALL ENT('\"||STRIP(dsn)||\"')\"\n\n\"EXECIO 1 DISKW COMMANDS (STEM commands. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"COMMANDS !!!\"\n   Say \"File COMMANDS was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS1 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\n\nOutput_IMPORT_In_Record:\n\nimport.1    = \"  IMPORT INFILE(IMAGE)  INTOEMPTY   +\"\nimport.2    = \"     ODS('\"||STRIP(dsn)||\"')\"\n\n\"EXECIO 2 DISKW IMPORT (STEM import. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"IMPORT !!!\"\n   Say \"File IMPORT was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS1 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nSignal Get_Input_Datasets\n\nEnd_Up:\n\n\"EXECIO 0 DISKR LIST      (FINIS\"\nexport.1     = \"  \"\n\"EXECIO 1 DISKW EXPORT    (STEM export.\"\n\"EXECIO 0 DISKW EXPORT    (FINIS\"\ncommands.1   = \"  \"\n\"EXECIO 1 DISKW COMMANDS  (STEM commands.\"\n\"EXECIO 0 DISKW COMMANDS  (FINIS\"\nimport.1     = \"  \"\n\"EXECIO 1 DISKW IMPORT    (STEM import.\"\n\"EXECIO 0 DISKW IMPORT    (FINIS\"\n\nSay ;\nSay \"REORGVS1 Exec - Build IDCAMS Commands ...\"\nSay ;\nSay \"version_level                =>\" version_level\nSay ;\nSay \"Dataset Input Count is         \" input_count\nSay ;\nSay \"REORGVS1 exec return code is   \" rtcd\nSay ;\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVS2": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x014\\x00\\x08\\x01\\x06\\x03\\x1f\\x01\\x08&\\x0f\\x12%\\x04\\x1a\\x03\\xa5\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.52", "flags": 0, "createdate": "2006-01-31T00:00:00", "modifydate": "2008-09-16T12:25:08", "lines": 1050, "newlines": 933, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVS2   (Recreate a VSAM Cluster - Used with the     */\n/*                        REORGVS exec).                              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/04/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/16/2008                         */\n/*                                                                    */\n/*  PURPOSE                                                           */\n/*                                                                    */\n/*            The exec will input an IDCAMS LISTC SYSPRINT file and   */\n/*            will parse out the appropriate parameters to recreate   */\n/*            a VSAM cluster.                                         */\n/*                                                                    */\n/*            Input File SYSPRINT must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            The exec will also input a PARMFILE which is passed     */\n/*            from exec REORGVS.  It can be empty or it can contain   */\n/*            parms passed from exec REORGVS:                         */\n/*                PRI(+/-nnn) and/or SEC(+/-nnn).                     */\n/*            If the PRI(+NNN) or SEC(+NNN) execution parameters      */\n/*            are passed upon invocation, the exec will input         */\n/*            a PARMFILE file.  Otherwise, this file will be empty.   */\n/*            The PARMFILE contains two parameters to be used to      */\n/*            adjust the PRIMARY and SECONDARY allocation values      */\n/*            (either increase or decrease the values by a percentage */\n/*            adjustment.  Syntax is PRI(+nnn) or PRI(-nnn) and       */\n/*            SEC(+nnn) or SEC(-nnn). This parmfile record is         */\n/*            optional (i.e., the file may be empty)                  */\n/*                                                                    */\n/*            Input File PARMFILE must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            Output File DEFINES must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            Output File AIXCMDS must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            The output of this exec will be a stream of IDCAMS      */\n/*            DEFINE CLUSTER commands which will be used to           */\n/*            recreate a VSAM cluster.                                */\n/*                                                                    */\n/*            If there are any AIX files associated to the VSAM       */\n/*            cluster, this exec will output LISTC ENT ALL(AIXdsn)    */\n/*            comands to the AIX output file.  Otherwise, this file   */\n/*            will be empty.                                          */\n/*                                                                    */\n/*                                                                    */\n/*  (Optional Input Parms on Input File PARMFILE):                    */\n/*                                                                    */\n/*       PRI(+NNN) = This parameter increases or decreases the        */\n/*    or PRI(-NNN)   primary space allocation for the cluster         */\n/*                   (relative to what it was before).                */\n/*                   The syntax is: +nnn or -nnn.  nnn must be        */\n/*                   numeric value between 1 and 999 and must be      */\n/*                   preceded with either a \"+\" or \"-\". nnn           */\n/*                   represents a percentage value of increase or     */\n/*                   decrease against the previous primary            */\n/*                   allocation value.                                */\n/*                                                                    */\n/*       SEC(+NNN) = This parameter increases or decreases the        */\n/*    or SEC(-NNN)   secondary space allocation for the cluster       */\n/*                   (relative to what it was before).                */\n/*                   The syntax is: +nnn or -nnn.  nnn must be        */\n/*                   numeric value between 1 and 999 and must be      */\n/*                   preceded with either a \"+\" or \"-\". nnn           */\n/*                   represents a percentage value of increase or     */\n/*                   decrease against the previous secondary          */\n/*                   allocation value.                                */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*                                                                    */\n/*  Modifications/Tailoring:                                          */\n/*                                                                    */\n/*  Make the following modification before storing this Rexx exec.    */\n/*                                                                    */\n/*  1)        Change the length of \"sysid\" to your specification.     */\n/*            The default is 3 characters if this is not              */\n/*            modified.                                               */\n/*                                                                    */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Invalid SYSPRINT input file or SYSPRINT file was not      */\n/*          preallocated or Invalid DEFINES, REPORT, or AIXCMDS files */\n/*          or these files were not preallocated.                     */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.08\"\nArg parms\nTrace \"O\"\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nuserid             = Userid()\nrtcd               = 0\nsysid              = Left(MVSVAR(sysname),3,\" \")\nparmfile_count     = 0\ncmd_count          = 0\ninput_count        = 0\ndef_output_count   = 0\naix_output_count   = 0\nprint_count        = 0\nline_count         = 99\n\nlitdel        = \"  DELETE \"\nlit2          = \"  IF LASTCC = 8           \"\nlit3          = \"    THEN IF MAXCC LT 12   \"\nlit4          = \"      THEN SET MAXCC = 0  \"\nlit5          = \"  DEFINE                  \"\nlitclus       = \"    CLUSTER (NAME(\"\nindent        = \"            \"\nlitdata       = \"       DATA (NAME(\"\nlitindx       = \"      INDEX (NAME(\"\nfiller        = Copies(\" \",80)\n\nheading_1     = \"   VSAM Cluster Dataset Allocation Information\"\nheading_2     = \"   VSAM Cluster                                Data\",\n                \"  Managemt Storage  Data\"\nheading_3     = \"   Dataset Name                               Volser\",\n                \"  Class    Class   Class\"\n\nGet_Invocation_Parms:\n\nprim_alc_adjust      = 0\nsec_alc_adjust       = 0\nprim_adj_round       = +.5\nsec_adj_round        = +.5\n\n\"EXECIO 1 DISKR PARMFILE (STEM parmfile. FINIS \"\nexeciorc     = rc\n\nIf execiorc  = 2   Then ,        /* On end of file - Go On      */\n   Signal Read_SYSPRINT_Loop\n\nparmfile_count = parmfile_count + 1\n\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"PARMFILE !!!\"\n   Say \"File PARMFILE was not properly preallocated or is invalid\",\n   Say \"Input I/O count is \" parmfile_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS2 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nparm_rec = parmfile.1\n\nParse var parm_rec \"PRI(\" parse_value \")\"\nIf parse_value <> \"\" & prim_alc_adjust = 0        Then Do\n   prim_alc_adjust = parse_value\n   Say ;\n   Say \"Primary   Allocation Adjustment Percentage =\" prim_alc_adjust\n   If SUBSTR(prim_alc_adjust,1,1) = \"-\"           Then ,\n      prim_adj_round = -.5\nEnd\n\nParse var parm_rec \"SEC(\" parse_value \")\"\nIf parse_value <> \"\" & sec_alc_adjust = 0         Then Do\n   sec_alc_adjust = parse_value\n   Say ;\n   Say \"Secondary Allocation Adjustment Percentage =\" sec_alc_adjust\n   If SUBSTR(sec_alc_adjust,1,1) = \"-\"            Then ,\n      sec_adj_round = -.5\nEnd\n\nRead_SYSPRINT_Loop:\n\ninput_count = input_count + 1\n\n\"EXECIO 1 DISKR SYSPRINT (STEM sysprint. \"\nexeciorc     = rc\nIf execiorc  = 2   Then ,        /* On end of file - Finish up  */\n   Signal End_Up\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"SYSPRINT !!!\"\n   Say \"File SYSPRINT was not properly preallocated or is invalid\",\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS2 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\np1  = POS(\"LISTC ALL ENT\",sysprint.1)\nIf p1  > 0                                         Then Do\n   Call   Initialize_Variables\n   Signal Read_SYSPRINT_Loop\nEnd\n\nnf  = POS(\" NOT FOUND \",sysprint.1)\nIf nf  > 0                                         Then ,\n   not_fnd = \"Y\"\n\nIf not_fnd = \"Y\"                                   Then ,\n   Signal Read_SYSPRINT_Loop\n\np2  = POS(\"CLUSTER -------\",sysprint.1)\nIf p2  > 0  & level = \"\"                           Then Do\n   cluster     = SUBSTR(sysprint.1,p2 + 16,44)\n   cluster     = STRIP(cluster,both)\n   level       = \"CLUSTER\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np2a = POS(\"AIX------\",sysprint.1)\nIf p2a > 0  & level = \"CLUSTER\"                    Then Do\n   aix         = SUBSTR(sysprint.1,p2a + 9,44)\n   aix         = STRIP(aix,both)\n   Call Output_AIX_LISTC_Record\n   Signal Read_SYSPRINT_Loop\nEnd\n\np3  = POS(\" DATA -------\",sysprint.1)\nIf p3  > 0  & level = \"CLUSTER\"                    Then Do\n   data        = SUBSTR(sysprint.1,p3 + 14,44)\n   data        = STRIP(data,both)\n   level       = \"DATA\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np4  = POS(\" KEYLEN------\",sysprint.1)\nIf p4  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p4 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   keylen      = STRIP(parse_it,leading,\"0\")\n   If keylen   = \"\"  Then keylen       = 0\nEnd\n\np5  = POS(\" AVGLRECL----\",sysprint.1)\nIf p5  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p5 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   avglrecl    = STRIP(parse_it,leading,\"0\")\n   If avglrecl = \"\"  Then avglrecl     = 0\nEnd\n\np6  = POS(\" BUFSPACE----\",sysprint.1)\nIf p6  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p6 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   buffer      = STRIP(parse_it,leading,\"0\")\n   If buffer   = \"\"  Then buffer       = 0\nEnd\n\np7  = POS(\" CISIZE----\",sysprint.1)\nIf p7  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p7 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   dcisize     = STRIP(parse_it,leading,\"0\")\n   If dcisize  = \"\"  Then dcisize      = 0\nEnd\n\np8  = POS(\" RKP---------\",sysprint.1)\nIf p8  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p8 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   rkp         = STRIP(parse_it,leading,\"0\")\n   If rkp      = \"\"  Then rkp          = 0\nEnd\n\np9  = POS(\" MAXLRECL----\",sysprint.1)\nIf p9  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p9 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   maxlrecl    = STRIP(parse_it,leading,\"0\")\n   If maxlrecl = \"\"  Then maxlrecl     = 0\nEnd\n\np10 = POS(\" SHROPTNS(\",sysprint.1)\nIf p10 > 0  & level = \"DATA\"                       Then Do\n   shr_opt1    = SUBSTR(sysprint.1,p10 + 10,1)\n   shr_opt2    = SUBSTR(sysprint.1,p10 + 12,1)\nEnd\n\nptype_e  = POS(\" NONINDEXED\",sysprint.1)\nptype_k  = POS(\" INDEXED\",sysprint.1)\nptype_l  = POS(\" LINEAR\",sysprint.1)\nptype_n  = POS(\" NUMBERED\",sysprint.1)\n\nIf ptype_e > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"NONINDEXED\"\nEnd\n\nIf ptype_k > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"INDEXED\"\nEnd\n\nIf ptype_l > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"LINEAR\"\nEnd\n\nIf ptype_n > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"NUMBERED\"\nEnd\n\np11 = POS(\" SPEED \",sysprint.1)\nIf p11 > 0  & level = \"DATA\"                       Then Do\n   spd_rec     = \"SPEED\"\nEnd\n\np12 = POS(\" RECOVERY \",sysprint.1)\nIf p12 > 0  & level = \"DATA\"                       Then Do\n   spd_rec     = \"RECOVERY\"\nEnd\n\np13 = POS(\" STORAGECLASS\",sysprint.1)\nIf p13 > 0  & level = \"CLUSTER\"       & ,\n   SUBSTR(sysprint.1,p13 + 17,8) <> \"--(NULL)\"     Then Do\n      sc          = SUBSTR(sysprint.1,p13 + 17,8)\n      sc          = TRANSLATE(sc,\" \",\"-\")\n      sc          = STRIP(sc)\nEnd\n\np14 = POS(\" MANAGEMENTCLASS\",sysprint.1)\nIf p14 > 0  & level = \"CLUSTER\"       & ,\n   SUBSTR(sysprint.1,p14 + 17,8) <> \"--(NULL)\"     Then Do\n      mc          = SUBSTR(sysprint.1,p14 + 17,8)\n      mc          = TRANSLATE(mc,\" \",\"-\")\n      mc          = STRIP(mc)\nEnd\n\np15 = POS(\" DATACLASS\",sysprint.1)\nIf p15 > 0  & level = \"CLUSTER\"       & ,\n   SUBSTR(sysprint.1,p15 + 17,8) <> \"--(NULL)\"     Then Do\n      dc          = SUBSTR(sysprint.1,p15 + 17,8)\n      dc          = TRANSLATE(dc,\" \",\"-\")\n      dc          = STRIP(dc)\nEnd\n\np17 = POS(\" NOREUSE\",sysprint.1)\nIf p17 > 0  & level = \"DATA\"                       Then Do\n   reuse       = \"NOREUSE\"\nEnd\n\np18 = POS(\" REUSE\",sysprint.1)\nIf p18 > 0  & level = \"DATA\"                       Then Do\n   reuse       = \"REUSE\"\nEnd\n\np19 = POS(\" NONSPANNED\",sysprint.1)\nIf p19 > 0  & level = \"DATA\"                       Then Do\n   spanned     = \"NONSPANNED\"\nEnd\n\np20 = POS(\" SPANNED\",sysprint.1)\nIf p20 > 0  & level = \"DATA\"                       Then Do\n   spanned        = \"SPANNED\"\nEnd\n\np21 = POS(\" FREESPACE-\",sysprint.1)\nSelect\n   When p21   <= 0                                 Then Nop\n   When level <> \"DATA\"                            Then Nop\n   When SUBSTR(sysprint.1,p21 + 12,2) = \"CI\"       Then Do\n        parse_it    = SUBSTR(sysprint.1,p21 + 17,8)\n        parse_it    = STRIP(parse_it,both)\n        parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n        fs_ci       = STRIP(parse_it,leading,\"0\")\n        If fs_ci    = \"\"  Then fs_ci = 0\n   End\n   When SUBSTR(sysprint.1,p21 + 12,2) = \"CA\"       Then Do\n        parse_it    = SUBSTR(sysprint.1,p21 + 17,8)\n        parse_it    = STRIP(parse_it,both)\n        parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n        fs_ca       = STRIP(parse_it,leading,\"0\")\n        If fs_ca    = \"\"  Then fs_ca = 0\n   End\n   Otherwise Nop\nEnd\n\np22 = POS(\" UNORDERED\",sysprint.1)\nIf p22 > 0  & level = \"DATA\"                       Then Do\n   ordered     = \"UNORDERED\"\nEnd\n\np22b = POS(\" ORDERED\",sysprint.1)\nIf p22b > 0  & level = \"DATA\"                       Then Do\n   ordered        = \"ORDERED\"\nEnd\n\np22c = POS(\" NOERASE\",sysprint.1)\nIf p22c > 0  & level = \"DATA\"                       Then Do\n   erase       = \"NOERASE\"\nEnd\n\np22d = POS(\" ERASE\",sysprint.1)\nIf p22d > 0  & level = \"DATA\"                       Then Do\n   erase          = \"ERASE\"\nEnd\n\np23 = POS(\" SPACE-TYPE-----\",sysprint.1)\nIf p23 > 0  & level = \"DATA\"                       Then Do\n   dsp_type       = SUBSTR(sysprint.1,p23 + 17,8)\n   dsp_type       = TRANSLATE(dsp_type,\" \",\"-\")\n   dsp_type       = STRIP(dsp_type)\nEnd\n\np24 = POS(\" SPACE-PRI------\",sysprint.1)\nIf p24 > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p24 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   dprim       = TRANSLATE(parse_it,\"0\",\"-\")\n   dprim       = dprim + (dprim * prim_alc_adjust / 100) + ,\n                     prim_adj_round\n   parse_it    = TRUNC(dprim)\n   dprim       = STRIP(parse_it,leading,\"0\")\n   If dprim    = \"\"  Then dprim        = 0\nEnd\n\np25 = POS(\" SPACE-SEC------\",sysprint.1)\nIf p25 > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p25 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   dsec        = TRANSLATE(parse_it,\"0\",\"-\")\n   dsec        = dsec  + (dsec  * sec_alc_adjust / 100) + ,\n                     sec_adj_round\n   parse_it    = TRUNC(dsec)\n   dsec        = STRIP(parse_it,leading,\"0\")\n   If dsec     = \"\"  Then dsec         = 0\nEnd\n\np26 = POS(\" VOLSER------\",sysprint.1)\nIf p26 > 0  & level = \"DATA\" & dvolser = \"\"        Then Do\n   dvolser     = SUBSTR(sysprint.1,p26 + 19,6)\nEnd\n\nIf p26 > 0  & SUBSTR(sysprint.1,p26 + 19,6) = \"MIGRAT\"    Then Do\n   not_fnd = \"Y\"\nEnd\n\np27 = POS(\" NOWRITECHK\",sysprint.1)\nIf p27 > 0  & level = \"DATA\"                       Then Do\n   writechk    = \"NOWRITECHECK\"\nEnd\n\np28 = POS(\" WRITECHK\",sysprint.1)\nIf p28 > 0  & level = \"DATA\"                       Then Do\n   writechk    = \"WRITECHECK\"\nEnd\n\n/*  UNIQUE and SUALLOCATION keywords are no longer used           */\n/*  variables unique_sub and lit15 have been deleted  05/24/2006  */\n/*                                                                */\n/*  p29 = POS(\" UNIQUE\",sysprint.1)                               */\n/*  If p29 > 0  & level = \"DATA\"                       Then Do    */\n/*     unique_sub  = \"UNIQUE\"                                     */\n/*  End                                                           */\n/*                                                                */\n/*  p29b = POS(\" SUBALLOCATION\",sysprint.1)                       */\n/*  If p29b > 0  & level = \"DATA\"                       Then Do   */\n/*     unique_sub  = \"SUBALLOCATION\"                              */\n/*  End                                                           */\n\np30 = POS(\" INDEX -----\",sysprint.1)\nIf p30 > 0  & level = \"DATA\"                       Then Do\n   index       = SUBSTR(sysprint.1,p30 + 14,44)\n   index       = STRIP(index)\n   level       = \"INDEX\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np31 = POS(\" CISIZE----\",sysprint.1)\nIf p31 > 0  & level = \"INDEX\"                      Then Do\n   parse_it    = SUBSTR(sysprint.1,p31 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   icisize     = STRIP(parse_it,leading,\"0\")\n   If icisize  = \"\"  Then icisize      = 0\nEnd\n\np32 = POS(\" SPACE-TYPE-----\",sysprint.1)\nIf p32 > 0  & level = \"INDEX\"                      Then Do\n   isp_type       = SUBSTR(sysprint.1,p32 + 17,8)\n   isp_type       = TRANSLATE(isp_type,\" \",\"-\")\n   isp_type       = STRIP(isp_type)\nEnd\n\np33 = POS(\" SPACE-PRI------\",sysprint.1)\nIf p33 > 0  & level = \"INDEX\"                      Then Do\n   parse_it    = SUBSTR(sysprint.1,p33 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   iprim       = STRIP(parse_it,leading,\"0\")\n   If iprim    = \"\"  Then iprim        = 0\nEnd\n\np34 = POS(\" SPACE-SEC------\",sysprint.1)\nIf p34 > 0  & level = \"INDEX\"                      Then Do\n   parse_it    = SUBSTR(sysprint.1,p34 + 17,8)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   isec        = STRIP(parse_it,leading,\"0\")\n   If isec     = \"\"  Then isec         = 0\nEnd\n\np35 = POS(\" VOLSER------\",sysprint.1)\nIf p35 > 0  & level = \"INDEX\"                      Then Do\n   ivolser     = SUBSTR(sysprint.1,p35 + 19,6)\nEnd\n\np99 = POS(\"HIGHEST CONDITION CODE\",sysprint.1)\n\n/* END OF LISTCAT FUNCTION FOR THIS DATASET ?               */\n\nSelect\n   When not_fnd = \"Y\"                              Then ,\n        Signal Read_SYSPRINT_Loop\n   When p99 <= 0                                   Then ,\n        Signal Read_SYSPRINT_Loop\n   Otherwise Nop\nEnd\n\n\nBuild_DEFINE_CLUSTER_Commands:\n\nlit                = litdel||STRIP(cluster)\nlit1               = LEFT(lit,80,\" \")\nlit1               = OVERLAY(\"CLUSTER PURGE\",lit1,55,13)\n\nlit2               = LEFT(lit2,80,\" \")\nlit2               = OVERLAY(\"-\",lit2,65,1)\n\nlit3               = LEFT(lit3,80,\" \")\nlit3               = OVERLAY(\"-\",lit3,65,1)\n\nlit4               = LEFT(lit4,80,\" \")\nlit4               = OVERLAY(\"-\",lit4,65,1)\n\nlit5               = LEFT(lit5,80,\" \")\nlit5               = OVERLAY(\"-\",lit5,65,1)\n\nlit                = litclus||STRIP(cluster)||\")\"\nlit6               = LEFT(lit,80,\" \")\nlit6               = OVERLAY(\"-\",lit6,65,1)\n\nlit                = indent||type_vs\nlit7               = LEFT(lit,80,\" \")\nlit7               = OVERLAY(\"-\",lit7,65,1)\n\nlit                = indent||STRIP(reuse)\nlit8               = LEFT(lit,80,\" \")\nlit8               = OVERLAY(\"-\",lit8,65,1)\n\nlit                = indent||\"STORAGECLASS(\"||STRIP(sc)||\")\"\nlit9               = LEFT(lit,80,\" \")\nlit9               = OVERLAY(\"-\",lit9,65,1)\n\nlit                = indent||\"MANAGEMENTCLASS(\"||STRIP(mc)||\")\"\nlit10              = LEFT(lit,80,\" \")\nlit10              = OVERLAY(\"-\",lit10,65,1)\n\nlit                = indent||\"DATACLASS(\"||STRIP(dc)||\")\"\nlit11              = LEFT(lit,80,\" \")\nlit11              = OVERLAY(\"-\",lit11,65,1)\n\nlit                = indent||STRIP(spd_rec)\nlit12              = LEFT(lit,80,\" \")\nlit12              = OVERLAY(\"-\",lit12,65,1)\n\nlit                = indent||\"SHAREOPTIONS(\"||STRIP(shr_opt1)||,\n                        \",\"||STRIP(shr_opt2)||\")\"\nlit13              = LEFT(lit,80,\" \")\nlit13              = OVERLAY(\"-\",lit13,65,1)\n\nlit                = indent||STRIP(writechk)\nlit14              = LEFT(lit,80,\" \")\nlit14              = OVERLAY(\"-\",lit14,65,1)\n\nlit                = indent||STRIP(spanned)\nlit16              = LEFT(lit,80,\" \")\nlit16              = OVERLAY(\"-\",lit16,65,1)\n\nlit                = indent||STRIP(ordered)\nlit17              = LEFT(lit,80,\" \")\nlit17              = OVERLAY(\"-\",lit17,65,1)\n\nlit                = indent||STRIP(erase)\nlit18              = LEFT(lit,80,\" \")\nlit18              = OVERLAY(\"-\",lit18,65,1)\n\nlit                = indent||\")\"\nlit19              = LEFT(lit,80,\" \")\nlit19              = OVERLAY(\"-\",lit19,65,1)\n\nlit                = litdata||STRIP(data)||\")\"\nlit20              = LEFT(lit,80,\" \")\nlit20              = OVERLAY(\"-\",lit20,65,1)\n\nlit                = indent||\"VOLUMES(\"||STRIP(dvolser)||\")\"\nlit21              = LEFT(lit,80,\" \")\nlit21              = OVERLAY(\"-\",lit21,65,1)\n\nlit                = indent||\"FREESPACE(\"||STRIP(fs_ci)||\" \"||,\n                        STRIP(fs_ca)||\")\"\nlit22              = LEFT(lit,80,\" \")\nlit22              = OVERLAY(\"-\",lit22,65,1)\n\nlit                = indent||\"BUFFERSPACE(\"||STRIP(buffer)||\")\"\nlit23              = LEFT(lit,80,\" \")\nlit23              = OVERLAY(\"-\",lit23,65,1)\n\nlit                = indent||STRIP(dsp_type)||\"S\"||\"(\"||,\n                        STRIP(dprim)||\" \"||STRIP(dsec)||\")\"\nlit24              = LEFT(lit,80,\" \")\nlit24              = OVERLAY(\"-\",lit24,65,1)\n\nlit                = indent||\"RECORDSIZE(\"||STRIP(AVGLRECL)||,\n                        \" \"||STRIP(maxlrecl)||\")\"\nlit25              = LEFT(lit,80,\" \")\nlit25              = OVERLAY(\"-\",lit25,65,1)\n\nlit                = indent||\"KEYS(\"||STRIP(keylen)||\" \"||,\n                        STRIP(rkp)||\")\"\nlit26              = LEFT(lit,80,\" \")\nlit26              = OVERLAY(\"-\",lit26,65,1)\n\nlit                = indent||\"CONTROLINTERVALSIZE(\"||STRIP(dcisize)||,\n                        \")\"\nlit27              = LEFT(lit,80,\" \")\nlit27              = OVERLAY(\"-\",lit27,65,1)\n\nlit                = indent||\")\"\nlit28              = LEFT(lit,80,\" \")\nlit28              = OVERLAY(\"-\",lit28,65,1)\n\nlit                = litindx||STRIP(index)||\")\"\nlit29              = LEFT(lit,80,\" \")\nlit29              = OVERLAY(\"-\",lit29,65,1)\n\nlit                = indent||\"VOLUMES(\"||STRIP(ivolser)||\")\"\nlit30              = LEFT(lit,80,\" \")\nlit30              = OVERLAY(\"-\",lit30,65,1)\n\nlit                = indent||STRIP(isp_type)||\"S\"||\"(\"||,\n                        STRIP(iprim)||\" \"||STRIP(isec)||\")\"\nlit31              = LEFT(lit,80,\" \")\nlit31              = OVERLAY(\"-\",lit31,65,1)\n\nlit                = indent||\"CONTROLINTERVALSIZE(\"||STRIP(icisize)||,\n                        \")\"\nlit32              = LEFT(lit,80,\" \")\nlit32              = OVERLAY(\"-\",lit32,65,1)\n\nlit33              = indent||\")\"\n\n/****************  Debugging  Start  *********************************/\n\n    Say ;\n    Say \"REORGVS2 Exec - Cluster Component Information ...\"\n    Say ;\n    Say \"version_level  = \"  version_level\n    Say ;\n    Say \"not_fnd        = \"  not_fnd\n    Say \"level          = \"  level\n    Say \"cluster        = \"  cluster\n    Say \"aix            = \"  aix\n    Say \"data           = \"  data\n    Say \"index          = \"  index\n    Say \"reuse          = \"  reuse\n    Say \"dc             = \"  dc\n    Say \"sc             = \"  sc\n    Say \"mc             = \"  mc\n    Say \"type_vs        = \"  type_vs\n    Say \"spanned        = \"  spanned\n    Say \"erase          = \"  erase\n    Say \"ordered        = \"  ordered\n    Say \"writechk       = \"  writechk\n    Say \"spd_rec        = \"  spd_rec\n    Say \"shr_opt1       = \"  shr_opt1\n    Say \"shr_opt2       = \"  shr_opt2\n    Say \"fs_ci          = \"  fs_ci\n    Say \"fs_ca          = \"  fs_ca\n    Say \"buffer         = \"  buffer\n    Say \"dsp_type       = \"  dsp_type\n    Say \"dprim          = \"  dprim\n    Say \"dsec           = \"  dsec\n    Say \"dvolser        = \"  dvolser\n    Say \"avglrecl       = \"  avglrecl\n    Say \"maxlrecl       = \"  maxlrecl\n    Say \"rkp            = \"  rkp\n    Say \"keylen         = \"  keylen\n    Say \"dcisize        = \"  dcisize\n    Say \"isp_type       = \"  isp_type\n    Say \"iprim          = \"  iprim\n    Say \"isec           = \"  isec\n    Say \"icisize        = \"  icisize\n    Say \"ivolser        = \"  ivolser\n    Say \"lit1    =\"  lit1\n    Say \"lit2    =\"  lit2\n    Say \"lit3    =\"  lit3\n    Say \"lit4    =\"  lit4\n    Say \"lit5    =\"  lit5\n    Say \"lit6    =\"  lit6\n    Say \"lit7    =\"  lit7\n    Say \"lit8    =\"  lit8\n    Say \"lit9    =\"  lit9\n    Say \"lit10   =\"  lit10\n    Say \"lit11   =\"  lit11\n    Say \"lit12   =\"  lit12\n    Say \"lit13   =\"  lit13\n    Say \"lit14   =\"  lit14\n    Say \"lit16   =\"  lit16\n    Say \"lit17   =\"  lit17\n    Say \"lit18   =\"  lit18\n    Say \"lit19   =\"  lit19\n    Say \"lit20   =\"  lit20\n    Say \"lit21   =\"  lit21\n    Say \"lit22   =\"  lit22\n    Say \"lit23   =\"  lit23\n    Say \"lit24   =\"  lit24\n    Say \"lit25   =\"  lit25\n    Say \"lit26   =\"  lit26\n    Say \"lit27   =\"  lit27\n    Say \"lit28   =\"  lit28\n    Say \"lit29   =\"  lit29\n    Say \"lit30   =\"  lit30\n    Say \"lit31   =\"  lit31\n    Say \"lit32   =\"  lit32\n    Say \"lit33   =\"  lit33\n\n/****************  Debugging  End    *********************************/\n\nFormat_IDCAMS_Commands:\n\ndefines.1          = lit1\nCall Output_IDCAM_Record\n\ndefines.1          = lit2\nCall Output_IDCAM_Record\n\ndefines.1          = lit3\nCall Output_IDCAM_Record\n\ndefines.1          = lit4\nCall Output_IDCAM_Record\n\ndefines.1          = filler\nCall Output_IDCAM_Record\n\ndefines.1          = lit5\nCall Output_IDCAM_Record\n\ndefines.1          = lit6\nCall Output_IDCAM_Record\n\ndefines.1          = lit7\nCall Output_IDCAM_Record\n\ndefines.1          = lit8\nCall Output_IDCAM_Record\n\nIf sc <> \"        \"              Then Do\n   defines.1          = lit9\n   Call Output_IDCAM_Record\nEnd\n\nIf mc <> \"        \"              Then Do\n   defines.1          = lit10\n   Call Output_IDCAM_Record\nEnd\n\nIf dc <> \"        \"              Then Do\n   defines.1          = lit11\n   Call Output_IDCAM_Record\nEnd\n\ndefines.1          = lit12\nCall Output_IDCAM_Record\n\ndefines.1          = lit13\nCall Output_IDCAM_Record\n\ndefines.1          = lit14\nCall Output_IDCAM_Record\n\ndefines.1          = lit16\nCall Output_IDCAM_Record\n\ndefines.1          = lit17\nCall Output_IDCAM_Record\n\ndefines.1          = lit18\nCall Output_IDCAM_Record\n\ndefines.1          = lit19\nCall Output_IDCAM_Record\n\ndefines.1          = lit20\nCall Output_IDCAM_Record\n\ndefines.1          = lit21\nCall Output_IDCAM_Record\n\nIf type_vs  <> \"LINEAR\"          Then Do\n   defines.1          = lit22\n   Call Output_IDCAM_Record\nEnd\n\ndefines.1          = lit23\nCall Output_IDCAM_Record\n\ndefines.1          = lit24\nCall Output_IDCAM_Record\n\nIf type_vs  <> \"LINEAR\"          Then Do\n   defines.1          = lit25\n   Call Output_IDCAM_Record\nEnd\n\nIf type_vs   = \"INDEXED\"         Then Do\n   defines.1          = lit26\n   Call Output_IDCAM_Record\nEnd\n\ndefines.1          = lit27\nCall Output_IDCAM_Record\n\ndefines.1          = lit28\nCall Output_IDCAM_Record\n\nIf type_vs  <> \"INDEXED\"         Then Do\n   Signal Skip_Indexed\nEnd\n\ndefines.1          = lit29\nCall Output_IDCAM_Record\n\ndefines.1          = lit30\nCall Output_IDCAM_Record\n\ndefines.1          = lit31\nCall Output_IDCAM_Record\n\ndefines.1          = lit32\nCall Output_IDCAM_Record\n\ndefines.1          = lit33\nCall Output_IDCAM_Record\n\nSkip_Indexed:\n\ndefines.1          = filler\nCall Output_IDCAM_Record\n\ncmd_count = cmd_count + 1\n\nSignal Print_VSAM_Alloation_Information\n\n\nOutput_IDCAM_Record:\n\ndef_output_count = def_output_count + 1\n\n\"EXECIO 1 DISKW DEFINES  (STEM defines. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"DEFINES !!!\"\n   Say \"File DEFINES was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"Output I/O count is \" def_output_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS2 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nReturn\n\n\nOutput_AIX_LISTC_Record:\n\naix_output_count = aix_output_count + 1\n\naixcmds.1    = \"  LISTC ALL ENT(\"||STRIP(aix)\")\"\naixcmds.2    = \"  \"\n\n\"EXECIO 2 DISKW AIXCMDS  (STEM aixcmds. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"AIXCMDS !!!\"\n   Say \"File AIXCMDS was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"Output I/O count is \" def_output_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS2 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nReturn\n\n\nPrint_VSAM_Alloation_Information:\n\n  If line_count > 60                    Then Do\n     line_count = 0\n     Call Print_Report_Headings\n  End\n\n  report.1         = COPIES(\" \",80)\n  report.1         = OVERLAY(cluster,report.1,2,44)\n  report.1         = OVERLAY(dvolser,report.1,47,6)\n  report.1         = OVERLAY(mc,report.1,55,8)\n  report.1         = OVERLAY(sc,report.1,64,8)\n  report.1         = OVERLAY(dc,report.1,73,8)\n\n  Call Print_Report_Line\n\n  Signal Read_SYSPRINT_Loop\n\n\nPrint_Report_Headings:\n\n  report.1         = heading_1\n  Call Print_Report_Line\n\n  report.1         = filler\n  Call Print_Report_Line\n\n  report.1         = heading_2\n  Call Print_Report_Line\n\n  report.1         = heading_3\n  Call Print_Report_Line\n\n  report.1         = filler\n  Call Print_Report_Line\n\nReturn\n\n\nPrint_Report_Line:\n\nprint_count = print_count + 1\nline_count  = line_count  + 1\n\n\"EXECIO 1 DISKW REPORT   (STEM report. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"REPORT !!!\"\n   Say \"File REPORT was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"Output Report count is \" print_count\n   Say \"Page   Line   count is \" line_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS2 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\n\nReturn\n\n\nInitialize_Variables:\n\n  not_fnd         = \"\"\n  level           = \"\"\n  cluster         = \"\"\n  aix             = \"\"\n  data            = \"\"\n  index           = \"\"\n  reuse           = \"\"\n  dc              = \"\"\n  sc              = \"\"\n  mc              = \"\"\n  type_vs         = \"\"\n  spanned         = \"\"\n  erase           = \"\"\n  ordered         = \"\"\n  writechk        = \"\"\n  spd_rec         = \"\"\n  shr_opt1        = \"\"\n  shr_opt2        = \"\"\n  fs_ci           = \"\"\n  fs_ca           = \"\"\n  buffer          = \"\"\n  dsp_type        = \"\"\n  dprim           = \"\"\n  dsec            = \"\"\n  dvolser         = \"\"\n  avglrecl        = \"\"\n  maxlrecl        = \"\"\n  rkp             = \"\"\n  keylen          = \"\"\n  dcisize         = \"\"\n  isp_type        = \"\"\n  iprim           = \"\"\n  isec            = \"\"\n  icicize         = \"\"\n  ivolser         = \"\"\n\nReturn\n\n\nEnd_Up:\n\n\"EXECIO 0 DISKR PARMFILE (FINIS\"\n\"EXECIO 0 DISKR SYSPRINT (FINIS\"\n\"EXECIO 0 DISKW REPORT   (FINIS\"\ndefines.1    = \"  \"\n\"EXECIO 1 DISKW DEFINES  (STEM defines.\"\n\"EXECIO 0 DISKW DEFINES  (FINIS\"\naixcmds.1    = \"  \"\n\"EXECIO 1 DISKW AIXCMDS  (STEM aixcmds.\"\n\"EXECIO 0 DISKW AIXCMDS  (FINIS\"\n\nSay ;\nSay \"REORGVS2 exec return code is   \" rtcd\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVS3": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00\\x13\\x01\\x06\\x02\\x0f\\x01\\x08&\\x0f\\x12%\\x04\\x04\\x02\\xf5\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2006-01-20T00:00:00", "modifydate": "2008-09-16T12:25:13", "lines": 1028, "newlines": 757, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVS3   (Recreate a VSAM AIX - Used with the         */\n/*                        REORGVS exec).                              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/20/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/16/2008                         */\n/*                                                                    */\n/*  PURPOSE = This exec will input an IDCAMS LISTC SYSPRINT file and  */\n/*            will parse out the appropriate parameters to recreate   */\n/*            a VSAM aix component.                                   */\n/*                                                                    */\n/*            Input File SYSPRINT must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            Output File DEFINES must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            The output of this exec will be a stream of IDCAMS      */\n/*            DEFINE AIX commands which will be used to               */\n/*            recreate a VSAM aix component.                          */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*                                                                    */\n/*  Modifications/Tailoring:                                          */\n/*                                                                    */\n/*  Make the following modification before storing this Rexx exec.    */\n/*                                                                    */\n/*  1)        Change the length of \"sysid\" to your specification.     */\n/*            The default is 3 characters if this is not              */\n/*            modified.                                               */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Invalid SYSPRINT input file or SYSPRINT file was not      */\n/*          preallocated or Invalid DEFINES or REPORT files or the    */\n/*          files were not preallocated.                              */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.08\"\nArg parms\nTrace \"O\"\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nuserid        = Userid()\nrtcd          = 0\nsysid         = Left(MVSVAR(sysname),3,\" \")\ncmd_count     = 0\ninput_count   = 0\noutput_count  = 0\nprint_count   = 0\nline_count    = 99\n\n\nRead_SYSPRINT_Loop:\n\ninput_count = input_count + 1\n\n\"EXECIO 1 DISKR SYSPRINT (STEM sysprint. \"\nexeciorc     = rc\nIf execiorc  = 2   Then ,        /* On end of file - Finish up  */\n   Signal End_Up\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"SYSPRINT !!!\"\n   Say \"File SYSPRINT was not properly preallocated or is invalid\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS3 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\np1  = POS(\"LISTC ALL ENT\",sysprint.1)\nIf p1  > 0                                         Then Do\n   Call   Initialize_Variables\n   Signal Read_SYSPRINT_Loop\nEnd\n\nnf  = POS(\" NOT FOUND \",sysprint.1)\nIf nf  > 0                                         Then ,\n   not_fnd = \"Y\"\n\nIf not_fnd = \"Y\"                                   Then ,\n   Signal Read_SYSPRINT_Loop\n\np2  = POS(\"CLUSTER--\",sysprint.1)\nIf p2  > 0                                         Then Do\n   cluster     = SUBSTR(sysprint.1,p2 + 9,44)\n   cluster     = STRIP(cluster,both)\n   Signal Read_SYSPRINT_Loop\nEnd\n\np2b = POS(\"AIX -----------\",sysprint.1)\nIf p2b > 0  & level = \"\"                           Then Do\n   aix         = SUBSTR(sysprint.1,p2b + 16,44)\n   aix         = STRIP(aix,both)\n   level       = \"AIX\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np2c = POS(\"PATH ------- \",sysprint.1)\nIf p2c > 0                                         Then Do\n   path        = SUBSTR(sysprint.1,p2c + 13,44)\n   path        = STRIP(path,both)\n   level       = \"PATH\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np3  = POS(\" DATA -------\",sysprint.1)\nIf p3  > 0  & level = \"AIX\"                        Then Do\n   data        = SUBSTR(sysprint.1,p3 + 14,44)\n   data        = STRIP(data,both)\n   level       = \"DATA\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np4  = POS(\" KEYLEN------\",sysprint.1)\nIf p4  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p4 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   keylen      = STRIP(parse_it,leading,\"0\")\n   If keylen   = \"\"  Then keylen       = 0\nEnd\n\np5  = POS(\" AVGLRECL----\",sysprint.1)\nIf p5  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p5 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   avglrecl    = STRIP(parse_it,leading,\"0\")\n   If avglrecl = \"\"  Then avglrecl     = 0\nEnd\n\np6  = POS(\" BUFSPACE----\",sysprint.1)\nIf p6  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p6 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   buffer      = STRIP(parse_it,leading,\"0\")\n   If buffer   = \"\"  Then buffer       = 0\nEnd\n\np7  = POS(\" CISIZE----\",sysprint.1)\nIf p7  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p7 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   dcisize     = STRIP(parse_it,leading,\"0\")\n   If dcisize  = \"\"  Then dcisize      = 0\nEnd\n\np8  = POS(\" RKP---------\",sysprint.1)\nIf p8  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p8 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   rkp         = STRIP(parse_it,leading,\"0\")\n   If rkp      = \"\"  Then rkp          = 0\nEnd\n\np9  = POS(\" MAXLRECL----\",sysprint.1)\nIf p9  > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p9 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   maxlrecl    = STRIP(parse_it,leading,\"0\")\n   If maxlrecl = \"\"  Then maxlrecl     = 0\nEnd\n\np10 = POS(\" SHROPTNS(\",sysprint.1)\nIf p10 > 0  & level = \"DATA\"                       Then Do\n   shr_opt1    = SUBSTR(sysprint.1,p10 + 10,1)\n   shr_opt2    = SUBSTR(sysprint.1,p10 + 12,1)\nEnd\n\nptype_e  = POS(\" NONINDEXED\",sysprint.1)\nptype_k  = POS(\" INDEXED\",sysprint.1)\nptype_l  = POS(\" LINEAR\",sysprint.1)\nptype_n  = POS(\" NUMBERED\",sysprint.1)\n\nIf ptype_e > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"NONINDEXED\"\nEnd\n\nIf ptype_k > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"INDEXED\"\nEnd\n\nIf ptype_l > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"LINEAR\"\nEnd\n\nIf ptype_n > 0  & level = \"DATA\"                   Then Do\n   type_vs = \"NUMBERED\"\nEnd\n\np11 = POS(\" SPEED \",sysprint.1)\nIf p11 > 0  & level = \"DATA\"                       Then Do\n   spd_rec     = \"SPEED\"\nEnd\n\np12 = POS(\" RECOVERY \",sysprint.1)\nIf p12 > 0  & level = \"DATA\"                       Then Do\n   spd_rec     = \"RECOVERY\"\nEnd\n\np12b = POS(\" NOUPGRADE\",sysprint.1)\nIf p12b > 0 & level = \"AIX\"                        Then Do\n   upgrade_lit    = \"NOUPGRADE\"\nEnd\n\np13 = POS(\" STORAGECLASS\",sysprint.1)\nIf p13 > 0  & level = \"AIX\"       & ,\n   SUBSTR(sysprint.1,p13 + 17,8) <> \"--(NULL)\"     Then Do\n      sc          = SUBSTR(sysprint.1,p13 + 17,8)\n      sc          = TRANSLATE(sc,\" \",\"-\")\n      sc          = STRIP(sc)\nEnd\n\np14 = POS(\" MANAGEMENTCLASS\",sysprint.1)\nIf p14 > 0  & level = \"AIX\"       & ,\n   SUBSTR(sysprint.1,p14 + 17,8) <> \"--(NULL)\"     Then Do\n      mc          = SUBSTR(sysprint.1,p14 + 17,8)\n      mc          = TRANSLATE(mc,\" \",\"-\")\n      mc          = STRIP(mc)\nEnd\n\np15 = POS(\" DATACLASS\",sysprint.1)\nIf p15 > 0  & level = \"AIX\"       & ,\n   SUBSTR(sysprint.1,p15 + 17,8) <> \"--(NULL)\"     Then Do\n      dc          = SUBSTR(sysprint.1,p15 + 17,8)\n      dc          = TRANSLATE(dc,\" \",\"-\")\n      dc          = STRIP(dc)\nEnd\n\np17 = POS(\" NOREUSE\",sysprint.1)\nIf p17 > 0  & level = \"DATA\"                       Then Do\n   reuse       = \"NOREUSE\"\nEnd\n\np18 = POS(\" REUSE\",sysprint.1)\nIf p18 > 0  & level = \"DATA\"                       Then Do\n   reuse       = \"REUSE\"\nEnd\n\np19 = POS(\" UNIQUEKEY\",sysprint.1)\nIf p19 > 0   & level = \"DATA\"                      Then Do\n   unique_key_lit = \"UNIQUEKEY\"\nEnd\n\np20 = POS(\" UNIQKEY\",sysprint.1)\nIf p20 > 0   & level = \"DATA\"                      Then Do\n   unique_key_lit = \"UNIQUEKEY\"\nEnd\n\np21 = POS(\" FREESPACE-\",sysprint.1)\nSelect\n   When p21   <= 0                                 Then Nop\n   When level <> \"DATA\"                            Then Nop\n   When SUBSTR(sysprint.1,p21 + 12,2) = \"CI\"       Then Do\n        parse_it    = SUBSTR(sysprint.1,p21 + 20,5)\n        parse_it    = STRIP(parse_it,both)\n        parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n        fs_ci       = STRIP(parse_it,leading,\"0\")\n        If fs_ci    = \"\"  Then fs_ci        = 0\n   End\n   When SUBSTR(sysprint.1,p21 + 12,2) = \"CA\"       Then Do\n        parse_it    = SUBSTR(sysprint.1,p21 + 20,5)\n        parse_it    = STRIP(parse_it,both)\n        parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n        fs_ca       = STRIP(parse_it,leading,\"0\")\n        If fs_ca    = \"\"  Then fs_ca        = 0\n   End\n   Otherwise Nop\nEnd\n\np22 = POS(\" UNORDERED\",sysprint.1)\nIf p22 > 0  & level = \"DATA\"                       Then Do\n   ordered     = \"UNORDERED\"\nEnd\n\np22b = POS(\" ORDERED\",sysprint.1)\nIf p22b > 0  & level = \"DATA\"                       Then Do\n   ordered        = \"ORDERED\"\nEnd\n\np22c = POS(\" NOERASE\",sysprint.1)\nIf p22c > 0  & level = \"DATA\"                       Then Do\n   erase       = \"NOERASE\"\nEnd\n\np22d = POS(\" ERASE\",sysprint.1)\nIf p22d > 0  & level = \"DATA\"                       Then Do\n   erase          = \"ERASE\"\nEnd\n\np23 = POS(\" SPACE-TYPE-----\",sysprint.1)\nIf p23 > 0  & level = \"DATA\"                       Then Do\n   dsp_type       = SUBSTR(sysprint.1,p23 + 17,8)\n   dsp_type       = TRANSLATE(dsp_type,\" \",\"-\")\n   dsp_type       = STRIP(dsp_type)\nEnd\n\np24 = POS(\" SPACE-PRI------\",sysprint.1)\nIf p24 > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p24 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   dprim       = STRIP(parse_it,leading,\"0\")\n   If dprim    = \"\"  Then dprim        = 0\nEnd\n\np25 = POS(\" SPACE-SEC------\",sysprint.1)\nIf p25 > 0  & level = \"DATA\"                       Then Do\n   parse_it    = SUBSTR(sysprint.1,p25 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   dsec        = STRIP(parse_it,leading,\"0\")\n   If dsec     = \"\"  Then dsec         = 0\nEnd\n\np26 = POS(\" VOLSER------\",sysprint.1)\nIf p26 > 0  & level = \"DATA\" & dvolser = \"\"        Then Do\n   dvolser     = SUBSTR(sysprint.1,p26 + 19,6)\nEnd\n\nIf p26 > 0  & SUBSTR(sysprint.1,p26 + 19,6) = \"MIGRAT\"    Then Do\n   not_fnd = \"Y\"\nEnd\n\np27 = POS(\" NOWRITECHK\",sysprint.1)\nIf p27 > 0  & level = \"DATA\"                       Then Do\n   writechk    = \"NOWRITECHECK\"\nEnd\n\np28 = POS(\" WRITECHK\",sysprint.1)\nIf p28 > 0  & level = \"DATA\"                       Then Do\n   writechk    = \"WRITECHECK\"\nEnd\n\n/*  UNIQUE and SUALLOCATION keywords are no longer used           */\n/*  variables unique_sub and lit18 have been deleted  05/24/2006  */\n/*                                                                */\n/*  p29 = POS(\" UNIQUE\",sysprint.1)                               */\n/*  If p29 > 0  & level = \"DATA\"                       Then Do    */\n/*     unique_sub  = \"UNIQUE\"                                     */\n/*  End                                                           */\n/*                                                                */\n/*  p29b = POS(\" SUBALLOCATION\",sysprint.1)                       */\n/*  If p29b > 0  & level = \"DATA\"                       Then Do   */\n/*     unique_sub  = \"SUBALLOCATION\"                              */\n/*  End                                                           */\n\np30 = POS(\" INDEX -----\",sysprint.1)\nIf p30 > 0  & level = \"DATA\"                       Then Do\n   index       = SUBSTR(sysprint.1,p30 + 14,44)\n   index       = STRIP(index)\n   level       = \"INDEX\"\n   Signal Read_SYSPRINT_Loop\nEnd\n\np31 = POS(\" CISIZE----\",sysprint.1)\nIf p31 > 0  & level = \"INDEX\"                      Then Do\n   parse_it    = SUBSTR(sysprint.1,p31 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   icisize     = STRIP(parse_it,leading,\"0\")\n   If icisize  = \"\"  Then icisize      = 0\nEnd\n\np32 = POS(\" SPACE-TYPE-----\",sysprint.1)\nIf p32 > 0  & level = \"INDEX\"                      Then Do\n   isp_type       = SUBSTR(sysprint.1,p32 + 17,8)\n   isp_type       = TRANSLATE(isp_type,\" \",\"-\")\n   isp_type       = STRIP(isp_type)\nEnd\n\np33 = POS(\" SPACE-PRI------\",sysprint.1)\nIf p33 > 0  & level = \"INDEX\"                      Then Do\n   parse_it    = SUBSTR(sysprint.1,p33 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   iprim       = STRIP(parse_it,leading,\"0\")\n   If iprim    = \"\"  Then iprim        = 0\nEnd\n\np34 = POS(\" SPACE-PRI------\",sysprint.1)\nIf p34 > 0  & level = \"INDEX\"                      Then Do\n   parse_it    = SUBSTR(sysprint.1,p34 + 20,5)\n   parse_it    = STRIP(parse_it,both)\n   parse_it    = TRANSLATE(parse_it,\"0\",\"-\")\n   isec        = STRIP(parse_it,leading,\"0\")\n   If isec     = \"\"  Then isec         = 0\nEnd\n\np35 = POS(\" VOLSER------\",sysprint.1)\nIf p35 > 0  & level = \"INDEX\"                      Then Do\n   ivolser     = SUBSTR(sysprint.1,p35 + 19,6)\nEnd\n\np99 = POS(\"HIGHEST CONDITION CODE\",sysprint.1)\n\n/* END OF LISTCAT FUNCTION FOR THIS DATASET ?               */\n\nSelect\n   When not_fnd = \"Y\"                              Then ,\n        Signal Read_SYSPRINT_Loop\n   When p99 <= 0                                   Then ,\n        Signal Read_SYSPRINT_Loop\n   Otherwise Nop\nEnd\n\n\nBuild_DEFINE_AIX_Commands:\n\nlitdel        = \"  DELETE \"\nlit2          = \"  IF LASTCC = 8           \"\nlit3          = \"    THEN IF MAXCC LT 12   \"\nlit4          = \"      THEN SET MAXCC = 0  \"\nlit5          = \"  DEFINE                  \"\nlitclus       = \"    AIX     (NAME(\"\nindent        = \"            \"\nlitdata       = \"       DATA (NAME(\"\nlitindx       = \"      INDEX (NAME(\"\nlit37         = \"  DEFINE                  \"\nlit38         = \"    PATH    (NAME(\"\nlit39         = \"    PATHENTRY(\"\nlit40         = \"  BLDINDEX                \"\nlit41         = \"    IDS(\"\nlit42         = \"    ODS(\"\nfiller        = Copies(\" \",80)\n\nheading_1     = \"   VSAM AIX Component Allocation Information\"\nheading_2     = \"   Aix Dataset                                 Data\",\n                \"  Managemt Storage  Data\"\nheading_3     = \"   Dataset Name                               Volser\",\n                \"  Class    Class   Class\"\n\nlit                = litdel||STRIP(aix)\nlit1               = LEFT(lit,80,\" \")\nlit1               = OVERLAY(\"AIX PURGE\",lit1,55,9)\n\nlit2               = LEFT(lit2,80,\" \")\nlit2               = OVERLAY(\"-\",lit2,65,1)\n\nlit3               = LEFT(lit3,80,\" \")\nlit3               = OVERLAY(\"-\",lit3,65,1)\n\nlit4               = LEFT(lit4,80,\" \")\nlit4               = OVERLAY(\"-\",lit4,65,1)\n\nlit5               = LEFT(lit5,80,\" \")\nlit5               = OVERLAY(\"-\",lit5,65,1)\n\nlit                = litclus||STRIP(aix)||\")\"\nlit6               = LEFT(lit,80,\" \")\nlit6               = OVERLAY(\"-\",lit6,65,1)\n\nlit                = indent||STRIP(reuse)\nlit7               = LEFT(lit,80,\" \")\nlit7               = OVERLAY(\"-\",lit7,65,1)\n\nlit                = indent||\"RELATE(\"||STRIP(cluster)||\")\"\nlit9               = LEFT(lit,80,\" \")\nlit9               = OVERLAY(\"-\",lit9,65,1)\n\nlit                = indent||upgrade_lit\nlit10              = LEFT(lit,80,\" \")\nlit10              = OVERLAY(\"-\",lit10,65,1)\n\nlit                = indent||unique_key_lit\nlit11              = LEFT(lit,80,\" \")\nlit11              = OVERLAY(\"-\",lit11,65,1)\n\nlit                = indent||\"STORAGECLASS(\"||STRIP(sc)||\")\"\nlit12              = LEFT(lit,80,\" \")\nlit12              = OVERLAY(\"-\",lit12,65,1)\n\nlit                = indent||\"MANAGEMENTCLASS(\"||STRIP(mc)||\")\"\nlit13              = LEFT(lit,80,\" \")\nlit13              = OVERLAY(\"-\",lit13,65,1)\n\nlit                = indent||\"DATACLASS(\"||STRIP(dc)||\")\"\nlit14              = LEFT(lit,80,\" \")\nlit14              = OVERLAY(\"-\",lit14,65,1)\n\nlit                = indent||STRIP(spd_rec)\nlit15              = LEFT(lit,80,\" \")\nlit15              = OVERLAY(\"-\",lit15,65,1)\n\nlit                = indent||\"SHAREOPTIONS(\"||STRIP(shr_opt1)||,\n                        \",\"||STRIP(shr_opt2)||\")\"\nlit16              = LEFT(lit,80,\" \")\nlit16              = OVERLAY(\"-\",lit16,65,1)\n\nlit                = indent||STRIP(writechk)\nlit17              = LEFT(lit,80,\" \")\nlit17              = OVERLAY(\"-\",lit17,65,1)\n\nlit                = indent||STRIP(ordered)\nlit20              = LEFT(lit,80,\" \")\nlit20              = OVERLAY(\"-\",lit20,65,1)\n\nlit                = indent||STRIP(erase)\nlit21              = LEFT(lit,80,\" \")\nlit21              = OVERLAY(\"-\",lit21,65,1)\n\nlit                = indent||\")\"\nlit22              = LEFT(lit,80,\" \")\nlit22              = OVERLAY(\"-\",lit22,65,1)\n\nlit                = litdata||STRIP(data)||\")\"\nlit23              = LEFT(lit,80,\" \")\nlit23              = OVERLAY(\"-\",lit23,65,1)\n\nlit                = indent||\"VOLUMES(\"||STRIP(dvolser)||\")\"\nlit24              = LEFT(lit,80,\" \")\nlit24              = OVERLAY(\"-\",lit24,65,1)\n\nlit                = indent||\"FREESPACE(\"||STRIP(fs_ci)||\" \"||,\n                        STRIP(fs_ca)||\")\"\nlit25              = LEFT(lit,80,\" \")\nlit25              = OVERLAY(\"-\",lit25,65,1)\n\nlit                = indent||\"BUFFERSPACE(\"||STRIP(buffer)||\")\"\nlit26              = LEFT(lit,80,\" \")\nlit26              = OVERLAY(\"-\",lit26,65,1)\n\nlit                = indent||STRIP(dsp_type)||\"S\"||\"(\"||,\n                        STRIP(dprim)||\" \"||STRIP(dsec)||\")\"\nlit27              = LEFT(lit,80,\" \")\nlit27              = OVERLAY(\"-\",lit27,65,1)\n\nlit                = indent||\"RECORDSIZE(\"||STRIP(AVGLRECL)||,\n                        \" \"||STRIP(maxlrecl)||\")\"\nlit28              = LEFT(lit,80,\" \")\nlit28              = OVERLAY(\"-\",lit28,65,1)\n\nlit                = indent||\"KEYS(\"||STRIP(keylen)||\" \"||,\n                        STRIP(rkp)||\")\"\nlit29              = LEFT(lit,80,\" \")\nlit29              = OVERLAY(\"-\",lit29,65,1)\n\nlit                = indent||\"CONTROLINTERVALSIZE(\"||STRIP(dcisize)||,\n                        \")\"\nlit30              = LEFT(lit,80,\" \")\nlit30              = OVERLAY(\"-\",lit30,65,1)\n\nlit                = indent||\")\"\nlit31              = LEFT(lit,80,\" \")\nlit31              = OVERLAY(\"-\",lit31,65,1)\n\nlit                = litindx||STRIP(index)||\")\"\nlit32              = LEFT(lit,80,\" \")\nlit32              = OVERLAY(\"-\",lit32,65,1)\n\nlit                = indent||\"VOLUMES(\"||STRIP(ivolser)||\")\"\nlit33              = LEFT(lit,80,\" \")\nlit33              = OVERLAY(\"-\",lit33,65,1)\n\nlit                = indent||STRIP(isp_type)||\"S\"||\"(\"||,\n                        STRIP(iprim)||\" \"||STRIP(isec)||\")\"\nlit34              = LEFT(lit,80,\" \")\nlit34              = OVERLAY(\"-\",lit34,65,1)\n\nlit                = indent||\"CONTROLINTERVALSIZE(\"||STRIP(icisize)||,\n                        \")\"\nlit35              = LEFT(lit,80,\" \")\nlit35              = OVERLAY(\"-\",lit35,65,1)\n\nlit36              = indent||\")\"\n\nlit37              = LEFT(lit37,80,\" \")\nlit37              = OVERLAY(\"-\",lit37,65,1)\n\nlit                = lit38||STRIP(path)||\")\"\nlit38              = LEFT(lit,80,\" \")\nlit38              = OVERLAY(\"-\",lit38,65,1)\n\nlit                = lit39||STRIP(aix)||\"))\"\nlit39              = LEFT(lit,80,\" \")\nlit39              = OVERLAY(\"-\",lit39,65,1)\n\nlit40              = LEFT(lit40,80,\" \")\nlit40              = OVERLAY(\"-\",lit40,65,1)\n\nlit                = lit41||STRIP(cluster)||\")\"\nlit41              = LEFT(lit,80,\" \")\nlit41              = OVERLAY(\"-\",lit41,65,1)\n\nlit                = lit42||STRIP(aix)||\")\"\nlit42              = LEFT(lit,80,\" \")\nlit42              = OVERLAY(\"-\",lit42,65,1)\n\n\n/****************  Debugging  Start  *********************************/\n\n    Say ;\n    Say \"REORGVS3 Exec - AIX Component Information ...\"\n    Say ;\n    Say \"version_level  = \"  version_level\n    Say ;\n    Say \"not_fnd        = \"  not_fnd\n    Say \"level          = \"  level\n    Say \"aix            = \"  aix\n    Say \"data           = \"  data\n    Say \"index          = \"  index\n    Say \"path           = \"  path\n    Say \"reuse          = \"  reuse\n    Say \"dc             = \"  dc\n    Say \"sc             = \"  sc\n    Say \"mc             = \"  mc\n    Say \"type_vs        = \"  type_vs\n    Say \"upgrade_lit    = \"  upgrade_lit\n    Say \"unique_key_lit = \"  unique_key_lit\n    Say \"erase          = \"  erase\n    Say \"ordered        = \"  ordered\n    Say \"writechk       = \"  writechk\n    Say \"spd_rec        = \"  spd_rec\n    Say \"shr_opt1       = \"  shr_opt1\n    Say \"shr_opt2       = \"  shr_opt2\n    Say \"fs_ci          = \"  fs_ci\n    Say \"fs_ca          = \"  fs_ca\n    Say \"buffer         = \"  buffer\n    Say \"dsp_type       = \"  dsp_type\n    Say \"dprim          = \"  dprim\n    Say \"dsec           = \"  dsec\n    Say \"dvolser        = \"  dvolser\n    Say \"avglrecl       = \"  avglrecl\n    Say \"maxlrecl       = \"  maxlrecl\n    Say \"rkp            = \"  rkp\n    Say \"keylen         = \"  keylen\n    Say \"dcisize        = \"  dcisize\n    Say \"isp_type       = \"  isp_type\n    Say \"iprim          = \"  iprim\n    Say \"isec           = \"  isec\n    Say \"icisize        = \"  icisize\n    Say \"ivolser        = \"  ivolser\n    Say \"lit1    =\"  lit1\n    Say \"lit2    =\"  lit2\n    Say \"lit3    =\"  lit3\n    Say \"lit4    =\"  lit4\n    Say \"lit5    =\"  lit5\n    Say \"lit6    =\"  lit6\n    Say \"lit7    =\"  lit7\n    Say \"lit9    =\"  lit9\n    Say \"lit10   =\"  lit10\n    Say \"lit11   =\"  lit11\n    Say \"lit12   =\"  lit12\n    Say \"lit13   =\"  lit13\n    Say \"lit14   =\"  lit14\n    Say \"lit15   =\"  lit15\n    Say \"lit16   =\"  lit16\n    Say \"lit17   =\"  lit17\n    Say \"lit20   =\"  lit20\n    Say \"lit21   =\"  lit21\n    Say \"lit22   =\"  lit22\n    Say \"lit23   =\"  lit23\n    Say \"lit24   =\"  lit24\n    Say \"lit25   =\"  lit25\n    Say \"lit26   =\"  lit26\n    Say \"lit27   =\"  lit27\n    Say \"lit28   =\"  lit28\n    Say \"lit29   =\"  lit29\n    Say \"lit30   =\"  lit30\n    Say \"lit31   =\"  lit31\n    Say \"lit32   =\"  lit32\n    Say \"lit33   =\"  lit33\n    Say \"lit34   =\"  lit34\n    Say \"lit35   =\"  lit35\n    Say \"lit36   =\"  lit36\n    Say \"lit37   =\"  lit37\n    Say \"lit38   =\"  lit38\n    Say \"lit39   =\"  lit39\n    Say \"lit40   =\"  lit40\n    Say \"lit41   =\"  lit41\n    Say \"lit42   =\"  lit42\n\n/****************  Debugging  End    *********************************/\n\nFormat_IDCAMS_Commands:\n\ndefines.1          = lit1\nCall Output_IDCAM_Record\n\ndefines.1          = lit2\nCall Output_IDCAM_Record\n\ndefines.1          = lit3\nCall Output_IDCAM_Record\n\ndefines.1          = lit4\nCall Output_IDCAM_Record\n\ndefines.1          = filler\nCall Output_IDCAM_Record\n\n/********************************************************************/\n/* Output DEFINE AIX IDCAMS statements                              */\n/********************************************************************/\n\ndefines.1          = lit5\nCall Output_IDCAM_Record\n\ndefines.1          = lit6\nCall Output_IDCAM_Record\n\ndefines.1          = lit7\nCall Output_IDCAM_Record\n\ndefines.1          = lit9\nCall Output_IDCAM_Record\n\ndefines.1          = lit10\nCall Output_IDCAM_Record\n\ndefines.1          = lit11\nCall Output_IDCAM_Record\n\nIf sc <> \"        \"              Then Do\n   defines.1          = lit12\n   Call Output_IDCAM_Record\nEnd\n\nIf mc <> \"        \"              Then Do\n   defines.1          = lit13\n   Call Output_IDCAM_Record\nEnd\n\nIf dc <> \"        \"              Then Do\n   defines.1          = lit14\n   Call Output_IDCAM_Record\nEnd\n\ndefines.1          = lit15\nCall Output_IDCAM_Record\n\ndefines.1          = lit16\nCall Output_IDCAM_Record\n\ndefines.1          = lit17\nCall Output_IDCAM_Record\n\ndefines.1          = lit20\nCall Output_IDCAM_Record\n\ndefines.1          = lit21\nCall Output_IDCAM_Record\n\ndefines.1          = lit22\nCall Output_IDCAM_Record\n\ndefines.1          = lit23\nCall Output_IDCAM_Record\n\ndefines.1          = lit24\nCall Output_IDCAM_Record\n\nIf type_vs  <> \"LINEAR\"          Then Do\n   defines.1          = lit25\n   Call Output_IDCAM_Record\nEnd\n\ndefines.1          = lit26\nCall Output_IDCAM_Record\n\ndefines.1          = lit27\nCall Output_IDCAM_Record\n\nIf type_vs  <> \"LINEAR\"          Then Do\n   defines.1          = lit28\n   Call Output_IDCAM_Record\nEnd\n\nIf type_vs   = \"INDEXED\"         Then Do\n   defines.1          = lit29\n   Call Output_IDCAM_Record\nEnd\n\ndefines.1          = lit30\nCall Output_IDCAM_Record\n\ndefines.1          = lit31\nCall Output_IDCAM_Record\n\nIf type_vs  <> \"INDEXED\"         Then Do\n   Signal Skip_Indexed\nEnd\n\ndefines.1          = lit32\nCall Output_IDCAM_Record\n\ndefines.1          = lit33\nCall Output_IDCAM_Record\n\ndefines.1          = lit34\nCall Output_IDCAM_Record\n\ndefines.1          = lit35\nCall Output_IDCAM_Record\n\ndefines.1          = lit36\nCall Output_IDCAM_Record\n\nSkip_Indexed:\n\ndefines.1          = filler\nCall Output_IDCAM_Record\n\n/********************************************************************/\n/* Output DEFINE PATH IDCAMS statements                            */\n/********************************************************************/\n\ndefines.1          = lit37\nCall Output_IDCAM_Record\n\ndefines.1          = lit38\nCall Output_IDCAM_Record\n\ndefines.1          = lit39\nCall Output_IDCAM_Record\n\ndefines.1          = filler\nCall Output_IDCAM_Record\n\ndefines.1          = lit40\nCall Output_IDCAM_Record\n\ndefines.1          = lit41\nCall Output_IDCAM_Record\n\ndefines.1          = lit42\nCall Output_IDCAM_Record\n\ndefines.1          = filler\nCall Output_IDCAM_Record\n\n/********************************************************************/\n/* Output BLDINDEX IDCAMS statements                                */\n/********************************************************************/\n\n/*                                                                  */\n/*//BLDINDX EXEC IDCAM327,SYSOUT='*'                                */\n/*//BASEIN   DD DISP=OLD,DSN=EPL.Q99.P66T0.EPLDN331                 */\n/*//ALTINDX1 DD DISP=OLD,DSN=EPL.Q99.P66T0.EPLDN331.AIX1            */\n/*//ALTINDX2 DD DISP=OLD,DSN=EPL.Q99.P66T0.EPLDN331.AIX2            */\n/*//SYSIN    DD *                                                   */\n/* BLDINDEX INFILE(BASEIN) -                                        */\n/*     OUTFILE(ALTINDX1)                                            */\n/* BLDINDEX INFILE(BASEIN) -                                        */\n/*     OUTFILE(ALTINDX2)                                            */\n/*                                                                  */\n/*                                                                  */\n\ncmd_count = cmd_count + 1\n\nSignal Print_VSAM_Alloation_Information\n\n\nOutput_IDCAM_Record:\n\noutput_count = output_count + 1\n\n\"EXECIO 1 DISKW DEFINES  (STEM defines. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"DEFINES !!!\"\n   Say \"File DEFINES was not properly preallocated or invalid\"\n       \"or an I/O error was encountered\"\n   Say \"Output I/O count is \" output_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS3 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nReturn\n\n\nPrint_VSAM_Alloation_Information:\n\n  If line_count > 60                    Then Do\n     line_count = 0\n     Call Print_Report_Headings\n  End\n\n  report.1         = COPIES(\" \",80)\n  report.1         = OVERLAY(aix,report.1,2,44)\n  report.1         = OVERLAY(dvolser,report.1,47,6)\n  report.1         = OVERLAY(mc,report.1,55,8)\n  report.1         = OVERLAY(sc,report.1,64,8)\n  report.1         = OVERLAY(dc,report.1,73,8)\n\n  Call Print_Report_Line\n\n  Signal Read_SYSPRINT_Loop\n\n\nPrint_Report_Headings:\n\n  report.1         = heading_1\n  Call Print_Report_Line\n\n  report.1         = filler\n  Call Print_Report_Line\n\n  report.1         = heading_2\n  Call Print_Report_Line\n\n  report.1         = heading_3\n  Call Print_Report_Line\n\n  report.1         = filler\n  Call Print_Report_Line\n\nReturn\n\n\nPrint_Report_Line:\n\nprint_count = print_count + 1\nline_count  = line_count  + 1\n\n\"EXECIO 1 DISKW REPORT   (STEM report. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"REPORT !!!\"\n   Say \"File REPORT was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"Output Report count is \" print_count\n   Say \"Page   Line   count is \" line_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS3 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\n\nReturn\n\n\nInitialize_Variables:\n\n  not_fnd         = \"\"\n  level           = \"\"\n  aix             = \"\"\n  data            = \"\"\n  index           = \"\"\n  path            = \"\"\n  reuse           = \"\"\n  dc              = \"\"\n  sc              = \"\"\n  mc              = \"\"\n  type_vs         = \"\"\n  upgrade_lit     = \"UPGRADE\"\n  unique_key_lit  = \"NONUNIQUEKEY\"\n  erase           = \"\"\n  ordered         = \"\"\n  writechk        = \"\"\n  spd_rec         = \"\"\n  shr_opt1        = \"\"\n  shr_opt2        = \"\"\n  fs_ci           = \"\"\n  fs_ca           = \"\"\n  buffer          = \"\"\n  dsp_type        = \"\"\n  dprim           = \"\"\n  dsec            = \"\"\n  dvolser         = \"\"\n  avglrecl        = \"\"\n  maxlrecl        = \"\"\n  rkp             = \"\"\n  keylen          = \"\"\n  dcisize         = \"\"\n  isp_type        = \"\"\n  iprim           = \"\"\n  isec            = \"\"\n  icicize         = \"\"\n  ivolser         = \"\"\n\nReturn\n\n\nEnd_Up:\n\n\"EXECIO 0 DISKR SYSPRINT (FINIS\"\ndefines.1    = \"  \"\n\"EXECIO 1 DISKW DEFINES  (STEM defines.\"\n\"EXECIO 0 DISKW DEFINES  (FINIS\"\n\"EXECIO 0 DISKW REPORT   (FINIS\"\n\nSay ;\nSay \"REORGVS3 Exec - Parse Out AIX Parameters ...\"\nSay ;\nSay \"version_level                =>\" version_level\nSay ;\nSay \"REORGVS3 exec return code is   \" rtcd\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVS4": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x18\\x01\\x06\\x00o\\x01\\x08&\\x0f\\x12%\\x02\\x06\\x01\\xd9\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2006-01-06T00:00:00", "modifydate": "2008-09-16T12:25:18", "lines": 518, "newlines": 473, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVS4   (Recreate a VSAM Cluster - Used with the     */\n/*                        REORGVS exec).                              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/05/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/16/2008                         */\n/*                                                                    */\n/*  PURPOSE = This exec will input a Racf LISTDSD command for a file  */\n/*            and will parse out the appropriate parameters to        */\n/*            produce the RACF Commands to recreate a discrete Racf   */\n/*            profile for the file after it is deleted and            */\n/*            reallocated.                                            */\n/*                                                                    */\n/*            If there is no Racf profile for the dataset or if a     */\n/*            profile exists but it is not a discrete dataclass       */\n/*            profile, nothing will be generated since the profile    */\n/*            will not be disturbe when the file is deleted.          */\n/*                                                                    */\n/*            Input File SYSPRINT must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            Output File COMMANDS must be preallocated prior to the  */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            The output of this exec will be a stream the following  */\n/*            RACF Commands:                                          */\n/*                                                                    */\n/*              ADDSD 'PROFILE NAME' UACC(uaccess) AUDIT(auditinfo)   */\n/*                    OWNER(ownerid) [NOTIFY(notify id)]              */\n/*                                                                    */\n/*              ALTDSD 'PROFILE NAME' OWNER(ownerid)                  */\n/*                                                                    */\n/*              PERMIT 'PROFILE NAME' ID(groups and userids) +        */\n/*                     ACCESS(access levels)                          */\n/*                                                                    */\n/*              PERMIT 'PROFILE NAME' ID(submit userid)   DELETE      */\n/*                                                                    */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*                                                                    */\n/*  Modifications/Tailoring:                                          */\n/*                                                                    */\n/*  Make the following modification before storing this Rexx exec.    */\n/*                                                                    */\n/*  1)        Change the length of \"sysid\" to your specification.     */\n/*            The default is 3 characters if this is not              */\n/*            modified.                                               */\n/*                                                                    */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Invalid SYSPRINT input file or SYSPRINT file was not      */\n/*          preallocated or Invalid COMMANDS output file or the file  */\n/*          was not preallocated.                                     */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.08\"\nArg parms\nTrace \"O\"\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nuserid                     = Userid()\nrtcd                       = 0\nsysid                      = Left(MVSVAR(sysname),3,\" \")\ncmd_count                  = 0\ninput_count                = 0\noutput_count               = 0\nhad_p3                     = \"\"\nhad_p4                     = \"\"\nhad_p5                     = \"\"\nhad_p7                     = \"\"\nhad_p9                     = \"\"\nhad_p10                    = \"\"\nhad_p12                    = \"\"\nhad_p14                    = \"\"\nhad_std_access_entries     = \"\"\nhad_cnd_access_entries     = \"\"\nend_std_access_list        = \"\"\nend_cnd_access_list        = \"\"\nii                         = 0\njj                         = 0\nkk                         = 0\nuacc_line_count            = -99\naudit_line_count           = -99\nnotify_line_count          = -99\nyour_access_line_count     = -99\nglobal_audit_line_count    = -99\nvolumes_resides_line_count = -99\nstd_access_list_line_count = -99\ncnd_access_list_line_count = -99\n\n\nRead_SYSPRINT_Loop:\n\ninput_count = input_count + 1\n\n\"EXECIO 1 DISKR SYSPRINT (STEM sysprint. \"\nexeciorc     = rc\nIf execiorc  = 2   Then Do       /* On end of file - Finish up  */\n   input_count = input_count - 1\n   Signal Print_Racf_Information\nEnd\n\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"SYSPRINT !!!\"\n   Say \"File SYSPRINT was not properly preallocated or is invalid\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS4 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\np1  = POS(\"NO RACF DESCRIPTION FOUND\",sysprint.1)\nIf p1  > 0                                         Then ,\n   Signal End_Up\n\np2  = POS(\"INFORMATION FOR DATASET\",sysprint.1)\nIf p2  > 0                                         Then Do\n   dsn  = SUBSTR(sysprint.1,p2 + 24,44)\n   dsn  = STRIP(WORD(dsn,1))\n   p3  = POS(\" (G) \",sysprint.1)\n   If p3 > 0                                       Then Do\n      /* If this is not a discrete Racf profile, exit this exec  */\n      Say ;\n      Say \"Dataset '\"||STRIP(dsn)||\"' has a Generic Racf Profile\"\n      Say \"The Racf Profile was unaffected by the reorganization\"\n      Say ;\n      Signal End_Up\n   End\n   Else Do\n      Call   Initialize_Variables\n      dsn  = SUBSTR(sysprint.1,p2 + 24,44)\n      dsn  = STRIP(WORD(dsn,1))\n      Signal Read_SYSPRINT_Loop\n   End\nEnd\n\np3  = POS(\" UNIVERSAL ACCESS \",sysprint.1)\nIf p3  > 0                                         Then Do\n   had_p3  = \"Y\"\n   uacc_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\nIf had_p3  = \"Y\" & ,\n   (input_count = uacc_line_count + 2)             Then Do\n       ownerid = WORD(sysprint.1,2)\n       uacc    = WORD(sysprint.1,3)\n       Signal Read_SYSPRINT_Loop\nEnd\n\np4  = POS(\"AUDITING\",sysprint.1)\nIf p4  > 0                                         Then Do\n   had_p4  = \"Y\"\n   audit_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\nIf had_p4  = \"Y\" & ,\n   (input_count = audit_line_count + 2)            Then Do\n       audit_lit  = WORD(sysprint.1,1)\n       Signal Read_SYSPRINT_Loop\nEnd\n\np5  = POS(\"NOTIFY\",sysprint.1)\nIf p5  > 0                                         Then Do\n   had_p5  = \"Y\"\n   notify_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\nIf had_p5  = \"Y\" & (input_count = notify_line_count + 2 ) Then Do\n   p6  = POS(\"NO USER TO BE NOTIFIED\",sysprint.1)\n   If p6  = 0                                      Then Do\n      notify_id   = WORD(sysprint.1,1)\n   End\n   Signal Read_SYSPRINT_Loop\nEnd\n\np7  = POS(\"YOUR ACCESS  CREATION\",sysprint.1)\nIf p7  > 0                                         Then Do\n   had_p7  = \"Y\"\n   your_access_line_count     = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\n/* If this is not a discrete Racf profile, exit this exec          */\n\nIf had_p7  = \"Y\" & (input_count = your_access_line_count + 2 ) Then Do\n   p8  = POS(\" MODEL \",sysprint.1)\n   If p8  > 0                                      Then Do\n      Say ;\n      Say \"Dataset '\"||STRIP(dsn)||\"' has a Model Racf Profile\"\n      Say \"The Racf Profile was unaffected by the reorganization\"\n      Say ;\n      Signal End_Up\n   End\n   Else Do\n      your_access  = WORD(sysprint.1,1)\n      Signal Read_SYSPRINT_Loop\n   End\nEnd\n\np9  = POS(\"GLOBALAUDIT\",sysprint.1)\nIf p9  > 0                                         Then Do\n   had_p9  = \"Y\"\n   global_audit_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\nIf had_p9  = \"Y\" & ,\n   (input_count = global_audit_line_count + 2 )    Then Do\n      global_audit_lit   = WORD(sysprint.1,1)\n      Signal Read_SYSPRINT_Loop\nEnd\n\np10 = POS(\"VOLUMES ON WHICH DATASET RESIDES\",sysprint.1)\nIf p10 > 0                                         Then Do\n   had_p10 = \"Y\"\n   volumes_resides_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\nIf had_p10 = \"Y\" & ,\n   (input_count = volumes_resides_line_count + 2 ) Then Do\n   p11 = POS(\"NO VOLUMES IN DATASET PROFILE\",sysprint.1)\n   If p11 > 0                                      Then ,\n      Signal End_Up\n   Else Do\n      volser = WORD(sysprint.1,1)\n      Signal Read_SYSPRINT_Loop\n   End\nEnd\n\np12 = POS(\"   ID     ACCESS\",sysprint.1)\nIf p12 > 0                                         Then Do\n   had_p12 = \"Y\"\n   std_access_list_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\np14 = POS(\"   ID    ACCESS\",sysprint.1)\nIf p14 > 0                                         Then Do\n   had_p14 = \"Y\"\n   cnd_access_list_line_count = input_count\n   Signal Read_SYSPRINT_Loop\nEnd\n\nIf had_p12 = \"Y\" & end_std_access_list = \"\" & ,\n   (input_count > std_access_list_line_count + 1 )       Then Do\n      p13 = POS(\"NO ENTRIES IN STANDARD ACCESS LIST\",sysprint.1)\n      Select\n         When p13 > 0                                    Then Do\n            /* No entries in the Standard Access List     */\n            had_std_access_entries = \"N\"\n            end_std_access_list    = \"Y\"\n            Signal Read_SYSPRINT_Loop\n         End\n         When SUBSTR(sysprint.1,2,30) = Copies(\" \",30)   Then Do\n            /* End of Standard Access List Entries */\n            end_std_access_list    = \"Y\"\n            Signal Read_SYSPRINT_Loop\n         End\n         Otherwise Do\n            /* Add the next Standard Access List Entry  */\n            had_std_access_entries = \"Y\"\n            ii         = ii + 1\n            std_id.ii      = WORD(sysprint.1,1)\n            std_access.ii  = WORD(sysprint.1,2)\n            Signal Read_SYSPRINT_Loop\n         End\n      End\nEnd\n\nIf had_p14 = \"Y\" & end_cnd_access_list = \"\" & ,\n   (input_count > cnd_access_list_line_count + 1 )       Then Do\n      p15 = POS(\"NO ENTRIES IN CONDITIONAL ACCESS LIST\",sysprint.1)\n      Select\n         When p15 > 0                                    Then Do\n            /* No entries in the Conditional Access List  */\n            had_cnd_access_entries = \"N\"\n            end_cnd_access_list    = \"Y\"\n            Signal Read_SYSPRINT_Loop\n         End\n         When SUBSTR(sysprint.1,2,30) = Copies(\" \",30)   Then Do\n            /* End of Conditional Access List Entries */\n            end_cnd_access_list    = \"Y\"\n            Signal Read_SYSPRINT_Loop\n         End\n         When WORD(sysprint.1,1) = \"READY\"               Then Do\n            /* End of Conditional Access List Entries */\n            end_cnd_access_list    = \"Y\"\n            Signal Read_SYSPRINT_Loop\n         End\n         When WORD(sysprint.1,1) = \"END\"                 Then Do\n            /* End of Conditional Access List Entries */\n            end_cnd_access_list    = \"Y\"\n            Signal Read_SYSPRINT_Loop\n         End\n         Otherwise Do\n            /* Add the next Conditional Access List Entry  */\n            had_cnd_access_entries = \"Y\"\n            jj             = jj + 1\n            cnd_id.jj      = WORD(sysprint.1,1)\n            cnd_access.jj  = WORD(sysprint.1,2)\n            cnd_class.jj   = WORD(sysprint.1,4)\n            cnd_entity.jj  = WORD(sysprint.1,5)\n            Signal Read_SYSPRINT_Loop\n         End\n      End\nEnd\n\nSignal Read_SYSPRINT_Loop\n\n\nPrint_Racf_Information:\n\n\n/*****  Display Results  *******************************************/\n\nSay ;\nSay \"Dataset '\"||STRIP(dsn)||\"' has a Discrete Racf Profile\"\nSay \"  The Discrete profile will be re-created ...         \"\nSay ;\nSay \"DATASET NAME     =\" dsn\nSay \"OWNER            =\" ownerid\nSay \"UACC             =\" uacc\nSay \"YOUR USERID      =\" userid\nSay \"YOUR ACCESS      =\" your_access\nSay \"RACF VOLSER      =\" volser\nSay \"AUDITING         =\" audit_lit\nSay \"NOTIFY           =\" notify_id\nSay \"GLOBALAUDIT      =\" global_audit_lit\n\nIf had_std_access_entries = \"Y\"                        Then Do\n   Say ;\n   Say ii||\" Entries in the Standard Access List:\"\n   Say ;\nEnd\nElse Do\n   Say ;\n   Say \"No Entries in the Standard Access List\"\n   Say ;\nEnd\n\nIf had_std_access_entries = \"Y\"                        Then ,\n   Do kk = 1 to ii\n       Say \"Std Access Id =>\" LEFT(std_id.kk,8,\" \")||\"   \"||,\n           \"Access Level =>\" LEFT(std_access.kk,10,\" \")\nEnd\n\nIf had_cnd_access_entries = \"Y\"                        Then Do\n   Say ;\n   Say jj||\" Entries in the Conditional Access List:\"\n   Say ;\nEnd\nElse Do\n   Say ;\n   Say \"No Entries in the Conditional Access List\"\n   Say ;\nEnd\n\nIf had_cnd_access_entries = \"Y\"                        Then ,\n   Do kk = 1 to jj\n       Say \"Cnd Access Id => \"||LEFT(cnd_id.kk,8,\" \")||\"  \"||,\n           \"Access Level => \"||LEFT(cnd_access.kk,8,\" \")||\"  \"||,\n           \"Class => \"||LEFT(cnd_class.kk,10,\" \")\n       Say \"       Entity => \"||LEFT(cnd_entity.kk,10,\" \")\nEnd\n\n/*****  End Display ************************************************/\n\n\nOutput_Racf_Commands:\n\ncommands.1 = \" ADDSD  '\"||STRIP(dsn)||\"' UACC(\"||STRIP(uacc)||\")    +\"\nCall Output_A_Racf_Record\n\ncommands.1 = \"        AUDIT(\"||audit_lit||\") OWNER(\"||ownerid||\")\"\nCall Output_A_Racf_Record\n\ncommands.1 = \" ALTDSD '\"||STRIP(dsn)||\"' OWNER(\"||ownerid||\")\"\nCall Output_A_Racf_Record\n\nIf had_std_access_entries = \"Y\"                        Then ,\n   Do kk = 1 to ii\n     commands.1 = \" PERMIT '\"||STRIP(dsn)||\"' ID(\"||,\n                  STRIP(std_id.kk)||\") ACCESS(\"||,\n                  STRIP(std_access.kk)||\")\"\n     Call Output_A_Racf_Record\nEnd\n\nIf had_cnd_access_entries = \"Y\"                        Then ,\n   Do kk = 1 to jj\n     commands.1 = \" PERMIT '\"||STRIP(dsn)||\"' ID(\"||,\n                  STRIP(cnd_id.kk)||\") ACCESS(\"||,\n                  STRIP(cnd_access.kk)||\")    +\"\n     Call Output_A_Racf_Record\n\n     commands.1 = \"      WHEN(\"||STRIP(cnd_class.kk)||\"(\"||,\n                  STRIP(cnd_entity.kk)||\"))\"\n     Call Output_A_Racf_Record\nEnd\n\ncommands.1 = \" PERMIT '\"||STRIP(dsn)||\"'\"||,\n             \" ID(\"||LEFT(userid,8,\" \")||\") DELETE\"\nCall Output_A_Racf_Record\n\nSay ;\nSay \"Number of Racf Command Lines Output =>\" output_count\nSay ;\n\nSignal End_Up\n\n\nInitialize_Variables:\n\nhad_p3                     = \"\"\nhad_p4                     = \"\"\nhad_p5                     = \"\"\nhad_p7                     = \"\"\nhad_p9                     = \"\"\nhad_p10                    = \"\"\nhad_p12                    = \"\"\nhad_p14                    = \"\"\nhad_std_access_entries     = \"\"\nhad_cnd_access_entries     = \"\"\nend_std_access_list        = \"\"\nend_cnd_access_list        = \"\"\nii                         = 0\njj                         = 0\nkk                         = 0\ndsn                        = \"\"\nownerid                    = \"\"\nuacc                       = \"\"\nyour_access                = \"\"\nvolser                     = \"\"\naudit_lit                  = \"\"\nnotify_id                  = \"\"\nglobal_audit_lit           = \"\"\nuacc_line_count            = -99\naudit_line_count           = -99\nnotify_line_count          = -99\nyour_access_line_count     = -99\nglobal_audit_line_count    = -99\nvolumes_resides_line_count = -99\nstd_access_list_line_count = -99\ncnd_access_list_line_count = -99\n\nReturn\n\n\nOutput_A_Racf_Record:\n\noutput_count = output_count + 1\n\ncommands.1 = LEFT(commands.1,80,\" \")\n\n\"EXECIO 1 DISKW COMMANDS (STEM commands. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"COMMANDS !!!\"\n   Say \"File COMMANDS was not properly preallocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"Output I/O count is \" output_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS4 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nReturn\n\n\nEnd_Up:\n\n\"EXECIO 0 DISKR SYSPRINT (FINIS\"\ncommands.1   = \"  \"\n\"EXECIO 1 DISKW COMMANDS (STEM commands.\"\n\"EXECIO 0 DISKW COMMANDS (FINIS\"\n\nSay ;\nSay \"REORGVS4 Exec - Generate RACF Commands ...\"\nSay ;\nSay \"version_level                =>\" version_level\nSay ;\nSay \"REORGVS4 exec return code is   \" rtcd\nSay ;\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVS5": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00#\\x01\\x06\\x01o\\x01\\x08&\\x0f\\x12%\\x00\\xc1\\x00\\xa1\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2006-01-16T00:00:00", "modifydate": "2008-09-16T12:25:23", "lines": 193, "newlines": 161, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVS5   (Recreate a VSAM Cluster - Used with the     */\n/*                        REORGVS exec).                              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/16/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/16/2008                         */\n/*                                                                    */\n/*  PURPOSE = This exec will update the log file (LOGFILE) with the   */\n/*            VSAM cluster dataset name and EXPORT image dataset      */\n/*            name and the current julian date for each VSAM file     */\n/*            which was successfully reorganized.                     */\n/*                                                                    */\n/*            The VSAM cluster dataset which is being reorganized     */\n/*            is input on file LIST.  File LIST must be preallocated  */\n/*            prior to the execution of this exec.                    */\n/*                                                                    */\n/*            Input File EXPORT is input to retrieve the EXPORT       */\n/*            dataset name used to hold the backup image of the       */\n/*            VSAM cluster being reorganized.                         */\n/*            File EXPORT must be preallocated prior to the           */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            Output File LOGFILE must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*  Modifications/Tailoring:                                          */\n/*                                                                    */\n/*  Make the following modifications before storing this Rexx exec.   */\n/*                                                                    */\n/*                                                                    */\n/*  1)        Change the length of \"sysid\" to your specification.     */\n/*            The default is 3 characters if this is not              */\n/*            modified.                                               */\n/*                                                                    */\n/*  2)        Change the HLQ of the log dataset to your               */\n/*            specification.  The default is HLQ is \"SYS3\".           */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Invalid input or output files or the files were not       */\n/*          preallocated properly.                                    */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.08\"\nArg parms\nTrace \"O\"\n\nreorg_status = \"\"\ndebug        = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\n         If ABBREV(\"GOOD\",word(parms,i),4) = 1  then Do\n            reorg_status = \"GOOD\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\n         If ABBREV(\"BAD\",word(parms,i),3) = 1  then Do\n            reorg_status = \"BAD\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nuserid        = Userid()\nrtcd          = 0\nsysid         = Left(MVSVAR(sysname),3,\" \")\nlogfile_dsn   = \"SYS3.REORGVS.LOGFILE\"\ninput_count   = 0\n\nGet_Input_Datasets:\n\n\"EXECIO 1 DISKR LIST     (STEM list. \"\nexeciorc     = rc\nIf execiorc  = 2   Then ,        /* On end of file - Finish up  */\n   Signal End_Up\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"LIST !!!\"\n   Say \"File LIST was not properly preallocated or is invalid\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS5 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\ninput_count = input_count + 1\n\ncluster_dsn = STRIP(WORD(list.1,1))\n\nGet_Export_File_Dsn:\n\nlistdsi_rc = LISTDSI(EXPORT FILE)\n\nIf listdsi_rc <> 0   then Do\n   Say \"Error calling LISTDSI function to obtain EXPORT dsname !\"\n   Say \"Return Code =\" listdsi_rc\n   rtcd = listdsi_rc\n   Signal End_Up\nEnd\n\nexport_dsn = sysdsname\n\nSay ;\nSay \"REORGVS5 Exec - Log Reorganization Results ...\"\nSay ;\nSay \"version_level                   =>\" version_level\nSay ;\nSay \"Vsam Cluster Dataset Name       =>\" cluster_dsn\nSay \"Export Image Dataset Name       =>\" export_dsn\nSay \"Reorganization status           =>\" reorg_status \"reorganization\"\n\nOutput_Log_Entry:\n\n\"%DYNALC DD(LOGFILE) DA('\"logfile_dsn\"') DISP(MOD)\",\n     \"ATTEMPTS(1800) INTERVAL(3)\"\ndynalc_rc = rc\n\nIf dynalc_rc <> 0 Then Do\n   Say ;\n   Say \"Error executing the DYNALC exec to allocate logfile dataset\"\n   Say \"    \"\"\"logfile_dsn\"\"\" !\"\n   Say \"DYNALC exec return code is =>\" dynalc_rc\n   Say \"Exec REORGVS5 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\ndatej       = Substr(Date(S),1,4)\"/\"Substr(Date(J),3,3)\ntimex       = Time()\n\nlogfile.1   = Copies(\" \",150)      /* Initialize the LOGFILE record */\nlogfile.1   = OVERLAY(STRIP(cluster_dsn),logfile.1,1,44)\nlogfile.1   = OVERLAY(STRIP(reorg_status),logfile.1,46,4)\nlogfile.1   = OVERLAY(STRIP(export_dsn),logfile.1,51,44)\nlogfile.1   = OVERLAY(STRIP(datej),logfile.1,96,8)\nlogfile.1   = OVERLAY(STRIP(timex),logfile.1,105,8)\n\n\"EXECIO 1 DISKW LOGFILE  (STEM logfile. \"\nexeciorc     = rc\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\",\n       \"LOGFILE !!!\"\n   Say \"File LOGFILE was not properly allocated or invalid\",\n       \"or an I/O error was encountered\"\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS5 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nSay \"Reorganization Result Logged In =>\" logfile_dsn\n\nSignal Get_Input_Datasets\n\nEnd_Up:\n\n\"EXECIO 0 DISKR LIST     (FINIS\"\n\"EXECIO 0 DISKR EXPORT   (FINIS\"\n\"EXECIO 0 DISKW LOGFILE  (FINIS\"\n\nSay ;\nSay \"Dataset Input Count is         \" input_count\nSay ;\nSay \"REORGVS5 exec return code is   \" rtcd\nSay ;\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REORGVS6": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00(\\x01\\x06\\x01\\x7f\\x01\\x08&\\x0f\\x12%\\x00}\\x00g\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2006-01-17T00:00:00", "modifydate": "2008-09-16T12:25:28", "lines": 125, "newlines": 103, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*  MODULE  = REORGVS6   (Recreate a VSAM Cluster - Used with the     */\n/*                        REORGVS exec).                              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 01/17/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 09/16/2008                         */\n/*                                                                    */\n/*  PURPOSE = This exec will input an IDCAMS EXPORT SYSPRINT file and */\n/*            will parse out the return codes and messages to         */\n/*            determine the result of the EXPORT FUNCTION.            */\n/*                                                                    */\n/*            Input File SYSPRINT must be preallocated prior to the   */\n/*            execution of this exec.                                 */\n/*                                                                    */\n/*            If the IDCAMS EXPORT Function completed unsuccessfully  */\n/*            with a return code 12 and Feedback code of 160, return  */\n/*            a return code 0 (the VSAM Cluster was empty) instead of */\n/*            a return code of 12.                                    */\n/*                                                                    */\n/*            For all other results, return the return code which was */\n/*            returned from the IDCAMS EXPORT function in the         */\n/*            SYSPRINT report.                                        */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*                                                                    */\n/*  Modifications/Tailoring:                                          */\n/*                                                                    */\n/*  Make the following modification before storing this Rexx exec.    */\n/*                                                                    */\n/*  1)        Change the length of \"sysid\" to your specification.     */\n/*            The default is 3 characters if this is not              */\n/*            modified.                                               */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Export function was successful.                           */\n/*    2   - The VSAM Cluster input the IDCAMS EXPORT Function was     */\n/*    4   - Export function was successful with warnings.             */\n/*    8   - Export function has syntax error on SYSIN command stream. */\n/*   12   - Export function was unsuccessful.                         */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.08\"\nArg parms\nTrace \"O\"\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nuserid        = Userid()\nrtcd          = 12\n\nsysid         = Left(MVSVAR(sysname),3,\" \")\ninput_count   = 0\n\nRead_SYSPRINT_Loop:\n\ninput_count = input_count + 1\n\n\"EXECIO 1 DISKR SYSPRINT (STEM sysprint. \"\nexeciorc     = rc\nIf execiorc  = 2   Then ,        /* On end of file - Finish up  */\n   Signal End_Up\nIf execiorc <> 0   Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\",\n       \"SYSPRINT !!!\"\n   Say \"File SYSPRINT was not properly preallocated or is invalid\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execiorc\" !!!\"\n   Say \"Exec REORGVS6 is Terminated Prematurely     ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\np1  = POS(\"IDC3351I\",sysprint.1)\nIf p1  > 0                                            Then Do\n   p2  = POS(\"OPEN RETURN CODE IS 160\",sysprint.1)\n   If p2  > 0                                         Then Do\n      rtcd    = 0\n      Signal End_Up\n   End\nEnd\n\nrecord = sysprint.1\nParse var record \"HIGHEST CONDITION CODE WAS\" +26 parse_value +4\nIf parse_value <> \"\"                                  Then Do\n   rtcd    = STRIP(parse_value)\n   Signal End_Up\nEnd\n\nSignal Read_SYSPRINT_Loop\n\nEnd_Up:\n\n\"EXECIO 0 DISKR SYSPRINT (FINIS\"\n\nSay ;\nSay \"REORGVS6 Exec - Get EXPORT Return Code ...\"\nSay ;\nSay \"version_level                =>\" version_level\nSay ;\nSay \"REORGVS6 exec return code is   \" rtcd\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAITFOR": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00A\\x01\\x06#\\x7f\\x01\\x06$O\\x13\\x16\\x00Z\\x00R\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2006-08-25T00:00:00", "modifydate": "2006-09-01T13:16:41", "lines": 90, "newlines": 82, "modlines": 0, "user": "TKMILLE"}, "text": "*******************************************************************\n**    MODULE NAME : WAITFOR                                      **\n**    TYPE        : PROGRAM                                      **\n**    PARAMETERS  : PARM1 ( WAIT TIME AS HHMMSSth FORMAT )       **\n**                                                               **\n**    IT GET'S A PARAMETER. FORMAT OF THIS PARAMETER IS HHMMSSth.**\n**    IT WAITS FOR A TIME THAT IS GIVEN TO THIS PROGRAM AS A     **\n**    PARAMETER. IT EXECUTES STIMER MACRO. AT THE END OF THE     **\n**    WAIT TIME IT RETURNS TO CALLER.                            **\n**                                                               **\n**    THIS PROGRAM WAS FOUND ON THE MAINFRAME WEEKLY WEB SITE:   **\n**    WWW.MAINFRAMEWEEK.COM/CODE/SHOWCODE.PHP/0036/MW36MVS2.TXT  **\n**    AND TAILORED.                                              **\n**                                                               **\n**    REGISTER USAGE:                                            **\n**           R2   WORK REGISTER                                  **\n**           R3   WORK REGISTER                                  **\n**           R4   WORK REGISTER                                  **\n**           R5   UNUSED                                         **\n**           R6   SAVE AREA BACKWARD LINK                        **\n**           R7   PARAMETER LIST ADDRESS                         **\n**        R8-R10  UNUSED                                         **\n**           R11  UNUSED                                         **\n**           R12  BASE REGISTER                                  **\n**           R13  SAVE AREA                                      **\n*******************************************************************\nWAITFOR  CSECT\nWAITFOR  AMODE 31\nWAITFOR  RMODE 24\n***********************************************************************\n         SAVE  (14,12),,WAITFOR_ASSEMBLED_ON_&SYSDATE._&SYSTIME\n         LR    R12,R15              Load entry address\n         USING WAITFOR,R12          Declare entry base\n         LR    R7,R1                Preserve passed parmlist address\n         LR    R6,R13               Store SAVEAREA Backward link\n         L     R3,=A(STORSIZE)      Size of storage to get and clear\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\n**********************************************************************\n*   Pick up the passed stimer wait time (HHMMSSth) - 8 bytes EBCDIC\n**********************************************************************\n         MVC   WAITTIME,WAITINIT     Initialize the Waittime - 0 Secs\n**********************************************************************\n*        This program can be called from a Rexx exec (or via jcl\n*        directly) or from another program as a subroutine call.\n*        Determine the caller's method of calling WAITFOR.\n*        Macro HOWCALLD will determine how this program was called.\n**********************************************************************\n         L     R2,0(,R7)\n         LR    R1,R7                Restore R1\n         HOWCALLD PARMCALL=PARMCALL\n         B     GOWAIT\nPARMCALL DS    0H\n         CLC   0(2,R2),=H'1'        WaitTime must be at least 1 byte\n         BL    GOWAIT               Invalid parm passed Use 0 Seconds\n         CLC   0(2,R2),=H'8'        Must not be longer than 8 bytes\n         BH    GOWAIT               Member Name Parm too long\n         LH    R4,0(,R2)            Pick up the WaitTime length\n         LA    R2,2(,R2)            Pick up the WaitTime Address\n         B     GOWAIT\nGOWAIT   DS    0H\n         MVC   WAITTIME,0(R2)        Move wait time into WAITTIME\n         STIMER WAIT,DINTVL=WAITTIME Issue STIMER WAIT Macro (HHMMSSth)\nRETURN   DS    0H\n         LR    R2,R13               Pointer to storage area\n         L     R3,=A(STORSIZE)      Work area size\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore R14\n         XR    R15,R15              Zero Return Code\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n**********************************************************************\n*    STATIC  STORAGE FOLLOWS\n**********************************************************************\n           LTORG\nWAITINIT   DC   CL8'00000000'       Default Value for Invalid Parms\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS\n**********************************************************************\nSTORAREA   DSECT ,                  Reentrant storage\nSAVEAREA   DS   20F\n           DS   0D                  WAITTIME must be on a DW boundary\nWAITTIME   DS   CL8                 Wait Time as HHMMSSth - EBCDIC\nSTORSIZE   EQU  *-STORAREA\n           YREGS\n           END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT738/FILE738.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT738", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}