{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013558000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE955.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE955.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x0b'", "DS1TRBAL": "b'L^'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xed\\x00\\r\\t\\xee\\x00\\x08\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00G\\x01\\x18\\x01\\x0f\\x01\\x18\\x01\\x0f\\x143\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2018-01-10T00:00:00", "modifydate": "2018-01-10T14:33:47", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-495"}, "text": "REGULAR CBT TAPE - VERSION 495    FILE:  955\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT495.FILE955\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    9440    PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,999 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/10/18    14:33:46    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00@\\x01\\x10\\x15o\\x01\\x17\\x10/#5\\x01\\xbf\\x01\\x88\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-06-05T00:00:00", "modifydate": "2017-04-12T23:35:40", "lines": 447, "newlines": 392, "modlines": 0, "user": "USER03"}, "text": "-------------------------------------------\nRMTLOG\n\nz/OS Remote Logging Facility v1.1\n---------------------------------\n\n\n\n09/12/2016\nJohn C. Miller\njohn@jmit.com\n\n\n\nI - Overview\n------------\n\nRMTLOG is a z/OS started task that transmits z/OS console hardcopy\nmessages to an external RFC 3164/5424 compliant Syslog appliance\nor server.  Its purpose is to enhance z/OS security and auditability\nby establishing near real time logging to an external syslog server.\nSuch a remote syslog appliance/server can be any device that is\ncompliant with RFC 3164 and/or RFC 5424.  Unix and Linux servers\nare typically packaged with syslogd or syslog-ng, both of which are\nRFC compliant.\n\nRMTLOG also demonstrates useful assembler and z/OS programming\ntechniques including:\n- Access Register programming;\n- Extended MCS consoles, including the MSCOPER and MCSOPMSG macros for\n  managing consoles and console message units;\n- TCPIP sockets programming;\n- MVS start/stop interface (Handle START and STOP operator cmds.)\n\nThe two principal components required for z/OS remote logging are the\nRMTLOG z/OS started task running on z/OS, and the remote Syslog\nserver compliant with RFC 3164 and/or 5424.\n\nCOPYRIGHT, LICENSE AND WARRANTY:  This program is Copyright 2010-2017,\nJohn C. Miller.  This program is free software: you can redistribute it\nand/or modify it under the terms of the GNU General Public License\nversion 3 as published by the Free Software Foundation.\n(See Appendix E.)\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nSUPPORT:\nNo support is provided for this software.  This software is a beta\nversion, which means that it may have bugs, and has not been fully\ntested with all possible configurations and conditions.  While not\nrequired, it would be greatly appreciated if you sent your feedback\nto me.\n\nII   How it Works\n-----------------\nINITIALIZATION:\nRMTLOG is an APF authorized started task.  Upon initialization, RMTLOG\nestablishes itself as a software only extended MCS console, with options\nspecified to receive the z/OS HARDCOPY message set.  The RMTLOG started\ntask then sees all hardcopy messages.\n\nThe RMTLOG task runs with settings specified in a parameter file that is\nallocated to the PARMS DDNAME.  See Appendix B for details on the\nparameter file statements.\n\nRMTLOG runs continuously until it is stopped.  It stays in a disabled\nwait until it is given something to do:  Either process a new Message\nData Block (syslog message), process a stop or modify command, or send a\nmessage to the remote syslog server.\n\nSee Appendix A for the started task JCL and Appendix B for the Parameter\nfile parameters and format.\n\nTHE SYSLOG SERVER:\nThe syslog server is a server that accepts UDP datagrams or TCP\nconnections, and writes the payload of these packets to a file as\nspecified in RFC 3164 and/or RFC 5424.  For more information on the\nSyslog protocol (RFC 5424), see http://tools.ietf.or\n\nOPERATION:\nThe RMTLOG server runs as a started task, and should be started as early\nas possible during the IPL process, prior to TCPIP initialization.  In\nsuch a case, RMTLOG will capture and buffer SYSLOG messages while it\nwaits for TCPIP to initialize.  RMTLOG will deliver those buffered\nmessages to the remote SYSLOG server once it is reachable via TCPIP.\n\n\nStart RMTLOG:\nTo start the RMTLOG task, enter the z/OS console command:\n   S RMTLOG\n\nor specify a similar START command in the PARMLIB(COMMNDxx) member, or\nin system automation software if used.\n\nNotes when starting RMTLOG before TCPIP is up:\n- RMTLOG can be started prior to TCP/IP initialization.  In such a\n  case, the RETRYINT and RETRIES parameters in the PARMS member\n  should be set to values that allow for an adequate retry period.\n\n- The SIZE and QLIMIT parameters must be large enough to allow\n  RMTLOG to queue all the hardcopy messages that are issued before\n  TCPIP is initialized, and the remote SYSLOG server can be reached.\n\nStop RMTLOG:\nTo stop the RMTLOG task, issue the z/OS STOP command:\n   P RMTLOG\n\nCommunications or syslog server outages:  If communications disruptions\nto the syslog server occur, or if the syslog server itself has an\noutage, RMTLOG will continue to queue z/OS messages up to the limits\nthat are defined by the QLIMIT and SIZE parameters of the PARMS file.\nOnce communications are restored, the queued messages are sent to the\nsyslog server.\n\nPriority:\nThe RMTLOG started task should be given a high enough dispatching\npriority to ensure that it continues passing Syslog records, and does\nnot have console messages backed up.  RMTLOG should not need to be\nmarked as non-swappable, although this can be d\n\nIII   Other Uses\n----------------\nLog processing tools such as Splunk can be used to view and process log\ndata from a variety of hosts.  By using RMTLOG to get z/OS syslog\nmessages onto a Linux or Unix system, tools such as Splunk can easily be\nused to examine z/OS messages.\n\n\nIV   Future Enhancements\n------------------------\nSome possible future enhancements to RMTLOG include:\n\n1. Allow IP address for Syslog server;\n\n2. Enhance MCS and TCP/IP error handling;\n\n3. Specify multiple Syslog servers for failover.\n\n4. Allow directives in the parameter file to send certain types of\n   records to different servers if desired.\n\n5. Allow directives in the parameter file to exclude or include certain\n   records based on some kind of pattern matching;\n\n6. Allow dynamic changing of parameters in the PARMS member either by\n   allowing changes to be submitted via a MODIFY command, or by\n   allowing the PARMS parameter member to be changed and then\n   refreshed.\n\n7. Establish ESTAE environment to make RMTLOG more bullet-proof.\n\n8. Optimize the code to reduce the instruction path for each syslog\n   record processed.  Currently the data gets copied twice; the program\n   would be more efficient if it only moved the data once.\n\n\nAppendix A   Started PROCEDURE\n------------------------------\n\n//RMTLOG PROC\n//*--------------------------------------------------------------------\n//* RMTLOG - Remote Syslog Task.\n//*--------------------------------------------------------------------\n//* 05/29/2010 John C. Miller.\n//*--------------------------------------------------------------------\n//LOGGER   EXEC PGM=RMTLOG,TIME=1440             <=== (1)\n//STEPLIB  DD DISP=SHR,DSN=SYS2.LINKLIB          <=== (2)\n//PARMS    DD DISP=SHR,DSN=SYS1.PARMLIB(RMTLOG)  <=== (3)\n//SYSTCPD  DD DISP=SHR,DSN=SYS1.TCPIP(TCPDATA)   <=== (4)\n//SYSPRINT DD SYSOUT=*\n\n(1) Execute statement.   TIME=1440 makes this task not time out.\n\n(2) APF authorized link library that contains the RMTLOG module.\n    STEPLIB can be omitted if the RMTLOG module is in a linklist LPA\n    List library.\n\n(3) LRECL(80) file containing the parameters for RMTLOG.\n\n(4) TCPDATA file, if required for your installation.  May be needed for\n    dns name lookup of the remote syslog server, depending on the\n    configuration of TCP/IP on z/OS.\n\n\nAppendix B   Parameter File\n---------------------------\nThe parameter file is an LRECL(80) PDS member that contains settings for\nthe RMTLOG started task.  The parameters are all space delim meaning\nthat each line contains a parameter name, followed by one or more\nspaces, followed by the value for that parameter.  Lines th begin with\neither  #  or  *  in column one are ignored i.e. are treated as\ncomments.  A sample parameter member is supplied with the RMTLOG package\nin member PARMS.\n\nParameter:  Example:            Description:\n------------------------------------------------------------------------\n\nSERVER      rmtlog.jmit.com     Host name of SYSLOG server.  This should\n                                be a partially or fully qualified domain\n                                name for the server that will receive\n                                the syslog records.  Be sure that the\n                                DNS servers specified in the z/OS TCPIP\n                                stack are able to resolve this name.\n\nSERVERIP    70.102.3.45         IP address of SYSLOG server.  Note:\n                                Note:  SERVERIP or SERVER can be coded,\n                                but not both.  An error message will\n                                be issued if both SERVER and SERVERIP\n                                are coded.\n\nHOSTAME     myhost              Overrides the local host name specified\n                                in the active TCPDATA file.  Some syslog\n                                servers use this value to affect how\n                                logs are handled.\n\nPROTO       TCP                 UDP or TCP Specifies the protocol to use\n                                in communicating with the remote SYSLOG\n                                server.  If using the older BSD Syslog\n                                facility (described by RFC 3164) then\n                                only UDP can be specified here, as the\n                                BSD Syslog daemon only responds to UDP\n                                requests.  See Appendix C Syslog Server\n                                for more information on configuring the\n                                Syslog server.\n\nPORT        514                 Usually set to 514. UDP or TCP port to\n                                which RMTLOG will send Syslog messages.\n                                The Syslog Server must be listening on\n                                this port for Syslog requests.\n\nCNAME       RLG01               Up to 8 characters.  The name of the\n                                Extended MCS console.  Mainly or\n                                documentary purposes.  This name can be\n                                used with the D EMCS command   e.g.:\n                                D EMCS,FULL,CN=RLG01\n\nTIMESRC     MESSAGE             MESSAGE: Takes the time stamp from the\n                                z/OS Message Data Block (MDB).  This\n                                will result in the remotely logged\n                                message having the same time stamp as\n                                the original local SYSLOG message.\n                                SYSTEM:  Causes the current z/OS system\n                                time to be placed in the remotely logged\n                                message.\n\nPRI         035                 3 digit number. Default PRI value.  See\n                                Appendix C on Syslog Server, and RFC\n                                3164 and RFC 5424 for an extensive\n                                treatment of the PRI value.  It can be\n                                left as its default value of 035 to\n                                start with.\n\nRETRYINT    15                  Retry seconds.  If the syslog server\n                                cannot be reached, the parameter\n                                determines how long to wait (in seconds)\n                                before retrying the connection.\n\nRETRIES     0                   How many times to retry before giving\n                                up, and issuing a fatal message.  A\n                                value of 0 means to never give up\n                                retrying, and is the recommended value.\n\nSIZE        512                 Number of megabytes allowed for the\n                                messages data space.  Minimum is 1, and\n                                maximum is 2048 (2gb)\n\nQLIMIT      524288              Maximum number of MCS messages that can\n                                be queued.  Maximum value is 2147483647,\n                                (2 billion) which equates to X 7FFFFFFF\n                                .\n\n# Sample RMTLOG parameter file:\n#\nSERVER syslog.jmit.com\nPROTO TCP\nPORT  514\nTIMESRC MESSAGE\nCNAME RLG01\nPRI  035\nRETRYINT 15\nRETRIES 0\nSIZE  512\nQLIMIT 524288\n\n\nAppendix C   Syslog Server\n--------------------------\nHARDWARE / OS PLATFORM The remote Syslog server can be any platform that\nis capable of running an RFC 3164 or RFC 5424 compliant syslog server.\nMost mainst Linux distributions come with a syslog server installed that\nis capable of satisfying the requirements for such a server.  Red Hat En\nLinux (RHEL) 5.3 was used as the development platform for RMTLOG, and\nthe sample configurations in this document are what would be us RHEL or\nCENTOS Linux.  An Intel based Linux or Solaris server is an inexpensive\nbut capable platform for hosting the remote Syslog se\n\nSYSLOG SOFTWARE:\nMany Linux distributions come with the BSD Syslog facility already\ninstalled.  BSD Syslog only accepts UDP syslog requests, not TCP.  best\nresults, it is recommended that BSD Syslog be either uninstalled or\ndisabled, and Syslog-ng (Next Generation) be installed inste Syslog-ng\ncan be configured to accept either UDP or TCP syslog requests, and TCP\nconnections offer the benefits of greater reliabilit and proper\nsequencing of records even under congested network situations.\nSyslog-ng can be downloaded from the Syslog-ng home page a\nhttp://www.balabit.com/network-security/syslog-ng/\n\nAn Open Source (free) version of Syslog-ng is available at this site, as\nis a  Premium  (i.e. not free) version.  The free version wo fine for\nthe purposes of RMTLOG.  This site has information on configuring\nSyslog-ng, but a sample configuration (such as was used in development\nof RMTLOG) is shown below.\n\nSAMPLE SYSLOG-NG  CONFIGURATION FOR USE WITH RMTLOG:\n\n@version: 3.0\n#\n# Syslog-ng configuration for use with RMTLOG\n#\noptions {\n  use_fqdn(no);\n  keep_hostname(yes);\n  use_dns(no);\n  dns_cache(no);\n  long_hostnames(off);\n  };\n\n#---\n# Default source for internal messages.\n#---\nsource s_local {\ninternal();\nunix-stream(\"/dev/log\");\n# messages from the kernel\nfile(\"/proc/kmsg\" program_override(\"kernel: \"));\n};\n\n#---\n# Default destination for internal messages.\n#---\ndestination d_messages { file(\"/var/log/messages\"); };\n\n\n\n#---\n# RMTLOG source and destination.  The destination as coded here will res\n# in a separate log file for each host that is logged in the directory:\n# /var/log/HOSTS/<hostname>.  This can be changed as desired.\n#---\nsource TCP_UDP {\n  tcp( port(514));\n  udp( port(514));\n  };\n\ndestination logip {\n  file(\"/var/log/HOSTS/$HOST\" perm(0600) create_dirs(no) dir_perm(0700)\n  };\n\n#---\n# Source and destination connections.\n#---\nlog {\n  source(s_local);\n  destination(d_messages);\n  source(TCP_UDP);\n  destination(logip);\n  };\n\nRED HAT ENTERPRISE LINUX (RHEL) 5.X CONFIGURATION\nListening:\nIf a BSD Syslog server is chosen, then the following changes need to be\nmade to the RHEL configuration:  In the file /etc/sysconfig/syslog, add\nthe  -r  flag to SYSLOGD_OPTIONS.  When finished, it should look\nsomething like this:\n\nSYSLOGD_OPTIONS=\"-m 0 -r\"\n\nIf the Syslog-ng syslog server is installed, the above change is not\nneeded.  Syslog-ng already listens on both UDP and TCP port 514 TCP\ndirective in the Source entry in the configuration file.\n\nFirewall:\nThe firewall must be instructed to allow inbound datagrams / packets on\nport 514.  For RHEL5, select GUI as follows:  System / Admini Level and\nFirewall.\n\nClick the  Other Ports  arrow, and then click the  Add  button, specify\nthe port number (e.g. 514) and type (UDP or TCP).  Click OK t\n\nOTHER CONFIGURATION ISSUES:\nLog file size and location:  As Syslog data can grow to be quite large,\nit is strongly recommended that the Syslog files be mounted on a\nseparate, dedicated file prevent the Syslog server system from crashing\nif the log files become  full.  It is also recommended that the file\nsystem that is to as large as possible to prevent running out of\nstorage.\n\nLog Rotation:\nUse of the logrotate package on Linux platforms is highly recommended.\nLogrotate will automatically break up the log file into a siz and\ncompress these files for maximum space efficiency.  For more\ninformation, Google on  logrotate rhel  for example, if RHEL is the\n\n\nNetwork connectivity:\nHosts that are sending Syslog records to the Syslog server should have\nrobust, high-speed network connectivity to the Syslog server w\n\nDedication:\nIt is strongly recommended that the Syslog server be dedicated solely to\nrecording syslog records from remote hosts.  Other workloads timely\nprocessing of Syslog recording requests.\n\n\n\n\nAppendix D - RMTLOG Messages\n---------------------\nRLG000I RMTLOG Starting shutdown.\nRLG002I Console not deactivated, was not active.\nRLG003I MCS console activated.\nRLG004I MCS Console failed to activate.\nRLG005I MCS Console deactivated.\nRLG006I MCS Console deactivate failed.\nRLG009I Waiting for connection to syslog server.\nRLG010I Error processing MDB.\nRLG011I RMTLOG is active.\nRLG012I Issuing MCSOPMSG RESUME.\nRLG016I Message queueing stopped, memory limit.\nRLG017I Message queueing stopped, queue depth reached.\nRLG018I Message queueing stopped, internal error.\nRLG019I Message queueing stopped, alert percentage reached.\nRLG020I RMTLOG Starting initialization phase 2.\nRLG021I RMTLOG Starting initialization phase 1.\nRLG023I Default value assigned for parameter:\nRLG024I Neither SERVER nor SERVERIP coded, one is required - exiting.\nRLG025I SERVER and SERVERIP both coded, but only one allowed - exiting.\nRLG032I TCP protocol selected.\nRLG033I UDP protocol selected.\nRLG034I Unable to determine local hostname.\nRLG035I Error creating socket.\nRLG036I Error connecting socket.\nRLG037I Waiting for TCPIP initialization.\nRLG053I Error opening parameter file.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$INDEX": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x01\\x164O\\x01\\x164O\\x179\\x00\\x15\\x00\\x13\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-12-09T00:00:00", "modifydate": "2016-12-09T17:39:01", "lines": 21, "newlines": 19, "modlines": 0, "user": "USER03"}, "text": "Members in this PDS.\n--------------------\n\nASM      - Assemble all modules and load module for rmtlog.\nASM$     - Assemble proc.\nIPADDR   - Support module for RMTLOG.\nJULIAN   - Support module for RMTLOG.\nPARMS    - Sample PARMS member for RMTLOG.\nRACFUSR  - Sample CLIST to set up RACF user, STARTED profile, etc.\nRECON    - Support module for RMTLOG.\nRLCLOS   - Support module for RMTLOG.\nRLCOMM   - Support module for RMTLOG.\nRLINCL   - Support module for RMTLOG.\nRLINIT1  - Support module for RMTLOG.\nRLINIT2  - Support module for RMTLOG.\nRLWRITE  - Support module for RMTLOG.\nRLWRITEL - Support module for RMTLOG.\nRMTLOG   - Main RMTLOG module.\nRMTLOG$  - Sample PROC for RMTLOG started task.\nRMTLOG00\nSTR      - String manipulation macro for RMTLOG.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$GPL": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00P\\x01\\x10\\x16o\\x01\\x164O\\x189\\x02\\xa2\\x02\\xa3\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-06-15T00:00:00", "modifydate": "2016-12-09T18:39:50", "lines": 674, "newlines": 675, "modlines": 0, "user": "USER03"}, "text": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds o\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporatio\ninto a dwelling.  In determining whether a product is a consumer product\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product fro\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders o\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you m\nnot convey it at all.  For example, if you agree to terms that obligate\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions o\nthe GNU General Public License from time to time.  Such new versions wil\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANT\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGR\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEY\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS O\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THI\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY O\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these ter\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it doe\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `sh\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropri\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or sch\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, s\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your prog\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications w\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00$\\x01\\x10\\x15o\\x01\\x164O\\x18\\x14\\x00 \\x00\\x03\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2010-06-05T00:00:00", "modifydate": "2016-12-09T18:14:24", "lines": 32, "newlines": 3, "modlines": 0, "user": "USER03"}, "text": "Quick Install Instructions:\n---------------------------\n\n1) Modify the ASM member to reflect your local libraries, and run.  The\n   job should complete with a condition code of 0.\n\n2) Create and customize a PARMS member.  See the $$$DOC member for more\n   information.  A sample PARMS members is included in this PDS.\n\n3) Create a started PROC.  You may need to create a STARTED RACF profile\n   for the new started task.  Use member RMTLOG$ in this PDS as an\n   example, changing the data set names as appropriate.\n\n4) Configure and start a syslog server as per the $$$DOC member.\n\n5) Start RMTLOG with the command: S RMTLOG\n\nYou should see z/OS messages in the log file of the SYSLOG server.\n\nNote:\nIt does not matter which is started first, the RMTLOG started task,\nthe remote syslog server, or TCPIP.  If RMTLOG is started first, it\nwill buffer z/OS syslog messages while it continues retrying the\nTCPIP socket init, and while waiting for the remote syslog server to\nstart responding.\n\n\nIf RMTLOG is started before TCPIP and the remote syslog server, be sure\nthat the RETRYINT and RETRIES settings are set appropriately in the\nPARMS member.\n\nJohn C. Miller 09/2016 - software@jmit.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$RELEASE": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x06\\x01\\x101_\\x01\\x164O\\x18\\x08\\x00\\x11\\x00\\x02\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2016-12-09T18:08:06", "lines": 17, "newlines": 2, "modlines": 0, "user": "USER03"}, "text": "Release Notes:\n--------------\n09/21/2016 -\nTested and operational on z/OS 2.0 without reassembly.\n\n11/10/2010 -\nv1.1\nAdded SERVERIP parameter to allow specifying syslog server by ipv4\naddress instead of by domain name.  I am not calling this code beta any\nlonger, as it has been in production on at least one z/OS system for\nover 5 years.  However it would be helpful to have any feedback or bug\nreports.\n\n06/20/2010 -\nv1.0 (beta)\nOriginal version, developed on z/OS 1.10. I'm calling this a beta\nversion mainly because it's only been run at a couple of sites.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE955": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x008\\x01\\x18\\x01\\x0f\\x01\\x18\\x01\\x0f\\x143\\x00@\\x00@\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2018-01-10T00:00:00", "modifydate": "2018-01-10T14:33:38", "lines": 64, "newlines": 64, "modlines": 0, "user": "CBT-495"}, "text": "//***FILE 955 is from John C. Miller and contains his remote        *   FILE 955\n//*           logging facility.  A more detailsd description        *   FILE 955\n//*           follows, and you should look at member $$$DOC         *   FILE 955\n//*           for more information                                  *   FILE 955\n//*                                                                 *   FILE 955\n//*     RMTLOG                                                      *   FILE 955\n//*                                                                 *   FILE 955\n//*     z/OS Remote Logging Facility v1.1                           *   FILE 955\n//*     ---------------------------------                           *   FILE 955\n//*                                                                 *   FILE 955\n//*     09/12/2016                                                  *   FILE 955\n//*     John C. Miller                                              *   FILE 955\n//*     john@jmit.com                                               *   FILE 955\n//*                                                                 *   FILE 955\n//*     I - Overview                                                *   FILE 955\n//*     ------------                                                *   FILE 955\n//*                                                                 *   FILE 955\n//*     RMTLOG is a z/OS started task that transmits z/OS           *   FILE 955\n//*     console hardcopy messages to an external RFC 3164/5424      *   FILE 955\n//*     compliant Syslog appliance or server.  Its purpose is to    *   FILE 955\n//*     enhance z/OS security and auditability by establishing      *   FILE 955\n//*     near real time logging to an external syslog server.        *   FILE 955\n//*     Such a remote syslog appliance/server can be any device     *   FILE 955\n//*     that is compliant with RFC 3164 and/or RFC 5424.  Unix      *   FILE 955\n//*     and Linux servers are typically packaged with syslogd or    *   FILE 955\n//*     syslog-ng, both of which are RFC compliant.                 *   FILE 955\n//*                                                                 *   FILE 955\n//*     RMTLOG also demonstrates useful assembler and z/OS          *   FILE 955\n//*     programming techniques including:                           *   FILE 955\n//*                                                                 *   FILE 955\n//*     - Access Register programming;                              *   FILE 955\n//*     - Extended MCS consoles, including the MCSOPER and          *   FILE 955\n//*       MCSOPMSG macros for managing consoles and console         *   FILE 955\n//*       message units;                                            *   FILE 955\n//*     - TCPIP sockets programming;                                *   FILE 955\n//*     - MVS start/stop interface (Handle START and STOP           *   FILE 955\n//*       operator cmds.)                                           *   FILE 955\n//*                                                                 *   FILE 955\n//*     The two principal components required for z/OS remote       *   FILE 955\n//*     logging are the RMTLOG z/OS started task running on         *   FILE 955\n//*     z/OS, and the remote Syslog server compliant with RFC       *   FILE 955\n//*     3164 and/or 5424.                                           *   FILE 955\n//*                                                                 *   FILE 955\n//*     COPYRIGHT, LICENSE AND WARRANTY:  This program is           *   FILE 955\n//*     Copyright 2010-2017, John C. Miller.  This program is       *   FILE 955\n//*     free software: you can redistribute it and/or modify it     *   FILE 955\n//*     under the terms of the GNU General Public License           *   FILE 955\n//*     version 3 as published by the Free Software Foundation.     *   FILE 955\n//*     (See Appendix E.)                                           *   FILE 955\n//*                                                                 *   FILE 955\n//*     This program is distributed in the hope that it will be     *   FILE 955\n//*     useful, but WITHOUT ANY WARRANTY; without even the          *   FILE 955\n//*     implied warranty of MERCHANTABILITY or FITNESS FOR A        *   FILE 955\n//*     PARTICULAR PURPOSE.  See the GNU General Public License     *   FILE 955\n//*     for more details.                                           *   FILE 955\n//*                                                                 *   FILE 955\n//*     SUPPORT:                                                    *   FILE 955\n//*     No support is provided for this software.  This software    *   FILE 955\n//*     is a beta version, which means that it may have bugs,       *   FILE 955\n//*     and has not been fully tested with all possible             *   FILE 955\n//*     configurations and conditions.  While not required, it      *   FILE 955\n//*     would be greatly appreciated if you sent your feedback      *   FILE 955\n//*     to me.  email:  john@jmit.com                               *   FILE 955\n//*                                                                 *   FILE 955\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASM": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x19\\x01\\x10\\x15o\\x01\\x164O\\x18@\\x00\\x1b\\x00\\x17\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2010-06-05T00:00:00", "modifydate": "2016-12-09T18:40:19", "lines": 27, "newlines": 23, "modlines": 0, "user": "USER03"}, "text": "//Z90008A JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=T,REGION=64M\n/*JOBPARM L=999999\n//*-------------------------------------------------------------------\n//* COMPILE AND LINK RMTLOG\n//*-------------------------------------------------------------------\n//* 12/09/2010 John C. Miller\n//*-------------------------------------------------------------------\n//* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.\n//*-------------------------------------------------------------------\n//* Fix the jobcard as appropriate.  Then set the following values to\n//* something appropriate for your site, and run this job.\n//*-------------------------------------------------------------------\n// JCLLIB ORDER=USER03.RMTLOG.V01B      <-- Name of this install PDS.\n// SET  INSTLIB=USER03.RMTLOG.V01B      <-- Name of this install PDS.\n// SET  LINKLIB=SYS2.LINKLIB            <-- Name of target loadlib.\n// SET  SEZACMAC=TCPIP.SEZACMAC         <-- Your TCPIP SEZACMAC.\n// SET  SEZATCP=TCPIP.SEZATCP           <-- Your TCPIP SEZATCP.\n//*-------------------------------------------------------------------\n//IPADDR   EXEC ASM$,M=IPADDR\n//JULIAN   EXEC ASM$,M=JULIAN\n//RECON    EXEC ASM$,M=RECON\n//RLCLOS   EXEC ASM$,M=RLCLOS\n//RLINIT1  EXEC ASM$,M=RLINIT1\n//RLINIT2  EXEC ASM$,M=RLINIT2\n//RLWRITE  EXEC ASM$,M=RLWRITE\n//RMTLOG   EXEC ASM$,M=RMTLOG\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASM$": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x13\\x01\\x10\\x16O\\x01\\x164O\\x18@\\x00 \\x00&\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2010-06-13T00:00:00", "modifydate": "2016-12-09T18:40:13", "lines": 32, "newlines": 38, "modlines": 0, "user": "USER03"}, "text": "//ASM$     PROC M=,AMODE=31\n//*-------------------------------------------------------------------\n//* PROC - COMPILE AND LINK RMTLOG\n//*-------------------------------------------------------------------\n//* PROC - COMPILE AND LINK RMTLOG\n//*----------------------------------------------assemble-------------\n//C        EXEC PGM=ASMA90,\n//    PARM='NODECK,XREF(SHORT),RENT'\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=3390,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=3390,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=3390,SPACE=(CYL,(20,20))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=&SEZACMAC\n//         DD DISP=SHR,DSN=&INSTLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS,DELETE),\n//            BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1\n//SYSIN    DD DISP=SHR,DSN=&INSTLIB(&M)\n//*----------------------------------------------linkedit-------------\n//L        EXEC PGM=IEWL,COND=(4,LT,C),\n//         PARM='XREF,LIST,MAP,LET,CALL,AMODE=&AMODE'\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=&LINKLIB\n//         DD  DISP=SHR,DSN=&SEZATCP\n//SYSLMOD  DD  DISP=SHR,DSN=&LINKLIB\n//SYSIN    DD  DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IPADDR": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00$\\x01\\x101_\\x01\\x164O\\x18@\\x00\\x9c\\x008\\x00E\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2016-12-09T18:40:24", "lines": 156, "newlines": 56, "modlines": 69, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* IPADDR  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* Convert a text IP address to a fullword IP address.                 *\n*---------------------------------------------------------------------*\n* There are no doubt more elegant implementations of this function;   *\n* Feel free to email me with yours.                                   *\n*---------------------------------------------------------------------*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\nIPADDR   CSECT\nIPADDR   AMODE ANY\nIPADDR   RMODE ANY\n         PRINT GEN,DATA\n         YREGS                      Do register equates.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Prolog - Get private and common storage areas and set up.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING IPADDR,R12           Addressability.\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         ST    R2,R1SAVE            Save R1 contents.\n         LR    R1,R2                Get original R1 for CPPL/PUTLINE.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Get pointer to text IP address passed by caller.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         L     R3,0(R1)\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*             7        8     9     2              4      5(i)         *\n*             v        v     v     v              v      v            *\n* IPSTR:---> '80.81.82.83.....'    .... .... .... ....                *\n*                                  IP1  IP2  IP3  IP4                 *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         MVC   IPSTR,0(R3)         Move user IP address.\n*        MVC   IPSTR,=CL16' 80.81.82.83 '\n         MVC   IPS,=XL16'F0'       Clear 4 target string octets.\n         LA    R7,IPSTR            -> IP string.\n         LA    R9,15(R7)           -> End of IP string.\n         LR    R8,R9                    \"\n         LA    R4,IP4              -> Last IP target string.\n         LA    R5,3                Load index register.\n         LA    R2,IPS              -> Start of IP target strings.\nIPTOP0   DS    0H\n         CR    R8,R7               Done with all chars?\n         BL    IPDONE              Yes, process last octet.\n         CLI   0(R8),C' '          Spaces (end of IP not fnd yet)?\n         BNE   IPTOP               No, end of ip was found, keep going.\n         BCTR  R8,0                Back up one.\n         B     IPTOP0              Top of loop.\nIPTOP    DS    0H\n         CR    R8,R7               Done with all chars?\n         BL    IPDONE              Yes, process last octet.\n         CLI   0(R8),C' '          Spaces (end of IP not fnd yet)?\n         BE    IPDONE              Yes, leading space means we're done.\n         CLI   0(R8),C'.'          '.' (end of octet)?\n         BE    NEXTOCT             Yes, process octet.\n         IC    R1,0(R8)            Get next character.\n         STC   R1,0(R5,R4)         Store it.\n         BCTR  R8,0                Back up one.\n         BCTR  R5,0                Decrement index register.\n         B     IPTOP               Top of loop.\nNEXTOCT  DS    0H\n         BCTR  R8,0                Back up past '.'\n         LA    R5,3                Load index reg again.\n         S     R4,=A(4)            POINT TO NEXT IP TARGET.\n         CR    R4,R2               Done with all octets?\n         BNL   IPTOP\nIPDONE   DS    0H\n         L     R1,IP1\n         BAL   R11,CVB4            Convert a byte\n         STC   R1,IPBYTE1\n*---\n         L     R1,IP2\n         BAL   R11,CVB4            Convert a byte\n         STC   R1,IPBYTE2\n*---\n         L     R1,IP3\n         BAL   R11,CVB4            Convert a byte\n         STC   R1,IPBYTE3\n*---\n         L     R1,IP4\n         BAL   R11,CVB4            Convert a byte\n         STC   R1,IPBYTE4\n*---\n         L     R2,IP\n         ST    R2,0(R3)            Store binary IP addr in user stg.\n*---------------------------------------------------------------------*\n* Exit - Release storage and return to caller.                        *\n*---------------------------------------------------------------------*\nEXIT     DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*  Convert a 4 character, right justified number to hex.     Strg:    *\n*  E.G.: C'  12' -> X'000C'                               WRKD  DS 0D *\n*  Entry: R1 - Contains field to convert.                 WRKD1 DS F  *\n*  Exit:  R1 -> 2 byte (halfword) text field.             WRKD2 DS F  *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCVB4     DS    0H\n         XC    WRKD,WRKD           Clear DBLWORD work field.\n         ST    R1,WRKD2            Store chars to conver to wrk field.\n         PACK  WRKD2,WRKD2         Make packed decimal.\n         OI    WRKD2+3,X'0F'       Fix sign.\n         CVB   R1,WRKD             Convert to binary.\n         BR    R11\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT                     Dynamic area.\nSAVE     DS    18F                 Register save area.  Must be first\nR1SAVE   DS    F\n*---\nIPSTR    DS    CL16\nIP       DS    0F\nIPBYTE1  DS    C\nIPBYTE2  DS    C\nIPBYTE3  DS    C\nIPBYTE4  DS    C\nUNPACK   DS    2F\nIPS      DS    0CL16\nIP1      DS    CL4\nIP2      DS    CL4\nIP3      DS    CL4\nIP4      DS    CL4\nDBL      DS    D\nDBL2     DS    D\nWRKD     DS    0D\nWRKD1    DS    F\nWRKD2    DS    F\nWRKF     DS    F\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU    *-DATD\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* DSECT mapping macros.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         END   IPADDR\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    IPADDR       '\n         PUNCH ' NAME     IPADDR(R)    '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JULIAN": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00T\\x01\\x10\\x15o\\x01\\x164O\\x18@\\x00\\xb5\\x00\\xa3\\x00\\xa5\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-06-05T00:00:00", "modifydate": "2016-12-09T18:40:54", "lines": 181, "newlines": 163, "modlines": 165, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* JULIAN - Convert date to/from Julian.                               *\n*---------------------------------------------------------------------*\n* Input - R1 -> parameter list:                                       *\n* +0 - -> CL7 field, like: C'2010123'                                 *\n* +4 - -> XL1 Options field:                                          *\n*    EQU  X'80' - Convert to Julian. (**)                             *\n*    EQU  X'40' - Convert to Gregorian.                               *\n*    EQU  X'20' - Return EBCDIC date like: mm/dd/yyyy                 *\n*    EQU  X'10' - Return EBCDIC date like: Jun 25 2010                *\n*    EQU  X'08' - Return binary date like: X'20101115' (**)           *\n* +8 - -> Output field to contain converted date.                     *\n* Output: R1 -> parameter list:                                       *\n*                                                                     *\n* (**) - Not yet implemented.                                         *\n*---------------------------------------------------------------------*\n* 06/04/2010 John C. Miller - john@jmit.com                           *\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\nJULIAN   CSECT\nJULIAN   AMODE ANY\nJULIAN   RMODE ANY\n         PRINT GEN,DATA\n         YREGS                     Do register equates.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Prolog - Get private and common storage areas and set up.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING JULIAN,R12           Addressability.\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         LR    R1,R2                Get original R1 for CPPL/PUTLINE.\n         L     R3,0(R2)             -> date to convert.\n         MVC   JULDATE,0(R3)        Move date.\n         L     R3,4(R2)             -> options byte.\n         MVC   FLAG,0(R3)           move options byte.\n*        MVI   FLAG,X'50'          TEST\n*        MVC   JULDATE,=C'2012156' TEST\n         L     R3,8(R2)            -> output variable.\n         TM    FLAG,X'40'          Convert to gregorian?\n         BO    GREGORN             Yes, do that.\n         B     EXIT                No, exit.\n*---------------------------------------------------------------------*\n* GREGORIAN - Convert Julian to Gregorian.                            *\n*---------------------------------------------------------------------*\nGREGORN  DS    0H\n         PACK  WRKD,YYYYC          Convert year to packed decimal.\n         CVB   R2,WRKD             Convert to binary.\n         ST    R2,YYYYB            Store binary year.\n         PACK  WRKD,DDDC           Convert day to packed decimal.\n         CVB   R2,WRKD             Convert to binary.\n         ST    R2,DDDB             Store binary day.\n         MVC   WMONSH,MONSH\n         TM    YYYYB+3,B'00000011' Is year divisible by 4?\n         BNZ   DPM365              No, not a leap year.\n         CLC   YYYYC+2,=C'00'      Is year centenary (century)\n         BNE   DPM366              No, this is a leap year.\n         L     R15,YYYYB           Load binary year.\n         SR    R14,R14             Clear high word for divide.\n         D     R14,=F'400'         Divide by 400.\n         LTR   R14,R14             Is year evenly divisible by 400?\n         BNZ   DPM365              No, then not a leap year.\nDPM366   DS    0H                  Yes, add 1 to February days.\n         MVI   WMONSH+3,29\nDPM365   DS    0H\n         LA    R4,WMONSH           -> month array.\n         SR    R10,R10             Clear index reg.\n         SR    R9,R9               Clear reg.\n         L     R8,DDDB             Get Julian days in reg.\n*---------------------------------------------------------------------*\n* WMONSH contains a series of halfwords with the length of each       *\n* month Jan-Dec.                                                      *\n* 001F 001C 001F 001E 001F 001E 001F 001F 001E 001F 001E 001F         *\n*---------------------------------------------------------------------*\nJTOP     DS    0H\n         AH    R9,WMONSH(R10)      Add number of days in this month.\n         ST    R9,TST9\n         CR    R8,R9               Are jdays < cumulative days?\n         BL    JDCALC              No, go figure out day.\n         LA    R10,2(R10)          -> next month's days.\n         B     JTOP                Check again.\nJDCALC   DS    0H\n         SH    R9,WMONSH(R10)      Take this month back off.\n         SR    R8,R9               Subtract binary julian days for day.\n         SRL   R10,1               /2 to get month.\n*        Convert day to EBCDIC.\n         CVD   R8,WRKD             Convert day to packed decimal.\n         OI    WRKD+7,X'0F'        Fix sign.\n         UNPK  WRKD(2),WRKD+6(2)   Unpack it\n         MVC   DAY,WRKD            Move to DAY field.\n*        TPUT  DAY,2\n         TM    FLAG,X'10'          \"Jan 25 2010\" style date?\n         BO    JANSTYLE            Yes, go do it.\nTERSESTY DS    0H\n         MVC   0(10,R3),=CL11' '   Initialize output to blanks.\n         MVC   3(2,R3),DAY         Move DAY to output in TERSE format.\n         MVI   2(R3),C'/'          Move slash.\n         MVI   5(R3),C'/'          Move slash.\n         LA    R10,1(R10)          Add 1 for month.\n         CVD   R10,WRKD            Convert month to packed decimal.\n         OI    WRKD+7,X'0F'        Fix sign.\n         UNPK  0(2,R3),WRKD+6(2)   Unpack it\n         MVC   6(4,R3),YYYYC       Move year.\n         B     EXIT                Leave.\nJANSTYLE DS    0H                  R10 contains month-1 in binary.\n         MVC   0(11,R3),=CL11' '   Initialize output to blanks.\n         SLL   R10,2               Multiply R10 x 2\n         LA    R4,MONS             Point to month constants.\n         L     R5,0(R4,R10)        Load month constant.\n         ST    R5,0(R3)            Store mon in \"Jan \" fmt in output.\n         MVC   4(2,R3),DAY         Move Day.\n         MVI   6(R3),C' '\n         MVC   7(4,R3),YYYYC       Move year.\n*---------------------------------------------------------------------*\n* Exit - Release storage and return to caller.                        *\n*---------------------------------------------------------------------*\nEXIT     DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n         DC    X'0D25'\nMONSH    DC    H'31,28,31,30,31,30,31,31,30,31,30,31,999'\nMONSHL   EQU   *-MONSH\nMONS     DC    C'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT                     Dynamic area.\nSAVE     DS    18F                 Register save area.  Must be first\n*---\nDWORK    DS    D\nWRK      DS    CL8\nJULDATE  DS    0CL7\nYYYYC    DS    CL4\nDDDC     DS    CL3\nYYYYB    DS    F\nDDDB     DS    F\nWRKD     DS    D\nWRKF     DS    F\nWMONSH   DS    CL(MONSHL)\nTST9     DS    F\nFLAG     DS    X\nDAY      DS    CL2\n*\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* M I S C . . . . . . . . . . .\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU    *-DATD\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* DSECT mapping macros.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         END   JULIAN\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' ENTRY    JULIAN       '\n         PUNCH ' NAME     JULIAN(R)    '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARMS": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00X\\x01\\x10\\x13o\\x01\\x164O\\x18@\\x003\\x00\\x07\\x003\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-05-16T00:00:00", "modifydate": "2016-12-09T18:40:58", "lines": 51, "newlines": 7, "modlines": 51, "user": "USER03"}, "text": "*---------------------------------------------------------------------\n* Parameter file for RMTLOG, the remote syslog task.\n*---------------------------------------------------------------------\n* 05/15/2010 John C. Miller\n*---------------------------------------------------------------------\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.\n*---------------------------------------------------------------------\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* HOSTNAME: Overrides hostname from TCPDATA.                          *\n* SERVERIP  IP address of SYSLOGD server.                             *\n* PROTO:    UDP or TCP.  TCP is preferred, if supported by server.    *\n* PORT:     UDP or TCP port to contact the syslogd server.            *\n* CNAME:    MCS Console name.                                         *\n* PRI:      Default PRI value for message.                            *\n* RETRYINT: How many seconds to wait between communications retries.  *\n* RETRIES:  How many times to retry comm.  0 means retry forever.     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n\n*HOSTNAME ZOS1000\n SERVERIP 172.31.5.9\n PROTO    TCP\n PORT     514\n CNAME    RLG06\n PRI      035\n*         hhmmss\n RETRYINT 000015\n RETRIES  0\n\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* TIMESRC: SYSTEM | MESSAGE                                           *\n* Get the time stamp from the MVS system, the message block, or let   *\n* the SYSLOGD serve set the time in the log message.                  *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n TIMESRC  MESSAGE\n\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* QLIMIT: The max number of MCS messages that can be queued.          *\n* 2147483647 (2 billion) is the maximum value.                        *\n* QLIMIT   2147483647\n* ALERTPCT - Percentage of console buffer usage at which a warning    *\n* message is issued.                                                  *\n* QRESUME  - Percentage of console buffer usage at logging resumes    *\n* automatically.                                                      *\n* SIZE: The max number of megabytes for the messages data space.      *\n* 2048 (2gb) is the maximum value.                                    *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n QLIMIT   524800\n*QLIMIT   100\n SIZE     512\n ALERTPCT 80\n QRESUME  99\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RACFUSR": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x02\\x01\\x104?\\x01\\x164O\\x18A\\x00\\x0f\\x00\\x0c\\x00\\x0f\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-12-09T00:00:00", "modifydate": "2016-12-09T18:41:02", "lines": 15, "newlines": 12, "modlines": 15, "user": "USER03"}, "text": "PROC 00\n/*------------------------------------------------------------------*/\n/* Sample CLIST to set userid and STARTED profile for the RMTLOG    */\n/* task.                                                            */\n/*------------------------------------------------------------------*/\n/* RMTLOG Remote logging program copyright 2010-2017 John C. Miller */\n/*------------------------------------------------------------------*/\nADDUSER RMTLOG DFLTGRP(STCGRP) OWNER(TECHSVCS)\n\nRDELETE STARTED RMTLOG.*\n\nRDEFINE STARTED RMTLOG.* OWNER(TECHSVCS) +\n   STDATA(USER(RMTLOG) GROUP(STCGRP) TRUSTED(NO))\n\nSETR RACLIST(STARTED) REFRESH\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECON": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x10\\x01\\x10\\x15O\\x01\\x164O\\x18A\\x00\\xaa\\x00\\xa3\\x00\\xaa\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2010-06-03T00:00:00", "modifydate": "2016-12-09T18:41:10", "lines": 170, "newlines": 163, "modlines": 170, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RMTLOG  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* RECON - Reconnect a broken connection.                              *\n*---------------------------------------------------------------------*\n* Entry (Called by RMTLOG):                                           *\n* - R11 - Points to common storage area.  Use this for base reg.      *\n* Regs:                                                               *\n* - R12 - Base register for this program.                             *\n* - R13 - Points to private storage area.                             *\n*---------------------------------------------------------------------*\n* 1) Shutdown current socket.                                         *\n* 2) Close socket.                                                    *\n* 3) Get new socket.                                                  *\n* 4) Connect to host.                                                 *\n*---------------------------------------------------------------------*\n* 06/01/2010 John C. Miller - software@jmit.com                       *\n*---------------------------------------------------------------------*\n*\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\n         PRINT GEN,DATA\nRECON    CSECT\nRECON    AMODE ANY\nRECON    RMODE ANY\n         YREGS\n*---------------------------------------------------------------------*\n* Prolog - Get private and common areas, and get set up.\n*---------------------------------------------------------------------*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING RECON,R12            \"\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         USING RLCOMM,R11           Addressability to common area.\n*        TPUT  =CL50'RECON-----------',50\n*---------------------------------------------------------------------*\n* SHUTSOC - Shut down socket.  The HOW variable is a fullword         *\n* containing the type of shutdown: 1 = TO, 0 = FROM, 2 = BOTH.        *\n* Don't error check.                                                  *\n*---------------------------------------------------------------------*\nSHUTSOC  DS    0H\n         MVC   HOW,=F'2'           Set to close both directions.\n         EZASMI TYPE=SHUTDOWN,     Shutdown.                           X\n               S=S,                Socket.                             X\n               HOW=HOW,            Mode (Both directions).             X\n               ERRNO=ERRNO,        Output: ERRNO                       X\n               RETCODE=RETCODE,    Output: RETCODE                     X\n               ERROR=ERROR         Abend if Macro error\n*        TPUT  =CL50'SHUTSOC',50\n*---------------------------------------------------------------------*\n* CLOSESC - Close socket and free resources.                          *\n*---------------------------------------------------------------------*\nCLOSESC  DS    0H\n         EZASMI TYPE=CLOSE,        Close.                              X\n               S=S,                Socket.                             X\n               ERRNO=ERRNO,        Output: ERRNO                       X\n               RETCODE=RETCODE,    Output: RETCODE                     X\n               ERROR=ERROR         Abend if Macro error\n*        TPUT  =CL50'CLOSESC',50\n*---------------------------------------------------------------------*\n* Obtain a TCP or UDP socket descriptor, depending on the PROTO parm. *\n*---------------------------------------------------------------------*\nSOCKET   DS    0H\n         CLC   =C'UDP',PROTO       UDP protocol?\n         BE    SOCKETUD            Yes, get a UDP socket.\nSOCKETST DS    0H                  No, get a STREAM (TCP) socket.\n         EZASMI TYPE=SOCKET,       Issue SOCKET macro.                 X\n               AF='INET',          INET socket.                        X\n               SOCTYPE='STREAM',   STREAM for TCP socket.              X\n               ERRNO=ERRNO,        ERRNO output field.                 X\n               RETCODE=RETCODE,    RETCODE output field.               X\n               ERROR=ERROR         Go here on exit.\n         B     CHECKSOK            Go check socket success.\nSOCKETUD DS    0H                  No, get a STREAM (TCP) socket.\n         EZASMI TYPE=SOCKET,       Issue SOCKET macro.                 X\n               AF='INET',          INET socket.                        X\n               SOCTYPE='DATAGRAM', DATAGRAM for UDP socket.            X\n               ERRNO=ERRNO,        ERRNO output field.                 X\n               RETCODE=RETCODE,    RETCODE output field.               X\n               ERROR=ERROR         Go here on exit.\nCHECKSOK DS    0H\n*        TPUT  =CL50'SOCKET',50\n         CLC   RETCODE,MINUSONE    Operation ok?\n         BNE   SOCKOK              Yes, continue.\n         B     EXIT8               Return with bad RC.\nSOCKOK   DS    0H\n         L     R8,RETCODE          Load RETCODE.\n         STH   R8,S                Save socket num in comm strg.\n*---------------------------------------------------------------------*\n* Connect to server.                                                  *\n*---------------------------------------------------------------------*\nCONNECT  DS    0H\n         MVC   FAMILY,=H'2'        Store family in sockt addr struct.\n         MVC   PORT,=H'514'        Store port in sockt addr struct.\n         EZASMI TYPE=CONNECT,                                          X\n               S=S,                Stream.                             X\n               NAME=NAME,          Socket name structure.              X\n               ERRNO=ERRNO,        (Specify ERRNO field)               X\n               RETCODE=RETCODE,    (Specify RETCODE field)             X\n               ERROR=ERROR         Abend if Macro error\n*        TPUT  =CL50'CONNECT',50\n         CLC   RETCODE,MINUSONE    Operation ok?\n         BNE   CONNOK              Yes, continue.\n         B     EXIT8               Return with bad RC.\nCONNOK   DS    0H\n*---------------------------------------------------------------------*\n* RETURN                                                              *\n*---------------------------------------------------------------------*\nERROR    DS    0H\nEXIT8    DS    0H\n         MVI   CC,8                Set return code 8 (error).\n         B     EXIT\nEXIT0    DS    0H\n         MVI   CC,0                Set zero (good) return code.\nEXIT     DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*   Constants.\n*---------------------------------------------------------------------*\n         RLCOMM CONST\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT\nSAVE     DS    18F                 Register save area.\n*---------------------------------------------------------------------*\n*   MACRO storage.\n*---------------------------------------------------------------------*\nWRKD     DS    D                   Doubleword work area.\nWRKF     DS    D                   Fullword work area.\n*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU   *-DATD\n*---------------------------------------------------------------------*\n*   Common Storage DSECT.                                             *\n*---------------------------------------------------------------------*\n         RLCOMM DSECT\n         IKJCPPL\n         END   RECON\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    RECON        '\n         PUNCH ' NAME     RECON(R)     '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RLCLOS": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x014\\x00\\x19\\x01\\x10\\x11\\x8f\\x01\\x164O\\x18A\\x00\\xb8\\x01/\\x00\\xb8\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.52", "flags": 0, "createdate": "2010-04-28T00:00:00", "modifydate": "2016-12-09T18:41:19", "lines": 184, "newlines": 303, "modlines": 184, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RMTLOG  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* RLCLOS  - Remote syslog closedown.                                  *\n*---------------------------------------------------------------------*\n* Entry (Called by RMTLOG):                                           *\n* - R11 - Points to common storage area.  Use this for base reg.      *\n* Regs:                                                               *\n* - R12 - Base register for this program.                             *\n* - R13 - Points to private storage area.                             *\n*---------------------------------------------------------------------*\n* 1) Open and process PARMS file.                                     *\n*---------------------------------------------------------------------*\n* 04/19/2010 John C. Miller                                           *\n*---------------------------------------------------------------------*\n*\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  1\n*\n         PRINT GEN,DATA\nRLCLOS   CSECT\nRLCLOS   AMODE ANY\nRLCLOS   RMODE ANY\n         YREGS\n*---------------------------------------------------------------------*\n* Prolog - Get private and common storage areas and set up.\n*---------------------------------------------------------------------*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING RLCLOS,R12           Addressability.\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         USING RLCOMM,R11           Comm area addressability.\n*---------------------------------------------------------------------*\n* Issue SHUTDOWN - HOW = 1 (end communication TO socket)              *\n*---------------------------------------------------------------------*\nSHUTDOWN DS    0H\n         MVC   HOW,=F'2'\n         BAL   R14,SHUTSUB         Close socket.\n*---------------------------------------------------------------------*\n* CLOSESC - Close socket and free resources.                          *\n*---------------------------------------------------------------------*\nCLOSESC  DS    0H\n         EZASMI TYPE=CLOSE,        Close.                              X\n               S=S,                Socket.                             X\n               ERRNO=ERRNO,        Output: ERRNO                       X\n               RETCODE=RETCODE,    Output: RETCODE                     X\n               ERROR=ERROR         Abend if Macro error\n*---------------------------------------------------------------------*\n* RETURN                                                              *\n*---------------------------------------------------------------------*\nEXITOK   DS    0H\n         SR    R10,R10\n         B     EXIT\nERROR    DS    0H\n         LA    R10,8               Set return code 8 (error).\nEXIT     DS    0H\n         CLI   SYSPOK,C'Y'         Was SYSPRINT opened ok?\n         BNE   EXIT0               No, don't close it.\n         CLOSE MF=(E,GOPENOUT)     Close SYSPRINT file.\n         MVI   SYSPOK,C'N'         Mark SYSPRINT unusable.\nEXIT0    DS    0H\n         LR    R1,R13              Get address of RELEASE.\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n* SHUTSUB - Shut down socket.  The HOW variable is a fullword         *\n* containing the type of shutdown: 1 = TO, 0 = FROM.                  *\n*---------------------------------------------------------------------*\nSHUTSUB  EQU   *\n         LR    R7,R14\n         EZASMI TYPE=SHUTDOWN,    Issue Macro                          X\n               S=S,               STREAM                               X\n               HOW=HOW,           End communication in both directions X\n               ERRNO=ERRNO,       (Specify ERRNO field)                X\n               RETCODE=RETCODE,   (Specify RETCODE field)              X\n               ERROR=ERROR        Abend if Macro error\n         BR    R7                 --> RETURN TO CALLER\n*---------------------------------------------------------------------*\n*  MSG - WTO a message, and write it to SYSPRINT if open.             *\n*---------------------------------------------------------------------*\nMSG      DS      0H\n         BAKR    R14,0             Save callers environment.\n         SAC     0                 Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         MVC     WTOPL,WTOPLM      Set up parm list.\n         LR      R2,R1             Point R2 to msg text passed in R1.\n         WTO     TEXT=(R2),        WTO the message.                    X\n               MF=(E,WTOPL)\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP0             No, branch around.\n         MVC   BUFFER,BLANKS       Clear message buffer.\n         LA    R4,BUFFER           -> buffer.\n         SR    R5,R5               Clear reg.\n         LH    R5,0(R2)            Len of MVCL.\n         LR    R7,R5               Len of MVCL.\n         LA    R8,2(R2)            -> message text.\n         MVCL  R4,R8\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP0  DS    0H\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n* Write a line to SYSPRINT.\n*---------------------------------------------------------------------*\nPUTLINE  DS    0H\n         BAKR  R14,0               Save callers environment.\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP1             No, branch around.\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP1  DS    0H\n         PR\n*---------------------------------------------------------------------*\n* LEN - Get length of a blank terminated field.\n* ENTRY:\n*    R0 - Maximum length of string.\n*    R1 - Points to start of string.\n* EXIT:\n*    R1 - Length of string.\n*---------------------------------------------------------------------*\nLEN      DS    0H\n         SR    R15,R15\nLENTOP   DS    0H\n         CLI   0(R1),C' '             Blank?\n         BE    LENDONE                Yes, Return with len in R15.\n         LA    R1,1(R1)               Bump over 1.\n         LA    R15,1(R15)             Bump over 1.\n         CR    R15,R0                 End of search yet?\n         BL    LENTOP                 No, keep looking.\nLENDONE  DS    0H\n         LR    R1,R15                 Load len in R0\n         BR    R6\n*---------------------------------------------------------------------*\n* MACROS and constants.                                               *\n*---------------------------------------------------------------------*\n         RLCOMM CONST\n         LTORG\nWTOPLM   WTO TEXT=,DESC=(7),MF=L   WTO parm list.\nWTOPLL   EQU *-WTOPLM\n*\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT\nSAVE     DS    18F                 Register save area.\nWTOPL    DS    CL(WTOPLL)          WTO parm list.\n*---------------------------------------------------------------------*\n*   MACRO storage.\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU   *-DATD\n*---------------------------------------------------------------------*\n*   Common Storage DSECT.                                             *\n*---------------------------------------------------------------------*\n         RLCOMM DSECT\n         IKJCPPL\n         END   RLCLOS\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    RLCLOS       '\n         PUNCH ' NAME     RLCLOS(R)    '\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RLCOMM": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x04\\x01\\x10\\x10\\x9f\\x01\\x164O\\x17&\\x00\\xbe\\x002\\x00\\xbe\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-04-19T00:00:00", "modifydate": "2016-12-09T17:26:04", "lines": 190, "newlines": 50, "modlines": 190, "user": "USER03"}, "text": "         MACRO\n&NAME    RLCOMM &MODE\n         LCLC  &GNAME\n&GNAME   SETC  '@Q@'.'&SYSNDX'\n.*--------------------------------------------------------------------*\n.* RLCOMM  - Common DSECT for RMTLOG components.\n.* RLCOMM CONST - Define common constants.\n.* RLCOMM DSECT - Define common DSECT.\n.*--------------------------------------------------------------------*\n.*\n.*====================================================================*\n.* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.  *\n.*--------------------------------------------------------------------*\n.* This program is free software: you can redistribute it and/or      *\n.* modify it under the terms of the GNU General Public License as     *\n.* published by the Free Software Foundation, either version 3 of     *\n.* the License, or (at your option) any later version.                *\n.*                                                                    *\n.* This program is distributed in the hope that it will be useful,    *\n.* but WITHOUT ANY WARRANTY; without even the implied warranty of     *\n.* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *\n.* GNU General Public License in member $GPL for more details.        *\n.*--------------------------------------------------------------------*\n         AIF   ('&MODE' EQ 'DSECT').DODSECT\n         AIF   ('&MODE' EQ 'CONSTANTS').DOCONST\n         AIF   ('&MODE' EQ 'CONST').DOCONST\n.DODSECT ANOP\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* RLCOMM - Common dynamic storage DSECT.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nRLCOMM   DSECT\nREGSAVE  DS    18F                 REGISTER SAVE AREA\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*   MISC WORK AREAS                                                   *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nBUFFER   DS    CL80                For reading PARMS file.\nR1SAVE   DS    D                   Reg save area.\nR1SAVE2  DS    D                   Reg save area.\nRSAVE1   DS    18F                 Reg save area.\nRSAVE2   DS    18F                 Reg save area.\nRSAVED   DS    18F                 Reg save area.\nR        DS    18F                 Reg save area.\nMYTIE    EZASMI TYPE=TASK,STORAGE=CSECT     TIE\nJOBNMDB  DS    CL8                 Jobname from the MDBG object.\nTIMEMDB  DS    CL8                 Time from the MDBG object.\nDATEMDB  DS    CL8                 Date from the MDBG object.\nMDBTIME  DS    CL8                 Time from the MDBG object.\nPWK      DS    32F                 Parse work area.\nPARMLST  DS    6F                  Parse work area.\nCNID     DS    F                   Console id.\nCC       DS    X                   Inter-routine return code.\n*\nFLAG     DS    X                   Flag byte.\nFRETRMSG EQU   X'80'               Retry message has been issued.\nFPARTWRT EQU   X'40'               Partial write needed.\n*\nTRACE    DS    X                   Flag byte.\nSYSPOK   DS    X                   \"Y\" = SYSPRINT OK to write to.\nBUFFERL  DS    F                   Buffer len to write.\nBUFFERP  DS    F                   Buffer ptr to write.\nPARMLIST DS    6F\n*---\n*--\n*- Storage for parameters passed in the PARMS file.\n*--\n*---\nSERVER   DS    CL80\nSERVERIP DS    CL16\nCONTENT  DS    CL80\nTIMEOUT  DS    CL8\nTIMESRC  DS    CL8                 Source for timestamp in msg.\nVERB     DS    CL8\nCNAME    DS    CL8                 Console name.\nSIZE     DS    CL4                 Size of data space.\nSIZED    DS    D                   Binary value of size for MCSOPER.\nSIZEH    DS    H                   Halfword size value.\nPRI      DS    CL5                 PRI value read from parm file.\nQLIMITN  DS    CL12                QLIMIT value read from parm file.\nQLIMIT   DS    F                   QLIMIT value read by macro (binary).\nPROTO    DS    CL4                 PROTO value read from parm file.\nPORTN    DS    CL8                 PORT value read from parm file.\nHOSTNAML DS    F                   Host name length.\nHOSTNAM  DS    CL12                Host name from GETHOSNAME macro.\nHOSTNM   DS    CL8                 Hard coded HOST name.\nHOSTNML  DS    F                   Hard coded HOST name length.\nRETRYINT DS    CL8                 Retry interval.\nRETRIES  DS    F                   Number of retries.\nALERTPCT DS    CL3                 Alert percentage.\nALERTPCN DS    X                   Number of retries.\nQRESUME  DS    CL3                 Queue resume percentage.\nQRESUMEN DS    X                   Number of retries.\n*---\n*                                  $SERVNAM=1: SERVER was coded.\n*                                  $SERVNUM=1: SERVERIP was coded.\nSERVFLG  DS    C                   Flag - SERVER/SERVERIP flag.\n$SERVNAM EQU   X'80'               - Server name coded.\n$SERVNUM EQU   X'40'               - Server IP coded.\n*---\n*\n*---\n*--\n*- Message block sent to server:\n*--\n*---\n@@HEADER DS    0H\n@PRI     DS    CL5                 <036>\n@MON     DS    CL4                 Aug_\n@DAY     DS    CL3                 29_\n@TIME    DS    CL9                 21:02:55_\n@HEADRLN EQU   *-@@HEADER          =21\n@MESSAGE DS    CL255\n@LENALL  EQU   *-@@HEADER          Calculate length of whole message.\n@YEAR    DS    CL7                 Year\n         ORG   @MON                Back up to date field.\n@MESSAG2 DS    CL271               Message field when date is omitted.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*   TCP/IP Sockets storage.                                           *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         CNOP  0,4\nREQAREA  EQU   *\nECB      DS    F                   Event Control Block.\n         DS    CL100               State information used by EZASMI\nMAXSNO   DS    F                   Highest socket descriptor available.\nHOW      DS    F                   How to terminate socket.\nTYPE     DS    CL8\nRCODE    DS    F\nRETCODE  DS    F\nERRNO    DS    F\nHOSTENT  DS    F\nNAMELEN  DS    F\nS        DS    H                   Socket descriptor.\n*- - - - - - - - - - -*\n* Connect macro parms *\n*- - - - - - - - - - -*\n         CNOP  0,4\nNAME     DS    0CL16' '            Socket address structure.\nFAMILY   DS    AL2                 Family - Always '2' for af_inet.\nPORT     DS    H                   Portnum - 514 for SYSLOGD.\nSERVER#  DS    F                   IP address fullword.\n         DS    XL8                 Reserved.\n*---------------------------------------------------------------------*\n* Storage for macros.\n*---------------------------------------------------------------------*\n         CNOP  0,4\nGTEXTOUT DS    CL(LTEXTOUT)        Macro storage.\n         CNOP  0,4\nGEEXTOUT DS    CL(LEEXTOUT)        Macro storage.\n         CNOP  0,4\nGOPENOUT DS    F                   Macro storage.\n         CNOP  0,4\n*\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*   End on doubleword boundary.                                       *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         DS    0D\nRLCOMML  EQU   *-RLCOMM\n         AGO   .EXIT000\n.*--------------------------------------------------------------------*\n.* RLDESCT - Constants definitions.\n.*--------------------------------------------------------------------*\n.DOCONST ANOP\n*---------------------------------------------------------------------*\n*   RMTLOG Constants.                                                 *\n*---------------------------------------------------------------------*\n         B     &GNAME              Branch around constants in case.\nMINUSONE DC    X'FFFFFFFF'         For return code compare.\nMSOCKET  DC    CL8'SOCKET'\nMCONNECT DC    CL8'CONNECT'\nMGETPEER DC    CL8'GETPEERN'\nMREAD    DC    CL8'READ'\nMWRITE   DC    CL8'WRITE'\nMSHUTDOW DC    CL8'SHUTDOWN'\nMTERMAPI DC    CL8'TERMAPI'\nBLANKS   DC    CL80' '\nRLVERSN  DC    CL6'v1.1  '\n*\n*---------------------------------------------------------------------*\n* Macros for output file.\n*---------------------------------------------------------------------*\n         CNOP  0,4\nOPENOUT  OPEN  (TEXTOUT,OUTPUT),MF=L\n         CNOP  0,4\nTEXTOUT  DCB   MACRF=(PM),DSORG=PS,LRECL=80,DDNAME=SYSPRINT,DCBE=*-*\nLTEXTOUT EQU   *-TEXTOUT\n         CNOP  0,4\nEEXTOUT  DCBE  RMODE31=BUFF\nLEEXTOUT EQU   *-EEXTOUT\n*\n&GNAME   DS    0H\n.EXIT000 MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RLINCL": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00)\\x01\\x10\\x15\\x9f\\x01\\x164O\\x18A\\x00\\xc6\\x00\\xc9\\x00\\xc6\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2010-06-08T00:00:00", "modifydate": "2016-12-09T18:41:29", "lines": 198, "newlines": 201, "modlines": 198, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RLINCL - Test                                                       *\n*---------------------------------------------------------------------*\n* 04/20/2010 John C. Miller - john@jmit.com                           *\n*---------------------------------------------------------------------*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\nRLINCL   CSECT\nRLINCL   AMODE ANY\nRLINCL   RMODE ANY\n         PRINT GEN,DATA\n         YREGS                     Do register equates.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Prolog - Get private and common storage areas and set up.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING RLINCL,R12           Addressability.\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n*---------------------------------------------------------------------*\n* Call init routine to:                                               *\n* - Read, parse and validate PARMS file.                              *\n*---------------------------------------------------------------------*\nMAIN     DS    0H\n         SR    R2,R2\n         SR    R3,R3\n         SR    R4,R4\n         LM    R2,R8,ZERO\n*---------------------------------------------------------------------*\n* Exit - Release storage and return to caller.                        *\n*---------------------------------------------------------------------*\nEXIT     DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\nZERO     DC    18F'0'\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* Setup:                                                              *\n* Set up storage for macro models.                                    *\n* Set up com area for modify, stop, etc.                              *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nSETUP    DS    0H\n         BAKR  R14,0               Save regs.\n         MVI   DONE,0              Init flag.\n         LA    R2,MACROS           -> MACRO storage. (tgt of MVCL)\n         LA    R3,MACROSL          Get length of move.\n         LA    R5,MACROSL          Get length of move.\n         LA    R4,MACROSM          -> MACRO models. (src of MVCL)\n         MVCL  R2,R4               Populate all MACRO storage.\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*  MSG - WTO a message.                                               *\n*---------------------------------------------------------------------*\nMSG    DS      0H\n       BAKR    R14,0              Save callers environment.\n       SAC     0                  Set primary mode.\n       SYSSTATE ASCENV=P          Tell macros PRIMARY mode.\n       LR      R2,R1              Point R2 to msg text passed in R1.\n       WTO     TEXT=(R2),         WTO the message.                     X\n               MF=(E,WTOPL)\n       PR                         return to caller\n*\n*---------------------------------------------------------------------*\n* MACRO Models.  All models in this section are copied to working     *\n* storage in the section called: Macro Working Storage.  This is to   *\n* enable this program to be reentrant.  The model section is copied   *\n* to working storage by the SETUP subroutine at the startup of this   *\n* program.                                                            *\n*---------------------------------------------------------------------*\n         CNOP  0,4\nMACROSM  DS    0H\n*-\nEXTRACTM EXTRACT MF=L              EXTRACT parameter list.\nEXTRACTL EQU *-EXTRACTM\n*\nSUPM     MODESET MODE=SUP,MF=L     MODESET parm list for sup state\nSUPL     EQU *-SUPM\n*\nSUP0M    MODESET MODE=SUP,                                             X\n               KEY=ZERO,MF=L       MODESET parm list for sup, key 0\nSUP0L    EQU *-SUP0M\nPROBM    MODESET MODE=PROB,                                            X\n               KEY=NZERO,MF=L      MODESET parm list for problem state\nPROBL    EQU *-PROBM\n*-\nWTOPLM   WTO TEXT=,DESC=(7),MF=L   WTO parm list.\nWTOPLL   EQU *-WTOPLM\n*-\nMACROSL  EQU *-MACROSM             Length of all macro models.\n*\n*---------------------------------------------------------------------*\n* Messages (for WTO).\n*---------------------------------------------------------------------*\nSHUTTING DC     AL2(L'MSG0)\nMSG0     DC     C'RLG000I RMTLOG Starting shutdown.'\nNOTACT   DC     AL2(L'MSG2)\nMSG2     DC     C'RLG002I Console not deactivated, was not active.'\nACTOK    DC     AL2(L'MSG3)\nMSG3     DC     C'RLG003I Console activated successfully.'\nACTBAD   DC     AL2(L'MSG4)\nMSG4     DC     C'RLG004I Console failed to activate.'\nDACTOK   DC     AL2(L'MSG5)\nMSG5     DC     C'RLG005I Console deactivated.'\nDACTBAD  DC     AL2(L'MSG6)\nMSG6     DC     C'RLG006I Console deactivate failed.'\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT                     Dynamic area.\nSAVE     DS    18F                 Register save area.  Must be first\n*---\nTIMEDATE DS    4F\nDWORK    DS    D\nWRK      DS    CL8\n* BUFFERL  DS    F\nBUFFER2  DS    CL255\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*--- ECB List - This is a list of pointers to ECBs. The WAIT macro ---*\n*--- works with all ECBs in this list.                             ---*\n*---------------------------------------------------------------------*\n*---v---v---v---v---v---v---v---v---v---v---v---v---v---v---v---v---v-*\n         CNOP  0,4\nECBS     DS    0CL(ECBLEN)\nAECBMSG  DS    A                   -> ECB for console messages.\nAECBALRT DS    A                   -> ECB for ALERT.\nAECBMOD  DS    A                   -> ECB for MODIFY (STOP,etc).\nECBLEN   EQU   *-AECBMOD\n*---\n*--- ECBs - These are the actual ECBs.\n*---\nECBMSG   DS    F                   ECB for console message.\nECBALRT  DS    F                   ECB for alert.\n*---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^-*\n*---------------------------------------------------------------------*\n*--- End of ECB List and ECBs.                                        *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nMCSPL    MCSOPER MF=(L,MCSOPPL)   MCSOPER parameter list\nMCSMPL   MCSOPMSG MF=(L,MCSOPMPL),PLISTVER=2 MCSOPMSG Parm List\nRC       DS    F                  Return code.\nRSN      DS    F                  Reason code.\nDONE     DS    C                  Flag - Set to '1' to signify exit.\nCSAALET  DS    F                  ALET (mcscsa)\nCSA      DS    A                  Addr (mcscsa)\nOPERPRM  DS    CL(MCSOPLEN)       OPERPARMs area\nTXTOFF   DS    F                  Offset to text area.\nMDBFLAG  DS    C                  MDB processing flags.\nMDBFGO   EQU   X'01'              Processed MDB general object.\nMDBFCO   EQU   X'02'              Processed MDB control prog object.\nCOMADDR DS     F                  Addr (comarea) from extract macro.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* MACRO working storage.  Each macro in this section should have a\n* corresponding model in the constants section.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         CNOP  0,4\nMACROS   DS    0H\nEXTRACT  DS    CL(EXTRACTL)        EXTRACT parameter list\nSUP      DS    CL(SUPL)            MODESET parm list.\nSUP0     DS    CL(SUP0L)           MODESET parm list.\nPROB     DS    CL(PROBL)           MODESET parm list.\nWTOPL    DS    CL(WTOPLL)          WTO parm list.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* M I S C . . . . . . . . . . .\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nPARML    DS    4F                  parm list.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* End of MACROS working storage\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU    *-DATD\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* DSECT mapping macros.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        DCBD    DSORG=QS\n         IKJCPPL                   CPPL for PUTLINE.\n         IEAVG132 ,                MDB prefix area.\n         IEAVM105 ,                MDB.\n         IEAVG131 ,                Console status area.\n         IEZVG111 ,                OPERPARM parameter area.\nCOM      DSECT\n         IEZCOM   ,                COM area\nCIB      DSECT\n         IEZCIB   ,                CIB and CIBX\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RLINIT1": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01Y\\x003\\x01\\x10\\x15\\x1f\\x01\\x164O\\x18A\\x02\\xe8\\x01\\x84\\x02\\xe8\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.89", "flags": 0, "createdate": "2010-05-31T00:00:00", "modifydate": "2016-12-09T18:41:33", "lines": 744, "newlines": 388, "modlines": 744, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RMTLOG  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* RLINIT1 - Read and parse parameter file, and perform other          *\n* assorted tasks.                                                     *\n* This module performs tasks that must succeed immediately, or else   *\n* the RMTLOG faility must quit.  This module starts with the return   *\n* code (var CC) set to 0 (meaning successful).  If any fatal error    *\n* occurs, then we set CC to 8, which signals the caller that we need  *\n* to terminate RMTLOG.                                                *\n*---------------------------------------------------------------------*\n* Entry (Called by RMTLOG):                                           *\n* - R11 - Points to common storage area.  Use this for base reg.      *\n* Regs:                                                               *\n* - R12 - Base register for this program.                             *\n* - R13 - Points to private storage area.                             *\n* Return Code:                                                        *\n* - Variable CC = 0 ===> success                                      *\n* - Variable CC = 8 ===> fail                                         *\n*---------------------------------------------------------------------*\n* 1) Open, parse, process, and validate the PARMS file.               *\n*---------------------------------------------------------------------*\n* 06/01/2010 John C. Miller - software@jmit.com                       *\n* 03/22/2011 JCM - Added DCBE for 31 bit EODAD, changed dynamic strg  *\n* area to LOC=24 for DCB compatibility.                               *\n*---------------------------------------------------------------------*\n*\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\n         PRINT GEN,DATA\nRLINIT1  CSECT\nRLINIT1  AMODE ANY\nRLINIT1  RMODE ANY\n         YREGS\n*---------------------------------------------------------------------*\n* Prolog - Get private and common areas, and get set up.\n*---------------------------------------------------------------------*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING RLINIT1,R12          \"\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL,LOC=24 Workarea below 16mb line.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         USING RLCOMM,R11           Addressability to common area.\n         LR    R1,R2                Restore original R1.\n         ST    R1,R1SAVE            Save R1.\n*---------------------------------------------------------------------*\n* We branch to READPARM (rather than BALR) because this code section\n* has to loop until EOF on the input file, at which time the DCB\n* specifies that it returns by branch to label EOF.\n*---------------------------------------------------------------------*\nMAIN     DS    0H\n         MVI   CC,0                Start with return code 0.\n         MVC   MSG21H,MSG21L       Move msg length.\n         MVC   MSG21W,MSG21        Move message text to wrking strg.\n         MVC   MSG21W+15(4),RLVERSN Store version in message.\n         LA    R1,MSG21H           -> Msg\n         BAL   R14,MSG             Display it.\n         BAL   R6,SETUP            Open input file, init vars.\n         CLI   CC,0                Everything ok?\n         BNE   EXIT0               No, exit with error.\n         B     READPARM            Yes, continue reading parms.\nEOF      DS    0H                  Return from READPARM on EOF.\n         BAL   R6,CKPARMS          Check parms.\n*---------------------------------------------------------------------*\n* Other setup.                                                        *\n*---------------------------------------------------------------------*\n         B     EXIT\n*---------------------------------------------------------------------*\n* RETURN                                                              *\n*---------------------------------------------------------------------*\nERROR    DS    0H\n         MVI   CC,8                Set return code 8 (error).\nEXIT     DS    0H\n         CLOSE MF=(E,GOPENIN)\nEXIT0    DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*  MSG - WTO a message.                                               *\n*---------------------------------------------------------------------*\nMSG      DS      0H\n         BAKR    R14,0             Save callers environment.\n         SAC     0                 Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         MVC     WTOPL,WTOPLM      Set up parm list.\n         LR      R2,R1             Point R2 to msg text passed in R1.\n         WTO     TEXT=(R2),        WTO the message.                    X\n               MF=(E,WTOPL)\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP0             No, branch around.\n         MVC   BUFFER,BLANKS       Clear message buffer.\n         LA    R4,BUFFER           -> buffer.\n         SR    R5,R5               Clear reg.\n         LH    R5,0(R2)            Len of MVCL.\n         LR    R7,R5               Len of MVCL.\n         LA    R8,2(R2)            -> message text.\n         MVCL  R4,R8\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP0  DS    0H\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n* Write output buffer to SYSPRINT DD statement.                       *\n*---------------------------------------------------------------------*\nPUTLINE  DS    0H\n         BAKR    R14,0             Save callers environment.\n         SAC     0                 Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP1             No, branch around.\n         PUT   GTEXTOUT,4(R2)      Write data to SYSPRINT.\nNOSYSP1  DS    0H\n         PR                        Return to caller\n* Message constants.\nMSG21L   DC    AL2(L'MSG21)\nMSG21    DC    C'RLG021I RMTLOG:     starting initialization phase 1.'\n*\nOPENERR  DS    AL2(L'MSG22)\nMSG22    DC    C'RLG053I Error opening parameter file.'\n*\nSRVBOTH  DC    AL2(L'MSG24)\nMSG24    DC    C'RLG024I SERVER and SERVERIP both coded, but only one iX\n               s allowed - exiting.'\n*\nSRVNONE  DC    AL2(L'MSG25)\nMSG25    DC    C'RLG025I Neither SERVER nor SERVERIP coded, one is requX\n               ired - exiting.'\n*\n* Messages below have a variable component, so these constants will be\n* copied to working storage, and additional data added before the WTO.\n* Total msg length of these dynamic message must <= 80.\n*\nMSG23L   DC    AL2(L'MSG23)\nMSG23    DC    C'RLG023I Default value assigned for parameter:         X\n                                         '\n*\nMSG26L   DC    AL2(L'MSG26)\nMSG26    DC    C'RLG026I Parameter specified:                          X\n                                         '\n*\n*---------------------------------------------------------------------*\n* Read parameter file records.  On EOF, DCB specifies that we branch  *\n* to label EOF.  Reaching EOF is the only way of branching out of     *\n* this section of code.                                               *\n*---------------------------------------------------------------------*\nREADPARM DS    0H\n         BAL   R6,GETLINE          Get input record.\n         CLI   BUFFER,C'*'         Comment?\n         BE    READPARM            Yes, ignore this record.\n         CLI   BUFFER,C'#'         Comment?\n         BE    READPARM            Yes, ignore this record.\n         CLC   =CL20' ',BUFFER     Blank line?\n         BE    READPARM            Yes, ignore this record.\n*        ---\n         LA    R1,BUFFER           Point to it.\n         LA    R0,79               Set length of line.\n         BAL   R6,PARSE            Go parse it.\n*        ---\n         MVC   VERB,BLANKS         Set VERB field to blanks.\n         LM    R4,R5,PWK           Load ptr and len of source of MVCL\n         LR    R3,R5               Copy over len reg.\n         LA    R2,VERB             Point to target of MVCL.\n         MVCL  R2,R4               Move data.\n*        ---\n         MVC   CONTENT,BLANKS      Set target field to blanks.\n         LM    R4,R5,PWK+8         Load ptr and len of source of MVCL\n         LR    R3,R5               Copy over len reg.\n         LA    R2,CONTENT          Point to target of MVCL.\n         MVCL  R2,R4               Move data.\n*        ---\n* Check for SERVER statement.\n*        ---\n         CLC   =C'SERVER ',VERB    Was this a SERVER stmt?\n         BNE   RPM0002A            No, check next.\n         MVC   SERVER,CONTENT      Yes, copy content to SERVER var.\n         B     RPM9999             Done, process next stmt.\n*        ---\n* Check for SERVER statement.\n*        ---\nRPM0002A DS    0H\n         CLC   =C'SERVERIP',VERB  Was this a SERVERIP stmt?\n         BNE   RPM0002B            No, check next.\n         MVC   SERVERIP,CONTENT    Yes, copy content to SERVER var.\n         B     RPM9999             Done, process next stmt.\n*        ---\n* Check for TIMEOUT statement.\n*        ---\nRPM0002B DS    0H\n         CLC   =C'TIMEOUT',VERB   Was this a TIMEOUT stmt?\n         BNE   RPM0003\n         MVC   TIMEOUT,CONTENT     Copy content to TIMEOUT var.\n         B     RPM9999\n*        ---\n* Check for CNAME statement.\n*        ---\nRPM0003  DS    0H\n         CLC   =C'CNAME',VERB     CNAME stmt?\n         BNE   RPM0004\n         MVC   CNAME,CONTENT       Copy content to CNAME var.\n         B     RPM9999\n*        ---\n* Check for PRI statement.\n*        ---\nRPM0004  DS    0H\n         CLC   =C'PRI',VERB       PRI stmt?\n         BNE   RPM0005\n         MVC   PRI+1(3),CONTENT    Copy content to PRI var.\n         MVI   PRI,C'<'\n         MVI   PRI+4,C'>'\n         B     RPM9999\n*        ---\n* Check for SIZE statement.\n*        ---\nRPM0005  DS    0H\n         CLC   =C'SIZE',VERB      SIZE stmt?\n         BNE   RPM0006\n         MVC   SIZE,CONTENT        Copy content to SIZE var.\n         B     RPM9999\n*        ---\n* Check for QLIMIT statement.\n*        ---\nRPM0006  DS    0H\n         CLC   =C'QLIMIT',VERB    QLIMIT stmt?\n         BNE   RPM0007\n         MVC   QLIMITN,CONTENT     Copy content to var.\n         B     RPM9999\n*        ---\n* Check for HOSTNAME statement.\n*        ---\nRPM0007  DS    0H\n         CLC   =C'HOSTNAME',VERB  HOSTNM stmt?\n         BNE   RPM0008\n         MVC   HOSTNM,CONTENT      Copy content to var.\n         STR   LENG,HOSTNM,8       Get len of string in R0\n         ST    R1,HOSTNML          Save host name length.\n         B     RPM9999\n*        ---\n* Check for PROTO statement.\n*        ---\nRPM0008  DS    0H\n         CLC   =C'PROTO',VERB     PROTO stmt?\n         BNE   RPM0009\n         MVC   PROTO,CONTENT       Copy content to var.\n         B     RPM9999\n*        ---\n* Check for PORT statement.\n*        ---\nRPM0009  DS    0H\n         CLC   =C'PORT',VERB      PORT stmt?\n         BNE   RPM0010\n         MVC   PORTN,CONTENT       Copy content to var.\n         B     RPM9999\n*        ---\n* Check for TIME statement.\n*        ---\nRPM0010  DS    0H\n         CLC   =C'TIME',VERB      TIME stmt?\n         BNE   RPM0011\n         MVC   TIMESRC,CONTENT     Copy content to var.\n         B     RPM9999\n*        ---\n* Check for RETRYINT statement.\n*        ---\nRPM0011  DS    0H\n         CLC   =C'RETRYINT',VERB   RETRYINT stmt?\n         BNE   RPM0012\n         MVC   RETRYINT,CONTENT    Copy content to var.\n         STR   RJUST,RETRYINT,6    Right justify the field (almost).\n         OC    RETRYINT,=CL8'00000000' Force blank spaces to zeros.\n         B     RPM9999\n*        ---\n* Check for RETRIES statement.\n*        ---\nRPM0012  DS    0H\n         CLC   =C'RETRIES',VERB   RETRIES stmt?\n         BNE   RPM0013\n         MVC   RETRIES,CONTENT     Copy content to var.\n         B     RPM9999\n*        ---\n* Check for ALERTPCT statement.\n*        ---\nRPM0013  DS    0H\n         CLC   =C'ALERTPCT',VERB   ALERTPCT stmt?\n         BNE   RPM0014\n         MVC   ALERTPCT,CONTENT    Copy content to var.\n         B     RPM9999\n*        ---\n* Check for QRESUME statement.\n*        ---\nRPM0014  DS    0H\n         CLC   =C'QRESUME',VERB   QRESUME stmt?\n         BNE   RPM0015\n         MVC   QRESUME,CONTENT     Copy content to var.\n         B     RPM9999\n*        ---\n* Check for ALERTPCT statement.\n*        ---\nRPM0015  DS    0H\n         CLC   =C'TRACE',VERB     TRACE stmt?\n         BNE   RPM0016\n         MVC   TRACE,CONTENT       Copy content to var.\n         B     RPM9999\nRPM0016  DS    0H\nRPM9999  DS    0H\n         B     READPARM            Top of loop.\n*\n*---------------------------------------------------------------------*\n* (SUBR) GETLINE - GET AN INPUT RECORD.                               *\n* R14 IS RETURN REGISTER.                                             *\n*---------------------------------------------------------------------*\nGETLINE  DS    0H\n         GET   GTEXTIN,BUFFER                   READ RECORD.\n         BR    R6\n*---------------------------------------------------------------------*\n* SETUP.  Set variables to blanks as appropriate, and set up other\n* variables.\n*---------------------------------------------------------------------*\nSETUP    DS    0H\n         MVC   BUFFER,BLANKS          Set field to blanks.\n         MVC   CNAME,BLANKS           Set field to blanks.\n         MVC   ALERTPCT,BLANKS        Set field to blanks.\n         MVC   TRACE,BLANKS           Set field to blanks.\n         MVC   QRESUME,BLANKS         Set field to blanks.\n         XC    ALERTPCT,ALERTPCT      Set field to zeros.\n         XC    QRESUMEN,QRESUMEN      Set field to zeros.\n         MVC   CONTENT,BLANKS         Set field to blanks.\n         MVC   HOSTNM,BLANKS          Set field to blanks.\n         MVC   MDBTIME,BLANKS         Set field to blanks.\n         MVC   PORTN,BLANKS           Set field to blanks.\n         MVC   PRI,BLANKS             Set field to blanks.\n         MVC   QLIMITN,BLANKS         Set field to blanks.\n         MVC   RETRIES,BLANKS         Set field to blanks.\n         MVC   RETRYINT,BLANKS        Set field to blanks.\n         MVC   SERVER,BLANKS          Set field to blanks.\n         MVC   SERVERIP,BLANKS        Set field to blanks.\n         MVC   SIZE,BLANKS            Set field to blanks.\n         MVC   TIMEOUT,BLANKS         Set field to blanks.\n         MVC   TIMESRC,BLANKS         Set field to blanks.\n         MVC   VERB,BLANKS            Set field to blanks.\n*\n         MVC   WTOPL,WTOPLM           Set up WTO parm list.\n         XC    FLAG,FLAG              Clear flag byte.\n         XC    HOSTNML,HOSTNML        Set harcoded hostname len to 0.\n*---------------------------------------------------------------------*\n* Set up OPEN, DCB and DCBE macros.\n*---------------------------------------------------------------------*\n         MVC   GOPENIN,OPENIN         Copy OPEN parm list.\n         MVC   GTEXTIN,TEXTIN         Copy DCB parm list.\n         MVC   GEEXTIN,EEXTIN         Copy DCBE parm list.\n         LA    R1,GEEXTIN             -> DCBE in dynamic storage.\n         ST    R1,GTEXTIN             Store DCBE ptr in DCB parm list.\n         LA    R1,GTEXTIN             POINT TO DCB\n         STCM  R1,B'0111',GOPENIN+1   STORE PTR TO DCB IN OPEN LIST.\n         ST    R1,GOPENIN+4           STORE PTR TO DCB IN OPEN LIST.\n         OPEN  MF=(E,GOPENIN)         OPEN INPUT FILE.\n         ST    R15,WRKF\n         LTR   R15,R15                OPEN SUCCESSFUL?\n         BZ    SETUPRT                YES, GO RETURN.\n         LA    R1,OPENERR             -> Msg\n         BAL   R14,MSG                Display it.\n         MVI   CC,8                   Set bad CC.\nSETUPRT  DS    0H\n         MVC   GOPENOUT,OPENOUT       Copy OPEN parm list.\n         MVC   GTEXTOUT,TEXTOUT       Copy DCB parm list.\n         MVC   GEEXTOUT,EEXTOUT       Copy DCBE parm list.\n         LA    R1,GTEXTOUT            -> DCB.\n         STCM  R1,B'0111',GOPENOUT+1  Store ptr to DCB in open list.\n         LA    R1,GEEXTOUT            ->DBCE\n         ST    R1,GTEXTOUT            Store DCBE ptr in DCB list.\n         MVI   SYSPOK,C'N'            Set SYSPRINT OPEN to N.\n         OPEN  MF=(E,GOPENOUT)        Open output file.\n*        DC    F'0'\n         ST    R15,WRKF\n         LTR   R15,R15                SYSPRINT OPEN OK?\n         BNZ   BADSYSP                No, leave flag set at 'N'.\n         MVI   SYSPOK,C'Y'            OK to write to SYSPRINT.\n         WTO   'OUTPUT FILE OPENED'\nBADSYSP  DS    0H\n         BR    R6                     RETURN TO CALLER.\n*---------------------------------------------------------------------*\n* CKPARMS - Make sure all required parms were found in the PARMS file,\n* and provide default values where possible for omitted parms.  Do\n* any additional processing needed for parameters, such as converting\n* zoned decimal to binary, etc.\n*---------------------------------------------------------------------*\n* For some parameters that are user coded, MSG the value coded with\n* MSG26.\n*---------------------------------------------------------------------*\nCKPARMS  DS    0H\n* Set up variable messages in working storage.\n         MVC   MSG23H,MSG23L          Move length for WTO.\n         MVC   MSG23W,MSG23           Set up \"dftl taken' message.\n         MVC   MSG26H,MSG26L          Move length for WTO.\n         MVC   MSG26W,MSG26           Set up \"parm coded' message.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* CNAME\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0001   DS    0H\n         CLC   CNAME,BLANKS\n         BNE   CK0001B\n         MVC   CNAME,=CL8'RLG01'   Set default value.\n         MVC   MSG23W+45(20),=CL20' CNAME: RLG01'\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0001B  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* PRI\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0002   DS    0H\n         CLC   PRI,BLANKS\n         BNE   CK0002B\n         MVC   PRI,=CL5'<035>'        Set default value.\n         MVC   MSG23W+45(20),=CL20' PRI: <035>'\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0002B  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* TIMESRC (Not currently used - for future use.)\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0003   DS    0H\n         CLC   TIMESRC,BLANKS\n         BNE   CK0003B\n         MVC   TIMESRC,=CL8'MESSAGE'  Set default value.\n         MVC   MSG23W+45(20),=CL20' TIMESRC: MESSAGE   '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0003B  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* QLIMIT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0004   DS    0H\n         CLC   QLIMITN,BLANKS\n         BNE   CK0004B\n         MVC   QLIMITN,=CL12'524288'\n         MVC   MSG23W+45(20),=CL20' QLIMIT: 524288     '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0004B  DS    0H\n         STR   RJUST,QLIMITN,12    Right justify the field.\n         PACK  WRKD,QLIMITN\n         CVB   R2,WRKD\n         ST    R2,QLIMIT           Store QLIMIT in binary.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* RETRYINT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0005   DS    0H\n         CLC   RETRYINT,BLANKS\n         BNE   CK0005B\n         MVC   RETRYINT,=CL8'000015'\n         MVC   MSG23W+45(20),=CL20' RETRYINT: 000015   '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0005B  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* RETRIES\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0006   DS    0H\n         CLC   RETRIES,BLANKS\n         BNE   CK0006B\n         MVC   RETRIES,=CL4'0'\n         MVC   MSG23W+45(20),=CL20' RETRIES: 0         '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0006B  DS    0H\n         STR   RJUST,RETRIES,4     Right justify the string.\n         PACK  WRKD,RETRIES        Convert to packed.\n         CVB   R2,WRKD             Convert to binary.\n         ST    R2,RETRIES          Store retries binary value.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* PORT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0007   DS    0H\n         CLC   PORTN,BLANKS\n         BNE   CK0007B\n         MVC   PORTN,=CL8'514'\n         MVC   MSG23W+45(20),=CL20' PORT: 514          '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\n         B     CK0007C\nCK0007B  DS    0H                  User coded parm--display this one.\n         MVC   MSG26W+28(40),BLANKS Clear variable part of message.\n         MVC   MSG26W+28(06),=CL06' PORT:'\n         MVC   MSG26W+35(8),PORTN  Move user coded PORT value.\n         LA    R1,MSG26H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0007C  DS    0H\n         STR   RJUST,PORTN,8       Right justify the string.\n         PACK  WRKD,PORTN          Convert to packed.\n         CVB   R2,WRKD             Convert to binary.\n         STH   R2,PORT             Store halfword\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* PROTO\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0008   DS    0H\n         CLC   PROTO,BLANKS\n         BNE   CK0008B\n         MVC   PROTO,=CL4'UDP'\n         MVC   MSG23W+45(20),=CL20' PROTO: UDP         '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0008B  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* SIZE\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0009   DS    0H\n         CLC   SIZE,BLANKS\n         BNE   CK0009B\n         MVC   SIZE,=CL4'512'\n         MVC   MSG23W+45(20),=CL20' SIZE: 512          '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0009B  DS    0H\n         STR   RJUST,SIZE,4        Right justify the field.\n         PACK  SIZED,SIZE          Convert to packed.\n         CVB   R2,SIZED            Convert to binary.\n         STH   R2,SIZEH            Store halfword\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* SERVER/SERVERIP (Must have one or the other, but not both).\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0010   DS    0H\n         XC    SERVFLG,SERVFLG     Clear SERVER/SERVERIP flag.\n         CLC   SERVER,BLANKS       SERVER blank?\n         BE    CK0010Q             Yes, check SERVERIP.\n         OI    SERVFLG,$SERVNAM    No, set flag bit to that effect.\nCK0010Q  DS    0H                  Check SERVERIP\n         CLC   SERVERIP,BLANKS     SERVERIP blank?\n         BE    CK0010R             Yes, continue.\n         OI    SERVFLG,$SERVNUM    No, set flag bit to that effect.\nCK0010R  DS    0H                  Status of SERVER & SERVERIP coded?\n         TM    SERVFLG,$SERVNAM+$SERVNUM\n         BZ    CK0010S             Neither coded, go do error.\n         BO    CK0010T             Both coded go do error.\n         B     CK0010M             Only one coded - We're good.\n*--- Neither SERVER nor SERVERIP - error.\nCK0010S  DS    0H\n         LA    R1,SRVNONE          -> Msg - Server name blank.\n         BAL   R14,MSG             Display it.\n         MVI   CC,8                Set error code.\n         B     CK0010M             We're finished with this check.\n*--- Both SERVER and SERVERIP - error.\nCK0010T  DS    0H         Neither SERVER nor SERVERIP - error.\n         LA    R1,SRVBOTH          -> Msg - Server ans Serverip coded.\n         BAL   R14,MSG             Display it.\n         MVI   CC,8                Set error code.\n*        B     CK0010M             We're finished with this check.\nCK0010M  DS    0H\n         TM    SERVFLG,$SERVNUM    Server num (SERVERIP) coded?\n         BO    CK0010M1            Yes, go say it.\n         MVC   MSG26W+28(40),BLANKS Clear variable part of message.\n         MVC   MSG26W+28(08),=CL8' SERVER:'\n         MVC   MSG26W+37(40),SERVER Move user coded SERVER value.\n         LA    R1,MSG26H           -> Msg\n         BAL   R14,MSG             Display it.\n         B     CK0010Z             Branch end of this routine.\nCK0010M1 DS    0H\n         MVC   MSG26W+28(40),BLANKS Clear variable part of message.\n         MVC   MSG26W+28(10),=CL10' SERVERIP:'\n         MVC   MSG26W+39(16),SERVERIP Move user coded SERVER value.\n         LA    R1,MSG26H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0010Z  DS    0H                  Done with SERVER/SERVERIP. Whew.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* ALERTPCT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0011   DS    0H\n         CLC   ALERTPCT,BLANKS\n         BNE   CK0011B\n         MVC   ALERTPCT,=CL3'95'\n         MVC   MSG23W+45(20),=CL20' ALERTPCT: 95       '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0011B  DS    0H\n         STR   RJUST,ALERTPCT,3    Right justify the field.\n         PACK  WRKD,ALERTPCT       Convert to packed.\n         CVB   R2,WRKD             Convert to binary.\n         STC   R2,ALERTPCN         Store byte.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* QRESUME\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0012   DS    0H\n         CLC   ALERTPCT,BLANKS\n         BNE   CK0012B\n         MVC   QRESUME,=CL3'90'\n         MVC   MSG23W+45(20),=CL20' QRESUME: 90        '\n         LA    R1,MSG23H           -> Msg\n         BAL   R14,MSG             Display it.\nCK0012B  DS    0H\n         STR   RJUST,QRESUME,3     Right justify the field.\n         PACK  WRKD,QRESUME        Convert to packed.\n         CVB   R2,WRKD             Convert to binary.\n         STC   R2,QRESUMEN         Store byte.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* TRACE\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nCK0013   DS    0H\n         CLC   TRACE,BLANKS\n         BNE   CK0013B\n         MVC   TRACE,=CL1'N'\nCK0013B  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Return to caller.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         BR    R6\n*---------------------------------------------------------------------*\n* PARSE - A primitive parse routine that gets the length and addr\n* of a value, given an input buffer record like this:\n*\n* SERVER   WWW.MYSRVR.COM\n*      . . .\n* PARMn    SOMEDATA\n*\n* ENTRY:\n*    R0 - Length of buffer record to scan.\n*    R1 - Points to start of buffer to scan.\n*    R6 - Return address.\n* EXIT:\n*    PWK is a set of 4 pair of fullwords.  Word one of each pair is\n*    the length of the token, and word 2 is the address of the token.\n* Work:\n*    R7 - Points to parse Work Area (PWK).\n*---------------------------------------------------------------------*\nPARSE    DS    0H\n         STM   R7,R12,RSAVE1          Save callers regs 7-12.\n         XC    PWK,PWK                Clear parse work area.\n         LA    R7,PWK                 -> Parse work area.\n         LR    R8,R1                  -> Start of data.\n         LR    R9,R1                  -> Start of data.\n         AR    R9,R0                  -> End of data.\n*\n* FIND FIRST NONBLANK CHAR.\n*\nPTOP1    DS    0H\n         CLI   0(R8),C' '             First nonblank char yet?\n         BNE   PTOP2                  Yes, find end of first token.\n         LA    R8,1(R8)               Over 1.\n         CR    R8,R9                  End of record yet?\n         BNL   ENDREC                 Yes.\n         B     PTOP1                  Top of loop 1.\nPTOP2    DS    0H\n*        DC    X'0000'\n         ST    R8,0(R7)               Save ptr to token 1.\nPTOP2B   DS    0H\n         LA    R8,1(R8)               Over 1.\n         CR    R8,R9                  End of record?\n         BNL   ENDREC                 Yes, we're done.\n         CLI   0(R8),C' '             No - Next blank yet?\n         BNE   PTOP2B                 No, keep looking.\n         LR    R2,R8                  Get current ptr.\n         S     R2,0(R7)               Subtract origin to get len.\n         ST    R2,4(R7)               Store length.\n         LA    R7,8(R7)               Point to next PWK slot.\n         B     PTOP1\nENDREC   DS    0H\n         LM    R7,R12,RSAVE1          Restore callers regs 7-12.\n         BR    R6                     Return to caller.\n*---------------------------------------------------------------------*\n* MACROS and constants.                                               *\n*---------------------------------------------------------------------*\n         LTORG\n         CNOP  0,4\nOPENIN   OPEN  (TEXTIN,INPUT),MF=L\n         CNOP  0,4\nTEXTIN   DCB   MACRF=(GM),DSORG=PS,LRECL=80,                           X\n               DDNAME=PARMS,DCBE=*-*\nLTEXTIN  EQU   *-TEXTIN\n*\nEEXTIN   DCBE  RMODE31=BUFF,EODAD=EOF\nLEEXTIN  EQU   *-EEXTIN\nWTOPLM   WTO   TEXT=,DESC=(7),MF=L   WTO parm list.\nWTOPLL   EQU   *-WTOPLM\n*\nSVRBLNK  DC    CL50'Remote log server name not specified.  Exiting'\nSVRNFND  DC    CL50'Remote log server lookup failed. Exiting'\nAPIERR   DC    CL50'Error initializing sockets API. Exiting'\nRLCOMM1  RLCOMM CONST\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT\nSAVE     DS    18F                 Register save area.\n*---------------------------------------------------------------------*\n*   MACRO storage.\n*---------------------------------------------------------------------*\n         CNOP  0,4\nGTEXTIN  DS    CL(LTEXTIN)         Macro storage.\n         CNOP  0,4\nGEEXTIN  DS    CL(LEEXTIN)         Macro storage.\n         CNOP  0,4\nGOPENIN  DS    F                   Macro storage.\n         CNOP  0,4\nWTOPL    DS    CL(WTOPLL)          WTO parm list.\n         CNOP  0,4\nWRKD     DS    D                   Doubleword work area.\nWRKF     DS    D                   Fullword work area.\nRR       DS    F                   Fullword work area.\n*\n* Storage for (partially) dynamic messages.\n*\n*\nMSG21H   DS    AL2                 Message skeleton.\nMSG21W   DS    CL(L'MSG21)\n*\nMSG23H   DS    AL2                 Message skeleton.\nMSG23W   DS    CL(L'MSG23)\n*\nMSG26H   DS    AL2                 Message skeleton.\nMSG26W   DS    CL(L'MSG26)\n*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU   *-DATD\n*---------------------------------------------------------------------*\n*   Common Storage DSECT.                                             *\n*---------------------------------------------------------------------*\n         RLCOMM DSECT\n         IKJCPPL\n         END   RLINIT1\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    RLINIT1      '\n         PUNCH ' NAME     RLINIT1(R)   '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RLINIT2": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x007\\x01\\x10\\x10\\x9f\\x01\\x164O\\x18A\\x01\\x1c\\x00\\xfd\\x01\\x1c\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-04-19T00:00:00", "modifydate": "2016-12-09T18:41:37", "lines": 284, "newlines": 253, "modlines": 284, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RMTLOG  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* RLINIT2 - Initialization.                                           *\n*---------------------------------------------------------------------*\n* Entry (Called by RMTLOG):                                           *\n* - R11 - Points to common storage area.  Use this for base reg.      *\n* Regs:                                                               *\n* - R12 - Base register for this program.                             *\n* - R13 - Points to private storage area.                             *\n*---------------------------------------------------------------------*\n* 1) Get hostname of SERVER specified in PARMS file.                  *\n* 2) Initialize TCPIP environment.                                    *\n* 3) Get socket.                                                      *\n* 4) Get local hostname.                                              *\n*---------------------------------------------------------------------*\n* 06/01/2010 John C. Miller - software@jmit.com                       *\n*---------------------------------------------------------------------*\n*\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\n         PRINT GEN,DATA\nRLINIT2  CSECT\nRLINIT2  AMODE ANY\nRLINIT2  RMODE ANY\n         YREGS\n*---------------------------------------------------------------------*\n* Prolog - Get private and common areas, and get set up.\n*---------------------------------------------------------------------*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING RLINIT2,R12          \"\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         USING RLCOMM,R11           Addressability to common area.\n         LR    R1,R2                Restore original R1.\n         ST    R1,R1SAVE            Save R1.\n         MVI   CC,0                 Start with zero CC.\n*---------------------------------------------------------------------*\n* Parms can contain either SERVER or SERVERIP to identify the target  *\n* syslogd server--but only one of these two parms can be coded.       *\n* If SERVER was coded, then do a lookup on hosname to get IP.         *\n* If SERVERIP was coded, then call IPADDR module to convert str->IP.  *\n*---------------------------------------------------------------------*\n         TM    SERVFLG,$SERVNAM     SERVER specified?\n         BO    GETHOST              Yes, go do host lookup.\n         MVC   IPSTRING,SERVERIP    Copy ipadd string to work var.\n         CALL  IPADDR,(IPSTRING),MF=(E,PARMLIST)\n         L     R1,IPSTRING          Load converted IPADDR from 1st wrd.\n         ST    R1,SERVER#           Store it in parms for connect.\n         B     INITAPI              Continue.\n*---------------------------------------------------------------------*\n* GETHOSTBYNAME - Get ip address of target host name.                 *\n*---------------------------------------------------------------------*\nGETHOST  DS    0H\n         STR   LENG,SERVER,79      Get length of string.\n         ST    R1,NAMELEN          Store length of string.\n         EZASMI TYPE=GETHOSTBYNAME,                                    X\n               HOSTENT=HOSTENT,                                        X\n               RETCODE=RETCODE,                                        X\n               NAMELEN=NAMELEN,                                        X\n               NAME=SERVER\n         CLC   RETCODE,MINUSONE    Operation fail?\n         BNE   GETHOSTX            No, continue.\n         B     EXIT8               ... and go to exit rtn.\nGETHOSTX DS    0H\n         L     R5,HOSTENT          -> HOSTENT structure.\n         L     R5,16(R5)           -> IP address list.\n         L     R5,0(R5)            -> 1st IP address.\n         L     R5,0(R5)            Load 1st IP address content.\n         ST    R5,SERVER#          Save server IP address.\n*---------------------------------------------------------------------*\n* INITAPI - Connect to socket interface.                              *\n*---------------------------------------------------------------------*\nINITAPI  DS    0H\n         EZASMI TYPE=INITAPI,      ISSUE INITAPI MACRO                 X\n               SUBTASK=SUBTASK,    SPECIFY SUBTASK IDENTIFIER          X\n               MAXSOC=MAXSOC,      SPECIFY MAXIMUM NUMBER OF SOCKETS   X\n               MAXSNO=MAXSNO,      (HIGHEST SOCKET NUMBER ASSIGNED)    X\n               ERRNO=ERRNO,        (Specify ERRNO field)               X\n               RETCODE=RETCODE,    (Specify RETCODE field)             X\n               APITYPE=APITYPE,    (SPECIFY APITYPE FIELD)             X\n               ASYNC='NO',         Specify synchronous mode.           X\n               ERROR=ERROR         Abend if error on macro\n         CLC   RETCODE,MINUSONE    Operation fail?\n         BNE   SOCKET              No, do next step.\n         CLC   ERRNO,=F'10197'     Already initialized?\n         BE    SOCKET              Yes, that's ok.  Keep going.\n         LA    R1,MINITAPI         -> message.\n         BAL   R14,MSG\n         B     EXIT8               Go to exit rtn.\n*---------------------*\n* INITAPI macro parms *\n*---------------------*\nSUBTASK  DC    CL8'RMTLOG'        SUBTASK PARM VALUE\nMAXSOC   DC    AL2(50)            MAXSOC PARM VALUE\nAPITYPE  DC    H'2'               2 = 1 socket.  3 = many sockets.\n*---------------------------------------------------------------------*\n* Obtain a TCP or UDP socket descriptor, depending on the PROTO parm. *\n*---------------------------------------------------------------------*\nSOCKET   DS    0H\n         CLC   =C'UDP',PROTO       UDP protocol?\n         BE    SOCKETUD            Yes, get a UDP socket.\nSOCKETST DS    0H                  No, get a STREAM (TCP) socket.\n         LA    R1,SOCKTCP          -> Msg - TCP socket selected.\n         BAL   R14,MSG             Display it.\n         MVC   TYPE,MSOCKET        Move SOCKET to message.\n         EZASMI TYPE=SOCKET,       Issue SOCKET macro.                 X\n               AF='INET',          INET socket.                        X\n               SOCTYPE='STREAM',   STREAM for TCP socket.              X\n               ERRNO=ERRNO,        ERRNO output field.                 X\n               RETCODE=RETCODE,    RETCODE output field.               X\n               ERROR=ERROR         Go here on exit.\n         B     CHECKSOK            Go check socket success.\nSOCKETUD DS    0H                  No, get a STREAM (TCP) socket.\n         LA    R1,SOCKUDP          -> Msg - UDP socket selected.\n         BAL   R14,MSG             Display it.\n         MVC   TYPE,MSOCKET        Move SOCKET to message.\n         EZASMI TYPE=SOCKET,       Issue SOCKET macro.                 X\n               AF='INET',          INET socket.                        X\n               SOCTYPE='DATAGRAM', DATAGRAM for UDP socket.            X\n               ERRNO=ERRNO,        ERRNO output field.                 X\n               RETCODE=RETCODE,    RETCODE output field.               X\n               ERROR=ERROR         Go here on exit.\nCHECKSOK DS    0H\n         CLC   RETCODE,MINUSONE    Operation ok?\n         BNE   SOCKOK              Yes, continue.\n         LA    R1,MSOCKERR         -> message.\n         BAL   R14,MSG\n         B     EXIT8               Return with bad RC.\nSOCKOK   DS    0H\n         L     R8,RETCODE          Load RETCODE.\n         STH   R8,S                Save socket num in comm strg.\n*---------------------------------------------------------------------*\n* Connect to server.                                                  *\n*---------------------------------------------------------------------*\nCONNECT  DS    0H\n         MVC   TYPE,MCONNECT       Move 'CONNECT' to message.\n         MVC   FAMILY,=H'2'        Store family in sockt addr struct.\n*        MVC   PORT,=H'514'        *TST* Store port in sockt addr struc\n         EZASMI TYPE=CONNECT,                                          X\n               S=S,                Stream.                             X\n               NAME=NAME,          Socket name structure.              X\n               ERRNO=ERRNO,        (Specify ERRNO field)               X\n               RETCODE=RETCODE,    (Specify RETCODE field)             X\n               ERROR=ERROR         Abend if Macro error\n         CLC   RETCODE,MINUSONE    Operation ok?\n         BNE   CONNOK              Yes, continue.\n         LA    R1,MCONNERR         -> message.\n         BAL   R14,MSG\n         B     EXIT8               Return with bad RC.\nCONNOK   DS    0H\n*---------------------------------------------------------------------*\n* GETHOSTNAME - Get the host name that we're running on.  Comes from  *\n* the HOSTNAME field in the TCPDATA member in use.                    *\n*---------------------------------------------------------------------*\nHOSTNAME DS    0H\n         NOP   GETHOSNX\n         MVC   HOSTNAML,=F'12'     Set length.\n         EZASMI TYPE=GETHOSTNAME,  Get host name of our local host.    X\n               NAMELEN=HOSTNAML,                                       X\n               NAME=HOSTNAM,                                           X\n               RETCODE=RETCODE,                                        X\n               ERRNO=ERRNO\n         CLC   RETCODE,MINUSONE    Operation fail?\n         BNE   GETHOSNX            No, continue.\n         LA    R1,MLOCHOST         -> Msg.\nGETHOSNX DS    0H\n         OC    HOSTNAM,BLANKS      Convert X'00' to X'40'\n         STR   LENG,HOSTNAM,12     Get length of hostname.\n         ST    R1,HOSTNAML         Save length for later MVCL.\nGETHOSNY DS    0H\n*---------------------------------------------------------------------*\n* Other setup.                                                        *\n*---------------------------------------------------------------------*\n         B     EXIT\n*---------------------------------------------------------------------*\n* RETURN                                                              *\n*---------------------------------------------------------------------*\nERROR    DS    0H\nEXIT8    DS    0H\n         MVI   CC,8                Set return code 8 (error).\n         B     EXIT\nEXIT0    DS    0H\n         MVI   CC,0                Set zero (good) return code.\nEXIT     DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*  MSG - WTO a message, and write it to SYSPRINT if open.             *\n*---------------------------------------------------------------------*\nMSG      DS      0H\n         BAKR    R14,0             Save callers environment.\n         SAC     0                 Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         MVC     WTOPL,WTOPLM      Set up parm list.\n         LR      R2,R1             Point R2 to msg text passed in R1.\n         WTO     TEXT=(R2),        WTO the message.                    X\n               MF=(E,WTOPL)\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP0             No, branch around.\n         MVC   BUFFER,BLANKS       Clear message buffer.\n         LA    R4,BUFFER           -> buffer.\n         SR    R5,R5               Clear reg.\n         LH    R5,0(R2)            Len of MVCL.\n         LR    R7,R5               Len of MVCL.\n         LA    R8,2(R2)            -> message text.\n         MVCL  R4,R8\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP0  DS    0H\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n* MACROS and constants.                                               *\n*---------------------------------------------------------------------*\nSOCKTCP  DC     AL2(L'MSG32)\nMSG32    DC     C'RLG032I TCP protocol selected.'\nSOCKUDP  DC     AL2(L'MSG33)\nMSG33    DC     C'RLG033I UDP protocol selected.'\nMLOCHOST DC     AL2(L'MSG34)\nMSG34    DC     C'RLG034I Unable to determine local hostname.'\nMSOCKERR DC     AL2(L'MSG35)\nMSG35    DC     C'RLG035I Error creating socket.'\nMCONNERR DC     AL2(L'MSG36)\nMSG36    DC     C'RLG036I Error connecting socket.'\nMINITAPI DC     AL2(L'MSG37)\nMSG37    DC     C'RLG037I Waiting for TCPIP initialization.'\n*---------------------------------------------------------------------*\n         LTORG\n         CNOP  0,4\nWTOPLM   WTO TEXT=,DESC=(7),MF=L   WTO parm list.\nWTOPLL   EQU *-WTOPLM\n*\nRLCOMM1  RLCOMM CONST              Define RMTLOG common constants.\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT\nSAVE     DS    18F                 Register save area.\n*---------------------------------------------------------------------*\n*   MACRO storage.\n*---------------------------------------------------------------------*\nWTOPL    DS    CL(WTOPLL)          WTO parm list.\n         CNOP  0,4\nWRKD     DS    D                   Doubleword work area.\nWRKF     DS    D                   Fullword work area.\nIPSTRING DS    CL16                Workarea for IP address.\n*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU   *-DATD\n*---------------------------------------------------------------------*\n*   RMTLOG Common Storage DSECT.                                      *\n*---------------------------------------------------------------------*\n         RLCOMM DSECT              RMTLOG command storage mmapping.\n         IKJCPPL                   CPPL mapping.\n         END   RLINIT2\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    RLINIT2      '\n         PUNCH ' NAME     RLINIT2(R)   '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RLWRITE": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00A\\x01\\x105\\x0f\\x01\\x164O\\x18A\\x01\\x9d\\x01\\x7f\\x01\\x9d\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2010-12-16T00:00:00", "modifydate": "2016-12-09T18:41:41", "lines": 413, "newlines": 383, "modlines": 413, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RMTLOG  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* This version does synchronous socket operations.                    *\n*---------------------------------------------------------------------*\n* RLWRITE - Write a record to a remote syslog server.                 *\n*---------------------------------------------------------------------*\n* Entry:                                                              *\n*   R11 - Points to common area.                                      *\n*   R1  - Points to parameter list.                                   *\n*   +0  - Pointer to data to write.                                   *\n*   +4  - Pointer to length of data.                                  *\n*  F+4  - Pointer to length of data.                                  *\n*---------------------------------------------------------------------*\n* Record format - Time option 1 (Use system time)                     *\n* <039>May 25 22:12:12 Hostname :Hi there world...                    *\n*---------------------------------------------------------------------*\n* 01/28/2011 - John Miller - Changed code so that 2 character PRI     *\n* values will not cause a space in the PRI field.  e.g. if  \"PRI 35\": *\n* Old code: <35 >May 25 22:12:12 Hostname :Hi there world...          *\n* New code: <35>May 25 22:12:12 Hostname :Hi there world...           *\n* This was done to accomodate syslog servers that don't like leading  *\n* zeros in the PRI value, and to remove embedded spaces from the PRI  *\n* value which does not technically conform to RFC5424.                *\n* Changed code is tagged with: @JCM1                                  *\n*---------------------------------------------------------------------*\n* 06/10/2010 John C. Miller                                           *\n*---------------------------------------------------------------------*\n*\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\n*\nRLWRITE  CSECT\nRLWRITE  AMODE ANY\nRLWRITE  RMODE ANY\n         PRINT GEN,DATA\n         YREGS                     Do register equates.\n*---------------------------------------------------------------------*\n* Prolog - Get private and common storage areas and set up.\n*---------------------------------------------------------------------*\n         BAKR  R14,0                Save caller env.\n         LAE   R12,0(R15)           Load base reg.\n         USING RLWRITE,R12          Addressability.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Get workarea addr in reg.\n         USING DATD,R13             DSECT addressability.\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         USING RLCOMM,R11           Common area addressability.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* R1SAVE contains the contents of R1 when the parent program got cntl.*\n* We need this R1 because it points to the CPPL if one exists (i.e.   *\n* we are running under TSO.).  This allows us to use PUTLINEs.        *\n* We use R2 to save R1 as passed to this program, which points        *\n* to our parameter list as per standard call linkage.                 *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         L     R1,R1SAVE            Get saved R1 contents for CPPL.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Check the FLAG for partial write needed.  If so then do it.         *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         TM    FLAG,FPARTWRT       Get third passed parm.\n         BO    REWRITE             Yes, go do it.\n*---------------------------------------------------------------------*\n* @WRITE - Set up syslogd buffer and write it.                        *\n*---------------------------------------------------------------------*\n* TIME - Get local system time, and plug it into the SYSLOG message.  *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* 0        4        8 9 A B  12                                       *\n* 08040498 12260000 05062010 00000000                                 *\n*---------------------------------------------------------------------*\n@WRITE   DS    0H\n*\n* Use MVCL to set buffer to blanks.\n*\n         LA    R6,@@HEADER         Target of move.\n         LA    R7,@LENALL          Length of move.\n         SR    R4,R4               Dummy source for MVCL.\n         SR    R5,R5               Clear reg.\n         ICM   R5,B'1000',=X'40'   Pad character.\n         MVCL  R6,R4               Clear entire msg buffer.\n         LA    R4,@MESSAGE         -> message buffer.\n*\n* Copy HOSTNAME to data buffer if it was hardcoded.  If not hardcoded,\n* then copy the hostname that was retrieved by gethostname.\n* HOSTNM & HOSTNML are the hard coded hostname/length.\n* HOSTNAM & HOSTNAML are the looked up hostname/length.\n* R9 contains the running length of the message to be sent.\n*\n         ICM   R9,B'1111',HOSTNML  Get len of hardcoded host name.\n         BZ    HOSTNM2             Zero len, so check next hostname.\n*        TPUT  =CL50'HOSTNM:',50\n         MVC   0(8,R4),HOSTNM      Move hard coded host name.\n         B     HOSTNMMV            Go move it.\nHOSTNM2  DS    0H\n         ICM   R9,B'1111',HOSTNAML Get lenght of looked up hostname.\n         BZ    NOHSTNAM            Zero means no host name to use.\n         MVC   0(8,R4),HOSTNAM     Move looked up host name.\nHOSTNMMV DS    0H\n         ICM   R3,B'0011',=C' :'   Get delimiter chars in register.\n         STH   R3,0(R4,R9)         Store delimiters past host name.\n         LA    R9,2(R9)            Point past delimiters, and\n         AR    R4,R9               ... point past hostname.\nNOHSTNAM DS    0H\n*\n* Copy caller's data to our header and msg buffer.\n*\n         L     R6,0(R2)            -> caller's data.\n         L     R5,4(R2)            Load -> length.\n         L     R5,0(R5)            Load length.\n         LR    R7,R5               Load length.\n         MVCL  R4,R6               Move message to our buffer.\n*\n* Update R4 to point to end of the data.\n*\n         L     R5,4(R2)            Load -> length.\n         L     R5,0(R5)            Load length.\n         AR    R9,R5               Length to end of data.\n*\n* For TCP connections only, add a CR/LF to the end of the data.\n* UDP connections don't need it.  Insert CR/LF characters x'0D25'\n* into our buffer after msg text.\n*\n         CLC   =C'UDP',PROTO       UDP?\n         BE    UDPNOCR             Yes, branch around crlf code.\n         LH    R3,=X'0D25'         Get CR/LF in EBCDIC.\n         STH   R3,@MESSAGE(R9)     Put CR/LF at end of message.\n         LA    R9,2(R9)            Point past delimiters.\nUDPNOCR  DS    0H\n         LA    R9,@HEADRLN(R9)     Add length of header.\n         ST    R9,BUFFERL          Store len of hrd+msg.\n*\n* @@@ copy PRI value from PARMS.\n*\n         MVC   @PRI,PRI            Copy PRI from PARMS.\n\n*\n* Populate time and date.  Use TIMESRC parm to decide whether to use:\n* MESSAGE - Time embedded in the MVS MDB;\n* SYSTEM  - Use system time.\n*\n*---------------------------------------------------------------------*\n* TIME - Get local system time, and plug it into the SYSLOG message.  *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* 0        4        8 9 A B  12                                       *\n* 08040498 12260000 05062010 00000000                                 *\n* hhmmsshh          mmddyyyy 00000000                                 *\n* 00.43.24 TIMEMDB                                                    *\n* 01234567 TIMEMDB                                                    *\n* 2010155  DATEMDB                                                    *\n*---------------------------------------------------------------------*\n         CLC   TIMESRC,=CL8'SYSTEM' Use time stamp from system clock?\n         BE    SYSTIME             Yes, go use it.\n         CLC   TIMEMDB,=CL8' '     Bad MDB time?\n         BE    SYSTIME             Yes, use system time.\n         MVC   @TIME(8),TIMEMDB    Move time.\n         MVI   @TIME+2,C':'        Move :\n         MVI   @TIME+5,C':'        Move :\n         MVI   @TIME+8,C' '        Move blank.\n         CALL  JULIAN,(DATEMDB,=X'50',JANDATE),MF=(E,PARMLIST)\n         MVC   @MON,JANDATE        Move text month.\n         MVC   @DAY,JANDATE+4      Move 2 digit day.\n         CLI   @DAY,C'0'           Leading '0'?\n         BNE   NOLDZER             No, leave it.\n         MVI   @DAY,C' '           Make it a space per RFC 3164.\nNOLDZER  DS    0H\n         B     TIMECONT            Continue formatting time and date.\nSYSTIME  DS    0H\n         TIME  DEC,TIMEDATE,ZONE=LT,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         SR    R6,R6               Clear reg.\n         LH    R6,TIMEDATE+10      Load halfword containing year.\n         SLL   R6,4                Shift left to make room for sign.\n         O     R6,=X'0000000C'     Make positive sign.\n         ST    R6,DWORK+4          Store packed decimal in work area.\n         UNPK  WRK,DWORK+4(4)      Unpack it.\n         OI    WRK+7,X'F0'         Fix the sign.\n         MVI   @YEAR,C'-'          Add a dash.\n         MVC   @YEAR+1(4),WRK+4    Put year in message header.\n         MVI   @YEAR+5,C'-'        Add a dash.\n* Set text version of month.\n         SR    R6,R6               Clear reg.\n         IC    R6,TIMEDATE+8       Get month byte.\n         S     R6,=F'1'            Back up one.\n         CH    R6,=H'0'            Too low for a month?\n         BL    @MONBAD             Check for month too high.\n         CH    R6,=H'11'           Month too high?\n         BNH   @MONOK              No, continue on.\n@MONBAD  DS    0H\n         LA    R6,0                Bad month, so hard code Jan.\n@MONOK   DS    0H\n         SLL   R6,2                Mult. by 4 by shifting lft 2 bits.\n         LA    R5,@MONS            -> months table.\n         L     R4,0(R6,R5)         Get appropriate month.\n         STCM  R4,B'1111',@MON     Save month.\n* Set text version of day.\n         SR    R6,R6               Clear reg.\n         IC    R6,TIMEDATE+9       Get day byte in reg.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@DAY+1           Store right hand digit of day.\n         IC    R6,TIMEDATE+9       Get day byte in reg.\n         SRL   R6,4                Get left digit in lo order position.\n         LTR   R6,R6               Leading zero?\n         BZ    LEADZERO            Yes, don't store '0', leave blank.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@DAY             Store left hand digit of day.\nLEADZERO DS    0H\n*\n* Convert to zoned decimal: Hour\n         IC    R6,TIMEDATE         Get first byte.\n         SRL   R6,4                Get first nibble.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@TIME            Store byte of time.\n         IC    R6,TIMEDATE         Get first byte/second nibble.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@TIME+1          Store byte of time.\n         MVI   @TIME+2,C':'        Store literal ':'\n*\n* Convert to zoned decimal: Minute\n         IC    R6,TIMEDATE+1       Get 2nd byte.\n         SRL   R6,4                Get 1st nibble.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@TIME+3          Store byte of time.\n         IC    R6,TIMEDATE+1       Get 2nd byte.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@TIME+4          Store byte of time.\n         MVI   @TIME+5,C':'\n*\n* Convert to zoned decimal: Seconds\n         IC    R6,TIMEDATE+2       Get 3rd byte.\n         SRL   R6,4                Get 1st nibble.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@TIME+6          Store byte of time.\n         IC    R6,TIMEDATE+2       Get 2nd byte.\n         O     R6,=X'000000F0'     Set zone for numeric.\n         STC   R6,@TIME+7          Store byte.\nTIMECONT DS    0H\n*        TPUT  @@HEADER,70\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* @@JCM1 - Fix PRI field to remove blanks.                            *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Make some checks and adjustments for the PRI value.  We do this now *\n* because PRI is at the front of the buffer, and so all the other     *\n* fields have to slide to the \"left\" to account for a PRI len < 3.    *\n* e.g. is user coded \"PRI  35\" then the @PRI field looks like: <35 >aaa\n* This code changes the @PRI field to look like: <35>.                *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         L     R5,BUFFERL          @JCM1 Get buffer length.\n         LA    R4,@PRI             @JCM1 -> PRI in buffer.\n         LA    R4,3(R4)            @JCM1 -> first blank to delete.\n         CLI   0(R4),C' '          @JCM1 2 or fewer chars?\n         BNE   @@JCM1Z             @JCM1 No, do nothing.\n         BCTR  R5,0                @JCM1 Len - 1.\n         ST    R5,BUFFERL          @JCM1 Store new shorter length.\n         LA    R6,1(R4)            @JCM1 -> data to move.\n         S     R5,=AL4(2)          @JCM1 Adjust length of move.\n         LR    R7,R5               @JCM1 Get MVCL len in other len reg.\n         MVCL  R4,R6               @JCM1 Shift buffer left.\n@@JCM1Z  DS    0H\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Set up for write.                                                   *\n* EZACIC04 converts EBCDIC to ASCII text.                             *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nDOASCII  DS    0H\n         CALL  EZACIC04,(@@HEADER,BUFFERL),VL,MF=(E,PARMLST)\n         MVC   TYPE,MWRITE         MOVE 'WRITE ' TO MESSAGE\n         LA    R4,@@HEADER         -> field to write.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Write to the TCP or UDP socket.                                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* The RETCODE field contains the number of bytes written on the       *\n* WRITE call.  This may or may not be the number of bytes that we     *\n* requested to be written.  Shorter messages are usually written      *\n* with one call, but there is no guarantee that this will be so.      *\n* To account for this, we need to compare the bytes written with      *\n* the bytes requested to be written, and if all the bytes were not    *\n* written, we need to do another WRITE invocation.  Before we do      *\n* this, we have to calculate the remaining number of bytes that       *\n* still need to be written, and update the pointer to point to the    *\n* start of the unwritten data.                                        *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nWRITE    DS    0H\n         EZASMI TYPE=WRITE,        Issue WRITE.                        X\n               S=S,                STREAM socket.                      X\n               NBYTE=BUFFERL,      Size of message buffer.             X\n               BUF=(R4),           Data to write.                      X\n               ERRNO=ERRNO,        Output field: ERRNO.                X\n               RETCODE=RETCODE,    Output field: RETCODE.              X\n               ERROR=ERROR         Abend if Macro error\n*        MVC   BUFFER,=CL80'WRITE:::'\n*        BAL   R14,PUTLINE\n         CLC   RETCODE,MINUSONE    Error on write?\n         BE    ERROR               Return indicating an error.\n         CLC   RETCODE,BUFFERL     Bytes written=bytes requested?\n         BNL   EXIT                Yes, we're finished with the write.\n*\n* Bytes written (RETCODE) less than bytes requested (BUFFERL).  Need to\n* prepare for a partial buffer write next time we're called.\n* BUFFERL and BUFFERP are in the common DSECT, & so will still be here\n* next time through.\n*\n         OI    FLAG,FPARTWRT       Turn on partial write needed bit.\n         A     R4,RETCODE          Add length of data that was written.\n         ST    R4,BUFFERP          Store ptr to next data to write.\n         L     R5,BUFFERL          Get length into reg.\n         S     R5,RETCODE          Subtract length of data written.\n         ST    R5,BUFFERL          Save length back in length field.\n         B     ERROR               Drive partial write.\n*\n* Entry point for a partial write.\n*\nREWRITE  DS    0H\n         NI    FLAG,X'FF'-FPARTWRT Turn off partial write needed bit.\n         L     R4,BUFFERP          -> data to write.\n*        BUFFERL already has new partial length from last time we ran.\n         B     WRITE               Go do write\n*---------------------------------------------------------------------*\n* Return.  CC is in common storage, and contains return code.         *\n*---------------------------------------------------------------------*\nERROR    DS    0H\n         MVI   CC,X'08'            Set RC=8.\n         B     EXIT0               Go exit.\nEXIT     DS    0H\n         MVI   CC,X'00'            Set zero return code.\nEXIT0    DS    0H\n         LR    R1,R13              Get address of RELEASE.\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*   Constants and LTORG\n*---------------------------------------------------------------------*\n@MONS    DC    C'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec '\n         LTORG\n         RLCOMM CONST\nWTOPLM   WTO TEXT=,DESC=(7),MF=L   WTO parm list.\nWTOPLL   EQU *-WTOPLM\n*---------------------------------------------------------------------*\n* MSG subroutine.  WTO the text, and write it to SYSPRINT if open.\n*---------------------------------------------------------------------*\nMSG      DS      0H\n         BAKR    R14,0             Save callers environment.\n         SAC     0                 Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         MVC     WTOPL,WTOPLM      Set up parm list.\n         LR      R2,R1             Point R2 to msg text passed in R1.\n         WTO     TEXT=(R2),        WTO the message.                    X\n               MF=(E,WTOPL)\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP0             No, branch around.\n         MVC   BUFFER,BLANKS       Clear message buffer.\n         LA    R4,BUFFER           -> buffer.\n         SR    R5,R5               Clear reg.\n         LH    R5,0(R2)            Len of MVCL.\n         LR    R7,R5               Len of MVCL.\n         LA    R8,2(R2)            -> message text.\n         MVCL  R4,R8\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP0  DS    0H\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n* Write a line to SYSPRINT.\n*---------------------------------------------------------------------*\nPUTLINE  DS    0H\n         BAKR    R14,0             Save callers environment.\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT                     Dynamic area.\nSAVE     DS    18F                 Register save area.\nTIMEDATE DS    4F\nWTOPL    DS    CL(WTOPLL)          WTO parm list.\nJANDATE  DS    CL11\nDWORK    DS    D\nTMP1     DS    F\nTMP2     DS    F\nTMP3     DS    F\nTMP4     DS    F\nTMP5     DS    F\nTMP6     DS    F\nWRK      DS    CL8\nWTOLL    DS    CL2\nWTOLR    DS    CL2\n*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU    *-DATD\n*        DCBD    DSORG=QS\n         RLCOMM DSECT\n         IKJCPPL\n         END   RLWRITE\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    RLWRITE      '\n         PUNCH ' NAME     RLWRITE(R)   '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMTLOG": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00F\\x01\\x10\\tO\\x01\\x164O\\x18A\\x03\\xa1\\x02\\xea\\x03\\xa1\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-04-04T00:00:00", "modifydate": "2016-12-09T18:41:46", "lines": 929, "newlines": 746, "modlines": 929, "user": "USER03"}, "text": "*---------------------------------------------------------------------*\n* RMTLOG  - MVS Remote Syslog Facility.                               *\n*---------------------------------------------------------------------*\n* RMTLOG  - Main module.                                              *\n*---------------------------------------------------------------------*\n* 04/20/2010 John C. Miller - software@jmit.com                       *\n* 03/22/2011 JCM - Changed common storage area to LOC=24 so that the  *\n* DCB/DCBE in common storage will work correctly.                     *\n*---------------------------------------------------------------------*\n* Purpose: mirror MVS hardcopy messages to an RFC 3194 compliant      *\n* remote syslog server.  Sends messages via UDP port 514.             *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Development notes:                                                  *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Environment is z/OS 1.10.  Code uses EZASMI facility for managing   *\n* the TCP/IP sockets environment.  MCSOPER and MCSOPMSG macros are    *\n* used to create and operate the extended MCS console.  The console   *\n* code uses a combination of Access Register (AR) mode for            *\n* accessing MDBs in data spaces, and primary mode for normal          *\n* execution.                                                          *\n*---------------------------------------------------------------------*\n* This code may be useful for examples of how to code for datagram    *\n* (UDP) and stream (TCP) sockets communication, EMCS consoles, and    *\n* Access Register (AR) mode coding in general.  Use of multiple       *\n* ECBs to handle multiple events, and coding to handle MODIFY and     *\n* STOP commands is also illustrated.                                  *\n*                                                                     *\n* Asynchronous vs. synchronous sockets:                               *\n* -------------------------------------                               *\n* The TCP/IP socket calls are synchronous blocking calls, which       *\n* means that the address space is suspended while waiting for         *\n* socket I/O to complete.  This design decision was made because it   *\n* simplifies coding somewhat, and because I did not see any real      *\n* benefit to coding for asynchronous socket operation.  If there is   *\n* any delay in writing to the remote syslog server, the EMCS          *\n* console will continue to queue messages until it's buffers are      *\n* depleted.  This provides a reasonable mechanism for buffering       *\n* between the z/OS syslog and unix/syslogd environment.  The same     *\n* scenario (EMCS buffering) would take place with either synchronous  *\n* or asynchronous sockets in the case of a non-responsive syslog      *\n* server.                                                             *\n*                                                                     *\n* Operation notes:                                                    *\n* ----------------                                                    *\n* For best results the syslogd server should be dedicated only to     *\n* handling remote syslog requests, and should have plenty of disk     *\n* space for logs.  There's no reason that a syslogd server could      *\n* not handle remote logging for multiple or even many different       *\n* servers, including MVS systems using this program.                  *\n*                                                                     *\n* It is also recommended that syslog-ng (Syslog Next Generation) be   *\n* used in lieu of the standard BSD Syslogd server that is still       *\n* packaged with many Linux distributions.  One of the main            *\n* advantages of using syslog-ng is that it supports TCP               *\n* connections.                                                        *\n*---------------------------------------------------------------------*\n* This program runs as a started task, and mirrors all MVS hardcopy   *\n* syslog messages to a RFC 3164 compliant syslogd server.  The main   *\n* purpose for this program is to provide a facility for MVS logs to   *\n* be mirrored to another platform for security purposes. This         *\n* capability is a common requirement for PCI compliance.              *\n*                                                                     *\n* This facility also enables MVS messages to be aggregated with       *\n* logs from other machines for ease of management, and use of log     *\n* management tools like splunk.                                       *\n*---------------------------------------------------------------------*\n* The syslogd server to which this program sends messages can be a    *\n* simple Linux server running SuSE, Red Hat, or most any Linux        *\n* distribution.  Follow the instructions for your particular Linux    *\n* distribution for enabling the Linux server to allow remote syslog   *\n* connections.  This typically involves adding a switch to the        *\n* syslogd daemon (usually the \"-r\" switch.)  The Linux firewall       *\n* must also be configured to allow access to UDP port 514, which is   *\n* the remote syslogd port that this program uses.                     *\n*                                                                     *\n* To end the program, issue the MVS STOP command like this:           *\n*    P RMTLOG                                                         *\n*                                                                     *\n* This program must reside in an APF authorized library.              *\n*                                                                     *\n* The starup PROC for this program is simple:                         *\n*                                                                     *\n* //RMTLOG   PROC                                                     *\n* //LOGGER   EXEC PGM=RMTLOG,TIME=1440                                *\n* //PARMS    DD   DISP=SHR,DSN=pds.name(PARMS)                        *\n* //SYSTCPD  DD   DISP=SHR,DSN=tcpip.tcpdata                          *\n* //SYSPRINT DD   SYSOUT=*                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Parameter file:                                                     *\n* This program uses a parameter file allocated to the DDNAME: PARMS.  *\n* Parameters currently allowed in the parameter file are as follows:  *\n*                                                                     *\n*  SERVER   syslog server name.                                       *\n*  CNAME    MCS Console name to be created.                           *\n*  PRI      Per RFC 3194, the message priority.  See the docs for RFC *\n*           3194 at http://tools.ietf.org/html/rfc3164 for more info. *\n*                                                                     *\n* # Sample RMTLOG parameter file:                                     *\n* #                                                                   *\n*   SERVER    syslog.jmit.com                                         *\n*   PROTO     TCP | UDP                                               *\n*   PORT      514                                                     *\n*   TIMESRC   MESSAGE | SYSTEM                                        *\n*   CNAME     RLG01                                                   *\n*   PRI       035                                                     *\n*   RETRYINT  15                                                      *\n*   RETRIES   0                                                       *\n*   SIZE      512                                                     *\n*   QLIMIT    524288                                                  *\n*---------------------------------------------------------------------*\n* This program should run at a fairly high dispatching priority, so   *\n* that messages don't get backed up and cause problems.  The code     *\n* operates approximately as follows:                                  *\n*                                                                     *\n* Initialization:                                                     *\n* - Initialize the TCP/IP sockets environment, and connect to the     *\n*   syslogd server specified by the SERVER parameter in PARMS file.   *\n* - Dynamically create a software extended MCS console, specifying    *\n*   that the hardcopy message set is to be routed to the MCS cons.    *\n* Operation:                                                          *\n* - Wait on three different ECBs, and dispatch based on which ECB is  *\n*   posted.                                                           *\n* -- If the CIB ECB is posted, then process STOP and MODIFY commands. *\n*    At this time only the STOP (P) command is implemented, but other *\n*    modify commands (F) can easily be added.                         *\n* -- If the MSG ECB is posted, then read and process Message Data     *\n*    Blocks (MDB's) that contain the syslog messages.  Write these    *\n*    messages to the remote syslogd server.  This initial version of  *\n*    the code mirrors all hardcopy messages to the remote syslog      *\n*    server, but some ability to only mirror selected messages, and   *\n*    the use of different PRI codes for different messages is a       *\n*    likely enhancement to be made to the code.                       *\n* -- If the ALTERT ECB is posted, then handle errors with the MCS     *\n*    console interface.                                               *\n* Shutdown:                                                           *\n* - When the STOP command is issued against the started task, the     *\n*   extended MCS console is shut down, the syslog server connection   *\n*   is closed, and the started task ends.                             *\n*---------------------------------------------------------------------*\n*\n*=====================================================================*\n* RMTLOG Remote logging program copyright 2010-2017 John C. Miller.   *\n*---------------------------------------------------------------------*\n* This program is free software: you can redistribute it and/or       *\n* modify it under the terms of the GNU General Public License as      *\n* published by the Free Software Foundation, either version 3 of      *\n* the License, or (at your option) any later version.                 *\n*                                                                     *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License in member $GPL for more details.         *\n*---------------------------------------------------------------------*\n         GBLB  &NODEBUG\n&NODEBUG SETB  0\nRMTLOG   CSECT\nRMTLOG   AMODE ANY\nRMTLOG   RMODE ANY\n         PRINT GEN,DATA\n         YREGS                     Do register equates.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Prolog - Get private and common storage areas and set up.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         BAKR  R14,0                Save caller env.\n         LR    R12,R15              Load base reg.\n         USING RMTLOG,R12           Addressability.\n         MODID ,                    Eyecatcher.\n         LR    R2,R1                Save R1 contents.\n         STORAGE OBTAIN,LENGTH=DYNL Obtain private work area.\n         LR    R13,R1               Load base reg.\n         USING DATD,R13             DSECT addressability\n         MVC   4(4,R13),=C'F1SA'    Indicate Fmt1 save area.\n         STORAGE OBTAIN,LENGTH=RLCOMML,LOC=24 Common storage area.\n         LR    R11,R1                   Addressability to common area.\n         USING RLCOMM,R11               \"\n         ST    R2,R1SAVE            Save R1 contents.\n         LR    R1,R2                Get original R1 for CPPL/PUTLINE.\n         BAL   R14,SETUP            Set up.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Set up for ECB for console messages and console alerts.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         LA    R1,ECBMSG           -> ECB for console messages.\n         ST    R1,AECBMSG          Store ECB ptr in ECB list.\n         LA    R1,ECBALRT          -> ECB for cosole ALERT.\n         ST    R1,AECBALRT         Store ECB ptr in ECB list.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Set up for CIB for MODIFY (F) and STOP (P) commands.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         LA    R9,COMADDR          -> com area.\n         EXTRACT (R9),FIELDS=COMM,  extract the com area               X\n               MF=(E,EXTRACT)\n         L     R9,COMADDR          -> com area.\n         USING COM,R9              Use R9 as base rweg for com area.\n         ICM   R7,B'1111',COMCIBPT get address of the CIB\n         BZ    NOCIB               no start CIB\n         BAL   R14,DOCIB           process the CIB\nNOCIB    DS    0H\n         CLI   DONE,1              STOP issued?\n         BE    EXIT                Yes, exit.\n         QEDIT ORIGIN=COMCIBPT,                                        X\n               CIBCTR=1            Set modify limit to 1.\n         L     R1,COMECBPT         -> com ecb.\n         O     R1,=X'80000000'     Set high bit - last ecb in list.\n         ST    R1,AECBMOD          Put addr of modify ECB in ECB list.\n*---------------------------------------------------------------------*\n* Call RLINIT1 routine to:                                            *\n* - Read, parse and validate PARMS file.                              *\n*---------------------------------------------------------------------*\nRLINIT1  CALL  RLINIT1             Call init1 routine.\n         CLI   CC,0                Successful?\n         BNE   EXIT                No, exit.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* Get extended MCS console, and start capturing messages.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         BAL   R14,GETCONS         Get extended MCS console.\n*---------------------------------------------------------------------*\n* Call RLINIT2 routine to:                                            *\n* - Do hostname lookup on server name.                                *\n* - Other setup tasks.                                                *\n*---------------------------------------------------------------------*\nRLINIT2A DS    0H\n         LA    R1,STARTIN2         -> Msg - Starting init phase 2.\n         BAL   R14,MSG             Display message.\nRLINIT2B DS    0H\n         CALL  RLINIT2             Call init routine.\n         CLI   CC,0                Successful?\n         BE    LOOP0               Yes, start processing.\n         TM    FLAG,FRETRMSG       No - was retry message sent already?\n         BO    NORETRYM            Don't reissue message\n         LA    R1,MRETRYC          -> Msg - Retrying connection.\n         BAL   R14,MSG             Display message.\n         OI    FLAG,FRETRMSG       Say we've already\nNORETRYM DS    0H\n         STIMER WAIT,DINTVL=RETRYINT Wait a spell.\n*        BAL   R14,DOCIB           Check for STOP command entered.\n         BAL   R14,CKSTOP          Check for STOP command entered.\n         CLI   DONE,1              STOP command entered?\n         BE    EXIT                Yes, leave.\n         CALL  RECON               Try to reconnect.\n         B     RLINIT2B            Try again.\n*---------------------------------------------------------------------*\n* Main Loop:                                                          *\n* Wait on a list of ECBs, and go do appropriate things when one of    *\n* the ECBs is posted.                                                 *\n*---------------------------------------------------------------------*\nLOOP0    DS    0H\n         LA    R1,RECRDING         -> Msg.\n         BAL   R14,MSG             Display message.\nLOOP     DS    0H\n         NI    FLAG,X'FF'-FRETRMSG Turn off retry message flag.\n         CLI   DONE,1              Done flag set?\n         BE    RLCLOS              Yes, release storage and exit.\nWAIT     DS    0H\n         WAIT  ECBLIST=ECBS        Wait for ECB to be posted.\n         L     R1,ECBMSG           Load message ECB.\n         N     R1,=X'40000000'     Check for ECB post.\n         BZ    CKALRT              Not posted, check next ECB.\n         XC    ECBMSG,ECBMSG       Clear ECB, and...\n         BAL   R14,GETMSGS         Get messages.\nCKALRT   DS    0H\n         L     R1,ECBALRT          Load alert ecb\n         N     R1,=X'40000000'     Check for ECB post.\n         BZ    CKCIB               Not posted, check next.\n         XC    ECBALRT,ECBALRT     Clear ECB.\n         BAL   R14,DOALERT         Do console alert processing.\nCKCIB    DS    0H\n         ICM   R1,B'1111',COMCIBPT Get CIB pointer.\n         BZ    LOOP                No CIB, back to main loop.\n         BAL   R14,DOCIB           Process CIB.\n         B     LOOP                Back to main loop\n*---------------------------------------------------------------------*\n* Call close routine to:                                              *\n* - Close socket.                                                     *\n* - Other cleanup tasks.                                              *\n*---------------------------------------------------------------------*\nRLCLOS   DS    0H\n         CALL  RLCLOS              Call shutdown routine.\n*---------------------------------------------------------------------*\n* Exit - Release storage and return to caller.                        *\n*---------------------------------------------------------------------*\nEXIT     DS    0H\n         BAL   R14,DEACT           Deactivate console.\n         STORAGE RELEASE,LENGTH=RLCOMML,ADDR=(11) Release common strg.\n         LR    R1,R13\n         STORAGE RELEASE,LENGTH=DYNL,ADDR=(1)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*  MSG - WTO a message, and write it to SYSPRINT if open.             *\n*---------------------------------------------------------------------*\nMSG      DS    0H\n         BAKR  R14,0               Save callers environment.\n         MVC   WTOPL,WTOPLM        Set up parm list.\n         LR    R2,R1               Point R2 to msg text passed in R1.\n         WTO   TEXT=(R2),          WTO the message.                    X\n               MF=(E,WTOPL)\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP0             No, branch around.\n         MVC   BUFFER,BLANKS       Clear message buffer.\n         LA    R4,BUFFER           -> buffer.\n         SR    R5,R5               Clear reg.\n         LH    R5,0(R2)            Len of MVCL.\n         LR    R7,R5               Len of MVCL.\n         LA    R8,2(R2)            -> message text.\n         MVCL  R4,R8\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP0  DS    0H\n         PR                        Return to caller.\n*\n*---------------------------------------------------------------------*\n* Write data to SYSPRINT.                                             *\n*---------------------------------------------------------------------*\nPUTLINE  DS    0H\n         BAKR  R14,0               Save callers environment.\n         CLI   SYSPOK,C'Y'         OK to write to SYSPRINT?\n         BNE   NOSYSP1             No, branch around.\n         PUT   GTEXTOUT,BUFFER     Write data to SYSPRINT.\nNOSYSP1  DS    0H\n         PR\n*\n*---------------------------------------------------------------------*\n* Console ALERT processing.  Called by ALERT ECB.                     *\n* Display a message explaining what happened.                         *\n*---------------------------------------------------------------------*\nDOALERT  DS    0H\n         BAKR  R14,0               Save caller's environment.\n         SAC   512                 Go AR mode.\n         SYSSTATE ASCENV=AR        Tell macros the mode.\n         L     R2,CSA              Load address of the status area\n         LAM   R2,R2,CSAALET       Get ALET for status area\n         USING MCSCSA,R2           Addressability\n         MVC   XCSCQSTA,MCSCQSTA   Copy status bytes.\n         SAC   0                   Go Primary mode.\n         SYSSTATE ASCENV=P         Tell macros the mode.\nACSCMLIM DS    0H\n         CLI   MCSCMLIM,1          Memory limit?\n         BZ    ACSCDLIM            No, check next.\n         LA    R1,ZCSCMLIM         -> Msg.\n         BAL   R14,MSG             Display it.\n         B     DOALERT0            Done.\nACSCDLIM DS    0H\n         CLI   MCSCDLIM,1          Queue depth limit?\n         BZ    ACSCINTR            No, check next.\n         LA    R1,ZCSCDLIM         -> Msg.\n         BAL   R14,MSG             Display it.\n         B     DOALERT0            Done.\nACSCINTR DS    0H\n         CLI   MCSCINTR,1          Queue depth limit?\n         BZ    ACSCALRT            No, check next.\n         LA    R1,ZCSCINTR         -> Msg.\n         BAL   R14,MSG             Display it.\n         B     DOALERT0            Done.\nACSCALRT DS    0H\n         CLI   MCSCALRT,1          Queue depth limit?\n         BZ    DOALERT0            No, check next.\n         LA    R1,ZCSCALRT         -> Msg.\n         BAL   R14,MSG             Display it.\nDOALERT0 DS    0H\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n* GETMSGS - This routine is entered when the msg ECB is posted.       *\n* ACSMODE=Primary on entry.                                           *\n* - Issue MCSOPMSG to retrieve MDB.                                   *\n* - Parse the MDB for general, control and text objects.              *\n*---------------------------------------------------------------------*\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\nGETMSGS  DS    0H\n         BAKR  R14,0               Save regs.\nMSGLP    DS    0H                  Top of message loop.\n         ICM   R8,B'1111',CNID     Get console ID.\n         BZ    GETMSGX             Leave if CNID is zeros.\n         SAC   0                   Set primary mode for modeset.\n         MODESET MF=(E,SUP)        Go supervisor mode.\n         SAC     512               Go AR mode for MCSOPMSG.\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\n         MCSOPMSG REQUEST=GETMSG,  Get an MDB.                         X\n               NAME=CNAME,         Specify our console name.           X\n               RTNCODE=RC,         Save retncode here.                 X\n               RSNCODE=RSN,        Save rsn code here.                 X\n               MF=(E,MCSOPMPL)\n         LAE   R8,0(0,R1)          Get MDB address in AR/GPR 8.\n         USING MDB,R8              Addressability to the MDB.\n         SAC   0                   Go primary mode for modeset.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         MODESET MF=(E,PROB)       Go problem mode.\n         SAC   512                 Back to AR mode.\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\n         XC    MDBFLAG,MDBFLAG     Clear my MDB processing flag.\n         CLC   RC,=F'8'            Get MDB successful?\n         BL    MDBOK               Yes, keep going.\nGETMSGX  DS    0H\n         PR\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* MDB was retrieved.  Parse it.  AR/GPR 8 -> MDB.                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nMDBOK    DS    0H\n         LR    R5,R8               -> MDB.\n         AH    R5,MDBLEN           Point to end of MDB.\n         LR    R6,R8               -> MDB.\n         LA    R8,MDBHLEN(R8)      -> first object in MDB.\nOBJLP    DS    0H\n         LH    R3,MDBTYPE          Get MDB object type in reg.\n         C     R3,=A(MDBGOBJ)      Is it GEN type?\n         BNE   NOTGO               No, check for other types.\n         TM    MDBFLAG,MDBFGO      Was GEN object already found?\n         BO    NXTOBJ              Yes, then skip this object.\n         BAL   R14,FNDMDBG         No, process this one as GEN obj.\n         B     NXTOBJ              Now go on to next object.\nNOTGO    DS    0H                  Not GEN - Check next.\n         C     R3,=A(MDBCOBJ)      CTL object?\n         BNE   NOTCO               No, check next.\n         TM    MDBFLAG,MDBFCO      See if already did CTL object.\n         BO    NXTOBJ              Yes, then skip this object.\n         BAL   R14,FNDMDBC         No, process this as the CTL obj.\n         B     NXTOBJ              Go index to next object.\nNOTCO    DS    0H                  Not CTL object.\nNXTOBJ   DS    0H\n         TM    MDBFLAG,MDBFGO+MDBFCO GEN & CTL obects found?\n         BO    FNDTXT             Yes, go find text objects now.\n         AH    R8,MDBLEN          -> next object.\n         CR    R8,R5              Are we past the end of MDB?\n         BL    OBJLP              No, get next object.\n         B     MSGLP              Yes, must be missing objs.  Skip it.\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FNDTXT:   ENTRY VIA BRANCH (NOT A SUBROUTINE)                      *\n*  Function: Process all text objects in all MDBs for this message.   *\n*            Text objects are always ordered, but it cannot be        *\n*            assumed that they are contiguous.                        *\n*  Operation:                                                         *\n*      find end of MDB                                                *\n*      get pointer to next MDB in message                             *\n*      loop through MDBs                                              *\n*         loop through objects                                        *\n*             when text object                                        *\n*               call GOTMDBT to process text object                   *\n*             otherwise ignore object                                 *\n*           skip to next object                                       *\n*             add object length                                       *\n*             if end of MDB, move to next MDB                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nFNDTXT   DS    0H\n         LR    R8,R6               Set R8 back to start of MDB\nTXTLP    DS    0H\n         LR    R5,R8               Calc end of mbd in R5\n         AH    R5,MDBLEN           Start+mdblen in header\n         LAE   R6,0(0,R8)          Calc prefix address in R6\n         SH    R6,=AL2(MDBPLNNO)   Prefix=start-prefix length\n         USING MDBPRFX,R6          Get addressability\n         L     R6,MDBPNEXT         Get forward pointer in R6\n         DROP  R6                  R6 no longer base for prefix\n         LA    R8,MDBHLEN(R8)      Bump to 1st object\nTOBJLP   DS    0H                  Loop through the objects.\n         LH    R3,MDBTYPE          Get MDB type.\n         C     R3,=A(MDBTOBJ)      Check for text object.\n         BNE   NOTTXT              Not text object.\n         BAL   R14,FNDMDBT         Process text object\nNOTTXT   DS    0H\n         AH    R8,MDBLEN           Bump to next object\n         CR    R8,R5               See if this is the end\n         BL    TOBJLP              No, get another object\n         LTR   R6,R6               Check for more MDBs for message\n         BZ    MSGLP               Done with message\n         LR    R8,R6               Next mdb\n         B     TXTLP               Process the mdb\n         DROP  R8\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FNDMDBG:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(general object)      *\n*  Function: process MDB general object                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\nFNDMDBG  DS    0H\n         BAKR  R14,0               Save callers environment.\n         USING MDBG,R8             Addressability to MDB gen object.\n         OI    MDBFLAG,MDBFGO      Set bit saying gen object found.\n         MVC   TIMEMDB,MDBGTIMH    Save timestamp.\n         MVC   DATEMDB,MDBGDSTP    Save date stamp.\n*        SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n*        SAC   0                   Go PRIMARY mode.\n         PR\n         DROP  R8\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FNDMDBC:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(control object)      *\n*  Function: process MDB control object                               *\n*                                                                     *\n*---------------------------------------------------------------------*\nFNDMDBC  DS     0H\n         BAKR  R14,0               Save callers environment.\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\n         USING MDBSCP,R8           Addressability to ctl prog object.\n         CLC   MDBCPNAM,=C'MVS '   Confirm this is an MVS object.\n         BNE   FNDCEX              It's not, so leave now.\n         MVC   JOBNMDB,MDBCOJBN    Save jobname from MDBC.\n         OI    MDBFLAG,MDBFCO      Set flag saying cntl object found.\n         LH    R1,MDBCTOFF2        Get offset to text.\n         ST    R1,TXTOFF           Save for retrieving text.\nFNDCEX   DS    0H\n         PR\n         DROP  R8\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FNDMDBT:  BRANCH ENTERED, ASCMODE=AR, R8=ADDR(text object)         *\n*  Function: process MDB text objects                                 *\n*  Operation:                                                         *\n*      Addressability to text object.                                 *\n*      BAL to routine to select or reject this text record.           *\n*      If accepted, move text to buffer for RLWRITE.                  *\n*      Call RLWRITE to write record as remote log record.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\nFNDMDBT  DS    0H\n         BAKR  R14,0               Save callers environment.\n         SAC   512                 Set AR mode.\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\n         USING MDBT,R8             Addressability to text object.\n         SR    R1,R1               Clear reg.\n         LH    R1,MDBTLEN          Get text object length.\n         S     R1,=A(MDBTMSGT-MDBTLEN) Subtract non-text size.\n         S     R1,TXTOFF           Minus offset to text.\n         C     R1,=A(L'BUFFER2)    Make sure its not too long for buf.\n         BNH   GOTT1               Ok.\n         L     R1,=A(L'BUFFER2)    Not ok, truncate at buf length.\nGOTT1    DS    0H\n         ST    R1,BUFFERL          Store length of data.\n         LA    R4,BUFFER2          -> buffer.\n         LR    R3,R1               length\n         LR    R5,R1               length\n         LAE   R2,MDBTMSGT         Get address of text\n         A     R2,TXTOFF           Bump past prefix info\n         MVCL  R4,R2               Move data from data space.\n         SAC   0                   Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         L     R9,RETRIES          Load number of retries in reg.\nWRITELP  DS    0H\n         CALL  RLWRITE,(BUFFER2,BUFFERL),VL,MF=(E,PARMLST)\n         CLI   CC,X'00'            Write OK?\n         BE    MDBTRTN             Yes, we're done.\n*---\n* Write failed.  Check for a CIB (Modify, stop) and process that\n* if present.  Then wait for RETRYINT, and retry the write.\n* NOTE: Consider changing code to add a wait ECB to the ECB chain,\n* rather than doing the wait here outside the ECB loop.\n*---\n*        BAL   R14,DOCIB\n         BAL   R14,CKSTOP\n         CLI   DONE,1\n         BE    RLCLOS\nWRRETRY  DS    0H\n         STIMER WAIT,DINTVL=RETRYINT Wait for RETRYINT.\n         CLC   ERRNO,=F'0'         Non zero ERRNO?\n         BE    ERRNOZ              No.\n         CALL  RECON\nERRNOZ   DS    0H\n         BCT   R9,WRITELP\n         NC    RETRIES,RETRIES     Is RETRIES=0?\n         BZ    WRITELP             Yes, infinite loop.\nMDBTRTN  DS    0H\n         PR\n         DROP  R8\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* CHKSTOP:                                                            *\n* Check CIB for STOP command.  This routine is called for pieces of   *\n* code that are outside of the main ECB loop.  This means anywhere    *\n* that an STIMER is set to retry a failed operation.                  *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nCKSTOP   DS    0H\n         BAKR  14,0                Save caller's environment.\n         L     R9,COMADDR          -> com area.\n         USING COM,R9              Use R9 as base reg for com area.\n         ICM   R7,B'1111',COMCIBPT Try to get a CIB pointer.\n         BZ    CKSTOP0             No CIB, so don't process.\n         USING CIB,R7              R7 -> CIB\n         CLI   CIBVERB,CIBSTOP     Check for stop CIB\n         BNE   CKSTOP0             If stop command, then stop.\n         MVI   DONE,1              Set flag to done.\nCKSTOP0  DS    0H\n         CLI   CIBVERB,CIBMODFY    Check for modify\n         BNE   CKSTOP00            No, we're done.\n         LH    R3,CIBDATLN         get text length in R3\n         C     R3,=A(5)            Cmd len = 5?\n         BL    NOTRESU0            No, too short.\n         CLC   =C'RESUME',CIBDATA  RESUME command?\n         BNE   NOTRESU0            No, look at next.\n         BAL   R14,RESUMECN        Yes, go do MCSOPMSG RESUME.\nNOTRESU0 DS    0H\nCKSTOP00 DS    0H\n         DROP  R7                  Drop Reg.\n         QEDIT ORIGIN=COMCIBPT,    We're done with this CIB. Free it.  X\n               BLOCK=(R7)\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* Setup:                                                              *\n* Set up storage for macro models.                                    *\n* Set up com area for modify, stop, etc.                              *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nSETUP    DS    0H\n         BAKR  R14,0               Save regs.\n         MVI   DONE,0              Init flag.\n         LA    R2,MACROS           -> MACRO storage. (tgt of MVCL)\n         LA    R3,MACROSL          Get length of move.\n         LA    R5,MACROSL          Get length of move.\n         LA    R4,MACROSM          -> MACRO models. (src of MVCL)\n         MVCL  R2,R4               Populate all MACRO storage.\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* DOCIB: Process CIB when COM ECB is posted.                          *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nDOCIB    DS    0H\n         BAKR  R14,0               Save callers environment.\nCIBLOOP  DS    0H\n         ICM   R7,B'1111',COMCIBPT -> CIB.\n         BNZ   CHEKCIB             If it's there then process it.\n         USING CIB,R7              CIB addressed by R7.\n         PR                        If not, then return to caller.\nCHEKCIB  DS    0H                  Check for STOP command.\n*        WTO   'IN DOCIB - DATA AREAS:'\n         CLI   CIBVERB,CIBSTOP     Check for stop CIB\n         BNE   CKSTART             No, check next.\n         MVI   DONE,1              Flag for done.\n         B     DELCIB              Now delete this CIB.\nCKSTART  DS    0H\n*        CLI   CIBVERB,CIBSTART    Check for start CIB\n*        BNE   CKDATA              CIB not used by this prog\n         CLI   CIBVERB,CIBMODFY    Check for modify\n         BNE   DELCIB              No, we're done.\n         LH    R3,CIBDATLN         get text length in R3\n         C     R3,=A(5)            Cmd len = 5?\n         BL    NOTRESUM            No, too short.\n         CLC   =C'RESUME',CIBDATA  RESUME command?\n         BNE   NOTRESUM            No, look at next.\n         BAL   R14,RESUMECN        Yes, go do MCSOPMSG RESUME.\nNOTRESUM DS    0H\n*        LH    R3,CIBDATLN         get text length in R3\n*        C     R3,=A(L'CMDACT)     check cmd length\nDELCIB   DS    0H\n         QEDIT ORIGIN=COMCIBPT,    We're done with this CIB. Free it.  X\n               BLOCK=(R7)\n         B     CIBLOOP             Check for more CIBs.\n*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* GETCONS - Get MCS console.                                          *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n         SYSSTATE ASCENV=P         Tell macros primary mode\nGETCONS  DS    0H\n         BAKR  R14,0               Save caller's environment.\n         LA      R1,OPERPRM        Build operparm defaults.\n         USING   MCSOPPRM,R1       Map area.\n         XC      OPERPRM(MCSOPLEN),OPERPRM Clear operparm parm list.\n         MVI     MCSOAUTH,MCSOMSTR Set master authority.\n         MVI     MCSORCFL,MCSORCAL All route codes.\n         MVC     MCSOKEY,=C'RLOG    ' Set key.\n         OI      MCSOMISC,MCSOINTY\n         OI      MCSOMSC2,MCSOUNKY\n         OI      MCSOFLAG,MCSOVRDY Override RACF OPERCMDS settings.\n         OI      MCSOMISC,MCSOHDCY Specify hardcopy message set.\n         MVC     MCSOSTOR,SIZEH    Specify data space size (SIZE).\n         MODESET MF=(E,SUP)        Set supv move to activate console.\n         MCSOPER REQUEST=ACTIVATE, Activate the console.               X\n               QRESUME=QRESUMEN,   Resume percentage.                  X\n               ALERTPCT=ALERTPCN,  Alert percentage.                   X\n               QLIMIT=QLIMIT,      Message queue limit.                X\n               NAME=CNAME,         Cons name is in CNAME.              X\n               TERMNAME=CNAME,     Also use CNAME for termname.        X\n               OPERPARM=OPERPRM,   Use my OPERPARMS always, not RACF.  X\n               MSGDLVRY=FIFO,      FIFO message delivery.              X\n               MSGECB=ECBMSG,      ECB to be posted when msg queued.   X\n               ALERTECB=ECBALRT,   ECB to be posted when alert occurs. X\n               MCSCSA=CSA,         Returned status area address.       X\n               MCSCSAA=CSAALET,    Returned status area alet.          X\n               CONSID=CNID,        Returned console id.                X\n               RTNCODE=RC,         Store return code here.             X\n               RSNCODE=RSN,        Store reason code here.             X\n               MF=(E,MCSOPPL)\n         MODESET MF=(E,PROB)       Go back to PROBLEM state.\n         ICM   R15,15,RC           Get return code and set COND.\n         STC   R15,CC              Save return code.\n         BZ    $ACTOK              If non-zero, process error\n*ACTERR  DS    0H\n         LA    R1,ACTBAD           -> Msg.\n         BAL   R14,MSG             Display msg.\n         B     ACTEXIT\n$ACTOK   DS    0H\n         LA    R1,ACTOK            -> Msg.\n         BAL   R14,MSG             Display msg.\nACTEXIT  DS    0H\n         PR                        Return to caller.\nZQRESUME DC    X'20'\nZALERTPC DC    X'30'\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*  DEACT - Deactivate MCS console.                                   -*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nDEACT    DS    0H\n         BAKR  R14,0               Save callers environment.\n         SAC   0                   Set primary mode.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         ICM   R15,B'1111',CNID    Get CNID\n         BNZ   DODEACT             Non-zero, so do deact.\n         B     DACTRTN             Go return to caller.\nDODEACT  DS    0H\n         MODESET MF=(E,SUP)        Go supervisor mode.\n         MCSOPER REQUEST=DEACTIVATE,                                   X\n               NAME=CNAME,         Deactivate the console.             X\n               RTNCODE=RC,         Store return code here.             X\n               RSNCODE=RSN,        Store reason code here.             X\n               MF=(E,MCSOPPL)\n         MODESET MF=(E,PROB)       Go PROBLEM mode.\n         ICM   R15,15,RC           Get RC and set cond.\n         BNZ   DACTERR             Non zero, display error.\n         XC    CNID,CNID           Zero out cnid to indicate inactive.\n         LA    R1,DACTOK           -> deactivated message.\n         BAL   R14,MSG             Display message.\n         PR                        Return to caller.\nDACTERR  DS    0H\n         LA    R1,DACTBAD          Deactivate error.\n         BAL   R14,MSG             Show message.\nDACTRTN  DS    0H\n         MVC   BUFFER,=CL80'DEACT:::'\n         BAL   R14,PUTLINE\n         PR                        Return to caller.\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* RESUME  - Resume message queuing.                                   *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nRESUMECN DS    0H\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         BAKR  R14,0               Save regs.\n         ICM   R8,B'1111',CNID     Get console ID.\n         BZ    RESUME00            Leave if CNID is zeros.\n         SAC   0                   Set primary mode for modeset.\n         LA    R1,MRESUME          -> Msg.\n         BAL   R14,MSG             Display it.\n         MODESET MF=(E,SUP)        Go supervisor mode.\n         SAC     512               Go AR mode for MCSOPMSG.\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\n         MCSOPMSG REQUEST=RESUME,  Get an MDB.                         X\n               NAME=CNAME,         Specify our console name.           X\n               RTNCODE=RC,         Save retncode here.                 X\n               RSNCODE=RSN,        Save rsn code here.                 X\n               MF=(E,MCSOPMPL)\n         SAC   0                   Go primary mode for modeset.\n         SYSSTATE ASCENV=P         Tell macros PRIMARY mode.\n         MODESET MF=(E,PROB)       Go problem mode.\n         SAC   512                 Back to AR mode.\n         SYSSTATE ASCENV=AR        Tell macros AR mode.\nRESUME00 DS    0H\n         PR\n*---------------------------------------------------------------------*\n* MACRO Models.  All models in this section are copied to working     *\n* storage in the section called: Macro Working Storage.  This is to   *\n* enable this program to be reentrant.  The model section is copied   *\n* to working storage by the SETUP subroutine at the startup of this   *\n* program.                                                            *\n*---------------------------------------------------------------------*\n         CNOP  0,4\nMACROSM  DS    0H\n*-\nEXTRACTM EXTRACT MF=L              EXTRACT parameter list.\nEXTRACTL EQU *-EXTRACTM\n*\nSUPM     MODESET MODE=SUP,MF=L     MODESET parm list for sup state\nSUPL     EQU *-SUPM\n*\nSUP0M    MODESET MODE=SUP,                                             X\n               KEY=ZERO,MF=L       MODESET parm list for sup, key 0\nSUP0L    EQU *-SUP0M\nPROBM    MODESET MODE=PROB,                                            X\n               KEY=NZERO,MF=L      MODESET parm list for problem state\nPROBL    EQU *-PROBM\n*-\nWTOPLM   WTO TEXT=,DESC=(7),MF=L   WTO parm list.\nWTOPLL   EQU *-WTOPLM\n*-\nMACROSL  EQU *-MACROSM             Length of all macro models.\n*\n*---------------------------------------------------------------------*\n* Messages (for WTO).\n*---------------------------------------------------------------------*\nSHUTTING DC  AL2(L'MSG0)\nMSG0     DC  C'RLG000I RMTLOG Starting shutdown.'\nNOTACT   DC  AL2(L'MSG2)\nMSG2     DC  C'RLG002I Console not deactivated, was not active.'\nACTOK    DC  AL2(L'MSG3)\nMSG3     DC  C'RLG003I MCS console activated.'\nACTBAD   DC  AL2(L'MSG4)\nMSG4     DC  C'RLG004I MCS Console failed to activate.'\nDACTOK   DC  AL2(L'MSG5)\nMSG5     DC  C'RLG005I MCS Console deactivated.'\nDACTBAD  DC  AL2(L'MSG6)\nMSG6     DC  C'RLG006I MCS Console deactivate failed.'\nMRETRYC  DC  AL2(L'MSG9)\nMSG9     DC  C'RLG009I Waiting for connection to syslog server.'\nMGETERR  DC  AL2(L'MSG10)\nMSG10    DC  C'RLG010I Error processing MDB.'\nRECRDING DC  AL2(L'MSG11)\nMSG11    DC  C'RLG011I RMTLOG is active.'\nMRESUME  DC  AL2(L'MSG12)\nMSG12    DC  C'RLG012I Issuing MCSOPMSG RESUME.'\nMALERT   DC  AL2(L'MSG15)\nMSG15    DC  C'RLG015I                                  '\nZCSCMLIM DC  AL2(L'MSG16)\nMSG16    DC  C'RLG016I Message queueing stopped, memory limit.'\nZCSCDLIM DC  AL2(L'MSG17)\nMSG17    DC  C'RLG017I Message queueing stopped, queue depth reached.'\nZCSCINTR DC  AL2(L'MSG18)\nMSG18    DC  C'RLG018I Message queueing stopped, internal error.'\nZCSCALRT DC  AL2(L'MSG18)\nMSG19    DC  C'RLG019I Message queueing stopped, alert percentage reachX\n               ed.'\nSTARTIN2 DC     AL2(L'MSG20)\nMSG20    DC     C'RLG020I RMTLOG Starting initialization phase 2.'\n*\n         RLCOMM CONST\n*\n*---------------------------------------------------------------------*\n*   Private working storage.\n*---------------------------------------------------------------------*\nDATD     DSECT                     Dynamic area.\nSAVE     DS    18F                 Register save area.  Must be first\n*---\nTIMEDATE DS    4F\nDWORK    DS    D\nWRK      DS    CL8\n* BUFFERL  DS    F                Moved to common DSECT.\nBUFFER2  DS    CL255\nRRR      DS    18F\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*--- ECB List - This is a list of pointers to ECBs. The WAIT macro ---*\n*--- works with all ECBs in this list.                             ---*\n*---------------------------------------------------------------------*\n*---v---v---v---v---v---v---v---v---v---v---v---v---v---v---v---v---v-*\n         CNOP  0,4\nECBS     DS    0CL(ECBLEN)\nAECBMSG  DS    A                   -> ECB for console messages.\nAECBALRT DS    A                   -> ECB for ALERT.\nAECBMOD  DS    A                   -> ECB for MODIFY (STOP,etc).\nECBLEN   EQU   *-AECBMOD\n*---\n*--- ECBs - These are the actual ECBs.\n*---\nECBMSG   DS    F                   ECB for console message.\nECBALRT  DS    F                   ECB for alert.\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*--- End of ECB List and ECBs.                                        *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\nMCSPL    MCSOPER MF=(L,MCSOPPL)   MCSOPER parameter list\nMCSMPL   MCSOPMSG MF=(L,MCSOPMPL),PLISTVER=2 MCSOPMSG Parm List\nRC       DS    F                  Return code.\nRSN      DS    F                  Reason code.\nDONE     DS    C                  Flag - Set to '1' to signify exit.\nCSAALET  DS    F                  ALET (mcscsa)\nCSA      DS    A                  Addr (mcscsa)\nOPERPRM  DS    CL(MCSOPLEN)       OPERPARMs area\nTXTOFF   DS    F                  Offset to text area.\nMDBFLAG  DS    C                  MDB processing flags.\nMDBFGO   EQU   X'01'              Processed MDB general object.\nMDBFCO   EQU   X'02'              Processed MDB control prog object.\nCOMADDR  DS    F                  Addr (comarea) from extract macro.\nXCSCQSTA DS    CL4                Status bytes for ALERTECB\n         ORG   XCSCQSTA\nXCSCMLIM DS    X                  Queuing Stopped by Memory Limit\nXCSCDLIM DS    X                  Queuing Stopped by Queue Depth Lim\nXCSCINTR DS    X                  Queuing Stopped by Internal Error\nXCSCALRT DS    X                  Queuing Reached Alert percentage\n*\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* MACRO working storage.  Each macro in this section should have a\n* corresponding model in the constants section.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         CNOP  0,4\nMACROS   DS    0H\nEXTRACT  DS    CL(EXTRACTL)        EXTRACT parameter list\nSUP      DS    CL(SUPL)            MODESET parm list.\nSUP0     DS    CL(SUP0L)           MODESET parm list.\nPROB     DS    CL(PROBL)           MODESET parm list.\nWTOPL    DS    CL(WTOPLL)          WTO parm list.\n* For dynamically built message.\nMSG15H   DS    AL2                 Fullword work area.\nMSG15W   DS    CL(L'MSG15+30)      Fullword work area.\nMSG15L   EQU   *-MSG15W\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* End of MACROS working storage\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*---------------------------------------------------------------------*\n*   End on doubleword boundary.                                       *\n*---------------------------------------------------------------------*\n         DS    0D\nENDDATD  EQU   *\nDYNL     EQU    *-DATD\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* DSECT mapping macros.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        DCBD    DSORG=QS\n         RLCOMM DSECT              Our common area, mapped by R11.\n         IEAVG132 ,                MDB prefix area.\n         IEAVM105 ,                MDB.\n         IEAVG131 ,                Console status area.\n         IEZVG111 ,                OPERPARM parameter area.\nCOM      DSECT\n         IEZCOM   ,                COM area\nCIB      DSECT\n         IEZCIB   ,                CIB and CIBX\n         END   RMTLOG\n*---------------------------------------------------------------------*\n*   PUNCH the linkedit control statements here.                       *\n*---------------------------------------------------------------------*\n         PUNCH ' SETCODE  AC(1)        '\n         PUNCH ' ENTRY    RMTLOG       '\n         PUNCH ' NAME     RMTLOG(R)    '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMTLOG$": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x10\\x16o\\x01\\x164O\\x18A\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-06-15T00:00:00", "modifydate": "2016-12-09T18:41:50", "lines": 11, "newlines": 11, "modlines": 0, "user": "USER03"}, "text": "//RMTLOG PROC\n//*--------------------------------------------------------------------\n//* RMTLOG - Remote Syslog Task.\n//*--------------------------------------------------------------------\n//* 05/29/2010 John C. Miller.\n//*--------------------------------------------------------------------\n//LOGGER   EXEC PGM=RMTLOG,TIME=1440\n//STEPLIB  DD DISP=SHR,DSN=SYS2.LINKLIB2\n//PARMS    DD DISP=SHR,DSN=SYS1.PARMLIB(RMTLOG00)\n//SYSTCPD  DD DISP=SHR,DSN=SYS2.TCPIP(TCPDATA)\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STR": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00X\\x01\\x10\\x10\\x9f\\x01\\x164O\\x18A\\x00\\x93\\x00,\\x00\\x93\\xe4\\xe2\\xc5\\xd9\\xf0\\xf3@@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2010-04-19T00:00:00", "modifydate": "2016-12-09T18:41:58", "lines": 147, "newlines": 44, "modlines": 147, "user": "USER03"}, "text": "         MACRO\n&NAME    STR   &OPT,&P1,&P2\n.*--------------------------------------------------------------------*\n.* STR - String manipulation functions.\n.*--------------------------------------------------------------------*\n.* 04/19/2010 John C. Miller\n.*--------------------------------------------------------------------*\n.* Overview: On the first invocation of a particular option, the code\n.* needed for that option is inserted in-line, immediately preceeded by\n.* a branch around the code.  This enables the code to be called as a\n.* subroutine.  The code is only generated once, and subsequent calls\n.* to the same function involve only setting up parms and BAL to the\n.* previously embedded in-line code.\n.*--------------------------------------------------------------------*\n.* Invocation options:\n.*\n.* RJUST FLD,Length - Right justify the field FLD. The length of the\n.* field operated on is determined by the LEN parameter. If LEN is\n.* omitted, the length attribute of the FIELD variable is used, if it\n.* is present.\n.*\n.* LEN FLD,Length - Calculate the length of field FLD, assuming it\n.* is right justified, and padded with blanks (X'40').  If not padded\n.* with blanks, the length returned will equal the length coded in the\n.* macro.\n.*--------------------------------------------------------------------*\n         LCLC  &G\n&G       SETC  '@ST'.'&SYSNDX'\n         AIF ('&OPT' EQ 'RJUST').RJUST\n         AIF ('&OPT' EQ 'LJUST').LJUST\n         AIF ('&OPT' EQ 'LENGTH').LENG\n         AIF ('&OPT' EQ 'LENG').LENG\n         AIF ('&OPT' EQ 'LEN').LENG\n         LCLC &TY\n&TY      SETC T'&P1\n         MNOTE 9,'P1: &TY'\n&TY      SETC T'&P1\n         MNOTE 9,'P2: &TY'\n         AGO .DONE\n.*--------------------------------------------------------------------*\n.* Code for LENG - Calculate length.\n.*--------------------------------------------------------------------*\n.LENG    ANOP\n         LCLC  &FIELD\n         LCLA  &LEN\n&FIELD   SETC  '&P1'                    Set field to first parm.\n&LEN     SETA  &P2\n         AIF (T'@@@@LN EQ 'H').LENG0  Only define code once.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* STR: LENG. Get length of a space padded field.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* LEN - Get length of a blank terminated field.\n* ENTRY:\n*    R0 - Maximum length of string.\n*    R1 - Points to start of string.\n* EXIT:\n*    R1 - Length of string.\n*---------------------------------------------------------------------*\n         B     &G.B                Branch around code.\n@@@@LN   DS    0H\n         BAKR  14,0                Save caller's environment.\n         SR    15,15\n@@@@LN00 DS    0H\n         CLI   0(1),C' '           Blank?\n         BE    @@@@LN01            Yes, Return with len in R15.\n         LA    1,1(1)              Bump over 1.\n         LA    15,1(15)            Bump over 1.\n         CR    15,0                End of search yet?\n         BL    @@@@LN00            No, keep looking.\n@@@@LN01 DS    0H\n         LR    1,15                Load length in R1\n         PR                        Return to caller.\n&G.B     DS  0H\n.LENG0   ANOP\n         LA    0,&LEN              Get length of field.\n         LA    1,&FIELD            Point to field to justify.\n         BAL   14,@@@@LN           BAL to RJUST routine.\n         AGO .DONE\n.*\n.*--------------------------------------------------------------------*\n.* Code for RJUST - Right Justify.\n.*--------------------------------------------------------------------*\n.RJUST   ANOP\n         LCLC  &FIELD\n         LCLA  &LEN\n&FIELD   SETC  '&P1'                    Set field to first parm.\n&LEN     SETA  &P2\n         AIF (T'@@@@RJ EQ 'H').RJUST0  Only define code once.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* STR: RJUST.  Right justify a text field.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*---------------------------------------------------------------------*\n* RJUST - Right justify a space padded text field.\n* - R0 - Length of field.\n* - R1 - Pointer to field.\n*---------------------------------------------------------------------*\n* - R2 - Pointer to start.      |     2 34\n* - R3 - Point to end of data.  |     | ||\n* - R4 - Point to end of field. |     v vv\n* - R8 - Length of data.        |   C'123.'\n* - R9 - Save length of data.   |     ___\n*                               |      8\n*---------------------------------------------------------------------*\n         B     &G.A                  Branch around code.\n@@@@RJ   DS    0H\n         BAKR  14,0                Save caller's environment.\n         LR    R2,R1               -> field.\n         LR    R4,R0               Load length of field.\n         AR    R4,R1               -> end of field.\n         BCTR  R4,0                Back up one.\n         LR    R3,R4               Index register.\n         CLI   0(R3),C' '          Already right justified?\n         BNE   @@@@RJ99            Yes, we're done.\n@@@@RJ04 DS    0H\n         CLI   0(R3),C' '          Last char a space?\n         BNE   @@@@RJ03            Yes, end of text found.\n         CR    R3,R2               Entire field scanned?\n         BE    @@@@RJ99            Yes, leave.\n         BCT   R3,@@@@RJ04         Back up one and go top of loop.\n@@@@RJ03 DS    0H\n         LR    R8,R3               -> end of data.\n         SR    R8,R2               Calc length of data.\n         LA    R8,1(R8)            Add 1.\n         LR    R9,R4               -> end of field.\n         SR    R9,R3               Subtract to get length of pad.\n@@@@RJ10 DS    0H\n         MVC   0(1,R4),0(R3)       Move rightmost char.\n         BCTR  R3,0                Back up one.\n         BCTR  R4,0                Back up one.\n         BCT   R8,@@@@RJ10         Decrement leng, go top of loop.\n         LR    R3,R9               Get length for MVCL.\n         SR    R9,R9               Clear length reg to zeros for pad.\n         ICM   R9,B'1000',=C' '    Insert pad char.\n         MVCL  R2,R8               Set leading chars to pad.\n@@@@RJ99 DS    0H\n         PR\n         PR\n&G.A     DS  0H\n.RJUST0  ANOP\n         LA    0,&LEN               Get length of field.\n         LA    1,&FIELD             Point to field to justify.\n         BAL   14,@@@@RJ            BAL to RJUST routine.\n         AGO .DONE\n.DONE    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT955/FILE955.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT955", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}