{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012657000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE729.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE729.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\n'", "DS1TRBAL": "b'Z\\x94'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xfc\\x00\\x07\\x04\\xfc\\x00\\x0c\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x051O\\x01\\x051O\\t7\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-10T00:00:00", "modifydate": "2005-11-10T09:37:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-470"}, "text": "REGULAR CBT TAPE - VERSION 470    FILE:  729\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE729\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,053 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/10/05    09:37:18    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x051/\\x01\\x051O\\t5\\x01\"\\x01\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-11-08T00:00:00", "modifydate": "2005-11-10T09:35:24", "lines": 290, "newlines": 276, "modlines": 0, "user": "SBGOLOB"}, "text": "The MAXITRAN EXEC was created to support file transfer between\nthe MAXIMO server and the MVS server.  It can be also be used by\nother applications for scripted file transfer between MVS and an\nFTP server, such as Windows.\n\nNarrative\nMAXITRAN currently uses FTP for file transfer.\nThe program operates as follows:\n\nMessages from MAXITRAN are written to:\nThe SYSTSPRT dataset.\nThe LOG dataset, if present in the JCL.\nEmail messages sent as a result of EMAIL keywords.\n\nAll SYSIN control cards are read. If any keywords are\nunrecognized, execution terminates.\n\nGETMASK request are translated to individual GET requests.\n\nAll FILEEXISTS statements are executed. If any FILEEXISTS file\nnot found, RC 4 is set and MAXITRAN execution terminates.\n\nIf any GET requests; If a getlock is specified (see GETLOCK\nkeyword below) test for the presence of the lock file  on the\nserver GETDIR.  If the lock is found, execution terminates.\n\nAll GET requests are executed. If any GET fails, execution\nterminates\n\nIf keyword GETDELETE=YES (defaut) then all files that were GET\nare deleted from the server directory.\n\nIf any PUT requests; If a putlock is specified (see PUTLOCK\nkeyword below) test for the presence of the lock file  on the\nserver PUTDIR.  If the lock is found, execution terminates. Note\nthat the default for PUTLOCK is blank, that is the PUTDIR will be\nconsidered locked if it has any files.\n\nAll PUT requests are executed. If any PUT fails, execution\nterminates.\n\nJCL\nTo execute MAXITRAN, use the following JCL:\n//T1      EXEC MAXITRAN\n//LOG      DD  DSN=log.file,DISP=MOD  Optional log file\n//SYSIN    DD  *\n\nMessages will be printed to ddname SYSTSPRT which is included in\nthe MAXITRAN PROC.\n\nDDname LOG is an optional sequential file to accumulate a copy of\nmessages from MAXITRAN.\n\nMAXITRAN is controlled by commands in the SYSIN dataset. All\nSYSIN cards are processed  before any transfers take place.\nExcept for GET and PUT, each keyword should appear no more than\nonce.\n\nCards may be continued by ending a parameter with \",\" and\ncontinuing the parameter on the next card.\n\nAn '*' in column 1 of any SYSIN card indicates a comment.\n\n\n\nSample MAXITRAN Job\n\n//T1      EXEC MAXITRAN\n//LOG      DD  DSN=WTS03.MAXILOG,DISP=MOD\n//SYSIN    DD  *\nSERVER UPIFILE1\nPUTDIR MAXIMO-IN\nGETDIR MAXIMO-OUT\nEMAIL-ON-ERROR ROB@USSPOSCO.COM\nLOCSITE TRACKS PRIMARY=1 SECONDARY=2 LRECL=200 RECFM=VB BLKSIZE=0\nGET PO.TXT WTS03.XS1.MAXOUT.PO(+1)\nGET INV.TXT WTS03.XS1.MAXOUT.INV(+1) LOCSITE LRECL=80 RECFM=FB\nPUT WTS03.XS1.MAXIN.PO(0) PO.TXT\nPUT WTS03.XS1.MAXIN.INV(0) INV.TXT\n\n\n\n\nAll SYSIN statements should begin in column 1 of the record and\nmay extend to the end of the record.  Statements may be continued\nto a new record by ending the statement with a comma. Column 1 of\nthe continuation record will be overlayed at the position of the\ncomma.\n\nAn \"*\" in column 1 indicates a comment card.\n\nSYSIN Keywords:\n\nEMAIL-ON-ERROR address ...\nOptional. Default: none\nEmail address(es) to send error reports to if MAXITRAN ends with\nRC greater than 4. Addresses should be of the form\n\"name@domain.com\".\n\nEMAIL-ON-SUCCESS address ...\nOptional. Default: none\nEmail address(es) to send error reports to if MAXITRAN ends\nnormally. Addresses should be of the form \"name@domain.com\".\n\nFILEEXISTS dir/serverfile\nOptional. Default: none\nFILEEXISTS tests for the existence of serverfile in directory\ndir. If the file is found, RC 0 is set. If the file is not found,\nRC 4 is set.\ndir is relative to the server FTP directory.\nserverfile may be a complete filename or a mask (*.*).\nNote: Filenames are case sensitive.\n\nGET serverfile mvsfile  locsitestmt  (REPLACE |  (APPEND\nOptional. Default: none\nserverfile is the file on the server to be transferred to\nmvsfile. The full pathname ofserverfile is the value of GETDIR\n(if specified) + serverfile.\nlocsitstmt are optional allocation parms (see locsite keyword) to\nuse for this GET request.\n(REPLACE indicates the mvsfile should be replaced if it already\nexists.\n(APPEND indicates data should be added to the end (DISP=MOD) of\nmvsfile if mvsfile already exists.\nmvsfile will be created if it does not exist.\nThe (APPEND and (REPLACE parameters are mutually exclusive. They\nmay not appear together on the same statement.\n\nGETMASK serverfileMask rexxExpression locsitestmt  (REPLACE | (APPEND\nOptional. Default: none\nserverfileMask is the file on the server to be transferred to\nMVS. Multiple files may be represented by wildcards.\nservefileMask  is case sensitive.\nThe full pathname of serverfileMask is the value of GETDIR (if\nspecified) + serverfileMask.\nrexxExpression is an expression in the rexx language that will be\nexecuted to create the MVS target filename. The variable name\nsfile may be used in this expression to represent the name of the\nsource file. The expression may not contain any embedded spaces.\nThe result of the expression will always be translated to upper\ncase to satisfy MVS dsname requirements.\n\nrexxExpression may also contain MAXITRAN special REXX functions\nas documented in the section \"Special REXX Functions\".\n\nSee the GET statement for an explanation of the locsitestmt,\n(REPLACE and (APPEND parameters.\n\nExample GETMASK:\nGETMASK *.txt 'UPZZ.XS1.TRAN.'substr(sfile,2,3)'.DATA'\n\nFor a directory that contains these files:\narnold.txt\nabcdefghijk.txt\n\nThe following GETs would be executed:\nGET arnold.txt UPZZ.XS1.TRAN.RNO.DATA\nGET abcdefghijk.txt UPZZ.XS1.TRAN.BCD.DATA\n\n\nGETDIR dir\nOptional. Default: null - the server FTP default directory will\nbe used.\nName of server directory where files will be transferred from\n(GET).\n\nGETDELETE YES | NO\nOptional. Default: YES\nYES indicates that serverfiles should be deleted after the GET is\ncompleted. NO indicates serverfiles should not be deleted.\n\nGETLOCK file-mask |  NO\nOptional. Default: *.lck - file-mask specifies a filename on the\nserver. Wildcards may be used. The presence of this filename in\nthe GETDIR will be taken to mean that the server is locked and no\nGETs will be executed.  NO indicates MAXITRAN should bypass lock\nchecking for the GETDIR.\n\n\nLOCSITE allocparms\nOptional. Default: none\nParameters to use for allocating new target datasets on MVS for a\nGET request. Any keyword supported by the FTP LOCSITE subcommand\nis supported. See TCPIP users guide for details.\n\nSome common LOCSITE keywords:\nTRACKS      - allocate dataset in tracks\nCYLINDERS   - allocate dataset  in cylinders\nPRIMARY n   - primary space allocation amount\nSECONDARY n - secondary space allocation amount\nRECFM  xx   - record format - VB, FB, etc\nLRECL  nn   - logical record length\n\n\nPUT mvsfile  serverfile\nOptional. Default: none\nmvsfile is the file to be transferred to serverfile.\n\n\nPUTMASK mvsfileMask rexxExpression\nOptional. Default: none\nmvsfileMask is the MVS file to be transferred to the server.\nMultiple files may be represented by wildcards.\n\nrexxExpression is an optional expression in the rexx language\nthat will be executed to create the server target filename. The\nvariable name sfile may be used in this expression to represent\nthe name of the source file. The expression may not contain any\nembedded spaces.\n\nrexxExpression may also contain MAXITRAN special REXX functions\nas documented in the section \"Special REXX Functions\".\n\nExample PUTMASK:\nPUTMASK UPZZ.XS1.TRAN.* 'coils.'substr(sfile,15,7)'.data'\n\nFor these MVS files:\nUPZZ.XS1.TRAN.G0001V00\nUPZZ.XS1.TRAN.G0002V00\n\n\nThe following PUTs would be executed:\nPUT UPZZ.XS1.TRAN.G0001V00 coils.G0001V00.data\nPUT UPZZ.XS1.TRAN.G0002V00 coils.G0002V00.data\n\n\nPUTDIR dir\nOptional. Default: null - the server FTP default directory will\nbe used.  Name of server directory where files will be\ntransferred to (PUT).\n\nPUTLOCK file-mask |  NO\nOptional. Default: null - file-mask specifies a filename on the\nserver. Wildcards may be used. The presence of this filename in\nthe PUTDIR will be taken to mean that the server is locked and no\nPUTs will be executed. Note that the default of null means that\nPUTs will only be executed if the target directory is empty.  NO\nindicates MAXITRAN should bypass lock checking for he PUTDIR.\n\n\nSERVER servername\nRequired. Default: none.\nName of the server which MVS will exchange files with.\n\n\n\nReturn Codes\n\n4:\nFILEEXISTS file not found\n\n8:\nFTP logic error\n\n12:\nUnable to obtain lock\nUnable to contact server\nGETDIR/PUTDIR invalid directory\n\n20:\nSYSIN syntax error\n\n\n\nSpecial REXX functions\nThe following functions are special to MAXITRAN and may be used\nin as part of  rexxExpression in a GETMASK or PUTMASK statement:\n\ncounter()  represents a 4 digit counter value that is incremented\neach time it is used bt GETMASK/PUTMASK to generate a GET/PUT\nstatement. The first call returns \"0001\".\n\nhhmmss()  returns the current hours, minutes, seconds value. For\nexample: 142733.\n\nyyyymmdd()  returns the year, month, date value. For\nexample: 20041029.\n\ngdsversion(sfile)  returns the G0000V00 portion of the name from\nsfile.\n\ntoken(sfile,num,delim,maxLength) returns the num token from sfile\nwhere delim seperates the tokens. The first token is num 1. The\ntoken is truncated to maxlength before it is returned.\n\nExamples:\n token('abcd.txt',1,'.',8)  returns => \"abcd\"\n token('somelongname.tuesday.data',1,'.',8) returns => \"somelong\"\n token('somelongname.tuesday.data',1,'.') returns => \"tuesday\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MSWDOC": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x051O\\x01\\x051O\\t#\\x02@\\x02@\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-10T00:00:00", "modifydate": "2005-11-10T09:23:00", "lines": 576, "newlines": 576, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "$README": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x16\\x01\\x02\\x11?\\x01\\x051O\\x05F\\x00\\x1d\\x00\\x10\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-04-23T00:00:00", "modifydate": "2005-11-10T05:46:16", "lines": 29, "newlines": 16, "modlines": 0, "user": "WTS03"}, "text": "Member $MSWDOC contains an MS Word version of the user guide.\nBinary download this member to your PC with a *.doc extension.\n\nThe MAXITRAN exec is used to script batch FTP between an MVS client\nand another FTP server. It provides functions such as delete of\nsource files after GET (delete is the default!). Read the doc\n\"maxitran.doc\" for complete documentation.\n\nThis software is distributed into the public domain \"as-is\" by\nRob Wunderlich (RobWunderlich@ussposco.com).\n\nTo execute maxitran, copy the member \"PROC\" to a proclib (or JCLLIB)\nas member \"MAXITRAN\". Update the SYSPROC DD stmt to point to this PDS.\n\nCustomizations required before you use this at your site:\n-- Member MAXITRAN --\n1)The shipped default is \"GETDELETE YES\" which means files will\nbe deleted from the server after a sucessfull GET. If you want to\nchange the default for your shop, change the line\n  flagGetDelete=1\nto\n  flagGetDelete=0\n\n2)If you use the email feature, you might want to\nupdate subroutine \"sendmail\" to use \"HELO\" and \"FROM\" values that\nare meaningful for your site.\n\nThe email email routine expects that you have an MVS SMTP server\nset up named \"SMTP\" that services output class B.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE729": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x051O\\x01\\x051O\\t7\\x00*\\x00*\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-10T00:00:00", "modifydate": "2005-11-10T09:37:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CBT-470"}, "text": "//***FILE 729 is from Rob Wunderlich and contains his MAXITRAN      *   FILE 729\n//*           REXX that helps to run batch FTP between an MVS       *   FILE 729\n//*           client and another FTP server.                        *   FILE 729\n//*                                                                 *   FILE 729\n//*           email:  RobWunderlich@ussposco.com                    *   FILE 729\n//*                                                                 *   FILE 729\n//*     Description:                                                *   FILE 729\n//*                                                                 *   FILE 729\n//*     The MAXITRAN exec is used to script batch FTP between       *   FILE 729\n//*     an MVS client and another FTP server.  It provides          *   FILE 729\n//*     functions such as delete of source files after GET          *   FILE 729\n//*     (delete is the default!).  Read the doc \"maxitran.doc\"      *   FILE 729\n//*     for complete documentation.  (MSWORD format member          *   FILE 729\n//*     MAXITRA@).                                                  *   FILE 729\n//*                                                                 *   FILE 729\n//*     This software is distributed into the public domain         *   FILE 729\n//*     \"as-is\" by Rob Wunderlich.                                  *   FILE 729\n//*                                                                 *   FILE 729\n//*     To execute maxitran, copy the member \"PROC\" to a            *   FILE 729\n//*     proclib (or JCLLIB) as member \"MAXITRAN\".  Update the       *   FILE 729\n//*     SYSPROC DD stmt to point to this PDS.                       *   FILE 729\n//*                                                                 *   FILE 729\n//*     Customizations required before you use this at your         *   FILE 729\n//*     site:                                                       *   FILE 729\n//*                                                                 *   FILE 729\n//*     -- Member MAXITRAN --                                       *   FILE 729\n//*     1)The shipped default is \"GETDELETE YES\" which means        *   FILE 729\n//*     files will be deleted from the server after a               *   FILE 729\n//*     sucessfull GET.  If you want to change the default for      *   FILE 729\n//*     your shop, change the line                                  *   FILE 729\n//*       flagGetDelete=1                                           *   FILE 729\n//*     to                                                          *   FILE 729\n//*       flagGetDelete=0                                           *   FILE 729\n//*                                                                 *   FILE 729\n//*     2)If you use the email feature, you might want to           *   FILE 729\n//*     update subroutine \"sendmail\" to use \"HELO\" and \"FROM\"       *   FILE 729\n//*     values that are meaningful for your site.                   *   FILE 729\n//*                                                                 *   FILE 729\n//*     The email routine expects that you have an MVS              *   FILE 729\n//*     SMTP server set up named \"SMTP\" that services output        *   FILE 729\n//*     class B.                                                    *   FILE 729\n//*                                                                 *   FILE 729\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTPDIR": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x05\\x00\\x99\\x14\\x1f\\x01\\x05)\\x7f\\t\\x12\\x00o\\x00N\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1999-05-21T00:00:00", "modifydate": "2005-10-24T09:12:05", "lines": 111, "newlines": 78, "modlines": 0, "user": "WTS03"}, "text": "/* rexx */\n/**********************************************************************/\n/* Function: FTP List DIR entries.                                    */\n/* parms: server dir                                                  */\n/* Returns:  FTP return code                                          */\n/*           Count of files found in dir                              */\n/*           File msg lines - each begins with 'EZA2284I'             */\n/*                                                                    */\n/* RBW 5/99                                                           */\n/**********************************************************************/\n/*    *    *    *    Establish Error Traps    *    *    *    *    *   */\ncall on error name errproc\nsignal on syntax name errproc\nsignal on novalue name errproc\n/*    *    *    *    *    *    *    *    *    *    *    *    *    *   */\n\nserver = arg(1)\ndir = arg(2)\nupper server                      /* Upcase server name */\n\n\n\naddress tso\nok=0;\"PROFILE MSGID\"                   /* Set MSGIDs on */\n/* Alloc FTP command and msg datasets */\nok='0 4';\"ALLOC  FI(INPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\nok='0 4';\"ALLOC  FI(OUTPUT) NEW DELETE REUSE\" ,\n         \"LRECL(137) RECFM(V B) UNIT(VIO)\"\n\n /* Queue up the FTP commands */\nok=0;\"NEWSTACK\"                       /* Get a clean stack */\n queue 'LIST' dir\n queue 'QUIT'\n queue ''\nok=0;\"EXECIO * DISKW INPUT (FINIS\"     /* Write FTP commands to file */\nok=0;\"DELSTACK\"                        /* Delete the stack */\n\n/**********************************************************************/\n/* Invoke FTP                                                         */\n/**********************************************************************/\nok='*';\"FTP\" server '(EXIT'              /* Invoke FTP */\nftprc = rc                        /* Save off return code */\n\"FREE FI(INPUT)\"                  /* Free the command file */\n\n/* Read the input messages into stem */\nok=0;\"EXECIO * DISKR OUTPUT (STEM FTPMSG. FINIS\"\nok=0;\"FREE FI(OUTPUT)\"            /* Free the output file */\n\n/**********************************************************************/\n/* If non-zero return from FTP, ecit now with RC                      */\n/**********************************************************************/\nif wordpos(ftprc,'0 14550') = 0   /* If error from FTP, */\n  then return ftprc '0'    /* Return error code and count */\nif ftprc = 14550       /* If file not found, */\n  then return '0 0'    /* Return rc=0 and count=0 */\n\n/**********************************************************************/\n/* Zero RC from FTP. Process the msg file                             */\n/**********************************************************************/\n/* Put all the messages into one var for parse */\nbigmsg =''\ndo i = 1 to ftpmsg.0\n  bigmsg = bigmsg strip(ftpmsg.i,'B')\nend\n\n/* Get segment of msgs we're interested in */\nstart_msg = '150 Opening ASCII mode data connection for /bin/ls.'\nend_msg = '226 Transfer complete.'\nparse var bigmsg (start_msg) filemsgs (end_msg) .\n/* Count the EZA2284I messages */\nfilecount = 0; idx = 1; str = 'EZA2284I'\ndo while wordpos(str,filemsgs,idx) > 0\n   filecount = filecount + 1\n   idx = wordpos(str,filemsgs,idx) + 1\nend\n\n\n/** Return return code, count if files found, and msg line for each\n    file */\nreturn ftprc filecount filemsgs\n\n\n\n/*********************************************************************/\n/**   Cleanup after error                                           **/\n/*********************************************************************/\ncleanup_after_error:\naddress tso free fi(INPUT)\naddress tso free fi(OUTPUT)\nexit\n/*********************************************************************/\n/**   standard error handling routine                               **/\n/*********************************************************************/\nerrproc:\nif condition('c') = 'ERROR' & symbol('OK') = 'VAR'\n  then if wordpos(rc,ok) > 0 | ok = '*' then return;   /* Not an error*/\n/* Cancel error traps to prevent recursion */\nsignal off syntax\nsignal off novalue\ncall off error\n/* error presentation code */\nerror_type = condition('c')\nsay error_type 'at line' sigl ':' condition('d')\nif error_type = 'SYNTAX'\n  then say errortext(rc)\nif error_type = 'ERROR' & symbol('zerrlm') = 'VAR'\n  then say zerrlm\nif error_type = 'ERROR'\n  then say 'Return code = ' rc\ncall cleanup_after_error\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETJOBN": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x00\\x99\\x15o\\x00\\x99\\x15o\\x121\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-05T00:00:00", "modifydate": "1999-06-05T12:31:40", "lines": 12, "newlines": 12, "modlines": 0, "user": "WTS03"}, "text": "/* rexx */\n/**********************************************************************/\n/* Function: Return current jobname                                   */\n/* RBW 6/99                                                           */\n/**********************************************************************/\ncvt = 17                          /* cvt address */\ncvt@     = c2d(storage(d2x(cvt),3))  /* get CVT address */\ncvttcbp  = c2d(storage(d2x(cvt@ + 0), 4))     /* TCB words addr */\ncurrtcb  = c2d(storage(d2x(cvttcbp + 4), 4))  /* Current TCB addr */\ntiot@    = c2d(storage(d2x(currtcb + 12), 4)) /* TIOT addr */\njobname  = storage(d2x(tiot@),8)               /* Get jobname */\nreturn jobname\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAXITRAN": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01M\\x00#\\x00\\x99\\x13\\x7f\\x01\\x05)O\\x17 \\x03\\xb0\\x00X\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3@@@@@'", "ispf": {"version": "01.77", "flags": 0, "createdate": "1999-05-17T00:00:00", "modifydate": "2005-10-21T17:20:23", "lines": 944, "newlines": 88, "modlines": 0, "user": "WTS03"}, "text": "/* rexx */\n/**********************************************************************/\n/* GET/PUT files from/to a FTP server.                                */\n/* Written: 1998 Rob Wunderlich                                       */\n/* Created to transfer files between MVS and MAXIMO server.           */\n/* See Lotus Notes \"Plant Systems Knowledge Base\" for doc.            */\n/*                                                                    */\n/* Changes:                                                           */\n/* 10/21/2005 RBW. Replaced server password lookup with NETRC.        */\n/*                 Added TOKEN function.                              */\n/*                                                                    */\n/**********************************************************************/\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n/*    *    *    *    Establish Error Traps    *    *    *    *    *   */\ncall on error name errproc\nsignal on syntax name errproc\nsignal on novalue name errproc\n/*    *    *    *    *    *    *    *    *    *    *    *    *    *   */\n\n/* Init variables */\nmaxrc = 0\nlogmsg.0 = 0                      /* Count of stacked messages*/\nlogmsg.jobname = getjobn()        /* This jobname */\ncounter.=0;                      /* sequence counter used in rexepr*/\n/* Check if logfile allocated */\nif listdsi(\"LOG FILE\") = 16 & sysreason = 2\n  then logmsg.alloc = 0\n  else logmsg.alloc = 1\n\ncall logmsg 'MAXITRAN V1.6.2 Started'\n\n/* Variables to be set by keyword input at sysin */\nserver =''\nemail_on_error_list = ''\nemail_on_success_list = ''\nput.=''; putidx=0                 /* List of files to PUT */\nget.=''; getidx=0                 /* List of files to GET */\ngetmask.=''; getmaskidx=0         /* List of files to GET with mask */\nputmask.=''; putmaskidx=0         /* List of files to PUT with mask */\nlocsite = ''                      /* LOCSITE parms */\nfileexists.=''; feidx=0           /* List of FileExists to check */\ngetLockMask='/*.lck'              /* Default lock mask for GET */\nputLockMask=''                    /* Default lock mask for PUT */\nflagGetDelete=1                   /* Delete files after GET */\nflagUseGetLock=1                  /* Default is use getlock */\nflagUsePutLock=1                  /* Default is use putlock */\ndebug=0                           /* Debug off */\n\n/* Process parm string */\narg $parm\ndo i = 1 to words($parm)\n  select\n    when abbrev('DEBUG',word($parm,i),3)\n     then debug=1\n    otherwise do\n      call logmsg 'Error - Unknown parm \"' || word($parm,i) || '\"'\n      exit 24\n    end\n  end\nend\n\n/* * * * * * * Main routine * * * * * * */\n\n\n/* Read and process control cards */\n\ncall read_control_cards\nif maxrc > 0                      /* If control card errors, */\n  then signal main_exit           /*  then exit now */\n\ncall display_parms            /* Display the parms that we will use */\n\n/* Convert all GETMASK requests to GETs */\nif getmaskidx > 0                 /* If any GETMASK to do, */\nthen do\n  call convert_getmask\nend\nif maxrc > 0                           /* If not rc 0, */\n  then signal main_exit                /*  then exit with error */\n\n/* Convert all PUTMASK requests to PUTs */\nif putmaskidx > 0                 /* If any GETMASK to do, */\nthen do\n  call convert_putmask\nend\nif maxrc > 0                           /* If not rc 0, */\n  then signal main_exit                /*  then exit with error */\n\n/* Perform all FILEEXISTS */\nif feidx > 0\nthen do i = 1 to feidx\n  maxrc = max(maxrc, check_fileexists(server, fileexists.i))\nend\nif maxrc > 0                           /* If not rc 0, */\n  then signal main_exit                /*  then exit with error */\n\n/* Perform all GETS */\nif getidx > 0                     /* If any GETs to do, */\nthen do\n  if flagUseGetLock\n  then do\n    if \\test_lock(server,get.dir,getLockMask)  /* Try for lock */\n    then do                         /* Couldn't get lock */\n      call logmsg 'Error-Unable to obtain lock for GET, dir' get.dir\n      maxrc = max(maxrc,12)\n      signal main_exit                /* Exit with error */\n    end\n  end\n\n  call get_files           /* Lock successful or not used */\n\n  if maxrc = 0 & flagGetDelete           /* If get_files was ok, */\n    then call delete_get_files           /*  then go delete the files*/\n  if maxrc > 0                           /* If not rc 0, */\n    then signal main_exit                /*  then exit with error */\n\nend\n\n\n/* Perform all PUTS */\nif putidx > 0                     /* If any PUTs to do, */\nthen do\n  if flagUsePutLock\n  then do\n    if \\test_lock(server,put.dir,putLockMask)  /* Try for lock */\n    then do                         /* Couldn't get lock */\n      call logmsg 'Error-Unable to obtain lock for PUT, dir' put.dir\n      maxrc = max(maxrc,12)\n      signal main_exit                /* Exit with error */\n    end\n  end\n\n  call put_files           /* Lock successful or not used */\nend\n\nmain_exit:\ncall logmsg 'Ending with Rc' maxrc\n\nif maxrc = 0 & email_on_success_list \\= ''\n  then call sendmail email_on_success_list ',' ,\n            logmsg.jobname 'MAXITRAN ended normally'\n\nif maxrc > 4 & email_on_error_list \\= ''\n  then call sendmail email_on_error_list ',' ,\n            logmsg.jobname 'MAXITRAN ended with ERROR'\n\nexit maxrc                        /*  EXIT for main routine */\n\n\n\n\n/**********************************************************************/\n/* Sub: Convert GETMASK request to GETs                               */\n/* Adds GET requests to the get. var                                  */\n/**********************************************************************/\nconvert_getmask:\ndo i = 1 to getmaskidx\ncall logmsg 'Getmask conversion for: ' getmask.i\n  parse var getmask.i src rxexpr ftpparms   /* Parse next GETMASK */\n\n  parse value ftpdir(server,get.dir || '\\' || src) with ,\n    ftprc count filelist      /* Get files that match mask */\n  if ftprc = 0\n  then do j= 1 to count                    /* Do for each file */\n    parse var filelist 'EZA2284I' . . . sfile filelist\n    sfile = strip(sfile,'B')\n\n    /* Form target file name by applying expression from SYSIN stmt */\n    interpret 'tfile=' rxexpr\n    upper tfile                   /* Insure name is upper case */\n\n    getidx = getidx + 1           /* Increment GET count */\n    get.getidx = sfile tfile ftpparms  /* Save as a GET request */\n    call logmsg '-- Generated stmt: GET' get.getidx\n  end\n  else do\n    call logmsg 'Error - Unable to access server \"'server'\"',\n                'dir \"'src'\" rc='ftprc\n    maxrc = max(maxrc, 12)     /* Set RC 12 */\n  end\n\nend\n\nreturn\n\n\n/**********************************************************************/\n/* Sub: Convert PUTMASK request to PUTs                               */\n/* Adds PUT requests to the put. var                                  */\n/**********************************************************************/\nconvert_putmask:\ntrace ?r\ndo i = 1 to putmaskidx\n  call logmsg 'Putmask conversion for: ' putmask.i\n  /* getmask rxexpr does not allow imbedded spaces. */\n  /* Enforce same restriction here for compatability  */\n  parse var putmask.i src rxexpr rest /* Parse next PUTMASK */\n\n  if rest <> ''\n  then do\n    call logmsg '-- Invalid parameter:' rest\n    maxrc = max(maxrc, 20)     /* Set RC 20 */\n    signal main_exit\n  end\n\n  if isRelativeGds(src)\n  then do\n    dslist = rxdslist(basename(src),'B')   /* Get list for this mask */\n  end\n\n  else do  /* Not a relative GDS name */\n    dslist = rxdslist(src)   /* Get list for this mask */\n  end\n\n  do j = 1 to words(dslist) by 2\n    sfile = strip(word(dslist,j),'B')  /* Get next dsn */\n    /* Convert relative GDS to absolute */\n    sfile = resolve_gds_name(sfile, member_name(src))\n\n    /* Form target file name by applying expression from SYSIN stmt */\n    interpret 'tfile=' rxexpr\n\n    putidx = putidx + 1           /* Increment PUT count */\n    put.putidx = sfile tfile  /* Save as a PUT request */\n    call logmsg '-- Generated stmt: PUT' put.putidx\n  end\n\nend\n\nreturn\n\n/**********************************************************************/\n/* Sub: Check FILEEXISTS                                              */\n/* Returns 0 if file is found, 4 if not found                         */\n/**********************************************************************/\ncheck_fileexists: procedure expose logmsg.\nserver = arg(1)\nfile = arg(2)\nparse value ftpdir(server,file) with ,\n  ftprc count .\nif ftprc = 0\nthen do\n  if count = 0                    /* File exists?    */\n\n  then do                         /* File not found */\n    subrc = 4                     /*  set rc to 4 */\n    call logmsg 'FileExists' file 'File not found:',\n                'ftprc='ftprc 'count='count 'rc=4'\n  end\n\n  else do                         /* File is found */\n    subrc = 0                     /*  set rc to 4 */\n    call logmsg 'FileExists' file 'File is found: rc=0'\n  end\nend\n\nelse do\n  call logmsg 'Error - Unable to access server \"'server'\"',\n                'file \"'file'\" rc='ftprc\n  subrc = 12                    /* Set RC 12 */\nend\n\nreturn subrc                      /* Return to caller */\n\n\n/**********************************************************************/\n/* Sub: Send email messages                                           */\n/**********************************************************************/\nsendmail: procedure expose logmsg.\nparse arg recpt ',' subject       /* Get recipents and subject line */\n/* Allocate ds to spin to SMTP */\nwrkdd = '$SMTPWRK'\nok='0 4';\"ALLOC  FI(\"wrkdd\") NEW DELETE REUSE\" ,\n         \"LRECL(200) RECFM(V B) SYSOUT(B) WRITER(SMTP)\"\n\n/* Queue smtp commands on stack */\nok='*';\"MAKEBUF\"\nqueue 'HELO NJEUPI'\nqueue ' MAIL FROM:<MAXIMO@NJEUPI.COM>'\ndo i = 1 to words(recpt)\n  queue 'RCPT TO:<'word(recpt,i)'>'\nend\nqueue 'DATA'\nqueue 'FROM: MAXITRAN'\nqueue 'TO: SUPPORT'\nqueue 'SUBJECT:' subject\nqueue '   '                       /* Queue a blank line - IMPORTANT*/\ndo i = 1 to logmsg.0\n  queue logmsg.i                  /* Queue all logmsgs into body */\nend\nqueue '.'                         /* SMTP end of data */\nqueue 'QUIT'                      /* Smtp quit */\nqueue ''                          /* Null for end-of-stack */\n\nok='0 1';address tso \"EXECIO * DISKW\" wrkdd \"(FINIS\"\nok=0;\"DROPBUF\"\nok=0;\"FREE FI(\"wrkdd\")\"\n\ncall logmsg 'Email sent subject:' subject\ncall logmsg 'Email sent to:' recpt\n\nreturn                            /* Return to caller */\n/**********************************************************************/\n/* Sub: GET files                                                     */\n/**********************************************************************/\nget_files:\naddress tso\nok=0;\"PROFILE MSGID\"                   /* Set MSGIDs on */\n/* Alloc FTP command dataset */\nok='0 4';\"ALLOC  FI(INPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\nok='0 4';\"ALLOC  FI(OUTPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\n\n\ndo i = 1 to getidx                    /* Loop for all datasets to get*/\n  parse var get.i sourcedsn targetdsn ftpparms\n\n  /* Process APPEND keyword if present */\n  append =0                /* Default to GET, not APPEND */\n  kywd = '(APPEND'\n  if pos(kywd,ftpparms) > 0  /* Look for APPEND keyword */\n  then do\n    /* Remove kywd from ftpparms string */\n    ftpparms = delstr(ftpparms,pos(kywd,ftpparms),length(kywd))\n    ftpparms = strip(ftpparms,'B')\n    if sysdsn(\"'\"targetdsn\"'\") = 'OK'   /* If target already exists,*/\n    then do\n      append=1               /* then use append logic */\n      ok=0;address tso \"ALLOC FI(APPOUT) MOD DA('\"targetdsn\"')\"\n    end\n  end\n\n  /* Process REPLACE keyword if present */\n  replace=''               /* Default to no replace */\n  kywd = '(REPLACE'\n  if pos(kywd,ftpparms) > 0  /* Look for REPLACE keyword */\n  then do\n    replace = '(REPLACE'     /* FTP GET operand */\n    /* Remove kywd from ftpparms string */\n    ftpparms = delstr(ftpparms,pos(kywd,ftpparms),length(kywd))\n    ftpparms = strip(ftpparms,'B')\n  end\n\n  /* Test for APPEND & REPLACE together which is not allowed */\n  if append & replace \\= ''\n  then do\n    call logmsg \"Error - (APPEND and (REPLACE may not be used together.\"\n    maxrc = max(maxrc, 20)     /* Set RC 12 */\n    signal main_exit           /*  and exit now */\n  end\n\n\n  /* Queue up the FTP commands */\n  ok=0;\"NEWSTACK\"                    /* Get a clean stack */\n  queue \"LCD ''\"                     /* Turn off prefix */\n  queue 'CD' get.dir\n  queue 'ASCII'                      /* ASCII transfer mode */\n  if locsite \\= ''\n   then queue 'LOCSITE' locsite      /* Allocation parms */\n  if ftpparms \\= ''\n   then queue ftpparms                /* LOCSITE Parms for this get */\n  if append\n    then queue 'GET' sourcedsn '//DD:APPOUT'  /* Trans using DD    */\n    else queue 'GET' sourcedsn targetdsn replace\n  queue 'QUIT'\n  queue ''\n  ok=0;\"EXECIO * DISKW INPUT (FINIS\"  /* Write FTP commands to file */\n  ok=0;\"DELSTACK\"                    /* Delete the stack */\n\n  ok='*';\"FTP\" server '(EXIT'              /* Invoke FTP */\n  ftprc = rc                        /* Save off return code */\n\n  fromtomsg =  'from \"'get.dir'/'sourcedsn'\" to \"'targetdsn'\"'\n\n  if ftprc = 0                      /* If rc=0, */\n    then if scan_output('EZA1617I') = 1 |, /* scan msgs for trns msg*/\n            scan_output('EZA2517I') = 1\n    then do                             /* GOOD completion */\n      if append\n        then call logmsg 'APPEND successful' fromtomsg\n        else call logmsg 'GET successful' fromtomsg\n      if debug                          /* If debug, */\n        then call list_output           /*  then display the sess msg*/\n    end\n\n    else do                             /* rc 0 but something BAD */\n      call logmsg 'Error-GET unexpected FTP message output',\n                  fromtomsg\n      call logmsg 'Review FTP session log to determine problem'\n      call list_output                /* Display the session msgs */\n      maxrc = max(maxrc,8)            /* Set return code */\n    end\n\n  else do                             /* BAD completion, rc not 0 */\n    call logmsg 'Error-GET ftprc' ftprc fromtomsg\n    maxrc = max(maxrc,8)            /* Set return code */\n    call list_output                /* Display the session msgs */\n  end\n\nend\n\nok='*';\"FREE FI(INPUT)\"              /* Free the command file */\nok='*';\"FREE FI(OUTPUT)\"             /* Free the msg file     */\nif append\nthen do\n  ok='*';\"FREE FI(APPOUT)\"             /* Free the target file  */\nend\n\nreturn\n\n\n/**********************************************************************/\n/* Sub: Delete files that were GOT                                    */\n/**********************************************************************/\ndelete_get_files:\naddress tso\nok=0;\"PROFILE MSGID\"                   /* Set MSGIDs on */\n/* Alloc FTP command dataset */\nok='0 4';\"ALLOC  FI(INPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\nok='0 4';\"ALLOC  FI(OUTPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\n\n/* Queue up the FTP commands */\nok=0;\"NEWSTACK\"                    /* Get a clean stack */\nqueue 'CD' get.dir\nif debug                          /* If debug, */\n  then queue 'DIR'                /*  then insert a DIR cmd */\ndellist.=0                       /* List to track dsns we delete */\ndo i = 1 to getidx                    /* Loop for all datasets to get*/\n  parse var get.i sourcedsn .\n  if \\dellist.sourcedsn          /* Have we already deleted this dsn?*/\n  then do                        /* No */\n    queue 'DELETE' sourcedsn     /* Add the delete command */\n    dellist.sourcedsn = 1        /* Add this dsn to list */\n  end\nend\nif debug                          /* If debug, */\n  then queue 'DIR'                /*  then insert a DIR cmd */\nqueue 'QUIT'\nqueue ''\nok=0;\"EXECIO * DISKW INPUT (FINIS\"  /* Write FTP commands to file */\nok=0;\"DELSTACK\"                    /* Delete the stack */\n\nok='*';\"FTP\" server '(EXIT'              /* Invoke FTP */\nftprc = rc                        /* Save off return code */\nif ftprc = 0\nthen do\n  if debug                          /* If debug, */\n    then call list_output           /*  then display the sess msg*/\n  call logmsg 'DELETE of GET source files successful'\nend\n\nelse do\n  call logmsg 'Error-DELETE of GET source files failed with ftprc' ,\n              ftprc'. See session log for details.'\n  maxrc = max(maxrc,8)            /* Set return code */\n  call list_output           /*  then display the sess msg*/\nend\n\n\nok='*';\"FREE FI(INPUT)\"              /* Free the command file */\nok='*';\"FREE FI(OUTPUT)\"             /* Free the msg file     */\n\nreturn\n\n\n\n/**********************************************************************/\n/* Sub: PUT files                                                     */\n/**********************************************************************/\nput_files:\naddress tso\nok=0;\"PROFILE MSGID\"                   /* Set MSGIDs on */\n/* Alloc FTP command dataset */\nok='0 4';\"ALLOC  FI(INPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\nok='0 4';\"ALLOC  FI(OUTPUT) NEW DELETE REUSE\" ,\n         \"LRECL(80) RECFM(F B) UNIT(VIO)\"\n\n\ndo i = 1 to putidx                    /* Loop for all datasets to get*/\n  parse var put.i sourcedsn targetdsn ftpparms\n\n  /* Queue up the FTP commands */\n  ok=0;\"NEWSTACK\"                    /* Get a clean stack */\n  queue 'SENDSITE'                   /* Toggle off site data */\n  queue \"LCD ''\"                     /* Turn off prefix */\n  queue 'CD' put.dir\n  queue 'ASCII'                      /* ASCII transfer mode */\n  if ftpparms \\= ''\n   then queue ftpparms                /* Parms for this get */\n  queue 'PUT' sourcedsn targetdsn     /* Transfer the dataset */\n  if debug                          /* If debug, */\n    then queue 'DIR'                /*  then insert a DIR cmd */\n  queue 'QUIT'\n  queue ''\n  ok=0;\"EXECIO * DISKW INPUT (FINIS\"  /* Write FTP commands to file */\n  ok=0;\"DELSTACK\"                    /* Delete the stack */\n\n  ok='*';\"FTP\" server '(EXIT'              /* Invoke FTP */\n\n  ftprc = rc                        /* Save off return code */\n\n  fromtomsg =  'from \"'sourcedsn'\" to \"'put.dir'/'targetdsn'\"'\n\n  if ftprc = 0                      /* If rc=0, */\n    then if scan_output('EZA1617I') = 1 |, /* scan msgs for trns msg*/\n            scan_output('EZA2517I') = 1\n    then do                             /* GOOD completion */\n      call logmsg 'PUT successful' fromtomsg\n      if debug                          /* If debug, */\n        then call list_output           /*  then display the sess msg*/\n    end\n\n    else do                             /* rc 0 but something BAD */\n      call logmsg 'Error-PUT unexpected FTP message output',\n                  fromtomsg\n      call logmsg 'Review FTP session log to determine problem'\n      maxrc = max(maxrc,8)            /* Set return code */\n      call list_output                /* Display the session msgs */\n    end\n\n  else do\n    call logmsg 'Error-PUT ftprc' ftprc fromtomsg\n    maxrc = max(maxrc,8)            /* Set return code */\n    call list_output                /* Display the session msgs */\n  end\n\nend\n\nok='*';\"FREE FI(INPUT)\"              /* Free the command file */\nok='*';\"FREE FI(OUTPUT)\"             /* Free the msg file     */\n\nreturn\n\n\n\n/**********************************************************************/\n/* Sub: Check directory lock status                                   */\n/**********************************************************************/\n/* For PUT, dir is locked if any files present, unlocked if empty */\n/* For GET, dir is locked if any *.lck files are present          */\ntest_lock: procedure expose logmsg. maxrc debug\ngotlock = 0                       /* We have lock flag */\nserver=arg(1)                     /* Server */\ndir = arg(2)                      /* Dir to test */\nmask = arg(3)                     /* File that represents a lock */\nlock_wait = 3                     /* seconds to wait for lock */\nlock_tries = 2                    /* How many times to try lock */\n\n\ntry_lock:\nlock_tries = lock_tries - 1       /* Decrement counter */\nparse value ftpdir(server,dir||mask) with ,\n  ftprc count .\nselect\n\n  when ftprc = 0 & count = 0      /* When ok and no lock found, */\n    then gotlock = 1              /*  the set flag we have lock */\n\n\n  when ftprc = 0 & count > 0 & ,  /* Lock was found */\n       lock_tries > 0             /*  and retries remain */\n  then do\n    if debug\n      then say 'Waiting for lock, lock_tries=' lock_tries\n    ok=0;address tso \"WAIT\" lock_wait*100   /* Wait 100ths secs */\n    signal try_lock               /* Go try the lock again */\n  end\n\n\n  when ftprc = 0 & count > 0 & ,  /* Lock was found */\n       lock_tries <= 0             /*  and no retries remain */\n    then nop                      /* Do nothing - just fall through*/\n\n\n  when ftprc = 14550              /* Directory not found */\n  then do\n    call logmsg 'Error-Invalid directory \"'dir'\".'\n    maxrc = max(maxrc,12)         /* Set return code */\n  end\n\n\n  otherwise do\n    call logmsg 'Error-Unexpected return from FTPDIR'\n    call logmsg 'ftprc='ftprc 'count='count 'server='server,\n                      'dir='dir 'mask='mask\n  end\n\nend\n\nreturn gotlock                    /* return lock status */\n\n\n\n/**********************************************************************/\n/* Sub: Copy ftp msg stream from OUTPUT dd to SAY                     */\n/**********************************************************************/\nlist_output:\nsay '--------FTP Session log follows--------'\nok=0;\"EXECIO * DISKR OUTPUT (STEM x. FINIS\"\ndo i = 1 to x.0\n  say strip(x.i,'T')\nend\nreturn                            /* Return to caller   */\n\n\n/**********************************************************************/\n/* Sub: Scan the ftp msg OUTPUT ds for a string                       */\n/**********************************************************************/\nscan_output: procedure\nstr = arg(1)                      /* String to scan for */\nok=0;\"EXECIO * DISKR OUTPUT (STEM x. FINIS\"\n/* Put all the messages into one var for parse */\nbigmsg =''\ndo i = 1 to x.0\n  bigmsg = bigmsg strip(x.i,'B')\nend\n\nx = wordpos(str,bigmsg)           /* Scan for argument string */\nif x = 0                          /* If not found, */\n  then return 0                   /*  return not found */\n  else return 1                   /*  return found */\n\n\n\n/**********************************************************************/\n/* Sub: Read control cards                                            */\n/**********************************************************************/\nread_control_cards:\nok=0;\"EXECIO * DISKR SYSIN (STEM cardin. FINIS\"\n\ndo i = 1 to cardin.0\n\n  parse var cardin.i keyword keyparm\n  upper keyword;                    /* Make keyword uppercase */\n  keyparm = strip(keyparm,'B')\n\n  if right(keyparm,1) = ','       /* If continued, */\n  then do while right(keyparm,1) = ',' & i < cardin.0\n    i = i + 1\n    keyparm = delstr(keyparm,length(keyparm),1) || strip(cardin.i,'B')\n  end\n\n  select\n\n    when left(keyword,1) = '*'         /* Ignore comment lines */\n      then nop\n\n    when keyword = 'EMAIL-ON-ERROR'    /* Email address for error */\n      then email_on_error_list = ,\n           email_on_error_list keyparm  /* Add to list */\n\n    when keyword = 'EMAIL-ON-SUCCESS'    /* Email address for success*/\n      then email_on_success_list = ,\n           email_on_success_list keyparm  /* Add to list */\n\n    when keyword = 'FILEEXISTS'\n    then do\n      feidx = feidx + 1             /* Increment count */\n      fileexists.feidx = keyparm    /* Save filename to test  */\n    end\n\n    when keyword = 'NOTFILEEXISTS'\n    then do\n      nfeidx = nfeidx + 1             /* Increment count */\n      notfileexists.nfeidx = keyparm    /* Save filename to test  */\n    end\n\n    when keyword = 'GET'\n    then do\n      getidx = getidx + 1           /* Increment count */\n      get.getidx = keyparm          /* Save get parms         */\n    end\n\n    when keyword = 'GETLOCK'\n    then do\n      if translate(strip(keyparm,'B')) = 'NO'\n        then flagUseGetLock = 0          /* If no lock, turn off flag */\n        else getLockMask = strip(keyparm,'B')\n    end\n\n    when keyword = 'GETMASK'\n    then do\n      getmaskidx = getmaskidx + 1   /* Increment count */\n      getmask.getmaskidx = keyparm          /* Save get parms         */\n    end\n\n    when keyword = 'PUTMASK'\n    then do\n      putmaskidx = putmaskidx + 1   /* Increment count */\n      putmask.putmaskidx = keyparm          /* Save get parms         */\n    end\n\n    when keyword = 'GETDELETE'\n    then do\n      keyparm = strip(keyparm,'B')\n      upper keyparm\n      select\n        when keyparm = 'NO'\n          then flagGetDelete = 0\n        when keyparm = 'YES'\n          then flagGetDelete = 1\n        otherwise do\n          call logmsg ,\n          'Error- SYSIN card' i '- invalid value for GETDELETE. Must' ,\n          'be YES or NO'\n          maxrc = max(maxrc,20)\n        end\n      end\n    end\n\n    when keyword = 'GETDIR'\n      then get.dir = keyparm\n\n    when keyword = 'LOCSITE'        /* Allocation parms */\n      then locsite = keyparm\n\n    when keyword = 'PUT'\n    then do\n      putidx = putidx + 1           /* Increment count */\n      put.putidx = keyparm          /* Save put parms         */\n    end\n\n    when keyword = 'PUTLOCK'\n    then do\n      if translate(strip(keyparm,'B')) = 'NO'\n        then flagUsePutLock = 0          /* If no lock, turn off flag */\n        else putLockMask = strip(keyparm,'B')\n    end\n\n    when keyword = 'PUTDIR'\n      then put.dir = keyparm\n\n    when keyword = 'SERVER'\n      then server = keyparm\n\n\n    otherwise do\n      call logmsg ,\n      'Error- SYSIN card' i '- unrecognized keyword' keyword\n      maxrc = max(maxrc,20)\n    end\n\n  end                           /* End select */\nend\nreturn                          /* * return to caller * */\n\n/*********************************************************************/\n/**   Translate a boolen to YES or NO                               **/\n/*********************************************************************/\nflagYN: procedure\narg flag\nif flag\n  then return 'YES'\n  else return 'NO'\n\n/*********************************************************************/\n/**   Display and save log messages                                 **/\n/*********************************************************************/\nlogmsg: procedure expose logmsg.\nparse arg xmsg\n/* Add date, time, jobname to msg */\nxmsg = right(date('S'),6),\n       space(translate(time('N'),'',':'),0),\n       logmsg.jobname xmsg\n\nlogmsg.0 = logmsg.0 + 1; x = logmsg.0\nlogmsg.x = xmsg                    /* Add msg to array  */\nsay xmsg                           /* Display the message */\n\nif logmsg.alloc                    /* If logfile allocated, */\nthen do                            /*  then write msg to logfile */\n  push xmsg                          /* Put msg on stack */\n  ok='0 1';address tso \"EXECIO 1 DISKW LOG\"\nend\n\nreturn                            /* Return to caller */\n\n/*********************************************************************/\n/**   Display parms for this run                                    **/\n/*********************************************************************/\ndisplay_parms:\ncall logmsg 'The following parameters will be used -----------'\ncall logmsg 'SERVER='server 'PUTDIR='put.dir 'GETDIR='get.dir\ncall logmsg 'DELETE AFTER GET=' flagYN(flagGetDelete)\nif flagUseGetLock\n  then call logmsg 'USING GET LOCK=' getLockMask\n  else call logmsg 'NO GET LOCK'\nif flagUsePutLock\n  then call logmsg 'USING PUT LOCK=' putLockMask\n  else call logmsg 'NO PUT LOCK'\ncall logmsg 'LOCSITE='locsite\ncall logmsg 'EMAIL-ON-ERROR=' email_on_error_list\ncall logmsg 'EMAIL-ON-SUCCESS=' email_on_success_list\ncall logmsg '---------- End of parameter list'\nreturn                            /* Return to caller */\n\n\n/*********************************************************************/\n/**   Convert a relative GDS name to abslute name                   **/\n/*********************************************************************/\nresolve_gds_name: procedure expose logmsg. maxrc\nbase = arg(1)\nrelgen = arg(2)\nselect\n  /* No (..) suffix on dsn */\n  when relgen = ''\n  then do\n    return base\n  end\n\n  /* A (nn) suffix on dsn - must be gdg */\n  when datatype(relgen, 'NUM')\n  then do\n    fulldsname = base'('relgen')'\n    /*TODO: replace with more robust getgdg function */\n    parse value getgdg(fulldsname) with fulldsname .\n    /* Some error from getgdg()? */\n    if datatype(fulldsname,'NUM') | left(fulldsname,1) = '*'\n    then do\n      call logmsg 'Error-Resolving GDS' base'('relgen')'\n      call logmsg 'Error return from getgdg(): ' fulldsname\n      maxrc = max(maxrc,8)\n    end\n    return fulldsname\n  end\n\n  /* some (aaaa) suffix - must be pds */\n  otherwise do\n    return base'('relgen')'\n  end\n\nend\n\n/*********************************************************************/\n/**   Returns the dsname without paren portion                      **/\n/*********************************************************************/\nbasename: procedure\nparse arg base '(' .\nreturn base\n/*********************************************************************/\n/**   Returns the portion of the name in parens                     **/\n/*********************************************************************/\nmember_name: procedure\nparse arg . '(' mem ')' .\nreturn mem\n/*********************************************************************/\n/**   Tests if the dsname appears to be a relative GDG name         **/\n/*********************************************************************/\nisRelativeGds: procedure\n/* If \"member name\" portion is a number, then it's a relative gds */\nif datatype(member_name(arg(1)), 'NUM')\n  then return 1\n  else return 0\n\n/*********************************************************************/\n/**   A group of special rexx expressions to use in filenames       **/\n/*********************************************************************/\n/*********************************************************************/\n/**   Convience function to get GDS G0000V00 portion of name        **/\n/*********************************************************************/\ngdsversion: procedure\ndsname = arg(1)\n/* Find last node in dsn */\nlastdot = lastpos('.',dsname)\n/* No node, return empty */\nif lastdot = 0\n  then return ''\n/* Get the assumed G0000V00 node */\ngv = substr(dsname,lastdot+1)\n/* Break out the numbers */\nparse var gv 'G' gen 'V' ver\n/* Validate that it looks like a G0000V00 */\nif datatype(gen || ver,'NUM')\n  then return gv\nelse return \"\"   /* Couldn't find it - return empty */\n/*********************************************************************/\n/**   Convience function to get HHMMSS time stamp                   **/\n/*********************************************************************/\nhhmmss: procedure\nreturn space(translate(time('n'),'',':'),0)\n/*********************************************************************/\n/**   Convience function to get YYMMDD date stamp                   **/\n/*********************************************************************/\nyyyymmdd: procedure\nreturn date('S')\n/*********************************************************************/\n/**   Convienence function to return a token from a string           **/\n/*********************************************************************/\ntoken: procedure\nstr = arg(1)       /* The string to parse */\npos = arg(2)       /* Which token to return */\ndelim = arg(3)     /* Delimiter that seperates tokens */\nmaxlen = arg(4)    /* Max length of returned token */\nif delim = ''      /* If no delim provided, use default */\n  then delim = '.'\ndo pos\n  parse var str retToken (delim) str\nend\nif maxlen <>  ''   /* If a maxlength was specified, then truncate */\n  then parse var retToken 1 retToken +(maxlen)\nreturn retToken\n/*********************************************************************/\n/**   Returns incremented counter value                             **/\n/*********************************************************************/\ncounter:\nsfx = arg(1)\ncounter.sfx = counter.sfx + 1;\nreturn right(counter.sfx,4,'0')\n\n/*********************************************************************/\n/**   Cleanup after error                                           **/\n/*********************************************************************/\ncleanup_after_error:\naddress tso \"FREE FI(INPUT)\"\naddress tso \"FREE FI(OUTPUT)\"\naddress tso \"FREE FI(APPOUT)\"\nexit 20\n\n/*********************************************************************/\n/**   standard error handling routine                               **/\n/*********************************************************************/\nerrproc:\nif condition('c') = 'ERROR' & symbol('OK') = 'VAR'\n  then if wordpos(rc,ok) > 0 | ok = '*' then return;   /* Not an error*/\n/* Cancel error traps to prevent recursion */\nsignal off syntax\nsignal off novalue\ncall off error\n/* error presentation code */\nerror_type = condition('c')\nsay error_type 'at line' sigl ':' condition('d')\nif error_type = 'SYNTAX'\n  then say errortext(rc)\nif error_type = 'ERROR' & symbol('zerrlm') = 'VAR'\n  then say zerrlm\nif error_type = 'ERROR'\n  then say 'Return code = ' rc\ncall cleanup_after_error\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROC": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x008\\x00\\x99\\x15\\x7f\\x01\\x05)\\x7f\\x10\\x04\\x00\\n\\x00\\n\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3\\xe7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-06-06T00:00:00", "modifydate": "2005-10-24T10:04:38", "lines": 10, "newlines": 10, "modlines": 0, "user": "WTS03X"}, "text": "//MAXITRAN PROC OPT=\n//*********************************************************************\n//* TRANSFER FILES BETWEEN MVS FTP CLIENT AND FTP SERVER.             *\n//*********************************************************************\n//TRAN    EXEC PGM=IKJEFT1A,REGION=4M,PARM='%MAXITRAN &OPT'                    5\n//SYSPROC  DD  DISP=SHR,DSN=your-sysexec\n//NETRC    DD  DISP=SHR,DSN=your-netrc-dataset\n//SYSTSPRT DD  SYSOUT=*\n//LOG      DD  SYSOUt=*   * Optional log file *\n//SYSTSIN  DD  DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "README": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Y\\x01\\x02\\x11?\\x01\\x05)\\x7f\\x10\\x08\\x00\\x1b\\x00\\x10\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3\\xe7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-04-23T00:00:00", "modifydate": "2005-10-24T10:08:59", "lines": 27, "newlines": 16, "modlines": 0, "user": "WTS03X"}, "text": "The MAXITRAN exec is used to script batch FTP between an MVS client\nand another FTP server. It provides functions such as delete of\nsource files after GET (delete is the default!). Read the doc\n\"maxitran.doc\" for complete documentation.\n\nThis software is distributed into the public domain \"as-is\" by\nRob Wunderlich (RobWunderlich@ussposco.com).\n\nTo execute maxitran, copy the member \"PROC\" to a proclib (or JCLLIB)\nas member \"MAXITRAN\". Update the SYSPROC DD stmt to point to this PDS.\n\n\nCustomizations required before you use this at your site:\n-- Member MAXITRAN --\n1)The shipped default is \"GETDELETE YES\" which means files will\nbe deleted from the server after a sucessfull GET. If you want to\nchange the default for your shop, change the line\n  flagGetDelete=1\nto\n  flagGetDelete=0\n\n2)If you use the email feature, you might want to\nupdate subroutine \"sendmail\" to use \"HELO\" and \"FROM\" values that\nare meaningful for your site.\n\nThe email email routine expects that you have an MVS SMTP server\nset up named \"SMTP\" that services output class B.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT729/FILE729.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT729", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}