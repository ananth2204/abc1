{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013606000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE961.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE961.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x10\\x07'", "DS1TRBAL": "b'\\x98\\xbc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xf7\\x00\\x05\\t\\xf8\\x00\\x06\\x00\\x11'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00D\\x01\\x19$/\\x01\\x19$/\\x14\\x05\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-08-30T00:00:00", "modifydate": "2019-08-30T14:05:44", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  961\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE961\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 30 MEMBERS COUNTED; CUMULATIVE SIZE IS 8,360 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/30/19    14:05:44    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x17\\x00A\\x01\\x18\\x14/\\x01\\x19$/\\x06S\\x00U\\x00T\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "02.23", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2019-08-30T06:53:41", "lines": 85, "newlines": 84, "modlines": 0, "user": "SLBD"}, "text": "YCLMAC - A collection of user line commands for use in ISPF Edit and View\nby YCOS Yves Colliard Software - www.ycos.de\nand many others|\n\n-------------------------------------------------------------------------\n\nInstallation:\n\n   1. Copy YCLMACTB into ISPTLIB library (see $$$INST)\n   2. Copy REXX others into SYSEXEC or SYSPROC library (see $$$INST)\n   3. Update ISPF site customization table (ISPFC) (z/OS 2.2)\n      GLOBAL_LINE_COMMAND_TABLE = YCLMACTB\n   4. If using (E)JES instead of SDSF change the LMACJES2/3\n      members from sdsf to ejes\n   5. If you plan using the System Automation interface some\n      more customization will be needed|\n      If the name of the rexx of System Automation is not:\n        SYS1.ING.SINGTREX\n      then you have to create a rexx YCINGCUS in your SYSPROC/\n      SYSEXEC concatenation with following content:\n/* Rexx YCINGCUS */\n/* User customized System Automation Call              */\n/* Define the name of the dataset containing the Rexx: */\n/*        AOFRYCMD                                     */\n/* Default is: SYS1.ING.SINGTREX                       */\npush \"MY.DATA.SET\"  <- replace with your name\nexit 0\n\n-------------------------------------------------------------------------\n\nMembers of this dataset:\n\n   $$$DOC           This member that you are reading\n   $$$HELP          A copy of the HELP information\n   $$$HELPS         A short reference 'card' of commands\n   $$$INST          some IEBCOPY to distribute members\n\nRexx to be added to SYSEXEC/SYSPROC\n   YCLMACDS         REXX to extract DSN from records\n   YCLMACHG         Summary of Changes\n   YCLMACLM         REXX to get messages\n   YCLMACNS         REXX to support split screen functions\n   YCLMACRX         REXX to process new line commands\n   YCLMAHLP         REXX to display help information\n   YCLMAHLU         REXX to display user extensions help information\n   Y$CL             REXX to compare members\n   Y$HC             REXX short help\n   Y$RU             REXX support of RU - Ruler line command\n\nISPF Table - must be copied to ISPTLIB\n   YCLMACTB         ISPF Table of Line Commands\n\nRexx Additional commands - extra installation needed\nRexx to be added to SYSEXEC/SYSPROC if needed\n   Y$REV            REXX to interface to Greg Price's REVIEW command\n   Y$PDS            REXX to interface to Lionel Dyck's PDS\n   Y$PG             REXX to interface to Lionel Dyck's PDSEGEN\n   YCLMACT          REXX to support user line command table extensions\n\nSamples to run EX command\n   LMACJES2         Sample JES2 commands for use with EX\n   LMACJES3         Sample JES3 commands for use with EX\n   LMACMVS          Sample MVS (SDSF/EJES) commands for use with EX\n   LMACTSO          Sample TSO commands for use with EX\n   LMACUSS          Sample OMVS commands for use with EX\n   LMACING          Sample System Automation cmds use with EX\n   LMACISPF         Sample ISPF commands use with EX\n\nSample coding for own application\n   YLM01            Sample application using own line commands\n   YLM02            Sample application using own line commands\n\n-------------------------------------------------------------------------\n\nAddition of user/local commands:\n\n   1. Update YCLMACT with the name of the new command\n      - Update at the bottom in the User Command section\n      - Follow the coding examples in YCLMACT\n   2. Run the REXX YCLMACT to replace the line command table YCLMACTB\n   3. Copy YCLMACTB into the ISPTLIB library\n   4. Create a REXX Exec Y$xxx\n      - where xxx is the 1-6 character name of the new command\n   5. Update YCLMAHLU to document the new command\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$HELP": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00G\\x01\\x18\\t\\x9f\\x01\\x19$/\\x06Q\\x02\\xd5\\x02\\xd6\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-04-09T00:00:00", "modifydate": "2019-08-30T06:51:47", "lines": 725, "newlines": 726, "modlines": 0, "user": "SLBD"}, "text": "+------------------------------------------------------------------+\n| YCLMACRX     (c)  YCOS Yves Colliard Software                    |\n+------------------------------------------------------------------+\n|\n| Functions of YCLMACRX:\n| H      ==>> Show help as note\n| HELP   ==>> Show help\n|             Help from outside - TSO YCLMACRX\n| HV     ==>> Show help as view\n| HC     ==>> Show a Short description of each command\n|\n| =========== Text Commands =======================================\n| RV     ==>> Reverse the line text\n|             Block: RVV - RVV\n|             Multi: RV#\n|\nRV 024 Help File - see YCLMACRX\n-> Result:\n000024                                      XRCAMLCY ees - eliF pleH\n|\n| =========== Text Commands =======================================\n| CE     ==>> Center the line text\n|             Block: CEE - CEE\n|             Multi: CE#\n|\nCE 024 Help File - see YCLMACRX\n-> Result:\n000024                   Help File - see YCLMACRX\n|\n| =========== Text Commands =======================================\n| AL     ==>> Align Left the line text\n|             Block: ALL - ALL\n|             Multi: AL#\n|\nAL 024                   Help File - see YCLMACRX\n-> Result:\n000024 Help File - see YCLMACRX\n|\n| =========== Text Commands =======================================\n| AR     ==>> Align Right the line text\n|             Block: ARR - ARR\n|             Multi: AR#\n|\nAR 024 Help File - see YCLMACRX\n-> Result:\n000024                                      Help File - see YCLMACRX\n|\n| =========== Text Commands =======================================\n| AU     ==>> Align Up the line text as the previous line\n|             Block: AUU - AUU\n|             Multi: AU#\n|\n000107      ISupport=\"CE RV AL AR E EX V DI DL\",\nAU 108 newl=\"YVES\"\n-> Result:\n000107      ISupport=\"CE RV AL AR E EX V DI DL\",\n000108      newl=\"YVES\"\n|\n|             if JCL found - alignment based on:\n|             Ref Line \"JCL Comment   -> column 15\n|             Ref Line \"// \"          -> first parameter statement\n|                     if more than 16 -> use column 15\n|             else     \"//D1 DD DSN=\" -> third parameter statement\n|                     if more than 16 -> use column 15\n000093 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\nAU5 94 //   DISP=(,CATLG),\n000095 //     SPACE=(TRK,(15,15),RLSE),\n000096 // STORCLAS=SMS,\n000097 //     RECFM=FB,\n000098 //    LRECL=4160\n-> Result:\n000093 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n000094 //         DISP=(,CATLG),\n000095 //         SPACE=(TRK,(15,15),RLSE),\n000096 //         STORCLAS=SMS,\n000097 //         RECFM=FB,\n000098 //         LRECL=4160\n|\n| =========== Text Commands =======================================\n| AD     ==>> Align Down the line text as the next line\n|             Block: ADD - ADD\n|             Multi: AD#\n|\nAD 108 newl=\"YVES\"\n000109            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"\n-> Result:\n000108            newl=\"YVES\"\n000109            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"\n|\n|             if JCL found - alignment based on:\n|             Ref Line \"JCL Comment   -> column 15\n|             Ref Line \"// \"          -> first parameter statement\n|                     if more than 16 -> use column 15\n|             else     \"//D1 DD DSN=\" -> third parameter statement\n|                     if more than 16 -> use column 15\n000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\nADD 08 //   DISP=(,CATLG),\n000109 //     SPACE=(TRK,(15,15),RLSE),\n000110 // STORCLAS=SMS,\nADD 11 //     RECFM=FB,\n000112 //      LRECL=4160\n-> Result:\n000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n000108 //      DISP=(,CATLG),\n000109 //      SPACE=(TRK,(15,15),RLSE),\n000110 //      STORCLAS=SMS,\n000111 //      RECFM=FB,\n000112 //      LRECL=4160\n|\n| =========== Text Commands =======================================\n| YX     ==>> Hex one line as note (native support 1.11|)\n|             Block: YXX - YXX\n|             Multi: YX#\n|\nYX 107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n-> Result:\n000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n====== 66EEEDCEDD4CC4CED7EECE4ECDE4EC4CEDD6444444444444444\n====== 11282444470440425E8552B8362B26B4447B000000000000000\n|\n| =========== Text Commands =======================================\n| YD     ==>> Hex one line as note (in data form)\n|             Block: YDD - YDD\n|             Multi: YD#\n|\nYD 107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n-> Result:\n000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n====== 6161E2E8E2D4C4E4D4D740C4C440C4E2D57EE8E5C5E24BE8C3D6E24BE2...\n====== 4040404040404040404040404040404040404040404040404040404040...\n|\n| =========== Text Commands =======================================\n| CL     ==>> Compare lines\n|             NO-Block and NO-Multi\n|             the lines to be compared could be marked with labels:\n|               .EF and .EL\n|             the selected line and the next line will be compared\n|             differences will be shown with an infoline:\n|             - single character difference with a |\n|             - many characters with <----> or <>\n|\nCL 001 THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA\n000002 THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA\n-> Result:\n000001 THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA\n======    |       <--->                     |     |     |     <>\n000002 THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA\n|\n|        ==>> Compare lines - NOT ADJACENT|\n|\nCL 005 lmactest\n000006 lmactest\n.EF 07 THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA\n000008 lmactest\n000009 lmactest\n.EL 10 THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA\n-> Result:\n.EF    THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA\n======    |       <--->                     |     |     |     <>\n.EL    THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA\n|\n| =========== Text Commands =======================================\n| CM     ==>> Comment/uncomment lines\n|             Block: CMM - CMM\n|             Multi: CM#\n|             if JCL: try to toggle // and //*\n|\n000117 //SYSPRINT DD DSN=YVESCOL.AMBLIST,\nCM4 18 //            DISP=SHR\n000119 //*            DISP=(,CATLG),\n000120 //*            SPACE=(TRK,(50,10),RLSE),\n000121 //*            DCB=(RECFM=VBA,LRECL=137),MGMTCLAS=BAT#NJ\n000122 //SYSIN      DD      *\n-> Result:\n000117 //SYSPRINT DD DSN=YVESCOL.AMBLIST,\n000118 //*            DISP=SHR\n000119 //            DISP=(,CATLG),\n000120 //            SPACE=(TRK,(50,10),RLSE),\n000121 //            DCB=(RECFM=VBA,LRECL=137),MGMTCLAS=BAT#NJ\n000122 //SYSIN      DD      *\n|\n|             not JCL: create a before/after comment a la rexx\n|\n000124 else do\nCM3 25   ISupport=\"CE RV AL AR E EX V DI DL\",\n000126            newl=\"YVES\"\n000127            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"\n000128 end\n-> Result:\n000124 else do\n000125   /* Comment Start\n000126   ISupport=\"CE RV AL AR E EX V DI DL\",\n000127            newl=\"YVES\"\n000128            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"\n000129      Comment End */\n000130 end\n|\n|                  if given on \"Comment Start\" or \"Comment End\"\n|                     it will delete them\n000124 else do\n000125   /* Comment Start\nCM 126   ISupport=\"CE RV AL AR E EX V DI DL\",\n000127            newl=\"YVES\"\n000128            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"\n000129      Comment End */\n000130 end\n-> Result:\n000025   ISupport=\"CE RV AL AR E EX V DI DL\",\n000126            newl=\"YVES\"\n000127            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"\n             +---------------------------------------+\n             ] Comments on lines 125 and 129 deleted ]\n             +---------------------------------------+\n|\n| =========== Text Commands =======================================\n| LN     ==>> Display the number of characters of variable length\n|             Block: LNN - LNN\n|             Multi: LN#\n|             datasets - could be important for USS|\n|             L= line size/length\n|\nLN2 01 information of line 1\n000002 even more information on line 2\n000003 nothing...\n-> Result:\n====== L=00021 -1----+----2-\n000001 information of line 1\n====== L=00031 -1----+----2----+----3-\n000002 even more information on line 2\n000003 nothing...\n|\n| =========== Text Commands =======================================\n| TOPD   ==>> Delete all lines from here to the top\n|             NO-Block and NO-Multi\n|             will inform about number of lines\n|\n000104 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR\n000105 //SYSEXEC  DD DSN=YVES.CLIST,DISP=SHR\n000106 //SYSTSPRT DD SYSOUT=*\nTOPD 7 //SYSOUT   DD SYSOUT=*\n000108 //SYSPRINT DD SYSOUT=*\n000109 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n000110 //   DISP=(,CATLG),\n000111 //     SPACE=(TRK,(15,15),RLSE),\n000112 // STORCLAS=SMS,\n-> Result:\n000001 //SYSPRINT DD SYSOUT=*\n000002 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n000003 //   DISP=(,CATLG),\n000004 //     SPACE=(TRK,(15,15),RLSE),\n000005 // STORCLAS=SMS,\n               +-------------------+\n               ] 107 lines deleted ]\n               +-------------------+\n|\n| =========== Text Commands =======================================\n| BOTD   ==>> Delete all lines from here to the bottom\n|             NO-Block and NO-Multi\n|             will inform about number of lines\n|             D9999 could also be used, but sometime not so \"good\"\n|\n000087 //*----------------------------*\n000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M\nBOTD 9 //STEPLIB  DD DISP=SHR,DSN=YVES.YCDIAG.LINKLIB\n000090 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR\n-> Result:\n000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M\n               +------------------+\n               ] 86 lines deleted ]\n               +------------------+\n|\n| =========== Text Commands =======================================\n| TOPX   ==>> eXclude all lines from here to the top\n|             NO-Block and NO-Multi\n|             will inform about number of lines\n|\n000104 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR\n000105 //SYSEXEC  DD DSN=YVES.CLIST,DISP=SHR\n000106 //SYSTSPRT DD SYSOUT=*\nTOPX 7 //SYSOUT   DD SYSOUT=*\n000108 //SYSPRINT DD SYSOUT=*\n000109 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n000110 //   DISP=(,CATLG),\n000111 //     SPACE=(TRK,(15,15),RLSE),\n000112 // STORCLAS=SMS,\n-> Result:\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  93 Line(s) not Displayed\n000094 //SYSPRINT DD SYSOUT=*\n000095 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,\n000096 //   DISP=(,CATLG),\n000097 //     SPACE=(TRK,(15,15),RLSE),\n000098 // STORCLAS=SMS,\n               +-------------------+\n               ] 93 lines excluded ]\n               +-------------------+\n|\n| =========== Text Commands =======================================\n| BOTX   ==>> eXclude all lines from here to the bottom\n|             NO-Block and NO-Multi\n|             will inform about number of lines\n|             X9999 could also be used, but sometime not so \"good\"\n|\n000087 //*----------------------------*\n000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M\nBOTX 9 //STEPLIB  DD DISP=SHR,DSN=YVES.YCDIAG.LINKLIB\n000090 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR\n-> Result:\n000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  86 Line(s) not Displayed\n               +------------------+\n               ] 86 lines deleted ]\n               +------------------+\n|\n| =========== Text Commands =======================================\n| FI     ==>> FindFirst where the cursor is placed - or first word\n|             NO-Block and NO-Multi\n|\nFI 176 we search sdsf\n|                 |\n|                 +-- cursor pointing on SDSF\n-> Result:\n000130 * time\n000131 sdsf d t\n|      |\n|      +-- sdsf on line 131 found\n|\n| =========== Text Commands =======================================\n| FL     ==>> FindLast  where the cursor is placed - or first word\n|             NO-Block and NO-Multi\n|\nFL 131 we search sdsf\n                  |\n                  +-- cursor pointing on SDSF\n-> Result:\n000780 * time\n00 781 sdsf d t\n       |\n       +-- sdsf on line 781 found\n|\n| =========== Text Commands =======================================\n| FA     ==>> FindAll   where the cursor is placed - or first word\n|                       other lines will be excluded\n|             Multi: FA#\n|                       will also show # lines before and after\n|\n000130 * time\n000131 sdsf d t\n000132\n000133 * work with exits\nFA 134 sdsf SETPROG EXIT,ADD,  +\n        |\n        +-- cursor pointing on SDSF\n-> Result:\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  130 Line(s) not Displayed\n000131 sdsf d t\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  - 2 Line(s) not Displayed\n000134 sdsf SETPROG EXIT,ADD,  +\n- - -  -  -  -  -  -  -  -  -  -  -  -  -   41 Line(s) not Displayed\n000176 we search sdsf\n|\n|             Multi: FA#\n000130 * time\n000131 sdsf d t\n000132\n000133 * work with exits\nFA2 34 sdsf SETPROG EXIT,ADD,  +\n        |\n        +-- cursor pointing on SDSF\n-> Result:\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  128 Line(s) not Displayed\n000129\n000130 * time\n000131 sdsf d t\n000132 next line1\n000133 next line2\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  - 2 Line(s) not Displayed\n000136 previous line2\n000137 * work with exits\n000138 sdsf SETPROG EXIT,ADD,  +\n000139           EX=SYS.IEFUSI,    +\n000140      MOD=YCDUSI,    +\n- - -  -  -  -  -  -  -  -  -  -  -  -  -   37 Line(s) not Displayed\n000178        *C*\n000179\n000180 we search sdsf\n|\n| =========== Dataset Commands ====================================\n|             Analyse the line to find a dataset\n|             Make a difference if JCL or not\n|             JCL search DSN= and JCLLIB ORDER= and PATH=\n|             For JCL which is not DSN or JCLLIB (e.g. PROC)\n|             support dataset in parameter=dataset\n|             If not JCL search a nn.nn.nn\n|             If more than one nn.nn.nn in line process first\n|             or nn.nn.nn pointed to by cursor position.\n|\n| =========== Dataset Commands ====================================\n| E      ==>> Edit the dataset\n| EZ     ==>> Edit the dataset in new Split Screen\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| V      ==>> View the dataset\n| VZ     ==>> View the dataset in new Split Screen\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| DA     ==>> Dataset allocation like - JCL and TSO Allocate\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| DI     ==>> DSINFO the dataset\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| DL     ==>> LISTCAT the dataset\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| DS     ==>> DSLIST the dataset 3.4\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| DX     ==>> DSLIST first n Qualifiers 3.4\n|             Multi: DX#\n|             Default (not like DZ) will show first qualifier\n|\n| =========== Dataset Commands ====================================\n| DZ     ==>> DSLIST first n Qualifiers 3.4 in new Split Screen\n|             Multi: DZ#\n|             Default (not like DX) will show all qualifiers\n|\n| =========== Dataset Commands ====================================\n| DM     ==>> MemberList 3.1\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| LD     ==>> Execute the RACF LISTDSD/LD Command\n|             NO-Block and NO-Multi\n|\n| =========== Dataset Commands ====================================\n| DH     ==>> HSM List command - Display HSM Migrate/Backup\n|             data and give the possibility to\n|             HRECALL or HRESTORE\n|             the selected data - using the EX Line Command\n|             NO-Block and NO-Multi\n|\n| =========== Edit Command     ====================================\n| RU     ==>> Call RU to create a ruler as a note starting at the\n|             current cursor position\n| Example:      X <== Cursor is here when RULER starts\n|               ----+----1----+----2----+----3----+----4----+---...\n| RU# (any number from 1-...) will give the number\n|               ----+---10----+---20----+----30-...--150----+---...\n|             Author: Norbert Haas\n|\n+------------------------------------------------------------------+\n| =========== TSO Commands ========================================\n| EX     ==>> Execute the cmd line - as a tso cmd\n|             NO-Block and NO-Multi\n|             Output will be displayed using ISPF VIEW\n|             TSO is default and has not to be given|\n|             the lines can be continued with a + or a ,\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        execute the command under TSO               |\n|           |                                                    |\n|        -> | EX0002 lista st h                                  |\n|           | 000003 listc ent('a.very.imp.ds') all              |\n|           | 000004 listc ent('a.very.imp.ds') all              |\n|           | 000005 tso listc,                                  |\n|           | 000006     ent('a.very.imp.ds')+                   |\n|           | 000007     all                                     |\n|           +----------------------------------------------------+\n|             see member LMACTSO\n|\n| =========== SDSF Commands =======================================\n| EX     ==>> Execute the cmd line - as a SDSF command like /...\n|             NO-Block and NO-Multi\n|             Output will be displayed using ISPF EDIT\n|             the lines can be continued with a + or a ,\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        execute the command under SDSF              |\n|           |                                                    |\n|           | 000001 sdsf  d a                                   |\n|           | 000002 sdsf  d xcf,str                             |\n|        -> | EX0003 sdsf  d prog,     +                         |\n|           | 000004        lpa, +                               |\n|           | 000005         mod=iefbr14                         |\n|           +----------------------------------------------------+\n|             see member LMACMVS\n|             see member LMACJES2\n|             see member LMACJES3\n|\n| =========== Other Commands ======================================\n| EX     ==>> Execute the cmd line - as an EJES command like /...\n|             NO-Block and NO-Multi\n|             Output will be displayed using ISPF EDIT\n|             the lines can be continued with a + or a ,\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        execute the command under EJES (c)          |\n|           |                                                    |\n|           | 000001 ejes  d a                                   |\n|           | 000002 ejes  d xcf,str                             |\n|        -> | EX0003 ejes  d prog,     +                         |\n|           | 000004        lpa, +                               |\n|           | 000005         mod=iefbr14                         |\n|           +----------------------------------------------------+\n|\n| =========== Unix Commands =======================================\n| EX     ==>> Execute the cmd line - as a UNIX command like Shell\n|             NO-Block and NO-Multi\n|             the command can also be run as a Superuser - if\n|                 authority is given - using the UNIXSU prefix\n|             Output will be displayed using ISPF EDIT\n|             the lines can be continued with a + or a ,\n|                 ||| but here not a directory |||\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        execute the command under Unix USS          |\n|           |                                                    |\n|           | 000018 unix ls                                     |\n|           | 000019 unixsu  ls                                  |\n|        -> | EX0020 unixsu mkdir -m 755 /u/AUTH                 |\n|           | 000021 unix mkdir -m 755 /u/NOTAUTH                |\n|           | 000022 unix ls -l /u/PFA                           |\n|           | 000023 unix ls -l +                                |\n|           | 000024         /u                                  |\n|           +----------------------------------------------------+\n|             see member LMACUSS\n|\n|             Since version 2.11 you can use the\n|             unixenv and unixsuenv\n|             to run the command using the same environment\n|             variables like you would have starting the command\n|             under the OMVS Shell\n|             - this will cost some more overhead|\n|             - the used environment variables will be listed at\n|               the end of the display\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        execute the command under Unix USS          |\n|           |        using the environment variables             |\n|           |                                                    |\n|           | 000018 unixenv javac mypgm.java                    |\n|           +----------------------------------------------------+\n|\n|           +----------------------------------------------------+\n|           |        execute the command under Unix USS          |\n|           |        using the environment variables             |\n|           |        and setting own environment variables       |\n|           | Syntax:                                            |\n|           |   first line only: unixenv +                       |\n|           |   second line eyecatcher: env_variable_start       |\n|           |   many lines with environment variables            |\n|           |   eyecatcher: env_variable_end                     |\n|           |   command line (with continuation if needed)       |\n|           |                                                    |\n|           | 000167 unixenv +                                   |\n|           | 000168 env_variable_start                          |\n|           | 000169 PATH=/usr/lpp/dfsms/bin                     |\n|           | 000170 env_variable_end                            |\n|           | 000171   confighfs +                               |\n|           | 000172   -l                                        |\n|           +----------------------------------------------------+\n|\n| =========== Unix File/Directory List commands ===================\n| EX     ==>> Execute the cmd line - as a UDLIST 3.17 command\n|             the lines can be continued with a + or a ,\n|             NO-Block and NO-Multi\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        display the path using UDLIST - 3.17        |\n|           |                                                    |\n|           | 000039 udlist /u                                   |\n|           | 000040 udlist /u/zfs/YVES                          |\n|        -> | EX0041 udlist /u/zfs      +                        |\n|           | 000042              /YVES +                        |\n|           | 000043        /DIR                                 |\n|           +----------------------------------------------------+\n|             see member LMACUSS\n|\n| =========== Unix Directory Find Commands ========================\n| EX     ==>> Execute the cmd line - as a Unix FIND for a\n|             directory and show all results with UDLIST 3.17\n|             the lines can be continued with a + or a ,\n|                 ||| but here not the directory |||\n|             NO-Block and NO-Multi\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        find and display all directories within     |\n|           |        first parm is path                          |\n|           |        second parm is directory name (also generic)|\n|           |                                                    |\n|           | 000047 ufdir  /u o*                                |\n|        -> | EX0048 ufdir  /u/zfs/YVES *u*                      |\n|           | 000049 * the directory name CANNOT be continued||| |\n|           | 000050 ufdir  /u/zfs/YVES +                        |\n|           | 000051        *I*                                  |\n|           +----------------------------------------------------+\n|             see member LMACUSS\n|\n| =========== Unix File Find Commands =============================\n| EX     ==>> Execute the cmd line - as a Unix FIND for a\n|             file name and show all results with UDLIST 3.17\n|             the lines can be continued with a + or a ,\n|                 ||| but here not the directory |||\n|             NO-Block and NO-Multi\n|             for example with following lines\n|           +----------------------------------------------------+\n|           |        find and display all files within given     |\n|           |        name within a given directoy tree           |\n|           |        first parm is path                          |\n|           |        second parm is file name (also generic)     |\n|           |                                                    |\n|           | 000062 uffil  /u/zfs/YVES +                        |\n|           | 000063        *y*                                  |\n|           | 000064 uffil  /u/zfs/YVES +                        |\n|           | 000065        *                                    |\n|           | 000066 * the directory name CANNOT be continued||| |\n|        -> | EX0067 uffil  /u          +                        |\n|           | 000068        *C*                                  |\n|           +----------------------------------------------------+\n|             see member LMACUSS\n|\n| =========== SA Commands =========================================\n| EX     ==>> Call IBM System Automation commands (need cust of SA)\n|           +----------------------------------------------------+\n|        -> | EX0062 ing inglist                                 |\n|           | 000063 ing inglist ycplex                          |\n|           +----------------------------------------------------+\n|             see member LMACING\n|\n| =========== ISPF Commands =======================================\n| EX     ==>> Execute ISPF functions\n|           +----------------------------------------------------+\n|           | 000062 * ispf diagnosis                            |\n|        -> | EX0063 ispf select cmd(ispvcall)                   |\n|           +----------------------------------------------------+\n|             see member LMACISPF\n|\n| =========== Other Commands ======================================\n| EX     ==>> External call of the EX function:\n|             TSO YCLMACRX tso lista st h\n|             TSO YCLMACRX sdsf d a,l\n|             TSO YCLMACRX ejes d a,l\n|             TSO YCLMACRX unix ps -le\n|             TSO YCLMACRX unixsu ps -le\n|             TSO YCLMACRX udlist /u/zfs/YVES\n|             TSO YCLMACRX ufdir  /u o*\n|             TSO YCLMACRX uffil  /u/zfs/YVES *y*\n|\n| =========== Other Commands ======================================\n| AE     ==>> Ascii -> Ebcdic - simple table\n|             Block: AEE - AEE\n|             Multi: AE#\n| EA     ==>> Ebcdic -> Ascii - simple table\n|             Block: EAA - EAA\n|             Multi: EA#\n|\n| =========== Other Commands ======================================\n| JU     ==>> JCL Upper Case\n|             Block: JUU - JUU\n|             Multi: JU#\n|             Work \"like\" UC but it will not Uppercase\n|             - jcl comment lines\n|             - sysin (not JCL)\n|             - all quoted data, like PATH=, PARM=...\n|\n| =========== General Information =================================\n| H HELP E V EZ VZ DH DI DL DM DS EX CL LD REV FI FL FA\n| are single line commands\n|\n| All othes can be given in the forms\n|     CE5\n|   or\n|     CEE\n|      ...\n|     CEE\n|\n| =========== Usage Hint ==========================================\n| Line Commands could also be defined on PFKs using :xx notation\n| Possible good candidates like :E or :V or :DS and others\n|\n+------------------------------------------------------------------+\n| Vers 2.20  02.03.2018 Yves Colliard                              |\n|            - Extention of YCLMACRX to execute                    |\n|              the RU command - RULER                              |\n| Based on - many thanks to Norbert Haas                           |\n| Name:        RULER                                               |\n| Type:        Macro                                               |\n| Author:      Norbert Haas                                        |\n|              Y$RU member needed                                  |\n+------------------------------------------------------------------+\n+------------------------------------------------------------------+\n| User Line Commands                                               |\n+------------------------------------------------------------------+\n| =========== Dataset Commands ====================================\n| REV    ==>> Call REVIEW to work with dataset\n|             Works also for VSAM dataset (only VIEW)\n|             http://www.prycroft6.com.au/REVIEW/index.html\n|             NO-Block and NO-Multi\n|\n+------------------------------------------------------------------+\n+------------------------------------------------------------------+\n| User Line Commands                                               |\n+------------------------------------------------------------------+\n| =========== Dataset Commands ====================================\n| PDS    ==>> Call PDS to work with PDS\n|             Have to Install PDS\n|             http://cbttape.org    (File 182)\n|\n+------------------------------------------------------------------+\n+------------------------------------------------------------------+\n| User Line Commands                                               |\n+------------------------------------------------------------------+\n| =========== Dataset Commands ====================================\n| PG     ==>> Call PG to wotk with PDSE 2 Generation\n|             Have to Install PDSEGEN\n|             http://www.lbdsoftware.com\n|             http://cbttape.org  (File 969)\n|\n+------------------------------------------------------------------+\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$HELPS": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x19$/\\x01\\x19$/\\x06S\\x00+\\x00+\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-30T00:00:00", "modifydate": "2019-08-30T06:53:10", "lines": 43, "newlines": 43, "modlines": 0, "user": "SLBD"}, "text": "* ----------------------------------------- *\n* SHORT HELP FOR THE YCL EDIT LINE COMMANDS *\n* ----------------------------------------- *\nH      ==>> Show help as note\nHV     ==>> Show help as view\nRV     ==>> Reverse the line text\nCE     ==>> Center the line text (CEE-CEE, CE#)\nAL     ==>> Align Left the line text (ALL-ALL, AL#)\nAR     ==>> Align Right the line text (ARR-ARR, AR#)\nAU     ==>> Align Up the line text as the previous line (AUU-AUU, AU#)\nAD     ==>> Align Down the line text as the next line (ADD-ADD, AD#)\nYD     ==>> Hex one line as note (in data form) (YDD-YDD, YD#)\nCL     ==>> Compare lines\nCM     ==>> Comment/uncomment lines (CMM-CMM, CM#)\nLN     ==>> Display the number of characters of variable length (LNN-LNN, LN#)\nTOPD   ==>> Delete all lines from here to the top\nBOTD   ==>> Delete all lines from here to the bottom\nTOPX   ==>> eXclude all lines from here to the top\nBOTX   ==>> eXclude all lines from here to the bottom\nFI     ==>> FindFirst where the cursor is placed - or first word\nFL     ==>> FindLast  where the cursor is placed - or first word\nFA     ==>> FindAll   where the cursor is placed - or first word\nE      ==>> Edit the dataset\nEZ     ==>> Edit the dataset in new Split Screen\nV      ==>> View the dataset\nVZ     ==>> View the dataset in new Split Screen\nDA     ==>> Dataset allocation like - JCL and TSO Allocate\nDI     ==>> DSINFO the dataset\nDL     ==>> LISTCAT the dataset\nDS     ==>> DSLIST the dataset 3.4\nDX     ==>> DSLIST first n Qualifiers 3.4 (DX#)\nDZ     ==>> DSLIST first n Qualifiers 3.4 in new Split Screen (DZ#)\nDM     ==>> MemberList 3.1\nLD     ==>> Execute the RACF LISTDSD/LD Command\nDH     ==>> HSM List command - Display HSM Migrate/Backup\nRU     ==>> Call RU to create a ruler as a note starting at the\nEX     ==>> Execute the cmd line - as a tso cmd\nAE     ==>> Ascii -> Ebcdic - simple table (AEE-AEE, AE#)\nEA     ==>> Ebcdic -> Ascii - simple table (EAA-EAA, EA#)\nJU     ==>> JCL Upper Case (JUU-JUU, JU#)\nREV    ==>> Call REVIEW to work with dataset\nPDS    ==>> Call PDS to work with PDS\nPG     ==>> Call PG to wotk with PDSE 2 Generation\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$INST": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x18\\x14/\\x01\\x18\\x14/\\x18\\x18\\x00.\\x00.\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2018-05-22T18:18:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "YCLMAC"}, "text": "//*\n//* YCOS YVES COLLIARD SOFTWARE - WWW.YCOS.DE\n//*\n//* YCLMAC\n//* A COLLECTION OF USER LINE COMMANDS FOR USE IN ISPF EDIT AND VIEW\n//*\n//*             <- CUSTOMIZE TO YOUR HLQ\n//*                        <- CUSTOMIZE FOR THIS VERSION\n//   SET LMACIN=HLQ.YCLMAC.V???.REXX\n//*\n//*              <- CUSTOMIZE TO YOUR ISPF TABLE LIBRARY\n//   SET LMACTAB=YOUR.TABLE.LIBRARY\n//*\n//*               <- CUSTOMIZE TO YOUR ISPF SYSPROC/SYSEXEC\n//   SET LMACREXX=YOUR.SYSPROC.SYSEXEC\n//*\n//*  COPY THE TABLE MEMBER TO YOUR ISPF TABLE LIBRARY\n//STEP     EXEC PGM=IEBCOPY\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  DISP=SHR,DSN=&LMACIN\n//SYSUT2   DD  DISP=SHR,DSN=&LMACTAB\n//SYSIN    DD  *\n     COPY INDD=((SYSUT1,R)),OUTDD=SYSUT2\n     SELECT  MEMBER=(YCLMACTB)\n/*\n//*  COPY THE REXX TO YOUR ISPF SYSPROC/SYSEXEC\n//STEP     EXEC PGM=IEBCOPY\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  DISP=SHR,DSN=&LMACIN\n//SYSUT2   DD  DISP=SHR,DSN=&LMACREXX\n//SYSIN    DD  *\n     COPY INDD=((SYSUT1,R)),OUTDD=SYSUT2\n     SELECT  MEMBER=(YCLMACDS,                                         X\n                     YCLMACHG,                                         X\n                     YCLMACLM,                                         X\n                     YCLMACNS,                                         X\n                     YCLMACRX,                                         X\n                     YCLMAHLP,                                         X\n                     YCLMAHLU,                                         X\n                     Y$CL,                                             X\n                     Y$HC,                                             X\n                     Y$RU,                                             X\n                     Y$REV,                                            X\n                     Y$PDS,                                            X\n                     Y$PG)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE961": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x008\\x01\\x19$/\\x01\\x19$/\\x14\\x05\\x00N\\x00N\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-08-30T00:00:00", "modifydate": "2019-08-30T14:05:38", "lines": 78, "newlines": 78, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 961 is from Yves Colliard and contains a collection of    *   FILE 961\n//*           ISPF commands which can be added to your session.     *   FILE 961\n//*                                                                 *   FILE 961\n//*     YCLMAC - A collection of user line commands for use in      *   FILE 961\n//*              ISPF Edit and View                                 *   FILE 961\n//*                                                                 *   FILE 961\n//*     by YCOS Yves Colliard Software - www.ycos.de                *   FILE 961\n//*     and many others                                             *   FILE 961\n//*                                                                 *   FILE 961\n//*     Installation:                                               *   FILE 961\n//*                                                                 *   FILE 961\n//*     1. Copy YCLMACTB into ISPTLIB library                       *   FILE 961\n//*     2. Copy REXX others into SYSEXEC or SYSPROC library         *   FILE 961\n//*     3. Update ISPF site customization table (ISPFC) (z/OS 2.2)  *   FILE 961\n//*        GLOBAL_LINE_COMMAND_TABLE = YCLMACTB                     *   FILE 961\n//*     4. If using (E)JES instead of SDSF change the LMACJES2/3    *   FILE 961\n//*        members from sdsf to ejes                                *   FILE 961\n//*                                                                 *   FILE 961\n//*     Members of this dataset:                                    *   FILE 961\n//*                                                                 *   FILE 961\n//*        $$$DOC           This member that you are reading        *   FILE 961\n//*        $$$HELP          A copy of the HELP information          *   FILE 961\n//*        $$$HELPS         A short reference \"card\" of commands    *   FILE 961\n//*                                                                 *   FILE 961\n//*     Rexx to be added to SYSEXEC/SYSPROC                         *   FILE 961\n//*        YCLMACDS         REXX to extract DSN from records        *   FILE 961\n//*        YCLMACHG         Summary of Changes                      *   FILE 961\n//*        YCLMACLM         REXX to get messages                    *   FILE 961\n//*        YCLMACNS         REXX to support split screen functions  *   FILE 961\n//*        YCLMACRX         REXX to process new line commands       *   FILE 961\n//*        YCLMAHLP         REXX to display help information        *   FILE 961\n//*        YCLMAHLU         REXX to display user extensions         *   FILE 961\n//*                         help information                        *   FILE 961\n//*        Y$CL             REXX to compare members                 *   FILE 961\n//*        Y$HC             REXX short help                         *   FILE 961\n//*                                                                 *   FILE 961\n//*     ISPF Table - must be copied to ISPTLIB                      *   FILE 961\n//*        YCLMACTB         ISPF Table of Line Commands             *   FILE 961\n//*                                                                 *   FILE 961\n//*     Rexx Additional commands - extra installation needed        *   FILE 961\n//*     Rexx to be added to SYSEXEC/SYSPROC if needed               *   FILE 961\n//*        Y$REV            REXX to interface to Greg Price's       *   FILE 961\n//*                         REVIEW command                          *   FILE 961\n//*        Y$PDS            REXX to interface to the PDS command    *   FILE 961\n//*        Y$PG             REXX to interface to Lionel Dyck's PDSEGEN  FILE 961\n//*        YCLMACT          REXX to support user line command       *   FILE 961\n//*                         table extensions                        *   FILE 961\n//*                                                                 *   FILE 961\n//*     Samples to run EX command                                   *   FILE 961\n//*        LMACJES2         Sample JES2 commands for use with EX    *   FILE 961\n//*        LMACJES3         Sample JES3 commands for use with EX    *   FILE 961\n//*        LMACMVS          Sample MVS (SDSF/EJES) commands for     *   FILE 961\n//*                         use with EX                             *   FILE 961\n//*        LMACTSO          Sample TSO commands for use with EX     *   FILE 961\n//*        LMACUSS          Sample OMVS commands for use with EX    *   FILE 961\n//*        LMACING          Sample System Automation cmds use       *   FILE 961\n//*                         with EX                                 *   FILE 961\n//*        LMACISPF         Sample ISPF commands use with EX        *   FILE 961\n//*                                                                 *   FILE 961\n//*     Sample coding for own application                           *   FILE 961\n//*        YLM01            Sample application using own line       *   FILE 961\n//*                         commands                                *   FILE 961\n//*        YLM02            Sample application using own line       *   FILE 961\n//*                         commands                                *   FILE 961\n//*                                                                 *   FILE 961\n//*     Addition of user/local commands:                            *   FILE 961\n//*                                                                 *   FILE 961\n//*        1. Update YCLMACT with the name of the new command       *   FILE 961\n//*           - Update at the bottom in the User Command section    *   FILE 961\n//*           - Follow the coding examples in YCLMACT               *   FILE 961\n//*        2. Run the REXX YCLMACT to replace the line command      *   FILE 961\n//*           table YCLMACTB                                        *   FILE 961\n//*        3. Copy YCLMACTB into the ISPTLIB library                *   FILE 961\n//*        4. Create a REXX Exec Y$xxx                              *   FILE 961\n//*           - where xxx is the 1-6 character name of the new      *   FILE 961\n//*             command                                             *   FILE 961\n//*        5. Update YCLMAHLU to document the new command           *   FILE 961\n//*                                                                 *   FILE 961\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMACING": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x18\\x14/\\x01\\x18\\x14/\\x18\\x18\\x004\\x004\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2018-05-22T18:18:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "YCLMAC"}, "text": "* System Automation Commands - 31.08.2017\n* Samples for the EX ING ...\n*                           line command from YCLMACRX\n* all commands can also be called from outside EDIT/VIEW:\n* TSO YCLMACRX ing ...\n* This way could also be used in a Rexx Batch|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2017-18                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*|            - Extention of YCLMACRX to execute                    |*/\n/*|              SA System Automation Commands                       |*/\n/*|              |||| SUPPORT MUST BE ENABLED WITHIN SA ||||||       |*/\n/*|              SA System Automation is an IBM product              |*/\n/*+------------------------------------------------------------------+*/\n\n\n\ning inglist\ning inglist ycplex\n\n\n                                    .-SERVER--=--EVJCMDRV-.\n>>-AOFRYCMD--+------+--+---------+--+---------------------+----->\n             '-wsid-'  '-NOWKSTS-'  '-SERVER--=--+-name-+-'\n                                                 '-*----'\n   .-TIMEOUT--=--60------.  .-HIGHRC--=--0-----------.\n>--+---------------------+--+------------------------+---------->\n   +-TIMEOUT--=--seconds-+  '-HIGHRC--=--return_code-'\n   '-TIMEOUT--=--NONE----'\n   .-MAXRC--=--999---------.  .-SYSIN--=--SYSIN--.\n>--+-----------------------+--+------------------+-------------->\n   '-MAXRC--=--return_code-'  '-SYSIN--=--DDname-'\n   .-REDIRECT--=-->-----.  .-ASIS--=--NO--.\n>--+--------------------+--+--------------+--------------------><\n   '-REDIRECT--=--chars-'  '-ASIS--=--YES-'\n\n\n\n   If the name of the rexx of System Automation is not:\n     SYS1.ING.SINGTREX\n   then you have to create a rexx YCINGCUS in your SYSPROC/\n   SYSEXEC concatenation with following content:\n/* Rexx YCINGCUS */\n/* User customized System Automation Call              */\n/* Define the name of the dataset containing the Rexx: */\n/*        AOFRYCMD                                     */\n/* Default is: SYS1.ING.SINGTREX                       */\npush \"MY.DATA.SET\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMACISPF": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x13\\x00\\x00\\x01\\x17$?\\x01\\x17$?\\x081\\x00g\\x00g\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.19", "flags": 0, "createdate": "2017-08-31T00:00:00", "modifydate": "2017-08-31T08:31:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "YCLMAC"}, "text": "* ISPF Commands - 31.08.2017\n* Samples for the EX ISPF ...\n*                           line command from YCLMACRX\n* will call \"ADDRESS ISPEXEC\" ...\n* EXCEPTION:\n* ispf REFRESH PANEL(...)\n*      will allow you to refresh a panel without 7.2|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2017-17                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n\n* ispf diagnosis\nispf select cmd(ispvcall)\n\n* ispf panel trace\nispf select cmd(ispdptrc panel(yc*))\n* do not display start and termination messages\n* \u00c4QUIET\u00dc\n* control of amount of trace\n* \u00c4DSP]DISPLAY(None ] In ] Out ] Both) \u00dc \u00c4READ(None ] Summary ] Detail) \u00dc\n* \u00c4SVC]SERVICE(None ] Detail) \u00dc\n* selection/filtering\n* \u00c4PNL]PANEL(* ] panel_name ] panel_mask) \u00dc\n* \u00c4SCR]SCREEN(0 ] * ] screenid)\u00dc\n* \u00c4SECT]SECTION(* ] All ] None ] \u00c4Init\u00dc \u00c4Reinit\u00dc \u00c4Proc\u00dc ]\n* \u00c4NOInit\u00dc \u00c4NOReinit\u00dc \u00c4NOProc\u00dc) \u00dc\n* end trace and/or optionally view trace\n* \u00c4VIEW\u00dc \u00c4END\n\n* ispf panel trace results\nispf select cmd(ispdptrc)\n\n* ispf file tailoring trace\nispf select cmd(ispdftrc SKL(yc*))\n* do not display start and termination messages\n* \u00c4QUIET\u00dc\n* control of amount of trace\n* \u00c4READ(None ] Summary ] Detail) \u00dc\n* \u00c4SVC]SERVICE(None ] Detail) \u00dc\n* \u00c4TBV]TBVARS(None ] Detail) \u00dc\n* selection/filtering\n* \u00c4SKL]SKEL]SKELETON(* ] skel_name ] skel_mask) \u00dc\n* \u00c4SCR]SCREEN(0 ] * ] screenid)\u00dc\n* \u00c4REC]RECORDS(* ] All ] None ]\n* \u00c4Src]Source\u00dc \u00c4Data\u00dc \u00c4Cntl\u00dc ] \u00c4NOSrc\u00dc \u00c4NOData\u00dc \u00c4NOCntl\u00dc) \u00dc\n* end trace and/or optionally view trace\n* \u00c4VIEW\u00dc \u00c4END\u00dc\n\n* ispf panel file tailoring results\nispf select cmd(ispdftrc)\n\n* ispf display panel\nispf select panel(isr@prim)\n\n* ispf VERY IMPORTANT|||||\n* ispf VERY IMPORTANT|||||\n* ispf use the NON EXISTENT refresh option to get a new copy\n*      of the panel| many thanks to Gilbert Saint-Flour| (RIP)\nispf refresh panel(yvespan)\n\n* ispf display panel\nispf display panel(isr@prim)\n\n* ispf configuration\nispf select cmd(ispcconf)\n\n* ispf Dataset list DDLIST\nispf SELECT PGM(ISRDDN) NEWAPPL(ISR) SUSPEND SCRNAME(DDLIST)\n\n* ispf LIBDEF Display\nispf SELECT PGM(ISPLLS) SCRNAME(LIBDEF)\n\n* ispf SAREA\nispf SELECT PGM(ISPSAM) PARM(POP)\n\n* ispf SETTINGS\nispf SELECT PGM(ISPISM) SUSPEND SCRNAME(SETTINGS)\n\n* ispf Start new split screen with...\nispf SELECT PGM(ISPSTRT) +\n     PARM(SD;ST)\n\n* ispf UDLIST ...\nispf SELECT PGM(ISRDSLST) PARM(UDL +\n     /u/fzi5297 +\n     ) SUSPEND SCRNAME(UDLIST)\n\n* ispf DSLIST ...\nispf SELECT PGM(ISRDSLST) PARM(DSL +\n     YCOS.CNTL +\n     ) SUSPEND SCRNAME(DSLIST)\nispf SELECT PGM(ISRDSLST) PARM(DSL +\n     'SYS1.PARM*' +\n     ) SUSPEND SCRNAME(DSLIST)\n\n* ispf edit\nispf edit dataset(ycos.cntl(newone))\n\n* ispf view\nispf view dataset(ycos.cntl(newone))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMACJES2": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x161\\x9f\\x01\\x161\\x9f\\x17\\x17\\x01\\xc1\\x01\\xc1\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2016-11-14T00:00:00", "modifydate": "2016-11-14T17:17:00", "lines": 449, "newlines": 449, "modlines": 0, "user": "YCLMAC"}, "text": "* JES2 Commands - 14.11.2016\n* Samples for the EX (SDSF/EJES) line command from YCLMACRX\n* If you use EJES change all SDSF EJES in column 1\n* all commands can also be called from outside EDIT:\n* TSO YCLMACRX sdsf $D I\n* This way could also be used in a Rexx Batch|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n\n* Console and Display MAX\n* $HASP003 RC=(57),........ - DISPLAY TERMINATED DUE TO\n* $HASP003         EXCESSIVE OUTPUT (AS DEFINED BY CONDEF DISPMAX)\nsdsf $D CONDEF\nsdsf $T CONDEF,DISPMAX=###\n* Changes will AFFECT ALL COMMANDS|\n\n* Start JES2 activities (NOREQ)\n* $HASP400 ENTER REQUESTS\nsdsf $S\n\n* Stop JES2 activities (Initiator, Printer, Puncher, Job Trans...)\nsdsf $P\n* $HASP623 MEMBER DRAINING\n* $HASP099 ALL AVAILABLE FUNCTIONS COMPLETE\n\n* Display JES2 activities (z/OS>1.8):\nsdsf $D JES2\n* $HASP608 ALL AVAILABLE FUNCTIONS COMPLETE\n* or see $PJES2\n* ACTIVE PROCESSORS (PCES)\n* ACTIVE ADDRESS SPACES\n* ACTIVE NETWORKING DEVICES\n* HELD PROCESSORS\n* ALLOCATED INTERNAL READERS\n* OUTSTANDING CROSS MEMBER REQUESTS\n* OUTSTANDING BERT LOCK REQUESTS\n* INTERNAL ACTIVITY\n\n* Stop JES2\nsdsf $P JES2\u00c4,ABEND\u00c4,FORCE\u00dc]QUICK]TERM\u00dc\n* see $DJES2\n* ABEND:\n*$HASP095 JES2 CATASTROPHIC ERROR.  CODE = $PJ2\n*$HASP198 REPLY TO $HASP098 WITH ONE OF THE FOLLOWING: 417\n*  END            - STANDARD ABNORMAL END\n*  END,DUMP       - END JES2 WITH A DUMP (WITH AN OPTIONAL TITLE)\n*  END,NOHOTSTART - ABBREVIATED ABNORMAL END (HOT-START IS AT RISK)\n*  SNAP           - RE-DISPLAY $HASP088\n*  DUMP           - REQUEST SYSTEM DUMP (WITH AN OPTIONAL TITLE)\n*## $HASP098 ENTER TERMINATION OPTION\n\n* Display Jobclass\nsdsf $D JOBCLASS\nsdsf $D JOBCLASS(A)\nsdsf $D JOBCLASS(A),LONG\n\n* Display Initiators\nsdsf $D I\nsdsf $D I(5),LONG\nsdsf $D I,C=*A*\n* Display Initiators serving class A and INACTIVE - waiting on job\nsdsf $D I,/C=*A*,/STATUS=INACTIVE\n* Display Initiators serving class A and ACTIVE - serving a job\nsdsf $D I,/C=*A*,/STATUS=ACTIVE\n\n* start Initiators - previous Status DRAINED or HALTED\nsdsf $S I(5)\n\n* hold Initiators - Status HALTING -> HALTED\nsdsf $Z I(5)\n\n* stop Initiators - Status DRAINING -> DRAINED\nsdsf $P I(5)\n\n* change Initiators\nsdsf $T I(5),CLASS=Z\n\n* Display Information About Currently Active Jobs\nsdsf $D A\n* Started Tasks\nsdsf $D A,S\n* TSO Users\nsdsf $D A,T\n* Executing\nsdsf $D A,XEQ\n* Executing on system SYS1\nsdsf $D A,XEQ,SYS1\n\n* Display Information About Specified Jobs\nsdsf $D Job\n*  Job Selection:\n     $DJnnnn $DSnnnn $DTnnnn\n     $DJnn-mm $DSnn-mm $DTnn-mm nn-*\n     $DJ'jobname' or $DJ(jobname)\n     $DJQ,JM=mask Mask: ? *\n*  Other Selection/Display:\n     ,ARM_element]CANCEL]PURGE]REBUILD \u00c4=][=Yes]No\u00dc\n     ,CMDauth]OFFS]SCHENV_AFF]Sysaff]XEQNode \u00c4=][=sel_parm\u00dc\n     ,CARDS]Class]INITASID]Priority]SCHENV]SECLABEL]\n     SRVCLASS]USERID \u00c4=][=]<]>sel_parm\u00dc\n     ,Age]DAys]Hours \u00c4<]>sel_parm\u00dc\n     ,CC\u00c4=(ABEND\u00c4=][=system]user\u00dc]ABENDED]CANcelled]CNVT_abend]\n     CODE\u00c4=][=]<]>condcode\u00dc]COMPleted]ENDed_by_cc]\n     EOM_failure]JCLerror]SECurity_failure)\u00dc\n     ,DELAY\u00c4=][=BUSY_ON_DEVICE]HOLD]LIMIT]LOCKED]No]SCHENV]\n     SPOOLS_NOT_AVAILABLE]SYSAFF]MEMBER_STATUS]Yes\n     ,HOLD\u00c4=][=ALL]ARM]DUP]JOB]NONE\u00dc\n     ,Queue\u00c4=][=CNV]INPUT]OUT]PPU]PURGE]RCV]SETUP]SPIN]XEQ]XMT\u00dc\n     ,SPooL\u00c4=(%]Percent]Tgs]Volumes\u00c4<]>]=][=value)\u00dc\n     ,TYPE\u00c4=][=JOB]STC]TSU\u00dc\n     ,JC]JOBCORR=sys:usr\n     ,HOLDUNTL\n     ,JOBGROUP\n     ,STARTBY\n     ,WITH\n*  Other Display:\n     ,STATUS\n     ,LONG\n\n* Long job display\nsdsf $D JOBQ,JM=THISJOB\n* age of job\nsdsf $D JOBQ,JM=THISJOB,AGE\n* job spool usage over 2%\n$DJQ,SPL=(%>2)\n* use L=Z to see job numbers - using generic name\nsdsf $D JOBQ,JM=TH?SJOB*,L=Z\n* jobs abended\nsdsf $DJQ,CC=ABENDED\n* jobs abended with system abend 806\nsdsf $DJQ,CC=ABEND=S806\n* jobs abended with user abend 123\nsdsf $DJQ,CC=ABEND=(S000,U0123)\n* jobs abended with system abend 22\nsdsf $DJQ,CC=ABEND=*22\n* jobs with condition code > 4\nsdsf $DJQ,CC=CODE>4\n* job display with Hold and Delay reason\nsdsf $DJ'J201A',HOLD,DELAY\n\n* Release Held Jobs - selection see $DJ\nsdsf $A Job\n\n* Hold Specific Jobs - selection see $DJ\nsdsf $H Job\n\n* Cancel a Job - selection see $DJ\nsdsf $C Job\n* with dump\nsdsf $C Job,Dump\n* purge output\nsdsf $C Job,Purge\n* use ARMRESTART policy\nsdsf $C Job,ARMRESTART\n\n* Purge a Job - selection see $DJ\nsdsf $P Job\n\n* Change a Job - selection see $DJ\nsdsf $T Job\n* Class\nsdsf $T Job,C=class\n* Priority\nsdsf $T Job,P=\u00c4+]-\u00dcn\n* Affinity\nsdsf $T Job,S=\u00c4+]-\u00dcsys\n* Scheduling Environment\nsdsf $T Job,SCHENV=sch\n* Service Class\nsdsf $T Job,SRVCLASS=s\n\n* Duplicate jobs\nsdsf $D DUPJOB\n\n* Initiate a Batch Job into Execution - RUN\nsdsf $S Jnnn]'jobname'\n\n* Restart a job - BE VERY CAREFUL|\nsdsf $E Job,C\n* will: $H - HOLD THE JOB\n*       $E - REQUEUE THE JOB FOR EXECUTION\n*       $C - CANCEL THE JOB FOR RERUN\n\n* Send a Message to Job Log\n* only Job: Jn,Sn,Tn,'jobname'\n* Only Job executing\nsdsf $D M Job,'msg'\nsdsf $DMJ84,'YCOS Message to User'\n18.25.27 JOB00084 IEF403I JC90A - STARTED - TIME=18.25.27\n...\n18.27.03 JOB00084 MSG FROM OPER: 'YCOS MESSAGE TO USER'\n\n* Display the Number of Jobs Queued\nsdsf $D Q\u00c4,sys\u00dc\u00c4,Q=q\u00dc\n* Display the Number of Jobs Waiting for execution in Class H\nsdsf $D Q,Q=XEQH\n\n* Display Job Queue Information\nsdsf $D N\u00c4,sys\u00dc\u00c4,Q=q\u00dc\n* waiting on converstion\nsdsf $D N,Q=CNV\n* waiting execution class A\nsdsf $D N,Q=XEQA\n\n* Display Output Classes\nsdsf $D OUTCLASS\n\n* Display Job Output Characteristics - many section and display parms\nsdsf $D O Job\nsdsf $DOJQ,JM=YVES,LONG\nsdsf $DOJQ,JM=YVES,ALL\nsdsf $DOJQ,JM=YVES,CRTIME\nsdsf $DOJQ,JM=YVES,STATUS\n\n* Change Job Output\nsdsf $T O Job\n* new output class\nsdsf $TOJ1472,ALL,Q=F\n* new output form\nsdsf $TOJ'MEINJOB',ALL,F=A4QW\n* new output class for a range of jobs\nsdsf $TOT4123-4200,ALL,Q=B\n* all output for job MEIN* will be changed from Outdisp=Hold to Write\nsdsf $TOJQ,JM=MEIN*,/OUTD=H,OUTD=W\n* delete all output older than 5 days in class Z\nsdsf $TOJQ,A>5,OUTD=P,Q=Z\n\n* Release Job Output\nsdsf $O O Job\n\n* Cancel Job Output\nsdsf $C O Job\n\n* Purge Job Output\nsdsf $P O Job\n\n* Display Spool\nsdsf $D SPL\n* Display Spool all volumes\nsdsf $D SPL,ALL\n* job spool usage over 2%\nsdsf $DJQ,SPL=(%>2)\n\n* Automatic Commands\n* Display, Specify, and Modify Automatic Commands\nsdsf $T Acccc]A,ALL\n* Display all automatic commands\nsdsf $T A,ALL\n\n* Set automatic command\nsdsf $T Acccc\u00c4,I=ssss]T=hh.mm\u00dc,'command\u00c4;command\u00dc'\n* every 60 seconds $DA,X\nsdsf $T A7,I=60,'$DA,X'\n* stop init 5 at 12:30\nsdsf $T A9,T=12.30,'$PI5'\n* every 10 seconds an MVS Command D T\nsdsf $TA,I=10,'$VS,''D T'''\n\n* Cancel one or all automatic command\nsdsf $C Acccc]A,ALL\n* Cancel automatic Command 7\nsdsf $C A7\n\n* Start all Automatic Commands\nsdsf $S A,ALL\n\n* Halt all Automatic Commands\nsdsf $Z A,ALL\n\n* Job Groups -----------------------------------------------------------\n\nsdsf $D G###\nsdsf $D G###-###\nsdsf $D G'YVESGRP1'\nsdsf $D G'YVESGRP1',LONG\n\n* List of Jobs\nsdsf $D G###,JOBS\n* List of Jobs with full job group detail\nsdsf $D G###,JOBF\n* List of Jobs with job group dependency\nsdsf $D G###,DEP\n* List of Jobs with job group concurrent\nsdsf $D G###,CON\n* List of Jobs with job group erros\nsdsf $D G###,INERROR\n\n* Work with groups\nsdsf $A/H/P/C G###\n\n* Display Group Definitions (Sysprog)\nsdsf $D GRPDEF\n \u00c4,ZJCNUM\u00dc\u00c4,ZJCWARN\u00dc\u00c4,CONCURRENT_MAX\u00dc\u00c4,JOBGROUP_JOB_MAX\u00dc\u00c4,ZJCUSE\u00dc\u00c4,ZJCFREE\u00dc\n\n* mostly SYSPROG -------------------------------------------------------\n* mostly SYSPROG -------------------------------------------------------\n\n* MAS\nsdsf $D MASDEF\n\n* Members\nsdsf $D MEMBER\nsdsf $D MEMBER(1)\nsdsf $D MEMBER,NAME=YVES\nsdsf $D MEMBER,NAME=YV*\n\n* Checkpoint\nsdsf $D CKPTDEF\n\nsdsf $D CKPTSPACE\nsdsf $D CKPTSPACE,BERTUSE\nsdsf $JD HISTORY(BERT)\n\n* Display Spool\nsdsf $D SPL\n* Display Spool all volumes\nsdsf $D SPL,ALL\n* job spool usage over 2%\nsdsf $DJQ,SPL=(%>2)\n* Display Spool definition\nsdsf $D SPOOLDEF\nsdsf $D SPOOLDEF,GCRATE\n* Change Spool Garbage collector\nsdsf $T SPOOLDEF,GCRATE=FAST\nsdsf $T SPOOLDEF,GCRATE=NORMAL\n* Display Unitdata information of spool\nsdsf $D SPL,V=SPOOYB,UNITDATA\n\n* Proclib\nsdsf $D PROCLIB(*)\nsdsf $D PROCLIB(*),STATIC\u00c4=YES]NO\u00dc\nsdsf $ADD PROCLIB(YVES),DD1=DSN=YVES.PROCLIB\nsdsf $T   PROCLIB(YVES),DD2=DSN=SYS1.PROCLIB\nsdsf $DEL PROCLIB(YVES)\nsdsf $DEL PROCLIB(YVES),/DD2=DSN=SYS1.PROCLIB\n\n* PCE - Processor Controller Element\nsdsf $D PCEDEF\nsdsf $JD DETAILS\nsdsf $D PCE\n\n* Exit Display\nsdsf $D EXIT\nsdsf $D EXIT,/STATUS=ENABLED\nsdsf $D EXIT(40)\nsdsf $D EXIT(40),LONG\n* Exit Change\nsdsf $T EXIT(40),STATUS=ENABLED\nsdsf $T EXIT(40),STATUS=DISABLED\nsdsf $T EXIT(40),ROUTINE=\u00c4+/-\u00dcroutine\nsdsf $T EXIT(40),REFRESH\nsdsf $D   LOADMOD(loadmod)\nsdsf $D   LOADMOD(loadmod),LONG\nsdsf $ADD LOADMOD(loadmod),STORAGE=PVT/PRIVATE/CSA/LPA\nsdsf $DEL LOADMOD(loadmod)\nsdsf $T   LOADMOD(loadmod),REFRESH\n\n* Output Default\nsdsf $D OUTDEF\n\n* Output Control\nsdsf $D ESTLNCT\nsdsf $T ESTLNCT,NUM=120,INT=240000\n\n* Initiators\nsdsf $D INITDEF\n\n* Output priority\nsdsf $D OUTPRTY\n\n* Output classes\nsdsf $D OUTCLASS\nsdsf $D OUTCLASS(J)\nsdsf $D OUTCLASS(*)\nsdsf $D OUTCLASS(I)\nsdsf $T OUTCLASS(I),OUTDISP=(HOLD,HOLD)\nsdsf $T OUTCLASS(I),OUTDISP=(WRITE,WRITE)\n\n* Internal Reader\nsdsf $D INTRDR\nsdsf $D RDI\n\n* Jobclass\nsdsf $D JOBCLASS\nsdsf $D JOBCLASS(nn)\nsdsf $D JOBCLASS(A),LONG\nsdsf $T JOBCLASS(nn),\n\n* Job default\nsdsf $D JOBDEF\nsdsf $T JOBDEF,RANGE=(1-999999)\n\n* Printer default\nsdsf $D PRINTDEF\n\n* NJE - Network Job Entry\n* NJE Definition\nsdsf $D NJEDEF\n* NJE Node\nsdsf $D NODE(1)\n* NJE Netserver\nsdsf $D NETSERV\nsdsf $S NETSERV1\nsdsf $P NETSERV1\n* NJE Socket\nsdsf $D SOCKET\nsdsf $SN SOCKET=mysock\n* NJE Line\nsdsf $D LINE(1)\nsdsf $S LINE(1)\nsdsf $P LINE(1)\n* NJE overall\nsdsf $D NETwork\nsdsf $S NETwork\nsdsf $P NETwork\n\n* show JES2 start information\n$D INITINFO\u00c4,STARTCMD\u00dc\u00c4,HASPPARM\u00dc\u00c4,STEPLIB\u00dc\n* Monitoring\n* Display non-severe incident report\nsdsf $JDJES\n\n* Display current status\nsdsf $JDSTATUS\n\n* Display details summary of jobs\nsdsf $JDDETAILS \u00c4(RESOURCE/MAIN/WAIT/ERROR/STORAGE)\u00dc\nsdsf $JDDETAILS(MAIN)\n\n* Display history of JES2 resource usage\nsdsf $JDHISTORY \u00c4(MAIN/BERT/BSCB/BUFX/CKVR/CMBS/ERROR/ICES/JNUM/\n                 JOES/JQES/LBUF/NHBS/SMFB/TGS/TTAB/VTMB)\u00dc\n                \u00c4Hours=72\u00dc\nsdsf $JDHISTORY(JQES,JOES,TGS),HOURS=24\n* Display current status of JES2 monitor subtasks\nsdsf $JDMONITOR\n\n* Terminate monitor address space\n* automatic restart\nsdsf $JSTOP\n\n* how you can write commands:\n\nsdsf $ D I N T R D R\nsdsf $D/*good sample*/JQ\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LMACJES3": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0e\\x00\\x00\\x01\\x14 ?\\x01\\x14 ?\\x14\\x14\\x00l\\x00l\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.14", "flags": 0, "createdate": "2014-07-22T00:00:00", "modifydate": "2014-07-22T14:14:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "YCLMAC"}, "text": "* JES3 Commands - 17.04.2014\n* Samples for the EX (SDSF) line command from YCLMACRX\n* all commands can also be called from outside EDIT:\n* TSO YCLMACRX sdsf *i main=all\n* This way could also be used in a Rexx Batch|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-14                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n\n* Mains\nsdsf *i main=all\nsdsf *i main=all,x\n\n* inquiry and change device\nsdsf *i d d=0E00\nsdsf *i d d=0E00,sy1\nsdsf *i d d=sy1\nsdsf *F V 0E00,ONLINE\nsdsf *v sy1,off\nsdsf *v sy1,on\n\n* inquiry setup\nsdsf *i s\n* inquiry setup allocation\nsdsf *i s a\nsdsf *i s a,J=64420\nsdsf *i s de=yves.data.set\nsdsf *i s v=vol???,e\nsdsf *i s,a,summ\n* inquiry setup error\nsdsf *i s e\nsdsf *i s e,J=62966\nsdsf *x display,j=64440\nsdsf d u,vol=vol001\n\n* inquiry GMS\n*             all groups\nsdsf *i g sy1 g\n*             group DFLT\nsdsf *i g sy1 g dflt\n*             all classes\nsdsf *i g sy1 c\n*             class Y\nsdsf *i g sy1 c y\nsdsf *i c=y\n\n* modify GMS\n*             group DFLT OFF\nsdsf *f g sy1 g dflt off\n*             group DFLT Init change\nsdsf *f g sy1 g dflt init 5\n*             class Y OFF\nsdsf *f g sy1 c y off\n\n* job queues\nsdsf *i b\nsdsf *i b,sy1\nsdsf *i b,g=dflt\nsdsf *i q,g=dbms\nsdsf *i q,g=dflt\n\n* job\nsdsf *i j=1245\nsdsf *i j=jobn*\nsdsf *i j=j?bn*\nsdsf *i j=test*,w,x\nsdsf *x display,j=1245\n* job active\nsdsf *i a\nsdsf *i a,sy1\nsdsf *i a,g=dflt\n* job changes\n*              new Class\nsdsf *f j=????,C=?\n*              new Service Class\nsdsf *f j=????,SRVCLASS=?\n*              Run a job wainting on a WLM Inititor\nsdsf *f j=????,RUN\n*              Put a message in the joblog\nsdsf *f j=64440,MSG='Das ist lustig'\n* job cancel\nsdsf *f j=?????,C\nsdsf *f j=?????,C,DUMP\n* job cancel P=Print O=Output\nsdsf *f j=?????,CP\nsdsf *f j=?????,CO\n\n* spool\nsdsf *i q dd=all\nsdsf *i q s\n*                Top usage\nsdsf *i q sp=all,U\n\n* output\nsdsf *i u cl=?\nsdsf *i u q=wtr,cl=?\nsdsf *i u q=hold,cl=?\nsdsf *i u q=hold,cl=?,j=?,n=ALL\nsdsf *i u q=hold,cl=t,j=63145,req=all,dd=?\n\n* PROCLIB\nsdsf *i proclib\n\n* DJC\nsdsf *I,N,ID=DJCNET,LIST\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LMACMVS": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x13\\x00\\x00\\x01\\x17$?\\x01\\x17$?\\x081\\x01}\\x01}\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.19", "flags": 0, "createdate": "2017-08-31T00:00:00", "modifydate": "2017-08-31T08:31:00", "lines": 381, "newlines": 381, "modlines": 0, "user": "YCLMAC"}, "text": "* MVS Commands - 31.08.2017\n* Samples for the EX (SDSF) line command from YCLMACRX\n* all commands can also be called from outside EDIT:\n* TSO YCLMACRX sdsf d c\n* This way could also be used in a Rexx Batch|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-17                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n\n* consoles\nsdsf d c\nsdsf d c,cn=myoper\n* consoles - my one\nsdsf d c,*\n* consoles - backlog\nsdsf d c,b\n* consoles - emcs\nsdsf d emcs\nsdsf d emcs,full,cn=yvescn\n\n* pfk\nsdsf d pfk,cn=myoper\n\n* time\nsdsf d t\n\n* log on hardcopy (syslog/operlog)\nsdsf l 'das ist ein Beispiel'\n\n* send to operator\nsdsf se 'Hallo',cn=myoper\n* send to user\nsdsf se 'Hallo du',user=(yves)\n* list all brodcast messages\nsdsf se list\n\n* Ipl & system\nsdsf d iplinfo\n\n* Static Symbols\nsdsf d symbols\nsdsf d symbols,DETAIL\nsdsf d symbols,SUMmary\nsdsf d symbols,Symname=symname\n\n* Parmlib concatenation\nsdsf d parmlib\n\n* ipl parms details\nsdsf d iplinfo,csa\nsdsf d iplinfo,omvs\nsdsf d iplinfo,lpa\nsdsf d iplinfo,license\nsdsf d iplinfo,prog\n\n* ppt - program property table\nsdsf d ppt,ALL]PARMlib]DEFault]NAME=genam*?\n\n* Display Activity\nsdsf d a\nsdsf d a,l\nsdsf d a,a\nsdsf d ts,l\nsdsf d a,net\nsdsf d a,JES*\nsdsf d a,gtf*\nsdsf d a,a,userid=yves\n\n* replies\nsdsf d r\nsdsf d r,cn=(all)\nsdsf d r,l\nsdsf d r,l,cn=(all)\nsdsf d r,r,cn=(all)\nsdsf d r,l,t,cn=(all)\n\n* devices\nsdsf d u\nsdsf d u,,,2800,3\nsdsf d u,vol=vol001\nsdsf d u,,alloc,1002,1\nsdsf d u,dasd,online,,4\nsdsf d u,ctc,alloc,,32\nsdsf d u,ctc,alloc,2600,32\nsdsf d u,,as\n\n* matrix\nsdsf d m=cpu\nsdsf cf cpu(2),online\nsdsf cf cpu(2),offline\nsdsf d m=stor\nsdsf d m=chp(80)\nsdsf d m=chp(83)\nsdsf d m=dev(1002)\nsdsf d m=config(07)\nsdsf v path(1002,80),offline\nsdsf v path(1002,80),online\nsdsf cf chp(80),offline\nsdsf cf chp(80),online\n\n* device\nsdsf ds p,1002,3\nsdsf ds qd,1002,1\nsdsf ds qd,vol=voll01\nsdsf ds qd,1002,5,totalcyl\nsdsf ds qd,1002,1,ucb\nsdsf ds ql,list\nsdsf ds ql,60381\nsdsf v 1E53,offline\nsdsf v 1E53,online\nsdsf d u,,alloc,1E53,1\nsdsf d u,,,1E53,1\nsdsf ds s,0AA6,1\nsdsf ds s,0AA6,1\nsdsf ds qt,0f00,10\n\n* sms\nsdsf d sms\nsdsf d sms,sg(all)\nsdsf d sms,sg(sms),listvol\nsdsf d sms,vol(y3work)\n\n* smf\nsdsf d smf\nsdsf d smf,o\n\n* dump\nsdsf d d\nSDSF DUMP PARMLIB=AC,SYMDEF=(&DMPNAME.='RXSLEEP')\n\n* grs\nsdsf d grs,c\nsdsf d grs,res=(sysdsn,sys1.macl*)\nsdsf d grs,analyze,waiter\nsdsf d grs,analyze,blocker\nsdsf d grs,analyze,dependency\nsdsf d grs,analyze,dep\nsdsf d grs,analyze,latch,dep\n\n* sysplex xcf\nsdsf d opdata\nsdsf d xcf\nsdsf d xcf,s,all\nsdsf d xcf,cpl\nsdsf d xcf,cpl,type=sysplex\nsdsf d xcf,cpl,type=cfrm\nsdsf d xcf,cpl,type=logr\nsdsf d xcf,grp\nsdsf d xcf,grp,sysgrs,all\nsdsf d xcf,grp,dfhir000,all\nsdsf d xcf,grp,IXCLO14C,all\nsdsf d xcf,pi\nsdsf d xcf,pi,dev=0411\nsdsf d xcf,pi,strnm=ixc*\nsdsf d xcf,po\nsdsf d xcf,po,dev=0415\nsdsf d xcf,po,strnm=ixc*\nsdsf d xcf,classdef\nsdsf d xcf,classdef,class=default\nsdsf d xcf,classdef,class=def16k\nsdsf d xcf,classdef,class=def64k\nsdsf d xcf,localmsg\n\n* sysplex xcf set\nsdsf setxcf cpl,type=sysplex,acouple=sys1.xcf.cds03\nsdsf d xcf,cpl,type=sysplex\nsdsf setxcf cpl,type=sysplex,pswitch\n\n* sysplex cf\nsdsf d cf\nsdsf d xcf,cf\nsdsf d xcf,cf,cfnm=CFPR1\nsdsf d xcf,str\nsdsf d xcf,str,stat=notalloc\nsdsf d xcf,str,stat=fpconn\nsdsf d xcf,str,stat=noconn\nsdsf d xcf,str,strnm=IXC*\nsdsf d xcf,str,strnm=IXCSML1\nsdsf d xcf,str,strnm=IXCSML1,connm=all\n\n\n* logger\nsdsf d logger\nsdsf d logger,c\nsdsf d logger,c,lsn=sysplex.operlog\nsdsf d logger,c,lsn=sysplex.operlog,detail\nsdsf d logger,l\nsdsf d logger,l,lsn=atr.pgplex.delayed.ur\nsdsf d logger,l,lsn=sysplex.operlog\nsdsf d logger,str\nsdsf d logger,str,strn=operlog\nsdsf d logger,str,strn=rrs1\n\n* paging\nsdsf d asm\n\n* io\nsdsf d ios,config(all)\nsdsf d ios,hyperpav\n\n* wlm change sc\nsdsf E jobname,SRVCLASS=newsc\n* wlm quiesce address space\nsdsf E jobname,Q\n* wlm unquiesce or/and return to original sc\nsdsf E jobname,RESUME\n\n* check commands hanging\nsdsf cmds d\n\n* check console mode\nsdsf d opdata,mode\n\n* check lpa\nsdsf d prog,lpa,mod=iefbr14\n* change lpa\nsdsf setprog lpa,add,mod=ISPGE78T,dsn=SYS1.SISPLOAD\n* change lpa and SVC entry\nsdsf setprog lpa,add,mod=svc00240,dsn=yves.ycints.linklib,     +\n        svcnumdec=(240)\n* change lpa and SVC entry of an ESR SVC\nsdsf setprog lpa,add,mod=svce0240,dsn=yves.ycints.linklib,     +\n             SVCNUMDEC=(109,240)\n* delete from lpa\nsdsf setprog lpa,delete,mod=xmsrouta,force=yes\n\n* work with exits\nsdsf d  PROG EXIT\nsdsf d  PROG EXIT,exitname=IEFDB401,diag\nsdsf d  PROG EXIT,exitname=sys.iefusi,diag\nsdsf SETPROG EXIT,ADD,EX=SYS.IEFUSI,    +\n     MOD=YCDUSI,DSN=yves.ycos.linklib\nsdsf SETPROG EXIT,ADD,EX=SYS.IEFUSI,    +\n     MOD=IEFBR14,DSN=sys1.linklib,JOBname=IPREG*\nsdsf SETPROG EXIT,replace,EX=SYS.IEFUSI,    +\n     MOD=YCDUSI,DSN=yves.ycos.linklib\nsdsf SETPROG EXIT,replace,EX=SYS.IEFUSI,    +\n     MOD=IEFBR14,DSN=sys1.linklib\nsdsf SETPROG EXIT,delete,EX=SYS.IEFUSI,    +\n     MOD=YCDUSI\n\n* work with lnklst\nsdsf +\nD  PROG,LNKLST\nsdsf +\nSETPROG LNKLST,DEFINE,NAME=LNKLSTYY,COPYFROM=LNKLST00\nsdsf +\nSETPROG LNKLST,DELETE,NAME=LNKLSTYY,DSN=SYS1.SISFMOD1\nsdsf +\nSETPROG LINKLST,ADD,NAME=LNKLSTYY,DSN=YVES.YCINTS.LINKLIB,VOL=Y3WORK\nsdsf +\nSETPROG LINKLST,ADD,NAME=LNKLSTYY,DSN=YVES.YCINTS.LINKLIB,VOL=Y3WORK +\n     ATBOTTOM - default\n     ATTOP\n     AFTER=dsname\nsdsf +\nSETPROG LNKLST,ACTIVATE,NAME=LNKLSTYY\nsdsf +\nSETPROG LNKLST,UPDATE,JOB=*,DELAY=5\n\nDynamic Linklist Add per command:\nsdsf +\nSETPROG LINKLST,DEFINE,NAME=LNKLSTYY,COPYFROM=CURRENT\nsdsf +\nSETPROG LINKLST,ADD,NAME=LNKLSTYY,DSN=customer.YCELOGZ.LINKLIB,VOL=??????\nsdsf +\nSETPROG LINKLST,ADD,NAME=LNKLSTYY,DSN=customer.YCELOGZ.LINKAPF,VOL=??????\nsdsf +\nSETPROG LINKLST,ACTIVATE,NAME=LNKLSTYY\nsdsf +\nSETPROG LINKLST,UPDATE,JOB=*,DELAY=5\n\n* work with APF\nsdsf d prog,apf\nDynamic Add APF per command:\nsdsf +\nSETPROG APF,ADD,DSNAME=customer.YCELOGZ.LINKAPF,SMS\nor\nsdsf +\nSETPROG APF,ADD,DSNAME=customer.YCELOGZ.LINKAPF,VOLUME=xxxxxx\n\n* lla\nsdsf d lla\nsdsf D LLA,STATISTICS\nsdsf D LLA,DSN=xxxxxxxx,MEMBER=*\nsdsf D LLA,STATS,LIBRARY=xxxx,MEMBER=YYY*,FETCHED\nsdsf ro *all,F lla,refresh\nsdsf F lla,updaate=xx\n\n* Display SLIP\nsdsf D SLIP\n* Display SLIP ID\nsdsf D SLIP=HEM1\n* Disable/Modify a SLIP ID\nsdsf SLIP MOD,ID=HEM1,DISABLE,END\n* Delete a SLIP ID\nsdsf SLIP DEL,ID=HEM1\n* Dump Suppression   no SVC or SYSUDUMP on an SD37 Error\nsdsf SLIP SET,Comp=D37,ID=XD37,Action=(NOSVCD,NOSYSU),END\n* Action: NODUMP, NOSVCD, NOSYSU, NOSYSA\nsdsf SLIP SET,C=EC6,REason=0000FFXX,ID=XEC6,Action=NODUMP,END\n* Create a Dump on some Errors\n* SVC Dump in Module in Case of User Abend\nsdsf SLIP SET,LPAMOD=HEMSFR,ACTION=SVCD,COMP=UXXXX,ID=HEM1,END\n* Create a Dump on Instruction Fetch\n* Instruction Fetch within RANGE, get the first 5\nsdsf SLIP SET,IF,ACTION=SVCD,RANGE=(05E2A580,05E2A588), +\n     JOBNAME=HEMSSIYY,MATCHLIM=5,END\n* Create a TRACE on Instruction Fetch\n* all Instruction Fetch within a Range will\n* produce for a given Job a GTF Tace record\nStart GTF with TRACE=SLIP Option\nsdsf SLIP SET,IF,ACTION=TRACE,RANGE=(05D58BB0,05D58BB0+13A8), +\n     JOBNAME=yvesjob,MATCHLIM=9999,END\n\n* display IKJTSO Settings\nsdsf d ikjtso\n* change IKJTSO Settings\nsdsf t ikjtso=yc\n\n* 64Bit Virtual storage - shared memory objects\nsdsf d vs,hvshare\n* 64Bit Virtual storage - common memory objects\nsdsf d vs,hvcommon\n* 64Bit Virtual storage - large frame usage\nsdsf d vs,lfarea\n\n* General SSI Commands\nSDSF D SSI\nSDSF D SSI,ALL\nSDSF D SSI,FUNC=01\nSDSF D SSI,SUBSYS=MSTR\nSDSF D SSI,SUBSYS=???F\nSDSF D SSI,SUBSYS=SF##\nSDSF D SSI,ALL,FUNC=01\nSDSF D SSI,ALL,FUNC=10\nSDSF D SSI,STAT=ACT\nSDSF D SSI,STAT=INACTIVE\n\n* ADD A SUBSTYSTEM\nSDSF SETSSI   ADD,SUBNAME=SF##\n* ADD A SUBSTYSTEM AND RUN AN INIT ROUTINE\nSDSF SETSSI   ADD,S=SF##,INITRTN=SSIINI##\n* DEACTIVATE SUBSYSTEM\nSDSF SETSSI   DEACTIVATE,SUBNAME=SF##\n* ACTIVATE SUBSYSTEM\nSDSF SETSSI   ACTIVATE,SUBNAME=SF##\n\n* DELETE A SUBSTYSTEM\nsdsf SETSSI DELETE,SUBNAME=subname,FORCE\n\n* vtam\nsdsf d net,bfruse,buf=(t1,t2)\nsdsf d net,vtamopts\nsdsf d net,vtamopts,function=appnchar\nsdsf d net,id=istlsxcf,e\nsdsf v net,id=istlsxcf,inact\n\n* AXR - System Rexx\nsdsf F AXR,SR STatus\nsdsf F AXR,SR STatus,detail\nsdsf F AXR,SR REXXLIB\nsdsf F AXR,myrexx\n\n* Catalog Address Space\nsdsf f catalog,report\nsdsf f catalog,ecshr\nsdsf f catalog,castats\nsdsf f catalog,allocated\n\n* z/OS 2.2 SMFLIMIT\nsdsf D SMFLIM\u00c4,S]SUMMARY\u00dc\n      \u00c4,R]REGION \u00c4,MEMBER=SMFLIMxx\u00c4,RULE=xxxx\u00dc\u00dc ] \u00c4,joboptions\u00dc\nsdsf d smflim\nsdsf d smflim,r\nsdsf d smflim,r,member=smflimyc\nsdsf d smflim,r,member=smflimyc,rule=3\nsdsf d smflim,r,jobname=ipreg4\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LMACTSO": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x161\\x9f\\x01\\x161\\x9f\\x17\\x17\\x00i\\x00i\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2016-11-14T00:00:00", "modifydate": "2016-11-14T17:17:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "YCLMAC"}, "text": "* TSO Commands - 14.11.2016\n* Samples for the EX (TSO) line command from YCLMACRX\n* all commands can also be called from outside EDIT:\n* TSO YCLMACRX tso lista st h\n* This way could also be used in a Rexx Batch|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n* tso prefix is optional(default) using \"ex\"\n\n* Alloc files using BPXWDYN|\ntso ,\ncall *(bpxwdyn) 'alloc fi(a) new catalog da(yves.ycos.gdg(+1)) +\n    cyl space(10,10)'\ncall *(bpxwdyn) 'alloc fi(a) shr da(yves.ycos.cntl) '\nfree fi(a)\n\n* List Catalog\nlistc ent('YVES.YCOS.CNTL') +\n  all\n\n* List Allocated files (use DDLIST|)\nlista st h\n\n* Transmit dataset\ntransmit (n1/yves) dataset(bcpii.rexx),\n    outdataset(bcpii.rexx.xmit),\n    noepilog nolog nonotify sysout(*)\n\n* Help\nHelp\nHelp CALL\nHelp TEST\nHelp ALLOCATE\nHelp ALTLIB\nHelp FREE\nHelp LISTALC\nHelp LISTCAT\nHelp LISTDS\nHelp EXEC\nHelp EXECUTIL\nHelp PROFILE\nHelp SEND\nHelp RECEIVE\nHelp TRANSMIT\n\n* TCP/IP\nHelp netstat\nnetstat\nHelp ping\nping 1.2.3.4\nping 1.2.3.4 (count 4\n\n* RACF\n* LISTUSER - LU\nlu yves\nlu yves omvs\nlu yves tso\nhelp lu\n\n* LISTGRP - LG\nlg sys1\nlg sys1 omvs\nhelp lg\n\n* LISTDSD - LD\n* List profile\nld da('sys1.parmlib')\n* List all profiles HLQ=userid]group\nld id(yves)\n* List all profiles like prefix\nld pre(yves.myprof)\n* Show the Dataset protected by\nld id(yves) dsn\nhelp ld\n\n* RLIST - RL - List General Resource\nrl facility (*) noracf\nrl facility (MVSADMIN.WLM.POLICY) all\nhelp rl\n\n* SEARCH - SR\nsr class(user) mask(yv)\nsr class(user) filter(y%e%)\nsr class(user) filter(y%e%) CLIST('LU ' ' OMVS NORACF') NOLIST\n* >>> look for prefix.EXEC.RACF.CLIST\nsr class(dataset) filter(sys%.**)\nsr class(dataset) filter(yves.**)\nsr class(dataset) warning\n* List all profile with USER access at least read\nsr user(yves)\nsr class(user) uid(0)\nsr class(group) gid(0)\nhelp sr\n\n* VLF\nHELP VLFNOTE\nVLFNOTE   DELETE | ADD | UPDATE +\n          CLASS('CLASSNAME') DATASET('DSLIST') VOLSER('SERIAL')\nVLFNOTE                  UPDATE +\n          CLASS(IKJTSO) DATASET('YVES.CLIST(YT)')\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMACUSS": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x18\\x14/\\x01\\x18\\x14/\\x18\\x18\\x02\\t\\x02\\t\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2018-05-22T18:18:00", "lines": 521, "newlines": 521, "modlines": 0, "user": "YCLMAC"}, "text": "* USS Commands and subcommands - 03.04.2017\n* Samples for the EX (UNIX/UNIXSU/UNIXENV/UNIXSUENV/UDLIST/UFDIR/UFFIL)\n*                           line command from YCLMACRX\n* all commands can also be called from outside EDIT/VIEW:\n* TSO YCLMACRX unix ls\n* TSO YCLMACRX udlist /u\n* TSO YCLMACRX ufdir  /u *c*\n* TSO YCLMACRX uffil  /u *c*\n* TSO YCLMACRX unix ls\n* This way could also be used in a Rexx Batch|\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-17                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n\n\n\nunix pwd\n: show current working directory\n\n===================================================================\n\nunix cd\n: change directory\n\nunix cd\n: home dir\n\nunix cd dir\n: relative dir\n\nunix cd /dir1/dir2\n: absolute dir\n\nunix cd old new\n: replace old to new in current working dir (cwd)\n\nunix cd -\n: go to previous dir\n\nunix cd ..\n: go to parent dir\n\n===================================================================\n\nunix mkdir yvest\n: create directory yvest under cwd\n\nunix mkdir /yvest\n: create directory yvest under / (root)\n\n===================================================================\n\nunix ln -s /mainview /u/yves/symblink_to_mainview\n: Create symbolic link\n\n===================================================================\n\nunix ls -l\n: details\n\nunix ls -E\n: extended attributes\n\nunix ls -m\n: names coma separated\n\nunix ls -n\n: UID and GID number\n\nunix ls -R\n: subdirectories\n\nunix ls -t\n: sort by last modification time\n\nunix ls -u\n: sort by last access time\n\nunix ls -W\n: audit bits\n\n===================================================================\n\nunix chmod, extattr, chown, chgrp\n: change file \"attributes\"\n\n===================================================================\n\nunix cat\n: concatenate files\n\nunix cat /u/zfs/YVES/yves.rex\n: list to screen\n\nunix cat /u/zfs/YVES/yves.rex >/u/zfs/YVES/n.rex\n: list to dataset\n\nunix cat /u/zfs/YVES/yves.rex >>/u/zfs/YVES/n.rex\n: append list to dataset\n\nunix cat \"//'SYS1.PARMLIB(ADYSET00)'\"\n: list mvs dataset to screen\n\n===================================================================\n\nunix head, tail\n: list first/last lines of file on screen - defaut 10\n\nunix head -n 5 /u/zfs/YVES/yves.rex\n: list first 5 lines to screen\n\nunix tail -n 3 /u/zfs/YVES/yves.rex >>/u/zfs/YVES/n.rex\n: append last 3 lines to dataset\n\n===================================================================\n\nunix rm\n: remove file or directory\n\nunix rm *\n: remove all files in directory\n\nunix rm -r *\n: remove all all all all\n     -r or -R recursive\n     -i prompt are you sure?\n     -v list removed files\n\n===================================================================\n\nunix cp\n: copy file or directory\n\nunix ,\n cp -F lf        /u/zfs/YVES/ycos1.tx ,\n \"//'YVES.CRLF(DATA)'\"\n: copy an \"lf\" file to an MVS to get it \"CRLF\"\n\n===================================================================\n\nunix mv\n: move file or directory\n\n===================================================================\n\nunix find\n: search file\n  - many parms\n\nunix find / -name \"*.rex\"\n: find all *.rex files starting from root\n\nunix find . -name \"*.rex\"\n: find all *.rex files starting from current working dir\n\n     -perm  : permission bits\n     -atime : access time\n     -ctime : changed attributes time\n     -mtime : modified time\n     -ext   : extended attributes\n     -newer : file newer than the one giving\n     -size  : file size\n     -type  : file type\n     ...\n\n===================================================================\n\nunix grep\n: find data within files\n\nunix grep 'print' *.c\n: find all files (within *.c) with 'print' string\n\nunix grep -i 'print' *.c\n: find all files (within *.c) with 'print' string - regardles of case\n\nunix grep -n 'print' *.c\n: find all files (within *.c) with 'print' string - give line #\n\nunix grep -c 'print' *.c\n: count all matches in files (within *.c) with 'print' string\n\nunix grep -l 'print' *.c\n: list all files (within *.c) with matches 'print' string\n\nunix grep -E 'print|comment' *.*\n: find all files (within *.*) with 'print' or 'comment' string\n  -E using regular expression\n  | - german for ]\n\nunix grep -E '\u00ddcCN\u00a8omment' *.*\n: find all files (within *.*) with 'comment' 'Comment' 'Nomment'\n  -E using regular expression\n  \u00dd (x'AD') - german for \u00c4\n  \u00a8 (x'BD') - german for \u00dc\n\n===================================================================\n\nunix cmp\n: compare files\n\nunix cmp cmd1.tx  cmd2.tx\n: compare files\n\nunix cmp -l cmd1.tx  cmd2.tx\n: compare files - displays the byte number (in decimal) and the\n                  differing bytes (in octal format)\n\nunix cmp -lx cmd1.tx  cmd2.tx\n: compare files - displays the byte number (in decimal) and the\n                  differing bytes (in hexadecimal format)\n\nunix cmp -s cmd1.tx  cmd2.tx\n: compare files - Suppresses output and returns a nonzero status\n                  if the files are not identical\n\n===================================================================\n\nunix diff\n: compare files and find differences\n\nunix diff ycos1.tx ycos2.tx\n: compare files and find differences\n\nunix diff -c ycos1.tx ycos2.tx\n: find differences - Shows n lines of context before and after each change\n\n===================================================================\n\nunix df\n: display file system\n\nunix df -P\n: display file system with more details\n\nunix df -v\n: display file system with status\n\nunix df -k\n: display file system in 1024K blocks\n\nunix df -S\n: display file system in 1024K blocks\n\n===================================================================\n\nunix man\n: display command help\n\nunix man ls\n: display command help for \"ls\" command\n\n===================================================================\n\nunix who\n: display user and system information\n\nunix who -a\n: all information\n\n===================================================================\n\nunix whoami\n: display \"me\"\n\nunix id\n\n===================================================================\n\nunix su\n: set superuser\n\n===================================================================\n\nunix su\n: set superuser\n\n===================================================================\n\nunix ps\n: display process information (all info - only superuser) - many parms\n\nunix ps -e\nunixsu ps -el\n\n===================================================================\n\nbpxmtext errcode\n: display error code information\n\n===================================================================\n\nunix pax\n: create/extract archive file - many parms\n\n===================================================================\n\nunix kill\n: end a process\n\n===================================================================\n\nunix uptime\n: time since last ipl and other infos\n\n===================================================================\n\nunix wc\n     -c      : byte count\n     -l      : line count\n     -m      : character count\n     -w      : word count\n: count\nunix wc yves.rex\n\n===================================================================\n\nunix date\n: Datum / Uhrzeit - many format parms\n\nunix date +\"%d\".\"%m\".\"%y  \"Weekday:\"%A\"\n\nunix date +%H:%M:%S\n\n===================================================================\n\nunix echo\n: output information to stdout\n\nunix echo they are $(ls | wc -l) files in this directory $(pwd)\n\n===================================================================\n\nUsing Pipes:\n\nunix ls -ltr | tail -n 4\n: list 4 mostly referenced files\n\nunix ls | wc -l\n: number of files\n\nunix find *.tx | wc -l\n: number of files with names *.tx\n\nunix cat \"//'SYS1.PARMLIB(ADYSET00)'\" | grep 'SUPPLIED'\n: cat MVS dataset to Stdout | (Pipe) -> grep from Stdin\n  find line(s) with word SUPPLIED in MVS file\n\n===================================================================\n\nzlsof \u00c4-p\u00c4pids\u00dc]\u00c4-a\u00c4asids\u00dc]\u00c4-j\u00c4jobs\u00dc\u00dc \u00c4-u\u00c4users\u00dc\u00dc \u00c4-c\u00dc \u00c4-d\u00dc \u00c4-t\u00dc\n      \u00c4-i\u00dc \u00c4-l\u00dc \u00c4-n\u00dc \u00c4-su\u00dc \u00c4-v\u00dc\n      \u00c4-m maxtime\u00dc \u00c4-rw\u00c4seconds\u00dc\u00dc \u00c4pathname]pipe]socket\u00dc\n: Displays information about open files, sockets, and pipes\n\nunixsu /bin/zlsof /u/fzi5297\n\n===================================================================\n\nunix zfsadm fsinfo \u00c4-aggregate aggr ] -path pth ] -all\u00dc\n                   \u00c4-basic ] -owner ] -full ] -reset\u00dc\n                   \u00c4-select criteria ] -exceptions\u00dc\n                   \u00c4-sort name]requests]response\u00dc\u00c4-level\u00dc\u00c4-help\u00dc\n: File System Information (also as MVS Modify/F command)\n\nSelect criteria:\nCE*  Had XCF communication failures between client systems and owning systems.\nDA*  Are marked damaged by the zFS salvager.\nDI*  Are disabled for reading and writing.\nGD*  Are disabled for dynamic grow.\nGF*  Had failed dynamic grow attempts.\nGR   Are currently being grown.\nIE*  Have had disk I/0 errors.\nL*   Have less than 1 MB of free space, which means that increased XCF traffic\n     is required for writing files.\nNS   Are mounted NORWSHARE.\nOV   Contain extended (v5) directories that are using overflow pages.\nQ*   Are currently quiesced.\nRO   Are mounted read-only.\nRQ   Had application activity.\nRW   Are mounted read/write.\nRS   Are mounted RWSHARE.\nSE*  Have returned ENOSPC errors to applications.\nTH   Have sysplex thrashing objects in them.\nV4   Are version 1.4.\nV5   Are version 1.5.\nV5D' Are disabled for conversion to version 1.5.\nWR   Had application write activity.\n  * = exceptions\n\n===================================================================\n\n* iconv convert from ger to us\n* http://de.wikipedia.org/\n*         wiki/Extended_Binary_Coded_Decimals_Interchange_Code\nunix ,\n iconv -f IBM-273 -t IBM-1047 ,\n  /u/yves/my.javao,\n  >/u/yves/my.java\n\n===================================================================\n\nunixsu zfsadm define -aggregate YVES.NEW.ZFS -cylinders 15\n: create a zfs\n\nunixsu zfsadm format -aggregate YVES.NEW.ZFS -compat\n: format a zfs\n\nunixsu /usr/sbin/mount -f YVES.NEW.ZFS      +\n                -t ZFS                      +\n                -a unmount                  +\n                /u/zfs/YVES/yvest\n: Mount the file system\n\n===================================================================\n\nunix /usr/lpp/wbem/bin/cimcli ei IBMzOS_Incident -o xml\nunixenv +\nenv_variable_start\nPATH=/bin:.:/usr/lpp/wbem/bin\nLIBPATH=/lib:/usr/lib:/usr/lpp/wbem/lib:.\nenv_variable_end\n        cimcli ei IBMzOS_Incident\n        cimcli ei IBMzOS_Process\n        cimcli ei IBMzOS_OSProcess\n        cimcli ei IBMzOS_ComputerSystem\n        cimcli ei IBMzOS_OperatingSystem\n        cimcli ei IBMzOS_BaseBoard\n        cimcli ei IBM_BaseBoard\n        cimcli ni\n        cimcli ei +\nIBMzOS_SFMAttributes\nIBMzOS_IncidentIndication\n        cimcli nc\n        cimcli ec\n        cimcli ei IBMzOS_Incident\n\n\n* Create symbolic link\nunix ln -s /mainview /u/yves/symblink_to_mainview\n*------------------------------------------------------\n\n*------------------------------------------------------\n* UDLIST Samples\n* display the path using UDLIST - 3.17\nudlist /u\nudlist /u/zfs/YVES\nudlist /u/zfs      +\n             /YVES +\n       /DIR\n\n*------------------------------------------------------\n* UFDIR  Samples\n* find and display all directories within\n* first parm is path\n* second parm is directory name (also generic)\nufdir  /u o*\nufdir  /u/zfs/YVES *u*\n* the directory name CANNOT be continued|||\nufdir  /u/zfs/YVES +\n       *I*\n\n*------------------------------------------------------\n* UFFIL  Samples\n* find and display all files within given\n* name within a given directoy tree\n* first parm is path\n* second parm is directory name (also generic)\nuffil  /u/zfs/YVES +\n       *y*\nuffil  /u/zfs/YVES +\n       *\n* the directory name CANNOT be continued|||\nuffil  /u          +\n       *C*\n\n*------------------------------------------------------\n* files\nsdsf d omvs,f\n*------------------------------------------------------\n* phys file systems\nsdsf d omvs,pfs\n*------------------------------------------------------\n* options\nsdsf d omvs,o\n*------------------------------------------------------\n* limits\nsdsf d omvs,l\n* all ps\nsdsf d omvs,a=all\n\n*------------------------------------------------------\n* tso user omvs\nlu yves    omvs noracf\n*------------------------------------------------------\n* tso group omvs\nlg mygrp   mmvs noracf\n\n* zfs\nunix   zfsadm configquery -all\nunix   zfsadm configquery -aggrgrow\nunix   zfsadm configquery -level\nunix   zfsadm lsaggr\nunix   zfsadm lsfs -long\nunix   zfsadm aggrinfo -long\nsdsf F ZFS,QUERY,FILE\nsdsf F ZFS,QUERY,LEVEL\n\n* Terminate/Force a Process/Thread\nsdsf F BPXOINIT,TERM=pid\u00c4.tid\u00dc\nsdsf F BPXOINIT,FORCE=pid\u00c4.tid\u00dc\n\n*------------------------------------------------------\n* write to console\n*------------------------------------------------------\n\nunix echo blabla > /dev/console\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y$CL": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x13\\x00\\x00\\x01\\x17$?\\x01\\x17$?\\x081\\x00p\\x00p\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.19", "flags": 0, "createdate": "2017-08-31T00:00:00", "modifydate": "2017-08-31T08:31:00", "lines": 112, "newlines": 112, "modlines": 0, "user": "YCLMAC"}, "text": "/* REXX exec to compare two lines                                     */\n/*** trace ?r *****************************************************    *\n*               (C) Copyright Robert AH Prins, 2010-2016               *\n************************************************************************\n*  ------------------------------------------------------------------  *\n* | Date       | By   | Remarks                                      | *\n* |------------+------+----------------------------------------------| *\n* |            |      |                                              | *\n* |------------+------+----------------------------------------------| *\n* | 2017-06-20 | YCD  | Long line processing                         | *\n* |------------+------+----------------------------------------------| *\n* | 2016-02-16 | RAHP | Add label processing                         | *\n* |------------+------+----------------------------------------------| *\n* | 2011-01-07 | RAHP | Improve compare dif setting                  | *\n* |------------+------+----------------------------------------------| *\n* | 2010-09-22 | RAHP | Initial version                              | *\n* |------------+------+----------------------------------------------| *\n************************************************************************\n* Y$CL is a REXX exec to compare two lines. It can be used in two      *\n* ways:                                                                *\n*                                                                      *\n* - to compare two adjacent lines, place the cursor on the first of    *\n*   the two and enter \"Y$CL\", or                                       *\n* - mark the two lines to be compared with the labels \".EF\" and \".EL\"  *\n*   and enter \"Y$CL\"                                                   *\n************************************************************************\n* Send questions, suggestions and/or bug reports to:                   *\n*                                                                      *\n* robert\u00a7prino.org / robert.ah.prins\u00a7gmail.com                         *\n*                                                                      *\n* Robert AH Prins                                                      *\n* Taboralaan 46                                                        *\n* 8400 Oostende                                                        *\n* Belgium                                                              *\n************************************************************************\n* This program is free software: you can redistribute it and/or        *\n* modify it under the terms of the GNU General Public License as       *\n* published by the Free Software Foundation, either version 3 of       *\n* the License, or (at your option) any later version.                  *\n*                                                                      *\n* This program is distributed in the hope that it will be useful,      *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of       *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         *\n* GNU General Public License for more details.                         *\n*                                                                      *\n* You should have received a copy of the GNU General Public License    *\n* along with this program. If not, see <http://www.gnu.org/licenses/>  *\n***********************************************************************/\nparse source source\nparse value source with . . moi .\n\n\"isredit macro\"\n\"ispexec control errors return\"\n\n\"isredit (EF) = linenum .EF\"\n\"isredit (EL) = linenum .EL\"\n\nif ef <> 0 & el <> 0 then\n  do\n    \"isredit x .EF .EL all\"\n    \"isredit hide x\"\n    \"isredit l .EF\"\n    \"isredit l .EL\"\n\n    \"isredit (L1) = line .EF\"\n    \"isredit (L2) = line .EL\"\n\n    zc = min(ef, el)\n    n  = el - ef\n    \"isredit l\" zc\n  end\nelse\n  do\n    \"isredit (ZL) = linenum .zl\"\n    \"isredit (ZC) = linenum .zcsr\"\n\n    \"isredit (L1) = line .zcsr\"\n\n    if zc <> zl then\n      n =  1\n    else\n      n = -1\n\n    \"isredit (L2) = line\" zc + n\n  end\n\nl1=strip(l1,\"T\")\nl2=strip(l2,\"T\")\n\nx   = left(' ', 256, '|')\ndif = translate((bitxor(l1, l2)), x, xrange())\n\nif dif = '' then\n  dif = 'Lines \u00ac\u00ac'zc + 0'\u00ac\u00ac and vv'zc + n'vv are identical'\nelse\n  do\n    p = pos('||', dif)\n\n    do while p > 0\n      nb  = pos(' ', dif' ', p + 1)\n\n      dif = left(dif, p - 1)'<'copies('-',nb - p - 2)'>' ||,\n            substr(dif, nb)\n\n      p   = pos('||', dif, nb)\n    end\n  end\n\nif n > 0 then\n  \"isredit line_after\"  zc \"= infoline (DIF)\"\nelse\n  \"isredit line_before\" zc \"= infoline (DIF)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y$HC": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x00\\x01\\x18\\t\\x9f\\x01\\x18\\t\\x9f!!\\x00\\x83\\x00\\x83\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2018-04-09T00:00:00", "modifydate": "2018-04-09T21:21:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| Help File - Displays only the commands with 1 line description   |*/\n/*+------------------------------------------------------------------+*/\n\nADDRESS ISREDIT\n\n\"ISREDIT MACRO\"\n\nbefq=queued()\nqueue '+------------------------------------------------------------------+'\nqueue '|                                                                   '\nqueue '| Line commands and a short description:                            '\nqueue '|                                                                   '\nqueue '| H      ==>> Show help as note                                     '\nqueue '| HC     ==>> Show a Short description of each command              '\nqueue '| HELP   ==>> Show help                                             '\nqueue '| HV     ==>> Show help as view                                     '\nqueue '| RV     ==>> Reverse the line text                                 '\nqueue '| CE     ==>> Center the line text                                  '\nqueue '| AL     ==>> Align Left the line text                              '\nqueue '| AR     ==>> Align Right the line text                             '\nqueue '| AU     ==>> Align Up the line text as the previous line           '\nqueue '| AD     ==>> Align Down the line text as the next line             '\nqueue '| YX     ==>> Hex one line as note (native support 1.11|)           '\nqueue '| YD     ==>> Hex one line as note (in data form)                   '\nqueue '| CL     ==>> Compare lines                                         '\nqueue '| CM     ==>> Comment/uncomment lines                               '\nqueue '| LN     ==>> Display the number of characters of variable length   '\nqueue '| TOPD   ==>> Delete all lines from here to the top                 '\nqueue '| BOTD   ==>> Delete all lines from here to the bottom              '\nqueue '| TOPX   ==>> eXclude all lines from here to the top                '\nqueue '| BOTX   ==>> eXclude all lines from here to the bottom             '\nqueue '| FI     ==>> FindFirst where the cursor is placed - or first word  '\nqueue '| FL     ==>> FindLast  where the cursor is placed - or first word  '\nqueue '| FA     ==>> FindAll   where the cursor is placed - or first word  '\nqueue '| E      ==>> Edit the dataset                                      '\nqueue '| EZ     ==>> Edit the dataset in new Split Screen                  '\nqueue '| V      ==>> View the dataset                                      '\nqueue '| VZ     ==>> View the dataset in new Split Screen                  '\nqueue '| REV    ==>> View the dataset with REVIEW (also VSAM)              '\nqueue '| DA     ==>> Dataset allocation like - JCL and TSO Allocate        '\nqueue '| DI     ==>> DSINFO the dataset                                    '\nqueue '| DL     ==>> LISTCAT the dataset                                   '\nqueue '| DS     ==>> DSLIST the dataset 3.4                                '\nqueue '| DX     ==>> DSLIST first n Qualifiers 3.4                         '\nqueue '| DZ     ==>> DSLIST first n Qualifiers 3.4 in new Split Screen     '\nqueue '| DM     ==>> MemberList 3.1                                        '\nqueue '| LD     ==>> Execute the RACF LISTDSD/LD Command                   '\nqueue '| DH     ==>> HSM List command - Display HSM Migrate/Backup         '\nqueue '] RU     ==>> Create a ruler as a notes where cursor is located     '\nqueue '| EX     ==>> Execute the cmd line - as a tso cmd                   '\nqueue '| EX     ==>> Execute the cmd line - as a SDSF command like /...    '\nqueue '| EX     ==>> Execute the cmd line - as an EJES command like /...   '\nqueue '| EX     ==>> Execute the cmd line - as a UNIX command like Shell   '\nqueue '| EX     ==>> Execute the cmd line - as a UDLIST 3.17 command       '\nqueue '| EX     ==>> Execute the cmd line - as a Unix FIND for a directory '\nqueue '| EX     ==>> Execute the cmd line - as a Unix FIND for a file name '\nqueue '| EX     ==>> Execute the cmd line - as a System automation cmd     '\nqueue '| EX     ==>> Execute the cmd line - as an ISPF command             '\nqueue '| AE     ==>> Ascii -> Ebcdic - simple table                        '\nqueue '| EA     ==>> Ebcdic -> Ascii - simple table                        '\nqueue '| JU     ==>> JCL Upper Case                                        '\nqueue '|                                                                   '\nqueue '| =========== General Information ================================= '\nqueue '|                                                                   '\nqueue '| H HELP E V EZ VZ DH DI DL DM DS EX CL LD REV FI FL FA             '\nqueue '| are single line commands                                          '\nqueue '|                                                                   '\nqueue '| All othes can be given in the forms                               '\nqueue '|     CE5                                                           '\nqueue '|   or                                                              '\nqueue '|     CEE                                                           '\nqueue '|      ...                                                          '\nqueue '|     CEE                                                           '\nqueue '|                                                                   '\nqueue '| =========== Usage Hint ========================================== '\nqueue '|                                                                   '\nqueue '| Line Commands could also be defined on PFKs using :xx notation    '\nqueue '| Possible good candidates like :E or :V or :DS and others          '\nqueue '|                                                                   '\nqueue '+------------------------------------------------------------------+'\nparse source . calltype .\nif calltype=\"SUBROUTINE\" then exit\n\n/* direct call */\nAddress  ISPEXEC \"CONTROL ERRORS RETURN\"     /* Return ispf errors  */\n\nAddress ISPEXEC \"VGET (ZOS390RL)\"                      /* 2.10 */\n                   /* \"z/OS   01.13.00\"   */           /* 2.10 */\ned_parms=\"\"                                            /* 2.10 */\nif ZOS390RL = \"z/OS   01.13.00\" |,                     /* 2.10 */\n   left(ZOS390RL,10)=\"z/OS   02.\" then do              /* 2.10 */\n  Address ISPEXEC \"VGET (ZLMAC)\"                       /* 2.10 */\n  if ZLMAC <> \"\" then do                               /* 2.10 */\n    ed_parms=\" LINECMDS(\"strip(ZLMAC)\")\"               /* 2.10 */\n  end                                                  /* 2.10 */\nend                                                    /* 2.10 */\ndo cnt1=1 to befq\n         parse pull bm.cnt1\nend\ndo cnt=1 to queued()\n         parse pull msg\n         m.cnt=Msg\nend\ndo cnt1=1 to befq\n         queue bm.cnt1\nend\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(80)\",\n\"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  do i=1 to cnt-1\n    say m.i\n  end\n  exit 0\nend\n/* write the data */\naddress mvs \"execio \"cnt-1\" diskw \"ydd1\" (stem m. finis\"\n/* show the result */\naddress ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\naddress ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\naddress ispexec \"lmfree dataid(\"myou\")\"\nmsgset=msg('OFF')\naddress tso \"free fi(\"ydd1\")\"\nmsgset=msg(msgset)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y$PDS": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x13\\x01\\x165\\x0f\\x01\\x19$/\\x06P\\x00K\\x00K\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2016-12-15T00:00:00", "modifydate": "2019-08-30T06:50:13", "lines": 75, "newlines": 75, "modlines": 0, "user": "SLBD"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK                           |*/\n/*|                                                                  |*/\n/*| Function Y$PDS:   External line command: PDS                     |*/\n/*|                                                                  |*/\n/*| Author:           Lionel Dyck                                    |*/\n/*+------------------------------------------------------------------+*/\n/*| see http://www.cbttape.org    (File 182)                         |*/\n/*+------------------------------------------------------------------+*/\n/*| VERS 1.00  16.11.2016 Lionel Dyck                                |*/\n/*| VERS 1.01  16.12.2016 Yves Colliard                              |*/\n/*| VERS 1.02  30.08.2019 Lionel Dyck                                |*/\n/*+------------------------------------------------------------------+*/\n\naddress \"ISREDIT\"\n\"MACRO (PARM) NOPROCESS\"\n\"PROCESS RANGE \"parm\n\n\"(CURLINE CURCOL) = CURSOR\"\n\nShowAct = \"PDS\"\n\"(LINE) = LINE \"Curline\nparse value YCLMACDS(Line) with retc mydsn '05'x myvol\nif retc = 0 then do\n\n      xx = outtrap('tsomsg.')\n      if myvol <> \"UNIXPATH\" then do\n         address \"TSO\" \"ALLOC DUMMY DSN('\"MyDsn\"') SHR REU\"\n         retc = RC\n         xx = outtrap('xx')\n         if retc > 0 then do\n            zedsmsg=''\n            zedlmsg=tsomsg.1\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            \"CURSOR = \"CURLINE CURCOL\n            return retc\n         end\n      end\n      else do\n         cc = syscalls(\"ON\")\n         address SYSCALL \"stat \"MyDsn\" st.\"\n         if st.0 = 0 then do\n            zedsmsg=''\n            zedlmsg=\"File '\"MyDsn\"' nicht vorhanden.\"\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            \"CURSOR = \"CURLINE CURCOL\n            return 8\n         end\n      end\n\n   if myvol = \"\" | myvol = \"UNIXPATH\" then do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC \"SELECT CMD(PDS '\"MyDsn\"') SUSPEND\"\n      if rc=20 then call not_found\n      retc = rc\n   end\n   else do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC \"SELECT CMD(PDS '\"MyDsn\"' VOLUME(\"myvol\")) SUSPEND\"\n      if rc=20 then call not_found\n      retc = rc\n   end\n\nend\n\"CURSOR = \"CURLINE CURCOL\nreturn retc\nnot_found:\n  zedsmsg = \"\"\n  zedlmsg = \"PDSEGEN command not found - must first be installed\"\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y$PG": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x06\\x01\\x165\\x0f\\x01\\x19$/\\x06R\\x00L\\x00K\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2016-12-15T00:00:00", "modifydate": "2019-08-30T06:52:06", "lines": 76, "newlines": 75, "modlines": 0, "user": "SLBD"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK                           |*/\n/*|                                                                  |*/\n/*| Function Y$PDS:   External line command: PG - PDSE2 Generation   |*/\n/*|                                                                  |*/\n/*| Author:           Lionel Dyck                                    |*/\n/*+------------------------------------------------------------------+*/\n/*| see http://www.lbdsoftware.com/                                  |*/\n/*| see http://www.cbttape.org  (File 969)                           |*/\n/*+------------------------------------------------------------------+*/\n/*| VERS 1.00  16.11.2016 Lionel Dyck                                |*/\n/*| VERS 1.01  16.12.2016 Yves Colliard                              |*/\n/*| VERS 1.02  30.08.2019 Lionel Dyck                                |*/\n/*+------------------------------------------------------------------+*/\n\naddress \"ISREDIT\"\n\"MACRO (PARM) NOPROCESS\"\n\"PROCESS RANGE \"parm\n\n\"(CURLINE CURCOL) = CURSOR\"\n\nShowAct = \"PDSEGEN\"\n\"(LINE) = LINE \"Curline\nparse value YCLMACDS(Line) with retc mydsn '05'x myvol\nif retc = 0 then do\n\n      xx = outtrap('tsomsg.')\n      if myvol <> \"UNIXPATH\" then do\n         address \"TSO\" \"ALLOC DUMMY DSN('\"MyDsn\"') SHR REU\"\n         retc = RC\n         xx = outtrap('xx')\n         if retc > 0 then do\n            zedsmsg=''\n            zedlmsg=tsomsg.1\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            \"CURSOR = \"CURLINE CURCOL\n            return retc\n         end\n      end\n      else do\n         cc = syscalls(\"ON\")\n         address SYSCALL \"stat \"MyDsn\" st.\"\n         if st.0 = 0 then do\n            zedsmsg=''\n            zedlmsg=\"File '\"MyDsn\"' nicht vorhanden.\"\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            \"CURSOR = \"CURLINE CURCOL\n            return 8\n         end\n      end\n\n   if myvol = \"\" | myvol = \"UNIXPATH\" then do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC \"SELECT CMD(PDSEGEN '\"MyDsn\"') SUSPEND\"\n      if rc=20 then call not_found\n      retc = rc\n   end\n   else do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC \"SELECT CMD(PDSEGEN '\"MyDsn\"' VOLUME(\"myvol\")) SUSPEND\"\n      if rc=20 then call not_found\n      retc = rc\n   end\n\nend\n\"CURSOR = \"CURLINE CURCOL\nreturn retc\nnot_found:\n  zedsmsg = \"\"\n  zedlmsg = \"PDSEGEN command not found - must first be installed\"\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y$REV": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x00\\x01\\x18\\x06\\x1f\\x01\\x18\\x06\\x1f\\x16\\x16\\x00N\\x00N\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2018-03-02T00:00:00", "modifydate": "2018-03-02T16:16:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-17                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*|                                                                  |*/\n/*| Function Y$REV:   External line command: REV to call REVIEW      |*/\n/*|                                                                  |*/\n/*| Author:           Juergen Eberle                                 |*/\n/*| Email:            Juergen.Eberle\u00a7huk-coburg.de                   |*/\n/*+------------------------------------------------------------------+*/\n/*| see http://www.prycroft6.com.au/REVIEW/index.html                |*/\n/*+------------------------------------------------------------------+*/\n/*| VERS 1.01  20.04.2016 Juergen Eberle                             |*/\n/*| VERS 1.02  16.11.2016 Bruce Koss                                 |*/\n/*|            Changed module name GETLMSG to YCLMACLM               |*/\n/*|            Changed module name GETDSN  to YCLMACDS               |*/\n/*| VERS 1.03  16.12.2016 Yves Colliard                              |*/\n/*+------------------------------------------------------------------+*/\n\naddress \"ISREDIT\"\n\"MACRO (PARM) NOPROCESS\"\n\"PROCESS RANGE \"parm\n\n\"(CURLINE CURCOL) = CURSOR\"\n\nShowAct = \"Review\"\n\"(LINE) = LINE \"Curline\nparse value YCLMACDS(Line) with retc mydsn '05'x myvol\nif retc = 0 then do\n\n      xx = outtrap('tsomsg.')\n      if myvol <> \"UNIXPATH\" then do\n         address \"TSO\" \"ALLOC DUMMY DSN('\"MyDsn\"') SHR REU\"\n         retc = RC\n         xx = outtrap('xx')\n         if retc > 0 then do\n            zedsmsg=''\n            zedlmsg=tsomsg.1\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            \"CURSOR = \"CURLINE CURCOL\n            return retc\n         end\n      end\n      else do\n         cc = syscalls(\"ON\")\n         address SYSCALL \"stat \"MyDsn\" st.\"\n         if st.0 = 0 then do\n            zedsmsg=''\n            zedlmsg=\"File '\"MyDsn\"' nicht vorhanden.\"\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            \"CURSOR = \"CURLINE CURCOL\n            return 8\n         end\n      end\n\n   if myvol = \"\" | myvol = \"UNIXPATH\" then do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC \"SELECT CMD(REV '\"MyDsn\"') SUSPEND\"\n      if rc=20 then call not_found\n      retc = rc\n   end\n   else do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC \"SELECT CMD(REV '\"MyDsn\"' VOLUME(\"myvol\")) SUSPEND\"\n      if rc=20 then call not_found\n      retc = rc\n   end\n\nend\n\"CURSOR = \"CURLINE CURCOL\nreturn retc\nnot_found:\n  zedsmsg = \"\"\n  zedlmsg = \"REVIEW command not found - must first be installed\"\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y$RU": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x00\\x01\\x18\\x06\\x1f\\x01\\x18\\x06\\x1f\\x16\\x16\\x00f\\x00f\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2018-03-02T00:00:00", "modifydate": "2018-03-02T16:16:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| Ruler - Display a Ruler as a note below the current cursor pos   |*/\n/*|         define :RU or :RU1 as a PFK to simplify usage|           |*/\n/*+------------------------------------------------------------------+*/\n/*| RU will create a ruler as a note starting at cursor position     |*/\n/*| Example:      X <== Cursor is here when RULER starts             |*/\n/*|               ----+----1----+----2----+----3----+----4----+---...|*/\n/*| RU# (any number from 1-...) will give the column number on 10th  |*/\n/*|               ----+---10----+---20----+----30-...--150----+---...|*/\n/*+------------------------------------------------------------------+*/\n\n/* Based on - many thanks to Norbert Haas                             */\n/* REXX ------------------------------------------------------------- */\n/* Name:         RULER                                                */\n/* Type:         Macro                                                */\n/* Author:       Norbert Haas                                         */\n/* Date:         21.12.2017                                           */\n/* Syntax:       Linecommand RULER and cursor within data             */\n/* Parameter:    none                                                 */\n/* Description:  Shows a ruler from the cursor position               */\n/* Example:      X <== Cursor is here when RULER starts               */\n/*               ----+----1----+----2----+----3----+----4----+----5...*/\n/* Comment:      Works perfect, if command RULER is on a PF-key       */\n/*                                                                    */\n/* Vers.  Date       Author    Reason                                 */\n/* ------ ---------- --------- -------------------------------------- */\n/* V03.01 02.03.2018 Y.Colliard                                       */\n/* V02.01 21.12.2017 N.Haas    New Version (engl.)                    */\n/* V01.01 29.02.2007 N.Haas    Creation (\u00a7 Ford)                      */\n/* ------------------------------------------------------------------ */\n\n\nADDRESS ISREDIT\n\n\"MACRO   (PARM) NOPROCESS\"                   /* Get line command    */\n\nparse var parm \"RU\" numb\nselect\nwhen numb=\"\"              then numb=0 /* line ruler        */\nwhen datatype(numb)=\"NUM\" then numb=1 /* with number       */\notherwise\n  ZedSMsg = \"Value not numeric\"\n  ZedLMsg = \"This cannot happen|\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  exit\nend\n/* */\n\"(dmy, col) = CURSOR\"\n\"(dw) = SAVE_LENGTH\" dmy\nif rc=6 then do /* not variable */\n  \"(dw) = LRECL\"\nend\nif col = 0 then col = 1        /* added by LBD */\nrl = dw - col + 1\nif rl<1 then do\n  ZedSMsg = \"Cursor pos error\"\n  ZedLMsg = \"Cursor position not within line\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  exit\nend\n/* setup */\nruler = COPIES(' ', col-1)\n/* */\nselect\nwhen numb=0 then do /* line ruler */\n  /* */\n  rul=\"----+----1----+----2----+----3----+----4----+----5\"\n  rul=rul\"----+----6----+----7----+----8----+----9----+----0\"\n  /* first setting */\n  ruler=ruler\"\"left(rul,min(rl,100))\n  rl=rl-min(rl,100)\n  /* more than 100 */\n  DO while rl>0\n    ruler=ruler\"\"left(rul,min(rl,100))\n    rl=rl-min(rl,100)\n  END\n  /* insert note */\n  \"LINE_AFTER .ZCSR = INFOLINE (ruler)\"\nend\notherwise           /* line ruler with nmbers */\n  /* */\n  if rl>99999 then do\n    ZedSMsg = \"not supported\"\n    ZedLMsg = \"more than 99999 cols not supported:\" rl\n    Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n    exit\n  end\n  /* */\n  DO cnt=10 to rl by 10\n    ruler = ruler\"----+\"RIGHT(cnt,5,\"-\")\n  END\n  ruler=left(ruler\"-----+----\",dw)\n  /* insert notes */\n  \"LINE_AFTER .ZCSR = INFOLINE (ruler)\"\nend\n/* set cursor */\n\"CURSOR = \"dmy col\nlcmd=\"\"\nreturn 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACDS": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x18\\x14/\\x01\\x18\\x14/\\x18\\x18\\x012\\x012\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2018-05-22T18:18:00", "lines": 306, "newlines": 306, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*|                                                                  |*/\n/*| Function YCLMACDS: Extract dataset name from line(s) of          |*/\n/*|                   edited data set.                               |*/\n/*|                   2013-06-11                                     |*/\n/*| Author:           Juergen Eberle                                 |*/\n/*| Email:            Juergen.Eberle\u00a7huk-coburg.de                   |*/\n/*+------------------------------------------------------------------+*/\n/*|                                                                  |*/\n/*| This Rexx uses the Doug Nadel marvellous program|                |*/\n/*| This LMAC program as to run, be customized and an initial        |*/\n/*| macro as to be set                                               |*/\n/*| download LMAC from IBM:                                          |*/\n/*| http://www-01.ibm.com/support/docview.wss?uid=swg24014047        |*/\n/*|                                                                  |*/\n/*| Integrated within z/OS 1.13|                                     |*/\n/*|                                                                  |*/\n/*|                                                                  |*/\n/*+------------------------------------------------------------------+*/\n/*| VERS 2.21  06.05.2018 Yves Colliard                              |*/\n/*|            Change of DSN chars based on a good idea from         |*/\n/*|            Stefan Mitterer| Thanks                               |*/\n/*| VERS 1.01  11.06.2013 Juergen Eberle                             |*/\n/*|            Added code to resolve system symbols in DSN.          |*/\n/*| VERS 1.00  11.06.2013 Juergen Eberle                             |*/\n/*|            Move YCLMACDS to a separate member - external function. |*/\n/*+------------------------------------------------------------------+*/\naddress \"ISREDIT\"\n\n\"(CURLINE CURCOL) = CURSOR\"\n\"(START) = LINENUM .ZFRANGE\"   /* Get 1st line number in the range    */\n\"(STOP)  = LINENUM .ZLRANGE\"   /* Get last line number in the range   */\n\"(DW)    = DATA_WIDTH\"         /* Get the width of the editable data  */\n\"(LEFT,RIGHT) = BOUNDS\"        /* Get the BOUNDS                      */\n\n/* yves */\nsep='05'x       /* 2.9 */\nRC = 0          /* 2.9 */\n/* T        = Translate(Arg(1)) */\nT = arg(1)\ndsn   =\"\"\nvolser=\"\"\nif curcol>0 then do\n  call lmaccsrp T, curcol                                 /* 2.12 HUK */\n  dsn = result                                            /* 2.12 HUK */\nend\nif dsn <> \"\" then do                                      /* 2.12 HUK */\n   if pos(\"/\",dsn) > 0 then do                            /* 2.12 HUK */\n      dsn = strip(dsn,\"B\",\"'\")                            /* 2.12 HUK */\n      sep = sep\"UNIXPATH\"                                 /* 2.12 HUK */\n   end                                                    /* 2.12 HUK */\nend                                                       /* 2.12 HUK */\nelse do                                                   /* 2.12 HUK */\n   if left(T,2)=\"//\" then do\n     parse Var T teil1 teil2 teil3 .\n     yanf = Start\n     yend = Start\n     if teil2 <> \"DD\" & pos(\"LIKE=\",T)=0 then do\n        yl=teil2\n        /* search begin */\n        trop=\"N\"\n        do j=start-1 to 1 by -1 until trop=\"Y\"\n           \"(YLIN) = LINE \"j     /* Get previous line                  */\n           parse Var YLIN teil1 teil2 teil3 .\n           if left(teil1,3)<>\"//*\" & teil2 =\"DD\" then do\n              trop = \"Y\"\n           end\n        end\n        if trop = \"Y\" then do\n           yanf = J\n       /*  say yanf \"LINE\" ylin */\n        end\n     end\n     else do\n        yl=teil3\n     end\n     if right(strip(yl),1)=\",\" then do\n        /* search End */\n        \"(TLINE) = LINENUM .ZLAST\"\n        do j=start+1 to TLINE until right(strip(yl),1)<>\",\"\n           \"(YLIN) = LINE \"j     /* Get previous line                  */\n           parse Var YLIN teil1 yl .\n           if left(teil1,3)=\"//*\" then do\n              yl=\",\"\n           end\n        end\n        yend = J\n     /* say yend \"LINE\" ylin */\n     end\n     /* say \"Anf\" yanf \"End\" yend */\n\n     /* search DSN & VOLSER  */\n                       /* until (dsn<>\"\" & volser<>\"\") */\n     do j=yanf to yend until (dsn<>\"\" & volser<>\"\")\n       \"(YLIN) = LINE \"j     /* Get the line                       */\n       if dsn=\"\" then do\n          Parse    Var ylin t1 \"DSN=\" DSN \",\" .\n          if left(t1,3)<>\"//*\" | ,\n             (left(t1,3)=\"//*\" & yanf=yend) then do\n             if Dsn = \"\" then Parse Var ylin . \"DSNAME=\" Dsn \",\" .\n   /*\n             if Dsn = \"\" & pos(\"JCLLIB\",ylin)>0 then do\n               Parse Var ylin \"JCLLIB\" \"ORDER=\"Dsn .\n               Parse Var dsn . \"(\" dsn \")\" .\n               Parse Var dsn dsn \",\" .\n             end\n   */\n             if Dsn = \"\" & pos(\"LIKE=\",ylin)>0 & start=j then do\n               Parse Var ylin \"LIKE=\"Dsn \",\" .\n             end\n          end\n          else do\n             dsn=\"\"\n         end\n       end\n       if volser=\"\" then do\n          Parse    Var ylin t1 \"VOL=SER=\" volser \",\" .\n          if left(t1,3)=\"//*\" then do\n             volser=\"\"\n         end\n       end\n     end\n     dsn=strip(dsn)\n     dsn=strip(dsn,\"B\",\"'\")\n     /* 2.9 check for path */\n     if dsn=\"\" then do                                           /* 2.9 */\n       do j=yanf to yend until (dsn<>\"\")                         /* 2.9 */\n         \"(YLIN) = LINE \"j     /* Get the line           */      /* 2.9 */\n         Parse    Var ylin \"PATH='\" DSN \"'\" .                    /* 2.9 */\n       end                                                       /* 2.9 */\n       dsn=strip(dsn)                                            /* 2.9 */\n       if dsn<>\"\" then do                                        /* 2.9 */\n         sep=sep\"UNIXPATH\"                                       /* 2.9 */\n       end                                                       /* 2.9 */\n     end                                                         /* 2.9 */\n   end\n                                                      /* Eberle  120720 */\n   /* next 34 lines moved                                Eberle  120720 */\n                                                      /* Eberle  120720 */\n   if Dsn = \"\" then do\n     if left(T,3)=\"//*\" then do\n       select\n       when pos(\"DSN=\",T)>0 then do\n         parse var T \"DSN=\" dsn \",\" .\n         dsn=strip(dsn)\n       end\n       when pos(\"DSNAME=\",T)>0 then do\n         parse var T \"DSNAME=\" dsn \",\" .\n         dsn=strip(dsn)\n       end\n       otherwise\n         nop\n       end\n     end\n     else do /* it is not a JCL */\n                                                     /* Eberle  120720 */\n     /* 34 lines moved to here                          Eberle  120720 */\n                                                     /* Eberle  120720 */\n        \"(zz ss) = Cursor\"                           /* Eberle  120720 */\n        if ss = 0 then ss = 1                        /* Eberle  120720 */\n        if POS(\".\",T,ss) > 0 then do                 /* Eberle  120720 */\n           wo = POS(\".\",T,ss)                        /* Eberle  120720 */\n                                                     /* Eberle  120720 */\n           if wo>1 & wo<dw-1 then do\n             dsnc=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#\u00a7$-.&*%\"  /* ?.?? SM */\n             fnda=\"NO\"\n             do i=wo-1 to 1 by -1 until fnda<>\"NO\"\n                if pos(substr(T,i,1),dsnc)=0 then\n                   fnda=I\n             end\n             fnde=\"NO\"\n             do i=wo+1 to dw until fnde<>\"NO\"\n                if pos(substr(T,i,1),dsnc)=0 then\n                   fnde=I\n             end\n             if substr(T,fnde,1)=\"(\" then do\n               fndm=\"NO\"\n               do i=fnde+1 to dw until fndm<>\"NO\"\n                  if pos(substr(T,i,1),dsnc)=0 then\n                     fndm=I\n               end\n               if fndm <> \"NO\" & substr(T,fndm,1)=\")\" then do\n                  fnde = fndm + 1\n               end\n             end\n             if fnda=\"NO\" then\n                fnda=0\n             if fnde=\"NO\" then\n                dsn=\"\"\n             else\n               dsn = substr(T,fnda+1,fnde-fnda-1)\n           end\n        end\n     end\n   end\nend                                                               /* 2.12 HUK */\nif       Dsn = \"\" then do\n         ZedSMsg = yclmaclm(4)\n         ZedLMsg = yclmaclm(5)\n         \"cursor = .ZFRANGE 0\"                                    /* 2.12 HUK */\n         Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n         Return 8 Dsn\"\"sep\"\"volser\nend\n\nParse    Var Dsn Dsn .\n\n/* try to solve &dsn using system symbols and // JCL SET - 2.13 */\nii = 1\nii=Pos(\"&\",Dsn)\ndo while ii > 0\n   iimin1=ii-1\n   if iimin1>0 then do\n     Parse Var Dsn  Dsn1 +(iimin1) +1 Dsn2 .\n   end\n   else do\n     Dsn1=\"\"\n     Parse Var Dsn  +1 Dsn2 .\n   end\n   if Dsn2 <> \"\" then do\n      parse var Dsn2 Dsn2 \".\" Dsn3\n      kdsn2=dsn2\n      if length(Dsn2)<9 then do\n        if dsn2=\"SYSUID\" then dsn2=userid()  /* 2.14 */\n        else dsn2 = mvsvar(\"SYMDEF\",Dsn2)\n        if dsn2<>\"\" then kdsn2=dsn2\n      end\n      else do\n        dsn2=\"\"\n      end\n      redo=\"N\"\n      if dsn2=\"\" & start > 1 & left(T,2)=\"//\" then do\n        do j=start-1 to 1 by -1\n          \"(xstat) = XSTATUS \"j\n          if xstat = \"NX\" then do\n            \"(YLIN) = LINE \"j\n            select\n            when left(ylin,3)=\"//*\" then nop /* no comment */\n            when left(ylin,2)<>\"//\" then nop /* no jcl     */\n            otherwise\n              parse var ylin . jc2 jc3 .\n              if jc2=\"SET\" then do\n                parse var jc3 jc3 \"=\" jc4 .\n                if strip(jc3)=kdsn2 & jc4<>\"\" then do\n                  dsn2=strip(jc4,\"B\",\"'\")\n                  if pos(\"&\",jc4)>0 then do\n                    redo=\"Y\"\n                    dsn2=dsn2\".\"\n                  end\n                  kdsn2=dsn2\n                  j=0\n                end\n              end\n            end\n          end\n        end\n      end\n      if dsn2<>kdsn2 & redo=\"N\" then dsn2=\"&\"kdsn2\n      dsn = Dsn1||Dsn2||Dsn3\n      if redo=\"N\" then do\n        ii=ii+length(dsn2)\n        ii=Pos(\"&\",Dsn,ii)\n      end\n      else do\n        ii=Pos(\"&\",Dsn,ii)\n      end\n   end\nend\n\nParse    var Dsn  DsnN \"(\" DsnM \")\" .\nif       Pos(\"&\",DsnM) > 0 then Dsn = DsnN\n\nif length(strip(volser))<>6 then do\n   volser=\"\"\nend\n\nReturn RC Dsn\"\"sep\"\"volser\n\n/* Evaluate DSN or Path around current cursor position                        */\n\nlmaccsrp:\nparse arg line, curcol\n\nAddress  ISPEXEC \"CONTROL ERRORS RETURN\"       /* Return ispf errors  */\n\nparse var line p1 =(curcol) p2\nparse value reverse(p1) with t1 \",\" ,\n                           1 t2 \"=\" ,\n                           1 t3 \",\" ,\n                           1 t4 \" \"\nml=min(length(t1),length(t2),length(t3),length(t4))\nparse value         p2  with t1 \",\" ,\n                           1 t2 \"=\" ,\n                           1 t3 \",\" ,\n                           1 t4 \" \"\nmx=min(length(t1),length(t2),length(t3),length(t4))\n\ndsn=substr(line,curcol-ml,ml+mx)\ndsn = strip(dsn,\"B\")\n\nreturn dsn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACHG": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x16\\x00@\\x01\\x18\\x14/\\x01\\x19$/\\x06P\\x00\\xf0\\x00\\xf0\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "02.22", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2019-08-30T06:50:40", "lines": 240, "newlines": 240, "modlines": 0, "user": "SLBD"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-18                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*|                                                                  |*/\n/*| Summary of old changes to reduce the size of the rexx            |*/\n/*|                                                                  |*/\n/*+------------------------------------------------------------------+*/\n/*|                                                                  |*/\n/*| Vers 2.20  02.03.2018 Yves Colliard                              |*/\n/*|            - Extention of YCLMACRX to execute                    |*/\n/*|              the RU command - RULER                              |*/\n/*| Based on - many thanks to Norbert Haas                           |*/\n/*| Name:        RULER                                               |*/\n/*| Type:        Macro                                               |*/\n/*| Author:      Norbert Haas                                        |*/\n/*|              Y$RU member needed                                  |*/\n/*| Vers 2.19  17.07.2017 Yves Colliard                              |*/\n/*|            - Extention of YCLMACRX to execute                    |*/\n/*|              SA System Automation Commands                       |*/\n/*|              |||| SUPPORT MUST BE ENABLED WITHIN SA ||||||       |*/\n/*|            - Extention of YCLMACRX to execute                    |*/\n/*|              ISPF Commands                                       |*/\n/*| Vers 2.18  16.11.2016 Juergen Eberle                             |*/\n/*|            - Redesigned check_ext_macro                          |*/\n/*|              o Removed IBM restriction, which limits LMINIT for  |*/\n/*|                DDNAME to 16 datasets in concatenation.           |*/\n/*|                                                                  |*/\n/*|            - Corrected error in CM when JCL already had comment  |*/\n/*|              lines within a block CMM -- CMM                     |*/\n/*|              o When inside a CMM -- CMM block of JCL statements  |*/\n/*|                there are already comment lines after CMM -- CMM  |*/\n/*|                the job ends at the first original JCL Comment.   |*/\n/*|                                                                  |*/\n/*|            Bruce Koss and Lionel B. Dyck                         |*/\n/*|            - Support Y$HC                                        |*/\n/*|            - Support Y$PDS                                       |*/\n/*|            - Support Y$PG                                        |*/\n/*|            - Enhance Installation                                |*/\n/*| Vers 2.17  20.04.2016 Juergen Eberle                             |*/\n/*|            - Redesigned REXX:                                    |*/\n/*|              o Removed GETDSN - is now a external function and   |*/\n/*|                so also available for external extentions to      |*/\n/*|                this REXX called from here with name Y$lcmdname.  |*/\n/*|              o Removed SETMYMSG and YLANG - is now external      |*/\n/*|                function GETLMSG and allows external extentions   |*/\n/*|                to get common LINEMAC messages.                   |*/\n/*|              o Removed all references for REView in this REXX.   |*/\n/*|                Created Y$REV as external line command for those  |*/\n/*|                who use REVIEW.                                   |*/\n/*|              o Replaced all calls to GETDSN to receive extra RC  |*/\n/*|                e.g. PARSE VALUE GETDSN(dsn) WITH rc dsn '05'x vol|*/\n/*|              o Replaced all references to yms.mylang.xx with     |*/\n/*|                call to function GETLMSG(nn).                     |*/\n/*|              o Added call to YCLMAHLU from YCLMAHLP to add help  |*/\n/*|                for external user line commands.                  |*/\n/*|            14.11.2016 Yves Colliard                              |*/\n/*|            - Support for ELCO from Robert AH Prins - Thanks      |*/\n/*|              o better than CL - since lines to be comapred can   |*/\n/*|                be marked with .EF .EL labels|                    |*/\n/*|            - Correct CM JCL - column 70 not moved                |*/\n/*|            - DI & DA support EAV and PDSE2                       |*/\n/*| Vers 2.16  31.07.2015 Yves Colliard                              |*/\n/*|            - Redesign Help - support for compile rexx            |*/\n/*|            - Support for FA# (FA already supported)              |*/\n/*|              FindAll  where the cursor is placed - or first word |*/\n/*|                       other lines will be excluded               |*/\n/*|              Multi: FA#                                          |*/\n/*|                       will also show # lines before and after    |*/\n/*|            - JU support for EXPORT JCL statement - z/OS 2.1      |*/\n/*|            - HV support for Help in View mode                    |*/\n/*|                                                                  |*/\n/*| ALL Other changes in YCLMACHG|                                   |*/\n/*| EZ, VZ and DZ needs also YCLMACNS Rexx to be installed           |*/\n/*| Vers 2.15  01.09.2014 Yves Colliard                              |*/\n/*|            - Integrated new functions from Hans-Peter Bodden IVV |*/\n/*|              . support for FI - Find first                       |*/\n/*|              . support for FL - Find last                        |*/\n/*|              . support for FA - Find all (with Exlude)           |*/\n/*|            - Support for EZ und VZ                               |*/\n/*|              . Edit/View in new Split Screen                     |*/\n/*|            - Support for DZ#                                     |*/\n/*|              . Dslist/Dirlist in new Split Screen                |*/\n/*| Vers 2.14  21.07.2014 Yves Colliard                              |*/\n/*|            - Support YD - hex data as note                       |*/\n/*|            - Support LN - line size for variable datasets        |*/\n/*|              many thanks to Michael Pollak from Fiducia|         |*/\n/*|            - Greater temp allocation to support more output      |*/\n/*|            - Support batch background call of EXecute IKJEFT01   |*/\n/*|              Only TSO supported                                  |*/\n/*|            - Support for foreground call of EXecute              |*/\n/*|              TSO YCLMACRX TSO H ALLOC                            |*/\n/*|              TSO YCLMACRX SDSF D A                               |*/\n/*|              TSO YCLMACRX UNIX ls                                |*/\n/*|              TSO YCLMACRX UNIXSU ls                              |*/\n/*|              TSO YCLMACRX UDLIST /u                              |*/\n/*|              TSO YCLMACRX UFDIR  /u z*                           |*/\n/*|              TSO YCLMACRX UFFIL  /u y*                           |*/\n/*|            - JU Corrections                                      |*/\n/*|            - Small corection                                     |*/\n/*|            - &SYSUID. -> Userid                                  |*/\n/*|            - Request from Andreas Karst ARAG - Thanks|           |*/\n/*|              . support for TOPD - Delete to top of edit          |*/\n/*|              . support for BOTD - Delete to bottom of edit       |*/\n/*|            - Based on idea of Andreas Karst ARAG - Thanks|       |*/\n/*|              . support for TOPX - X to top of edit               |*/\n/*|              . support for BOTX - X to bottom of edit            |*/\n/*| Vers 2.13  08.10.2013 Yves Colliard                              |*/\n/*|            - Support for AU/AD alignment for JCL continuation    |*/\n/*|            - support CM for deleting comments within Rexx        |*/\n/*|            - try to solve symbolics using of level of JCL SET    |*/\n/*|            - NEW DA - Dataset Allocate Like: JCL and TSO         |*/\n/*|            - Small correction                                    |*/\n/*|            - Many changes to support \"wrong\" VOL=SER in JCL      |*/\n/*|            - JU Correction                                       |*/\n/*|            - REV Correction                                      |*/\n/*|            - Remove old changes to YCLMACHG                      |*/\n/*| Vers 2.12  22.07.2013 Juergen Eberle - HUK Coburg                |*/\n/*|            - Added REVIEW (http://www.prycroft6.com.au/REVIEW/)  |*/\n/*|              to browse VSAM datasets.                            |*/\n/*|              If you are using REVIEW change the                  |*/\n/*|              ISupport=\"... REV\"                                  |*/\n/*|              statement|                                          |*/\n/*|            - Added REV (=REVIEW) as separate command.            |*/\n/*|            - When searching for DSName first look whether the    |*/\n/*|              cursor is in the text field. If so, evaluate        |*/\n/*|              DSName at cursor position.                          |*/\n/*|            - Support for resolving static system symbols in      |*/\n/*|              DSNames.                                            |*/\n/*|            - Correct umlauts in various German msgs.             |*/\n/*|            - Include variable message parts in yms.mylang.2      |*/\n/*|            - Include variable message parts in yms.mylang.2      |*/\n/*|            - Correctly set cursor after execution of lcmd        |*/\n/*|            09.08.2013 Yves Colliard                              |*/\n/*|            - Support for JU Command - JCL Upper Case             |*/\n/*|            - Support for Dataset DH - Display HSM Migrate/Backup |*/\n/*|              data and give the possibility to                    |*/\n/*|              HRECALL or HRESTORE                                 |*/\n/*|              the selected data                                   |*/\n/*|                                                                  |*/\n/*| Vers 2.11  01.07.2013 Yves Colliard                              |*/\n/*|            Support for unixenv and unixsuenv - read the          |*/\n/*|            environment variables and set them for the unix       |*/\n/*|            call - for instance PATH. Also support for giving     |*/\n/*|            own environment variables, like in STDENV             |*/\n/*|                                                                  |*/\n/*| Vers 2.10  31.05.2013 Yves Colliard                              |*/\n/*|            Support Line Commands on Edit/View                    |*/\n/*|                    until IBM will solve generaly the problem|    |*/\n/*|                    thanks to Andreas Steinberg|                  |*/\n/*|            Small enhancements of the samples of EX               |*/\n/*|            Small enhancement on SDSF                             |*/\n/*|            Older support pre z/OS 1.11 deleted                   |*/\n/*|                                                                  |*/\n/*| Vers 2.9   17.05.2013 Yves Colliard                              |*/\n/*|            Distribute some files with typical commands:          |*/\n/*|              - LMACTSO                                           |*/\n/*|              - LMACMVS                                           |*/\n/*|              - LMACUSS                                           |*/\n/*|              - LMACJES3                                          |*/\n/*|              to be executed with the EX line command             |*/\n/*|            Support for EX UFFIL  - like USS FIND File and 3.17   |*/\n/*|            Support for Help from outside - TSO YCLMACRX          |*/\n/*|            Support for External call of the EX function:         |*/\n/*|              TSO YCLMACRX tso lista st h                         |*/\n/*|              TSO YCLMACRX sdsf d a,l                             |*/\n/*|              TSO YCLMACRX ejes d a,l                             |*/\n/*|              TSO YCLMACRX unix ps -le                            |*/\n/*|              TSO YCLMACRX unixsu ps -le                          |*/\n/*|              TSO YCLMACRX udlist /u/zfs/YVES                     |*/\n/*|              TSO YCLMACRX ufdir  /u o*                           |*/\n/*|              TSO YCLMACRX uffil  /u/zfs/YVES *y*                 |*/\n/*|            Support for // JCL PATH='path name' for fucntions:    |*/\n/*|              E-Edit, V-View, DS and DX-Dataset Levels            |*/\n/*|                                                                  |*/\n/*| Vers 2.80  21.03.2013 Yves Colliard                              |*/\n/*|            Support for EX UDLIST - like 3.17                     |*/\n/*|            Support for EX UFDIR  - like USS FIND DIR and 3.17    |*/\n/*|            Support for EJES Command interface - Line Command EX  |*/\n/*|              EJES (c) product from PHOENIX Software              |*/\n/*|            Improve greatly the CL Command programming|           |*/\n/*|              many thanks to Robert AH Prins|                     |*/\n/*| Vers 2.70  29.09.2012 Yves Colliard                              |*/\n/*|            Correct CM with line num - because of continuation    |*/\n/*| Vers 2.60  26.09.2012 Yves Colliard                              |*/\n/*|            Distribute ISPF Table for z/OS 1.13                   |*/\n/*|            Correct CM with line num                              |*/\n/*|            Support for EX - Execute SDSF Commands                |*/\n/*|            Support for EX - Execute Unix Commands                |*/\n/*|            Support for EX - Execute Unix Commands in SU Mode     |*/\n/*| Vers 2.50  19.09.2012 Yves Colliard - new name for Table         |*/\n/*| Vers 2.40  01.08.2012 JUERGEN EBERLE                             |*/\n/*|            Corrected H/Help bug. when h was issued in the first  |*/\n/*|            line of a screen after page down the help text        |*/\n/*|            appeared on the last page and you had to page up      |*/\n/*|            to see the help text.                                 |*/\n/*|            Honoring BNDS set for commands RV, CE, AL, AR, AU,    |*/\n/*|            AD, CL, AE, EA, which modify data.                    |*/\n/*|            (Dataset commands still work at complete line.)       |*/\n/*| Vers 2.30  27.07.2012 Juergen Eberle                             |*/\n/*|            Removed JCLLIB seqence. JCLLIB allows \"(\" and \")\"     |*/\n/*|            and more than one DSN. This is covered already with   |*/\n/*|            Vers. 2.10.                                           |*/\n/*| Vers 2.20  26.07.2012 Juergen Eberle                             |*/\n/*|            Added support for routing line commands not           |*/\n/*|            implemented by this EXEC to a external EXEC L$cmd     |*/\n/*|            (e.g. for Y = L$Y). If routine not found, then        |*/\n/*|            error message.                                        |*/\n/*| Vers 2.10  20.07.2012 Juergen Eberle                             |*/\n/*|            Added support for dataset services for JCL Statements |*/\n/*|            which are NOT DD statements (e.g. PROC), where a      |*/\n/*|            DSN is coded after a PARM= parameter statement.       |*/\n/*|            If more than one nn.nn.nn then process the first      |*/\n/*|            or the one pointed to by cursor position.             |*/\n/*|            If VOL is used for dataset search add VOL for         |*/\n/*|            error messages.                                       |*/\n/*| Vers 2.00  14.05.2012 Juergen Eberle                             |*/\n/*|            Danke|                                                |*/\n/*|            he has fixed some bugs and made changes for zOS 1.13  |*/\n/*| Vers 1.90  12.09.2011 Yves Colliard                              |*/\n/*|            TEMPORARY FIX FOR Mr. Schreier in Wien|               |*/\n/*|            enhanced support for dataset in JCL                   |*/\n/*|              - support //comment DSN=                            |*/\n/*|              - support //   ...  LIKE=                           |*/\n/*|              - support //   ...  DSN='d.a.t.a'                   |*/\n/*| Vers 1.80  29.09.2011 Yves Colliard                              |*/\n/*|            support new CL command - compare two lines            |*/\n/*|            support for JCLLIB ORDER= in                          |*/\n/*|              dataset line commands                               |*/\n/*|            change alloc to bpxwdyn                               |*/\n/*| Vers 1.70  23.03.2011 Yves Colliard                              |*/\n/*| Vers 1.60  12.04.2010 Yves Colliard                              |*/\n/*| Vers 1.50  01.02.2008 Yves Colliard                              |*/\n/*| Vers 1.40  20.04.2005 Yves Colliard                              |*/\n/*| Vers 1.30  04.10.2004 Yves Colliard                              |*/\n/*+------------------------------------------------------------------+*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACLM": {"ttr": 2060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x12\\x00\\x00\\x01\\x165\\x0f\\x01\\x165\\x0f\"\"\\x00\\x98\\x00\\x98\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.18", "flags": 0, "createdate": "2016-12-15T00:00:00", "modifydate": "2016-12-15T22:22:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*|                                                                  |*/\n/*| Function YCLMACLM: External function to get messages common to   |*/\n/*|                   LINEMAC commands.                              |*/\n/*|                                                                  |*/\n/*| Author:           Juergen Eberle                                 |*/\n/*| Email:            Juergen.Eberle\u00a7huk-coburg.de                   |*/\n/*+------------------------------------------------------------------+*/\n/*| VERS 1.01  11.06.2013 Juergen Eberle                             |*/\n/*|            Added code to resolve system symbols in DSN.          |*/\n/*| VERS 1.00  11.06.2013 Juergen Eberle                             |*/\n/*|            Move YCLMACDS to a separate member.external function. |*/\n/*+------------------------------------------------------------------+*/\n\narg msgid\n\nmylang=ylang()\n/* Comment Start\nmylang=\"DEU\"\n   Comment End */\ncall setmymsg mylang msgid\n\nreturn result\n\nsetmymsg: procedure\narg mylang msgid\n\nif mylang=\"DEU\" then do\nyms.DEU.1 = \"nur 1 Zeile ausw{hlen\"\nyms.DEU.2 = \"'Line command '\"LCMD\"' kann nur auf eine Zeile\",\n                      \"angewendet werden'\"\nyms.DEU.3 = \"fehlerhaft\"\nyms.DEU.4 = \"DSN nicht erkannt\"\nyms.DEU.5 = \"'DSN=', 'DSNAME=' oder \"PATH=\" wurde nicht\",     /* 2.12 HUK */\n            \"erkannt oder Cusor nicht auf Dateiname/Pfadname/Filename\"\nyms.DEU.6 = \"nicht gefunden\"\nyms.DEU.7 = \"abgebrochen\"\nyms.DEU.8 = \" Dateiname . . . . . . :\"\nyms.DEU.9 = \" Allgemeine Angaben:                   Z. Zt. angelegt:\"\nyms.DEU.10= \"  Verwaltungsklasse  . :\"\nyms.DEU.11= \" Angelegte . . . . . :\"\nyms.DEU.12= \"  Speicherklasse . . . :\"\nyms.DEU.13= \" Bereiche  . . . . . :\"\nyms.DEU.14= \"   Datentr{ger . . . . :\"                          /* 2.12 HUK */\nyms.DEU.15= \"   Einheitentyp  . . . :\"\nyms.DEU.16= \"  Datenklasse  . . . . :\"\nyms.DEU.17= \"Z. Zt. benutzt:\"\nyms.DEU.18= \"   Organisation  . . . :\"\nyms.DEU.19= \" Benutzte\"\nyms.DEU.20= \"   Satzformat  . . . . :\"\nyms.DEU.21= \" Bereiche  . . . . . :\"\nyms.DEU.22= \"   Satzl{nge . . . . . :\"                           /* 2.12 HUK */\nyms.DEU.23= \"   Blockgr\u00a6~e  . . . . :\"                           /* 2.12 HUK */\nyms.DEU.24= \"   Prim{re\"                                         /* 2.12 HUK */\nyms.DEU.25= \"   Sekund{re\"                                       /* 2.12 HUK */\nyms.DEU.26= \" Verzeichnisbl\u00a6cke . :\"                             /* 2.12 HUK */\nyms.DEU.27= \" (Maximum)\"\nyms.DEU.28= \" Seiten  . . . . . . :\"\nyms.DEU.29= \" % Prozentual  . . . :\"\nyms.DEU.30= \" Anzahl der Member . :\"\nyms.DEU.31= \"   Dateinamenstyp  . . :\"\nyms.DEU.32= \" Angelegte\"\nyms.DEU.33= \" Benutzte\"\nyms.DEU.34= \"   Erstellungsdatum  . :\"\nyms.DEU.35= \" Bezugsdatum . . . . :\"\nyms.DEU.36= \"   Verfallsdatum . . . :\"\nyms.DEU.37= \"Bl\u00a6cke Spuren Zylinder Bytes Kylobytes Megabytes\"   /* 2.12 HUK */\nyms.DEU.38= \" Bereiche  . . . . . :\"\nyms.DEU.39= \"nicht m\u00a6glich\"                                      /* 2.12 HUK */\nyms.DEU.40= \"AU Align Up nicht m\u00a6glich auf erste Zeile\"          /* 2.12 HUK */\nyms.DEU.41= \"AD Align Down nicht m\u00a6glich auf letzte Zeile\"       /* 2.12 HUK */\nyms.DEU.42= \"Keine Non-Excluded Zeile gefunden\"                  /* 2.12 HUK */\nyms.DEU.43= \" SMS Compressible  . :\"                             /* 2.12 HUK */\nyms.DEU.44= \" Verzeichnisbl\u00a6cke . :\"                             /* 2.12 HUK */\nyms.DEU.45= \"Datei wird von einem anderen User benutzt\"\nyms.DEU.46= \"Member wird bereits benutzt\"\nyms.DEU.47= \"Vsam-Dateien werden nicht unterst}tzt\"              /* 2.12 HUK */\nyms.DEU.48= \"nicht gefunden/autorisiert\"\nyms.DEU.49= \"nicht gefunden oder in Benutzung\"\nyms.DEU.50= \"nicht gen}gend Platz f}r die Ausrichtung\"  /* 2.13 */\nend\nelse do\nyms.ENU.1 = \"select only one line\"\nyms.ENU.2 = \"'Line command '\"LCMD\"' can only be given on one line'\"\nyms.ENU.3 = \"error\"\nyms.ENU.4 = \"DSN not found\"\nyms.ENU.5 = \"'DSN=', 'DSNAME=' or 'PATH=' not found in the\",        /*2.12 HUK*/\n            \"line(s) or cursor not positioned on dsn/path/file.\"    /*2.12 HUK*/\nyms.ENU.6 = \"not found\"\nyms.ENU.7 = \"with error\"\nyms.ENU.8 = \" Data Set Name . . . . :\"\nyms.ENU.9 = \" General Data                           Current Allocation\"\nyms.ENU.10= \"  Management class . . :\"\nyms.ENU.11= \" Allocated . . . . . :\"\nyms.ENU.12= \"  Storage class  . . . :\"\nyms.ENU.13= \" Used Extends  . . . :\"\nyms.ENU.14= \"   Volume serial . . . :\"\nyms.ENU.15= \"   Device type . . . . :\"\nyms.ENU.16= \"  Data class . . . . . :\"\nyms.ENU.17= \"Current Utilization\"\nyms.ENU.18= \"   Organization  . . . :\"\nyms.ENU.19= \" Used\"\nyms.ENU.20= \"   Record format . . . :\"\nyms.ENU.21= \" Allocated extents . :\"\nyms.ENU.22= \"   Record length . . . :\"\nyms.ENU.23= \"   Block size  . . . . :\"\nyms.ENU.24= \"   1st extent \"\nyms.ENU.25= \"   Secondary \"\nyms.ENU.26= \" Maximum dir. blocks :\"\nyms.ENU.27= \"\"\nyms.ENU.28= \" Used pages  . . . . :\"\nyms.ENU.29= \" % Utilized  . . . . :\"\nyms.ENU.30= \" Number of members . :\"\nyms.ENU.31= \"   Data set name type  :\"\nyms.ENU.32= \" Allocated\"\nyms.ENU.33= \" Used\"\nyms.ENU.34= \"   Creation date . . . :\"\nyms.ENU.35= \" Referenced date . . :\"\nyms.ENU.36= \"   Expiration date . . :\"\nyms.ENU.37= \"blocks tracks cylinders bytes kylobytes megabytes\"\nyms.ENU.38= \" Used extents  . . . :\"\nyms.ENU.39= \"not allowed\"\nyms.ENU.40= \"AU Align Up not allowed on first line\"\nyms.ENU.41= \"AD Align Down not allowed on last line\"\nyms.ENU.42= \"No Non-Excluded line found\"\nyms.ENU.43= \" SMS Compressible  . :\"\nyms.ENU.44= \" Used dir. blocks . .:\"\nyms.ENU.45= \"Dataset in use by another user\"\nyms.ENU.46= \"Member in use\"                     /* Eberle 120720 */\nyms.ENU.47= \"Vsam-datasets not supported\"\nyms.ENU.48= \"not found/authorized\"\nyms.ENU.49= \"not found or in use\"\nyms.ENU.50= \"not enough place to align\"   /* 2.13 */\nend\n\nmessage = yms.mylang.msgid\nreturn message\n\nylang: procedure\nNumeric  Digits 10                      /*Allow for big addresses    */\nTCBAddr  = C2D(       Storage(D2X(540                 ),  4) )\nJSCBAddr = C2D(       Storage(D2X(TCBAddr  +       180),  4) )\nPSCBAddr = C2D(       Storage(D2X(JSCBAddr +       264),  4) )\nUPTAddr  = C2D(       Storage(D2X(PSCBAddr +        52),  4) )\nUpt      = Storage(D2X(UptAddr),176)\nPLang    = SubStr(Upt,25,3)\nreturn plang\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACNS": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x161\\x9f\\x01\\x161\\x9f\\x17\\x17\\x00\\xa1\\x00\\xa1\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2016-11-14T00:00:00", "modifydate": "2016-11-14T17:17:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACNS     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2014-16                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*| Support for Split Screen functions within YCLMACRX               |*/\n/*| - E    : Edit - EZ Line Command                                  |*/\n/*| - EU   : Edit Unix - EZ Line Command                             |*/\n/*| - V    : View - VZ Line Command                                  |*/\n/*| - VU   : View Unix - VZ Line Command                             |*/\n/*| - DZ   : DSLIST - DZ# Line Command                               |*/\n/*| - DZU  : DIrList Unix - DZ# Line Command                         |*/\n/*+------------------------------------------------------------------+*/\n/*| Vers 2.15  01.09.2014 Yves Colliard                              |*/\n/*+------------------------------------------------------------------+*/\n\nAddress  ISPEXEC \"CONTROL ERRORS RETURN\"     /* Return ispf errors  */\n\nAddress ISPEXEC \"VGET (ZOS390RL)\"\n                   /* \"z/OS   01.13.00\"   */\ned_parms=\"\"\nif ZOS390RL = \"z/OS   01.13.00\" |,\n   left(ZOS390RL,10)=\"z/OS   02.\" then do\n  Address ISPEXEC \"VGET (ZLMAC)\"\n  if ZLMAC <> \"\" then do\n    ed_parms=\" LINECMDS(\"strip(ZLMAC)\")\"\n  end\nend\n\nparse arg What Todo\n\nselect\nwhen what=\"E\" then do  /* Edit */\n  parse var Todo mydsn myvol\n  ZedSMsg = \"\"\n  ZedLMsg = \"Edit\" MyDsn\" in new Split Screen\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  Address ISPEXEC \"EDIT DATASET('\"MyDsn\"')\",\n          \"VOLUME(\"myvol\")\"ed_parms\n  if RC>4 then do\n    ZedSMsg = \"\"\n    ZedLMsg = \"Problem during Edit\" MyDsn\" Return Code:\"RC\n    Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  end\nend\nwhen what=\"EU\" then do  /* Edit USS */\n  parse var Todo mydsn\n  ZedSMsg = \"\"\n  ZedLMsg = \"Edit\" MyDsn\" in new Split Screen\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  Address ISPEXEC \"EDIT FILE(MyDsn) \"ed_parms\n  if RC>4 then do\n    ZedSMsg = \"\"\n    ZedLMsg = \"Problem during Edit\" MyDsn\" Return Code:\"RC\n    Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  end\nend\nwhen what=\"V\" then do  /* View */\n  parse var Todo mydsn myvol\n  ZedSMsg = \"\"\n  ZedLMsg = \"View\" MyDsn\" in new Split Screen\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  Address ISPEXEC \"VIEW DATASET('\"MyDsn\"')\",\n          \"VOLUME(\"myvol\")\"ed_parms\n  if RC>4 then do\n    ZedSMsg = \"\"\n    ZedLMsg = \"Problem during Edit\" MyDsn\" Return Code:\"RC\n    Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  end\nend\nwhen what=\"VU\" then do  /* View Unix */\n  parse var Todo mydsn\n  ZedSMsg = \"\"\n  ZedLMsg = \"View\" MyDsn\" in new Split Screen\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  Address ISPEXEC \"VIEW FILE(MyDsn) \"ed_parms\n  if RC>4 then do\n    ZedSMsg = \"\"\n    ZedLMsg = \"Problem during Edit\" MyDsn\" Return Code:\"RC\n    Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  end\nend\nwhen what=\"DZ\" then do  /* DSLIST */\n  parse var Todo mydsn myvol\n  ShowAct = \"Dslist\"                  /* 2.15 */\n  ZedSMsg = \"\"\n  ZedLMsg = \"Dslist\" MyDsn myvol\" in new Split Screen\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  Address ISPEXEC \"LMDINIT LISTID(ID) Level(\"MyDsn\")\",\n          \"VOLUME(\"MyVol\")\"\n  Address ISPEXEC \"LMDDISP LISTID(\"ID\")\"\n  DispRC = RC\n  Address ISPEXEC \"LMDFREE LISTID(\"ID\")\"\n  Address ISPEXEC \"CONTROL ERRORS CANCEL\"\n  if DispRC > 0 then do\n    ZedSMsg = \"LMDDISP-RC=\"DispRC\n                                 /* Eberle 120720 */\n    if MyVol <> \"\" then do            /* 2.13 */\n      Address ISPEXEC,\n      \"CONTROL ERRORS RETURN\"\n      Address ISPEXEC,\n      \"LMDINIT LISTID(ID) Level(\"MyDsn\")\"\n      ZedSMsg  =  \"\"\n      ZedLMsg  =  ShowAct \"without Volume\" MyVol \"in new Split Screen\"\n      Address  ISPEXEC 'SETMSG MSG(ISRZ001)'\n      Address ISPEXEC,\n      \"LMDDISP LISTID(\"ID\")\"\n      Disp2RC = RC\n      Address ISPEXEC,\n      \"LMDFREE LISTID(\"ID\")\"\n      Address ISPEXEC,\n      \"CONTROL ERRORS CANCEL\"\n      if Disp2RC > 0 then do\n        errvol = \"VOL(\"strip(MyVol,\"B\")\")\"\n        ZedSMsg = \"\"\n        ZedLMsg = \"Dslist\" MyDsn errvol\" in new Split Screen\"\n        Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n        ZedLMsg = \"LMDDISP LEVEL(\"MyDsn\")\" errvol \"Error\"\n        Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n      end\n    end\n    else do\n      ZedLMsg = \"LMDDISP LEVEL(\"MyDsn\") Error\"\n      Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n    end\n  end\nend\nwhen what=\"DZU\" then do  /* Dir file Unix */\n  parse var Todo mydsn\n  ZedSMsg = \"\"\n  ZedLMsg = \"Directory List\" MyDsn\" in new Split Screen\"\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  Address ISPEXEC \"DIRLIST PATH(mydsn)\"\n  select\n  when rc=0 then do\n    exit 0\n    end\n  when rc=8 then do\n    if lastpos(\"/\",mydsn)>0 then do\n      mydsn=left(mydsn,lastpos(\"/\",mydsn)-1)\n      ZedSMsg = \"\"\n      ZedLMsg = \"Directory List\" MyDsn\" in new Split Screen\"\n      Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n      address ispexec,\n      \"DIRLIST PATH(mydsn)\"\n    end\n  end\n  otherwise\n    ZedSMsg = \"\"\n    ZedLMsg = \"Problem during Dir List\" MyDsn\" Return Code:\"RC\n    Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n  end\nend\notherwise\n  ZedSMsg = \"\"\n  ZedLMsg = \"Unknown parameter\" what\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACRX": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x18\\x14/\\x01\\x18\\x14/\\x18\\x18\\x0c\\t\\x0c\\t\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-05-22T00:00:00", "modifydate": "2018-05-22T18:18:00", "lines": 3081, "newlines": 3081, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-18                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*|                                                                  |*/\n/*| This Rexx uses the Doug Nadel marvellous program|                |*/\n/*| This LMAC program as to run, be customized and an initial        |*/\n/*| macro as to be set                                               |*/\n/*| download LMAC from IBM:                                          |*/\n/*| http://www-01.ibm.com/support/docview.wss?uid=swg24014047        |*/\n/*|                                                                  |*/\n/*| Integrated by IBM within z/OS 1.13|                              |*/\n/*|                                                                  |*/\n/*| Fully usable starting with z/OS 2.2|                             |*/\n/*|                                                                  |*/\n/*| Installation see $$$DOC                                          |*/\n/*|                                                                  |*/\n/*+------------------------------------------------------------------+*/\n/*|                                                                  |*/\n/*| Functions of YCLMACRX:                                           |*/\n/*| H      ==>> Show help                                            |*/\n/*| HELP   ==>> Show help                                            |*/\n/*|             Help from outside - TSO YCLMACRX                     |*/\n/*|                                                                  |*/\n/*| see YCLMACHLP                                                    |*/\n/*+------------------------------------------------------------------+*/\n/*| Vers 2.21  22.05.2018 Yves Colliard                              |*/\n/*|            Change of DSN chars based on a good idea from         |*/\n/*|              Stefan Mitterer| Thanks                             |*/\n/*|              See YCLMACDS                                        |*/\n/*|            Change of ING cust                                    |*/\n/*|              Karlheinz Wittemann| Thanks                         |*/\n/*|            Correct JU for continuation and support 2.2/2.3 Stmts |*/\n/*|                                                                  |*/\n/*+------------------------------------------------------------------+*/\n\nif SYSVAR(\"SYSENV\")=\"BACK\" then do  /* 2.14 */\n  rc_ext=12       /* 2.14 */\nend               /* 2.14 */\nelse do           /* 2.14 */\n  Address  ISPEXEC \"CONTROL ERRORS RETURN\"     /* Return ispf errors  */\n\n  Address ISPEXEC \"VGET (ZOS390RL)\"                      /* 2.10 */\n                     /* \"z/OS   01.13.00\"   */           /* 2.10 */\n  ed_parms=\"\"                                            /* 2.10 */\n  if ZOS390RL = \"z/OS   01.13.00\" |,                     /* 2.10 */\n     left(ZOS390RL,10)=\"z/OS   02.\" then do              /* 2.10 */\n    Address ISPEXEC \"VGET (ZLMAC)\"                       /* 2.10 */\n    if ZLMAC <> \"\" then do                               /* 2.10 */\n      ed_parms=\" LINECMDS(\"strip(ZLMAC)\")\"               /* 2.10 */\n    end                                                  /* 2.10 */\n  end                                                    /* 2.10 */\n\n  Address  ISREDIT                             /* Start of macro      */\n  \"MACRO   (PARM) NOPROCESS\"                   /* Get line command    */\n  rc_ext=rc       /* 2.14 */\nend               /* 2.14 */\nif  rc_ext > 0 then do  /* 2.14 */\n                                                             /* 2.9 */\n  parse arg func line\n  func=translate(func)\n  select\n  when func = \"TSO\" then signal ext_tso_ex\n  when func = \"SDSF\" then do\n    world_cmd=\"SDSF\"\n    signal ext_sdsf_ex\n  end\n  when func = \"EJES\" then do\n    world_cmd=\"EJES\"\n    signal ext_sdsf_ex\n  end\n  when func = \"UNIX\" then do\n    usrsu=\"\"\n    usren=\"\"                                              /* 2.11 */\n    signal ext_unix_ex\n  end\n  when func = \"UNIXSU\" then do\n    usrsu=\"SU\"\n    usren=\"\"                                              /* 2.11 */\n    signal ext_unix_ex\n  end\n  when func = \"UNIXENV\" then do                           /* 2.11 */\n    usrsu=\"\"                                              /* 2.11 */\n    usren=\"ENV\"                                           /* 2.11 */\n    signal ext_unix_ex                                    /* 2.11 */\n  end                                                     /* 2.11 */\n  when func = \"UNIXSUENV\" then do                         /* 2.11 */\n    usrsu=\"SU\"                                            /* 2.11 */\n    usren=\"ENV\"                                           /* 2.11 */\n    signal ext_unix_ex                                    /* 2.11 */\n  end                                                     /* 2.11 */\n  when func = \"ING\" then do                               /* 2.19 */\n    signal ext_ING_EX                                     /* 2.19 */\n  end                                                     /* 2.19 */\n  when func = \"UDLIST\" then signal ext_udlist_ex\n  when func = \"UFDIR\" then signal ext_ufdir_ex\n  when func = \"UFFIL\" then signal ext_uffil_ex\n  otherwise\n    Call Help \"OUTSIDE\"                                        /* 2.9 */\n  end\nend\n\nISupport=\"CE RV AL AR E EX V DI DL\",\n         \"DS DM DX AU AD CM YX LD H HELP AE EA JU DH DA LN YD\",    /* 2.17 */\n         \"TOPD BOTD TOPX BOTX FI FL FA EZ VZ DZ HV\"                /* 2.16 */\n                                               /* Define the all the  */\n                                               /* Line-Commands       */\nCSupport = \"CE RV AL AR AU AD CM AE EA JU\"\n                                               /* Define the all the  */\n                                               /* Line-Commands which */\n                                               /* change the lines    */\n\n/* change Eberle 120418 */\nLcmd = translate(Parm,,xrange(\"0\",\"9\"))\nLcmd = strip(Lcmd,\"B\")\n\nLcmdnum = translate(Parm,,xrange(\"A\",\"Z\"))\n\nLcmdnum =strip(Lcmdnum,\"B\")\n\nCmd_length = length(Lcmd)\n\nif      Cmd_length > 1 then do                 /* commands            */\n        if substr(Lcmd,Cmd_length-1,1) = substr(Lcmd,cmd_length,1)\n           then do\n               lcmd = substr(Lcmd,1,Cmd_length-1)\n        end\nend\n/* change Eberle 120418 */\n\n/* change Parm --> Lcmd Eberle 120418 */\n\nif      WordPos(Lcmd,ISupport) = 0 then do     /* No \"internal\" LMAC */\n        Lcmd_Exec = \"Y$\"||Lcmd                 /* try calling an     */\n        Ret_Cde = check_ext_macro(\"SYSEXEC\" lcmd_Exec) /* external   */\n        if Ret_Cde <> 0 then                           /* macro named*/\n        Ret_Cde = check_ext_macro(\"SYSPROC\" lcmd_Exec) /* Y$cmd      */\n        if Ret_Cde = 0 then do\n           \"ISREDIT\" Lcmd_Exec Parm            /* named Y$cmd        */\n           exit                              /* \"external\" LMAC done */\n        end\n        else do                                /* if external exec   */\n                                               /* not found:         */\n           ZInfo = Parm                        /* Set up for message  */\n           Address ISPEXEC \"SETMSG MSG(ISRE041)\" /* Invalid command   */\n           Exit 8                              /* let ISPF handle     */\n        END                                    /*   THE ERROR         */\nend\n\n\"PROCESS RANGE\" Lcmd                           /* Get range for cmd   */\n\nif       RC > 0 then do                        /* if something went   */\n                                               /*   wrong             */\n         Address ISPEXEC \"SETMSG MSG(ISRZ002)\" /* Set ISPF's message  */\n         Exit 8                                /* let ISPF handle     */\n                                               /*   the Error         */\nend\n\"(CURLINE CURCOL) = CURSOR\"\n\"(START) = LINENUM .ZFRANGE\"   /* Get 1st line number in the range    */\n\"(STOP)  = LINENUM .ZLRANGE\"   /* Get last line number in the range   */\n\"(DW)    = DATA_WIDTH\"         /* Get the width of the editable data  */\n\"(LEFT,RIGHT) = BOUNDS\"        /* Get the BOUNDS                      */\n\nif       Start <> Stop then do\n         /* yves */                                         /* 2.17 */\n         if wordpos(Lcmd,\"E V DI DL DM DS EX LD DH\")>0 then do\n            ZedSMsg = YCLMACLM(1)\n            interpret \"ZedLMsg = \"YCLMACLM(2)\n            Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n            \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n            Exit 8\n         end\n         /* correct for zOS<1.13 */\n         if Lcmdnum = \"\" then do\n            lcmdnum = stop-start+1\n         end\nend\n\njcl_if  =\"N\" /*  JCL Upper Case 2.12 */\njcl_hyph=\"N\" /*  JCL Upper Case 2.12 */\n\ndo       I = Start to Stop     /* Loop through the range of lines     */\n   \"(LINE) = LINE \"I     /* Get old line value                  */\n                         /*                                     */\n   line_l = left(line,left-1)\n   line_r = right(line,dw-right)\n   line_b = substr(line,left,right-left+1)\n\n   Select                /* process the command for this line   */\n\n                                             /*  Help          */\n      when Lcmd = \"H\" | Lcmd = \"HELP\" then\n           Signal help\n\n                                             /*  Help view 2.16*/\n      when Lcmd = \"HV\" then do\n           prm=\"OUTSIDE\"\n           Signal help_v\n      end\n\n      when Lcmd = \"EX\"  then do               /*  Execute       */\n           call ex_tso\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit\n           end\n\n      when Lcmd = \"AE\"  then do               /*  Ascii->Ebcdic */\n           Line_b = ASCEBC(Line_b,length(line_b),\"E\")\n           line = line_l||line_b||line_r\n           end\n\n      when Lcmd = \"EA\"  then do               /*  Ebcdic->Ascii */\n           Line_b = ASCEBC(Line_b,length(line_b),\"A\")\n           line = line_l||line_b||line_r\n           end\n\n      /* 2.15 FindFirst - FindLast - FindAll */\n      /*      Hans-Peter Bodden - IVV        */\n      when Lcmd = \"FI\" | Lcmd = \"FL\" | Lcmd = \"FA\"  then do  /*  2.15 */\n        wordDelimiter = \"/*+-(',=).;:<>\" /* ASM   */\n        wordDelimiter = \" *+-(',=) ;:<>\" /* JCL   */\n        wordDelimiter = \"/*+ (',=).;:<>\" /* Cobol */\n\n        line = translate(line, ' ', wordDelimiter)\n\n        select\n          when curcol = 0 then do\n              myWord = word(line,1)\n          End\n          when curcol = 1 then do\n              myWord = word(line,1)\n          End\n          when substr(line, curcol, 1) = ' ' then do\n              parse var line  . = (curcol) myWord .\n          end\n          when substr(line, curcol - 1, 1) = ' ' then do\n              parse var line  . = (curcol) myWord .\n          end\n          otherwise\n              parse var line  p1 = (curcol) p2 .\n              i = words(p1)\n              if i > 0 then\n                    myWord = word(p1,i) || p2\n              else\n                    myWord = p2\n        End\n\n        if length(myWord) > 0 then do\n          myWord = '\"' || myWord || '\"'\n          select\n              when lcmd = 'FI' then  findOpt = 'FIRST NX'\n              when lcmd = 'FL' then  findOpt = 'LAST NX'\n              when lcmd = 'FA' then  findOpt = 'ALL'\n              otherwise\n                   findOpt = ''\n          End\n          if lcmd = 'FA' then    \"EXCLUDE ALL\"\n          \"find \" myWord findOpt\n          if lcmd = 'FA' then do\n            \"(fnd,lfnd) = FIND_COUNTS\"\n            fnd=fnd+0\n            lfnd=lfnd+0\n            if Lcmdnum<>\"\" & datatype(Lcmdnum)=\"NUM\" &,\n               Lcmdnum>0 then do\n               \"(TLINE) = LINENUM .ZLAST\"\n               anz=Lcmdnum\n               cn=0\n               pl=0\n               do i=1 to tline\n                 \"(xstat) = XSTATUS \"i\n                 if xstat = \"NX\" then do\n                   if pl>0 then do /* check previous lines */\n                     pl=min(pl,anz)\n                     do l1=i-1 to 1 by -1\n                       \"(nstat) = XSTATUS \"l1\n                       if nstat = \"X\" then do\n                         \"XSTATUS \"l1\" = NX\"\n                         if rc<>0 then pl=0\n                         else do\n                           cn=cn+1\n                         end\n                       end\n                       else do\n                         leave l1\n                       end\n                       pl=pl-1\n                       if pl<1 then do\n                         leave l1\n                       end\n                     end\n                     pl=0\n                   end\n                   if i<tline then do\n                     /* check next lines */\n                     \"(nstat) = XSTATUS \"i+1\n                     if nstat = \"X\" then do\n                       do l2=i+1 to min(tline,i+anz)\n                         \"XSTATUS \"l2\" = NX\"\n                         cn=cn+1\n                         \"(nstat) = XSTATUS \"l2+1\n                         if nstat = \"NX\" then leave l2\n                       end\n                       i=l2-1\n                     end\n                   end\n                 end\n                 else do\n                   pl=pl+1\n                 end\n               end\n               /* */\n            end\n            zedsmsg = fnd \"fnds in\" lfnd \"lines\"\n            zedlmsg = myword \"found\" fnd \"times in\" lfnd \"lines\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n          end\n          else do\n            zedsmsg = myword \"searched\"\n            zedlmsg = myword \"searched\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n          end\n        end\n        exit 0\n      end\n\n      when Lcmd = \"JU\"  then do               /*  JCL Upper Case 2.12 */\n           Line_b = JCL_UP(Line_b,length(line_b))\n           line = line_l||line_b||line_r\n           end\n\n      when Lcmd = \"CE\"  then do               /*  Center        */\n           line_b = ,\n           Center(strip(line_b,\"B\"),length(line_b))\n           line = line_l||line_b||line_r\n           end\n\n      when Lcmd = \"LN\"  then do               /*  Line 2.14     */\n           \"(NCHARS) = SAVE_LENGTH \"i\n           col1=\"----+----\"\n           cols=\"\"\n           rcnt=1\n           do j=1 to nchars by 10\n             cols=cols\"\"col1\"\"rcnt\n             rcnt=rcnt+1\n             if rcnt>9 then rcnt=0\n           end\n           cols=left(cols,nchars)\n           cols=overlay(\"L=\"right(nchars,5,\"0\")\" \",cols,1)\n           \"LINE_before \"i\" = INFOLINE (cols)\"\n           end\n\n      when Lcmd = \"RV\"  then do               /*  Reverse       */\n           line_b = Reverse(line_b)\n           line = line_l||line_b||line_r\n           end\n\n      when Lcmd = \"TOPD\"  then do             /*  Delete to top 2.14 */\n           \"LABEL .zfirst = .start 0\"\n           \"LABEL \"start\" = .stop 0\"\n           if start=1 then \"DELETE ALL .stop .stop\"\n           else \"DELETE ALL .start .stop\"\n           ZedSMsg = \"\"\n           ZedLMsg = start+0 \"lines deleted\"\n           Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           exit\n           end\n\n      when Lcmd = \"BOTD\"  then do             /*  Delete to bot 2.14 */\n           \"(TEND) = LINENUM .zlast\"\n           \"LABEL \"start\" = .start 0\"\n           \"LABEL .zlast  = .stop 0\"\n           if tend=start then \"DELETE ALL .stop .stop\"\n           else \"DELETE ALL .start .stop\"\n           ZedSMsg = \"\"\n           ZedLMsg = tend-start+1 \"lines deleted\"\n           Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           exit\n           end\n\n      when Lcmd = \"TOPX\"  then do             /*  X to top 2.14 */\n           \"LABEL .zfirst = .start 0\"\n           \"LABEL \"start\" = .stop 0\"\n           if start=1 then \"X ALL .stop .stop\"\n           else \"X ALL .start .stop\"\n           ZedSMsg = \"\"\n           ZedLMsg = start+0 \"lines excluded\"\n           Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           exit\n           end\n\n      when Lcmd = \"BOTX\"  then do             /*  X to bot 2.14 */\n           \"(TEND) = LINENUM .zlast\"\n           \"LABEL \"start\" = .start 0\"\n           \"LABEL .zlast  = .stop 0\"\n           if tend=start then \"X ALL .stop .stop\"\n           else \"X ALL .start .stop\"\n           ZedSMsg = \"\"\n           ZedLMsg = tend-start+1 \"lines excluded\"\n           Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           exit\n           end\n\n      when Lcmd = \"AL\" then do                /*  left justify  */\n           tmp_line = copies(\" \",length(line_b))\n           line_b = Strip(line_b,\"L\")\n           line_b = overlay(line_b,tmp_line)\n           line = line_l||line_b||line_r\n           end\n\n      when Lcmd = \"AR\" then do                /*  right justify */\n           tmp_line = copies(\" \",length(line_b))\n           line_b = ,\n           Right(Strip(line_b,\"T\"),length(line_b))\n           line_b = overlay(line_b,tmp_line)\n           line = line_l||line_b||line_r\n           end\n\n      when Lcmd = \"AU\" then do                /*  Align Up      */\n           if start=1 then do\n              ZedSMsg = YCLMACLM(39)\n              ZedLMsg = YCLMACLM(40)\n              Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n              \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n              Exit 8\n           end\n           fnd=\"NO\"\n           do j=start-1 to 1 by -1 until fnd<>\"NO\"\n              \"(xstat) = XSTATUS \"j\n              if xstat = \"NX\" then\n                 fnd=j\n           end\n           if fnd=\"NO\" then do\n              ZedSMsg = YCLMACLM(39)\n              ZedLMsg = YCLMACLM(42)\n              Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n              \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n              Exit 8\n           end\n           \"(YLIN) = LINE \"fnd /* Get previous NX line     */\n           /* 2.13 support for JCL AU */\n           if left(ylin,2)=\"//\" & left(line,3)=\"// \" then do\n             select\n             when substr(ylin,3,1)=\"*\" then pos=15\n             when substr(ylin,3,1)=\" \" then pos=wordindex(ylin,2)\n             otherwise\n               pos=wordindex(ylin,2)\n             end\n             if pos > 16 then pos=15\n             tmp_line=strip(substr(line,4,68))\n             if pos+length(tmp_line) > 72 then do\n              ZedSMsg = YCLMACLM(39)\n              ZedLMsg = YCLMACLM(50)\n              Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n              \"cursor = .ZFRANGE 0\"\n              Exit 8\n             end\n             line=left(left(\"//\",pos-1)\"\"tmp_line,71)\"\"substr(line,72)\n           end  /* 2.13 end */\n           else do\n             ylin_l = left(ylin,left-1)\n             ylin_r = right(ylin,dw-right)\n             ylin_b = substr(ylin,left,right-left+1)\n            /* change Eberle 120418 */\n             ylin_b = Strip(ylin_b,\"L\")\n             l1 = right-left+1 - length(ylin_b)\n             tmp_line = copies(\" \",length(line_b))\n             line_b = strip(line_b,\"B\")\n             l2 = right-left+1 - length(line_b)\n             line_b = copies(\" \",min(l1,l2))||line_b\n             line_b = overlay(line_b,tmp_line)\n             line = line_l||line_b||line_r\n          /* change Eberle 120418 */\n           end  /* 2.13 end */\n      end\n\n      when Lcmd = \"AD\" then do                /*  Align Down    */\n           \"(TLINE) = LINENUM .ZLAST\"\n           if stop=tline then do\n              ZedSMsg = YCLMACLM(39)\n              ZedLMsg = YCLMACLM(41)\n              Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n              \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n              Exit 8\n           end\n           fnd=\"NO\"\n           do j=stop+1 to tline until fnd<>\"NO\"\n              \"(xstat) = XSTATUS \"j\n              if xstat = \"NX\" then\n                 fnd=j\n           end\n           if fnd=\"NO\" then do\n              ZedSMsg = YCLMACLM(39)\n              ZedLMsg = YCLMACLM(42)\n              Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n              \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n              Exit 8\n           end\n           \"(YLIN) = LINE \"j /* Get next NX line     */\n           /* 2.13 support for JCL AD */\n           if left(ylin,2)=\"//\" & left(line,3)=\"// \" then do\n             select\n             when substr(ylin,3,1)=\"*\" then pos=15\n             when substr(ylin,3,1)=\" \" then pos=wordindex(ylin,2)\n             otherwise\n               pos=wordindex(ylin,2)\n             end\n             if pos > 16 then pos=15\n             tmp_line=strip(substr(line,4,68))\n             if pos+length(tmp_line) > 72 then do\n              ZedSMsg = YCLMACLM(39)\n              ZedLMsg = YCLMACLM(50)\n              Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n              \"cursor = .ZFRANGE 0\"\n              Exit 8\n             end\n             line=left(left(\"//\",pos-1)\"\"tmp_line,71)\"\"substr(line,72)\n           end  /* 2.13 end */\n           else do\n             ylin_l = left(ylin,left-1)\n             ylin_r = right(ylin,dw-right)\n             ylin_b = substr(ylin,left,right-left+1)\n            /* change Eberle 120418 */\n             ylin_b = Strip(ylin_b,\"L\")\n             l1 = right-left+1 - length(ylin_b)\n             tmp_line = copies(\" \",length(line_b))\n             line_b = strip(line_b,\"B\")\n             l2 = right-left+1 - length(line_b)\n             line_b = copies(\" \",min(l1,l2))||line_b\n             line_b = overlay(line_b,tmp_line)\n             line = line_l||line_b||line_r\n            /* change Eberle 120418 */\n           end  /* 2.13 end */\n      end\n\n      when Lcmd = \"CM\" then do                /*  Comment       */\n           /* 2.18 */\n           if i = start then do\n              if left(line,3)=\"//*\" then uncomm=1\n              else                       uncomm=0\n           end\n           /* 2.18 */\n\n           select\n           when uncomm & left(line,3)=\"//*\" then do    /* 2.18 */\n              if substr(line,71)=\"\" then do  /* no continuation */\n                line=left(line,2)\"\"substr(line,4,67),   /* 2.17 */\n                    substr(line,72)\n              end\n              else do                         /* continuation */\n                if left(line,4)=\"//* \" then do     /* 2.17 */\n                   line=\"// \"substr(line,4)\n                end\n                else do\n                   ZedSMsg = \"\" /* 2.70 */\n                   ZedLMsg = \"Nothing done - uncomment will\",\n                             \"change JCL behavior - col 71 cont.\"\n                   Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n                end\n              end\n           end\n           when left(line,2)=\"//\" then do\n              woleer=pos(\"  \",reverse(left(line,71)))\n              if woleer=0 then do\n                 ZedSMsg = \"\" /* 2.70 */\n                 ZedLMsg = \"Character '\"substr(line,3,1)\"'\",\n                           \"overridden -\",\n                           \"no space found\"\n                 Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n                 line=left(line,2)\"*\"substr(line,4)\n              end\n              else do\n               line=left(line,71-woleer)\"\"substr(line,71-woleer+2)\n               line=left(line,2)\"*\"substr(line,3)\n              end\n           end\n           /* 2.13 */\n           when start=stop &,\n             translate(strip(line))=\"/* COMMENT START\" then do\n             \"(TLINE) = LINENUM .ZLAST\"\n             fnd=\"N\"\n             wo=pos(\"/* COMMENT START\",translate(line))\n             do l1=start+1 to tline\n               \"(xstat) = XSTATUS \"l1\n               if xstat = \"NX\" then do\n                 \"(YLIN) = LINE \"l1\n                 upda=translate(substr(ylin,wo+3,14))\n                 if left(ylin,wo+2)=\" \" &,\n                   upda==\"COMMENT END */\" then do\n                   fnd=l1\n                   l1=tline+9\n                 end\n               end\n             end\n             if fnd=\"N\" then do\n               ZedSMsg = \"\"\n               ZedLMsg = \"'Comment End */' not found on column\" wo+3\n               Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n               \"Cursor =  .zfrange 0\"\n               exit 0\n             end\n             \"DELETE\" fnd\n             \"DELETE\" start\n             ZedSMsg = \"\"\n             ZedLMsg = \"Comments on lines\" start+0 \"and\" fnd \"deleted\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n             \"Cursor =  \"start\" 0\"\n             exit 0\n           end\n           when start=stop &,\n             translate(strip(line))=\"COMMENT END */\" then do\n             fnd=\"N\"\n             wo=pos(\"  COMMENT END */\",translate(line))\n             if wo>1 then do\n               do l1=stop-1 to 1 by -1\n                 \"(xstat) = XSTATUS \"l1\n                 if xstat = \"NX\" then do\n                   \"(YLIN) = LINE \"l1\n                   upda=translate(substr(ylin,wo-1,16))\n                   if upda==\"/* COMMENT START\" then do\n                     ylin=overlay(\" \",ylin,wo-1,16)\n                     if ylin=\"\" then do\n                       fnd=l1\n                       l1=0\n                     end\n                   end\n                 end\n               end\n             end\n             if fnd=\"N\" then do\n               ZedSMsg = \"\"\n               ZedLMsg = \"'/* Comment Start' not found on column\" wo-1\n               Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n               \"Cursor =  .zfrange 0\"\n               exit 0\n             end\n             \"DELETE\" stop\n             \"DELETE\" fnd\n             ZedSMsg = \"\"\n             ZedLMsg = \"Comments on lines\" fnd \"and\" stop+0 \"deleted\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n             \"Cursor =  \"stop\" 0\"\n             exit 0\n           end\n           otherwise\n              /* change Eberle 120418 */\n              l1 = dw - length(\"   Comment End */\")\n              l2 = dw - length(strip(line,\"L\"))\n              if l2 = dw then l2 = 0          /* empty line     */\n              line = copies(\" \",min(l1,l2))\n              /* change Eberle 120418 */\n              outit=\"'\"line\"/* Comment Start'\"\n              \"LINE_BEFORE\" start \"= DATALINE\" outit\n              outit=\"'\"line\"   Comment End */'\"\n              \"LINE_AFTER\" stop+1 \"= DATALINE\" outit\n              \"Cursor =  .zfrange 0\"                              /* 2.12 HUK */\n              exit 0\n           end\n      end\n\n      when Lcmd = \"YX\" then do                /*  Hex It        */\n           \"(NCHARS) = SAVE_LENGTH \"i\n           hexit=c2x(line)\n           hex1=\"\"\n           hex2=\"\"\n           do j=1 to nchars*2 by 2\n              hex1=hex1\"\"substr(hexit,j,1)\n              hex2=hex2\"\"substr(hexit,j+1,1)\n           end\n           \"LINE_BEFORE\" i+1 \"= INFOLINE\" hex1\n           \"LINE_BEFORE\" i+1 \"= INFOLINE\" hex2\n      end\n\n      when Lcmd = \"YD\" then do                /*  Hex It data   */\n           \"(NCHARS) = SAVE_LENGTH \"i\n           hexit=c2x(line)\n           hex1=left(hexit,nchars)\n           hex2=substr(hexit,nchars+1,nchars)\n           \"LINE_BEFORE\" i+1 \"= INFOLINE\" hex1\n           \"LINE_BEFORE\" i+1 \"= INFOLINE\" hex2\n      end\n\n      when Lcmd = \"E\" | Lcmd = \"EZ\" then do    /* 2.15 */\n      /*   yves                 */\n      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n           Address ISPEXEC \"CONTROL ERRORS RETURN\"\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             if Lcmd = \"EZ\" then do /* 2.15 */\n               Address ISPEXEC,\n               \"SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS EU\" MyDsn\")\"\n             end\n             else do\n               Address ISPEXEC \"EDIT FILE(mydsn)\"ed_parms /* 2.10 */\n             end\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             if Lcmd = \"EZ\" then do /* 2.15 */\n               Address ISPEXEC,\n               \"SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS E\" MyDsn myvol\")\"\n             end\n             else do\n               Address ISPEXEC \"EDIT DATASET('\"MyDsn\"')\",\n                       \"VOLUME(\"myvol\")\"ed_parms          /* 2.10 */\n             end\n           end                                          /* 2.9 */\n           if RC > 4 then do\n              ShowAct = \"Edit\"                 /* Eberle 120720 */\n              ShowDSN = mydsn                  /* Eberle 120720 */\n              ShowVOL = myvol                  /* Eberle 120720 */\n              signal CheckRC\n           end                                                 /* 2.12 HUK */\n           Address ISPEXEC \"CONTROL ERRORS CANCEL\"\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n\n      when Lcmd = \"V\" | Lcmd = \"VZ\" then do    /* 2.15 */\n      /*   yves                 */\n      /*   MyDsn = YCLMACDS(Line) */\n           ShowAct = \"View\"                    /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n           Address ISPEXEC \"CONTROL ERRORS RETURN\"\n             if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n               if Lcmd = \"VZ\" then do /* 2.15 */\n                 Address ISPEXEC,\n                 \"SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS VU\" MyDsn\")\"\n               end\n               else do\n                 Address ISPEXEC \"VIEW FILE(mydsn)\"ed_parms /* 2.10 */\n               end\n             end                                          /* 2.9 */\n             else do                                      /* 2.9 */\n               if Lcmd = \"VZ\" then do /* 2.15 */\n                 Address ISPEXEC,\n                 \"SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS V\" MyDsn myvol\")\"\n               end\n               else do\n                 Address ISPEXEC \"VIEW DATASET('\"MyDsn\"')\",\n                         \"VOLUME(\"myvol\")\"ed_parms          /* 2.10 */\n               end\n             end                                          /* 2.9 */\n             if RC > 4 then do\n                ShowAct = \"View\"                 /* Eberle 120720 */\n                ShowDSN = mydsn                  /* Eberle 120720 */\n                ShowVOL = myvol                  /* Eberle 120720 */\n                signal CheckRC\n             end\n           Address ISPEXEC \"CONTROL ERRORS CANCEL\"\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n                                                        /* 2.12 HUK */\n      when Lcmd = \"DA\" then do   /* 2.13 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n           if myvol=\"UNIXPATH\" then do\n             ZedSMsg = \"\"\n             ZedLMsg = \"DI not supported for PATH='\"mydsn\"'\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           end\n           else do\n             X = MyDsInfo(\"'\"MyDsn\"'\",myvol)\n           end\n           \"Cursor = \"curline curcol\n           exit 0\n      end\n\n      when Lcmd = \"DI\" then do\n      /*   yves                 */\n      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n        /* say mydsn \"-\" myvol */\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             ZedSMsg = \"\"\n             ZedLMsg = \"DI not supported for PATH='\"mydsn\"'\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             X = MyDsInfo(\"'\"MyDsn\"'\",myvol)\n           end                                          /* 2.9 */\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n\n      when Lcmd = \"LD\" then do                 /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             ZedSMsg = \"\"\n             ZedLMsg = \"LD not supported for PATH='\"mydsn\"'\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             X = MyLdInfo(\"'\"MyDsn\"'\",myvol)\n           end                                          /* 2.9 */\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n\n      when Lcmd = \"DH\" then do                 /* 2.12 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n           if myvol=\"UNIXPATH\" then do\n             ZedSMsg = \"\"\n             ZedLMsg = \"DH not supported for PATH='\"mydsn\"'\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             X = MyDHInfo(\"'\"MyDsn\"'\",myvol)\n           end                                          /* 2.9 */\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n\n      when Lcmd = \"DL\" then do\n      /*   yves                 */\n      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n        /* say mydsn \"-\" myvol */\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             ZedSMsg = \"\"\n             ZedLMsg = \"DL not supported for PATH='\"mydsn\"'\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             X = MyDsCat(\"'\"MyDsn\"'\",myvol)\n           end                                          /* 2.9 */\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n\n      when Lcmd = \"DM\" then do\n\n      /*   yves                 */\n      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n       /*  say mydsn \"-\" myvol */\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             ZedSMsg = \"\"\n             ZedLMsg = \"DM not supported for PATH='\"mydsn\"'\"\n             Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n             \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n             Exit 0\n           end                                          /* 2.9 */\n           Parse var MyDsn MyDsn \"(\" .\n           Address ISPEXEC \"CONTROL ERRORS RETURN\"\n           Address ISPEXEC,\n           \"LMINIT DATAID(DATAODV) DATASET('\"MyDsn\"')\",\n                   \"VOLUME(\"MyVol\")\"\n           cont=\"Y\"                                           /* 2.12 */\n           if rc<>0 then do                                   /* 2.12 */\n              ksm=ZerrSM                                      /* 2.12 */\n              klm=ZerrLM                                      /* 2.12 */\n              if rc=8 & MyVol<>\"\" then do                     /* 2.12 */\n                Address ISPEXEC,                              /* 2.12 */\n                \"LMINIT DATAID(DATAODV) DATASET('\"MyDsn\"')\"   /* 2.12 */\n                if rc=0 then do                               /* 2.12 */\n                  ZedSMsg  =  \"\"                              /* 2.12 */\n                  ZedLMsg  =  \"MEMLIST without Volume\" MyVol  /* 2.12 */\n                  Address  ISPEXEC 'SETMSG MSG(ISRZ001)'      /* 2.12 */\n                end                                           /* 2.12 */\n                else do                                       /* 2.12 */\n                  cont=\"N\"                                    /* 2.12 */\n                  ZerrSM=ksm                                  /* 2.12 */\n                  ZerrLM=klm                                  /* 2.12 */\n                  Address ISPEXEC 'SETMSG MSG(ISRZ002)'       /* 2.12 */\n                end                                           /* 2.12 */\n              end                                             /* 2.12 */\n              else do                                         /* 2.12 */\n                cont=\"N\"                                      /* 2.12 */\n                Address ISPEXEC 'SETMSG MSG(ISRZ002)'         /* 2.12 */\n              end                                             /* 2.12 */\n           end                                                /* 2.12 */\n           if cont=\"Y\" then do                                /* 2.12 */\n             Address ISPEXEC,\n             \"MEMLIST  DATAID(\"DATAODV\")\"\n             DispRC = RC\n             Address ISPEXEC,\n             \"LMFREE   DATAID(\"DATAODV\")\"\n             Address ISPEXEC \"CONTROL ERRORS CANCEL\"\n             if DispRC > 0 then do\n                ZedSMsg = \"MEMLIST-RC=\"DispRC\n                                              /* Eberle 120720 */\n                if MyVol <> \"\" then do\n                  errvol = \"VOL(\"strip(myvol,\"B\")\")\"\n                end\n                else errvol =\"\"\n                ZedLMsg = \"MEMLIST \"MyDsn errvol YCLMACLM(3)\n                Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n             end\n           end\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n      end\n\n      otherwise\n   /* when Lcmd = \"DS\" | Lcmd=\"DX\" | Lcmd=\"DZ\" then do */\n           ShowAct = \"Dslist\"                  /* 2.15 */\n      /*   yves                 */\n      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */\n           parse value YCLMACDS(Line) with retc mydsn '05'x myvol\n           if retc = 8 then exit retc\n           MyVol=strip(MyVol)   /* 2.12 */\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             sep=\"/\"                                    /* 2.9 */\n             mydsn=substr(mydsn,2)                      /* 2.9 */\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             Parse var MyDsn MyDsn \"(\" .\n             sep=\".\"                                    /* 2.9 */\n           end                                          /* 2.9 */\n      /*   yves                 */\n           if Lcmd = \"DX\" | Lcmd=\"DZ\" then do /* 2.15 */\n           /* change Eberle 120418 */\n             /* Comment Start\n             if start=stop then do\n                Comment End */\n             select\n             when Lcmdnum <= 1 & Lcmd=\"DX\" then do /* 2.15 */\n               parse var mydsn mydsn (sep) .\n             end\n             when datatype(Lcmdnum)<>\"NUM\" then do /* 2.15 */\n               nop\n             end\n             otherwise\n                tdsn=\"\"\n                pt=\"\"\n                do i=1 to Lcmdnum until mydsn=\"\" /* 2.15 */\n                /* change Eberle 120418 */                  /* 2.9 */\n                   parse var mydsn fq (sep) mydsn\n                   tdsn = tdsn\"\"pt\"\"fq\n                   pt=sep          /* 2.9 */\n                end\n                mydsn=tdsn\n             end\n           end\n           if myvol=\"UNIXPATH\" then do                  /* 2.9 */\n             mydsn=\"/\"mydsn                             /* 2.9 */\n             if Lcmd = \"DZ\" then do /* 2.15 */\n               Address ISPEXEC,\n               \"SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS DZU\" MyDsn\")\"\n             end\n             else do\n               address ispexec,                         /* 2.9 */\n               \"DIRLIST PATH(mydsn)\"                    /* 2.9 */\n               select                                   /* 2.9 */\n               when rc=0 then do                        /* 2.12 HUK */\n                 \"cursor = .ZFRANGE 0\"                  /* 2.12 HUK */\n                 exit 0                                 /* 2.9 */\n                 end\n               when rc=8 then do                        /* 2.9 */\n                 if lastpos(\"/\",mydsn)>0 then do\n                   mydsn=left(mydsn,lastpos(\"/\",mydsn)-1)\n                   address ispexec,                     /* 2.9 */\n                   \"DIRLIST PATH(mydsn)\"                /* 2.9 */\n                   if rc=0 then do                      /* 2.9 */\n                      \"cursor = .ZFRANGE 0\"             /* 2.12 HUK */\n                      exit 0                            /* 2.9 */\n                   end                                  /* 2.12 HUK */\n                 end\n               end                                      /* 2.9 */\n               otherwise\n                 ZedSMsg = \"DIRLIST-RC=\"RC\n                 ZedLMsg = \"DIRLIST PATH(\"MyDsn\")\"\n                 Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n                 \"Cursor = \"curline curcol              /* 2.12 HUK */\n                 exit 0\n               end\n             end\n           end                                          /* 2.9 */\n           else do                                      /* 2.9 */\n             if Lcmd = \"DZ\" then do /* 2.15 */\n               Address ISPEXEC,\n               \"SELECT PGM(ISPSTRT)\",\n                      \"PARM(TSO %YCLMACNS DZ\" MyDsn MyVol\")\"\n             end\n             else do\n               Address ISPEXEC \"CONTROL ERRORS RETURN\"\n               Address ISPEXEC \"LMDINIT LISTID(ID) Level(\"MyDsn\")\",\n                       \"VOLUME(\"MyVol\")\"\n               Address ISPEXEC \"LMDDISP LISTID(\"ID\")\"\n               DispRC = RC\n               Address ISPEXEC \"LMDFREE LISTID(\"ID\")\"\n               Address ISPEXEC \"CONTROL ERRORS CANCEL\"\n               if DispRC > 0 then do\n                 ZedSMsg = \"LMDDISP-RC=\"DispRC\n                                              /* Eberle 120720 */\n                 if MyVol <> \"\" then do            /* 2.13 */\n                   Address ISPEXEC,\n                   \"CONTROL ERRORS RETURN\"\n                   Address ISPEXEC,\n                   \"LMDINIT LISTID(ID) Level(\"MyDsn\")\"\n                   ZedSMsg  =  \"\"\n                   ZedLMsg  =  ShowAct \"without Volume\" MyVol\n                   Address  ISPEXEC 'SETMSG MSG(ISRZ001)'\n                   Address ISPEXEC,\n                   \"LMDDISP LISTID(\"ID\")\"\n                   Disp2RC = RC\n                   Address ISPEXEC,\n                   \"LMDFREE LISTID(\"ID\")\"\n                   Address ISPEXEC,\n                   \"CONTROL ERRORS CANCEL\"\n                   if Disp2RC > 0 then do\n                     errvol = \"VOL(\"strip(MyVol,\"B\")\")\"\n                     ZedLMsg = \"LMDDISP LEVEL(\"MyDsn\")\" errvol,\n                               YCLMACLM(3)\n                     Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n                   end\n                 end\n                 else do\n                   ZedLMsg = \"LMDDISP LEVEL(\"MyDsn\")\",\n                             YCLMACLM(3)\n                   Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n                 end\n               end\n             end\n           end                                          /* 2.9 */\n           \"Cursor = \"curline curcol                           /* 2.12 HUK */\n           exit 0\n\n   end\n   if WordPos(Lcmd,CSupport) > 0 then do /* If a command which  */\n                                         /*    changed line     */\n      \"LINE \"I\" = (LINE)\"   /* save changed Line                */\n   end\nend                            /* End of loop through lines           */\n\n\"Cursor = \"curline curcol                                      /* 2.12 HUK */\nexit     0                     /* Return to ISPF                      */\n\nCheckRc:\n\nActRC    = RC\n\nSelect\n\n   When ActRC = 14 then do\n        if Pos(\"(\",ShowDsn) = 0 then do\n           ZedSMsg = \"Dsn in use\"\n           ZedLMsg = YCLMACLM(45)\n        end\n        else do\n           ZedSMsg = \"Member in use\"\n           ZedLMsg = YCLMACLM(46)\n        end\n   end\n\n   When ActRC = 18 then do\n        ZedSMsg = \"VSAM\"\n        ZedLMsg = YCLMACLM(47)\n   end\n\n   When ActRC = 20 then do\n        if ShowVol<>\"\" & ShowVol<>\"UNIXPATH\" then do      /* 2.12 */\n          ZedSMsg  =  \"\"                                  /* 2.12 */\n          ZedLMsg  =  ShowAct \"without Volume\" MyVol      /* 2.12 */\n          Address  ISPEXEC 'SETMSG MSG(ISRZ001)'          /* 2.12 */\n          Address ISPEXEC ShowAct \"DATASET('\"MyDsn\"')\"    /* 2.12 */\n          if RC>4 then nop                                /* 2.12 */\n          else do                                         /* 2.12 */\n            \"cursor = .ZFRANGE 0\"                         /* 2.12 */\n            Exit 0                                        /* 2.12 */\n          end                                             /* 2.12 */\n        end                                               /* 2.12 */\n        ZedSMsg = YCLMACLM(48)\n                                                   /* Eberle 120720 */\n        ShowVol = strip(ShowVol,\"B\")               /* Eberle 120720 */\n        if ShowVol <> \"\" then do                   /* Eberle 120720 */\n          xshowvol = \"VOL(\"ShowVol\")\"              /* Eberle 120720 */\n        end                                        /* Eberle 120720 */\n        else xshowvol = \"\"                         /* Eberle 120720 */\n        ZedLMsg = \"DSN\" ShowDsn xshowvol YCLMACLM(6)\n                                                   /* Eberle 120720 */\n   end\n\n   otherwise do\n      ZedSMsg  = ShowAct\"-RC=\"ActRC\n      ZedLMsg  = ShowAct \"Dsn=\"ShowDsn\" Vol=\"myvol, /* Eberle 120720 */\n                 \"mit RC=\"ActRC YCLMACLM(7)\n   end\n\nend\n\nAddress  ISPEXEC 'SETMSG MSG(ISRZ001)'\n\"cursor = .ZFRANGE 0\"                                /* 2.12 HUK */\n\nExit 0\n\nMyDsInfo:\n\n/* used for DI and DA 2.13 */\n/* Arg      InfoDsn  */\ninfodsn = arg(1)\ninfovol = strip(arg(2),\"B\")                        /* Eberle 120720 */\n\nif       Pos(\"(\",InfoDsn) > 0 then do\n         Parse Var InfoDsn InfoDsn \"(\" .\n         if Left(InfoDsn,1) = \"'\" then Infodsn = InfoDsn\"'\"\nend\n\nAddress  ISPEXEC \"DSINFO DATASET(\"InfoDsn\") VOLUME(\"infovol\")\"\nif       RC > 0 then do\n         /* yves */\n         if rc=8 then do\n         ZedSMsg=\"DSINFO\",\n           YCLMACLM(49)\n         ZedLMsg=\"DSINFO DATASET(\"InfoDsn\") VOLUME(\"infovol\")\",\n           YCLMACLM(49)\n         end\n         else do\n         ZedSMsg=\"DSINFO\",\n         YCLMACLM(7)\n         ZedLMsg=\"DSINFO DATASET(\"InfoDsn\") VOLUME(\"infovol\")\",\n         \"RC=\"Rc YCLMACLM(7)\n         end\n         Address  ISPEXEC 'SETMSG MSG(ISRZ001)'\n         \"cursor = .ZFRANGE 0\"                           /* 2.12 HUK */\n         exit 4\nend\n\nI        = WordPos(ZdsSpc,\"BLOCK TRACK CYLINDER BYTE KYLOBYTE MEGABYTE\")\nEalloc   = Word(Strip(ZdsBlk) \"TRK CYL 1\",I)\nKalloc   = Word(\"BLOCK(\"Strip(ZdsBlk)\")\" \"TRACKS CYL 1\",I)\nezus=\"\"\nif i>3 then do\n  Kalloc = \"AVBLOCK(\"Strip(ZdsBlk)\")\"\n  select\n  when left(ZdsSpc,1)=\"B\" then do\n    ezus=\"AVGREC=U,\"\n    kzus=\"AVGREC(U)\"\n  end\n  when left(ZdsSpc,1)=\"K\" then do\n    ezus=\"AVGREC=K,\"\n    kzus=\"AVGREC(K)\"\n  end\n  when left(ZdsSpc,1)=\"M\" then do\n    ezus=\"AVGREC=M,\"\n    kzus=\"AVGREC(M)\"\n  end\n  otherwise\n  end\nend\nEinheit  = Word(YCLMACLM(37),I)\n\nMoreVols = \" \"\nif       Zds#Vols > 1 then do\n  MoreVols = \"+\"\nend\n\n/* yves */\n/* Address  TSO \"CLEAR\" */\n\nInfo.1   = YCLMACLM(8) Strip(InfoDsn,\"B\",\"'\")\nInfo.2   = \"\"\nInfo.3   = YCLMACLM(9)\n\nif       ZdsMC\"\"ZdsSC\"\"ZdsDC = Copies(\"0\"X,24) then signal NoSMS\nif       ZdsOrg = \"PO\" then signal SmsPO\n\nSmsPS:\n\nTl       = YCLMACLM(10) ZdsMc\nTl       = Left(Tl,39) YCLMACLM(11),\n         Edit(Strip(ZdsTota))\nInfo.4   = Overlay(Einheit,Tl,52,Length(Einheit)+1)\nTl       = YCLMACLM(12) ZdsSc\nInfo.5   = Left(Tl,39) YCLMACLM(21),\n         Edit(Strip(ZdsExtA))\nInfo.6   = YCLMACLM(14) ZdsVol MoreVols\nInfo.7   = YCLMACLM(15) ZdsDevt\nTl       = YCLMACLM(16) ZdsDc\nInfo.8   = Left(Tl,39) YCLMACLM(17)\nTl       = YCLMACLM(18) ZdsOrg\nInfo.9   = Left(Tl,39) \" . . . . . . . . . . :\",\n           Edit(Strip(ZdsTotU))\nInfo.9   = Overlay(YCLMACLM(19)\" \"einheit\" \",info.9,41)\nTl       = YCLMACLM(20) ZdsRf\nInfo.10  = Left(Tl,39) YCLMACLM(38),\n           Edit(Strip(ZdsExtU))\nInfo.11  = YCLMACLM(22) Strip(ZdsLrec)\nInfo.12  = YCLMACLM(23) Strip(ZdsBlk)\nInfo.13  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds1Ex))\nInfo.13  = Overlay(YCLMACLM(24)\"\"einheit\" \",info.13,1)\nInfo.14  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds2Ex))\nInfo.14  = Overlay(YCLMACLM(25)\"\"einheit\" \",info.14,1)\nInfo.15  = left(YCLMACLM(31) ZdsDsnT,39),\n           YCLMACLM(43) ZdsSeq\n\nInfo.0   = 15\n/* 2.17 */\nif ZDSDSNV<>\"ZDSDSNV\" then do\n  Info.0   = Info.0+1\n  II       = Info.0\n  Info.II = \"   Dataset Version . . :\" ZDSDSNV\nend\n\nsignal   Dates\n\nSmsPO:\n\nTl       = YCLMACLM(10) ZdsMc\nTl       = Left(Tl,39) YCLMACLM(11),\n         Edit(Strip(ZdsTota))\nInfo.4   = Overlay(Einheit,Tl,52,Length(Einheit)+1)\nTl       = YCLMACLM(12) ZdsSc\nInfo.5   = Left(Tl,39) YCLMACLM(21),\n         Edit(Strip(ZdsExtA))\nTl       = YCLMACLM(14) ZdsVol MoreVols\nif       ZdsDsnT = \"LIBRARY\" then\n         Info.6  = Left(Tl,39) YCLMACLM(26) Strip(ZdsDir)\nelse\n         Info.6  = Left(Tl,39) YCLMACLM(26) Edit(Strip(ZdsDirA))\nTl       = YCLMACLM(15) ZdsDevt\nInfo.7   = Tl\nif       ZdsDsnT = \"LIBRARY\" then Info.7  = Left(Tl,39) YCLMACLM(27)\n                             else Info.7  = Left(Tl,39)\nInfo.8   = YCLMACLM(16) ZdsDc\nTl       = YCLMACLM(18) ZdsOrg\nInfo.9   = Left(Tl,39) YCLMACLM(17)\nTl       = YCLMACLM(20) ZdsRf\nif       ZdsDsnT = \"LIBRARY\" then\n         Info.10 = Left(Tl,39) YCLMACLM(28) Edit(Strip(ZdsPagU))\nelse do\n         Info.10  = Left(Tl,39) \" . . . . . . . . . . :\",\n                    Edit(Strip(ZdsTotU))\n         Info.10  = Overlay(YCLMACLM(19)\" \"einheit\" \",info.10,41)\nend\nTl       = YCLMACLM(22) Strip(ZdsLrec)\nif       ZdsDsnT = \"LIBRARY\" then\n         Info.11 = Left(Tl,39) YCLMACLM(29) Edit(Strip(ZdsPerU))\nelse\n         Info.11 = Left(Tl,39) YCLMACLM(38) Edit(Strip(ZdsExtU))\nTl       = YCLMACLM(23) Strip(ZdsBlk)\nif       ZdsDsnT = \"LIBRARY\" then\n         Info.12  = Left(Tl,39) YCLMACLM(30) Edit(Strip(Zds#Mem))\nelse\n         Info.12  = Left(Tl,39) YCLMACLM(44) Edit(Strip(ZdsDirU))\nInfo.13  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds1Ex))\nInfo.13  = Overlay(YCLMACLM(24)\"\"einheit\" \",info.13,1)\nif       ZdsDsnT = \"LIBRARY\" then\n         Info.13  = Left(Info.13,39)\nelse\n         Info.13  = Left(Info.13,39) YCLMACLM(30) Edit(Strip(Zds#Mem))\nInfo.14  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds2Ex))\nInfo.14  = Overlay(YCLMACLM(25)\"\"einheit\" \",info.14,1)\nInfo.15  = left(YCLMACLM(31) ZdsDsnT,39)\n\nInfo.0   = 15\n/* 2.17 */\nif ZDSDSNV<>\"ZDSDSNV\" then do\n  Info.0   = Info.0+1\n  II       = Info.0\n  Info.II = \"   Dataset Version . . :\" ZDSDSNV\nend\nif ZDSNGEN<>\"ZDSNGEN\" then do\n  Info.0   = Info.0+1\n  II       = Info.0\n  Info.II = \"   Number of Generation:\" ZDSNGEN\nend\n\nsignal   Dates\n\nNoSms:\n\nif       ZdsOrg = \"PO\" then signal NoSmsPO\n\nNoSmsPS:\n\nTl       = YCLMACLM(14) ZdsVol MoreVols\nInfo.4   = Left(Tl,39) YCLMACLM(32) Left(Einheit,8)\". :\",\n           Edit(Strip(ZdsTota))\nTl       = YCLMACLM(15) ZdsDevt\nInfo.5   = Left(Tl,39) YCLMACLM(21),\n           Edit(Strip(ZdsExtA))\nInfo.6   = YCLMACLM(18) ZdsOrg\nInfo.7   = YCLMACLM(20) ZdsRf\nInfo.8   = YCLMACLM(22) Strip(ZdsLrec)\nTl       = YCLMACLM(23) Strip(ZdsBlk)\nInfo.9   = Left(Tl,39) YCLMACLM(17)\nInfo.10  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds1Ex))\nInfo.10  = Overlay(YCLMACLM(24)\"\"einheit\" \",info.10,1)\nInfo.10  = Left(Info.10,39) \" . . . . . . . . . . :\",\n           Edit(Strip(ZdsTotU))\nInfo.10  = Overlay(YCLMACLM(33)\" \"einheit\" \",info.10,41)\nInfo.11  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds2Ex))\nInfo.11  = Overlay(YCLMACLM(25)\"\"einheit\" \",info.11,1)\nInfo.11  = Left(Info.11,39) YCLMACLM(38),\n           Edit(Strip(ZdsExtU))\n\nInfo.0   = 11\n\n/* 2.17 */\nif ZDSDSNV<>\"ZDSDSNV\" then do\n  Info.0   = Info.0+1\n  II       = Info.0\n  Info.II = \"   Dataset Version . . :\" ZDSDSNV\nend\n\nsignal   Dates\n\nNoSmsPO:\n\nTl       = YCLMACLM(14) ZdsVol MoreVols\nTl       = Left(Tl,39) YCLMACLM(11),\n         Edit(Strip(ZdsTota))\nInfo.4   = Overlay(Einheit,Tl,52,Length(Einheit)+1)\nTl       = YCLMACLM(15) ZdsDevt\nInfo.5   = Left(Tl,39) YCLMACLM(21),\n         Edit(Strip(ZdsExtA))\nTl       = YCLMACLM(18) ZdsOrg\nInfo.6   = Left(Tl,39) YCLMACLM(26),\n         Edit(Strip(ZdsDirA))\nTl       = YCLMACLM(20) ZdsRf\nInfo.7   = Left(Tl,39) \" (Maximum)\"\nInfo.8   = YCLMACLM(22) Strip(ZdsLrec)\nTl       = YCLMACLM(23) Strip(ZdsBlk)\nInfo.9   = Left(Tl,39) YCLMACLM(17)\nInfo.10  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds1Ex))\nInfo.10  = Overlay(YCLMACLM(24)\"\"einheit\" \",info.10,1)\nInfo.10  = Left(Info.10,39) \" . . . . . . . . . . :\",\n           Edit(Strip(ZdsTotU))\nInfo.10  = Overlay(YCLMACLM(33)\" \"einheit\" \",info.10,41)\nInfo.11  = \" . . . . . . . . . . . :\",\n           Edit(Strip(Zds2Ex))\nInfo.11  = Overlay(YCLMACLM(25)\"\"einheit\" \",info.11,1)\nInfo.11  = Left(Info.11,39) YCLMACLM(38),\n           Edit(Strip(ZdsExtU))\nTl       = \"\"\nInfo.12  = Left(Tl,39) YCLMACLM(26),\n           Edit(Strip(ZdsDirU))\nTl       = \"\"\nInfo.13  = Left(Tl,39) YCLMACLM(30),\n           Edit(Strip(Zds#Mem))\n\nInfo.0   = 13\n\n/* 2.17 */\nif ZDSDSNV<>\"ZDSDSNV\" then do\n  Info.0   = Info.0+1\n  II       = Info.0\n  Info.II = \"   Dataset Version . . :\" ZDSDSNV\nend\nif ZDSNGEN<>\"ZDSNGEN\" then do\n  Info.0   = Info.0+1\n  II       = Info.0\n  Info.II = \"   Number of Generation:\" ZDSNGEN\nend\n\nsignal   Dates\n\nDates:\n\nII       = Info.0 + 1\nInfo.II  = \"\"\n\n/* 2.17 */\nif ZDSEATR<>\"ZDSEATR\" & ZDSEATR<>\"\" then do\n  II       = II + 1\n  Info.II = \"   EATTR - Ext. Attr.  :\" ZDSEATR\nend\nif ZDSCJOBN<>\"ZDSCJOBN\" & ZDSCJOBN<>\"\" then do\n  II       = II + 1\n  Info.II = \"   EAV - Jobname Creat :\" ZDSCJOBN\nend\nif ZDSCSTPN<>\"ZDSCSTPN\" & ZDSCSTPN<>\"\" then do\n  II       = II + 1\n  Info.II = \"   EAV - Stepnm  Creat :\" ZDSCSTPN\nend\n\nII       = II + 1\nTl       = YCLMACLM(34) FormDate(ZdsCDate)\nInfo.II  = Left(Tl,39) YCLMACLM(35) FormDate(ZdsRDate)\nII       = II + 1\nInfo.II  = YCLMACLM(36) FormDate(ZdsXDate)\n\nII       = II + 1\nInfo.II=\">>> Use line command MD (Make Data) to use JCL to allocate\"\nki=II\nII       = II + 1\nInfo.II  = \"//ycosddn  DD DSN=\"Strip(InfoDsn,\"B\",\"'\")\",\"\nka=1\nkal.ka=\">>> Use line command MD (Make Data) and EX (Execute)\"\nka=ka+1\nkal.ka=\"ALLOC FI(ycosddn) DA(\"InfoDsn\") +\"\nII       = II + 1\nInfo.II  = \"//            DISP=(,CATLG),\"\nII       = II + 1\nInfo.II  = \"//            SPACE=(\"strip(Ealloc)\",(\"strip(zds1ex)\",\"\nInfo.II  = Info.II\"\"strip(zds2ex)\",\"strip(zdsdira)\")),\"ezus\nka=ka+1\nkal.ka=\"   NEW CATALOG\" Kalloc,\n        \"SPACE(\"strip(zds1ex)\",\"strip(zds2ex)\") +\"\nka=ka+1\nif zdsdira<>\"\" & zdsdira<>0 then do\n  kal.ka=\"   DIR(\"strip(zdsdira)\") \"\nend\nelse do\n  kal.ka=\"   \"\nend\nII       = II + 1\nInfo.II  = \"//            LRECL=\"strip(zdslrec)\",\"\ntl3=strip(zdsrf)\ntl4=\"\"\ntl5=\"\"\ndo l3=1 to length(tl3)\n  tl4=tl4\"\"tl5\"\"substr(tl3,l3,1)\n  tl5=\" \"\nend\nkal.ka=kal.ka\"LRECL(\"strip(zdslrec)\") RECFM(\"tl4\") +\"\nInfo.II  = Info.II\"RECFM=\"strip(zdsrf)\",BLKSIZE=\"strip(zdsblk)\",\"\nInfo.II  = Info.II\"DSORG=\"strip(zdsorg)\",\"\nka=ka+1\nkal.ka=\"   BLKSIZE(\"strip(zdsblk)\") DSORG(\"strip(zdsorg)\") \"\nII       = II + 1\nif zds#vols > 1 then do\n  Info.II  = \"//            UNIT=(\"strip(zdsdevt)\",,,\"strip(zds#vols)\")\"\nend\nelse do\n  Info.II  = \"//            UNIT=\"strip(zdsdevt)\nend\nInfo.II  = Info.II\",VOL=SER=\"strip(zdsvol)\nif       ZdsMC\"\"ZdsSC\"\"ZdsDC <> Copies(\"0\"X,24) &,\n         ZdsMC\"\"ZdsSC\"\"ZdsDC <> \"**None****None****None**\" then do\n  kal.ka=kal.ka\"+\"\n  ka=ka+1\n  kal.ka=\"   \"\n  Info.II  = Info.II\",\"\n  II       = II + 1\n  cont=\"\"\n  Info.II  = \"//            \"\n  if       ZdsMC <> Copies(\"0\"X,8) &,\n           ZdsMC <> \"**None**\" then do\n     Info.II  = info.ii\"MGMTCLAS=\"strip(zdsMC)\n     cont=\",\"\n     kal.ka=kal.ka\"MGMTCLAS(\"strip(zdsMC)\") \"\n  end\n  if       ZdsSC <> Copies(\"0\"X,8) &,\n           ZdsSC <> \"**None**\" then do\n     Info.II  = info.ii\"\"cont\"STORCLAS=\"strip(zdsSC)\n     cont=\",\"\n     kal.ka=kal.ka\"STORCLAS(\"strip(zdsSC)\") \"\n  end\n  if       ZdsDC <> Copies(\"0\"X,8) &,\n           ZdsDC <> \"**None**\" then do\n     Info.II  = info.ii\"\"cont\"DATACLAS=\"strip(zdsDC)\n     kal.ka=kal.ka\"DATACLAS(\"strip(zdsDC)\") \"\n  end\nend\nif ZdsDsnt<>\"\" then do\n  if Info.II <> \"//            \" then do\n    Info.II = Info.II\",\"\n    II       = II + 1\n  end\n  /* 2.17 version */\n  ka1=\"\"\n  ka2=\"\"\n  ka3=\"\"\n  if ZDSDSNV<>\"ZDSDSNV\" & ZDSDSNV<>\"\" & ZDSDSNV<>\"0\" then do\n    ka2=\",\"ZDSDSNV    /* version */\n  end\n  If ZdsDsnt=\"EXTENDED\" then ZdsDsnt=\"EXTREQ\"   /* 2.14 */\n  Info.II = \"//            DSNTYPE=\"ka1\"\"strip(ZdsDsnT)\"\"ka2\"\"ka3\n  kal.ka=kal.ka\" +\"\n  ka=ka+1\n  kal.ka=\"   DSNTYPE(\"strip(ZdsDsnT)\"\"ka2\")\"\nend\n/* 2.17 maxgens */\nif ZDSNGEN<>\"\" & ZDSNGEN<>\"ZDSNGEN\" & ZDSNGEN<>\"0\" then do\n  if Info.II <> \"//            \" then do\n    Info.II = Info.II\",\"\n    II       = II + 1\n  end\n  Info.II = \"//            MAXGENS=\"strip(ZDSNGEN)\n  kal.ka=kal.ka\" +\"\n  ka=ka+1\n  kal.ka=\"   MAXGENS(\"strip(ZDSNGEN)\")\"\nend\nka=ka+1\nkal.ka=\"FREE FI(ycosddn)\"\n/* yves */\n\"(CAPMODE) = CAPS\"\nif capmode = \"ON\" then\n  \"CAPS OFF\"\ndo i=ka to 1 by -1\n   \"LINE_AFTER \"start\" = INFOLINE '\"kal.i\"'\"\nend\nif Lcmd = \"DI\" then endii=1    /* 2.13 */\nelse                endii=ki\ndo i=ii to endii by -1         /* 2.13 */\n   \"LINE_AFTER \"start\" = INFOLINE '\"info.i\"'\"\nend\nif capmode = \"ON\" then\n  \"CAPS ON\"\n/* yves\ndo       I = 1 to II\n         Say Info.I\nend\n*/\n\nReturn 0\n\nMyLdInfo:\n\ninfodsn = arg(1)\ninfovol = strip(arg(2),\"B\")                      /* Eberle 120720 */\n\nif       Pos(\"(\",InfoDsn) > 0 then do\n         Parse Var InfoDsn InfoDsn \"(\" .\n         if Left(InfoDsn,1) = \"'\" then Infodsn = InfoDsn\"'\"\nend\n\n/* list racf the dataset */\nx=outtrap(\"ycos.\")\naddress tso \"listdsd dataset(\"infodsn\") generic all dfp history\"\nx=outtrap(\"OFF\")\n/* yves */\n\"(CAPMODE) = CAPS\"\nif capmode = \"ON\" then\n  \"CAPS OFF\"\ndo i=ycos.0 to 1 by -1\n   \"LINE_AFTER \"start\" = INFOLINE '\"ycos.i\"'\"\nend\nif capmode = \"ON\" then\n  \"CAPS ON\"\n/* yves\ndo       I = 1 to II\n         Say Info.I\nend\n*/\nReturn 0\n\n/* hsm HLIST Command 2.12 */\nMyDHInfo:\n/* rexx */\n/* */\nSysuid   = userid()\nSysPref  = SysVar(\"SysPref\")\n\nif       Syspref = Sysuid then MyHlq = Syspref\n                          else MyHlq = SysPref\".\"Sysuid\n\nODsn     = \"'\"Strip(MyHlq,\"L\",\".\")\".\" ||,\n           \"SYS\"Date(\"J\")\".\"       ||,\n           \"T\"Translate(124578,Time(\"N\"),12345678)\".\" ||,\n           \"HSMOUT'\"\n\nNumeric  Digits 10\nCVT      = Storage(10,4)\nDCVTHSM  = C2D(CVT)+X2D(3DC)\nCVTHSM   = STORAGE(C2X(D2C(DCVTHSM)),4)\nHSMASCB='00000000'x\nif C2X(CVTHSM)<>\"00000000\" then do\n  DHSMASCB = C2D(CVTHSM)+X2D(8)\n  HSMASCB  = STORAGE(C2X(D2C(DHSMASCB)),4)\nend\nif C2X(HSMASCB)=\"00000000\" then do\n  ZedSMsg  = \"HSM not active\"\n  ZedLMsg  = \"HSM not found using CVT + 3DC + 8. Not active\"\n  address ispexec \"SETMSG MSG(ISRZ001)\"\n  return\nend\n\nrx=listdsi(\"'\"mydsn\"'\" \"NORECALL\")\nif rx=16 & sysreason=\"0009\" then hopt=\"BOTH\"\nelse                             hopt=\"BCDS\"\n\naddress tso,\n\"HLIST   DSNAME('\"MyDsn\"')\" hopt\" ODS(\"ODsn\")\"\n\nif SysDsn(ODsn) <> \"OK\" then do\n  ZedSMsg  = \"HSM Error\"\n  ZedLMsg  = \"HSM HLIST output dataset not allocated\"\n  address ispexec \"SETMSG MSG(ISRZ001)\"\n  return\nend\n/* alloc input dataset */\ncall bpxwdyn \"alloc da(\"ODsn\") shr\",\n  \"msg(ymsg1.) rtddn(ydd1)\"\nif result<>0 then do\n  say \"Alloc Input dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  return\nend\n\naddress mvs \"EXECIO  * DISKR\" ydd1 \"(Stem Hsm. Finis\"\naddress tso \"free fi(\"ydd1\")\"\nOldMsg   = Msg(\"OFF\")\naddress tso \"Delete\" ODsn\nNewMsg   = Msg(OldMsg)\n\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(132)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg2.) rtddn(ydd2) rtdsn(ydsn2)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg2.0\n    say ymsg2.i\n  end\n  exit 0\nend\n\nol=0 /* output lines */\nstart=1\nif hopt=\"BOTH\" then do\n  select\n  when substr(hsm.1,31,8)=\"MIGRATED\" then do\n    do i=start to hsm.0 until substr(hsm.i,2,12)=\"DATASET NAME\"\n      ol=ol+1\n      ot.ol=hsm.i\n      if substr(hsm.i,2,23)=\"----- END OF - MIGRATED\" then do\n        i=9+hsm.0\n        leave i\n      end\n    end\n    if i>hsm.0 then do\n      ol=ol+1\n      ot.ol=\"Error\" Mydsn\" Migration information not found|\"\n      do i=start until substr(hsm.1,31,6)=\"BACKUP\"\n        ol=ol+1\n        ot.ol=hsm.i\n      end\n      start=i\n    end\n    else do\n      do j=i+1 until substr(hsm.j,2,23)=\"----- END OF - MIGRATED\"\n        ol=ol+1\n        ot.ol=hsm.j\n        if strip(substr(hsm.j,2,44))=Mydsn then do\n          ol=ol+1\n          ot.ol=\"tso HRECALL ('\"mydsn\"') NOWAIT\"\n        ol=ol+1\n        ot.ol=\">>>>>> Please Select the needed parameter and use 'EX'\"\n        ol=ol+1\n        ot.ol=\"\"\n        end\n      end\n      start=j+1\n    end\n  end\n  when substr(hsm.1,31,6)=\"BACKUP\" then do\n    ol=ol+1\n    ot.ol=\"Error\" Mydsn\" Migration information not found|\"\n    ZedSMsg  = \"\"\n    ZedLMsg  = ot.ol\n    address ispexec \"SETMSG MSG(ISRZ001)\"\n  end\n  otherwise\n    ol=ol+1\n    ot.ol=\"Unknown first line in output|\"\n    start=i\n  end\nend  /* work backup */\nselect\nwhen substr(hsm.start,31,6)=\"BACKUP\" then do\n  do i=start to hsm.0 until substr(hsm.i,2,14)=\"BACKUP VERSION\"\n    ol=ol+1\n    ot.ol=hsm.i\n    if substr(hsm.i,2,23)=\"----- END OF - BACKUP D\" then do\n      i=9+hsm.0\n      leave i\n    end\n  end\n  if i>hsm.0 then do\n    ol=ol+1\n    ot.ol=\"Error\" Mydsn\" Backup information not found|\"\n    ZedSMsg  = \"\"\n    ZedLMsg  = ot.ol\n    address ispexec \"SETMSG MSG(ISRZ001)\"\n  end\n  else do\n    do j=i+1 until substr(hsm.j,2,23)=\"----- END OF - BACKUP D\"\n      ol=ol+1\n      ot.ol=hsm.j\n      if substr(hsm.j,63,1)=\"/\" then do   /* date */\n        Parse Var hsm.j hsmbdsn . . . . . . hsmbvers .\n        ol=ol+1\n        ot.ol=\"tso HRECOVER ('\"Mydsn\"') VERSION(\"hsmbvers\") +\"\n        ol=ol+1\n        ot.ol=\"    REPLACE +\"\n        ol=ol+1\n        ot.ol=\"    NEWNAME('\"strip(mydsn,\"B\",\"'\")\".???.???')\"\n        ol=ol+1\n        ot.ol=\">>>>>> Please Select the needed parameter and use 'EX'\"\n        ol=ol+1\n        ot.ol=\"\"\n      end\n    end\n    start=j\n  end\nend\notherwise\n  ol=ol+1\n  ot.ol=\"Unknown first line in output|\"\n  do i=start to hsm.0\n    ol=ol+1\n    ot.ol=hsm.i\n  end\n  start=i\nend\n/* write the data */\naddress mvs \"execio \"ol\" diskw \"ydd2\" (stem ot. finis\"\n/* show the result */\naddress ispexec \"lminit dataid(myou) ddname(\"ydd2\")\"\naddress ispexec \"edit dataid(\"myou\")\"ed_parms\naddress ispexec \"lmfree dataid(\"myou\")\"\naddress tso \"free fi(\"ydd2\")\"\n\nexit\n\nMyDsCat:\n\ninfodsn = arg(1)\ninfovol = strip(arg(2),\"B\")                        /* Eberle 120720 */\n\nif       Pos(\"(\",InfoDsn) > 0 then do\n         Parse Var InfoDsn InfoDsn \"(\" .\n         if Left(InfoDsn,1) = \"'\" then Infodsn = InfoDsn\"'\"\nend\n\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(121)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  \"Cursor = \"curline curcol                           /* 2.12 HUK */\n  exit 0\nend\n/* listcat the dataset */\nx=outtrap(\"ycos.\")\naddress tso \"listc ent(\"infodsn\") all\"\nx=outtrap(\"OFF\")\n\n/* create info line */\ninfo.1=\"YCOS LISTCAT:\" translate(strip(infodsn)) date(\"E\") time()\ninfo.2=copies(\"-\",121)\naddress mvs \"execio 2 diskw \"ydd1\" (stem info.\"\n/* write the Listcat data */\naddress mvs \"execio \"ycos.0\" diskw \"ydd1\" (stem ycos. finis\"\n/* show the result */\naddress ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\naddress ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\naddress ispexec \"lmfree dataid(\"myou\")\"\nmsgset=msg('OFF')\naddress tso \"free fi(\"ydd1\")\"\nmsgset=msg(msgset)\n\"cursor =\"curline curcol                                        /* 2.12 HUK */\n\nExit 0\n\nFormDate:\n\nif mylang=\"ENU\" then Return Arg(1)\nif       Pos(\"/\",Arg(1)) = 0 then Return Arg(1)\nReturn   SubStr(Arg(1),9,2)\".\"SubStr(Arg(1),6,2)\".\"SubStr(Arg(1),1,4)\n\nEdit:\n\nEditT    = Arg(1)\nEditN    = Length(EditT)\nEditR    = \"\"\nEditP    = 0\n\ndo       forever\n         if EditN = 0 then leave\n         if SubStr(EditT,EditN,1) <> \",\" then do\n            EditR = SubStr(EditT,EditN,1)\"\"EditR\n            EditP = EditP + 1\n            if EditP // 3 = 0 then EditR = \".\"EditR\n         end\n         EditN = EditN - 1\nend\n\nreturn   Strip(EditR,\"L\",\".\")\n\nhelp:\n\nprm = arg(1)  /* 2.9 */\n\nhelp_V:       /* 2.16 */\n\n/* Comment Start\nAddress  TSO \"CLEAR\"\n   Comment End */\nif prm <> \"OUTSIDE\" then do  /* 2.9 */\n  wo=start+1\n  \"(CAPMODE) = CAPS\"\n  if capmode = \"ON\" then\n    \"CAPS OFF\"\nend\naddress TSO NEWSTACK\ncall \"YCLMAHLP\"\ndo cnt=1 to queued()\n   parse pull msg\n   if prm = \"OUTSIDE\" then do  /* 2.9 */\n     m.cnt=Msg\n   end\n   else do\n     \"LINE_BEFORE\" wo\" = INFOLINE '\"msg\"'\"\n     if rc<>0 then do\n       ZedSMsg = \"\"\n       ZedLMsg = \"display of help not possible\"\n       Address ISPEXEC 'SETMSG MSG(ISRZ001)'\n       leave cnt\n     end\n   end\nend\naddress TSO DELSTACK\nif prm = \"OUTSIDE\" then do  /* 2.9 */\n  /* alloc output datasets */\n  call bpxwdyn \"alloc space(15,15) tracks new delete lrecl(80)\",\n     \"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\n  if result<>0 then do\n    say \"Alloc temp dataset error:\" result\n    do i=1 to ymsg1.0\n      say ymsg1.i\n    end\n    do i=1 to cnt-1\n      say m.i\n    end\n    exit 0\n  end\n  /* write the data */\n  address mvs \"execio \"cnt-1\" diskw \"ydd1\" (stem m. finis\"\n  /* show the result */\n  address ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\n  address ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\n  address ispexec \"lmfree dataid(\"myou\")\"\n  msgset=msg('OFF')\n  address tso \"free fi(\"ydd1\")\"\n  msgset=msg(msgset)\nend\nelse do\n  if capmode = \"ON\" then\n    \"CAPS ON\"\n  if curline - 1 <> 0 then \"cursor = \"curline - 1\" 0\" /*Eberle 120801*/\nend\nexit     0\n\n\nex_tso:\n/* run a command         */\n/* - tso (default)       */\n/* - sdsf                */\n/* - ejes      2.8       */\n/* - unix und unixsu     */\n/* - udlist    2.8       */\n/* - ufdir     2.8       */\n/* - uffil     2.9       */\n/* - unixenv   2.11      */\n/* - unixsuenv 2.11      */\n/* - ing       2.19      */\n/* - ispf      2.19      */\nparse var line cmdtype lrest /* check command type        */\ncmdtype=translate(strip(cmdtype))\nselect\nwhen cmdtype=\"SDSF\" then do\n  line=lrest\n  call ex_sdsf \"SDSF\"\n  return\nend\nwhen cmdtype=\"EJES\" then do\n  line=lrest\n  call ex_sdsf \"EJES\"\n  return\nend\nwhen cmdtype=\"UNIX\" then do\n  line=lrest\n  call ex_unix\n  return\nend\nwhen cmdtype=\"UNIXSU\" then do\n  line=lrest\n  call ex_unix \"SU\"\n  return\nend\nwhen cmdtype=\"UNIXENV\" then do                          /* 2.11 */\n  line=lrest                                            /* 2.11 */\n  usren=\"ENV\"                                           /* 2.11 */\n  call ex_unix                                          /* 2.11 */\n  return                                                /* 2.11 */\nend                                                     /* 2.11 */\nwhen cmdtype=\"UNIXSUENV\" then do                        /* 2.11 */\n  line=lrest                                            /* 2.11 */\n  usren=\"ENV\"                                           /* 2.11 */\n  call ex_unix \"SU\"                                     /* 2.11 */\n  return                                                /* 2.11 */\nend                                                     /* 2.11 */\nwhen cmdtype=\"ING\" then do                              /* 2.19 */\n  line=lrest                                            /* 2.19 */\n  call ex_ING                                           /* 2.19 */\n  return                                                /* 2.19 */\nend                                                     /* 2.19 */\nwhen cmdtype=\"ISPF\" then do                             /* 2.19 */\n  line=lrest                                            /* 2.19 */\n  call ex_ISPF                                          /* 2.19 */\n  return                                                /* 2.19 */\nend                                                     /* 2.19 */\nwhen cmdtype=\"UDLIST\" then do    /* 2.8 */\n  line=lrest\n  call ex_udlist\n  return\nend\nwhen cmdtype=\"UFDIR\"  then do    /* 2.8 */\n  line=lrest\n  call ex_ufdir\n  return\nend\nwhen cmdtype=\"UFFIL\"  then do    /* 2.9 */\n  line=lrest\n  call ex_uffil\n  return\nend\nwhen cmdtype=\"TSO\" then do\n  line=lrest\nend\notherwise\n  nop\nend\n/* end */\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n   j=j+1\n   if j>lli then do\n     say \"Continuation error\"\n     return\n   end\n   \"(CLINE) = LINE \"j     /* Get line value                  */\n   line=strip(strip(line),\"T\",right(strip(line),1)) strip(cline)\nend\next_tso_ex:   /* 2.9 */\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(121)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  exit 0\nend\n/* execute the command */\nx=outtrap(\"ycos.\")\naddress tso strip(line)\nsaverc=rc\nx=outtrap(\"OFF\")\n\nif ycos.0 > 0 then do\n  /* create info line */\n  info.1=\"YCOS CMD:\" strip(line) date(\"E\") time() \"RC=\"saverc\n  info.2=copies(\"-\",121)\n  if  rc_ext > 0 then do  /* 2.14 */\n    do l3=1 to ycos.0\n      say ycos.l3\n    end\n  end\n  else do\n    address mvs \"execio 2 diskw \"ydd1\" (stem info.\"\n    /* write the data */\n    address mvs \"execio \"ycos.0\" diskw \"ydd1\" (stem ycos. finis\"\n    /* show the result */\n    address ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\n    address ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\n    address ispexec \"lmfree dataid(\"myou\")\"\n  end\nend\nelse do\n  ZedSMsg = \"\"\n  ZedLMsg = \"YCOS CMD:\" strip(line) date(\"E\") time() \"RC=\"saverc\n  Address ISPEXEC 'SETMSG MSG(ISRZ001)'\nend\nmsgset=msg('OFF')\naddress tso \"free fi(\"ydd1\")\"\nmsgset=msg(msgset)\nreturn\n\n/* */\n/* yves */\nylang: procedure\nNumeric  Digits 10                      /*Allow for big addresses    */\nTCBAddr  = C2D(       Storage(D2X(540                 ),  4) )\nJSCBAddr = C2D(       Storage(D2X(TCBAddr  +       180),  4) )\nPSCBAddr = C2D(       Storage(D2X(JSCBAddr +       264),  4) )\nUPTAddr  = C2D(       Storage(D2X(PSCBAddr +        52),  4) )\nUpt      = Storage(D2X(UptAddr),176)\nPLang    = SubStr(Upt,25,3)\nreturn plang\n\n/* 2.12 */\nJCL_UP: procedure expose jcl_hyph jcl_if\n/* Parm1 = Line      */\n/* Parm2 = Length    */\n/* */\np1=arg(1)\np2=arg(2)\ninfo=p1\njclstm1=\"/CNTL/ENDCNTL/ELSE/ENDIF/PEND/EXPORT/\"\njclstm2=\"/COMMAND/DD/EXEC/INCLUDE/JCLLIB/JOB/OUTPUT/PROC/SET/XMIT/\"\n/* 2.21 */\njclstm2=jclstm2\"/EXPORT/JOBGROUP/GJOB/JOBSET/SJOB/ENDSET/ENDGROUP/\"\njclstm2=jclstm2\"/BEFORE/AFTER/CONCURRENT/SCHEDULE/\"\njclstm3=\"/IF/NOTIFY/\"\nselect\nwhen p1=\"//\" then do    /* 2.14 job end */\n  jcl_if  =\"N\"\n  jcl_hyph=\"N\"\nend\nwhen left(p1,3)=\"//*\" then do\n  jcl_if  =\"N\"\n  jcl_hyph=\"N\"\nend\nwhen left(p1,2)<>\"//\" then do\n  jcl_if  =\"N\"\n  jcl_hyph=\"N\"\nend\notherwise\n  if substr(p1,3,1)=\" \" then do\n    parse var p1 \"//\" jcl com rest .\n    label=\"\"\n    stmt =\"\"\n    jcu=translate(strip(jcl))\n    select  /* //   jcl comment      */\n    when pos(\"/\"jcu\"/\",jclstm1)>0 then do\n      wo=pos(jcl,p1)\n      info=overlay(jcu,info,wo,length(jcu))\n    end     /* //   jcl stmt comment */\n    when pos(\"/\"jcu\"/\",jclstm2)>0 then do\n      wo=pos(jcl,p1)\n      info=overlay(jcu,info,wo,length(jcu))\n      wo=pos(\" \"com,p1,wo)\n      if pos(\"'\",com)=0 & pos('\"',com)=0 then do     /* 2.14 */\n        com=translate(com)\n      end\n      else do\n        ph1=pos(\"'\",com)              /* 2.14 */\n        if ph1=0 then ph1=999         /* 2.14 */\n        ph2=pos('\"',com)              /* 2.14 */\n        if ph2=0 then ph2=999         /* 2.14 */\n        if ph1>0 & ph1<ph2 then do    /* 2.14 */\n          com=chk_jclu(com,\"'\")       /* 2.14 */\n        end                           /* 2.14 */\n        else do                       /* 2.14 */\n          com=chk_jclu(com,'\"')       /* 2.14 */\n        end\n      end\n      info=overlay(\" \"com,info,wo,length(com)+1)\n    end     /* //   jcl stmt1 stmt2 comment */\n    when pos(\"/\"jcu\"/\",jclstm3)>0 then do\n      wo= pos(\" THEN \",translate(p1))\n      if wo>0 then do\n        jcu=translate(left(p1,wo+5))\n        info=overlay(jcu,info,1)\n      end\n      else do\n        info=translate(info)\n        jcl_if  =\"Y\"\n      end\n    end\n    otherwise /* continuation */\n      select\n      when jcl_if  =\"Y\" then do\n        wo= pos(\" THEN \",translate(p1))\n        if wo>0 then do\n          jcu=translate(left(p1,wo+5))\n          info=overlay(jcu,info,1)\n          jcl_if  =\"N\"\n        end\n        else do\n          info=translate(info)\n        end\n      end\n      when jcl_hyph=\"Y\" then do\n        if pos(\"'\",p1)=0 & pos('\"',p1)=0 then do      /* 2.14 */\n          nop\n        end\n        else do\n          ph1=pos(\"'\",p1)               /* 2.14 */\n          if ph1=0 then ph1=999         /* 2.14 */\n          ph2=pos('\"',p1)               /* 2.14 */\n          if ph2=0 then ph2=999         /* 2.14 */\n          if ph1>0 & ph1<ph2 then do                  /* 2.14 */\n            wo=ph1                                    /* 2.14 */\n            wo=pos(\" \",p1,wo)                         /* 2.14 */\n            com=chk_jclu(left(p1,wo),\"'\")             /* 2.14 */\n            info=overlay(com,info,1)                  /* 2.14 */\n          end                                         /* 2.14 */\n          else do                                     /* 2.14 */\n            wo=ph2                                    /* 2.14 */\n            wo=pos(\" \",p1,wo)                         /* 2.14 */\n            com=chk_jclu(left(p1,wo),'\"')             /* 2.14 */\n            info=overlay(com,info,1)                  /* 2.14 */\n          end                                         /* 2.14 */\n        end\n      end\n      otherwise /* continuation - no if and no ' */\n        ph1=pos(\"'\",p1)                               /* 2.21 */\n        if ph1=0 then ph1=999                         /* 2.21 */\n        ph2=pos('\"',p1)                               /* 2.21 */\n        if ph2=0 then ph2=999                         /* 2.21 */\n        if ph1>0 & ph1<ph2 then do                    /* 2.21 */\n          wo=ph1                                      /* 2.21 */\n          wo=pos(\" \",p1,wo)                           /* 2.21 */\n          com=chk_jclu(left(p1,wo),\"'\")               /* 2.21 */\n          info=overlay(com,info,1)                    /* 2.21 */\n        end                                           /* 2.21 */\n        else do                                       /* 2.21 */\n          wo=ph2                                      /* 2.21 */\n          wo=pos(\" \",p1,wo)                           /* 2.21 */\n          com=chk_jclu(left(p1,wo),'\"')               /* 2.21 */\n          info=overlay(com,info,1)                    /* 2.21 */\n        end                                           /* 2.21 */\n      end\n    end\n  end\n  else do\n    parse var p1 \"//\" label jcl stmt comment\n    info=overlay(translate(label),info,3)\n    jcu=translate(strip(jcl))\n    wo=pos(jcl,p1)\n    info=overlay(translate(jcl),info,wo)\n    select  /* //lab   jcl comment      */\n    when pos(\"/\"jcu\"/\",jclstm1)>0 then do\n      nop\n    end     /* //lab   jcl stmt comment */\n    when pos(\"/\"jcu\"/\",jclstm2)>0 then do\n      wo=pos(\" \"stmt,p1)\n      stmt=chk_jclu(stmt)\n      info=overlay(stmt,info,wo+1)\n    end     /* //lab   jcl stmt1 stmt2 comment */\n    when pos(\"/\"jcu\"/\",jclstm3)>0 then do\n      wo= pos(\" THEN \",translate(p1))\n      if wo>0 then do\n        jcu=translate(left(p1,wo+5))\n        info=overlay(jcu,info,1)\n      end\n      else do\n        info=translate(info)\n        jcl_if  =\"Y\"\n      end\n    end     /* //lab   jcl stmt1 stmt2 comment */\n    otherwise /* continuation */\n      info=info\n    end\n  end\nend\nreturn info\n/* 2.12 */\nCHK_JCLU: procedure expose jcl_cont jcl_hyph\np1=arg(1)\np2=arg(2)             /* 2.14 */\nstart=1\nif p2=\"\" then do                /* 2.14 */\n  if pos(\"'\",p1)>0 then do      /* 2.14 */\n    p2=\"'\"                      /* 2.14 */\n    stop=pos(p2,p1)             /* 2.14 */\n  end                           /* 2.14 */\n  else do                       /* 2.14 */\n    if pos('\"',p1)>0 then do    /* 2.14 */\n      p2='\"'                    /* 2.14 */\n      stop=pos(p2,p1)           /* 2.14 */\n    end                         /* 2.14 */\n    else do                     /* 2.14 */\n      stop=0                    /* 2.14 */\n    end                         /* 2.14 */\n  end                           /* 2.14 */\nend                             /* 2.14 */\nelse do                         /* 2.14 */\n  stop=pos(p2,p1)               /* 2.14 */\nend                             /* 2.14 */\ndo while stop>0\n  if jcl_hyph=\"N\" then do\n    p1=overlay(translate(substr(p1,start,stop-start+1)),p1,start)\n    jcl_hyph=\"Y\"\n  end\n  else do\n    jcl_hyph=\"N\"\n  end\n  start=stop+1\n  stop=pos(p2,p1,start)   /* 2.14 */\nend\nif jcl_hyph=\"N\" & start<>length(p1) then do\n  p1=overlay(translate(substr(p1,start)),p1,start)\nend\n\nreturn p1\n\nASCEBC: procedure\n/* Parm1 = Line      */\n/* Parm2 = Length    */\n/* Parm3 = E - Convert to Ebcdic */\n/*       = A - Convert to Ascii  */\n\ntabas =        '000102039C09867F978D8E0B0C0D0E0F'x      /* 00 */\ntabas = tabas||'101112139D8508871819928F1C1D1E1F'x      /* 10 */\ntabas = tabas||'80818283840A171B88898A8B8C050607'x      /* 20 */\ntabas = tabas||'909116939495960498999A9B14159E1A'x      /* 30 */\ntabas = tabas||'20A0E2E4E0E1E3E5E7F1A22E3C282B7C'x      /* 40 */\ntabas = tabas||'26E9EAEBE8EDEEEFECDF21242A293B5E'x      /* 50 */\ntabas = tabas||'2D2FC2C4C0C1C3C5C7D1A62C255F3E3F'x      /* 60 */\ntabas = tabas||'F8C9CACBC8CDCECFCC603A2340273D22'x      /* 70 */\ntabas = tabas||'D8616263646566676869ABBBF0FDFEB1'x      /* 80 */\ntabas = tabas||'B06A6B6C6D6E6F707172AABAE6B8C6A4'x      /* 90 */\ntabas = tabas||'B57E737475767778797AA1BFD05BDEAE'x      /* A0 */\ntabas = tabas||'ACA3A5B7A9A7B6BCBDBEDDA8AF5DB4D7'x      /* B0 */\ntabas = tabas||'7B414243444546474849ADF4F6F2F3F5'x      /* C0 */\ntabas = tabas||'7D4A4B4C4D4E4F505152B9FBFCF9FAFF'x      /* D0 */\ntabas = tabas||'5CF7535455565758595AB2D4D6D2D3D5'x      /* E0 */\ntabas = tabas||'30313233343536373839B3DBDCD9DA9F'x      /* F0 */\n\nhextable =             '000102030405060708090A0B0C0D0E0F'x   /* 00 */\nhextable = hextable || '101112131415161718191A1B1C1D1E1F'x   /* 10 */\nhextable = hextable || '202122232425262728292A2B2C2D2E2F'x   /* 20 */\nhextable = hextable || '303132333435363738393A3B3C3D3E3F'x   /* 30 */\nhextable = hextable || '404142434445464748494A4B4C4D4E4F'x   /* 40 */\nhextable = hextable || '505152535455565758595A5B5C5D5E5F'x   /* 50 */\nhextable = hextable || '606162636465666768696A6B6C6D6E6F'x   /* 60 */\nhextable = hextable || '707172737475767778797A7B7C7D7E7F'x   /* 70 */\nhextable = hextable || '808182838485868788898A8B8C8D8E8F'x   /* 80 */\nhextable = hextable || '909192939495969798999A9B9C9D9E9F'x   /* 90 */\nhextable = hextable || 'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'x   /* A0 */\nhextable = hextable || 'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'x   /* B0 */\nhextable = hextable || 'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'x   /* C0 */\nhextable = hextable || 'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'x   /* D0 */\nhextable = hextable || 'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'x   /* E0 */\nhextable = hextable || 'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'x   /* F0 */\n\nif arg(3)=\"E\" then do\n  info=translate(left(arg(1),arg(2)),hextable,tabas)\nend\nelse do\n  info=translate(left(arg(1),arg(2)),tabas,hextable)\nend\nreturn info\n\ncheck_ext_macro: procedure\narg ddname member\naddress \"ISPEXEC\"\n/* 2.18 */\nckmac_found = 0\n\"QBASELIB \"ddname\" ID(ckmac)\"\nckmac = translate(ckmac,,',')\ndo ckmac_I = 1 to words(ckmac) until ckmac_found\n   \"LMInit DataID(did) Dataset(\"word(ckmac,ckmac_I)\") ENQ(SHR)\"\n   \"LMOpen DataID(\"did\")\"\n   \"LMMFind DataID(\"did\") Member(\"member\")\"\n   ret_cde = RC\n   if ret_cde = 0 then ckmac_found = 1\n/* 2.18 */\n   \"LMClose DataID(\"did\")\"\n   \"LMFree  DataID(\"did\")\"\nend\nReturn ret_cde\n\n/* */\n/* 2.60 */\nex_sdsf:\n/* run command within SDSF */\n/*          or within EJES */\nworld_cmd=arg(1)\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\"\"strip(cline)\nend\next_sdsf_ex:   /* 2.9 */\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(121)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  exit 0\nend\n/* execute the command */\n\nlc=1\nline=strip(line)\nyc.lc=\"Executing:\" line\nlc=2\nyc.lc=copies(\"-\",121)\nlc=3\nyc.lc=\" \"\n\nif world_cmd=\"SDSF\" then do\n  rc=isfcalls('ON')\n  /* Comment Start                                        /* 2.10 */\n  line=\"'\"line\"'\"                                         /* 2.10 */\n     Comment End */                                       /* 2.10 */\nend\nelse do\n  rc=ejesisfx('ON')\nend\nif rc<>0 then do\n  lc=lc+1\n  if world_cmd=\"SDSF\" then do\n    yc.lc=\"Error on ISFCALLS('ON') - RC:\"rc\n  end\n  else do\n    yc.lc=\"Error on EJESISFX('ON') - RC:\"rc\n  end\nend\nelse do\n     /************************************/\n     /* Set console name                 */\n     /************************************/\n  isfcons =userid()\"Y\"\n  if pos(\"'\",line)>0 then do                              /* 2.10 */\n    wo=pos(\"'\",line)                                      /* 2.10 */\n    do while wo>0                                         /* 2.10 */\n      line=left(line,wo)\"'\"substr(line,wo+1)              /* 2.10 */\n      wo=pos(\"'\",line,wo+2)                               /* 2.10 */\n    end                                                   /* 2.10 */\n  end                                                     /* 2.10 */\n  Address SDSF \"ISFEXEC '/\"line\"' (WAIT)\"                 /* 2.10 */\n  lrc=rc\n  if lrc<>0 then do\n    if isfmsg<>\"\" then do\n      lc=lc+1\n      yc.lc=\"Error on ISFEXEC - RC:\"lrc\n      lc=lc+1\n      yc.lc=\"isfmsg is:\" isfmsg\n         /****************************************************/\n         /* The isfmsg2 stem contains additional descriptive */\n         /* error messages                                   */\n         /****************************************************/\n    end\n    do ix=1 to isfmsg2.0\n      lc=lc+1\n      yc.lc=\"isfmsg2.\"ix \"is:\" isfmsg2.ix\n    end\n  end\n  else do\n\n    if isfresp.0>0 then do\n      yc.2=overlay(\" \"isfresp.0\" Lines of responses \",yc.2,5)\n         /**************************************************/\n         /* The responses are returned in the isfresp stem */\n         /**************************************************/\n      do ix=1 to isfresp.0\n        lc=lc+1\n        yc.lc=isfresp.ix\n      end\n    end\n\n    if isfulog.0>0 then do\n      lc=lc+1\n      yc.lc=overlay(\" \"isfulog.0\" Lines of output \",copies(\"=\",121),5)\n\n       /**************************************************/\n       /* The Message   are returned in the isfulog stem */\n       /**************************************************/\n      do ix=1 to isfulog.0\n        lc=lc+1\n        yc.lc=isfulog.ix\n      end\n    end\n  end\nend\n\nif world_cmd=\"SDSF\" then do\n  rc=isfcalls('OFF')\nend\nelse do\n  rc=ejesisfx('OFF')\nend\n\nif SYSVAR(\"SYSENV\")=\"FORE\" then do  /* 2.14 */\n  /* write the data */\n  address mvs \"execio \"lc\" diskw \"ydd1\" (stem yc. finis\"\n  /* show the result */\n  address ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\n  address ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\n  address ispexec \"lmfree dataid(\"myou\")\"\n  address tso \"free fi(\"ydd1\")\"\nend                                 /* 2.14 */\nelse do                             /* 2.14 */\n  do j=1 to lc                      /* 2.14 */\n    say yc.j                        /* 2.14 */\n  end                               /* 2.14 */\nend                                 /* 2.14 */\n\nreturn\n\n/* */\n/* 2.19 */\nex_ING:\n/* run command for SA System automation */\nworld_cmd=arg(1)\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\"\"strip(cline)\nend\next_ING_EX:\n/* 2.21 */\nSaLib=\"SYS1.ING.SINGTREX\"\nif sysdsn(\"'\"SaLib\"'\")<>\"OK\" then do\n  \"%YCINGCUS\"\n  if rc=0 then pull SaLib\n  else do\n    ZedSMsg = \"See YCLMACRX DOC\"\n    ZedLMsg = \"You HAVE to crate an own YCINGCUS rexx to set the name\",\n              \"of you System Automation Rexx\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    exit\n  end\nend\n  /* */\n  /* */\n/* */\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(4096)\",\n   \"recfm(v,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  exit 0\nend\n/* alloc SYSIN dataset */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(80)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg2.) rtddn(ydd2) rtdsn(ydsn2)\"\nif result<>0 then do\n  say \"Alloc sysin dataset error:\" result\n  do i=1 to ymsg2.0\n    say ymsg2.i\n  end\n  exit 0\nend\n/* write command to sysin */\n/* including redirection  */\nl.1=strip(line) \">\"ydd1\naddress mvs \"execio 1 diskw \"ydd2\" (stem l. finis\"\n/* outtrap the infos */\nx=outtrap(\"YCOS.\")\n/* execute the command */\naddress tso,\n          \"EX '\"SaLib\"(AOFRYCMD)'\",\n          \"'SERVER=* HIGHRC=00 MAXRC=00 SYSIN=\"ydd2\"'\"\n/*                                     .-SERVER--=--EVJCMDRV-.       */\n/* >>-AOFRYCMD--+------+--+---------+--+---------------------+-----> */\n/*              '-wsid-'  '-NOWKSTS-'  '-SERVER--=--+-name-+-'       */\n/*                                                  '-*----'         */\n/*    .-TIMEOUT--=--60------.  .-HIGHRC--=--0-----------.            */\n/* >--+---------------------+--+------------------------+----------> */\n/*    +-TIMEOUT--=--seconds-+  '-HIGHRC--=--return_code-'            */\n/*    '-TIMEOUT--=--NONE----'                                        */\n/*    .-MAXRC--=--999---------.  .-SYSIN--=--SYSIN--.                */\n/* >--+-----------------------+--+------------------+--------------> */\n/*    '-MAXRC--=--return_code-'  '-SYSIN--=--DDname-'                */\n/*    .-REDIRECT--=-->-----.  .-ASIS--=--NO--.                       */\n/* >--+--------------------+--+--------------+-------------------->< */\n/*    '-REDIRECT--=--chars-'  '-ASIS--=--YES-'                       */\nx=outtrap(\"Off.\")\naddress tso \"free fi(\"ydd2\")\"\n\nif SYSVAR(\"SYSENV\")=\"FORE\" then do\n  /* write the result */\n  call bpxwdyn \"alloc space(15,15) tracks new delete lrecl(4096)\",\n     \"recfm(v,b) dsorg(ps) msg(ymsgo.) rtddn(yddo) rtdsn(ydsno)\"\n  if result<>0 then do\n    say \"Alloc temp dataset error:\" result\n    do i=1 to ymsgo.0\n      say ymsgo.i\n    end\n    exit 0\n  end\n  address mvs \"execio \"ycos.0\" diskw \"yddo\" (stem ycos.\"\n  drop ycos.\n  address mvs \"execio * diskr \"ydd1\" (stem ycos. finis\"\n  address mvs \"execio \"ycos.0\" diskw \"yddo\" (stem ycos. finis\"\n  /* show the result */\n  address ispexec \"lminit dataid(myou) ddname(\"yddo\")\"\n  address ispexec \"edit dataid(\"myou\")\"ed_parms\n  address ispexec \"lmfree dataid(\"myou\")\"\n  address tso \"free fi(\"yddo\")\"\n  address tso \"free fi(\"ydd1\")\"\nend\nelse do\n  do j=1 to ycos.0\n    say ycos.j\n  end\n  address mvs \"execio * diskr \"ydd1\" (stem yc. finis\"\n  address tso \"free fi(\"ydd1\")\"\n  do j=1 to yc.0\n    say yc.j\n  end\nend\n\nreturn\n/* */\n/* 2.19 */\nex_ISPF:\n/* run ISPF Command                     */\n/* addess ispexec ...                   */\nworld_cmd=arg(1)\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\" \"strip(cline)\nend\n/* check if panel used */\n/* many thanks to Gilbert Saint-Flour| (RIP) */\nparse upper var line p1 \"PANEL(\" p2 \")\"\nif p1=\"REFRESH\" & p2<>\"\" then do\n  DO I=1 TO 30\n    address ispexec,\n    \"DISPLAY PANEL($Y$\"RIGHT(I,5,'0')\n  END\n  line=\"select panel(\"p2\")\"\nend\n/* run command */\naddress ispexec line\nsavrc=rc\n/* rc */\nif savrc<>0 then do\n  ZedSMsg = \"\"\n  ZedLMsg = \"ISPF:\" line \"- Error:\" savrc\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\nend\n\nreturn\n\n/* */\n/* 2.60 */\nex_unix:\nusrsu=arg(1)\n/* run command within Unix */\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\n/* Start 2.11 new */\nextra_env=0                                              /* 2.11 */\nif usren=\"ENV\" then do                                   /* 2.11 */\n  if wordpos(right(strip(line),1),\"+ ,\")>0 then do\n    nl=j+1\n    \"(LINE) = LINE \"nl    /* Get line value              */\n    if translate(left(strip(line),18))=\"ENV_VARIABLE_START\" then do\n      \"(LINE) = LINE \"nl+1  /* Get line value              */\n      do l1=nl+2 to lli\n        if translate(left(strip(line),18))=\"ENV_VARIABLE_END\" then do\n          j=l1\n          l1=lli+99\n        end\n        else do\n          extra_env=extra_env+1\n          extra_var.extra_env=strip(line)\n          \"(LINE) = LINE \"l1    /* Get line value              */\n        end\n      end\n      \"(LINE) = LINE \"j     /* Get line value              */\n    end\n  end\nend\n/* End   2.11 new */\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\" \"strip(cline)\nend\next_unix_ex:   /* 2.9 */\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(1024)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  exit 0\nend\n/* execute the command */\n/* */\nif syscalls('ON')>0 then do\n  say \"Unix environment not possible\"\n  exit 8\nend\naddress syscall 'getuid'\nmyuid=retval\naddress syscall 'geteuid'\nmyeuid=retval\nsuper=\"0\"\n\nlc=1\nline=strip(line)\nyc.lc=\"Executing:\" line\nif myeuid<>0 & usrsu<>\"\" then do\n  address syscall 'seteuid 0'\n  address syscall 'geteuid'\n  if retval<>0 then do\n    say \"Seteuid not successful - review RACF BPX.SUPERUSER\"\n    exit 8\n  end\n  address syscall 'getuid'\n  myuid=retval\n  address syscall 'geteuid'\n  myeuid=retval\n  lc=lc+1\n  yc.lc=\"Current uid :\" myuid \"Current euid:\" myeuid\n  lc=lc+1\n  yc.lc=\"Now running SU - Superuser\"\n  super=\"1\"\nend\nelse do\n  lc=lc+1\n  yc.lc=\"Current uid :\" myuid \"Current euid:\" myeuid\nend\nlc=lc+1\nyc.lc=copies(\"-\",121)\nlc=lc+1\nyc.lc=\" \"\n\n/* Start 2.11 new */\nif usren=\"ENV\" then do                                   /* 2.11 */\n  msgs = msg('OFF')\n  address tso,\n  \"FREE fi(STDERR, STDIN, STDOUT)\"\n  msgs = msg(msgs)\n  /* alloc output datasets */\n  call bpxwdyn \"alloc space(15,15) tracks new delete lrecl(4096)\",\n     \"fi(stdout) recfm(v,b) dsorg(ps) msg(ymsg1.)\"\n  if result<>0 then do\n    say \"Alloc STDOUT dataset error:\" result\n    do i=1 to ymsg1.0\n      say ymsg1.i\n    end\n    exit 8\n  end\n  /* alloc dummy datasets */\n  call bpxwdyn \"alloc dummy\",\n     \"fi(stdin) msg(ymsg1.)\"\n  if result<>0 then do\n    say \"Alloc STDIN DUMMY error:\" result\n    do i=1 to ymsg1.0\n      say ymsg1.i\n    end\n    exit 8\n  end\n  call bpxwdyn \"alloc space(15,15) tracks new delete lrecl(4096)\",\n     \"fi(stderr) recfm(v,b) dsorg(ps) msg(ymsg1.)\"\n  if result<>0 then do\n    say \"Alloc STDERR dataset error:\" result\n    do i=1 to ymsg1.0\n      say ymsg1.i\n    end\n    exit 8\n  end\n  /****************************************************/\n  /* Invoke shell by calling BPXBATCH                 */\n  /****************************************************/\n  address tso,\n  \"BPXBATCH SH echo YENV Results;env\"\n\n  IF RC <> 0 Then Do\n    Say ' YEND RC = ' RC\n    Say ' '\n    IF RC > 255 Then Do\n      Say ' YEND Exit Status = ' RC/256\n      Say ' '\n    End\n    address mvs,\n    \"EXECIO * DISKR STDERR (stem e. finis\"\n    say \"STDERR:\"\n    do i=1 to e.0\n      say e.i\n    end\n    exit 8\n  End\n  address mvs,\n  \"EXECIO * DISKR STDOUT (stem l. finis\"\n  yenv.0=0\n  do i=1 until left(l.i,12)=\"YENV Results\"\n  end\n  do i=i+1 to l.0\n    yenv.0=yenv.0+1\n    j=yenv.0\n    yenv.j=l.i\n  end\n  if extra_env>0 then do\n    do l1=1 to extra_env\n      yenv.0=yenv.0+1\n      j=yenv.0\n      yenv.j=extra_var.l1\n    end\n  end\n  address tso,\n  \"FREE fi(STDERR, STDIN, STDOUT)\"\nend\nelse do\n  yenv.0=0\nend\n/*   End 2.11 new */\n\naddress sh\nretc=bpxwunix(line,,out.,err.,yenv.)\nif retc=0 then do\n  lc=lc+1\n  yc.lc=\"Run with following \"out.0\" response(s)\"\n  do j=1 to out.0\n    lc=lc+1\n    yc.lc=out.j\n  end\n  lc=lc+1\n  yc.lc=\"\"\nend\nelse do\n  lc=lc+1\n  yc.lc=\"Run with following retc:\" retc \"and\" err.0 \"message(s)\"\n  do j=1 to err.0\n    lc=lc+1\n    yc.lc=err.j\n  end\n  do j=1 to out.0\n    lc=lc+1\n    yc.lc=out.j\n  end\n  lc=lc+1\n  yc.lc=\"\"\nend\n/* */\nif super=1 then do\n  address syscall 'seteuid' myuid\nend\n\nrc=syscalls('OFF')\n\n/* Start 2.11 new */\nif usren=\"ENV\" then do                                   /* 2.11 */\n  if yenv.0>0 then do\n    lc=lc+1\n    yc.lc=\"\"\n    lc=lc+1\n    yc.lc=copies(\"=\",72)\n    lc=lc+1\n    yc.lc=yenv.0 \"Environment variable(s) used:\"\n    lc=lc+1\n    yc.lc=copies(\"=\",72)\n    do k=1 to yenv.0\n      lc=lc+1\n      yc.lc=yenv.k\n    end\n  end\nend\n/*   End 2.11 new */\n\nif  rc_ext > 0 then do  /* 2.14 */\n  do l3=1 to lc\n    say yc.l3\n  end\nend\nelse do\n  /* write the data */\n  address mvs \"execio \"lc\" diskw \"ydd1\" (stem yc. finis\"\n  /* show the result */\n  address ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\n  address ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\n  address ispexec \"lmfree dataid(\"myou\")\"\n  address tso \"free fi(\"ydd1\")\"\nend\n\nreturn\n\n/* */\n/* 2.80 */\nex_udlist:\n/* show a Unix dir with UDLIST 3.17 */\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\"\"strip(cline)\nend\next_udlist_ex:   /* 2.9 */\n/* show the file/dir */\naddress ispexec,\n\"VGET ZULWFNMC\"    /* size of filename on display */\nsav_zfsz=ZULWFNMC\nZULWFNMC=40\naddress ispexec,\n\"VPUT ZULWFNMC\"\n/* */\naddress ispexec,\n\"DIRLIST PATH(LINE)\"\nif rc>0 then do   /* 2.13 */\n  ZedSMsg = ZERRSM\n  ZedLMsg = ZERRLM\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\nend\n/* */\nZULWFNMC=sav_zfsz\naddress ispexec,\n\"VPUT ZULWFNMC\"    /* size of filename on display */\n/* */\n\nreturn\n/* */\n/* 2.80 */\nex_ufdir:\n/* show all Unix dirs with UDLIST 3.17 containing a string */\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\" \"strip(cline)\nend\next_ufdir_ex:   /* 2.9 */\n/*====================================================================*/\n/* Parameter                                                          */\n/*  - dir      path to be searched                                    */\n/*  - dirname  searched directory names                               */\n/*====================================================================*/\nparse var line dir dirname\ndir=strip(dir)\ndirname=strip(dirname)\nif dirname=\"\" then do\n  say \"Not enough parms: dir dirname\"\n  return\nend\n/* */\n/* write user dslist table: isrplist          */\n/* */\n/* */\n/* open output private table */\n/* */\n  address ispexec,\n  \"TBOPEN ISRPLIST WRITE SHARE\"\n  If rc \u00ac= 0 Then               /* Return codes                     */\n    Do                          /*  8 - Table does not exist        */\n       say \"TBOPEN Problem ISRPLIST\" rc\n       exit\n    End                         /* 12 - Table in use; enq failed    */\n                                /* 16 - Input library not allocated */\n                                /* 20 - Severe error                */\n\n  zcurtb=\"YYYYMUSS\"\n  address ispexec,\n  \"TBTOP ISRPLIST\"\n  address ispexec,\n  \"TBSCAN ISRPLIST ARGLIST(ZCURTB) NOREAD\"\n  If rc = 0 Then do          /* Return codes                      */\n                             /* 0  - Row found                    */\n/* */\n/* delete  row in private table */\n/* */\n     address ispexec,\n     \"TBDELETE ISRPLIST\"\n  end\n  DSADESCP=\"Temp USS List\"\n  do loop1=1 to 30\n    interpret \"DSAPET\"right(loop1,2,\"0\")\"=''\"\n  end\n\ncall bpxwunix \"find \"dir\" -type d -name '\"dirname\"'\",,out.\ndo loop1=1 to out.0\n  if loop1>30 then do\n    say \"Too much directory matches:\" out.0 \"Only first 30 will be\",\n      \"displayed|\"\n    loop1=out.0+99\n  end\n  else do\n    interpret \"DSAPET\"right(loop1,2,\"0\")\"='\"strip(out.loop1)\"'\"\n  end\nend\nif out.0>0 then do\n/* */\n/* add row in private table */\n/* */\n   address ispexec,\n   \"TBADD ISRPLIST\"\n   address ispexec,\n   \"TBSORT ISRPLIST FIELDS(ZCURTB)\"\nEnd\n/* */\n/* */\n/* close all */\n/* */\n address ispexec,\n \"TBCLOSE ISRPLIST\"\n/* */\nif out.0>0 then do\n  zedsmsg=''\n  zedlmsg=format(out.0,9) \"directories with name:\" dirname \"found\",\n          \"from dir\" dir\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  address ispexec,\n  \"SELECT PGM(ISRDSLST) PARM(UDL YYYYMUSS)\"\nEnd\nelse do\n  zedsmsg=''\n  zedlmsg=\"No directories with name:\" dirname \"found\",\n          \"from dir\" dir\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\nEnd\n/* */\n\nreturn\n/* */\n/* 2.90 */\nex_uffil:\n/* show all Unix dirs with UDLIST 3.17 containing a file */\n\"ISREDIT (LLI) = LINENUM .ZLAST\"\nj=start\ndo while wordpos(right(strip(line),1),\"+ ,\")>0\n  j=j+1\n  if j>lli then do\n    say \"Continuation error\"\n    return\n  end\n  \"(CLINE) = LINE \"j     /* Get line value                  */\n  line=strip(strip(strip(line),\"T\",right(strip(line),1)))\" \"strip(cline)\nend\next_uffil_ex:   /* 2.9 */\n/*====================================================================*/\n/* Parameter                                                          */\n/*  - dir      path to be searched                                    */\n/*  - filename searched file names                                    */\n/*====================================================================*/\nparse var line dir filename\ndir=strip(dir)\nfilename=strip(filename)\nif filename=\"\" then do\n  say \"Not enough parms: dir filename\"\n  return\nend\n/* */\n/* write user dslist table: isrplist          */\n/* */\n/* */\n/* open output private table */\n/* */\n  address ispexec,\n  \"TBOPEN ISRPLIST WRITE SHARE\"\n  If rc \u00ac= 0 Then               /* Return codes                     */\n    Do                          /*  8 - Table does not exist        */\n       say \"TBOPEN Problem ISRPLIST\" rc\n       exit\n    End                         /* 12 - Table in use; enq failed    */\n                                /* 16 - Input library not allocated */\n                                /* 20 - Severe error                */\n\n  zcurtb=\"YYYYMUSS\"\n  address ispexec,\n  \"TBTOP ISRPLIST\"\n  address ispexec,\n  \"TBSCAN ISRPLIST ARGLIST(ZCURTB) NOREAD\"\n  If rc = 0 Then do          /* Return codes                      */\n                             /* 0  - Row found                    */\n/* */\n/* delete  row in private table */\n/* */\n     address ispexec,\n     \"TBDELETE ISRPLIST\"\n  end\n  DSADESCP=\"Temp USS List\"\n  do loop1=1 to 30\n    interpret \"DSAPET\"right(loop1,2,\"0\")\"=''\"\n  end\n\nanzdir=0\ncall bpxwunix \"find \"dir\" -type f -name '\"filename\"'\",,out.\ndo loop1=1 to out.0\n  parse value reverse(out.loop1) with \"/\" cpath\n  cpath=reverse(cpath)\n  fnd=\"N\"\n  do loop2=1 to anzdir\n    if cpath=dirf.loop2 then do\n      fnd=\"Y\"\n      dirc.loop2=dirc.loop2+1\n      leave loop2\n    end\n  end\n  if fnd=\"N\" then do\n    anzdir=anzdir+1\n    dirf.anzdir=cpath\n    dirc.anzdir=1\n  end\n  if loop1>30 then do\n    say \"Too much matches - Only first 30 will be\",\n      \"displayed|\"\n    loop1=out.0+99\n  end\n  else do\n    interpret \"DSAPET\"right(loop1,2,\"0\")\"='\"strip(out.loop1)\"'\"\n  end\nend\nif out.0>0 then do\n/* */\n/* add row in private table */\n/* */\n   address ispexec,\n   \"TBADD ISRPLIST\"\n   address ispexec,\n   \"TBSORT ISRPLIST FIELDS(ZCURTB)\"\nEnd\n/* */\n/* */\n/* close all */\n/* */\n address ispexec,\n \"TBCLOSE ISRPLIST\"\n/* */\nif out.0>0 then do\n  zedsmsg=''\n  zedlmsg=out.0 \"files with name:\" filename \"found in \"anzdir,\n          \"directories, searching from\" dir\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  address ispexec,\n  \"SELECT PGM(ISRDSLST) PARM(UDL YYYYMUSS)\"\nEnd\nelse do\n  zedsmsg=''\n  zedlmsg=\"No files with name:\" filename \"found\",\n          \"from dir\" dir\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\nEnd\n/* */\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACT": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x00\\x01\\x18\\x06\\x1f\\x01\\x18\\x06\\x1f\\x16\\x16\\x00\\xa6\\x00\\xa6\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2018-03-02T00:00:00", "modifydate": "2018-03-02T16:16:00", "lines": 166, "newlines": 166, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACT      (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2012-17                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*|                                                                  |*/\n/*| Create z/OS 1.13 Table - for line commands                       |*/\ncmdname=\"YCLMACRX\"  /* Default Name for all Commands */\n/*|                                                                  |*/\n/*+------------------------------------------------------------------+*/\n/*| Vers 1.19  27.12.2017 RU also added                              |*/\n/*| Vers 1.18  16.12.2016 PG and PDS also added                      |*/\n/*| Vers 1.17  11.10.2016 CL - enhanced                              |*/\n/*| Vers 1.16  31.07.2015 HV single - help view                      |*/\n/*| Vers 1.15  01.09.2014 FA multi                                   |*/\n/*|                       FI and FL single                           |*/\n/*| Vers 1.14  22.07.2014 LN line size information                   |*/\n/*|                       YD hex on data                             |*/\n/*|                       TOPD delete to top                         |*/\n/*|                       BOTD delete to bottom                      |*/\n/*|                       TOPX exclude to top                        |*/\n/*|                       BOTX exclude to bottom                     |*/\n/*| Vers 1.13  03.09.2013 DA Support                                 |*/\n/*| Vers 1.01  24.07.2013 DH, REV, JU Support                        |*/\n/*|                       correct LD is only a single line cmd       |*/\n/*| Vers 1.00  19.09.2012 Yves Colliard                              |*/\n/*+------------------------------------------------------------------+*/\n/* */\nAddress  ISPEXEC \"CONTROL ERRORS RETURN\"       /* Return ispf errors  */\n/* */\naddress ispexec\n'TBERASE   YCLMACTB'\nif rc=0 then do\n  say 'Table erased'\nend\nelse do\n  say 'Table Erase error - rc' rc\nend\n'TBCREATE YCLMACTB NAMES(ZELCNAME, ZELCSLNM, ZELCPGMF,',\n          'ZELCBLKA, ZELCMLTA, ZELCDSTA)'\nsay 'Table Created'\n/* */\n   /* */\n\n/*----- single line commands          ----------------------------*/\n/* Macro   name of the Rexx or program to get control             */\nZELCSLNM=left(cmdname,8)\n/* Program Macro   N=Rexx (or Clist) Y=program                    */\nZELCPGMF=\"N\"\n/* Block Format   Y=block commands are supported (like: rr   rr)  */\nZELCBLKA=\"N\"\n/* Multi Line   Y=many lines as target (like: r9)                 */\nZELCMLTA=\"N\"\n/* Dest Used   Y=a destination line is needed (like: c -> a)      */\nZELCDSTA=\"N\"\n\n/* User Command   name of the line command (1-6 chars)            */\nZELCNAME=left(\"H\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"HELP\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"HV\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"E\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"EZ\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"V\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"VZ\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DH\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DA\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DI\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DL\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DM\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DS\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"EX\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"CL\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"LD\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"TOPD\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"BOTD\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"TOPX\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"BOTX\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"FI\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"FL\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"REV\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"PDS\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"PG\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"HC\",6)\n'TBADD YCLMACTB'\n\n/*----- Block and Multiline           ----------------------------*/\n/* Block Format   Y=block commands are supported (like: rr   rr)  */\nZELCBLKA=\"Y\"\n/* Multi Line   Y=many lines as target (like: r9)                 */\nZELCMLTA=\"Y\"\n\n/* User Command   name of the line command (1-6 chars)            */\nZELCNAME=left(\"RV\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"CE\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"AL\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"AR\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"AU\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"AD\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"YX\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"YD\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"CM\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"AE\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"EA\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"JU\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"LN\",6)\n'TBADD YCLMACTB'\n\n/*----- Multiline                     ----------------------------*/\n/* Block Format   Y=block commands are supported (like: rr   rr)  */\nZELCBLKA=\"N\"\n/* Multi Line   Y=many lines as target (like: r9)                 */\nZELCMLTA=\"Y\"\n\n/* User Command   name of the line command (1-6 chars)            */\nZELCNAME=left(\"DX\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"DZ\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"FA\",6)\n'TBADD YCLMACTB'\nZELCNAME=left(\"RU\",6)\n'TBADD YCLMACTB'\n/* */\n'TBCLOSE YCLMACTB'\n/* */\nsay \"YCLMACTB done\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMACTB": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x00\\x01\\x18\\x06\\x1f\\x01\\x18\\x06\\x1f\\x16\\x16\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2018-03-02T00:00:00", "modifydate": "2018-03-02T16:16:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "YCLMAC"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "YCLMAHLP": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x14\\x00\\x00\\x01\\x18\\t\\x9f\\x01\\x18\\t\\x9f!!\\x02\\xf7\\x02\\xf7\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.20", "flags": 0, "createdate": "2018-04-09T00:00:00", "modifydate": "2018-04-09T21:21:00", "lines": 759, "newlines": 759, "modlines": 0, "user": "YCLMAC"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-17                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*| Help File - see YCLMACRX                                         |*/\n/*+------------------------------------------------------------------+*/\n\nbefq=queued()\nqueue '+------------------------------------------------------------------+'\nqueue '| YCLMACRX     (c)  YCOS Yves Colliard Software                    |'\nqueue '+------------------------------------------------------------------+'\nqueue '|                                                                   '\nqueue '| Functions of YCLMACRX:                                            '\nqueue '| H      ==>> Show help as note                                     '\nqueue '| HELP   ==>> Show help                                             '\nqueue '|             Help from outside - TSO YCLMACRX                      '\nqueue '| HV     ==>> Show help as view                                     '\nqueue '| HC     ==>> Show a Short description of each command              '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| RV     ==>> Reverse the line text                                 '\nqueue '|             Block: RVV - RVV                                      '\nqueue '|             Multi: RV#                                            '\nqueue '|                                                                   '\nqueue 'RV 024 Help File - see YCLMACRX                                     '\nqueue '-> Result:                                                          '\nqueue '000024                                      XRCAMLCY ees - eliF pleH'\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| CE     ==>> Center the line text                                  '\nqueue '|             Block: CEE - CEE                                      '\nqueue '|             Multi: CE#                                            '\nqueue '|                                                                   '\nqueue 'CE 024 Help File - see YCLMACRX                                     '\nqueue '-> Result:                                                          '\nqueue '000024                   Help File - see YCLMACRX                   '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| AL     ==>> Align Left the line text                              '\nqueue '|             Block: ALL - ALL                                      '\nqueue '|             Multi: AL#                                            '\nqueue '|                                                                   '\nqueue 'AL 024                   Help File - see YCLMACRX                   '\nqueue '-> Result:                                                          '\nqueue '000024 Help File - see YCLMACRX                                     '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| AR     ==>> Align Right the line text                             '\nqueue '|             Block: ARR - ARR                                      '\nqueue '|             Multi: AR#                                            '\nqueue '|                                                                   '\nqueue 'AR 024 Help File - see YCLMACRX                                     '\nqueue '-> Result:                                                          '\nqueue '000024                                      Help File - see YCLMACRX'\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| AU     ==>> Align Up the line text as the previous line           '\nqueue '|             Block: AUU - AUU                                      '\nqueue '|             Multi: AU#                                            '\nqueue '|                                                                   '\nqueue '000107      ISupport=\"CE RV AL AR E EX V DI DL\",                    '\nqueue 'AU 108 newl=\"YVES\"                                                  '\nqueue '-> Result:                                                          '\nqueue '000107      ISupport=\"CE RV AL AR E EX V DI DL\",                    '\nqueue '000108      newl=\"YVES\"                                             '\nqueue '|                                                                   '\nqueue '|             if JCL found - alignment based on:                    '\nqueue '|             Ref Line \"JCL Comment   -> column 15                  '\nqueue '|             Ref Line \"// \"          -> first parameter statement  '\nqueue '|                     if more than 16 -> use column 15              '\nqueue '|             else     \"//D1 DD DSN=\" -> third parameter statement  '\nqueue '|                     if more than 16 -> use column 15              '\nqueue '000093 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue 'AU5 94 //   DISP=(,CATLG),                                          '\nqueue '000095 //     SPACE=(TRK,(15,15),RLSE),                             '\nqueue '000096 // STORCLAS=SMS,                                             '\nqueue '000097 //     RECFM=FB,                                             '\nqueue '000098 //    LRECL=4160                                             '\nqueue '-> Result:                                                          '\nqueue '000093 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '000094 //         DISP=(,CATLG),                                    '\nqueue '000095 //         SPACE=(TRK,(15,15),RLSE),                         '\nqueue '000096 //         STORCLAS=SMS,                                     '\nqueue '000097 //         RECFM=FB,                                         '\nqueue '000098 //         LRECL=4160                                        '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| AD     ==>> Align Down the line text as the next line             '\nqueue '|             Block: ADD - ADD                                      '\nqueue '|             Multi: AD#                                            '\nqueue '|                                                                   '\nqueue 'AD 108 newl=\"YVES\"                                                  '\nqueue '000109            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"         '\nqueue '-> Result:                                                          '\nqueue '000108            newl=\"YVES\"                                       '\nqueue '000109            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"         '\nqueue '|                                                                   '\nqueue '|             if JCL found - alignment based on:                    '\nqueue '|             Ref Line \"JCL Comment   -> column 15                  '\nqueue '|             Ref Line \"// \"          -> first parameter statement  '\nqueue '|                     if more than 16 -> use column 15              '\nqueue '|             else     \"//D1 DD DSN=\" -> third parameter statement  '\nqueue '|                     if more than 16 -> use column 15              '\nqueue '000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue 'ADD 08 //   DISP=(,CATLG),                                          '\nqueue '000109 //     SPACE=(TRK,(15,15),RLSE),                             '\nqueue '000110 // STORCLAS=SMS,                                             '\nqueue 'ADD 11 //     RECFM=FB,                                             '\nqueue '000112 //      LRECL=4160                                           '\nqueue '-> Result:                                                          '\nqueue '000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '000108 //      DISP=(,CATLG),                                       '\nqueue '000109 //      SPACE=(TRK,(15,15),RLSE),                            '\nqueue '000110 //      STORCLAS=SMS,                                        '\nqueue '000111 //      RECFM=FB,                                            '\nqueue '000112 //      LRECL=4160                                           '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| YX     ==>> Hex one line as note (native support 1.11|)           '\nqueue '|             Block: YXX - YXX                                      '\nqueue '|             Multi: YX#                                            '\nqueue '|                                                                   '\nqueue 'YX 107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '-> Result:                                                          '\nqueue '000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '====== 66EEEDCEDD4CC4CED7EECE4ECDE4EC4CEDD6444444444444444          '\nqueue '====== 11282444470440425E8552B8362B26B4447B000000000000000          '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| YD     ==>> Hex one line as note (in data form)                   '\nqueue '|             Block: YDD - YDD                                      '\nqueue '|             Multi: YD#                                            '\nqueue '|                                                                   '\nqueue 'YD 107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '-> Result:                                                          '\nqueue '000107 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '====== 6161E2E8E2D4C4E4D4D740C4C440C4E2D57EE8E5C5E24BE8C3D6E24BE2...'\nqueue '====== 4040404040404040404040404040404040404040404040404040404040...'\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| CL     ==>> Compare lines                                         '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             the lines to be compared could be marked with labels: '\nqueue '|               .EF and .EL                                         '\nqueue '|             the selected line and the next line will be compared  '\nqueue '|             differences will be shown with an infoline:           '\nqueue '|             - single character difference with a |                '\nqueue '|             - many characters with <----> or <>                   '\nqueue '|                                                                   '\nqueue 'CL 001 THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA  '\nqueue '000002 THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA  '\nqueue '-> Result:                                                          '\nqueue '000001 THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA  '\nqueue '======    |       <--->                     |     |     |     <>    '\nqueue '000002 THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA  '\nqueue '|                                                                   '\nqueue '|        ==>> Compare lines - NOT ADJACENT|                         '\nqueue '|                                                                   '\nqueue 'CL 005 lmactest                                                     '\nqueue '000006 lmactest                                                     '\nqueue '.EF 07 THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA  '\nqueue '000008 lmactest                                                     '\nqueue '000009 lmactest                                                     '\nqueue '.EL 10 THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA  '\nqueue '-> Result:                                                          '\nqueue '.EF    THIS IS MY FIRST LINE WITH SOME HEX          AND OTHER DATA  '\nqueue '======    |       <--->                     |     |     |     <>    '\nqueue '.EL    THIX IS MY OTHER LINE WITH SOME HEX          AND XTHER ADTA  '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| CM     ==>> Comment/uncomment lines                               '\nqueue '|             Block: CMM - CMM                                      '\nqueue '|             Multi: CM#                                            '\nqueue '|             if JCL: try to toggle // and //*                      '\nqueue '|                                                                   '\nqueue '000117 //SYSPRINT DD DSN=YVESCOL.AMBLIST,                           '\nqueue 'CM4 18 //            DISP=SHR                                       '\nqueue '000119 //*            DISP=(,CATLG),                                '\nqueue '000120 //*            SPACE=(TRK,(50,10),RLSE),                     '\nqueue '000121 //*            DCB=(RECFM=VBA,LRECL=137),MGMTCLAS=BAT#NJ     '\nqueue '000122 //SYSIN      DD      *                                       '\nqueue '-> Result:                                                          '\nqueue '000117 //SYSPRINT DD DSN=YVESCOL.AMBLIST,                           '\nqueue '000118 //*            DISP=SHR                                      '\nqueue '000119 //            DISP=(,CATLG),                                 '\nqueue '000120 //            SPACE=(TRK,(50,10),RLSE),                      '\nqueue '000121 //            DCB=(RECFM=VBA,LRECL=137),MGMTCLAS=BAT#NJ      '\nqueue '000122 //SYSIN      DD      *                                       '\nqueue '|                                                                   '\nqueue '|             not JCL: create a before/after comment a la rexx      '\nqueue '|                                                                   '\nqueue '000124 else do                                                      '\nqueue 'CM3 25   ISupport=\"CE RV AL AR E EX V DI DL\",                       '\nqueue '000126            newl=\"YVES\"                                       '\nqueue '000127            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"         '\nqueue '000128 end                                                          '\nqueue '-> Result:                                                          '\nqueue '000124 else do                                                      '\nqueue '000125   /* Comment Start                                           '\nqueue '000126   ISupport=\"CE RV AL AR E EX V DI DL\",                       '\nqueue '000127            newl=\"YVES\"                                       '\nqueue '000128            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"         '\nqueue '000129      Comment End */                                          '\nqueue '000130 end                                                          '\nqueue '|                                                                   '\nqueue '|                  if given on \"Comment Start\" or \"Comment End\"     '\nqueue '|                     it will delete them                           '\nqueue '000124 else do                                                      '\nqueue '000125   /* Comment Start                                           '\nqueue 'CM 126   ISupport=\"CE RV AL AR E EX V DI DL\",                       '\nqueue '000127            newl=\"YVES\"                                       '\nqueue '000128            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"         '\nqueue '000129      Comment End */                                          '\nqueue '000130 end                                                          '\nqueue '-> Result:                                                          '\nqueue '000025   ISupport=\"CE RV AL AR E EX V DI DL\",                       '\nqueue '000126            newl=\"YVES\"                                       '\nqueue '000127            \"DS DM DX AU AD CM YX LD HELP H AE EA CL\"         '\nqueue '             +---------------------------------------+              '\nqueue '             ] Comments on lines 125 and 129 deleted ]              '\nqueue '             +---------------------------------------+              '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| LN     ==>> Display the number of characters of variable length   '\nqueue '|             Block: LNN - LNN                                      '\nqueue '|             Multi: LN#                                            '\nqueue '|             datasets - could be important for USS|                '\nqueue '|             L= line size/length                                   '\nqueue '|                                                                   '\nqueue 'LN2 01 information of line 1                                        '\nqueue '000002 even more information on line 2                              '\nqueue '000003 nothing...                                                   '\nqueue '-> Result:                                                          '\nqueue '====== L=00021 -1----+----2-                                        '\nqueue '000001 information of line 1                                        '\nqueue '====== L=00031 -1----+----2----+----3-                              '\nqueue '000002 even more information on line 2                              '\nqueue '000003 nothing...                                                   '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| TOPD   ==>> Delete all lines from here to the top                 '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             will inform about number of lines                     '\nqueue '|                                                                   '\nqueue '000104 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR                        '\nqueue '000105 //SYSEXEC  DD DSN=YVES.CLIST,DISP=SHR                        '\nqueue '000106 //SYSTSPRT DD SYSOUT=*                                       '\nqueue 'TOPD 7 //SYSOUT   DD SYSOUT=*                                       '\nqueue '000108 //SYSPRINT DD SYSOUT=*                                       '\nqueue '000109 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '000110 //   DISP=(,CATLG),                                          '\nqueue '000111 //     SPACE=(TRK,(15,15),RLSE),                             '\nqueue '000112 // STORCLAS=SMS,                                             '\nqueue '-> Result:                                                          '\nqueue '000001 //SYSPRINT DD SYSOUT=*                                       '\nqueue '000002 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '000003 //   DISP=(,CATLG),                                          '\nqueue '000004 //     SPACE=(TRK,(15,15),RLSE),                             '\nqueue '000005 // STORCLAS=SMS,                                             '\nqueue '               +-------------------+                                '\nqueue '               ] 107 lines deleted ]                                '\nqueue '               +-------------------+                                '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| BOTD   ==>> Delete all lines from here to the bottom              '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             will inform about number of lines                     '\nqueue '|             D9999 could also be used, but sometime not so \"good\"  '\nqueue '|                                                                   '\nqueue '000087 //*----------------------------*                             '\nqueue '000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M                      '\nqueue 'BOTD 9 //STEPLIB  DD DISP=SHR,DSN=YVES.YCDIAG.LINKLIB               '\nqueue '000090 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR                        '\nqueue '-> Result:                                                          '\nqueue '000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M                      '\nqueue '               +------------------+                                 '\nqueue '               ] 86 lines deleted ]                                 '\nqueue '               +------------------+                                 '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| TOPX   ==>> eXclude all lines from here to the top                '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             will inform about number of lines                     '\nqueue '|                                                                   '\nqueue '000104 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR                        '\nqueue '000105 //SYSEXEC  DD DSN=YVES.CLIST,DISP=SHR                        '\nqueue '000106 //SYSTSPRT DD SYSOUT=*                                       '\nqueue 'TOPX 7 //SYSOUT   DD SYSOUT=*                                       '\nqueue '000108 //SYSPRINT DD SYSOUT=*                                       '\nqueue '000109 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '000110 //   DISP=(,CATLG),                                          '\nqueue '000111 //     SPACE=(TRK,(15,15),RLSE),                             '\nqueue '000112 // STORCLAS=SMS,                                             '\nqueue '-> Result:                                                          '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -  93 Line(s) not Displayed '\nqueue '000094 //SYSPRINT DD SYSOUT=*                                       '\nqueue '000095 //SYSMDUMP DD DSN=YVES.YCOS.SF.DUMP,                         '\nqueue '000096 //   DISP=(,CATLG),                                          '\nqueue '000097 //     SPACE=(TRK,(15,15),RLSE),                             '\nqueue '000098 // STORCLAS=SMS,                                             '\nqueue '               +-------------------+                                '\nqueue '               ] 93 lines excluded ]                                '\nqueue '               +-------------------+                                '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| BOTX   ==>> eXclude all lines from here to the bottom             '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             will inform about number of lines                     '\nqueue '|             X9999 could also be used, but sometime not so \"good\"  '\nqueue '|                                                                   '\nqueue '000087 //*----------------------------*                             '\nqueue '000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M                      '\nqueue 'BOTX 9 //STEPLIB  DD DISP=SHR,DSN=YVES.YCDIAG.LINKLIB               '\nqueue '000090 //SYSPROC  DD DSN=YVES.CLIST,DISP=SHR                        '\nqueue '-> Result:                                                          '\nqueue '000088 //PRINT     EXEC PGM=IKJEFT01,REGION=0M                      '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -  86 Line(s) not Displayed '\nqueue '               +------------------+                                 '\nqueue '               ] 86 lines deleted ]                                 '\nqueue '               +------------------+                                 '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| FI     ==>> FindFirst where the cursor is placed - or first word  '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue 'FI 176 we search sdsf                                               '\nqueue '|                 |                                                 '\nqueue '|                 +-- cursor pointing on SDSF                       '\nqueue '-> Result:                                                          '\nqueue '000130 * time                                                       '\nqueue '000131 sdsf d t                                                     '\nqueue '|      |                                                            '\nqueue '|      +-- sdsf on line 131 found                                   '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| FL     ==>> FindLast  where the cursor is placed - or first word  '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue 'FL 131 we search sdsf                                               '\nqueue '                  |                                                 '\nqueue '                  +-- cursor pointing on SDSF                       '\nqueue '-> Result:                                                          '\nqueue '000780 * time                                                       '\nqueue '00 781 sdsf d t                                                     '\nqueue '       |                                                            '\nqueue '       +-- sdsf on line 781 found                                   '\nqueue '|                                                                   '\nqueue '| =========== Text Commands ======================================= '\nqueue '| FA     ==>> FindAll   where the cursor is placed - or first word  '\nqueue '|                       other lines will be excluded                '\nqueue '|             Multi: FA#                                            '\nqueue '|                       will also show # lines before and after     '\nqueue '|                                                                   '\nqueue '000130 * time                                                       '\nqueue '000131 sdsf d t                                                     '\nqueue '000132                                                              '\nqueue '000133 * work with exits                                            '\nqueue 'FA 134 sdsf SETPROG EXIT,ADD,  +                                    '\nqueue '        |                                                           '\nqueue '        +-- cursor pointing on SDSF                                 '\nqueue '-> Result:                                                          '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -  130 Line(s) not Displayed'\nqueue '000131 sdsf d t                                                     '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -  - 2 Line(s) not Displayed'\nqueue '000134 sdsf SETPROG EXIT,ADD,  +                                    '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -   41 Line(s) not Displayed'\nqueue '000176 we search sdsf                                               '\nqueue '|                                                                   '\nqueue '|             Multi: FA#                                            '\nqueue '000130 * time                                                       '\nqueue '000131 sdsf d t                                                     '\nqueue '000132                                                              '\nqueue '000133 * work with exits                                            '\nqueue 'FA2 34 sdsf SETPROG EXIT,ADD,  +                                    '\nqueue '        |                                                           '\nqueue '        +-- cursor pointing on SDSF                                 '\nqueue '-> Result:                                                          '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -  128 Line(s) not Displayed'\nqueue '000129                                                              '\nqueue '000130 * time                                                       '\nqueue '000131 sdsf d t                                                     '\nqueue '000132 next line1                                                   '\nqueue '000133 next line2                                                   '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -  - 2 Line(s) not Displayed'\nqueue '000136 previous line2                                               '\nqueue '000137 * work with exits                                            '\nqueue '000138 sdsf SETPROG EXIT,ADD,  +                                    '\nqueue '000139           EX=SYS.IEFUSI,    +                                '\nqueue '000140      MOD=YCDUSI,    +                                        '\nqueue '- - -  -  -  -  -  -  -  -  -  -  -  -  -   37 Line(s) not Displayed'\nqueue '000178        *C*                                                   '\nqueue '000179                                                              '\nqueue '000180 we search sdsf                                               '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '|             Analyse the line to find a dataset                    '\nqueue '|             Make a difference if JCL or not                       '\nqueue '|             JCL search DSN= and JCLLIB ORDER= and PATH=           '\nqueue '|             For JCL which is not DSN or JCLLIB (e.g. PROC)        '\nqueue '|             support dataset in parameter=dataset                  '\nqueue '|             If not JCL search a nn.nn.nn                          '\nqueue '|             If more than one nn.nn.nn in line process first       '\nqueue '|             or nn.nn.nn pointed to by cursor position.            '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| E      ==>> Edit the dataset                                      '\nqueue '| EZ     ==>> Edit the dataset in new Split Screen                  '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| V      ==>> View the dataset                                      '\nqueue '| VZ     ==>> View the dataset in new Split Screen                  '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DA     ==>> Dataset allocation like - JCL and TSO Allocate        '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DI     ==>> DSINFO the dataset                                    '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DL     ==>> LISTCAT the dataset                                   '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DS     ==>> DSLIST the dataset 3.4                                '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DX     ==>> DSLIST first n Qualifiers 3.4                         '\nqueue '|             Multi: DX#                                            '\nqueue '|             Default (not like DZ) will show first qualifier       '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DZ     ==>> DSLIST first n Qualifiers 3.4 in new Split Screen     '\nqueue '|             Multi: DZ#                                            '\nqueue '|             Default (not like DX) will show all qualifiers        '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DM     ==>> MemberList 3.1                                        '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| LD     ==>> Execute the RACF LISTDSD/LD Command                   '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| DH     ==>> HSM List command - Display HSM Migrate/Backup         '\nqueue '|             data and give the possibility to                      '\nqueue '|             HRECALL or HRESTORE                                   '\nqueue '|             the selected data - using the EX Line Command         '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '| =========== Edit Command     ==================================== '\nqueue '| RU     ==>> Call RU to create a ruler as a note starting at the   '\nqueue '|             current cursor position                               '\nqueue '| Example:      X <== Cursor is here when RULER starts              '\nqueue '|               ----+----1----+----2----+----3----+----4----+---... '\nqueue '| RU# (any number from 1-...) will give the number                  '\nqueue '|               ----+---10----+---20----+----30-...--150----+---... '\nqueue '|             Author: Norbert Haas                                  '\nqueue '|                                                                   '\nqueue '+------------------------------------------------------------------+'\nqueue '| =========== TSO Commands ======================================== '\nqueue '| EX     ==>> Execute the cmd line - as a tso cmd                   '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             Output will be displayed using ISPF VIEW              '\nqueue '|             TSO is default and has not to be given|               '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        execute the command under TSO               |  '\nqueue '|           |                                                    |  '\nqueue '|        -> | EX0002 lista st h                                  |  '\nqueue \"|           | 000003 listc ent('a.very.imp.ds') all              |  \"\nqueue \"|           | 000004 listc ent('a.very.imp.ds') all              |  \"\nqueue '|           | 000005 tso listc,                                  |  '\nqueue \"|           | 000006     ent('a.very.imp.ds')+                   |  \"\nqueue '|           | 000007     all                                     |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACTSO                                    '\nqueue '|                                                                   '\nqueue '| =========== SDSF Commands ======================================= '\nqueue '| EX     ==>> Execute the cmd line - as a SDSF command like /...    '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             Output will be displayed using ISPF EDIT              '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        execute the command under SDSF              |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000001 sdsf  d a                                   |  '\nqueue '|           | 000002 sdsf  d xcf,str                             |  '\nqueue '|        -> | EX0003 sdsf  d prog,     +                         |  '\nqueue '|           | 000004        lpa, +                               |  '\nqueue '|           | 000005         mod=iefbr14                         |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACMVS                                    '\nqueue '|             see member LMACJES2                                   '\nqueue '|             see member LMACJES3                                   '\nqueue '|                                                                   '\nqueue '| =========== Other Commands ====================================== '\nqueue '| EX     ==>> Execute the cmd line - as an EJES command like /...   '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             Output will be displayed using ISPF EDIT              '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        execute the command under EJES (c)          |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000001 ejes  d a                                   |  '\nqueue '|           | 000002 ejes  d xcf,str                             |  '\nqueue '|        -> | EX0003 ejes  d prog,     +                         |  '\nqueue '|           | 000004        lpa, +                               |  '\nqueue '|           | 000005         mod=iefbr14                         |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|                                                                   '\nqueue '| =========== Unix Commands ======================================= '\nqueue '| EX     ==>> Execute the cmd line - as a UNIX command like Shell   '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             the command can also be run as a Superuser - if       '\nqueue '|                 authority is given - using the UNIXSU prefix      '\nqueue '|             Output will be displayed using ISPF EDIT              '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|                 ||| but here not a directory |||                  '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        execute the command under Unix USS          |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000018 unix ls                                     |  '\nqueue '|           | 000019 unixsu  ls                                  |  '\nqueue '|        -> | EX0020 unixsu mkdir -m 755 /u/AUTH                 |  '\nqueue '|           | 000021 unix mkdir -m 755 /u/NOTAUTH                |  '\nqueue '|           | 000022 unix ls -l /u/PFA                           |  '\nqueue '|           | 000023 unix ls -l +                                |  '\nqueue '|           | 000024         /u                                  |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACUSS                                    '\nqueue '|                                                                   '\nqueue '|             Since version 2.11 you can use the                    '\nqueue '|             unixenv and unixsuenv                                 '\nqueue '|             to run the command using the same environment         '\nqueue '|             variables like you would have starting the command    '\nqueue '|             under the OMVS Shell                                  '\nqueue '|             - this will cost some more overhead|                  '\nqueue '|             - the used environment variables will be listed at    '\nqueue '|               the end of the display                              '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        execute the command under Unix USS          |  '\nqueue '|           |        using the environment variables             |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000018 unixenv javac mypgm.java                    |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|                                                                   '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        execute the command under Unix USS          |  '\nqueue '|           |        using the environment variables             |  '\nqueue '|           |        and setting own environment variables       |  '\nqueue '|           | Syntax:                                            |  '\nqueue '|           |   first line only: unixenv +                       |  '\nqueue '|           |   second line eyecatcher: env_variable_start       |  '\nqueue '|           |   many lines with environment variables            |  '\nqueue '|           |   eyecatcher: env_variable_end                     |  '\nqueue '|           |   command line (with continuation if needed)       |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000167 unixenv +                                   |  '\nqueue '|           | 000168 env_variable_start                          |  '\nqueue '|           | 000169 PATH=/usr/lpp/dfsms/bin                     |  '\nqueue '|           | 000170 env_variable_end                            |  '\nqueue '|           | 000171   confighfs +                               |  '\nqueue '|           | 000172   -l                                        |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|                                                                   '\nqueue '| =========== Unix File/Directory List commands =================== '\nqueue '| EX     ==>> Execute the cmd line - as a UDLIST 3.17 command       '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        display the path using UDLIST - 3.17        |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000039 udlist /u                                   |  '\nqueue '|           | 000040 udlist /u/zfs/YVES                          |  '\nqueue '|        -> | EX0041 udlist /u/zfs      +                        |  '\nqueue '|           | 000042              /YVES +                        |  '\nqueue '|           | 000043        /DIR                                 |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACUSS                                    '\nqueue '|                                                                   '\nqueue '| =========== Unix Directory Find Commands ======================== '\nqueue '| EX     ==>> Execute the cmd line - as a Unix FIND for a           '\nqueue '|             directory and show all results with UDLIST 3.17       '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|                 ||| but here not the directory |||                '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        find and display all directories within     |  '\nqueue '|           |        first parm is path                          |  '\nqueue '|           |        second parm is directory name (also generic)|  '\nqueue '|           |                                                    |  '\nqueue '|           | 000047 ufdir  /u o*                                |  '\nqueue '|        -> | EX0048 ufdir  /u/zfs/YVES *u*                      |  '\nqueue '|           | 000049 * the directory name CANNOT be continued||| |  '\nqueue '|           | 000050 ufdir  /u/zfs/YVES +                        |  '\nqueue '|           | 000051        *I*                                  |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACUSS                                    '\nqueue '|                                                                   '\nqueue '| =========== Unix File Find Commands ============================= '\nqueue '| EX     ==>> Execute the cmd line - as a Unix FIND for a           '\nqueue '|             file name and show all results with UDLIST 3.17       '\nqueue '|             the lines can be continued with a + or a ,            '\nqueue '|                 ||| but here not the directory |||                '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|             for example with following lines                      '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           |        find and display all files within given     |  '\nqueue '|           |        name within a given directoy tree           |  '\nqueue '|           |        first parm is path                          |  '\nqueue '|           |        second parm is file name (also generic)     |  '\nqueue '|           |                                                    |  '\nqueue '|           | 000062 uffil  /u/zfs/YVES +                        |  '\nqueue '|           | 000063        *y*                                  |  '\nqueue '|           | 000064 uffil  /u/zfs/YVES +                        |  '\nqueue '|           | 000065        *                                    |  '\nqueue '|           | 000066 * the directory name CANNOT be continued||| |  '\nqueue '|        -> | EX0067 uffil  /u          +                        |  '\nqueue '|           | 000068        *C*                                  |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACUSS                                    '\nqueue '|                                                                   '\nqueue '| =========== SA Commands ========================================= '\nqueue '| EX     ==>> Call IBM System Automation commands (need cust of SA) '\nqueue '|           +----------------------------------------------------+  '\nqueue '|        -> | EX0062 ing inglist                                 |  '\nqueue '|           | 000063 ing inglist ycplex                          |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACING                                    '\nqueue '|                                                                   '\nqueue '| =========== ISPF Commands ======================================= '\nqueue '| EX     ==>> Execute ISPF functions                                '\nqueue '|           +----------------------------------------------------+  '\nqueue '|           | 000062 * ispf diagnosis                            |  '\nqueue '|        -> | EX0063 ispf select cmd(ispvcall)                   |  '\nqueue '|           +----------------------------------------------------+  '\nqueue '|             see member LMACISPF                                   '\nqueue '|                                                                   '\nqueue '| =========== Other Commands ====================================== '\nqueue '| EX     ==>> External call of the EX function:                     '\nqueue '|             TSO YCLMACRX tso lista st h                           '\nqueue '|             TSO YCLMACRX sdsf d a,l                               '\nqueue '|             TSO YCLMACRX ejes d a,l                               '\nqueue '|             TSO YCLMACRX unix ps -le                              '\nqueue '|             TSO YCLMACRX unixsu ps -le                            '\nqueue '|             TSO YCLMACRX udlist /u/zfs/YVES                       '\nqueue '|             TSO YCLMACRX ufdir  /u o*                             '\nqueue '|             TSO YCLMACRX uffil  /u/zfs/YVES *y*                   '\nqueue '|                                                                   '\nqueue '| =========== Other Commands ====================================== '\nqueue '| AE     ==>> Ascii -> Ebcdic - simple table                        '\nqueue '|             Block: AEE - AEE                                      '\nqueue '|             Multi: AE#                                            '\nqueue '| EA     ==>> Ebcdic -> Ascii - simple table                        '\nqueue '|             Block: EAA - EAA                                      '\nqueue '|             Multi: EA#                                            '\nqueue '|                                                                   '\nqueue '| =========== Other Commands ====================================== '\nqueue '| JU     ==>> JCL Upper Case                                        '\nqueue '|             Block: JUU - JUU                                      '\nqueue '|             Multi: JU#                                            '\nqueue '|             Work \"like\" UC but it will not Uppercase              '\nqueue '|             - jcl comment lines                                   '\nqueue '|             - sysin (not JCL)                                     '\nqueue '|             - all quoted data, like PATH=, PARM=...               '\nqueue '|                                                                   '\nqueue '| =========== General Information ================================= '\nqueue '| H HELP E V EZ VZ DH DI DL DM DS EX CL LD REV FI FL FA             '\nqueue '| are single line commands                                          '\nqueue '|                                                                   '\nqueue '| All othes can be given in the forms                               '\nqueue '|     CE5                                                           '\nqueue '|   or                                                              '\nqueue '|     CEE                                                           '\nqueue '|      ...                                                          '\nqueue '|     CEE                                                           '\nqueue '|                                                                   '\nqueue '| =========== Usage Hint ========================================== '\nqueue '| Line Commands could also be defined on PFKs using :xx notation    '\nqueue '| Possible good candidates like :E or :V or :DS and others          '\nqueue '|                                                                   '\nqueue '+------------------------------------------------------------------+'\nqueue '| Vers 2.20  02.03.2018 Yves Colliard                              |'\nqueue '|            - Extention of YCLMACRX to execute                    |'\nqueue '|              the RU command - RULER                              |'\nqueue '| Based on - many thanks to Norbert Haas                           |'\nqueue '| Name:        RULER                                               |'\nqueue '| Type:        Macro                                               |'\nqueue '| Author:      Norbert Haas                                        |'\nqueue '|              Y$RU member needed                                  |'\nqueue '+------------------------------------------------------------------+'\n\ncall yclmahlu                                          /* 2.17 */\n\nparse source . calltype .\nif calltype=\"SUBROUTINE\" then exit\n\n/* direct call */\nAddress  ISPEXEC \"CONTROL ERRORS RETURN\"     /* Return ispf errors  */\n\nAddress ISPEXEC \"VGET (ZOS390RL)\"                      /* 2.10 */\n                   /* \"z/OS   01.13.00\"   */           /* 2.10 */\ned_parms=\"\"                                            /* 2.10 */\nif ZOS390RL = \"z/OS   01.13.00\" |,                     /* 2.10 */\n   left(ZOS390RL,10)=\"z/OS   02.\" then do              /* 2.10 */\n  Address ISPEXEC \"VGET (ZLMAC)\"                       /* 2.10 */\n  if ZLMAC <> \"\" then do                               /* 2.10 */\n    ed_parms=\" LINECMDS(\"strip(ZLMAC)\")\"               /* 2.10 */\n  end                                                  /* 2.10 */\nend                                                    /* 2.10 */\ndo cnt1=1 to befq\n         parse pull bm.cnt1\nend\ndo cnt=1 to queued()\n         parse pull msg\n         m.cnt=Msg\nend\ndo cnt1=1 to befq\n         queue bm.cnt1\nend\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(80)\",\n\"recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg1.0\n    say ymsg1.i\n  end\n  do i=1 to cnt-1\n    say m.i\n  end\n  exit 0\nend\n/* write the data */\naddress mvs \"execio \"cnt-1\" diskw \"ydd1\" (stem m. finis\"\n/* show the result */\naddress ispexec \"lminit dataid(myou) ddname(\"ydd1\")\"\naddress ispexec \"edit dataid(\"myou\")\"ed_parms          /* 2.10 */\naddress ispexec \"lmfree dataid(\"myou\")\"\nmsgset=msg('OFF')\naddress tso \"free fi(\"ydd1\")\"\nmsgset=msg(msgset)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YCLMAHLU": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00B\\x01\\x18\\t\\x9f\\x01\\x19$/\\x06R\\x00)\\x00*\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2018-04-09T00:00:00", "modifydate": "2019-08-30T06:52:42", "lines": 41, "newlines": 42, "modlines": 0, "user": "SLBD"}, "text": "/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */\n/*                                                                    */\n/*+------------------------------------------------------------------+*/\n/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/\n/*|                   2004-18                                        |*/\n/*|                   Mail yves.colliard\u00a7ycos.de                     |*/\n/*|                   Use at your own RISK|                          |*/\n/*+------------------------------------------------------------------+*/\n/*| Help File - User Extentions                                      |*/\n/*+------------------------------------------------------------------+*/\n\nbefq=queued()\nqueue '+------------------------------------------------------------------+'\nqueue '| User Line Commands                                               |'\nqueue '+------------------------------------------------------------------+'\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| REV    ==>> Call REVIEW to work with dataset                      '\nqueue '|             Works also for VSAM dataset (only VIEW)               '\nqueue '|             http://www.prycroft6.com.au/REVIEW/index.html         '\nqueue '|             NO-Block and NO-Multi                                 '\nqueue '|                                                                   '\nqueue '+------------------------------------------------------------------+'\nqueue '+------------------------------------------------------------------+'\nqueue '| User Line Commands                                               |'\nqueue '+------------------------------------------------------------------+'\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| PDS    ==>> Call PDS to work with PDS                             '\nqueue '|             Have to Install PDS                                   '\nqueue '|             http://cbttape.org   (File 182)                       '\nqueue '|                                                                   '\nqueue '+------------------------------------------------------------------+'\nqueue '+------------------------------------------------------------------+'\nqueue '| User Line Commands                                               |'\nqueue '+------------------------------------------------------------------+'\nqueue '| =========== Dataset Commands ==================================== '\nqueue '| PG     ==>> Call PG to work with PDSE 2 Generation                '\nqueue '|             Have to Install PDSEGEN                               '\nqueue '|             http://www.lbdsoftware.com/                           '\nqueue '|             http://cbttape.org    (File 969)                      '\nqueue '|                                                                   '\nqueue '+------------------------------------------------------------------+'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "YLM01": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0e\\x00\\x00\\x01\\x14 ?\\x01\\x14 ?\\x14\\x14\\x00t\\x00t\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.14", "flags": 0, "createdate": "2014-07-22T00:00:00", "modifydate": "2014-07-22T14:14:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "YCLMAC"}, "text": "/***  REXX  **********************************************************/\n/*  Funktion:  Simple sample to edit a dataset and activate          */\n/*             other edit line commands                              */\n/*             here a line command YVES will be added                */\n/*  Copyright 2014-14 YCOS Yves Colliard Software GmbH V1.0          */\n/*********************************************************************/\n/* */\nAddress  ISPEXEC\n\"CONTROL ERRORS RETURN\"     /* Return ispf errors  */\n\n\"VGET (ZOS390RL)\"\n\nYCLINECMDS=\"\"\ned_parms=\"\"\n                   /* \"z/OS   01.13.00\"   */\nif ZOS390RL = \"z/OS   01.13.00\" |,\n   left(ZOS390RL,10)=\"z/OS   02.\" then do\n  \"VGET (ZLMAC)\"\n  if ZLMAC <> \"\" then do\n    YCLINECMDS=ZLMAC\n  end\nend\n\n/* */\nif YCLINECMDS<>\"\" & YCLINECMDS<>\"YCLINECMDS\" then do\n  'TBOPEN    'YCLINECMDS\n  'TBTOP     'YCLINECMDS\n  'TBSKIP    'YCLINECMDS\n  do l1=1 until rc>0\n    LCNAME.l1=ZELCNAME\n    LCSLNM.l1=ZELCSLNM\n    LCPGMF.l1=ZELCPGMF\n    LCBLKA.l1=ZELCBLKA\n    LCMLTA.l1=ZELCMLTA\n    LCDSTA.l1=ZELCDSTA\n    'TBSKIP    'YCLINECMDS\n  end\n  'TBCLOSE   'YCLINECMDS\nend\n/* */\n'TBERASE   YCTMPLCM'\nselect\nwhen rc=0 then do\n  nop\nend\nwhen rc=8 then do\n  nop\nend\notherwise\n  say 'Table Erase error - rc' rc 'YCTMPLCM'\n  say 'Contact YCOS Support'\n  exit\nend\n'TBCREATE YCTMPLCM NAMES(ZELCNAME, ZELCSLNM, ZELCPGMF,',\n          'ZELCBLKA, ZELCMLTA, ZELCDSTA)'\n/* */\nif YCLINECMDS<>\"\" & YCLINECMDS<>\"YCLINECMDS\" then do\n  do l2=1 to l1\n    ZELCNAME=LCNAME.l2\n    ZELCSLNM=LCSLNM.l2\n    ZELCPGMF=LCPGMF.l2\n    ZELCBLKA=LCBLKA.l2\n    ZELCMLTA=LCMLTA.l2\n    ZELCDSTA=LCDSTA.l2\n    'TBADD YCTMPLCM'\n  end\nend\n\n/*----- single line commands          ----------------------------*/\n/* Macro   name of the Rexx or program to get control             */\nZELCSLNM=\"YLM02\"       /* line cmd YVES */\n/* Program Macro   N=Rexx (or Clist) Y=program                    */\nZELCPGMF=\"N\"\n/* Block Format   Y=block commands are supported (like: rr   rr)  */\nZELCBLKA=\"N\"\n/* Multi Line   Y=many lines as target (like: r9)                 */\nZELCMLTA=\"Y\"\n/* Dest Used   Y=a destination line is needed (like: c -> a)      */\nZELCDSTA=\"N\"\n\n/* User Command   name of the line command (1-6 chars)            */\nZELCNAME=left(\"YVES\",6)\n'TBADD YCTMPLCM'\n\n/* */\n'TBCLOSE YCTMPLCM'\n/* */\n\ned_parms=\" LINECMDS(YCTMPLCM)\"\n\n/* alloc output datasets */\ncall bpxwdyn \"alloc space(15,15) tracks new delete lrecl(132)\",\n   \"recfm(f,b) dsorg(ps) msg(ymsg2.) rtddn(ydd2) rtdsn(ydsn2)\"\nif result<>0 then do\n  say \"Alloc temp dataset error:\" result\n  do i=1 to ymsg2.0\n    say ymsg2.i\n  end\n  exit 0\nend\not.1=\"Try to use YVES or line YVES# as a line command\"\not.2=\"Try to use YVES or line YVES# as a line command\"\not.3=\"Try to use YVES or line YVES# as a line command\"\not.4=\"Try to use YVES or line YVES# as a line command\"\not.5=\"Try to use YVES or line YVES# as a line command\"\n/* write the data */\naddress mvs \"execio 5 diskw \"ydd2\" (stem ot. finis\"\n/* */\nzedsmsg=\"\"\nzedlmsg=\"Edit line commands activated\"\n\"SETMSG MSG(ISRZ001)\"\n/* show the result */\n\"lminit dataid(myou) ddname(\"ydd2\")\"\n\"edit dataid(\"myou\")\"ed_parms\n\"lmfree dataid(\"myou\")\"\naddress tso \"free fi(\"ydd2\")\"\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "YLM02": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0e\\x00\\x00\\x01\\x14 ?\\x01\\x14 ?\\x14\\x14\\x00\\x19\\x00\\x19\\x00\\x00\\xe8\\xc3\\xd3\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "02.14", "flags": 0, "createdate": "2014-07-22T00:00:00", "modifydate": "2014-07-22T14:14:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "YCLMAC"}, "text": "/***  REXX  **********************************************************/\n/*  Funktion:  Line Macro sample                                     */\n/*  Copyright 2014-14 YCOS Yves Colliard Software GmbH V1.0          */\n/*********************************************************************/\n/* */\nAddress  ISPEXEC \"CONTROL ERRORS RETURN\"     /* Return ispf errors  */\nAddress  ISREDIT                             /* Start of macro      */\n\"MACRO   (PARM) NOPROCESS\"                   /* Get line command    */\n\"(CURLINE CURCOL) = CURSOR\"\n/* */\nstart = curline\nparse var parm \"YVES\" cnt\nif datatype(cnt)<>\"NUM\" then do\n  cnt=\"with no other parameter given\"\nend\nelse do\n  cnt=\"with counter:\" cnt \"given\"\nend\n/* */\nZedSMsg = \"\"\nZedLMsg = \"On line\" start \"command YVES\" cnt\nAddress ISPEXEC 'SETMSG MSG(ISRZ001)'\n\"Cursor = \"curline curcol\n/* */\nexit 0\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT961/FILE961.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT961", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}