/* Rexx by YCOS Yves Colliard Software - www.ycos.de                  */
/*                                                                    */
/*+------------------------------------------------------------------+*/
/*| YCLMACRX     (c)  YCOS Yves Colliard Software                    |*/
/*|                   2004-18                                        |*/
/*|                   Mail yves.colliardÂ§ycos.de                     |*/
/*|                   Use at your own RISK|                          |*/
/*+------------------------------------------------------------------+*/
/*|                                                                  |*/
/*| This Rexx uses the Doug Nadel marvellous program|                |*/
/*| This LMAC program as to run, be customized and an initial        |*/
/*| macro as to be set                                               |*/
/*| download LMAC from IBM:                                          |*/
/*| http://www-01.ibm.com/support/docview.wss?uid=swg24014047        |*/
/*|                                                                  |*/
/*| Integrated by IBM within z/OS 1.13|                              |*/
/*|                                                                  |*/
/*| Fully usable starting with z/OS 2.2|                             |*/
/*|                                                                  |*/
/*| Installation see $$$DOC                                          |*/
/*|                                                                  |*/
/*+------------------------------------------------------------------+*/
/*|                                                                  |*/
/*| Functions of YCLMACRX:                                           |*/
/*| H      ==>> Show help                                            |*/
/*| HELP   ==>> Show help                                            |*/
/*|             Help from outside - TSO YCLMACRX                     |*/
/*|                                                                  |*/
/*| see YCLMACHLP                                                    |*/
/*+------------------------------------------------------------------+*/
/*| Vers 2.21  22.05.2018 Yves Colliard                              |*/
/*|            Change of DSN chars based on a good idea from         |*/
/*|              Stefan Mitterer| Thanks                             |*/
/*|              See YCLMACDS                                        |*/
/*|            Change of ING cust                                    |*/
/*|              Karlheinz Wittemann| Thanks                         |*/
/*|            Correct JU for continuation and support 2.2/2.3 Stmts |*/
/*|                                                                  |*/
/*+------------------------------------------------------------------+*/

if SYSVAR("SYSENV")="BACK" then do  /* 2.14 */
  rc_ext=12       /* 2.14 */
end               /* 2.14 */
else do           /* 2.14 */
  Address  ISPEXEC "CONTROL ERRORS RETURN"     /* Return ispf errors  */

  Address ISPEXEC "VGET (ZOS390RL)"                      /* 2.10 */
                     /* "z/OS   01.13.00"   */           /* 2.10 */
  ed_parms=""                                            /* 2.10 */
  if ZOS390RL = "z/OS   01.13.00" |,                     /* 2.10 */
     left(ZOS390RL,10)="z/OS   02." then do              /* 2.10 */
    Address ISPEXEC "VGET (ZLMAC)"                       /* 2.10 */
    if ZLMAC <> "" then do                               /* 2.10 */
      ed_parms=" LINECMDS("strip(ZLMAC)")"               /* 2.10 */
    end                                                  /* 2.10 */
  end                                                    /* 2.10 */

  Address  ISREDIT                             /* Start of macro      */
  "MACRO   (PARM) NOPROCESS"                   /* Get line command    */
  rc_ext=rc       /* 2.14 */
end               /* 2.14 */
if  rc_ext > 0 then do  /* 2.14 */
                                                             /* 2.9 */
  parse arg func line
  func=translate(func)
  select
  when func = "TSO" then signal ext_tso_ex
  when func = "SDSF" then do
    world_cmd="SDSF"
    signal ext_sdsf_ex
  end
  when func = "EJES" then do
    world_cmd="EJES"
    signal ext_sdsf_ex
  end
  when func = "UNIX" then do
    usrsu=""
    usren=""                                              /* 2.11 */
    signal ext_unix_ex
  end
  when func = "UNIXSU" then do
    usrsu="SU"
    usren=""                                              /* 2.11 */
    signal ext_unix_ex
  end
  when func = "UNIXENV" then do                           /* 2.11 */
    usrsu=""                                              /* 2.11 */
    usren="ENV"                                           /* 2.11 */
    signal ext_unix_ex                                    /* 2.11 */
  end                                                     /* 2.11 */
  when func = "UNIXSUENV" then do                         /* 2.11 */
    usrsu="SU"                                            /* 2.11 */
    usren="ENV"                                           /* 2.11 */
    signal ext_unix_ex                                    /* 2.11 */
  end                                                     /* 2.11 */
  when func = "ING" then do                               /* 2.19 */
    signal ext_ING_EX                                     /* 2.19 */
  end                                                     /* 2.19 */
  when func = "UDLIST" then signal ext_udlist_ex
  when func = "UFDIR" then signal ext_ufdir_ex
  when func = "UFFIL" then signal ext_uffil_ex
  otherwise
    Call Help "OUTSIDE"                                        /* 2.9 */
  end
end

ISupport="CE RV AL AR E EX V DI DL",
         "DS DM DX AU AD CM YX LD H HELP AE EA JU DH DA LN YD",    /* 2.17 */
         "TOPD BOTD TOPX BOTX FI FL FA EZ VZ DZ HV"                /* 2.16 */
                                               /* Define the all the  */
                                               /* Line-Commands       */
CSupport = "CE RV AL AR AU AD CM AE EA JU"
                                               /* Define the all the  */
                                               /* Line-Commands which */
                                               /* change the lines    */

/* change Eberle 120418 */
Lcmd = translate(Parm,,xrange("0","9"))
Lcmd = strip(Lcmd,"B")

Lcmdnum = translate(Parm,,xrange("A","Z"))

Lcmdnum =strip(Lcmdnum,"B")

Cmd_length = length(Lcmd)

if      Cmd_length > 1 then do                 /* commands            */
        if substr(Lcmd,Cmd_length-1,1) = substr(Lcmd,cmd_length,1)
           then do
               lcmd = substr(Lcmd,1,Cmd_length-1)
        end
end
/* change Eberle 120418 */

/* change Parm --> Lcmd Eberle 120418 */

if      WordPos(Lcmd,ISupport) = 0 then do     /* No "internal" LMAC */
        Lcmd_Exec = "Y$"||Lcmd                 /* try calling an     */
        Ret_Cde = check_ext_macro("SYSEXEC" lcmd_Exec) /* external   */
        if Ret_Cde <> 0 then                           /* macro named*/
        Ret_Cde = check_ext_macro("SYSPROC" lcmd_Exec) /* Y$cmd      */
        if Ret_Cde = 0 then do
           "ISREDIT" Lcmd_Exec Parm            /* named Y$cmd        */
           exit                              /* "external" LMAC done */
        end
        else do                                /* if external exec   */
                                               /* not found:         */
           ZInfo = Parm                        /* Set up for message  */
           Address ISPEXEC "SETMSG MSG(ISRE041)" /* Invalid command   */
           Exit 8                              /* let ISPF handle     */
        END                                    /*   THE ERROR         */
end

"PROCESS RANGE" Lcmd                           /* Get range for cmd   */

if       RC > 0 then do                        /* if something went   */
                                               /*   wrong             */
         Address ISPEXEC "SETMSG MSG(ISRZ002)" /* Set ISPF's message  */
         Exit 8                                /* let ISPF handle     */
                                               /*   the Error         */
end
"(CURLINE CURCOL) = CURSOR"
"(START) = LINENUM .ZFRANGE"   /* Get 1st line number in the range    */
"(STOP)  = LINENUM .ZLRANGE"   /* Get last line number in the range   */
"(DW)    = DATA_WIDTH"         /* Get the width of the editable data  */
"(LEFT,RIGHT) = BOUNDS"        /* Get the BOUNDS                      */

if       Start <> Stop then do
         /* yves */                                         /* 2.17 */
         if wordpos(Lcmd,"E V DI DL DM DS EX LD DH")>0 then do
            ZedSMsg = YCLMACLM(1)
            interpret "ZedLMsg = "YCLMACLM(2)
            Address ISPEXEC 'SETMSG MSG(ISRZ001)'
            "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
            Exit 8
         end
         /* correct for zOS<1.13 */
         if Lcmdnum = "" then do
            lcmdnum = stop-start+1
         end
end

jcl_if  ="N" /*  JCL Upper Case 2.12 */
jcl_hyph="N" /*  JCL Upper Case 2.12 */

do       I = Start to Stop     /* Loop through the range of lines     */
   "(LINE) = LINE "I     /* Get old line value                  */
                         /*                                     */
   line_l = left(line,left-1)
   line_r = right(line,dw-right)
   line_b = substr(line,left,right-left+1)

   Select                /* process the command for this line   */

                                             /*  Help          */
      when Lcmd = "H" | Lcmd = "HELP" then
           Signal help

                                             /*  Help view 2.16*/
      when Lcmd = "HV" then do
           prm="OUTSIDE"
           Signal help_v
      end

      when Lcmd = "EX"  then do               /*  Execute       */
           call ex_tso
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit
           end

      when Lcmd = "AE"  then do               /*  Ascii->Ebcdic */
           Line_b = ASCEBC(Line_b,length(line_b),"E")
           line = line_l||line_b||line_r
           end

      when Lcmd = "EA"  then do               /*  Ebcdic->Ascii */
           Line_b = ASCEBC(Line_b,length(line_b),"A")
           line = line_l||line_b||line_r
           end

      /* 2.15 FindFirst - FindLast - FindAll */
      /*      Hans-Peter Bodden - IVV        */
      when Lcmd = "FI" | Lcmd = "FL" | Lcmd = "FA"  then do  /*  2.15 */
        wordDelimiter = "/*+-(',=).;:<>" /* ASM   */
        wordDelimiter = " *+-(',=) ;:<>" /* JCL   */
        wordDelimiter = "/*+ (',=).;:<>" /* Cobol */

        line = translate(line, ' ', wordDelimiter)

        select
          when curcol = 0 then do
              myWord = word(line,1)
          End
          when curcol = 1 then do
              myWord = word(line,1)
          End
          when substr(line, curcol, 1) = ' ' then do
              parse var line  . = (curcol) myWord .
          end
          when substr(line, curcol - 1, 1) = ' ' then do
              parse var line  . = (curcol) myWord .
          end
          otherwise
              parse var line  p1 = (curcol) p2 .
              i = words(p1)
              if i > 0 then
                    myWord = word(p1,i) || p2
              else
                    myWord = p2
        End

        if length(myWord) > 0 then do
          myWord = '"' || myWord || '"'
          select
              when lcmd = 'FI' then  findOpt = 'FIRST NX'
              when lcmd = 'FL' then  findOpt = 'LAST NX'
              when lcmd = 'FA' then  findOpt = 'ALL'
              otherwise
                   findOpt = ''
          End
          if lcmd = 'FA' then    "EXCLUDE ALL"
          "find " myWord findOpt
          if lcmd = 'FA' then do
            "(fnd,lfnd) = FIND_COUNTS"
            fnd=fnd+0
            lfnd=lfnd+0
            if Lcmdnum<>"" & datatype(Lcmdnum)="NUM" &,
               Lcmdnum>0 then do
               "(TLINE) = LINENUM .ZLAST"
               anz=Lcmdnum
               cn=0
               pl=0
               do i=1 to tline
                 "(xstat) = XSTATUS "i
                 if xstat = "NX" then do
                   if pl>0 then do /* check previous lines */
                     pl=min(pl,anz)
                     do l1=i-1 to 1 by -1
                       "(nstat) = XSTATUS "l1
                       if nstat = "X" then do
                         "XSTATUS "l1" = NX"
                         if rc<>0 then pl=0
                         else do
                           cn=cn+1
                         end
                       end
                       else do
                         leave l1
                       end
                       pl=pl-1
                       if pl<1 then do
                         leave l1
                       end
                     end
                     pl=0
                   end
                   if i<tline then do
                     /* check next lines */
                     "(nstat) = XSTATUS "i+1
                     if nstat = "X" then do
                       do l2=i+1 to min(tline,i+anz)
                         "XSTATUS "l2" = NX"
                         cn=cn+1
                         "(nstat) = XSTATUS "l2+1
                         if nstat = "NX" then leave l2
                       end
                       i=l2-1
                     end
                   end
                 end
                 else do
                   pl=pl+1
                 end
               end
               /* */
            end
            zedsmsg = fnd "fnds in" lfnd "lines"
            zedlmsg = myword "found" fnd "times in" lfnd "lines"
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
          end
          else do
            zedsmsg = myword "searched"
            zedlmsg = myword "searched"
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
          end
        end
        exit 0
      end

      when Lcmd = "JU"  then do               /*  JCL Upper Case 2.12 */
           Line_b = JCL_UP(Line_b,length(line_b))
           line = line_l||line_b||line_r
           end

      when Lcmd = "CE"  then do               /*  Center        */
           line_b = ,
           Center(strip(line_b,"B"),length(line_b))
           line = line_l||line_b||line_r
           end

      when Lcmd = "LN"  then do               /*  Line 2.14     */
           "(NCHARS) = SAVE_LENGTH "i
           col1="----+----"
           cols=""
           rcnt=1
           do j=1 to nchars by 10
             cols=cols""col1""rcnt
             rcnt=rcnt+1
             if rcnt>9 then rcnt=0
           end
           cols=left(cols,nchars)
           cols=overlay("L="right(nchars,5,"0")" ",cols,1)
           "LINE_before "i" = INFOLINE (cols)"
           end

      when Lcmd = "RV"  then do               /*  Reverse       */
           line_b = Reverse(line_b)
           line = line_l||line_b||line_r
           end

      when Lcmd = "TOPD"  then do             /*  Delete to top 2.14 */
           "LABEL .zfirst = .start 0"
           "LABEL "start" = .stop 0"
           if start=1 then "DELETE ALL .stop .stop"
           else "DELETE ALL .start .stop"
           ZedSMsg = ""
           ZedLMsg = start+0 "lines deleted"
           Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           exit
           end

      when Lcmd = "BOTD"  then do             /*  Delete to bot 2.14 */
           "(TEND) = LINENUM .zlast"
           "LABEL "start" = .start 0"
           "LABEL .zlast  = .stop 0"
           if tend=start then "DELETE ALL .stop .stop"
           else "DELETE ALL .start .stop"
           ZedSMsg = ""
           ZedLMsg = tend-start+1 "lines deleted"
           Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           exit
           end

      when Lcmd = "TOPX"  then do             /*  X to top 2.14 */
           "LABEL .zfirst = .start 0"
           "LABEL "start" = .stop 0"
           if start=1 then "X ALL .stop .stop"
           else "X ALL .start .stop"
           ZedSMsg = ""
           ZedLMsg = start+0 "lines excluded"
           Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           exit
           end

      when Lcmd = "BOTX"  then do             /*  X to bot 2.14 */
           "(TEND) = LINENUM .zlast"
           "LABEL "start" = .start 0"
           "LABEL .zlast  = .stop 0"
           if tend=start then "X ALL .stop .stop"
           else "X ALL .start .stop"
           ZedSMsg = ""
           ZedLMsg = tend-start+1 "lines excluded"
           Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           exit
           end

      when Lcmd = "AL" then do                /*  left justify  */
           tmp_line = copies(" ",length(line_b))
           line_b = Strip(line_b,"L")
           line_b = overlay(line_b,tmp_line)
           line = line_l||line_b||line_r
           end

      when Lcmd = "AR" then do                /*  right justify */
           tmp_line = copies(" ",length(line_b))
           line_b = ,
           Right(Strip(line_b,"T"),length(line_b))
           line_b = overlay(line_b,tmp_line)
           line = line_l||line_b||line_r
           end

      when Lcmd = "AU" then do                /*  Align Up      */
           if start=1 then do
              ZedSMsg = YCLMACLM(39)
              ZedLMsg = YCLMACLM(40)
              Address ISPEXEC 'SETMSG MSG(ISRZ001)'
              "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
              Exit 8
           end
           fnd="NO"
           do j=start-1 to 1 by -1 until fnd<>"NO"
              "(xstat) = XSTATUS "j
              if xstat = "NX" then
                 fnd=j
           end
           if fnd="NO" then do
              ZedSMsg = YCLMACLM(39)
              ZedLMsg = YCLMACLM(42)
              Address ISPEXEC 'SETMSG MSG(ISRZ001)'
              "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
              Exit 8
           end
           "(YLIN) = LINE "fnd /* Get previous NX line     */
           /* 2.13 support for JCL AU */
           if left(ylin,2)="//" & left(line,3)="// " then do
             select
             when substr(ylin,3,1)="*" then pos=15
             when substr(ylin,3,1)=" " then pos=wordindex(ylin,2)
             otherwise
               pos=wordindex(ylin,2)
             end
             if pos > 16 then pos=15
             tmp_line=strip(substr(line,4,68))
             if pos+length(tmp_line) > 72 then do
              ZedSMsg = YCLMACLM(39)
              ZedLMsg = YCLMACLM(50)
              Address ISPEXEC 'SETMSG MSG(ISRZ001)'
              "cursor = .ZFRANGE 0"
              Exit 8
             end
             line=left(left("//",pos-1)""tmp_line,71)""substr(line,72)
           end  /* 2.13 end */
           else do
             ylin_l = left(ylin,left-1)
             ylin_r = right(ylin,dw-right)
             ylin_b = substr(ylin,left,right-left+1)
            /* change Eberle 120418 */
             ylin_b = Strip(ylin_b,"L")
             l1 = right-left+1 - length(ylin_b)
             tmp_line = copies(" ",length(line_b))
             line_b = strip(line_b,"B")
             l2 = right-left+1 - length(line_b)
             line_b = copies(" ",min(l1,l2))||line_b
             line_b = overlay(line_b,tmp_line)
             line = line_l||line_b||line_r
          /* change Eberle 120418 */
           end  /* 2.13 end */
      end

      when Lcmd = "AD" then do                /*  Align Down    */
           "(TLINE) = LINENUM .ZLAST"
           if stop=tline then do
              ZedSMsg = YCLMACLM(39)
              ZedLMsg = YCLMACLM(41)
              Address ISPEXEC 'SETMSG MSG(ISRZ001)'
              "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
              Exit 8
           end
           fnd="NO"
           do j=stop+1 to tline until fnd<>"NO"
              "(xstat) = XSTATUS "j
              if xstat = "NX" then
                 fnd=j
           end
           if fnd="NO" then do
              ZedSMsg = YCLMACLM(39)
              ZedLMsg = YCLMACLM(42)
              Address ISPEXEC 'SETMSG MSG(ISRZ001)'
              "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
              Exit 8
           end
           "(YLIN) = LINE "j /* Get next NX line     */
           /* 2.13 support for JCL AD */
           if left(ylin,2)="//" & left(line,3)="// " then do
             select
             when substr(ylin,3,1)="*" then pos=15
             when substr(ylin,3,1)=" " then pos=wordindex(ylin,2)
             otherwise
               pos=wordindex(ylin,2)
             end
             if pos > 16 then pos=15
             tmp_line=strip(substr(line,4,68))
             if pos+length(tmp_line) > 72 then do
              ZedSMsg = YCLMACLM(39)
              ZedLMsg = YCLMACLM(50)
              Address ISPEXEC 'SETMSG MSG(ISRZ001)'
              "cursor = .ZFRANGE 0"
              Exit 8
             end
             line=left(left("//",pos-1)""tmp_line,71)""substr(line,72)
           end  /* 2.13 end */
           else do
             ylin_l = left(ylin,left-1)
             ylin_r = right(ylin,dw-right)
             ylin_b = substr(ylin,left,right-left+1)
            /* change Eberle 120418 */
             ylin_b = Strip(ylin_b,"L")
             l1 = right-left+1 - length(ylin_b)
             tmp_line = copies(" ",length(line_b))
             line_b = strip(line_b,"B")
             l2 = right-left+1 - length(line_b)
             line_b = copies(" ",min(l1,l2))||line_b
             line_b = overlay(line_b,tmp_line)
             line = line_l||line_b||line_r
            /* change Eberle 120418 */
           end  /* 2.13 end */
      end

      when Lcmd = "CM" then do                /*  Comment       */
           /* 2.18 */
           if i = start then do
              if left(line,3)="//*" then uncomm=1
              else                       uncomm=0
           end
           /* 2.18 */

           select
           when uncomm & left(line,3)="//*" then do    /* 2.18 */
              if substr(line,71)="" then do  /* no continuation */
                line=left(line,2)""substr(line,4,67),   /* 2.17 */
                    substr(line,72)
              end
              else do                         /* continuation */
                if left(line,4)="//* " then do     /* 2.17 */
                   line="// "substr(line,4)
                end
                else do
                   ZedSMsg = "" /* 2.70 */
                   ZedLMsg = "Nothing done - uncomment will",
                             "change JCL behavior - col 71 cont."
                   Address ISPEXEC 'SETMSG MSG(ISRZ001)'
                end
              end
           end
           when left(line,2)="//" then do
              woleer=pos("  ",reverse(left(line,71)))
              if woleer=0 then do
                 ZedSMsg = "" /* 2.70 */
                 ZedLMsg = "Character '"substr(line,3,1)"'",
                           "overridden -",
                           "no space found"
                 Address ISPEXEC 'SETMSG MSG(ISRZ001)'
                 line=left(line,2)"*"substr(line,4)
              end
              else do
               line=left(line,71-woleer)""substr(line,71-woleer+2)
               line=left(line,2)"*"substr(line,3)
              end
           end
           /* 2.13 */
           when start=stop &,
             translate(strip(line))="/* COMMENT START" then do
             "(TLINE) = LINENUM .ZLAST"
             fnd="N"
             wo=pos("/* COMMENT START",translate(line))
             do l1=start+1 to tline
               "(xstat) = XSTATUS "l1
               if xstat = "NX" then do
                 "(YLIN) = LINE "l1
                 upda=translate(substr(ylin,wo+3,14))
                 if left(ylin,wo+2)=" " &,
                   upda=="COMMENT END */" then do
                   fnd=l1
                   l1=tline+9
                 end
               end
             end
             if fnd="N" then do
               ZedSMsg = ""
               ZedLMsg = "'Comment End */' not found on column" wo+3
               Address ISPEXEC 'SETMSG MSG(ISRZ001)'
               "Cursor =  .zfrange 0"
               exit 0
             end
             "DELETE" fnd
             "DELETE" start
             ZedSMsg = ""
             ZedLMsg = "Comments on lines" start+0 "and" fnd "deleted"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
             "Cursor =  "start" 0"
             exit 0
           end
           when start=stop &,
             translate(strip(line))="COMMENT END */" then do
             fnd="N"
             wo=pos("  COMMENT END */",translate(line))
             if wo>1 then do
               do l1=stop-1 to 1 by -1
                 "(xstat) = XSTATUS "l1
                 if xstat = "NX" then do
                   "(YLIN) = LINE "l1
                   upda=translate(substr(ylin,wo-1,16))
                   if upda=="/* COMMENT START" then do
                     ylin=overlay(" ",ylin,wo-1,16)
                     if ylin="" then do
                       fnd=l1
                       l1=0
                     end
                   end
                 end
               end
             end
             if fnd="N" then do
               ZedSMsg = ""
               ZedLMsg = "'/* Comment Start' not found on column" wo-1
               Address ISPEXEC 'SETMSG MSG(ISRZ001)'
               "Cursor =  .zfrange 0"
               exit 0
             end
             "DELETE" stop
             "DELETE" fnd
             ZedSMsg = ""
             ZedLMsg = "Comments on lines" fnd "and" stop+0 "deleted"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
             "Cursor =  "stop" 0"
             exit 0
           end
           otherwise
              /* change Eberle 120418 */
              l1 = dw - length("   Comment End */")
              l2 = dw - length(strip(line,"L"))
              if l2 = dw then l2 = 0          /* empty line     */
              line = copies(" ",min(l1,l2))
              /* change Eberle 120418 */
              outit="'"line"/* Comment Start'"
              "LINE_BEFORE" start "= DATALINE" outit
              outit="'"line"   Comment End */'"
              "LINE_AFTER" stop+1 "= DATALINE" outit
              "Cursor =  .zfrange 0"                              /* 2.12 HUK */
              exit 0
           end
      end

      when Lcmd = "YX" then do                /*  Hex It        */
           "(NCHARS) = SAVE_LENGTH "i
           hexit=c2x(line)
           hex1=""
           hex2=""
           do j=1 to nchars*2 by 2
              hex1=hex1""substr(hexit,j,1)
              hex2=hex2""substr(hexit,j+1,1)
           end
           "LINE_BEFORE" i+1 "= INFOLINE" hex1
           "LINE_BEFORE" i+1 "= INFOLINE" hex2
      end

      when Lcmd = "YD" then do                /*  Hex It data   */
           "(NCHARS) = SAVE_LENGTH "i
           hexit=c2x(line)
           hex1=left(hexit,nchars)
           hex2=substr(hexit,nchars+1,nchars)
           "LINE_BEFORE" i+1 "= INFOLINE" hex1
           "LINE_BEFORE" i+1 "= INFOLINE" hex2
      end

      when Lcmd = "E" | Lcmd = "EZ" then do    /* 2.15 */
      /*   yves                 */
      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
           Address ISPEXEC "CONTROL ERRORS RETURN"
           if myvol="UNIXPATH" then do                  /* 2.9 */
             if Lcmd = "EZ" then do /* 2.15 */
               Address ISPEXEC,
               "SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS EU" MyDsn")"
             end
             else do
               Address ISPEXEC "EDIT FILE(mydsn)"ed_parms /* 2.10 */
             end
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             if Lcmd = "EZ" then do /* 2.15 */
               Address ISPEXEC,
               "SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS E" MyDsn myvol")"
             end
             else do
               Address ISPEXEC "EDIT DATASET('"MyDsn"')",
                       "VOLUME("myvol")"ed_parms          /* 2.10 */
             end
           end                                          /* 2.9 */
           if RC > 4 then do
              ShowAct = "Edit"                 /* Eberle 120720 */
              ShowDSN = mydsn                  /* Eberle 120720 */
              ShowVOL = myvol                  /* Eberle 120720 */
              signal CheckRC
           end                                                 /* 2.12 HUK */
           Address ISPEXEC "CONTROL ERRORS CANCEL"
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end

      when Lcmd = "V" | Lcmd = "VZ" then do    /* 2.15 */
      /*   yves                 */
      /*   MyDsn = YCLMACDS(Line) */
           ShowAct = "View"                    /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
           Address ISPEXEC "CONTROL ERRORS RETURN"
             if myvol="UNIXPATH" then do                  /* 2.9 */
               if Lcmd = "VZ" then do /* 2.15 */
                 Address ISPEXEC,
                 "SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS VU" MyDsn")"
               end
               else do
                 Address ISPEXEC "VIEW FILE(mydsn)"ed_parms /* 2.10 */
               end
             end                                          /* 2.9 */
             else do                                      /* 2.9 */
               if Lcmd = "VZ" then do /* 2.15 */
                 Address ISPEXEC,
                 "SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS V" MyDsn myvol")"
               end
               else do
                 Address ISPEXEC "VIEW DATASET('"MyDsn"')",
                         "VOLUME("myvol")"ed_parms          /* 2.10 */
               end
             end                                          /* 2.9 */
             if RC > 4 then do
                ShowAct = "View"                 /* Eberle 120720 */
                ShowDSN = mydsn                  /* Eberle 120720 */
                ShowVOL = myvol                  /* Eberle 120720 */
                signal CheckRC
             end
           Address ISPEXEC "CONTROL ERRORS CANCEL"
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end
                                                        /* 2.12 HUK */
      when Lcmd = "DA" then do   /* 2.13 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
           if myvol="UNIXPATH" then do
             ZedSMsg = ""
             ZedLMsg = "DI not supported for PATH='"mydsn"'"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           end
           else do
             X = MyDsInfo("'"MyDsn"'",myvol)
           end
           "Cursor = "curline curcol
           exit 0
      end

      when Lcmd = "DI" then do
      /*   yves                 */
      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
        /* say mydsn "-" myvol */
           if myvol="UNIXPATH" then do                  /* 2.9 */
             ZedSMsg = ""
             ZedLMsg = "DI not supported for PATH='"mydsn"'"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             X = MyDsInfo("'"MyDsn"'",myvol)
           end                                          /* 2.9 */
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end

      when Lcmd = "LD" then do                 /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
           if myvol="UNIXPATH" then do                  /* 2.9 */
             ZedSMsg = ""
             ZedLMsg = "LD not supported for PATH='"mydsn"'"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             X = MyLdInfo("'"MyDsn"'",myvol)
           end                                          /* 2.9 */
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end

      when Lcmd = "DH" then do                 /* 2.12 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
           if myvol="UNIXPATH" then do
             ZedSMsg = ""
             ZedLMsg = "DH not supported for PATH='"mydsn"'"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             X = MyDHInfo("'"MyDsn"'",myvol)
           end                                          /* 2.9 */
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end

      when Lcmd = "DL" then do
      /*   yves                 */
      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
        /* say mydsn "-" myvol */
           if myvol="UNIXPATH" then do                  /* 2.9 */
             ZedSMsg = ""
             ZedLMsg = "DL not supported for PATH='"mydsn"'"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             X = MyDsCat("'"MyDsn"'",myvol)
           end                                          /* 2.9 */
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end

      when Lcmd = "DM" then do

      /*   yves                 */
      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
       /*  say mydsn "-" myvol */
           if myvol="UNIXPATH" then do                  /* 2.9 */
             ZedSMsg = ""
             ZedLMsg = "DM not supported for PATH='"mydsn"'"
             Address ISPEXEC 'SETMSG MSG(ISRZ001)'
             "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
             Exit 0
           end                                          /* 2.9 */
           Parse var MyDsn MyDsn "(" .
           Address ISPEXEC "CONTROL ERRORS RETURN"
           Address ISPEXEC,
           "LMINIT DATAID(DATAODV) DATASET('"MyDsn"')",
                   "VOLUME("MyVol")"
           cont="Y"                                           /* 2.12 */
           if rc<>0 then do                                   /* 2.12 */
              ksm=ZerrSM                                      /* 2.12 */
              klm=ZerrLM                                      /* 2.12 */
              if rc=8 & MyVol<>"" then do                     /* 2.12 */
                Address ISPEXEC,                              /* 2.12 */
                "LMINIT DATAID(DATAODV) DATASET('"MyDsn"')"   /* 2.12 */
                if rc=0 then do                               /* 2.12 */
                  ZedSMsg  =  ""                              /* 2.12 */
                  ZedLMsg  =  "MEMLIST without Volume" MyVol  /* 2.12 */
                  Address  ISPEXEC 'SETMSG MSG(ISRZ001)'      /* 2.12 */
                end                                           /* 2.12 */
                else do                                       /* 2.12 */
                  cont="N"                                    /* 2.12 */
                  ZerrSM=ksm                                  /* 2.12 */
                  ZerrLM=klm                                  /* 2.12 */
                  Address ISPEXEC 'SETMSG MSG(ISRZ002)'       /* 2.12 */
                end                                           /* 2.12 */
              end                                             /* 2.12 */
              else do                                         /* 2.12 */
                cont="N"                                      /* 2.12 */
                Address ISPEXEC 'SETMSG MSG(ISRZ002)'         /* 2.12 */
              end                                             /* 2.12 */
           end                                                /* 2.12 */
           if cont="Y" then do                                /* 2.12 */
             Address ISPEXEC,
             "MEMLIST  DATAID("DATAODV")"
             DispRC = RC
             Address ISPEXEC,
             "LMFREE   DATAID("DATAODV")"
             Address ISPEXEC "CONTROL ERRORS CANCEL"
             if DispRC > 0 then do
                ZedSMsg = "MEMLIST-RC="DispRC
                                              /* Eberle 120720 */
                if MyVol <> "" then do
                  errvol = "VOL("strip(myvol,"B")")"
                end
                else errvol =""
                ZedLMsg = "MEMLIST "MyDsn errvol YCLMACLM(3)
                Address ISPEXEC 'SETMSG MSG(ISRZ001)'
             end
           end
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0
      end

      otherwise
   /* when Lcmd = "DS" | Lcmd="DX" | Lcmd="DZ" then do */
           ShowAct = "Dslist"                  /* 2.15 */
      /*   yves                 */
      /*   MyDsn = YCLMACDS(Line) */           /* 2.9 */
           parse value YCLMACDS(Line) with retc mydsn '05'x myvol
           if retc = 8 then exit retc
           MyVol=strip(MyVol)   /* 2.12 */
           if myvol="UNIXPATH" then do                  /* 2.9 */
             sep="/"                                    /* 2.9 */
             mydsn=substr(mydsn,2)                      /* 2.9 */
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             Parse var MyDsn MyDsn "(" .
             sep="."                                    /* 2.9 */
           end                                          /* 2.9 */
      /*   yves                 */
           if Lcmd = "DX" | Lcmd="DZ" then do /* 2.15 */
           /* change Eberle 120418 */
             /* Comment Start
             if start=stop then do
                Comment End */
             select
             when Lcmdnum <= 1 & Lcmd="DX" then do /* 2.15 */
               parse var mydsn mydsn (sep) .
             end
             when datatype(Lcmdnum)<>"NUM" then do /* 2.15 */
               nop
             end
             otherwise
                tdsn=""
                pt=""
                do i=1 to Lcmdnum until mydsn="" /* 2.15 */
                /* change Eberle 120418 */                  /* 2.9 */
                   parse var mydsn fq (sep) mydsn
                   tdsn = tdsn""pt""fq
                   pt=sep          /* 2.9 */
                end
                mydsn=tdsn
             end
           end
           if myvol="UNIXPATH" then do                  /* 2.9 */
             mydsn="/"mydsn                             /* 2.9 */
             if Lcmd = "DZ" then do /* 2.15 */
               Address ISPEXEC,
               "SELECT PGM(ISPSTRT) PARM(TSO %YCLMACNS DZU" MyDsn")"
             end
             else do
               address ispexec,                         /* 2.9 */
               "DIRLIST PATH(mydsn)"                    /* 2.9 */
               select                                   /* 2.9 */
               when rc=0 then do                        /* 2.12 HUK */
                 "cursor = .ZFRANGE 0"                  /* 2.12 HUK */
                 exit 0                                 /* 2.9 */
                 end
               when rc=8 then do                        /* 2.9 */
                 if lastpos("/",mydsn)>0 then do
                   mydsn=left(mydsn,lastpos("/",mydsn)-1)
                   address ispexec,                     /* 2.9 */
                   "DIRLIST PATH(mydsn)"                /* 2.9 */
                   if rc=0 then do                      /* 2.9 */
                      "cursor = .ZFRANGE 0"             /* 2.12 HUK */
                      exit 0                            /* 2.9 */
                   end                                  /* 2.12 HUK */
                 end
               end                                      /* 2.9 */
               otherwise
                 ZedSMsg = "DIRLIST-RC="RC
                 ZedLMsg = "DIRLIST PATH("MyDsn")"
                 Address ISPEXEC 'SETMSG MSG(ISRZ001)'
                 "Cursor = "curline curcol              /* 2.12 HUK */
                 exit 0
               end
             end
           end                                          /* 2.9 */
           else do                                      /* 2.9 */
             if Lcmd = "DZ" then do /* 2.15 */
               Address ISPEXEC,
               "SELECT PGM(ISPSTRT)",
                      "PARM(TSO %YCLMACNS DZ" MyDsn MyVol")"
             end
             else do
               Address ISPEXEC "CONTROL ERRORS RETURN"
               Address ISPEXEC "LMDINIT LISTID(ID) Level("MyDsn")",
                       "VOLUME("MyVol")"
               Address ISPEXEC "LMDDISP LISTID("ID")"
               DispRC = RC
               Address ISPEXEC "LMDFREE LISTID("ID")"
               Address ISPEXEC "CONTROL ERRORS CANCEL"
               if DispRC > 0 then do
                 ZedSMsg = "LMDDISP-RC="DispRC
                                              /* Eberle 120720 */
                 if MyVol <> "" then do            /* 2.13 */
                   Address ISPEXEC,
                   "CONTROL ERRORS RETURN"
                   Address ISPEXEC,
                   "LMDINIT LISTID(ID) Level("MyDsn")"
                   ZedSMsg  =  ""
                   ZedLMsg  =  ShowAct "without Volume" MyVol
                   Address  ISPEXEC 'SETMSG MSG(ISRZ001)'
                   Address ISPEXEC,
                   "LMDDISP LISTID("ID")"
                   Disp2RC = RC
                   Address ISPEXEC,
                   "LMDFREE LISTID("ID")"
                   Address ISPEXEC,
                   "CONTROL ERRORS CANCEL"
                   if Disp2RC > 0 then do
                     errvol = "VOL("strip(MyVol,"B")")"
                     ZedLMsg = "LMDDISP LEVEL("MyDsn")" errvol,
                               YCLMACLM(3)
                     Address ISPEXEC 'SETMSG MSG(ISRZ001)'
                   end
                 end
                 else do
                   ZedLMsg = "LMDDISP LEVEL("MyDsn")",
                             YCLMACLM(3)
                   Address ISPEXEC 'SETMSG MSG(ISRZ001)'
                 end
               end
             end
           end                                          /* 2.9 */
           "Cursor = "curline curcol                           /* 2.12 HUK */
           exit 0

   end
   if WordPos(Lcmd,CSupport) > 0 then do /* If a command which  */
                                         /*    changed line     */
      "LINE "I" = (LINE)"   /* save changed Line                */
   end
end                            /* End of loop through lines           */

"Cursor = "curline curcol                                      /* 2.12 HUK */
exit     0                     /* Return to ISPF                      */

CheckRc:

ActRC    = RC

Select

   When ActRC = 14 then do
        if Pos("(",ShowDsn) = 0 then do
           ZedSMsg = "Dsn in use"
           ZedLMsg = YCLMACLM(45)
        end
        else do
           ZedSMsg = "Member in use"
           ZedLMsg = YCLMACLM(46)
        end
   end

   When ActRC = 18 then do
        ZedSMsg = "VSAM"
        ZedLMsg = YCLMACLM(47)
   end

   When ActRC = 20 then do
        if ShowVol<>"" & ShowVol<>"UNIXPATH" then do      /* 2.12 */
          ZedSMsg  =  ""                                  /* 2.12 */
          ZedLMsg  =  ShowAct "without Volume" MyVol      /* 2.12 */
          Address  ISPEXEC 'SETMSG MSG(ISRZ001)'          /* 2.12 */
          Address ISPEXEC ShowAct "DATASET('"MyDsn"')"    /* 2.12 */
          if RC>4 then nop                                /* 2.12 */
          else do                                         /* 2.12 */
            "cursor = .ZFRANGE 0"                         /* 2.12 */
            Exit 0                                        /* 2.12 */
          end                                             /* 2.12 */
        end                                               /* 2.12 */
        ZedSMsg = YCLMACLM(48)
                                                   /* Eberle 120720 */
        ShowVol = strip(ShowVol,"B")               /* Eberle 120720 */
        if ShowVol <> "" then do                   /* Eberle 120720 */
          xshowvol = "VOL("ShowVol")"              /* Eberle 120720 */
        end                                        /* Eberle 120720 */
        else xshowvol = ""                         /* Eberle 120720 */
        ZedLMsg = "DSN" ShowDsn xshowvol YCLMACLM(6)
                                                   /* Eberle 120720 */
   end

   otherwise do
      ZedSMsg  = ShowAct"-RC="ActRC
      ZedLMsg  = ShowAct "Dsn="ShowDsn" Vol="myvol, /* Eberle 120720 */
                 "mit RC="ActRC YCLMACLM(7)
   end

end

Address  ISPEXEC 'SETMSG MSG(ISRZ001)'
"cursor = .ZFRANGE 0"                                /* 2.12 HUK */

Exit 0

MyDsInfo:

/* used for DI and DA 2.13 */
/* Arg      InfoDsn  */
infodsn = arg(1)
infovol = strip(arg(2),"B")                        /* Eberle 120720 */

if       Pos("(",InfoDsn) > 0 then do
         Parse Var InfoDsn InfoDsn "(" .
         if Left(InfoDsn,1) = "'" then Infodsn = InfoDsn"'"
end

Address  ISPEXEC "DSINFO DATASET("InfoDsn") VOLUME("infovol")"
if       RC > 0 then do
         /* yves */
         if rc=8 then do
         ZedSMsg="DSINFO",
           YCLMACLM(49)
         ZedLMsg="DSINFO DATASET("InfoDsn") VOLUME("infovol")",
           YCLMACLM(49)
         end
         else do
         ZedSMsg="DSINFO",
         YCLMACLM(7)
         ZedLMsg="DSINFO DATASET("InfoDsn") VOLUME("infovol")",
         "RC="Rc YCLMACLM(7)
         end
         Address  ISPEXEC 'SETMSG MSG(ISRZ001)'
         "cursor = .ZFRANGE 0"                           /* 2.12 HUK */
         exit 4
end

I        = WordPos(ZdsSpc,"BLOCK TRACK CYLINDER BYTE KYLOBYTE MEGABYTE")
Ealloc   = Word(Strip(ZdsBlk) "TRK CYL 1",I)
Kalloc   = Word("BLOCK("Strip(ZdsBlk)")" "TRACKS CYL 1",I)
ezus=""
if i>3 then do
  Kalloc = "AVBLOCK("Strip(ZdsBlk)")"
  select
  when left(ZdsSpc,1)="B" then do
    ezus="AVGREC=U,"
    kzus="AVGREC(U)"
  end
  when left(ZdsSpc,1)="K" then do
    ezus="AVGREC=K,"
    kzus="AVGREC(K)"
  end
  when left(ZdsSpc,1)="M" then do
    ezus="AVGREC=M,"
    kzus="AVGREC(M)"
  end
  otherwise
  end
end
Einheit  = Word(YCLMACLM(37),I)

MoreVols = " "
if       Zds#Vols > 1 then do
  MoreVols = "+"
end

/* yves */
/* Address  TSO "CLEAR" */

Info.1   = YCLMACLM(8) Strip(InfoDsn,"B","'")
Info.2   = ""
Info.3   = YCLMACLM(9)

if       ZdsMC""ZdsSC""ZdsDC = Copies("0"X,24) then signal NoSMS
if       ZdsOrg = "PO" then signal SmsPO

SmsPS:

Tl       = YCLMACLM(10) ZdsMc
Tl       = Left(Tl,39) YCLMACLM(11),
         Edit(Strip(ZdsTota))
Info.4   = Overlay(Einheit,Tl,52,Length(Einheit)+1)
Tl       = YCLMACLM(12) ZdsSc
Info.5   = Left(Tl,39) YCLMACLM(21),
         Edit(Strip(ZdsExtA))
Info.6   = YCLMACLM(14) ZdsVol MoreVols
Info.7   = YCLMACLM(15) ZdsDevt
Tl       = YCLMACLM(16) ZdsDc
Info.8   = Left(Tl,39) YCLMACLM(17)
Tl       = YCLMACLM(18) ZdsOrg
Info.9   = Left(Tl,39) " . . . . . . . . . . :",
           Edit(Strip(ZdsTotU))
Info.9   = Overlay(YCLMACLM(19)" "einheit" ",info.9,41)
Tl       = YCLMACLM(20) ZdsRf
Info.10  = Left(Tl,39) YCLMACLM(38),
           Edit(Strip(ZdsExtU))
Info.11  = YCLMACLM(22) Strip(ZdsLrec)
Info.12  = YCLMACLM(23) Strip(ZdsBlk)
Info.13  = " . . . . . . . . . . . :",
           Edit(Strip(Zds1Ex))
Info.13  = Overlay(YCLMACLM(24)""einheit" ",info.13,1)
Info.14  = " . . . . . . . . . . . :",
           Edit(Strip(Zds2Ex))
Info.14  = Overlay(YCLMACLM(25)""einheit" ",info.14,1)
Info.15  = left(YCLMACLM(31) ZdsDsnT,39),
           YCLMACLM(43) ZdsSeq

Info.0   = 15
/* 2.17 */
if ZDSDSNV<>"ZDSDSNV" then do
  Info.0   = Info.0+1
  II       = Info.0
  Info.II = "   Dataset Version . . :" ZDSDSNV
end

signal   Dates

SmsPO:

Tl       = YCLMACLM(10) ZdsMc
Tl       = Left(Tl,39) YCLMACLM(11),
         Edit(Strip(ZdsTota))
Info.4   = Overlay(Einheit,Tl,52,Length(Einheit)+1)
Tl       = YCLMACLM(12) ZdsSc
Info.5   = Left(Tl,39) YCLMACLM(21),
         Edit(Strip(ZdsExtA))
Tl       = YCLMACLM(14) ZdsVol MoreVols
if       ZdsDsnT = "LIBRARY" then
         Info.6  = Left(Tl,39) YCLMACLM(26) Strip(ZdsDir)
else
         Info.6  = Left(Tl,39) YCLMACLM(26) Edit(Strip(ZdsDirA))
Tl       = YCLMACLM(15) ZdsDevt
Info.7   = Tl
if       ZdsDsnT = "LIBRARY" then Info.7  = Left(Tl,39) YCLMACLM(27)
                             else Info.7  = Left(Tl,39)
Info.8   = YCLMACLM(16) ZdsDc
Tl       = YCLMACLM(18) ZdsOrg
Info.9   = Left(Tl,39) YCLMACLM(17)
Tl       = YCLMACLM(20) ZdsRf
if       ZdsDsnT = "LIBRARY" then
         Info.10 = Left(Tl,39) YCLMACLM(28) Edit(Strip(ZdsPagU))
else do
         Info.10  = Left(Tl,39) " . . . . . . . . . . :",
                    Edit(Strip(ZdsTotU))
         Info.10  = Overlay(YCLMACLM(19)" "einheit" ",info.10,41)
end
Tl       = YCLMACLM(22) Strip(ZdsLrec)
if       ZdsDsnT = "LIBRARY" then
         Info.11 = Left(Tl,39) YCLMACLM(29) Edit(Strip(ZdsPerU))
else
         Info.11 = Left(Tl,39) YCLMACLM(38) Edit(Strip(ZdsExtU))
Tl       = YCLMACLM(23) Strip(ZdsBlk)
if       ZdsDsnT = "LIBRARY" then
         Info.12  = Left(Tl,39) YCLMACLM(30) Edit(Strip(Zds#Mem))
else
         Info.12  = Left(Tl,39) YCLMACLM(44) Edit(Strip(ZdsDirU))
Info.13  = " . . . . . . . . . . . :",
           Edit(Strip(Zds1Ex))
Info.13  = Overlay(YCLMACLM(24)""einheit" ",info.13,1)
if       ZdsDsnT = "LIBRARY" then
         Info.13  = Left(Info.13,39)
else
         Info.13  = Left(Info.13,39) YCLMACLM(30) Edit(Strip(Zds#Mem))
Info.14  = " . . . . . . . . . . . :",
           Edit(Strip(Zds2Ex))
Info.14  = Overlay(YCLMACLM(25)""einheit" ",info.14,1)
Info.15  = left(YCLMACLM(31) ZdsDsnT,39)

Info.0   = 15
/* 2.17 */
if ZDSDSNV<>"ZDSDSNV" then do
  Info.0   = Info.0+1
  II       = Info.0
  Info.II = "   Dataset Version . . :" ZDSDSNV
end
if ZDSNGEN<>"ZDSNGEN" then do
  Info.0   = Info.0+1
  II       = Info.0
  Info.II = "   Number of Generation:" ZDSNGEN
end

signal   Dates

NoSms:

if       ZdsOrg = "PO" then signal NoSmsPO

NoSmsPS:

Tl       = YCLMACLM(14) ZdsVol MoreVols
Info.4   = Left(Tl,39) YCLMACLM(32) Left(Einheit,8)". :",
           Edit(Strip(ZdsTota))
Tl       = YCLMACLM(15) ZdsDevt
Info.5   = Left(Tl,39) YCLMACLM(21),
           Edit(Strip(ZdsExtA))
Info.6   = YCLMACLM(18) ZdsOrg
Info.7   = YCLMACLM(20) ZdsRf
Info.8   = YCLMACLM(22) Strip(ZdsLrec)
Tl       = YCLMACLM(23) Strip(ZdsBlk)
Info.9   = Left(Tl,39) YCLMACLM(17)
Info.10  = " . . . . . . . . . . . :",
           Edit(Strip(Zds1Ex))
Info.10  = Overlay(YCLMACLM(24)""einheit" ",info.10,1)
Info.10  = Left(Info.10,39) " . . . . . . . . . . :",
           Edit(Strip(ZdsTotU))
Info.10  = Overlay(YCLMACLM(33)" "einheit" ",info.10,41)
Info.11  = " . . . . . . . . . . . :",
           Edit(Strip(Zds2Ex))
Info.11  = Overlay(YCLMACLM(25)""einheit" ",info.11,1)
Info.11  = Left(Info.11,39) YCLMACLM(38),
           Edit(Strip(ZdsExtU))

Info.0   = 11

/* 2.17 */
if ZDSDSNV<>"ZDSDSNV" then do
  Info.0   = Info.0+1
  II       = Info.0
  Info.II = "   Dataset Version . . :" ZDSDSNV
end

signal   Dates

NoSmsPO:

Tl       = YCLMACLM(14) ZdsVol MoreVols
Tl       = Left(Tl,39) YCLMACLM(11),
         Edit(Strip(ZdsTota))
Info.4   = Overlay(Einheit,Tl,52,Length(Einheit)+1)
Tl       = YCLMACLM(15) ZdsDevt
Info.5   = Left(Tl,39) YCLMACLM(21),
         Edit(Strip(ZdsExtA))
Tl       = YCLMACLM(18) ZdsOrg
Info.6   = Left(Tl,39) YCLMACLM(26),
         Edit(Strip(ZdsDirA))
Tl       = YCLMACLM(20) ZdsRf
Info.7   = Left(Tl,39) " (Maximum)"
Info.8   = YCLMACLM(22) Strip(ZdsLrec)
Tl       = YCLMACLM(23) Strip(ZdsBlk)
Info.9   = Left(Tl,39) YCLMACLM(17)
Info.10  = " . . . . . . . . . . . :",
           Edit(Strip(Zds1Ex))
Info.10  = Overlay(YCLMACLM(24)""einheit" ",info.10,1)
Info.10  = Left(Info.10,39) " . . . . . . . . . . :",
           Edit(Strip(ZdsTotU))
Info.10  = Overlay(YCLMACLM(33)" "einheit" ",info.10,41)
Info.11  = " . . . . . . . . . . . :",
           Edit(Strip(Zds2Ex))
Info.11  = Overlay(YCLMACLM(25)""einheit" ",info.11,1)
Info.11  = Left(Info.11,39) YCLMACLM(38),
           Edit(Strip(ZdsExtU))
Tl       = ""
Info.12  = Left(Tl,39) YCLMACLM(26),
           Edit(Strip(ZdsDirU))
Tl       = ""
Info.13  = Left(Tl,39) YCLMACLM(30),
           Edit(Strip(Zds#Mem))

Info.0   = 13

/* 2.17 */
if ZDSDSNV<>"ZDSDSNV" then do
  Info.0   = Info.0+1
  II       = Info.0
  Info.II = "   Dataset Version . . :" ZDSDSNV
end
if ZDSNGEN<>"ZDSNGEN" then do
  Info.0   = Info.0+1
  II       = Info.0
  Info.II = "   Number of Generation:" ZDSNGEN
end

signal   Dates

Dates:

II       = Info.0 + 1
Info.II  = ""

/* 2.17 */
if ZDSEATR<>"ZDSEATR" & ZDSEATR<>"" then do
  II       = II + 1
  Info.II = "   EATTR - Ext. Attr.  :" ZDSEATR
end
if ZDSCJOBN<>"ZDSCJOBN" & ZDSCJOBN<>"" then do
  II       = II + 1
  Info.II = "   EAV - Jobname Creat :" ZDSCJOBN
end
if ZDSCSTPN<>"ZDSCSTPN" & ZDSCSTPN<>"" then do
  II       = II + 1
  Info.II = "   EAV - Stepnm  Creat :" ZDSCSTPN
end

II       = II + 1
Tl       = YCLMACLM(34) FormDate(ZdsCDate)
Info.II  = Left(Tl,39) YCLMACLM(35) FormDate(ZdsRDate)
II       = II + 1
Info.II  = YCLMACLM(36) FormDate(ZdsXDate)

II       = II + 1
Info.II=">>> Use line command MD (Make Data) to use JCL to allocate"
ki=II
II       = II + 1
Info.II  = "//ycosddn  DD DSN="Strip(InfoDsn,"B","'")","
ka=1
kal.ka=">>> Use line command MD (Make Data) and EX (Execute)"
ka=ka+1
kal.ka="ALLOC FI(ycosddn) DA("InfoDsn") +"
II       = II + 1
Info.II  = "//            DISP=(,CATLG),"
II       = II + 1
Info.II  = "//            SPACE=("strip(Ealloc)",("strip(zds1ex)","
Info.II  = Info.II""strip(zds2ex)","strip(zdsdira)")),"ezus
ka=ka+1
kal.ka="   NEW CATALOG" Kalloc,
        "SPACE("strip(zds1ex)","strip(zds2ex)") +"
ka=ka+1
if zdsdira<>"" & zdsdira<>0 then do
  kal.ka="   DIR("strip(zdsdira)") "
end
else do
  kal.ka="   "
end
II       = II + 1
Info.II  = "//            LRECL="strip(zdslrec)","
tl3=strip(zdsrf)
tl4=""
tl5=""
do l3=1 to length(tl3)
  tl4=tl4""tl5""substr(tl3,l3,1)
  tl5=" "
end
kal.ka=kal.ka"LRECL("strip(zdslrec)") RECFM("tl4") +"
Info.II  = Info.II"RECFM="strip(zdsrf)",BLKSIZE="strip(zdsblk)","
Info.II  = Info.II"DSORG="strip(zdsorg)","
ka=ka+1
kal.ka="   BLKSIZE("strip(zdsblk)") DSORG("strip(zdsorg)") "
II       = II + 1
if zds#vols > 1 then do
  Info.II  = "//            UNIT=("strip(zdsdevt)",,,"strip(zds#vols)")"
end
else do
  Info.II  = "//            UNIT="strip(zdsdevt)
end
Info.II  = Info.II",VOL=SER="strip(zdsvol)
if       ZdsMC""ZdsSC""ZdsDC <> Copies("0"X,24) &,
         ZdsMC""ZdsSC""ZdsDC <> "**None****None****None**" then do
  kal.ka=kal.ka"+"
  ka=ka+1
  kal.ka="   "
  Info.II  = Info.II","
  II       = II + 1
  cont=""
  Info.II  = "//            "
  if       ZdsMC <> Copies("0"X,8) &,
           ZdsMC <> "**None**" then do
     Info.II  = info.ii"MGMTCLAS="strip(zdsMC)
     cont=","
     kal.ka=kal.ka"MGMTCLAS("strip(zdsMC)") "
  end
  if       ZdsSC <> Copies("0"X,8) &,
           ZdsSC <> "**None**" then do
     Info.II  = info.ii""cont"STORCLAS="strip(zdsSC)
     cont=","
     kal.ka=kal.ka"STORCLAS("strip(zdsSC)") "
  end
  if       ZdsDC <> Copies("0"X,8) &,
           ZdsDC <> "**None**" then do
     Info.II  = info.ii""cont"DATACLAS="strip(zdsDC)
     kal.ka=kal.ka"DATACLAS("strip(zdsDC)") "
  end
end
if ZdsDsnt<>"" then do
  if Info.II <> "//            " then do
    Info.II = Info.II","
    II       = II + 1
  end
  /* 2.17 version */
  ka1=""
  ka2=""
  ka3=""
  if ZDSDSNV<>"ZDSDSNV" & ZDSDSNV<>"" & ZDSDSNV<>"0" then do
    ka2=","ZDSDSNV    /* version */
  end
  If ZdsDsnt="EXTENDED" then ZdsDsnt="EXTREQ"   /* 2.14 */
  Info.II = "//            DSNTYPE="ka1""strip(ZdsDsnT)""ka2""ka3
  kal.ka=kal.ka" +"
  ka=ka+1
  kal.ka="   DSNTYPE("strip(ZdsDsnT)""ka2")"
end
/* 2.17 maxgens */
if ZDSNGEN<>"" & ZDSNGEN<>"ZDSNGEN" & ZDSNGEN<>"0" then do
  if Info.II <> "//            " then do
    Info.II = Info.II","
    II       = II + 1
  end
  Info.II = "//            MAXGENS="strip(ZDSNGEN)
  kal.ka=kal.ka" +"
  ka=ka+1
  kal.ka="   MAXGENS("strip(ZDSNGEN)")"
end
ka=ka+1
kal.ka="FREE FI(ycosddn)"
/* yves */
"(CAPMODE) = CAPS"
if capmode = "ON" then
  "CAPS OFF"
do i=ka to 1 by -1
   "LINE_AFTER "start" = INFOLINE '"kal.i"'"
end
if Lcmd = "DI" then endii=1    /* 2.13 */
else                endii=ki
do i=ii to endii by -1         /* 2.13 */
   "LINE_AFTER "start" = INFOLINE '"info.i"'"
end
if capmode = "ON" then
  "CAPS ON"
/* yves
do       I = 1 to II
         Say Info.I
end
*/

Return 0

MyLdInfo:

infodsn = arg(1)
infovol = strip(arg(2),"B")                      /* Eberle 120720 */

if       Pos("(",InfoDsn) > 0 then do
         Parse Var InfoDsn InfoDsn "(" .
         if Left(InfoDsn,1) = "'" then Infodsn = InfoDsn"'"
end

/* list racf the dataset */
x=outtrap("ycos.")
address tso "listdsd dataset("infodsn") generic all dfp history"
x=outtrap("OFF")
/* yves */
"(CAPMODE) = CAPS"
if capmode = "ON" then
  "CAPS OFF"
do i=ycos.0 to 1 by -1
   "LINE_AFTER "start" = INFOLINE '"ycos.i"'"
end
if capmode = "ON" then
  "CAPS ON"
/* yves
do       I = 1 to II
         Say Info.I
end
*/
Return 0

/* hsm HLIST Command 2.12 */
MyDHInfo:
/* rexx */
/* */
Sysuid   = userid()
SysPref  = SysVar("SysPref")

if       Syspref = Sysuid then MyHlq = Syspref
                          else MyHlq = SysPref"."Sysuid

ODsn     = "'"Strip(MyHlq,"L",".")"." ||,
           "SYS"Date("J")"."       ||,
           "T"Translate(124578,Time("N"),12345678)"." ||,
           "HSMOUT'"

Numeric  Digits 10
CVT      = Storage(10,4)
DCVTHSM  = C2D(CVT)+X2D(3DC)
CVTHSM   = STORAGE(C2X(D2C(DCVTHSM)),4)
HSMASCB='00000000'x
if C2X(CVTHSM)<>"00000000" then do
  DHSMASCB = C2D(CVTHSM)+X2D(8)
  HSMASCB  = STORAGE(C2X(D2C(DHSMASCB)),4)
end
if C2X(HSMASCB)="00000000" then do
  ZedSMsg  = "HSM not active"
  ZedLMsg  = "HSM not found using CVT + 3DC + 8. Not active"
  address ispexec "SETMSG MSG(ISRZ001)"
  return
end

rx=listdsi("'"mydsn"'" "NORECALL")
if rx=16 & sysreason="0009" then hopt="BOTH"
else                             hopt="BCDS"

address tso,
"HLIST   DSNAME('"MyDsn"')" hopt" ODS("ODsn")"

if SysDsn(ODsn) <> "OK" then do
  ZedSMsg  = "HSM Error"
  ZedLMsg  = "HSM HLIST output dataset not allocated"
  address ispexec "SETMSG MSG(ISRZ001)"
  return
end
/* alloc input dataset */
call bpxwdyn "alloc da("ODsn") shr",
  "msg(ymsg1.) rtddn(ydd1)"
if result<>0 then do
  say "Alloc Input dataset error:" result
  do i=1 to ymsg1.0
    say ymsg1.i
  end
  return
end

address mvs "EXECIO  * DISKR" ydd1 "(Stem Hsm. Finis"
address tso "free fi("ydd1")"
OldMsg   = Msg("OFF")
address tso "Delete" ODsn
NewMsg   = Msg(OldMsg)

/* alloc output datasets */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(132)",
   "recfm(f,b) dsorg(ps) msg(ymsg2.) rtddn(ydd2) rtdsn(ydsn2)"
if result<>0 then do
  say "Alloc temp dataset error:" result
  do i=1 to ymsg2.0
    say ymsg2.i
  end
  exit 0
end

ol=0 /* output lines */
start=1
if hopt="BOTH" then do
  select
  when substr(hsm.1,31,8)="MIGRATED" then do
    do i=start to hsm.0 until substr(hsm.i,2,12)="DATASET NAME"
      ol=ol+1
      ot.ol=hsm.i
      if substr(hsm.i,2,23)="----- END OF - MIGRATED" then do
        i=9+hsm.0
        leave i
      end
    end
    if i>hsm.0 then do
      ol=ol+1
      ot.ol="Error" Mydsn" Migration information not found|"
      do i=start until substr(hsm.1,31,6)="BACKUP"
        ol=ol+1
        ot.ol=hsm.i
      end
      start=i
    end
    else do
      do j=i+1 until substr(hsm.j,2,23)="----- END OF - MIGRATED"
        ol=ol+1
        ot.ol=hsm.j
        if strip(substr(hsm.j,2,44))=Mydsn then do
          ol=ol+1
          ot.ol="tso HRECALL ('"mydsn"') NOWAIT"
        ol=ol+1
        ot.ol=">>>>>> Please Select the needed parameter and use 'EX'"
        ol=ol+1
        ot.ol=""
        end
      end
      start=j+1
    end
  end
  when substr(hsm.1,31,6)="BACKUP" then do
    ol=ol+1
    ot.ol="Error" Mydsn" Migration information not found|"
    ZedSMsg  = ""
    ZedLMsg  = ot.ol
    address ispexec "SETMSG MSG(ISRZ001)"
  end
  otherwise
    ol=ol+1
    ot.ol="Unknown first line in output|"
    start=i
  end
end  /* work backup */
select
when substr(hsm.start,31,6)="BACKUP" then do
  do i=start to hsm.0 until substr(hsm.i,2,14)="BACKUP VERSION"
    ol=ol+1
    ot.ol=hsm.i
    if substr(hsm.i,2,23)="----- END OF - BACKUP D" then do
      i=9+hsm.0
      leave i
    end
  end
  if i>hsm.0 then do
    ol=ol+1
    ot.ol="Error" Mydsn" Backup information not found|"
    ZedSMsg  = ""
    ZedLMsg  = ot.ol
    address ispexec "SETMSG MSG(ISRZ001)"
  end
  else do
    do j=i+1 until substr(hsm.j,2,23)="----- END OF - BACKUP D"
      ol=ol+1
      ot.ol=hsm.j
      if substr(hsm.j,63,1)="/" then do   /* date */
        Parse Var hsm.j hsmbdsn . . . . . . hsmbvers .
        ol=ol+1
        ot.ol="tso HRECOVER ('"Mydsn"') VERSION("hsmbvers") +"
        ol=ol+1
        ot.ol="    REPLACE +"
        ol=ol+1
        ot.ol="    NEWNAME('"strip(mydsn,"B","'")".???.???')"
        ol=ol+1
        ot.ol=">>>>>> Please Select the needed parameter and use 'EX'"
        ol=ol+1
        ot.ol=""
      end
    end
    start=j
  end
end
otherwise
  ol=ol+1
  ot.ol="Unknown first line in output|"
  do i=start to hsm.0
    ol=ol+1
    ot.ol=hsm.i
  end
  start=i
end
/* write the data */
address mvs "execio "ol" diskw "ydd2" (stem ot. finis"
/* show the result */
address ispexec "lminit dataid(myou) ddname("ydd2")"
address ispexec "edit dataid("myou")"ed_parms
address ispexec "lmfree dataid("myou")"
address tso "free fi("ydd2")"

exit

MyDsCat:

infodsn = arg(1)
infovol = strip(arg(2),"B")                        /* Eberle 120720 */

if       Pos("(",InfoDsn) > 0 then do
         Parse Var InfoDsn InfoDsn "(" .
         if Left(InfoDsn,1) = "'" then Infodsn = InfoDsn"'"
end

/* alloc output datasets */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(121)",
   "recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)"
if result<>0 then do
  say "Alloc temp dataset error:" result
  do i=1 to ymsg1.0
    say ymsg1.i
  end
  "Cursor = "curline curcol                           /* 2.12 HUK */
  exit 0
end
/* listcat the dataset */
x=outtrap("ycos.")
address tso "listc ent("infodsn") all"
x=outtrap("OFF")

/* create info line */
info.1="YCOS LISTCAT:" translate(strip(infodsn)) date("E") time()
info.2=copies("-",121)
address mvs "execio 2 diskw "ydd1" (stem info."
/* write the Listcat data */
address mvs "execio "ycos.0" diskw "ydd1" (stem ycos. finis"
/* show the result */
address ispexec "lminit dataid(myou) ddname("ydd1")"
address ispexec "edit dataid("myou")"ed_parms          /* 2.10 */
address ispexec "lmfree dataid("myou")"
msgset=msg('OFF')
address tso "free fi("ydd1")"
msgset=msg(msgset)
"cursor ="curline curcol                                        /* 2.12 HUK */

Exit 0

FormDate:

if mylang="ENU" then Return Arg(1)
if       Pos("/",Arg(1)) = 0 then Return Arg(1)
Return   SubStr(Arg(1),9,2)"."SubStr(Arg(1),6,2)"."SubStr(Arg(1),1,4)

Edit:

EditT    = Arg(1)
EditN    = Length(EditT)
EditR    = ""
EditP    = 0

do       forever
         if EditN = 0 then leave
         if SubStr(EditT,EditN,1) <> "," then do
            EditR = SubStr(EditT,EditN,1)""EditR
            EditP = EditP + 1
            if EditP // 3 = 0 then EditR = "."EditR
         end
         EditN = EditN - 1
end

return   Strip(EditR,"L",".")

help:

prm = arg(1)  /* 2.9 */

help_V:       /* 2.16 */

/* Comment Start
Address  TSO "CLEAR"
   Comment End */
if prm <> "OUTSIDE" then do  /* 2.9 */
  wo=start+1
  "(CAPMODE) = CAPS"
  if capmode = "ON" then
    "CAPS OFF"
end
address TSO NEWSTACK
call "YCLMAHLP"
do cnt=1 to queued()
   parse pull msg
   if prm = "OUTSIDE" then do  /* 2.9 */
     m.cnt=Msg
   end
   else do
     "LINE_BEFORE" wo" = INFOLINE '"msg"'"
     if rc<>0 then do
       ZedSMsg = ""
       ZedLMsg = "display of help not possible"
       Address ISPEXEC 'SETMSG MSG(ISRZ001)'
       leave cnt
     end
   end
end
address TSO DELSTACK
if prm = "OUTSIDE" then do  /* 2.9 */
  /* alloc output datasets */
  call bpxwdyn "alloc space(15,15) tracks new delete lrecl(80)",
     "recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)"
  if result<>0 then do
    say "Alloc temp dataset error:" result
    do i=1 to ymsg1.0
      say ymsg1.i
    end
    do i=1 to cnt-1
      say m.i
    end
    exit 0
  end
  /* write the data */
  address mvs "execio "cnt-1" diskw "ydd1" (stem m. finis"
  /* show the result */
  address ispexec "lminit dataid(myou) ddname("ydd1")"
  address ispexec "edit dataid("myou")"ed_parms          /* 2.10 */
  address ispexec "lmfree dataid("myou")"
  msgset=msg('OFF')
  address tso "free fi("ydd1")"
  msgset=msg(msgset)
end
else do
  if capmode = "ON" then
    "CAPS ON"
  if curline - 1 <> 0 then "cursor = "curline - 1" 0" /*Eberle 120801*/
end
exit     0


ex_tso:
/* run a command         */
/* - tso (default)       */
/* - sdsf                */
/* - ejes      2.8       */
/* - unix und unixsu     */
/* - udlist    2.8       */
/* - ufdir     2.8       */
/* - uffil     2.9       */
/* - unixenv   2.11      */
/* - unixsuenv 2.11      */
/* - ing       2.19      */
/* - ispf      2.19      */
parse var line cmdtype lrest /* check command type        */
cmdtype=translate(strip(cmdtype))
select
when cmdtype="SDSF" then do
  line=lrest
  call ex_sdsf "SDSF"
  return
end
when cmdtype="EJES" then do
  line=lrest
  call ex_sdsf "EJES"
  return
end
when cmdtype="UNIX" then do
  line=lrest
  call ex_unix
  return
end
when cmdtype="UNIXSU" then do
  line=lrest
  call ex_unix "SU"
  return
end
when cmdtype="UNIXENV" then do                          /* 2.11 */
  line=lrest                                            /* 2.11 */
  usren="ENV"                                           /* 2.11 */
  call ex_unix                                          /* 2.11 */
  return                                                /* 2.11 */
end                                                     /* 2.11 */
when cmdtype="UNIXSUENV" then do                        /* 2.11 */
  line=lrest                                            /* 2.11 */
  usren="ENV"                                           /* 2.11 */
  call ex_unix "SU"                                     /* 2.11 */
  return                                                /* 2.11 */
end                                                     /* 2.11 */
when cmdtype="ING" then do                              /* 2.19 */
  line=lrest                                            /* 2.19 */
  call ex_ING                                           /* 2.19 */
  return                                                /* 2.19 */
end                                                     /* 2.19 */
when cmdtype="ISPF" then do                             /* 2.19 */
  line=lrest                                            /* 2.19 */
  call ex_ISPF                                          /* 2.19 */
  return                                                /* 2.19 */
end                                                     /* 2.19 */
when cmdtype="UDLIST" then do    /* 2.8 */
  line=lrest
  call ex_udlist
  return
end
when cmdtype="UFDIR"  then do    /* 2.8 */
  line=lrest
  call ex_ufdir
  return
end
when cmdtype="UFFIL"  then do    /* 2.9 */
  line=lrest
  call ex_uffil
  return
end
when cmdtype="TSO" then do
  line=lrest
end
otherwise
  nop
end
/* end */
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
   j=j+1
   if j>lli then do
     say "Continuation error"
     return
   end
   "(CLINE) = LINE "j     /* Get line value                  */
   line=strip(strip(line),"T",right(strip(line),1)) strip(cline)
end
ext_tso_ex:   /* 2.9 */
/* alloc output datasets */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(121)",
   "recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)"
if result<>0 then do
  say "Alloc temp dataset error:" result
  do i=1 to ymsg1.0
    say ymsg1.i
  end
  exit 0
end
/* execute the command */
x=outtrap("ycos.")
address tso strip(line)
saverc=rc
x=outtrap("OFF")

if ycos.0 > 0 then do
  /* create info line */
  info.1="YCOS CMD:" strip(line) date("E") time() "RC="saverc
  info.2=copies("-",121)
  if  rc_ext > 0 then do  /* 2.14 */
    do l3=1 to ycos.0
      say ycos.l3
    end
  end
  else do
    address mvs "execio 2 diskw "ydd1" (stem info."
    /* write the data */
    address mvs "execio "ycos.0" diskw "ydd1" (stem ycos. finis"
    /* show the result */
    address ispexec "lminit dataid(myou) ddname("ydd1")"
    address ispexec "edit dataid("myou")"ed_parms          /* 2.10 */
    address ispexec "lmfree dataid("myou")"
  end
end
else do
  ZedSMsg = ""
  ZedLMsg = "YCOS CMD:" strip(line) date("E") time() "RC="saverc
  Address ISPEXEC 'SETMSG MSG(ISRZ001)'
end
msgset=msg('OFF')
address tso "free fi("ydd1")"
msgset=msg(msgset)
return

/* */
/* yves */
ylang: procedure
Numeric  Digits 10                      /*Allow for big addresses    */
TCBAddr  = C2D(       Storage(D2X(540                 ),  4) )
JSCBAddr = C2D(       Storage(D2X(TCBAddr  +       180),  4) )
PSCBAddr = C2D(       Storage(D2X(JSCBAddr +       264),  4) )
UPTAddr  = C2D(       Storage(D2X(PSCBAddr +        52),  4) )
Upt      = Storage(D2X(UptAddr),176)
PLang    = SubStr(Upt,25,3)
return plang

/* 2.12 */
JCL_UP: procedure expose jcl_hyph jcl_if
/* Parm1 = Line      */
/* Parm2 = Length    */
/* */
p1=arg(1)
p2=arg(2)
info=p1
jclstm1="/CNTL/ENDCNTL/ELSE/ENDIF/PEND/EXPORT/"
jclstm2="/COMMAND/DD/EXEC/INCLUDE/JCLLIB/JOB/OUTPUT/PROC/SET/XMIT/"
/* 2.21 */
jclstm2=jclstm2"/EXPORT/JOBGROUP/GJOB/JOBSET/SJOB/ENDSET/ENDGROUP/"
jclstm2=jclstm2"/BEFORE/AFTER/CONCURRENT/SCHEDULE/"
jclstm3="/IF/NOTIFY/"
select
when p1="//" then do    /* 2.14 job end */
  jcl_if  ="N"
  jcl_hyph="N"
end
when left(p1,3)="//*" then do
  jcl_if  ="N"
  jcl_hyph="N"
end
when left(p1,2)<>"//" then do
  jcl_if  ="N"
  jcl_hyph="N"
end
otherwise
  if substr(p1,3,1)=" " then do
    parse var p1 "//" jcl com rest .
    label=""
    stmt =""
    jcu=translate(strip(jcl))
    select  /* //   jcl comment      */
    when pos("/"jcu"/",jclstm1)>0 then do
      wo=pos(jcl,p1)
      info=overlay(jcu,info,wo,length(jcu))
    end     /* //   jcl stmt comment */
    when pos("/"jcu"/",jclstm2)>0 then do
      wo=pos(jcl,p1)
      info=overlay(jcu,info,wo,length(jcu))
      wo=pos(" "com,p1,wo)
      if pos("'",com)=0 & pos('"',com)=0 then do     /* 2.14 */
        com=translate(com)
      end
      else do
        ph1=pos("'",com)              /* 2.14 */
        if ph1=0 then ph1=999         /* 2.14 */
        ph2=pos('"',com)              /* 2.14 */
        if ph2=0 then ph2=999         /* 2.14 */
        if ph1>0 & ph1<ph2 then do    /* 2.14 */
          com=chk_jclu(com,"'")       /* 2.14 */
        end                           /* 2.14 */
        else do                       /* 2.14 */
          com=chk_jclu(com,'"')       /* 2.14 */
        end
      end
      info=overlay(" "com,info,wo,length(com)+1)
    end     /* //   jcl stmt1 stmt2 comment */
    when pos("/"jcu"/",jclstm3)>0 then do
      wo= pos(" THEN ",translate(p1))
      if wo>0 then do
        jcu=translate(left(p1,wo+5))
        info=overlay(jcu,info,1)
      end
      else do
        info=translate(info)
        jcl_if  ="Y"
      end
    end
    otherwise /* continuation */
      select
      when jcl_if  ="Y" then do
        wo= pos(" THEN ",translate(p1))
        if wo>0 then do
          jcu=translate(left(p1,wo+5))
          info=overlay(jcu,info,1)
          jcl_if  ="N"
        end
        else do
          info=translate(info)
        end
      end
      when jcl_hyph="Y" then do
        if pos("'",p1)=0 & pos('"',p1)=0 then do      /* 2.14 */
          nop
        end
        else do
          ph1=pos("'",p1)               /* 2.14 */
          if ph1=0 then ph1=999         /* 2.14 */
          ph2=pos('"',p1)               /* 2.14 */
          if ph2=0 then ph2=999         /* 2.14 */
          if ph1>0 & ph1<ph2 then do                  /* 2.14 */
            wo=ph1                                    /* 2.14 */
            wo=pos(" ",p1,wo)                         /* 2.14 */
            com=chk_jclu(left(p1,wo),"'")             /* 2.14 */
            info=overlay(com,info,1)                  /* 2.14 */
          end                                         /* 2.14 */
          else do                                     /* 2.14 */
            wo=ph2                                    /* 2.14 */
            wo=pos(" ",p1,wo)                         /* 2.14 */
            com=chk_jclu(left(p1,wo),'"')             /* 2.14 */
            info=overlay(com,info,1)                  /* 2.14 */
          end                                         /* 2.14 */
        end
      end
      otherwise /* continuation - no if and no ' */
        ph1=pos("'",p1)                               /* 2.21 */
        if ph1=0 then ph1=999                         /* 2.21 */
        ph2=pos('"',p1)                               /* 2.21 */
        if ph2=0 then ph2=999                         /* 2.21 */
        if ph1>0 & ph1<ph2 then do                    /* 2.21 */
          wo=ph1                                      /* 2.21 */
          wo=pos(" ",p1,wo)                           /* 2.21 */
          com=chk_jclu(left(p1,wo),"'")               /* 2.21 */
          info=overlay(com,info,1)                    /* 2.21 */
        end                                           /* 2.21 */
        else do                                       /* 2.21 */
          wo=ph2                                      /* 2.21 */
          wo=pos(" ",p1,wo)                           /* 2.21 */
          com=chk_jclu(left(p1,wo),'"')               /* 2.21 */
          info=overlay(com,info,1)                    /* 2.21 */
        end                                           /* 2.21 */
      end
    end
  end
  else do
    parse var p1 "//" label jcl stmt comment
    info=overlay(translate(label),info,3)
    jcu=translate(strip(jcl))
    wo=pos(jcl,p1)
    info=overlay(translate(jcl),info,wo)
    select  /* //lab   jcl comment      */
    when pos("/"jcu"/",jclstm1)>0 then do
      nop
    end     /* //lab   jcl stmt comment */
    when pos("/"jcu"/",jclstm2)>0 then do
      wo=pos(" "stmt,p1)
      stmt=chk_jclu(stmt)
      info=overlay(stmt,info,wo+1)
    end     /* //lab   jcl stmt1 stmt2 comment */
    when pos("/"jcu"/",jclstm3)>0 then do
      wo= pos(" THEN ",translate(p1))
      if wo>0 then do
        jcu=translate(left(p1,wo+5))
        info=overlay(jcu,info,1)
      end
      else do
        info=translate(info)
        jcl_if  ="Y"
      end
    end     /* //lab   jcl stmt1 stmt2 comment */
    otherwise /* continuation */
      info=info
    end
  end
end
return info
/* 2.12 */
CHK_JCLU: procedure expose jcl_cont jcl_hyph
p1=arg(1)
p2=arg(2)             /* 2.14 */
start=1
if p2="" then do                /* 2.14 */
  if pos("'",p1)>0 then do      /* 2.14 */
    p2="'"                      /* 2.14 */
    stop=pos(p2,p1)             /* 2.14 */
  end                           /* 2.14 */
  else do                       /* 2.14 */
    if pos('"',p1)>0 then do    /* 2.14 */
      p2='"'                    /* 2.14 */
      stop=pos(p2,p1)           /* 2.14 */
    end                         /* 2.14 */
    else do                     /* 2.14 */
      stop=0                    /* 2.14 */
    end                         /* 2.14 */
  end                           /* 2.14 */
end                             /* 2.14 */
else do                         /* 2.14 */
  stop=pos(p2,p1)               /* 2.14 */
end                             /* 2.14 */
do while stop>0
  if jcl_hyph="N" then do
    p1=overlay(translate(substr(p1,start,stop-start+1)),p1,start)
    jcl_hyph="Y"
  end
  else do
    jcl_hyph="N"
  end
  start=stop+1
  stop=pos(p2,p1,start)   /* 2.14 */
end
if jcl_hyph="N" & start<>length(p1) then do
  p1=overlay(translate(substr(p1,start)),p1,start)
end

return p1

ASCEBC: procedure
/* Parm1 = Line      */
/* Parm2 = Length    */
/* Parm3 = E - Convert to Ebcdic */
/*       = A - Convert to Ascii  */

tabas =        '000102039C09867F978D8E0B0C0D0E0F'x      /* 00 */
tabas = tabas||'101112139D8508871819928F1C1D1E1F'x      /* 10 */
tabas = tabas||'80818283840A171B88898A8B8C050607'x      /* 20 */
tabas = tabas||'909116939495960498999A9B14159E1A'x      /* 30 */
tabas = tabas||'20A0E2E4E0E1E3E5E7F1A22E3C282B7C'x      /* 40 */
tabas = tabas||'26E9EAEBE8EDEEEFECDF21242A293B5E'x      /* 50 */
tabas = tabas||'2D2FC2C4C0C1C3C5C7D1A62C255F3E3F'x      /* 60 */
tabas = tabas||'F8C9CACBC8CDCECFCC603A2340273D22'x      /* 70 */
tabas = tabas||'D8616263646566676869ABBBF0FDFEB1'x      /* 80 */
tabas = tabas||'B06A6B6C6D6E6F707172AABAE6B8C6A4'x      /* 90 */
tabas = tabas||'B57E737475767778797AA1BFD05BDEAE'x      /* A0 */
tabas = tabas||'ACA3A5B7A9A7B6BCBDBEDDA8AF5DB4D7'x      /* B0 */
tabas = tabas||'7B414243444546474849ADF4F6F2F3F5'x      /* C0 */
tabas = tabas||'7D4A4B4C4D4E4F505152B9FBFCF9FAFF'x      /* D0 */
tabas = tabas||'5CF7535455565758595AB2D4D6D2D3D5'x      /* E0 */
tabas = tabas||'30313233343536373839B3DBDCD9DA9F'x      /* F0 */

hextable =             '000102030405060708090A0B0C0D0E0F'x   /* 00 */
hextable = hextable || '101112131415161718191A1B1C1D1E1F'x   /* 10 */
hextable = hextable || '202122232425262728292A2B2C2D2E2F'x   /* 20 */
hextable = hextable || '303132333435363738393A3B3C3D3E3F'x   /* 30 */
hextable = hextable || '404142434445464748494A4B4C4D4E4F'x   /* 40 */
hextable = hextable || '505152535455565758595A5B5C5D5E5F'x   /* 50 */
hextable = hextable || '606162636465666768696A6B6C6D6E6F'x   /* 60 */
hextable = hextable || '707172737475767778797A7B7C7D7E7F'x   /* 70 */
hextable = hextable || '808182838485868788898A8B8C8D8E8F'x   /* 80 */
hextable = hextable || '909192939495969798999A9B9C9D9E9F'x   /* 90 */
hextable = hextable || 'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'x   /* A0 */
hextable = hextable || 'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'x   /* B0 */
hextable = hextable || 'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'x   /* C0 */
hextable = hextable || 'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'x   /* D0 */
hextable = hextable || 'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'x   /* E0 */
hextable = hextable || 'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'x   /* F0 */

if arg(3)="E" then do
  info=translate(left(arg(1),arg(2)),hextable,tabas)
end
else do
  info=translate(left(arg(1),arg(2)),tabas,hextable)
end
return info

check_ext_macro: procedure
arg ddname member
address "ISPEXEC"
/* 2.18 */
ckmac_found = 0
"QBASELIB "ddname" ID(ckmac)"
ckmac = translate(ckmac,,',')
do ckmac_I = 1 to words(ckmac) until ckmac_found
   "LMInit DataID(did) Dataset("word(ckmac,ckmac_I)") ENQ(SHR)"
   "LMOpen DataID("did")"
   "LMMFind DataID("did") Member("member")"
   ret_cde = RC
   if ret_cde = 0 then ckmac_found = 1
/* 2.18 */
   "LMClose DataID("did")"
   "LMFree  DataID("did")"
end
Return ret_cde

/* */
/* 2.60 */
ex_sdsf:
/* run command within SDSF */
/*          or within EJES */
world_cmd=arg(1)
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))""strip(cline)
end
ext_sdsf_ex:   /* 2.9 */
/* alloc output datasets */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(121)",
   "recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)"
if result<>0 then do
  say "Alloc temp dataset error:" result
  do i=1 to ymsg1.0
    say ymsg1.i
  end
  exit 0
end
/* execute the command */

lc=1
line=strip(line)
yc.lc="Executing:" line
lc=2
yc.lc=copies("-",121)
lc=3
yc.lc=" "

if world_cmd="SDSF" then do
  rc=isfcalls('ON')
  /* Comment Start                                        /* 2.10 */
  line="'"line"'"                                         /* 2.10 */
     Comment End */                                       /* 2.10 */
end
else do
  rc=ejesisfx('ON')
end
if rc<>0 then do
  lc=lc+1
  if world_cmd="SDSF" then do
    yc.lc="Error on ISFCALLS('ON') - RC:"rc
  end
  else do
    yc.lc="Error on EJESISFX('ON') - RC:"rc
  end
end
else do
     /************************************/
     /* Set console name                 */
     /************************************/
  isfcons =userid()"Y"
  if pos("'",line)>0 then do                              /* 2.10 */
    wo=pos("'",line)                                      /* 2.10 */
    do while wo>0                                         /* 2.10 */
      line=left(line,wo)"'"substr(line,wo+1)              /* 2.10 */
      wo=pos("'",line,wo+2)                               /* 2.10 */
    end                                                   /* 2.10 */
  end                                                     /* 2.10 */
  Address SDSF "ISFEXEC '/"line"' (WAIT)"                 /* 2.10 */
  lrc=rc
  if lrc<>0 then do
    if isfmsg<>"" then do
      lc=lc+1
      yc.lc="Error on ISFEXEC - RC:"lrc
      lc=lc+1
      yc.lc="isfmsg is:" isfmsg
         /****************************************************/
         /* The isfmsg2 stem contains additional descriptive */
         /* error messages                                   */
         /****************************************************/
    end
    do ix=1 to isfmsg2.0
      lc=lc+1
      yc.lc="isfmsg2."ix "is:" isfmsg2.ix
    end
  end
  else do

    if isfresp.0>0 then do
      yc.2=overlay(" "isfresp.0" Lines of responses ",yc.2,5)
         /**************************************************/
         /* The responses are returned in the isfresp stem */
         /**************************************************/
      do ix=1 to isfresp.0
        lc=lc+1
        yc.lc=isfresp.ix
      end
    end

    if isfulog.0>0 then do
      lc=lc+1
      yc.lc=overlay(" "isfulog.0" Lines of output ",copies("=",121),5)

       /**************************************************/
       /* The Message   are returned in the isfulog stem */
       /**************************************************/
      do ix=1 to isfulog.0
        lc=lc+1
        yc.lc=isfulog.ix
      end
    end
  end
end

if world_cmd="SDSF" then do
  rc=isfcalls('OFF')
end
else do
  rc=ejesisfx('OFF')
end

if SYSVAR("SYSENV")="FORE" then do  /* 2.14 */
  /* write the data */
  address mvs "execio "lc" diskw "ydd1" (stem yc. finis"
  /* show the result */
  address ispexec "lminit dataid(myou) ddname("ydd1")"
  address ispexec "edit dataid("myou")"ed_parms          /* 2.10 */
  address ispexec "lmfree dataid("myou")"
  address tso "free fi("ydd1")"
end                                 /* 2.14 */
else do                             /* 2.14 */
  do j=1 to lc                      /* 2.14 */
    say yc.j                        /* 2.14 */
  end                               /* 2.14 */
end                                 /* 2.14 */

return

/* */
/* 2.19 */
ex_ING:
/* run command for SA System automation */
world_cmd=arg(1)
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))""strip(cline)
end
ext_ING_EX:
/* 2.21 */
SaLib="SYS1.ING.SINGTREX"
if sysdsn("'"SaLib"'")<>"OK" then do
  "%YCINGCUS"
  if rc=0 then pull SaLib
  else do
    ZedSMsg = "See YCLMACRX DOC"
    ZedLMsg = "You HAVE to crate an own YCINGCUS rexx to set the name",
              "of you System Automation Rexx"
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    exit
  end
end
  /* */
  /* */
/* */
/* alloc output datasets */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(4096)",
   "recfm(v,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)"
if result<>0 then do
  say "Alloc temp dataset error:" result
  do i=1 to ymsg1.0
    say ymsg1.i
  end
  exit 0
end
/* alloc SYSIN dataset */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(80)",
   "recfm(f,b) dsorg(ps) msg(ymsg2.) rtddn(ydd2) rtdsn(ydsn2)"
if result<>0 then do
  say "Alloc sysin dataset error:" result
  do i=1 to ymsg2.0
    say ymsg2.i
  end
  exit 0
end
/* write command to sysin */
/* including redirection  */
l.1=strip(line) ">"ydd1
address mvs "execio 1 diskw "ydd2" (stem l. finis"
/* outtrap the infos */
x=outtrap("YCOS.")
/* execute the command */
address tso,
          "EX '"SaLib"(AOFRYCMD)'",
          "'SERVER=* HIGHRC=00 MAXRC=00 SYSIN="ydd2"'"
/*                                     .-SERVER--=--EVJCMDRV-.       */
/* >>-AOFRYCMD--+------+--+---------+--+---------------------+-----> */
/*              '-wsid-'  '-NOWKSTS-'  '-SERVER--=--+-name-+-'       */
/*                                                  '-*----'         */
/*    .-TIMEOUT--=--60------.  .-HIGHRC--=--0-----------.            */
/* >--+---------------------+--+------------------------+----------> */
/*    +-TIMEOUT--=--seconds-+  '-HIGHRC--=--return_code-'            */
/*    '-TIMEOUT--=--NONE----'                                        */
/*    .-MAXRC--=--999---------.  .-SYSIN--=--SYSIN--.                */
/* >--+-----------------------+--+------------------+--------------> */
/*    '-MAXRC--=--return_code-'  '-SYSIN--=--DDname-'                */
/*    .-REDIRECT--=-->-----.  .-ASIS--=--NO--.                       */
/* >--+--------------------+--+--------------+-------------------->< */
/*    '-REDIRECT--=--chars-'  '-ASIS--=--YES-'                       */
x=outtrap("Off.")
address tso "free fi("ydd2")"

if SYSVAR("SYSENV")="FORE" then do
  /* write the result */
  call bpxwdyn "alloc space(15,15) tracks new delete lrecl(4096)",
     "recfm(v,b) dsorg(ps) msg(ymsgo.) rtddn(yddo) rtdsn(ydsno)"
  if result<>0 then do
    say "Alloc temp dataset error:" result
    do i=1 to ymsgo.0
      say ymsgo.i
    end
    exit 0
  end
  address mvs "execio "ycos.0" diskw "yddo" (stem ycos."
  drop ycos.
  address mvs "execio * diskr "ydd1" (stem ycos. finis"
  address mvs "execio "ycos.0" diskw "yddo" (stem ycos. finis"
  /* show the result */
  address ispexec "lminit dataid(myou) ddname("yddo")"
  address ispexec "edit dataid("myou")"ed_parms
  address ispexec "lmfree dataid("myou")"
  address tso "free fi("yddo")"
  address tso "free fi("ydd1")"
end
else do
  do j=1 to ycos.0
    say ycos.j
  end
  address mvs "execio * diskr "ydd1" (stem yc. finis"
  address tso "free fi("ydd1")"
  do j=1 to yc.0
    say yc.j
  end
end

return
/* */
/* 2.19 */
ex_ISPF:
/* run ISPF Command                     */
/* addess ispexec ...                   */
world_cmd=arg(1)
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))" "strip(cline)
end
/* check if panel used */
/* many thanks to Gilbert Saint-Flour| (RIP) */
parse upper var line p1 "PANEL(" p2 ")"
if p1="REFRESH" & p2<>"" then do
  DO I=1 TO 30
    address ispexec,
    "DISPLAY PANEL($Y$"RIGHT(I,5,'0')
  END
  line="select panel("p2")"
end
/* run command */
address ispexec line
savrc=rc
/* rc */
if savrc<>0 then do
  ZedSMsg = ""
  ZedLMsg = "ISPF:" line "- Error:" savrc
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
end

return

/* */
/* 2.60 */
ex_unix:
usrsu=arg(1)
/* run command within Unix */
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
/* Start 2.11 new */
extra_env=0                                              /* 2.11 */
if usren="ENV" then do                                   /* 2.11 */
  if wordpos(right(strip(line),1),"+ ,")>0 then do
    nl=j+1
    "(LINE) = LINE "nl    /* Get line value              */
    if translate(left(strip(line),18))="ENV_VARIABLE_START" then do
      "(LINE) = LINE "nl+1  /* Get line value              */
      do l1=nl+2 to lli
        if translate(left(strip(line),18))="ENV_VARIABLE_END" then do
          j=l1
          l1=lli+99
        end
        else do
          extra_env=extra_env+1
          extra_var.extra_env=strip(line)
          "(LINE) = LINE "l1    /* Get line value              */
        end
      end
      "(LINE) = LINE "j     /* Get line value              */
    end
  end
end
/* End   2.11 new */
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))" "strip(cline)
end
ext_unix_ex:   /* 2.9 */
/* alloc output datasets */
call bpxwdyn "alloc space(15,15) tracks new delete lrecl(1024)",
   "recfm(f,b) dsorg(ps) msg(ymsg1.) rtddn(ydd1) rtdsn(ydsn1)"
if result<>0 then do
  say "Alloc temp dataset error:" result
  do i=1 to ymsg1.0
    say ymsg1.i
  end
  exit 0
end
/* execute the command */
/* */
if syscalls('ON')>0 then do
  say "Unix environment not possible"
  exit 8
end
address syscall 'getuid'
myuid=retval
address syscall 'geteuid'
myeuid=retval
super="0"

lc=1
line=strip(line)
yc.lc="Executing:" line
if myeuid<>0 & usrsu<>"" then do
  address syscall 'seteuid 0'
  address syscall 'geteuid'
  if retval<>0 then do
    say "Seteuid not successful - review RACF BPX.SUPERUSER"
    exit 8
  end
  address syscall 'getuid'
  myuid=retval
  address syscall 'geteuid'
  myeuid=retval
  lc=lc+1
  yc.lc="Current uid :" myuid "Current euid:" myeuid
  lc=lc+1
  yc.lc="Now running SU - Superuser"
  super="1"
end
else do
  lc=lc+1
  yc.lc="Current uid :" myuid "Current euid:" myeuid
end
lc=lc+1
yc.lc=copies("-",121)
lc=lc+1
yc.lc=" "

/* Start 2.11 new */
if usren="ENV" then do                                   /* 2.11 */
  msgs = msg('OFF')
  address tso,
  "FREE fi(STDERR, STDIN, STDOUT)"
  msgs = msg(msgs)
  /* alloc output datasets */
  call bpxwdyn "alloc space(15,15) tracks new delete lrecl(4096)",
     "fi(stdout) recfm(v,b) dsorg(ps) msg(ymsg1.)"
  if result<>0 then do
    say "Alloc STDOUT dataset error:" result
    do i=1 to ymsg1.0
      say ymsg1.i
    end
    exit 8
  end
  /* alloc dummy datasets */
  call bpxwdyn "alloc dummy",
     "fi(stdin) msg(ymsg1.)"
  if result<>0 then do
    say "Alloc STDIN DUMMY error:" result
    do i=1 to ymsg1.0
      say ymsg1.i
    end
    exit 8
  end
  call bpxwdyn "alloc space(15,15) tracks new delete lrecl(4096)",
     "fi(stderr) recfm(v,b) dsorg(ps) msg(ymsg1.)"
  if result<>0 then do
    say "Alloc STDERR dataset error:" result
    do i=1 to ymsg1.0
      say ymsg1.i
    end
    exit 8
  end
  /****************************************************/
  /* Invoke shell by calling BPXBATCH                 */
  /****************************************************/
  address tso,
  "BPXBATCH SH echo YENV Results;env"

  IF RC <> 0 Then Do
    Say ' YEND RC = ' RC
    Say ' '
    IF RC > 255 Then Do
      Say ' YEND Exit Status = ' RC/256
      Say ' '
    End
    address mvs,
    "EXECIO * DISKR STDERR (stem e. finis"
    say "STDERR:"
    do i=1 to e.0
      say e.i
    end
    exit 8
  End
  address mvs,
  "EXECIO * DISKR STDOUT (stem l. finis"
  yenv.0=0
  do i=1 until left(l.i,12)="YENV Results"
  end
  do i=i+1 to l.0
    yenv.0=yenv.0+1
    j=yenv.0
    yenv.j=l.i
  end
  if extra_env>0 then do
    do l1=1 to extra_env
      yenv.0=yenv.0+1
      j=yenv.0
      yenv.j=extra_var.l1
    end
  end
  address tso,
  "FREE fi(STDERR, STDIN, STDOUT)"
end
else do
  yenv.0=0
end
/*   End 2.11 new */

address sh
retc=bpxwunix(line,,out.,err.,yenv.)
if retc=0 then do
  lc=lc+1
  yc.lc="Run with following "out.0" response(s)"
  do j=1 to out.0
    lc=lc+1
    yc.lc=out.j
  end
  lc=lc+1
  yc.lc=""
end
else do
  lc=lc+1
  yc.lc="Run with following retc:" retc "and" err.0 "message(s)"
  do j=1 to err.0
    lc=lc+1
    yc.lc=err.j
  end
  do j=1 to out.0
    lc=lc+1
    yc.lc=out.j
  end
  lc=lc+1
  yc.lc=""
end
/* */
if super=1 then do
  address syscall 'seteuid' myuid
end

rc=syscalls('OFF')

/* Start 2.11 new */
if usren="ENV" then do                                   /* 2.11 */
  if yenv.0>0 then do
    lc=lc+1
    yc.lc=""
    lc=lc+1
    yc.lc=copies("=",72)
    lc=lc+1
    yc.lc=yenv.0 "Environment variable(s) used:"
    lc=lc+1
    yc.lc=copies("=",72)
    do k=1 to yenv.0
      lc=lc+1
      yc.lc=yenv.k
    end
  end
end
/*   End 2.11 new */

if  rc_ext > 0 then do  /* 2.14 */
  do l3=1 to lc
    say yc.l3
  end
end
else do
  /* write the data */
  address mvs "execio "lc" diskw "ydd1" (stem yc. finis"
  /* show the result */
  address ispexec "lminit dataid(myou) ddname("ydd1")"
  address ispexec "edit dataid("myou")"ed_parms          /* 2.10 */
  address ispexec "lmfree dataid("myou")"
  address tso "free fi("ydd1")"
end

return

/* */
/* 2.80 */
ex_udlist:
/* show a Unix dir with UDLIST 3.17 */
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))""strip(cline)
end
ext_udlist_ex:   /* 2.9 */
/* show the file/dir */
address ispexec,
"VGET ZULWFNMC"    /* size of filename on display */
sav_zfsz=ZULWFNMC
ZULWFNMC=40
address ispexec,
"VPUT ZULWFNMC"
/* */
address ispexec,
"DIRLIST PATH(LINE)"
if rc>0 then do   /* 2.13 */
  ZedSMsg = ZERRSM
  ZedLMsg = ZERRLM
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
end
/* */
ZULWFNMC=sav_zfsz
address ispexec,
"VPUT ZULWFNMC"    /* size of filename on display */
/* */

return
/* */
/* 2.80 */
ex_ufdir:
/* show all Unix dirs with UDLIST 3.17 containing a string */
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))" "strip(cline)
end
ext_ufdir_ex:   /* 2.9 */
/*====================================================================*/
/* Parameter                                                          */
/*  - dir      path to be searched                                    */
/*  - dirname  searched directory names                               */
/*====================================================================*/
parse var line dir dirname
dir=strip(dir)
dirname=strip(dirname)
if dirname="" then do
  say "Not enough parms: dir dirname"
  return
end
/* */
/* write user dslist table: isrplist          */
/* */
/* */
/* open output private table */
/* */
  address ispexec,
  "TBOPEN ISRPLIST WRITE SHARE"
  If rc Â¬= 0 Then               /* Return codes                     */
    Do                          /*  8 - Table does not exist        */
       say "TBOPEN Problem ISRPLIST" rc
       exit
    End                         /* 12 - Table in use; enq failed    */
                                /* 16 - Input library not allocated */
                                /* 20 - Severe error                */

  zcurtb="YYYYMUSS"
  address ispexec,
  "TBTOP ISRPLIST"
  address ispexec,
  "TBSCAN ISRPLIST ARGLIST(ZCURTB) NOREAD"
  If rc = 0 Then do          /* Return codes                      */
                             /* 0  - Row found                    */
/* */
/* delete  row in private table */
/* */
     address ispexec,
     "TBDELETE ISRPLIST"
  end
  DSADESCP="Temp USS List"
  do loop1=1 to 30
    interpret "DSAPET"right(loop1,2,"0")"=''"
  end

call bpxwunix "find "dir" -type d -name '"dirname"'",,out.
do loop1=1 to out.0
  if loop1>30 then do
    say "Too much directory matches:" out.0 "Only first 30 will be",
      "displayed|"
    loop1=out.0+99
  end
  else do
    interpret "DSAPET"right(loop1,2,"0")"='"strip(out.loop1)"'"
  end
end
if out.0>0 then do
/* */
/* add row in private table */
/* */
   address ispexec,
   "TBADD ISRPLIST"
   address ispexec,
   "TBSORT ISRPLIST FIELDS(ZCURTB)"
End
/* */
/* */
/* close all */
/* */
 address ispexec,
 "TBCLOSE ISRPLIST"
/* */
if out.0>0 then do
  zedsmsg=''
  zedlmsg=format(out.0,9) "directories with name:" dirname "found",
          "from dir" dir
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
  address ispexec,
  "SELECT PGM(ISRDSLST) PARM(UDL YYYYMUSS)"
End
else do
  zedsmsg=''
  zedlmsg="No directories with name:" dirname "found",
          "from dir" dir
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
End
/* */

return
/* */
/* 2.90 */
ex_uffil:
/* show all Unix dirs with UDLIST 3.17 containing a file */
"ISREDIT (LLI) = LINENUM .ZLAST"
j=start
do while wordpos(right(strip(line),1),"+ ,")>0
  j=j+1
  if j>lli then do
    say "Continuation error"
    return
  end
  "(CLINE) = LINE "j     /* Get line value                  */
  line=strip(strip(strip(line),"T",right(strip(line),1)))" "strip(cline)
end
ext_uffil_ex:   /* 2.9 */
/*====================================================================*/
/* Parameter                                                          */
/*  - dir      path to be searched                                    */
/*  - filename searched file names                                    */
/*====================================================================*/
parse var line dir filename
dir=strip(dir)
filename=strip(filename)
if filename="" then do
  say "Not enough parms: dir filename"
  return
end
/* */
/* write user dslist table: isrplist          */
/* */
/* */
/* open output private table */
/* */
  address ispexec,
  "TBOPEN ISRPLIST WRITE SHARE"
  If rc Â¬= 0 Then               /* Return codes                     */
    Do                          /*  8 - Table does not exist        */
       say "TBOPEN Problem ISRPLIST" rc
       exit
    End                         /* 12 - Table in use; enq failed    */
                                /* 16 - Input library not allocated */
                                /* 20 - Severe error                */

  zcurtb="YYYYMUSS"
  address ispexec,
  "TBTOP ISRPLIST"
  address ispexec,
  "TBSCAN ISRPLIST ARGLIST(ZCURTB) NOREAD"
  If rc = 0 Then do          /* Return codes                      */
                             /* 0  - Row found                    */
/* */
/* delete  row in private table */
/* */
     address ispexec,
     "TBDELETE ISRPLIST"
  end
  DSADESCP="Temp USS List"
  do loop1=1 to 30
    interpret "DSAPET"right(loop1,2,"0")"=''"
  end

anzdir=0
call bpxwunix "find "dir" -type f -name '"filename"'",,out.
do loop1=1 to out.0
  parse value reverse(out.loop1) with "/" cpath
  cpath=reverse(cpath)
  fnd="N"
  do loop2=1 to anzdir
    if cpath=dirf.loop2 then do
      fnd="Y"
      dirc.loop2=dirc.loop2+1
      leave loop2
    end
  end
  if fnd="N" then do
    anzdir=anzdir+1
    dirf.anzdir=cpath
    dirc.anzdir=1
  end
  if loop1>30 then do
    say "Too much matches - Only first 30 will be",
      "displayed|"
    loop1=out.0+99
  end
  else do
    interpret "DSAPET"right(loop1,2,"0")"='"strip(out.loop1)"'"
  end
end
if out.0>0 then do
/* */
/* add row in private table */
/* */
   address ispexec,
   "TBADD ISRPLIST"
   address ispexec,
   "TBSORT ISRPLIST FIELDS(ZCURTB)"
End
/* */
/* */
/* close all */
/* */
 address ispexec,
 "TBCLOSE ISRPLIST"
/* */
if out.0>0 then do
  zedsmsg=''
  zedlmsg=out.0 "files with name:" filename "found in "anzdir,
          "directories, searching from" dir
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
  address ispexec,
  "SELECT PGM(ISRDSLST) PARM(UDL YYYYMUSS)"
End
else do
  zedsmsg=''
  zedlmsg="No files with name:" filename "found",
          "from dir" dir
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
End
/* */

return
