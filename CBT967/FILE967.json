{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013618000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2116296, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE967.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2116296, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2116296, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE967.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\"\\x10'", "DS1TRBAL": "b'D\\xcc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\r\\x00\\x06\\n\\x0f\\x00\\n\\x00#'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x14\\x01 5/\\x01 5/\\x08\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-17T00:00:00", "modifydate": "2020-12-17T08:12:14", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  967\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE967\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 52 MEMBERS COUNTED; CUMULATIVE SIZE IS 19,736 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/17/20    08:12:14    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CHANGES": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x172\\x0f\\x01 \\x19O\\x11\\x00\\x00\\xae\\x00\\x10\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-11-16T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 174, "newlines": 16, "modlines": 0, "user": "TCONLEY"}, "text": "***********************************************************************\n*                                                                     *\n*                         C H A N G E   L O G                         *\n*                         -------------------                         *\n*                                                                     *\n*    DATE      DESCRIPTION                                            *\n* ----------   ------------------------------------------------------ *\n*                                                                     *\n* 2020/07/12   V1R3 release (Total RFEs delivered to date - 22)       *\n*                                                                     *\n*              RFE 143505 - Add missing ISPF options to ISPCCONF      *\n*              RFE  42655 - ISPCCONF - Add PFKey definitions          *\n*                                                                     *\n*                  ISR@PRIM                                           *\n*                  USR@KYWD                                           *\n*                  USRCCONF                                           *\n*                  USRCCVWK                                           *\n*                  USRCMOD                                            *\n*                  USRPCONF                                           *\n*                  USRPMOD                                            *\n*                  USRPMODQ                                           *\n*                  USRPMOD1                                           *\n*                  USRPMOD2                                           *\n*                  USRPMOD3                                           *\n*                  USRPMOD4                                           *\n*                  USRUMNO2                                           *\n*                  USRUULO2                                           *\n*                  USR0Y002                                           *\n*                  USR0Y004                                           *\n*                  USR0Y007                                           *\n*                                                                     *\n*              RFE 143504 - ISPF Edit Highlighting for Google GO      *\n*                                                                     *\n*                  $HIGHLIT                                           *\n*                  ISREDDE2                                           *\n*                  UMISRHIJ                                           *\n*                  USRHILIT                                           *\n*                  USRL00                                             *\n*                                                                     *\n*              RFE 143155 - Modify SISPSAMP member ISRPXASM to add    *\n*                           missing COBOL and PL/I keywords for       *\n*                           highlighting (73 COBOL and 140 PL/I       *\n*                           keywords added)                           *\n*                                                                     *\n*                  ISRPXASM                                           *\n*                  UMISRPXJ                                           *\n*                                                                     *\n*              RFE 136261 - PDSE V2 allocated under ISPF              *\n*                                                                     *\n*                  ISRUAASE                                           *\n*                  ISRV01                                             *\n*                                                                     *\n*              RFE 132595 - VSCR for z/OS move ISPF members related   *\n*                           to SCLM from LPA to LOAD                  *\n*                                                                     *\n*                  UMISCLMJ                                           *\n*                                                                     *\n*              RFE  40668 - Prime ISRUMVC 'other dataset' field with  *\n*                           current dataset for Copy/Move             *\n*                                                                     *\n*                  ISRUMVC                                            *\n*                  UMISRVCJ                                           *\n*                                                                     *\n*              Add new doc members                                    *\n*                                                                     *\n*                  $MANHACK                                           *\n*                  $README                                            *\n*                  $USRCONF                                           *\n*                                                                     *\n*              Clean up and enhance doc members                       *\n*                                                                     *\n*                  $CHANGES                                           *\n*                  $FILE967                                           *\n*                  $ISPCMDS                                           *\n*                  $34DELET                                           *\n*                                                                     *\n*              Clean up and enhance usermods                          *\n*                                                                     *\n*                  UMISCLMJ                                           *\n*                  UMISRPDJ                                           *\n*                  UMISRPXJ                                           *\n*                  UMISRVCJ                                           *\n*                  UMUSRCFJ                                           *\n*                                                                     *\n*              Clean up and enhance usermods                          *\n*                                                                     *\n*                  BPXWISH                                            *\n*                  BPXW99                                             *\n*                  ISRUDSL0                                           *\n*                  ISRUUDL0                                           *\n*                  ISRUULP                                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* 2019/01/28   V1R2 release (Total RFEs delivered to date - 14)       *\n*                                                                     *\n*              Modify the following components to fix a bug when      *\n*              resetting UID(0) to user default UID upon exiting      *\n*              ISHELL:                                                *\n*                                                                     *\n*                  BPXWP99                                            *\n*                  BPXWISH                                            *\n*                  ISH                                                *\n*                  ISHELL                                             *\n*                  UMBPXISJ                                           *\n*                                                                     *\n*              RFE 122097 - ISPF EDIT highlighting for FORTRAN        *\n*              RFE 117386 - ISPF EDIT highlighting for SQL            *\n*              RFE  79228 - ISPF EDIT highlighting for SQL            *\n*              RFE  57717 - ISPF EDIT highlighting for SQL            *\n*              RFE  37007 - ISPF EDIT highlighting for SQL            *\n*              RFE 107568 - ISPF EDIT highlighting for CARLa          *\n*              RFE  83017 - ISPF EDIT highlighting for shell script   *\n*              RFE 139412 - ISPF EDIT highlighting for Java           *\n*              RFE  83016 - ISPF EDIT highlighting for Java           *\n*                                                                     *\n*              RFE 112741 - Simplify UNIX file access in ISPF by      *\n*                           prepending current Unix directory to      *\n*                           filename for COMPARE, COPY, CREATE,       *\n*                           and REPLACE commands (BROWSE, EDIT, and   *\n*                           VIEW require member names and continue    *\n*                           to issue \"Invalid member name\" error      *\n*                           message)                                  *\n*                                                                     *\n*                  ISREDDE2                                           *\n*                  UMISREDJ                                           *\n*                  USRHILIT                                           *\n*                  USRL00                                             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* 2018/12/24   V1R1 release (Total RFEs delivered to date - 5)        *\n*                                                                     *\n*              RFE 128561 - ISPF OPT 3.4 block delete commands should *\n*                           delete VSAM cluster, and bypass DATA and  *\n*                           INDEX components without stopping         *\n*                                                                     *\n*                  ISRUDSL0                                           *\n*                  UMISRUDJ                                           *\n*                  USRDEL34                                           *\n*                                                                     *\n*              RFE 120120 - ISPF 3.17 Should Reset UID on Exit Back   *\n*                           to User UID from SU                       *\n*              RFE 102407 - ISPF UDLIST - for reset to users default  *\n*                           UID on exit                               *\n*                                                                     *\n*                  ISRUUDL0                                           *\n*                  ISRUULP                                            *\n*                  UMISRUUJ                                           *\n*                                                                     *\n*              Add the following components to reset UID(0) to user   *\n*              default UID upon exiting ISHELL:                       *\n*                                                                     *\n*                  BPXWP99                                            *\n*                  UMBPXISJ                                           *\n*                                                                     *\n*              Modify UMISPCMJ for current ISPF FMID HIF7R02          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* 2017/11/16   V1R0 release (Total RFEs delivered to date - 2)        *\n*                                                                     *\n*              Inaugural release of CBT Usermod Collection for ISPF   *\n*              (CUCI)                                                 *\n*                                                                     *\n*              RFE 112749 - Update ISPCMDS table entries for Minimum  *\n*                           TRUNC values (e.g. UDLIST should be 3)    *\n*              RFE 112745 - Add DSL as a synonym for the DSLIST       *\n*                           command                                   *\n*                                                                     *\n*                   ISPCMDS                                           *\n*                   UMISPCMJ                                          *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FILE967": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x172\\x0f\\x01 \\x19O\\x11\\x00\\x00B\\x00\\x1b\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-11-16T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 66, "newlines": 27, "modlines": 0, "user": "TCONLEY"}, "text": "//***FILE 967 is the CBT Usermod Collection for ISPF (CUCI)         *   FILE 967\n//*                                                                 *   FILE 967\n//* Tom Conley, formerly SHARE's ISPF Advocate (now defunct), is    *   FILE 967\n//* establishing this collection to provide function that will in   *   FILE 967\n//* all likelihoood not be provided by IBM.  IBM's investment in    *   FILE 967\n//* ISPF has steadily dwindled since z/OS V2R1, while investment in *   FILE 967\n//* z/OSMF has vastly increased.  There is still a user community   *   FILE 967\n//* for ISPF that requires increased function.  The goal of this    *   FILE 967\n//* collection will be to provide that function wherever possible.  *   FILE 967\n//*                                                                 *   FILE 967\n//* Functions provided to this collection must be in a standard     *   FILE 967\n//* SMP/E usermod format.  Manual hacks will not be accepted.  It   *   FILE 967\n//* is expected that the ISPF community will provide functions to   *   FILE 967\n//* this collection with the foregoing in mind.                     *   FILE 967\n//*                                                                 *   FILE 967\n//* This collection includes the following documentation members:   *   FILE 967\n//*                                                                 *   FILE 967\n//*  $CHANGES - Change log of all changes to CUCI                   *   FILE 967\n//*  $FILE967 - This member                                         *   FILE 967\n//*  $HIGHLIT - Edit highlighting command HIGHLITE documentation    *   FILE 967\n//*  $ISPCMDS - Command abbreviation documentation                  *   FILE 967\n//*  $MANHACK - Instructions for the SMP/E-averse among us          *   FILE 967\n//*  $README  - Installation instructions for z/OS sysprogs         *   FILE 967\n//*  $USRCONF - USRCCONF documentation for settings not in ISPCCONF *   FILE 967\n//*  $34DELET - ISPF 3.4 delete documentation                       *   FILE 967\n//*                                                                 *   FILE 967\n//* The following list of members is followed by a short            *   FILE 967\n//* description to show you the ISPF usermods supported by the      *   FILE 967\n//* CBT Usermod Collection for ISPF.                                *   FILE 967\n//*                                                                 *   FILE 967\n//*  BPXWISH  - ISHELL exec to reset UID(0) to user's default UID   *   FILE 967\n//*  BPXWP99  - ISHELL panel to reset UID(0) to user's default UID  *   FILE 967\n//*  ISPCMDS  - Command Table w/abbreviations (e.g. UDL for UDLIST) *   FILE 967\n//*  ISR@PRIM - Primary option menu for default USRCCONF settings   *   FILE 967\n//*  ISREDDE2 - Edit panel for highlighting and Unix path prepend   *   FILE 967\n//*  ISRPXASM - SAMPLIB member with language keywords for HILITE    *   FILE 967\n//*  ISRUAASE - Allocation panel to prevent PDSE without mem gens   *   FILE 967\n//*  ISRUDSL0 - Data set list to process VSAM for block deletes     *   FILE 967\n//*  ISRUUDL0 - UDLIST panel to reset UID(0) to user's default UID  *   FILE 967\n//*  ISRUULP  - UDLIST panel to reset UID(0) to user's default UID  *   FILE 967\n//*  ISRV01   - Message member to go along with ISRUAASE for PDSEs  *   FILE 967\n//*  UMBPXISJ - RECEIVE/APPLY UMBPXIS usermod for ISHELL UID(0)     *   FILE 967\n//*  UMISCLMJ - RECEIVE/APPLY UMISCLM usermod for SISPLPA VSCR      *   FILE 967\n//*  UMISPCMJ - RECEIVE/APPLY UMISPCM usermod for ISPCMDS abbrev's  *   FILE 967\n//*  UMISRHIJ - RECEIVE/APPLY UMISRHI usermod for CUCI HIGHLITE     *   FILE 967\n//*  UMISRPDJ - RECEIVE/APPLY UMISRHI usermod for PDSE allocate bug *   FILE 967\n//*  UMISRPXJ - RECEIVE/APPLY UMISRPX usermod for SAMPLIB hilite    *   FILE 967\n//*  UMISRUDJ - RECEIVE/APPLY UMISRUD usermod for ISRUDSL0 VSAM del *   FILE 967\n//*  UMISRUUJ - RECEIVE/APPLY UMISRUU usermod for UDLIST UID(0)     *   FILE 967\n//*  UMUSRCFJ - RECEIVE/APPLY UMUSRCF usermod for USRCCONF dialog   *   FILE 967\n//*  USRDEL34 - Rexx exec to process VSAM for block deletes         *   FILE 967\n//*  USRHILIT - Rexx exec to process EDIT language highlighting     *   FILE 967\n//*  USRL00   - Message member for CUCI messages                    *   FILE 967\n//*  USRPCONF - USRCCONF primary panel                              *   FILE 967\n//*  USRPMOD  - CUCI Define ISPF Settings Not in ISPCCONF panel     *   FILE 967\n//*  USRPMODQ - Calendar Colors and Options                         *   FILE 967\n//*  USRPMOD1 - PFKeys and PFkey Labels panel                       *   FILE 967\n//*  USRPMOD2 - Calendar Colors and Options panel                   *   FILE 967\n//*  USRPMOD3 - Modify MEMLIST, DSLIST, and UDLIST SRCHFOR Options  *   FILE 967\n//*  USRPMOD4 - UDLIST Directory List and Mount Table Options       *   FILE 967\n//*  USRUMNO2 - UDLIST Mount Table by File System/Mount Point Cols  *   FILE 967\n//*  USRUULO2 - UDLIST Directory List Column Arrangement            *   FILE 967\n//*  USR0Y002 - Keyword File Member help panel                      *   FILE 967\n//*  USR0Y004 - Output File Content for Keyword File help panel     *   FILE 967\n//*  USR0Y007 - Output Keyword File help panel                      *   FILE 967\n//*******************************************************************   FILE 967\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$HIGHLIT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x02\\x8f\\x01 \\x19O\\x11\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TCONLEY"}, "text": "To use extended language highlighting, issue the HIGHLITE command\nwith the following syntax:\n\nHIGHLITE language | OFF\n\nlanguage = {CARLA | FLOWASM | FORTRAN | GO | JAVA | JSON | PYTHON | RUBY |\n           SHELL | SQL}, OFF turns off extended language highlighting.\n\nHIGHLITE BRACE toggles brace highlighting on and off.\n\nHIGHLITE BRACKET toggles bracket highlighting on and off.\n\nHIGHLITE DISPLAY | DISP shows current state of HIGHLITE options.\n\nHIGHLITE HELP | ? displays this HELP text.\n\nNote:  NULLS ON ALL causes some keywords to remain unhighlighted.\n       NULLS ON STD allows all keywords to be highlighted.\n       Issue NULLS ON STD if some keywords are not highlighted.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ISPCMDS": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x02\\x8f\\x01 \\x19O\\x11\\x00\\x00\\x10\\x00\\x10\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "TCONLEY"}, "text": "These are the command abbreviations in the updated ISPCMDS table:\n\nBACKWARD - 4 (BACK)\nBOTTOM   - 3 (BOT)\nFORWARD  - 4 (FORW)\nACTIONS  - 3 (ACT)\nCRETRIEV - 4 (CRET)\nDDLIST   - 3 (DDL)\nDSLIST   - 3 (DSL)\nENVIRON  - 3 (ENV)\nEXPAND   - 3 (EXP)\nKEYLIST  - 4 (KEYL)\nSETVERB  - 4 (SETV)\nRETRIEVE - 4 (RETR)\nUDLIST   - 3 (UDL)\nZEXPAND  - 4 (ZEXP)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MANHACK": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\\\\\x00(\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 92, "newlines": 40, "modlines": 0, "user": "TCONLEY"}, "text": "While contributions to this collection must be in SMP/E usermod format,\nan increasing number of people have requested instructions to manually\ninstall each piece of CUCI.  So here is a list of components for each\nfix, so simply copy each component into the DD listed for it (also\nfollow any additional directions listed).  Ensure that any members\nmatching IBM members appear in the concatenation before those members.\n\n-----------------------------------------------------------------------\nUSRCCONF dialog for default ISPF settings not set in ISPCCONF:\n-----------------------------------------------------------------------\n\nISPPLIB - ISR@PRIM (modify your ISR@PRIM member with CUCI changes)\n          USRPCONF\n          USRPMOD\n          USRPMODQ\n          USRPMOD1\n          USRPMOD2\n          USRPMOD3\n          USRPMOD4\n          USRUMNO2\n          USRUULO2\n          USR0Y002\n          USR0Y004\n          USR0Y007\nSYSPROC - USR@KYWD (modify for your ISPF keyword file member)\n          USRCCONF\n          USRCCVWK\n          USRCMOD\n\n-----------------------------------------------------------------------\nModify SISPSAMP member ISRPXASM to add missing COBOL and PL/I keywords\nfor highlighting (73 COBOL and 140 PL/I keywords added)\n-----------------------------------------------------------------------\n\nISPLLIB - ISRPX (must be assembled and link-edited per instructions in\n                 member ISRPXASM)\n\n-----------------------------------------------------------------------\nPDSE V2 allocated under ISPF\n-----------------------------------------------------------------------\n\nISPMLIB - ISRV01\nISPPLIB - ISRUAASE\n\n-----------------------------------------------------------------------\nPrime ISRUMVC 'other dataset' field with current dataset for Copy/Move\n-----------------------------------------------------------------------\n\nISPPLIB - ISRUMVC\n\n-----------------------------------------------------------------------\nEDIT highlighting for unsupported languages\n\nSimplify UNIX file access in ISPF by prepending current Unix directory\nto filename for COMPARE, COPY, CREATE, and REPLACE commands (BROWSE,\nEDIT, and VIEW require member names and continue to issue \"Invalid\nmember name\" error message)\n-----------------------------------------------------------------------\n\nISPMLIB - USRL00\nISPPLIB - ISREDDE2\nSYSPROC - USRHILIT\n\n-----------------------------------------------------------------------\nISPF OPT 3.4 block delete commands should delete VSAM cluster, and\nbypass DATA and INDEX components without stopping\n-----------------------------------------------------------------------\n\nISPPLIB - ISRUDSL0\nSYSPROC - USRDEL34\n\n-----------------------------------------------------------------------\nReset UID(0) to user default UID upon exiting ISPF 3.17\n-----------------------------------------------------------------------\n\nISPPLIB - ISRUUDL0\n          ISRUULP\n\n-----------------------------------------------------------------------\nReset UID(0) to user default UID upon exiting ISHELL\n-----------------------------------------------------------------------\n\nISPPLIB - BPXWP99\nSYSPROC - BPXWISH\n          ISH     (alias of BPXWISH)\n          ISHELL  (alias of BPXWISH)\n\n-----------------------------------------------------------------------\nUpdate ISPCMDS table entries for Minimum TRUNC values (UDL for UDLIST)\n-----------------------------------------------------------------------\n\nISPTLIB - ISPCMDS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$README": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x1d\\x00\\x13\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 29, "newlines": 19, "modlines": 0, "user": "TCONLEY"}, "text": "This is the CBT Usermod Collection for ISPF (CUCI).  Each usermod is packaged\nfor SMP/E installation in your environment.\n\nInstallation Instructions\n-------------------------\n\nFor SMP/E installation, modify and run these members:\n\nUMBPXISJ - RECEIVE/APPLY UMBPXIS usermod for ISHELL reset UID(0)\nUMISCLMJ - RECEIVE/APPLY UMISCLM usermod for SISPLPA VSCR for SCLM modules\nUMISPCMJ - RECEIVE/APPLY UMISPCM usermod for ISPCMDS abbreviations\nUMISRHIJ - RECEIVE/APPLY UMISRHI usermod for CUCI HIGHLITE\nUMISRPDJ - RECEIVE/APPLY UMISRHI usermod for PDSE allocate bug\nUMISRPXJ - RECEIVE/APPLY UMISRPX usermod for SAMPLIB keyword hilighting\nUMISRUDJ - RECEIVE/APPLY UMISRUD usermod for ISRUDSL0 VSAM block deletes\nUMISRUUJ - RECEIVE/APPLY UMISRUU usermod for UDLIST reset UID(0)\nUMUSRCFJ - RECEIVE/APPLY UMUSRCF usermod for USRCCONF configuration dialog.\n           Be sure to modify USR@KYWD for your keyword member file, and your\n           ISR@PRIM menu to set the defaults.\n\nFor the SMP/E-averse among you, read member $MANHACK for manually hacking in\nthese usermods.\n\nSpecific usermods are also documented in these members:\n\n$HIGHLIT - Notes on EDIT highlighting for unsupported languages\n$ISPCMDS - Notes on ISPF command table abbreviations\n$USRCONF - Notes for USRCCONF dialog for ISPF settings not in ISPCCONF\n$34DELET - Notes on ISPF 3.4 block deletes not stopping for VSAM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$USRCONF": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "TCONLEY"}, "text": "The CUCI dialog USRCCONF, which sets defaults for ISPF settings not is ISPCCONF,\nis an impotant addition to the colleciton.  ISPF administrators will now be able\nto set defautls for the following settings not in ISPCCONF:\n\nPF Keys and PF Key Labels\nCalendar Options\nMEMLIST, DSLIST, and UDLIST SRCHFOR Options\nUDLIST Directory List and Mount Table Options\nUDLIST Directory List Column Arrangement\nUDLIST Mount Table by File System Column Arrangement\nUDLIST Mount Table by Mount Point Column Arrangement\n\nEnabling the support for these settings requires three things:\n\n1 - Modify ISR@PRIM (or your primary option menu) to set the defaults.\n2 - Generate a keyword file by executing the USRCCONF dialog.  The dialog is\n    designed to look and act like ISPCCONF.  You can use your existing ISPF\n    keyword file, but just be sure to use a different member name than the name\n    you use for ISPF defaults.  I used \"USRDEFLT\" for testing purposes.\n3 - Modify the USR@KYWD exec to specify the keyword file you defined in step 2.\n    The file will be read at the beginning of each new TSO/ISPF session to\n    determine if there is a new user, or if any settings should be FORCEd.\n\nFuture releases will add the following settings:\n\nZKIT=LO support in primay option menu for ISPF notepad\nBROWSE/VIEW entry panel options\nEDIT entry panel options\nEntry panel options for various utility panels, such as 3.1, 3.4, etc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$34DELET": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x02\\x9f\\x01 \\x19O\\x11\\x00\\x00\\x1a\\x00\\x17\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-29T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 26, "newlines": 23, "modlines": 0, "user": "TCONLEY"}, "text": "Block delete (//D) commands in 3.4 are difficult to execute when VSAM is\nembedded along with physical sequential or PDS(E) datasets.  VSAM causes the\ndelete to stop dead in its tracks because panel ISRUVPC9 will be displayed for\neach VSAM dataset to be deleted.  If you try to use //DELETE, TSO will invoke\nIDCAMS to delete the VSAM datasets.  It works, but there are two problems with\nthat approach.  The first is that TSO sends IDCAMS SYSPRINT messages to the\nterminal, so the user has to sit at the terminal to clear the *** at the bottom\nof the screen.  The second problem is that the DELETE command will fail on the\nDATA and INDEX portions of the VSAM cluster, and again the block delete stops\ndead in its tracks.\n\nThe solution required changes to the dataset list panel ISRUDSL0, and a Rexx\nexec USRDEL34.  ISRUDSL0 will look for a //D command, and change it to\n//USRDEL34.  USRDEL34 will invoke IDCAMS to delete the file.  The IDCAMS\nmessages will not appear on the terminal because the IDCAMS SYSPRINT file is\nallocated to DD DUMMY.  ISRUDSL0 will trap the error messages from IDCAMS when\ndeleting the DATA and INDEX portions of the VSAM cluster, clear the command\nfield, and then simulate ENTER from the user to delete the next dataset.\n\nWhat's the catch?  The catch is that ALL errors are bypassed.  So the user may\nhave to perform multiple passes and REFRESH the ISRUDSL0 display in the event\nof any I/O errors, RACF violations, etc., in order to process all the datasets\nto be deleted.  For example, for any GDG's you will have to run the delete\nprocess twice.  The first run will delete all the GDG's, the second run will\ndelete the GDG base (the GDG base delete will fail on the first run because it\nis not empty).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE967": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x06\\x01 5/\\x01 5/\\x08\\x12\\x008\\x008\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-17T00:00:00", "modifydate": "2020-12-17T08:12:06", "lines": 56, "newlines": 56, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 967 is the CBT Usermods Collection for ISPF (CUCI).       *   FILE 967\n//*                                                                 *   FILE 967\n//*     Tom Conley, in his position as SHARE's ISPF Advocate, is    *   FILE 967\n//*     establishing this collection to provide function that will  *   FILE 967\n//*     in all likelihoood not be provided by IBM.  IBM's           *   FILE 967\n//*     investment in ISPF has steadily dwindled since z/OS V2R1,   *   FILE 967\n//*     while investment in z/OSMF has vastly increased.  There is  *   FILE 967\n//*     still a user community for ISPF that requires increased     *   FILE 967\n//*     function.  The goal of this collection will be to provide   *   FILE 967\n//*     that function wherever possible.                            *   FILE 967\n//*                                                                 *   FILE 967\n//*     Functions provided to this collection must be in a          *   FILE 967\n//*     standard SMP/E usermod format.  Manual hacks will not be    *   FILE 967\n//*     accepted.  It is expected that the ISPF community will      *   FILE 967\n//*     provide functions to this collection with the foregoing in  *   FILE 967\n//*     mind.                                                       *   FILE 967\n//*                                                                 *   FILE 967\n//*     This collection includes the following documentation        *   FILE 967\n//*     members:                                                    *   FILE 967\n//*                                                                 *   FILE 967\n//*      $CHANGES - Change log of all changes to CUCI.              *   FILE 967\n//*      @FILE967 - This member.                                    *   FILE 967\n//*                                                                 *   FILE 967\n//*     The following list of members is followed by a short        *   FILE 967\n//*     description to show you the ISPF usermods supported by the  *   FILE 967\n//*     CBT ISPF Usermods Collection:                               *   FILE 967\n//*                                                                 *   FILE 967\n//*      ISPCMDS  - Command Table w/abbreviations (e.g. UDL for     *   FILE 967\n//*                 UDLIST)                                         *   FILE 967\n//*      UMISPCMJ - JCL to RECEIVE/APPLY UMISPCM usermod            *   FILE 967\n//*                                                                 *   FILE 967\n//*     See member $FILE967 for a complete list of contents:        *   FILE 967\n//*                                                                 *   FILE 967\n//*     Member list for the pds:                                    *   FILE 967\n//*                                                                 *   FILE 967\n//*       $CHANGES  01.02  2019/01/28   23:30     85    TCONLEY     *   FILE 967\n//*       $FILE967  01.02  2019/01/28   23:30     45    TCONLEY     *   FILE 967\n//*       $HIGHLIT  01.02  2019/01/28   23:30     19    TCONLEY     *   FILE 967\n//*       $ISPCMDS  01.02  2019/01/28   23:30     16    TCONLEY     *   FILE 967\n//*       $34DELET  01.02  2019/01/28   23:30     23    TCONLEY     *   FILE 967\n//*       @FILE967  04.97  2019/02/20   16:38     56    CBT-497     *   FILE 967\n//*       BPXWISH   01.02  2019/01/28   23:30   6768    TCONLEY     *   FILE 967\n//*       BPXWP99   01.02  2019/01/28   23:30    267    TCONLEY     *   FILE 967\n//*       ISPCMDS   01.01  2017/11/16    0:50    106  Y IBMUSER     *   FILE 967\n//*       ISREDDE2  01.02  2019/01/28   23:30    312    TCONLEY     *   FILE 967\n//*       ISRUDSL0  01.01  2018/12/24   21:00    341    TCONLEY     *   FILE 967\n//*       ISRUUDL0  01.01  2018/12/24   21:00    185    TCONLEY     *   FILE 967\n//*       ISRUULP   01.01  2018/12/24   21:00    244    TCONLEY     *   FILE 967\n//*       UMBPXISJ  01.02  2019/01/28   23:30     20    TCONLEY     *   FILE 967\n//*       UMISPCMJ  01.01  2018/12/24   21:00     19    TCONLEY     *   FILE 967\n//*       UMISRHIJ  01.02  2019/01/28   23:30     20    TCONLEY     *   FILE 967\n//*       UMISRUDJ  01.01  2018/12/24   21:00     20    TCONLEY     *   FILE 967\n//*       UMISRUUJ  01.01  2018/12/24   21:00     20    TCONLEY     *   FILE 967\n//*       USRDEL34  01.01  2018/12/24   21:00     77    TCONLEY     *   FILE 967\n//*       USRHILIT  01.03  2019/01/28   23:30   2383    TCONLEY     *   FILE 967\n//*                                                                 *   FILE 967\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BPXWISH": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x02\\x7f\\x01 \\x19O\\x11\\x00\\x1a|\\x1ap\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-27T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 6780, "newlines": 6768, "modlines": 0, "user": "TCONLEY"}, "text": "/*REXX*/\n/**********************************************************************/\n/* $MAC(BPXWISH) COMP(SCPX1) PROD(BPX):                               */\n/* EXEC:      BPXWISH                                                 */\n/* PROPRIETARY STATEMENT:                                             */\n/*            LICENSED MATERIALS - PROGRAM PROPERTY OF IBM            */\n/*            5650-ZOS COPYRIGHT IBM CORPORATION, 1993,2015           */\n/* STATUS:    HBB77A0                                                 */\n/* FUNCTION:  ISPF shell (dialog) for OpenMVS file system access      */\n/*            and various administrative functions.                   */\n/* CHANGE ACTIVITY:  (recent only)                                    */\n/*   $P1=PPF0035  HOM1130, 940601, PDND: fix fsattr after name cmd    */\n/*                                       makevpath/path->tpath        */\n/*   $P2=PPF0080  HOM1130, 940804, PDND: showobj support for delete   */\n/*   $01=OY08318  HOM1120, 940920, PDND: libdef/altlib, user setup    */\n/*   $P4=PPF0477  HOM1130, 950613, PDND: adds for root setup          */\n/*   $02=OW16240  HOM1130, 950926, PDND: add mode popup for copy      */\n/*                                       user setup and automount     */\n/*   $03=OW19471  HOM1130, 960325, PDND: handle tso noprefix          */\n/*   $04=OW20797  HOM1130, 960604, PDND: allow 10 digit uids          */\n/*   $P5=PQC1428  HOM1150, 960611, PDND: do not prime fields on mount */\n/*                                       add diag for ispf select err */\n/*   $05=OW19596  HOM1130, 960801, PDND: sh/ex pathname, set HOME env */\n/*   $D3=DSYA188  JBB6604, 961011, PDND: trusted tree                 */\n/*   $D4=DSYA199  JBB6604, 961030, PDND: cee runopts  A199.03         */\n/*   $D6=DWAA297  JBB6607, 980507, PDJP: mount nosecurity             */\n/*   $P6=PWA0164  JBB6607, 980520, PDJP: 10 digit uid/gid FIN OW33117 */\n/*                                       fall back to CWD of /        */\n/*   $06=OW35469  HBB6606, 980826, PDND: default uid/gid, env vars    */\n/*   $D7=DWYA309  JBB6609, 990321, PDND: sysplex support              */\n/*   $07=OW36923  HBB6605, 990323, PDJP: 10 digit uid for panel P06   */\n/*   $08=OW42612  JBB6609, 000130, PDND: fsattr misses fs name        */\n/*                                       add dyn fs list              */\n/*   $09=OW43422  JBB6609, 000229, PDND: fix changing automove attr   */\n/*   $D8=DXVA412  HBB7705, 000515, PDMX: Native Ascii - file tag      */\n/*   $D9=DYMA...  HBB7706, 001204, PDND: autounmount                  */\n/*   $DA=DYMA525  HBB7706, 001218, PDND: ACLs A525.02                 */\n/*   $0A=OW47337  HBB7706, 010130, PDND: change seteuid to setreuid   */\n/*   $0B=OW47860  HBB7706, 010130, PDND: improve symlink handling     */\n/*   $DB=DYMA557  HBB7707, 010611, PDND: ish enhancements: local time */\n/*                                       sort, color, X via sh,       */\n/*                                       fixed len edit               */\n/*   $P7=PYM0293  HBB7707, 010628, PDND: call mpc and misc fixes      */\n/*   $P8=PYM....  HBB7707, 010711, PDND: sort fix                     */\n/*   $P9=PYM0396  HBB7707, 010809, PDND: execute fix                  */\n/*   $PA=PYM0365  HBB7707, 010809, PDND: reorder color attrs          */\n/*   $DC=DYVA579  HBB7707, 011012, PDND: zfs, syslist                 */\n/*   $PB=PYV0168  HBB7707, 011201, PDND: add syslist to mount         */\n/*   $PC=PYV0188  HBB7707, 011206, PDND: syslist fix                  */\n/*   $PD=PYV0159  HBB7707, 011220, PDND: syslist fix2                 */\n/*   $Px=PYV0276  HBB7707, 020103, PDND: rewrite dirlist nonrecursive */\n/*   $0C=OW.....  HBB7708, 020210, PDND: user setup with automount    */\n/*   $DD=DYNA604  HBB7708, 020210, PDND: zfs aggregates               */\n/*   $PE=xxxxxxx  HBB7708, 020601, PDMX: filetag update               */\n/*   $0E=PYN0516  HBB7708, 021001, PDND: dirlist nonrecursive OW56603 */\n/*   $0A=OW53406  JBB6609, 021201, PDMX: peg csr to cmdline on ps     */\n/*   $0D=OW52333  HBB7703, 020823, PDND: user setup with automount    */\n/*                                        (also PYN0207)              */\n/*   $PF=PYN0699  HBB7708, 021021, PDND: fix shortcuts on dirlist($0E)*/\n/*   $DE=DYNA597  HBB7708, 021104, PDND: add r/o seclabel to fs       */\n/*   $0F=OW55686  HBB7706, 021101, PDMX: incorrect HOME during spawn  */\n/*   $0G=OA01945  HBB7708, 020131, PDND: get init uid from user seg   */\n/*   $0H=OW57339  HBB7706, 030227, PDKG: do stat if readdir2 fails    */\n/*   $0I=OAxxxxx  HBB7708, 030227, PDKG: Allow no options on dir list */\n/*   $DF=DJKA663  HBB7709, 030418, PDND: ish enhancements: filter,    */\n/*                                       rwx, old way options,        */\n/*                                                                    */\n/*   $DG=DJKA612  HBB7709, 030522, PDND: superkill                    */\n/*   $PG=PJK0588  HBB7709, 030622, PDND: change fchattr to chattr     */\n/*   $PH=PJK0622  HBB7709, 030713, PDMX: init prc for setfilter       */\n/*   $0J=OA04911  HBB7720, 040313, PDMX: panel not found loop (FIN)   */\n/*   $0K=OA06789  HBB7720, 040313, PDMX: symlink 'L' cmd improvement  */\n/*   $DH=DDEA780  HBB7720, 040127, PDND: reflist, grplst, ...         */\n/*                         040622, PDND: add filesys type to mnt tab  */\n/*   $PI=ME01222  HBB7720, 040813, PDND: misc fixes                   */\n/*   $PJ=ME01786  HBB7720, 040927, PDND: fix for using old copy source*/\n/*   $0M=OA09148  HBB7720, 041010, PDMX: user setup tso error (fin)   */\n/*   $PK=ME03811  HBB7730, 050809, PDND: add crnl to data type display*/\n/*   $0N=OA13504  HBB7707, 051110, PDKG: check stat of getpwnam       */\n/*   $0O=OA13287  HBB7708, 051111, PDMX: allow long TZ env            */\n/*   $DI=DCRB241  HBB7750, 070413, PDGY: add mount status string      */\n/*   $PL=ME10435  HBB7750, 070618, PDGY: rename mount status string   */\n/*                                       variables                    */\n/*   $DJ=ME12185  HBB7750, 071217, PDND: remove blank copyright msg   */\n/*                                       reset quiesce for zfs        */\n/*                                       BPXWISHISPF envar            */\n/*   $DK=DCRB495  HBB7760, 080508, PDGY: Remount samemode support     */\n/*   $DL=ME14677  HBB7760, 080826, PDND: default to use ispf ed/br    */\n/*   $DM=DCRB763  HBB7770, 081215, PD2R: Add Record file format Supp. */\n/*   $DN=DCRB685  HBB7770, 090309  PDGY: Remove multi-file system supp*/\n/*   $0P=OA29228  HBB7760, 090618  PDFV: Screen size on compare option*/\n/*   $0Q=OA30104  HBB7760, 090831  PDGY: ISPF edit fails w/ rc>4      */\n/*   $0R=OA31564  HBB7760, 100119  PDGY: ISHELL edit fails            */\n/*   $0S=OA31876  HBB7760, 100210  PDGY: run edit macro               */\n/*   $DO=DCRC028  HBB7780, 100609  PDGY: add non-priv mounts  C028.04 */\n/*   $DP=ME20000  HBB7780, 100917  PDGY: Display user ID instead uid  */\n/*   $0T=OA33768  HBB7750, 101212, PDMX: bpxwunix for export -p       */\n/*   $0U=OA36218  HBB7780, 110418, PDGY: change var for mtabf         */\n/*   $DQ=ME23809  HBB7790, 120612, PDX8: detect MENU PENU TENU libs   */\n/*   $0V=OA41249  HBB7770, 130131, PDX8: filelist sorted by size w/ M */\n/*   $PM=OA42869  HBB77A0, 130724, PDGY: handle errno > 999   (FIN)   */\n/**********************************************************************/\nsignal on syntax\nparse source . . who . execdsn .    /* get name of this macro   10@02C*/\nif sysvar(sysispf)<>'ACTIVE' then   /* if ispf not active             */\n   do                               /* start it and exec this command */\n   if execdsn<>'?' then\n      \"ispstart cmd(ex '\"execdsn\"(\"who arg(1)\")') newappl(isr)\"\n    else\n      'ispstart cmd('who arg(1)') newappl(isr)'\n   return\n   end\n\nenopref='BPXW'\nejrcomp='BPXWC'\npan.p_main='BPXWP99'\npan.p_sdir='BPXWP01'\npan.p_scsp='BPXWP02'\npan.p_sreg='BPXWP03'\npan.p_sfifo='BPXWP04'\npan.p_ssym='BPXWP05'\npan.p_dir='BPXWP06'\npan.p_dirshort='BPXWP06'\npan.p_dirlong='BPXWP06a'\npan.p_creat='BPXWP07'\npan.p_fields='BPXWP08'\npan.p_edopt='BPXWP09'\npan.p_mtopts='BPXWP61' /* @08A*/\npan.p_obj='BPXWP10'\npan.p_settings='BPXWP11'\npan.p_cngmode='BPXWP12'\npan.p_cnguser='BPXWP13'\npan.p_cnggroup='BPXWP14'\npan.p_cnguaud='BPXWP15'\npan.p_cngaaud='BPXWP16'\npan.p_confd='BPXWP17'\npan.p_confr='BPXWP18'\npan.p_getpath='BPXWP19'\npan.p_mt='BPXWP20'\npan.p_smt='BPXWP21'\npan.p_mtstat='BPXWP22'\n                                                               /*@DND*/\npan.p_mtunmt='BPXWP23'\npan.p_dev='BPXWP24'\npan.p_root='BPXWP25'\npan.p_mount='BPXWP26'\npan.p_usere='BPXWP27'\npan.p_alluser='BPXWP28'\npan.p_grp='BPXWP29'\npan.p_usrlst='BPXWP30'\npan.p_usrlstm='BPXWP31'\npan.p_cpydst='BPXWP32'\npan.p_cpysrc='BPXWP33'\npan.p_getdsn='BPXWP34'\npan.p_symset='BPXWP35'\npan.p_mkfs='BPXWP36'\npan.p_cpyspds='BPXWP37'\npan.p_cpydpds='BPXWP38'\npan.p_cpyconv='BPXWP39'\npan.p_cpyerr='BPXWP40'\npan.p_segauth='BPXWP41'\npan.p_getrecl='BPXWP42'\npan.p_srchstr='BPXWP43'\npan.p_run='BPXWP44'\npan.p_memlist='BPXWP45'\npan.p_memlisthr='BPXWH45'\npan.p_memlisthc='BPXWH56'\npan.p_unquiesce='BPXWP46'\npan.p_perm='BPXWP47'\npan.p_dflts='BPXWP48'\npan.p_exconf='BPXWP49'\npan.p_symsel='BPXWP50'\npan.p_ps='BPXWP51'\npan.p_pssig='BPXWP52'\npan.p_psatt='BPXWP53'\npan.p_shcmd='BPXWP54'\npan.p_excmd='BPXWP55'\npan.p_rdel='BPXWP56'\npan.p_remount='BPXWP57'\npan.p_cngffmt='BPXWP58'\npan.p_cngexat='BPXWP59'\npan.p_cngfsat='BPXWP60'\npan.p_acltab='BPXWP62'   /*  @DAA*/\npan.p_aclnew='BPXWP63'   /*  @DAA*/\npan.p_aclconf='BPXWP64'   /*  @DAA*/\npan.p_acltype='BPXWP65'   /*  @DAA*/\npan.p_dircolor='BPXWP66'\npan.p_dirsort='BPXWP67'\npan.p_arights='BPXWP68'\npan.p_selamt='BPXWP70'    /* @DCA*/\npan.p_adops='BPXWP71'     /* @DFA*/\npan.p_filter='BPXWP72'    /* @DFA*/\npan.p_multi='BPXWP73'     /* @DFA*/\npan.p_multe='BPXWP74'     /* @DFA*/\npan.p_attrack='BPXWP75'   /* @DFA*/\npan.p_autoid='BPXWP76'    /* @DFA*/\npan.p_refltb='BPXWP77'    /* @DHA*/\npan.p_grplst='BPXWP79'    /* @DHA*/\npan.p_samemode='BPXWP80'  /* @DKA*/\n\npan.p_hlphelp='BPXWH90'\npan.p_hlpnews='BPXWH98'\npan.p_about='BPXWH00'\npan.p_acthelp='BPXWF13'\nmsg.m_blank='BPXWM999'       /* @DFA*/\nmsg.m_start='BPXWM001'\nmsg.m_invcmd='BPXWM002'\nmsg.m_scerr='BPXWM003'\nmsg.m_scerr2='BPXWM005'\nmsg.m_printed='BPXWM004'\nmsg.m_baduid='BPXWM006'\nmsg.m_defusr='BPXWM007'\nmsg.m_nouids='BPXWM008'\nmsg.m_unavail='BPXWM009'\nunavail='BPXWM009'\nmsg.m_grsetup='BPXWM010'\nmsg.m_gentxt='BPXWM011'\nmsg.m_nodsn='BPXWM012'\nmsg.m_dupfs='BPXWM013'\nmsg.m_alloc='BPXWM014'\nmsg.m_nopgm='BPXWM015'\nmsg.m_notfound='BPXWM016'\nmsg.m_noacc='BPXWM017'\nmsg.m_nodiff='BPXWM018'\nmsg.m_noarg='BPXWM019'\nmsg.m_timeout='BPXWM020'\nmsg.m_sigexit='BPXWM021'\nmsg.m_sigterm='BPXWM022'\nmsg.m_sigstop='BPXWM023'\nmsg.m_priv='BPXWM024'\nmnotpriv='BPXWM024'\nmsg.m_noaccw='BPXWM025'\nmsg.m_nospaces='BPXWM026'\n/* M027 used by oputx/ogetx */\nmsg.m_nocopy='BPXWM028'\nmsg.m_diff='BPXWM029'\nmsg.m_found='BPXWM030'\nmsg.m_nontext='BPXWM031'\nmsg.m_nocopy='BPXWM032'\nmsg.m_dupid='BPXWM034'\nmsg.m_badid='BPXWM035'\nmsg.m_noacl='BPXWM036'\nmsg.m_badname='BPXWM037'\nmsg.m_rmfilt='BPXWM038'     /* 2@PIA */\nmsg.m_badnum='BPXWM039'\nlit='BPXWL'\npgmedit='BPXWEDIT'\npgmbrws='BPXWBRWS'\naddress ispexec\n\"CONTROL ERRORS RETURN\"\n\"VGET (ZAPPLID ZSCROLLD ZPLACE)\"\nif zapplid<>\"BPXW\" then\n   do\n   if execdsn<>'?' then                                        /* @02A*/\n      do\n      address tso \"altlib activate appl(exec) da('\"execdsn\"')\" /* @02A*/\n      didalt=1\n      end\n   \"SELECT CMD(\"who arg(1)\") NEWAPPL(BPXW) NEWPOOL PASSLIB\"  /* @02C*/\n   if rc>8 then              /* @P5A*/\n      say zerrmsg zerrlm     /* @P5A*/\n   \"VPUT (ZPLACE) PROFILE\"\n   if didalt=1 then                            /* @wjs*/\n      address tso \"altlib deact appl(exec)\"\n   return\n   end\ncall libdefs\n\"VGET (IPLACE TPLACE) PROFILE\"\nif tplace='' then\n   tplace='BOTTOM'\nif iplace='' then\n   iplace='ASIS'\nzscrolld='DATA'\nif tplace<>'INHERIT' then   /*  6@DFA*/\n   do\n   zplace=tplace\n   \"VPUT (ZPLACE) PROFILE\"\n   end\n\"VPUT (IPLACE TPLACE ZSCROLLD) PROFILE\"\nmsgloc='MSGLOC(ZCMD)'\n\n\"GETMSG MSG(\"lit\"000) LONGMSG(L#MT0)\"\n\"GETMSG MSG(\"lit\"001) LONGMSG(L#MT1)\"\n\"GETMSG MSG(\"lit\"002) LONGMSG(L#MT2)\"\n\"GETMSG MSG(\"lit\"003) LONGMSG(L#MT4)\"\n\"GETMSG MSG(\"lit\"004) LONGMSG(L#MT8)\"\n\"GETMSG MSG(\"lit\"005) LONGMSG(L#MT16)\"\n\"GETMSG MSG(\"lit\"006) LONGMSG(L#MT32)\"\n\"GETMSG MSG(\"lit\"007) LONGMSG(L#MT64)\"\n\"GETMSG MSG(\"lit\"018) LONGMSG(L#MT130)\"\n\"GETMSG MSG(\"lit\"010) LONGMSG(L#USERL)\"\n\"GETMSG MSG(\"lit\"011) LONGMSG(L#USER)\"\n\"GETMSG MSG(\"lit\"012) LONGMSG(L#UID)\"\n\"GETMSG MSG(\"lit\"013) LONGMSG(L#GID)\"\n\"GETMSG MSG(\"lit\"014) LONGMSG(L#HD)\"\n\"GETMSG MSG(\"lit\"015) LONGMSG(L#IP)\"\n\"GETMSG MSG(\"lit\"016) LONGMSG(L#FTYPES)\"\n\"VGET (ZLSTLPP ZLSTTRUN)\"\njrnodir='003D'\n\nparse arg pathmain\nif translate(substr(pathmain,1,2))='-D' then\n   do\n   if translate(substr(pathmain,1,3))='-DT' then\n      debug=2\n    else\n      debug=1\n   parse var pathmain . pathmain\n   end\n else\n   debug=0\npathmain$=strip(pathmain)    /* @DHA*/\n\n/* In R13 a new column was added in the mount table. The mount table\n   headers get saved in variable mtabf. If one was to log onto R13 and\n   display the column and then log onto an R12 system, then the column\n   would show up and not have initialized data since R12 does not know\n   about it which caused bad output. To get around this, bpxinit was\n   incremented so that mtabf was initialized to the default headers.\n   This had the side effect of clearing all ISHELL display settings\n   and became a problem if a user were to switch back and forth between\n   releases. To get around this, bpxinit was changed back to its\n   previous version and the mtabf variable changed to mtabf2 for R13.\n   This way R13 could inherit the settings from R12 and if going back\n   to R12, ISHELL would use the old variable name which has not been\n   used in R13. */                                             /*@0UC*/\n\"VGET (BPXINIT DIRH NOCONF NOEXCONF FLSORT FLSORTS\",\n      \"VDIRFP VDIRFT VDIRFC VDIRFR VDIRFU VDIRFS VDIRVB VDIRENT\",\n      \"MTABF VFSLSN VFSLAM VFSLRO VFSLS1 VFSLS2 VFSLBC VFSLM1 VFSLM2\",\n      \"VFSFST ADDIR ADREG ADCSP ADFIFO ADSYML TPERM VFSUSR\",   /*@DOC*/\n      \"PROF IMAC EDPRF PATHMAIN NOAUTOSK NOPTHMEM VDIRNOM\",\n      \"REFLOFF VDIRPL MTABF2\",   /*@0UC@DHC*/\n     \") PROFILE\"                                          /* @DFC*/\nif mtabf2='' then                                              /*@0UA*/\n   mtabf2=mtabf                                                /*@0UA*/\nif pathmain$<>'' then    /* 2@DHA*/\n   pathmain=pathmain$\ncall setcolors 0\nif bpxinit<>2 then                                         /*@0UC@DOA*/\n   do\n   bpxinit=2                                               /*@0UC@DOA*/\n   mtabf2='fsname l 44 <File system name>',                    /*@0UC*/\n         'status l 30 <Status>'\n   mtfmt='O'\n   vdirft='/'\n   vdirvb='/'\n   flsort='C'\n   flsorts='0'\n   addir='L'\n   adreg='B'\n   adcsp='A'\n   adfifo='A'\n   adsyml='A'\n   tperm=600\n   dirh=''\n   \"VPUT (DIRH VDIRFT FLSORT FLSORTS MTFMT MTABF2\",            /*@0UC*/\n         \"ADDIR ADREG ADCSP ADFIFO ADSYML TPERM\",\n         \"PATHMAIN VDIRVB) PROFILE\"\n   \"VPUT (BPXINIT) PROFILE\"\n   end\nif vdirvb='/' then\n   pan.p_dir=pan.p_dirlong\nfsn=''\nstdout=''\nstderr=''\nvpath01=''\ngreppath='/bin/grep'\ndiffpath='/bin/diff'\nfindpath='/bin/find'\nautouid=''    /* 2@DFA*/\nautogid=''\nif syscalls(on)>4 then\n   do\n   eno='?'\n   rsn=''\n   call syscallm 'sysconf 1'\n   return\n   end\ncall syscalls 'SIGOFF'\ncall syscallm 'getuid'\nmyuid=retval\ncall syscallm 'geteuid'\nmyeuid=retval\npw.=''                                        /* 4@0GA*/\ncall syscallm 'getpwnam' userid() 'pw.'\n\n/*************************************************************** @0NA*/\n/* Check return value from getpwnam.  getpwnam returns UID/GID/CWD.  */\n/* If no entry exists in the security product data base for the      */\n/* passed in userid, getpwnam returns a 0 in RETVAL.                 */\n/* If a installation is using secondary USERIDs, the secondary ID    */\n/* is not defined to TSO or to the security product; it is           */\n/* associated with a primary userid (which is defined to TSO and has */\n/* OMVS segment information defined).  In this case, the USERID()    */\n/* function returns the secondary userid which is not defined to the */\n/* security product.  We must then issue getlogin to get the real    */\n/* USERID associated with the secondary userid.  We then pass this   */\n/* userid to getpwnam to get the UID information.                    */\n/*********************************************************************/\nif retval=-1 | retval=0 Then                                  /* @0NA*/\n do                                                           /* @0NA*/\n  call syscallm 'getlogin myid'                               /* @0NA*/\n  call syscallm 'getpwnam' myid 'pw.'                         /* @0NA*/\n end                                                          /* @0NA*/\n\ninituid=pw.pw_uid\niniteuid=pw.pw_uid\nuserhome=pw.pw_dir      /* 9@DHA*/\nreffile=userhome'/.ishell-reflist-'userid()\nif refloff<>0 & refloff<>1 then\n   refloff=1\nif refloff=0 then         /* if ref list is not off in profile */\n   do\n   refloff=1\n   call reflistproc 'on'  /* turn on ref list */\n   end\nnotpriv=1\nif myuid=0 then\n   do\n   call bpxwirac 'special'\n   if result=1 then\n      notpriv=0\n   end\nprod.=''\naddress syscall 'uname prod.'\nprodinf=prod.u_sysname prod.u_version'.'prod.u_release\naddress ispexec \"VPUT (PRODINF)\"\ndrop prod.\ndfltuser='00'x         /* @06A*/\ndfltgroup='00'x        /* @06A*/\npattern.=''  /* @DFA*/\npattern.0=0  /* @DFA*/\n\n/* *** start local time co-process ***/\ncmdline='export -p'\npgm=''\nltime.4='*'\ncall runshcmd\nparse var ltimebf 'TZ=' gmt\nif gmt='' then\n   gmt='GMT'\n else\n   do\n   gmt=strip(gmt)                /* @0OC*/\n   call runcoprocess             /* @DFA*/\n   end\nltime.4=''\nparse value '' with cmdl1 cmdl2 cmdl3 cmdl4\nif pathmain<>'' & nopthmem<>'/' then   /* @DFC*/\n   call makevpath pathmain\n else\n   pathmain=''\n\n/**********************************************************************/\n/* main panel loop                                                    */\n/**********************************************************************/\ndo forever\n   sellev=0\n   if vpath01='' then\n      do\n      call syscallm 'getcwd path'\n      if retval=-1 then path='/'                                /*@D6C*/\n      call makevpath path\n      end\n   address syscall 'geteuid'\n   uidline='EUID='retval\n   if debug=1 then\n      \"CONTROL ERRORS RETURN\"\n   \"REMPOP ALL\"\n   if debug=1 then\n      \"CONTROL ERRORS\"\n   \"DISPLAY PANEL(\"pan.p_main\")\"\n   if rc<>0 then\n      if rc>8 | noexconf='/' then\n         leave\n       else\n         do\n         \"VGET (ZVERB)\"\n         if ZVERB='RETURN' then\n            leave\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_exconf\")\"\n         src=rc\n         \"REMPOP\"\n         if src=0 then leave\n         \"VGET (ZVERB)\"\n         if ZVERB='CANCEL' then\n            iterate\n         leave\n         end\n   pathmain=makepath()\n   if length(zcmd)>1 & word(zcmd,1)<>'SEL' then\n      call main_cmd\n    else\n      do\n      if word(zcmd,1)='SEL' then\n         zcmd=word(zcmd,2)\n         call main_path\n      end\n   call makevpath pathmain\nend\naddress ispexec \"VPUT (PATHMAIN) PROFILE\"  /* @DHM*/\ncall reflistproc 'save'    /* @DHA*/\nif datatype(ltime.0,'W')=1 then\n   do\n   trace o\n   address syscall\n   'close' ltime.0\n   'close' ltime.1\n   'waitpid (ltime.3) st. 0'\n   p1='0000000000000000'x\n   p2=p1\n   p3=p1\n   p4=p1\n   address linkpgm 'bpx1mpc p1 p2 p3 p4'\n   end\nreturn\n\n/**********************************************************************/\n/* main panel: runcoprocess                                           */\n/************************************************************** 20@DFM*/\nruncoprocess:\n   address syscall 'pipe pi.'\n   address syscall 'pipe po.'\n   fd.0=pi.1\n   ltime.0=pi.2\n   fd.1=po.2\n   ltime.1=po.1\n   env.0=2\n   env.1='TZ='gmt\n   env.2='_BPX_SHAREAS=YES'\n   prm.0=1\n   prm.1='/bin/fomfuish'\n   call runopts 'env.'\n   address syscall 'spawn (prm.1) 2 fd. prm. env.'\n   ltime.3=retval\n   if retval=-1 then\n      do       /* cannot create coprocess, no time conv 4@DFA*/\n      address syscall 'close' ltime.0\n      address syscall 'close' ltime.1\n      ltime.0=''\n      gmt='GMT'\n      end\n   address syscall 'close' fd.0\n   address syscall 'close' fd.1\n   return\n\n/**********************************************************************/\n/* main panel: command entered                                        */\n/**********************************************************************/\nmain_cmd:\n   parse var zcmd zcmd cmdline\n   cmd=translate(zcmd)\n   zcmd=''\n   select\n      when cmd='PS' then\n         call pscmd\n\n      when cmd='SH' then\n         call shcmd cmdline\n\n      when cmd='EX' then\n         call shcmd cmdline,1\n\n /*   when cmd='ABOUT' then\n         do\n         \"SELECT PGM(ISPTUTOR) PARM(\"pan.p_about\")\"\n         end                                            @DFD*/\n\n      when cmd='ACTHELP' then\n         do\n         \"SELECT PGM(ISPTUTOR) PARM(\"pan.p_acthelp\")\"\n         end\n\n      when cmd='HLPHELP' then\n         do\n         \"SELECT PGM(ISPTUTOR) PARM(\"pan.p_hlphelp\")\"\n         end\n\n /*   when cmd='NEWINFO' then\n         do\n         \"SELECT PGM(ISPTUTOR) PARM(\"pan.p_hlpnews\")\"\n         end                                           @DFD*/\n\n      when cmd='FLFIELD' then\n         do\n         \"ADDPOP\"\n         if flsorts='' then     /* 4@P8A*/\n            flsortf=flsort\n          else\n            flsortf='X'\n         vdircl=''\n         vdirso=''\n         \"DISPLAY PANEL(\"pan.p_fields\")\"\n         if rc=0 then\n            do\n            dirh=''\n            if vdirft='/' then\n               dirh=dirh 'filetp l 4 <Type>'\n            if vdirfp='/' then\n               dirh=dirh 'filemd r 4 <Perm>'\n            if vdirfr='/' then                        /* @DFA*/\n               dirh=dirh 'filemd p 10 <Permission>'   /* @DFA*/\n            if vdirfc='/' then\n               dirh=dirh 'filecd l 16 <Changed(GMT)>'   /* @P7C*/\n            if vdirfu='/' then\n               dirh=dirh 'fileusr l 9 <Owner>'\n            if vdirfs='/' then\n               dirh=dirh 'filesz r 10 <------Size>'\n            dirh=dirh 'filenm l 255 <Filename>'\n            if vdirso='/' then\n               do\n               \"DISPLAY PANEL(\"pan.p_dirsort\")\"\n               if rc<>0 then\n                  \"VGET (FLSORT FLSORTS) PROFILE\"\n               end\n            if vdircl='/' then\n               call setcolors 1\n            if vdirvb='/' then\n               pan.p_dir=pan.p_dirlong\n             else\n               pan.p_dir=pan.p_dirshort\n            \"VPUT (DIRH FLSORT FLSORTS VDIRFP VDIRFR VDIRENT VDIRNOM\",\n                   \"VDIRPL\", /* @DHM*/\n                \"VDIRFT VDIRFC VDIRFU VDIRFS VDIRVB) PROFILE\"  /* @DFC*/\n            end\n          else\n            \"VGET (DIRH FLSORT FLSORTS VDIRFP VDIRFR VDIRENT VDIRNOM\",\n                   \"VDIRPL\", /* @DHM*/\n                  \"VDIRFT VDIRFC VDIRFU VDIRFS) PROFILE\"       /* @DFC*/\n         \"REMPOP\"\n         end\n\n      when cmd='BPXISHMT' then  /* xx@08A*/\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_mtopts\")\"\n         if rc<>0 then        /* If user canceled out of panel (PF3) */\n                                                               /*@0UC*/\n            \"VGET (MTABF2 VFSLSN VFSLAM VFSLRO VFSLS1 VFSLS2 VFSLBC\",\n                \"VFSLM1 VFSLM2 VFSFST VFSUSR) PROFILE\" /*@DPC@DOC@DHC*/\n          else\n            do\n            if mtfmt='O' then                /* Using default display */\n               mtabf2='fsname l 44 <File system name>',        /*@0UC*/\n                     'status l 30 <Status>'\n             else                        /* Using selectable display */\n               do\n               mtabf2=''                                       /*@0UC*/\n               if vfsfst='/' then                     /* 2@DHC*/\n                  mtabf2=mtabf2 'type l 4 <Type>'              /*@0UC*/\n               if vfslsn='/' then\n                  mtabf2=mtabf2 'sysname l 8 <Owner>'          /*@0UC*/\n               if vfslam='/' then\n                  mtabf2=mtabf2 'am     l 3  <A/M>'            /*@0UC*/\n               if vfslro='/' then\n                  mtabf2=mtabf2 'ro     l 3  <R/O>'            /*@0UC*/\n               if vfslbc='/' then\n                  mtabf2=mtabf2 'blkcnt r 9 <I/O Count>'       /*@0UC*/\n               if vfsusr='/' then\n                  mtabf2=mtabf2 'usercol l 8 <User>'   /*@0UC@DPC@DOC*/\n               if vfsls1='/' & vfsls2<>'/' then\n                  mtabf2=mtabf2 'status l 12 <Status>'         /*@0UC*/\n               if vfsls2='/' then\n                  mtabf2=mtabf2 'status l 30 <Status>'         /*@0UC*/\n               if vfslm1='/' then\n                  mtabf2=mtabf2 'path l 20 <Mount Point>'      /*@0UC*/\n               if vfslm2='/' then\n                  mtabf2=mtabf2 'path l 60 <Mount Point>'      /*@0UC*/\n               mtabf2=mtabf2 'fsname l 44 <File system name>'\n               end\n                                                               /*@0UC*/\n            \"VPUT (MTABF2 VFSLSN VFSLAM VFSLRO VFSLS1 VFSLS2 VFSLBC\",\n                 \"VFSUSR VFSLM1 VFSLM2 VFSFST) PROFILE\" /*@DPC@DOA@DHC*/\n            end\n         \"REMPOP\"\n         end\n\n      when cmd='EDOPTS' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_edopt\")\"\n         if rc=0 then\n            \"VPUT (IPLACE PROF IMAC EDPRF) PROFILE\"\n          else\n            \"VGET (IPLACE PROF IMAC EDPRF) PROFILE\"\n         \"REMPOP\"\n         end\n\n      when cmd='MT' then\n         call main_filesys\n\n      when cmd='MKFS' then\n         call main_mkfs\n\n      when cmd='MKZFS' then\n         do\n         address tso 'bpxwizfs - newzfs' ltime.0 ltime.1\n         end\n\n      when cmd='ZFS' then\n         do\n         address tso 'bpxwizfs - -' ltime.0 ltime.1\n         end\n\n      when cmd='USER' then\n         call main_user\n\n      when cmd='ALLUSER' then\n         call main_alluser\n\n      when cmd='LSTUSER' then\n         call main_lstuser\n\n      when cmd='LSTGROUP' then    /* 2@DHA*/\n         call main_lstgrps\n\n      when cmd='GROUP' then\n         call main_group\n\n      when cmd='DEV' then\n         call main_devsetup makepath()\n\n      when cmd='ROOT' then\n         call main_rootsetup makepath()\n\n      when cmd='OMVSSEG' then\n         call main_omvsseg\n\n      when cmd='NEWF' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_perm\")\"\n         src=rc\n         \"REMPOP\"\n         if src=0 then\n            do\n            \"VPUT (TPERM) PROFILE\"\n            pathname=makepath()\n            call syscallm 'open (pathname)',\n                          O_WRONLY+O_EXCL+O_CREAT vperm\n            if retval<>-1 then\n               address syscall 'close' retval\n            end\n         end\n\n      when cmd='NEWD' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_perm\")\"\n         src=rc\n         \"REMPOP\"\n         if src=0 then\n            do\n           \"VPUT (TPERM) PROFILE\"\n            pathname=makepath()\n            call syscallm 'mkdir (pathname)' vperm\n            end\n         end\n\n      when cmd='NEWP' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_perm\")\"\n         src=rc\n         \"REMPOP\"\n         if src=0 then\n            do\n           \"VPUT (TPERM) PROFILE\"\n            pathname=makepath()\n            call syscallm 'mkfifo (pathname)' vperm\n            end\n         end\n\n      when cmd='NEWS' then\n         do\n         pathnm=makepath()\n         call makesym\n         end\n\n      when cmd='NEWL' then\n         do\n         pathname=makepath()\n         \"ADDPOP\"\n         vtext='L'\n         \"DISPLAY PANEL(\"pan.p_getpath\")\"\n         src=rc\n         \"REMPOP\"\n         if src=0 then\n            do\n            lnknm=makepath()\n            call syscallm 'link (lnknm) (pathname)'\n            end\n         end\n\n      when cmd='DEFAULT' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_dflts\")\"\n         src=rc\n         \"REMPOP\"\n         if src=0 then\n            \"VPUT (ADDIR ADREG ADCSP ADFIFO ADSYML) PROFILE\"\n          else\n            \"VGET (ADDIR ADREG ADCSP ADFIFO ADSYML) PROFILE\"\n         end\n\n      when cmd='SU' then\n         do\n         if cmdline<>'' then\n            if datatype(cmdline,'W') then\n               call syscallm 'setreuid' cmdline cmdline\n             else\n               do\n               pw.=''\n               call syscallm 'getpwnam (cmdline) pw.'\n               if pw.pw_uid<>'' then\n                  call syscallm 'setreuid' pw.pw_uid pw.pw_uid\n               end\n         else\n         if myeuid<>initeuid then\n            call syscallm 'setreuid' inituid initeuid\n         else\n         if myeuid<>0 then\n            call syscallm 'setreuid 0 0'\n         call syscallm 'getuid'\n         myuid=retval\n         call syscallm 'geteuid'\n         myeuid=retval\n         notpriv=1\n         if myeuid=0 then\n            do\n            call bpxwirac 'special'\n            if result=1 then\n               notpriv=0\n            end\n         end\n\n      when cmd='BPXACLA' then               /* 2@DAA*/\n         call editacl 'acl',makepath()\n\n      when cmd='BPXACLD' then               /* 2@DAA*/\n         call editacl 'dir',makepath()\n\n      when cmd='BPXACLF' then               /* 2@DAA*/\n         call editacl 'file',makepath()\n\n      when cmd='BPXISHOP' then              /* 2@DFA*/\n         call advancedopts\n\n      when cmd='FILTER' then                /* 2@DFA*/\n         call setfilter cmdline\n\n      when cmd='REF' then                   /* 6@DHA*/\n         do\n         call reflistproc cmdline\n         if cmdline='' & length(result)>0 then\n            pathmain=result\n         end\n\n      when cmd='BPXWISHISPF' then                   /* 10@DJA*/\n         do\n         cmdline=translate(cmdline)\n         if cmdline='YES' then\n            isp=1\n         else\n         if cmdline='ALL' then\n            isp=2\n         else\n            isp=0\n         end\n\n      otherwise\n         \"SETMSG MSG(\"msg.m_invcmd\")\" msgloc\n   end\n   return\n\n/**********************************************************************/\n/* reflistadd  20@DHA                                                 */\n/**********************************************************************/\nreflistadd:\nprocedure expose refloff reffile reflist.\n   parse arg path\n   if refloff=1 then return\n   refix=reflist.0\n   do i=1 to refix\n      if reflist.i==path then\n         leave\n   end\n   if i>refix then\n      i=refix        /* i is entry to delete */\n   do j=i to 2 by -1\n      k=j-1\n      reflist.j=reflist.k\n   end\n   reflist.1=path\n   return\n\n/**********************************************************************/\n/* reflistproc  130@DHA                                               */\n/**********************************************************************/\nreflistproc:\nprocedure expose refloff reffile o_rdonly reflist. pan. p_usrlst msg.,\n                 reflcntl\n   arg refopt refparm .\n   if refopt='' then\n      do\n      if refloff=1 then\n         do                               /* 4@PIA*/\n         \"SETMSG MSG(\"msg.m_invcmd\")\"\n         return ''\n         end\n      do forever\n         s=''\n         \"TBCREATE REF NOWRITE REPLACE NAMES(S,PATH,FULLPATH,I)\"\n         do i=1 to reflist.0\n            fullpath=reflist.i\n            path=fullpath\n            \"TBADD REF\"\n         end\n         rtnpath=''\n         \"TBTOP REF\"\n         \"TBDISPL REF CSRROW(1) AUTOSEL(NO) PANEL(\"pan.p_refltb\")\"\n         svrc=rc\n         \"TBEND REF\"\n         if svrc>4 then leave\n         if zcmd<>'' then\n            do\n            \"SETMSG MSG(\"msg.m_invcmd\")\"\n            iterate\n            end\n         if ztdsels=0 then iterate\n         if translate(s)='D' then\n            do\n            do i=i to reflist.0-1\n               j=i+1\n               reflist.i=reflist.j\n               reflist.j=''\n            end\n            iterate\n            end\n         if translate(s)='S' | s='/' then\n            do\n            rtnpath=fullpath\n            leave\n            end\n         \"SETMSG MSG(\"msg.m_invcmd\")\"\n      end\n      return rtnpath\n      end\n\n   if refopt='ON' then\n      do\n      if refparm='' then\n         refparm=0\n      if datatype(refparm,'W')<>1 then\n         do\n         \"SETMSG MSG(\"msg.m_badnum\")\"       /* @PIC*/\n         return\n         end\n      if refparm>64 then\n         do                                 /* 4@PIA*/\n         \"SETMSG MSG(\"msg.m_badnum\")\"\n         return\n         end\n      if refloff=0 then\n         call reflistproc 'off'\n      reflist.=''\n      address syscall 'open (reffile)' o_rdonly\n      fd=retval\n      refix=0\n      if fd<>-1 then\n         do forever\n            reflistarea=''\n            address syscall 'read (fd) reflistarea' 1024\n            if retval<>1024 then\n               do                /* 5@PIA*/\n               if refix>0 then\n                  refix=refix-1\n               leave\n               end\n            parse var reflistarea reflist.refix '00'x\n            if refparm>0 & refix=refparm then  /* max entries hit */\n               leave\n            refix=refix+1\n         end\n      if fd<>-1 then\n         address syscall 'close (fd)'\n      if refix=0 then\n         do\n         refix=16     /* set default number of entries if no list */\n         reflcntl=''\n         end\n       else\n         reflcntl=reflist.0\n      if refparm=0 then\n         reflist.0=refix\n       else\n         reflist.0=refparm\n      refloff=0\n      \"VPUT (REFLOFF) PROFILE\"\n      end\n   else\n   if refopt='OFF' then\n      do\n      call reflistproc 'save'\n      drop reflist.\n      refloff=1\n      \"VPUT (REFLOFF) PROFILE\"\n      end\n   else\n   if refopt='SAVE' then\n      do\n      if refloff=1 then return\n      address syscall 'unlink (reffile)'\n      call syscallm 'creat (reffile) 400'\n      fd=retval\n      if fd<>-1 then\n         do\n         refix=reflist.0\n         reflist.0=reflcntl\n         do i=0 to refix\n            refbuf=reflist.i || copies('00'x,1024)\n            call syscallm 'write (fd) refbuf 1024'\n            if retval=-1 then leave\n         end\n         reflist.0=refix\n         address syscall 'close (fd)'\n         end\n      end\n   else\n   if refopt='CLEAR' then\n      do\n      if refloff=1 then return\n      do i=1 to reflist.0\n         reflist.i=''\n      end\n      end\n   else\n      do\n      \"SETMSG MSG(\"msg.m_invcmd\")\"\n      end\n   return\n\n/**********************************************************************/\n/* advancedops                                                        */\n/**********************************************************************/\nadvancedopts:\n\n   if refloff=1 then   /* 4@DHA*/\n      reflset=''\n    else\n      reflset='/'\n   \"ADDPOP\"\n   \"DISPLAY PANEL(\"pan.p_adops\")\"\n   prc=rc\n   \"REMPOP\"\n   if prc<>0 then\n      do\n      \"VGET (TPLACE NOCONF NOEXCONF NOAUTOSK NOPTHMEM) PROFILE\"\n      return\n      end\n\n   \"VPUT (NOCONF NOEXCONF NOAUTOSK NOPTHMEM) PROFILE\"\n   if tplace='INHERIT' then\n      do\n      'VERASE (ZPLACE) PROFILE'\n      'VERASE (ZPLACE) SHARED'\n      \"VPUT (TPLACE) PROFILE\"\n      end\n   else\n     do\n     zplace=tplace\n     \"VPUT (TPLACE ZPLACE) PROFILE\"\n     end\n   if reflset='/' & refloff=1 then       /* 5@DHA*/\n      call reflistproc 'on'\n   else\n   if reflset<>'/' & refloff=0 then\n      call reflistproc 'off'\n   return\n\n/**********************************************************************/\n/* main panel: path specified                                         */\n/**********************************************************************/\nmain_path:\n   path=pathmain\n   if path='' then\n      do\n      call syscallm 'getcwd path'\n      if retval=-1 then return\n      call makevpath path\n      pathmain=path\n      xcmd=zcmd\n      \"CONTROL DISPLAY LOCK\"\n      \"DISPLAY PANEL(\"pan.p_main\")\"\n      zcmd=xcmd\n      end\n   call syscalle ENOENT 'lstat (path) st.'\n   if retval=-1 then\n      do\n      parse upper var errnojr +8 -4 errnojr\n      if errno=ENOENT then\n         if errnojr<>jrnodir & (zcmd='' | zcmd='N' | zcmd='n') then\n            call main_create\n          else\n            call syscallm 'lstat (path) st.'\n      end\n    else\n      select\n         when st.st_type=s_isdir then\n            if zcmd='' then\n               call path_dir addir\n             else\n               call path_dir zcmd\n         when st.st_type=s_ischr then\n            if zcmd='' then\n               call path_chr adcsp\n             else\n               call path_chr zcmd\n         when st.st_type=s_isreg then\n            if zcmd='' then\n               call path_reg adreg\n             else\n               call path_reg zcmd\n         when st.st_type=s_isfifo then\n            if zcmd='' then\n               call path_fifo adfifo\n             else\n               call path_fifo zcmd\n         when st.st_type=s_issym then\n            if zcmd='' then\n               call path_sym adsyml\n             else\n               call path_sym zcmd\n         otherwise\n   end\n   return\n\n/**********************************************************************/\n/* main panel: mkfs specified                                         */\n/**********************************************************************/\nmain_mkfs:\n   \"ADDPOP\"\n   do forever\n      \"DISPLAY PANEL(\"pan.p_mkfs\")\"\n      if rc<>0 then leave\n      fsn=strip(fsn,'B',\"'\")\n      if sysdsn(\"'\"fsn\"'\")='OK' then\n         do\n         \"SETMSG MSG(\"msg.m_dupfs\")\" msgloc\n         iterate\n         end\n      clas=''\n      if storclas<>'' then\n         clas=clas 'storclas('storclas')'\n      if dataclas<>'' then\n         clas=clas 'dataclas('dataclas')'\n      if mgmtclas<>'' then\n         clas=clas 'mgmtclas('mgmtclas')'\n      if volser<>'' then\n         clas=clas 'vol('volser')'\n      if unit<>'' then\n         clas=clas 'unit('unit')'\n      cmd=\"alloc da('\"fsn\"') dsntype(hfs)\",\n          \"space(\"fspri\",\"fssec\") dir(1) cyl new\" clas\n      xx=outtrap(off)\n      address tso cmd\n      if rc<>0 then\n         do\n         say translate(cmd)\n         \"SETMSG MSG(\"msg.m_alloc\")\" msgloc\n         iterate\n         end\n       else\n         address tso \"free da('\"fsn\"')\"\n      leave\n   end\n   \"REMPOP\"\n   return\n\n/* mkzfs moved to bpxwizfs xx@DDD*/\n\n/**********************************************************************/\n/* main panel: file system specified                                  */\n/**********************************************************************/\nmain_filesys:\n   first=1\n   selrow=1\n   sellev=1\n   if mtabf2='' then                                      /*@0UC3@08A*/\n      mtabf2='fsname l 44 <File system name>',                 /*@0UC*/\n             'status l 30 <Status>'\n   alcurcmd=1\n   do forever\n      call filesystable\n      x=actionlist('MTAB',first,selrow,pan.p_mt,mtabf2)        /*@0UC*/\n      if x=0 & zverb<>'' then\n         leave\n      first=selrow.sel_top\n      selrow=selrow.sellev.x\n      \"TBTOP MTAB\"\n      do forever\n         \"TBSKIP MTAB\"\n         if rc<>0 then leave\n         if s='' | s='_' then iterate\n         call filesys_cmd s\n      end\n   end\n   \"TBEND MTAB\"\n   return\n\n/**********************************************************************/\n/* main panel: create character special files                         */\n/**********************************************************************/\nmain_devsetup:\n   parse arg path\n   if path='' then\n      path='/dev'\n   \"ADDPOP\"\n   devtty='/'\n   devnull='/'\n   devcons='/'\n   ptys=100\n   call syscallm 'sysconf' sc_open_max\n   if retval=-1 | retval>9999 then\n      fds=9999\n    else\n      fds=retval\n   \"DISPLAY PANEL(\"pan.p_dev\")\"\n   src=rc\n   \"REMPOP\"\n   if src<>0 then return\n   do i=0 to ptys-1\n      ix=right(i,4,'0')\n      call devsysc 'ptyp'ix 1 i\n      if retval<0 then return\n      call devsysc 'ttyp'ix 2 i\n      if retval<0 then return\n   end\n   if devtty='/' then\n      call devsysc 'tty' 3 0\n   if retval<0 then return\n   if devnull='/' then\n      call devsysc 'null' 4 0\n   if retval<0 then return\n   if devcons='/' then\n      do\n      call devsysc 'console' 9 0\n      call syscallm 'chmod (pathnm) 222'\n      end\n   if retval<0 then return\n   do i=0 to fds-1\n      call devsysc 'fd'i 5 i\n      if retval<0 then return\n   end\n   return\n\ndevsysc:\n   parse arg nm mjr mnr\n   pathnm=path'/'nm\n   call syscalle EEXIST 'mknod (pathnm)' 666 mjr mnr\n   if retval=-1 & errno=EEXIST then\n      retval=0\n   return\n\n/**********************************************************************/\n/* main panel: root - build dirs found in root                        */\n/**********************************************************************/\nmain_rootsetup:\n   parse arg path\n   if path='' then\n      path='/'\n   \"ADDPOP\"\n   dir1='/'\n   dir2='/'\n   dir3='/'\n   dir4='/'\n   dir5='/'\n   dir6='/'\n   dir7='/'\n   dodev='/'\n   \"DISPLAY PANEL(\"pan.p_root\")\"\n   src=rc\n   \"REMPOP\"\n   if src<>0 then return\n   call syscallm 'chmod (path) 755'\n   if retval=-1 then return\n   call syscallm 'getgid'\n   gid=retval\n   call syscallm 'getuid'\n   uid=retval\n   call syscallm 'chown (path)' uid gid\n   if retval=-1 then return\n   if dir1='/' then\n      do\n      call mdsysc 'dev'\n      if retval=-1 then return\n      end\n   if dir2='/' then\n      do\n      call mdsysc 'bin'\n      if retval=-1 then return\n      call mdsysc 'bin/IBM'\n      if retval=-1 then return\n      end\n   if dir3='/' then\n      do\n      call mdsysc 'usr'\n      if retval=-1 then return\n      call mdsysc 'usr/mail'\n      if retval=-1 then return\n      address syscall 'chmod (pathnm) 777' /* mailx seems to need this*/\n      call mdsysc 'usr/man'\n      if retval=-1 then return\n      call mdsysc 'usr/man/C'\n      if retval=-1 then return\n      call mdsysc 'usr/man/C/cat1'\n      if retval=-1 then return\n      call mdsysc 'usr/man/C/cat1/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/man/C/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/man/Ja_JP'\n      if retval=-1 then return\n      call mdsysc 'usr/man/Ja_JP/cat1'\n      if retval=-1 then return\n      call mdsysc 'usr/man/Ja_JP/cat1/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/man/Ja_JP/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/charmap'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/charmap/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/locale'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/locale/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/localedef'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/localedef/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/msg'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/msg/C'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/msg/C/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/msg/Ja_JP'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/nls/msg/Ja_JP/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/cron'\n      if retval=-1 then return\n      call mdsysc 'usr/lib/cron/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/include'\n      if retval=-1 then return\n      call mdsysc 'usr/include/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/include/sys'\n      if retval=-1 then return\n      call mdsysc 'usr/include/sys/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/include/net'\n      if retval=-1 then return\n      call mdsysc 'usr/include/net/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/include/netinet'\n      if retval=-1 then return\n      call mdsysc 'usr/include/netinet/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/include/arpa'\n      if retval=-1 then return\n      call mdsysc 'usr/include/arpa/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/lpp'\n      if retval=-1 then return\n      call mdsysc 'usr/sbin'\n      if retval=-1 then return\n      call mdsysc 'usr/sbin/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/share'\n      if retval=-1 then return\n      call mdsysc 'usr/share/lib'\n      if retval=-1 then return\n      call mdsysc 'usr/share/lib/terminfo'\n      if retval=-1 then return\n      call mdsysc 'usr/share/lib/terminfo/IBM'\n      if retval=-1 then return\n      call mdsysc 'usr/spool'\n      if retval=-1 then return\n      call mdsysc 'usr/spool/cron'\n      if retval=-1 then return\n      call mdsysc 'usr/spool/cron/atjobs'\n      if retval=-1 then return\n      call mdsysc 'usr/spool/cron/crontabs'\n      if retval=-1 then return\n      address syscall 'unlink usr/lib/terminfo'\n      pathnm=path'/usr/lib/terminfo'\n      call syscallm 'symlink ../share/lib/terminfo (pathnm)'\n      end\n   if dir4='/' then\n      do\n      call mdsysc 'etc'\n      if retval=-1 then return\n      call mdsysc 'samples'        /* samples is in root */\n      if retval=-1 then return\n      call mdsysc 'samples/IBM'\n      if retval=-1 then return\n      end\n   if dir5='/' then\n      do\n      call mdsysc 'tmp'\n      if retval=-1 then return\n      end\n   if dir6='/' then\n      do\n      call mdsysc 'u'\n      if retval=-1 then return\n      end\n   if dir7='/' then\n      do\n      call mdsysc 'lib'\n      if retval=-1 then return\n      end\n   if dodev='/' then\n      call main_devsetup strip(path,'T','/')'/dev'\n   return\n\nmdsysc:\n   parse arg nm\n   pathnm=path'/'nm\n   call syscalle EEXIST 'mkdir (pathnm)' 755\n   if retval=-1 & errno=EEXIST then\n      retval=0\n   return\n\n/**********************************************************************/\n/* main panel: implicit create                                        */\n/**********************************************************************/\nmain_create:\n   call dir_create\n   return\n\n/**********************************************************************/\n/* main panel: omvsseg specified                                      */\n/**********************************************************************/\nmain_omvsseg:\n   \"ADDPOP\"\n   \"DISPLAY PANEL(\"pan.p_segauth\")\"\n   src=rc\n   \"REMPOP\"\n   if src<>0 then return\n   call bpxwirac 'omvsseg'\n   return\n\n/**********************************************************************/\n/* main panel: user specifed                                          */\n/**********************************************************************/\ngetdfltuser:                   /* 15@06A*/\n   numeric digits 12\n   dfltuser.=''\n   dfltgroup.=''\n   tcb=c2d(storage('21c',4))\n   stcb=c2d(storage(d2x(tcb+x2d(138)),4))\n   otcb=c2d(storage(d2x(stcb+x2d('d8')),4))\n   oapb=c2d(storage(d2x(otcb+x2d('64')),4))\n   oapblen=c2d(storage(d2x(oapb+5),3))\n   if oapblen<256 then return\n   dfltuser=storage(d2x(oapb+x2d(101)),8)\n   dfltgroup=storage(d2x(oapb+x2d('10a')),8)\n   if substr(dfltuser,1,1)<>'00'x then\n      address syscall 'getpwnam (dfltuser) dfltuser.'\n   if substr(dfltgroup,1,1)<>'00'x then\n      address syscall 'getgrnam (dfltgroup) dfltgroup.'\n   return\n\nmain_user:\n   \"ADDPOP\"\n   user=userid()\n   group=''\n   home=''\n   program=''\n   fsn=''\n   do forever\n      mkfsok=0\n      \"DISPLAY PANEL(\"pan.p_usere\")\"\n      if rc<>0 then leave\n      lcuser=translate(user,'abcdefghijklmnopqrstuvwxyz',,\n                            'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n      if fsn='' then\n         mode=700\n       else\n         mode=500\n      address syscall 'getpwnam (user) pw.'                    /* @02M*/\n      retval2 = retval                                         /* @M0A*/\n      if substr(dfltuser,1,1)='00'x then      /* @06A*/\n         call getdfltuser                     /* @06A*/\n      if retval2>0 &                   ,                       /* @0MC*/\n         pw.pw_uid<>dfltuser.pw_uid &  ,                       /* @06C*/\n         datatype(pw.pw_uid,W) then                            /* @0MA*/\n         call usersetup mode\n      else                                                     /* @02A*/\n      if retval=-1 | errno=emvssaf2err then                    /* @02A*/\n         msgid=msg.m_baduid                                    /* @02A*/\n       else\n         do\n         uid=nextuid()\n         if uid<0 then\n            msgid=msg.m_nouids\n          else\n            call usersetup mode uid\n         end\n         if sfstype=1 then pfs='HFS'\n         else\n         if sfstype=2 then pfs='ZFS'\n         else\n            pfs=''\n         if msgid=msg.m_defusr & pfs<>'' then\n            do\n            pw.=''\n            address syscall 'getpwnam (user) pw.'\n            group=pw.pw_gid\n            \"SETMSG MSG(\"msgid\")\" msgloc\n            if pfs='HFS' then call main_mkfs\n            else\n            if pfs='ZFS' then\n               address tso 'bpxwizfs - newzfs' ltime.0 ltime.1 /* @PIC*/\n            end\n         if msgid=msg.m_defusr & pfs<>'' & mkfsok<>-1 then\n            do\n            call syscallm 'mount (pwdir) (fsn)' pfs '(mtm_rdwr)'\n            if pfs='HFS' then\n            if retval=-1 then\n               do\n               address syscall 'stat (pwdir) st.'\n               drop mt.\n               if retval<>-1 then\n                  address syscall 'getmntent mt.' x2d(st.st_dev)\n               if fsn=mt.mnte_fsname.1 then\n                  address syscall 'chown (pwdir)' pwuid pwgid\n                else\n                  iterate\n               end\n             else\n               address syscall 'chown (pwdir)' pwuid pwgid\n            end\n      if mkfs<>-1 then\n         \"SETMSG MSG(\"msgid\")\" msgloc\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* main panel: alluser specified                                      */\n/**********************************************************************/\nmain_alluser:\n   nxuid=nextuid()-1\n   if nxuid<0 then\n      do\n      \"SETMSG MSG(\"msg.m_nouids\")\" msgloc\n      return\n      end\n   call bpxwirac 'users'\n   do ix=1 by 1 while queued()>0\n      pull cmdusr.ix .\n   end\n   cmdusr.0=ix-1\n   group=''\n   hpref='/u'\n   program='/bin/sh'\n   dogroups=1\n   \"ADDPOP\"\n   do forever\n      \"DISPLAY PANEL(\"pan.p_alluser\")\"\n      if rc<>0 then leave\n      temp=hpref'/'\n      call syscallm 'access (temp)' x_ok   /* @0DC*/\n      if retval=-1 then iterate\n      if dogroups then\n         if main_group() then\n            do\n            dogroups=0\n            \"VGET (ZVERB)\"\n            if zverb<>'CANCEL' then\n               leave\n             else\n               iterate\n            end\n      do ix=1 to cmdusr.0\n         user=cmdusr.ix\n         lcuser=translate(user,'abcdefghijklmnopqrstuvwxyz',,\n                               'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n         home=hpref'/'lcuser\n         pw.=''\n         address syscall 'getpwnam (user) pw.'\n         if pw.pw_uid<>'' then\n            iterate\n         nxuid=nxuid+1\n         call usersetup 700 nxuid\n         \"SETMSG MSG(\"msgid\")\" msgloc\n         if msgid<>msg.m_baduid then\n            \"CONTROL DISPLAY LOCK\"\n         \"DISPLAY PANEL(\"pan.p_alluser\")\"\n         if rc<>0 then\n            leave\n      end\n      leave\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* main panel: lstuser specified                                      */\n/**********************************************************************/\nmain_lstuser:\n   numeric digits 10\n   \"ADDPOP ROW(5) COLUMN(20)\"\n   \"CONTROL DISPLAY LOCK\"\n   \"DISPLAY PANEL(\"pan.p_usrlstm\")\"\n   \"REMPOP\"\n   call bpxwirac 'users'\n   do ix=1 by 1 while queued()>0\n      pull cmdout.ix .\n   end\n   cmdout.0=ix-1\n   gid.gr_members=0\n   gid.0=1\n   j=gr_mem\n   do i=1 to cmdout.0\n      gid.gr_members=gid.gr_members+1\n      gid.j=cmdout.i\n      j=j+1\n   end\n   \"TBCREATE USR NOWRITE REPLACE\",\n      \"NAMES(S,USER,UID,GID,HDIR,IPGM,LOCATE)\"\n   \"TBSORT USR FIELDS(USER,C,A)\"\n   s=''\n   locate=''\n   grps.=''\n   do j=gr_mem to gr_mem + gid.gr_members -1\n      pw.=''\n      address syscall 'getpwnam (gid.j) pw.'\n      user=gid.j\n      hdir=pw.pw_dir\n      ipgm=pw.pw_shell\n      uid=pw.pw_uid\n      gid=pw.pw_gid\n      if datatype(uid,'W')<>1 then\n         uid=-1\n      if datatype(gid,'W')<>1 then\n         gid=-1\n      if gid>-1 then\n         if grps.gid='' then\n            do\n            gr.=''\n            address syscall 'getgrgid' gid 'gr.'\n            grps.gid=gr.gr_name\n            gid=gr.gr_name\n            end\n          else\n            gid=grps.gid\n       else\n         gid=''\n      \"TBADD USR ORDER\"\n   end\n   table.0=ix\n   usrsortv=\"USER,C,A\"\n   do forever\n      \"TBTOP USR\"\n      zcmd=''\n      \"TBDISPL USR PANEL(\"pan.p_usrlst\")\"\n      if rc<>0 then leave\n      select\n        when zcmd='' then\n           nop\n        when zcmd='SORTN' then\n          \"TBSORT USR FIELDS(USER,C,A)\"\n        when zcmd='SORTU' then\n          \"TBSORT USR FIELDS(UID,N,A)\"\n        when zcmd='SORTG' then\n          \"TBSORT USR FIELDS(GID,C,A)\"\n        when zcmd='PRNT' then\n           do\n           hdr1=''\n           hdr2=time() date() L#userl\n           hdr3=''\n           hdr4=left(L#user,8),\n                right(L#uid,9),\n                ' 'left(L#gid,8),\n                left(L#hd,40),\n                left(L#ip,40)\n           hdr0=4\n           'TBTOP USR'\n           call print_hdr 1\n           do forever\n              'TBSKIP USR'\n              if rc<>0 then\n                 leave\n              \"VGET (ZLSTNUML)\"\n              if zlstlpp=zlstnuml then\n                 call print_hdr pg+1\n              ln=left(user,8),\n                 right(uid,9),\n                 right(gid,9),\n                 left(hdir,40),\n                 left(ipgm,40)\n              'LIST BUFNAME(LN) LINELEN('length(ln)')'\n           end\n           'SETMSG MSG('msg.m_printed')'\n           end\n        otherwise\n           \"SETMSG MSG(\"msg.m_invcmd\")\" msgloc\n      end\n   end\n   return\n\n/**********************************************************************/\n/* main panel: lstgrps specified                                      */\n/************************************************************** 60@DHA*/\nmain_lstgrps:\n   numeric digits 10\n   call bpxwirac 'omvsgroup'\n   do ix=1 by 1 while queued()>0\n      pull cmdout.ix cmdout.ix.1 .\n   end\n   cmdout.0=ix-1\n   \"TBCREATE GRP NOWRITE REPLACE\",\n      \"NAMES(S,GROUP,GID,LOCATE)\"\n   \"TBSORT GRP FIELDS(GROUP,C,A)\"\n   s=''\n   locate=''\n   do i=1 to cmdout.0\n      group=cmdout.i\n      gid=cmdout.i.1\n      locate=group\n      \"TBADD GRP ORDER\"\n   end\n   do forever\n      \"TBTOP GRP\"\n      zcmd=''\n      \"TBDISPL GRP PANEL(\"pan.p_grplst\")\"\n      if rc<>0 then leave\n      select\n        when zcmd='' then\n           nop\n        when zcmd='SORTN' then\n          \"TBSORT GRP FIELDS(GROUP,C,A)\"\n        when zcmd='SORTG' then\n          \"TBSORT GRP FIELDS(GID,N,A)\"\n        when zcmd='PRNT' then\n           do\n           hdr1=''\n           hdr2=time() date() 'Group list'\n           hdr3=''\n           hdr4=left('Group',8),\n                right('GID',10)\n           hdr0=4\n           'TBTOP GRP'\n           call print_hdr 1\n           do forever\n              'TBSKIP GRP'\n              if rc<>0 then\n                 leave\n              \"VGET (ZLSTNUML)\"\n              if zlstlpp=zlstnuml then\n                 call print_hdr pg+1\n              ln=left(group,8),\n                 right(gid,10)\n              'LIST BUFNAME(LN) LINELEN('length(ln)')'\n           end\n           'SETMSG MSG('msg.m_printed')'\n           end\n        otherwise\n           \"SETMSG MSG(\"msg.m_invcmd\")\" msgloc\n      end\n   end\n   return\n\n/**********************************************************************/\n/* main panel: group specifed                                         */\n/**********************************************************************/\nmain_group:\n   grp.0=0\n   highgid=0\n   \"ADDPOP\"\n   \"DISPLAY PANEL(\"pan.p_grp\")\"\n   if rc<>0 then\n      do\n      \"REMPOP\"\n      return 1\n      end\n   if autogid='' then         /* 3@DFA*/\n      if checkautoid() then\n         return 1\n   call bpxwirac 'omvsgroup'\n   do ix=1 by 1 while queued()>0\n      pull cmdout.ix\n   end\n   cmdout.0=ix-1\n   do i=1 to cmdout.0\n      parse var cmdout.i grp.i gid .\n      if datatype(gid,'W') then\n         if gid>highgid then\n            highgid=gid\n   end\n   grp.0=cmdout.0\n   do i=1 to grp.0\n      address syscall 'getgrnam (grp.i) gr.'\n      if retval=0 then\n         do\n         grname=grp.i\n         if autogid=1 then      /* 3@DFA*/\n            gid='AUTOGID'\n          else\n            gid=highgid+1\n         \"SETMSG MSG(\"msg.m_grsetup\")\" msgloc\n         \"CONTROL DISPLAY LOCK\"\n         \"DISPLAY PANEL(\"pan.p_grp\")\"\n         if autogid=1 then                                   /* 3@DFA*/\n            call bpxwirac 'altgroup' grp.i 'omvs(autogid)'\n          else\n            call bpxwirac 'altgroup' grp.i 'omvs(gid('highgid+1'))'\n         if result=0 & autogid=0 then                        /* @DFC*/\n            highgid=highgid+1\n         end\n   end\n   \"REMPOP\"\n   return 0\n\n/**********************************************************************/\n/* path selection: file selected is directory                         */\n/**********************************************************************/\npath_dir:\narg selcode,fromsl\n   if selcode<>'' then\n      vactc=selcode\n    else\n      do\n      \"ADDPOP COLUMN(20) ROW(1)\"\n      src=popobj(pan.p_sdir)\n      \"REMPOP\"\n      if src<>0 then return 0\n      end\n   select\n      when vactc='L' then call dir_list\n      when vactc='N' then call dir_create\n      when vactc='A' then call dir_settings\n      when vactc='D' then call dir_delete\n      when vactc='R' then call dir_rename\n      when vactc='C' then call dir_copy\n      when vactc='I' then call dir_replace\n      when vactc='P' then call dir_print\n      when vactc='M' then call dir_compare\n      when vactc='F' then call dir_find\n      when vactc='W' then call dir_cwd\n      when vactc='O' then call dir_mount\n      when vactc='U' then call fsattr\n      when vactc='X' then call linecmd\n      otherwise\n        if fromsl<>'' then return 1   /* @0BA*/\n        if selcode<>'' then call path_dir\n   end\n   return 0\n\n/**********************************************************************/\n/* path selection: file selected is char special                      */\n/**********************************************************************/\npath_chr:\narg selcode,fromsl\n   if selcode<>'' then\n      vactc=selcode\n    else\n      do\n      \"ADDPOP COLUMN(20) ROW(1)\"\n      src=popobj(pan.p_scsp)\n      \"REMPOP\"\n      if src<>0 then return 0\n      end\n   select\n      when vactc='A' then call chr_settings\n      when vactc='D' then call chr_delete\n      when vactc='R' then call chr_rename\n      otherwise\n        if fromsl<>'' then return 1   /* @0BA*/\n        if selcode<>'' then call path_chr\n   end\n   return 0\n\n/**********************************************************************/\n/* path selection: file selected is regular file                      */\n/**********************************************************************/\npath_reg:\narg selcode,fromsl\n   if selcode<>'' then\n      vactc=selcode\n    else\n      do\n      \"ADDPOP COLUMN(20) ROW(1)\"\n      src=popobj(pan.p_sreg)\n      \"REMPOP\"\n      if src<>0 then return 0\n      end\n   select\n      when vactc='B' then call reg_brtext\n      when vactc='V' then call reg_brrecs\n      when vactc='E' then call reg_edit\n      when vactc='G' then call reg_edit\n      when vactc='A' then call reg_settings\n      when vactc='D' then call reg_delete\n      when vactc='R' then call reg_rename\n      when vactc='C' then call reg_copy\n      when vactc='I' then call reg_replace\n      when vactc='P' then call reg_print\n      when vactc='M' then call reg_compare\n      when vactc='F' then call reg_find\n  /*  when vactc='X' then call reg_run */\n      when vactc='U' then call fsattr\n      when vactc='X' then call linecmd\n      otherwise\n        if fromsl<>'' then return 1   /* @0BA*/\n        if selcode<>'' then call path_reg\n   end\n   return 0\n\n/**********************************************************************/\n/* path selection: file selected is fifo                              */\n/**********************************************************************/\npath_fifo:\narg selcode,fromsl\n   if selcode<>'' then\n      vactc=selcode\n    else\n      do\n      \"ADDPOP COLUMN(20) ROW(1)\"\n      src=popobj(pan.p_sfifo)\n      \"REMPOP\"\n      if src<>0 then return 0\n      end\n   select\n      when vactc='A' then call fifo_settings\n      when vactc='D' then call fifo_delete\n      when vactc='R' then call fifo_rename\n      otherwise\n        if fromsl<>'' then return 1   /* @0BA*/\n        if selcode<>'' then call path_fifo\n   end\n   return 0\n\n/**********************************************************************/\n/* path selection: file selected is symlink                           */\n/**********************************************************************/\npath_sym:\narg selcode\n   if selcode<>'' then\n      vactc=selcode\n    else\n      do\n      \"ADDPOP COLUMN(20) ROW(1)\"\n      src=popobj(pan.p_ssym)\n      \"REMPOP\"\n      if src<>0 then return\n      end\n   select\n      when vactc='A' then call sym_settings\n      when vactc='D' then call sym_delete\n      when vactc='R' then call sym_rename\n      otherwise\n        call syscallm 'stat (path) st.'\n        result=0\n        select\n           when st.st_type=s_isdir then\n              call path_dir selcode,1\n           when st.st_type=s_ischr then\n              call path_chr selcode,1\n           when st.st_type=s_isreg then\n              call path_reg selcode,1\n           when st.st_type=s_isfifo then\n              call path_fifo selcode,1\n           otherwise\n        end\n        if result=1 then call path_sym   /* @0BA*/\n   end\n   return\n\n/**********************************************************************/\n/* directory panel: file list selected                                */\n/**********************************************************************/\ndir_list:\n   if vdirpl<>'/' then        /* 2@DHA*/\n   do\n   address syscall 'realpath (path) dlpath'\n   if rc>=0 & retval<>-1 then\n      path=dlpath\n   end\n   if substr(path,length(path))<>'/' then\n      path=path'/'\n   /* if native ispf selected just call ispf dirlist and return 8@DJA*/\n   if isp>1 then\n      do\n      'dirlist path(path)'\n      if rc>8 then\n        'SETMSG MSG('zerrmsg')'\n      return\n      end\n\n   selrow=1\n   first=1\n   sellev=1\n   level=0\n   alcurcmd=1\n   row.=''\n   if substr(path,length(path))='/' then\n      path.level=path\n    else\n      path.level=path'/'\n   first.level=selrow\n   row.level=first\n   if dirh='' then\n      dirh='filetp l 4 <Type>',\n           'filenm l 255 <Filename>'\n\n   /* direxit:   loop control */\n   do direxit=1\n      if debug=2 then\n         do\n         say 'direxit loop level='level\n         trace ?i\n         end\n      if level<0 then leave direxit\n      path=path.level\n      call reflistadd path        /* @DHA */\n      nxlevel=level+1\n      row.nxlevel=''\n      if dir_mktable() then        /* build/rebuild the dir list */\n         do\n         level=level-1  /* backup one level on error */\n         iterate\n         end\n      \"TBTOP DIR\"\n\n      /* dirloop:   loop control */\n      do dirloop=1\n         first=first.level\n         selrow=row.level\n         row=row.level\n         path=path.level\n         sellev=level\n         x=actionlist('DIR',first,selrow,pan.p_dir,dirh,path,1)\n         if debug=2 then trace ?i\n         if x=0 then\n            if zverb='EXIT' | zverb='RETURN' then\n               leave direxit\n            else\n            if zverb='CANCEL' then  /* @DFC*/\n               do\n               level=level-1  /* backup one level on cancel */\n               iterate direxit\n               end\n            else\n            if word(zverb,1)='REFRESH' then      /* 3@DHA*/\n               iterate direxit\n            else\n            if word(zverb,1)='FILTER' then      /* 6@DFA*/\n               do\n               call setfilter substr(zverb,8)\n               iterate direxit\n               end\n            else\n            if word(zverb,1)='EMPTY' then      /* 10@DFA*/\n               do\n               if pattern.0=0 then\n                  level=level-1       /* treat as cancel if no filter */\n                else\n                  do\n                  call setfilter '*'  /* remove filter and refresh */\n                  'SETMSG MSG('msg.m_rmfilt')'    /* @PIA*/\n                  end\n               iterate direxit\n               end\n            else\n            if selrow.sellev.0=0 & word(zverb,1)='SELECT' then\n               do\n               call dir_cursel\n               if row.nxlevel<>'' then\n                  do\n                  level=level+1\n                  first.level=1                /* @0EA*/\n                  iterate direxit\n                  end\n               end\n         first=selrow.sel_top\n         first.level=first\n         row.level=selrow\n         do selix=1 to selrow.sellev.0\n            \"TBTOP DIR\"\n            selnum=selrow.sellev.selix\n            selrow=selnum\n            row.level=selrow\n            \"TBSKIP DIR NUMBER(\"selnum\")\"\n            if s='' | s='_' then iterate\n            else\n            if absel<>'' & s='/' then\n               s=absel\n            selval=s\n            s='_'\n            \"TBPUT DIR\"\n            selval=translate(selval)\n            if filetpn=1 then\n               if selval='S' | selval='/' then\n                  selval=addir\n            if filenm\\=='.' | selval<>'L' then\n               do\n               path=pathnm\n               call makevpath pathnm\n               end\n            select\n               when filetpn=1 then\n                  do\n                  if selval='S' | selval='/' then\n                     selval=addir\n                  src=0                          /* 10@0EA*/\n                  /* if selval not a valid dir command then prompt */\n                  if pos(selval,'LNADRCIPMFWOUX')=0 then\n                     do\n                     \"ADDPOP COLUMN(20) ROW(1)\"\n                     vactc=''\n                     src=popobj(pan.p_sdir)\n                     \"REMPOP\"\n                     selval=vactc\n                     end\n                  if src=0 then\n                   if selval<>'L' then\n                     call path_dir selval\n                   else\n                     if row.nxlevel='' then\n                        do\n                        if vdirpl<>'/' then        /* 2@DHA*/\n                        do\n                        address syscall 'realpath (pathnm) dlpath'\n                        if rc>=0 & retval<>-1 then\n                           pathnm=dlpath\n                        end\n                        if substr(pathnm,length(pathnm))<>'/' then\n                           pathnm=pathnm'/'\n                        path=pathnm\n                        path.nxlevel=pathnm\n                        row.nxlevel=0\n                        alcurcmd=1\n                        first.nxlevel=first.level\n                        end\n                  end\n               when filetpn=2 then\n                  do\n                  if selval='S' | selval='/' then\n                     selval=adcsp\n                  call path_chr selval\n                  end\n               when filetpn=3 then\n                  do\n                  if selval='S' | selval='/' then\n                     selval=adreg\n                  call path_reg selval\n                  end\n               when filetpn=4 then\n                  do\n                  if selval='S' | selval='/' then\n                     selval=adfifo\n                  call path_fifo selval\n                  end\n               when filetpn=5 then\n                  do\n                  if selval='S' | selval='/' then\n                     selval=adsyml\n                  if selval<>'L' then\n                     call path_sym selval\n                  else\n                     do                                      /* 9@0KA*/\n                     address syscall 'realpath (pathnm) dlpath'\n                     rprc = rc\n                     rpretval = retval\n                     drop tmpst.\n                     address syscall 'lstat (dlpath) tmpst.'\n                     if tmpst.st_type<>s_isdir then\n                       call path_sym\n                     else\n                       if row.nxlevel='' then\n                          do\n                          if vdirpl<>'/' then      /* 2@DHA*/\n                          do\n                          if rprc>=0 & rpretval<>-1 then\n                             pathnm=dlpath\n                          end\n                          if substr(pathnm,length(pathnm))<>'/' then\n                             pathnm=pathnm'/'\n                          path=pathnm\n                          path.nxlevel=pathnm\n                          row.nxlevel=0\n                          alcurcmd=1\n                          first.nxlevel=first.level\n                          end\n                     end                                      /* @0KA*/\n                  end\n               otherwise\n                  call syscallm 'stat (path) st.'\n            end\n            /* the following will show progress on multiple selections\n               if the no continue option is selected.  In general the\n               progress message will not show.  This is done so that\n               a blank message can conditionally be displayed to\n               detect if the selected function did issue a message.\n               In that case this will stop the multiselection\n               processing and show the path in error */\n            if vdirnom='/' & selrow.sellev.0>1 then   /* 25@DFA*/\n               do\n               'SETMSG MSG('msg.m_blank') COND'\n               if rc=4 then\n                  do\n                  if length(filenm)>70 then\n                     do\n                     tempnm=filenm\n                     filenm='<<' substr(filenm,length(filenm)-67)\n                     end\n                   else\n                     tempnm=''\n                  'ADDPOP'\n                  'DISPLAY PANEL('pan.p_multe')'\n                  'REMPOP'\n                  if length(tempnm)>0 then\n                     filenm=tempnm\n                  leave selix\n                  end\n               'ADDPOP'\n               'CONTROL DISPLAY LOCK'\n               'DISPLAY PANEL('pan.p_multi')'\n               'REMPOP'\n               end\n         end     /* end selix */\n         /* if staying on this level and\n             null enter does not refresh then iterate dirloop  @DFC*/\n         if selrow.sellev.0=0 & row.nxlevel='' & vdirent<>'/' then\n            iterate dirloop\n         if row.nxlevel<>'' then\n            do\n            level=level+1\n            first.level=1               /* @0EA*/\n            end\n         iterate direxit\n      end\n      if level>=0 then\n         call makevpath path\n   end\n   return\n\ndir_mktable:\n         st.=''\n         s='_'\n         parse value '' with filetpn filesz filemt filect,\n                             filecd filemd fileuid fileusr pathnm\n         if substr(path,length(path))<>'/' then\n            path=path'/'\n\n         /*----------------------------------------------------------*/\n         /* Call readdir2.  Any stat failure will cause the syscall  */\n         /* to fail and no information will be returned.             */\n         /*----------------------------------------------------------*/\n         Call syscalle EIO 'readdir (path) dir. st.'          /* @0HC*/\n\n         if retval=-1 then\n          do                  /* Call readdir and then lstat   21@0HA*/\n           /*--------------------------------------------------------*/\n           /* readdir2 failed.  Call readdir to get the directory    */\n           /* list entries.  Then call lstat for each entry.  This   */\n           /* way, we will be able to get to the root directory      */\n           /* This is slower than readdir2, but will not trip over   */\n           /* a black hole file on the stat call.                    */\n           /*--------------------------------------------------------*/\n\n           Call syscallm 'readdir (path) dir.'\n           If Retval = -1 Then\n            return 1\n\n           /*--------------------------------------------------------*/\n           /* Loop through directory entries and get stat info       */\n           /*--------------------------------------------------------*/\n           st. = ''\n           Do i = 1 to DIR.0     /* Loop through directory entries   */\n            Pathnm = path || dir.i\n            address syscall  'lstat (pathnm) st.'i'.'\n           End                 /* End Loop through directory entries */\n          end                 /* End Call readdir and then lstat @0HA*/\n\n         \"TBCREATE DIR NOWRITE REPLACE\",\n            \"NAMES(S,FILENM,LOCATE,FILETP,FILETPN,FILESZ,\",\n                  \"FILEMT,FILECT,FILECD,FILEXA,FILESID,FILESTK,\",\n                  \"FILEMD,FILEUID,FILEUSR,PATHNM)\"\n         sortx=pos(flsort,'NCTPSOM')     /* 10@P8C*/\n         if sortx=0 then sortx=1\n         sortkey=word(\"FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A\",\n                      \"FILESZ,C,D FILEUSR,C,A FILECT,C,D\",sortx)\n         sortx=pos(flsorts,'NCTPSOM')\n         if sortx>0 then\n            sortkey=sortkey',' ||,\n               word(\"FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A\",\n                    \"FILESZ,C,D FILEUSR,C,A FILECT,C,D\",sortx)\n         do i=1 to dir.0\n            filenm=dir.i\n            if pattern.0>0 then                 /* 3@DFC */\n               if matchpat(1,filenm)=0 then\n                  iterate\n            pathnm=path || filenm\n            locate=translate(filenm)\n            filetp='?'\n            filecd=''\n            call dirstat i\n            \"TBADD DIR\"\n         end\n         \"TBSORT DIR FIELDS(\"sortkey\")\"\n   return 0\n\ndir_cursel:\n               parse var zverb . csrcode csrline\n               if csrcode='P' then\n                  do\n                  'TBTOP DIR'\n                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'\n                  panpath=path\n                  path=path || filenm\n                  pathnm=path\n                  if filetpn=s_isdir then\n                     parse value 1 1 with faclch daclch\n                   else\n                     parse value 0 0 with faclch daclch\n                  cmd=path\n                  'SETMSG MSG('msg.m_gentxt')'\n                  \"ADDPOP\"\n                  \"DISPLAY PANEL(\"pan.p_arights\")\"\n                  if rc<>0 then chacc=''\n                  \"REMPOP\"\n                  if chacc='M' then\n                     do\n                     call info filetpn\n                     zcmd='MODE'\n                     call changeatt\n                     end\n                  else\n                  if chacc='A' then\n                     call editacl 'acl',path\n                  else\n                  if chacc='F' then\n                     call editacl 'file',path\n                  else\n                  if chacc='D' then\n                     call editacl 'dir',path\n                  path=panpath\n                  end\n               else\n               if csrcode='O' then\n                  do\n                  'TBTOP DIR'\n                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'\n                  panpath=path\n                  path=path || filenm\n                  pathnm=path\n                  cmd=path\n                  'SETMSG MSG('msg.m_gentxt')'\n                  call info filetpn\n                  zcmd='USER'\n                  call changeatt\n                  path=panpath\n                  end\n               else\n               if pos(csrcode,'CS-')>0 then\n                  do\n                  'TBTOP DIR'\n                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'\n                  panpath=path\n                  path=path || filenm\n                  pathnm=path\n                  select\n                    when filetpn=s_isdir then call dir_settings\n                    when filetpn=s_isreg then call reg_settings\n                    when filetpn=s_ischr then call chr_settings\n                    when filetpn=s_issym then call sym_settings\n                    when filetpn=s_isfifo then call fifo_settings\n                    otherwise\n                       nop\n                  end\n                  path=panpath\n                  end\n               else\n               if csrcode='T' then\n                  do\n                  'TBTOP DIR'\n                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'\n                  panpath=path\n                  path=path || filenm\n                  pathnm=path\n                  select\n                    when filetpn=s_isdir then\n                       if addir<>'L' then\n                          call path_dir addir,1\n                        else\n                          do\n                          if row.nxlevel='' then\n                             do\n                             if vdirpl<>'/' then        /* 2@DHA*/\n                             do\n                             address syscall 'realpath (pathnm) dlpath'\n                             if rc>=0 & retval<>-1 then\n                                pathnm=dlpath\n                             end\n                             if substr(pathnm,length(pathnm))<>'/' then\n                                pathnm=pathnm'/'\n                             path=pathnm\n                             path.nxlevel=pathnm\n                             row.nxlevel=0\n                             alcurcmd=1\n                             first.nxlevel=first.level\n                             end\n                          end\n                    when filetpn=s_isreg then call path_reg adreg,1\n                    when filetpn=s_ischr then call path_chr adcsp,1\n                    when filetpn=s_isfifo then call path_fifo adfifo,1\n                    when filetpn=s_issym then\n                       if adsyml<>'L' then\n                          call path_sym adsyml,1\n                        else\n                          do\n                          if row.nxlevel='' then\n                             do\n                             if vdirpl<>'/' then        /* 2@DHA*/\n                             do\n                             address syscall 'realpath (pathnm) dlpath'\n                             if rc>=0 & retval<>-1 then\n                                pathnm=dlpath\n                             end\n                             if substr(pathnm,length(pathnm))<>'/' then\n                                pathnm=pathnm'/'\n                             path=pathnm\n                             path.nxlevel=pathnm\n                             row.nxlevel=0\n                             alcurcmd=1\n                             first.nxlevel=first.level\n                             end\n                          end\n                    otherwise\n                       nop\n                  end\n                  path=panpath\n                  end\n               else\n               if csrcode='3e'x then\n                  do\n                  end\n               else\n                  do\n                  'TBTOP DIR'\n                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'\n                  panpath=path\n                  path=path || filenm\n                  pathnm=path\n                  call showobj\n                  path=panpath\n                  end\n   return\n\n/* pattern build and match routines  75@DFA*/\n\nsetfilter:\n   parse arg pat\n   prc = 0                          /* @PHA*/\n   if pat='' then\n      do\n      pat=pattern.1\n      \"ADDPOP\"\n      \"DISPLAY PANEL(\"pan.p_filter\")\"\n      prc=rc\n      \"REMPOP\"\n      end\n   if prc>0 then\n      return\n   pattern.0=0\n   if pat='*' then\n      pat=''\n   if pat<>'' then\n      do\n      pattern.1=pat\n      call parsepat 1,pat\n      pattern.0=1\n      end\n   return\n\nparsepat: procedure expose pattern.\n   parse arg patix,pat\n   pattern.patix.0=0\n   j=0\n   /* break each pattern segment into a var using last level index.\n      if var is * it means match to next segment\n      if var is ** it means match next sement at end of string\n      else var is an absolute string match                       */\n   do while pat<>''\n      j=j+1\n      if pos('*',pat)=0 then\n         do\n         pattern.patix.j=pat\n         pat=''\n         if j>1 then\n            do\n            i=j-1\n            if pattern.patix.i='*' then\n               pattern.patix.i='**'\n            end\n         leave\n         end\n      parse var pat pattern.patix.j '*' pat\n      if length(pattern.patix.j)=0 then\n         do\n         pattern.patix.j='*'\n         i=j-1\n         if pattern.patix.i='*' then   /* eliminate dup * */\n            j=j-1\n         end\n        else\n         do\n         j=j+1\n         pattern.patix.j='*'\n         end\n   end\n   pattern.patix.0=j\n   return\n\nmatchpat: procedure expose pattern.\nparse arg patix,str\ndo j=1 to pattern.patix.0\n   if substr(pattern.patix.j,1,1)='*' then\n      do\n      jj=j\n      j=j+1\n      if j>pattern.patix.0 then\n         do\n         str=''\n         leave\n         end\n      if pattern.patix.jj='**' then\n         p=lastpos(pattern.patix.j,str)\n       else\n         p=pos(pattern.patix.j,str)\n      end\n     else\n      p= substr(str,1,length(pattern.patix.j))=pattern.patix.j\n   if p=0 then return 0\n   str=substr(str,p+length(pattern.patix.j))\nend\nif str='' then\n   return 1\nreturn 0\n\n/**********************************************************************/\n/* directory panel: create selected                                   */\n/**********************************************************************/\ndir_create:\n   crpath=path\n   tattrs='N'               /* @DHA*/\n   do forever\n      call makevpath crpath\n      \"ADDPOP\"\n      zcmd=''\n      \"DISPLAY PANEL(\"pan.p_creat\")\"\n      prc=rc\n      \"REMPOP\"\n      if prc<>0 then return\n      if zcmd<>'' then\n         if zcmd<>'SHOWOBJ' then\n            return\n          else\n            do\n            crpath=makepath()\n            call showobj\n            iterate\n            end\n      leave\n   end\n   \"VPUT (TPERM) PROFILE\"\n   pathnm=makepath()\n   tattrs=translate(tattrs)\n   if tattrs='/' then tattrs='Y'\n   select\n     when vtype='D' then\n       do\n       call syscallm 'mkdir (pathnm)' vperm\n       if tattrs='Y' then              /* @DHA*/\n          call dir_settings /* @DHA*/\n       end\n\n     when vtype='C' then\n       do\n       call syscallm 'mknod (pathnm)' vperm vmajor vminor\n       if tattrs='Y' then               /* @DHA*/\n          call chr_settings /* @DHA*/\n       end\n\n     when vtype='L' then\n       do\n       \"ADDPOP\"\n       vtext='L'\n       \"DISPLAY PANEL(\"pan.p_getpath\")\"\n       prc=rc\n       \"REMPOP\"\n       if prc=0 then\n          do\n          lnknm=makepath()\n          call syscallm 'link (lnknm) (pathnm)'\n          if tattrs='Y' then   /* @DHA */\n             call sym_settings /* @DHA*/\n          end\n       end\n\n     when vtype='R' then\n       do\n       call syscallm 'open (pathnm)',\n          O_WRONLY+O_EXCL+O_CREAT vperm\n       if retval>=0 then\n          do\n          address syscall 'close' retval\n          if tattrs='Y' then               /* @DHA*/\n             call reg_settings /* @DHA*/\n          if vsrcs='' then vsrce=''        /* @PJA*/\n          select\n             when vsrce='E' then\n                call oedit pathnm\n             when vsrce='C' then\n                do\n                path=pathnm\n                call reg_replace 'F'\n                end\n             when vsrce='D' then\n                do\n                path=pathnm\n                call reg_replace 'D'\n                end\n             otherwise\n          end\n          end\n       end\n\n     when vtype='F' then\n       do\n       call syscallm 'mkfifo (pathnm)' vperm\n       end\n\n     when vtype='S' then\n       call makesym\n\n     otherwise\n   end\n\n   return\n\n/**********************************************************************/\n/* directory panel: settings selected                                 */\n/**********************************************************************/\ndir_settings:\n   call settings pan.p_settings s_isdir 'Directory'\n   return\n\n/**********************************************************************/\n/* directory panel: delete selected                                   */\n/**********************************************************************/\ndir_delete:\n   call delete 'rmdir'\n   if result<>enotempty then\n      return\n   if noconf='/' then\n      rdelopt='D'\n    else\n      rdelopt='A'\n   rdeldone=0\n   call rdelete path\n   if rdeldone>0 then\n      return\n   address syscall 'lstat (path) st.'\n   if retval=-1 then\n      return\n   call syscallm 'rmdir (path)'\n   return\n\n/**********************************************************************/\n/* directory panel: rename selected                                   */\n/**********************************************************************/\ndir_rename:\n   call rename\n   return\n\n/**********************************************************************/\n/* directory panel: copy selected                                     */\n/**********************************************************************/\ndir_copy:\n   call syscallm \"readdir (path) dir. st.\"\n   if retval=-1 then return\n   \"ADDPOP\"\n   optcb=''\n   optcl='/'\n   optcc=''\n   optcs='/'\n   optcm='/'\n   alcurcmd=1\n   do forever\n      zcmd=''\n      \"DISPLAY PANEL(\"pan.p_cpydpds\")\"\n      if rc<>0 then leave\n      if zcmd='SHOWOBJ' then\n         do\n         call showobj\n         iterate\n         end\n      pan=pan.p_cpydpds\n      if substr(dsn,1,1)=\"'\" then\n         cdsn=strip(dsn,,\"'\")\n       else\n         cdsn=strip(sysvar(syspref)'.'dsn,,'.')\n      util='OGET'\n      if optcb='/' then\n         utilopt='BINARY'\n       else\n         utilopt='TEXT'\n      if optcc='/' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_cpyconv\")\"\n         src=rc\n         \"REMPOP\"\n         if src<>0 then\n            do\n            \"VGET (ZVERB)\"\n            if ZVERB='CANCEL' then\n               iterate\n             else\n               leave\n            end\n         if tabdsn='' then\n            utilopt=utilopt 'convert(yes)'\n          else\n            utilopt=utilopt 'convert('tabdsn')'\n         end\n      suf='.'strip(suffix,'L','.')\n      copied=0\n      \"TBCREATE ML NAMES(S,MEM,FNAME,CPATH,LOCATE,UPDATE) NOWRITE\",\n             \"REPLACE\"\n      \"TBSORT ML FIELDS(FNAME)\"\n      if optcm='/' then\n         s='_'\n       else\n         s='/'\n      update=''\n      do i=1 to dir.0\n         if st.i.st_type<>s_isreg then\n            iterate\n         if optcs='/' then\n            do\n            parse var dir.i mem '.' tsuf\n            if suf<>'.' & suf<>'.'tsuf then\n               iterate\n            end\n          else\n            mem=dir.i\n         if optcl='/' then\n            mem=translate(mem)\n         if length(mem)>8 then\n            iterate\n         valchr='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$1234567890'\n         if verify(mem,valchr)>0 then\n            iterate\n         valchr='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$'\n         if verify(substr(mem,1,1),valchr)>0 then\n            iterate\n         fname=dir.i\n         locate=fname\n         cpath=\"'\"quotes(path\"/\"fname)\"'\"\n         \"TBADD ML ORDER\"\n      end\n      if optcm='/' then\n         do\n         \"ADDPOP\"\n         dlf='mem $ 8 <  Member> fname l 50 <  Filename>'\n         althelp=pan.p_memlisthc\n         x=actionlist('ML',1,1,pan.p_memlist,dlf)\n         \"REMPOP\"\n         if x=0 then\n            if zverb='EXIT' | zverb='RETURN' then\n               leave\n            else\n            if zverb='CANCEL' then\n               iterate\n         end\n      done=1\n      \"TBTOP ML\"\n      do forever\n         \"TBSKIP ML\"\n         if rc<>0 then leave\n         if s='' | s='_' then iterate\n         if update<>'' then\n            mem=update\n         cdsnm=\"'\"cdsn\"(\"mem\")'\"\n         src=tsocmd(util,pan,cpath cdsnm utilopt)\n         if src=0 then\n            copied=1\n          else\n            do\n            \"ADDPOP\"\n            \"DISPLAY PANEL(\"pan.p_cpyerr\")\"\n            src=rc\n            \"REMPOP\"\n            if src=0 then\n               iterate\n            \"VGET (ZVERB)\"\n            if ZVERB='CANCEL' then\n               done=0\n            leave\n            end\n      end\n      if copied=0 then\n         'SETMSG MSG('msg.m_nocopy')' msgloc\n      if done then leave\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* directory panel: replace selected                                  */\n/**********************************************************************/\ndir_replace:\n   \"ADDPOP\"\n   done=0\n   optcb=''\n   optcc=''\n   optcl='/'\n   optcm='/'\n   do until done\n      zcmd=''\n      \"DISPLAY PANEL(\"pan.p_cpyspds\")\"\n      if rc<>0 then leave\n      if zcmd='SHOWOBJ' then\n         do\n         call showobj\n         iterate\n         end\n      \"VPUT (TPERM) PROFILE\"\n      pan=pan.p_cpyspds\n      if substr(dsn,1,1)=\"'\" then\n         cdsn=strip(dsn,,\"'\")\n       else\n         cdsn=strip(sysvar(syspref)'.'dsn,,'.')\n      \"LMINIT DATAID(PDSID) DATASET(\"dsn\") ORG(DSORG)\"\n      if rc<>0 then\n         do\n         'LMFREE DATAID('pdsid')'\n         'SETMSG MSG('msg.m_nodsn')' msgloc\n         iterate\n         end\n      util='OPUT'\n      if optcb='/' then\n         utilopt='BINARY'\n       else\n         utilopt='TEXT'\n      if optcc='/' then\n         do\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_cpyconv\")\"\n         src=rc\n         \"REMPOP\"\n         if src<>0 then\n            do\n            \"VGET (ZVERB)\"\n            if ZVERB='CANCEL' then\n               iterate\n             else\n               leave\n            end\n         if tabdsn='' then\n            utilopt=utilopt 'convert(yes)'\n          else\n            utilopt=utilopt 'convert('tabdsn')'\n         end\n      'LMOPEN DATAID('pdsid') LRECL(LRECL)'\n      'TBCREATE ML NOWRITE REPLACE',\n                'NAMES(S,MEM,OMEM,CPATH,CDSNM,LOCATE,UPDATE)'\n      mem=''\n      update=''\n      if optcm='/' then\n         s='_'\n       else\n         s='/'\n      do forever\n         'LMMLIST DATAID('pdsid') MEMBER(MEM)'\n         if rc>0 then\n            leave\n         mem=strip(mem)\n         if optcl='/' then\n            omem=translate(mem,'abcdefghijklmnopqrstuvwxyz',,\n                               'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n          else\n            omem=mem\n         if suffix<>'' then\n            omem=omem'.'strip(suffix,'L','.')\n         cpath=strip(path,\"T\",\"/\")\"/\"omem\n         cdsnm=\"'\"cdsn\"(\"mem\")'\"\n         locate=mem\n         \"TBADD ML\"\n      end\n      if optcm='/' then\n         do\n         \"ADDPOP\"\n         dlf='mem l 8 < Member> omem $ 50 <  Filename>'\n         althelp=pan.p_memlisthr\n         x=actionlist('ML',1,1,pan.p_memlist,dlf)\n         \"REMPOP\"\n         if x=0 then\n            if zverb='EXIT' | zverb='RETURN' then\n               done=1\n            else\n            if zverb='CANCEL' then\n               iterate\n         end\n      if done then leave\n      done=1\n      \"TBTOP ML\"\n      cpcount=0\n      do forever\n         \"TBSKIP ML\"\n         if rc<>0 then leave\n         if s='' | s='_' then iterate\n         if update<>'' then\n            cpath=strip(path,\"T\",\"/\")\"/\"update\n         cpcount=cpcount+1\n         address syscall 'access (cpath)' f_ok\n         cprepl= rc=0 & retval<>-1                  /* @DFA*/\n         src=tsocmd(util,pan,cdsnm \"'\"quotes(cpath)\"'\" utilopt)\n         if src=0 then\n            do                                      /* @DFA*/\n            /* if new or replaced and reset perms opt */\n            if cprepl=0 | (cprepl=1 & optcp<>'/') then  /* @DFA*/\n               do\n               call syscallm 'chmod (cpath)' vperm\n               /* this will now stop on permission errors */\n               if retval=-1 then leave              /* @DFA*/\n               end                                  /* @DFA*/\n            end                                     /* @DFA*/\n           else\n            do\n            \"ADDPOP\"\n            \"DISPLAY PANEL(\"pan.p_cpyerr\")\"\n            src=rc\n            \"REMPOP\"\n            if src=0 then\n               iterate\n            \"VGET (ZVERB)\"\n            if ZVERB='CANCEL' then\n               done=0\n            leave\n            end\n      end\n      if cpcount=0 then\n         do\n         done=0\n         \"SETMSG MSG(\"msg.m_nocopy\")\" msgloc\n         end\n      \"TBEND ML\"\n      \"LMMLIST DATAID(\"pdsid\") OPTION(FREE)\"\n      \"LMFREE DATAID(\"pdsid\")\"\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* directory panel: print selected                                    */\n/**********************************************************************/\ndir_print:\n   call syscallm 'readdir (path) ln.'\n   if retval=-1 then return\n   hdr1=''\n   hdr2=time() date() 'Files:' ln.0 'Directory:' path\n   hdr3=''\n   hdr0=3\n   'TBCREATE DL NOWRITE REPLACE NAMES(LN)'\n   do i=1 to ln.0\n      ln=ln.i\n      'TBADD DL'\n   end\n   'TBSORT DL FIELDS(LN)'\n   'TBTOP DL'\n   call print_hdr 1\n   do forever\n      'TBSKIP DL'\n      if rc<>0 then\n         leave\n      \"VGET (ZLSTNUML)\"\n      if zlstlpp=zlstnuml then\n         call print_hdr pg+1\n      'LIST BUFNAME(LN) LINELEN('length(ln)')'\n   end\n   'TBEND DL'\n   'SETMSG MSG('msg.m_printed')' msgloc\n   return\n\n/**********************************************************************/\n/* directory panel: compare selected                                  */\n/**********************************************************************/\ndir_compare:\n   call run_diff 'CD' '-fr'\n   return\n\n/**********************************************************************/\n/* directory panel: find selected                                     */\n/**********************************************************************/\ndir_find:\n   pgmpath=greppath\n   call syscallm \"access (pgmpath)\" x_ok\n   if retval=-1 then\n      do\n      \"SETMSG MSG(\"msg.m_nopgm\")\" msgloc\n      return\n      end\n   pgmpath=findpath\n   call syscallm \"access (pgmpath)\" x_ok\n   if retval=-1 then\n      do\n      \"SETMSG MSG(\"msg.m_nopgm\")\" msgloc\n      return\n      end\n   if find_opts('SO') then return\n   srch=''\n   if str1<>'' then\n      srch=srch || str1 ||esc_n\n   if str2<>'' then\n      srch=srch || str2 ||esc_n\n   if str3<>'' then\n      srch=srch || str3 ||esc_n\n   if str4<>'' then\n      srch=srch || str4 ||esc_n\n   srch=strip(srch,,esc_n)\n   \"REMPOP\"                   /* @0PM*/\n   \"REMPOP\"                   /* @0PM*/\n   env.0=0\n   call syscallm \"creat (stdout)\" 600\n   if retval=-1 then return\n   fd0=-1\n   fd1=retval\n   fd2=retval\n   found=0\n   parm.1=pgmpath\n   parm.2=path\n   parm.3='-print'\n   parm.4='-type'\n   parm.5='f'\n   parm.6='-exec'\n   parm.7=greppath\n   parm.8='-Fni'\n   parm.9='-e'\n   parm.10=srch\n   parm.11='{}'  /* open/close braces */\n   parm.12=';'\n   parm.0=12\n   cmd=pgmpath '-exec' greppath'...'\n   call spawnpgm pan.p_srchstr\n   if retcode=0 then\n      do\n      call syscallm 'stat (stdout) st.'\n      if st.st_size>0 & st.st_type=s_isreg then\n         call obrowse stdout,0\n       else\n         \"SETMSG MSG(\"msg.m_found\")\"\n      end\n    else\n      \"SETMSG MSG(\"msg.m_notfound\")\" msgloc\n   address syscall 'close' fd1\n   address syscall 'close' fd2\n   if tempname=1 then\n      do\n      address syscall 'unlink (stdout)'\n      stdout=''\n      end\n   return\n\n/**********************************************************************/\n/* directory panel: set cwd selected                                  */\n/**********************************************************************/\ndir_cwd:\n   call syscallm 'chdir (path)'\n   return\n\n/**********************************************************************/\n/* directory panel: mount                                             */\n/**********************************************************************/\ndir_mount:\n   \"ADDPOP\"\n   opt='RDWR'\n   fsparm1=''\n   fsparm2=''\n   fsowner=''\n   dsn=''        /* @P5C*/\n   filesys=''    /* @P5C*/\n   fssystem=''   /* @D7A*/\n   fsccsid=''    /* @D8A*/\n   mpath=path\n   do forever\n      call makevpath mpath\n      zcmd=''\n      \"DISPLAY PANEL(\"pan.p_mount\")\"\n      if rc<>0 then leave\n      mpath=makepath()\n      if zcmd='SHOWOBJ' then\n         do\n         call showobj\n         iterate\n         end\n      if length(dsn)>2 & substr(dsn,1,1)=\"'\" &,       /* 5@DCA*/\n           substr(dsn,length(dsn),1)=\"'\" then\n         fsn=substr(dsn,2,length(dsn)-2)\n       else\n         fsn=translate(dsn)\n      fsparm=fsparm1 || fsparm2\n\n      /* 17@D7A - converted to mnte interface */\n      m.=''\n      if optro='' then\n         m.mnte_mode=mnt_mode_rdwr\n       else\n         m.mnte_mode=mnt_mode_rdonly\n      if optsetam<>'' then             /* 25@PBA*/\n         do\n         do sli=1 to 32                  /* 3@PCA*/\n            call value 'SYSNM'sli,''\n         end\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_selamt\")\"\n         rrc=rc\n         \"REMPOP\"\n         if rrc<>0 then leave\n         if vactc='Y' | vactc='N' | vactc='U' then\n            do\n            if vactc='N' then\n               m.mnte_mode=mnt_mode_noautomove+m.mnte_mode\n            else\n            if vactc='U' then\n               m.mnte_mode=mnt_mode_aunmount+m.mnte_mode\n            end\n          else\n            if vactc='I' | vactc='E' then\n               do\n               if vactc='I' then\n                  m.mnte_syslist='0000'x\n               else\n                  m.mnte_syslist='0001'x\n               slc=0\n               do sli=1 to 32\n                  sysnm=value('SYSNM'sli)\n                  if sysnm<>'' then\n                     do\n                     slc=slc+1\n                     m.mnte_syslist=m.mnte_syslist ||,\n                                     translate(left(sysnm,8))\n                     end\n               end\n               m.mnte_syslist=d2c(slc,2) || m.mnte_syslist\n               end\n         end\n\n      if optsec<>'' then\n         m.mnte_mode=m.mnte_mode+mnt_mode_nosec\n      if optid<>'' then\n         m.mnte_mode=m.mnte_mode+mnt_mode_nosetid\n      numeric digits 10                                     /* 8@D8A*/\n      if fsccsid='' then fsccsid=0\n      if opttext='' then\n        filetag = fsccsid * 65536\n      else\n        filetag = fsccsid * 65536 + 32768\n      if filetag=0 then fsccsid=''\n      m.mnte_filetag=d2c(filetag)\n      m.mnte_fsname=fsn\n      m.mnte_fstype=filesys\n      m.mnte_parm=fsparm\n      m.mnte_path=mpath\n      m.mnte_sysname=fssystem\n      call syscallm 'mount m.'\n\n      if retval=-1 then iterate\n      if fsowner<>'' then\n         do\n         call syscallm 'getpwnam (fsowner) pw.'\n         if retval>0 then\n            call syscallm 'chown (mpath)' pw.pw_uid pw.pw_gid\n          else\n            if retval=0 then\n               do\n               retval=-1\n               rsn=getjr(errnojr)\n               eno=geterr(errno)\n               \"SETMSG MSG(\"msg.m_scerr\")\" msgloc\n               end\n         end\n      leave\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* chr special panel: settings selected                               */\n/**********************************************************************/\nchr_settings:\n   call settings pan.p_settings s_ischr 'Character special'\n   return\n\n/**********************************************************************/\n/* chr special panel: delete selected                                 */\n/**********************************************************************/\nchr_delete:\n   call delete 'unlink'\n   return\n\n/**********************************************************************/\n/* chr special panel: rename selected                                 */\n/**********************************************************************/\nchr_rename:\n   call rename\n   return\n\n/**********************************************************************/\n/* reg file panel: text browse selected                               */\n/**********************************************************************/\nreg_brtext:\n   xx=obrowse(path,0)\n   return\n\n/**********************************************************************/\n/* reg file panel: record browse selected                             */\n/**********************************************************************/\nreg_brrecs:\n   \"ADDPOP\"\n   \"DISPLAY PANEL(\"pan.p_getrecl\")\"\n   src=rc\n   \"REMPOP\"\n   if src<>0 then return\n   xx=obrowse(path,hfsrl)\n   return\n\n/**********************************************************************/\n/* reg file panel: edit selected                                      */\n/**********************************************************************/\nreg_edit:\n   call oedit path\n   return\n\n/**********************************************************************/\n/* reg file panel: settings selected                                  */\n/**********************************************************************/\nreg_settings:\n   call settings pan.p_settings s_isreg 'Regular file'\n   return\n\n/**********************************************************************/\n/* reg file panel: delete selected                                    */\n/**********************************************************************/\nreg_delete:\n   call delete 'unlink'\n   return\n\n/**********************************************************************/\n/* reg file panel: rename selected                                    */\n/**********************************************************************/\nreg_rename:\n   call rename\n   return\n\n/**********************************************************************/\n/* reg file panel: copy selected                                      */\n/**********************************************************************/\nreg_copy:\n   \"ADDPOP\"\n   sel=''\n   optcc=''\n   optcb=''\n   do forever\n      \"DISPLAY PANEL(\"pan.p_cpydst\")\"\n      if rc=0 then\n         select\n            when selc='F' then\n               do\n               \"ADDPOP\"\n               vtext='CP'\n               \"DISPLAY PANEL(\"pan.p_getpath\")\"\n               src=rc\n               \"REMPOP\"\n               if src<>0 then\n                  do\n                  \"VGET (ZVERB)\"\n                  if ZVERB='CANCEL' then\n                     iterate\n                   else\n                     leave\n                  end\n               xx=copy(pan.p_getpath,path,makepath())\n               end\n\n            when selc='D' then\n               do\n               \"ADDPOP\"\n               util='OGET'\n               if optcb='/' then\n                  utilopt='BINARY'\n                else\n                  utilopt='TEXT'\n               \"DISPLAY PANEL(\"pan.p_getdsn\")\"\n               if rc<>0 then\n                  do\n                  \"REMPOP\"\n                  \"VGET (ZVERB)\"\n                  if ZVERB='CANCEL' then\n                     iterate\n                   else\n                     leave\n                  end\n               if optcc='/' then\n                  do\n                  \"DISPLAY PANEL(\"pan.p_cpyconv\")\"\n                  if rc<>0 then\n                     do\n                     \"REMPOP\"\n                     \"VGET (ZVERB)\"\n                     if ZVERB='CANCEL' then\n                        iterate\n                      else\n                        leave\n                     end\n                  if tabdsn='' then\n                     utilopt=utilopt 'convert(yes)'\n                   else\n                     utilopt=utilopt 'convert('tabdsn')'\n                  end\n               src=tsocmd(util,pan.p_getdsn,,\n                          \"'\"quotes(path)\"'\" dsn utilopt)\n               \"REMPOP\"\n               if src=0 then leave\n               iterate\n               end\n\n            otherwise\n         end\n      leave\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* reg file panel: replace selected                                   */\n/**********************************************************************/\nreg_replace:\n   \"ADDPOP\"\n   arg selc\n   optcc=''\n   optcb=''\n   do forever\n      \"DISPLAY PANEL(\"pan.p_cpysrc\")\"\n      if rc=0 then\n         select\n            when selc='F' then\n               do\n               vtext='RP'\n               \"ADDPOP\"\n               \"DISPLAY PANEL(\"pan.p_getpath\")\"\n               src=rc\n               \"REMPOP\"\n               if src<>0 then iterate\n               xx=copy(pan.p_getpath,makepath(),path)\n               end\n\n            when selc='D' then\n               do\n               \"ADDPOP\"\n               util='OPUT'\n               if optcb='/' then\n                  utilopt='BINARY'\n                else\n                  utilopt='TEXT'\n               \"DISPLAY PANEL(\"pan.p_getdsn\")\"\n               if rc<>0 then\n                  do\n                  \"REMPOP\"\n                  \"VGET (ZVERB)\"\n                  if ZVERB='CANCEL' then\n                     iterate\n                   else\n                     leave\n                  end\n               if sysdsn(dsn)<>'OK' then\n                  do\n                  \"SETMSG MSG(\"msg.m_nodsn\")\" msgloc\n                  \"REMPOP\"\n                  iterate\n                  end\n               if optcc='/' then\n                  do\n                  \"DISPLAY PANEL(\"pan.p_cpyconv\")\"\n                  if rc<>0 then\n                     do\n                     \"REMPOP\"\n                     \"VGET (ZVERB)\"\n                     if ZVERB='CANCEL' then\n                        iterate\n                      else\n                        leave\n                     end\n                  if tabdsn='' then\n                     utilopt=utilopt 'convert(yes)'\n                   else\n                     utilopt=utilopt 'convert('tabdsn')'\n                  end\n               src=tsocmd(util,pan.p_getdsn,,\n                          dsn \"'\"quotes(path)\"'\" utilopt)\n               \"REMPOP\"\n               if src=0 then leave\n               iterate\n               end\n\n            otherwise\n         end\n      leave\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* reg file panel: print selected                                     */\n/**********************************************************************/\nreg_print:\n   call syscallm 'readfile (path) ln'\n   if rc<>0 then\n      do\n      \"SETMSG MSG(\"msg.m_nontext\")\"\n      return\n      end\n   if retval=-1 then return\n   hdr1=''\n   \"GETMSG MSG(\"lit\"017) LONGMSG(HDR2)\"\n   hdr2=time() date() hdr2\n   hdr3=''\n   hdr0=3\n   call print_hdr 1\n   do i=1 to ln0\n      \"VGET (ZLSTNUML)\"\n      if zlstlpp=zlstnuml then\n         call print_hdr pg+1\n      'LIST BUFNAME(LN'i') LINELEN('length(value('ln'i))')'\n   end\n   'SETMSG MSG('msg.m_printed')'\n   return\n\n/**********************************************************************/\n/* reg file panel: compare selected                                   */\n/**********************************************************************/\nreg_compare:\n   call run_diff 'CF' '-f'\n   return\n\n/**********************************************************************/\n/* reg file panel: find selected                                      */\n/**********************************************************************/\nreg_find:\n   pgmpath=greppath\n   call syscallm \"access (pgmpath)\" x_ok\n   if retval=-1 then\n      do\n      \"SETMSG MSG(\"msg.m_nopgm\")\" msgloc\n      return\n      end\n   if find_opts('SO') then return\n   parm.0=4\n   parm.1=pgmpath\n   parm.2='-Fni'\n   parm.3='-e'\n   parm.4=''\n   if str1<>'' then\n      parm.4=parm.4 || str1 ||esc_n\n   if str2<>'' then\n      parm.4=parm.4 || str2 ||esc_n\n   if str3<>'' then\n      parm.4=parm.4 || str3 ||esc_n\n   if str4<>'' then\n      parm.4=parm.4 || str4 ||esc_n\n   parm.4=strip(parm.4,,esc_n)\n   env.0=0\n   call syscallm \"creat (stdout)\" 600\n   if retval=-1 then\n      do\n      \"REMPOP\"\n      \"REMPOP\"\n      return\n      end\n   fd1=retval\n   fd2=retval\n   found=0\n   call syscallm \"open (path)\" o_rdonly+o_nonblock 000\n   if retval=-1 then\n      do\n      \"REMPOP\"\n      \"REMPOP\"\n      address syscall \"close\" fd1\n      return\n      end\n   fd0=retval\n   buf=\"Searching\" path \"for:\"esc_n || parm.4 || esc_n || esc_n\n   address syscall \"write\" fd1 \"buf\"\n   cmd=pgmpath'...'\n   call spawnpgm pan.p_srchstr\n   if retcode=0 then\n      do\n      found=1\n      buf=esc_n || esc_n\n      address syscall \"write\" fd1 \"buf\"\n      end\n   \"REMPOP\"\n   \"REMPOP\"\n   if found then\n      do\n      call syscallm 'stat (stdout) st.'\n      if st.st_size>0 & st.st_type=s_isreg then\n         call obrowse stdout,0\n       else\n         \"SETMSG MSG(\"msg.m_found\")\"\n      end\n    else\n      \"SETMSG MSG(\"msg.m_notfound\")\" msgloc\n   address syscall 'close' fd1\n   address syscall 'close' fd0\n   if tempname=1 then\n      do\n      address syscall 'unlink (stdout)'\n      stdout=''\n      end\n   return\n\n/**********************************************************************/\n/* fifo panel: settings selected                                      */\n/**********************************************************************/\nfifo_settings:\n   call settings pan.p_settings s_isfifo 'FIFO'\n   return\n\n/**********************************************************************/\n/* fifo panel: delete selected                                        */\n/**********************************************************************/\nfifo_delete:\n   call delete 'unlink'\n   return\n\n/**********************************************************************/\n/* fifo panel: rename selected                                        */\n/**********************************************************************/\nfifo_rename:\n   call rename\n   return\n\n/**********************************************************************/\n/* symlink panel: settings selected                                   */\n/**********************************************************************/\nsym_settings:\n   call settings pan.p_symset s_issym 'Symbolic link'\n   return\n\n/**********************************************************************/\n/* symlink panel: delete selected                                     */\n/**********************************************************************/\nsym_delete:\n   call delete 'unlink'\n   return\n\n/**********************************************************************/\n/* symlink panel: rename selected                                     */\n/**********************************************************************/\nsym_rename:\n   call rename\n   return\n\n/**********************************************************************/\n/* make a symlink                                                     */\n/**********************************************************************/\nmakesym:\n   doingsl=1\n   \"ADDPOP\"\n   do while doingsl>0\n      \"DISPLAY PANEL(\"pan.p_symsel\")\"\n      if rc<>0 then\n         do\n         \"REMPOP\"\n         return\n         end\n      vtext=vsymc\n      doingsl=2\n      \"ADDPOP\"\n      do while doingsl>1\n         call getlinkname\n         if lnknm='' then\n            leave\n         if vsymc='S' then\n            call syscallm 'symlink (lnknm) (pathnm)'\n          else\n            call syscallm 'extlink (lnknm) (pathnm)'\n         if retval<>-1 then\n            doingsl=0\n      end\n      \"REMPOP\"\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* getlinkname                                                        */\n/**********************************************************************/\ngetlinkname:\n   select\n     when vsymc='S' then\n        do\n        \"DISPLAY PANEL(\"pan.p_getpath\")\"\n        src=rc\n        lnknm=makepath()\n        end\n     when vsymc='E' then\n        do\n        \"DISPLAY PANEL(\"pan.p_getpath\")\"\n        src=rc\n        lnknm=makepath()\n        end\n     otherwise\n        \"DISPLAY PANEL(\"pan.p_getdsn\")\"\n        src=rc\n        lnknm=dsn\n   end\n   if src>0 then\n      do\n      lnknm=''\n      \"VGET (ZVERB)\"\n      if zverb<>'CANCEL' then\n         doingsl=0\n       else\n         doingsl=1\n      end\n   return\n\n/**********************************************************************/\n/* delete: delete a file or directory                                 */\n/**********************************************************************/\ndelete:\n   arg op\n   prc=0\n   errno=0\n   if noconf<>'/' then\n      do forever\n         \"ADDPOP\"\n         zcmd=''\n         \"DISPLAY PANEL(\"pan.p_confd\")\"\n         prc=rc\n         \"REMPOP\"\n         if prc<>0 then\n            leave\n         \"VPUT (NOCONF) PROFILE\"\n         if zcmd='' then\n            leave\n         if translate(zcmd)='SHOWOBJ' then\n            call showobj\n      end\n   if prc=0 then\n      call syscallm op '(path)'\n   return errno\n\n/**********************************************************************/\n/* shcmd:  issue shell command or run program                         */\n/**********************************************************************/\nshcmd:\n   parse arg cmdline,pgm\n   path=''\n   if cmdline='' then\n      do\n         if pgm<>'' then\n            do\n            runmeth='D'\n            call linecmd 1\n            return\n            end\n         do forever                      /* @DHA*/\n         \"ADDPOP\"\n         \"DISPLAY PANEL(\"pan.p_shcmd\")\"\n         src=rc\n         \"REMPOP\"\n         if src<>0 then return\n         cmdline=strip(left(shcmd1,64) || left(shcmd2,64) ||,\n                       left(shcmd3,64) || left(shcmd4,64))\n         call runshcmd pgm              /* @DHA*/\n         end                            /* @DHA*/\n      end\n   call runshcmd pgm\n   return\n\n/**********************************************************************/\n/* runshcmd:  run the shell command                                   */\n/**********************************************************************/\nrunshcmd:\n\n   arg pgm\n   pw.=''\n   address syscall 'getpwnam' sysvar('SYSUID') 'pw.'\n   ev.1='PATH=/bin:.'                                  /* @06C*/\n   ev.2='_BPX_SHAREAS=YES'\n   ev.3='HOME='pw.pw_dir                               /* @05A*/\n   ev.4='LOGNAME='userid()                             /* @06A*/\n   ev.0=4                                              /* @06C*/\n   if pgm<>'' then\n      do\n      i=0\n      prm=cmdline\n      do while prm<>''\n         i=i+1\n         if substr(prm,1,1)='\"' then\n            dlm='\"'\n         else\n         if substr(prm,1,1)=\"'\" then\n            dlm=\"'\"\n         else\n            dlm=' '\n         if dlm<>'' then\n            prm=substr(prm,2)\n         j=pos(dlm,prm)\n         if j=0 then\n            j=length(prm)+1\n         p.i=substr(prm,1,j-1)\n         prm=strip(substr(prm,j+1))\n      end\n      p.0=i\n      end\n    else\n      do\n      p.1='/bin/sh'\n      p.2='-Lc'\n      p.3=cmdline\n      p.0=3\n      end\n   call runopts 'ev.'\n   if ltime.4<>'*' then       /* no speical init processing     @0TC*/\n      do                                                    /*  @0TA*/\n      call syscallm 'open /dev/null 2 000'\n      fd.0=retval\n      shout='/tmp/'sysvar('SYSUID')'.'time('L')'.ishell'\n      call syscallm 'open (shout) 147 700' /* rdwr+create+trunc */\n      fd.1=retval\n      fd.2=retval\n      if retval<>-1 then\n         call syscallm 'spawnp (p.1) 3 fd. p. ev.'\n      pid=retval\n      if pid>0 then\n         do\n         address syscall 'waitpid (pid) st. 0'\n         end\n      if retval<>-1 then\n         do\n         call syscallm 'fstat (fd.1) stat.'\n         if stat.8>0 then                                   /* @0TC*/\n            call obrowse shout,0\n         end\n      trace o\n      address syscall 'close' fd.0\n      address syscall 'close' fd.1\n      address syscall 'close' fd.2\n      address syscall 'unlink (shout)'\n      trace\n      end                                                   /*  @0TA*/\n   if ltime.4='*' then         /* special processing for init 20@0TC*/\n      do\n      itz=''\n      ltz=''\n      /* Use bpxwunix to retrieve env vars - avoid using tmp space. */\n      /* Echo env vars to stderr and parse the output.              */\n      cmd='/bin/sh -Lc \"echo',\n          'IS=\\$BPXWISHISPF\\IZ=\\$BPXWISHTZ\\TZ=\\$TZ >/dev/fd2\"'\n      if bpxwunix(cmd,,,stderr.,ev.)=0 then\n         do\n         i=stderr.0\n         parse var stderr.i 'IS=' isp 'IZ=' itz 'TZ=' ltz\n         end\n      if isp='NO' then\n         isp=0                                          /* 2@DLC*/\n      else\n      if isp='ALL' then\n         isp=2\n      else                                              /* 3@DLA*/\n         isp=1\n      if itz<>'' then ltz=itz\n      if ltz='GMT' then ltz=''\n      ltimebf='TZ='ltz\n      end\n   return\n\n/**********************************************************************/\n/* spawn a command                                                    */\n/**********************************************************************/\nspawncmd:\n   arg excmd\n\n   pw.=''                                            /* @0FA 8@DFM*/\n   address syscall 'getpwnam' sysvar('SYSUID') 'pw.' /* @0FA*/\n   env.1='PATH=/bin:.'                         /* @06C*/\n   env.2='_BPX_SHAREAS=YES'\n   env.3='HOME='pw.pw_dir       /* 2@wjs*/\n   env.4='LOGNAME='userid()\n   env.0=4\n   call runopts 'env.'\n\n   if runmeth='I' then             /* 12@DFA*/\n      do\n      /* this run method does not show the completion value nor does it\n         support a time limit */\n      spnin.0=0\n      address tso 'alloc fi(bpxwidd1) da(*) reuse'\n      address tso 'alloc fi(bpxwidd2) da(*) reuse'\n      rv=bpxwunix(pgmpath parm,spnin.,'DD:bpxwidd1','DD:bpxwidd2',env.)\n      address tso 'free fi(bpxwidd1 bpxwidd2)'\n      return\n      end\n\n   stdin='/dev/null'\n   call syscallm \"open (stdin)\" o_rdonly+o_nonblock 000\n   fd0=retval\n   if retval=-1 then\n      do\n      msgpath=stdin\n      \"SETMSG MSG(\"msg.m_noacc\")\" msgloc\n      return\n      end\n   stdout='/tmp/'sysvar('SYSUID')'.'time('L')'.stdout.ishell'\n   call syscallm \"creat (stdout)\" 600\n   fd1=retval\n   if retval=-1 then\n      do\n      address syscall 'close' fd0\n      msgpath=stdout\n      \"SETMSG MSG(\"msg.m_noaccw\")\" msgloc\n      return\n      end\n   stderr='/tmp/'sysvar('SYSUID')'.'time('L')'.stderr.ishell'\n   call syscallm \"creat (stderr)\" 600\n   fd2=retval\n   if retval=-1 then\n      do\n      address syscall 'close' fd0\n      address syscall 'close' fd1\n      address syscall 'unlink (stdout)'\n      msgpath=stderr\n      \"SETMSG MSG(\"msg.m_noaccw\")\" msgloc\n      return\n      end\n   fd.0=fd0\n   fd.1=fd1\n   fd.2=fd2\n   pw.=''                                            /* @0FA*/\n   address syscall 'getpwnam' sysvar('SYSUID') 'pw.' /* @0FA*/\n   env.1='PATH=/bin:.'                         /* @06C*/\n   env.2='_BPX_SHAREAS=YES'\n   env.3='HOME='pw.pw_dir       /* 2@wjs*/\n   env.4='LOGNAME='userid()\n   env.0=4\n   call runopts 'env.'\n   if excmd='' & runmeth='L' then       /* 10@DBA*/\n      do\n      parm.1='/bin/sh'\n      parm.2='-Lc'\n      parm.3=pgmpath parm\n      parm.0=3\n      end\n    else\n      do\n      i=1\n      prm=parm\n      parm.i=pgmpath\n      do while prm<>''\n         i=i+1\n         if substr(prm,1,1)='\"' then\n            dlm='\"'\n         else\n         if substr(prm,1,1)=\"'\" then\n            dlm=\"'\"\n         else\n            dlm=' '\n         if dlm<>'' then\n            prm=substr(prm,2)\n         j=pos(dlm,prm)\n         if j=0 then\n            j=length(prm)+1\n         parm.i=substr(prm,1,j-1)\n         prm=strip(substr(prm,j+1))\n      end\n      parm.0=i\n      end\n   cmd=pgmpath parm\n   cmd=''\n   do j=1 to parm.0\n      cmd=cmd||parm.j||'!'\n   end\n   spcmd=cmd\n   \"ADDPOP\"\n   \"CONTROL DISPLAY LOCK\"\n   \"SETMSG MSG(\"msg.m_gentxt\")\" msgloc\n   \"DISPLAY PANEL(\"panel\")\"\n   call syscallm 'spawnp (parm.1) 3 fd. parm. env.'\n   if retval=-1 then\n      do\n      \"REMPOP\"\n      return\n      end\n   pid=retval\n   cmd=spcmd 'PID='pid\n   \"CONTROL DISPLAY LOCK\"\n   \"SETMSG MSG(\"msg.m_gentxt\")\" msgloc\n   \"DISPLAY PANEL(\"panel\")\"\n   call syscalls 'SIGON'\n   address syscall 'sigaction' sigalrm sig_cat 0 'ohdl oflg'\n   address syscall 'sigprocmask' sig_unblock,\n      sigaddset(sigsetempty(),sigalrm) 'mask'\n   if tout<>'' then\n      address syscall 'alarm' tout\n   address syscall 'waitpid (pid) st. 0'\n   srv=retval\n   address syscall 'alarm 0'\n   if srv=-1 then\n      do\n      \"CONTROL DISPLAY LOCK\"\n      \"SETMSG MSG(\"msg.m_timeout\")\" msgloc\n      \"DISPLAY PANEL(\"panel\")\"\n      address syscall 'kill' pid sigkill\n      address syscall 'alarm 10'\n      address syscall 'waitpid (pid) st. 0'\n      srv=retval\n      address syscall 'alarm 0'\n      if srv=-1 then\n         st.=-1\n      end\n   address syscall 'sigaction' sigalrm ohdl oflg 'x y'\n   call syscalls 'SIGOFF'\n   select\n      when st.w_ifexited=1 then\n         parse value msg.m_sigexit st.w_exitstatus with msgid code\n      when st.w_ifsignaled=1 then\n         parse value msg.m_sigterm st.w_termsig with msgid code\n      when st.w_ifstopped=1 then\n         parse value msg.m_sigstop st.w_stopsig with msgid code\n      otherwise\n         msgid=''\n   end\n   if msgid<>'' then\n      \"SETMSG MSG(\"msgid\")\" msgloc\n   \"REMPOP\"\n   st.=0\n   address syscall 'fstat' fd1 'st.'\n   if st.st_size>0 & st.st_type=s_isreg then\n      xx=obrowse(stdout,0)\n   address syscall 'fstat' fd2 'st.'\n   if st.st_size>0 & st.st_type=s_isreg & fd1<>fd2 &,\n       stdout<>stderr then\n      xx=obrowse(stderr,0)\n   address syscall 'unlink (stdout)'\n   address syscall 'unlink (stderr)'\n   address syscall 'close' fd0\n   address syscall 'close' fd1\n   address syscall 'close' fd2\n   return 0\n\n/**********************************************************************/\n/* linecmd: enter a line command                                      */\n/**********************************************************************/\nlinecmd:\n   arg excmd\n   linecmdbrc=pos('{}',path)\n   excmdsv=excmd                                    /* 3@DHA*/\n   do forever           /* keep dialog active until pf3  */\n   excmd=excmdsv\n   \"ADDPOP\"\n   if excmd<>'' then\n      panel=pan.p_excmd\n    else\n      panel=pan.p_run\n   \"DISPLAY PANEL(\"panel\")\"\n   lcrc=rc\n   \"REMPOP\"\n   if lcrc<>0 then\n      return\n   cmdline=cmdl1 || cmdl2 || cmdl3 || cmdl4\n   if excmd='' then\n      do\n      do i=1 by 1\n         if pos('{}',cmdline)=0 then leave\n         if linecmdbrc>0 then\n            do\n            /* path cannot contain {} */\n            \"SETMSG MSG(\"msg.m_badname\")\" msgloc\n            return\n            end\n         parse var cmdline p1 '{}' p2\n         cmdline=p1 || path || p2\n      end\n      if i=1 then cmdline=cmdline path\n      end\n   cmdline=strip(cmdline)\n   parse var cmdline pgmpath parm\n   zcmd=''    /* @DHA*/\n   if runmeth='T' then\n      address tso cmdline\n   else\n   if runmeth='L' then\n      call spawncmd\n   else\n   if runmeth='I' then   /* 3@DFA*/\n      call spawncmd\n   else\n   if runmeth='D' then\n      call spawncmd 1\n   else\n      \"SETMSG MSG(\"msg.m_invcmd\")\" msgloc\n   end             /* @DHA*/\n   return\n\n/**********************************************************************/\n/* rename: rename a file or directory                                 */\n/**********************************************************************/\nrename:\n   \"ADDPOP\"\n   vtext='R'\n   \"DISPLAY PANEL(\"pan.p_getpath\")\"\n   if rc<>0 then\n      do\n      \"REMPOP\"\n      return\n      end\n   newpath=makepath()\n   address syscall 'access (newpath)' f_ok\n   if retval=0 & noconf<>'/' then\n      do\n      \"ADDPOP\"\n      \"DISPLAY PANEL(\"pan.p_confr\")\"\n      prc=rc\n      \"REMPOP\"\n      if prc<>0 then\n         do\n         \"REMPOP\"\n         \"VGET (ZVERB)\"\n         if zverb=\"CANCEL\" then\n            call rename\n         return\n         end\n      end\n   call syscallm 'rename (path) (newpath)'\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* settings:  common settings logic                                   */\n/**********************************************************************/\nsettings:\n   parse arg pan sttype type\n   \"ADDPOP\"\n   do forever\n      call info sttype type\n      if result then leave\n      \"DISPLAY PANEL(\"pan\")\"\n      if rc<>0 then leave\n      if zcmd='SHOWOBJ' then\n         call showobj\n      else\n      if zcmd<>'' then\n         call changeatt\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* info:  Get the stat structure and set dialog variables             */\n/**********************************************************************/\ninfo:\n   parse arg sttype type\n   st.='?'\n   call syscallm 'lstat (path) st.'\n   if retval=-1 then return 1\n   if datatype(st.st_type,'W')=0 |,\n        st.st_type<>sttype then\n      return 1\n   /*******************************************************************/\n   /* set dialog vars from stat structure                             */\n   /*******************************************************************/\n   extlink=st.st_extlink\n   filesz=st.st_size\n   dev=st.st_dev\n   inode=st.st_ino\n   links=st.st_nlink\n   uid=st.st_uid\n   gid=st.st_gid\n   id.=''\n   address syscall 'getgrgid' gid 'id.'\n   gname=id.gr_name\n   group=strip(gname)'('gid')'\n   id.=''\n   address syscall 'getpwuid' uid 'id.'\n   uname=id.pw_name\n   user=strip(uname)'('uid')'\n   access=ltime(st.st_atime)\n   modify=ltime(st.st_mtime)\n   change=ltime(st.st_ctime)\n   fmajor=st.st_major\n   fminor=st.st_minor\n   key='RWE'\n   i=translate(d2c(st.st_aaudit,4),' SFB','00010203'x)\n   aaudit=''\n   do j=1 to 3\n      if substr(i,j,1)='B' then\n         aaudit=aaudit||substr(key,j,1)'= FS  '\n       else\n         aaudit=aaudit||substr(key,j,1)'= 'substr(i,j,1)'   '\n   end\n   i=translate(d2c(st.st_uaudit,4),' SFB','00010203'x)\n   uaudit=''\n   do j=1 to 3\n      if substr(i,j,1)='B' then\n         uaudit=uaudit||substr(key,j,1)'= FS  '\n       else\n         uaudit=uaudit||substr(key,j,1)'= 'substr(i,j,1)'   '\n   end\n   auditid=st.st_auditid\n   crtime=ltime(st.st_crtime)\n   fformat=word('NA BINARY NL CR LF CRLF LFCR CRNL RECORD',\n                ,st.st_filefmt+1)        /* add crnl and REC @DMC @PKC*/\n   if fformat='' then\n      fformat=st.st_filefmt\n   if st.st_type=s_isreg then\n      do\n      genval=substr(st.st_genvalue,4)\n      extattrs= bitand(genval,'08'x)='00'x /* reverse bit */\n      extattra= bitand(genval,'04'x)='04'x\n      extattrp= bitand(genval,'02'x)='02'x\n      extattrl= bitand(genval,'10'x)='10'x  /* @D7A*/\n      end\n   else\n      parse value '- - - -' with extattrs extattra extattrp extattrl\n   /*******************************************************************/\n   /* set mode flags                                                  */\n   /*******************************************************************/\n   setuid=st.st_setuid\n   setgid=st.st_setgid\n   fmode=st.st_mode\n   fmode=fmode,\n         o2rwx(substr(fmode,1,1)) ||,\n         o2rwx(substr(fmode,2,1)) ||,\n         o2rwx(substr(fmode,3,1))                /* @DFA*/\n   sticky=st.st_sticky\n   /*******************************************************************/\n   /* if file is a symlink, read the link contents                    */\n   /*******************************************************************/\n   if st.st_type=s_issym then\n      do\n      call syscallm 'readlink (path) sympath'\n      if retval=-1 then sympath=''\n      call makevpath sympath\n      end\n   /*******************************************************************/\n   /* get the real CCSID and text flag from the beginning of st_ccsid */\n   /*******************************************************************/\n   filetag=c2d(substr(st.st_ccsid,1,2))                        /* 5@D8*/\n   if substr(st.st_ccsid,3,1)>='80'x then\n     filetag= right(filetag,5,'0') 'ON'                        /* @PEC*/\n   else\n     filetag= right(filetag,5,'0') 'OFF'                       /* @PEC*/\n\n   aclacc=st.st_accessacl        /* 4@DAA*/\n   aclfile=st.st_fmodelacl\n   acldir=st.st_dmodelacl\n   seclabel=st.st_seclabel\n   return 0\n\n/**********************************************************************/\n/* changeatt:  change attributes                                      */\n/**********************************************************************/\nchangeatt:\n   numeric digits 10                                     /*@P6A*/\n   \"ADDPOP POPLOC(PATH)\"\n   select\n      when zcmd='MODE' then\n         do forever\n            fmode=word(fmode,1)     /* @DFA*/\n            fmodec=fmode\n            setuidc=setuid\n            setgidc=setgid\n            stickyc=sticky\n            \"DISPLAY PANEL(\"pan.p_cngmode\")\"\n            if rc<>0 then leave\n            if fmode<>fmodec | setuid<>setuidc |,\n                 setgid<>setgidc | sticky<>stickyc then\n               do\n               call syscallm 'chmod (path)',\n                  fmodec setuidc setgidc stickyc\n               fmode=fmodec,\n                     o2rwx(substr(fmode,1,1)) ||,\n                     o2rwx(substr(fmode,2,1)) ||,\n                     o2rwx(substr(fmode,3,1))              /* @DFA*/\n               if retval<>-1 then leave\n               end\n         end\n\n      when zcmd='USER' then\n         do forever\n            uidc=uid\n            unamec=uname\n            \"DISPLAY PANEL(\"pan.p_cnguser\")\"\n            if rc<>0 then leave\n            if uid<>uidc & uidc<>'' then\n               do\n               call syscallm 'chown (path)' uidc gid\n               if retval<>-1 then leave\n               end\n            else\n            if uname<>unamec & unamec<>'' then\n               do\n               call syscallm 'getpwnam (unamec) pw.'\n               if retval=0 then\n                  do\n                  retval=-1\n                  rsn=getjr(errnojr)\n                  eno=geterr(errno)\n                  \"SETMSG MSG(\"msg.m_scerr\")\" msgloc\n                  iterate\n                  end\n               if retval>0 then\n                  do\n                  call syscallm 'chown (path)' pw.pw_uid gid\n                  if retval<>-1 then leave\n                  end\n               end\n         end\n\n      when zcmd='GROUP' then\n         do forever\n            gidc=gid\n            gnamec=gname\n            \"DISPLAY PANEL(\"pan.p_cnggroup\")\"\n            if rc<>0 then leave\n            if gid<>gidc & gidc<>'' then\n               do\n               call syscallm 'chown (path)' uid gidc\n               if retval<>-1 then leave\n               end\n            else\n            if gname<>gnamec &gnamec<>'' then\n               do\n               call syscallm 'getgrnam (gnamec) gr.'\n               if retval=0 then\n                  do\n                  retval=-1\n                  rsn=getjr(errnojr)\n                  eno=geterr(errno)\n                  \"SETMSG MSG(\"msg.m_scerr\")\" msgloc\n                  iterate\n                  end\n               if retval>0 then\n                  do\n                  call syscallm 'chown (path)' uid gr.gr_gid\n                  if retval<>-1 then leave\n                  end\n               end\n         end\n\n      when zcmd='UAUDIT' then\n         do forever\n            zero='00000000'x\n            aud=d2c(st.st_uaudit,4)\n            ar= bitand(aud,d2c(aud_fread,4))<>zero\n            ar= ar + (bitand(aud,d2c(aud_sread,4))<>zero)*2\n            aw= bitand(aud,d2c(aud_fwrite,4))<>zero\n            aw= aw + (bitand(aud,d2c(aud_swrite,4))<>zero)*2\n            ax= bitand(aud,d2c(aud_fexec,4))<>zero\n            ax= ax + (bitand(aud,d2c(aud_sexec,4))<>zero)*2\n            arc=ar\n            awc=aw\n            axc=ax\n            \"DISPLAY PANEL(\"pan.p_cnguaud\")\"\n            if rc<>0 then leave\n            if ar<>arc | aw<>awc | ax<>axc then\n               do\n               aud=0\n               select\n                 when arc=1 then aud=aud+aud_fread\n                 when arc=2 then aud=aud+aud_sread\n                 when arc=3 then aud=aud+aud_fread+aud_sread\n                 otherwise\n               end\n               select\n                 when awc=1 then aud=aud+aud_fwrite\n                 when awc=2 then aud=aud+aud_swrite\n                 when awc=3 then aud=aud+aud_fwrite+aud_swrite\n                 otherwise\n               end\n               select\n                 when axc=1 then aud=aud+aud_fexec\n                 when axc=2 then aud=aud+aud_sexec\n                 when axc=3 then aud=aud+aud_fexec+aud_sexec\n                 otherwise\n               end\n               call syscallm 'chaudit (path)' aud 0\n               if retval<>-1 then leave\n               end\n         end\n\n      when zcmd='AAUDIT' then\n         do forever\n            zero='00000000'x\n            aud=d2c(st.st_aaudit,4)\n            ar= bitand(aud,d2c(aud_fread,4))<>zero\n            ar= ar + (bitand(aud,d2c(aud_sread,4))<>zero)*2\n            aw= bitand(aud,d2c(aud_fwrite,4))<>zero\n            aw= aw + (bitand(aud,d2c(aud_swrite,4))<>zero)*2\n            ax= bitand(aud,d2c(aud_fexec,4))<>zero\n            ax= ax + (bitand(aud,d2c(aud_sexec,4))<>zero)*2\n            arc=ar\n            awc=aw\n            axc=ax\n            \"DISPLAY PANEL(\"pan.p_cngaaud\")\"\n            if rc<>0 then leave\n            if ar<>arc | aw<>awc | ax<>axc then\n               do\n               aud=0\n               select\n                 when arc=1 then aud=aud+aud_fread\n                 when arc=2 then aud=aud+aud_sread\n                 when arc=3 then aud=aud+aud_fread+aud_sread\n                 otherwise\n               end\n               select\n                 when awc=1 then aud=aud+aud_fwrite\n                 when awc=2 then aud=aud+aud_swrite\n                 when awc=3 then aud=aud+aud_fwrite+aud_swrite\n                 otherwise\n               end\n               select\n                 when axc=1 then aud=aud+aud_fexec\n                 when axc=2 then aud=aud+aud_sexec\n                 when axc=3 then aud=aud+aud_fexec+aud_sexec\n                 otherwise\n               end\n               call syscallm 'chaudit (path)' aud 1\n               if retval<>-1 then leave\n               end\n         end\n\n      when zcmd='FFMT' then\n         do forever\n            ffmt=st.st_filefmt\n            \"DISPLAY PANEL(\"pan.p_cngffmt\")\"\n            if rc<>0 then leave\n            call syscallm 'chattr (path)' st_filefmt ffmt\n            if retval<>-1 then leave\n         end\n\n      when zcmd='EXTATTR' then\n         do forever\n            if st.st_type<>s_isreg then\n               leave\n            genval=substr(st.st_genvalue,4)\n            extattrs= bitand(genval,'08'x)='00'x /* reverse bit */\n            extattra= bitand(genval,'04'x)='04'x\n            extattrp= bitand(genval,'02'x)='02'x\n            extattrl= bitand(genval,'10'x)='10'x  /* @D7A*/\n            oldeas=extattrs\n            oldeaa=extattra\n            oldeap=extattrp\n            oldeal=extattrl  /* @D7A*/\n            \"DISPLAY PANEL(\"pan.p_cngexat\")\"\n            if rc<>0 then leave\n            genm='00'x\n            if oldeas<>extattrs then\n               genm=bitor(genm,'08'x)\n            if oldeaa<>extattra then\n               genm=bitor(genm,'04'x)\n            if oldeap<>extattrp then\n               genm=bitor(genm,'02'x)\n            if oldeal<>extattrl then    /* 2@D7A*/\n               genm=bitor(genm,'10'x)\n            genval='00'x\n            if extattrs=0 then\n               genval=bitor(genval,'08'x)\n            if extattra=1 then\n               genval=bitor(genval,'04'x)\n            if extattrp=1 then\n               genval=bitor(genval,'02'x)\n            if extattrl=1 then            /* 2@D7A*/\n               genval=bitor(genval,'10'x)\n            genval='000000'x || genval\n            genm='000000'x || genm\n            call syscallm 'chattr (path)' st_genvalue '(genm) (genval)'\n            if retval<>-1 then leave\n         end\n\n      when zcmd='BPXWACLS' then     /* access acl  2@DAA */\n         call editacl 'acl',path\n\n      when zcmd='BPXWACLD' then     /* dir dflt acl  2@DAA */\n         call editacl 'dir',path\n\n      when zcmd='BPXWACLF' then     /* file dflt acl 2@DAA */\n         call editacl 'file',path\n\n      otherwise\n   end\n   zcmd=''\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* decodemtab:  copy mtab fields to panel variables                   */\n/**********************************************************************/\ndecodemtab:\n   arg mtix\n   type=mtab.mnte_type.mtix\n   cmode=d2c(mtab.mnte_mode.mtix,4)\n   z4='00000000'x\n   if bitand(cmode,'00000001'x)=z4 then mode='R/W'; else mode='R/O'\n   if bitand(cmode,'00000002'x)=z4 then md=md'-'; else md=md'S'\n   if bitand(cmode,'00000004'x)=z4 then md=md'-'; else md=md'E'\n   if bitand(cmode,'00000008'x)=z4 then md=md'-'; else md=md'U'\n   if bitand(cmode,'00000010'x)=z4 then amv='Yes'; else amv='No'\n   if bitand(cmode,'00000020'x)=z4 then md=md'-'; else md=md'C'\n   if bitand(cmode,'00000040'x)<>z4 then amv='Unmount'   /* @D9A*/\n   sysname=mtab.mnte_sysname.mtix\n   dirblio=mtab.mnte_diribc.mtix\n   datablrd=mtab.mnte_readibc.mtix\n   datablwr=mtab.mnte_writeibc.mtix\n   dev=mtab.mnte_dev.mtix\n   dd=mtab.mnte_dd.mtix\n   fstype=mtab.mnte_fstype.mtix\n   path=mtab.mnte_path.mtix\n                                                               /*@DND*/\n   roseclab=mtab.mnte_roseclabel.mtix             /* @DEA*/\n   if mtab.mnte_syslist.mtix<>'' then             /* 13@DCA*/\n      do\n      /* syslist: 2 byte count, 2 byte type, 8 byte names */\n      if bitand('0001'x,substr(mtab.mnte_syslist.mtix,3,2))='0000'x then\n         amv='I'\n       else\n         amv='E'\n      syslist=substr(mtab.mnte_syslist.mtix,5)\n      do syslistc=c2d(substr(mtab.mnte_syslist.mtix,1,2)) by -1 to 1\n         amv=amv','strip(substr(syslist,1,8))\n         syslist=substr(syslist,9)\n      end\n      end\n   do ix=1 to 21\n      call value 'fsparm'ix,,\n                 substr(mtab.mnte_parm.mtix,(ix-1)*50+1,50,'_')\n   end\n\n   pfsstnor=substr(mtab.mnte_pfsstatusnormal.mtix,1,50,'_')/*@PLC@DIA*/\n   pfsstexc=substr(mtab.mnte_pfsstatusexcp.mtix,1,50,'_')  /*@PLC@DIA*/\n\n           /* Get the user ID from the uid and display them both @DOA*/\n           /* If uid=0 then privileged mount so clear out info   @DOA*/\n   uid=mtab.mnte_fsusrmntuid.mtix                              /*@DOA*/\n   if uid <>0 Then                                             /*@DOA*/\n   do                                                          /*@DOA*/\n     id.=''                                                    /*@DOA*/\n     address syscall 'getpwuid' uid 'id.'                      /*@DOA*/\n     uname=id.pw_name                                          /*@DOA*/\n     user=strip(uname)'('uid')'                                /*@DOA*/\n   end                                                         /*@DOA*/\n   else                                                        /*@DOA*/\n     user=''                                                   /*@DOA*/\n\n   return\n\n/**********************************************************************/\n/* filesys_cmd:  process command from filesys display                 */\n/**********************************************************************/\nfilesys_cmd:\n   arg selcode\n   if selcode<>'' then\n      vactc=selcode\n    else\n      do\n      \"ADDPOP COLUMN(20) ROW(1)\"\n      src=popobj(pan.p_smt)\n      \"REMPOP\"\n      if src<>0 then return\n      end\n   \"ADDPOP\"\n   fsix=i\n   select\n      when vactc='A' then\n         do\n         call decodemtab fsix\n         do forever\n            st.=\n            if mtab.mnte_status.fsix=0 then\n               do\n               call syscallm \"statfs (fsname) st.\"\n               end\n            blksz=st.stfs_blocksize\n            total=st.stfs_total\n            avail=st.stfs_avail\n            inuse=st.stfs_inuse\n            nosuid=st.stfs_nosuid\n            nosec=st.stfs_nosec                                 /*@D6A*/\n            \"DISPLAY PANEL(\"pan.p_mtstat\")\"\n                                                              /*3@DND*/\n            if rc<>0 then leave\n            if zcmd='SHOWOBJ' then\n               do\n               call showobj\n               iterate\n               end\n         end\n         end\n\n      when vactc='U' then\n         do\n         opt=''\n         \"DISPLAY PANEL(\"pan.p_mtunmt\")\"\n         if rc=0 then\n            do\n            if opt='' then\n               mode=mtm_normal\n             else\n               mode=value('mtm_'opt)\n            if wtm<>'' then\n               do\n               call syscalls 'SIGON'\n               address syscall 'sigaction' sigalrm sig_cat 0 'ohdl oflg'\n               address syscall 'sigprocmask' sig_unblock,\n                  sigaddset(sigsetempty(),sigalrm) 'mask'\n               address syscall \"alarm\" wtm\n               end\n            call syscallm \"unmount (fsname)\" mode\n            srv=retval\n            if wtm<>'' then\n               do\n               address syscall \"alarm 0\"\n               address syscall 'sigaction' sigalrm ohdl oflg 'x y'\n               call syscalls 'SIGOFF'\n               end\n            if srv=-1 then\n               do\n               \"REMPOP\"\n               call filesys_cmd vactc\n               end\n            end\n         end\n\n      when vactc='R' then\n         if statnum=4 then      /* draining   @DJC*/\n            do\n            opt=''\n            call syscallm \"unmount (fsname)\" mtm_reset\n            end\n          else\n            do\n            opt=''\n            \"DISPLAY PANEL(\"pan.p_unquiesce\")\"\n            if rc=0 then\n             if type='ZFS' then                         /* 3@DJA*/\n               call zfsunquiesce\n              else\n               call syscallm \"unquiesce (fsname) 1\"\n            end\n\n      when vactc='M' then       /* 60@D7A*/\n         do\n         opt=''\n         call decodemtab fsix\n         if mode='R/W' then\n            newmode='R/O'\n          else\n            newmode='R/W'\n         if amv='No' then               /* 3@D9D  16@D9A */\n            do\n            newamv='Yes'\n            newamv2='Unmount'\n            end\n         else\n         if amv='Yes' then\n            do\n            newamv='No'\n            newamv2='Unmount'\n            end\n         else\n            do\n            newamv='No'\n            newamv2='Unmount'\n            end\n         oldsys=sysname\n         fssystem=''\n         \"DISPLAY PANEL(\"pan.p_cngfsat\")\"\n         if rc=0 then\n            select\n\n               when vactc='C' then\n                  do\n                  \"DISPLAY PANEL(\"pan.p_remount\")\"\n                  if rc=0 then\n                     do\n                     call syscallm \"unmount (fsname)\" mtm_remount\n                     srv=retval\n                     if srv=-1 then\n                        do\n                        \"REMPOP\"\n                        call filesys_cmd 'M'\n                        end\n                     end\n                  end\n\n               when vactc='M' then         /* xx@DCA*/\n                  do\n                  vactc=substr(amv,1,1)\n                  do sli=1 to 32                        /* 3@PCA*/\n                     call value 'SYSNM'sli,''\n                  end\n                  if vactc='I' | vactc='E' then\n                     do\n                     amvsl=translate(substr(amv,3),' ',',')\n                     do sli=1 to words(amvsl)\n                        call value 'SYSNM'sli,word(amvsl,sli)\n                     end\n                     end\n                  \"ADDPOP\"\n                  \"DISPLAY PANEL(\"pan.p_selamt\")\"\n                  rrc=rc\n                  \"REMPOP\"\n                  if rrc=0 then\n\n                     if vactc='Y' | vactc='N' | vactc='U' then\n                           do\n                           mt.=''\n                           mt.mnte_rflags=3\n                           mt.mnte_fsname=fsname\n                           if vactc='N' then\n                              mt.mnte_mode=mnt_mode_noautomove\n                           else\n                           if vactc='Y' then\n                              mt.mnte_mode=0\n                           else\n                              mt.mnte_mode=mnt_mode_aunmount\n                           call syscallm 'mount mt.'\n                           end\n                     else\n                     if vactc='I' | vactc='E' then\n                        do\n                        mt.=''\n                        mt.mnte_rflags=3\n                        mt.mnte_mode=0              /* @PDA*/\n                        mt.mnte_fsname=fsname\n                        if vactc='I' then\n                           mt.mnte_syslist='0000'x\n                        else\n                           mt.mnte_syslist='0001'x\n                        slc=0\n                        do sli=1 to 32\n                           sysnm=value('SYSNM'sli)\n                           if sysnm<>'' then\n                              do\n                              slc=slc+1\n                              mt.mnte_syslist=mt.mnte_syslist ||,\n                                              translate(left(sysnm,8))\n                              end\n                        end\n                        mt.mnte_syslist=d2c(slc,2) || mt.mnte_syslist\n                        call syscallm 'mount mt.'\n                        end\n\n                  end\n\n               when vactc='O' then\n                  do\n                  mt.=''\n                  mt.mnte_rflags=1\n                  mt.mnte_fsname=fsname\n                  mt.mnte_sysname=fssystem\n                  call syscallm 'mount mt.'\n                  end\n\n               when vactc='S' then                           /*14@DKA*/\n                  do\n                  \"DISPLAY PANEL(\"pan.p_samemode\")\"\n                  if rc=0 then\n                     do\n                     call syscallm \"unmount (fsname)\" mtm_samemode\n                     srv=retval\n                     if srv=-1 then\n                        do\n                        \"REMPOP\"\n                        call filesys_cmd 'M'\n                        end\n                     end\n                  end\n\n               otherwise\n                  nop\n            end\n         end\n\n      otherwise\n         \"REMPOP\"\n         call filesys_cmd\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* zfsunquiesce                                                       */\n/************************************************************** 12@DJA*/\nzfsunquiesce:\n   z4='00000000'x\n   agid='AGID' || '5401'x || left(strip(fsname),45,'00'x) ||,\n        copies('00'x,33)\n   pctbf=d2c(133,4) ||,                     /* unquiesce     */\n         d2c(32,4)  ||,                     /* p0: ofs agrid */\n         'ffffffff'x ||,                    /* p1: force unq */\n         z4||z4||z4||z4||z4||,              /* p2-p6     */\n         agid\n   call syscallm 'pfsctl ZFS 1073741829 pctbf'\n   return\n\n/**********************************************************************/\n/* filesystable:  build file system table                             */\n/**********************************************************************/\nfilesystable:\n   call syscallm 'getmntent mtab.'\n   if retval=-1 then return\n   \"TBCREATE MTAB NAMES\" ||,\n    \"(S,FSNAME,STATUS,SYSNAME,AM,RO,BLKCNT,PATH,TYPE,I,LOCATE,\" ||,\n    \"STATNUM,USERCOL) NOWRITE REPLACE\"             /*@DPC@DOC@08C@DHC*/\n   if pos('sysname',mtabf2)>0 then                        /*@0UC3@08A*/\n      \"TBSORT MTAB FIELDS(SYSNAME,C,A,FSNAME,C,A)\"\n    else\n      \"TBSORT MTAB FIELDS(FSNAME)\"\n   s=''\n   do i=1 to mtab.0\n      call setmntent\n      \"TBADD MTAB ORDER\"\n   end\n   return\n\n/**********************************************************************/\n/* setmntent:  set vars for a mount entry                             */\n/**********************************************************************/\nsetmntent:\n   fsname=mtab.mnte_fsname.i\n   type=mtab.mnte_fstype.i              /* @DHA*/\n   locate=translate(fsname)\n   sysname=mtab.mnte_sysname.i          /* 8@08A*/\n   sysname=mtab.mnte_sysname.i\n   blkcnt=mtab.mnte_diribc.i+mtab.mnte_readibc.i+mtab.mnte_writeibc.i\n   path=mtab.mnte_path.i\n   cmode=d2c(mtab.mnte_mode.i,4)\n   z4='00000000'x\n   if bitand(cmode,'00000010'x)=z4 then am='Yes'; else am='No'\n   if bitand(cmode,'00000040'x)<>z4 then am='U'   /* @DFA*/\n   if mtab.mnte_syslist.i<>'' then                /* 8@DFA*/\n      do\n      /* syslist: 2 byte count, 2 byte type, 8 byte names */\n      if bitand('0001'x,substr(mtab.mnte_syslist.i,3,2))='0000'x then\n         am='I'\n       else\n         am='E'\n      end\n   if bitand(cmode,'00000001'x)=z4 then ro='No'; else ro='Yes'\n\n    /* Get user ID from uid to display in User ID column of mount table.\n       If uid=0 then column will be blank. If user ID is blank for\n       whatever reason, then show UID instead.                   @DOA*/\n   uid=mtab.mnte_fsusrmntuid.i                                 /*@DOA*/\n   if uid = 0 then                                             /*@DOA*/\n     usercol=''                                            /*@DPC@DOA*/\n   else                                                        /*@DOA*/\n   do                                                          /*@DPA*/\n     id.=''                                                    /*@DPA*/\n     address syscall 'getpwuid' uid 'id.'                      /*@DPA*/\n     if id.pw_name='' then                                     /*@DPA*/\n       usercol=uid                                             /*@DPA*/\n     else                                                      /*@DPA*/\n       usercol=strip(id.pw_name)                               /*@DPA*/\n   end                                                         /*@DPA*/\n\n   statnum=mtab.mnte_status.i\n   statnum2=mtab.mnte_status2.i                                /*@DIA*/\n   j=statnum\n   k=statnum2                                                  /*@DIA*/\n   select                                                     /*5@DIA*/\n     when k=1  then \"GETMSG MSG(\"lit\"022) LONGMSG(STATUS)\"\n     when k=2  then \"GETMSG MSG(\"lit\"023) LONGMSG(STATUS)\"\n     when k=4  then \"GETMSG MSG(\"lit\"024) LONGMSG(STATUS)\"\n     when k=8  then \"GETMSG MSG(\"lit\"019) LONGMSG(STATUS)\"\n     when k=16 then \"GETMSG MSG(\"lit\"020) LONGMSG(STATUS)\"\n     when k=32 then \"GETMSG MSG(\"lit\"021) LONGMSG(STATUS)\"\n     otherwise\n      do                                                       /*@DIA*/\n       select\n        when j=0 then status=L#mt0\n        when j=1 then status=L#mt1\n        when j=2 then status=L#mt2\n        when j=4 then status=L#mt4\n        when j=8 then status=L#mt8\n        when j=16 then status=L#mt16\n        when j=32 then status=L#mt32\n        when j=64 then status=L#mt64\n        when j=128 then\n         do\n           quiesr=strip(mtab.mnte_qjobname.i),\n                  '('mtab.mnte_qpid.i')'\n           \"GETMSG MSG(\"lit\"008) LONGMSG(STATUS)\"\n         end\n        when j=130 then status=L#mt130\n        otherwise\n               \"GETMSG MSG(\"lit\"009) LONGMSG(STATUS)\"\n       end                                                   /*@DIA*/\n      end                                                    /*@DIA*/\n   end\n   return\n\n/**********************************************************************/\n/* fsattr: show fs attributes using pathname                    44@D5A*/\n/**********************************************************************/\nfsattr:\n   \"ADDPOP\"\n   do forever\n      st.=\n      call syscallm \"statvfs (path) st.\"\n      if retval=-1 then\n         return\n      if st.stfs_fsid<>0 & datatype(st.stfs_fsid,'W') then\n         do\n         address syscall 'getmntent mtab.' st.stfs_fsid\n         if retval<>-1 then\n            do                      /* @08A*/\n            i=1                     /* @08A*/\n            call setmntent          /* @08A*/\n            call decodemtab 1\n            end                     /* @08A*/\n         end\n      blksz=st.stfs_blocksize\n      total=st.stfs_total\n      avail=st.stfs_avail\n      inuse=st.stfs_inuse\n      nosuid=st.stfs_nosuid\n      nosec=st.stfs_nosec                                       /*@D6A*/\n      \"DISPLAY PANEL(\"pan.p_mtstat\")\"\n                                                              /*3@DND*/\n      if rc<>0 then leave\n      if zcmd='SHOWOBJ' then\n         do\n         call showobj\n         iterate\n         end\n   end\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* run_diff:  get args for diff and run it                            */\n/**********************************************************************/\nrun_diff:\n   parse arg vpathflg opt\n   pgmpath=diffpath\n   call syscallm \"access (pgmpath)\" x_ok\n   if retval=-1 then\n      do\n      \"SETMSG MSG(\"msg.m_nopgm\")\" msgloc\n      return\n      end\n   call syscallm \"access (path)\" r_ok\n   if retval=-1 then\n      do\n      msgpath=path\n      \"SETMSG MSG(\"msg.m_noacc\")\" msgloc\n      return\n      end\n   parm.0=5\n   parm.1=pgmpath\n   parm.2=opt\n   parm.3='-c'\n   parm.4=path\n   parm.5=path\n   \"ADDPOP\"\n   done=0\n   do until done\n      call makevpath parm.5\n      vtext=vpathflg\n      \"DISPLAY PANEL(\"pan.p_getpath\")\"\n      if rc<>0 then\n         do\n         \"REMPOP\"\n         return\n         end\n      parm.5=makepath()\n      call syscallm \"access (parm.5)\" r_ok\n      if retval=-1 then\n         do\n         msgpath=parm.5\n         \"SETMSG MSG(\"msg.m_noacc\")\" msgloc\n         iterate\n         end\n      vtext='CO'\n      \"ADDPOP\"\n      stdout=''\n      temppath=''\n      do until done\n         call makevpath stdout\n         \"DISPLAY PANEL(\"pan.p_getpath\")\"\n         if rc<>0 then\n            do\n            \"REMPOP\"\n            \"VGET (ZVERB)\"\n            if zverb<>\"CANCEL\" then\n               do\n               \"REMPOP\"\n               return\n               end\n            leave\n            end\n         stdout=makepath()\n         if length(stdout)=0 |temppath==stdout then\n            do\n            tempname=1\n            stdout='/tmp/'sysvar('SYSUID')'.'time('L')'.ishell'\n            temppath=stdout\n            end\n          else\n            tempname=0\n         call syscallm \"creat (stdout)\" 600\n         if retval=-1 then\n            iterate\n         fd1=retval\n         fd2=retval\n         done=1\n      end\n   end\n   \"REMPOP\"                   /* @0PM*/\n   \"REMPOP\"                   /* @0PM*/\n   env.0=0\n   fd0=-1\n   cmd=diffpath'...'\n   call spawnpgm pan.p_getpath\n   select\n      when retcode=0 then\n         \"SETMSG MSG(\"msg.m_nodiff\")\"\n      when retcode=1 then\n         do\n         call syscallm 'stat (stdout) st.'\n         if st.st_size>0 & st.st_type=s_isreg then\n            call obrowse stdout,0\n          else\n            \"SETMSG MSG(\"msg.m_diff\")\"\n         end\n      otherwise\n   end\n   address syscall 'close' fd1\n   if tempname=1 then\n      do\n      address syscall 'unlink (stdout)'\n      stdout=''\n      end\n   return\n\n/**********************************************************************/\n/* find_opts:  get opts for search                                    */\n/**********************************************************************/\nfind_opts:\n   optrc=1\n   \"ADDPOP\"\n   stdout=''\n   done=0\n   temppath=''\n   do until done\n      vtext=arg(1)\n      call makevpath stdout\n      \"DISPLAY PANEL(\"pan.p_getpath\")\"\n      if rc<>0 then\n         do\n         \"REMPOP\"\n         leave\n         end\n      stdout=makepath()\n      if length(stdout)=0 | temppath==stdout then\n         do\n         tempname=1\n         stdout='/tmp/'sysvar('SYSUID')'.'time('L')'.ishell'\n         temppath=stdout\n         end\n       else\n         tempname=0\n      \"ADDPOP\"\n      do until done\n         \"DISPLAY PANEL(\"pan.p_srchstr\")\"\n         if rc<>0 then\n            do\n            \"REMPOP\"\n            \"VGET (ZVERB)\"\n            if zverb<>'CANCEL' then\n               done=1\n            if zverb='EXIT' then\n               \"REMPOP\"\n            leave\n            end\n         optrc=0\n         done=1\n      end\n   end\n   if done=0 then\n      \"REMPOP\"\n   return optrc\n\n/**********************************************************************/\n/* spawnpgm:  spawn a program                                         */\n/**********************************************************************/\nspawnpgm:\n   arg pan\n   retcode=-1\n   fd.0=fd0\n   fd.1=fd1\n   fd.2=fd2\n   \"CONTROL DISPLAY LOCK\"\n   \"SETMSG MSG(\"msg.m_gentxt\")\" msgloc\n   \"DISPLAY PANEL(\"pan\")\"\n   call runopts 'env.'\n   call syscallm 'spawn (pgmpath) 3 fd. parm. env.'\n   pid=retval\n   address syscall 'waitpid (pid) st. 0'\n   if st.w_ifexited=0 then\n      \"SETMSG MSG(\"msg.m_nopgm\")\" msgloc\n   else\n      retcode=st.w_exitstatus\n   return retcode\n\n/**********************************************************************/\n/* print_hdr:  print top of page heading                              */\n/**********************************************************************/\nprint_hdr:\n   arg pg\n   if pg>0 then\n      hdr1=right('Page:' pg,zlsttrun)\n   page='PAGE'\n   do hdri=1 to hdr0\n      'LIST BUFNAME(HDR'hdri') LINELEN('length(value('hdr'hdri))')' page\n      page=''\n   end\n   return\n\n/**********************************************************************/\n/* makepath: return pathname made from vpath01-vpath20 vars           */\n/**********************************************************************/\nmakepath:\n   retpath=''\n   quote=\"'\"\n   do i=1 to 20\n      tpath=value('vpath' || right(i,2,0))\n      if tpath='' then\n         leave\n      if substr(tpath,1,1)=quote then\n         tpath=substr(tpath,2)\n      if length(tpath)=0 then\n         iterate\n      if substr(tpath,length(tpath),1)=quote then\n         tpath=substr(tpath,1,length(tpath)-1)\n      retpath=retpath || tpath\n   end\n   return retpath\n\n/**********************************************************************/\n/* makevpath: set vpath01-vpath20 vars from a pathname                */\n/**********************************************************************/\nmakevpath:\n   parse arg fullpath\n   quote=\"'\"\n   do i=1 to 20\n      parse var fullpath tpath 63 fullpath\n      if length(tpath)=0 then\n         leave\n      if substr(tpath,1,1)=quote | substr(tpath,1,1)==' ' |, /* @0GC*/\n         substr(tpath,1,1)='_' then                          /* @0GA*/\n         tpath=quote || tpath\n      if substr(tpath,length(tpath),1)=quote |,\n           substr(tpath,length(tpath),1)='_' |,              /* @0GA*/\n           substr(tpath,length(tpath),1)==' ' then\n         tpath=tpath || quote\n      xx=value('vpath' || right(i,2,0),tpath)\n   end\n   do i=i to 20\n      xx=value('vpath' || right(i,2,0),'')\n   end\n   return\n\n/**********************************************************************/\n/* showobj:  show selected object                                     */\n/**********************************************************************/\nshowobj:\n   call makevpath path\n   \"ADDPOP\"\n   \"DISPLAY PANEL(\"pan.p_obj\")\"\n   \"REMPOP\"\n   return\n\n/**********************************************************************/\n/* setcolors: setup colors                                            */\n/*                                                                    */\n/* cltd  directory       clsa  ext attr           clst  trunc name    */\n/* cltr  reg file        clsu  setuid/gid                             */\n/* cltf  fifo            clss  sticky                                 */\n/* cltc  char spec       clsx  exec perm                              */\n/* clts  symlink         clso  not yours                              */\n/*                                                                    */\n/* 33  white     36  green       39  turq                             */\n/* 34  red       37  pin                                              */\n/* 35  blue      38  yellow      32  default                          */\n/*                                                                    */\n/**********************************************************************/\nsetcolors:\n   parse arg coloropt\n   clvars='CLNO CLTD CLTR CLTF CLTC CLTS CLSA CLSU CLSS CLSX CLSO CLST'\n   if coloropt=0 then\n      do\n      \"VGET (\"clvars\") PROFILE\"\n      return\n      end\n   \"DISPLAY PANEL(\"pan.p_dircolor\")\"\n   if rc<>0 then\n      \"VGET (\"clvars\") PROFILE\"\n    else\n      \"VPUT (\"clvars\") PROFILE\"\n   return\n\n/**********************************************************************/\n/* color: determine color attribute byte                              */\n/**********************************************************************/\ncolor:\n   colorchoice=xrange('33'x,'39'x) || '3f3e'x\n   if gotcolors<>1 then\n      call setcolors 0\n   coloratt='32'x\n   if clno='/' then return coloratt\n   if filetpn=1 & datatype(cltd,'W') then\n      coloratt=substr(colorchoice,cltd,1)\n   else\n   if filetpn=2 & datatype(cltc,'W') then\n      coloratt=substr(colorchoice,cltc,1)\n   else\n   if filetpn=3 & datatype(cltr,'W') then\n      coloratt=substr(colorchoice,cltr,1)\n   else\n   if filetpn=4 & datatype(cltf,'W') then\n      coloratt=substr(colorchoice,cltf,1)\n   else\n   if filetpn=5 & datatype(clts,'W') then\n      coloratt=substr(colorchoice,clts,1)\n\n   if datatype(clso,'W') & fileuid<>myuid then\n      coloratt=substr(colorchoice,clso,1)\n   if datatype(clsx,'W') & filetpn=3 &,\n        bitand(strip(filemd,'B','+'),'010101'x)<> '000000'x then\n      coloratt=substr(colorchoice,clsx,1)\n   if datatype(clst,'W') & filenmtrunc=1 then\n      coloratt=substr(colorchoice,clst,1)\n   if datatype(clsu,'W') & filesid=1 then\n      coloratt=substr(colorchoice,clsu,1)\n   if datatype(clss,'W') & filestk=1 then\n      coloratt=substr(colorchoice,clss,1)\n   if datatype(clsa,'W') & filexa=1 then\n      coloratt=substr(colorchoice,clsa,1)\n\n   return coloratt\n\n/**********************************************************************/\n/* actionlist: display a table as an action list                      */\n/*                                                                    */\n/*   the panel must contain a scrollable dynamic area called DYN      */\n/*   and the table must contain the name S                            */\n/*   On return,                                                       */\n/*     SELROW.SELLEV. contains the row numbers for all selected rows  */\n/*     SELROW.SELLEV.0 contains the number of selected rows           */\n/*     SELROW.SELLEV.SEL_TOP contains the top row number              */\n/*   The table is updated for each selected row with S containing     */\n/*   the action code.                                                 */\n/**********************************************************************/\n\nactionlist:\n   procedure expose selrow. sellev zverb vpath01 vpath02 msg. pan. path,\n     st_type L#ftypes st_size vdirfc st_mtime st_uid pw_name st_mode,\n     st_setuid st_setgid st_sticky st_gid st_genvalue,\n     f_ok noconf m_scerr pw_uid gmt,\n     enopref ejrcomp tm_mon tm_mday tm_year tm_hour tm_min vdirfu,\n     pgmbrws iplace tplace althelp pw_dir st_accessacl,\n     st_fmodelacl st_dmodelacl ltime. flsort flsorts myuid,\n     absel vdirvb alcurcmd pattern. noautosk                  /* @DFC*/\n   true=1\n   parse arg id,first,selrow,panel,format,name,dirlst\n   selrow.sellev.0=0\n   sel=0\n   selrow.sel_top=first\n   \"TBSTATS\" id \"ROWCURR(TOTAL)\"\n   if rc<>0 | datatype(total,'W')=0 then return 0\n   if total=0 then\n      do\n      zverb='EMPTY'\n      return 0\n      end\n   \"VGET (ZSCREENW ZSCREEND)\"\n   \"PQUERY PANEL(\"panel\") AREANAME(DYN)\",\n      \"WIDTH(WIDTH) DEPTH(DEPTH)\"\n   if rc>8 then                                              /* 5@0JA*/\n      do\n      say zerrmsg zerrlm\n      zverb = 'RETURN'\n      end\n   if rc<>0 then\n      return 0\n   total=strip(total,'L','0')\n   if first>total then\n      first=1\n   if selrow>total | datatype(selrow,'W')=0 then  /* @DHC*/\n      selrow=1\n   ddi=(selrow-first)*width+2\n   if ddi<2 then ddi=2\n   hexdata=xrange('00'x,'0d'x) || xrange('10'x,'3f'x)\n   do forever\n\n      dynhdr='3e4040'x\n      map=format\n      modify=0\n      do while map<>''\n         parse var map . v j '<' t '>' map\n         parse var t pref '(' subvar ')'\n         if subvar<>'' then\n            t=pref'-'value(subvar)\n         if length(t)<>j then\n            t=left(t,j)\n         dynhdr=dynhdr || t || '  '\n         if v='$' then\n            modify=1\n      end\n      if first>total then\n         first=total\n      rowsh='Row' first 'of' total\n      dynhdr=substr(dynhdr,1,width-length(rowsh)-4) ' 'rowsh\n      dyn=''\n      linenum=0\n      \"TBTOP\" id\n      \"TBSKIP\" id \"NUMBER(\"first-1\") NOREAD\"\n      do cnt=1 to depth\n         \"TBSKIP\" id\n         if rc>0 then leave\n         if dirlst=1 & filecd='' then\n            filecd=substr(ltime(filect),1,16)\n         map=format\n         linenum=linenum+1\n         if s='' then s='_'\n         ln=''\n         do while map<>''\n            parse var map v j t '<' . '>' map\n            if j='r' then\n               ln=ln || right(value(v),t)'  '\n            else\n            if j='c' then\n               ln=ln || center(value(v),t)'  '\n            else\n            if j='$' then        /* modify allowed */\n               do\n               ln=ln || '31'x || left(value(v),t) '32'x\n               updname=v\n               end\n            else                                      /* 8@DFA*/\n            if j='p' then        /* perms in rwxrwxrwx format */\n               do\n               perm=value(v)\n               if length(perm)=3 then\n                  perm=' ' || perm\n               else\n               if length(perm)=4 then\n                  nop\n               else\n                  perm=' 000'\n               perms=substr(perm,1,1) ||,\n                     o2rwx(substr(perm,2,1)) ||,\n                     o2rwx(substr(perm,3,1)) ||,\n                     o2rwx(substr(perm,4,1))\n               ln=ln || left(perms,t)'  '\n               end\n             else\n              if id<>'DIR' then\n               ln=ln || left(value(v),t)'  '\n              else\n               do\n               if map='' then\n                  do\n                  filenmtrunc=(length(ln)+length(value(v))+3)>width\n                 if ln <> '' then                            /* @0IA*/\n                  ln=substr(ln,1,length(ln)-1) || color()\n                 else                                        /* @0IA*/\n                  ln = color()                               /* @0IA*/\n                  end\n               ln=ln || left(translate(value(v),,hexdata,' '),t)'  '\n               end\n         end\n         if noautosk='/' then                          /* @DFA*/\n            s#attr='30'x                               /* @DFA*/\n          else\n            s#attr='32'x                               /* @DFA*/\n         if modify then\n            dyn=dyn || '31'x || s || s#attr substr(ln,1,width-4)\n          else\n            dyn=dyn || '31'x || s || s#attr || substr(ln,1,width-3)\n      end\n\n      do cnt=cnt to depth\n         dyn=dyn || copies(' ',width)\n      end\n      zcmd=''\n      if id='DIR' then\n         do\n         address syscall 'geteuid'\n         uidline='EUID='retval\n         patix=pattern.0          /* 7@DFC*/\n         if patix>0 then    /* if filter short and on show it in red */\n            if length(pattern.patix)>10 then\n               uidline=uidline '34'x || 'FILTER=ON' || '32'x\n             else\n               uidline=uidline '34'x || pattern.patix || '32'x\n         end\n      if id='DIR' then panpath='32'x || uidline ' ' path\n      if alcurcmd=1 then                        /* 5@DBA*/\n         curfield='CURSOR(ZCMD)'\n       else\n         curfield=\"CURSOR(DYN) CSRPOS(\"ddi\")\"\n      alcurcmd=0\n      \"DISPLAY PANEL(\"panel\")\" curfield         /* @DBC*/\n      src=rc\n      \"VGET (ZSCROLLA ZSCROLLN ZVERB)\"\n      if src<>0 then\n         return 0\n       dynwrk=dyn\n       cmd=translate(zcmd)\n       if id='DIR' & word(cmd,1)='FILTER' then          /* 6@DFC*/\n          do\n          parse var zcmd . cmd\n          zverb='FILTER' cmd\n          return 0\n          end\n       if word(cmd,1)='SEL' then\n          do\n          absel=word(cmd,2)\n          cmd=''\n          end\n        else\n          absel=''\n       do selrow=1 by 1 while dynwrk<>''\n          dynln=substr(dynwrk,1,width)\n          tag=substr(dynln,1,1)\n          dynwrk=substr(dynwrk,width+1)\n          if tag='3f'x then\n             do\n             sel=sel+1\n             selrow.sellev.sel=first+selrow-1\n             \"TBTOP\" id\n             \"TBSKIP\" id \"NUMBER(\"selrow.sellev.sel\")\"\n             s=substr(dynln,2,1)\n             if s='' then s='_'\n             if modify then\n                do\n                upd=substr(dynln,4)\n                parse var upd '3f'x upd '32'x\n                if upd<>'' then\n                   do\n                   update=strip(upd)\n                   call value updname,update\n                   end\n                end\n             \"TBPUT\" id\n             end\n       end\n       if zverb='UP' | zverb='DOWN' then\n          do\n          ddi=2\n          alcurcmd=1\n          if lvline>0 then\n             select\n               when zscrolla='PAGE' then\n                 if zverb='UP' then\n                    first=first-lvline\n                  else\n                    first=first+lvline\n\n               when zscrolla='MAX' then\n                 if zverb='UP' then\n                    first=1\n                  else\n                    first=total-lvline+2\n\n               otherwise\n                  if zverb='UP' then\n                     first=first-zscrolln\n                   else\n                     first=first+zscrolln\n             end\n          if first>total-lvline+1 then\n             first=total-lvline+2\n          if first<1 then\n             first=1\n          selrow.sel_top=first\n          end\n       else\n       select\n         when cmd='' & csrfld='DYNHDR' & id='DIR' & sel=0 then\n            do\n            dynstr=reverse(substr(dynhdr,1,csrpos))\n            parse var dynstr dyncol .\n            csrcode=substr(dyncol,length(dyncol),1)\n            sortx=pos(csrcode,'FTP-OC')\n            if sortx>0 then\n               do\n               flsort=substr('NTPSOM',sortx,1)    /* @P8C*/\n               sortkey=word(\"FILENM,C,A FILETP,C,A FILEMD,C,A\",\n                            \"FILESZ,C,D FILEUSR,C,A FILECT,C,D\",sortx)\n               \"VPUT (FLSORT) PROFILE\"\n               sortx=pos(flsorts,'NCTPSOM')\n               if sortx>0 then\n                  sortkey=sortkey',' ||,\n                    word(\"FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A\",\n                         \"FILESZ,C,D FILEUSR,C,A FILECT,C,D\",sortx)\n              \"TBSORT DIR FIELDS(\"sortkey\")\"\n               end\n             else\n               done=1\n            end\n         when cmd='' & csrfld='DYN' & id='DIR' then\n            do\n            csrcol=csrpos//width\n            dynstr=reverse(substr(dynhdr,1,csrcol))\n            parse var dynstr dyncol .\n            csrcode=''\n            if length(dyncol)>0 then\n               do\n               csrcode=substr(dyncol,length(dyncol),1)\n               csrline=(width+csrpos-1)%width\n               end\n            zverb='SELECT' csrcode csrline\n            if csrcode<>'' | sel<>0 then\n               done=1\n            end\n         when cmd='' then\n            done=1\n         when cmd='REFRESH' | cmd='REFR' then  /* 5@DHA*/\n            do\n            done=1\n            zverb='REFRESH'\n            end\n         when abbrev('LOCATE',word(cmd,1)) then\n           do\n           oldfirst=0\n           find=word(cmd,2)\n           if find='' then\n              \"SETMSG MSG(\"msg.m_noarg\")\" msgloc\n            else\n              do 2\n              \"TBTOP\" id\n              \"TBSKIP\" id \"NUMBER(\"first\")\"\n              do newfirst=first by 1\n                 \"TBSKIP\" id\n                 if rc<>0 then leave\n                 if substr(locate,1,length(find))=find then\n                    leave\n              end\n              if rc=0 then\n                 do\n                 first=newfirst+1\n                 selrow.sel_top=first\n                 leave\n                 end\n               else\n                 if first<2 then\n                    do\n                    if oldfirst<>0 then\n                       first=oldfirst\n                    leave\n                    end\n                  else\n                    do\n                    oldfirst=first\n                    first=1\n                    end\n              end\n           end\n         when cmd='NOAB' & id='DIR' then\n           do\n           pan.p_dir=pan.p_dirshort\n           vdirvb=''\n           \"VPUT (VDIRVB) PROFILE\"\n           done=1\n           end\n         when cmd='AB' & id='DIR' then\n           do\n           pan.p_dir=pan.p_dirlong\n           done=1\n           vdirvb='/'\n           \"VPUT (VDIRVB) PROFILE\"\n           end\n         when cmd='SHOWOBJ' then\n           do\n           call makevpath name\n           \"ADDPOP\"\n           \"DISPLAY PANEL(\"pan.p_obj\")\"\n           \"REMPOP\"\n           end\n         when word(cmd,1)='SH' & words(zcmd)>1 then\n           do                                          /*start @05A*/\n           svpath=path\n           call shcmd delword(zcmd,1,1)\n           path=svpath\n           end\n         when word(cmd,1)='EX' & words(zcmd)>1 then\n           do\n           svpath=path\n           call shcmd delword(zcmd,1,1),1\n           path=svpath\n           end                                        /*end @05A*/\n         when word(cmd,1)='SORT' & id='DIR' &,\n              flsorts<>'' then                       /* 20@DBC*/\n           do\n           \"ADDPOP\"\n           \"DISPLAY PANEL(\"pan.p_dirsort\")\"\n           src=rc\n           \"REMPOP\"\n           if src=0 then\n             do\n             sortx=pos(flsort,'NCTPSOM')\n             if sortx=0 then sortx=1\n             sortkey=word(\"FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A\",\n                          \"FILESZ,C,D FILEUSR,C,A FILECT,C,D\",sortx)\n             sortx=pos(flsorts,'NCTPSOM')\n             if sortx>0 then\n                sortkey=sortkey',' ||,\n                   word(\"FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A\",\n                        \"FILESZ,C,D FILEUSR,C,A FILECT,C,D\",sortx)\n             \"TBSORT DIR FIELDS(\"sortkey\")\"\n             \"VPUT (FLSORT FLSORTS) PROFILE\"\n            end\n           end\n         when word(cmd,1)='COLORS' & id='DIR' then   /* 20@DBC*/\n           do\n           \"ADDPOP\"\n           call setcolors 1\n           \"REMPOP\"\n           end\n         otherwise\n            \"SETMSG MSG(\"msg.m_invcmd\")\"\n       end\n       if done=1 then leave\n       if cmd<>'' then alcurcmd=1\n   end\n   selrow.sellev.0=sel\n   return sel\n/**********************************************************************/\n/* o2rwx: convert octal permissions to rwf format                     */\n/***************************************************************  @DFA*/\no2rwx: procedure\n   parse arg perm\n   if bitand(perm,'04'x)<>'00'x then\n      rwx='r'\n    else\n      rwx='-'\n   if bitand(perm,'02'x)<>'00'x then\n      rwx=rwx || 'w'\n    else\n      rwx=rwx || '-'\n   if bitand(perm,'01'x)<>'00'x then\n      rwx=rwx || 'x'\n    else\n      rwx=rwx || '-'\n   return rwx\n\n/**********************************************************************/\n/* dirstat:  get stat for an item in the directory list               */\n/**********************************************************************/\ndirstat:\n   arg stix\n   numeric digits 10                                     /*@07A*/\n   if datatype(st.stix.st_type,'W'),\n       & st.stix.st_type>0 & st.stix.st_type<6 then\n      filetp=substr('   'L#ftypes,st.stix.st_type*4,4)\n   filetpn=st.stix.st_type\n   if pos('M',st.stix.st_size)<>0 Then                   /*@0VA*/\n      filesz='*' || right(st.stix.st_size,10)            /*@0VA*/\n   else                                                  /*@0VA*/\n      filesz=right(st.stix.st_size,11)                   /*@0VC*/\n   fileuid=st.stix.st_uid\n   filect=right(st.stix.st_mtime,10)\n   if datatype(fileuid,'W') then\n    if cachediruid.fileuid=fileuid then\n       fileusr=cachediruid.fileuid.1\n     else\n      do\n      pw.=''\n      address syscall 'getpwuid' fileuid 'pw.'\n      fileusr=pw.pw_name\n      cachediruid.fileuid=fileuid\n      cachediruid.fileuid.1=fileusr\n      end\n    else\n      fileusr=''\n   filemd=st.stix.st_mode\n   filexa=(bitand(substr(st.stix.st_genvalue,4),'16'x)<>'00'x) /*LAP--*/\n   filesid=(st.stix.st_setuid=1 | st.stix.st_setgid=1)\n   filestk=st.stix.st_sticky\n   if st.stix.st_accessacl=1 | st.stix.st_fmodelacl=1 |, /* 2@DAA*/\n        st.stix.st_dmodelacl=1 then\n      filemd='+'filemd\n   return\n\n/**********************************************************************/\n/* popobj:  display popup and handle showobj command                  */\n/**********************************************************************/\npopobj:\n   arg panel\n   /* 4@0ED*/\n   do forever\n      \"DISPLAY PANEL(\"panel\")\"\n      src=rc\n      if src<>0 | zcmd='' then\n         leave\n      if zcmd='SHOWOBJ' then\n         call showobj\n       else\n         \"SETMSG MSG(\"msg.m_invcmd\")\" msgloc\n   end\n   return src\n\n/**********************************************************************/\n/* Name:    ltime                                                     */\n/* Purpose: get gm time from epoch time                               */\n/**********************************************************************/\nltime:\n   arg tm\n   numeric digits 10\n   if datatype(tm,'W')<>1 | datatype(ltime.0,'W')<>1 then\n      return gtime(tm)\n   if tm=-1 then return ''   /* @DHA */\n   writetm='L'tm\n   address syscall 'write' ltime.0 'writetm'\n   if retval=-1 then   /* if error clean up coprocess and retry 20@DFA*/\n      do\n      address syscall 'close' ltime.0\n      address syscall 'close' ltime.1\n      address syscall 'waitpid (ltime.3) st. 0'\n      call runcoprocess\n      if datatype(tm,'W')<>1 | datatype(ltime.0,'W')<>1 then\n         return gtime(tm)\n      address syscall 'write' ltime.0 'writetm'\n      if retval=-1 then /* 2 errors in a row, turn off time conv */\n         do\n         address syscall 'close' ltime.0\n         ltime.0=''\n         gmt='GMT'\n         address syscall 'close' ltime.1\n         address syscall 'waitpid (ltime.3) st. 0'\n         return gtime(tm)\n         end\n      end\n   address syscall 'read' ltime.1 'ltimebf' 20\n   if retval=-1 then return gtime(tm)\n   return ltimebf\n\n   address syscall 'close' ltime.0\n   address syscall 'close' ltime.1\n   address syscall 'waitpid (ltime.3) st. 0'\n\n/**********************************************************************/\n/* Name:    gtime                                                     */\n/* Purpose: get gm time from epoch time                               */\n/**********************************************************************/\ngtime:\n   arg tm\n   numeric digits 10\n   if tm=0 | datatype(tm,'W')<>1 then\n      return ''\n   if tm=-1 then return ''   /* @DHA */\n   numeric digits\n   call syscallm 'gmtime' tm 'tm.'\n   if retval=-1 then return ''\n   return right(tm.tm_year,4,0)'-' ||,\n          right(tm.tm_mon,2,0)'-'right(tm.tm_mday,2,0),\n          right(tm.tm_hour,2,0)':'right(tm.tm_min,2,0) 'GMT'\n\n/**********************************************************************/\n/* usersetup: setup a user                                            */\n/**********************************************************************/\nusersetup:\n   arg mode uid\n   cmd='altuser ('user')'\n   ocmd=''\n   address syscall 'getpwnam (user) pw.'\n   if retval<1 | pw.pw_uid=dfltuser.pw_uid |  ,        /* @06C*/\n      datatype(pw.pw_uid,W)=0 then                     /* @0MA*/\n      if autouid=1 then                           /* 3@DFA*/\n         ocmd=ocmd 'AUTOUID'\n       else\n         ocmd=ocmd 'uid('uid')'\n    else\n      uid=pw.pw_uid\n   if home<>'' then\n      ocmd=ocmd \"home('\"home\"')\"\n   if program<>'' then\n      ocmd=ocmd \"program('\"program\"')\"\n   if ocmd<>'' then\n      do\n      cmd=cmd 'omvs('ocmd')'\n      call bpxwirac cmd\n      end\n   pw.=''\n   address syscall 'getpwnam (user) pw.'\n   if pw.pw_uid='' then\n      msgid=msg.m_baduid\n    else\n      do\n      pwuid=pw.pw_uid\n      pwgid=pw.pw_gid\n      pwdir=pw.pw_dir\n      pwpgm=pw.pw_shell\n      msgid=msg.m_defusr\n      if home<>'' then\n         do\n         address syscall 'access (home)' f_ok\n         if retval=-1 then\n            do\n            address syscall 'mkdir (home)' mode\n            end\n         address syscall 'chown (home)' pw.pw_uid pw.pw_gid  /* @0DM*/\n         end\n      /* setup other files/dirs for user which do not already exist */\n      end\n   return\n\n/**********************************************************************/\n/* nextuid:  find the next highest unused uid                         */\n/**********************************************************************/\nnextuid:\n   if autouid='' then                         /* 5@DFA*/\n      if checkautoid() then\n         return -1\n   if autouid=1 then\n      return 999999999   /* this number will not really be used */\n   call bpxwirac 'highuid'\n   if result<0 then\n      return result\n    else\n      return result+1\n\n/**********************************************************************/\n/* checkautoid: ask user if autouid/gid is to be used                 */\n/************************************************************** @15DFA*/\ncheckautoid:\n   'ADDPOP'\n   'DISPLAY PANEL('pan.p_autoid')'\n   src=rc\n   'REMPOP'\n   if src>0 then return 1\n   if autouid='/' then\n      autouid=1\n    else\n      autouid=0\n   if autogid='/' then\n      autogid=1\n    else\n      autogid=0\n   return 0\n\n/**********************************************************************/\n/* copy:  copy file1 to file2                                         */\n/**********************************************************************/\ncopy:\n   parse arg panel,file1,file2\n   call syscallm 'open (file1)' O_RDONLY+O_NONBLOCK 000\n   if retval=-1 then return 1\n   fd1=retval\n   address syscall 'fstat' fd1 'cp.'\n   cpino=cp.st_ino\n   cpdev=cp.st_dev\n   cpperm=tperm\n   tperm=cp.st_mode\n   cpgenval=cp.st_genvalue  /* @DFA*/\n   cpgenatt=''              /* @DFA*/\n   cpccsid=substr(cp.st_ccsid,1,4)            /* 2@DHA*/\n   cpfilefmt=cp.st_filefmt\n   cp.=''\n   address syscall 'stat (file2) cp.'\n   if retval<>-1 then\n      tperm=cp.st_mode\n   if cpino=cp.st_ino & cpdev=cp.st_dev then\n      do\n      address syscall 'close' fd1\n      return 0\n      end\n   \"ADDPOP\"\n   \"DISPLAY PANEL(\"pan.p_perm\")\"\n   src=rc\n   \"REMPOP\"\n   tperm=cpperm\n   if src<>0 then\n      return 1\n\n   if cpgenval<>'00000000'x then   /* 12@DFA*/\n      do                           /* ask if extattrs should be set */\n      cmd=file1\n      \"SETMSG MSG(\"msg.m_gentxt\")\"\n      \"ADDPOP\"\n      \"DISPLAY PANEL(\"pan.p_attrack\")\"\n      src=rc\n      \"REMPOP\"\n      if src<>0 then\n         return 1\n      end\n\n   call syscallm 'creat (file2)' vperm\n   fd2=retval\n   if retval=-1 then\n      do\n      address syscall 'close' fd1\n      return 1\n      end\n   address syscall 'fchmod' fd2 vperm\n   address syscall 'fchattr' fd2 st_ccsid '(cpccsid)',\n                                 st_filefmt '(cpfilefmt)'   /* @DHA*/\n   cmd='copy' file1 file2\n   \"CONTROL DISPLAY LOCK\"\n   \"SETMSG MSG(\"msg.m_gentxt\")\"\n   \"DISPLAY PANEL(\"panel\")\"\n   /* note: can and may eventually need to turn off translation\n            (w/ fcntl) to avoid problems with non-reversible tables */\n   do until retval<0\n      call syscallm 'read' fd1 'buf 16384'\n      if retval<1 then leave\n      szread=retval\n      do forever\n         call syscallm 'write' fd2 'buf' szread\n         if retval=szread | retval=-1 then\n            leave\n         buf=substr(buf,retval+1)\n         szread=szread-retval\n      end\n   end\n   address syscall 'close' fd1\n   address syscall 'close' fd2    /* @PGM*/\n   if cpgenatt='/' then   /* user wants extattrs set 10@DFA*/\n      do\n      cpgenm=cpgenval\n      call syscallm 'chattr (file2)' st_genvalue,\n                    '(cpgenm) (cpgenval)'  /* @PGC*/\n      if retval=-1 then\n         return 1\n      end\n\n   return 0\n\n/**********************************************************************/\n/* quotes: double-up all quotes                                       */\n/**********************************************************************/\nquotes: procedure\n   qpath=translate(arg(1),'00'x,\"'\")\n   do forever\n      i=pos('00'x,qpath)\n      if i=0 then leave\n      qpath=substr(qpath,1,i-1) || \"''\" || substr(qpath,i+1)\n   end\n   return qpath\n\n/**********************************************************************/\n/* tsocmd:  run tso command (oget/oput)                               */\n/**********************************************************************/\ntsocmd:\n   parse arg util,pan,cmdline\n   cmd=util cmdline\n   \"CONTROL DISPLAY LOCK\"\n   \"SETMSG MSG(\"msg.m_gentxt\")\"\n   \"DISPLAY PANEL(\"pan\")\"\n   xx=outtrap('M.')\n   address tso cmd\n   src=rc\n   xx=outtrap(off)\n   if src<>0 then\n      do ci=1 to m.0\n         say m.ci\n      end\n   return src\n\n/**********************************************************************/\n/* oedit:  call edit service                                          */\n/**********************************************************************/\noedit: procedure expose iplace tplace prof imac edprf pan. pgmedit msg.,\n         vactc isp\n   parse arg path\n   if edprf<>'/' then\n      do\n      \"ADDPOP\"\n      \"DISPLAY PANEL(\"pan.p_edopt\")\"\n      src=rc\n      \"REMPOP\"\n      if src<>0 then\n         do\n         \"VGET (IPLACE PROF IMAC EDPRF) PROFILE\"\n         return 20\n         end\n      \"VPUT (IPLACE PROF IMAC EDPRF) PROFILE\"\n      end\n   if vactc='G' then\n      do /* fixed length recs */\n      \"ADDPOP\"\n      \"DISPLAY PANEL(\"pan.p_getrecl\")\"\n      src=rc\n      \"REMPOP\"\n      if src<>0 then return 20\n      end\n    else\n      hfsrl=0\n   'VPUT (HFSRL)'\n   xx=lastpos('/',path)\n   if xx=0 then\n      do\n      path='./'path\n      xx=2\n      end\n   hfscwd=substr(path,1,xx)\n   hfsname=substr(path,xx+1)\n   if substr(hfscwd,length(hfscwd))='' |,\n       substr(hfsname,length(hfsname))='' then\n      do\n      \"SETMSG MSG(\"msg.m_nospaces\")\"\n      return 20\n      end\n   \"CONTROL DISPLAY SAVE\"\n   zplace=iplace\n   \"VPUT (HFSCWD HFSNAME PROF IMAC ZPLACE)\"\n   if isp>0 then                  /* using ispf services  14@DJA*/\n      do\n      if hfsrl<>0 then            /* 4@DLA*/\n         reclen='RECLEN('hfsrl')'\n       else\n         reclen=''\n      if imac = '' Then                                        /*@0SC*/\n        initmac=''                                             /*@0SC*/\n      else                                                     /*@0SC*/\n        initmac = 'MACRO('imac')'                              /*@0SC*/\n      if substr(path,1,1) <> '/' & substr(path,1,2) <> './' Then\n         path = './' || path                                   /*@0RA*/\n      \"VPUT (PATH)\"\n      \"EDIT FILE(PATH)\" reclen initmac                         /*@0SC*/\n      src=rc\n      /* ISPF edit only sets zerrsm if return code > 4           @0QA*/\n      if src>4 then                                            /*@0QC*/\n         do\n         zedsmsg=zerrsm        /* put out just the short msg if error */\n         zedlmsg=zerrsm\n         \"SETMSG MSG(ISRZ000)\"\n         end\n      end\n   else\n      do\n      \"SELECT CMD(\"pgmedit\") SUSPEND\"\n      src=rc\n      end                                               /* @DJA*/\n   zplace=tplace\n   \"VPUT (ZPLACE)\"\n   \"CONTROL DISPLAY RESTORE\"\n   return src\n\n/**********************************************************************/\n/* obrowse:  call browse service                                      */\n/**********************************************************************/\nobrowse: procedure expose iplace tplace pgmbrws msg. isp\n   parse arg path,hfsrl\n   xx=lastpos('/',path)\n   if xx=0 then\n      do\n      path='./'path\n      xx=2\n      end\n   hfscwd=substr(path,1,xx)\n   hfsname=substr(path,xx+1)\n   if substr(hfscwd,length(hfscwd))='' |,\n       substr(hfsname,length(hfsname))='' then\n      do\n      \"SETMSG MSG(\"msg.m_nospaces\")\"\n      return 20\n      end\n   \"CONTROL DISPLAY SAVE\"\n   zplace=iplace\n   \"VPUT (HFSCWD HFSNAME HFSRL ZPLACE)\"\n   if isp>0 then                  /* using ispf services  14@DJA*/\n      do\n      if hfsrl<>0 then            /* 4@DLA*/\n         reclen='RECLEN('hfsrl')'\n       else\n         reclen=''\n      if substr(path,1,1) <> '/' & substr(path,1,2) <> './' Then\n         path = './' || path                                   /*@0RA*/\n      \"VPUT (PATH)\"\n      \"BROWSE FILE(PATH)\" reclen\n      src=rc\n      if src<>0 then\n         do\n         zedsmsg=zerrsm        /* put out just the short msg if error */\n         zedlmsg=zerrsm\n         \"SETMSG MSG(ISRZ000)\"\n         end\n      end\n   else\n      do\n      \"SELECT CMD(\"pgmbrws\") SUSPEND\"\n      src=rc\n      end                                               /* @DJA*/\n   zplace=tplace\n   \"VPUT (ZPLACE)\"\n   \"CONTROL DISPLAY RESTORE\"\n   return src\n\n/**********************************************************************/\n/* pscmd:  show process table                                         */\n/**********************************************************************/\npscmd:\n   pstabf='pid r 10 <Process_ID>',\n          'state l 6 <State>',\n          'cttyfn l 8 <  TTY>',\n          'usertmd r 7 <   Time>',\n          'pscmd l 1024 <Command>'\n   first=1\n   selrow=1\n   sellev=1\n   do forever\n      call syscallm 'getpsent ps.'\n      if retval=-1 then return\n      \"TBCREATE PSTAB NAMES(S,PID,STATE,PSCMD,LOCATE,\" ||,\n           \"PSPATH,CTTY,CTTYFN,STARTTM,USERTM,USERTMD,SYSTM,PPID,\" ||,\n           \"EUID,RUID,SUID,EGID,RGID,SGID,SID,PGPID,FGPID,SIZE,\" ||,\n           \"SRVTYPE,SRVNAME,MAXPIDS,PIDCNT,MAXVN,VNCNT,SRVFLAGS\" ||,\n                          \") NOWRITE REPLACE\"\n      \"TBSORT PSTAB FIELDS(RUID,N,A,PID,N,A)\"\n      s=''\n      do i=1 to ps.0\n         pid=ps.i.ps_pid\n         locate=pid\n         state=ps.i.ps_state\n         select\n           when state=ps_run then state='RUN'\n           when state=ps_waito then state='K-WAIT'\n           when state=ps_child then state='CHILD'\n           when state=ps_zombie then state='ZOMBIE'\n           when state=ps_fork then state='FORK'\n           when state=ps_sleep then state='SLEEP'\n           when state=ps_waitc then state='C-WAIT'\n           when state=ps_waitf then state='F-WAIT'\n           when state=ps_msgrcv then state='MSGRCV'\n           when state=ps_msgsnd then state='MSGSND'\n           when state=ps_semwt then state='SEM-WT'\n           when state=ps_freeze then state='FREEZE'\n           when state=ps_quiesce then state='QUIESCE'\n           when state=ps_zombie2 then state='ZOMBIE2'\n           when state=ps_pause then state='PAUSE'\n           otherwise\n         end\n         pscmd=ps.i.ps_cmd\n         pspath    = ps.i.ps_path\n         ctty      = ps.i.ps_contty\n         parse value reverse(ctty) with cttyfn '/'\n         cttyfn=reverse(cttyfn)\n         starttm   = ltime(ps.i.ps_starttime)\n         usertm    = ps.i.ps_usertime/100\n         if length(usertm)>7 then\n            usertmd='*******'\n          else\n            usertmd=usertm\n         systm     = ps.i.ps_systime/100\n         ppid      = ps.i.ps_ppid\n         euid      = ps.i.ps_euid\n         ruid      = ps.i.ps_ruid\n         suid      = ps.i.ps_suid\n         egid      = ps.i.ps_egid\n         rgid      = ps.i.ps_rgid\n         sgid      = ps.i.ps_sgid\n         sid       = ps.i.ps_sid\n         pgpid     = ps.i.ps_pgpid\n         fgpid     = ps.i.ps_fgpid\n         size      = ps.i.ps_size\n         srvtype   = ps.i.ps_servertype\n         if srvtype=0 then\n            parse value '' with,\n                  srvtype srvname maxpids pidcnt maxvn vncnt srvflags\n          else\n            do\n            select\n              when srvtype=1 then srvtype='FILE'\n              when srvtype=2 then srvtype='LOCK'\n              otherwise\n              end\n            srvname   = ps.i.ps_servername\n            maxpids   = ps.i.ps_maxbrlmpids\n            pidcnt    = ps.i.ps_brlmpids\n            maxvn     = ps.i.ps_maxvnodes\n            vncnt     = ps.i.ps_vnodecount\n            srvflags  = c2x(ps.i.ps_serverflags)\n            end\n         \"TBADD PSTAB ORDER\"\n      end\n      alcurcmd=1        /* @0AA keep csr on cmd line */\n      x=actionlist('PSTAB',first,selrow,pan.p_ps,pstabf)\n      if x=0 & zverb<>'' then\n         leave\n      first=selrow.sel_top\n      selrow=selrow.sellev.x\n      \"TBTOP PSTAB\"\n      do forever\n         \"TBSKIP PSTAB\"\n         if rc<>0 then leave\n         if s='' | s='_' then iterate\n         s=translate(s)\n         select\n            when s='A' then\n               do\n               \"ADDPOP\"\n               do forever\n                  \"DISPLAY PANEL(\"pan.p_psatt\")\"\n                  if rc<>0 then leave\n               end\n               \"REMPOP\"\n               end\n            when s='S' then\n               do\n               signum=''\n               \"ADDPOP\"\n               do forever\n                  \"DISPLAY PANEL(\"pan.p_pssig\")\"\n                  if rc<>0 | datatype(signum,'W')=0 then\n                     leave\n                  if signum=99 then     /* 7@DGA*/\n                     do\n                     sigdata='00000800'x\n                     signbr=9\n                     end\n                   else\n                     do\n                     sigdata='00000000'x\n                     signbr=signum\n                     end\n                  call syscallm 'kill (pid)' signbr 'sigdata'   /*@DGC*/\n                  if retval=0 then leave\n               end\n               \"REMPOP\"\n               end\n            when s='K' then\n               call syscallm 'kill (pid)' sigkill\n            otherwise\n               /* ignore */\n         end\n      end\n   end\n   \"TBEND PSTAB\"\n   return\n\n/**********************************************************************/\n/* rdelete: delete a directory and everything below it            @D2A*/\n/**********************************************************************/\nrdelete: procedure expose enotempty msg. pan. rdelopt rdeldone\n   inrdel=1\n   noconf=''\n   parse arg path\n   /* rdelopt = N,no confirm, A,all, D,non-empty dirs */\n   if rdelopt<>'N' then\n      do\n      address ispexec\n      do forever\n         \"ADDPOP\"\n         cmd=''                       /* delete pndg msg */\n         'SETMSG MSG('msg.m_gentxt')'\n         zcmd=''\n         \"DISPLAY PANEL(\"pan.p_rdel\")\"\n         src=rc\n         \"REMPOP\"\n         if src<>0 then\n            do\n            \"VGET (ZVERB)\"\n            if ZVERB='CANCEL' then\n               do\n               rdeldone=1\n               return\n               end\n            rdeldone=2\n            return\n            end\n         if zcmd='' then leave\n         if translate(zcmd)='SHOWOBJ' then\n            call showobj\n      end\n      end\n   address syscall\n   d.0=0\n   'readdir (path) d.'\n   do i=1 to d.0\n      dpath=path'/'d.i\n      if d.i<>'.' & d.i<>'..' then\n         do\n         if rdelopt='A' then\n            do forever\n               address ispexec\n               \"ADDPOP\"\n               svpath=path\n               path=dpath\n               \"DISPLAY PANEL(\"pan.p_confd\")\"\n               src=rc\n               path=svpath\n               \"REMPOP\"\n               if src<>0 then\n                  do\n                  \"VGET (ZVERB)\"\n                  if ZVERB='CANCEL' then\n                     do\n                     rdeldone=1\n                     return\n                     end\n                  rdeldone=2\n                  return\n                  end\n               if noconf='/' then\n                  rdelopt='D'\n               if zcmd='' then leave\n               if translate(zcmd)='SHOWOBJ' then\n                  do\n                  path=dpath\n                  call showobj\n                  path=svpath\n                  end\n            end\n         address syscall\n         'unlink (dpath)'\n         if retval=-1 then\n            do\n            'rmdir (dpath)'\n            if retval=-1 & errno=enotempty then\n               do\n               call rdelete dpath\n               if rdeldone>1 then return\n               end\n            end\n         end\n   end\n   'rmdir (path)'\n   return\n\n/**********************************************************************/\n/* runopts: add default runopts to environment before spawn       @DxA*/\n/**********************************************************************/\nrunopts:\n   arg optenv\n   numeric digits 12\n   cvt=c2x(storage(10,4))\n   ecvt=c2x(storage(d2x(x2d(cvt)+140),4))\n   ocvt=c2x(storage(d2x(x2d(ecvt)+240),4))\n   if ocvt=0 then return\n   oext=c2x(storage(d2x(x2d(ocvt)+12),4))\n   if oext=0 then return\n   optstr=c2x(storage(d2x(x2d(oext)+36),4))\n   if optstr=0 then return\n   optlen=c2d(storage(d2x(x2d(oext)+40),4))\n   if optlen<2 then return\n   opti=value(optenv'0')\n   opti=opti+1\n   call value optenv||opti,'_CEE_RUNOPTS='storage(optstr,optlen-1)\n   call value optenv'0',opti\n   return\n\n/**********************************************************************/\n/* getjr:  get message text for an errnojr                            */\n/**********************************************************************/\ngetjr: procedure expose ejrcomp msg.\n   arg jr\n   jr=right(jr,8,'0')\n   id=x2d(substr(jr,5,4))\n   if id>999 then\n      return jr\n   comp=x2d(substr(jr,1,2))\n   mod=x2d(substr(jr,3,2))\n   \"GETMSG MSG(\"ejrcomp || right(comp,3,'0')\") LONGMSG(PREF)\"\n   if rc>8 then\n      return jr\n   \"GETMSG MSG(\"pref || right(id,3,'0')\") LONGMSG(TXT)\"\n   if rc>8 then\n      return jr\n   return jr txt\n\n/**********************************************************************/\n/* geterr: get message text for an errno                              */\n/*                                                                    */\n/* The errno is converted to decimal and right justified to three     */\n/* characters to create a message ID when concatenated with enopref.  */\n/* A message such as BPXW129 will be created and GETMSG is used to    */\n/* retrieve the message text. Message text is only available for      */\n/* IDs with less than four digits.                                    */\n/**********************************************************************/\ngeterr: procedure expose enopref msg.\n   arg eno\n   enod=x2d(eno)                           /* Convert to decimal @PMC*/\n   id= right(enod,3,'0')                /* make decimal 3 digits @PMC*/\n   msg=enopref || id                                           /*@PMC*/\n   \"GETMSG MSG(\"msg\") LONGMSG(TXT)\"\n   /* If GETMSG succeeded and enod is less than 4 digits */\n   if rc<12 & enod<1000 then                                   /*@PMC*/\n      txt=eno'x' txt\n    else\n      do\n      \"GETMSG MSG(\"msg.m_scerr2\") LONGMSG(TXT)\"\n      if rc<12 then\n         txt=eno'x' txt\n       else\n         txt=eno'x  '\n      end\n   return txt\n\n/**********************************************************************/\n/* syscallm:  issue syscall and put up a message on error             */\n/**********************************************************************/\nsyscallm:\n   parse arg cmd\n   address syscall cmd\n   if rc<0 then\n      signal retry\n   if retval\u00ac=-1 then\n      return\n   rsn=getjr(errnojr)\n   eno=geterr(errno)\n   \"SETMSG MSG(\"msg.m_scerr\")\" msgloc\n   return\n\n/**********************************************************************/\n/* syscalle:  like syscallm but a parm specifies an ok error          */\n/**********************************************************************/\nsyscalle:\n   parse arg err cmd\n   address syscall cmd\n   if rc<0 then\n      signal retry\n   if retval\u00ac=-1 then\n      return\n   if errno=err then\n      return\n   rsn=getjr(errnojr)\n   eno=geterr(errno)\n   \"SETMSG MSG(\"msg.m_scerr\")\" msgloc\n   return\n\n/**********************************************************************/\n/* signal functions                                                   */\n/**********************************************************************/\nsigsetempty: return copies(0,64)\nsigfillset: return copies(1,64)\nsigaddset: return overlay(1,arg(1),arg(2))\nsigismember return substr(arg(1),arg(2),1)\n\n/**********************************************************************/\n/* error exits                                                        */\n/**********************************************************************/\nretry:\nsay 'Invalid syscall command syntax'\nsay 'address syscall' cmd\nif datatype(ltime.0,'W')=1 then\n   do\n   address syscall\n   'close' ltime.0\n   'close' ltime.1\n   end\ntrace ?r\nnop\nexit\n\nsyntax:\nsay 'Internal error encountered'\nsay sigl sourceline(sigl)\nsay errortext(rc)\nif datatype(ltime.0,'W')=1 then\n   do\n   address syscall\n   'close' ltime.0\n   'close' ltime.1\n   end\ntrace ?r\nnop\nexit\n\n/**********************************************************************/\n/* LIBDEFs                                                            */\n/**********************************************************************/\nlibdefs:\n   \"CONTROL ERRORS RETURN\"\n   \"CONTROL NONDISPL END\"              /* next panel not displayed    */\n   \"GETMSG MSG(\"lit\"000) LONGMSG(L#MT0)\"  /* detect msg lib       @DQA*/\n   rcm=rc\n/*********************************************************************/\n/********************* BEGIN CUCI MODIFICATIONS **********************/\n/*********************************************************************/\n   usrlibdf = 'YES'               /* CUCI change to bypass uid reset  */\n                                  /* on PANEL display where CONTROL   */\n                                  /* NONDISPL END is specified        */\n                                  /* instead of user issuing END      */\n/*********************************************************************/\n/********************** END CUCI MODIFICATIONS ***********************/\n/*********************************************************************/\n   \"DISPLAY PANEL(\"pan.p_main\")\"       /* detect panel and table libs */\n   rcp=rc\n/*********************************************************************/\n/********************* BEGIN CUCI MODIFICATIONS **********************/\n/*********************************************************************/\n   usrlibdf = 'NO'                /* CUCI change to allow uid reset   */\n                                  /* for user-entered 'END' cmd       */\n/*********************************************************************/\n/********************** END CUCI MODIFICATIONS ***********************/\n/*********************************************************************/\n   if rcm<12 & rcp<12 then\n      return\n   \"LIBDEF ISPPLIB DATASET ID('SYS1.SBPXPENU')\"\n   \"LIBDEF ISPMLIB DATASET ID('SYS1.SBPXMENU')\"\n   \"LIBDEF ISPTLIB DATASET ID('SYS1.SBPXTENU')\"\n   \"CONTROL ERRORS\"\n   if rcp >= 12 then      /* only if prev. main panel disp failed @DQA*/\n      \"DISPLAY PANEL(\"pan.p_main\")\"\n   \"CONTROL ERRORS RETURN\"\n   return\n\n/**********************************************************************/\n/* editacl                                                            */\n/**********************************************************************/\neditacl:\n   parse arg aclcmd,aclpath\n   if aclcmd='acl' then\n      do\n      call listacl acl_type_access,\"Access\"\n      end\n   else\n   if aclcmd='dir' then\n      do\n      call listacl acl_type_dirdefault,\"Directory Default\"\n      end\n   else\n   if aclcmd='file' then\n      do\n      call listacl acl_type_filedefault,\"File Default\"\n      end\n   return\n\nlistacl:\n   parse arg typeofacl,acllabel\n   address ispexec\n   call makeacltable\n   call syscallm 'aclinit acltok'\n   call getacl typeofacl,aclpath\n   zcmd=''\n   aclmod=0\n   do forever\n      \"TBTOP ACL\"\n      aclopt=''\n      d=''\n      \"TBDISPL ACL PANEL(\"pan.p_acltab\")\"\n      if rc>4 then\n         do\n         'VGET (ZVERB)'\n         if ZVERB='CANCEL' & aclmod<>0 then\n            do\n            \"ADDPOP\"\n            'DISPLAY PANEL('pan.p_aclconf')'\n            crc=rc\n            \"REMPOP\"\n            if crc=0 then\n               aclmod=0\n             else\n               iterate\n            end\n         leave\n         end\n      do i=ztdsels by -1 to 1\n         if d='D' then\n            do\n            acl.acl_id=aclid\n            if acltp='User' then\n               acl.acl_entry_type=acl_entry_user\n             else\n               acl.acl_entry_type=acl_entry_group\n            address syscall 'acldeleteentry acltok acl.'\n            'TBDELETE ACL'\n            aclmod=1\n            end\n          else\n            do\n            d=''\n            newid=strip(aclid)\n            newname=strip(aclname)\n            call makeaclperm\n            call updateacl\n            'TBPUT ACL'\n            aclmod=1\n            end\n         if i>1 then\n            'TBDISPL ACL'\n      end\n      if zcmd<>'' then\n         do\n         parse upper var zcmd zcmd1 zcmd2\n         if zcmd1='SORT' & zcmd2='ID' then\n            \"TBSORT ACL FIELDS(ACLTP,C,A,ACLID,N,A)\"\n         else\n         if zcmd1='SORT' & zcmd2='NAME' then\n            \"TBSORT ACL FIELDS(ACLTP,C,A,ACLNAME,C,A)\"\n         else\n         if zcmd1='SHOWOBJ' & zcmd2='' then\n            call showobj\n         else\n         if zcmd1='SAVE' & zcmd2='' then\n            do\n            call syscallm 'aclset acltok (aclpath)' typeofacl\n            \"TBEND ACL\"\n            call makeacltable\n            call getacl typeofacl,aclpath\n            aclmod=0\n            aclopt=0\n            end\n         else\n         if zcmd1='D' & zcmd2='*' then\n            do\n            \"TBTOP ACL\"\n            do forever\n               \"TBSKIP ACL\"\n               if rc<>0 then leave\n               \"TBDELETE ACL\"\n               call updateacl 1\n               aclmod=1\n            end\n            end\n         else\n            \"SETMSG MSG(\"msg.m_invcmd\")\" msgloc\n         zcmd=''\n         end\n      'ADDPOP'\n      parse value '' with pr pw px d\n      aclname=''\n      select\n        when aclopt=2 then\n         do\n         acltp='User'\n         'DISPLAY PANEL('pan.p_aclnew')'\n         if rc=0 then\n            do\n            call makeaclperm\n            pw.=''\n            if datatype(aclname,'W') then\n               address syscall 'getpwuid' aclname 'pw.'\n             else\n               address syscall 'getpwnam' aclname 'pw.'\n            aclname=strip(pw.pw_name)\n            aclid=pw.pw_uid\n            if aclname<>'' then\n               do\n               \"TBADD ACL ORDER\"\n               if rc=8 then\n                  do\n                  'SETMSG MSG('msg.m_dupid')' msgloc\n                  end\n                else\n                  do\n                  call updateacl\n                  aclmod=1\n                  end\n               end\n             else\n               do\n               'SETMSG MSG('msg.m_badid')' msgloc\n               end\n            end\n         end\n        when aclopt=1 then\n         do\n         acltp='Group'\n         'DISPLAY PANEL('pan.p_aclnew')'\n         if rc=0 then\n            do\n            call makeaclperm\n            gr.=''\n            if datatype(aclname,'W') then\n               address syscall 'getgrgid' aclname 'gr.'\n             else\n               address syscall 'getgrnam' aclname 'gr.'\n            aclname=strip(gr.gr_name)\n            aclid=gr.gr_gid\n            if aclname<>'' then\n               do\n               \"TBADD ACL ORDER\"\n               if rc=8 then\n                  do\n                  'SETMSG MSG('msg.m_dupid')' msgloc\n                  end\n                else\n                  do\n                  call updateacl\n                  aclmod=1\n                  end\n               end\n             else\n               do\n               'SETMSG MSG('msg.m_badid')' msgloc\n               end\n            end\n         end\n\n        when aclopt=3 then\n         do\n         vtext='Add ACL entries from the ACL from path:'\n         'DISPLAY PANEL('pan.p_getpath')'\n         if rc=0 then\n            do\n            cpaclpath=makepath()\n            cpacltp=selectacl()\n            if cpacltp<>'' then\n               do\n               svtok=acltok\n               drop acltok\n               call syscallm 'aclinit acltok'\n               call getacl cpacltp,cpaclpath,svtok\n               call syscallm 'aclfree acltok'\n               acltok=svtok\n               drop svtok\n               aclmod=1\n               end\n            end\n         end\n\n        when aclopt=4 then\n         do\n         vtext='Replace this ACL with the ACL from path:'\n         'DISPLAY PANEL('pan.p_getpath')'\n         if rc=0 then\n            do\n            cpaclpath=makepath()\n            cpacltp=selectacl()\n            if cpacltp<>'' then\n               do\n               \"TBEND ACL\"\n               call makeacltable\n               call getacl cpacltp,cpaclpath\n               aclmod=1\n               end\n            end\n         end\n        otherwise\n         nop\n      end\n      'REMPOP'\n   end\n   \"TBEND ACL\"\n   if aclmod then\n      call syscallm 'aclset acltok (aclpath)' typeofacl\n   call syscallm 'aclfree acltok'\n   return\n\nselectacl:\n   call syscallm 'stat (cpaclpath) aclst.'\n   if retval=-1 then\n      return ''\n   ac=aclst.st_accessacl + aclst.st_fmodelacl + aclst.st_dmodelacl\n   if ac=0 then\n      do\n      'SETMSG MSG('msg.m_noacl')' msgloc\n      return ''\n      end\n   aaclch=aclst.st_accessacl\n   faclch=aclst.st_fmodelacl\n   daclch=aclst.st_dmodelacl\n   if ac=1 then\n      do\n      if aaclch then return 1\n      if faclch then return 2\n      if daclch then return 3\n      return ''\n      end\n   'ADDPOP'\n   'DISPLAY PANEL('pan.p_acltype')'\n   arc=rc\n   'REMPOP'\n   if arc>0 then\n      return ''\n   return saclch\n\nmakeacltable:\n   \"TBCREATE ACL NOWRITE REPLACE\",\n            \"KEYS(ACLTP,ACLID)\",\n            \"NAMES(PR,PW,PX,D,ACLTP1,ACLID1,ACLNAME)\"\n   \"TBSORT ACL FIELDS(ACLTP,C,A,ACLNAME,C,A)\"\n   return\n\ngetacl:\n   parse arg getacltype,getaclpath,cpacltok\n   d='_'\n   call syscalle enoent 'aclget acltok (getaclpath) (getacltype)'\n   if retval=-1 then return\n   do i=1 by 1\n      call syscalle enoent 'aclgetentry acltok acl.' i\n      if retval=-1 then\n         leave\n      if acl.acl_delete=1 then\n         iterate\n      parse value '' with pr pw px\n      if acl.acl_read=1 then\n         pr='R'\n      if acl.acl_write=1 then\n         pw='W'\n      if acl.acl_execute=1 then\n         px='X'\n      aclid=acl.acl_id\n      if acl.acl_entry_type=acl_entry_user then\n         do\n         acltp='User'\n         pw.=''\n         address syscall 'getpwuid' aclid 'pw.'\n         aclname=strip(pw.pw_name)\n         if aclname='' then iterate\n         end\n      else\n      if acl.acl_entry_type=acl_entry_group then\n         do\n         acltp='Group'\n         gr.=''\n         address syscall 'getgrgid' aclid 'gr.'\n         aclname=strip(gr.gr_name)\n         if aclname='' then iterate\n         end\n      else\n         iterate\n      \"TBADD ACL ORDER\"\n      if rc<8 & cpacltok<>'' then\n         address syscall 'aclupdateentry cpacltok acl.'\n   end\n   return\n\nmakeaclperm:\n   if pr<>'' then pr='R'\n   if pw<>'' then pw='W'\n   if px<>'' then px='X'\n   return\n\nupdateacl:\n   parse arg delacl\n   acl.=''\n   acl.acl_id=aclid\n   if acltp='User' then\n      acl.acl_entry_type=acl_entry_user\n    else\n      acl.acl_entry_type=acl_entry_group\n   if pr='R' then\n      acl.acl_read=1\n   if pw='W' then\n      acl.acl_write=1\n   if px='X' then\n      acl.acl_execute=1\n   acl.acl_delete=delacl\n   address syscall 'aclupdateentry acltok acl.'\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXWP99": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x185\\x8f\\x01 \\x19O\\x11\\x00\\x01\\x11\\x01\\n\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-24T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 273, "newlines": 266, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISPCMDS": {"ttr": 3589, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x01 R\\x01\\x172\\x0f\\x01\\x172\\x0f\\x00P\\x00j\\x00j\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9\\x00\\x00\\x00\\x00j\\x00\\x00\\x00j\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.01", "flags": 32, "createdate": "2017-11-16T00:00:00", "modifydate": "2017-11-16T00:50:52", "lines": 106, "newlines": 106, "modlines": 0, "user": "IBMUSER\u0000"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISR@PRIM": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x01\\xaf\\x01\\xaf\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 431, "newlines": 431, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISREDDE2": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x02\\x8f\\x01 \\x19O\\x11\\x00\\x01y\\x00\\xca\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 377, "newlines": 202, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRPXASM": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\r6\\r6\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 3382, "newlines": 3382, "modlines": 0, "user": "TCONLEY"}, "text": "* Keyword lists for ISPF enhanced edit color\n*----------------------------------------------------------------------\n*\n* 5650-ZOS     COPYRIGHT IBM Corp. 2001, 2018\n*\n* Instructions:\n*\n*   Change the CSECT for the language keyword tables you want to\n*   alter.  To save space, You may delete CSECTs to delete entire\n*   keyword lists.\n*\n*   If you want to change the symbols which are highlighted for a\n*   language, modify CSECT ISRPXSYM.  You may specify up to 32 symbols\n*   per language.  Do not change the length of the symbol entries or\n*   delete any symbols entries.  Do not change the 1st entry.  It must\n*   be blank.\n*   Note that symbol changes are not reflected to users\n*   until the user selects 'Defaults' on that language or 'Default\n*   All Settings' from the HILITE dialog.\n*\n*   Assemble this file.\n*   You MUST use the BATCH option (parameter) of the assembler.\n*\n*   Link the object as module ISRPX.\n*   Note that the name of the load module is ISRPX, not ISRPXASM.\n*   The module should be reentrant with RMODE(ANY),AMODE(31) and must\n*   have the CSECT called ISRPX residing first in the load module.\n*   Sample Linkage Editor Control statements are shown here:\n*\n*      ORDER ISRPX\n*      ENTRY ISRPX\n*       INCLUDE OBJECT(ISRPXASM)\n*       MODE AMODE(31),RMODE(ANY)\n*      NAME ISRPX(R)\n*\n*----------------------------------------------------------------------\n*   Change History                                                    -\n*----------------------------------------------------------------------\n*\n*   $01=ZOSR113  2009/07/14 HO: Source cleanup\n*                             : Updates for Enterprise Cobol V4.1\n*                             : Updates for DTL\n*                             : Updates for Enterprise PL/I V3.8\n*   $02=ZOSR113  2010/05/07 HO: Updates for Enterprise PL/I V3.9\n*   $03=OA37363  2011/08/22 HO: Missing UNION and NOINIT\n*   $04=OA37363  2011/08/22 HO: Updates for Enterprise PL/I V4.1\n*   $05=OA44291  2014/04/29 NB: Updates for Enterprise PL/I V4.2\n*                             : V4.3,V4.4 and Enterprise Cobol V5.1\n*   $06=OA48569  2016/01/28 NB: Updates for new V2R2 JES2 Statements\n*   $07=OA50455  2016/07/21 NB: Add hilight for TRAPMSG\n*   $08=OA53510  2017/07/25 AP: Updates for NOTIFY statement\n*   $09=OA54520  2017/12/22 AP: Fix symbol list for C and IDL\n*   $0A=OA55117  2018/05/10 AP: Bring keywords up to Cobol V6.2\n*\n*\n*----------------------------------------------------------------------\n* Optional instructions:\n*   If you are going to place the modified copy of module ISRPX into\n*   LPA, you may want to perform the following additional steps.\n*   Although these steps are not required, they will result in\n*   slightly better performance when the list is used:\n*\n*    1) Follow all of the steps above to create module ISRPX.\n*    2) Place the new module in the ISPLLIB concatenation\n*       and exit and reenter ISPF.\n*    3) From an ISPF command line, type TSO ISRPLKWD.\n*       This will create an assembler source file called\n*       userid.ISRPXNEW.ASM.\n*    4) Assemble ISRPXNEW.ASM\n*    5) Re-linkedit the new object using the same control statements\n*       shown above to create a new ISRPX load module.\n*\n*----------------------------------------------------------------------\n*\n*     Language       Table (CSECT) used\n*     ------------   ---------------------\n*     PL/I           ISRPXPLI\n*     Pascal         ISRPXPSC\n*     Cobol          ISRPXCOB\n*     BookMaster     ISRPXSCR\n*     REXX           ISRPXREX\n*     Other          ISRPXGEN\n*     C language     ISRPXC\n*     JCL            ISRPXJCL\n*     DTL            ISRPXDTL\n*     IDL            ISRPXIDL\n*     PL/X-370 (*)   ISRPXPLX\n*     HTML           ISRPXHTM\n*     XML            ISRPXXML\n*     DTL Logic      ISRPXLGD  (tags with an end-tag)\n*     HTML Logic     ISRPXLGH  (tags with an end-tag)\n*     Assembler      None\n*     Default        None\n*     Panel          None\n*     Skel           None\n*     SuperC         None\n*\n*     BookMaster: ISRPXSCR\n*        The only entries in the table are BookMaster tags which have\n*        a corresponding end (:e) tag.\n*\n*     DTL logic words: ISRPXLGD\n*        These are the tags that require an end tag.\n*\n*     HTML logic words: ISRPXLGH\n*        These are the tags that require an end tag.\n*\n* (*) PL/X-370: ISRPXPLX\n*        At the time of this writing, PL/X-370 is primarily an IBM\n*        internal language which has limited external availability.\n*        You may delete the CSECT ISRPXPLX entirely if you do not\n*        use PL/X-370.\n*\n* All keywords are\n*    DC AL1(keyword length + 1)\n*    DC CLxx'keyword '  Must have a trailing blank\n*\n* All keyword lists end with\n*    DC AL1(0)\n*\n* ******************************************************************\n* ******************************************************************\n* **                                                              **\n* **  WARNING: Be sure that the length of the specified in the    **\n* **           length field AL1(xx) matches the length            **\n* **           specified for the keyword CLxx'...'.               **\n* **                                                              **\n* **           If the lengths do not match, the results are       **\n* **           unpredictable.  This problem may show up as        **\n* **           infinite loops or abends in the editor.            **\n* **                                                              **\n* ******************************************************************\n* ******************************************************************\n*\n* Keyword lists must be sorted alphabetically.\n*\n* Each list is its own CSECT so lists for languages which are not used\n* by your installation may be deleted.\n*\n* In CSECT ISRPXJCL, do not remove the word 'DLM '.  It is not\n* highlighted, but is used to process delimited inline data\n* statements.\n*\n*\n*----------------------------------------------------------------------\n*  DO NOT MODIFY BETWEEN THE DASHED LINES\n*\nISRPX    CSECT ,\nISRPX    AMODE 31\nISRPX    RMODE ANY\n         DC A(0)                  1. Reserved\n         DC A(0)                  2. Reserved\n         DC A(ISRPXPLI)           3. PLI\n         DC A(ISRPXCOB)           4. COBOL\n         DC A(ISRPXPSC)           5. PASCAL\n         DC A(ISRPXC)             6. C\n         DC A(ISRPXSCR)           7. BOOK\n         DC A(ISRPXREX)           8. REXX\n         DC A(0)                  9. Reserved\n         DC A(0)                 10. Reserved\n         DC A(ISRPXJCL)          11. JCL\n         DC A(ISRPXDTL)          12. DTL\n         DC A(ISRPXOTH)          13. OTHER\n         DC A(0)                 14. Reserved\n         DC A(ISRPXPLX)          15. PLX\n         DC A(ISRPXIDL)          16. IDL\n         DC A(0)                 17. Reserved\n         DC A(ISRPXHTM)          18. HTML\n         DC A(ISRPXXML)          19. XML\n         DC A(ISRPXLGD)          20. DTL Logic keywords\n         DC A(ISRPXLGH)          21. HTML Logic keywords\n         DC A(ISRPXSYM)          22. Symbols for all\n*\n         WXTRN ISRPXPLI\n         WXTRN ISRPXCOB\n         WXTRN ISRPXPSC\n         WXTRN ISRPXC\n         WXTRN ISRPXSCR\n         WXTRN ISRPXREX\n         WXTRN ISRPXJCL\n         WXTRN ISRPXDTL\n         WXTRN ISRPXOTH\n         WXTRN ISRPXPLX\n         WXTRN ISRPXIDL\n         WXTRN ISRPXHTM\n         WXTRN ISRPXXML\n         WXTRN ISRPXLGD\n         WXTRN ISRPXLGH\n         EXTRN ISRPXSYM\n         END   ISRPX\n*----------------------------------------------------------------------\n*\n******* Start of symbol lists *******************\nISRPXSYM CSECT ,\nISRPXSYM AMODE 31\nISRPXSYM RMODE ANY\n*\n*  isrpxsym: 32 characters per language.\n*  Do not change the length or number of entries.\n*\n*  Remember to double ampersands and quotes when\n*  they are part of the symbol list.  Otherwise\n*  the assembly will fail.\n*\n         DC   CL32'                         '   1. Unused\n         DC   CL32'+-*/=<>&&\u00ac|:,            '   2. Asm\n         DC   CL32'+-*/=<>&&\u00ac|:             '   3. Pli\n         DC   CL32'.                        '   4. Cobol\n         DC   CL32'+-*/=<>&&\u00ac|:\u00dd\u00a8           '   5. Pascal\n         DC   CL32'+-*/=<>&&\u00ac|:!;\u00a6%?#\u00dd\u00a8\\    '   6. C\n         DC   CL32'.,!?$                    '   7. Bookmaster\n         DC   CL32'+-*/=<>&&\u00ac|:%\\           '   8. Rexx\n         DC   CL32'&&                       '   9. Panel\n         DC   CL32'&&?!<|>                  '  10. Skel\n         DC   CL32'(),|<>\u00ac&&=               '  11. Jcl\n         DC   CL32'<>()=                    '  12. Dtl\n         DC   CL32'+-*/=<>&&\u00ac|:             '  13. Other\n         DC   CL32'                         '  14. Default\n         DC   CL32'+-*/=<>&&\u00ac|:             '  15. Plx\n         DC   CL32'+-*/=<>&&\u00ac|:!;\u00a6%?#\u00dd\u00a8\\    '  16. Idl\n         DC   CL32'                         '  17. Reserved\n         DC   CL32'<>()=                    '  18. Html\n         DC   CL32'<>()\u00dd\u00a8=                  '  19. Xml\n******* End of symbol lists *********************\n         END\nISRPXC   CSECT ,\nISRPXC   AMODE 31\nISRPXC   RMODE ANY\n*  ISRPXC: 58 Keywords\n*  434 bytes\n*\n         DC   AL1(08),CL08'_packed '\n         DC   AL1(05),CL05'auto '\n         DC   AL1(06),CL06'break '\n         DC   AL1(05),CL05'case '\n         DC   AL1(06),CL06'catch '\n         DC   AL1(06),CL06'cdecl '\n         DC   AL1(05),CL05'char '\n         DC   AL1(06),CL06'class '\n         DC   AL1(06),CL06'const '\n         DC   AL1(09),CL09'continue '\n         DC   AL1(08),CL08'default '\n         DC   AL1(07),CL07'delete '\n         DC   AL1(03),CL03'do '\n         DC   AL1(07),CL07'double '\n         DC   AL1(05),CL05'else '\n         DC   AL1(06),CL06'entry '\n         DC   AL1(05),CL05'enum '\n         DC   AL1(07),CL07'extern '\n         DC   AL1(04),CL04'far '\n         DC   AL1(06),CL06'float '\n         DC   AL1(04),CL04'for '\n         DC   AL1(08),CL08'fortran '\n         DC   AL1(07),CL07'friend '\n         DC   AL1(05),CL05'goto '\n         DC   AL1(05),CL05'huge '\n         DC   AL1(03),CL03'if '\n         DC   AL1(07),CL07'inline '\n         DC   AL1(04),CL04'int '\n         DC   AL1(10),CL10'interrupt '\n         DC   AL1(05),CL05'long '\n         DC   AL1(05),CL05'near '\n         DC   AL1(04),CL04'new '\n         DC   AL1(09),CL09'operator '\n         DC   AL1(07),CL07'pascal '\n         DC   AL1(08),CL08'private '\n         DC   AL1(10),CL10'protected '\n         DC   AL1(07),CL07'public '\n         DC   AL1(09),CL09'register '\n         DC   AL1(07),CL07'return '\n         DC   AL1(06),CL06'short '\n         DC   AL1(07),CL07'signed '\n         DC   AL1(08),CL08'size_of '\n         DC   AL1(07),CL07'sizeof '\n         DC   AL1(07),CL07'static '\n         DC   AL1(07),CL07'struct '\n         DC   AL1(07),CL07'switch '\n         DC   AL1(09),CL09'template '\n         DC   AL1(05),CL05'this '\n         DC   AL1(06),CL06'throw '\n         DC   AL1(04),CL04'try '\n         DC   AL1(08),CL08'typedef '\n         DC   AL1(06),CL06'union '\n         DC   AL1(09),CL09'unsigned '\n         DC   AL1(08),CL08'virtual '\n         DC   AL1(05),CL05'void '\n         DC   AL1(09),CL09'volatile '\n         DC   AL1(08),CL08'wchar_t '\n         DC   AL1(06),CL06'while '\n         DC   AL1(0)                /*                               */\n         END\nISRPXCOB CSECT ,\nISRPXCOB AMODE 31\nISRPXCOB RMODE ANY\n*  ISRPXCOB: 519 Keywords\n*  4850 bytes\n*\n         DC   AL1(04),CL04'ABS '                    * CUCI COB\n         DC   AL1(07),CL07'ACCEPT '\n         DC   AL1(07),CL07'ACCESS '\n         DC   AL1(05),CL05'ACOS '                   * CUCI COB\n         DC   AL1(13),CL13'ACTIVE-CLASS '\n         DC   AL1(04),CL04'ADD '\n         DC   AL1(08),CL08'ADDRESS '\n         DC   AL1(10),CL10'ADVANCING '\n         DC   AL1(06),CL06'AFTER '\n         DC   AL1(08),CL08'ALIGNED '\n         DC   AL1(04),CL04'ALL '\n         DC   AL1(09),CL09'ALLOCATE '\n         DC   AL1(09),CL09'ALPHABET '\n         DC   AL1(11),CL11'ALPHABETIC '\n         DC   AL1(17),CL17'ALPHABETIC-LOWER '\n         DC   AL1(17),CL17'ALPHABETIC-UPPER '\n         DC   AL1(13),CL13'ALPHANUMERIC '\n         DC   AL1(20),CL20'ALPHANUMERIC-EDITED '\n         DC   AL1(05),CL05'ALSO '\n         DC   AL1(06),CL06'ALTER '\n         DC   AL1(10),CL10'ALTERNATE '\n         DC   AL1(04),CL04'AND '\n         DC   AL1(08),CL08'ANNUITY '                * CUCI COB\n         DC   AL1(04),CL04'ANY '\n         DC   AL1(08),CL08'ANYCASE '\n         DC   AL1(06),CL06'APPLY '\n         DC   AL1(04),CL04'ARE '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(06),CL06'AREAS '\n         DC   AL1(10),CL10'ASCENDING '\n         DC   AL1(05),CL05'ASIN '                   * CUCI COB\n         DC   AL1(07),CL07'ASSIGN '\n         DC   AL1(03),CL03'AT '\n         DC   AL1(05),CL05'ATAN '                   * CUCI COB\n         DC   AL1(11),CL11'ATTRIBUTES '\n         DC   AL1(07),CL07'AUTHOR '\n         DC   AL1(06),CL06'B-AND '\n         DC   AL1(06),CL06'B-NOT '\n         DC   AL1(05),CL05'B-OR '\n         DC   AL1(06),CL06'B-XOR '\n         DC   AL1(06),CL06'BASED '\n         DC   AL1(06),CL06'BASIS '\n         DC   AL1(07),CL07'BEFORE '\n         DC   AL1(10),CL10'BEGINNING '\n         DC   AL1(07),CL07'BINARY '\n         DC   AL1(12),CL12'BINARY-CHAR '\n         DC   AL1(14),CL14'BINARY-DOUBLE '\n         DC   AL1(12),CL12'BINARY-LONG '\n         DC   AL1(13),CL13'BINARY-SHORT '\n         DC   AL1(04),CL04'BIT '\n         DC   AL1(07),CL07'BIT-OF '                 * CUCI COB\n         DC   AL1(12),CL12'BIT-TO-CHAR '            * CUCI COB\n         DC   AL1(06),CL06'BLANK '\n         DC   AL1(06),CL06'BLOCK '\n         DC   AL1(08),CL08'BOOLEAN '\n         DC   AL1(07),CL07'BOTTOM '\n         DC   AL1(03),CL03'BY '\n         DC   AL1(12),CL12'BYTE-LENGTH '            * CUCI COB\n         DC   AL1(05),CL05'CALL '\n         DC   AL1(07),CL07'CANCEL '\n         DC   AL1(04),CL04'CBL '\n         DC   AL1(03),CL03'CD '\n         DC   AL1(03),CL03'CF '\n         DC   AL1(03),CL03'CH '\n         DC   AL1(05),CL05'CHAR '                   * CUCI COB\n         DC   AL1(10),CL10'CHARACTER '\n         DC   AL1(11),CL11'CHARACTERS '\n         DC   AL1(06),CL06'CLASS '\n         DC   AL1(09),CL09'CLASS-ID '\n         DC   AL1(12),CL12'CLOCK-UNITS '\n         DC   AL1(06),CL06'CLOSE '\n         DC   AL1(06),CL06'COBOL '\n         DC   AL1(05),CL05'CODE '\n         DC   AL1(09),CL09'CODE-SET '\n         DC   AL1(04),CL04'COL '\n         DC   AL1(10),CL10'COLLATING '\n         DC   AL1(05),CL05'COLS '\n         DC   AL1(07),CL07'COLUMN '\n         DC   AL1(08),CL08'COLUMNS '\n         DC   AL1(08),CL08'COM-REG '\n         DC   AL1(06),CL06'COMMA '\n         DC   AL1(07),CL07'COMMON '\n         DC   AL1(14),CL14'COMMUNICATION '\n         DC   AL1(05),CL05'COMP '\n         DC   AL1(07),CL07'COMP-1 '\n         DC   AL1(07),CL07'COMP-2 '\n         DC   AL1(07),CL07'COMP-3 '\n         DC   AL1(07),CL07'COMP-4 '\n         DC   AL1(07),CL07'COMP-5 '\n         DC   AL1(14),CL14'COMPUTATIONAL '\n         DC   AL1(16),CL16'COMPUTATIONAL-1 '\n         DC   AL1(16),CL16'COMPUTATIONAL-2 '\n         DC   AL1(16),CL16'COMPUTATIONAL-3 '\n         DC   AL1(16),CL16'COMPUTATIONAL-4 '\n         DC   AL1(16),CL16'COMPUTATIONAL-5 '\n         DC   AL1(08),CL08'COMPUTE '\n         DC   AL1(10),CL10'CONDITION '\n         DC   AL1(14),CL14'CONFIGURATION '\n         DC   AL1(09),CL09'CONSTANT '\n         DC   AL1(09),CL09'CONTAINS '\n         DC   AL1(08),CL08'CONTENT '\n         DC   AL1(09),CL09'CONTINUE '\n         DC   AL1(08),CL08'CONTROL '\n         DC   AL1(09),CL09'CONTROLS '\n         DC   AL1(11),CL11'CONVERTING '\n         DC   AL1(05),CL05'COPY '\n         DC   AL1(05),CL05'CORR '\n         DC   AL1(14),CL14'CORRESPONDING '\n         DC   AL1(04),CL04'COS '                    * CUCI COB\n         DC   AL1(06),CL06'COUNT '\n         DC   AL1(04),CL04'CRT '\n         DC   AL1(09),CL09'CURRENCY '\n         DC   AL1(13),CL13'CURRENT-DATE '           * CUCI COB\n         DC   AL1(07),CL07'CURSOR '\n         DC   AL1(06),CL06'CYCLE '                  * CUCI COB\n         DC   AL1(05),CL05'DATA '\n         DC   AL1(13),CL13'DATA-POINTER '\n         DC   AL1(05),CL05'DATE '\n         DC   AL1(14),CL14'DATE-COMPILED '\n         DC   AL1(16),CL16'DATE-OF-INTEGER '        * CUCI COB\n         DC   AL1(17),CL17'DATE-TO-YYYYMMDD '       * CUCI COB\n         DC   AL1(13),CL13'DATE-WRITTEN '\n         DC   AL1(04),CL04'DAY '\n         DC   AL1(12),CL12'DAY-OF-WEEK '\n         DC   AL1(15),CL15'DAY-TO-YYYYDDD '         * CUCI COB\n         DC   AL1(05),CL05'DBCS '\n         DC   AL1(03),CL03'DE '\n         DC   AL1(15),CL15'DEBUG-CONTENTS '\n         DC   AL1(11),CL11'DEBUG-ITEM '\n         DC   AL1(11),CL11'DEBUG-LINE '\n         DC   AL1(11),CL11'DEBUG-NAME '\n         DC   AL1(12),CL12'DEBUG-SUB-1 '\n         DC   AL1(12),CL12'DEBUG-SUB-2 '\n         DC   AL1(12),CL12'DEBUG-SUB-3 '\n         DC   AL1(10),CL10'DEBUGGING '\n         DC   AL1(14),CL14'DECIMAL-POINT '\n         DC   AL1(13),CL13'DECLARATIVES '\n         DC   AL1(08),CL08'DEFAULT '\n         DC   AL1(07),CL07'DELETE '\n         DC   AL1(10),CL10'DELIMITED '\n         DC   AL1(10),CL10'DELIMITER '\n         DC   AL1(10),CL10'DEPENDING '\n         DC   AL1(11),CL11'DESCENDING '\n         DC   AL1(12),CL12'DESTINATION '\n         DC   AL1(07),CL07'DETAIL '\n         DC   AL1(08),CL08'DISABLE '\n         DC   AL1(08),CL08'DISPLAY '\n         DC   AL1(11),CL11'DISPLAY-OF '             * CUCI COB\n         DC   AL1(10),CL10'DISPLAY-1 '\n         DC   AL1(07),CL07'DIVIDE '\n         DC   AL1(09),CL09'DIVISION '\n         DC   AL1(05),CL05'DOWN '\n         DC   AL1(11),CL11'DUPLICATES '\n         DC   AL1(08),CL08'DYNAMIC '\n         DC   AL1(02),CL02'E '                      * CUCI COB\n         DC   AL1(07),CL07'EBCDIC '                 * CUCI COB\n         DC   AL1(03),CL03'EC '\n         DC   AL1(05),CL05'EGCS '\n         DC   AL1(04),CL04'EGI '\n         DC   AL1(06),CL06'EJECT '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(04),CL04'EMI '\n         DC   AL1(07),CL07'ENABLE '\n         DC   AL1(09),CL09'ENCODING '\n         DC   AL1(04),CL04'END '\n         DC   AL1(11),CL11'END-ACCEPT '\n         DC   AL1(08),CL08'END-ADD '\n         DC   AL1(09),CL09'END-CALL '\n         DC   AL1(12),CL12'END-COMPUTE '\n         DC   AL1(11),CL11'END-DELETE '\n         DC   AL1(12),CL12'END-DISPLAY '\n         DC   AL1(11),CL11'END-DIVIDE '\n         DC   AL1(13),CL13'END-EVALUATE '\n         DC   AL1(09),CL09'END-EXEC '\n         DC   AL1(07),CL07'END-IF '\n         DC   AL1(11),CL11'END-INVOKE '\n         DC   AL1(09),CL09'END-JSON '\n         DC   AL1(13),CL13'END-MULTIPLY '\n         DC   AL1(12),CL12'END-OF-PAGE '\n         DC   AL1(12),CL12'END-PERFORM '\n         DC   AL1(09),CL09'END-READ '\n         DC   AL1(12),CL12'END-RECEIVE '\n         DC   AL1(11),CL11'END-RETURN '\n         DC   AL1(12),CL12'END-REWRITE '\n         DC   AL1(11),CL11'END-SEARCH '\n         DC   AL1(10),CL10'END-START '\n         DC   AL1(11),CL11'END-STRING '\n         DC   AL1(13),CL13'END-SUBTRACT '\n         DC   AL1(13),CL13'END-UNSTRING '\n         DC   AL1(10),CL10'END-WRITE '\n         DC   AL1(08),CL08'END-XML '\n         DC   AL1(07),CL07'ENDING '\n         DC   AL1(06),CL06'ENTER '\n         DC   AL1(06),CL06'ENTRY '\n         DC   AL1(12),CL12'ENVIRONMENT '\n         DC   AL1(03),CL03'EO '\n         DC   AL1(04),CL04'EOP '\n         DC   AL1(06),CL06'EQUAL '\n         DC   AL1(06),CL06'ERROR '\n         DC   AL1(04),CL04'ESI '\n         DC   AL1(09),CL09'EVALUATE '\n         DC   AL1(06),CL06'EVERY '\n         DC   AL1(10),CL10'EXCEPTION '\n         DC   AL1(17),CL17'EXCEPTION-OBJECT '\n         DC   AL1(05),CL05'EXEC '\n         DC   AL1(08),CL08'EXECUTE '\n         DC   AL1(05),CL05'EXIT '\n         DC   AL1(04),CL04'EXP '                    * CUCI COB\n         DC   AL1(06),CL06'EXP10 '                  * CUCI COB\n         DC   AL1(07),CL07'EXTEND '\n         DC   AL1(09),CL09'EXTERNAL '\n         DC   AL1(10),CL10'FACTORIAL '              * CUCI COB\n         DC   AL1(08),CL08'FACTORY '\n         DC   AL1(06),CL06'FALSE '\n         DC   AL1(03),CL03'FD '\n         DC   AL1(05),CL05'FILE '\n         DC   AL1(13),CL13'FILE-CONTROL '\n         DC   AL1(07),CL07'FILLER '\n         DC   AL1(06),CL06'FINAL '\n         DC   AL1(06),CL06'FIRST '\n         DC   AL1(15),CL15'FLOAT-EXTENDED '\n         DC   AL1(11),CL11'FLOAT-LONG '\n         DC   AL1(12),CL12'FLOAT-SHORT '\n         DC   AL1(08),CL08'FOOTING '\n         DC   AL1(04),CL04'FOR '\n         DC   AL1(07),CL07'FORMAT '\n         DC   AL1(05),CL05'FREE '\n         DC   AL1(05),CL05'FROM '\n         DC   AL1(09),CL09'FUNCTION '\n         DC   AL1(12),CL12'FUNCTION-ID '\n         DC   AL1(17),CL17'FUNCTION-POINTER '\n         DC   AL1(09),CL09'GENERATE '\n         DC   AL1(04),CL04'GET '\n         DC   AL1(07),CL07'GIVING '\n         DC   AL1(07),CL07'GLOBAL '\n         DC   AL1(03),CL03'GO '\n         DC   AL1(07),CL07'GOBACK '\n         DC   AL1(08),CL08'GREATER '\n         DC   AL1(06),CL06'GROUP '\n         DC   AL1(12),CL12'GROUP-USAGE '\n         DC   AL1(08),CL08'HEADING '\n         DC   AL1(07),CL07'HEX-OF '                 * CUCI COB\n         DC   AL1(12),CL12'HEX-TO-CHAR '            * CUCI COB\n         DC   AL1(11),CL11'HIGH-VALUE '\n         DC   AL1(12),CL12'HIGH-VALUES '\n         DC   AL1(04),CL04'I-O '\n         DC   AL1(12),CL12'I-O-CONTROL '\n         DC   AL1(03),CL03'ID '\n         DC   AL1(15),CL15'IDENTIFICATION '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(03),CL03'IN '\n         DC   AL1(06),CL06'INDEX '\n         DC   AL1(08),CL08'INDEXED '\n         DC   AL1(09),CL09'INDICATE '\n         DC   AL1(09),CL09'INHERITS '\n         DC   AL1(08),CL08'INITIAL '\n         DC   AL1(11),CL11'INITIALIZE '\n         DC   AL1(09),CL09'INITIATE '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(13),CL13'INPUT-OUTPUT '\n         DC   AL1(07),CL07'INSERT '\n         DC   AL1(08),CL08'INSPECT '\n         DC   AL1(13),CL13'INSTALLATION '\n         DC   AL1(08),CL08'INTEGER '                * CUCI COB\n         DC   AL1(16),CL16'INTEGER-OF-DATE '        * CUCI COB\n         DC   AL1(15),CL15'INTEGER-OF-DAY '         * CUCI COB\n         DC   AL1(13),CL13'INTEGER-PART '           * CUCI COB\n         DC   AL1(10),CL10'INTERFACE '\n         DC   AL1(13),CL13'INTERFACE-ID '\n         DC   AL1(05),CL05'INTO '\n         DC   AL1(10),CL10'INTRINSIC '              * CUCI COB\n         DC   AL1(08),CL08'INVALID '\n         DC   AL1(07),CL07'INVOKE '\n         DC   AL1(03),CL03'IS '\n         DC   AL1(10),CL10'JNIENVPTR '\n         DC   AL1(05),CL05'JSON '\n         DC   AL1(10),CL10'JSON-CODE '\n         DC   AL1(12),CL12'JSON-STATUS '\n         DC   AL1(05),CL05'JUST '\n         DC   AL1(10),CL10'JUSTIFIED '\n         DC   AL1(06),CL06'KANJI '\n         DC   AL1(04),CL04'KEY '\n         DC   AL1(06),CL06'LABEL '\n         DC   AL1(05),CL05'LAST '\n         DC   AL1(08),CL08'LEADING '\n         DC   AL1(05),CL05'LEFT '\n         DC   AL1(07),CL07'LENGTH '\n         DC   AL1(05),CL05'LESS '\n         DC   AL1(06),CL06'LIMIT '\n         DC   AL1(07),CL07'LIMITS '\n         DC   AL1(07),CL07'LINAGE '\n         DC   AL1(15),CL15'LINAGE-COUNTER '\n         DC   AL1(05),CL05'LINE '\n         DC   AL1(13),CL13'LINE-COUNTER '\n         DC   AL1(06),CL06'LINES '\n         DC   AL1(08),CL08'LINKAGE '\n         DC   AL1(04),CL04'LOC '                    * CUCI COB\n         DC   AL1(14),CL14'LOCAL-STORAGE '\n         DC   AL1(07),CL07'LOCALE '\n         DC   AL1(05),CL05'LOCK '\n         DC   AL1(04),CL04'LOG '                    * CUCI COB\n         DC   AL1(06),CL06'LOG10 '                  * CUCI COB\n         DC   AL1(10),CL10'LOW-VALUE '\n         DC   AL1(11),CL11'LOW-VALUES '\n         DC   AL1(11),CL11'LOWER-CASE '             * CUCI COB\n         DC   AL1(04),CL04'MAX '                    * CUCI COB\n         DC   AL1(05),CL05'MEAN '                   * CUCI COB\n         DC   AL1(07),CL07'MEDIAN '                 * CUCI COB\n         DC   AL1(07),CL07'MEMORY '\n         DC   AL1(06),CL06'MERGE '\n         DC   AL1(08),CL08'MESSAGE '\n         DC   AL1(10),CL10'METACLASS '\n         DC   AL1(07),CL07'METHOD '\n         DC   AL1(10),CL10'METHOD-ID '\n         DC   AL1(09),CL09'MIDRANGE '               * CUCI COB\n         DC   AL1(04),CL04'MIN '                    * CUCI COB\n         DC   AL1(06),CL06'MINUS '\n         DC   AL1(04),CL04'MOD '                    * CUCI COB\n         DC   AL1(05),CL05'MODE '\n         DC   AL1(08),CL08'MODULES '\n         DC   AL1(12),CL12'MORE-LABELS '\n         DC   AL1(05),CL05'MOVE '\n         DC   AL1(09),CL09'MULTIPLE '\n         DC   AL1(09),CL09'MULTIPLY '\n         DC   AL1(05),CL05'NAME '\n         DC   AL1(10),CL10'NAMESPACE '\n         DC   AL1(17),CL17'NAMESPACE-PREFIX '\n         DC   AL1(09),CL09'NATIONAL '\n         DC   AL1(16),CL16'NATIONAL-EDITED '\n         DC   AL1(12),CL12'NATIONAL-OF '            * CUCI COB\n         DC   AL1(07),CL07'NATIVE '\n         DC   AL1(09),CL09'NEGATIVE '\n         DC   AL1(07),CL07'NESTED '\n         DC   AL1(05),CL05'NEXT '\n         DC   AL1(07),CL07'NUMVAL '                 * CUCI COB\n         DC   AL1(03),CL03'NO '\n         DC   AL1(04),CL04'NOT '\n         DC   AL1(05),CL05'NULL '\n         DC   AL1(06),CL06'NULLS '\n         DC   AL1(07),CL07'NUMBER '\n         DC   AL1(08),CL08'NUMERIC '\n         DC   AL1(15),CL15'NUMERIC-EDITED '\n         DC   AL1(07),CL07'NUMVAL '                 * CUCI COB\n         DC   AL1(09),CL09'NUMVAL-C'                * CUCI COB\n         DC   AL1(09),CL09'NUMVAL-F'                * CUCI COB\n         DC   AL1(07),CL07'OBJECT '\n         DC   AL1(16),CL16'OBJECT-COMPUTER '\n         DC   AL1(17),CL17'OBJECT-REFERENCE '\n         DC   AL1(07),CL07'OCCURS '\n         DC   AL1(03),CL03'OF '\n         DC   AL1(04),CL04'OFF '\n         DC   AL1(08),CL08'OMITTED '\n         DC   AL1(03),CL03'ON '\n         DC   AL1(05),CL05'OPEN '\n         DC   AL1(09),CL09'OPTIONAL '\n         DC   AL1(08),CL08'OPTIONS '\n         DC   AL1(03),CL03'OR '\n         DC   AL1(04),CL04'ORD '                    * CUCI COB\n         DC   AL1(08),CL08'ORD-MAX '                * CUCI COB\n         DC   AL1(08),CL08'ORD-MIN '                * CUCI COB\n         DC   AL1(06),CL06'ORDER '\n         DC   AL1(13),CL13'ORGANIZATION '\n         DC   AL1(06),CL06'OTHER '\n         DC   AL1(07),CL07'OUTPUT '\n         DC   AL1(09),CL09'OVERFLOW '\n         DC   AL1(09),CL09'OVERRIDE '\n         DC   AL1(15),CL15'PACKED-DECIMAL '\n         DC   AL1(08),CL08'PADDING '\n         DC   AL1(05),CL05'PAGE '\n         DC   AL1(13),CL13'PAGE-COUNTER '\n         DC   AL1(10),CL10'PARAGRAPH '              * CUCI COB\n         DC   AL1(06),CL06'PARSE '\n         DC   AL1(09),CL09'PASSWORD '\n         DC   AL1(08),CL08'PERFORM '\n         DC   AL1(03),CL03'PF '\n         DC   AL1(03),CL03'PH '\n         DC   AL1(03),CL03'PI '                     * CUCI COB\n         DC   AL1(04),CL04'PIC '\n         DC   AL1(08),CL08'PICTURE '\n         DC   AL1(05),CL05'PLUS '\n         DC   AL1(08),CL08'POINTER '\n         DC   AL1(11),CL11'POINTER-32 '             * CUCI COB\n         DC   AL1(09),CL09'POSITION '\n         DC   AL1(09),CL09'POSITIVE '\n         DC   AL1(08),CL08'PRESENT '\n         DC   AL1(14),CL14'PRESENT-VALUE '          * CUCI COB\n         DC   AL1(09),CL09'PRINTING '\n         DC   AL1(10),CL10'PROCEDURE '\n         DC   AL1(18),CL18'PROCEDURE-POINTER '\n         DC   AL1(11),CL11'PROCEDURES '\n         DC   AL1(08),CL08'PROCEED '\n         DC   AL1(11),CL11'PROCESSING '\n         DC   AL1(08),CL08'PROGRAM '\n         DC   AL1(11),CL11'PROGRAM-ID '\n         DC   AL1(16),CL16'PROGRAM-POINTER '\n         DC   AL1(09),CL09'PROPERTY '\n         DC   AL1(10),CL10'PROTOTYPE '\n         DC   AL1(06),CL06'PURGE '\n         DC   AL1(06),CL06'QUEUE '\n         DC   AL1(06),CL06'QUOTE '\n         DC   AL1(07),CL07'QUOTES '\n         DC   AL1(06),CL06'RAISE '\n         DC   AL1(08),CL08'RAISING '\n         DC   AL1(07),CL07'RANDOM '\n         DC   AL1(06),CL06'RANGE '                  * CUCI COB\n         DC   AL1(03),CL03'RD '\n         DC   AL1(05),CL05'READ '\n         DC   AL1(06),CL06'READY '\n         DC   AL1(08),CL08'RECEIVE '\n         DC   AL1(07),CL07'RECORD '\n         DC   AL1(10),CL10'RECORDING '\n         DC   AL1(08),CL08'RECORDS '\n         DC   AL1(10),CL10'RECURSIVE '\n         DC   AL1(10),CL10'REDEFINES '\n         DC   AL1(05),CL05'REEL '\n         DC   AL1(10),CL10'REFERENCE '\n         DC   AL1(11),CL11'REFERENCES '\n         DC   AL1(09),CL09'RELATIVE '\n         DC   AL1(08),CL08'RELEASE '\n         DC   AL1(07),CL07'RELOAD '\n         DC   AL1(04),CL04'REM '                    * CUCI COB\n         DC   AL1(10),CL10'REMAINDER '\n         DC   AL1(08),CL08'REMOVAL '\n         DC   AL1(08),CL08'RENAMES '\n         DC   AL1(08),CL08'REPLACE '\n         DC   AL1(10),CL10'REPLACING '\n         DC   AL1(07),CL07'REPORT '\n         DC   AL1(10),CL10'REPORTING '\n         DC   AL1(08),CL08'REPORTS '\n         DC   AL1(11),CL11'REPOSITORY '\n         DC   AL1(06),CL06'RERUN '\n         DC   AL1(08),CL08'RESERVE '\n         DC   AL1(06),CL06'RESET '\n         DC   AL1(07),CL07'RESUME '\n         DC   AL1(06),CL06'RETRY '\n         DC   AL1(07),CL07'RETURN '\n         DC   AL1(12),CL12'RETURN-CODE '\n         DC   AL1(10),CL10'RETURNING '\n         DC   AL1(08),CL08'REVERSE '                * CUCI COB\n         DC   AL1(09),CL09'REVERSED '\n         DC   AL1(07),CL07'REWIND '\n         DC   AL1(08),CL08'REWRITE '\n         DC   AL1(03),CL03'RF '\n         DC   AL1(03),CL03'RH '\n         DC   AL1(06),CL06'RIGHT '\n         DC   AL1(08),CL08'ROUNDED '\n         DC   AL1(04),CL04'RUN '\n         DC   AL1(05),CL05'SAME '\n         DC   AL1(07),CL07'SCREEN '\n         DC   AL1(03),CL03'SD '\n         DC   AL1(07),CL07'SEARCH '\n         DC   AL1(08),CL08'SECTION '\n         DC   AL1(09),CL09'SECURITY '\n         DC   AL1(08),CL08'SEGMENT '\n         DC   AL1(14),CL14'SEGMENT-LIMIT '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(05),CL05'SELF '\n         DC   AL1(05),CL05'SEND '\n         DC   AL1(09),CL09'SENTENCE '\n         DC   AL1(09),CL09'SEPARATE '\n         DC   AL1(09),CL09'SEQUENCE '\n         DC   AL1(11),CL11'SEQUENTIAL '\n         DC   AL1(08),CL08'SERVICE '\n         DC   AL1(04),CL04'SET '\n         DC   AL1(08),CL08'SHARING '\n         DC   AL1(09),CL09'SHIFT-IN '\n         DC   AL1(10),CL10'SHIFT-OUT '\n         DC   AL1(05),CL05'SIGN '\n         DC   AL1(04),CL04'SIN '                    * CUCI COB\n         DC   AL1(05),CL05'SIZE '\n         DC   AL1(06),CL06'SKIP1 '\n         DC   AL1(06),CL06'SKIP2 '\n         DC   AL1(06),CL06'SKIP3 '\n         DC   AL1(05),CL05'SORT '\n         DC   AL1(13),CL13'SORT-CONTROL '\n         DC   AL1(15),CL15'SORT-CORE-SIZE '\n         DC   AL1(15),CL15'SORT-FILE-SIZE '\n         DC   AL1(11),CL11'SORT-MERGE '\n         DC   AL1(13),CL13'SORT-MESSAGE '\n         DC   AL1(15),CL15'SORT-MODE-SIZE '\n         DC   AL1(12),CL12'SORT-RETURN '\n         DC   AL1(07),CL07'SOURCE '\n         DC   AL1(16),CL16'SOURCE-COMPUTER '\n         DC   AL1(08),CL08'SOURCES '\n         DC   AL1(06),CL06'SPACE '\n         DC   AL1(07),CL07'SPACES '\n         DC   AL1(14),CL14'SPECIAL-NAMES '\n         DC   AL1(04),CL04'SQL '\n         DC   AL1(07),CL07'SQLIMS '\n         DC   AL1(05),CL05'SQRT '                   * CUCI COB\n         DC   AL1(09),CL09'STANDARD '\n         DC   AL1(19),CL19'STANDARD-DEVIATION '     * CUCI COB\n         DC   AL1(11),CL11'STANDARD-1 '\n         DC   AL1(11),CL11'STANDARD-2 '\n         DC   AL1(06),CL06'START '\n         DC   AL1(07),CL07'STATUS '\n         DC   AL1(05),CL05'STOP '\n         DC   AL1(07),CL07'STRING '\n         DC   AL1(12),CL12'SUB-QUEUE-1 '\n         DC   AL1(12),CL12'SUB-QUEUE-2 '\n         DC   AL1(12),CL12'SUB-QUEUE-3 '\n         DC   AL1(09),CL09'SUBTRACT '\n         DC   AL1(04),CL04'SUM '\n         DC   AL1(06),CL06'SUPER '\n         DC   AL1(09),CL09'SUPPRESS '\n         DC   AL1(09),CL09'SYMBOLIC '\n         DC   AL1(05),CL05'SYNC '\n         DC   AL1(13),CL13'SYNCHRONIZED '\n         DC   AL1(15),CL15'SYSTEM-DEFAULT '\n         DC   AL1(06),CL06'TABLE '\n         DC   AL1(06),CL06'TALLY '\n         DC   AL1(09),CL09'TALLYING '\n         DC   AL1(04),CL04'TAN '                    * CUCI COB\n         DC   AL1(05),CL05'TAPE '\n         DC   AL1(09),CL09'TERMINAL '\n         DC   AL1(10),CL10'TERMINATE '\n         DC   AL1(05),CL05'TEST '\n         DC   AL1(12),CL12'TEST-NUMVAL '            * CUCI COB\n         DC   AL1(14),CL14'TEST-NUMVAL-C '          * CUCI COB\n         DC   AL1(14),CL14'TEST-NUMVAL-F '          * CUCI COB\n         DC   AL1(05),CL05'TEXT '\n         DC   AL1(05),CL05'THAN '\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(08),CL08'THROUGH '\n         DC   AL1(05),CL05'THRU '\n         DC   AL1(05),CL05'TIME '\n         DC   AL1(06),CL06'TIMES '\n         DC   AL1(06),CL06'TITLE '\n         DC   AL1(03),CL03'TO '\n         DC   AL1(04),CL04'TOP '\n         DC   AL1(06),CL06'TRACE '\n         DC   AL1(09),CL09'TRAILING '\n         DC   AL1(05),CL05'TRIM '                   * CUCI COB\n         DC   AL1(05),CL05'TRUE '\n         DC   AL1(05),CL05'TYPE '\n         DC   AL1(08),CL08'TYPEDEF '\n         DC   AL1(08),CL08'ULENGTH '                * CUCI COB\n         DC   AL1(10),CL10'UNBOUNDED '              * CUCI COB\n         DC   AL1(05),CL05'UNIT '\n         DC   AL1(10),CL10'UNIVERSAL '\n         DC   AL1(07),CL07'UNLOCK '\n         DC   AL1(09),CL09'UNSTRING '\n         DC   AL1(06),CL06'UNTIL '\n         DC   AL1(03),CL03'UP '\n         DC   AL1(05),CL05'UPON '\n         DC   AL1(05),CL05'UPOS '                   * CUCI COB\n         DC   AL1(11),CL11'UPPER-CASE '             * CUCI COB\n         DC   AL1(06),CL06'USAGE '\n         DC   AL1(04),CL04'USE '\n         DC   AL1(13),CL13'USER-DEFAULT '\n         DC   AL1(06),CL06'USING '\n         DC   AL1(08),CL08'USUBSTR '                * CUCI COB\n         DC   AL1(15),CL15'USUPPLEMENTARY '         * CUCI COB\n         DC   AL1(06),CL06'UTF-8 '                  * CUCI COB\n         DC   AL1(06),CL06'UUID4 '                  * CUCI COB\n         DC   AL1(07),CL07'UVALID '                 * CUCI COB\n         DC   AL1(07),CL07'UWIDTH '                 * CUCI COB\n         DC   AL1(11),CL11'VAL-STATUS '\n         DC   AL1(06),CL06'VALID '\n         DC   AL1(09),CL09'VALIDATE '\n         DC   AL1(16),CL16'VALIDATE-STATUS '\n         DC   AL1(11),CL11'VALIDATING '\n         DC   AL1(06),CL06'VALUE '\n         DC   AL1(07),CL07'VALUES '\n         DC   AL1(09),CL09'VARIANCE '               * CUCI COB\n         DC   AL1(08),CL08'VARYING '\n         DC   AL1(09),CL09'VOLATILE '\n         DC   AL1(05),CL05'WHEN '\n         DC   AL1(14),CL14'WHEN-COMPILED '\n         DC   AL1(05),CL05'WITH '\n         DC   AL1(06),CL06'WORDS '\n         DC   AL1(16),CL16'WORKING-STORAGE '\n         DC   AL1(06),CL06'WRITE '\n         DC   AL1(11),CL11'WRITE-ONLY '\n         DC   AL1(04),CL04'XML '\n         DC   AL1(09),CL09'XML-CODE '\n         DC   AL1(16),CL16'XML-DECLARATION '\n         DC   AL1(10),CL10'XML-EVENT '\n         DC   AL1(16),CL16'XML-INFORMATION '\n         DC   AL1(14),CL14'XML-NAMESPACE '\n         DC   AL1(21),CL21'XML-NAMESPACE-PREFIX '\n         DC   AL1(15),CL15'XML-NNAMESPACE '\n         DC   AL1(22),CL22'XML-NNAMESPACE-PREFIX '\n         DC   AL1(10),CL10'XML-NTEXT '\n         DC   AL1(11),CL11'XML-SCHEMA '\n         DC   AL1(09),CL09'XML-TEXT '\n         DC   AL1(13),CL13'YEAR-TO-YYYY '           * CUCI COB\n         DC   AL1(08),CL08'YYYYDDD '\n         DC   AL1(09),CL09'YYYYMMDD '\n         DC   AL1(05),CL05'ZERO '\n         DC   AL1(07),CL07'ZEROES '\n         DC   AL1(06),CL06'ZEROS '\n         DC   AL1(0)\n         END\nISRPXDTL CSECT ,\nISRPXDTL AMODE 31\nISRPXDTL RMODE ANY\n*  ISRPXDTL: 507 Keywords\n*  3722 bytes\n*\n         DC   AL1(09),CL09'!DOCTYPE '\n         DC   AL1(08),CL08'!ENTITY '\n         DC   AL1(09),CL09':DOCTYPE '\n         DC   AL1(08),CL08':ENTITY '\n         DC   AL1(03),CL03'AB '\n         DC   AL1(04),CL04'ABC '\n         DC   AL1(08),CL08'ABCINIT '\n         DC   AL1(08),CL08'ABCPROC '\n         DC   AL1(06),CL06'ABOVE '\n         DC   AL1(09),CL09'ABSEPSTR '\n         DC   AL1(05),CL05'ACC1 '\n         DC   AL1(05),CL05'ACC2 '\n         DC   AL1(05),CL05'ACC3 '\n         DC   AL1(07),CL07'ACTBAR '\n         DC   AL1(07),CL07'ACTION '\n         DC   AL1(08),CL08'ACTIONS '\n         DC   AL1(07),CL07'ADDPOP '\n         DC   AL1(06),CL06'AFTER '\n         DC   AL1(06),CL06'ALARM '\n         DC   AL1(06),CL06'ALIGN '\n         DC   AL1(04),CL04'ALL '\n         DC   AL1(06),CL06'ALPHA '\n         DC   AL1(07),CL07'ALPHAB '\n         DC   AL1(04),CL04'ALT '\n         DC   AL1(04),CL04'ANY '\n         DC   AL1(04),CL04'APL '\n         DC   AL1(08),CL08'APPLCMD '\n         DC   AL1(07),CL07'APPLID '\n         DC   AL1(09),CL09'APPTITLE '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(05),CL05'ASIS '\n         DC   AL1(08),CL08'ASSIGNI '\n         DC   AL1(08),CL08'ASSIGNL '\n         DC   AL1(10),CL10'ATTENTION '\n         DC   AL1(05),CL05'ATTR '\n         DC   AL1(11),CL11'ATTRCHANGE '\n         DC   AL1(09),CL09'ATTRCHAR '\n         DC   AL1(08),CL08'ATTRUSE '\n         DC   AL1(08),CL08'AUTOCLR '\n         DC   AL1(08),CL08'AUTOTAB '\n         DC   AL1(09),CL09'AVAILVAR '\n         DC   AL1(10),CL10'BACKSPACE '\n         DC   AL1(09),CL09'BACKWARD '\n         DC   AL1(08),CL08'BARRIER '\n         DC   AL1(07),CL07'BEFORE '\n         DC   AL1(06),CL06'BELOW '\n         DC   AL1(04),CL04'BIT '\n         DC   AL1(06),CL06'BLANK '\n         DC   AL1(07),CL07'BLANKS '\n         DC   AL1(06),CL06'BLINK '\n         DC   AL1(05),CL05'BLUE '\n         DC   AL1(05),CL05'BOTH '\n         DC   AL1(08),CL08'BOTINST '\n         DC   AL1(04),CL04'BOX '\n         DC   AL1(06),CL06'BREAK '\n         DC   AL1(07),CL07'CANCEL '\n         DC   AL1(05),CL05'CAPS '\n         DC   AL1(05),CL05'CASE '\n         DC   AL1(08),CL08'CAUTION '\n         DC   AL1(06),CL06'CCSID '\n         DC   AL1(07),CL07'CENTER '\n         DC   AL1(05),CL05'CHAR '\n         DC   AL1(06),CL06'CHARS '\n         DC   AL1(07),CL07'CHECKI '\n         DC   AL1(07),CL07'CHECKL '\n         DC   AL1(09),CL09'CHECKVAR '\n         DC   AL1(06),CL06'CHDIV '\n         DC   AL1(08),CL08'CHGDEFS '\n         DC   AL1(07),CL07'CHKBOX '\n         DC   AL1(07),CL07'CHOFLD '\n         DC   AL1(07),CL07'CHOICE '\n         DC   AL1(11),CL11'CHOICECOLS '\n         DC   AL1(12),CL12'CHOICEDEPTH '\n         DC   AL1(06),CL06'CKBOX '\n         DC   AL1(06),CL06'CLASS '\n         DC   AL1(06),CL06'CLEAR '\n         DC   AL1(04),CL04'CMD '\n         DC   AL1(07),CL07'CMDACT '\n         DC   AL1(08),CL08'CMDAREA '\n         DC   AL1(08),CL08'CMDLINE '\n         DC   AL1(07),CL07'CMDLOC '\n         DC   AL1(07),CL07'CMDTBL '\n         DC   AL1(04),CL04'COL '\n         DC   AL1(06),CL06'COLOR '\n         DC   AL1(09),CL09'COLSPACE '\n         DC   AL1(08),CL08'COLTYPE '\n         DC   AL1(09),CL09'COLWIDTH '\n         DC   AL1(08),CL08'COMMENT '\n         DC   AL1(08),CL08'COMPACT '\n         DC   AL1(08),CL08'COMPOPT '\n         DC   AL1(08),CL08'CONTROL '\n         DC   AL1(07),CL07'COPIES '\n         DC   AL1(06),CL06'COPYR '\n         DC   AL1(05),CL05'CREX '\n         DC   AL1(09),CL09'CRITICAL '\n         DC   AL1(07),CL07'CSRGRP '\n         DC   AL1(09),CL09'CSRINDEX '\n         DC   AL1(07),CL07'CSRPOS '\n         DC   AL1(05),CL05'CTRL '\n         DC   AL1(04),CL04'CUA '\n         DC   AL1(07),CL07'CUADYN '\n         DC   AL1(07),CL07'CURSOR '\n         DC   AL1(03),CL03'DA '\n         DC   AL1(07),CL07'DATAIN '\n         DC   AL1(08),CL08'DATAMOD '\n         DC   AL1(08),CL08'DATAOUT '\n         DC   AL1(08),CL08'DATAVAR '\n         DC   AL1(05),CL05'DATE '\n         DC   AL1(05),CL05'DBCS '\n         DC   AL1(03),CL03'DD '\n         DC   AL1(05),CL05'DDHD '\n         DC   AL1(07),CL07'DDLIST '\n         DC   AL1(08),CL08'DEFAULT '\n         DC   AL1(07),CL07'DELETE '\n         DC   AL1(06),CL06'DEPTH '\n         DC   AL1(08),CL08'DESSKIP '\n         DC   AL1(08),CL08'DESTVAR '\n         DC   AL1(09),CL09'DESWIDTH '\n         DC   AL1(04),CL04'DIR '\n         DC   AL1(05),CL05'DISP '\n         DC   AL1(08),CL08'DISPLAY '\n         DC   AL1(08),CL08'DISPLEN '\n         DC   AL1(04),CL04'DIV '\n         DC   AL1(08),CL08'DIVIDER '\n         DC   AL1(07),CL07'DIVLOC '\n         DC   AL1(03),CL03'DL '\n         DC   AL1(06),CL06'DLDIV '\n         DC   AL1(03),CL03'DM '\n         DC   AL1(04),CL04'DSN '\n         DC   AL1(07),CL07'DSNAME '\n         DC   AL1(08),CL08'DSNAMEQ '\n         DC   AL1(03),CL03'DT '\n         DC   AL1(07),CL07'DTACOL '\n         DC   AL1(07),CL07'DTAFLD '\n         DC   AL1(08),CL08'DTAFLDD '\n         DC   AL1(06),CL06'DTDIV '\n         DC   AL1(05),CL05'DTHD '\n         DC   AL1(07),CL07'DTHDIV '\n         DC   AL1(06),CL06'DTSEG '\n         DC   AL1(07),CL07'EBCDIC '\n         DC   AL1(04),CL04'END '\n         DC   AL1(08),CL08'ENDATTR '\n         DC   AL1(06),CL06'ENTER '\n         DC   AL1(09),CL09'ENTWIDTH '\n         DC   AL1(05),CL05'ENUM '\n         DC   AL1(03),CL03'EQ '\n         DC   AL1(06),CL06'ERROR '\n         DC   AL1(07),CL07'EXHELP '\n         DC   AL1(05),CL05'EXIT '\n         DC   AL1(07),CL07'EXPAND '\n         DC   AL1(07),CL07'EXTEND '\n         DC   AL1(09),CL09'EXTENDED '\n         DC   AL1(08),CL08'FCHOICE '\n         DC   AL1(06),CL06'FIELD '\n         DC   AL1(04),CL04'FIG '\n         DC   AL1(07),CL07'FIGCAP '\n         DC   AL1(07),CL07'FILEID '\n         DC   AL1(04),CL04'FIT '\n         DC   AL1(04),CL04'FKA '\n         DC   AL1(09),CL09'FLDSPACE '\n         DC   AL1(08),CL08'FLDTYPE '\n         DC   AL1(09),CL09'FLDWIDTH '\n         DC   AL1(09),CL09'FMTWIDTH '\n         DC   AL1(05),CL05'FONT '\n         DC   AL1(07),CL07'FORMAT '\n         DC   AL1(08),CL08'FORWARD '\n         DC   AL1(06),CL06'FRAME '\n         DC   AL1(05),CL05'FSCR '\n         DC   AL1(03),CL03'F1 '\n         DC   AL1(04),CL04'F10 '\n         DC   AL1(04),CL04'F11 '\n         DC   AL1(04),CL04'F12 '\n         DC   AL1(03),CL03'F2 '\n         DC   AL1(03),CL03'F3 '\n         DC   AL1(03),CL03'F4 '\n         DC   AL1(03),CL03'F5 '\n         DC   AL1(03),CL03'F6 '\n         DC   AL1(03),CL03'F7 '\n         DC   AL1(03),CL03'F8 '\n         DC   AL1(03),CL03'F9 '\n         DC   AL1(03),CL03'GA '\n         DC   AL1(04),CL04'GAP '\n         DC   AL1(03),CL03'GE '\n         DC   AL1(09),CL09'GENERATE '\n         DC   AL1(06),CL06'GREEN '\n         DC   AL1(07),CL07'GRPBOX '\n         DC   AL1(07),CL07'GRPHDR '\n         DC   AL1(06),CL06'GRPID '\n         DC   AL1(09),CL09'GRPWIDTH '\n         DC   AL1(05),CL05'GRP1 '\n         DC   AL1(05),CL05'GRP2 '\n         DC   AL1(05),CL05'GRP3 '\n         DC   AL1(05),CL05'GRP4 '\n         DC   AL1(03),CL03'GT '\n         DC   AL1(04),CL04'GUI '\n         DC   AL1(07),CL07'GUTTER '\n         DC   AL1(09),CL09'HEADLINE '\n         DC   AL1(05),CL05'HELP '\n         DC   AL1(08),CL08'HELPDEF '\n         DC   AL1(09),CL09'HELPHELP '\n         DC   AL1(04),CL04'HEX '\n         DC   AL1(05),CL05'HIDE '\n         DC   AL1(05),CL05'HIGH '\n         DC   AL1(07),CL07'HILITE '\n         DC   AL1(06),CL06'HORIZ '\n         DC   AL1(08),CL08'HOSTCMD '\n         DC   AL1(03),CL03'HP '\n         DC   AL1(03),CL03'H1 '\n         DC   AL1(03),CL03'H2 '\n         DC   AL1(03),CL03'H3 '\n         DC   AL1(03),CL03'H4 '\n         DC   AL1(05),CL05'ICMD '\n         DC   AL1(05),CL05'ICON '\n         DC   AL1(03),CL03'ID '\n         DC   AL1(06),CL06'IDATE '\n         DC   AL1(07),CL07'IGNORE '\n         DC   AL1(03),CL03'IN '\n         DC   AL1(08),CL08'INCLUDE '\n         DC   AL1(07),CL07'INDENT '\n         DC   AL1(06),CL06'INDEX '\n         DC   AL1(07),CL07'INDVAL '\n         DC   AL1(07),CL07'INDVAR '\n         DC   AL1(05),CL05'INFO '\n         DC   AL1(05),CL05'INIT '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(07),CL07'INSERT '\n         DC   AL1(07),CL07'INTENS '\n         DC   AL1(05),CL05'ISPF '\n         DC   AL1(05),CL05'ISYN '\n         DC   AL1(06),CL06'ITIME '\n         DC   AL1(05),CL05'ITOP '\n         DC   AL1(06),CL06'JDATE '\n         DC   AL1(05),CL05'JSTD '\n         DC   AL1(05),CL05'JUST '\n         DC   AL1(05),CL05'KANA '\n         DC   AL1(04),CL04'KEY '\n         DC   AL1(05),CL05'KEYI '\n         DC   AL1(05),CL05'KEYL '\n         DC   AL1(08),CL08'KEYLIST '\n         DC   AL1(09),CL09'KEYLTYPE '\n         DC   AL1(05),CL05'KEYS '\n         DC   AL1(09),CL09'KEYSHELP '\n         DC   AL1(05),CL05'LANG '\n         DC   AL1(08),CL08'LCOLIND '\n         DC   AL1(03),CL03'LE '\n         DC   AL1(05),CL05'LEFT '\n         DC   AL1(04),CL04'LEN '\n         DC   AL1(07),CL07'LENGTH '\n         DC   AL1(03),CL03'LI '\n         DC   AL1(08),CL08'LINDVAL '\n         DC   AL1(08),CL08'LINDVAR '\n         DC   AL1(05),CL05'LINE '\n         DC   AL1(06),CL06'LINES '\n         DC   AL1(08),CL08'LISTBOX '\n         DC   AL1(10),CL10'LISTDEPTH '\n         DC   AL1(08),CL08'LISTREF '\n         DC   AL1(09),CL09'LISTTYPE '\n         DC   AL1(06),CL06'LISTV '\n         DC   AL1(07),CL07'LISTVX '\n         DC   AL1(04),CL04'LIT '\n         DC   AL1(05),CL05'LMSG '\n         DC   AL1(09),CL09'LOCATION '\n         DC   AL1(04),CL04'LOW '\n         DC   AL1(03),CL03'LP '\n         DC   AL1(07),CL07'LSTCOL '\n         DC   AL1(07),CL07'LSTFLD '\n         DC   AL1(07),CL07'LSTGRP '\n         DC   AL1(07),CL07'LSTVAR '\n         DC   AL1(03),CL03'LT '\n         DC   AL1(07),CL07'LVLINE '\n         DC   AL1(02),CL02'M '\n         DC   AL1(08),CL08'MARGIND '\n         DC   AL1(08),CL08'MARGINW '\n         DC   AL1(06),CL06'MATCH '\n         DC   AL1(09),CL09'MAXDEPTH '\n         DC   AL1(07),CL07'MAXDIM '\n         DC   AL1(08),CL08'MAXROWS '\n         DC   AL1(09),CL09'MAXWIDTH '\n         DC   AL1(09),CL09'MCOMMENT '\n         DC   AL1(09),CL09'MCOMMENT '\n         DC   AL1(04),CL04'MEM '\n         DC   AL1(05),CL05'MENU '\n         DC   AL1(11),CL11'MERGESAREA '\n         DC   AL1(09),CL09'MINDEPTH '\n         DC   AL1(08),CL08'MINROWS '\n         DC   AL1(09),CL09'MINWIDTH '\n         DC   AL1(04),CL04'MIX '\n         DC   AL1(06),CL06'MIXED '\n         DC   AL1(08),CL08'MNEMGEN '\n         DC   AL1(06),CL06'MODAL '\n         DC   AL1(05),CL05'MODE '\n         DC   AL1(09),CL09'MODELESS '\n         DC   AL1(07),CL07'MODVAR '\n         DC   AL1(04),CL04'MSG '\n         DC   AL1(08),CL08'MSGLINE '\n         DC   AL1(07),CL07'MSGMBR '\n         DC   AL1(08),CL08'MSGTYPE '\n         DC   AL1(06),CL06'MULTI '\n         DC   AL1(05),CL05'NAME '\n         DC   AL1(03),CL03'NE '\n         DC   AL1(05),CL05'NEST '\n         DC   AL1(04),CL04'NEW '\n         DC   AL1(08),CL08'NEWAPPL '\n         DC   AL1(08),CL08'NEWPOOL '\n         DC   AL1(03),CL03'NG '\n         DC   AL1(03),CL03'NL '\n         DC   AL1(03),CL03'NO '\n         DC   AL1(08),CL08'NOCHECK '\n         DC   AL1(10),CL10'NOENDATTR '\n         DC   AL1(06),CL06'NOGUI '\n         DC   AL1(07),CL07'NOINIT '\n         DC   AL1(07),CL07'NOKANA '\n         DC   AL1(08),CL08'NOMATCH '\n         DC   AL1(11),CL11'NOMCOMMENT '\n         DC   AL1(11),CL11'NOMCOMMENT '\n         DC   AL1(04),CL04'NON '\n         DC   AL1(05),CL05'NONE '\n         DC   AL1(07),CL07'NOPLEB '\n         DC   AL1(07),CL07'NOSCAN '\n         DC   AL1(05),CL05'NOTE '\n         DC   AL1(06),CL06'NOTEL '\n         DC   AL1(07),CL07'NOTIFY '\n         DC   AL1(03),CL03'NT '\n         DC   AL1(06),CL06'NULLS '\n         DC   AL1(04),CL04'NUM '\n         DC   AL1(07),CL07'NUMBER '\n         DC   AL1(08),CL08'NUMERIC '\n         DC   AL1(08),CL08'NUMROWS '\n         DC   AL1(04),CL04'OFF '\n         DC   AL1(03),CL03'OL '\n         DC   AL1(03),CL03'ON '\n         DC   AL1(04),CL04'OUT '\n         DC   AL1(08),CL08'OUTLINE '\n         DC   AL1(07),CL07'OUTPUT '\n         DC   AL1(02),CL02'P '\n         DC   AL1(04),CL04'PAD '\n         DC   AL1(05),CL05'PADC '\n         DC   AL1(05),CL05'PAGE '\n         DC   AL1(07),CL07'PANDEF '\n         DC   AL1(06),CL06'PANEL '\n         DC   AL1(08),CL08'PANELID '\n         DC   AL1(05),CL05'PARM '\n         DC   AL1(06),CL06'PARML '\n         DC   AL1(06),CL06'PARM1 '\n         DC   AL1(06),CL06'PARM2 '\n         DC   AL1(06),CL06'PARM3 '\n         DC   AL1(04),CL04'PAS '\n         DC   AL1(08),CL08'PASSLIB '\n         DC   AL1(09),CL09'PASSTHRU '\n         DC   AL1(03),CL03'PD '\n         DC   AL1(04),CL04'PDC '\n         DC   AL1(07),CL07'PDCVAR '\n         DC   AL1(06),CL06'PDSEP '\n         DC   AL1(06),CL06'PDSNI '\n         DC   AL1(06),CL06'PDSNL '\n         DC   AL1(04),CL04'PGM '\n         DC   AL1(05),CL05'PICT '\n         DC   AL1(05),CL05'PINK '\n         DC   AL1(06),CL06'PLDIV '\n         DC   AL1(05),CL05'PLEB '\n         DC   AL1(06),CL06'PLIBI '\n         DC   AL1(06),CL06'PLIBL '\n         DC   AL1(07),CL07'PMTFMT '\n         DC   AL1(07),CL07'PMTLOC '\n         DC   AL1(08),CL08'PMTSKIP '\n         DC   AL1(08),CL08'PMTTEXT '\n         DC   AL1(09),CL09'PMTWIDTH '\n         DC   AL1(08),CL08'PNLINST '\n         DC   AL1(09),CL09'POSITION '\n         DC   AL1(06),CL06'PRIME '\n         DC   AL1(08),CL08'PRIVATE '\n         DC   AL1(08),CL08'PRMDATA '\n         DC   AL1(05),CL05'PROC '\n         DC   AL1(08),CL08'PROFILE '\n         DC   AL1(05),CL05'PROJ '\n         DC   AL1(03),CL03'PS '\n         DC   AL1(09),CL09'PSBUTTON '\n         DC   AL1(06),CL06'PSVAL '\n         DC   AL1(06),CL06'PSVAR '\n         DC   AL1(03),CL03'PT '\n         DC   AL1(06),CL06'PTDIV '\n         DC   AL1(06),CL06'PTSEG '\n         DC   AL1(06),CL06'RADIO '\n         DC   AL1(06),CL06'RANGE '\n         DC   AL1(08),CL08'RCOLIND '\n         DC   AL1(04),CL04'RED '\n         DC   AL1(08),CL08'REFRESH '\n         DC   AL1(07),CL07'REGION '\n         DC   AL1(07),CL07'REINIT '\n         DC   AL1(09),CL09'REQUIRED '\n         DC   AL1(04),CL04'RES '\n         DC   AL1(08),CL08'RESPECT '\n         DC   AL1(07),CL07'RESULT '\n         DC   AL1(09),CL09'RETRIEVE '\n         DC   AL1(08),CL08'REVERSE '\n         DC   AL1(06),CL06'RIGHT '\n         DC   AL1(08),CL08'RINDVAL '\n         DC   AL1(08),CL08'RINDVAR '\n         DC   AL1(05),CL05'ROOT '\n         DC   AL1(06),CL06'ROOTS '\n         DC   AL1(05),CL05'ROWS '\n         DC   AL1(03),CL03'RP '\n         DC   AL1(05),CL05'RULE '\n         DC   AL1(06),CL06'RULES '\n         DC   AL1(04),CL04'RUN '\n         DC   AL1(06),CL06'SCALE '\n         DC   AL1(05),CL05'SCAN '\n         DC   AL1(07),CL07'SCRFLD '\n         DC   AL1(08),CL08'SCRNAME '\n         DC   AL1(07),CL07'SCROLL '\n         DC   AL1(10),CL10'SCROLLTAB '\n         DC   AL1(10),CL10'SCROLLVAR '\n         DC   AL1(09),CL09'SCRVHELP '\n         DC   AL1(08),CL08'SELCHAR '\n         DC   AL1(07),CL07'SELCOL '\n         DC   AL1(11),CL11'SELDEFAULT '\n         DC   AL1(07),CL07'SELFLD '\n         DC   AL1(07),CL07'SELFMT '\n         DC   AL1(07),CL07'SELLST '\n         DC   AL1(07),CL07'SELMSG '\n         DC   AL1(07),CL07'SELVAR '\n         DC   AL1(09),CL09'SELWIDTH '\n         DC   AL1(07),CL07'SETVAR '\n         DC   AL1(08),CL08'SETVERB '\n         DC   AL1(07),CL07'SHADOW '\n         DC   AL1(07),CL07'SHARED '\n         DC   AL1(06),CL06'SHIFT '\n         DC   AL1(08),CL08'SINDVAL '\n         DC   AL1(08),CL08'SINDVAR '\n         DC   AL1(07),CL07'SINGLE '\n         DC   AL1(05),CL05'SKIP '\n         DC   AL1(08),CL08'SKIPVAR '\n         DC   AL1(03),CL03'SL '\n         DC   AL1(05),CL05'SMSG '\n         DC   AL1(06),CL06'SOLID '\n         DC   AL1(05),CL05'SORT '\n         DC   AL1(08),CL08'SORTKEY '\n         DC   AL1(07),CL07'SOURCE '\n         DC   AL1(06),CL06'SPACE '\n         DC   AL1(06),CL06'START '\n         DC   AL1(06),CL06'STATE '\n         DC   AL1(08),CL08'STDDATE '\n         DC   AL1(08),CL08'STDTIME '\n         DC   AL1(06),CL06'STRIP '\n         DC   AL1(07),CL07'SUFFIX '\n         DC   AL1(08),CL08'SUSPEND '\n         DC   AL1(08),CL08'SYSMONO '\n         DC   AL1(07),CL07'SYSTEM '\n         DC   AL1(02),CL02'T '\n         DC   AL1(03),CL03'TE '\n         DC   AL1(05),CL05'TEXT '\n         DC   AL1(08),CL08'TEXTFMT '\n         DC   AL1(08),CL08'TEXTLEN '\n         DC   AL1(09),CL09'TEXTLINE '\n         DC   AL1(08),CL08'TEXTLOC '\n         DC   AL1(08),CL08'TEXTSEG '\n         DC   AL1(09),CL09'TEXTSKIP '\n         DC   AL1(04),CL04'THS '\n         DC   AL1(05),CL05'TIME '\n         DC   AL1(06),CL06'TITLE '\n         DC   AL1(08),CL08'TITLINE '\n         DC   AL1(07),CL07'TOGVAR '\n         DC   AL1(08),CL08'TOPINST '\n         DC   AL1(07),CL07'TOPROW '\n         DC   AL1(06),CL06'TRAIL '\n         DC   AL1(06),CL06'TRUNC '\n         DC   AL1(06),CL06'TSIZE '\n         DC   AL1(05),CL05'TURQ '\n         DC   AL1(06),CL06'TUTOR '\n         DC   AL1(09),CL09'TUTORIAL '\n         DC   AL1(05),CL05'TYPE '\n         DC   AL1(03),CL03'UC '\n         DC   AL1(03),CL03'UL '\n         DC   AL1(08),CL08'UNAVAIL '\n         DC   AL1(06),CL06'UPPER '\n         DC   AL1(06),CL06'USAGE '\n         DC   AL1(07),CL07'USCORE '\n         DC   AL1(05),CL05'USER '\n         DC   AL1(08),CL08'USERMOD '\n         DC   AL1(06),CL06'VALUE '\n         DC   AL1(07),CL07'VALUES '\n         DC   AL1(08),CL08'VALUESX '\n         DC   AL1(07),CL07'VALUE1 '\n         DC   AL1(07),CL07'VALUE2 '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(09),CL09'VARCLASS '\n         DC   AL1(07),CL07'VARDCL '\n         DC   AL1(08),CL08'VARLIST '\n         DC   AL1(08),CL08'VARNAME '\n         DC   AL1(07),CL07'VARSUB '\n         DC   AL1(07),CL07'VERIFY '\n         DC   AL1(05),CL05'VERT '\n         DC   AL1(06),CL06'VMASK '\n         DC   AL1(04),CL04'VOL '\n         DC   AL1(07),CL07'VOLUME '\n         DC   AL1(08),CL08'WARNING '\n         DC   AL1(06),CL06'WHITE '\n         DC   AL1(06),CL06'WIDTH '\n         DC   AL1(07),CL07'WINDOW '\n         DC   AL1(09),CL09'WINTITLE '\n         DC   AL1(06),CL06'XLATI '\n         DC   AL1(06),CL06'XLATL '\n         DC   AL1(04),CL04'XMP '\n         DC   AL1(04),CL04'X2C '\n         DC   AL1(07),CL07'YELLOW '\n         DC   AL1(04),CL04'YES '\n         DC   AL1(05),CL05'ZGUI '\n         DC   AL1(0)\n         END\nISRPXJCL CSECT ,\nISRPXJCL AMODE 31\nISRPXJCL RMODE ANY\n*  ISRPXJCL: 31 Keywords\n*  222 bytes\n*\n         DC   AL1(06),CL06'AFTER '\n         DC   AL1(07),CL07'BEFORE '\n         DC   AL1(05),CL05'CNTL '\n         DC   AL1(08),CL08'COMMAND '\n         DC   AL1(11),CL11'CONCURRENT '\n         DC   AL1(05),CL05'DATA '\n         DC   AL1(03),CL03'DD '\n         DC   AL1(04),CL04'DLM '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(08),CL08'ENDCNTL '\n         DC   AL1(09),CL09'ENDGROUP '\n         DC   AL1(06),CL06'ENDIF '\n         DC   AL1(07),CL07'ENDSET '\n         DC   AL1(05),CL05'EXEC '\n         DC   AL1(07),CL07'EXPORT '\n         DC   AL1(05),CL05'GJOB '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(08),CL08'INCLUDE '\n         DC   AL1(07),CL07'JCLLIB '\n         DC   AL1(04),CL04'JOB '\n         DC   AL1(09),CL09'JOBGROUP '\n         DC   AL1(07),CL07'JOBSET '\n         DC   AL1(07),CL07'NOTIFY '\n         DC   AL1(07),CL07'OUTPUT '\n         DC   AL1(05),CL05'PEND '\n         DC   AL1(05),CL05'PROC '\n         DC   AL1(09),CL09'SCHEDULE '\n         DC   AL1(04),CL04'SET '\n         DC   AL1(05),CL05'SJOB '\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(05),CL05'XMIT '\n         DC   AL1(0)                /*                               */\n         END\nISRPXOTH CSECT ,\nISRPXOTH AMODE 31\nISRPXOTH RMODE ANY\n*  ISRPXOTH: 25 Keywords\n*  169 bytes\n*\n         DC   AL1(06),CL06'BEGIN '\n         DC   AL1(03),CL03'BY '\n         DC   AL1(05),CL05'CALL '\n         DC   AL1(04),CL04'DCL '\n         DC   AL1(08),CL08'DECLARE '\n         DC   AL1(03),CL03'DO '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(04),CL04'END '\n         DC   AL1(06),CL06'ENTRY '\n         DC   AL1(08),CL08'FOREVER '\n         DC   AL1(05),CL05'GOTO '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(08),CL08'ITERATE '\n         DC   AL1(06),CL06'LEAVE '\n         DC   AL1(06),CL06'OTHER '\n         DC   AL1(10),CL10'OTHERWISE '\n         DC   AL1(05),CL05'PROC '\n         DC   AL1(10),CL10'PROCEDURE '\n         DC   AL1(07),CL07'RETURN '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(03),CL03'TO '\n         DC   AL1(06),CL06'UNTIL '\n         DC   AL1(05),CL05'WHEN '\n         DC   AL1(06),CL06'WHILE '\n         DC   AL1(0)\n         END\nISRPXPLI CSECT ,\nISRPXPLI AMODE 31\nISRPXPLI RMODE ANY\n*  ISRPXPLI: 649 Keywords\n*  5571 bytes\n*\n         DC   AL1(09),CL09'ABNORMAL '\n         DC   AL1(04),CL04'ABS '\n         DC   AL1(05),CL05'ACOS '\n         DC   AL1(04),CL04'ADD '\n         DC   AL1(08),CL08'ADDBUFF '\n         DC   AL1(05),CL05'ADDR '\n         DC   AL1(09),CL09'ADDRDATA '\n         DC   AL1(06),CL06'ALIAS '\n         DC   AL1(08),CL08'ALIGNED '\n         DC   AL1(04),CL04'ALL '\n         DC   AL1(11),CL11'ALLCOMPARE '\n         DC   AL1(06),CL06'ALLOC '\n         DC   AL1(09),CL09'ALLOCATE '\n         DC   AL1(11),CL11'ALLOCATION '\n         DC   AL1(07),CL07'ALLOCN '\n         DC   AL1(10),CL10'ALLOCNEXT '              * CUCI PLI\n         DC   AL1(10),CL10'ALLOCSIZE '\n         DC   AL1(08),CL08'ALLOC31 '                * CUCI PLI\n         DC   AL1(04),CL04'ANS '                    * CUCI PLI\n         DC   AL1(04),CL04'ANY '\n         DC   AL1(13),CL13'ANYCONDITION '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(06),CL06'ASCII '\n         DC   AL1(05),CL05'ASGN '\n         DC   AL1(05),CL05'ASIN '\n         DC   AL1(04),CL04'ASM '\n         DC   AL1(08),CL08'ASMTDLI '\n         DC   AL1(10),CL10'ASSEMBLER '\n         DC   AL1(07),CL07'ASSERT '\n         DC   AL1(11),CL11'ASSIGNABLE '\n         DC   AL1(05),CL05'ATAN '\n         DC   AL1(06),CL06'ATAND '\n         DC   AL1(06),CL06'ATANH '\n         DC   AL1(07),CL07'ATTACH '\n         DC   AL1(10),CL10'ATTENTION '\n         DC   AL1(05),CL05'ATTN '\n         DC   AL1(05),CL05'AUTO '\n         DC   AL1(10),CL10'AUTOMATIC '\n         DC   AL1(14),CL14'AVAILABLEAREA '\n         DC   AL1(10),CL10'BACKWARDS '\n         DC   AL1(06),CL06'BASED '\n         DC   AL1(13),CL13'BASE64DECODE '           * CUCI PLI\n         DC   AL1(14),CL14'BASE64DECODE8 '\n         DC   AL1(15),CL15'BASE64DECODE16 '\n         DC   AL1(13),CL13'BASE64ENCODE '           * CUCI PLI\n         DC   AL1(14),CL14'BASE64ENCODE8 '\n         DC   AL1(15),CL15'BASE64ENCODE16 '\n         DC   AL1(06),CL06'BEGIN '\n         DC   AL1(08),CL08'BETWEEN '                * CUCI PLI\n         DC   AL1(17),CL17'BETWEENEXCLUSIVE '       * CUCI PLI\n         DC   AL1(21),CL21'BETWEENLEFTEXCLUSIVE '   * CUCI PLI\n         DC   AL1(22),CL22'BETWEENRIGHTEXCLUSIVE '  * CUCI PLI\n         DC   AL1(10),CL10'BIGENDIAN '\n         DC   AL1(04),CL04'BIN '\n         DC   AL1(07),CL07'BINARY '\n         DC   AL1(12),CL12'BINARYVALUE '\n         DC   AL1(10),CL10'BINSEARCH '              * CUCI PLI\n         DC   AL1(11),CL11'BINSEARCHX '             * CUCI PLI\n         DC   AL1(05),CL05'BIND '\n         DC   AL1(09),CL09'BINVALUE '\n         DC   AL1(04),CL04'BIT '\n         DC   AL1(07),CL07'BITLOC '\n         DC   AL1(12),CL12'BITLOCATION '\n         DC   AL1(05),CL05'BKWD '\n         DC   AL1(08),CL08'BLKSIZE '\n         DC   AL1(05),CL05'BOOL '\n         DC   AL1(04),CL04'BUF '\n         DC   AL1(09),CL09'BUFFERED '\n         DC   AL1(08),CL08'BUFFERS '\n         DC   AL1(06),CL06'BUFND '\n         DC   AL1(06),CL06'BUFNI '\n         DC   AL1(07),CL07'BUFOFF '\n         DC   AL1(06),CL06'BUFSP '\n         DC   AL1(08),CL08'BUILTIN '\n         DC   AL1(03),CL03'BX '\n         DC   AL1(03),CL03'BY '\n         DC   AL1(07),CL07'BYADDR '\n         DC   AL1(05),CL05'BYTE '\n         DC   AL1(11),CL11'BYTELENGTH '             * CUCI PLI\n         DC   AL1(08),CL08'BYVALUE '\n         DC   AL1(03),CL03'B4 '\n         DC   AL1(05),CL05'CALL '\n         DC   AL1(07),CL07'CANCEL '                 * CUCI PLI\n         DC   AL1(05),CL05'CAST '\n         DC   AL1(04),CL04'CDS '\n         DC   AL1(05),CL05'CEIL '\n         DC   AL1(07),CL07'CENTER '\n         DC   AL1(11),CL11'CENTERLEFT '\n         DC   AL1(12),CL12'CENTERRIGHT '\n         DC   AL1(07),CL07'CENTRE '\n         DC   AL1(11),CL11'CENTRELEFT '\n         DC   AL1(12),CL12'CENTRERIGHT '\n         DC   AL1(05),CL05'CHAR '\n         DC   AL1(10),CL10'CHARACTER '\n         DC   AL1(06),CL06'CHARG '\n         DC   AL1(12),CL12'CHARGRAPHIC '\n         DC   AL1(08),CL08'CHARVAL '\n         DC   AL1(06),CL06'CHECK '\n         DC   AL1(09),CL09'CHECKSTG '\n         DC   AL1(09),CL09'CHECKSUM '               * CUCI PLI\n         DC   AL1(06),CL06'CLOSE '\n         DC   AL1(06),CL06'CMPAT '\n         DC   AL1(06),CL06'COBOL '\n         DC   AL1(09),CL09'CODEPAGE '               * CUCI PLI\n         DC   AL1(04),CL04'COL '\n         DC   AL1(08),CL08'COLLATE '\n         DC   AL1(09),CL09'COLLAPSE '               * CUCI PLI\n         DC   AL1(07),CL07'COLUMN '\n         DC   AL1(08),CL08'COMMENT '\n         DC   AL1(08),CL08'COMPARE '\n         DC   AL1(12),CL12'COMPILEDATE '\n         DC   AL1(12),CL12'COMPILETIME '\n         DC   AL1(11),CL11'COMPLETION '\n         DC   AL1(08),CL08'COMPLEX '\n         DC   AL1(05),CL05'COND '\n         DC   AL1(10),CL10'CONDITION '\n         DC   AL1(06),CL06'CONJG '\n         DC   AL1(05),CL05'CONN '\n         DC   AL1(10),CL10'CONNECTED '\n         DC   AL1(12),CL12'CONSECUTIVE '\n         DC   AL1(11),CL11'CONTROLLED '\n         DC   AL1(05),CL05'CONV '\n         DC   AL1(11),CL11'CONVERSION '\n         DC   AL1(05),CL05'COPY '\n         DC   AL1(04),CL04'COS '\n         DC   AL1(05),CL05'COSD '\n         DC   AL1(05),CL05'COSH '\n         DC   AL1(06),CL06'COUNT '\n         DC   AL1(08),CL08'COUNTER '\n         DC   AL1(05),CL05'CPLN '\n         DC   AL1(05),CL05'CPLX '\n         DC   AL1(03),CL03'CS '\n         DC   AL1(05),CL05'CSTG '\n         DC   AL1(04),CL04'CTL '\n         DC   AL1(07),CL07'CTLASA '\n         DC   AL1(07),CL07'CTL360 '\n         DC   AL1(12),CL12'CURRENTSIZE '\n         DC   AL1(15),CL15'CURRENTSTORAGE '\n         DC   AL1(05),CL05'DATA '\n         DC   AL1(10),CL10'DATAFIELD '\n         DC   AL1(05),CL05'DATE '\n         DC   AL1(09),CL09'DATETIME '\n         DC   AL1(05),CL05'DAYS '\n         DC   AL1(11),CL11'DAYSTODATE '\n         DC   AL1(16),CL16'DAYSTOMICROSECS '        * CUCI PLI\n         DC   AL1(11),CL11'DAYSTOSECS '\n         DC   AL1(03),CL03'DB '\n         DC   AL1(04),CL04'DCL '\n         DC   AL1(04),CL04'DEC '\n         DC   AL1(08),CL08'DECIMAL '\n         DC   AL1(08),CL08'DECLARE '\n         DC   AL1(04),CL04'DEF '\n         DC   AL1(08),CL08'DEFAULT '\n         DC   AL1(07),CL07'DEFINE '\n         DC   AL1(08),CL08'DEFINED '\n         DC   AL1(06),CL06'DELAY '\n         DC   AL1(07),CL07'DELETE '\n         DC   AL1(05),CL05'DESC '                   * CUCI PLI\n         DC   AL1(11),CL11'DESCRIPTOR '\n         DC   AL1(12),CL12'DESCRIPTORS '\n         DC   AL1(07),CL07'DETACH '\n         DC   AL1(04),CL04'DFT '\n         DC   AL1(04),CL04'DIM '\n         DC   AL1(10),CL10'DIMACROSS '\n         DC   AL1(10),CL10'DIMENSION '\n         DC   AL1(07),CL07'DIRECT '\n         DC   AL1(08),CL08'DISPLAY '\n         DC   AL1(07),CL07'DIVIDE '\n         DC   AL1(03),CL03'DO '\n         DC   AL1(09),CL09'DOWNTHRU '\n         DC   AL1(05),CL05'EDIT '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(06),CL06'EMPTY '\n         DC   AL1(04),CL04'END '\n         DC   AL1(08),CL08'ENDFILE '\n         DC   AL1(08),CL08'ENDPAGE '\n         DC   AL1(06),CL06'ENTRY '\n         DC   AL1(10),CL10'ENTRYADDR '\n         DC   AL1(04),CL04'ENV '\n         DC   AL1(12),CL12'ENVIRONMENT '\n         DC   AL1(08),CL08'EPSILON '\n         DC   AL1(04),CL04'ERF '\n         DC   AL1(05),CL05'ERFC '\n         DC   AL1(06),CL06'ERROR '\n         DC   AL1(06),CL06'EVENT '\n         DC   AL1(05),CL05'EXCL '\n         DC   AL1(10),CL10'EXCLUSIVE '\n         DC   AL1(05),CL05'EXIT '\n         DC   AL1(04),CL04'EXP '\n         DC   AL1(09),CL09'EXPONENT '\n         DC   AL1(08),CL08'EXPORTS '\n         DC   AL1(04),CL04'EXT '\n         DC   AL1(09),CL09'EXTERNAL '\n         DC   AL1(06),CL06'FALSE '                  * CUCI PLI\n         DC   AL1(03),CL03'FB '\n         DC   AL1(04),CL04'FBS '\n         DC   AL1(06),CL06'FETCH '\n         DC   AL1(05),CL05'FILE '\n         DC   AL1(10),CL10'FILEDDINT '\n         DC   AL1(11),CL11'FILEDDTEST '\n         DC   AL1(11),CL11'FILEDDWORD '\n         DC   AL1(07),CL07'FILEID '\n         DC   AL1(08),CL08'FILENEW '                * CUCI PLI\n         DC   AL1(09),CL09'FILEOPEN '\n         DC   AL1(09),CL09'FILEREAD '\n         DC   AL1(09),CL09'FILESEEK '\n         DC   AL1(09),CL09'FILETELL '\n         DC   AL1(10),CL10'FILEWRITE '\n         DC   AL1(07),CL07'FINISH '\n         DC   AL1(06),CL06'FIRST '\n         DC   AL1(06),CL06'FIXED '\n         DC   AL1(09),CL09'FIXEDBIN '\n         DC   AL1(09),CL09'FIXEDDEC '\n         DC   AL1(14),CL14'FIXEDOVERFLOW '\n         DC   AL1(06),CL06'FLOAT '\n         DC   AL1(09),CL09'FLOATBIN '\n         DC   AL1(09),CL09'FLOATDEC '\n         DC   AL1(06),CL06'FLOOR '\n         DC   AL1(06),CL06'FLUSH '\n         DC   AL1(05),CL05'FOFL '\n         DC   AL1(16),CL16'FOLDEDFULLMATCH '        * CUCI PLI\n         DC   AL1(18),CL18'FOLDEDSIMPLEMATCH '      * CUCI PLI\n         DC   AL1(07),CL07'FORMAT '\n         DC   AL1(08),CL08'FORTRAN '\n         DC   AL1(05),CL05'FREE '\n         DC   AL1(05),CL05'FROM '\n         DC   AL1(10),CL10'FROMALIEN '\n         DC   AL1(03),CL03'FS '\n         DC   AL1(06),CL06'GAMMA '\n         DC   AL1(08),CL08'GENERIC '\n         DC   AL1(07),CL07'GENKEY '\n         DC   AL1(04),CL04'GET '\n         DC   AL1(07),CL07'GETENV '\n         DC   AL1(13),CL13'GETJCLSYMBOL '           * CUCI PLI\n         DC   AL1(10),CL10'GETSYSINT '              * CUCI PLI\n         DC   AL1(11),CL11'GETSYSWORD '             * CUCI PLI\n         DC   AL1(03),CL03'GO '\n         DC   AL1(05),CL05'GOTO '\n         DC   AL1(08),CL08'GRAPHIC '\n         DC   AL1(03),CL03'GX '\n         DC   AL1(07),CL07'HANDLE '\n         DC   AL1(07),CL07'HBOUND '\n         DC   AL1(13),CL13'HBOUNDACROSS '\n         DC   AL1(04),CL04'HEX '\n         DC   AL1(08),CL08'HEXADEC '\n         DC   AL1(10),CL10'HEXDECODE '              * CUCI PLI\n         DC   AL1(11),CL11'HEXDECODE8 '             * CUCI PLI\n         DC   AL1(09),CL09'HEXIMAGE '\n         DC   AL1(10),CL10'HEXIMAGE8 '              * CUCI PLI\n         DC   AL1(05),CL05'HEX8 '                   * CUCI PLI\n         DC   AL1(05),CL05'HIGH '\n         DC   AL1(05),CL05'HUGE '\n         DC   AL1(05),CL05'IAND '\n         DC   AL1(05),CL05'ICLZ '                   * CUCI PLI\n         DC   AL1(05),CL05'IEEE '\n         DC   AL1(05),CL05'IEOR '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(11),CL11'IFTHENELSE '             * CUCI PLI\n         DC   AL1(07),CL07'IGNORE '\n         DC   AL1(05),CL05'IMAG '\n         DC   AL1(03),CL03'IN '\n         DC   AL1(08),CL08'INARRAY '                * CUCI PLI\n         DC   AL1(07),CL07'INDFOR '                 * CUCI PLI\n         DC   AL1(06),CL06'INDEX '\n         DC   AL1(10),CL10'INDEXAREA '\n         DC   AL1(08),CL08'INDEXED '\n         DC   AL1(07),CL07'INDEXR '\n         DC   AL1(11),CL11'INDICATORS '\n         DC   AL1(05),CL05'INIT '\n         DC   AL1(08),CL08'INITIAL '\n         DC   AL1(07),CL07'INLINE '\n         DC   AL1(07),CL07'INLIST '                 * CUCI PLI\n         DC   AL1(07),CL07'INONLY '\n         DC   AL1(05),CL05'INOT '\n         DC   AL1(06),CL06'INOUT '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(04),CL04'INT '\n         DC   AL1(06),CL06'INTER '\n         DC   AL1(09),CL09'INTERNAL '\n         DC   AL1(05),CL05'INTO '\n         DC   AL1(10),CL10'INVALIDOP '\n         DC   AL1(04),CL04'IOR '\n         DC   AL1(06),CL06'IRRED '\n         DC   AL1(12),CL12'IRREDUCIBLE '\n         DC   AL1(09),CL09'ISFINITE '\n         DC   AL1(08),CL08'ISIGNED '\n         DC   AL1(06),CL06'ISINF '\n         DC   AL1(12),CL12'ISJCLSYMBOL '            * CUCI PLI\n         DC   AL1(05),CL05'ISLL '\n         DC   AL1(07),CL07'ISMAIN '\n         DC   AL1(06),CL06'ISNAN '\n         DC   AL1(09),CL09'ISNORMAL '\n         DC   AL1(05),CL05'ISRL '\n         DC   AL1(07),CL07'ISZERO '\n         DC   AL1(08),CL08'ITERATE '                * CUCI PLI\n         DC   AL1(10),CL10'IUNSIGNED '\n         DC   AL1(16),CL16'JSONGETARRAYEND '        * CUCI PLI\n         DC   AL1(18),CL18'JSONGETARRAYSTART '      * CUCI PLI\n         DC   AL1(13),CL13'JSONGETCOLON '           * CUCI PLI\n         DC   AL1(13),CL13'JSONGETCOMMA '           * CUCI PLI\n         DC   AL1(14),CL14'JSONGETMEMBER '          * CUCI PLI\n         DC   AL1(17),CL17'JSONGETOBJECTEND '       * CUCI PLI\n         DC   AL1(19),CL19'JSONGETOBJECTSTART '     * CUCI PLI\n         DC   AL1(13),CL13'JSONGETVALUE '           * CUCI PLI\n         DC   AL1(16),CL16'JSONPUTARRAYEND '        * CUCI PLI\n         DC   AL1(18),CL18'JSONPUTARRAYSTART '      * CUCI PLI\n         DC   AL1(13),CL13'JSONPUTCOLON '           * CUCI PLI\n         DC   AL1(13),CL13'JSONPUTCOMMA '           * CUCI PLI\n         DC   AL1(14),CL14'JSONPUTMEMBER '          * CUCI PLI\n         DC   AL1(17),CL17'JSONPUTOBJECTEND '       * CUCI PLI\n         DC   AL1(19),CL19'JSONPUTOBJECTSTART '     * CUCI PLI\n         DC   AL1(13),CL13'JSONPUTVALUE '           * CUCI PLI\n         DC   AL1(10),CL10'JSONVALID '              * CUCI PLI\n         DC   AL1(12),CL12'JULIANTOSMF '            * CUCI PLI\n         DC   AL1(04),CL04'KEY '\n         DC   AL1(06),CL06'KEYED '\n         DC   AL1(08),CL08'KEYFROM '\n         DC   AL1(10),CL10'KEYLENGTH '\n         DC   AL1(07),CL07'KEYLOC '\n         DC   AL1(06),CL06'KEYTO '\n         DC   AL1(06),CL06'LABEL '\n         DC   AL1(05),CL05'LAST '\n         DC   AL1(07),CL07'LBOUND '\n         DC   AL1(13),CL13'LBOUNDACROSS '\n         DC   AL1(06),CL06'LEAVE '\n         DC   AL1(05),CL05'LEFT '\n         DC   AL1(07),CL07'LENGTH '\n         DC   AL1(05),CL05'LIKE '\n         DC   AL1(08),CL08'LIMITED '\n         DC   AL1(05),CL05'LINE '\n         DC   AL1(07),CL07'LINENO '\n         DC   AL1(09),CL09'LINESIZE '\n         DC   AL1(08),CL08'LINKAGE '\n         DC   AL1(05),CL05'LIST '\n         DC   AL1(13),CL13'LITTLEENDIAN '\n         DC   AL1(04),CL04'LOC '\n         DC   AL1(07),CL07'LOCATE '\n         DC   AL1(08),CL08'LOCATES '\n         DC   AL1(09),CL09'LOCATION '\n         DC   AL1(12),CL12'LOCNEWSPACE '\n         DC   AL1(12),CL12'LOCNEWVALUE '\n         DC   AL1(07),CL07'LOCSTG '\n         DC   AL1(07),CL07'LOCVAL '\n         DC   AL1(04),CL04'LOG '\n         DC   AL1(09),CL09'LOGGAMMA '\n         DC   AL1(06),CL06'LOG10 '\n         DC   AL1(05),CL05'LOG2 '\n         DC   AL1(04),CL04'LOW '\n         DC   AL1(11),CL11'LOWERASCII '             * CUCI PLI\n         DC   AL1(10),CL10'LOWERCASE '\n         DC   AL1(12),CL12'LOWERLATIN1 '            * CUCI PLI\n         DC   AL1(07),CL07'LOWER2 '\n         DC   AL1(07),CL07'MACCOL '\n         DC   AL1(08),CL08'MACLMAR '\n         DC   AL1(08),CL08'MACNAME '\n         DC   AL1(08),CL08'MACRMAR '\n         DC   AL1(05),CL05'MAIN '\n         DC   AL1(09),CL09'MAINNAME '               * CUCI PLI\n         DC   AL1(04),CL04'MAR '                    * CUCI PLI\n         DC   AL1(04),CL04'MAX '\n         DC   AL1(08),CL08'MAXDATE '                * CUCI PLI\n         DC   AL1(07),CL07'MAXEXP '\n         DC   AL1(10),CL10'MAXLENGTH '\n         DC   AL1(07),CL07'MAXVAL '                 * CUCI PLI\n         DC   AL1(12),CL12'MEMCOLLAPSE '            * CUCI PLI\n         DC   AL1(11),CL11'MEMCONVERT '\n         DC   AL1(08),CL08'MEMCU12 '\n         DC   AL1(08),CL08'MEMCU14 '\n         DC   AL1(08),CL08'MEMCU21 '\n         DC   AL1(08),CL08'MEMCU24 '\n         DC   AL1(08),CL08'MEMCU41 '\n         DC   AL1(08),CL08'MEMCU42 '\n         DC   AL1(09),CL09'MEMINDEX '\n         DC   AL1(11),CL11'MEMREPLACE '             * CUCI PLI\n         DC   AL1(10),CL10'MEMSEARCH '\n         DC   AL1(11),CL11'MEMSEARCHR '\n         DC   AL1(11),CL11'MEMSQUEEZE '             * CUCI PLI\n         DC   AL1(10),CL10'MEMVERIFY '\n         DC   AL1(11),CL11'MEMVERIFYR '\n         DC   AL1(10),CL10'MICROSECS '              * CUCI PLI\n         DC   AL1(17),CL17'MICROSECSTODATE '        * CUCI PLI\n         DC   AL1(17),CL17'MICROSECSTODAYS '        * CUCI PLI\n         DC   AL1(04),CL04'MIN '\n         DC   AL1(08),CL08'MINDATE '                * CUCI PLI\n         DC   AL1(07),CL07'MINEXP '\n         DC   AL1(07),CL07'MINVAL '                 * CUCI PLI\n         DC   AL1(04),CL04'MOD '\n         DC   AL1(06),CL06'MPSTR '\n         DC   AL1(09),CL09'MULTIPLY '\n         DC   AL1(05),CL05'NAME '\n         DC   AL1(07),CL07'NATIVE '\n         DC   AL1(04),CL04'NCP '\n         DC   AL1(04),CL04'NEW '\n         DC   AL1(08),CL08'NOCHARG '\n         DC   AL1(14),CL14'NOCHARGRAPHIC '\n         DC   AL1(08),CL08'NOCHECK '\n         DC   AL1(08),CL08'NOCMPAT '\n         DC   AL1(07),CL07'NOCONV '\n         DC   AL1(13),CL13'NOCONVERSION '\n         DC   AL1(13),CL13'NODESCRIPTOR '\n         DC   AL1(10),CL10'NOEXECOPS '\n         DC   AL1(16),CL16'NOFIXEDOVERFLOW '\n         DC   AL1(07),CL07'NOFOFL '\n         DC   AL1(09),CL09'NOGLOBAL '               * CUCI PLI\n         DC   AL1(07),CL07'NOINIT '\n         DC   AL1(09),CL09'NOINLINE '\n         DC   AL1(07),CL07'NOLOCK '\n         DC   AL1(06),CL06'NOMAP '\n         DC   AL1(08),CL08'NOMAPIN '\n         DC   AL1(09),CL09'NOMAPOUT '\n         DC   AL1(08),CL08'NONASGN '\n         DC   AL1(14),CL14'NONASSIGNABLE '\n         DC   AL1(13),CL13'NONCONNECTED '\n         DC   AL1(08),CL08'NONCONN '\n         DC   AL1(07),CL07'NONVAR '\n         DC   AL1(11),CL11'NONVARYING '\n         DC   AL1(10),CL10'NONNATIVE '\n         DC   AL1(06),CL06'NOOFL '\n         DC   AL1(11),CL11'NOOVERFLOW '\n         DC   AL1(09),CL09'NORESCAN '\n         DC   AL1(07),CL07'NORMAL '\n         DC   AL1(07),CL07'NOSIZE '\n         DC   AL1(07),CL07'NOSTRG '\n         DC   AL1(14),CL14'NOSTRINGRANGE '\n         DC   AL1(13),CL13'NOSTRINGSIZE '\n         DC   AL1(07),CL07'NOSTRZ '\n         DC   AL1(08),CL08'NOSUBRG '\n         DC   AL1(17),CL17'NOSUBSCRIPTRANGE '\n         DC   AL1(06),CL06'NOUFL '\n         DC   AL1(12),CL12'NOUNDERFLOW '\n         DC   AL1(08),CL08'NOWRITE '\n         DC   AL1(07),CL07'NOZDIV '\n         DC   AL1(13),CL13'NOZERODIVIDE '\n         DC   AL1(05),CL05'NULL '\n         DC   AL1(10),CL10'NULLENTRY '               * CUCI PLI\n         DC   AL1(07),CL07'OFFSET '\n         DC   AL1(10),CL10'OFFSETADD '\n         DC   AL1(11),CL11'OFFSETDIFF '\n         DC   AL1(15),CL15'OFFSETSUBTRACT '\n         DC   AL1(12),CL12'OFFSETVALUE '\n         DC   AL1(04),CL04'OFL '\n         DC   AL1(08),CL08'OMITTED '\n         DC   AL1(03),CL03'ON '\n         DC   AL1(09),CL09'ONACTUAL '               * CUCI PLI\n         DC   AL1(07),CL07'ONAREA '\n         DC   AL1(07),CL07'ONCHAR '\n         DC   AL1(07),CL07'ONCODE '\n         DC   AL1(11),CL11'ONCONDCOND '\n         DC   AL1(09),CL09'ONCONDID '\n         DC   AL1(08),CL08'ONCOUNT '\n         DC   AL1(11),CL11'ONEXPECTED '             * CUCI PLI\n         DC   AL1(07),CL07'ONFILE '\n         DC   AL1(10),CL10'ONGSOURCE '\n         DC   AL1(06),CL06'ONKEY '\n         DC   AL1(07),CL07'ONLINE '\n         DC   AL1(06),CL06'ONLOC '\n         DC   AL1(09),CL09'ONOFFSET '\n         DC   AL1(11),CL11'ONOPERATOR '             * CUCI PLI\n         DC   AL1(10),CL10'ONPACKAGE '              * CUCI PLI\n         DC   AL1(07),CL07'ONPROC '                 * CUCI PLI\n         DC   AL1(12),CL12'ONPROCEDURE '            * CUCI PLI\n         DC   AL1(09),CL09'ONSOURCE '\n         DC   AL1(10),CL10'ONSUBCODE '\n         DC   AL1(11),CL11'ONSUBCODE2 '             * CUCI PLI\n         DC   AL1(07),CL07'ONTEXT '                 * CUCI PLI\n         DC   AL1(08),CL08'ONUCHAR '                * CUCI PLI\n         DC   AL1(10),CL10'ONUSOURCE '              * CUCI PLI\n         DC   AL1(08),CL08'ONWCHAR '\n         DC   AL1(10),CL10'ONWSOURCE '\n         DC   AL1(05),CL05'OPEN '\n         DC   AL1(09),CL09'OPTIONAL '\n         DC   AL1(08),CL08'OPTIONS '\n         DC   AL1(06),CL06'ORDER '\n         DC   AL1(08),CL08'ORDINAL '\n         DC   AL1(12),CL12'ORDINALNAME '\n         DC   AL1(12),CL12'ORDINALPRED '\n         DC   AL1(12),CL12'ORDINALSUCC '\n         DC   AL1(06),CL06'OTHER '\n         DC   AL1(10),CL10'OTHERWISE '\n         DC   AL1(07),CL07'OUTPUT '\n         DC   AL1(08),CL08'OUTONLY '\n         DC   AL1(09),CL09'OVERFLOW '\n         DC   AL1(08),CL08'PACKAGE '\n         DC   AL1(12),CL12'PACKAGENAME '\n         DC   AL1(05),CL05'PAGE '\n         DC   AL1(07),CL07'PAGENO '\n         DC   AL1(09),CL09'PAGESIZE '\n         DC   AL1(10),CL10'PARAMETER '\n         DC   AL1(08),CL08'PARMSET '\n         DC   AL1(09),CL09'PASSWORD '\n         DC   AL1(08),CL08'PENDING '\n         DC   AL1(04),CL04'PIC '\n         DC   AL1(08),CL08'PICSPEC '\n         DC   AL1(08),CL08'PICTURE '\n         DC   AL1(07),CL07'PLACES '\n         DC   AL1(09),CL09'PLIASCII '\n         DC   AL1(08),CL08'PLIATTN '                * CUCI PLI\n         DC   AL1(08),CL08'PLICANC '\n         DC   AL1(08),CL08'PLICKPT '\n         DC   AL1(10),CL10'PLIDELETE '\n         DC   AL1(08),CL08'PLIDUMP '\n         DC   AL1(10),CL10'PLIEBCDIC '\n         DC   AL1(08),CL08'PLIFILL '\n         DC   AL1(08),CL08'PLIFREE '\n         DC   AL1(08),CL08'PLIMOVE '\n         DC   AL1(08),CL08'PLIOVER '\n         DC   AL1(08),CL08'PLIREST '\n         DC   AL1(08),CL08'PLIRETC '\n         DC   AL1(08),CL08'PLIRETV '\n         DC   AL1(08),CL08'PLISAXA '\n         DC   AL1(08),CL08'PLISAXB '\n         DC   AL1(08),CL08'PLISAXC '\n         DC   AL1(08),CL08'PLISAXD '\n         DC   AL1(08),CL08'PLISRTA '\n         DC   AL1(08),CL08'PLISRTB '\n         DC   AL1(08),CL08'PLISRTC '\n         DC   AL1(08),CL08'PLISRTD '\n         DC   AL1(08),CL08'PLISTCK '                * CUCI PLI\n         DC   AL1(09),CL09'PLISTCKE '               * CUCI PLI\n         DC   AL1(14),CL14'PLISTCKELOCAL '          * CUCI PLI\n         DC   AL1(12),CL12'PLISTCKEUTC '            * CUCI PLI\n         DC   AL1(09),CL09'PLISTCKF '               * CUCI PLI\n         DC   AL1(13),CL13'PLISTCKLOCAL '           * CUCI PLI\n         DC   AL1(11),CL11'PLISTCKUTC '             * CUCI PLI\n         DC   AL1(08),CL08'PLITDLI '\n         DC   AL1(10),CL10'PLITRAN11 '\n         DC   AL1(10),CL10'PLITRAN12 '\n         DC   AL1(10),CL10'PLITRAN21 '\n         DC   AL1(10),CL10'PLITRAN22 '\n         DC   AL1(08),CL08'POINTER '\n         DC   AL1(11),CL11'POINTERADD '\n         DC   AL1(12),CL12'POINTERDIFF '\n         DC   AL1(16),CL16'POINTERSUBTRACT '\n         DC   AL1(13),CL13'POINTERVALUE '\n         DC   AL1(05),CL05'POLY '\n         DC   AL1(07),CL07'POPCNT '\n         DC   AL1(04),CL04'POS '\n         DC   AL1(09),CL09'POSITION '\n         DC   AL1(05),CL05'PREC '\n         DC   AL1(10),CL10'PRECISION '\n         DC   AL1(08),CL08'PRECVAL '                * CUCI PLI\n         DC   AL1(05),CL05'PRED '\n         DC   AL1(08),CL08'PRESENT '\n         DC   AL1(06),CL06'PRINT '\n         DC   AL1(09),CL09'PRIORITY '\n         DC   AL1(05),CL05'PROC '\n         DC   AL1(10),CL10'PROCEDURE '\n         DC   AL1(14),CL14'PROCEDURENAME '\n         DC   AL1(09),CL09'PROCNAME '\n         DC   AL1(05),CL05'PROD '\n         DC   AL1(04),CL04'PTR '\n         DC   AL1(07),CL07'PTRADD '\n         DC   AL1(08),CL08'PTRDIFF '\n         DC   AL1(12),CL12'PTRSUBTRACT '\n         DC   AL1(09),CL09'PTRVALUE '\n         DC   AL1(04),CL04'PUT '\n         DC   AL1(07),CL07'PUTENV '\n         DC   AL1(08),CL08'QUALIFY '                * CUCI PLI\n         DC   AL1(10),CL10'QUICKSORT '              * CUCI PLI\n         DC   AL1(11),CL11'QUICKSORTX '             * CUCI PLI\n         DC   AL1(06),CL06'QUOTE '\n         DC   AL1(06),CL06'RADIX '\n         DC   AL1(07),CL07'RAISE2 '\n         DC   AL1(07),CL07'RANDOM '\n         DC   AL1(06),CL06'RANGE '\n         DC   AL1(05),CL05'RANK '\n         DC   AL1(05),CL05'READ '\n         DC   AL1(05),CL05'REAL '\n         DC   AL1(07),CL07'RECORD '\n         DC   AL1(08),CL08'RECSIZE '\n         DC   AL1(10),CL10'RECURSIVE '\n         DC   AL1(04),CL04'RED '\n         DC   AL1(10),CL10'REDUCIBLE '\n         DC   AL1(10),CL10'REENTRANT '\n         DC   AL1(06),CL06'REFER '\n         DC   AL1(09),CL09'REGIONAL '\n         DC   AL1(06),CL06'REG12 '\n         DC   AL1(06),CL06'REGEX '                  * CUCI PLI\n         DC   AL1(07),CL07'REINIT '                 * CUCI PLI\n         DC   AL1(08),CL08'RELEASE '\n         DC   AL1(04),CL04'REM '\n         DC   AL1(08),CL08'REORDER '\n         DC   AL1(10),CL10'REPATTERN '\n         DC   AL1(07),CL07'REPEAT '\n         DC   AL1(08),CL08'REPLACE '                * CUCI PLI\n         DC   AL1(11),CL11'REPLACEBY2 '\n         DC   AL1(06),CL06'REPLY '\n         DC   AL1(07),CL07'REREAD '\n         DC   AL1(07),CL07'RESCAN '\n         DC   AL1(09),CL09'RESERVED '\n         DC   AL1(09),CL09'RESERVES '\n         DC   AL1(09),CL09'RESIGNAL '\n         DC   AL1(07),CL07'RESPEC '\n         DC   AL1(08),CL08'RETCODE '\n         DC   AL1(07),CL07'RETURN '\n         DC   AL1(08),CL08'RETURNS '\n         DC   AL1(06),CL06'REUSE '\n         DC   AL1(08),CL08'REVERSE '\n         DC   AL1(07),CL07'REVERT '\n         DC   AL1(08),CL08'REWRITE '\n         DC   AL1(06),CL06'RIGHT '\n         DC   AL1(06),CL06'ROUND '\n         DC   AL1(18),CL18'ROUNDAWAYFROMZERO '      * CUCI PLI\n         DC   AL1(09),CL09'ROUNDDEC '\n         DC   AL1(12),CL12'ROUNDTOEVEN '            * CUCI PLI\n         DC   AL1(08),CL08'ROUTCDE '                * CUCI PLI\n         DC   AL1(08),CL08'SAMEKEY '\n         DC   AL1(14),CL14'SCALARVARYING '\n         DC   AL1(09),CL09'SCRUBOUT '               * CUCI PLI\n         DC   AL1(06),CL06'SCALE '\n         DC   AL1(09),CL09'SCALEVAL '               * CUCI PLI\n         DC   AL1(07),CL07'SEARCH '\n         DC   AL1(08),CL08'SEARCHR '\n         DC   AL1(05),CL05'SECS '\n         DC   AL1(11),CL11'SECSTODATE '\n         DC   AL1(11),CL11'SECSTODAYS '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(05),CL05'SEQL '\n         DC   AL1(11),CL11'SEQUENTIAL '\n         DC   AL1(11),CL11'SERIALIZE4 '\n         DC   AL1(04),CL04'SET '\n         DC   AL1(05),CL05'SIGN '\n         DC   AL1(07),CL07'SIGNAL '\n         DC   AL1(07),CL07'SIGNED '\n         DC   AL1(04),CL04'SIN '\n         DC   AL1(05),CL05'SIND '\n         DC   AL1(05),CL05'SINH '\n         DC   AL1(04),CL04'SIS '\n         DC   AL1(05),CL05'SIZE '\n         DC   AL1(05),CL05'SKIP '\n         DC   AL1(12),CL12'SMFTOJULIAN '            * CUCI PLI\n         DC   AL1(05),CL05'SNAP '\n         DC   AL1(11),CL11'SOURCEFILE '\n         DC   AL1(11),CL11'SOURCELINE '\n         DC   AL1(05),CL05'SQRT '\n         DC   AL1(06),CL06'SQRTF '\n         DC   AL1(10),CL10'STACKADDR '\n         DC   AL1(12),CL12'STCKETODATE '            * CUCI PLI\n         DC   AL1(11),CL11'STCKTODATE '             * CUCI PLI\n         DC   AL1(10),CL10'STATEMENT '\n         DC   AL1(07),CL07'STATIC '\n         DC   AL1(07),CL07'STATUS '\n         DC   AL1(04),CL04'STG '\n         DC   AL1(05),CL05'STMT '\n         DC   AL1(05),CL05'STOP '\n         DC   AL1(08),CL08'STORAGE '\n         DC   AL1(07),CL07'STREAM '\n         DC   AL1(05),CL05'STRG '\n         DC   AL1(07),CL07'STRING '\n         DC   AL1(12),CL12'STRINGRANGE '\n         DC   AL1(11),CL11'STRINGSIZE '\n         DC   AL1(07),CL07'STRUCT '                 * CUCI PLI\n         DC   AL1(10),CL10'STRUCTURE '\n         DC   AL1(05),CL05'STRZ '\n         DC   AL1(06),CL06'SUBRG '\n         DC   AL1(15),CL15'SUBSCRIPTRANGE '\n         DC   AL1(07),CL07'SUBSTR '\n         DC   AL1(09),CL09'SUBTRACT '\n         DC   AL1(05),CL05'SUCC '\n         DC   AL1(04),CL04'SUM '\n         DC   AL1(09),CL09'SUPPRESS '\n         DC   AL1(11),CL11'SYSDIMSIZE '             * CUCI PLI\n         DC   AL1(06),CL06'SYSIN '\n         DC   AL1(08),CL08'SYSNULL '\n         DC   AL1(14),CL14'SYSOFFSETSIZE '          * CUCI PLI\n         DC   AL1(08),CL08'SYSPARM '\n         DC   AL1(15),CL15'SYSPOINTERSIZE '         * CUCI PLI\n         DC   AL1(09),CL09'SYSPRINT '\n         DC   AL1(07),CL07'SYSTEM '\n         DC   AL1(11),CL11'SYSVERSION '\n         DC   AL1(06),CL06'TALLY '\n         DC   AL1(04),CL04'TAN '\n         DC   AL1(05),CL05'TAND '\n         DC   AL1(05),CL05'TANH '\n         DC   AL1(05),CL05'TASK '\n         DC   AL1(05),CL05'TEXT '                   * CUCI PLI\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(07),CL07'THREAD '\n         DC   AL1(09),CL09'THREADID '\n         DC   AL1(05),CL05'TIME '\n         DC   AL1(10),CL10'TIMESTAMP '              * CUCI PLI\n         DC   AL1(05),CL05'TINY '\n         DC   AL1(06),CL06'TITLE '\n         DC   AL1(03),CL03'TO '\n         DC   AL1(06),CL06'TOTAL '\n         DC   AL1(04),CL04'TPK '\n         DC   AL1(04),CL04'TPM '\n         DC   AL1(10),CL10'TRANSIENT '\n         DC   AL1(10),CL10'TRANSLATE '\n         DC   AL1(09),CL09'TRANSMIT '\n         DC   AL1(05),CL05'TRIM '\n         DC   AL1(07),CL07'TRKOFL '\n         DC   AL1(05),CL05'TRUE '                   * CUCI PLI\n         DC   AL1(06),CL06'TRUNC '\n         DC   AL1(05),CL05'TYPE '\n         DC   AL1(06),CL06'UCHAR '                  * CUCI PLI\n         DC   AL1(04),CL04'UFL '\n         DC   AL1(06),CL06'UHIGH '                  * CUCI PLI\n         DC   AL1(08),CL08'ULENGTH '\n         DC   AL1(10),CL10'ULENGTH16 '\n         DC   AL1(09),CL09'ULENGTH8 '\n         DC   AL1(05),CL05'ULOW '                   * CUCI PLI\n         DC   AL1(05),CL05'UNAL '\n         DC   AL1(10),CL10'UNALIGNED '\n         DC   AL1(12),CL12'UNALLOCATED '\n         DC   AL1(06),CL06'UNBUF '\n         DC   AL1(11),CL11'UNBUFFERED '\n         DC   AL1(14),CL14'UNDEFINEDFILE '\n         DC   AL1(10),CL10'UNDERFLOW '\n         DC   AL1(05),CL05'UNDF '\n         DC   AL1(06),CL06'UNHEX '                  * CUCI PLI\n         DC   AL1(07),CL07'UNLOCK '\n         DC   AL1(06),CL06'UNION '\n         DC   AL1(12),CL12'UNREACHABLE '            * CUCI PLI\n         DC   AL1(09),CL09'UNSIGNED '\n         DC   AL1(07),CL07'UNSPEC '\n         DC   AL1(06),CL06'UNTIL '\n         DC   AL1(07),CL07'UPDATE '\n         DC   AL1(05),CL05'UPOS '\n         DC   AL1(11),CL11'UPPERASCII '             * CUCI PLI\n         DC   AL1(10),CL10'UPPERCASE '\n         DC   AL1(12),CL12'UPPERLATIN1 '            * CUCI PLI\n         DC   AL1(07),CL07'UPTHRU '\n         DC   AL1(08),CL08'USUBSTR '\n         DC   AL1(15),CL15'USUPPLEMENTARY '\n         DC   AL1(12),CL12'UTCDATETIME '            * CUCI PLI\n         DC   AL1(13),CL13'UTCMICROSECS '           * CUCI PLI\n         DC   AL1(08),CL08'UTCSECS '                * CUCI PLI\n         DC   AL1(05),CL05'UTF8 '\n         DC   AL1(08),CL08'UTF8STG '                * CUCI PLI\n         DC   AL1(11),CL11'UTF8TOCHAR '\n         DC   AL1(12),CL12'UTF8TOWCHAR '\n         DC   AL1(05),CL05'UUID '                   * CUCI PLI\n         DC   AL1(06),CL06'UUID4 '                  * CUCI PLI\n         DC   AL1(07),CL07'UVALID '\n         DC   AL1(07),CL07'UWIDTH '\n         DC   AL1(03),CL03'UX '                     * CUCI PLI\n         DC   AL1(06),CL06'VALID '\n         DC   AL1(10),CL10'VALIDDATE '\n         DC   AL1(11),CL11'VALIDVALUE '             * CUCI PLI\n         DC   AL1(06),CL06'VALUE '\n         DC   AL1(10),CL10'VALUELIST '              * CUCI PLI\n         DC   AL1(14),CL14'VALUELISTFROM '          * CUCI PLI\n         DC   AL1(11),CL11'VALUERANGE '             * CUCI PLI\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(09),CL09'VARGLIST '\n         DC   AL1(09),CL09'VARGSIZE '\n         DC   AL1(09),CL09'VARIABLE '\n         DC   AL1(08),CL08'VARYING '\n         DC   AL1(09),CL09'VARYINGZ '\n         DC   AL1(09),CL09'VARYING4 '               * CUCI PLI\n         DC   AL1(05),CL05'VARZ '\n         DC   AL1(03),CL03'VB '\n         DC   AL1(04),CL04'VBS '\n         DC   AL1(07),CL07'VERIFY '\n         DC   AL1(08),CL08'VERIFYR '\n         DC   AL1(03),CL03'VS '\n         DC   AL1(05),CL05'VSAM '\n         DC   AL1(05),CL05'WAIT '\n         DC   AL1(06),CL06'WCHAR '\n         DC   AL1(09),CL09'WCHARVAL '\n         DC   AL1(08),CL08'WEEKDAY '\n         DC   AL1(05),CL05'WHEN '\n         DC   AL1(06),CL06'WHIGH '\n         DC   AL1(06),CL06'WHILE '\n         DC   AL1(19),CL19'WHITESPACECOLLAPSE '\n         DC   AL1(18),CL18'WHITESPACEREPLACE '\n         DC   AL1(09),CL09'WIDECHAR '\n         DC   AL1(08),CL08'WIDEPIC '\n         DC   AL1(05),CL05'WLOW '\n         DC   AL1(06),CL06'WRITE '\n         DC   AL1(11),CL11'WSCOLLAPSE '             * CUCI PLI\n         DC   AL1(13),CL13'WSCOLLAPSE16 '           * CUCI PLI\n         DC   AL1(10),CL10'WSREPLACE '              * CUCI PLI\n         DC   AL1(12),CL12'WSREPLACE16 '            * CUCI PLI\n         DC   AL1(08),CL08'XDEFINE '                * CUCI PLI\n         DC   AL1(08),CL08'XMLATTR '                * CUCI PLI\n         DC   AL1(08),CL08'XMLCHAR '\n         DC   AL1(09),CL09'XMLCLEAN '\n         DC   AL1(08),CL08'XMLOMIT '                * CUCI PLI\n         DC   AL1(09),CL09'XMLSCRUB '               * CUCI PLI\n         DC   AL1(11),CL11'XMLSCRUB16 '             * CUCI PLI\n         DC   AL1(11),CL11'XPROCEDURE '             * CUCI PLI\n         DC   AL1(06),CL06'XPROC '                  * CUCI PLI\n         DC   AL1(07),CL07'Y4DATE '\n         DC   AL1(09),CL09'Y4JULIAN '\n         DC   AL1(07),CL07'Y4YEAR '\n         DC   AL1(05),CL05'ZDIV '\n         DC   AL1(11),CL11'ZERODIVIDE '\n         DC   AL1(0)\n         END\nISRPXPSC CSECT ,\nISRPXPSC AMODE 31\nISRPXPSC RMODE ANY\n*  ISRPXPSC: 79 Keywords\n*  504 bytes\n*\n         DC   AL1(04),CL04'ABS '\n         DC   AL1(04),CL04'AND '\n         DC   AL1(07),CL07'ARCTAN '\n         DC   AL1(06),CL06'ARRAY '\n         DC   AL1(06),CL06'BEGIN '\n         DC   AL1(08),CL08'BOOLEAN '\n         DC   AL1(05),CL05'CASE '\n         DC   AL1(05),CL05'CHAR '\n         DC   AL1(04),CL04'CHR '\n         DC   AL1(06),CL06'CONST '\n         DC   AL1(04),CL04'COS '\n         DC   AL1(08),CL08'DISPOSE '\n         DC   AL1(04),CL04'DIV '\n         DC   AL1(03),CL03'DO '\n         DC   AL1(07),CL07'DOWNTO '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(04),CL04'END '\n         DC   AL1(04),CL04'EOF '\n         DC   AL1(05),CL05'EOLN '\n         DC   AL1(04),CL04'EXP '\n         DC   AL1(06),CL06'FALSE '\n         DC   AL1(05),CL05'FILE '\n         DC   AL1(04),CL04'FOR '\n         DC   AL1(09),CL09'FUNCTION '\n         DC   AL1(04),CL04'GET '\n         DC   AL1(05),CL05'GOTO '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(03),CL03'IN '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(08),CL08'INTEGER '\n         DC   AL1(06),CL06'LABEL '\n         DC   AL1(03),CL03'LN '\n         DC   AL1(08),CL08'LSTRING '\n         DC   AL1(07),CL07'MAXINT '\n         DC   AL1(04),CL04'MOD '\n         DC   AL1(04),CL04'NEW '\n         DC   AL1(04),CL04'NIL '\n         DC   AL1(04),CL04'NOT '\n         DC   AL1(04),CL04'ODD '\n         DC   AL1(03),CL03'OF '\n         DC   AL1(03),CL03'OR '\n         DC   AL1(04),CL04'ORD '\n         DC   AL1(10),CL10'OTHERWISE '\n         DC   AL1(07),CL07'OUTPUT '\n         DC   AL1(05),CL05'PACK '\n         DC   AL1(07),CL07'PACKED '\n         DC   AL1(05),CL05'PAGE '\n         DC   AL1(05),CL05'PRED '\n         DC   AL1(10),CL10'PROCEDURE '\n         DC   AL1(08),CL08'PROGRAM '\n         DC   AL1(04),CL04'PUT '\n         DC   AL1(05),CL05'READ '\n         DC   AL1(07),CL07'READLN '\n         DC   AL1(05),CL05'REAL '\n         DC   AL1(07),CL07'RECORD '\n         DC   AL1(07),CL07'REPEAT '\n         DC   AL1(06),CL06'RESET '\n         DC   AL1(08),CL08'REWRITE '\n         DC   AL1(06),CL06'ROUND '\n         DC   AL1(04),CL04'SET '\n         DC   AL1(04),CL04'SIN '\n         DC   AL1(04),CL04'SQR '\n         DC   AL1(05),CL05'SQRT '\n         DC   AL1(07),CL07'STRING '\n         DC   AL1(05),CL05'SUCC '\n         DC   AL1(05),CL05'TEXT '\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(03),CL03'TO '\n         DC   AL1(05),CL05'TRUE '\n         DC   AL1(05),CL05'TYPE '\n         DC   AL1(07),CL07'UNPACK '\n         DC   AL1(06),CL06'UNTIL '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(06),CL06'WHILE '\n         DC   AL1(05),CL05'WITH '\n         DC   AL1(05),CL05'WORD '\n         DC   AL1(06),CL06'WRITE '\n         DC   AL1(08),CL08'WRITELN '\n         DC   AL1(04),CL04'XOR '\n         DC   AL1(0)\n         END\nISRPXREX CSECT ,\nISRPXREX AMODE 31\nISRPXREX RMODE ANY\n*  ISRPXREX: 129 Keywords\n*  961 bytes\n*\n         DC   AL1(07),CL07'ABBREV '\n         DC   AL1(04),CL04'ABS '\n         DC   AL1(08),CL08'ADDRESS '\n         DC   AL1(04),CL04'ARG '\n         DC   AL1(07),CL07'BITAND '\n         DC   AL1(06),CL06'BITOR '\n         DC   AL1(07),CL07'BITXOR '\n         DC   AL1(03),CL03'BY '\n         DC   AL1(04),CL04'B2X '\n         DC   AL1(05),CL05'CALL '\n         DC   AL1(07),CL07'CENTER '\n         DC   AL1(07),CL07'CENTRE '\n         DC   AL1(08),CL08'COMPARE '\n         DC   AL1(10),CL10'CONDITION '\n         DC   AL1(07),CL07'COPIES '\n         DC   AL1(04),CL04'C2D '\n         DC   AL1(04),CL04'C2X '\n         DC   AL1(09),CL09'DATATYPE '\n         DC   AL1(05),CL05'DATE '\n         DC   AL1(05),CL05'DBCS '\n         DC   AL1(07),CL07'DELSTR '\n         DC   AL1(08),CL08'DELWORD '\n         DC   AL1(07),CL07'DIGITS '\n         DC   AL1(03),CL03'DO '\n         DC   AL1(05),CL05'DROP '\n         DC   AL1(04),CL04'D2C '\n         DC   AL1(04),CL04'D2X '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(04),CL04'END '\n         DC   AL1(12),CL12'ENGINEERING '\n         DC   AL1(06),CL06'ERROR '\n         DC   AL1(10),CL10'ERRORTEXT '\n         DC   AL1(05),CL05'EXIT '\n         DC   AL1(07),CL07'EXPOSE '\n         DC   AL1(09),CL09'EXTERNAL '\n         DC   AL1(10),CL10'EXTERNALS '\n         DC   AL1(08),CL08'FAILURE '\n         DC   AL1(05),CL05'FIND '\n         DC   AL1(04),CL04'FOR '\n         DC   AL1(08),CL08'FOREVER '\n         DC   AL1(05),CL05'FORM '\n         DC   AL1(07),CL07'FORMAT '\n         DC   AL1(05),CL05'FUZZ '\n         DC   AL1(07),CL07'GETMSG '\n         DC   AL1(05),CL05'HALT '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(06),CL06'INDEX '\n         DC   AL1(07),CL07'INSERT '\n         DC   AL1(10),CL10'INTERPRET '\n         DC   AL1(08),CL08'ITERATE '\n         DC   AL1(08),CL08'JUSTIFY '\n         DC   AL1(08),CL08'LASTPOS '\n         DC   AL1(06),CL06'LEAVE '\n         DC   AL1(05),CL05'LEFT '\n         DC   AL1(07),CL07'LENGTH '\n         DC   AL1(09),CL09'LINESIZE '\n         DC   AL1(08),CL08'LISTDSI '\n         DC   AL1(04),CL04'MAX '\n         DC   AL1(04),CL04'MIN '\n         DC   AL1(04),CL04'MSG '\n         DC   AL1(07),CL07'MVSVAR '\n         DC   AL1(04),CL04'NOP '\n         DC   AL1(08),CL08'NOVALUE '\n         DC   AL1(08),CL08'NUMERIC '\n         DC   AL1(04),CL04'OFF '\n         DC   AL1(03),CL03'ON '\n         DC   AL1(08),CL08'OPTIONS '\n         DC   AL1(10),CL10'OTHERWISE '\n         DC   AL1(08),CL08'OUTTRAP '\n         DC   AL1(08),CL08'OVERLAY '\n         DC   AL1(06),CL06'PARSE '\n         DC   AL1(04),CL04'POS '\n         DC   AL1(10),CL10'PROCEDURE '\n         DC   AL1(07),CL07'PROMPT '\n         DC   AL1(05),CL05'PULL '\n         DC   AL1(05),CL05'PUSH '\n         DC   AL1(06),CL06'QUEUE '\n         DC   AL1(07),CL07'QUEUED '\n         DC   AL1(07),CL07'RANDOM '\n         DC   AL1(03),CL03'RC '\n         DC   AL1(07),CL07'RESULT '\n         DC   AL1(07),CL07'RETURN '\n         DC   AL1(08),CL08'REVERSE '\n         DC   AL1(06),CL06'RIGHT '\n         DC   AL1(04),CL04'SAY '\n         DC   AL1(11),CL11'SCIENTIFIC '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(08),CL08'SETLANG '\n         DC   AL1(05),CL05'SIGL '\n         DC   AL1(05),CL05'SIGN '\n         DC   AL1(07),CL07'SIGNAL '\n         DC   AL1(07),CL07'SOURCE '\n         DC   AL1(11),CL11'SOURCELINE '\n         DC   AL1(06),CL06'SPACE '\n         DC   AL1(08),CL08'STORAGE '\n         DC   AL1(06),CL06'STRIP '\n         DC   AL1(07),CL07'SUBSTR '\n         DC   AL1(08),CL08'SUBWORD '\n         DC   AL1(07),CL07'SYMBOL '\n         DC   AL1(07),CL07'SYNTAX '\n         DC   AL1(08),CL08'SYSCPUS '\n         DC   AL1(07),CL07'SYSDSN '\n         DC   AL1(07),CL07'SYSVAR '\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(05),CL05'TIME '\n         DC   AL1(03),CL03'TO '\n         DC   AL1(06),CL06'TRACE '\n         DC   AL1(10),CL10'TRANSLATE '\n         DC   AL1(08),CL08'TRAPMSG '\n         DC   AL1(06),CL06'TRUNC '\n         DC   AL1(06),CL06'UNTIL '\n         DC   AL1(06),CL06'UPPER '\n         DC   AL1(07),CL07'USERID '\n         DC   AL1(06),CL06'VALUE '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(07),CL07'VERIFY '\n         DC   AL1(08),CL08'VERSION '\n         DC   AL1(05),CL05'WHEN '\n         DC   AL1(06),CL06'WHILE '\n         DC   AL1(05),CL05'WITH '\n         DC   AL1(05),CL05'WORD '\n         DC   AL1(10),CL10'WORDINDEX '\n         DC   AL1(11),CL11'WORDLENGTH '\n         DC   AL1(08),CL08'WORDPOS '\n         DC   AL1(06),CL06'WORDS '\n         DC   AL1(07),CL07'XRANGE '\n         DC   AL1(04),CL04'X2B '\n         DC   AL1(04),CL04'X2C '\n         DC   AL1(04),CL04'X2D '\n         DC   AL1(0)\n         END\nISRPXSCR CSECT ,\nISRPXSCR AMODE 31\nISRPXSCR RMODE ANY\n*  ISRPXSCR: 109 Keywords\n*  834 bytes\n*\n         DC   AL1(09),CL09':ADDRESS '\n         DC   AL1(07),CL07':ANNOT '\n         DC   AL1(05),CL05':APL '\n         DC   AL1(08),CL08':ARTALT '\n         DC   AL1(05),CL05':BIN '\n         DC   AL1(09),CL09':CAUTION '\n         DC   AL1(10),CL10':CGRAPHIC '\n         DC   AL1(06),CL06':CHAR '\n         DC   AL1(05),CL05':CIT '\n         DC   AL1(09),CL09':CLETTER '\n         DC   AL1(07),CL07':CODEL '\n         DC   AL1(07),CL07':COMPL '\n         DC   AL1(08),CL08':DANGER '\n         DC   AL1(09),CL09':DATAOBJ '\n         DC   AL1(04),CL04':DF '\n         DC   AL1(08),CL08':DIALOG '\n         DC   AL1(08),CL08':DIRECT '\n         DC   AL1(04),CL04':DL '\n         DC   AL1(03),CL03':F '\n         DC   AL1(05),CL05':FIG '\n         DC   AL1(04),CL04':FN '\n         DC   AL1(10),CL10':FRAGMENT '\n         DC   AL1(06),CL06':GDOC '\n         DC   AL1(04),CL04':GL '\n         DC   AL1(06),CL06':GRID '\n         DC   AL1(07),CL07':GROUP '\n         DC   AL1(05),CL05':HEX '\n         DC   AL1(05),CL05':HP0 '\n         DC   AL1(05),CL05':HP1 '\n         DC   AL1(05),CL05':HP2 '\n         DC   AL1(05),CL05':HP3 '\n         DC   AL1(05),CL05':HP4 '\n         DC   AL1(05),CL05':HP5 '\n         DC   AL1(05),CL05':HP6 '\n         DC   AL1(05),CL05':HP7 '\n         DC   AL1(05),CL05':HP8 '\n         DC   AL1(05),CL05':HP9 '\n         DC   AL1(06),CL06':IBMX '\n         DC   AL1(03),CL03':L '\n         DC   AL1(08),CL08':LBLBOX '\n         DC   AL1(05),CL05':LEN '\n         DC   AL1(06),CL06':LERS '\n         DC   AL1(07),CL07':LINES '\n         DC   AL1(09),CL09':LITDATA '\n         DC   AL1(04),CL04':LQ '\n         DC   AL1(05),CL05':MAP '\n         DC   AL1(09),CL09':MAPQFIX '\n         DC   AL1(10),CL10':MARKDESC '\n         DC   AL1(08),CL08':MARKNT '\n         DC   AL1(04),CL04':MD '\n         DC   AL1(06),CL06':MSGL '\n         DC   AL1(04),CL04':MV '\n         DC   AL1(07),CL07':NOTEL '\n         DC   AL1(09),CL09':NOTICES '\n         DC   AL1(04),CL04':NT '\n         DC   AL1(04),CL04':OL '\n         DC   AL1(09),CL09':OVERLAY '\n         DC   AL1(07),CL07':PARML '\n         DC   AL1(06),CL06':PART '\n         DC   AL1(10),CL10':PARTSASM '\n         DC   AL1(04),CL04':PK '\n         DC   AL1(08),CL08':PNCDOC '\n         DC   AL1(08),CL08':PROLOG '\n         DC   AL1(05),CL05':PSC '\n         DC   AL1(06),CL06':PTOC '\n         DC   AL1(04),CL04':PV '\n         DC   AL1(03),CL03':Q '\n         DC   AL1(08),CL08':QUALIF '\n         DC   AL1(10),CL10':QUESTION '\n         DC   AL1(05),CL05':REV '\n         DC   AL1(07),CL07':REVCW '\n         DC   AL1(07),CL07':REVPF '\n         DC   AL1(07),CL07':REVPP '\n         DC   AL1(07),CL07':REVPT '\n         DC   AL1(09),CL09':REVSLUG '\n         DC   AL1(04),CL04':RK '\n         DC   AL1(10),CL10':SCHEDULE '\n         DC   AL1(08),CL08':SCREEN '\n         DC   AL1(04),CL04':SL '\n         DC   AL1(09),CL09':SNOTICE '\n         DC   AL1(08),CL08':STDDOC '\n         DC   AL1(06),CL06':STEP '\n         DC   AL1(05),CL05':SUB '\n         DC   AL1(05),CL05':SUP '\n         DC   AL1(07),CL07':SYNNT '\n         DC   AL1(10),CL10':SYNOPSIS '\n         DC   AL1(08),CL08':SYNTAX '\n         DC   AL1(09),CL09':TABDATA '\n         DC   AL1(07),CL07':TABLE '\n         DC   AL1(07),CL07':TDESC '\n         DC   AL1(05),CL05':TFT '\n         DC   AL1(05),CL05':THD '\n         DC   AL1(07),CL07':TNOTE '\n         DC   AL1(04),CL04':TP '\n         DC   AL1(04),CL04':UL '\n         DC   AL1(09),CL09':USERDOC '\n         DC   AL1(09),CL09':VNOTICE '\n         DC   AL1(09),CL09':WARNING '\n         DC   AL1(05),CL05':XMP '\n         DC   AL1(05),CL05':XPH '\n         DC   AL1(09),CL09':ZCOVDEF '\n         DC   AL1(10),CL10':ZFONTDEF '\n         DC   AL1(10),CL10':ZHEADDEF '\n         DC   AL1(08),CL08':ZLODEF '\n         DC   AL1(08),CL08':ZRFDEF '\n         DC   AL1(08),CL08':ZRHDEF '\n         DC   AL1(10),CL10':ZRULEDEF '\n         DC   AL1(08),CL08':ZSTYLE '\n         DC   AL1(09),CL09':ZTOCDEF '\n         DC   AL1(0)\n         END\nISRPXPLX CSECT ,\nISRPXPLX AMODE 31\nISRPXPLX RMODE ANY\n*  ISRPXPLX: 356 Keywords\n*  2987 bytes\n*\n         DC   AL1(08),CL08'@INLINE '\n         DC   AL1(10),CL10'@NOINLINE '\n         DC   AL1(05),CL05'ABNL '\n         DC   AL1(09),CL09'ABNORMAL '\n         DC   AL1(06),CL06'ABOVE '\n         DC   AL1(04),CL04'ABS '\n         DC   AL1(04),CL04'ACT '\n         DC   AL1(09),CL09'ACTIVATE '\n         DC   AL1(05),CL05'ADDR '\n         DC   AL1(08),CL08'ADDROFF '\n         DC   AL1(05),CL05'ALET '\n         DC   AL1(10),CL10'ALIGNMENT '\n         DC   AL1(06),CL06'AMODE '\n         DC   AL1(04),CL04'ANS '\n         DC   AL1(07),CL07'ANSWER '\n         DC   AL1(04),CL04'ANY '\n         DC   AL1(03),CL03'AR '\n         DC   AL1(09),CL09'ARCHSIZE '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(08),CL08'ARGADDR '\n         DC   AL1(09),CL09'ARGCOUNT '\n         DC   AL1(03),CL03'AS '\n         DC   AL1(05),CL05'AUTO '\n         DC   AL1(09),CL09'AUTODATA '\n         DC   AL1(10),CL10'AUTOMATIC '\n         DC   AL1(09),CL09'AUTOSIZE '\n         DC   AL1(06),CL06'BASED '\n         DC   AL1(04),CL04'BDY '\n         DC   AL1(06),CL06'BEGIN '\n         DC   AL1(06),CL06'BELOW '\n         DC   AL1(04),CL04'BIN '\n         DC   AL1(07),CL07'BINARY '\n         DC   AL1(04),CL04'BIT '\n         DC   AL1(07),CL07'BIT_OF '\n         DC   AL1(07),CL07'BITPOS '\n         DC   AL1(12),CL12'BLOCKANSWER '\n         DC   AL1(09),CL09'BOUNDARY '\n         DC   AL1(08),CL08'BUILTIN '\n         DC   AL1(03),CL03'BY '\n         DC   AL1(07),CL07'BYADDR '\n         DC   AL1(10),CL10'BYADDROFF '\n         DC   AL1(09),CL09'BYOFFSET '\n         DC   AL1(05),CL05'BYTE '\n         DC   AL1(08),CL08'BYVALUE '\n         DC   AL1(10),CL10'BYVIAADDR '\n         DC   AL1(12),CL12'CACHELNEXCL '\n         DC   AL1(05),CL05'CALC '\n         DC   AL1(05),CL05'CALL '\n         DC   AL1(11),CL11'CALLASSIST '\n         DC   AL1(06),CL06'CAP24 '\n         DC   AL1(06),CL06'CAP31 '\n         DC   AL1(05),CL05'CHAR '\n         DC   AL1(08),CL08'CHAR_OF '\n         DC   AL1(10),CL10'CHARACTER '\n         DC   AL1(06),CL06'CLASS '\n         DC   AL1(05),CL05'CODE '\n         DC   AL1(08),CL08'CODENUM '\n         DC   AL1(08),CL08'CODEREG '\n         DC   AL1(04),CL04'COL '\n         DC   AL1(07),CL07'COLUMN '\n         DC   AL1(08),CL08'COMMENT '\n         DC   AL1(07),CL07'COMMON '\n         DC   AL1(05),CL05'COND '\n         DC   AL1(13),CL13'CONDCODEMASK '\n         DC   AL1(09),CL09'CONSTANT '\n         DC   AL1(07),CL07'CONSTR '\n         DC   AL1(12),CL12'CONSTRAINED '\n         DC   AL1(10),CL10'COPYRIGHT '\n         DC   AL1(05),CL05'CORP '\n         DC   AL1(05),CL05'DATA '\n         DC   AL1(11),CL11'DATAMODULE '\n         DC   AL1(08),CL08'DATANUM '\n         DC   AL1(08),CL08'DATAREG '\n         DC   AL1(05),CL05'DBCS '\n         DC   AL1(04),CL04'DCL '\n         DC   AL1(09),CL09'DCLCLASS '\n         DC   AL1(06),CL06'DEACT '\n         DC   AL1(11),CL11'DEACTIVATE '\n         DC   AL1(08),CL08'DECLARE '\n         DC   AL1(13),CL13'DECLARECLASS '\n         DC   AL1(04),CL04'DEF '\n         DC   AL1(09),CL09'DEFAULTS '\n         DC   AL1(08),CL08'DEFINED '\n         DC   AL1(05),CL05'DEFS '\n         DC   AL1(04),CL04'DIM '\n         DC   AL1(03),CL03'DO '\n         DC   AL1(09),CL09'DONTSAVE '\n         DC   AL1(07),CL07'DOWNTO '\n         DC   AL1(06),CL06'DWORD '\n         DC   AL1(05),CL05'EANS '\n         DC   AL1(07),CL07'EBCDIC '\n         DC   AL1(05),CL05'ELSE '\n         DC   AL1(04),CL04'END '\n         DC   AL1(10),CL10'ENDANSWER '\n         DC   AL1(07),CL07'ENTREG '\n         DC   AL1(06),CL06'ENTRY '\n         DC   AL1(04),CL04'ENV '\n         DC   AL1(12),CL12'ENVIRONMENT '\n         DC   AL1(07),CL07'EPILOG '\n         DC   AL1(07),CL07'ESCAPE '\n         DC   AL1(05),CL05'EVAL '\n         DC   AL1(05),CL05'EXIT '\n         DC   AL1(04),CL04'EXT '\n         DC   AL1(11),CL11'EXTENSIONS '\n         DC   AL1(09),CL09'EXTERNAL '\n         DC   AL1(06),CL06'EXTNS '\n         DC   AL1(06),CL06'FIXED '\n         DC   AL1(09),CL09'FIXED_OF '\n         DC   AL1(06),CL06'FLOWS '\n         DC   AL1(08),CL08'FOREVER '\n         DC   AL1(08),CL08'FRIENDS '\n         DC   AL1(04),CL04'GEN '\n         DC   AL1(05),CL05'GEND '\n         DC   AL1(09),CL09'GENERATE '\n         DC   AL1(10),CL10'GENERATED '\n         DC   AL1(07),CL07'GLOBAL '\n         DC   AL1(03),CL03'GO '\n         DC   AL1(05),CL05'GOTO '\n         DC   AL1(07),CL07'HBOUND '\n         DC   AL1(05),CL05'HVAL '\n         DC   AL1(08),CL08'HVAL_OF '\n         DC   AL1(06),CL06'HWORD '\n         DC   AL1(03),CL03'ID '\n         DC   AL1(03),CL03'IF '\n         DC   AL1(11),CL11'IMPLEMENTS '\n         DC   AL1(10),CL10'INARGLIST '\n         DC   AL1(08),CL08'INCLUDE '\n         DC   AL1(06),CL06'INDEX '\n         DC   AL1(09),CL09'INHERITS '\n         DC   AL1(05),CL05'INIT '\n         DC   AL1(08),CL08'INITIAL '\n         DC   AL1(07),CL07'INLINE '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(06),CL06'INREG '\n         DC   AL1(04),CL04'INT '\n         DC   AL1(09),CL09'INTERNAL '\n         DC   AL1(09),CL09'INTOAREA '\n         DC   AL1(04),CL04'ISA '\n         DC   AL1(08),CL08'ITERATE '\n         DC   AL1(04),CL04'KEY '\n         DC   AL1(05),CL05'KEYS '\n         DC   AL1(08),CL08'KEYWORD '\n         DC   AL1(06),CL06'LABEL '\n         DC   AL1(07),CL07'LBOUND '\n         DC   AL1(06),CL06'LEAVE '\n         DC   AL1(07),CL07'LENGTH '\n         DC   AL1(05),CL05'LIKE '\n         DC   AL1(08),CL08'LINKAGE '\n         DC   AL1(10),CL10'LINKSTACK '\n         DC   AL1(04),CL04'LOC '\n         DC   AL1(06),CL06'LOCAL '\n         DC   AL1(08),CL08'LOCATES '\n         DC   AL1(09),CL09'LOCATESA '\n         DC   AL1(09),CL09'LOCATION '\n         DC   AL1(05),CL05'LVAL '\n         DC   AL1(08),CL08'LVAL_OF '\n         DC   AL1(07),CL07'MACCOL '\n         DC   AL1(08),CL08'MACCONC '\n         DC   AL1(08),CL08'MACDATE '\n         DC   AL1(08),CL08'MACECHO '\n         DC   AL1(09),CL09'MACGLMAR '\n         DC   AL1(09),CL09'MACGRMAR '\n         DC   AL1(05),CL05'MACH '\n         DC   AL1(08),CL08'MACHINE '\n         DC   AL1(09),CL09'MACINDEX '\n         DC   AL1(07),CL07'MACKEY '\n         DC   AL1(08),CL08'MACKEYS '\n         DC   AL1(09),CL09'MACLABEL '\n         DC   AL1(08),CL08'MACLIST '\n         DC   AL1(08),CL08'MACLMAR '\n         DC   AL1(08),CL08'MACNAME '\n         DC   AL1(08),CL08'MACPARM '\n         DC   AL1(11),CL11'MACRETCODE '\n         DC   AL1(08),CL08'MACRMAR '\n         DC   AL1(06),CL06'MACRO '\n         DC   AL1(11),CL11'MACRO_TIME '\n         DC   AL1(08),CL08'MACTIME '\n         DC   AL1(05),CL05'MAIN '\n         DC   AL1(07),CL07'MAPPED '\n         DC   AL1(04),CL04'MAR '\n         DC   AL1(08),CL08'MARGINS '\n         DC   AL1(04),CL04'MAX '\n         DC   AL1(08),CL08'MAXLOOP '\n         DC   AL1(08),CL08'MESSAGE '\n         DC   AL1(04),CL04'MIN '\n         DC   AL1(04),CL04'MSG '\n         DC   AL1(09),CL09'MSGLEVEL '\n         DC   AL1(11),CL11'NOAUTODATA '\n         DC   AL1(10),CL10'NOCODEREG '\n         DC   AL1(07),CL07'NODEFS '\n         DC   AL1(09),CL09'NOENTREG '\n         DC   AL1(09),CL09'NOEPILOG '\n         DC   AL1(07),CL07'NOEXIT '\n         DC   AL1(08),CL08'NOFLOWS '\n         DC   AL1(05),CL05'NOID '\n         DC   AL1(09),CL09'NONLOCAL '\n         DC   AL1(13),CL13'NONREENTRANT '\n         DC   AL1(10),CL10'NOPARMREG '\n         DC   AL1(08),CL08'NOPATCH '\n         DC   AL1(12),CL12'NOPATCHAREA '\n         DC   AL1(09),CL09'NOPROLOG '\n         DC   AL1(07),CL07'NOREFS '\n         DC   AL1(06),CL06'NOREG '\n         DC   AL1(11),CL11'NOREGISTER '\n         DC   AL1(09),CL09'NORESCAN '\n         DC   AL1(09),CL09'NORETREG '\n         DC   AL1(07),CL07'NORMAL '\n         DC   AL1(07),CL07'NOSAVE '\n         DC   AL1(11),CL11'NOSAVEAREA '\n         DC   AL1(10),CL10'NOSAVEREG '\n         DC   AL1(07),CL07'NOSCAN '\n         DC   AL1(06),CL06'NOSEG '\n         DC   AL1(10),CL10'NOSEGMENT '\n         DC   AL1(10),CL10'NOSEQFLOW '\n         DC   AL1(07),CL07'NOSETS '\n         DC   AL1(08),CL08'NOSTACK '\n         DC   AL1(10),CL10'NOSTATREG '\n         DC   AL1(08),CL08'NOTEMPS '\n         DC   AL1(05),CL05'NULL '\n         DC   AL1(04),CL04'NUM '\n         DC   AL1(07),CL07'NUMBER '\n         DC   AL1(07),CL07'OFFSET '\n         DC   AL1(08),CL08'OMITTED '\n         DC   AL1(10),CL10'OPTACROSS '\n         DC   AL1(09),CL09'OPTIONAL '\n         DC   AL1(08),CL08'OPTIONS '\n         DC   AL1(06),CL06'ORDER '\n         DC   AL1(06),CL06'OTHER '\n         DC   AL1(10),CL10'OTHERWISE '\n         DC   AL1(07),CL07'OUTPUT '\n         DC   AL1(11),CL11'OVERLOADED '\n         DC   AL1(05),CL05'PAGE '\n         DC   AL1(05),CL05'PARM '\n         DC   AL1(08),CL08'PARMREG '\n         DC   AL1(06),CL06'PATCH '\n         DC   AL1(10),CL10'PATCHAREA '\n         DC   AL1(04),CL04'PLX '\n         DC   AL1(07),CL07'PLX370 '\n         DC   AL1(08),CL08'POINTER '\n         DC   AL1(11),CL11'POINTER_OF '\n         DC   AL1(04),CL04'POP '\n         DC   AL1(05),CL05'PORT '\n         DC   AL1(12),CL12'PORTABILITY '\n         DC   AL1(04),CL04'POS '\n         DC   AL1(09),CL09'POSITION '\n         DC   AL1(04),CL04'PRI '\n         DC   AL1(08),CL08'PRIMARY '\n         DC   AL1(08),CL08'PRIVATE '\n         DC   AL1(05),CL05'PROC '\n         DC   AL1(10),CL10'PROCEDURE '\n         DC   AL1(07),CL07'PROLOG '\n         DC   AL1(10),CL10'PROTECTED '\n         DC   AL1(04),CL04'PTR '\n         DC   AL1(07),CL07'PTR_OF '\n         DC   AL1(07),CL07'PTROFF '\n         DC   AL1(07),CL07'PUBLIC '\n         DC   AL1(05),CL05'PUSH '\n         DC   AL1(06),CL06'QUOTE '\n         DC   AL1(09),CL09'READONLY '\n         DC   AL1(10),CL10'READWRITE '\n         DC   AL1(10),CL10'REENTRANT '\n         DC   AL1(05),CL05'REFS '\n         DC   AL1(04),CL04'REG '\n         DC   AL1(09),CL09'REGISTER '\n         DC   AL1(08),CL08'REORDER '\n         DC   AL1(07),CL07'REPEAT '\n         DC   AL1(04),CL04'RES '\n         DC   AL1(07),CL07'RESCAN '\n         DC   AL1(10),CL10'RESPECIFY '\n         DC   AL1(11),CL11'RESTRICTED '\n         DC   AL1(08),CL08'RETCODE '\n         DC   AL1(07),CL07'RETREG '\n         DC   AL1(07),CL07'RETURN '\n         DC   AL1(13),CL13'RETURNASSIST '\n         DC   AL1(08),CL08'RETURNS '\n         DC   AL1(04),CL04'RFY '\n         DC   AL1(06),CL06'RMODE '\n         DC   AL1(06),CL06'RSECT '\n         DC   AL1(05),CL05'RSTD '\n         DC   AL1(09),CL09'RULESMOD '\n         DC   AL1(05),CL05'SAME '\n         DC   AL1(05),CL05'SAVE '\n         DC   AL1(09),CL09'SAVEAREA '\n         DC   AL1(08),CL08'SAVEREG '\n         DC   AL1(05),CL05'SCAN '\n         DC   AL1(04),CL04'SEG '\n         DC   AL1(08),CL08'SEGMENT '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(08),CL08'SEQFLOW '\n         DC   AL1(05),CL05'SETS '\n         DC   AL1(07),CL07'SIGNED '\n         DC   AL1(10),CL10'SIGNED_OF '\n         DC   AL1(05),CL05'SIZE '\n         DC   AL1(05),CL05'SKIP '\n         DC   AL1(03),CL03'SP '\n         DC   AL1(08),CL08'SPACEID '\n         DC   AL1(10),CL10'SPACETYPE '\n         DC   AL1(06),CL06'STACK '\n         DC   AL1(07),CL07'STATIC '\n         DC   AL1(12),CL12'STATICLOCAL '\n         DC   AL1(08),CL08'STATNUM '\n         DC   AL1(08),CL08'STATREG '\n         DC   AL1(08),CL08'STORAGE '\n         DC   AL1(13),CL13'STORAGECLASS '\n         DC   AL1(04),CL04'STR '\n         DC   AL1(07),CL07'STRING '\n         DC   AL1(11),CL11'STRINGTYPE '\n         DC   AL1(07),CL07'STRONG '\n         DC   AL1(08),CL08'SUBPOOL '\n         DC   AL1(10),CL10'SUBSTRLEN '\n         DC   AL1(10),CL10'SUBSYSTEM '\n         DC   AL1(08),CL08'SYNONYM '\n         DC   AL1(08),CL08'SYSDATE '\n         DC   AL1(09),CL09'SYSDATEC '\n         DC   AL1(11),CL11'SYSENVLIST '\n         DC   AL1(12),CL12'SYSENVQUERY '\n         DC   AL1(08),CL08'SYSLIST '\n         DC   AL1(08),CL08'SYSPARM '\n         DC   AL1(09),CL09'SYSQUERY '\n         DC   AL1(12),CL12'SYSRULESMOD '\n         DC   AL1(08),CL08'SYSTIME '\n         DC   AL1(11),CL11'SYSVERSION '\n         DC   AL1(06),CL06'TEMPS '\n         DC   AL1(05),CL05'THEN '\n         DC   AL1(03),CL03'TO '\n         DC   AL1(06),CL06'TRACE '\n         DC   AL1(06),CL06'TRANS '\n         DC   AL1(10),CL10'TRANSLATE '\n         DC   AL1(05),CL05'TYPE '\n         DC   AL1(16),CL16'UNCHECKED_INPUT '\n         DC   AL1(17),CL17'UNCHECKED_OUTPUT '\n         DC   AL1(10),CL10'UNDEFINED '\n         DC   AL1(06),CL06'UNION '\n         DC   AL1(13),CL13'UNRESTRICTED '\n         DC   AL1(07),CL07'UNRSTD '\n         DC   AL1(09),CL09'UNSIGNED '\n         DC   AL1(12),CL12'UNSIGNED_OF '\n         DC   AL1(06),CL06'UNTIL '\n         DC   AL1(11),CL11'UPORDOWNTO '\n         DC   AL1(05),CL05'UPTO '\n         DC   AL1(06),CL06'VALRG '\n         DC   AL1(11),CL11'VALUERANGE '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(08),CL08'VARYING '\n         DC   AL1(07),CL07'VBLTRC '\n         DC   AL1(07),CL07'VERIFY '\n         DC   AL1(08),CL08'VERSION '\n         DC   AL1(04),CL04'VIA '\n         DC   AL1(08),CL08'VIAADDR '\n         DC   AL1(11),CL11'VIAPOINTER '\n         DC   AL1(07),CL07'VIAPTR '\n         DC   AL1(06),CL06'VLIST '\n         DC   AL1(05),CL05'WEAK '\n         DC   AL1(05),CL05'WHEN '\n         DC   AL1(06),CL06'WHILE '\n         DC   AL1(05),CL05'WORD '\n         DC   AL1(0)\n         END\nISRPXIDL CSECT ,\nISRPXIDL AMODE 31\nISRPXIDL RMODE ANY\n*  ISRPXIDL: 78 Keywords\n*  604 bytes\n*\n         DC   AL1(08),CL08'_packed '\n         DC   AL1(04),CL04'any '\n         DC   AL1(10),CL10'attribute '\n         DC   AL1(05),CL05'auto '\n         DC   AL1(08),CL08'boolean '\n         DC   AL1(06),CL06'break '\n         DC   AL1(05),CL05'case '\n         DC   AL1(06),CL06'catch '\n         DC   AL1(06),CL06'cdecl '\n         DC   AL1(05),CL05'char '\n         DC   AL1(06),CL06'class '\n         DC   AL1(06),CL06'const '\n         DC   AL1(08),CL08'context '\n         DC   AL1(09),CL09'continue '\n         DC   AL1(08),CL08'default '\n         DC   AL1(07),CL07'delete '\n         DC   AL1(03),CL03'do '\n         DC   AL1(07),CL07'double '\n         DC   AL1(05),CL05'else '\n         DC   AL1(06),CL06'entry '\n         DC   AL1(05),CL05'enum '\n         DC   AL1(10),CL10'exception '\n         DC   AL1(07),CL07'extern '\n         DC   AL1(04),CL04'far '\n         DC   AL1(06),CL06'float '\n         DC   AL1(04),CL04'for '\n         DC   AL1(08),CL08'fortran '\n         DC   AL1(07),CL07'friend '\n         DC   AL1(05),CL05'goto '\n         DC   AL1(05),CL05'huge '\n         DC   AL1(03),CL03'if '\n         DC   AL1(15),CL15'implementation '\n         DC   AL1(03),CL03'in '\n         DC   AL1(07),CL07'inline '\n         DC   AL1(06),CL06'inout '\n         DC   AL1(04),CL04'int '\n         DC   AL1(10),CL10'interface '\n         DC   AL1(10),CL10'interrupt '\n         DC   AL1(05),CL05'long '\n         DC   AL1(07),CL07'module '\n         DC   AL1(05),CL05'near '\n         DC   AL1(04),CL04'new '\n         DC   AL1(06),CL06'octet '\n         DC   AL1(07),CL07'oneway '\n         DC   AL1(09),CL09'operator '\n         DC   AL1(04),CL04'out '\n         DC   AL1(07),CL07'pascal '\n         DC   AL1(08),CL08'private '\n         DC   AL1(10),CL10'protected '\n         DC   AL1(07),CL07'public '\n         DC   AL1(07),CL07'raises '\n         DC   AL1(09),CL09'readonly '\n         DC   AL1(09),CL09'register '\n         DC   AL1(07),CL07'return '\n         DC   AL1(09),CL09'sequence '\n         DC   AL1(06),CL06'short '\n         DC   AL1(07),CL07'signed '\n         DC   AL1(08),CL08'size_of '\n         DC   AL1(07),CL07'sizeof '\n         DC   AL1(07),CL07'static '\n         DC   AL1(07),CL07'string '\n         DC   AL1(07),CL07'struct '\n         DC   AL1(07),CL07'switch '\n         DC   AL1(09),CL09'template '\n         DC   AL1(05),CL05'this '\n         DC   AL1(06),CL06'throw '\n         DC   AL1(04),CL04'try '\n         DC   AL1(08),CL08'typedef '\n         DC   AL1(06),CL06'union '\n         DC   AL1(09),CL09'unsigned '\n         DC   AL1(08),CL08'virtual '\n         DC   AL1(05),CL05'void '\n         DC   AL1(09),CL09'volatile '\n         DC   AL1(08),CL08'wchar_t '\n         DC   AL1(06),CL06'while '\n         DC   AL1(06),CL06'FALSE '\n         DC   AL1(09),CL09'TypeCode '\n         DC   AL1(05),CL05'TRUE '\n         DC   AL1(0)                /*                               */\n         END\nISRPXHTM CSECT ,\nISRPXHTM AMODE 31\nISRPXHTM RMODE ANY\n*  ISRPXHTM: 99 Keywords\n*  633 bytes\n*\n         DC   AL1(09),CL09'!ATTLIST '\n         DC   AL1(09),CL09'!DOCTYPE '\n         DC   AL1(09),CL09'!ELEMENT '\n         DC   AL1(08),CL08'!ENTITY '\n         DC   AL1(09),CL09':ATTLIST '\n         DC   AL1(09),CL09':DOCTYPE '\n         DC   AL1(09),CL09':ELEMENT '\n         DC   AL1(08),CL08':ENTITY '\n         DC   AL1(02),CL02'A '\n         DC   AL1(05),CL05'ABBR '\n         DC   AL1(08),CL08'ACRONYM '\n         DC   AL1(08),CL08'ADDRESS '\n         DC   AL1(07),CL07'APPLET '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(02),CL02'B '\n         DC   AL1(05),CL05'BASE '\n         DC   AL1(09),CL09'BASEFONT '\n         DC   AL1(04),CL04'BDO '\n         DC   AL1(04),CL04'BIG '\n         DC   AL1(11),CL11'BLOCKQUOTE '\n         DC   AL1(05),CL05'BODY '\n         DC   AL1(03),CL03'BR '\n         DC   AL1(07),CL07'BUTTON '\n         DC   AL1(08),CL08'CAPTION '\n         DC   AL1(07),CL07'CENTER '\n         DC   AL1(05),CL05'CITE '\n         DC   AL1(05),CL05'CODE '\n         DC   AL1(04),CL04'COL '\n         DC   AL1(09),CL09'COLGROUP '\n         DC   AL1(03),CL03'DD '\n         DC   AL1(04),CL04'DEL '\n         DC   AL1(04),CL04'DFN '\n         DC   AL1(04),CL04'DIR '\n         DC   AL1(04),CL04'DIV '\n         DC   AL1(03),CL03'DL '\n         DC   AL1(03),CL03'DT '\n         DC   AL1(03),CL03'EM '\n         DC   AL1(09),CL09'FIELDSET '\n         DC   AL1(05),CL05'FONT '\n         DC   AL1(05),CL05'FORM '\n         DC   AL1(06),CL06'FRAME '\n         DC   AL1(09),CL09'FRAMESET '\n         DC   AL1(05),CL05'HEAD '\n         DC   AL1(03),CL03'HR '\n         DC   AL1(05),CL05'HTML '\n         DC   AL1(03),CL03'H1 '\n         DC   AL1(03),CL03'H2 '\n         DC   AL1(03),CL03'H3 '\n         DC   AL1(03),CL03'H4 '\n         DC   AL1(03),CL03'H5 '\n         DC   AL1(03),CL03'H6 '\n         DC   AL1(02),CL02'I '\n         DC   AL1(07),CL07'IFRAME '\n         DC   AL1(04),CL04'IMG '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(04),CL04'INS '\n         DC   AL1(08),CL08'ISINDEX '\n         DC   AL1(04),CL04'KBD '\n         DC   AL1(06),CL06'LABEL '\n         DC   AL1(07),CL07'LEGEND '\n         DC   AL1(03),CL03'LI '\n         DC   AL1(05),CL05'LINK '\n         DC   AL1(04),CL04'MAP '\n         DC   AL1(05),CL05'MENU '\n         DC   AL1(05),CL05'META '\n         DC   AL1(09),CL09'NOFRAMES '\n         DC   AL1(09),CL09'NOSCRIPT '\n         DC   AL1(07),CL07'OBJECT '\n         DC   AL1(03),CL03'OL '\n         DC   AL1(09),CL09'OPTGROUP '\n         DC   AL1(07),CL07'OPTION '\n         DC   AL1(02),CL02'P '\n         DC   AL1(06),CL06'PARAM '\n         DC   AL1(04),CL04'PRE '\n         DC   AL1(02),CL02'Q '\n         DC   AL1(02),CL02'S '\n         DC   AL1(05),CL05'SAMP '\n         DC   AL1(07),CL07'SCRIPT '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(06),CL06'SMALL '\n         DC   AL1(05),CL05'SPAN '\n         DC   AL1(07),CL07'STRIKE '\n         DC   AL1(07),CL07'STRONG '\n         DC   AL1(06),CL06'STYLE '\n         DC   AL1(04),CL04'SUB '\n         DC   AL1(04),CL04'SUP '\n         DC   AL1(06),CL06'TABLE '\n         DC   AL1(06),CL06'TBODY '\n         DC   AL1(03),CL03'TD '\n         DC   AL1(09),CL09'TEXTAREA '\n         DC   AL1(06),CL06'TFOOT '\n         DC   AL1(03),CL03'TH '\n         DC   AL1(06),CL06'THEAD '\n         DC   AL1(06),CL06'TITLE '\n         DC   AL1(03),CL03'TR '\n         DC   AL1(03),CL03'TT '\n         DC   AL1(02),CL02'U '\n         DC   AL1(03),CL03'UL '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(0)\n         END\nISRPXXML CSECT ,\nISRPXXML AMODE 31\nISRPXXML RMODE ANY\n*  ISRPXXML: 104 Keywords\n*  676 bytes\n*\n         DC   AL1(09),CL09'!ATTLIST '\n         DC   AL1(09),CL09'!DOCTYPE '\n         DC   AL1(09),CL09'!ELEMENT '\n         DC   AL1(08),CL08'!ENTITY '\n         DC   AL1(10),CL10'!NOTATION '\n         DC   AL1(08),CL08'?TARGET '\n         DC   AL1(05),CL05'?XML '\n         DC   AL1(09),CL09':ATTLIST '\n         DC   AL1(09),CL09':DOCTYPE '\n         DC   AL1(09),CL09':ELEMENT '\n         DC   AL1(08),CL08':ENTITY '\n         DC   AL1(10),CL10':NOTATION '\n         DC   AL1(02),CL02'A '\n         DC   AL1(05),CL05'ABBR '\n         DC   AL1(08),CL08'ACRONYM '\n         DC   AL1(08),CL08'ADDRESS '\n         DC   AL1(07),CL07'APPLET '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(02),CL02'B '\n         DC   AL1(05),CL05'BASE '\n         DC   AL1(09),CL09'BASEFONT '\n         DC   AL1(04),CL04'BDO '\n         DC   AL1(04),CL04'BIG '\n         DC   AL1(11),CL11'BLOCKQUOTE '\n         DC   AL1(05),CL05'BODY '\n         DC   AL1(03),CL03'BR '\n         DC   AL1(07),CL07'BUTTON '\n         DC   AL1(08),CL08'CAPTION '\n         DC   AL1(07),CL07'CENTER '\n         DC   AL1(05),CL05'CITE '\n         DC   AL1(05),CL05'CODE '\n         DC   AL1(04),CL04'COL '\n         DC   AL1(09),CL09'COLGROUP '\n         DC   AL1(03),CL03'DD '\n         DC   AL1(04),CL04'DEL '\n         DC   AL1(04),CL04'DFN '\n         DC   AL1(04),CL04'DIR '\n         DC   AL1(04),CL04'DIV '\n         DC   AL1(03),CL03'DL '\n         DC   AL1(03),CL03'DT '\n         DC   AL1(03),CL03'EM '\n         DC   AL1(09),CL09'FIELDSET '\n         DC   AL1(05),CL05'FONT '\n         DC   AL1(05),CL05'FORM '\n         DC   AL1(06),CL06'FRAME '\n         DC   AL1(09),CL09'FRAMESET '\n         DC   AL1(05),CL05'HEAD '\n         DC   AL1(03),CL03'HR '\n         DC   AL1(05),CL05'HTML '\n         DC   AL1(03),CL03'H1 '\n         DC   AL1(03),CL03'H2 '\n         DC   AL1(03),CL03'H3 '\n         DC   AL1(03),CL03'H4 '\n         DC   AL1(03),CL03'H5 '\n         DC   AL1(03),CL03'H6 '\n         DC   AL1(02),CL02'I '\n         DC   AL1(07),CL07'IFRAME '\n         DC   AL1(04),CL04'IMG '\n         DC   AL1(06),CL06'INPUT '\n         DC   AL1(04),CL04'INS '\n         DC   AL1(08),CL08'ISINDEX '\n         DC   AL1(04),CL04'KBD '\n         DC   AL1(06),CL06'LABEL '\n         DC   AL1(07),CL07'LEGEND '\n         DC   AL1(03),CL03'LI '\n         DC   AL1(05),CL05'LINK '\n         DC   AL1(04),CL04'MAP '\n         DC   AL1(05),CL05'MENU '\n         DC   AL1(05),CL05'META '\n         DC   AL1(09),CL09'NOFRAMES '\n         DC   AL1(09),CL09'NOSCRIPT '\n         DC   AL1(07),CL07'OBJECT '\n         DC   AL1(03),CL03'OL '\n         DC   AL1(09),CL09'OPTGROUP '\n         DC   AL1(07),CL07'OPTION '\n         DC   AL1(02),CL02'P '\n         DC   AL1(06),CL06'PARAM '\n         DC   AL1(04),CL04'PRE '\n         DC   AL1(02),CL02'Q '\n         DC   AL1(02),CL02'S '\n         DC   AL1(05),CL05'SAMP '\n         DC   AL1(07),CL07'SCRIPT '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(06),CL06'SMALL '\n         DC   AL1(05),CL05'SPAN '\n         DC   AL1(07),CL07'STRIKE '\n         DC   AL1(07),CL07'STRONG '\n         DC   AL1(06),CL06'STYLE '\n         DC   AL1(04),CL04'SUB '\n         DC   AL1(04),CL04'SUP '\n         DC   AL1(06),CL06'TABLE '\n         DC   AL1(06),CL06'TBODY '\n         DC   AL1(03),CL03'TD '\n         DC   AL1(09),CL09'TEXTAREA '\n         DC   AL1(06),CL06'TFOOT '\n         DC   AL1(03),CL03'TH '\n         DC   AL1(06),CL06'THEAD '\n         DC   AL1(06),CL06'TITLE '\n         DC   AL1(03),CL03'TR '\n         DC   AL1(03),CL03'TT '\n         DC   AL1(02),CL02'U '\n         DC   AL1(03),CL03'UL '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(05),CL05'XSL: '\n         DC   AL1(0)\n         END\nISRPXLGD CSECT ,\nISRPXLGD AMODE 31\nISRPXLGD RMODE ANY\n*  ISRPXLGD: 38 Keywords\n*  253 bytes\n*\n         DC   AL1(03),CL03'AB '\n         DC   AL1(05),CL05'AREA '\n         DC   AL1(08),CL08'ASSIGNL '\n         DC   AL1(10),CL10'ATTENTION '\n         DC   AL1(08),CL08'CAUTION '\n         DC   AL1(07),CL07'CHECKL '\n         DC   AL1(07),CL07'CMDTBL '\n         DC   AL1(03),CL03'DA '\n         DC   AL1(03),CL03'DL '\n         DC   AL1(07),CL07'DTACOL '\n         DC   AL1(04),CL04'FIG '\n         DC   AL1(09),CL09'GENERATE '\n         DC   AL1(05),CL05'HELP '\n         DC   AL1(03),CL03'HP '\n         DC   AL1(05),CL05'INFO '\n         DC   AL1(05),CL05'KEYL '\n         DC   AL1(06),CL06'LINES '\n         DC   AL1(04),CL04'LIT '\n         DC   AL1(07),CL07'LSTFLD '\n         DC   AL1(07),CL07'LSTGRP '\n         DC   AL1(07),CL07'MSGMBR '\n         DC   AL1(06),CL06'NOTEL '\n         DC   AL1(03),CL03'NT '\n         DC   AL1(03),CL03'OL '\n         DC   AL1(06),CL06'PANEL '\n         DC   AL1(06),CL06'PARML '\n         DC   AL1(03),CL03'PS '\n         DC   AL1(07),CL07'REGION '\n         DC   AL1(03),CL03'RP '\n         DC   AL1(07),CL07'SELFLD '\n         DC   AL1(03),CL03'SL '\n         DC   AL1(07),CL07'SOURCE '\n         DC   AL1(09),CL09'TEXTLINE '\n         DC   AL1(03),CL03'UL '\n         DC   AL1(08),CL08'VARLIST '\n         DC   AL1(08),CL08'WARNING '\n         DC   AL1(06),CL06'XLATL '\n         DC   AL1(04),CL04'XMP '\n         DC   AL1(0)\n         END\nISRPXLGH CSECT ,\nISRPXLGH AMODE 31\nISRPXLGH RMODE ANY\n*  ISRPXLGH: 43 Keywords\n*  248 bytes\n*\n         DC   AL1(02),CL02'A '\n         DC   AL1(05),CL05'ABBR '\n         DC   AL1(08),CL08'ACRONYM '\n         DC   AL1(08),CL08'ADDRESS '\n         DC   AL1(02),CL02'B '\n         DC   AL1(04),CL04'BDO '\n         DC   AL1(04),CL04'BIG '\n         DC   AL1(11),CL11'BLOCKQUOTE '\n         DC   AL1(07),CL07'CENTER '\n         DC   AL1(05),CL05'CITE '\n         DC   AL1(05),CL05'CODE '\n         DC   AL1(04),CL04'DEL '\n         DC   AL1(04),CL04'DFN '\n         DC   AL1(03),CL03'DL '\n         DC   AL1(03),CL03'EM '\n         DC   AL1(09),CL09'FRAMESET '\n         DC   AL1(05),CL05'HTML '\n         DC   AL1(03),CL03'H1 '\n         DC   AL1(03),CL03'H2 '\n         DC   AL1(03),CL03'H3 '\n         DC   AL1(03),CL03'H4 '\n         DC   AL1(03),CL03'H5 '\n         DC   AL1(03),CL03'H6 '\n         DC   AL1(04),CL04'INS '\n         DC   AL1(04),CL04'KBD '\n         DC   AL1(07),CL07'OBJECT '\n         DC   AL1(03),CL03'OL '\n         DC   AL1(04),CL04'PRE '\n         DC   AL1(02),CL02'Q '\n         DC   AL1(02),CL02'S '\n         DC   AL1(05),CL05'SAMP '\n         DC   AL1(07),CL07'SCRIPT '\n         DC   AL1(07),CL07'SELECT '\n         DC   AL1(06),CL06'SMALL '\n         DC   AL1(07),CL07'STRIKE '\n         DC   AL1(07),CL07'STRONG '\n         DC   AL1(06),CL06'TABLE '\n         DC   AL1(09),CL09'TEXTAREA '\n         DC   AL1(06),CL06'TITLE '\n         DC   AL1(03),CL03'TT '\n         DC   AL1(02),CL02'U '\n         DC   AL1(03),CL03'UL '\n         DC   AL1(04),CL04'VAR '\n         DC   AL1(0)\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISRUAASE": {"ttr": 5381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x01\\x01\\x00\\xfd\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 257, "newlines": 253, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUDSL0": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x185\\x7f\\x01 \\x19O\\x11\\x00\\x01U\\x01U\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-23T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 341, "newlines": 341, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUMVC": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x01\\t\\x01\\x02\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 265, "newlines": 258, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUUDL0": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x185\\x8f\\x01 \\x19O\\x11\\x00\\x00\\xb7\\x00\\xb5\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-24T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 183, "newlines": 181, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUULP": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x185\\x8f\\x01 \\x19O\\x11\\x00\\x00\\xf5\\x00\\xe6\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-24T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 245, "newlines": 230, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRV01": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "TCONLEY"}, "text": "ISRV010  'Invalid combination     ' .ALARM=YES NOKANA\n'Data set version is only valid when Data set name type is set ' +\n'to LIBRARY.'\nISRV011  'Invalid combination     ' .ALARM=YES NOKANA\n'Number of generations is only valid when Data set name type is ' +\n'set to LIBRARY.'\n/*********************************************************************/\n/********************* BEGIN CUCI MODIFICATIONS **********************/\n/*********************************************************************/\nISRV012  'Invalid combination     ' .ALARM=YES NOKANA\n'Number of generations is only valid when Data set version is 2.'\n/*********************************************************************/\n/********************** END CUCI MODIFICATIONS ***********************/\n/*********************************************************************/\n/* 5650-ZOS     COPYRIGHT IBM CORP 1994, 2013                                 */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMBPXISJ": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x185\\x8f\\x01\\x19\\x02\\x8f#0\\x00\\x14\\x00\\x13\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-12-24T00:00:00", "modifydate": "2019-01-28T23:30:00", "lines": 20, "newlines": 19, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMBPXIS) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMBPXIS) CHECK.\n   APPLY S(UMBPXIS).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMBPXIS) REWORK(20190270).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HBB77B0). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++PNLENU(BPXWP99) DISTLIB(ABPXPENU) TXLIB(CBTFILE).\n++EXEC(BPXWISH) ALIAS(ISH,ISHELL) DISTLIB(ABPXEXEC) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISCLMJ": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x002\\x00!\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 50, "newlines": 33, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISCLM) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISCLM) CHECK.\n   APPLY S(UMISCLM).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISCLM) REWORK(20201930).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++MOVE (FLM$CPI ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMB ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMCPCS ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMDDL ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMIO24 ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMLPCBL) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMLPFRT) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMLPGEN) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMLSS ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMP ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMPTC ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMRA ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMRC ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMRTLIB) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMS$LNK) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMS$SRV) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMS7C ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTBMAP) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTCCPS) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTCIDS) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTCLGT) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTCPC ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTCPP ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTCVER) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTMMI ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTMSI ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMTXFER) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMUM ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMVCSUP) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMXE ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (FLMXI ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n++MOVE (ISRSUPC ) SYSLIB(SISPLPA) TOSYSLIB(SISPLOAD) LMOD.\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISPCMJ": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x172\\x0f\\x01\\x185\\x8f!\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-11-16T00:00:00", "modifydate": "2018-12-24T21:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISPCM) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISPCM) CHECK.\n   APPLY S(UMISPCM).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISPCM) REWORK(20173190).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++TBLENU(ISPCMDS) DISTLIB(AISPTENU) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISRHIJ": {"ttr": 5904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x00\\x8f\\x01 \\x19O\\x11\\x00\\x00\\x15\\x00\\x14\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-08T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 21, "newlines": 20, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISRHI) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISRHI) CHECK.\n   APPLY S(UMISRHI).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISRHI) REWORK(20201940).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++PNLENU(ISREDDE2) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++EXEC(USRHILIT) SYSLIB(SISPEXEC) DISTLIB(AISPEXEC) TXLIB(CBTFILE).\n++MSGENU(USRL00) SYSLIB(SISPMENU) DISTLIB(AISPMENU) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISRPDJ": {"ttr": 5906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x14\\x00\\x14\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISRPD) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISRPD) CHECK.\n   APPLY S(UMISRPD).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISRPD) REWORK(20201930).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++PNLENU(ISRUAASE) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++MSGENU(ISRV01) DISTLIB(AISPMENU) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISRPXJ": {"ttr": 5908, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x1f\\x00 \\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 31, "newlines": 32, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//* INVOKE HIGH LEVEL ASSEMBLER\n//ASM      EXEC  PGM=ASMA90,REGION=0M,\n//             PARM=(NORLD,RENT,TERM,OBJ,\n//             'XREF(SHORT,UNREFS),SIZE(MAX,ABOVE)',\n//             'FLAG(PAGE0)')\n//SYSLIN   DD  DISP=SHR,DSN=DSN=yourhlq.CBT.FILE967(ISRPXOBJ)\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSIN    DD  DISP=SHR,DSN=DSN=yourhlq.CBT.FILE967(ISRPXASM)\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHARE\n//         DD  DSN=SYS1.MACLIB,DISP=SHARE\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISRPX) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISRPX) CHECK.\n   APPLY S(UMISRPX).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISRPX) REWORK(20201930).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02) PRE(UA96341). /*<=== YOUR ISPF FMID/PRE   */\n++MOD(ISRPX) DISTLIB(AISPMOD1).\n@@\n//         DD DISP=SHR,DSN=yourhlq.CBT.FILE967(ISRPXOBJ)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISRUDJ": {"ttr": 5910, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x185\\x7f\\x01 \\x19O\\x11\\x00\\x00\\x14\\x00\\x14\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-23T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISRUD) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISRUD) CHECK.\n   APPLY S(UMISRUD).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISRUD) REWORK(20183570).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++PNLENU(ISRUDSL0) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++EXEC(USRDEL34) SYSLIB(SISPEXEC) DISTLIB(AISPEXEC) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISRUUJ": {"ttr": 5912, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x185\\x8f\\x01 \\x19O\\x11\\x00\\x00\\x14\\x00\\x14\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-12-24T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISRUU) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISRUU) CHECK.\n   APPLY S(UMISRUU).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISRUU) REWORK(20183580).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++PNLENU(ISRUUDL0) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(ISRUULP)  DISTLIB(AISPPENU) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMISRVCJ": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMISRVC) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMISRVC) CHECK.\n   APPLY S(UMISRVC).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMISRVC) REWORK(20201930).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02). /*<=== YOUR ISPF FMID (ADD PRE IF NEEDED)*/\n++PNLENU(ISRUMVC) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n@@\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMUSRCFJ": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00%\\x00\\x1f\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 37, "newlines": 31, "modlines": 0, "user": "TCONLEY"}, "text": "//IBMUSERU JOB 'IBMUSER',CLASS=A,NOTIFY=&SYSUID,\n//             MSGCLASS=X,REGION=0M,TIME=NOLIMIT,MSGLEVEL=(1,1)\n//*********************************************************************\n//APPLYUM  EXEC PGM=GIMSMP\n//SYSPRINT DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=yourhlq.GLOBAL.CSI  <=== YOUR ISPF CSI\n//CBTFILE  DD DISP=SHR,DSN=yourhlq.CBT.FILE967 <=== CBT FILE\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n   RECEIVE S(UMUSRCF) SYSMODS.\n SET BDY(target).   /* <=== YOUR TARGET ZONE */\n   APPLY S(UMUSRCF) CHECK.\n   APPLY S(UMUSRCF).\n/*\n//SMPPTFIN DD DATA,DLM=@@\n++USERMOD(UMUSRCF) REWORK(20201930).   /*<=== RESET REWORK IF NEEDED */\n++VER (Z038) FMID(HIF7R02).            /*<=== YOUR ISPF FMID/PRE     */\n++PNLENU(ISR@PRIM) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPCONF) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMOD)  SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMODQ) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMODX) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMOD1) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMOD2) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMOD3) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRPMOD4) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRUMNO2) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USRUULO2) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USR0Y002) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USR0Y004) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++PNLENU(USR0Y007) SYSLIB(SISPPENU) DISTLIB(AISPPENU) TXLIB(CBTFILE).\n++EXEC(USR@KYWD)   SYSLIB(SISPEXEC) DISTLIB(AISPEXEC) TXLIB(CBTFILE).\n++EXEC(USRCCONF)   SYSLIB(SISPEXEC) DISTLIB(AISPEXEC) TXLIB(CBTFILE).\n++EXEC(USRCCVWK)   SYSLIB(SISPEXEC) DISTLIB(AISPEXEC) TXLIB(CBTFILE).\n++EXEC(USRCMOD)    SYSLIB(SISPEXEC) DISTLIB(AISPEXEC) TXLIB(CBTFILE).\n@@\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USR@KYWD": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x013\\x00\\xd2\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 307, "newlines": 210, "modlines": 0, "user": "TCONLEY"}, "text": "/* rexx */\ncall isprexpx('I')\naddress tso \"ALLOC FI(USRKWFIL) SHR\",\n               \"DA('yourhlq.ispf.keyword(member)')\"   /*MODIFY FOR   */\n                                                      /*YOUR ISPF    */\n                                                      /*KEYWORD FILE */\n                                                      /*AND MEMBER   */\n\"EXECIO * DISKR USRKWFIL (OPEN STEM USRKWFIL. FINIS)\"\naddress tso \"FREE FI(USRKWFIL)\"\nif usrkwnew = 'YES' then\n   do\n      createkw = 1\n      usrkwupd = 'YES'\n   end\nelse\n   createkw = 0\ndo i = 1 to usrkwfil.0\n   parse var usrkwfil.i 1 cm 3 . 1 keyword . ' = ' valu ',' frc .\n   say keyword valu frc\n   if cm = '/*' then\n      iterate i\n   if frc = '/' then\n      do\n         force    = 1\n         usrkwupd = 'YES'\n      end\n   else\n      force = 0\n   select\n      when (keyword = 'PF01' & (createkw | force)) then\n         zpf01 = valu\n      when (keyword = 'PF02' & (createkw | force)) then\n         zpf02 = valu\n      when (keyword = 'PF03' & (createkw | force)) then\n         zpf03 = valu\n      when (keyword = 'PF04' & (createkw | force)) then\n         zpf04 = valu\n      when (keyword = 'PF05' & (createkw | force)) then\n         zpf05 = valu\n      when (keyword = 'PF06' & (createkw | force)) then\n         zpf06 = valu\n      when (keyword = 'PF07' & (createkw | force)) then\n         zpf07 = valu\n      when (keyword = 'PF08' & (createkw | force)) then\n         zpf08 = valu\n      when (keyword = 'PF09' & (createkw | force)) then\n         zpf09 = valu\n      when (keyword = 'PF10' & (createkw | force)) then\n         zpf10 = valu\n      when (keyword = 'PF11' & (createkw | force)) then\n         zpf11 = valu\n      when (keyword = 'PF12' & (createkw | force)) then\n         zpf12 = valu\n      when (keyword = 'PF13' & (createkw | force)) then\n         zpf13 = valu\n      when (keyword = 'PF14' & (createkw | force)) then\n         zpf14 = valu\n      when (keyword = 'PF15' & (createkw | force)) then\n         zpf15 = valu\n      when (keyword = 'PF16' & (createkw | force)) then\n         zpf16 = valu\n      when (keyword = 'PF17' & (createkw | force)) then\n         zpf17 = valu\n      when (keyword = 'PF18' & (createkw | force)) then\n         zpf18 = valu\n      when (keyword = 'PF19' & (createkw | force)) then\n         zpf19 = valu\n      when (keyword = 'PF20' & (createkw | force)) then\n         zpf20 = valu\n      when (keyword = 'PF21' & (createkw | force)) then\n         zpf21 = valu\n      when (keyword = 'PF22' & (createkw | force)) then\n         zpf22 = valu\n      when (keyword = 'PF23' & (createkw | force)) then\n         zpf23 = valu\n      when (keyword = 'PF24' & (createkw | force)) then\n         zpf24 = valu\n      when (keyword = 'PF01_LABEL' & (createkw | force)) then\n         zpfl01 = valu\n      when (keyword = 'PF02_LABEL' & (createkw | force)) then\n         zpfl02 = valu\n      when (keyword = 'PF03_LABEL' & (createkw | force)) then\n         zpfl03 = valu\n      when (keyword = 'PF04_LABEL' & (createkw | force)) then\n         zpfl04 = valu\n      when (keyword = 'PF05_LABEL' & (createkw | force)) then\n         zpfl05 = valu\n      when (keyword = 'PF06_LABEL' & (createkw | force)) then\n         zpfl06 = valu\n      when (keyword = 'PF07_LABEL' & (createkw | force)) then\n         zpfl07 = valu\n      when (keyword = 'PF08_LABEL' & (createkw | force)) then\n         zpfl08 = valu\n      when (keyword = 'PF09_LABEL' & (createkw | force)) then\n         zpfl09 = valu\n      when (keyword = 'PF10_LABEL' & (createkw | force)) then\n         zpfl10 = valu\n      when (keyword = 'PF11_LABEL' & (createkw | force)) then\n         zpfl11 = valu\n      when (keyword = 'PF12_LABEL' & (createkw | force)) then\n         zpfl12 = valu\n      when (keyword = 'PF13_LABEL' & (createkw | force)) then\n         zpfl13 = valu\n      when (keyword = 'PF14_LABEL' & (createkw | force)) then\n         zpfl14 = valu\n      when (keyword = 'PF15_LABEL' & (createkw | force)) then\n         zpfl15 = valu\n      when (keyword = 'PF16_LABEL' & (createkw | force)) then\n         zpfl16 = valu\n      when (keyword = 'PF17_LABEL' & (createkw | force)) then\n         zpfl17 = valu\n      when (keyword = 'PF18_LABEL' & (createkw | force)) then\n         zpfl18 = valu\n      when (keyword = 'PF19_LABEL' & (createkw | force)) then\n         zpfl19 = valu\n      when (keyword = 'PF20_LABEL' & (createkw | force)) then\n         zpfl20 = valu\n      when (keyword = 'PF21_LABEL' & (createkw | force)) then\n         zpfl21 = valu\n      when (keyword = 'PF22_LABEL' & (createkw | force)) then\n         zpfl22 = valu\n      when (keyword = 'PF23_LABEL' & (createkw | force)) then\n         zpfl23 = valu\n      when (keyword = 'PF24_LABEL' & (createkw | force)) then\n         zpfl24 = valu\n      when (keyword = 'CALENDAR_SCROLL_BUTTON_COLOR' &,\n            (createkw | force)) then\n         zcalgcsb = valu\n      when (keyword = 'CALENDAR_HEADING_DATE_COLOR' &,\n            (createkw | force)) then\n         zcalgchd = valu\n      when (keyword = 'CALENDAR_HEADING_TEXT_COLOR' &,\n            (createkw | force)) then\n         zcalgcht = valu\n      when (keyword = 'CALENDAR_WEEKDAY_COLOR' &,\n            (createkw | force)) then\n         zcalgcwd = valu\n      when (keyword = 'CALENDAR_SATURDAY_SUNDAY_COLOR' &,\n            (createkw | force)) then\n         zcalgcwe = valu\n      when (keyword = 'CALENDAR_CURRENT_DAY_COLOR' &,\n            (createkw | force)) then\n         zcalgctd = valu\n      when (keyword = 'CALENDAR_START_DATE' &,\n            (createkw | force)) then\n         zcalstrt = valu\n      when (keyword = 'CALENDAR_TIME_FORMAT' &,\n            (createkw | force)) then\n         zcaltime = valu\n      when (keyword = 'MEMLIST_SRCHFOR_MIXED_MODE' &,\n            (createkw | force)) then\n         zmsfmixv = valu\n      when (keyword = 'MEMLIST_SRCHFOR_ANY_CASE' &,\n            (createkw | force)) then\n         zmsfanyc = valu\n      when (keyword = 'MEMLIST_SRCHFOR_ASCII' &,\n            (createkw | force)) then\n         zmsfasci = valu\n      when (keyword = 'MEMLIST_SRCHFOR_SET_EDIT_FIND_STRING' &,\n            (createkw | force)) then\n         zmsfedtf = valu\n      when (keyword = 'MEMLIST_SRCHFOR_SET_BROWSE_FIND_STRING' &,\n            (createkw | force)) then\n         zmsfbrof = valu\n      when (keyword = 'MEMLIST_SRCHFOR_VIEW_OUTPUT' &,\n            (createkw | force)) then\n         zmsfview = valu\n      when (keyword = 'MEMLIST_SRCHFOR_SAVE_OUTPUT' &,\n            (createkw | force)) then\n         zmsfsave = valu\n      when (keyword = 'MEMLIST_SRCHFOR_FILTER_LIST' &,\n            (createkw | force)) then\n         zmsffilt = valu\n      when (keyword = 'DSLIST_SRCHFOR_MIXED_MODE' &,\n            (createkw | force)) then\n         zus4mixv = valu\n      when (keyword = 'DSLIST_SRCHFOR_ANY_CASE' &,\n            (createkw | force)) then\n         zus4anyc = valu\n      when (keyword = 'DSLIST_SRCHFOR_ASCII' &,\n            (createkw | force)) then\n         zus4asci = valu\n      when (keyword = 'DSLIST_SRCHFOR_TOTALS_ONLY' &,\n            (createkw | force)) then\n         zus4tots = valu\n      when (keyword = 'DSLIST_SRCHFOR_FIRST_FOUND' &,\n            (createkw | force)) then\n         zus4stop = valu\n      when (keyword = 'DSLIST_SRCHFOR_VIEW_OUTPUT' &,\n            (createkw | force)) then\n         zus4view = valu\n      when (keyword = 'DSLIST_SRCHFOR_EXCLUDE_NOT_FOUND' &,\n            (createkw | force)) then\n         zus4xnf = valu\n      when (keyword = 'DSLIST_SRCHFOR_SEARCH_MIGRATED' &,\n            (createkw | force)) then\n         zus4migr = valu\n      when (keyword = 'DSLIST_SRCHFOR_SEARCH_EXCLUDED' &,\n            (createkw | force)) then\n         zus4xcld = valu\n      when (keyword = 'UDLIST_SRCHFOR_MIXED_MODE' &,\n            (createkw | force)) then\n         zudfmixv = valu\n      when (keyword = 'UDLIST_SRCHFOR_ANY_CASE' &,\n            (createkw | force)) then\n         zudfanyc = valu\n      when (keyword = 'UDLIST_SRCHFOR_ASCII' &,\n            (createkw | force)) then\n         zudfasci = valu\n      when (keyword = 'UDLIST_SRCHFOR_SET_EDIT_FIND_STRING' &,\n            (createkw | force)) then\n         zudfedtf = valu\n      when (keyword = 'UDLIST_SRCHFOR_SET_BROWSE_FIND_STRING' &,\n            (createkw | force)) then\n         zudfbrof = valu\n      when (keyword = 'UDLIST_SRCHFOR_VIEW_OUTPUT' &,\n            (createkw | force)) then\n         zudfview = valu\n      when (keyword = 'UDLIST_SRCHFOR_SAVE_OUTPUT' &,\n            (createkw | force)) then\n         zudfsave = valu\n      when (keyword = 'UDLIST_WIDTH_OF_FILENAME_COLUMN' &,\n            (createkw | force)) then\n         zulwfnmc = valu\n      when (keyword = 'UDLIST_PATHNAME_SUBSTITUTION_CHARACTER' &,\n            (createkw | force)) then\n         zulfsubc = valu\n      when (keyword = 'UDLIST_ZOS_UNIX_COMMAND_TIME_LIMIT' &,\n            (createkw | force)) then\n         zulshctm = valu\n      when (keyword = 'UDLIST_CONFIRM_FILE_DELETE' &,\n            (createkw | force)) then\n         zulfconv = valu\n      when (keyword = 'UDLIST_CONFIRM_NON-EMPTY_DIRECTORY_DELETE' &,\n            (createkw | force)) then\n         zuldconv = valu\n      when (keyword =,\n            'UDLIST_BYPASS_ZOS_UNIX_FILE_EDIT_OPTIONS_PANEL' &,\n            (createkw | force)) then\n         do\n         trace i\n            zulbyedv = valu\n            if zulbyedv = '/' then\n               zulbyedf = 'ON'\n            else\n               zulbyedf = 'OFF'\n         trace o\n         end\n      when (keyword = 'UDLIST_DISPLAY_PERMISSIONS_IN_OCTAL_FORMAT' &,\n            (createkw | force)) then\n         do\n            zuldpmov = valu\n            if zuldpmov = '/' then\n               zuldpmof = 'ON'\n            else\n               zuldpmof = 'OFF'\n         end\n      when (keyword =,\n            'UDLIST_ENTER_ZOS_UNIX_COMMANDS_IN_COMMAND_FIELD' &,\n            (createkw | force)) then\n         do\n            zuluxpcv = valu\n            if zuluxpcv = '/' then\n               zuluxpcf = 'ON'\n            else\n               zuluxpcf = 'OFF'\n         end\n      when (keyword = 'UDLIST_OUTPUT_MODE' &,\n            (createkw | force)) then\n         zulcmdom = valu\n      when (keyword = 'UDLIST_DIRECTORY_DEFAULT_LINE_COMMAND' &,\n            (createkw | force)) then\n         zuldldir = valu\n      when (keyword = 'UDLIST_REGULAR_FILE_DEFAULT_LINE_COMMAND' &,\n            (createkw | force)) then\n         zuldlreg = valu\n      when (keyword = 'UDLIST_CHARACTER_SPECIAL_DEFAULT_LINE_COMMAND' &,\n            (createkw | force)) then\n         zuldlchs = valu\n      when (keyword = 'UDLIST_FIFO_DEFAULT_LINE_COMMAND' &,\n            (createkw | force)) then\n         zuldlfif = valu\n      when (keyword = 'UDLIST_SYMBOLIC_LINK_LINE_COMMAND' &,\n            (createkw | force)) then\n         zuldlsym = valu\n      when (keyword =,\n            'UDLIST_WIDTH_OF_MOUNT_POINT_COLUMN_IN_MOUNT_POINT_LIST' &,\n            (createkw | force)) then\n         zmtwmtpc = valu\n      when (keyword =,\n            'UDLIST_WIDTH_OF_FILE_SYSTEM_COLUMN_IN_FILE_SYSTEM_LIST' &,\n            (createkw | force)) then\n         zmtwfsyc = valu\n      when (keyword = 'UDLIST_COLUMN_ARRANGEMENT' &,\n            (createkw | force)) then\n           zularr = valu\n      when (keyword = 'MOUNT_TABLE_FILE_SYSTEM_COLUMN_ARRANGEMENT' &,\n            (createkw | force)) then\n           zmtfarr = valu\n      when (keyword = 'MOUNT_TABLE_MOUNT_POINT_COLUMN_ARRANGEMENT' &,\n            (createkw | force)) then\n           zmtmarr = valu\n      otherwise\n         nop\n   end\nend\ncall isprexpx('T')\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USRCCONF": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x8c\\x01\\xe9\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 140, "newlines": 489, "modlines": 0, "user": "TCONLEY"}, "text": "/* rexx */\n/*********************************************************************/\n/*                                                                   */\n/* This exec will run the CUCI dialog to set ISPF defaults that are  */\n/* not included in ISPCCONF.  This is a heavily modified version of  */\n/* the ISPF ISPCCONF dialog.  Modifying the existing execs allows us */\n/* to reuse common code, such as verifying the keyword file.         */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/* Ensure that this exec runs under ISR APPLID.                      */\n/*                                                                   */\n/*********************************************************************/\n  address ispexec 'VGET (ZAPPLID) SHARED'\nif zapplid <> 'ISR' then\n   do\n      address ispexec \"SELECT CMD(%USRCCONF) NEWAPPL(ISR)\"\n      exit\n   end\naddress ispexec\n'CONTROL ERRORS RETURN'\n'VGET (USRVKWD USRVKWDM UCNVOPT) PROFILE'\nm = ''\nc = 'ZCMD'\nlocal_zcmd = ''\ndsrc = 0\ndisplay_rc = 0\ndisplay_rc2 = 0\nDo While display_rc = 0\n   if m \u00ac= ' ' Then\n      msg = 'MSG('m')'\n   Else\n      msg = ''\n   If dsrc > 0 Then\n      zcmd = local_zcmd\n   'DISPLAY PANEL(USRPCONF)' msg 'CURSOR('c')'\n   display_rc = rc\n   m = ''\n   c = 'ZCMD'\n   local_zcmd = zcmd\n   zcmd = ''\n   dsrc = 0\n   If display_rc = 0 Then\n    Do\n      'VPUT (USRVKWD USRVKWDM UCNVOPT) PROFILE'\n      Select\n        When local_zcmd = ' ' Then\n          m = 'ISRU292 '\n        When local_zcmd = 1 Then\n          Do\n            m = 'ISPC250'\n            Call verify_keyword_file\n            If dsrc = 0 Then\n              Do\n                c = 'ZCMD'\n                Address TSO usrcmod\n                dsrc = rc\n                'VGET (USRVOUTN) SHARED'\n                If dsrc > 0 Then\n                  m = ''\n                If dsrc = 4 Then\n                  dsrc = 0\n              End\n          End\n        When local_zcmd = 2 Then\n          Do\n            Call verify_keyword_file\n            If dsrc = 0 Then\n              Do\n                c = 'ZCMD'\n                'CONTROL REFLIST NOUPDATE'\n                \"LMINIT DATASET(\"usrvkwd\") DATAID(DATA1)\"\n                'CONTROL REFLIST UPDATE'\n                \"VIEW DATAID(\"data1\") MEMBER(\"usrvkwdm\")\"\n                e_rc = rc\n                \"LMFREE DATAID(\"data1\")\"\n              End\n          End\n        Otherwise\n          m = 'ISPD241'\n      End\n    End\nEnd\nExit\n/* */\nverify_keyword_file:\n/* Check target data set */\nnotfound = 0\nc = 'USRVKWD'\nIf pos('(',usrvkwd) > 0 Then\n   Do\n      'SETMSG MSG(ISPC282)'\n      dsrc=4\n   End\nIf dsrc = 0 Then\n   Do\n      'CONTROL REFLIST NOUPDATE'\n      'LMINIT DATAID(BB) ENQ(SHR) DATASET('usrvkwd')'\n      dsrc=rc\n      'CONTROL REFLIST UPDATE'\n      If dsrc=0 Then\n         Do\n            'LMOPEN DATAID('bb') OPTION(INPUT) ORG(ORG) LRECL(LRECL)'\n            dsrc = rc\n            If dsrc = 0 Then\n               If org \u00ac= 'PO' | lrecl < 251 Then\n                  Do\n                     'SETMSG MSG(ISPC268)'\n                     dsrc=4\n                  End\n               Else\n                  If usrvkwdm = '' Then\n                     Do\n                        c = 'usrvkwdm'\n                        'SETMSG MSG(ISRU007)'\n                        dsrc=4\n                     End\n                  Else\n                     Do\n                        address ispexec \"LMMFIND DATAID(\"bb\")\",\n                                        \"MEMBER(\"usrvkwdm\")\",\n                                        \"STATS(NO)\"\n                        dsrc = rc\n                        If dsrc = 8 Then\n                           Do\n                              notfound = 1\n                              dsrc = 0\n                           End\n                        Else\n                           c = 'usrvkwdm'\n                     End\n         End\n   End\nIf dsrc > 7 Then\n   'SETMSG MSG(ISRZ002)'\n'LMFREE DATAID('bb')'\n'VPUT (NOTFOUND) SHARED'\nReturn\n/* */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USRCCVWK": {"ttr": 6158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\t\\x00\\x07\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 9, "newlines": 7, "modlines": 0, "user": "TCONLEY"}, "text": "/* rexx */\n/*********************************************************************/\n/*                                                                   */\n/* This exec will VIEW the keyword file for the USRCCONF dialog.     */\n/*                                                                   */\n/*********************************************************************/\naddress ispexec \"VGET (USRVKWD USRVKWDM)\"\ndsn = strip(usrvkwd,'B',\"'\")\naddress ispexec \"VIEW DATASET('\"dsn\"(\"usrvkwdm\")') CONFIRM(NO)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USRCMOD": {"ttr": 6160, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x07\\x8c\\x08\\xc7\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 1932, "newlines": 2247, "modlines": 0, "user": "TCONLEY"}, "text": "/* rexx */\n/*********************************************************************/\n/*                                                                   */\n/* This exec will run the CUCI dialog to set ISPF defaults that are  */\n/* not included in ISPCCONF.  This is a heavily modified version of  */\n/* the ISPF ISPCMOD exec.  Modifying the existing execs allows us to */\n/* to reuse common code, such as setting defaults, generating the    */\n/* keyword file, etc.                                                */\n/*                                                                   */\n/*********************************************************************/\naddress ispexec \"CONTROL ERRORS RETURN\"\nexec_rc = 0\ncall set_defaults      /* initialize panel variables to defaults  */\ncall read_keyword_file /* set panel variables with data from file */\nnot_keyword = 0\nif total_count = bad_count & total_count > 0 then\n  do\n    not_keyword = 1\n    address ispexec \"ADDPOP\"\n    address ispexec \"DISPLAY PANEL(USRPMODQ)\"\n    qrc = rc\n    address ispexec \"REMPOP\"\n    if qrc > 0 then\n      exec_rc = 4\n  end\ndisplay_rc = 0\nc = 'ZCMD'\naddress ispexec \"VGET (UCNVOPT USRVKWD USRVKWDM) PROFILE\"\nusrvkwd2 = usrvkwd\nusrvkwm2 = usrvkwdm\nif notfound = 1 | not_keyword = 1 then\n  address ispexec \"SETMSG MSG(ISPC276)\"\nelse\n  address ispexec \"SETMSG MSG(ISPC277)\"\nif exec_rc = 0 then\n  do while display_rc = 0\n    address ispexec \"DISPLAY PANEL(USRPMOD) CURSOR(\"c\")\"\n    display_rc = rc\n    c = 'ZCMD'\n    address ispexec \"VPUT (USRVKWD,USRVKWDM) PROFILE\"\n    if display_rc = 0 then\n      do\n        if usrvkwd2 = '' then\n          usrvkwd2 = usrvkwd\n        if usrvkwm2 = '' then\n          usrvkwm2 = usrvkwdm\n        dsrc = 0\n        call verify_keyword_file_exists\n        if dsrc = 0 then\n          do\n            usrvout = usrvkwd2\n            usrvoutm = usrvkwm2\n          end\n        if dsrc = 0 then\n          do\n            c = 'ZCMD'\n            select\n               when (zcmd >= 1 & zcmd <= 4) then\n                  do\n                    usrvsel = zcmd\n                    panel_id = 'USRPMOD'||zcmd\n                    display_rc2 = 0\n                      do while display_rc2 = 0\n                        zcmd = ''\n                        address ispexec \"DISPLAY PANEL(\"panel_id\")\"\n                        display_rc2 = rc\n                        call reset_defaults\n                        if display_rc2 > 12 then\n                          address ispexec \"SETMSG MSG(\"zerrmsg\")\"\n                      end\n                  end\n               when (zcmd = 5) then\n                  do\n                     call column_table('UULARR')\n                  end\n               when (zcmd = 6) then\n                  do\n                     call column_table('UMTFARR')\n                  end\n               when (zcmd = 7) then\n                  do\n                     call column_table('UMTMARR')\n                  end\n               otherwise\n                  address ispexec \"SETMSG MSG(ISPD241)\"\n            end\n          end\n      end\n    else\n      if display_rc = 8 then\n        do\n          address ispexec \"VGET (ZVERB) SHARED\"\n          if zverb \u00ac= 'CANCEL' then\n            do\n              dsrc = 0\n              if usrvkwd2 = '' then\n                usrvkwd2 = usrvkwd\n              if usrvkwm2 = '' then\n                usrvkwm2 = usrvkwdm\n              dsrc = 0\n              call verify_keyword_file_exists\n              if dsrc = 0 then\n                do\n                  usrvout = usrvkwd2\n                  usrvoutm = usrvkwm2\n                end\n              if dsrc = 0 then\n                do\n                  c = 'ZCMD'\n                  outlines = 0\n                  outlines2 = 0\n                  call create_header\n                  call create_output\n                  call write_output\n                end\n            end\n          else\n            exec_rc = 4\n        end\n  end\nExit exec_rc\n/* */\nverify_keyword_file_exists:\n/* Check target data set to see if it exists and is partitioned */\nc = 'USRVKWD2'\nif pos('(',usrvkwd) > 0 then\n  do\n    address ispexec \"SETMSG MSG(ISPC282)\"\n    dsrc=4\n  end\naddress ispexec \"CONTROL REFLIST NOUPDATE\"\naddress ispexec \"LMINIT DATAID(BB) ENQ(SHR) DATASET(\"usrvkwd2\")\"\ndsrc=rc\naddress ispexec \"CONTROL REFLIST UPDATE\"\nif dsrc=0 then\n  do\n    address ispexec \"LMOPEN DATAID(\"bb\") OPTION(INPUT) ORG(ORG) LRECL(LRECL)\"\n    dsrc = rc\n    if dsrc = 0 then\n      if org \u00ac= 'PO' | lrecl < 251 then\n        do\n          address ispexec \"SETMSG MSG(ISPC268)\"\n          dsrc=4\n        end\n      else\n        if usrvkwm2 = '' then\n          do\n            address ispexec \"SETMSG MSG(ISRU007)\"\n            dsrc=4\n          end\n  end\nif dsrc>7 then\n  address ispexec \"SETMSG MSG(ISRZ002)\"\naddress ispexec \"LMFREE DATAID(\"bb\")\"\nreturn\n/* */\nset_defaults:\n/* PFKeys and force variables */\nupf01    = 'HELP    '\nupf02    = 'SPLIT   '\nupf03    = 'END     '\nupf04    = 'RETURN  '\nupf05    = 'RFIND   '\nupf06    = 'RCHANGE '\nupf07    = 'UP      '\nupf08    = 'DOWN    '\nupf09    = 'SWAP    '\nupf10    = 'LEFT    '\nupf11    = 'RIGHT   '\nupf12    = 'RETRIEVE'\nupf13    = 'HELP    '\nupf14    = 'SPLIT   '\nupf15    = 'END     '\nupf16    = 'RETURN  '\nupf17    = 'RFIND   '\nupf18    = 'RCHANGE '\nupf19    = 'UP      '\nupf20    = 'DOWN    '\nupf21    = 'SWAP    '\nupf22    = 'LEFT    '\nupf23    = 'RIGHT   '\nupf24    = 'RETRIEVE'\nfupf01   = ' '\nfupf02   = ' '\nfupf03   = ' '\nfupf04   = ' '\nfupf05   = ' '\nfupf06   = ' '\nfupf07   = ' '\nfupf08   = ' '\nfupf09   = ' '\nfupf10   = ' '\nfupf11   = ' '\nfupf12   = ' '\nfupf13   = ' '\nfupf14   = ' '\nfupf15   = ' '\nfupf16   = ' '\nfupf17   = ' '\nfupf18   = ' '\nfupf19   = ' '\nfupf20   = ' '\nfupf21   = ' '\nfupf22   = ' '\nfupf23   = ' '\nfupf24   = ' '\n/* PFKey Labels and Force variables */\nupfl01   = '        '\nupfl02   = '        '\nupfl03   = '        '\nupfl04   = '        '\nupfl05   = '        '\nupfl06   = '        '\nupfl07   = '        '\nupfl08   = '        '\nupfl09   = '        '\nupfl10   = '        '\nupfl11   = '        '\nupfl12   = '        '\nupfl13   = '        '\nupfl14   = '        '\nupfl15   = '        '\nupfl16   = '        '\nupfl17   = '        '\nupfl18   = '        '\nupfl19   = '        '\nupfl20   = '        '\nupfl21   = '        '\nupfl22   = '        '\nupfl23   = '        '\nupfl24   = '        '\nfupfl01  = ' '\nfupfl02  = ' '\nfupfl03  = ' '\nfupfl04  = ' '\nfupfl05  = ' '\nfupfl06  = ' '\nfupfl07  = ' '\nfupfl08  = ' '\nfupfl09  = ' '\nfupfl10  = ' '\nfupfl11  = ' '\nfupfl12  = ' '\nfupfl13  = ' '\nfupfl14  = ' '\nfupfl15  = ' '\nfupfl16  = ' '\nfupfl17  = ' '\nfupfl18  = ' '\nfupfl19  = ' '\nfupfl20  = ' '\nfupfl21  = ' '\nfupfl22  = ' '\nfupfl23  = ' '\nfupfl24  = ' '\n/* Calendar options and Force variables */\nualdctsb = '8'\nualdcthd = '8'\nualdctht = '8'\nualdctwd = '8'\nualdctwe = '8'\nualdcttd = '8'\nnewsd    = '1'\nnewtm    = '1'\nfaldctsb = ' '\nfaldcthd = ' '\nfaldctht = ' '\nfaldctwd = ' '\nfaldctwe = ' '\nfaldcttd = ' '\nnewsdf   = ' '\nnewtmf   = ' '\n/* MEMLIST SRCHFOR options and Force variables */\numsfmixv = ' '\numsfanyc = ' '\numsfasci = ' '\numsfedtf = ' '\numsfbrof = ' '\numsffilt = ' '\numsfview = ' '\numsfsave = ' '\nfmsfmixv = ' '\nfmsfanyc = ' '\nfmsfasci = ' '\nfmsfedtf = ' '\nfmsfbrof = ' '\nfmsffilt = ' '\nfmsfview = ' '\nfmsfsave = ' '\n/* DSLIST SRCHFOR options and Force variables */\nuus4mixv = ' '\nuus4anyc = ' '\nuus4asci = ' '\nuus4tots = ' '\nuus4stop = ' '\nuus4view = ' '\nuus4xnf  = ' '\nuus4migr = '1'\nuus4xcld = '3'\nfus4mixv = ' '\nfus4anyc = ' '\nfus4asci = ' '\nfus4tots = ' '\nfus4stop = ' '\nfus4view = ' '\nfus4xnf  = ' '\nfus4migr = ' '\nfus4xcld = ' '\n/* UDLIST SRCHFOR options and Force variables */\nuudfmixv = ' '\nuudfanyc = ' '\nuudfasci = ' '\nuudfedtf = ' '\nuudfbrof = ' '\nuudfview = ' '\nuudfsave = ' '\nfudfmixv = ' '\nfudfanyc = ' '\nfudfasci = ' '\nfudfedtf = ' '\nfudfbrof = ' '\nfudfview = ' '\nfudfsave = ' '\n/* UDLIST Directory List and Mount Table Options and Force variables */\nusrwfnmc = '15'\nusrfsubc = '!'\nusrshctm = ' '\nusrfconv = '/'\nusrdconv = '/'\nusrbyedv = ' '\nusrdpmov = ' '\nusruxpcv = ' '\nusrcmdom = '2'\nusrdldir = 'L'\nusrdlreg = 'B'\nusrdlchs = 'I'\nusrdlfif = 'I'\nusrdlsym = 'I'\nusrwmtpc = '35'\nusrwfsyc = '35'\nfsrwfnmc = ' '\nfsrfsubc = ' '\nfsrshctm = ' '\nfsrfconv = ' '\nfsrdconv = ' '\nfsrbyedv = ' '\nfsrdpmov = ' '\nfsruxpcv = ' '\nfsrcmdom = ' '\nfsrdldir = ' '\nfsrdlreg = ' '\nfsrdlchs = ' '\nfsrdlfif = ' '\nfsrdlsym = ' '\nfsrwmtpc = ' '\nfsrwfsyc = ' '\n/* UDLIST column arrangements and Force variables */\nuularr    = 'UDLCOLS ' || '010D010101040202020A0303050604040604'x\nuularr    = uularr || '050507040606040807070808'x\nuularr    = uularr || '0808090609090A0A0A0A0B130B0B0C130C0C0D130D0D0E13'x\numtfarr   = 'MTBFCOLS' || '0108000002230101012302020304'x\numtfarr   = umtfarr || '0303050404040608050507030606040A0707080A'x\numtmarr   = 'MTBMCOLS' || '0108000001230101022302020304'x\numtmarr   = umtmarr || '0303050404040608050507030606040A0707080A'x\nuularrdf  = uularr\numtfarrdf = umtfarr\numtmarrdf = umtmarr\nfularr    = ' '\nfmtfarr   = ' '\nfmtmarr   = ' '\nreturn\n/* */\nreset_defaults:\nif upf01 = ' ' then upf01 = 'HELP    '\nif upf02 = ' ' then upf02 = 'SPLIT   '\nif upf03 = ' ' then upf03 = 'END     '\nif upf04 = ' ' then upf04 = 'RETURN  '\nif upf05 = ' ' then upf05 = 'RFIND   '\nif upf06 = ' ' then upf06 = 'RCHANGE '\nif upf07 = ' ' then upf07 = 'UP      '\nif upf08 = ' ' then upf08 = 'DOWN    '\nif upf09 = ' ' then upf09 = 'SWAP    '\nif upf10 = ' ' then upf10 = 'LEFT    '\nif upf11 = ' ' then upf11 = 'RIGHT   '\nif upf12 = ' ' then upf12 = 'RETRIEVE'\nif upf13 = ' ' then upf13 = 'HELP    '\nif upf14 = ' ' then upf14 = 'SPLIT   '\nif upf15 = ' ' then upf15 = 'END     '\nif upf16 = ' ' then upf16 = 'RETURN  '\nif upf17 = ' ' then upf17 = 'RFIND   '\nif upf18 = ' ' then upf18 = 'RCHANGE '\nif upf19 = ' ' then upf19 = 'UP      '\nif upf20 = ' ' then upf20 = 'DOWN    '\nif upf21 = ' ' then upf21 = 'SWAP    '\nif upf22 = ' ' then upf22 = 'LEFT    '\nif upf23 = ' ' then upf23 = 'RIGHT   '\nif upf24 = ' ' then upf24 = 'RETRIEVE'\nif ualdctsb = ' ' then ualdctsb = '8'\nif ualdcthd = ' ' then ualdcthd = '8'\nif ualdctht = ' ' then ualdctht = '8'\nif ualdctwd = ' ' then ualdctwd = '8'\nif ualdctwe = ' ' then ualdctwe = '8'\nif ualdcttd = ' ' then ualdctsb = '8'\nif newsd    = ' ' then newsd    = '1'\nif newtm    = ' ' then newtm    = '1'\nif uus4migr = ' ' then uus4migr = '1'\nif uus4xcld = ' ' then uus4xcld = '3'\nif usrwfnmc = ' ' then usrwfnmc = '15'\nif usrfsubc = ' ' then usrfsubc = '!'\nif usrfconv = ' ' then usrfconv = '/'\nif usrdconv = ' ' then usrdconv = '/'\nif usrcmdom = ' ' then usrcmdom = '2'\nif usrdldir = ' ' then usrdldir = 'L'\nif usrdlreg = ' ' then usrdlreg = 'B'\nif usrdlchs = ' ' then usrdlchs = 'I'\nif usrdlfif = ' ' then usrdlfif = 'I'\nif usrdlsym = ' ' then usrdlsym = 'I'\nif usrwmtpc = ' ' then usrwmtpc = '35'\nif usrwfsyc = ' ' then usrwfsyc = '35'\nreturn\n/* */\nread_keyword_file:\naddress ispexec \"VGET (USRVKWD,USRVKWDM) PROFILE\"\naddress ispexec \"VGET (NOTFOUND) SHARED\"\nif substr(usrvkwd,1,1) = \"'\" then\n  kwdname = \"'\"strip(usrvkwd,'B',\"'\")\"(\"usrvkwdm\")'\"\nelse\n  kwdname = strip(usrvkwd,'B',\"'\")\"(\"usrvkwdm\")\"\nzkwd = kwdname                         /* msg ISPC276 needs   @015a */\naddress ispexec \"VPUT (ZKWD) SHARED\"   /* ZKWD to be set      @015a */\naddress tso \"ALLOC F(INFILE) DA(\"kwdname\") SHR REU\"\nif rc > 0 then\n  do\n    exec_rc = 8\n    address ispexec address ispexec \"SETMSG MSG(ISPC261)\"\n  end\nif exec_rc = 0 & notfound = 0 then\n  do\n    address tso \"EXECIO * DISKR INFILE (FINIS STEM CONFIG.\"\n    if rc > 0 then\n      do\n        exec_rc = 8\n        address ispexec \"SETMSG MSG(ISPC262)\"\n      end\n  end\ntotal_count = 0\nbad_count = 0\nif exec_rc = 0 & notfound = 0 then\n  do i = 1 to config.0\n    Parse Var config.i first rest\n    first = strip(first)\n    if substr(first,1,1) \u00ac= '*' &,\n       substr(first,1,2) \u00ac= '/*' then\n      call process_keyword\n  end\naddress tso \"FREE FI(INFILE)\"\nreturn\n/* */\nprocess_keyword:\ntotal_count = total_count + 1\nparse value config.i with keyword '=' Valu ',' force\nUpper keyword\nvalu = strip(valu)\nif valu = 'NONE' then\n  valu = ''\nselect\n   when keyword = 'PF01' then\n      do\n         upf01  = valu\n         fupf01 = force\n      end\n   when keyword = 'PF02' then\n      do\n         upf02  = valu\n         fupf02 = force\n      end\n   when keyword = 'PF03' then\n      do\n         upf03  = valu\n         fupf03 = force\n      end\n   when keyword = 'PF04' then\n      do\n         upf04  = valu\n         fupf04 = force\n      end\n   when keyword = 'PF05' then\n      do\n         upf05  = valu\n         fupf05 = force\n      end\n   when keyword = 'PF06' then\n      do\n         upf06  = valu\n         fupf06 = force\n      end\n   when keyword = 'PF07' then\n      do\n         upf07  = valu\n         fupf07 = force\n      end\n   when keyword = 'PF08' then\n      do\n         upf08  = valu\n         fupf08 = force\n      end\n   when keyword = 'PF09' then\n      do\n         upf09  = valu\n         fupf09 = force\n      end\n   when keyword = 'PF10' then\n      do\n         upf10  = valu\n         fupf10 = force\n      end\n   when keyword = 'PF11' then\n      do\n         upf11  = valu\n         fupf11 = force\n      end\n   when keyword = 'PF12' then\n      do\n         upf12  = valu\n         fupf12 = force\n      end\n   when keyword = 'PF13' then\n      do\n         upf13  = valu\n         fupf13 = force\n      end\n   when keyword = 'PF14' then\n      do\n         upf14  = valu\n         fupf14 = force\n      end\n   when keyword = 'PF15' then\n      do\n         upf15  = valu\n         fupf15 = force\n      end\n   when keyword = 'PF16' then\n      do\n         upf16  = valu\n         fupf16 = force\n      end\n   when keyword = 'PF17' then\n      do\n         upf17  = valu\n         fupf17 = force\n      end\n   when keyword = 'PF18' then\n      do\n         upf18  = valu\n         fupf18 = force\n      end\n   when keyword = 'PF19' then\n      do\n         upf19  = valu\n         fupf19 = force\n      end\n   when keyword = 'PF20' then\n      do\n         upf20  = valu\n         fupf20 = force\n      end\n   when keyword = 'PF21' then\n      do\n         upf21  = valu\n         fupf21 = force\n      end\n   when keyword = 'PF22' then\n      do\n         upf22  = valu\n         fupf22 = force\n      end\n   when keyword = 'PF23' then\n      do\n         upf23  = valu\n         fupf23 = force\n      end\n   when keyword = 'PF24' then\n      do\n         upf24  = valu\n         fupf24 = force\n      end\n   when keyword = 'PF01_LABEL' then\n      do\n         upfl01  = valu\n         fupfl01 = force\n      end\n   when keyword = 'PF02_LABEL' then\n      do\n         upfl02  = valu\n         fupfl02 = force\n      end\n   when keyword = 'PF03_LABEL' then\n      do\n         upfl03  = valu\n         fupfl03 = force\n      end\n   when keyword = 'PF04_LABEL' then\n      do\n         upfl04  = valu\n         fupfl04 = force\n      end\n   when keyword = 'PF05_LABEL' then\n      do\n         upfl05  = valu\n         fupfl05 = force\n      end\n   when keyword = 'PF06_LABEL' then\n      do\n         upfl06  = valu\n         fupfl06 = force\n      end\n   when keyword = 'PF07_LABEL' then\n      do\n         upfl07  = valu\n         fupfl07 = force\n      end\n   when keyword = 'PF08_LABEL' then\n      do\n         upfl08  = valu\n         fupfl08 = force\n      end\n   when keyword = 'PF09_LABEL' then\n      do\n         upfl09  = valu\n         fupfl09 = force\n      end\n   when keyword = 'PF10_LABEL' then\n      do\n         upfl10  = valu\n         fupfl10 = force\n      end\n   when keyword = 'PF11_LABEL' then\n      do\n         upfl11  = valu\n         fupfl11 = force\n      end\n   when keyword = 'PF12_LABEL' then\n      do\n         upfl12  = valu\n         fupfl12 = force\n      end\n   when keyword = 'PF13_LABEL' then\n      do\n         upfl13  = valu\n         fupfl13 = force\n      end\n   when keyword = 'PF14_LABEL' then\n      do\n         upfl14  = valu\n         fupfl14 = force\n      end\n   when keyword = 'PF15_LABEL' then\n      do\n         upfl15  = valu\n         fupfl15 = force\n      end\n   when keyword = 'PF16_LABEL' then\n      do\n         upfl16  = valu\n         fupfl16 = force\n      end\n   when keyword = 'PF17_LABEL' then\n      do\n         upfl17  = valu\n         fupfl17 = force\n      end\n   when keyword = 'PF18_LABEL' then\n      do\n         upfl18  = valu\n         fupfl18 = force\n      end\n   when keyword = 'PF19_LABEL' then\n      do\n         upfl19  = valu\n         fupfl19 = force\n      end\n   when keyword = 'PF20_LABEL' then\n      do\n         upfl20  = valu\n         fupfl20 = force\n      end\n   when keyword = 'PF21_LABEL' then\n      do\n         upfl21  = valu\n         fupfl21 = force\n      end\n   when keyword = 'PF22_LABEL' then\n      do\n         upfl22  = valu\n         fupfl22 = force\n      end\n   when keyword = 'PF23_LABEL' then\n      do\n         upfl23  = valu\n         fupfl23 = force\n      end\n   when keyword = 'PF24_LABEL' then\n      do\n         upfl24  = valu\n         fupfl24 = force\n      end\n   when keyword = 'CALENDAR_SCROLL_BUTTON_COLOR' then\n      do\n         ualdctsb = valu\n         faldctsb = force\n      end\n   when keyword = 'CALENDAR_HEADING_DATE_COLOR' then\n      do\n         ualdcthd = valu\n         faldcthd = force\n      end\n   when keyword = 'CALENDAR_HEADING_TEXT_COLOR' then\n      do\n         ualdctht = valu\n         faldctht = force\n      end\n   when keyword = 'CALENDAR_WEEKDAY_COLOR' then\n      do\n         ualdctwd = valu\n         faldctwd = force\n      end\n   when keyword = 'CALENDAR_SATURDAY_SUNDAY_COLOR' then\n      do\n         ualdctwe = valu\n         faldctwe = force\n      end\n   when keyword = 'CALENDAR_CURRENT_DAY_COLOR' then\n      do\n         ualdcttd = valu\n         faldcttd = force\n      end\n   when keyword = 'CALENDAR_START_DATE' then\n      do\n         newsd  = valu\n         newsdf = force\n      end\n   when keyword = 'CALENDAR_TIME_FORMAT' then\n      do\n         newtm  = valu\n         newtmf = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_MIXED_MODE' then\n      do\n         umsfmixv = valu\n         fmsfmixv = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_ANY_CASE' then\n      do\n         umsfanyc = valu\n         fmsfanyc = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_ASCII' then\n      do\n         umsfasci = valu\n         fmsfasci = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_SET_EDIT_FIND_STRING' then\n      do\n         umsfedtf = valu\n         fmsfedtf = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_SET_BROWSE_FIND_STRING' then\n      do\n         umsfbrof = valu\n         fmsfbrof = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_VIEW_OUTPUT' then\n      do\n         umsfview = valu\n         fmsfview = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_SAVE_OUTPUT' then\n      do\n         umsfsave = valu\n         fmsfsave = force\n      end\n   when keyword = 'MEMLIST_SRCHFOR_FILTER_LIST' then\n      do\n         umsffilt = valu\n         fmsffilt = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_MIXED_MODE' then\n      do\n         uus4mixv = valu\n         fus4mixv = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_ANY_CASE' then\n      do\n         uus4anyc = valu\n         fus4anyc = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_ASCII' then\n      do\n         uus4asci = valu\n         fus4asci = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_TOTALS_ONLY' then\n      do\n         uus4tots = valu\n         fus4tots = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_FIRST_FOUND' then\n      do\n         uus4stop = valu\n         fus4stop = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_VIEW_OUTPUT' then\n      do\n         uus4view = valu\n         fus4view = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_EXCLUDE_NOT_FOUND' then\n      do\n         uus4xnf = valu\n         fus4xnf = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_SEARCH_MIGRATED' then\n      do\n         uus4migr = valu\n         fus4migr = force\n      end\n   when keyword = 'DSLIST_SRCHFOR_SEARCH_EXCLUDED' then\n      do\n         uus4xcld = valu\n         fus4xcld = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_MIXED_MODE' then\n      do\n         uudfmixv = valu\n         fudfmixv = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_ANY_CASE' then\n      do\n         uudfanyc = valu\n         fudfanyc = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_ASCII' then\n      do\n         uudfasci = valu\n         fudfasci = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_SET_EDIT_FIND_STRING' then\n      do\n         uudfedtf = valu\n         fudfedtf = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_SET_BROWSE_FIND_STRING' then\n      do\n         uudfbrof = valu\n         fudfbrof = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_VIEW_OUTPUT' then\n      do\n         uudfview = valu\n         fudfview = force\n      end\n   when keyword = 'UDLIST_SRCHFOR_SAVE_OUTPUT' then\n      do\n         uudfsave = valu\n         fudfsave = force\n      end\n   when keyword = 'UDLIST_WIDTH_OF_FILENAME_COLUMN' then\n      do\n         usrwfnmc = valu\n         fsrwfnmc = force\n      end\n   when keyword = 'UDLIST_PATHNAME_SUBSTITUTION_CHARACTER' then\n      do\n         usrfsubc = valu\n         fsrfsubc = force\n      end\n   when keyword = 'UDLIST_ZOS_UNIX_COMMAND_TIME_LIMIT' then\n      do\n         usrshctm = valu\n         fsrshctm = force\n      end\n   when keyword = 'UDLIST_CONFIRM_FILE_DELETE' then\n      do\n         usrfconv = valu\n         fsrfconv = force\n      end\n   when keyword = 'UDLIST_CONFIRM_NON-EMPTY_DIRECTORY_DELETE' then\n      do\n         usrdconv = valu\n         fsrdconv = force\n      end\n   when keyword =,\n        'UDLIST_BYPASS_ZOS_UNIX_FILE_EDIT_OPTIONS_PANEL' then\n      do\n         usrbyedv = valu\n         fsrbyedv = force\n      end\n   when keyword = 'UDLIST_DISPLAY_PERMISSIONS_IN_OCTAL_FORMAT' then\n      do\n         usrdpmov = valu\n         fsrdpmov = force\n      end\n   when keyword =,\n        'UDLIST_ENTER_ZOS_UNIX_COMMANDS_IN_COMMAND_FIELD' then\n      do\n         usruxpcv = valu\n         fsruxpcv = force\n      end\n   when keyword = 'UDLIST_OUTPUT_MODE' then\n      do\n         usrcmdom = valu\n         fsrcmdom = force\n      end\n   when keyword = 'UDLIST_DIRECTORY_DEFAULT_LINE_COMMAND' then\n      do\n         usrdldir = valu\n         fsrdldir = force\n      end\n   when keyword = 'UDLIST_REGULAR_FILE_DEFAULT_LINE_COMMAND' then\n      do\n         usrdlreg = valu\n         fsrdlreg = force\n      end\n   when keyword = 'UDLIST_CHARACTER_SPECIAL_DEFAULT_LINE_COMMAND' then\n      do\n         usrdlchs = valu\n         fsrdlchs = force\n      end\n   when keyword = 'UDLIST_FIFO_DEFAULT_LINE_COMMAND' then\n      do\n         usrdlfif = valu\n         fsrdlfif = force\n      end\n   when keyword = 'UDLIST_SYMBOLIC_LINK_LINE_COMMAND' then\n      do\n         usrdlsym = valu\n         fsrdlsym = force\n      end\n   when keyword =,\n        'UDLIST_WIDTH_OF_MOUNT_POINT_COLUMN_IN_MOUNT_POINT_LIST' then\n      do\n         usrwmtpc = valu\n         fsrwmtpc = force\n      end\n   when keyword =,\n        'UDLIST_WIDTH_OF_FILE_SYSTEM_COLUMN_IN_FILE_SYSTEM_LIST' then\n      do\n         usrwfsyc = valu\n         fsrwfsyc = force\n      end\n   when keyword = 'UDLIST_COLUMN_ARRANGEMENT' then\n      do\n        uularr = valu\n        fularr = force\n      end\n   when keyword = 'MOUNT_TABLE_FILE_SYSTEM_COLUMN_ARRANGEMENT' then\n      do\n        umtfarr = valu\n        fmtfarr = force\n      end\n   when keyword = 'MOUNT_TABLE_MOUNT_POINT_COLUMN_ARRANGEMENT' then\n      do\n        umtmarr = valu\n        fmtmarr = force\n      end\n   otherwise\n      bad_count = bad_count + 1\nend\nreturn\n/* */\ncreate_header:\nstuff = '/* ISPF CUCI Configuration for settings not in ISPCCONF'\ncall addline stuff\nstuff = '/*   Generated by Rexx USRCMOD'\ncall addline stuff\nstuff = ''\ncall addline '/*   Created 'time()' on 'date()\ncall addline '/*   by user 'userid()'.'\nif ucnvopt = 'CHG' then\n  call addline '/*   Defaults were included as comments.'\nelse if ucnvopt = 'ALL' then\n  call addline '/*   All values were included.'\nelse\n  call addline '/*   Only values which differ from the defaults were',\n               ||' included.'\ncall addline '/*'\nreturn\n/* */\naddline:\nParse Arg line\nline = strip(line,'T')\noutlines = outlines + 1\nif substr(line,1,2)='/*' & substr(line,length(line)-1,2)\u00ac='*/' then\n line=left(line,max(length(line),70))||'*/'\noutput.outlines = line\nreturn\n/* */\naddline2:\nParse Arg line\nline = strip(line,'T')\noutlines2 = outlines2 + 1\nif substr(line,1,2)='/*' & substr(line,length(line)-1,2)\u00ac='*/' then\n line=left(line,max(length(line),70))||'*/'\noutput2.outlines2 = line\nreturn\n/* */\ncreate_output:\n/*------------------------------------------------------------------*/\ncall header 'PFKeys'\n/*------------------------------------------------------------------*/\n\ncall chkvalue 'PF01'                              ,'HELP    ',upf01,,\n               fupf01\ncall chkvalue 'PF02'                              ,'SPLIT   ',upf02,,\n               fupf02\ncall chkvalue 'PF03'                              ,'END     ',upf03,,\n               fupf03\ncall chkvalue 'PF04'                              ,'RETURN  ',upf04,,\n               fupf04\ncall chkvalue 'PF05'                              ,'RFIND   ',upf05,,\n               fupf05\ncall chkvalue 'PF06'                              ,'RCHANGE ',upf06,,\n               fupf06\ncall chkvalue 'PF07'                              ,'UP      ',upf07,,\n               fupf07\ncall chkvalue 'PF08'                              ,'DOWN    ',upf08,,\n               fupf08\ncall chkvalue 'PF09'                              ,'SWAP    ',upf09,,\n               fupf09\ncall chkvalue 'PF10'                              ,'LEFT    ',upf10,,\n               fupf10\ncall chkvalue 'PF11'                              ,'RIGHT   ',upf11,,\n               fupf11\ncall chkvalue 'PF12'                              ,'RETRIEVE',upf12,,\n               fupf12\ncall chkvalue 'PF13'                              ,'HELP    ',upf13,,\n               fupf13\ncall chkvalue 'PF14'                              ,'SPLIT   ',upf14,,\n               fupf14\ncall chkvalue 'PF15'                              ,'END     ',upf15,,\n               fupf15\ncall chkvalue 'PF16'                              ,'RETURN  ',upf16,,\n               fupf16\ncall chkvalue 'PF17'                              ,'RFIND   ',upf17,,\n               fupf17\ncall chkvalue 'PF18'                              ,'RCHANGE ',upf18,,\n               fupf18\ncall chkvalue 'PF19'                              ,'UP      ',upf19,,\n               fupf19\ncall chkvalue 'PF20'                              ,'DOWN    ',upf20,,\n               fupf20\ncall chkvalue 'PF21'                              ,'SWAP    ',upf21,,\n               fupf21\ncall chkvalue 'PF22'                              ,'LEFT    ',upf22,,\n               fupf22\ncall chkvalue 'PF23'                              ,'RIGHT   ',upf23,,\n               fupf23\ncall chkvalue 'PF24'                              ,'RETRIEVE',upf24,,\n               fupf24\ncall chkvalue 'PF01_LABEL'                        ,'        ',upfl01,,\n               fupfl01\ncall chkvalue 'PF02_LABEL'                        ,'        ',upfl02,,\n               fupfl02\ncall chkvalue 'PF03_LABEL'                        ,'        ',upfl03,,\n               fupfl03\ncall chkvalue 'PF04_LABEL'                        ,'        ',upfl04,,\n               fupfl04\ncall chkvalue 'PF05_LABEL'                        ,'        ',upfl05,,\n               fupfl05\ncall chkvalue 'PF06_LABEL'                        ,'        ',upfl06,,\n               fupfl06\ncall chkvalue 'PF07_LABEL'                        ,'        ',upfl07,,\n               fupfl07\ncall chkvalue 'PF08_LABEL'                        ,'        ',upfl08,,\n               fupfl08\ncall chkvalue 'PF09_LABEL'                        ,'        ',upfl09,,\n               fupfl09\ncall chkvalue 'PF10_LABEL'                        ,'        ',upfl10,,\n               fupfl10\ncall chkvalue 'PF11_LABEL'                        ,'        ',upfl11,,\n               fupfl11\ncall chkvalue 'PF12_LABEL'                        ,'        ',upfl12,,\n               fupfl12\ncall chkvalue 'PF13_LABEL'                        ,'        ',upfl13,,\n               fupfl13\ncall chkvalue 'PF14_LABEL'                        ,'        ',upfl14,,\n               fupfl14\ncall chkvalue 'PF15_LABEL'                        ,'        ',upfl15,,\n               fupfl15\ncall chkvalue 'PF16_LABEL'                        ,'        ',upfl16,,\n               fupfl16\ncall chkvalue 'PF17_LABEL'                        ,'        ',upfl17,,\n               fupfl17\ncall chkvalue 'PF18_LABEL'                        ,'        ',upfl18,,\n               fupfl18\ncall chkvalue 'PF19_LABEL'                        ,'        ',upfl19,,\n               fupfl19\ncall chkvalue 'PF20_LABEL'                        ,'        ',upfl20,,\n               fupfl20\ncall chkvalue 'PF21_LABEL'                        ,'        ',upfl21,,\n               fupfl21\ncall chkvalue 'PF22_LABEL'                        ,'        ',upfl22,,\n               fupfl22\ncall chkvalue 'PF23_LABEL'                        ,'        ',upfl23,,\n               fupfl23\ncall chkvalue 'PF24_LABEL'                        ,'        ',upfl24,,\n               fupfl24\n/*------------------------------------------------------------------*/\ncall header 'Calendar Options'\n/*------------------------------------------------------------------*/\ncall chkvalue 'CALENDAR_SCROLL_BUTTON_COLOR'           ,'8',ualdctsb,,\n               faldctsb\ncall chkvalue 'CALENDAR_HEADING_DATE_COLOR'            ,'8',ualdcthd,,\n               faldcthd\ncall chkvalue 'CALENDAR_HEADING_TEXT_COLOR'            ,'8',ualdctht,,\n               faldctht\ncall chkvalue 'CALENDAR_WEEKDAY_COLOR'                 ,'8',ualdctwd,,\n               faldctwd\ncall chkvalue 'CALENDAR_SATURDAY_SUNDAY_COLOR'         ,'8',ualdctwe,,\n               faldctwe\ncall chkvalue 'CALENDAR_CURRENT_DAY_COLOR'             ,'8',ualdcttd,,\n               faldcttd\ncall chkvalue 'CALENDAR_START_DATE'                    ,'1',newsd,,\n               newsdf\ncall chkvalue 'CALENDAR_TIME_FORMAT'                   ,'1',newtm,,\n               newtmf\n/*------------------------------------------------------------------*/\ncall header 'MEMLIST SRCHFOR Options'\n/*------------------------------------------------------------------*/\n\ncall chkvalue 'MEMLIST_SRCHFOR_MIXED_MODE'             ,' '  ,umsfmixv,,\n               fmsfmixv\ncall chkvalue 'MEMLIST_SRCHFOR_ANY_CASE'               ,' '  ,umsfanyc,,\n               fmsfanyc\ncall chkvalue 'MEMLIST_SRCHFOR_ASCII'                  ,' '  ,umsfasci,,\n               fmsfasci\ncall chkvalue 'MEMLIST_SRCHFOR_SET_EDIT_FIND_STRING'   ,' '  ,umsfedtf,,\n               fmsfedtf\ncall chkvalue 'MEMLIST_SRCHFOR_SET_BROWSE_FIND_STRING' ,' '  ,umsfbrof,,\n               fmsfbrof\ncall chkvalue 'MEMLIST_SRCHFOR_VIEW_OUTPUT'            ,' '  ,umsfview,,\n               fmsfview\ncall chkvalue 'MEMLIST_SRCHFOR_SAVE_OUTPUT'            ,' '  ,umsfsave,,\n               fmsfsave\ncall chkvalue 'MEMLIST_SRCHFOR_FILTER_LIST'            ,' '  ,umsffilt,,\n               fmsffilt\n/*------------------------------------------------------------------*/\ncall header 'DSLIST SRCHFOR Options'\n/*------------------------------------------------------------------*/\n\ncall chkvalue 'DSLIST_SRCHFOR_MIXED_MODE'              ,' '  ,uus4mixv,,\n               fus4mixv\ncall chkvalue 'DSLIST_SRCHFOR_ANY_CASE'                ,' '  ,uus4anyc,,\n               fus4anyc\ncall chkvalue 'DSLIST_SRCHFOR_ASCII'                   ,' '  ,uus4asci,,\n               fus4asci\ncall chkvalue 'DSLIST_SRCHFOR_TOTALS_ONLY'             ,' '  ,uus4tots,,\n               fus4tots\ncall chkvalue 'DSLIST_SRCHFOR_FIRST_FOUND'             ,' '  ,uus4stop,,\n               fus4stop\ncall chkvalue 'DSLIST_SRCHFOR_VIEW_OUTPUT'             ,' '  ,uus4view,,\n               fus4view\ncall chkvalue 'DSLIST_SRCHFOR_EXCLUDE_NOT_FOUND'       ,' '  ,uus4xnf,,\n               fus4xnf\ncall chkvalue 'DSLIST_SRCHFOR_SEARCH_MIGRATED'         ,'1'  ,uus4migr,,\n               fus4migr\ncall chkvalue 'DSLIST_SRCHFOR_SEARCH_EXCLUDED'         ,'3'  ,uus4xcld,,\n               fus4xcld\n/*------------------------------------------------------------------*/\ncall header 'UDLIST SRCHFOR Options'\n/*------------------------------------------------------------------*/\n\ncall chkvalue 'UDLIST_SRCHFOR_MIXED_MODE'              ,' '  ,uudfmixv,,\n               fudfmixv\ncall chkvalue 'UDLIST_SRCHFOR_ANY_CASE'                ,' '  ,uudfanyc,,\n               fudfanyc\ncall chkvalue 'UDLIST_SRCHFOR_ASCII'                   ,' '  ,uudfasci,,\n               fudfasci\ncall chkvalue 'UDLIST_SRCHFOR_SET_EDIT_FIND_STRING'    ,' '  ,uudfedtf,,\n               fudfedtf\ncall chkvalue 'UDLIST_SRCHFOR_SET_BROWSE_FIND_STRING'  ,' '  ,uudfbrof,,\n               fudfbrof\ncall chkvalue 'UDLIST_SRCHFOR_VIEW_OUTPUT'             ,' '  ,uudfview,,\n               fudfview\ncall chkvalue 'UDLIST_SRCHFOR_SAVE_OUTPUT'             ,' '  ,uudfsave,,\n               fudfsave\n/*------------------------------------------------------------------*/\ncall header 'UDLIST Directory List Options'\n/*------------------------------------------------------------------*/\ncall chkvalue 'UDLIST_WIDTH_OF_FILENAME_COLUMN'        ,'15' ,usrwfnmc,,\n               fsrwfnmc\ncall chkvalue 'UDLIST_PATHNAME_SUBSTITUTION_CHARACTER' ,'!'  ,usrfsubc,,\n               fsrfsubc\ncall chkvalue 'UDLIST_ZOS_UNIX_COMMAND_TIME_LIMIT'     ,' '  ,usrshctm,,\n               fsrshctm\ncall chkvalue 'UDLIST_CONFIRM_FILE_DELETE'             ,'/'  ,usrfconv,,\n               fsrfconv\ndeftitle = 'UDLIST_CONFIRM_NON-EMPTY_DIRECTORY_DELETE'\ncall chkvalue deftitle,'/',usrdconv,fsrdconv\ndeftitle = 'UDLIST_BYPASS_ZOS_UNIX_FILE_EDIT_OPTIONS_PANEL'\ncall chkvalue deftitle,' ',usrbyedv,fsrbyedv\ndeftitle = 'UDLIST_DISPLAY_PERMISSIONS_IN_OCTAL_FORMAT'\ncall chkvalue deftitle,' ',usrdpmov,fsrdpmov\ndeftitle = 'UDLIST_ENTER_ZOS_UNIX_COMMANDS_IN_COMMAND_FIELD'\ncall chkvalue deftitle,' ',usruxpcv,fsruxpcv\ncall chkvalue 'UDLIST_OUTPUT_MODE'                     ,'2'  ,usrcmdom,,\n               fsrcmdom\ncall chkvalue 'UDLIST_DIRECTORY_DEFAULT_LINE_COMMAND'  ,'L'  ,usrdldir,,\n               fsrdldir\ndeftitle = 'UDLIST_REGULAR_FILE_DEFAULT_LINE_COMMAND'\ncall chkvalue deftitle,'B',usrdlreg,fsrdlreg\ndeftitle = 'UDLIST_CHARACTER_SPECIAL_DEFAULT_LINE_COMMAND'\ncall chkvalue deftitle,'I',usrdlchs,fsrdlchs\ncall chkvalue 'UDLIST_FIFO_DEFAULT_LINE_COMMAND'       ,'I'  ,usrdlfif,,\n               fsrdlfif\ncall chkvalue 'UDLIST_SYMBOLIC_LINK_LINE_COMMAND'      ,'I'  ,usrdlsym,,\n               fsrdlsym\ndeftitle = 'UDLIST_WIDTH_OF_MOUNT_POINT_COLUMN_IN_MOUNT_POINT_LIST'\ncall chkvalue deftitle,'35',usrwmtpc,fsrwmtpc\ndeftitle = 'UDLIST_WIDTH_OF_FILE_SYSTEM_COLUMN_IN_FILE_SYSTEM_LIST'\ncall chkvalue deftitle,'35',usrwfsyc,fsrwfsyc\n/*------------------------------------------------------------------*/\ncall header 'UDLIST Column Arrangement'\n/*------------------------------------------------------------------*/\ndeftitle = 'UDLIST_COLUMN_ARRANGEMENT'\ncall chkvalue deftitle,uularrdf,uularr,fularr\n/*------------------------------------------------------------------*/\ncall header 'Mount Table by File System Column Arrangement'\n/*------------------------------------------------------------------*/\ndeftitle = 'MOUNT_TABLE_FILE_SYSTEM_COLUMN_ARRANGEMENT'\ncall chkvalue deftitle,umtfarrdf,umtfarr,fmtfarr\n/*------------------------------------------------------------------*/\ncall header 'Mount Table by Mount Point Column Arrangement'\n/*------------------------------------------------------------------*/\ndeftitle = 'MOUNT_TABLE_MOUNT_POINT_COLUMN_ARRANGEMENT'\ncall chkvalue deftitle,umtmarrdf,umtmarr,fmtmarr\n/*------------------------------------------------------------------*/\nreturn\n/* */\n/* chkvalue: starts the process of writing a line to the keyword table*/\nchkvalue:\ntag = arg(1)\ndef = arg(2)\nval = arg(3)\nfrc = arg(4)\nif def = ' ' then\n  def = 'NONE'\nif val = ' ' then\n  val = 'NONE'\ncall chkdefault tag,def,val,frc\nreturn\n/* */\n/* */\nchkdefault:\ntag=arg(1)\ndef=arg(2)\nval=arg(3)\nfrc=arg(4)\nif frc = '/' then\n   frc2 = ',/'\nelse\n   frc2 = ''\nUpper val\nif stuff \u00ac= '' then\n  do\n    val2 = strip(val) '/*'||stuff\n    val2 = left(val2,24)||'*/'\n  end\nelse\n  val2 = val\n  select\n   when (tag = 'CALENDAR_SCROLL_BUTTON_COLOR') then\n      val2 = calendar_color(val2)\n   when (tag = 'CALENDAR_HEADING_DATE_COLOR') then\n      val2 = calendar_color(val2)\n   when (tag = 'CALENDAR_HEADING_TEXT_COLOR') then\n      val2 = calendar_color(val2)\n   when (tag = 'CALENDAR_WEEKDAY_COLOR') then\n      val2 = calendar_color(val2)\n   when (tag = 'CALENDAR_SATURDAY_SUNDAY_COLOR') then\n      val2 = calendar_color(val2)\n   when (tag = 'CALENDAR_CURRENT_DAY_COLOR') then\n      val2 = calendar_color(val2)\n   otherwise\n      nop\nend\nif def \u00ac= val | frc = '/' then\n  call addline left(tag,56) '=' val2 || frc2\nelse\n  if ucnvopt = 'ALL' then\n    call addline left(tag,56) '=' val2 || frc\n  else\n    if ucnvopt = 'NEW' then\n      Nop\n    else\n      call addline2 '/*'left(tag,55)'=' val2 || frc\nreturn\n/* */\n/*********************************************************************/\n/* header: write out header info for keyword list section            */\n/*********************************************************************/\nheader:\nParse Arg in\nheader1 = '/*'copies('-',68)\nheader2 = '/*'center(in,68)'*/'\nif ucnvopt = 'ALL' then\n  do\n    call addline header1\n    call addline header2\n    call addline header1\n  end\nelse\n  if ucnvopt = 'NEW' then\n    Nop\n  else\n    do\n      call addline2 header1\n      call addline2 header2\n      call addline2 header1\n    end\nreturn\n\n/*********************************************************************/\n/* write_output:                                                     */\n/*********************************************************************/\nwrite_output:\nif ucnvopt = 'ALL' | ucnvopt = 'NEW' then\n  do i = 1 to outlines\n    final.i = output.i\n    final.0 = outlines\n  end\nelse\n  do\n    do i = 1 to outlines\n      final.i = output.i\n    end\n    num = outlines\n    in = 'The following values match the ISPF Defaults'\n    header1 = '/*'copies('-',68)'*/'\n    header2 = '/*'center(in,68)'*/'\n    num = num + 1\n    final.num = header1\n    num = num + 1\n    final.num = header2\n    num = num + 1\n    final.num = header1\n    do i = 1 to outlines2\n      num = num + 1\n      final.num = output2.i\n    end\n    final.0 = num\n  end\nif substr(usrvout,1,1) = \"'\" then\n  outname = \"'\"strip(usrvout,'B',\"'\")\"(\"usrvoutm\")'\"\nelse\n  outname = strip(usrvout,'B',\"'\")\"(\"usrvoutm\")\"\nusrvoutn = outname\naddress ispexec \"VPUT (USRVOUTN) SHARED\"\naddress tso \"ALLOC F(OUTFILE) REUSE SHR DA(\"outname\")\"\naddress tso \"EXECIO\" final.0 \"DISKW OUTFILE (FINIS STEM FINAL.\"\nexecio_rc = rc\nif execio_rc = 0 then\n  do\n    address tso \"ALLOC REU F(OUTFILE) DA(\"usrvout\") SHR\"\n    member = 'MEMBER('usrvoutm')'\n    address ispexec \"LMINIT DATAID(CNVRT) DDNAME(OUTFILE) ENQ(SHRW)\"\n    address ispexec \"VIEW DATAID(\"cnvrt\")\" member\n    if member \u00ac= '' then\n      address ispexec \"LMMSTATS DATAID(\"cnvrt\")\" member\n    address ispexec \"LMFREE DATAID(\"cnvrt\")\"\n    address tso \"FREE F(OUTFILE)\"\n  end\nelse\n  do\n    address ISPEXEC address ispexec \"SETMSG MSG(ISPC289)\"\n    exec_rc = 4\n  end\naddress ispexec\nreturn\n/*********************************************************************/\n/* Create and display column table.                                  */\n/*********************************************************************/\ncolumn_table:\nparse arg columvar\ncall column_defaults(columvar)\nif columvar = 'UULARR' then\n   panelnm = 'USRUULO2'\nelse\n   panelnm = 'USRUMNO2'\ndisprc = 0\ndo until (disprc = 8)\n   address ispexec \"TBDISPL COLUMTAB PANEL(\"panelnm\") AUTOSEL(NO)\"\n   disprc = rc\n   if disprc = 8 then\n      leave\n   select\n      when (columvar = 'UULARR' & uularstd = '/') then\n         do\n            address ispexec \"TBEND COLUMTAB\"\n            call column_defaults(columvar)\n         end\n      when ((columvar = 'UMTFARR' | columvar = 'UMTMARR') &,\n             umtarstd = '/') then\n         do\n            address ispexec \"TBEND COLUMTAB\"\n            call column_defaults(columvar)\n         end\n      otherwise\n         do while (ztdsels > 0)\n            disprc = rc\n            j = 1\n            if columvar = 'UULARR' then\n               if uulacord < uulacori then\n                  uula2srt = uula2srt - j\n               else\n                  uula2srt = uula2srt + j\n            else\n               if umtacord < umtacori then\n                  umta2srt = umta2srt - j\n               else\n                  umta2srt = umta2srt + j\n            address ispexec \"TBPUT COLUMTAB\"\n            if ztdsels > 1 then\n               do\n                  address ispexec \"TBDISPL COLUMTAB\"\n                  disprc = rc\n                  j = j + 1\n               end\n            else\n               ztdsels = 0\n         end\n   end\n   if columvar = 'UULARR' then\n      do\n         address ispexec \"TBSORT COLUMTAB FIELDS(UULACORD,N,A,UULA2SRT,N,A)\"\n         address ispexec \"TBTOP COLUMTAB\"\n         do i = 1 to 13\n            address ispexec \"TBSKIP COLUMTAB\"\n            uulacord = i\n            uula2srt = 9999\n            address ispexec \"TBPUT COLUMTAB\"\n         end\n      end\n   else\n      do\n         address ispexec \"TBSORT COLUMTAB FIELDS(UMTACORD,N,A,UMTA2SRT,N,A)\"\n         address ispexec \"TBTOP COLUMTAB\"\n         do i = 1 to 7\n            address ispexec \"TBSKIP COLUMTAB\"\n            umtacord = i\n            umta2srt = 9999\n            address ispexec \"TBPUT COLUMTAB\"\n         end\n      end\n   address ispexec \"TBTOP COLUMTAB\"\nend\ncall create_column_string(columvar)\naddress ispexec \"TBEND COLUMTAB\"\nreturn\n/* */\ncolumn_defaults:\nparse arg columvar\nif columvar = 'UULARR' then\n   do\n      address ispexec \"TBCREATE COLUMTAB NAMES(UULACORD UULA2SRT\",\n                      \"UULACORI UULACVIX UULACWID UULACMAX UULACHDG)\"\n      if uularr <> uularrdf & uularstd <> '/' then\n         call column_custom(columvar)\n      else\n         do\n            address ispexec \"TBTOP COLUMTAB\"\n            uulacord = 1\n            uula2srt = 9999\n            uulacori = 1\n            uulacvix = 1\n            uulacwid = 4\n            uulacmax = 4\n            uulachdg = 'Type'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 2\n            uula2srt = 9999\n            uulacori = 2\n            uulacvix = 2\n            uulacwid = 10\n            uulacmax = 10\n            uulachdg = 'Permission'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 3\n            uula2srt = 9999\n            uulacori = 3\n            uulacvix = 5\n            uulacwid = 6\n            uulacmax = 6\n            uulachdg = 'Audit'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 4\n            uula2srt = 9999\n            uulacori = 4\n            uulacvix = 6\n            uulacwid = 4\n            uulacmax = 4\n            uulachdg = 'Ext'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 5\n            uula2srt = 9999\n            uulacori = 5\n            uulacvix = 7\n            uulacwid = 4\n            uulacmax = 4\n            uulachdg = 'Fmat'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 6\n            uula2srt = 9999\n            uulacori = 6\n            uulacvix = 4\n            uulacwid = 8\n            uulacmax = 8\n            uulachdg = 'Owner'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 7\n            uula2srt = 9999\n            uulacori = 7\n            uulacvix = 8\n            uulacwid = 8\n            uulacmax = 8\n            uulachdg = 'Group'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 8\n            uula2srt = 9999\n            uulacori = 8\n            uulacvix = 9\n            uulacwid = 6\n            uulacmax = 14\n            uulachdg = 'Links'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 9\n            uula2srt = 9999\n            uulacori = 9\n            uulacvix = 10\n            uulacwid = 10\n            uulacmax = 20\n            uulachdg = 'Size'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 10\n            uula2srt = 9999\n            uulacori = 10\n            uulacvix = 11\n            uulacwid = 19\n            uulacmax = 19\n            uulachdg = 'Modified'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 11\n            uula2srt = 9999\n            uulacori = 11\n            uulacvix = 12\n            uulacwid = 19\n            uulacmax = 19\n            uulachdg = 'Changed'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 12\n            uula2srt = 9999\n            uulacori = 12\n            uulacvix = 13\n            uulacwid = 19\n            uulacmax = 19\n            uulachdg = 'Accessed'\n            address ispexec \"TBADD COLUMTAB\"\n            uulacord = 13\n            uula2srt = 9999\n            uulacori = 13\n            uulacvix = 14\n            uulacwid = 19\n            uulacmax = 19\n            uulachdg = 'Created'\n            address ispexec \"TBADD COLUMTAB\"\n         end\n   end\nelse\n   do\n      address ispexec \"TBCREATE COLUMTAB NAMES(UMTACORD UMTA2SRT\",\n                      \"UMTACORI UMTACVIX UMTACWID UMTACMAX UMTACHDG)\"\n      address ispexec \"TBTOP COLUMTAB\"\n      select\n         when (columvar = 'UMTMARR' & umtmarr <> umtmarrdf &,\n               umtarstd <> '/') then\n            call column_custom(columvar)\n         when (columvar = 'UMTFARR' & umtfarr <> umtfarrdf &,\n               umtarstd <> '/') then\n            call column_custom(columvar)\n         otherwise\n            do\n               if columvar = 'UMTMARR' then\n                  do\n                     umtacord = 1\n                     umta2srt = 9999\n                     umtacori = 1\n                     umtacvix = 2\n                     umtacwid = 35\n                     umtacmax = 70\n                     umtachdg = 'File System Name'\n                  end\n               else\n                  do\n                     umtacord = 1\n                     umta2srt = 9999\n                     umtacori = 1\n                     umtacvix = 1\n                     umtacwid = 35\n                     umtacmax = 150\n                     umtachdg = 'Mount Point'\n                  end\n               address ispexec \"TBADD COLUMTAB\"\n               umtacord = 2\n               umta2srt = 9999\n               umtacori = 2\n               umtacvix = 3\n               umtacwid = 4\n               umtacmax = 8\n               umtachdg = 'Type'\n               address ispexec \"TBADD COLUMTAB\"\n               umtacord = 3\n               umta2srt = 9999\n               umtacori = 3\n               umtacvix = 5\n               umtacwid = 4\n               umtacmax = 8\n               umtachdg = 'Mode'\n               address ispexec \"TBADD COLUMTAB\"\n               umtacord = 4\n               umta2srt = 9999\n               umtacori = 4\n               umtacvix = 6\n               umtacwid = 8\n               umtacmax = 8\n               umtachdg = 'Owner'\n               address ispexec \"TBADD COLUMTAB\"\n               umtacord = 5\n               umta2srt = 9999\n               umtacori = 5\n               umtacvix = 7\n               umtacwid = 3\n               umtacmax = 3\n               umtachdg = 'A/M'\n               address ispexec \"TBADD COLUMTAB\"\n               umtacord = 6\n               umta2srt = 9999\n               umtacori = 6\n               umtacvix = 4\n               umtacwid = 10\n               umtacmax = 40\n               umtachdg = 'Status'\n               address ispexec \"TBADD COLUMTAB\"\n               umtacord = 7\n               umta2srt = 9999\n               umtacori = 7\n               umtacvix = 8\n               umtacwid = 10\n               umtacmax = 16\n               umtachdg = 'I/O Counts'\n               address ispexec \"TBADD COLUMTAB\"\n            end\n      end\n   end\naddress ispexec \"TBTOP COLUMTAB\"\nreturn\ncolumn_custom:\nparse arg columvar\nselect\n   when (columvar = 'UULARR') then\n      do\n         parse var uularr 11 uularrst .\n         do l = 1 to 13\n            parse var uularrst 1 uulacord 2 uulacori 3 uulacvix 4 uulacwid,\n                               5 uularrst . 2 titleix 4 .\n            uula2srt = 9999\n            uulacord = c2d(uulacord)\n            uulacori = c2d(uulacori)\n            uulacvix = c2d(uulacvix)\n            uulacwid = c2d(uulacwid)\n            select\n               when (titleix = '0101'x) then\n                  do\n                     uulachdg = 'Type'\n                     uulacmax = 4\n                  end\n               when (titleix = '0202'x) then\n                  do\n                     uulachdg = 'Permission'\n                     uulacmax = 10\n                  end\n               when (titleix = '0305'x) then\n                  do\n                     uulachdg = 'Audit'\n                     uulacmax = 6\n                  end\n               when (titleix = '0406'x) then\n                  do\n                     uulachdg = 'Ext'\n                     uulacmax = 4\n                  end\n               when (titleix = '0507'x) then\n                  do\n                     uulachdg = 'Fmat'\n                     uulacmax = 4\n                  end\n               when (titleix = '0604'x) then\n                  do\n                     uulachdg = 'Owner'\n                     uulacmax = 8\n                  end\n               when (titleix = '0708'x) then\n                  do\n                     uulachdg = 'Group'\n                     uulacmax = 8\n                  end\n               when (titleix = '0809'x) then\n                  do\n                     uulachdg = 'Links'\n                     uulacmax = 14\n                  end\n               when (titleix = '090A'x) then\n                  do\n                     uulachdg = 'Size'\n                     uulacmax = 20\n                  end\n               when (titleix = '0A0B'x) then\n                  do\n                     uulachdg = 'Modified'\n                     uulacmax = 19\n                  end\n               when (titleix = '0B0C'x) then\n                  do\n                     uulachdg = 'Changed'\n                     uulacmax = 19\n                  end\n               when (titleix = '0C0D'x) then\n                  do\n                     uulachdg = 'Accessed'\n                     uulacmax = 19\n                  end\n               when (titleix = '0D0E'x) then\n                  do\n                     uulachdg = 'Created'\n                     uulacmax = 19\n                  end\n               otherwise\n            end\n            address ispexec \"TBADD COLUMTAB\"\n         end\n      end\n   when (columvar = 'UMTMARR') then\n      do\n         parse var umtmarr 15 umtmarrst .\n         do l = 1 to 7\n            parse var umtmarrst 1 umtacord 2 umtacori 3 umtacvix 4 umtacwid,\n                               5 umtmarrst . 2 titleix 4 .\n            umta2srt = 9999\n            umtacord = c2d(umtacord)\n            umtacori = c2d(umtacori)\n            umtacvix = c2d(umtacvix)\n            umtacwid = c2d(umtacwid)\n            select\n               when (titleix = '0102'x) then\n                  do\n                     umtachdg = 'File System Name'\n                     umtacmax = 70\n                  end\n               when (titleix = '0203'x) then\n                  do\n                     umtachdg = 'Type'\n                     umtacmax = 8\n                  end\n               when (titleix = '0305'x) then\n                  do\n                     umtachdg = 'Mode'\n                     umtacmax = 8\n                  end\n               when (titleix = '0406'x) then\n                  do\n                     umtachdg = 'Owner'\n                     umtacmax = 8\n                  end\n               when (titleix = '0507'x) then\n                  do\n                     umtachdg = 'A/M'\n                     umtacmax = 3\n                  end\n               when (titleix = '0604'x) then\n                  do\n                     umtachdg = 'Status'\n                     umtacmax = 40\n                  end\n               when (titleix = '0708'x) then\n                  do\n                     umtachdg = 'I/O Counts'\n                     umtacmax = 16\n                  end\n               otherwise\n            end\n            address ispexec \"TBADD COLUMTAB\"\n         end\n      end\n   when (columvar = 'UMTFARR') then\n      do\n         parse var umtfarr 15 umtfarrst .\n         do l = 1 to 7\n            parse var umtfarrst 1 umtacord 2 umtacori 3 umtacvix 4 umtacwid,\n                               5 umtfarrst . 2 titleix 4 .\n            umta2srt = 9999\n            umtacord = c2d(umtacord)\n            umtacori = c2d(umtacori)\n            umtacvix = c2d(umtacvix)\n            umtacwid = c2d(umtacwid)\n            select\n               when (titleix = '0101'x) then\n                  do\n                     umtachdg = 'Mount Point'\n                     umtacmax = 150\n                  end\n               when (titleix = '0203'x) then\n                  do\n                     umtachdg = 'Type'\n                     umtacmax = 8\n                  end\n               when (titleix = '0305'x) then\n                  do\n                     umtachdg = 'Mode'\n                     umtacmax = 8\n                  end\n               when (titleix = '0406'x) then\n                  do\n                     umtachdg = 'Owner'\n                     umtacmax = 8\n                  end\n               when (titleix = '0507'x) then\n                  do\n                     umtachdg = 'A/M'\n                     umtacmax = 3\n                  end\n               when (titleix = '0604'x) then\n                  do\n                     umtachdg = 'Status'\n                     umtacmax = 40\n                  end\n               when (titleix = '0708'x) then\n                  do\n                     umtachdg = 'I/O Counts'\n                     umtacmax = 16\n                  end\n               otherwise\n            end\n            address ispexec \"TBADD COLUMTAB\"\n         end\n     end\nend\nreturn\ncreate_column_string:\nparse arg columvar\nselect\n   when (columvar = 'UULARR') then\n      do\n         uularr = 'UDLCOLS ' || '010D'x\n         address ispexec \"TBTOP COLUMTAB\"\n         do k = 1 to 13\n            address ispexec \"TBSKIP COLUMTAB\"\n            uularr = uularr || d2c(uulacord) || d2c(uulacori)\n            uularr = uularr || d2c(uulacvix) || d2c(uulacwid)\n         end\n      end\n   when (columvar = 'UMTFARR') then\n      do\n         umtfarr = 'MTBFCOLS' || '010800000223'x\n         address ispexec \"TBTOP COLUMTAB\"\n         do k = 1 to 7\n            address ispexec \"TBSKIP COLUMTAB\"\n            umtfarr = umtfarr || d2c(umtacord) || d2c(umtacori)\n            umtfarr = umtfarr || d2c(umtacvix) || d2c(umtacwid)\n         end\n      end\n   when (columvar = 'UMTMARR') then\n      do\n         umtmarr = 'MTBMCOLS' || '010800000123'x\n         address ispexec \"TBTOP COLUMTAB\"\n         do k = 1 to 7\n            address ispexec \"TBSKIP COLUMTAB\"\n            umtmarr = umtmarr || d2c(umtacord) || d2c(umtacori)\n            umtmarr = umtmarr || d2c(umtacvix) || d2c(umtacwid)\n         end\n      end\n   otherwise\n      nop\nend\nreturn\ncalendar_color:\nparse arg color\nselect\n   when (color = 1) then\n      color = '31'x\n   when (color = 2) then\n      color = '32'x\n   when (color = 3) then\n      color = '33'x\n   when (color = 4) then\n      color = '34'x\n   when (color = 5) then\n      color = '35'x\n   when (color = 6) then\n      color = '36'x\n   when (color = 7) then\n      color = '37'x\n   when (color = 8) then\n      color = '38'x\n   when (color = '31'x) then\n      color = '1'\n   when (color = '32'x) then\n      color = '2'\n   when (color = '33'x) then\n      color = '3'\n   when (color = '34'x) then\n      color = '4'\n   when (color = '35'x) then\n      color = '5'\n   when (color = '36'x) then\n      color = '6'\n   when (color = '37'x) then\n      color = '7'\n   when (color = '38'x) then\n      color = '8'\n   otherwise\n      nop\nend\nreturn(color)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USRDEL34": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x185\\x7f\\x01\\x185\\x8f!\\x00\\x00M\\x00M\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-12-23T00:00:00", "modifydate": "2018-12-24T21:00:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "TCONLEY"}, "text": "/* rexx */\n/*********************************************************************/\n/* This exec will handle block deletes from option 3.4, bypassing    */\n/* errors for VSAM DATA and INDEX components.                        */\n/*                                                                   */\n/* Change Log                                                        */\n/*                                                                   */\n/*    Date    Name           Description                             */\n/* ---------- -------------- --------------------------------------- */\n/* 2018/12/23 Conley         Initial coding.                         */\n/*********************************************************************/\n/*********************************************************************/\n/* Parse the arguments for the dataset name to be deleted.           */\n/*********************************************************************/\nparse arg dsn\n/*********************************************************************/\n/* VGET the delete confirmation variable ZDSLCONF.  It the value is  */\n/* not equal to 'OFF', then display the delete confirmation panel,   */\n/* otherwise set the delrc variable to 0 and proceed with DELETE.    */\n/*********************************************************************/\naddress ispexec \"VGET (ZDSLCONF)\"\nif zdslconf <> 'OFF' then\n   do\n      address ispexec \"DISPLAY PANEL(ISRUADC4)\"\n/*********************************************************************/\n/* Save the return code from the delete confirmation panel display.  */\n/* If the user hit 'ENTER' on the panel, rc will be 0, any other key */\n/* will be a non-zero rc.                                            */\n/*********************************************************************/\n      delrc = rc\n   end\nelse\n   delrc = 0\n/*********************************************************************/\n/* If the user hit 'ENTER' to confirm the delete, or if delete       */\n/* confirmations were off, allocate files and invoke IDCAMS to       */\n/* process the DELETE.                                               */\n/*********************************************************************/\nif delrc = 0 then\n   do\n/*********************************************************************/\n/* Dummy out SYSPRINT to suppress any IDCAMS messages coming back to */\n/* the terminal.  Allocate SYSIN, write the DELETE command to it,    */\n/* set the lastrc to 0, call IDCAMS to complete the DELETE, and FREE */\n/* SYSPRINT AND SYSIN.                                               */\n/*********************************************************************/\n      address tso \"ALLOC FI(SYSPRINT) DUMMY REUSE\"\n      address tso \"ALLOC FI(SYSIN) UNIT(SYSALLDA) SPACE(1) TRACK\",\n                        \"RECFM(F B) LRECL(80)\"\n      sysin.1 = \" DELETE \"dsn\n      \"EXECIO * DISKW SYSIN (OPEN STEM SYSIN. FINIS)\"\n      lastrc = 0\n      address tso \"CALL *(IDCAMS)\"\n/*********************************************************************/\n/* Set all non-zero return codes to 4, to echo back a small error to */\n/* the user.  The return code 8 that IDCAMS receives when trying to  */\n/* delete any DATA or INDEX components causes a misleading \"Command  */\n/* failed\" message to appear on the re-display of ISRUDSL0.  Setting */\n/* the return code to 4 prevents this, while still showing the user  */\n/* \"USRDEL34 RC=4\" in the message area.                              */\n/*********************************************************************/\n      if rc <> 0 then\n         lastrc = 4\n      address tso \"FREE FI(SYSPRINT)\"\n      address tso \"FREE FI(SYSIN)\"\n   end\n/*********************************************************************/\n/* If the user hit 'CANCEL' or 'END' on the delete confirmation      */\n/* panel to cancel the delete, set lastrc = 4.                       */\n/*********************************************************************/\nelse\n   lastrc = 4\n/*********************************************************************/\n/* Send back the return code to prevent the misleading \"Command      */\n/* failed\" error message, and keep the re-display of ISRUDSL0 clean. */\n/*********************************************************************/\nexit(lastrc)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USRHILIT": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x02\\x8f\\x01 \\x19O\\x11\\x00\\nv\\x06.\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 2678, "newlines": 1582, "modlines": 0, "user": "TCONLEY"}, "text": "/* rexx */\n/*********************************************************************/\n/* This exec will handle highlighting unsupported languages in ISPF  */\n/* EDIT, as a panel exit invoked from the EDIT data panel ISREDDE2.  */\n/* This code is largely based on the groundbreaking work of Pedro    */\n/* Vera at IBM, as detailed in his SHARE presentation \"Customizing   */\n/* the ISPF HILITE command\", available at http://www.share.org.      */\n/*                                                                   */\n/* Change Log                                                        */\n/*                                                                   */\n/*    Date    Name           Description                             */\n/* ---------- -------------- --------------------------------------- */\n/* 2020/07/03 Conley         Add FLOWASM to supported languages.     */\n/* 2020/05/12 Conley         Add Google Go to supported languages.   */\n/* 2019/12/28 Conley         Initial coding.                         */\n/*********************************************************************/\ncall isprexpx('I')\n/*********************************************************************/\n/* There are three arrays which control the highlighting process,    */\n/* kw (keyword), atr (attribute), and clr (color).  The kw array     */\n/* holds blank-delimited keywords, the atr array holds the ISPF      */\n/* default attributes for the associated keyword (typically 'D'),    */\n/* and the clr array holds the highlighting color for the associated */\n/* keyword (typically 'R' for RED).                                  */\n/*                                                                   */\n/* The languages currently supported are:                            */\n/*                                                                   */\n/* CARLa                                                             */\n/* FLOWASM                                                           */\n/* FORTRAN                                                           */\n/* Go                                                                */\n/* JAVA                                                              */\n/* JSON                                                              */\n/* PYTHON                                                            */\n/* RUBY                                                              */\n/* SHELL                                                             */\n/* SQL                                                               */\n/*********************************************************************/\nselect\n   when (usrhilng = 'OFF') then\n      nop\n   when (usrhilng = 'CARLA') then\n      do\n         kw.0    = 46\n         kw.1    = ' ALLOCATE '\n         kw.2    = ' BDAMQSAM '\n         kw.3    = ' BUNDLE '\n         kw.4    = ' CAPS '\n         kw.5    = ' COMPAREOPT '\n         kw.6    = ' CONVERSION '\n         kw.7    = ' COPY '\n         kw.8    = ' DEBUG '\n         kw.9    = ' DEFAULT '\n         kw.10   = ' DEFINE '\n         kw.11   = ' DEFSENS '\n         kw.12   = ' DEFTYPE '\n         kw.13   = ' DISPLAY '\n         kw.14   = ' DSUMMARY '\n         kw.15   = ' ENDBUNDLE '\n         kw.16   = ' ENDMERGE '\n         kw.17   = ' EXCLUDE '\n         kw.18   = ' FILEOPTION '\n         kw.19   = ' IMBED '\n         kw.20   = ' INCLUDE '\n         kw.21   = ' LANGUAGE '\n         kw.22   = ' LIMIT '\n         kw.23   = ' LIST '\n         kw.24   = ' MARGINS '\n         kw.25   = ' MENU '\n         kw.26   = ' MERGE '\n         kw.27   = ' MERGELIST '\n         kw.28   = ' MERGERULE '\n         kw.29   = ' MOVE '\n         kw.30   = ' NEWLIST '\n         kw.31   = ' OPTION '\n         kw.32   = ' PRINT '\n         kw.33   = ' REMOVE '\n         kw.34   = ' REPORT '\n         kw.35   = ' SELECT '\n         kw.36   = ' SHOW '\n         kw.37   = ' SIMULATE '\n         kw.38   = ' SITE_SEVERITY '\n         kw.39   = ' SMFCACHE '\n         kw.40   = ' SORTLIST '\n         kw.41   = ' STANDARD '\n         kw.42   = ' SUMMARY '\n         kw.43   = ' SUPPRESS '\n         kw.44   = ' SYMBOLIC '\n         kw.45   = ' UNLOAD '\n         kw.46   = ' VERIFY '\n         atr.1   = 'DDDDDDDD'\n         atr.2   = 'DDDDDDDD'\n         atr.3   = 'DDDDDD'\n         atr.4   = 'DDDD'\n         atr.5   = 'DDDDDDDDDD'\n         atr.6   = 'DDDDDDDDDD'\n         atr.7   = 'DDDD'\n         atr.8   = 'DDDDD'\n         atr.9   = 'DDDDDDD'\n         atr.10  = 'DDDDDD'\n         atr.11  = 'DDDDDDD'\n         atr.12  = 'DDDDDDD'\n         atr.13  = 'DDDDDDD'\n         atr.14  = 'DDDDDDDD'\n         atr.15  = 'DDDDDDDDD'\n         atr.16  = 'DDDDDDDD'\n         atr.17  = 'DDDDDDD'\n         atr.18  = 'DDDDDDDDDD'\n         atr.19  = 'DDDDD'\n         atr.20  = 'DDDDDDD'\n         atr.21  = 'DDDDDDDD'\n         atr.22  = 'DDDDD'\n         atr.23  = 'DDDD'\n         atr.24  = 'DDDDDDD'\n         atr.25  = 'DDDD'\n         atr.26  = 'DDDDD'\n         atr.27  = 'DDDDDDDDD'\n         atr.28  = 'DDDDDDDDD'\n         atr.29  = 'DDDD'\n         atr.30  = 'DDDDDDD'\n         atr.31  = 'DDDDDD'\n         atr.32  = 'DDDDD'\n         atr.33  = 'DDDDDD'\n         atr.34  = 'DDDDDD'\n         atr.35  = 'DDDDDD'\n         atr.36  = 'DDDD'\n         atr.37  = 'DDDDDDDD'\n         atr.38  = 'DDDDDDDDDDDDD'\n         atr.39  = 'DDDDDDDD'\n         atr.40  = 'DDDDDDDD'\n         atr.41  = 'DDDDDDDD'\n         atr.42  = 'DDDDDDD'\n         atr.43  = 'DDDDDDDD'\n         atr.44  = 'DDDDDDDD'\n         atr.45  = 'DDDDDD'\n         atr.46  = 'DDDDDD'\n         clr.1   = 'RRRRRRRR'\n         clr.2   = 'RRRRRRRR'\n         clr.3   = 'RRRRRR'\n         clr.4   = 'RRRR'\n         clr.5   = 'RRRRRRRRRR'\n         clr.6   = 'RRRRRRRRRR'\n         clr.7   = 'RRRR'\n         clr.8   = 'RRRRR'\n         clr.9   = 'RRRRRRR'\n         clr.10  = 'RRRRRR'\n         clr.11  = 'RRRRRRR'\n         clr.12  = 'RRRRRRR'\n         clr.13  = 'RRRRRRR'\n         clr.14  = 'RRRRRRRR'\n         clr.15  = 'RRRRRRRRR'\n         clr.16  = 'RRRRRRRR'\n         clr.17  = 'RRRRRRR'\n         clr.18  = 'RRRRRRRRRR'\n         clr.19  = 'RRRRR'\n         clr.20  = 'RRRRRRR'\n         clr.21  = 'RRRRRRRR'\n         clr.22  = 'RRRRR'\n         clr.23  = 'RRRR'\n         clr.24  = 'RRRRRRR'\n         clr.25  = 'RRRR'\n         clr.26  = 'RRRRR'\n         clr.27  = 'RRRRRRRRR'\n         clr.28  = 'RRRRRRRRR'\n         clr.29  = 'RRRR'\n         clr.30  = 'RRRRRRR'\n         clr.31  = 'RRRRRR'\n         clr.32  = 'RRRRR'\n         clr.33  = 'RRRRRR'\n         clr.34  = 'RRRRRR'\n         clr.35  = 'RRRRRR'\n         clr.36  = 'RRRR'\n         clr.37  = 'RRRRRRRR'\n         clr.38  = 'RRRRRRRRRRRRR'\n         clr.39  = 'RRRRRRRR'\n         clr.40  = 'RRRRRRRR'\n         clr.41  = 'RRRRRRRR'\n         clr.42  = 'RRRRRRR'\n         clr.43  = 'RRRRRRRR'\n         clr.44  = 'RRRRRRRR'\n         clr.45  = 'RRRRRR'\n         clr.46  = 'RRRRRR'\n      end\n   when (usrhilng = 'FLOWASM') then\n      do\n         kw.0    = 0\n      end\n   when (usrhilng = 'FORTRAN') then\n      do\n         kw.0    = 145\n         kw.1    = ' ABSTRACT '\n         kw.2    = ' ACCESS '\n         kw.3    = ' ACTION '\n         kw.4    = ' ADVANCE '\n         kw.5    = ' ALLOCATABLE '\n         kw.6    = ' ALLOCATE '\n         kw.7    = ' ASSIGN '\n         kw.8    = ' ASSIGNMENT '\n         kw.9    = ' ASSOCIATE '\n         kw.10   = ' ASYNCHRONOUS '\n         kw.11   = ' BACKSPACE '\n         kw.12   = ' BIND '\n         kw.13   = ' BLANK '\n         kw.14   = ' BLOCK '\n         kw.15   = ' CALL '\n         kw.16   = ' CASE '\n         kw.17   = ' CHARACTER '\n         kw.18   = ' CLASS '\n         kw.19   = ' CLOSE '\n         kw.20   = ' CODIMENSION '\n         kw.21   = ' COMMON '\n         kw.22   = ' COMPLEX '\n         kw.23   = ' CONTAINS '\n         kw.24   = ' CONTIGUOUS '\n         kw.25   = ' CONTINUE '\n         kw.26   = ' CRITICAL '\n         kw.27   = ' CYCLE '\n         kw.28   = ' DATA '\n         kw.29   = ' DEALLOCATE '\n         kw.30   = ' DEFAULT '\n         kw.31   = ' DEFERRED '\n         kw.32   = ' DELIM '\n         kw.33   = ' DIMENSION '\n         kw.34   = ' DIRECT '\n         kw.35   = ' DO '\n         kw.36   = ' DO CONCURRENT '\n         kw.37   = ' DOUBLE '\n         kw.38   = ' ELSE '\n         kw.39   = ' ELSEWHERE '\n         kw.40   = ' END '\n         kw.41   = ' ENDFILE '\n         kw.42   = ' ENTRY '\n         kw.43   = ' ENUM '\n         kw.44   = ' ENUMERATOR '\n         kw.45   = ' EOR '\n         kw.46   = ' EQUIVALENCE '\n         kw.47   = ' ERR '\n         kw.48   = ' ERROR STOP '\n         kw.49   = ' EXIST '\n         kw.50   = ' EXIT '\n         kw.51   = ' EXTENDS '\n         kw.52   = ' EXTERNAL '\n         kw.53   = ' FILE '\n         kw.54   = ' FINAL '\n         kw.55   = ' FLUSH '\n         kw.56   = ' FMT '\n         kw.57   = ' FORM '\n         kw.58   = ' FORMAT '\n         kw.59   = ' FORMATTED '\n         kw.60   = ' FUNCTION '\n         kw.61   = ' GENERIC '\n         kw.62   = ' GO '\n         kw.63   = ' IF '\n         kw.64   = ' IMPLICIT '\n         kw.65   = ' IMPORT '\n         kw.66   = ' IN '\n         kw.67   = ' INOUT '\n         kw.68   = ' INQUIRE '\n         kw.69   = ' INTEGER '\n         kw.70   = ' INTENT '\n         kw.71   = ' INTERFACE '\n         kw.72   = ' INTRINSIC '\n         kw.73   = ' IOLENGTH '\n         kw.74   = ' IOSTAT '\n         kw.75   = ' KIND '\n         kw.76   = ' LEN '\n         kw.77   = ' LOCK '\n         kw.78   = ' LOGICAL '\n         kw.79   = ' MODULE '\n         kw.80   = ' NAME '\n         kw.81   = ' NAMED '\n         kw.82   = ' NAMELIST '\n         kw.83   = ' NEXTREC '\n         kw.84   = ' NML '\n         kw.85   = ' NON_OVERRIDABLE '\n         kw.86   = ' NONE '\n         kw.87   = ' NOPASS '\n         kw.88   = ' NULLIFY '\n         kw.89   = ' NUMBER '\n         kw.90   = ' ONLY '\n         kw.91   = ' OPEN '\n         kw.92   = ' OPENED '\n         kw.93   = ' OPERATOR '\n         kw.94   = ' OPTIONAL '\n         kw.95   = ' OUT '\n         kw.96   = ' PAD '\n         kw.97   = ' PARAMETER '\n         kw.98   = ' PASS '\n         kw.99   = ' PAUSE '\n         kw.100  = ' POINTER '\n         kw.101  = ' POSITION '\n         kw.102  = ' PRECISION '\n         kw.103  = ' PRINT '\n         kw.104  = ' PRIVATE '\n         kw.105  = ' PROCEDURE '\n         kw.106  = ' PROGRAM '\n         kw.107  = ' PROTECTED '\n         kw.108  = ' PUBLIC '\n         kw.109  = ' READ '\n         kw.110  = ' READWRITE '\n         kw.111  = ' REAL '\n         kw.112  = ' REC '\n         kw.113  = ' RECL '\n         kw.114  = ' RECURSIVE '\n         kw.115  = ' RESULT '\n         kw.116  = ' RETURN '\n         kw.117  = ' REWIND '\n         kw.118  = ' SAVE '\n         kw.119  = ' SELECT '\n         kw.120  = ' SEQUENCE  '\n         kw.121  = ' SEQUENTIAL '\n         kw.122  = ' SIZE '\n         kw.123  = ' STAT '\n         kw.124  = ' STATUS '\n         kw.125  = ' STOP '\n         kw.126  = ' SUBMODULE '\n         kw.127  = ' SUBROUTINE '\n         kw.128  = ' SYNC ALL '\n         kw.129  = ' SYNC IMAGES '\n         kw.130  = ' SYNC MEMORY '\n         kw.131  = ' TARGET '\n         kw.132  = ' THEN '\n         kw.133  = ' TO '\n         kw.134  = ' TYPE '\n         kw.135  = ' UNFORMATTED '\n         kw.136  = ' UNIT '\n         kw.137  = ' UNLOCK '\n         kw.138  = ' USE '\n         kw.139  = ' VALUE '\n         kw.140  = ' VOLATILE '\n         kw.141  = ' WAIT '\n         kw.142  = ' WHERE '\n         kw.143  = ' WHILE '\n         kw.144  = ' WRITE '\n         kw.145  = ' END PROGRAM '\n         atr.1   = 'DDDDDDDD'\n         atr.2   = 'DDDDDD'\n         atr.3   = 'DDDDDD'\n         atr.4   = 'DDDDDDD'\n         atr.5   = 'DDDDDDDDDDD'\n         atr.6   = 'DDDDDDDD'\n         atr.7   = 'DDDDDD'\n         atr.8   = 'DDDDDDDDDD'\n         atr.9   = 'DDDDDDDDD'\n         atr.10  = 'DDDDDDDDDDDD'\n         atr.11  = 'DDDDDDDDD'\n         atr.12  = 'DDDD'\n         atr.13  = 'DDDDD'\n         atr.14  = 'DDDDD'\n         atr.15  = 'DDDD'\n         atr.16  = 'DDDD'\n         atr.17  = 'DDDDDDDDD'\n         atr.18  = 'DDDDD'\n         atr.19  = 'DDDDD'\n         atr.20  = 'DDDDDDDDDDD'\n         atr.21  = 'DDDDDD'\n         atr.22  = 'DDDDDDD'\n         atr.23  = 'DDDDDDDD'\n         atr.24  = 'DDDDDDDDDD'\n         atr.25  = 'DDDDDDDD'\n         atr.26  = 'DDDDDDDD'\n         atr.27  = 'DDDDD'\n         atr.28  = 'DDDD'\n         atr.29  = 'DDDDDDDDDD'\n         atr.30  = 'DDDDDDD'\n         atr.31  = 'DDDDDDDD'\n         atr.32  = 'DDDDD'\n         atr.33  = 'DDDDDDDDD'\n         atr.34  = 'DDDDDD'\n         atr.35  = 'DD'\n         atr.36  = 'DDDDDDDDDDDD'\n         atr.37  = 'DDDDDD'\n         atr.38  = 'DDDD'\n         atr.39  = 'DDDDDDDDD'\n         atr.40  = 'DDD'\n         atr.41  = 'DDDDDDD'\n         atr.42  = 'DDDDD'\n         atr.43  = 'DDDD'\n         atr.44  = 'DDDDDDDDDD'\n         atr.45  = 'DDD'\n         atr.46  = 'DDDDDDDDDDD'\n         atr.47  = 'DDD'\n         atr.48  = 'DDDDDDDDD'\n         atr.49  = 'DDDDD'\n         atr.50  = 'DDDD'\n         atr.51  = 'DDDDDDD'\n         atr.52  = 'DDDDDDDD'\n         atr.53  = 'DDDD'\n         atr.54  = 'DDDDD'\n         atr.55  = 'DDDDD'\n         atr.56  = 'DDD'\n         atr.57  = 'DDDD'\n         atr.58  = 'DDDDDD'\n         atr.59  = 'DDDDDDDDD'\n         atr.60  = 'DDDDDDDD'\n         atr.61  = 'DDDDDDD'\n         atr.62  = 'DD'\n         atr.63  = 'DD'\n         atr.64  = 'DDDDDDDD'\n         atr.65  = 'DDDDDD'\n         atr.66  = 'DD'\n         atr.67  = 'DDDDD'\n         atr.68  = 'DDDDDDD'\n         atr.69  = 'DDDDDDD'\n         atr.70  = 'DDDDDD'\n         atr.71  = 'DDDDDDDDD'\n         atr.72  = 'DDDDDDDDD'\n         atr.73  = 'DDDDDDDD'\n         atr.74  = 'DDDDDD'\n         atr.75  = 'DDDD'\n         atr.76  = 'DDD'\n         atr.77  = 'DDDD'\n         atr.78  = 'DDDDDDD'\n         atr.79  = 'DDDDDD'\n         atr.80  = 'DDDD'\n         atr.81  = 'DDDDD'\n         atr.82  = 'DDDDDDDD'\n         atr.83  = 'DDDDDDD'\n         atr.84  = 'DDD'\n         atr.85  = 'DDDDDDDDDDDDDDD'\n         atr.86  = 'DDDD'\n         atr.87  = 'DDDDDD'\n         atr.88  = 'DDDDDDD'\n         atr.89  = 'DDDDDD'\n         atr.90  = 'DDDD'\n         atr.91  = 'DDDD'\n         atr.92  = 'DDDDDD'\n         atr.93  = 'DDDDDDDD'\n         atr.94  = 'DDDDDDDD'\n         atr.95  = 'DDD'\n         atr.96  = 'DDD'\n         atr.97  = 'DDDDDDDDD'\n         atr.98  = 'DDDD'\n         atr.99  = 'DDDDD'\n         atr.100 = 'DDDDDDD'\n         atr.101 = 'DDDDDDDD'\n         atr.102 = 'DDDDDDDDD'\n         atr.103 = 'DDDDD'\n         atr.104 = 'DDDDDDD'\n         atr.105 = 'DDDDDDDDD'\n         atr.106 = 'DDDDDDD'\n         atr.107 = 'DDDDDDDDD'\n         atr.108 = 'DDDDDD'\n         atr.109 = 'DDDD'\n         atr.110 = 'DDDDDDDDD'\n         atr.111 = 'DDDD'\n         atr.112 = 'DDD'\n         atr.113 = 'DDDD'\n         atr.114 = 'DDDDDDDDD'\n         atr.115 = 'DDDDDD'\n         atr.116 = 'DDDDDD'\n         atr.117 = 'DDDDDD'\n         atr.118 = 'DDDD'\n         atr.119 = 'DDDDDD'\n         atr.120 = 'DDDDDDDD'\n         atr.121 = 'DDDDDDDDDD'\n         atr.122 = 'DDDD'\n         atr.123 = 'DDDD'\n         atr.124 = 'DDDDDD'\n         atr.125 = 'DDDD'\n         atr.126 = 'DDDDDDDDD'\n         atr.127 = 'DDDDDDDDDD'\n         atr.128 = 'DDDDDDD'\n         atr.129 = 'DDDDDDDDDD'\n         atr.130 = 'DDDDDDDDDD'\n         atr.131 = 'DDDDDD'\n         atr.132 = 'DDDD'\n         atr.133 = 'DD'\n         atr.134 = 'DDDD'\n         atr.135 = 'DDDDDDDDDDD'\n         atr.136 = 'DDDD'\n         atr.137 = 'DDDDDD'\n         atr.138 = 'DDD'\n         atr.139 = 'DDDDD'\n         atr.140 = 'DDDDDDDD'\n         atr.141 = 'DDDD'\n         atr.142 = 'DDDDD'\n         atr.143 = 'DDDDD'\n         atr.144 = 'DDDDD'\n         atr.145 = 'DDD DDDDDDD'\n         clr.1   = 'RRRRRRRR'\n         clr.2   = 'RRRRRR'\n         clr.3   = 'RRRRRR'\n         clr.4   = 'RRRRRRR'\n         clr.5   = 'RRRRRRRRRRR'\n         clr.6   = 'RRRRRRRR'\n         clr.7   = 'RRRRRR'\n         clr.8   = 'RRRRRRRRRR'\n         clr.9   = 'RRRRRRRRR'\n         clr.10  = 'RRRRRRRRRRRR'\n         clr.11  = 'RRRRRRRRR'\n         clr.12  = 'RRRR'\n         clr.13  = 'RRRRR'\n         clr.14  = 'RRRRR'\n         clr.15  = 'RRRR'\n         clr.16  = 'RRRR'\n         clr.17  = 'RRRRRRRRR'\n         clr.18  = 'RRRRR'\n         clr.19  = 'RRRRR'\n         clr.20  = 'RRRRRRRRRRR'\n         clr.21  = 'RRRRRR'\n         clr.22  = 'RRRRRRR'\n         clr.23  = 'RRRRRRRR'\n         clr.24  = 'RRRRRRRRRR'\n         clr.25  = 'RRRRRRRR'\n         clr.26  = 'RRRRRRRR'\n         clr.27  = 'RRRRR'\n         clr.28  = 'RRRR'\n         clr.29  = 'RRRRRRRRRR'\n         clr.30  = 'RRRRRRR'\n         clr.31  = 'RRRRRRRR'\n         clr.32  = 'RRRRR'\n         clr.33  = 'RRRRRRRRR'\n         clr.34  = 'RRRRRR'\n         clr.35  = 'RR'\n         clr.36  = 'RRRRRRRRRRRR'\n         clr.37  = 'RRRRRR'\n         clr.38  = 'RRRR'\n         clr.39  = 'RRRRRRRRR'\n         clr.40  = 'RRR'\n         clr.41  = 'RRRRRRR'\n         clr.42  = 'RRRRR'\n         clr.43  = 'RRRR'\n         clr.44  = 'RRRRRRRRRR'\n         clr.45  = 'RRR'\n         clr.46  = 'RRRRRRRRRRR'\n         clr.47  = 'RRR'\n         clr.48  = 'RRRRRRRRR'\n         clr.49  = 'RRRRR'\n         clr.50  = 'RRRR'\n         clr.51  = 'RRRRRRR'\n         clr.52  = 'RRRRRRRR'\n         clr.53  = 'RRRR'\n         clr.54  = 'RRRRR'\n         clr.55  = 'RRRRR'\n         clr.56  = 'RRR'\n         clr.57  = 'RRRR'\n         clr.58  = 'RRRRRR'\n         clr.59  = 'RRRRRRRRR'\n         clr.60  = 'RRRRRRRR'\n         clr.61  = 'RRRRRRR'\n         clr.62  = 'RR'\n         clr.63  = 'RR'\n         clr.64  = 'RRRRRRRR'\n         clr.65  = 'RRRRRR'\n         clr.66  = 'RR'\n         clr.67  = 'RRRRR'\n         clr.68  = 'RRRRRRR'\n         clr.69  = 'RRRRRRR'\n         clr.70  = 'RRRRRR'\n         clr.71  = 'RRRRRRRRR'\n         clr.72  = 'RRRRRRRRR'\n         clr.73  = 'RRRRRRRR'\n         clr.74  = 'RRRRRR'\n         clr.75  = 'RRRR'\n         clr.76  = 'RRR'\n         clr.77  = 'RRRR'\n         clr.78  = 'RRRRRRR'\n         clr.79  = 'RRRRRR'\n         clr.80  = 'RRRR'\n         clr.81  = 'RRRRR'\n         clr.82  = 'RRRRRRRR'\n         clr.83  = 'RRRRRRR'\n         clr.84  = 'RRR'\n         clr.85  = 'RRRRRRRRRRRRRRR'\n         clr.86  = 'RRRR'\n         clr.87  = 'RRRRRR'\n         clr.88  = 'RRRRRRR'\n         clr.89  = 'RRRRRR'\n         clr.90  = 'RRRR'\n         clr.91  = 'RRRR'\n         clr.92  = 'RRRRRR'\n         clr.93  = 'RRRRRRRR'\n         clr.94  = 'RRRRRRRR'\n         clr.95  = 'RRR'\n         clr.96  = 'RRR'\n         clr.97  = 'RRRRRRRRR'\n         clr.98  = 'RRRR'\n         clr.99  = 'RRRRR'\n         clr.100 = 'RRRRRRR'\n         clr.101 = 'RRRRRRRR'\n         clr.102 = 'RRRRRRRRR'\n         clr.103 = 'RRRRR'\n         clr.104 = 'RRRRRRR'\n         clr.105 = 'RRRRRRRRR'\n         clr.106 = 'RRRRRRR'\n         clr.107 = 'RRRRRRRRR'\n         clr.108 = 'RRRRRR'\n         clr.109 = 'RRRR'\n         clr.110 = 'RRRRRRRRR'\n         clr.111 = 'RRRR'\n         clr.112 = 'RRR'\n         clr.113 = 'RRRR'\n         clr.114 = 'RRRRRRRRR'\n         clr.115 = 'RRRRRR'\n         clr.116 = 'RRRRRR'\n         clr.117 = 'RRRRRR'\n         clr.118 = 'RRRR'\n         clr.119 = 'RRRRRR'\n         clr.120 = 'RRRRRRRR'\n         clr.121 = 'RRRRRRRRRR'\n         clr.122 = 'RRRR'\n         clr.123 = 'RRRR'\n         clr.124 = 'RRRRRR'\n         clr.125 = 'RRRR'\n         clr.126 = 'RRRRRRRRR'\n         clr.127 = 'RRRRRRRRRR'\n         clr.128 = 'RRRRRRR'\n         clr.129 = 'RRRRRRRRRR'\n         clr.130 = 'RRRRRRRRRR'\n         clr.131 = 'RRRRRR'\n         clr.132 = 'RRRR'\n         clr.133 = 'RR'\n         clr.134 = 'RRRR'\n         clr.135 = 'RRRRRRRRRRR'\n         clr.136 = 'RRRR'\n         clr.137 = 'RRRRRR'\n         clr.138 = 'RRR'\n         clr.139 = 'RRRRR'\n         clr.140 = 'RRRRRRRR'\n         clr.141 = 'RRRR'\n         clr.142 = 'RRRRR'\n         clr.143 = 'RRRRR'\n         clr.144 = 'RRRRR'\n         clr.145 = 'RRR RRRRRRR'\n      end\n   when (usrhilng = 'GO') then\n      do\n         kw.0    = 25\n         kw.1    = ' BREAK '\n         kw.2    = ' CASE '\n         kw.3    = ' CHAN '\n         kw.4    = ' CONST '\n         kw.5    = ' CONTINUE '\n         kw.6    = ' DEFAULT '\n         kw.7    = ' DEFER '\n         kw.8    = ' ELSE '\n         kw.9    = ' FALLTHROUGH '\n         kw.10   = ' FOR '\n         kw.11   = ' FUNC '\n         kw.12   = ' GO '\n         kw.13   = ' GOTO '\n         kw.14   = ' IF '\n         kw.15   = ' IMPORT '\n         kw.16   = ' INTERFACE '\n         kw.17   = ' MAP '\n         kw.18   = ' PACKAGE '\n         kw.19   = ' RANGE '\n         kw.20   = ' RETURN '\n         kw.21   = ' SELECT '\n         kw.22   = ' STRUCT '\n         kw.23   = ' SWITCH '\n         kw.24   = ' TYPE '\n         kw.25   = ' VAR '\n         atr.1   = 'DDDDD'\n         atr.2   = 'DDDD'\n         atr.3   = 'DDDD'\n         atr.4   = 'DDDDD'\n         atr.5   = 'DDDDDDDD'\n         atr.6   = 'DDDDDDD'\n         atr.7   = 'DDDDD'\n         atr.8   = 'DDDD'\n         atr.9   = 'DDDDDDDDDDD'\n         atr.10  = 'DDD'\n         atr.11  = 'DDDD'\n         atr.12  = 'DD'\n         atr.13  = 'DDDD'\n         atr.14  = 'DD'\n         atr.15  = 'DDDDDD'\n         atr.16  = 'DDDDDDDDD'\n         atr.17  = 'DDD'\n         atr.18  = 'DDDDDDD'\n         atr.19  = 'DDDDD'\n         atr.20  = 'DDDDDD'\n         atr.21  = 'DDDDDD'\n         atr.22  = 'DDDDDD'\n         atr.23  = 'DDDDDD'\n         atr.24  = 'DDDD'\n         atr.25  = 'DDD'\n         clr.1   = 'RRRRR'\n         clr.2   = 'RRRR'\n         clr.3   = 'RRRR'\n         clr.4   = 'RRRRR'\n         clr.5   = 'RRRRRRRR'\n         clr.6   = 'RRRRRRR'\n         clr.7   = 'RRRRR'\n         clr.8   = 'RRRR'\n         clr.9   = 'RRRRRRRRRRR'\n         clr.10  = 'RRR'\n         clr.11  = 'RRRR'\n         clr.12  = 'RR'\n         clr.13  = 'RRRR'\n         clr.14  = 'RR'\n         clr.15  = 'RRRRRR'\n         clr.16  = 'RRRRRRRRR'\n         clr.17  = 'RRR'\n         clr.18  = 'RRRRRRR'\n         clr.19  = 'RRRRR'\n         clr.20  = 'RRRRRR'\n         clr.21  = 'RRRRRR'\n         clr.22  = 'RRRRRR'\n         clr.23  = 'RRRRRR'\n         clr.24  = 'RRRR'\n         clr.25  = 'RRR'\n      end\n   when (usrhilng = 'JAVA') then\n      do\n         kw.0   = 53\n         kw.1   = ' ABSTRACT '\n         kw.2   = ' ASSERT '\n         kw.3   = ' BOOLEAN '\n         kw.4   = ' BREAK '\n         kw.5   = ' BYTE '\n         kw.6   = ' CASE '\n         kw.7   = ' CATCH '\n         kw.8   = ' CHAR '\n         kw.9   = ' CLASS '\n         kw.10  = ' CONST '\n         kw.11  = ' CONTINUE '\n         kw.12  = ' DEFAULT '\n         kw.13  = ' DO '\n         kw.14  = ' DOUBLE '\n         kw.15  = ' ELSE '\n         kw.16  = ' ENUM '\n         kw.17  = ' EXTENDS '\n         kw.18  = ' FALSE '\n         kw.19  = ' FINAL '\n         kw.20  = ' FINALLY '\n         kw.21  = ' FLOAT '\n         kw.22  = ' FOR '\n         kw.23  = ' GOTO '\n         kw.24  = ' IF '\n         kw.25  = ' IMPLEMENTS '\n         kw.26  = ' IMPORT '\n         kw.27  = ' INSTANCEOF '\n         kw.28  = ' INT '\n         kw.29  = ' INTERFACE '\n         kw.30  = ' LONG '\n         kw.31  = ' NATIVE '\n         kw.32  = ' NEW '\n         kw.33  = ' NULL '\n         kw.34  = ' PACKAGE '\n         kw.35  = ' PRIVATE '\n         kw.36  = ' PROTECTED '\n         kw.37  = ' PUBLIC '\n         kw.38  = ' RETURN '\n         kw.39  = ' SHORT '\n         kw.40  = ' STATIC '\n         kw.41  = ' STRICTFP '\n         kw.42  = ' SUPER '\n         kw.43  = ' SWITCH '\n         kw.44  = ' SYNCHRONIZED '\n         kw.45  = ' THIS '\n         kw.46  = ' THROW '\n         kw.47  = ' THROWS '\n         kw.48  = ' TRANSIENT '\n         kw.49  = ' TRUE '\n         kw.50  = ' TRY '\n         kw.51  = ' VOID '\n         kw.52  = ' VOLATILE '\n         kw.53  = ' WHILE '\n         atr.1  = 'DDDDDDDD'\n         atr.2  = 'DDDDDD'\n         atr.3  = 'DDDDDDD'\n         atr.4  = 'DDDDD'\n         atr.5  = 'DDDD'\n         atr.6  = 'DDDD'\n         atr.7  = 'DDDDD'\n         atr.8  = 'DDDD'\n         atr.9  = 'DDDDD'\n         atr.10 = 'DDDDD'\n         atr.11 = 'DDDDDDDD'\n         atr.12 = 'DDDDDDD'\n         atr.13 = 'DD'\n         atr.14 = 'DDDDDD'\n         atr.15 = 'DDDD'\n         atr.16 = 'DDDD'\n         atr.17 = 'DDDDDDD'\n         atr.18 = 'DDDDD'\n         atr.19 = 'DDDDD'\n         atr.20 = 'DDDDDDD'\n         atr.21 = 'DDDDD'\n         atr.22 = 'DDD'\n         atr.23 = 'DDDD'\n         atr.24 = 'DD'\n         atr.25 = 'DDDDDDDDDD'\n         atr.26 = 'DDDDDD'\n         atr.27 = 'DDDDDDDDDD'\n         atr.28 = 'DDD'\n         atr.29 = 'DDDDDDDDD'\n         atr.30 = 'DDDD'\n         atr.31 = 'DDDDDD'\n         atr.32 = 'DDD'\n         atr.33 = 'DDDD'\n         atr.34 = 'DDDDDDD'\n         atr.35 = 'DDDDDDD'\n         atr.36 = 'DDDDDDDDD'\n         atr.37 = 'DDDDDD'\n         atr.38 = 'DDDDDD'\n         atr.39 = 'DDDDD'\n         atr.40 = 'DDDDDD'\n         atr.41 = 'DDDDDDDD'\n         atr.42 = 'DDDDD'\n         atr.43 = 'DDDDDD'\n         atr.44 = 'DDDDDDDDDDDD'\n         atr.45 = 'DDDD'\n         atr.46 = 'DDDDD'\n         atr.47 = 'DDDDDD'\n         atr.48 = 'DDDDDDDDD'\n         atr.49 = 'DDDD'\n         atr.50 = 'DDD'\n         atr.51 = 'DDDD'\n         atr.52 = 'DDDDDDDD'\n         atr.53 = 'DDDDD'\n         clr.1  = 'RRRRRRRR'\n         clr.2  = 'RRRRRR'\n         clr.3  = 'RRRRRRR'\n         clr.4  = 'RRRRR'\n         clr.5  = 'RRRR'\n         clr.6  = 'RRRR'\n         clr.7  = 'RRRRR'\n         clr.8  = 'RRRR'\n         clr.9  = 'RRRRR'\n         clr.10 = 'RRRRR'\n         clr.11 = 'RRRRRRRR'\n         clr.12 = 'RRRRRRR'\n         clr.13 = 'RR'\n         clr.14 = 'RRRRRR'\n         clr.15 = 'RRRR'\n         clr.16 = 'RRRR'\n         clr.17 = 'RRRRRRR'\n         clr.18 = 'RRRRR'\n         clr.19 = 'RRRRR'\n         clr.20 = 'RRRRRRR'\n         clr.21 = 'RRRRR'\n         clr.22 = 'RRR'\n         clr.23 = 'RRRR'\n         clr.24 = 'RR'\n         clr.25 = 'RRRRRRRRRR'\n         clr.26 = 'RRRRRR'\n         clr.27 = 'RRRRRRRRRR'\n         clr.28 = 'RRR'\n         clr.29 = 'RRRRRRRRR'\n         clr.30 = 'RRRR'\n         clr.31 = 'RRRRRR'\n         clr.32 = 'RRR'\n         clr.33 = 'RRRR'\n         clr.34 = 'RRRRRRR'\n         clr.35 = 'RRRRRRR'\n         clr.36 = 'RRRRRRRRR'\n         clr.37 = 'RRRRRR'\n         clr.38 = 'RRRRRR'\n         clr.39 = 'RRRRR'\n         clr.40 = 'RRRRRR'\n         clr.41 = 'RRRRRRRR'\n         clr.42 = 'RRRRR'\n         clr.43 = 'RRRRRR'\n         clr.44 = 'RRRRRRRRRRRR'\n         clr.45 = 'RRRR'\n         clr.46 = 'RRRRR'\n         clr.47 = 'RRRRRR'\n         clr.48 = 'RRRRRRRRR'\n         clr.49 = 'RRRR'\n         clr.50 = 'RRR'\n         clr.51 = 'RRRR'\n         clr.52 = 'RRRRRRRR'\n         clr.53 = 'RRRRR'\n      end\n   when (usrhilng = 'JSON') then\n      kw.0 = 0\n   when (usrhilng = 'PYTHON') then\n      do\n         kw.0   = 33\n         kw.1   = ' AND '\n         kw.2   = ' AS '\n         kw.3   = ' ASSERT '\n         kw.4   = ' BREAK '\n         kw.5   = ' CLASS '\n         kw.6   = ' CONTINUE '\n         kw.7   = ' DEF '\n         kw.8   = ' DEL '\n         kw.9   = ' ELIF '\n         kw.10  = ' ELSE '\n         kw.11  = ' EXCEPT '\n         kw.12  = ' FALSE '\n         kw.13  = ' FINALLY '\n         kw.14  = ' FOR '\n         kw.15  = ' FROM '\n         kw.16  = ' GLOBAL '\n         kw.17  = ' IF '\n         kw.18  = ' IMPORT '\n         kw.19  = ' IN '\n         kw.20  = ' IS '\n         kw.21  = ' LAMBDA '\n         kw.22  = ' NONE '\n         kw.23  = ' NONLOCAL '\n         kw.24  = ' NOT '\n         kw.25  = ' OR '\n         kw.26  = ' PASS '\n         kw.27  = ' RAISE '\n         kw.28  = ' RETURN '\n         kw.29  = ' TRUE '\n         kw.30  = ' TRY '\n         kw.31  = ' WHILE '\n         kw.32  = ' WITH '\n         kw.33  = ' YIELD '\n         atr.1  = 'DDD'\n         atr.2  = 'DD'\n         atr.3  = 'DDDDDD'\n         atr.4  = 'DDDDD'\n         atr.5  = 'DDDDD'\n         atr.6  = 'DDDDDDDD'\n         atr.7  = 'DDD'\n         atr.8  = 'DDD'\n         atr.9  = 'DDDD'\n         atr.10 = 'DDDD'\n         atr.11 = 'DDDDDD'\n         atr.12 = 'DDDDD'\n         atr.13 = 'DDDDDDD'\n         atr.14 = 'DDD'\n         atr.15 = 'DDDD'\n         atr.16 = 'DDDDDD'\n         atr.17 = 'DD'\n         atr.18 = 'DDDDDD'\n         atr.19 = 'DD'\n         atr.20 = 'DD'\n         atr.21 = 'DDDDDD'\n         atr.22 = 'DDDD'\n         atr.23 = 'DDDDDDDD'\n         atr.24 = 'DDD'\n         atr.25 = 'DD'\n         atr.26 = 'DDDD'\n         atr.27 = 'DDDDD'\n         atr.28 = 'DDDDDD'\n         atr.29 = 'DDDD'\n         atr.30 = 'DDD'\n         atr.31 = 'DDDDD'\n         atr.32 = 'DDDD'\n         atr.33 = 'DDDDD'\n         clr.1  = 'RRR'\n         clr.2  = 'RR'\n         clr.3  = 'RRRRRR'\n         clr.4  = 'RRRRR'\n         clr.5  = 'RRRRR'\n         clr.6  = 'RRRRRRRR'\n         clr.7  = 'RRR'\n         clr.8  = 'RRR'\n         clr.9  = 'RRRR'\n         clr.10 = 'RRRR'\n         clr.11 = 'RRRRRR'\n         clr.12 = 'RRRRR'\n         clr.13 = 'RRRRRRR'\n         clr.14 = 'RRR'\n         clr.15 = 'RRRR'\n         clr.16 = 'RRRRRR'\n         clr.17 = 'RR'\n         clr.18 = 'RRRRRR'\n         clr.19 = 'RR'\n         clr.20 = 'RR'\n         clr.21 = 'RRRRRR'\n         clr.22 = 'RRRR'\n         clr.23 = 'RRRRRRRR'\n         clr.24 = 'RRR'\n         clr.25 = 'RR'\n         clr.26 = 'RRRR'\n         clr.27 = 'RRRRR'\n         clr.28 = 'RRRRRR'\n         clr.29 = 'RRRR'\n         clr.30 = 'RRR'\n         clr.31 = 'RRRRR'\n         clr.32 = 'RRRR'\n         clr.33 = 'RRRRR'\n      end\n   when (usrhilng = 'RUBY') then\n      do\n         kw.0   = 43\n         kw.1   = ' __ENCODING__ '\n         kw.2   = ' __LINE__ '\n         kw.3   = ' __FILE__ '\n         kw.4   = ' BEGIN '\n         kw.5   = ' END '\n         kw.6   = ' ALIAS '\n         kw.7   = ' AND '\n         kw.8   = ' BREAK '\n         kw.9   = ' CASE '\n         kw.10  = ' CLASS '\n         kw.11  = ' DEF '\n         kw.12  = ' DEFINED? '\n         kw.13  = ' DO '\n         kw.14  = ' ELSE '\n         kw.15  = ' ELSIF '\n         kw.16  = ' END '\n         kw.17  = ' ENSURE '\n         kw.18  = ' FALSE '\n         kw.19  = ' FOR '\n         kw.20  = ' IF '\n         kw.21  = ' IN '\n         kw.22  = ' MODULE '\n         kw.23  = ' NEXT '\n         kw.24  = ' NIL '\n         kw.25  = ' NOT '\n         kw.26  = ' OR '\n         kw.27  = ' REDO '\n         kw.28  = ' RESCUE '\n         kw.29  = ' RETRY '\n         kw.30  = ' RETURN '\n         kw.31  = ' SELF '\n         kw.32  = ' SUPER '\n         kw.33  = ' THEN '\n         kw.34  = ' TRUE '\n         kw.35  = ' UNDEF '\n         kw.36  = ' UNLESS '\n         kw.37  = ' UNTIL '\n         kw.38  = ' WHEN '\n         kw.39  = ' WHILE '\n         kw.40  = ' YIELD '\n         kw.41  = ' PUTS '\n         kw.42  = ' PRINT '\n         kw.43  = ' __END__ '\n         atr.1  = 'DDDDDDDDDDDD'\n         atr.2  = 'DDDDDDDD'\n         atr.3  = 'DDDDDDDD'\n         atr.4  = 'DDDDD'\n         atr.5  = 'DDD'\n         atr.6  = 'DDDDD'\n         atr.7  = 'DDD'\n         atr.8  = 'DDDDD'\n         atr.9  = 'DDDD'\n         atr.10 = 'DDDDD'\n         atr.11 = 'DDD'\n         atr.12 = 'DDDDDDDD'\n         atr.13 = 'DD'\n         atr.14 = 'DDDD'\n         atr.15 = 'DDDDD'\n         atr.16 = 'DDD'\n         atr.17 = 'DDDDDD'\n         atr.18 = 'DDDDD'\n         atr.19 = 'DDD'\n         atr.20 = 'DD'\n         atr.21 = 'DD'\n         atr.22 = 'DDDDDD'\n         atr.23 = 'DDDD'\n         atr.24 = 'DDD'\n         atr.25 = 'DDD'\n         atr.26 = 'DD'\n         atr.27 = 'DDDD'\n         atr.28 = 'DDDDDD'\n         atr.29 = 'DDDDD'\n         atr.30 = 'DDDDDD'\n         atr.31 = 'DDDD'\n         atr.32 = 'DDDDD'\n         atr.33 = 'DDDD'\n         atr.34 = 'DDDD'\n         atr.35 = 'DDDDD'\n         atr.36 = 'DDDDDD'\n         atr.37 = 'DDDDD'\n         atr.39 = 'DDDD'\n         atr.38 = 'DDDDD'\n         atr.40 = 'DDDDD'\n         atr.41 = 'DDDD'\n         atr.42 = 'DDDDD'\n         atr.43 = 'DDDDDDD'\n         clr.1  = 'RRRRRRRRRRRR'\n         clr.2  = 'RRRRRRRR'\n         clr.3  = 'RRRRRRRR'\n         clr.4  = 'RRRRR'\n         clr.5  = 'RRR'\n         clr.6  = 'RRRRR'\n         clr.7  = 'RRR'\n         clr.8  = 'RRRRR'\n         clr.9  = 'RRRR'\n         clr.10 = 'RRRRR'\n         clr.11 = 'RRR'\n         clr.12 = 'RRRRRRRR'\n         clr.13 = 'RR'\n         clr.14 = 'RRRR'\n         clr.15 = 'RRRRR'\n         clr.17 = 'RRR'\n         clr.17 = 'RRRRRR'\n         clr.18 = 'RRRRR'\n         clr.19 = 'RRR'\n         clr.20 = 'RR'\n         clr.21 = 'RR'\n         clr.22 = 'RRRRRR'\n         clr.23 = 'RRRR'\n         clr.24 = 'RRR'\n         clr.25 = 'RRR'\n         clr.26 = 'RR'\n         clr.27 = 'RRRR'\n         clr.28 = 'RRRRRR'\n         clr.29 = 'RRRRR'\n         clr.30 = 'RRRRRR'\n         clr.31 = 'RRRR'\n         clr.32 = 'RRRRR'\n         clr.33 = 'RRRR'\n         clr.34 = 'RRRR'\n         clr.35 = 'RRRRR'\n         clr.36 = 'RRRRRR'\n         clr.37 = 'RRRRR'\n         clr.38 = 'RRRR'\n         clr.39 = 'RRRRR'\n         clr.40 = 'RRRRR'\n         clr.41 = 'RRRR'\n         clr.42 = 'RRRRR'\n         clr.43 = 'RRRRRRR'\n      end\n   when (usrhilng = 'SHELL') then\n      do\n         kw.0   = 33\n         kw.1   = ' BREAK '\n         kw.2   = ' CASE '\n         kw.3   = ' CONTINUE '\n         kw.4   = ' DO '\n         kw.5   = ' DONE '\n         kw.6   = ' ECHO '\n         kw.7   = ' ELIF '\n         kw.8   = ' ELSE '\n         kw.9   = ' ESAC '\n         kw.10  = ' EVAL '\n         kw.11  = ' EXEC '\n         kw.12  = ' EXIT '\n         kw.13  = ' EXPORT '\n         kw.14  = ' FI '\n         kw.15  = ' FOR '\n         kw.16  = ' FUNCTION '\n         kw.17  = ' IF '\n         kw.18  = ' IN '\n         kw.19  = ' READ '\n         kw.20  = ' READONLY '\n         kw.21  = ' RETURN '\n         kw.22  = ' SELECT '\n         kw.23  = ' SET '\n         kw.24  = ' SHIFT '\n         kw.25  = ' THEN '\n         kw.26  = ' TIME '\n         kw.27  = ' TRAP '\n         kw.28  = ' UILIMIT '\n         kw.29  = ' UMASK '\n         kw.30  = ' UNTIL '\n         kw.31  = ' UNSET '\n         kw.32  = ' WAIT '\n         kw.33  = ' WHILE '\n         atr.1  = 'DDDDD'\n         atr.2  = 'DDDD'\n         atr.3  = 'DDDDDDDD'\n         atr.4  = 'DD'\n         atr.5  = 'DDDD'\n         atr.6  = 'DDDD'\n         atr.7  = 'DDDD'\n         atr.8  = 'DDDD'\n         atr.9  = 'DDDD'\n         atr.10 = 'DDDD'\n         atr.11 = 'DDDD'\n         atr.12 = 'DDDD'\n         atr.13 = 'DDDDDD'\n         atr.14 = 'DD'\n         atr.15 = 'DDD'\n         atr.16 = 'DDDDDDDD'\n         atr.17 = 'DD'\n         atr.18 = 'DD'\n         atr.19 = 'DDDD'\n         atr.20 = 'DDDDDDDD'\n         atr.21 = 'DDDDDD'\n         atr.22 = 'DDDDDD'\n         atr.23 = 'DDD'\n         atr.24 = 'DDDDD'\n         atr.25 = 'DDDD'\n         atr.26 = 'DDDD'\n         atr.27 = 'DDDD'\n         atr.28 = 'DDDDDDD'\n         atr.29 = 'DDDDD'\n         atr.30 = 'DDDDD'\n         atr.31 = 'DDDDD'\n         atr.32 = 'DDDD'\n         atr.33 = 'DDDDD'\n         clr.1  = 'RRRRR'\n         clr.2  = 'RRRR'\n         clr.3  = 'RRRRRRRR'\n         clr.4  = 'RR'\n         clr.5  = 'RRRR'\n         clr.6  = 'RRRR'\n         clr.7  = 'RRRR'\n         clr.8  = 'RRRR'\n         clr.9  = 'RRRR'\n         clr.10 = 'RRRR'\n         clr.11 = 'RRRR'\n         clr.12 = 'RRRR'\n         clr.13 = 'RRRRRR'\n         clr.14 = 'RR'\n         clr.15 = 'RRR'\n         clr.16 = 'RRRRRRRR'\n         clr.17 = 'RR'\n         clr.18 = 'RR'\n         clr.19 = 'RRRR'\n         clr.20 = 'RRRRRRRR'\n         clr.21 = 'RRRRRR'\n         clr.22 = 'RRRRRR'\n         clr.23 = 'RRR'\n         clr.24 = 'RRRRR'\n         clr.25 = 'RRRR'\n         clr.26 = 'RRRR'\n         clr.27 = 'RRRR'\n         clr.28 = 'RRRRRRR'\n         clr.29 = 'RRRRR'\n         clr.30 = 'RRRRR'\n         clr.31 = 'RRRRR'\n         clr.32 = 'RRRR'\n         clr.33 = 'RRRRR'\n      end\n   when (usrhilng = 'SQL') then\n      do\n         kw.0    = 295\n         kw.1    = ' ADD '\n         kw.2    = ' AFTER '\n         kw.3    = ' ALL '\n         kw.4    = ' ALLOCATE '\n         kw.5    = ' ALLOW '\n         kw.6    = ' ALTERAND '\n         kw.7    = ' ANY '\n         kw.8    = ' AS '\n         kw.9    = ' ARRAY1 '\n         kw.10   = ' ARRAY_EXISTS1 '\n         kw.11   = ' ASENSITIVE '\n         kw.12   = ' ASSOCIATE '\n         kw.13   = ' ASUTIME '\n         kw.14   = ' AT '\n         kw.15   = ' AUDIT '\n         kw.16   = ' AUX '\n         kw.17   = ' AUXILIARY '\n         kw.18   = ' BEFORE '\n         kw.19   = ' BEGIN '\n         kw.20   = ' BETWEEN '\n         kw.21   = ' BUFFERPOOL '\n         kw.22   = ' BY '\n         kw.23   = ' CALL '\n         kw.24   = ' CAPTURE '\n         kw.25   = ' CASCADED '\n         kw.26   = ' CASER '\n         kw.27   = ' CAST '\n         kw.28   = ' CCSIDATE '\n         kw.29   = ' CHARW '\n         kw.30   = ' CHARACTER '\n         kw.31   = ' CHECK '\n         kw.32   = ' CLONE '\n         kw.33   = ' CLOSEY1 '\n         kw.34   = ' CLUSTEREXISTS1 '\n         kw.35   = ' COLLECTION '\n         kw.36   = ' COLLIDATE '\n         kw.37   = ' COLUMNE '\n         kw.38   = ' COMMENT '\n         kw.39   = ' COMMIT '\n         kw.40   = ' CONCAT '\n         kw.41   = ' CONDITION '\n         kw.42   = ' CONNECT '\n         kw.43   = ' CONNECTION '\n         kw.44   = ' CONSTRAINT '\n         kw.45   = ' CONTAINS '\n         kw.46   = ' CONTENTOOL '\n         kw.47   = ' CONTINUE '\n         kw.48   = ' CREATE '\n         kw.49   = ' CUBE '\n         kw.50   = ' CURRENT '\n         kw.51   = ' CURRENT_DATE '\n         kw.52   = ' CURRENT_LC_CTYPE '\n         kw.53   = ' CURRENT_PATH '\n         kw.54   = ' CURRENT_SCHEMA '\n         kw.55   = ' CURRENT_TIME '\n         kw.56   = ' CURRENT_TIMESTAMP '\n         kw.57   = ' CURRVAL '\n         kw.58   = ' CURSOR '\n         kw.59   = ' DATA '\n         kw.60   = ' DATABASE '\n         kw.61   = ' DAY '\n         kw.62   = ' DAYS '\n         kw.63   = ' DBINFO '\n         kw.64   = ' DECLARE '\n         kw.65   = ' DEFAULT '\n         kw.66   = ' DELETE '\n         kw.67   = ' DESCRIPTOR '\n         kw.68   = ' DETERMINISTIC '\n         kw.69   = ' DISABLE '\n         kw.70   = ' DISALLOW '\n         kw.71   = ' DISTINCT '\n         kw.72   = ' DO '\n         kw.73   = ' DOCUMENT '\n         kw.74   = ' DOUBLE '\n         kw.75   = ' DROP '\n         kw.76   = ' DSSIZE '\n         kw.77   = ' DYNAMIC '\n         kw.78   = ' EDITPROC '\n         kw.79   = ' ELSE '\n         kw.80   = ' ELSEIF '\n         kw.81   = ' ENCODING '\n         kw.82   = ' ENCRYPTION '\n         kw.83   = ' END '\n         kw.84   = ' ENDING '\n         kw.85   = ' END-EXEC2 '\n         kw.86   = ' ERASE '\n         kw.87   = ' ESCAPE '\n         kw.88   = ' EXCEPT '\n         kw.89   = ' EXCEPTION '\n         kw.90   = ' EXECUTE '\n         kw.91   = ' EXISTS '\n         kw.92   = ' EXIT '\n         kw.93   = ' EXPLAIN '\n         kw.94   = ' EXTERNAL '\n         kw.95   = ' FENCED '\n         kw.96   = ' FETCH '\n         kw.97   = ' FIELDPROC '\n         kw.98   = ' FINAL '\n         kw.99   = ' FIRST '\n         kw.100  = ' FOR '\n         kw.101  = ' FREE '\n         kw.102  = ' FROM '\n         kw.103  = ' FULL '\n         kw.104  = ' FUNCTION '\n         kw.105  = ' GENERATED '\n         kw.106  = ' GET '\n         kw.107  = ' GLOBAL '\n         kw.108  = ' GO '\n         kw.109  = ' GOTO '\n         kw.110  = ' GRANT '\n         kw.111  = ' GROUP '\n         kw.112  = ' HANDLER '\n         kw.113  = ' HAVING '\n         kw.114  = ' HOLD '\n         kw.115  = ' HOUR '\n         kw.116  = ' HOURS '\n         kw.117  = ' IF '\n         kw.118  = ' IMMEDIATE '\n         kw.119  = ' IN '\n         kw.120  = ' INCLUSIVE '\n         kw.121  = ' INDEX '\n         kw.122  = ' INHERIT '\n         kw.123  = ' INNER '\n         kw.124  = ' INOUT '\n         kw.125  = ' INSENSITIVE '\n         kw.126  = ' INSERT '\n         kw.127  = ' INTERSECT '\n         kw.128  = ' INTO '\n         kw.129  = ' IS '\n         kw.130  = ' ISOBID '\n         kw.131  = ' ITERATE '\n         kw.132  = ' JAR '\n         kw.133  = ' JOIN '\n         kw.134  = ' KEEP '\n         kw.135  = ' KEY '\n         kw.136  = ' LABEL '\n         kw.137  = ' LANGUAGE '\n         kw.138  = ' LAST '\n         kw.139  = ' LC_CTYPE '\n         kw.140  = ' LEAVE '\n         kw.141  = ' LEFT '\n         kw.142  = ' LIKE '\n         kw.143  = ' LOCAL '\n         kw.144  = ' LOCALE '\n         kw.145  = ' LOCATOR '\n         kw.146  = ' LOCATORS '\n         kw.147  = ' LOCK '\n         kw.148  = ' LOCKMAX '\n         kw.149  = ' LOCKSIZE '\n         kw.150  = ' LONG '\n         kw.151  = ' LOOP '\n         kw.152  = ' MAINTAINED '\n         kw.153  = ' MATERIALIZED '\n         kw.154  = ' MICROSECOND '\n         kw.155  = ' MICROSECONDS '\n         kw.156  = ' MINUTEMINUTES '\n         kw.157  = ' MODIFIES '\n         kw.158  = ' MONTH '\n         kw.159  = ' MONTHS '\n         kw.160  = ' NEXT '\n         kw.161  = ' NEXTVAL '\n         kw.162  = ' NO '\n         kw.163  = ' NONE '\n         kw.164  = ' NOT '\n         kw.165  = ' NULL '\n         kw.166  = ' NULLS '\n         kw.167  = ' NUMPARTS '\n         kw.168  = ' OBID '\n         kw.169  = ' OF '\n         kw.170  = ' OLD '\n         kw.171  = ' ON '\n         kw.172  = ' OPEN '\n         kw.173  = ' OPTIMIZATION '\n         kw.174  = ' OPTIMIZE '\n         kw.175  = ' OR '\n         kw.176  = ' ORDER '\n         kw.177  = ' ORGANIZATION '\n         kw.178  = ' OUT '\n         kw.179  = ' OUTER '\n         kw.180  = ' PACKAGE '\n         kw.181  = ' PARAMETER '\n         kw.182  = ' PART '\n         kw.183  = ' PADDED '\n         kw.184  = ' PARTITION '\n         kw.185  = ' PARTITIONED '\n         kw.186  = ' PARTITIONING '\n         kw.187  = ' PATH '\n         kw.188  = ' PIECESIZE '\n         kw.189  = ' PERIOD '\n         kw.190  = ' PLAN '\n         kw.191  = ' PRECISION '\n         kw.192  = ' PREPARE '\n         kw.193  = ' PREVVAL '\n         kw.194  = ' PRIOR '\n         kw.195  = ' PRIQTY '\n         kw.196  = ' PRIVILEGES '\n         kw.197  = ' PROCEDURE '\n         kw.198  = ' PROGRAM '\n         kw.199  = ' PSID '\n         kw.200  = ' PUBLIC '\n         kw.201  = ' QUERY '\n         kw.202  = ' QUERYNO '\n         kw.203  = ' READS '\n         kw.204  = ' REFERENCES '\n         kw.205  = ' REFRESH '\n         kw.206  = ' RESIGNAL '\n         kw.207  = ' RELEASE '\n         kw.208  = ' RENAME '\n         kw.209  = ' REPEAT '\n         kw.210  = ' RESTRICT '\n         kw.211  = ' RESULT '\n         kw.212  = ' RESULT_SET_LOCATOR '\n         kw.213  = ' RETURN '\n         kw.214  = ' RETURNS '\n         kw.215  = ' REVOKE '\n         kw.216  = ' RIGHT '\n         kw.217  = ' ROLE '\n         kw.218  = ' ROLLBACK '\n         kw.219  = ' ROLLUP1 '\n         kw.220  = ' ROUND_CEILING '\n         kw.221  = ' ROUND_DOWN '\n         kw.222  = ' ROUND_FLOOR '\n         kw.223  = ' ROUND_HALF_DOWN '\n         kw.224  = ' ROUND_HALF_EVEN '\n         kw.225  = ' ROUND_HALF_UP '\n         kw.226  = ' ROUND_UP '\n         kw.227  = ' ROW '\n         kw.228  = ' ROWSET '\n         kw.229  = ' RUN '\n         kw.230  = ' SAVEPOINT '\n         kw.231  = ' SCHEMA '\n         kw.232  = ' SCRATCHPAD '\n         kw.233  = ' SECOND '\n         kw.234  = ' SECONDS '\n         kw.235  = ' SECQTY '\n         kw.236  = ' SECURITY '\n         kw.237  = ' SEQUENCE '\n         kw.238  = ' SELECT '\n         kw.239  = ' SENSITIVE '\n         kw.240  = ' SESSION_USER '\n         kw.241  = ' SET '\n         kw.242  = ' SIGNAL '\n         kw.243  = ' SIMPLE '\n         kw.244  = ' SOME '\n         kw.245  = ' SOURCE '\n         kw.246  = ' SPECIFIC '\n         kw.247  = ' STANDARD '\n         kw.248  = ' STATIC '\n         kw.249  = ' STATEMENT '\n         kw.250  = ' STAY '\n         kw.251  = ' STOGROUP '\n         kw.252  = ' STORES '\n         kw.253  = ' STYLE '\n         kw.254  = ' SUMMARY '\n         kw.255  = ' SYNONYM '\n         kw.256  = ' SYSDATE '\n         kw.257  = ' SYSTEM '\n         kw.258  = ' SYSTIMESTAMP '\n         kw.259  = ' TABLE '\n         kw.260  = ' TABLESPACE '\n         kw.261  = ' THEN '\n         kw.262  = ' TO '\n         kw.263  = ' TRANSFER OWNERSHIP '\n         kw.264  = ' TRIGGER '\n         kw.265  = ' TRUNCATE '\n         kw.266  = ' TYPE '\n         kw.267  = ' UNDO '\n         kw.268  = ' UNION '\n         kw.269  = ' UNIQUE '\n         kw.270  = ' UNTIL '\n         kw.271  = ' UPDATE '\n         kw.272  = ' USER '\n         kw.273  = ' USING '\n         kw.274  = ' VALIDPROC '\n         kw.275  = ' VALUE '\n         kw.276  = ' VALUES '\n         kw.277  = ' VARIABLE '\n         kw.278  = ' VARIANT '\n         kw.279  = ' VCAT '\n         kw.280  = ' VERSIONING1 '\n         kw.281  = ' VIEW '\n         kw.282  = ' VOLATILE '\n         kw.283  = ' VOLUMES '\n         kw.284  = ' WHEN '\n         kw.285  = ' WHENEVER '\n         kw.286  = ' WHERE '\n         kw.287  = ' WHILE '\n         kw.288  = ' WITH '\n         kw.289  = ' WLM '\n         kw.290  = ' XMLEXISTS '\n         kw.291  = ' XMLNAMESPACES '\n         kw.292  = ' XMLCAST '\n         kw.293  = ' YEAR '\n         kw.294  = ' YEARS '\n         kw.295  = ' ZONE '\n         atr.1   = 'DDD'\n         atr.2   = 'DDDDD'\n         atr.3   = 'DDD'\n         atr.4   = 'DDDDDDDD'\n         atr.5   = 'DDDDD'\n         atr.6   = 'DDDDDDDD'\n         atr.7   = 'DDD'\n         atr.8   = 'DD'\n         atr.9   = 'DDDDDD'\n         atr.10  = 'DDDDDDDDDDDDD'\n         atr.11  = 'DDDDDDDDDD'\n         atr.12  = 'DDDDDDDDD'\n         atr.13  = 'DDDDDDD'\n         atr.14  = 'DD'\n         atr.15  = 'DDDDD'\n         atr.16  = 'DDD'\n         atr.17  = 'DDDDDDDDD'\n         atr.18  = 'DDDDDD'\n         atr.19  = 'DDDDD'\n         atr.20  = 'DDDDDDD'\n         atr.21  = 'DDDDDDDDDD'\n         atr.22  = 'DD'\n         atr.23  = 'DDDD'\n         atr.24  = 'DDDDDDD'\n         atr.25  = 'DDDDDDDD'\n         atr.26  = 'DDDDD'\n         atr.27  = 'DDDD'\n         atr.28  = 'DDDDDDDD'\n         atr.29  = 'DDDDD'\n         atr.30  = 'DDDDDDDDD'\n         atr.31  = 'DDDDD'\n         atr.32  = 'DDDDD'\n         atr.33  = 'DDDDDDD'\n         atr.34  = 'DDDDDDDDDDDDDD'\n         atr.35  = 'DDDDDDDDDD'\n         atr.36  = 'DDDDDDDDD'\n         atr.37  = 'DDDDDDD'\n         atr.38  = 'DDDDDDD'\n         atr.39  = 'DDDDDD'\n         atr.40  = 'DDDDDD'\n         atr.41  = 'DDDDDDDDD'\n         atr.42  = 'DDDDDDD'\n         atr.43  = 'DDDDDDDDDD'\n         atr.44  = 'DDDDDDDDDD'\n         atr.45  = 'DDDDDDDD'\n         atr.46  = 'DDDDDDDDDD'\n         atr.47  = 'DDDDDDDD'\n         atr.48  = 'DDDDDD'\n         atr.49  = 'DDDD'\n         atr.50  = 'DDDDDDD'\n         atr.51  = 'DDDDDDDDDDDD'\n         atr.52  = 'DDDDDDDDDDDDDDDD'\n         atr.53  = 'DDDDDDDDDDDD'\n         atr.54  = 'DDDDDDDDDDDDDD'\n         atr.55  = 'DDDDDDDDDDDD'\n         atr.56  = 'DDDDDDDDDDDDDDDDD'\n         atr.57  = 'DDDDDDD'\n         atr.58  = 'DDDDDD'\n         atr.59  = 'DDDD'\n         atr.60  = 'DDDDDDDD'\n         atr.61  = 'DDD'\n         atr.62  = 'DDDD'\n         atr.63  = 'DDDDDD'\n         atr.64  = 'DDDDDDD'\n         atr.65  = 'DDDDDDD'\n         atr.66  = 'DDDDDD'\n         atr.67  = 'DDDDDDDDDD'\n         atr.68  = 'DDDDDDDDDDDDD'\n         atr.69  = 'DDDDDDD'\n         atr.70  = 'DDDDDDDD'\n         atr.71  = 'DDDDDDDD'\n         atr.72  = 'DD'\n         atr.73  = 'DDDDDDDD'\n         atr.74  = 'DDDDDD'\n         atr.75  = 'DDDD'\n         atr.76  = 'DDDDDD'\n         atr.77  = 'DDDDDDD'\n         atr.78  = 'DDDDDDDD'\n         atr.79  = 'DDDD'\n         atr.80  = 'DDDDDD'\n         atr.81  = 'DDDDDDDD'\n         atr.82  = 'DDDDDDDDDD'\n         atr.83  = 'DDD'\n         atr.84  = 'DDDDDD'\n         atr.85  = 'DDDDDDDDD'\n         atr.86  = 'DDDDD'\n         atr.87  = 'DDDDDD'\n         atr.88  = 'DDDDDD'\n         atr.89  = 'DDDDDDDDD'\n         atr.90  = 'DDDDDDD'\n         atr.91  = 'DDDDDD'\n         atr.92  = 'DDDD'\n         atr.93  = 'DDDDDDD'\n         atr.94  = 'DDDDDDDD'\n         atr.95  = 'DDDDDD'\n         atr.96  = 'DDDDD'\n         atr.97  = 'DDDDDDDDD'\n         atr.98  = 'DDDDD'\n         atr.99  = 'DDDDD'\n         atr.100 = 'DDD'\n         atr.101 = 'DDDD'\n         atr.102 = 'DDDD'\n         atr.103 = 'DDDD'\n         atr.104 = 'DDDDDDDD'\n         atr.105 = 'DDDDDDDDD'\n         atr.106 = 'DDD'\n         atr.107 = 'DDDDDD'\n         atr.108 = 'DD'\n         atr.109 = 'DDDD'\n         atr.110 = 'DDDDD'\n         atr.111 = 'DDDDD'\n         atr.112 = 'DDDDDDD'\n         atr.113 = 'DDDDDD'\n         atr.114 = 'DDDD'\n         atr.115 = 'DDDD'\n         atr.116 = 'DDDDD'\n         atr.117 = 'DD'\n         atr.118 = 'DDDDDDDDD'\n         atr.119 = 'DD'\n         atr.120 = 'DDDDDDDDD'\n         atr.121 = 'DDDDD'\n         atr.122 = 'DDDDDDD'\n         atr.123 = 'DDDDD'\n         atr.124 = 'DDDDD'\n         atr.125 = 'DDDDDDDDDDD'\n         atr.126 = 'DDDDDD'\n         atr.127 = 'DDDDDDDDD'\n         atr.128 = 'DDDD'\n         atr.129 = 'DD'\n         atr.130 = 'DDDDDD'\n         atr.131 = 'DDDDDDD'\n         atr.132 = 'DDD'\n         atr.133 = 'DDDD'\n         atr.134 = 'DDDD'\n         atr.135 = 'DDD'\n         atr.136 = 'DDDDD'\n         atr.137 = 'DDDDDDDD'\n         atr.138 = 'DDDD'\n         atr.139 = 'DDDDDDDD'\n         atr.140 = 'DDDDD'\n         atr.141 = 'DDDD'\n         atr.142 = 'DDDD'\n         atr.143 = 'DDDDD'\n         atr.144 = 'DDDDDD'\n         atr.145 = 'DDDDDDD'\n         atr.146 = 'DDDDDDDD'\n         atr.147 = 'DDDD'\n         atr.148 = 'DDDDDDD'\n         atr.149 = 'DDDDDDDD'\n         atr.150 = 'DDDD'\n         atr.151 = 'DDDD'\n         atr.152 = 'DDDDDDDDDD'\n         atr.153 = 'DDDDDDDDDDDD'\n         atr.154 = 'DDDDDDDDDDD'\n         atr.155 = 'DDDDDDDDDDDD'\n         atr.156 = 'DDDDDDDDDDDDD'\n         atr.157 = 'DDDDDDDD'\n         atr.158 = 'DDDDD'\n         atr.159 = 'DDDDDD'\n         atr.160 = 'DDDD'\n         atr.161 = 'DDDDDDD'\n         atr.162 = 'DD'\n         atr.163 = 'DDDD'\n         atr.164 = 'DDD'\n         atr.165 = 'DDDD'\n         atr.166 = 'DDDDD'\n         atr.167 = 'DDDDDDDD'\n         atr.168 = 'DDDD'\n         atr.169 = 'DD'\n         atr.170 = 'DDD'\n         atr.171 = 'DD'\n         atr.172 = 'DDDD'\n         atr.173 = 'DDDDDDDDDDDD'\n         atr.174 = 'DDDDDDDD'\n         atr.175 = 'DD'\n         atr.176 = 'DDDDD'\n         atr.177 = 'DDDDDDDDDDDD'\n         atr.178 = 'DDD'\n         atr.179 = 'DDDDD'\n         atr.180 = 'DDDDDDD'\n         atr.181 = 'DDDDDDDDD'\n         atr.182 = 'DDDD'\n         atr.183 = 'DDDDDD'\n         atr.184 = 'DDDDDDDDD'\n         atr.185 = 'DDDDDDDDDDD'\n         atr.186 = 'DDDDDDDDDDDD'\n         atr.187 = 'DDDD'\n         atr.188 = 'DDDDDDDDD'\n         atr.189 = 'DDDDDD'\n         atr.190 = 'DDDD'\n         atr.191 = 'DDDDDDDDD'\n         atr.192 = 'DDDDDDD'\n         atr.193 = 'DDDDDDD'\n         atr.194 = 'DDDDD'\n         atr.195 = 'DDDDDD'\n         atr.196 = 'DDDDDDDDDD'\n         atr.197 = 'DDDDDDDDD'\n         atr.198 = 'DDDDDDD'\n         atr.199 = 'DDDD'\n         atr.200 = 'DDDDDD'\n         atr.201 = 'DDDDD'\n         atr.202 = 'DDDDDDD'\n         atr.203 = 'DDDDD'\n         atr.204 = 'DDDDDDDDDD'\n         atr.205 = 'DDDDDDD'\n         atr.206 = 'DDDDDDDD'\n         atr.207 = 'DDDDDDD'\n         atr.208 = 'DDDDDD'\n         atr.209 = 'DDDDDD'\n         atr.210 = 'DDDDDDDD'\n         atr.211 = 'DDDDDD'\n         atr.212 = 'DDDDDDDDDDDDDDDDDD'\n         atr.213 = 'DDDDDD'\n         atr.214 = 'DDDDDDD'\n         atr.215 = 'DDDDDD'\n         atr.216 = 'DDDDD'\n         atr.217 = 'DDDD'\n         atr.218 = 'DDDDDDDD'\n         atr.219 = 'DDDDDDD'\n         atr.220 = 'DDDDDDDDDDDDD'\n         atr.221 = 'DDDDDDDDDD'\n         atr.222 = 'DDDDDDDDDDD'\n         atr.223 = 'DDDDDDDDDDDDDDD'\n         atr.224 = 'DDDDDDDDDDDDDDD'\n         atr.225 = 'DDDDDDDDDDDDD'\n         atr.226 = 'DDDDDDDD'\n         atr.227 = 'DDD'\n         atr.228 = 'DDDDDD'\n         atr.229 = 'DDD'\n         atr.230 = 'DDDDDDDDD'\n         atr.231 = 'DDDDDD'\n         atr.232 = 'DDDDDDDDDD'\n         atr.233 = 'DDDDDD'\n         atr.234 = 'DDDDDDD'\n         atr.235 = 'DDDDDD'\n         atr.236 = 'DDDDDDDD'\n         atr.237 = 'DDDDDDDD'\n         atr.238 = 'DDDDDD'\n         atr.239 = 'DDDDDDDDD'\n         atr.240 = 'DDDDDDDDDDDD'\n         atr.241 = 'DDD'\n         atr.242 = 'DDDDDD'\n         atr.243 = 'DDDDDD'\n         atr.244 = 'DDDD'\n         atr.245 = 'DDDDDD'\n         atr.246 = 'DDDDDDDD'\n         atr.247 = 'DDDDDDDD'\n         atr.248 = 'DDDDDD'\n         atr.249 = 'DDDDDDDDD'\n         atr.250 = 'DDDD'\n         atr.251 = 'DDDDDDDD'\n         atr.252 = 'DDDDDD'\n         atr.253 = 'DDDDD'\n         atr.254 = 'DDDDDDD'\n         atr.255 = 'DDDDDDD'\n         atr.256 = 'DDDDDDD'\n         atr.257 = 'DDDDDD'\n         atr.258 = 'DDDDDDDDDDDD'\n         atr.259 = 'DDDDD'\n         atr.260 = 'DDDDDDDDDD'\n         atr.261 = 'DDDD'\n         atr.262 = 'DD'\n         atr.263 = 'DDDDDDDD DDDDDDDDD'\n         atr.264 = 'DDDDDDD'\n         atr.265 = 'DDDDDDDD'\n         atr.266 = 'DDDD'\n         atr.267 = 'DDDD'\n         atr.268 = 'DDDDD'\n         atr.269 = 'DDDDDD'\n         atr.270 = 'DDDDD'\n         atr.271 = 'DDDDDD'\n         atr.272 = 'DDDD'\n         atr.273 = 'DDDDD'\n         atr.274 = 'DDDDDDDDD'\n         atr.275 = 'DDDDD'\n         atr.276 = 'DDDDDD'\n         atr.277 = 'DDDDDDDD'\n         atr.278 = 'DDDDDDD'\n         atr.279 = 'DDDD'\n         atr.280 = 'DDDDDDDDDDD'\n         atr.281 = 'DDDD'\n         atr.282 = 'DDDDDDDD'\n         atr.283 = 'DDDDDDD'\n         atr.284 = 'DDDD'\n         atr.285 = 'DDDDDDDD'\n         atr.286 = 'DDDDD'\n         atr.287 = 'DDDDD'\n         atr.288 = 'DDDD'\n         atr.289 = 'DDD'\n         atr.290 = 'DDDDDDDDD'\n         atr.291 = 'DDDDDDDDDDDDD'\n         atr.292 = 'DDDDDDD'\n         atr.293 = 'DDDD'\n         atr.294 = 'DDDDD'\n         atr.295 = 'DDDD'\n         clr.1   = 'RRR'\n         clr.2   = 'RRRRR'\n         clr.3   = 'RRR'\n         clr.4   = 'RRRRRRRR'\n         clr.5   = 'RRRRR'\n         clr.6   = 'RRRRRRRR'\n         clr.7   = 'RRR'\n         clr.8   = 'RR'\n         clr.9   = 'RRRRRR'\n         clr.10  = 'RRRRRRRRRRRRR'\n         clr.11  = 'RRRRRRRRRR'\n         clr.12  = 'RRRRRRRRR'\n         clr.13  = 'RRRRRRR'\n         clr.14  = 'RR'\n         clr.15  = 'RRRRR'\n         clr.16  = 'RRR'\n         clr.17  = 'RRRRRRRRR'\n         clr.18  = 'RRRRRR'\n         clr.19  = 'RRRRR'\n         clr.20  = 'RRRRRRR'\n         clr.21  = 'RRRRRRRRRR'\n         clr.22  = 'RR'\n         clr.23  = 'RRRR'\n         clr.24  = 'RRRRRRR'\n         clr.25  = 'RRRRRRRR'\n         clr.26  = 'RRRRR'\n         clr.27  = 'RRRR'\n         clr.28  = 'RRRRRRRR'\n         clr.29  = 'RRRRR'\n         clr.30  = 'RRRRRRRRR'\n         clr.31  = 'RRRRR'\n         clr.32  = 'RRRRR'\n         clr.33  = 'RRRRRRR'\n         clr.34  = 'RRRRRRRRRRRRRR'\n         clr.35  = 'RRRRRRRRRR'\n         clr.36  = 'RRRRRRRRR'\n         clr.37  = 'RRRRRRR'\n         clr.38  = 'RRRRRRR'\n         clr.39  = 'RRRRRR'\n         clr.40  = 'RRRRRR'\n         clr.41  = 'RRRRRRRRR'\n         clr.42  = 'RRRRRRR'\n         clr.43  = 'RRRRRRRRRR'\n         clr.44  = 'RRRRRRRRRR'\n         clr.45  = 'RRRRRRRR'\n         clr.46  = 'RRRRRRRRRR'\n         clr.47  = 'RRRRRRRR'\n         clr.48  = 'RRRRRR'\n         clr.49  = 'RRRR'\n         clr.50  = 'RRRRRRR'\n         clr.51  = 'RRRRRRRRRRRR'\n         clr.52  = 'RRRRRRRRRRRRRRRR'\n         clr.53  = 'RRRRRRRRRRRR'\n         clr.54  = 'RRRRRRRRRRRRRR'\n         clr.55  = 'RRRRRRRRRRRR'\n         clr.56  = 'RRRRRRRRRRRRRRRRR'\n         clr.57  = 'RRRRRRR'\n         clr.58  = 'RRRRRR'\n         clr.59  = 'RRRR'\n         clr.60  = 'RRRRRRRR'\n         clr.61  = 'RRR'\n         clr.62  = 'RRRR'\n         clr.63  = 'RRRRRR'\n         clr.64  = 'RRRRRRR'\n         clr.65  = 'RRRRRRR'\n         clr.66  = 'RRRRRR'\n         clr.67  = 'RRRRRRRRRR'\n         clr.68  = 'RRRRRRRRRRRRR'\n         clr.69  = 'RRRRRRR'\n         clr.70  = 'RRRRRRRR'\n         clr.71  = 'RRRRRRRR'\n         clr.72  = 'RR'\n         clr.73  = 'RRRRRRRR'\n         clr.74  = 'RRRRRR'\n         clr.75  = 'RRRR'\n         clr.76  = 'RRRRRR'\n         clr.77  = 'RRRRRRR'\n         clr.78  = 'RRRRRRRR'\n         clr.79  = 'RRRR'\n         clr.80  = 'RRRRRR'\n         clr.81  = 'RRRRRRRR'\n         clr.82  = 'RRRRRRRRRR'\n         clr.83  = 'RRR'\n         clr.84  = 'RRRRRR'\n         clr.85  = 'RRRRRRRRR'\n         clr.86  = 'RRRRR'\n         clr.87  = 'RRRRRR'\n         clr.88  = 'RRRRRR'\n         clr.89  = 'RRRRRRRRR'\n         clr.90  = 'RRRRRRR'\n         clr.91  = 'RRRRRR'\n         clr.92  = 'RRRR'\n         clr.93  = 'RRRRRRR'\n         clr.94  = 'RRRRRRRR'\n         clr.95  = 'RRRRRR'\n         clr.96  = 'RRRRR'\n         clr.97  = 'RRRRRRRRR'\n         clr.98  = 'RRRRR'\n         clr.99  = 'RRRRR'\n         clr.100 = 'RRR'\n         clr.101 = 'RRRR'\n         clr.102 = 'RRRR'\n         clr.103 = 'RRRR'\n         clr.104 = 'RRRRRRRR'\n         clr.105 = 'RRRRRRRRR'\n         clr.106 = 'RRR'\n         clr.107 = 'RRRRRR'\n         clr.108 = 'RR'\n         clr.109 = 'RRRR'\n         clr.110 = 'RRRRR'\n         clr.111 = 'RRRRR'\n         clr.112 = 'RRRRRRR'\n         clr.113 = 'RRRRRR'\n         clr.114 = 'RRRR'\n         clr.115 = 'RRRR'\n         clr.116 = 'RRRRR'\n         clr.117 = 'RR'\n         clr.118 = 'RRRRRRRRR'\n         clr.119 = 'RR'\n         clr.120 = 'RRRRRRRRR'\n         clr.121 = 'RRRRR'\n         clr.122 = 'RRRRRRR'\n         clr.123 = 'RRRRR'\n         clr.124 = 'RRRRR'\n         clr.125 = 'RRRRRRRRRRR'\n         clr.126 = 'RRRRRR'\n         clr.127 = 'RRRRRRRRR'\n         clr.128 = 'RRRR'\n         clr.129 = 'RR'\n         clr.130 = 'RRRRRR'\n         clr.131 = 'RRRRRRR'\n         clr.132 = 'RRR'\n         clr.133 = 'RRRR'\n         clr.134 = 'RRRR'\n         clr.135 = 'RRR'\n         clr.136 = 'RRRRR'\n         clr.137 = 'RRRRRRRR'\n         clr.138 = 'RRRR'\n         clr.139 = 'RRRRRRRR'\n         clr.140 = 'RRRRR'\n         clr.141 = 'RRRR'\n         clr.142 = 'RRRR'\n         clr.143 = 'RRRRR'\n         clr.144 = 'RRRRRR'\n         clr.145 = 'RRRRRRR'\n         clr.146 = 'RRRRRRRR'\n         clr.147 = 'RRRR'\n         clr.148 = 'RRRRRRR'\n         clr.149 = 'RRRRRRRR'\n         clr.150 = 'RRRR'\n         clr.151 = 'RRRR'\n         clr.152 = 'RRRRRRRRRR'\n         clr.153 = 'RRRRRRRRRRRR'\n         clr.154 = 'RRRRRRRRRRR'\n         clr.155 = 'RRRRRRRRRRRR'\n         clr.156 = 'RRRRRRRRRRRRR'\n         clr.157 = 'RRRRRRRR'\n         clr.158 = 'RRRRR'\n         clr.159 = 'RRRRRR'\n         clr.160 = 'RRRR'\n         clr.161 = 'RRRRRRR'\n         clr.162 = 'RR'\n         clr.163 = 'RRRR'\n         clr.164 = 'RRR'\n         clr.165 = 'RRRR'\n         clr.166 = 'RRRRR'\n         clr.167 = 'RRRRRRRR'\n         clr.168 = 'RRRR'\n         clr.169 = 'RR'\n         clr.170 = 'RRR'\n         clr.171 = 'RR'\n         clr.172 = 'RRRR'\n         clr.173 = 'RRRRRRRRRRRR'\n         clr.174 = 'RRRRRRRR'\n         clr.175 = 'RR'\n         clr.176 = 'RRRRR'\n         clr.177 = 'RRRRRRRRRRRR'\n         clr.178 = 'RRR'\n         clr.179 = 'RRRRR'\n         clr.180 = 'RRRRRRR'\n         clr.181 = 'RRRRRRRRR'\n         clr.182 = 'RRRR'\n         clr.183 = 'RRRRRR'\n         clr.184 = 'RRRRRRRRR'\n         clr.185 = 'RRRRRRRRRRR'\n         clr.186 = 'RRRRRRRRRRRR'\n         clr.187 = 'RRRR'\n         clr.188 = 'RRRRRRRRR'\n         clr.189 = 'RRRRRR'\n         clr.190 = 'RRRR'\n         clr.191 = 'RRRRRRRRR'\n         clr.192 = 'RRRRRRR'\n         clr.193 = 'RRRRRRR'\n         clr.194 = 'RRRRR'\n         clr.195 = 'RRRRRR'\n         clr.196 = 'RRRRRRRRRR'\n         clr.197 = 'RRRRRRRRR'\n         clr.198 = 'RRRRRRR'\n         clr.199 = 'RRRR'\n         clr.200 = 'RRRRRR'\n         clr.201 = 'RRRRR'\n         clr.202 = 'RRRRRRR'\n         clr.203 = 'RRRRR'\n         clr.204 = 'RRRRRRRRRR'\n         clr.205 = 'RRRRRRR'\n         clr.206 = 'RRRRRRRR'\n         clr.207 = 'RRRRRRR'\n         clr.208 = 'RRRRRR'\n         clr.209 = 'RRRRRR'\n         clr.210 = 'RRRRRRRR'\n         clr.211 = 'RRRRRR'\n         clr.212 = 'RRRRRRRRRRRRRRRRRR'\n         clr.213 = 'RRRRRR'\n         clr.214 = 'RRRRRRR'\n         clr.215 = 'RRRRRR'\n         clr.216 = 'RRRRR'\n         clr.217 = 'RRRR'\n         clr.218 = 'RRRRRRRR'\n         clr.219 = 'RRRRRRR'\n         clr.220 = 'RRRRRRRRRRRRR'\n         clr.221 = 'RRRRRRRRRR'\n         clr.222 = 'RRRRRRRRRRR'\n         clr.223 = 'RRRRRRRRRRRRRRR'\n         clr.224 = 'RRRRRRRRRRRRRRR'\n         clr.225 = 'RRRRRRRRRRRRR'\n         clr.226 = 'RRRRRRRR'\n         clr.227 = 'RRR'\n         clr.228 = 'RRRRRR'\n         clr.229 = 'RRR'\n         clr.230 = 'RRRRRRRRR'\n         clr.231 = 'RRRRRR'\n         clr.232 = 'RRRRRRRRRR'\n         clr.233 = 'RRRRRR'\n         clr.234 = 'RRRRRRR'\n         clr.235 = 'RRRRRR'\n         clr.236 = 'RRRRRRRR'\n         clr.237 = 'RRRRRRRR'\n         clr.238 = 'RRRRRR'\n         clr.239 = 'RRRRRRRRR'\n         clr.240 = 'RRRRRRRRRRRR'\n         clr.241 = 'RRR'\n         clr.242 = 'RRRRRR'\n         clr.243 = 'RRRRRR'\n         clr.244 = 'RRRR'\n         clr.245 = 'RRRRRR'\n         clr.246 = 'RRRRRRRR'\n         clr.247 = 'RRRRRRRR'\n         clr.248 = 'RRRRRR'\n         clr.249 = 'RRRRRRRRR'\n         clr.250 = 'RRRR'\n         clr.251 = 'RRRRRRRR'\n         clr.252 = 'RRRRRR'\n         clr.253 = 'RRRRR'\n         clr.254 = 'RRRRRRR'\n         clr.255 = 'RRRRRRR'\n         clr.256 = 'RRRRRRR'\n         clr.257 = 'RRRRRR'\n         clr.258 = 'RRRRRRRRRRRR'\n         clr.259 = 'RRRRR'\n         clr.260 = 'RRRRRRRRRR'\n         clr.261 = 'RRRR'\n         clr.262 = 'RR'\n         atr.263 = 'RRRRRRRR RRRRRRRRR'\n         clr.264 = 'RRRRRRR'\n         clr.265 = 'RRRRRRRR'\n         clr.266 = 'RRRR'\n         clr.267 = 'RRRR'\n         clr.268 = 'RRRRR'\n         clr.269 = 'RRRRRR'\n         clr.270 = 'RRRRR'\n         clr.271 = 'RRRRRR'\n         clr.272 = 'RRRR'\n         clr.273 = 'RRRRR'\n         clr.274 = 'RRRRRRRRR'\n         clr.275 = 'RRRRR'\n         clr.276 = 'RRRRRR'\n         clr.277 = 'RRRRRRRR'\n         clr.278 = 'RRRRRRR'\n         clr.279 = 'RRRR'\n         clr.280 = 'RRRRRRRRRRR'\n         clr.281 = 'RRRR'\n         clr.282 = 'RRRRRRRR'\n         clr.283 = 'RRRRRRR'\n         clr.284 = 'RRRR'\n         clr.285 = 'RRRRRRRR'\n         clr.286 = 'RRRRR'\n         clr.287 = 'RRRRR'\n         clr.288 = 'RRRR'\n         clr.289 = 'RRR'\n         clr.290 = 'RRRRRRRRR'\n         clr.291 = 'RRRRRRRRRRRRR'\n         clr.292 = 'RRRRRRR'\n         clr.293 = 'RRRR'\n         clr.294 = 'RRRRR'\n         clr.295 = 'RRRR'\n      end\n/*********************************************************************/\n/* The user entered an invalid language name for highlighting, so    */\n/* set usrhilng to OFF to bypass highlighting.                       */\n/*********************************************************************/\n   otherwise\n      nop\nend\nif usrhilng <> '' & usrhilng <> 'OFF' then\n   do\n/*********************************************************************/\n/* The first thing we have to do is highlight comments so that none  */\n/* of the text bounded by the comments will be chosen for further    */\n/* highlighting.  Each language is handled individually.  ZDATA will */\n/* be broken down into individual lines that will be reviewed for    */\n/* comments.                                                         */\n/*********************************************************************/\n      select\n/*********************************************************************/\n/* For Fortran, HILITE OTHER will leave a lot of highlighting errors */\n/* due to lack of comment highlighting.  Any lines with 'c', 'C',    */\n/* 'd', 'D', '*', or ! in column 1, or ! in any column not part of   */\n/* quoted string, will be highlighted as a comment until the end of  */\n/* the line.                                                         */\n/*********************************************************************/\n         when (usrhilng = 'FORTRAN') then\n            do\n               #lines = length(zdata) / zwidth\n               do i = 0 to #lines - 1\n                  strtpos = (i * zwidth) + 1\n                  endpos  = ((i + 1) * zwidth) + 1\n                  totchar = i * zwidth\n                  parse var zdata =(strtpos) linedata =(endpos)\n                  parse var zshadow =(strtpos) shaddata =(endpos)\n                  parse var linedata 2 comchar 3 .\n                  if (comchar = 'c' |,\n                      comchar = 'C' |,\n                      comchar = 'd' |,\n                      comchar = 'D' |,\n                      comchar = '*' |,\n                      comchar = '!') then\n                     compos = 2\n                  else\n                     compos = pos('!',linedata)\n                  if compos > 0 then\n                     do\n                        compend = compos + 1\n                        parse var shaddata =(compos) comshad =(compend)\n                        if comshad <> 'Q' & comshad <> 'C' then\n                           zshadow = overlay(,\n                                     copies('C',zwidth - compos),,\n                                     zshadow,,\n                                     totchar+compos,zwidth - compos)\n                     end\n               end\n            end\n/*********************************************************************/\n/* For Java or Go, HILITE OTHER handles all slash asterisk style     */\n/* comments, so we have to add code to handle the // type comment.   */\n/* We will do that by breaking down zdata into individual lines and  */\n/* looking for any // characters that are either not already in a    */\n/* comment or a quoted string.  Anything else will highlight as a    */\n/* comment to the end of the line.                                   */\n/*********************************************************************/\n         when (usrhilng = 'JAVA' | usrhilng = 'GO') then\n            do\n               #lines = length(zdata) / zwidth\n               do i = 0 to #lines - 1\n                  strtpos = (i * zwidth) + 1\n                  endpos  = ((i + 1) * zwidth) + 1\n                  totchar = i * zwidth\n                  parse var zdata =(strtpos) linedata =(endpos)\n                  parse var zshadow =(strtpos) shaddata =(endpos)\n                  compos = pos('//',linedata)\n                  if compos > 0 then\n                     do\n                        compend = compos + 2\n                        parse var shaddata =(compos) comshad =(compend)\n                        if comshad <> 'QQ' & comshad <> 'CC' then\n                           zshadow = overlay(,\n                                     copies('C',zwidth - compos),,\n                                     zshadow,,\n                                     totchar+compos,zwidth - compos)\n                     end\n               end\n            end\n/*********************************************************************/\n/* For Python, Ruby, and SHELL, HILITE OTHER will leave a lot of     */\n/* highlighting errors due to lack of comment highlighting.  Any     */\n/* lines with '#' in any column not part of a quoted string, will be */\n/* highlighted as a comment until the end of the line.               */\n/*********************************************************************/\n         when (usrhilng = 'PYTHON' |,\n               usrhilng = 'RUBY'   |,\n               usrhilng = 'SHELL') then\n            do\n               #lines = length(zdata) / zwidth\n               do i = 0 to #lines - 1\n                  strtpos = (i * zwidth) + 1\n                  endpos  = ((i + 1) * zwidth) + 1\n                  totchar = i * zwidth\n                  parse var zdata =(strtpos) linedata =(endpos)\n                  parse var zshadow =(strtpos) shaddata =(endpos)\n                  compos = pos('#',linedata)\n                  if compos > 0 then\n                     do\n                        compend = compos + 1\n                        parse var shaddata =(compos) comshad =(compend)\n                        if comshad <> 'Q' & comshad <> 'C' then\n                           zshadow = overlay(,\n                                     copies('C',zwidth - compos),,\n                                     zshadow,,\n                                     totchar+compos,zwidth - compos)\n                     end\n               end\n            end\n/*********************************************************************/\n/* For SQL, HILITE OTHER will handle all the slash asterisk style    */\n/* comments, so we have to add code to handle the -- type comment.   */\n/* We will do that by breaking down zdata into individual lines and  */\n/* looking for any -- characters that are either not already in a    */\n/* comment or a quoted string.  Anything else will highlight as a    */\n/* comment to the end of the line.                                   */\n/*********************************************************************/\n         when (usrhilng = 'SQL') then\n            do\n               #lines = length(zdata) / zwidth\n               do i = 0 to #lines - 1\n                  strtpos = (i * zwidth) + 1\n                  endpos  = ((i + 1) * zwidth) + 1\n                  totchar = i * zwidth\n                  parse var zdata =(strtpos) linedata =(endpos)\n                  parse var zshadow =(strtpos) shaddata =(endpos)\n                  compos = pos('--',linedata)\n                  if compos > 0 then\n                     do\n                        compend = compos + 2\n                        parse var shaddata =(compos) comshad =(compend)\n                        if comshad <> 'QQ' & comshad <> 'CC' then\n                           zshadow = overlay(,\n                                     copies('C',zwidth - compos),,\n                                     zshadow,,\n                                     totchar+compos,zwidth - compos)\n                     end\n               end\n            end\n/*********************************************************************/\n/* For FLOWASM, HILITE ASM will handle normal assembler comments, so */\n/* so we have to add code to handle '*' or '/*' in any column,       */\n/* provided they are the first character(s) on the line (no closing  */\n/* '*/' is required).                                                */\n/*********************************************************************/\n         when (usrhilng = 'FLOWASM') then\n            do\n               #lines = length(zdata) / zwidth\n               do i = 0 to #lines - 1\n                  strtpos = (i * zwidth) + 1\n                  endpos  = ((i + 1) * zwidth) + 1\n                  totchar = i * zwidth\n                  parse var zdata =(strtpos) linedata =(endpos)\n                  parse var zshadow =(strtpos) shaddata =(endpos)\n/*********************************************************************/\n/* Eat the attribute, line number, and attrbute at the beginning of  */\n/* the line, then comment will hold a comment if it exists.  Verify  */\n/* the comment, then set the strings appropriately for the position  */\n/* checks in the code resetting the shadow variable for comments.    */\n/*********************************************************************/\n                  parse var linedata 2 linenum 8 . 9 comment .\n/*********************************************************************/\n/* Since the top and bottom lines start with '*', detect if the line */\n/* number is '******' and bypass it.                                 */\n/*********************************************************************/\n                  if linenum = '******' then\n                     iterate i\n                  parse var comment 1 asterisk 2 . 1 slashast 3 .\n                  if asterisk = '*' then\n                     do\n                        comstring = '*'\n                        shadquote = 'Q'\n                        shadcomnt = 'C'\n                     end\n                  if slashast = '/*' then\n                     do\n                        comstring = '/*'\n                        shadquote = 'QQ'\n                        shadcomnt = 'CC'\n                     end\n                  if asterisk = '*' | slashast = '/*' then\n                     do\n                        compos = pos(comstring,linedata)\n                        compend = compos + length(comstring)\n                        parse var shaddata =(compos) comshad =(compend)\n                        if comshad <> shadquote &,\n                           comshad <> shadcomnt then\n                           zshadow = overlay(,\n                                     copies('C',zwidth - compos),,\n                                     zshadow,,\n                                     totchar+compos,zwidth - compos)\n                     end\n               end\n            end\n         otherwise\n            nop\n      end\n/*********************************************************************/\n/* For Ruby, we also have to process block comments started by       */\n/* =BEGIN in column 1 and ended with =END in column 1.               */\n/*********************************************************************/\n      if usrhilng = 'RUBY' then\n         call rubycomment\n      if usrhilng = 'FLOWASM' then\n         call flowasmhighlight\n/*********************************************************************/\n/* Copy zdata to tempdata, then manipulate tempdata to facilitate    */\n/* language highlighting.  Translate all attribute bytes specified   */\n/* in ISREDDE2 to blanks, and translate all braces, brackets, and    */\n/* parens, and special characters to blanks.  Finally, uppercase     */\n/* tempdata to test against blank-delimited, uppercased keywords.    */\n/* This makes it simpler to match the keywords, since some           */\n/* programmers prefer to capitalize only the first letter of every   */\n/* keyword.                                                          */\n/*********************************************************************/\n      tempdata = zdata\n/*********************************************************************/\n/* The double commas are necessary to make the translate command     */\n/* work properly.  The first comma is the comma for the function,    */\n/* the second comma will continue the line.                          */\n/*********************************************************************/\n      tempdata = translate(tempdata,,\n               '                          ',,\n               '152A2B2F141B1C260102030405060708090A0B0C0D1316171D20'x)\n      tempdata = translate(tempdata,'                     ',,\n                                    '{}\u00dd\u00a8()#+-*/=<>&\u00ac|:%, ')\n      parse upper var tempdata tempdata\n/*********************************************************************/\n/* Loop through each keyword for the language selected.  Start in    */\n/* column 2, and search until offset is 0, meaning the keyword was   */\n/* not found.                                                        */\n/*********************************************************************/\n      do i = 1 to kw.0\n         strt = 2\n         offset = 1\n         /* Do until no more instances of this keyword are found */\n         do while (offset > 0)\n            offset = pos(kw.i,tempdata,strt)\n            if offset > 0 then\n               do\n/*********************************************************************/\n/* Change the highlighting only if ISPF has set the default          */\n/* highlighting (attribute character 'D').  The clr. array holds the */\n/* attribute byte for highlighting (default is 'R' for red, but      */\n/* keywords can be highlighted in other colors by changing the color */\n/* character in the clr array).                                      */\n/*********************************************************************/\n                if substr(zshadow,offset+1,length(atr.i)) = atr.i then\n                zshadow = overlay(clr.i,zshadow,offset+1,length(clr.i))\n/*********************************************************************/\n/* Increment strt to begin the next search after the current found   */\n/* keyword.                                                          */\n/*********************************************************************/\n                  strt = offset + length(kw.i)\n               end\n         end\n      end\n   end\n/*********************************************************************/\n/* This code will highlight braces and brackets.  The algorithms on  */\n/* the Web recommended a stack data structure to push and pop        */\n/* open/close pairs for parens, braces, and brackets.  Intialize the */\n/* \"stacks\" obracpos for braces, and obrakpos for brackets, and the  */\n/* variables representing the stack levels obrac#, and obrak#.       */\n/*********************************************************************/\nobracpos. = 0\nobrakpos. = 0\nobrac#    = 0\nobrak#    = 0\n/*********************************************************************/\n/* Set hbcolor to the colors for each level of highlighting, white,  */\n/* red, turquoise, pink, and yellow.                                 */\n/*********************************************************************/\nhbcolor   = 'WRTPY'\n/*********************************************************************/\n/* If the user selected brace or bracket highlighting, or both, read */\n/* zdata and zshadow a character at a time to find braces and/or     */\n/* brackets in zdata, and their current attribute byte highlighting  */\n/* in zshadow.                                                       */\n/*********************************************************************/\nif usrhibrc = 'YES' | usrhibrk = 'YES' then\n   do i = 1 to length(zdata)\n      parse var zdata =(i) char +1 .\n      parse var zshadow =(i) shad +1 .\n/*********************************************************************/\n/* If the user selected brace highlighting, process any braces not   */\n/* in quotes (indicated by attribute byte of 'Q' in zshadow).        */\n/*********************************************************************/\n      if usrhibrc = 'YES' then\n         select\n            when (char = '{' & shad <> 'Q' & shad <> 'C') then\n               do\n/*********************************************************************/\n/* For the open brace, increment obrac# and save the position of the */\n/* open brace for highlighting later (\"PUSH\" the open brace onto the */\n/* stack).                                                           */\n/*********************************************************************/\n                  obrac#          = obrac# + 1\n                  obracpos.obrac# = i\n               end\n/*********************************************************************/\n/* For the close brace, check to see if the open brace stack has any */\n/* elements.  If obrac# is 0, then change the attribute byte to 'Z'  */\n/* in zshadow (reverse pink, indicating a mismatched close brace).   */\n/*********************************************************************/\n            when (char = '}' & shad <> 'Q' & shad <> 'C') then\n               if obrac# = 0 then\n                  zshadow = overlay('Z',zshadow,i,1)\n               else\n                  do\n/*********************************************************************/\n/* If there is an element on the open brace stack, then determine    */\n/* color by dividing obrac# by 5 and using the remainder as an index */\n/* into the hbcolor string.  Overlay the zshadow attribute byte for  */\n/* the close brace with that color, and then overlay the zshadow     */\n/* attribute byte for the open brace using the saved postion.        */\n/*********************************************************************/\n                     bclrpos = obrac# // 5\n                     if bclrpos = 0 then\n                        bclrpos = 5\n                     battr   = substr(hbcolor,bclrpos,1)\n                     zshadow = overlay(battr,zshadow,i,1)\n                     zshadow = overlay(battr,zshadow,obracpos.obrac#,1)\n/*********************************************************************/\n/* Decrementing obrac# is the equivalent of a \"POP\" operation on the */\n/* open brace stack.                                                 */\n/*********************************************************************/\n                     obrac#  = obrac# - 1\n                  end\n            otherwise\n               nop\n         end\n/*********************************************************************/\n/* If the user selected bracket highlighting, process any brackets   */\n/* not in quotes (indicated by attribute byte of 'Q' in zshadow), or */\n/* comments (indicated by attribute byte of 'C' in zshadow).         */\n/*********************************************************************/\n      if usrhibrk = 'YES' then\n         select\n/*********************************************************************/\n/* For the open bracket, increment obrak# and save the position of   */\n/* the open bracket for highlighting later (\"PUSH\" the open bracket  */\n/* onto the stack).                                                  */\n/*********************************************************************/\n            when (char = '\u00dd' & shad <> 'Q' & shad <> 'C') then\n               do\n                  obrak#          = obrak# + 1\n                  obrakpos.obrak# = i\n               end\n/*********************************************************************/\n/* For the close bracket, check to see if the open bracket stack has */\n/* any elements.  If obrak# is 0, then change the attribute byte to  */\n/* 'Z' in zshadow (reverse pink, indicating a mismatched close       */\n/* bracket).                                                         */\n/*********************************************************************/\n            when (char = '\u00a8' & shad <> 'Q' & shad <> 'C') then\n               if obrak# = 0 then\n                  zshadow = overlay('Z',zshadow,i,1)\n               else\n                  do\n/*********************************************************************/\n/* If there is an element on the open bracket stack, then determine  */\n/* color by dividing obrak# by 5 and using the remainder as an index */\n/* into the hbcolor string.  Overlay the zshadow attribute byte for  */\n/* the close bracket with that color, and then overlay the zshadow   */\n/* attribute byte for the open bracket using the saved postion.      */\n/*********************************************************************/\n                     bclrpos = obrak# // 5\n                     if bclrpos = 0 then\n                        bclrpos = 5\n                     battr   = substr(hbcolor,bclrpos,1)\n                     zshadow = overlay(battr,zshadow,i,1)\n                     zshadow = overlay(battr,zshadow,obrakpos.obrak#,1)\n/*********************************************************************/\n/* Decrementing obrak# is the equivalent of a \"POP\" operation on the */\n/* open bracket stack.                                               */\n/*********************************************************************/\n                     obrak#  = obrak# - 1\n                  end\n            otherwise\n               nop\n         end\n   end\n/*********************************************************************/\n/* If there are any remaining entries on open brace stack, highlight */\n/* those characters with attribute byte 'Z' (reverse pink).          */\n/*********************************************************************/\nif usrhibrc = 'YES' then\n   do i = 1 to obrac#\n      zshadow = overlay('Z',zshadow,obracpos.i,1)\n   end\n/*********************************************************************/\n/* If there are any remaining entries on open bracket stack,         */\n/* highlight those characters with attribute byte 'Z' (reverse       */\n/* pink).                                                            */\n/*********************************************************************/\nif usrhibrk = 'YES' then\n   do i = 1 to obrak#\n      zshadow = overlay('Z',zshadow,obrakpos.i,1)\n   end\ncall isprexpx('T')\nexit\nrubycomment:\n#lines = length(zdata) / zwidth\nbcomment = 0\ndo i = 0 to #lines - 1\n   strtpos = (i * zwidth) + 1\n   endpos  = ((i + 1) * zwidth) + 1\n   totchar = i * zwidth\n   parse var zdata =(strtpos) linedata =(endpos)\n   parse var zshadow =(strtpos) shaddata =(endpos)\n   parse upper var linedata 9 rubybeg 15 . 9 rubyend 13 .\n   if rubybeg = '=BEGIN' then\n      bcomment = 1\n   if rubyend = '=END' then\n      bcomment = 0\n   if bcomment | rubyend = '=END' then\n      zshadow = overlay(copies('C',zwidth-9),zshadow,totchar+9,zwidth-9)\nend\nreturn\n/*********************************************************************/\n/* For FLOWASM, we need to detect continuation characters for        */\n/* statements ending in commas.  FLOWASM does not require a          */\n/* continuation character in column 72, and does not require the     */\n/* continued line to start in column 16.                             */\n/*                                                                   */\n/* HILITE ASM parses code lines into Keyword <blank> Operand <blank> */\n/* Comment.  Keyword is highlighted with K, Operand with D, and      */\n/* Comment with C.  We need to detect a trailing comma on Operand,   */\n/* then change the K highlighting for the Keyword on the next line   */\n/* to D, and the D highlighting on the next line to C.               */\n/*********************************************************************/\nflowasmhighlight:\n#lines = length(zdata) / zwidth\ncontcurrline = 0\nzshadlen = length(zshadow)\ndo i = 0 to #lines - 1\n   if \\contcurrline then\n      contprevline = 0\n   else\n      contprevline = 1\n   strtpos = (i * zwidth) + 1\n   endpos  = ((i + 1) * zwidth) + 1\n   parse var zdata =(strtpos) linedata =(endpos)\n   parse var zshadow =(strtpos) shaddata =(endpos)\n   kw = ''\n   cc = ''\n   if \\contprevline then\n      parse upper var linedata 9 kw opr comment 80 cc 81 .\n   else\n      parse upper var linedata 9 opr comment\n   oprlen = length(opr)\n   parse var opr =(oprlen) comma .\n   if comma = ',' & (cc = ' ' | cc = '00'x) then\n      contcurrline = 1\n   else\n      contcurrline = 0\n   if contprevline then\n      do\n         shaddata = translate(shaddata,'DC','KD')\n         endlen  = length(zshadow) - endpos\n         if endpos \\= zshadlen then\n            zshadow = substr(zshadow,1,strtpos-1) || shaddata ||,\n                      substr(zshadow,endpos,endlen+1)\n         else\n            zshadow = substr(zshadow,1,strtpos-1) || shaddata\n/*********************************************************************/\n/* Now that the line is put together and the continuation handled,   */\n/* we have to go back over the line and highlight the arithmetic     */\n/* characters, parens, etc.                                          */\n/*********************************************************************/\n         searchchar = '=,+-*/<>&\u00ac|:%'\n         sline = linedata\n         spos  = 1\n         slen  = length(linedata)\n         changeline = 0\n         do j = 1 to length(searchchar)\n            schar = substr(searchchar,j,1)\n            sline = substr(sline,spos,slen-spos+1)\n            charfound = 0\n            do until (\\charfound)\n               scharpos = pos(schar,sline)\n               if scharpos <> 0 then\n                  do\n                     shaddata = substr(shaddata,1,scharpos-1) || ' ' ||,\n                       substr(shaddata,scharpos+1,slen-scharpos)\n                     changeline = 1\n                  end\n               else\n                  charfound = 0\n            end\n            if changeline then\n               zshadow = substr(zshadow,1,strtpos-1) || shaddata ||,\n                         substr(zshadow,endpos,endlen+1)\n         end\n/*********************************************************************/\n/* After handling special characters, we now have to handle parens.  */\n/* If PAREN highlighting is enabled, we have to highlight the parens */\n/* where previously they were highlighted in red as a keyword.       */\n/*********************************************************************/\n         oparenpos. = 0\n         oparen#   = 0\n/*********************************************************************/\n/* Set hbcolor to the colors for each level of highlighting, white,  */\n/* red, turquoise, pink, and yellow.                                 */\n/*********************************************************************/\n         hbcolor   = 'WRTPY'\n/*********************************************************************/\n/* If the user selected paren highlighting, proceed.                 */\n/*********************************************************************/\n         do k = 1 to slen\n            parse var linedata =(k) char +1 .\n            parse var shaddata =(k) shad +1 .\n/*********************************************************************/\n/* If the user selected brace highlighting, process any braces not   */\n/* in quotes (indicated by attribute byte of 'Q' in zshadow).        */\n/*********************************************************************/\n            select\n               when (char = '(' & pos(shad,'QCWRTPY') = 0) then\n                  do\n/*********************************************************************/\n/* For the open brace, increment obrac# and save the position of the */\n/* open brace for highlighting later (\"PUSH\" the open brace onto the */\n/* stack).                                                           */\n/*********************************************************************/\n                     oparen#         = oparen# + 1\n                     oparenpos.oparen# = k\n                  end\n/*********************************************************************/\n/* For the close paren, check to see if the open paren stack has any */\n/* elements.  If obrac# is 0, then change the attribute byte to 'Z'  */\n/* in zshadow (reverse pink, indicating a mismatched close paren).   */\n/*********************************************************************/\n               when (char = ')' & pos(shad,'QCWRTPY') = 0) then\n                  if oparen# = 0 then\n                     shaddata = overlay('Z',shaddata,k,1)\n                  else\n                     do\n/*********************************************************************/\n/* If there is an element on the open paren stack, then determine    */\n/* color by dividing obrac# by 5 and using the remainder as an index */\n/* into the hbcolor string.  Overlay the zshadow attribute byte for  */\n/* the close paren with that color, and then overlay the zshadow     */\n/* attribute byte for the open paren using the saved postion.        */\n/*********************************************************************/\n                        bclrpos = oparen# // 5\n                        if bclrpos = 0 then\n                           bclrpos = 5\n                        battr   = substr(hbcolor,bclrpos,1)\n                        shaddata = overlay(battr,shaddata,k,1)\n                        shaddata =,\n                         overlay(battr,shaddata,oparenpos.oparen#,1)\n/*********************************************************************/\n/* Decrementing oparen# is the equivalent of a \"POP\" operation on    */\n/* the open paren stack.                                             */\n/*********************************************************************/\n                           oparen# = oparen# - 1\n                        end\n                  otherwise\n                     nop\n               end\n            end\n/*********************************************************************/\n/* If there are any remaining entries on open paren stack, highlight */\n/* those characters with attribute byte 'Z' (reverse pink).          */\n/*********************************************************************/\n         do l = 1 to oparen#\n            shaddata = overlay('Z',shaddata,oparenpos.l,1)\n         end\n         zshadow = substr(zshadow,1,strtpos-1) || shaddata ||,\n                   substr(zshadow,endpos,endlen+1)\n      end\nend\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USRL00": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "TCONLEY"}, "text": "USRL001  'Invalid language        ' .TYPE=W NOKANA\n'Please specify a valid language:  CARLA, FLOWASM, FORTRAN, GO, ' +\n'JAVA, JSON, PYTHON, RUBY, SHELL, or SQL'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USRPCONF": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00I\\x00/\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 73, "newlines": 47, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMOD": {"ttr": 8204, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x009\\x00:\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 57, "newlines": 58, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMODQ": {"ttr": 8206, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00'\\x00'\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMODX": {"ttr": 8208, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\xbc\\x00\\x84\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 188, "newlines": 132, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMOD1": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\xbe\\x00\\x87\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 190, "newlines": 135, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMOD2": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\xac\\x00\\xb7\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 172, "newlines": 183, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMOD3": {"ttr": 8460, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x99\\x00W\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 153, "newlines": 87, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRPMOD4": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x86\\x00\\\\\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 134, "newlines": 92, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRUMNO2": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00)\\x002\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 41, "newlines": 50, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USRUULO2": {"ttr": 8713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00,\\x00(\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 44, "newlines": 40, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USR0Y002": {"ttr": 8715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x15\\x00\\x15\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USR0Y004": {"ttr": 8717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USR0Y007": {"ttr": 8719, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01 \\x19O\\x01 \\x19O\\x11\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xc3\\xd6\\xd5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2020-07-12T00:00:00", "modifydate": "2020-07-12T11:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TCONLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT967/FILE967.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT967", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}