{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011904000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1704794, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE382.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1704794, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1704794, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE382.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x1c\\x05'", "DS1TRBAL": "b'\\xb1\\xb4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xbf\\x00\\x0c\\x02\\xc1\\x00\\n\\x00\\x1d'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x00\\x16\\x01\\x11\\x08o\\x01\\x11\\x08o T\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-03-27T00:00:00", "modifydate": "2011-03-27T20:54:16", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-482"}, "text": "REGULAR CBT TAPE - VERSION 482    FILE:  382\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT482.FILE382\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 29 MEMBERS COUNTED; CUMULATIVE SIZE IS 15,868 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/27/11    20:54:16    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99(\\x1f\\x01\\x00$?\\x187\\x00F\\x00F\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-10-08T00:00:00", "modifydate": "2000-08-30T18:37:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "WSBG"}, "text": "Subject:\n        CBT Contribution\n   Date:\n        Sat, 10 Jul 1999 00:02:24 +1000\n   From:\n        \"Paul Gillis\" <pgillis@warrandyte.starway.net.au>\n        \"@RTS PG\" <Paul.Gillis@colesmyer.com.au>\n     To:\n        \"Sam Golob\" <sbgolob@attglobal.net>\n\nSam,\n\nAttached is a file containing a few of the utilities that I\ndeveloped and have used at many sites over the last twenty plus\nyears. The contents of the file are:-\n\n1.) UNLOAD.ASM and UNLOAD.JCL. The unload assembler program\n    provides the ability to convert a PDS into a flat file and\n    to insert a control card of your own making in between each\n    unloaded member, with the member name inserted at any\n    position in the record.\n\n2). DASD.SMP. This SMP/E usermod provides a DASD LSPACE\n    program, that dumps all the data returned by the LSPACE\n    macro into a file for further analysis.\n\n3). DASDSPCE.SMP. This SMP/E usermod provides a DASD space\n    command that will display the available space on a selected\n    subset of the dasd farm.\n\n4). DEBUG.MAC. This assembler macro I use to produce debug\n    information from most programs that I write. The debug\n    information is written to any number of possible output\n    data sources.\n\n5). GRS.SMP. This SMP/E usermod provides a WHOHAS type\n    utility, and is normally used for that purpose.\n\n6). SYSTEM.SMP. This SMP/E usermod contains a system IPL\n    details program, which includes system symbols.\n\n7). DISASM. Members DISASJCL, DISASMAC and DISASSRC\n    contain an updated version of the disassembler\n    found on file 171. The update supports all of the\n    two byte 01 and B2 instructions. Support was not\n    added for the A4, A5, A6, E4 and E5 opcodes, but could\n    now be added reasonably easily.\n    Instruction set based on SA22-7209-01 ESA/390 Reference\n    Summary.\n\n -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\nI have a number of other pieces of code that I will add\nto this collection, being:-\n\n1). SAS utilities to manage the SMPPTS and the global\n    GZONE entry.\n\n2). SAS utility to convert the output from the DASD\n    program into a SAS database.\n\n3). An assembler ISPF environment that keeps tabs on your\n    most managed datasets. Better than 3.4, not as good\n    as Ezedit. Currently converting this to use the CSI.\n\nPaul Gillis\nDirector P.C. Link Pty. Ltd. &\nPacific Systems Management Pty. Ltd.\nMelbourne, Australia\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x10\\x00\\x1f\\x01\\x10\\x00\\x1f\\x10\\x11\\x00(\\x00(\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-01-01T00:00:00", "modifydate": "2010-01-01T10:11:16", "lines": 40, "newlines": 40, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:   RE: How do you use the DEBUG Macro?\nFrom:      \"Paul Gillis\" <pgillis@pc-link.com.au>\nDate:      Fri, 1 Jan 2010 13:23:18 +1100\nTo:        \"'Sam Golob'\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nMy apologies as there was something missing from the file so here\nis a replacement. It has DEBUGDOC and SHELL as additional members,\nwhere DEBUGDOC is just that and SHELL is my starter shell for any\nassembler code I might want to write from scratch and it has\nsamples of how I use the DEBUG macro.\n\nIn SHELL, the initial invocation of DEBUG sets all the global\nvariables, allocates and then opens SYSDEBUG etc. The second prints\n28 characters of storage from SHELL+5. The third prints the value\nin variable SYSTEMNM for 8 characters. The fourth closes and\ndeallocates the SYSDEBUG DD. The fifth allocates the debug\nconstants, and the sixth allocates the debug variables separately\nfor re-entrant programs.\n\nSo for copymods, you must have an invocation debug a termination\ndebug (if using SYSDEBUG) and two allocation debugs as a minimum.\nThen any number of data debugs. What I normally do if I am unsure\nof who is changing a variable is to put a debug after every change\nto the variable and one where I expect it to be used. Use a\ndifferent ID value to identify where in the code this debug came\nfrom\n\n          DEBUG ID=STEP1,(STRIPFLG,1,X),(XXX,8,C),(YYY,4,B)\n          DEBUG ID=STEP2,(STRIPFLG,1,X)\n          DEBUG ID=STEP3,(STRIPFLG,1,X)\n\nThis code just puts displays in the code at set points, but\nsimplifies the process of doing so with most of the work done in\na separate CSECT.\n\nCheers, Paul\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x11\\x08o\\x01\\x11\\x08o I\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-03-27T00:00:00", "modifydate": "2011-03-27T20:49:46", "lines": 31, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT V481 FILE382 DISASM S0C4\nFrom:     \"Sharpe, Ken\" <Ken.Sharpe@okdhs.org>\nDate:     Fri, 25 Mar 2011 19:42:01 +0000\nTo:       <sbgolob@cbttape.org>\n\nThis email is concerning DISASM utility in FILE382 on version 481\nof the CBT Tape.\n\nAn S0C4 can occur if you have x'01' or x'B2' instructions. This\nis because DISASMB2 updates the OPCMNT field but the OPCMNT field\nwas not created for these two instructions. The results are that\nthe OPCODES in DISASMOP CSECT that follow the x'01' or x'B2' are\noverlaid.\n\nDISASMOP needs updating, the following lines need updating:\n\nOPCODE 01,DC,$OPB2,2,' '\nOPCODE B2,DC,$OPB2,4,' '\n\nAdd a comment field on both the 01 and B2 Operation Codes.\n\nI have attached a copy of the source changes I have made to my\nversion in accordance with the above issue.\n\nKen Sharpe\nInformation Systems Operating System Specialist IV\nOklahoma Department of Human Services,\nInfrastructure and Platform SW Services\nPhone: 405-522-1304\nCell: 405-208-3661\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE3": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x11\\x08o\\x01\\x11\\x08o S\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-03-27T00:00:00", "modifydate": "2011-03-27T20:53:13", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RE: CBT V481 FILE382 DISASM S0C4\nFrom:     \"Sharpe, Ken\" <Ken.Sharpe@okdhs.org>\nDate:     Sat, 26 Mar 2011 00:28:49 +0000\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nOh, I figured out why in the original testing of the DISASM\nprogram the problem did not show up. The comment field is only\nfilled in for B1 and 01 instructions that are not in the INSTAB01\nor INSTABB2 tables in DISASMB2. Since new op codes have come out\nsince the current version of DISASMB2 was written the exposure to\nthe S0C4 problem is greater until DISASMB2 gets updated with the\nnew codes. The below update is need so that new codes not cause\nan S0C4.\n\nKen Sharpe\nInformation Systems Operating System Specialist IV\nOklahoma Department of Human Services,\nInfrastructure and Platform SW Services\nPhone: 405-522-1304\nCell: 405-208-3661\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$TXT": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99(\\x0f\\x01\\x00$?\\x187\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-10-07T00:00:00", "modifydate": "2000-08-30T18:37:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "WSBG"}, "text": "Subject: Updated File 382 for the CBT\nDate: Fri, 8 Oct 1999 07:59:49 +1000\nFrom: Paul Gillis <Paul.Gillis@colesmyer.com.au>\nTo: \"'Sam Golob'\" <sbgolob@attglobal.net>\nCC: \"'@PG'\" <pgillis@warrandyte.starway.net.au>\n\nSam,\n\nI have slightly modified my contribution to the CBT, by including\nan update to the disassembler from file 171.  It now handles the\n01 two byte opcode instructions, and all the B2 two byte opcode\ninstructions. I have not updated it to cater for the more\nesoteric A4, A5, A6, E4 and E5 instructions, but they should now\nbe quite easy to add.\n\n <<CBT File 382 Binary.zip>>\n\nRegards\nPaul Gillis\n\nRTS-IS  Software Services\nColes Myer Ltd.\n*               +61 3 9483-7233   fax  +61 3 9483-7381\n*       Paul.Gillis@colesmyer.com.au\n\n    ---------------------------------------------------------------------\n                              Name: CBT File 382 Binary.zip\n   CBT File 382 Binary.zip    Type: Zip Compressed Data\n                                    (application/x-zip-compressed)\n                          Encoding: base64\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE382": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x00\\t\\x01\\x11\\x08o\\x01\\x11\\x08o T\\x00H\\x00H\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-03-27T00:00:00", "modifydate": "2011-03-27T20:54:09", "lines": 72, "newlines": 72, "modlines": 0, "user": "CBT-482"}, "text": "//***FILE 382 is from Paul Gillis of Melbourne, Australia, and      *   FILE 382\n//*           contains a number of programs and utilities that      *   FILE 382\n//*           he has developed.                                     *   FILE 382\n//*                                                                 *   FILE 382\n//*           Paul Gillis                                           *   FILE 382\n//*           Director P.C. Link Pty. Ltd. &                        *   FILE 382\n//*           Pacific Systems Management Pty. Ltd.                  *   FILE 382\n//*           Melbourne, Australia                                  *   FILE 382\n//*                                                                 *   FILE 382\n//*   email:  \"Paul Gillis\" <pgillis@pc-link.com.au>                *   FILE 382\n//*                                                                 *   FILE 382\n//*         UNLOAD and UNLOAD$. The unload assembler program        *   FILE 382\n//*         provides the ability to convert a PDS into a flat       *   FILE 382\n//*         file and to insert a control card of your own           *   FILE 382\n//*         making in between each unloaded member, with the        *   FILE 382\n//*         member name inserted at any position in the record.     *   FILE 382\n//*                                                                 *   FILE 382\n//*         DASD. This SMP/E usermod provides a DASD LSPACE         *   FILE 382\n//*         program, that dumps all the data returned by the        *   FILE 382\n//*         LSPACE macro into a file for further analysis.          *   FILE 382\n//*                                                                 *   FILE 382\n//*         DASDSPCE. This SMP/E usermod provides a DASD space      *   FILE 382\n//*         command that will display the available space on a      *   FILE 382\n//*         selected subset of the dasd farm.                       *   FILE 382\n//*                                                                 *   FILE 382\n//*         DEBUG. This assembler macro I use to produce debug      *   FILE 382\n//*         information from most programs that I write. The        *   FILE 382\n//*         debug information is written to any number of           *   FILE 382\n//*         possible output data sources.                           *   FILE 382\n//*                                                                 *   FILE 382\n//*         GRS. This SMP/E usermod provides a WHOHAS type          *   FILE 382\n//*         utility, and is normally used for that purpose.         *   FILE 382\n//*                                                                 *   FILE 382\n//*         SYSTEM. This SMP/E usermod contains a system IPL        *   FILE 382\n//*         details program, which includes system symbols.         *   FILE 382\n//*                                                                 *   FILE 382\n//*         DISASM. Members DISASJCL, DISASMAC and DISASSRC         *   FILE 382\n//*         contain an updated version of the disassembler          *   FILE 382\n//*         found on file 171. The update supports all of the       *   FILE 382\n//*         two byte 01 and B2 instructions. Support was not        *   FILE 382\n//*         added for the A4, A5, A6, E4 and E5 opcodes, but        *   FILE 382\n//*         could now be added reasonably easily.  Instruction      *   FILE 382\n//*         set based on SA22-7209-01 ESA/390 Reference Summary.    *   FILE 382\n//*                                                                 *   FILE 382\n//* 2009 additions                                                  *   FILE 382\n//*                                                                 *   FILE 382\n//*         DEBUGDOC documentation file for the DEBUG macor.        *   FILE 382\n//*                                                                 *   FILE 382\n//*         SHELL a very basic assembler program that I use as a    *   FILE 382\n//*         model for any new code. This also contains samples of   *   FILE 382\n//*         how the debug macro is coded.                           *   FILE 382\n//*                                                                 *   FILE 382\n//*         ISPFSTAT An assembler copy book that maps the ISPF stats*   FILE 382\n//*         of a PDS directory, used by LISTDIR.                    *   FILE 382\n//*                                                                 *   FILE 382\n//*         LISTDIR  An assembler module to extract the contents of *   FILE 382\n//*         a PDS directory. Used in IPL volume comparisons         *   FILE 382\n//*                                                                 *   FILE 382\n//*         LISTVTOC An assembler module to extract the contents of *   FILE 382\n//*         a VTOC. Used in IPL volume comparisons                  *   FILE 382\n//*                                                                 *   FILE 382\n//*         IPLBLD00 JCL include meber to set both IPL Volsers      *   FILE 382\n//*                                                                 *   FILE 382\n//*         IPLBLD90 JCL deck to generate IPL vol PDS compare jobs  *   FILE 382\n//*         and compares the VTOCs while at it.                     *   FILE 382\n//*                                                                 *   FILE 382\n//*         IPLBLD91 JCL deck generated by IPLBLD90 that actually   *   FILE 382\n//*         compares all PDS directories on the 2 IPL volumes.      *   FILE 382\n//*                                                                 *   FILE 382\n//*         IPLCOMPR JCL proc to compare PDS directories            *   FILE 382\n//*                                                                 *   FILE 382\n//*         IPLVOLXP Rexx exec to build IPL vol PDS directories     *   FILE 382\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASD": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x19\\x0f\\x00\\x99\\x19\\x0f\\x13\\x02\\x01e\\x01e\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-09T00:00:00", "modifydate": "1999-07-09T13:02:00", "lines": 357, "newlines": 357, "modlines": 0, "user": "PGILLIS"}, "text": "++ USERMOD(L#FM093) REWORK(1997258)\n/*\n*\n*     Elements:    DASD\n*\n*     Purpose:     Support the DASD space command\n*\n*     Reference:   None\n*\n*     Environment: Zone:  MVS01T   Product:  Inhouse Code\n*\n*     WARNING:     None\n*\n*     Writer:      Paul Gillis\n*\n*     Date:        29/09/97\n*\n*     Change       Date      Inits  Description\n*     History:     ========  =====  ===========\n*\n*                  29/09/97  PGG    Code redesigned for 4 digit UCB\n*\n*/ .\n++VER(Z038) FMID(LBASE01).\n++JCLIN.\n//LINK1  EXEC   PGM=HEWL,PARM='LIST,XREF,MAP'\n//SYSPRINT  DD SYSOUT=A\n//AUSERMOD  DD DSN=SYS1.AUSERMOD,DISP=SHR\n//SYSLMOD   DD DSN=MVS01T.LINKLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN    DD *\n INCLUDE AUSERMOD(DASD)\n NAME DASD(R)\n++SRC(DASD) DISTLIB(AUSERSRC) DISTMOD(AUSERMOD).\nDASD     CSECT\nDASD     AMODE 24\nDASD     RMODE 24\n                                       SPACE 1\n***********************************************************************\n*                                                                     *\n* FUNCTION : THE PROGRAM DASD, ISSUES THE LSPACE SVC FOR EVERY DASD   *\n*            DEVICE IN THE SYSTEM AND OUTPUTS THE RESULT TO A FILE    *\n*            THE DATA OUTPUT TO THE FILE INCLUDES THE FORMAT 4 DSCB   *\n*                                                                     *\n* INPUTS   : NONE                                                     *\n*                                                                     *\n* OUTPUTS  : DDNAME=DASDDATA, NO DCB PARAMETERS REQUIRED, ONE RECORD  *\n*            FOR EVERY ONLINE DASD DEVICE. RECORD LAYOUT DESCRIBED AT *\n*            MSGLINE TO MSGLENG2.                                     *\n*                                                                     *\n* ATTRIBUTES : NONE                                                   *\n*                                                                     *\n* AUTHOR   : P.GILLIS, APRIL 1991                                     *\n*                                                                     *\n* CHANGES  : P.GILLIS, SEPTEMBER 1997 - SUPPORT 4 DIGIT UCBS          *\n*                                                                     *\n***********************************************************************\n                                       SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n                                       SPACE 1\n***********************************************************************\n*        INITIALISATION - PROGRAM                                     *\n***********************************************************************\n                                       SPACE 1\n         SAVE  (14,12),,'DASD &SYSDATE &SYSTIME'\n         LR    R12,R15                 LOAD BASE REGISTER\n         USING DASD,R12\n         USING CVTMAP,R11\n         USING UCBCMSEG,R10\n         LA    R3,SAVEAREA             LOAD ADDR OF MY REG SAVE AREA\n         ST    R13,4(R3)               STORE ADDR OF CLG SAVE IN MINE\n         ST    R3,8(R13)               STORE ADDR OF MY SAVE IN CLG PGM\n         LR    R13,R3                  POINT REG 13 AT MY SAVE AREA\n                                       SPACE 1\n***********************************************************************\n*        INITIALISATION - OPEN FILE , IF NOT PRESENT WE USE TPUTS     *\n***********************************************************************\n                                       SPACE 1\n         MVI   OPENFLAG,0              INDICATE THE DDNAME IS OPEN\n         OI    OPENWORD,X'80'          INDICATE ONLY ONE WORD IN LIST\n         OPEN  (DASDDATA,(OUTPUT)),MF=(E,OPENWORD)\n         TM    DASDDATA+DCBOFLGS-IHADCB,DCBOFOPN OPEN O.K.\n         BO    OPENOK                  ===> YES\n         MVI   OPENFLAG,1              INDICATE THE DDNAME IS NOT OPEN\nOPENOK   DS    0H\n         TIME  DEC\n         STM   R0,R1,TIMESTMP          SAVE THE TIME STAMP\n                                       SPACE 1\n***********************************************************************\n*        INITIALISATION - UCB SCAN ROUTINE                            *\n***********************************************************************\n                                       SPACE 1\n         L     R11,CVTPTR              A(CVT)\n         LA    R15,SCANWORK            A(IOSVSUCB WORK AREA)\n         LA    R0,DEVCLASS             A(DEVICE CLASS)\n         LA    R1,ADDRUCB              A(A(UCB))\n         STM   R15,R1,PARMWA           SAVE THE IOSVSUCB PARAMETERS\n         OI    PARMUCB,X'80'           INDICATE LAST ONE\n         MVI   DEVCLASS,UCB3DACC       ONLY DASD DEVICES\n                                       SPACE 1\n***********************************************************************\n*        LOOP THROUGH THE UCB CHAIN                                   *\n***********************************************************************\n                                       SPACE 1\n         BAL   R9,SCAN1                GET FIRST UCB ADDRESS\n         MVC   FIRSTUCB,UCBNAME        SAVE THE FIRST UCB NAME\n         LTR   R15,R15                 TEST THE RETURN CODE\n         BNZ   UCBLOOP2                ===> NO DASD UCBS\nUCBLOOP1 DS    0H\n         BAL   R9,UCBMSG               PROCESS A DASD UCB\n         BAL   R9,SCAN2                GET THE NEXT UCB ADDRESS\n         LTR   R15,R15                 TEST THE RETURN CODE\n         BNZ   UCBLOOP2                ===> NO MORE DASD UCBS\n         CLC   FIRSTUCB,UCBNAME        SAME AS THE FIRST UCB NAME\n         BNE   UCBLOOP1                ===> NO, PROCESS IT\nUCBLOOP2 DS    0H\n                                       SPACE 1\n***********************************************************************\n*        TERMINATE PROGRAM                                            *\n***********************************************************************\n                                       SPACE 1\n         CLOSE ,MF=(E,OPENWORD)\n         XR    R15,R15                 SET RC=0\n         L     R13,4(R13)              RESTORE CALLERS SAVE AREA\n         RETURN (14,12),,RC=(15)       RETURN TO CALLER\n                                       SPACE 1\n***********************************************************************\n*        SUBROUTINE - EXTRACT THE NEXT UCB ADDRESS                    *\n***********************************************************************\n                                       SPACE 1\nSCAN1    DS    0H\n         IOCINFO IOCTOKEN=TOKEN        GET CURRENT IOCTOKEN\n         XC    SCANWORK,SCANWORK       CLEAR THE WORK AREA\nSCAN2    DS    0H\n         UCBSCAN UCBAREA=UCBCOPY,WORKAREA=SCANWORK,DYNAMIC=YES,        *\n               RANGE=ALL,IOCTOKEN=TOKEN,DEVCLASS=DASD,DCEAREA=DCEAREA, *\n               DCELEN=48\n         LTR   R15,R15                 TEST THE RETURN CODE\n         LA    R10,UCBCOPY             A(UCB)\n         BR    R9                      ===> RETURN TO CALLER\n                                       SPACE 1\n***********************************************************************\n*        SUBROUTINE - PROCESS THE DASD UCB                            *\n***********************************************************************\n                                       SPACE 1\nUCBMSG   DS    0H\n         MVI   MSGLINE,C' '            CLEAR THE OUTPUT LINE\n         MVC   MSGLINE+1(MSGLENG1-1),MSGLINE\n*        MVC   MSGUCB,UCBNAME          SAVE THE UCB ADDRESS\n         UNPK  MSGUCB(5),UCBCHAN(3)    GET THE 4 DIGIT DEVICE ADDRESS\n         TR    MSGUCB(4),TRTABLE-240   CONVERT TO EBCDIC\n                                       SPACE 1\n         EDTINFO RTNUNIT,DEVTYPE=UCBTYP,OUTUNIT=MSGDEVT\n         CLI   UCBTYP+3,X'0E'          DEVICE EXTENSION PRESENT ?\n         BL    UCBMSG3                 * NO, USE RESULT OF EDTINFO\n         LA    R14,DCEAREA             R14 -> DEVICE CLASS EXTENSION\n         USING DCE,R14\n         LA    R15,TABLE2              R14 -> UNIT TABLE #2.\n                                       SPACE 1\nDEVLOOP  DS    0H\n         CLI   0(R15),X'FF'            END OF TABLE\n         BE    UCBMSG3                 ---> YES\n         CLC   DCEOBRDT,8(R15)         IS THIS THE DEVICE\n         BE    DEVINDEX                YES, INSERT INTO MESSAGE\n         LA    R15,TABLE2LN(R15)       INCREMENT TABLE\n         B     DEVLOOP                 LOOP THROUGH DEVICES\n                                       SPACE 1\nDEVINDEX DS    0H\n         MVC   MSGDEVT,0(R15)          COPY THE REAL DEVICE TYPE IN\nUCBMSG3  DS    0H\n                                       SPACE 1\n         TM    UCBVOLI,X'FF'           IS A VOLUME ON THIS ONE\n         BZ    UCBMSG99                ===> NO, SKIP IT\n         TM    UCBSTAT,UCBONLI         IS THE DEVICE ONLINE\n         BZ    UCBMSG99                ===> NO, SKIP IT\n         MVC   MSGVOL,UCBVOLI          SAVE THE VOLUME SERIAL\n         MVC   MSGSHR,=C'EXC'          EXCLUSIVE USE\n         TM    UCBTBYT2,UCBRR          IS IT SHARED\n         BZ    UCBMSG02                ===> NO, ITS EXCLUSIVE\n         MVC   MSGSHR,=C'SHR'          SHARED USE\nUCBMSG02 DS    0H\n                                       SPACE 1\n         MVC   MSGSTAT1,=C'STORAGE'    MAKE IT STORAGE\n         TM    UCBSTAB,UCBBSTR         IS IT STORAGE\n         BO    UCBMSG03                ===> YES\n         MVC   MSGSTAT1,=C'PUBLIC '    MAKE IT PUBLIC\n         TM    UCBSTAB,UCBBPUB         IS IT PUBLIC\n         BO    UCBMSG03                ===> YES\n         MVC   MSGSTAT1,=C'PRIVATE'    MAKE IT PRIVATE\n         TM    UCBSTAB,UCBBPRV         IS IT PRIVATE\n         BO    UCBMSG03                ===> YES\n         MVC   MSGSTAT1,=C'??????????' MAKE IT UNKNOWN\nUCBMSG03 DS    0H\n                                       SPACE 1\n         TM    UCBSTAT,UCBALOC         IS IT ALLOCATED\n         BZ    UCBMSG04                ===> NO\n         MVC   MSGSTAT2,=C'ALLOC '     MAKE IT ALLOCATED\nUCBMSG04 DS    0H\n         TM    UCBSTAT,UCBSYSR         IS IT SYSRES\n         BZ    UCBMSG05                ===> NO\n         MVC   MSGSTAT2,=C'SYSRES'     MAKE IT SYSRES\nUCBMSG05 DS    0H\n         TM    UCBFLA,UCBNRY           IS IT READY\n         BZ    UCBMSG06                ===> YES\n         MVC   MSGSTAT2,=C',READY'     MAKE IT ,READY\nUCBMSG06 DS    0H\n         TM    UCBSTAT,UCBPGFL         IS IT PAGING\n         BZ    UCBMSG07                ===> NO\n         MVC   MSGSTAT2,=C'PAGING'     MAKE IT PAGING\nUCBMSG07 DS    0H\n         CLI   UCBSQC,0                IS IT RESERVED\n         BE    UCBMSG08                ===> NO\n         MVC   MSGSTAT2,=C'RESRVD'     MAKE IT RESERVED\n         B     UCBMSG09                ===> DON'T ISSUE LSPACE SVC\nUCBMSG08 DS    0H\n                                       SPACE 1\n         LA    R6,LSPACF4D             A(F4DSCB RETURNED BY LSPACE)\n         USING IECSDSL4,R6\n         LA    R7,LSPACDAT             A(DATA RETURNED BY LSPACE)\n         USING LSPDRETN,R7\n         LA    R8,LSPACLST             A(LSPACE PARAMETER LIST)\n         USING LSPAPLID,R8\n         XC    LSPAPLID(LSPALEN),LSPAPLID ZERO THE CONTROL BLOCK\n         MVC   LSPAPLID,=C'LSPA'       CONTROL BLOCK ID\n         MVC   LSPANGTH,=AL2(LSPALEN)  CONTROL BLOCK LENGTH\n         LSPACE UCB=(R10),DATA=(R7),F4DSCB=(R6),MF=(E,(R8))\nUCBMSG09 DS    0H\n                                       SPACE 1\n         CLI   OPENFLAG,0              IS THE DDNAME OPEN\n         BNE   UCBMSG90                ===> NO, USE THE TPUT MACRO\n         PUT   DASDDATA,MSGLINE        OUTPUT A RECORD\n         B     UCBMSG99                ===> TERMINATE SUBROUTINE\n                                       SPACE 1\nUCBMSG90 DS    0H\n         LA    R0,MSGLENG1             L'MESSAGE\n         LA    R1,MSGLINE              A(MESSAGE)\n         TPUT  (1),(0),R               OUTPUT THE MESSAGE TO TSO USER\n                                       SPACE 1\nUCBMSG99 DS    0H\n         BR    R9                      ===> RETURN TO CALLER\n                                       SPACE 1\n***********************************************************************\n*        CONSTANTS AND LITERALS                                       *\n***********************************************************************\n                                       SPACE 1\nTRTABLE  DC    C'0123456789ABCDEF'     HEX/EBCDIC TRANSLATE TABLE\n         LTORG ,\n         DS    0D                      DOUBLE WORD ALIGNEMENT\n                                       SPACE 1\n***********************************************************************\n*        VARIABLES                                                    *\n***********************************************************************\n                                       SPACE 1\nSAVEAREA DS    18F                     STANDARD SAVE AREA\n                                       SPACE 1\nIEFEPARM DS    2A                      PARM LIST FOR IEFEB4UV\nIEFEFLAG DS    A                       FLAGS\nIEFEUNIT DS    2A                      UNIT TABLE\nIEFEUNI3 DS    A                       UNIT TABLE\nIEFEUNI4 DS    A                       UNIT TABLE\nIEFEUNI5 DS    A                       UNIT TABLE\nIEFEATTR DS    A                       ATTRIBUTE AREA\nIEFEATT2 DS    A                       ATTRIBUTE AREA\nIEFEATT3 DS    A                       ATTRIBUTE AREA\nIEFELENG EQU   *-IEFEPARM              LENGTH OF IEFEB4UV PARAMETERS\n                                       SPACE 1\nOPENWORD DS    A                       OPEN WORD FOR DCB\n                                       SPACE 1\nPARMWA   DS    A                       A(UCB SCAN WORK AREA)\nPARMDEVT DS    A                       A(DEVICE TYPE)\nPARMUCB  DS    A                       A(A(UCB))\nADDRUCB  DS    A                       A(UCB)\nSCANWORK DS    CL100                   UCB SCAN WORK AREA\nDEVCLASS DS    X                       DEVICE TYPE\n                                       SPACE 1\nOPENFLAG DS    X                       DCB OPEN INDICATOR\nFIRSTUCB DS    CL3                     FIRST UCB NAME\n                                       SPACE 1\nMSGLINE  DS    0F                      MSG LINE FOR TPUT ETC.\nMSGUCB   DS    CL4                     UNIT ADDRESS\nMSGDEVT  DS    CL8                     DEVICE TYPE\n         DS    C\nMSGVOL   DS    CL6                     VOLUME SERIAL\n         DS    C\nMSGSHR   DS    CL3                     SHARED OR EXCLUSIVE\n         DS    C\nMSGSTAT1 DS    CL7                     STORAGE, PUBLIC OR PRIVATE\n         DS    C\nMSGSTAT2 DS    CL6                     ALLOC SYSRES ,READY PAGING RSVD\nMSGLENG1 EQU   *-MSGLINE               MSG LINE LENGTH\n                                       SPACE 1\nLSPACDAT DS    XL36                    DATA RETURNED BY LSPACE\nLSPACF4D DS    XL96                    F4DSCB RETURNED BY LSPACE\nTIMESTMP DS    2F                      TIME STAMP\n                                       SPACE 1\nMSGLENG2 EQU   *-MSGLINE               LOGICAL RECORD LENGTH\nBLKSIZE  EQU   (23476/MSGLENG2)*MSGLENG2 BLOCK SIZE\n                                       SPACE 1\n         DS    0F                      ALIGNEMENT FOR PARAMETER LIST\nLSPACLST DS    CL(LSPALEN)             LSPACE PARAMETER LIST\n                                       SPACE 1\n         PRINT NOGEN\n         DS    0F\nDASDDATA DCB   DDNAME=DASDDATA,MACRF=PM,RECFM=FB,LRECL=MSGLENG2,       *\n               BLKSIZE=BLKSIZE,DSORG=PS\n                                       SPACE 1\nTOKEN    DC    CL48' '\nUCBCOPY  DC    CL48' '\nDCEAREA  DC    CL48' '\n                                       SPACE 1\nTABLE2   DC    CL8'3380-A',X'0E'\nTABLE2LN EQU   *-TABLE2\n         DC    CL8'3380-D',X'1E'\n         DC    CL8'3380-J',X'21'\n         DC    CL8'3380-K',X'23'\n         DC    CL8'3390-1',X'26'\n         DC    CL8'3390-2',X'27'\n         DC    CL8'3390-3',X'24'\n         DC    CL8'3380-E',X'2E'\n         DC    CL8'3390-9',X'32'\n         DC    X'FF'\n                                       SPACE 1\n         DS    0D                      DOUBLE WORD ALIGNEMENT\n                                       SPACE 1\n***********************************************************************\n*        DATA AREA MAPPING MACROS                                     *\n***********************************************************************\n                                       SPACE 1\n         PRINT GEN\n                                       SPACE 1\n         LSPACE MF=(D,DATA)\n                                       SPACE 1\n         IECSDSL1 (4)\n                                       SPACE 1\n         PRINT NOGEN\n         LSPACE MF=D\nUCBSPACE DSECT\n         IEFUCBOB\n         CVT   DSECT=YES,LIST=YES\n         DCBD  DEVD=DA,DSORG=PS\n         IECDDCE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DASDSPCE": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x19\\x0f\\x00\\x99\\x19\\x0f\\x13\\x02\\x03W\\x03W\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-09T00:00:00", "modifydate": "1999-07-09T13:02:00", "lines": 855, "newlines": 855, "modlines": 0, "user": "PGILLIS"}, "text": "++ USERMOD(L#FM104) REWORK(1998169)\n/*\n*\n*     Elements:    DASDSPCE and its 2 panels\n*\n*     Purpose:     Support the DASD space command\n*\n*     Reference:   None\n*\n*     Environment: Zone:  MVS01T   Product:  Inhouse Code\n*\n*     WARNING:     None\n*\n*     Writer:      Paul Gillis\n*\n*     Date:        29/09/97\n*\n*     Change       Date      Inits  Description\n*     History:     ========  =====  ===========\n*\n*                  29/09/97  PGG    Usermod redesigned for 4 digit UCB\n*                  17/06/98  PGG    Force LRECL of output file to 80\n*\n*/ .\n++VER(Z038) FMID(LBASE01) SUP(L#FM092).\n++JCLIN.\n//LINK1  EXEC   PGM=HEWL,PARM='LIST,XREF,MAP'\n//SYSPRINT  DD SYSOUT=A\n//AUSERMOD  DD DSN=SYS1.AUSERMOD,DISP=SHR\n//SYSLMOD   DD DSN=MVS01T.LINKLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN    DD *\n INCLUDE AUSERMOD(DASDSPCE)\n ALIAS DASDBTCH\n NAME DASDSPCE(R)\n++PNLENU(VSPACE0)  DISTLIB(AISRPLIB) SYSLIB(ISRPLIB).\n%------------ AVAILABLE SPACE ON THE ONLINE DASD UNITS -------------------------\n%COMMAND ===>_ZCMD\n%\n% NOTE:+POSSIBLE PARAMETERS FOR DASDPACE ARE:\n%\n+       VOLUME SERIAL%E.G. ZSC299\n+  PART VOLUME SERIAL%E.G. ZSC2\n+       nnn*         %E.G. 087*\n%\n+ENTER PARAMETERS%===>_PARM\n)INIT\n &ZCMD = ' '\n .CURSOR = PARM\n)PROC\n  &ZSEL = 'PGM(DASDSPCE) PARM(SPF &PARM)'\n)END\n++PNLENU(VSPACE00) DISTLIB(AISRPLIB) SYSLIB(ISRPLIB).\n)ATTR\n @ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%------------ AVAILABLE SPACE ON THE ONLINE DASD UNITS -------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT +\n%                   FREE     NUM    LARGEST\n%                   SPACE     OF     EXTENT   DEVICE     MOUNT    ALLOC   DEVICE\n%UCB VTOC VOLSER  CYLS/TRKS  EXTS  CYLS/TRKS  TYPE     ATTRIBUTE  STATUS  STATUS\n%\n)MODEL\n@Z\n)INIT\n   &VARS = '(REC1)'\n   &AMT = PAGE\n   &ZCMD = ' '\n)END\n++SRC(DASDSPCE) DISTLIB(AUSERSRC) DISTMOD(AUSERMOD).\n***********************************************************************\n*   TSO COMMAND DASDSPCE - DISPLAY DASD SPACE ***********  FCO1:MAS   *\n*                                         MODIFIED 28/2/79 FCO1:PGG   *\n*   MODIFIED TO INDICATE IF AN INDEXED VTOC EXISTS 21/8/81 FCO1:PGG   *\n*   MODIFIED TO INTERFACE WITH DIALOG MANAGEMENT   15/5/82 FCO1:PGG   *\n*   SAVAGELY MODIFIED TO RUN ON MVS/XA             25/3/84 FCO1:PGG   *\n*   AVOID 0C4 ABEND WHEN UNDER SPF AND > 36 VOLUMES14/11/84FCO1:MH    *\n*   SUPPORT 4 DIGIT UCB ADDRESSES : P.GILLIS : P. C. LINK PTY LTD     *\n*   SUPPORT BATCH INVOCATION      : P.GILLIS : P. C. LINK PTY LTD     *\n*                                                                     *\n* EDIT TABS:                                                          *\n*      10,16,40.                                                      *\n*                                                                     *\n* FUNCTION:                                                           *\n*      DISPLAY THE AVAILABLE SPACE ON A DASD, OR A GROUP OF DASD      *\n*      ALSO TO REPORT THE DEVICE TYPE IF NOT DASD.                    *\n*                                                                     *\n* SYNTAX:                                                             *\n*      DASDSPCE OPERAND(S)                                            *\n*                                                                     *\n* OPERANDS:                                                           *\n*      1). 'NULL'                              'DASDSPCE'             *\n*          THIS WILL GIVE YOU THE SYSRES VOLUME                       *\n*      2). VOLUME SERIAL (OR VOL PREFIX)  E.G. 'DASDSPCE DA501'       *\n*      3). UNIT ADDRESS                        'DASDSPCE 1F0'         *\n*      4). UNIT ADDRESS RANGE                  'DASDSPCE 1F*'         *\n*      5). GENERIC NAME                        'DASDSPCE SYSDA'       *\n*                                                                     *\n* ATTRIBUTES:                                                         *\n*      REENTERABLE, REUSEABLE, REFRESHABLE, AMODE(31) AND RMODE(ANY)  *\n*                                                                     *\n***********************************************************************\n                                       EJECT\nDASDSPCE CSECT\nDASDSPCE AMODE 31\nDASDSPCE RMODE ANY\n         USING GS,R13                  GOTTEN STORAGE BASE\n         USING DASDSPCE,R12            PROGRAM BASE\n         USING CVTMAP,R11              CVT BASE\n         USING UCBCMSEG,R10            UCB BASE\n         SAVE  (14,12),,'DASDSPCE &SYSDATE &SYSTIME'\n         LR    R12,R15\n                                       SPACE 1\n* ACQUIRE MAIN STORAGE FOR WORK AREAS.\n                                       SPACE 1\n         L     R2,0(R1)                FIND OPERAND LIST\n         L     R0,=A(GSLENGTH)         GET MAIN STORAGE\n         GETMAIN R,LV=(0)\n         ST    R13,4(R1)               BACK CHAIN\n         ST    R1,8(R13)               FORWARD CHAIN\n         LR    R13,R1\n                                       SPACE 1\n         LA    R0,DB                   ADDRESS OF STORAGE TO ZERO\n         L     R1,=A(CLLENGTH)         LENGTH OF STORAGE TO ZERO\n         L     R14,=A(DB)\n         LR    R15,R1\n         MVCL  R0,R14                  MOVE DATA AREA INTO GOTTEN AREA\n                                       SPACE 1\n         L     R11,CVTPTR              A(CVT)\n         LA    R15,SCANWORK            A(IOSVSUCB W/A)\n         LA    R0,DEVCLASS             A(DEVCLASS)\n         LA    R1,ADDRUCB              (AUCB SAVE ADDRESS)\n         STM   R15,R1,PARMWA           INIT IOSVSUCB PARMS\n         OI    PARMUCB,X'80'           LAST ONE\n         MVI   DEVCLASS,UCB3DACC       INIT DEVCLASS\n         LA    R1,BR14                 CONVERT ISPLINK TO BR14\n         ST    R1,EPLOC\n                                       SPACE 1\n         LA    R15,0                   A(PSA)\n         USING PSA,R15\n         L     R15,PSAANEW             A(ASCB)\n         USING ASCB,R15\n         L     R15,ASCBJBNS            A(JOBNAME)\n         LTR   R15,R15                 POINTER ?\n         BNZ   GOTJOBNM                ===> YES ITS A JOB NAME\n         OI    BATCHTSO,BATCH          INDICATE BATCH JOB\nGOTJOBNM DS    0H\n         DROP  R15\n                                       SPACE 1\n         BAL   R9,OPTIONS              => ANY OPERANDS\n         TM    OPND,OPVOL\n         BZ    NOSPF                   => NO\n         CLC   =C'SPF',PARAMETR        'CALLED BY SPF'\n         BNE   NOSPF                   => NO\n                                       SPACE 1\n* LOCATE ISPLINK, DEFINE TABLE VARIABLE AND CREATE A TEMPORARY TABLE\n                                       SPACE 1\n         LOAD  EPLOC=ISPLINK\n         ST    R0,XAEPLOC              SAVE ADDRESS OF THE ROUTINE\n         LA    R0,XACAPPER\n         ST    R0,EPLOC                SAVE ADDRESS OF THE ROUTINE\n         L     R15,EPLOC\n         CALL  (15),(VDEFINE,NAMELST,SPFLINE,FORMAT,LENGTH),           *\n               VL,MF=(E,SPFCALL)\n         LTR   R15,R15\n         BZ    CONTINUE\n         LA    R1,BR14                 CONVERT ISPLINK TO BR14\n         ST    R1,EPLOC\n         B     NOSPF\nCONTINUE DS    0H\n         L     R15,EPLOC\n         CALL  (15),(TBCREATE,SPACE,0,NAMELST,NOWRITE),                *\n               VL,MF=(E,SPFCALL)\n                                       SPACE 1\n*   MAINLINE -- FIND AN OPERAND\n                                       SPACE 1\n         BAL   R9,OPTIONS              => ANY OPERANDS\nNOSPF    DS    0H\n         TM    OPND,OPVOL\n         BZ    SYSRES1                 => NO\n                                       SPACE 1\n*   FIRST ASSUME THAT THE OPERAND IS A VOLUME, AND FIND ITS UCB\n                                       SPACE 1\nVOLUME1  DS    0H\n         XC    OPTCHAN(OPTCHANL),OPTCHAN\n         BAL   R9,SCAN1                GET FIRST UCB ADDRESS\n         LA    R10,UCBCOPY             A(UCB)\nVOLUME2  DS    0H\n         BNZ   VOLUME4                 END OF DASD UCB'S\n         EX    R4,CLCVOL               CHECK FOR MY VOLUME\n         BNE   VOLUME3                 - NO TRY NEXT\n         BAL   R9,UCBMSG               - YES PRINT SPACE DATA\nVOLUME3  DS    0H\n         BAL   R9,SCAN2                GET NEXT UCB\n         B     VOLUME2                 -> TEST\nVOLUME4  DS    0H\n         TM    OPND,OPFOUND            OPERAND DISPLAYED\n         BZ    SEARCH1                 -> NO\n         NI    OPND,255-OPFOUND        RESET FLAG\n         BAL   R9,OPTIONS              GET THE NEXT OPTION\n         TM    OPND,OPVOL              FOUND ONE\n         BZ    END                     -> NO\n         B     VOLUME1                 -> PROCESS THE NEXT OPERAND\n                                       SPACE 1\n* LOOP THROUGH THE UCB'S LOOKING FOR AN ADDRESS E.G. 443 OR 44X\n                                       SPACE 1\nSEARCH1  DS    0H\n         BAL   R9,SCAN1                GET FIRST UCB ADDRESS\nSEARCH2  DS    0H\n         BNZ   SEARCH4                 END OF DASD UCB'S\n         UNPK  MSGUCB(5),UCBCHAN(3)    GET THE 4 DIGIT DEVICE ADDRESS\n         TR    MSGUCB(4),TRTABLE2-240  CONVERT TO EBCDIC\n         CLC   MSGUCB(4),PARAMETR      THIS THE ADDRESS\n         BE    SEARCH5                 - NO TRY NEXT\n         CLI   PARAMETR+3,C'*'         GENERIC TYPE ADDRESS\n         BE    ASTER1                  - Yes\n         CLI   PARAMETR+3,C'X'         GENERIC TYPE ADDRESS\n         BNE   SEARCHX2                - NO TRY NEXT\nASTER1   DS    0H\n         CLC   MSGUCB(3),PARAMETR      THIS THE ADDRESS\n         BNE   SEARCH3                 - NO TRY NEXT\nSEARCH5  DS    0H\n         BAL   R9,UCBMSG               - YES PRINT SPACE DATA\nSEARCH3  DS    0H\n         BAL   R9,SCAN2                GET NEXT UCB\n         B     SEARCH2                 -> TEST\nSEARCH4  DS    0H\n         TM    OPND,OPFOUND            OPERAND DISPLAYED\n         BZ    GENERIC1                -> NO\n         BAL   R9,OPTIONS              -> LOOP THROUGH\n         TM    OPND,OPVOL              ANY VOLUME OPERANDS?\n         BZ    END                     - NO\n         B     VOLUME1                 - YES\nSEARCHX2 DS    0H\n         CLI   PARAMETR+2,C'*'         GENERIC TYPE ADDRESS\n         BE    ASTER2                  - Yes\n         CLI   PARAMETR+2,C'X'         GENERIC TYPE ADDRESS\n         BNE   SEARCHX3                - NO TRY NEXT\nASTER2   DS    0H\n         CLC   MSGUCB(2),PARAMETR      THIS THE ADDRESS\n         BE    SEARCH5                 - NO TRY NEXT\nSEARCHX3 DS    0H\n         CLI   PARAMETR+1,C'*'         GENERIC TYPE ADDRESS\n         BE    ASTER3                  - Yes\n         CLI   PARAMETR+1,C'X'         GENERIC TYPE ADDRESS\n         BNE   SEARCHX4                - NO TRY NEXT\nASTER3   DS    0H\n         CLC   MSGUCB(1),PARAMETR      THIS THE ADDRESS\n         BE    SEARCH5                 - NO TRY NEXT\nSEARCHX4 DS    0H\n         CLI   PARAMETR,C'*'           GENERIC TYPE ADDRESS\n         BE    SEARCH5                 - Yes\n         CLI   PARAMETR,C'X'           GENERIC TYPE ADDRESS\n         BE    SEARCH5                 - YES DUMP THEM ALL\n         B     SEARCH3                 - NO TRY NEXT\n                                       SPACE 1\n* CHECK IF IT IS A GENERIC UNIT TYPE\n                                       SPACE 1\nGENERIC1 DS    0H\n         XC    IEFEPARM(IEFELENG),IEFEPARM\n         LA    R0,IEFEUNIT             A(IEFEUNIT)\n         LA    R1,IEFEFLAG             A(IEFEUNIT)\n         STM   R0,R1,IEFEPARM          SAVED IN PARAMETER LIST\n         MVC   IEFEUNIT(8),PARAMETR    SAVED IN PARAMETER LIST\n         MVI   IEFEFLAG,X'10'          ATTRIBUTE BYTE\n         LA    R1,IEFEPARM             A(IEFEPARM)\n         LINK  EP=IEFEB4UV             GET THE DEVICE TYPE\n         LTR   R15,R15                 OK ?\n         BNZ   GENERIC3                -> NO\n         L     R3,IEFEUNI3             A(ATTRIBUTE AREA)\n         L     R2,4(R3)                NUMBER OF ENTRIES\n         LA    R4,8(R3)                A(A(UCB))\nGENERIC2 DS    0H\n         ST    R2,SAVER2               SAVE COUNT - T'WILL BE CLOBBERED\n         BAL   R9,UCBMSG               -> PRINT IT\n         L     R2,SAVER2               RESTORE COUNT\n         LA    R4,4(R4)                NEXT A(A(UCB))\n         BCT   R2,GENERIC2             -> LOOP THROUGH THEM ALL\n         L     R0,0(R3)                SUBPOOL AND LENGTH\n         FREEMAIN R,LV=(0),A=(R3)\nGENERIC3 DS    0H\n         TM    OPND,OPFOUND            OPERAND DISPLAYED\n         BZ    SYSRES1                 -> NO\n         BAL   R9,OPTIONS              -> LOOP THROUGH\n         TM    OPND,OPVOL              ANY VOLUME OPERANDS?\n         BZ    END                     - NO\n         B     VOLUME1                 - YES\n                                       SPACE 1\n* FIND SYSRES AND PRINT ITS SPACE DATA\n                                       SPACE 1\nSYSRES1  DS    0H\n         XC    OPTCHAN(OPTCHANL),OPTCHAN\n         BAL   R9,SCAN1                GET FIRST UCB ADDRESS\nSYSRES2  DS    0H\n         BNZ   SYSRES4                 END OF DASD UCB'S\n         TM    UCBSTAT,UCBSYSR         SYSRES OR CONSOLE\n         BZ    SYSRES3                 - NO TRY NEXT\n         TM    UCBTBYT3,UCB3DACC       IS DEVICE A DASD\n         BZ    SYSRES3                 - NO TRY NEXT\n         BAL   R9,UCBMSG               - YES PRINT SPACE DATA\n         B     END                     => ONLY ONE SYSRES AROUND\nSYSRES3  DS    0H\n         BAL   R9,SCAN2                GET NEXT UCB\n         B     SYSRES2                 -> TEST\nSYSRES4  DS    0H\n                                       SPACE 1\n*   MAINLINE -- END OF PROGRAM\n*               REPOSITION TABLE, DISPLAY IT AND CLOSE IT\n                                       SPACE 1\nEND      DS    0H\n         LA    R1,BR14\n         C     R1,EPLOC\n         BE    ENDNOSPF\n                                       SPACE 1\n         L     R15,EPLOC\n         CALL  (15),(TBTOP,SPACE),VL,MF=(E,SPFCALL)\n                                       SPACE 1\n         L     R15,EPLOC\n         CALL  (15),(TBDISPL,SPACE,PANELNM),VL,MF=(E,SPFCALL)\n                                       SPACE 1\n         L     R15,EPLOC\n         CALL  (15),(TBEND,SPACE),VL,MF=(E,SPFCALL)\n         DELETE EPLOC=ISPLINK\n                                       SPACE 1\n*   MAINLINE -- END OF PROGRAM\n*               FREE MY WORKAREA\n                                       SPACE\nENDNOSPF DS    0H\n         TM    BATCHTSO,FILEOPEN       IS THE SYSPRINT DCB OPEN\n         BZ    ENDNOPEN                -> NO, DON'T CLOSE IT\n         CLOSE MF=(E,OPENWORD),MODE=31\nENDNOPEN DS    0H\n         SR    R0,R0\n         IC    R0,RETURNCD\n         LR    R11,R13                 A(GOTTEN STORAGE)\n         L     R13,4(R13)              UNCHAIN MY SAVEAREA\n         ST    R0,16(R13)              SET MY RETURN CODE\n         L     R0,=A(GSLENGTH)\n         FREEMAIN R,LV=(0),A=(R11)\n         RETURN (14,12),T\n                                       SPACE 1\nBR14     DS    0H\n         LA    R15,1                   RESET RETURN CODE\n         BR    R14                     -> AND RETURN\n                                       SPACE 1\n*   MAINLINE -- CONSTANTS\n                                       SPACE 1\nCLCVOL   CLC   PARAMETR(*-*),UCBVOLI   CHECK FOR MY VOLUME\nMVCVOL   MVC   PARAMETR(*-*),0(R2)     MOVE INTO PARAMETER AREA\n                                       SPACE 1\n*   MAINLINE -- SCAN UCB ROUTINE\n                                       SPACE 1\nSCAN1    DS    0H\n         IOCINFO IOCTOKEN=TOKEN        GET CURRENT IOCTOKEN\n         XC    SCANWORK,SCANWORK       CLEAR THE WORK AREA\nSCAN2    DS    0H\n         UCBSCAN UCBAREA=UCBCOPY,WORKAREA=SCANWORK,DYNAMIC=YES,        *\n               RANGE=ALL,IOCTOKEN=TOKEN,DEVCLASS=DASD,DCEAREA=DCEAREA, *\n               DCELEN=48\n         LTR   R15,R15                 TEST THE RETURN CODE\n         BR    R9                      => RETURN TO CALLER\n TITLE 'UPD#XXX - OPTIONS -- SUBROUTINE TO ACCEPT OPTION KEYWORDS'\nOPTIONS  DS    0H\n         NI    OPND,255-OPVOL          TURN OFF FLAG\n         TM    OPND,OPLAST             LAST TIME THROUGH\n         BO    END                     -> YES\n         TM    OPND,OPFIRST            FIRST TIME THROUGH\n         BO    OPTFIND0                -> NO\n         OI    OPND,OPFIRST            FIRST TIME THROUGH\n                                       SPACE 1\n*   OPTIONS -- FIND OPERAND LIST\n                                       SPACE 1\n         LH    R3,0(R2)                LOAD L'(PARM LIST)\n         LA    R1,2                    SKIP 2 BYTE PREFIX\n         LTR   R2,R2                   TOP BIT SET IN PARM1?\n         BM    PARKEY                  - YES, BATCH PARMLIST\n         LA    R1,4                    SKIP 4 BYTE PREFIX\n         AH    R1,2(R2)                SKIP LENGTH OF COMMD VERB\n         SR    R3,R1                   CORRECT L'PARMS\nPARKEY   LA    R2,0(R1,R2)             POINT TO OPERAND\n         LTR   R3,R3\n         BZR   R9                      - NO OPERANDS\n         STM   R2,R3,SAVER23           SAVE A(OPERANDS,L'OPERNADS)\n                                       SPACE 1\n*   OPTIONS -- HANDLE KEYWORD OPERANDS\n                                       SPACE 1\nOPTFIND0 DS    0H\n         LM    R2,R3,SAVER23           RESTORE(OPERANDS,L'OPERANDS)\n         LR    R4,R2                   - NO OPERANDS\nOPTFIND  DS    0H\n         LR    R2,R4                   - NO OPERANDS\nOPTFIND2 DS    0H\n         OI    0(R4),C' '              CONVERT TO UPPERCASE\n         CLI   0(R4),C'-'              ALLOW FOR '3330-1'\n         BE    OPTFIND3\n         CLI   0(R4),C'*'              ALLOW AN ASTERISK\n         BE    OPTFIND3\n         CLI   0(R4),C'A'              FIND DELIMITER\n         BL    OPTSIZE                 - FOUND\nOPTFIND3 DS    0H\n         LA    R4,1(R4)                INCREMENT\n         BCT   R3,OPTFIND2             TRY AGAIN\n         OI    OPND,OPLAST             LAST TIME THROUGH\n                                       SPACE 1\n*   OPTIONS -- MOVE OPERAND TO WORKAREA\n                                       SPACE 1\nOPTSIZE  BCTR  R4,0\n         SR    R4,R2                   GET OPERAND LENGTH-1\n         BM    OPTNEXT                 - NULL OPERAND\n         C     R4,=A(L'PARAMETR)\n         BNL   OPTNEXT                 - TOO BIG\n         MVC   PARAMETR,CCBLANK        BLANK OUT AREA\n         EX    R4,OPTMOV\n         OI    OPND,OPVOL              FOUND A PARAMETER\n         LA    R2,2(R4,R2)             STEP PAST PREV DELIMITER\n         LTR   R3,R3\n         BP    OPTRETN\n         OI    OPND,OPLAST             LAST TIME THROUGH\n         B     OPTRETN                 => END\n                                       SPACE 1\n*   OPTIONS -- GET NEXT OPERAND\n                                       SPACE 1\nOPTNEXT  LTR   R3,R3\n         BNP   OPTRETN\n         LA    R2,2(R4,R2)             STEP PAST PREV DELIMITER\n         BCT   R3,OPTFIND\n         OI    OPND,OPLAST             LAST TIME THROUGH\n                                        SPACE 1\nOPTRETN  DS    0H\n         BCTR  R3,0                    LESS ONE\n         STM   R2,R3,SAVER23           SAVE A(OPERANDS,L'OPERNADS)\n         BR    R9\nOPTMOV   MVC   PARAMETR(*-*),0(R2)\n TITLE 'UPD#XXX - UCBMSG --- SUBROUTINE TO DISPLAY UCB AND LSPACE'\nUCBMSG   DS    0H\nUCBMSG0  OI    HADUCB,HAD1+HADANY      INDICATE THAT I FOUND ONE\n         OI    OPND,OPFOUND            INDICATE THAT I FOUND ONE\n         MVC   LINAME(LINELNG),CCBLANK CLEAR MESSAGE AREA\n         MVC   SPFLINE(SPFLENG),CCBLANK CLEAR MESSAGE AREA\n         MVC   LINE,=AL2(LINELNG)      SET LENGTH PREFIX\n         UNPK  MSGUCB(5),UCBCHAN(3)    GET THE 4 DIGIT DEVICE ADDRESS\n         TR    MSGUCB(4),TRTABLE2-240  CONVERT TO EBCDIC\n         MVC   SPFUCB,MSGUCB           COPY INTO TEXT LINE\n         MVC   LINAME,MSGUCB           COPY INTO TEXT LINE\n         TM    OPND,OPGENER            GENERIC UNIT REQUESTED\n         BO    UCBMSG2                 -> YES\n         MVC   LINDEVT,=CL8'????????'  INSERT DEVICE TYPE NAME\n         MVC   SPFDEVT,=CL8'????????'  INSERT DEVICE TYPE NAME\n         EDTINFO RTNUNIT,DEVTYPE=UCBTYP,OUTUNIT=SPFDEVT\n         MVC   LINDEVT,SPFDEVT\n         LTR   R15,R15                 OK ?\n         BNZ   NOUNIT                  SKIP THE UNIT TYPE\n         B     NOUNIT\nUCBMSG2  DS    0H\n         MVC   LINDEVT,PARAMETR        INSERT DEVICE TYPE NAME\n         MVC   SPFDEVT,PARAMETR        INSERT DEVICE TYPE NAME\nNOUNIT   DS    0H\n                                       SPACE 1\n*        CLI   UCBTBYT3,UCB3DACC       DIRECT ACCESS DEVICE ?\n*        BNE   UCBMSG3                 * YES, BYPASS.\n         CLI   UCBTYP+3,X'0E'          DEVICE EXTENSION PRESENT ?\n         BL    UCBMSG3                 * NO, USE RESULT OF EDTINFO\n         LA    R14,DCEAREA             R14 -> DEVICE CLASS EXTENSION\n         USING DCE,R14\n         LA    R15,TABLE2              R14 -> UNIT TABLE #2.\n                                       SPACE 1\nDEVLOOP  DS    0H\n         CLI   0(R15),X'FF'            END OF TABLE\n         BE    UCBMSG3                 ---> YES\n         CLC   DCEOBRDT,8(R15)         IS THIS THE DEVICE\n         BE    DEVINDEX                YES, INSERT INTO MESSAGE\n         LA    R15,TABLE2LN(R15)       INCREMENT TABLE\n         B     DEVLOOP                 LOOP THROUGH DEVICES\n                                       SPACE 1\nDEVINDEX DS    0H\n         MVC   SPFDEVT,0(R15)          COPY THE REAL DEVICE TYPE IN\n         MVC   LINDEVT,0(R15)          COPY THE REAL DEVICE TYPE IN\n                                       SPACE 1\n*   UCBMSG -- PUT IN UNIT STATUS\n                                       SPACE 1\nUCBMSG3  TM    UCBTBYT3,UCB3TAPE+UCB3DACC\n         BZ    UCBMSG6                 - NO\n         MVC   LINVOL,UCBVOLI          MOVE VOLUME ID EX UCB\n         MVC   SPFVOL,UCBVOLI          MOVE VOLUME ID EX UCB\n         TM    UCBTBYT3,UCB3DACC       DIRECT ACCESS\n         BZ    UCBMSG6                 - NO\n         MVC   LINSHARE,=C'EXC'\n         MVC   SPFSHARE,=CL9'EXCLUSIVE'\n         TM    UCBTBYT2,UCBRR          IS DEVICE SHAREABLE\n         BZ    UCBMSG4                 - NO\n         MVC   LINSHARE,=C'SHR'\n         MVC   SPFSHARE,=CL9'SHARED'\nUCBMSG4  MVI   LINUSAGE,C'S'           STORAGE\n         MVC   SPFSTAT1,=C'STORAG'\n         TM    UCBSTAB,UCBBSTR\n         BO    UCBMSG5                 - YES\n         MVI   LINUSAGE,C'P'           PUBLIC\n         MVC   SPFSTAT1,=C'PUBLIC'\n         TM    UCBSTAB,UCBBPUB\n         BO    UCBMSG5                 - YES\n         MVI   LINUSAGE,C'R'           PRIVATE\n         MVC   SPFSTAT1,=C'PRIVAT'\n         TM    UCBSTAB,UCBBPRV\n         BO    UCBMSG5                 - YES\n         MVI   LINUSAGE,C'?'           NONE OF THE ABOVE THREE\nUCBMSG5  TM    UCBVOLI,X'FF'           IS DISK MOUNTED\n         BZ    UCBMSG6                 - NO\n         MVC   SPFSTAT2,=CL6'ONLINE'\n         TM    UCBSTAT,UCBONLI         IS IT ONLINE\n         BO    UCBMSG5A                -> YES\n         MVC   SPFSTAT2,=CL6'OFFLNE'\nUCBMSG5A DS    0H\n         TM    UCBSTAT,UCBALOC         IS IT ALLOCATED\n         BZ    UCBMSG5B                -> NO\n         MVC   SPFSTAT2,=CL6'ALLOC'\nUCBMSG5B DS    0H\n         TM    UCBSTAT,UCBSYSR         IS IT SYSRES\n         BZ    UCBMSG5C                -> NO\n         MVC   SPFSTAT2,=CL6'SYSRES'\nUCBMSG5C DS    0H\n         TM    UCBFLA,UCBNRY           IS IT READY\n         BZ    UCBMSG5D                -> YES\n         MVC   SPFSTAT2,=CL6',READY'\nUCBMSG5D DS    0H\n         TM    UCBSTAB,UCBPGFL         IS IT PAGING\n         BZ    UCBMSG5E                -> NO\n         MVC   SPFSTAT2,=CL6'PAGING'\nUCBMSG5E DS    0H\n         CLI   UCBSQC,0                IS IT RESERVED\n         BE    UCBMSG5F                -> NO\n         MVC   SPFSTAT2,=CL6'RESRVD'\n         B     UCBMSGB                 -> NO\nUCBMSG5F DS    0H\n         TM    OPND,OPZAP              CHANGE UNIT STATUS?\n         BO    UCBMSG6                 - YES\n         LR    R0,R10                  A(UCB)\n         LA    R1,WORK                 A(WORK SPACE)\n         SVC   78                      ISSUE LSPACE SVC\n                                       SPACE 1\n**  REFORMAT SPACE IF RETURN CODE IS ZERO\n**  NOTE - THE LSPACE SVC FORMATS THE AVAILABLE SPACE IN EBCDIC\n*          BUT THE FIELDS ARE NOT LABELED.\n                                       SPACE 1\n         LTR   R15,R15                 TEST RETURN CODE FROM LSPACE\n         BNZ   UCBMSG7                 ERROR\n         MVC   LINSP(UCBCONL),UCBCONST ADJUST MESSAGE SKELETON\n         MVC   SPCYL,WORK+6            MOVE SPACE - CYL\n         MVC   SPTRK(4),WORK+11        MOVE SPACE - TRK\n         MVC   EXTS(4),WORK+16         MOVE NUMBER OF EXTENTS\n         MVC   EXCYL(4),WORK+21        MOVE EXTENT - CYL\n         MVC   EXTRK(2),WORK+28        MOVE EXTENT - TRK\n         MVC   SPFCYL1,WORK+6          MOVE SPACE - CYL\n         MVC   SPFTRK1,WORK+11         MOVE SPACE - TRK\n         MVC   SPFEXTS,WORK+16         MOVE NUMBER OF EXTENTS\n         MVC   SPFCYL2,WORK+21         MOVE EXTENT - CYL\n         MVC   SPFTRK2,WORK+26         MOVE EXTENT - TRK\n         MVI   SPFSLSH1,C'/'           MOVE IN A SLASH\n         MVI   SPFSLSH2,C'/'           MOVE IN A SLASH\n         B     UCBMSGA\n                                       SPACE 1\n*   UCBMSG -- USE SHORTER MESSAGE WITHOUT SPACE\n                                       SPACE\nUCBMSG6  MVI   LINE+1,LINELNG1         SHORTER LINE LENGTH\n         MVC   LINALLOC,=C'ALLOCATED'\n         TM    UCBSTAT,UCBALOC         UNIT ALLOCATED?\n         BO    UCBMSG8                 - YES\n         TM    UCBFL5,UCBNALOC         USING IT OFFLINE?\n         BO    UCBMSG8                 - YES\n         MVC   LINALLOC,=C'NOT ALLOC'\n         B     UCBMSG8\n                                       SPACE 1\n*   UCBMSG -- REPORT LSPACE ERROR\n                                       SPACE\nUCBMSG7  MVC   LINALLOC(30),WORK       PUT IN LSPACE TEXT\nUCBMSG8  MVC   LINONLI,=C'ONLINE '     ONLINE BY DEFAULT\n         TM    UCBSTAT,UCBONLI         AM I AN ONLINE UNIT ?\n         BO    UCBMSGA                 - YES\n         TM    OPND,OPALL+OPZAP        INCLUDE OFFLINE UNITS\n         BZ    UCBMSGND                - NO, SKIP MESSAGE\n         MVC   LINONLI,=C'OFFLINE'\n                                       SPACE 1\n*   UCBMSG -- CHECK TO SEE IF IT HAS AN INDEXED VTOC\n                                       SPACE 1\nUCBMSGA  DS    0H\n         CVAFTST UCB=(R10)             INDEXED VTOC ??\n         CH    R15,=H'8'               R15=8 IF INDEXED\n         BNE   UCBMSGB                 -> NOT INDEXED\n         MVC   LININDEX,=C'IX'         INDICATE VTOC IS INDEXED\n         MVC   SPFINDEX,=C'IX'         INDICATE VTOC IS INDEXED\nUCBMSGB  DS    0H\n                                       SPACE 1\n*   UCBMSG -- ADD THIS ROW TO THE TABLE FOR SPF OR TPUT IT AND RETURN\n                                       SPACE 1\n         L     R15,EPLOC\n         CALL  (15),(TBADD,SPACE),VL,MF=(E,SPFCALL)\n         CH    R15,=H'1'               IS TPUT REQUIRED\n         BNE   UCBMSGND                -> NO\n         TM    BATCHTSO,BATCH          IS THIS A BATCH RUN\n         BE    UCBMSGBT                -> YES, SKIP THE TPUT FOR PUT\n         LA    R0,LINELNG              L'MESSAGE\n         LA    R1,LINAME               A(MESSAGE)\n         TPUT  (1),(0),R\nUCBMSGND BR    R9\nUCBMSGBT DS    0H\n         TM    BATCHTSO,FILEOPEN       IS THE SYSPRINT FILE OPEN\n         BO    UCBMSGPT                -> YES, PUT THE MESSAGE\n         XC    OPENWORD,OPENWORD       ZERO THE OPEN WORDS\n         OI    OPENWORD,X'80'          INDICATE ONLY ONE IN LIST\n         LA    R0,SYSPRINT             ADDRESS THE DCB TO OPEN\n         OPEN  ((0),(OUTPUT)),MODE=31,MF=(E,OPENWORD)\n         OI    BATCHTSO,FILEOPEN       INDICATE THE FILE IS OPEN\nUCBMSGPT DS    0H\n         PUT   SYSPRINT,LINAME         OUTPUT THE DATA\n         BR    R9\n                                       SPACE 1\n*   UCBMSG -- CONSTANTS\n                                       SPACE\nUCBCONST EQU   *\n         DC    C'SPC C='\n         DC    CL4' '\n         DC    C',T='\n         DC    CL4' '\n         DC    C',EXT='\n         DC    CL4' '\n         DC    C' LARGEST EXT C='\n         DC    CL4' '\n         DC    C',T='\nUCBCONL  EQU   *-UCBCONST              LENGTH OF CONSTANTS\n                                       SPACE 1\nTRTABLE  DC    256X'00'\n         ORG   TRTABLE+C'0'\n         DC    X'00010203040506070809'\n         ORG   TRTABLE+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   ,\n                                       SPACE 1\nTRTABLE2 DC    C'0123456789ABCDEF'     HEX/EBCDIC TRANSLATE TABLE\n                                       SPACE 1\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n                                       SPACE 1\n         LTORG\n TITLE 'UPD#XXX - TSO COMMAND DASDSPCE - GOTTEN STORAGE'\nGS       CSECT\nGS       AMODE 31\nGS       RMODE ANY\n         DS    18F                     SAVE AREA FOR MAINLINE\nDB       DS    D                       DOUBLE WORD WORK AREA\n*\n*   UNIT STATUS MESSAGE/REPLY OUTPUT VIA TPUT\n*\nLINE     DS    H                       TEXT LENGTH\nLINAME   DC    CL4' '\n         DC    C' '\nLINSHARE DC    CL3' '\n         DC    C' '\nLINUSAGE DC    CL1' '\n         DC    C' '\nLININDEX DC    CL2' '\n         DC    C' '\nLINVOL   DC    CL6' '\n         DC    C' '\nLINDEVT  DC    CL6' '                  DEVICE TYPE NAME\n         DC    C' '\nLINONLI  DC    C'ONLINE '              ONLINE/OFFLINE\n         DC    C' '\nLINALLOC DC    C'ALLOCATED'            ALLOCATED/NOT ALLOC\nLINELNG1 EQU   *-LINAME\n         ORG   LINONLI\nLINSP    DC    C'SPC C='\nSPCYL    DC    CL4' '\n         DC    C',T='\nSPTRK    DC    CL4' '\n         DC    C',EXT='\nEXTS     DC    CL4' '\n         DC    C' LARGEST EXT C='\nEXCYL    DC    CL4' '\n         DC    C',T='\nEXTRK    DC    CL2' '\nLINELNG  EQU   *-LINAME                LINE LENGTH\n         AIF   (LINELNG LE 80).LINEOK\n         MNOTE 12,'Line length exceeds 80 bytes'\n.LINEOK  ANOP\n*\n*   UNIT STATUS MESSAGE WHICH IS OUTPUT TO SPF\n*\nSPFLINE  DS    0F\nSPFUCB   DC    CL4' '\n         DC    CL1' '\nSPFINDEX DC    CL2' '\n         DC    CL2' '\nSPFVOL   DC    CL6' '\n         DC    CL2' '\nSPFCYL1  DC    CL4' '\nSPFSLSH1 DC    CL1' '\nSPFTRK1  DC    CL4' '\n         DC    CL2' '\nSPFEXTS  DC    CL4' '\n         DC    CL2' '\nSPFCYL2  DC    CL4' '\nSPFSLSH2 DC    CL1' '\nSPFTRK2  DC    CL4' '\n         DC    CL2' '\nSPFDEVT  DC    CL8' '\n         DC    CL1' '\nSPFSHARE DC    CL9' '\n         DC    CL2' '\nSPFSTAT1 DC    CL6' '\n         DC    CL2' '\nSPFSTAT2 DC    CL6' '\n         DC    CL9' '\nSPFLENG  EQU   *-SPFLINE               LINE LENGTH\n*\n*   OTHER MESSAGES\n*\n*\n*   GENERAL WORK AREA\n*\nSPFCALL  CALL  ,(0,0,0,0,0,0),MF=L     SPF CALL PARAMETER LIST\nOPENWORD DS    2A                      TWO WORDS FOR OPEN PARMS\nEPLOC    DS    A                       ADDRESS OF ISPLINK\nDEVMASKT DS    A                       ADDRESS OF DEVMASK\nDEVNAMET DS    A                       ADDRESS OF DEVNAME\nWORK     DS    CL30                    AREA USED BY SVC LSPACE\n         CNOP  6,8                     CURRENT OPERAND...\nPARASIZE DS    H                       .  LENGTH\nPARAMETR DS    D                       .  CHAR STRING\nBYTE     DS    X                       LAST BYTE OF ADDRESS 13X\nBYTELIST DS    CL16                    ONE BYTE PER ADDRESS\nRETURNCD DS    X                       ADDRESS OF DEVNAME\nOPND     DC    X'00'                   OPERAND KEYWORDS...\nOPCONS   EQU   128                     .  CONSOLE: TALK TO CONSOLE\nOPALL    EQU   64                      .  ALL: INCLUDE OFFLINE UNITS\nOPZAP    EQU   32                      .  ZAP: CHANGE UNIT STATUS\nOPVOL    EQU   16                      .  UNIT/VOL OPERANDS\nOPFIRST  EQU   8                       .  FIRST TIME FLAG\nOPLAST   EQU   4                       .  LAST TIME FLAG\nOPFOUND  EQU   2                       .  OPERAND DISPLAYED\nOPGENER  EQU   1                       .  GENERIC OPERAND\n*\nHADUCB   DC    X'00'                   SUCCESS FLAGS...\nHAD1     EQU   128                     .  UCB MATCHED THIS OPERAND\nHADANY   EQU   64                      .  UCB MATCHED ANY OPERANDS\n*\nBATCHTSO DC    X'00'                   BATCH OR TSO USER\nBATCH    EQU   128                     .  A BATCH USER\nFILEOPEN EQU   64                      .  SYSPRINT FILE OPEN (BATCH)\n*\nSAVER2   DS    F                       SAVE AREA FOR COUNT OF UCB'S\nSAVER23  DS    2F                      SAVE AREA FOR OPTIONS\nDEVTTAB  DS    F                       DEVICE TYPE IN DEVNAMET\nDEVTUCB  DS    F                       DEVICE TYPE IN UCB\nOPTCHAN  DS    10CL3                   SAVE AREA FOR DUPLICATE UCB'S\nOPTCHANL EQU   *-OPTCHAN\nOPTCHANC DS    C\n*\nMSGUCB   DS    CL5                     FOR UCB ADDRESS\n*\nCCBLANK  DC    144C' '\nCCMISS   DC    AL2(CCMISSL)\nCCMISSA  DC    C'UKSPC05 CANNOT FIND VOLUME,'\n         DC    C' GENERIC OR UNIT NAME '\nCCMISSN  DC    CL8' '                  NAME OPERAND\nCCMISSL  EQU   *-CCMISSA\n                                       SPACE 1\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=80,             *\n               BLKSIZE=0,DCBE=DCBE,DSORG=PS\nDCBE     DCBE  RMODE31=BUFF\n                                       SPACE 1\nTABLE2   DC    CL8'3380-A',X'0E'\nTABLE2LN EQU   *-TABLE2\n         DC    CL8'3380-D',X'1E'\n         DC    CL8'3380-J',X'21'\n         DC    CL8'3380-K',X'23'\n         DC    CL8'3390-1',X'26'\n         DC    CL8'3390-2',X'27'\n         DC    CL8'3390-3',X'24'\n         DC    CL8'3380-E',X'2E'\n         DC    CL8'3390-9',X'32'\n         DC    X'FF'\n                                       SPACE 1\n*        CONSTANTS REQUIRED FOR LINKING TO ISPLINK (SPF)\n                                       SPACE 1\nISPLINK  DC    CL8'ISPLINK'\nPANELNM  DC    CL8'VSPACE00'\nTBTOP    DC    CL8'TBTOP'\nTBEND    DC    CL8'TBEND'\nTBDISPL  DC    CL8'TBDISPL'\nTBADD    DC    CL8'TBADD'\nTBCREATE DC    CL8'TBCREATE'\nSPACE    DC    CL8'SPACE'\nNOWRITE  DC    CL8'NOWRITE'\nVDEFINE  DC    CL8'VDEFINE'\nNAMELST  DC    CL8'(REC1)'\nFORMAT   DC    CL8'CHAR'\nLENGTH   DC    F'79'\nSCANWORK DC    CL100' '\nTOKEN    DC    CL48' '\nUCBCOPY  DC    CL48' '\nDCEAREA  DC    CL48' '\nPARMLIST DS    0F\nPARMWA   DS    F                   ADDRESS OF THE UCB SCAN WORK AREA\nPARMDEVT DS    F                   ADDRESS OF THE BYTE CONTAINING THE\n*                                  DEVICE TYPE TO BE SEARCHED\nPARMUCB  DS    F                   ADDRESS OF A WORD FOR A(UCB)\nADDRUCB  DS    F                   A(UCB)\nDEVCLASS DS    X                   DEVICE CLASS\n                                       SPACE 1\nIEFEPARM DC    2A(0)                   ADDRESS OF FOLLOWING FIELDS\nIEFEFLAG DC    A(0)                    FLAGS FOR IEFEB4UV\nIEFEUNIT DC    A(0)                    UNIT TABLE FOR IEFEB4UV\nIEFEUNI2 DC    A(0)                    UNIT TABLE FOR IEFEB4UV\nIEFEUNI3 DC    A(0)                    UNIT TABLE FOR IEFEB4UV\nIEFEUNI4 DC    A(0)                    UNIT TABLE FOR IEFEB4UV\nIEFEUNI5 DC    A(0)                    UNIT TABLE FOR IEFEB4UV\nIEFEATTR DC    A(0)                    ATTRIBUTE AREA\nIEFEATT2 DC    A(0)                    ATTRIBUTE AREA\nIEFEATT3 DC    A(0)                    ATTRIBUTE AREA\nIEFELENG EQU   *-IEFEPARM\n                                       SPACE 1\nXACAPPER DS    0H\n         DROP  ,\n         USING XACAPPER,R15\n         LR    R2,R14                  SAVE THE RETURN ADDRESS\n         O     R2,XABIT                SET HIGH ORDER BIT (AMODE=31)\n         LA    R14,XACAPP1             CLEAR HIGH ORDER BIT\n         BSM   0,R14                   CONVERT TO 24 BIT MODE\nXACAPP1  DS    0H\n         L     R15,XAEPLOC             CORRECT ENTRY POINT ADDRESS\n         BALR  R14,R15                 => CALL 24 BIT ROUTINE\n         BSM   0,R2                    OBTAIN INTO 31 BIT MODE\n                                       SPACE 1\nXAEPLOC  DS    F\nXABIT    DS    X'80000000'\n                                       SPACE 1\n         DS    0D                      END OF GOTTEN STOGAGE\nCLLENGTH EQU   *-DB                    LENGTH TO COPY BELOW 16MB\nGSLENGTH EQU   *-GS                    LENGTH OF GOTTEN STORAGE\n                                       SPACE 1\n***********************************************************************\n*        DSECTS                                                       *\n***********************************************************************\nUCBSPACE DSECT\n         IEFUCBOB LIST=YES,DEVCLAS=DA\n         IECDDCE\n         PRINT NOGEN\n         CVT   DSECT=YES\n         YREGS\n         IHAPSA\n         IHAASCB\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEBUG": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x02^\\x02^\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 606, "newlines": 606, "modlines": 0, "user": "PGILLIS"}, "text": "         MACRO\n         DEBUG &ID=NO,&DATA=YES,&TEST=YES,&MAXLEN=100,&TYPE=WTO,       *\n               &EP=EPLOC,&OPEN=NO,&CLOSE=NO,&PRINT=SYSDEBUG,&TIME=NO,  *\n               &ROUTCDE=11,&RC=ZERO,&RCVAR=RC,&PGMBASE=R12,&RENT=YES,  *\n               &USING=(GS,R13),&USING2=,&PRINTGEN=YES,&REG=REG,        *\n               &LABEL=DEBUG,&DEBBASE=R2,&MODE=YES,&EXTERNAL=NO\n.**********************************************************************\n.*                                                                    *\n.* Macro Name:           DEBUG                                        *\n.*                                                                    *\n.* Operating System:     OS/390 V2R10 through z/OS 1.9                *\n.*                                                                    *\n.* Function:             Allow almost any field within an assembler   *\n.*                       program to be output to a DEBUG file for     *\n.*                       problem analysis.                            *\n.*                                                                    *\n.* Purpose:              Make my life easier                          *\n.*                                                                    *\n.* Module Type:          Macro                                        *\n.*                                                                    *\n.* Language:             Assembler                                    *\n.*                                                                    *\n.* Attributes:           Any Key                                      *\n.*                       Problem State                                *\n.*                       Re-Entrant                                   *\n.*                       AMODE(ANY)                                   *\n.*                       RMODE(ANY)                                   *\n.*                       BAKR/PR                                      *\n.*                                                                    *\n.* Author:               Paul Gillis, P. C. Link Pty. Ltd.            *\n.*                                                                    *\n.* Copyright:            Paul Gillis, P. C. Link Pty. Ltd.            *\n.*                                                                    *\n.**********************************************************************\n.*\n.* Changes:\n.*       V3    Cater for long hexadecimal requests\n.*       V4    Tighten up on the storage requirements\n.*       V5    Move LOG code into a sub-routine\n.*       V6    Conditionally If RC selected and is 0 then do not debug\n.*       V7    Place most debug code into the DEBUG CSECT\n.*       V8    Add Date to TimeStamp\n.*       V9    Dynalloc the SYSDEBUG DD\n.*       V10   Alternate names for register equates and DEBUG lables\n.*       V11   Allow multiple base registers for DEBUG000 CSECT-notyet-\n.*       V12   Allow DEBUG under control of external variable\n.*       V13   DEBUG Data Type \"B\" Convert Binary to Numeric\n.*       V14   Fix bug when external variable control is used\n.*       V15   Fix bug when TIME=YES is used\n.*       V16   Fix bug when RC=NZERO\n.*       V17   What idiot used R9 as a base for dynalloc data\n.*       V18   PGMBASE handles up to 4 base registers\n.*\n.**********************************************************************\n.*\n.*       ID=NO | VALUE\n.*             Provides a unique ID for a DEBUG DATA=YES statement\n.*\n.*       (Field,Length,Type)\n.*             Coded when ID=value, supplies the \"Field\" name to\n.*             display, its \"Length\" and its \"Type\".\n.*             Default Type is \"X\" for hexadecimal, else \"C\" for\n.*             character display or B to convert a binary to numeric\n.*\n.*       DATA=YES | V | C | G\n.*             Generates data constants for V(variable storage)\n.*             Generates data constants for C(constant storage)\n.*             Generates G(global parameters), used with TYPE & MAXLEN\n.*\n.*       TEST=YES\n.*             Only generates code if SYSPARM(TEST) is used\n.*\n.*       MAXLEN=100\n.*             Maximum amount of data that can be displayed in bytes\n.*\n.*       TYPE=WTO | LOG | PUT | WTL\n.*             How the message is to be issued. WTO or ISPF LOG dataset\n.*             WTL or PUT to &PRINT (Which must be open)\n.*\n.*       EP=EPLOC\n.*             Provides the ISPLINK entry point for TYPE=LOG\n.*\n.*       OPEN=NO | YES\n.*             Generate and OPEN the &PRINT DCB for TYPE=PUT\n.*\n.*       CLOSE=NO | YES\n.*             Close the &PRINT DCB for TYPE=PUT\n.*\n.*       PRINT=SYSDEBUG | ddname\n.*             DD name of the print output DD and label on the DCB mac\n.*\n.*       TIME=NO | YES\n.*             Insert the time in the debug message instead of csect id\n.*\n.*       ROUTCDE=11 | n\n.*             Insert the ROUTCDE if 11 is not required for WTO\n.*\n.*       RC=ZERO | NZERO\n.*             If RC=NZERO on a Global call, and RC is selected on\n.*             a debug call and the value of RC is \"0\" then do not\n.*             debug the statement. RC must be the first data field\n.*\n.*       RCVAR=RC | variable name\n.*             If RCVAR=RC then the internal variable for Return Code\n.*             is RC, otherwise use the variable name supplied\n.*\n.*       PGMBASE=R12 | program base Registers\n.*\n.*       RENT=YES | NO\n.*             if RENT=YES, the work data area is in the main CSECT\n.*             if RENT=NO, the work data area is in the main DSECT\n.*\n.*       PRINTGEN = YES | NO\n.*             All DBUG0000 data has PRINT GEN(YES) PRINT NOGEN(NO)\n.*\n.*       USING=(GS,R13) | (dsect,base)\n.*             Define the programs work area and its base register\n.*\n.*       USING2= (dsect,base)\n.*             Define a temporary work area and its base register\n.*\n.*       REG=REG | name\n.*             Define the prefix for general purpose registers savearea\n.*\n.*       LABEL=DEBUG | prefix\n.*             Define the prefix for all other variables used by DEBUG\n.*\n.*       DEBBASE=R2\n.*             D\n.*\n.*       MODE=YES | NO\n.*             Generate AMODE(31),RMODE(ANY) on the DEBUG000 CSECT\n.*\n.*       EXTERNAL=NO\n.*             Contents of variable DEBUGXTN(Y) control use of DEBUG\n.*\n.**********************************************************************\n.*\n.*       Normal usage as described below, place statements into the\n.*       right place in your code.\n.*\n.*       DEBUG DATA=G,TYPE=PUT,MAXLEN=132,OPEN=YES\n.*       DEBUG ID=STEP1,(REG01,4,X),(RC,1,X),(NAME,8,C),(IN,4,B)\n.*       DEBUG DATA=G,CLOSE=YES\n.*       DEBUG DATA=C                  Debug Constants\n.*       DEBUG DATA=V                  Debug Variables\n.*\n.**********************************************************************\n         LCLA  &CNT,&L1,&L2,&L3,&L4,&L5,&L6,&L7,&L8,&LENGTH,&N,&MAX\n         LCLC  &C1\n         GBLC  &DEBUGTY,&DEBUGOP,&DEBUGDD,&DEBUGTM,&DEBUGEP,&DEBUGRO\n         GBLC  &DEBUGRC,&DEBUGR1,&DPGMBAS,&DBUGRNT,&DBUGUSE,&DBUGPGN\n         GBLC  &DEBUGLB,&DEBUGRG,&DBUGBAS\n         GBLC  &DEBUGXT\n         GBLA  &DEBUGML\n         GBLC  &CSECT\n         AIF   ('&TEST' NE 'YES').SYSP\n         AIF   ('&SYSPARM' NE 'TEST').EXIT\n.**********************************************************************\n.*       Output the required Debug Data Headers\n.**********************************************************************\n.SYSP    ANOP\n         AIF   ('&ID' EQ 'NO').DATA\n.*entry-start-\n         AIF   ('&DEBUGXT' EQ 'NO').EXTERN1\n         CLI   &DEBUGLB.XTN,C'Y'           Externally Controlled Debug\n         BNE   DEBUG_Z&SYSNDX          ===> No, Skip Debug Call\n.EXTERN1 ANOP\n         STM   R14,R13,&DEBUGLB.SAV\n         L     R15,=A(DBUG&SYSNDX)     Address of the debug entry\n         BALR  R14,R15                 ===> Invoke Debug Routine\n         PUSH  USING\n         PUSH  PRINT\n         PRINT &DBUGPGN\n&DEBUGLB.000 CSECT\nDBUG&SYSNDX DS 0H\n         DROP  ,                       Drop all usings\n         BAKR  R14,0                   Save the callers environment\n         LR    &DBUGBAS,R15            Set Base\n         USING DBUG&SYSNDX,&DBUGBAS\n         USING &CSECT,&DPGMBAS\n         AIF   ('&DBUGUSE' EQ '').USING1\n         USING &DBUGUSE\n.USING1  ANOP\n         AIF   ('&USING2(2)' EQ '').USING2A\n         USING &USING2(1),&USING2(2)\n.USING2A ANOP\n.*entry-end-\n         AIF   ('&DEBUGRC' EQ 'ZERO').RC1\n         AIF   ('&SYSLIST(1,1)' NE '&DEBUGR1').RC1\n         CLI   &DEBUGR1,0                Return Code check required\n         BE    DEBU&SYSNDX               ===> RC=0, skip debug\n.RC1     ANOP\n         MVC   &DEBUGLB.WTO,&DEBUGLB.CON\n&L1      SETA  4\n         AIF   ('&DEBUGTM' EQ 'NO').NOTIME\n&L1      SETA  22\n         BAL   R3,&DEBUGLB.TIM\n         L     R3,&DEBUGRG.03\n.NOTIME  ANOP\n         LA    R1,&DEBUGLB.WTO+&L1\n&N       SETA  K'&CSECT\n         MVC   0(&N,R1),ZZA&SYSNDX\n&N       SETA  K'&ID\n         MVC   9(&N,R1),ZZB&SYSNDX\n         LA    R1,18(R1)\n         AIF   (N'&SYSLIST EQ 0).MESSAGE\n.**********************************************************************\n.*       Loop through the input parameters\n.**********************************************************************\n&CNT     SETA  1\n&LENGTH  SETA  18\n.LOOP    ANOP\n&N       SETA  N'&SYSLIST\n         AIF   ('&SYSLIST(&CNT,2)' NE '').GETLENG\n&L1      SETA  L'&SYSLIST(&CNT,1)\n         AGO   .GOTLENG\n.GETLENG ANOP\n&L1      SETA  &SYSLIST(&CNT,2)\n.GOTLENG ANOP\n&L2      SETA  &L1+1\n&L3      SETA  &L1*2\n&L4      SETA  &L3+1\n&L5      SETA  K'&SYSLIST(&CNT,1)+1\n         MVC   0(&L5,R1),ZZC&SYSNDX&CNT\n         LA    R1,&L5.(R1)\n&LENGTH  SETA  &LENGTH+&L5\n         AIF   ('&SYSLIST(&CNT,3)' EQ 'X').HEX\n         AIF   ('&SYSLIST(&CNT,3)' EQ 'C').CHAR\n         AIF   ('&SYSLIST(&CNT,3)' EQ 'B').BINARY\n.**********************************************************************\n.*       Process short hexadecimal requests\n.**********************************************************************\n.HEX     ANOP\n         AIF   (&L1 GT 7).HEXLONG\n         UNPK  &DEBUGLB.WK(&L4),&SYSLIST(&CNT,1)(&L2)\n         TR    &DEBUGLB.WK(&L3),&DEBUGLB.TRT-240\n         MVC   0(&L3,R1),&DEBUGLB.WK\n&CNT     SETA  &CNT+1\n&LENGTH  SETA  &LENGTH+&L4\n         AIF   (&CNT GT N'&SYSLIST).MESSAGE\n         LA    R1,&L4.(R1)\n         AGO   .DONE\n.**********************************************************************\n.*       Process long hexadecimal requests\n.**********************************************************************\n.HEXLONG ANOP\n         LA    R14,&SYSLIST(&CNT,1)\n         LA    R15,&L1\nDEB&CNT&SYSNDX DS 0H\n         UNPK  &DEBUGLB.WK(9),0(5,R14)\n         TR    &DEBUGLB.WK(8),&DEBUGLB.TRT-240\n         MVC   0(8,R1),&DEBUGLB.WK\n         MVI   8(R1),C','\n         LA    R14,4(R14)\n         LA    R1,9(R1)\n         SH    R15,=H'4'\n         BP    DEB&CNT&SYSNDX\n         BCTR  R1,0\n         MVI   0(R1),C' '\n&CNT     SETA  &CNT+1\n&LENGTH  SETA  &LENGTH+&L4\n         AIF   (&CNT GT N'&SYSLIST).MESSAGE\n         LA    R1,1(R1)\n         AGO   .DONE\n.**********************************************************************\n.*       Process binary request 1, 2, 3 or 4 bytes long\n.**********************************************************************\n.BINARY  ANOP\n         AIF   ('&SYSLIST(&CNT,2)' EQ '1').BINARY1\n         AIF   ('&SYSLIST(&CNT,2)' EQ '2').BINARY2\n         AIF   ('&SYSLIST(&CNT,2)' EQ '3').BINARY3\n         AIF   ('&SYSLIST(&CNT,2)' EQ '4').BINARY4\n         MNOTE 8,'BINARY Not 1,2,3, or 4 but &SYSLIST(&CNT,2)'\n         AGO   .EXIT\n.BINARY1 ANOP\n&L4      SETA  3\n&L5      SETA  6\n&L6      SETA  2\n&L8      SETA  1\n         AGO   .BINARY5\n.BINARY2 ANOP\n&L4      SETA  5\n&L5      SETA  5\n&L6      SETA  3\n&L8      SETA  3\n         AGO   .BINARY5\n.BINARY3 ANOP\n&L4      SETA  7\n&L5      SETA  4\n&L6      SETA  4\n&L8      SETA  7\n         AGO   .BINARY5\n.BINARY4 ANOP\n&L4      SETA  11\n&L5      SETA  2\n&L6      SETA  6\n&L8      SETA  15\n         AGO   .BINARY5\n.BINARY5 ANOP\n&L7      SETA  &L4-1\n&C1      SETC  '&L5.(&L6)'\n         XR    R14,R14                 Zero R14\n         ICM   R14,&L8,&SYSLIST(&CNT,1)\n         CVD   R14,&DEBUGLB.DB\n         UNPK  &DEBUGLB.WK(&L4),&DEBUGLB.DB+&C1\n         OI    &DEBUGLB.WK+&L7,X'F0'\n         MVC   0(&L4,R1),&DEBUGLB.WK\n&CNT     SETA  &CNT+1\n&LENGTH  SETA  &LENGTH+&L4\n         AIF   (&CNT GT N'&SYSLIST).MESSAGE\n&L4      SETA  &L4+1\n         LA    R1,&L4.(R1)\n         AGO   .DONE\n.**********************************************************************\n.*       Process a character request\n.**********************************************************************\n.CHAR    ANOP\n         MVC   0(&L1,R1),&SYSLIST(&CNT,1)\n&CNT     SETA  &CNT+1\n&LENGTH  SETA  &LENGTH+&L2\n         AIF   (&CNT GT N'&SYSLIST).MESSAGE\n         LA    R1,&L2.(R1)\n.DONE    ANOP\n         AIF   (&CNT LE N'&SYSLIST).LOOP\n.**********************************************************************\n.*       Ensure that the message buffer is big enough\n.**********************************************************************\n.MESSAGE ANOP\n         AIF   (&LENGTH LE &DEBUGML).LOGCHK\n         MNOTE 8,'DEBUG WTO BUFFER USED &LENGTH OF &DEBUGML BYTES'\n         MNOTE 8,'WTO BUFFER TOO SMALL TO CONTAIN &LENGTH BYTES'\n         AGO   .EXIT\n.**********************************************************************\n.*       Work out what to do with the buffer\n.**********************************************************************\n.LOGCHK  ANOP\n         AIF   ('&DEBUGTY' EQ 'LOG').LOG\n         AIF   ('&DEBUGTY' EQ 'WTL').WTL1\n         AIF   ('&DEBUGTY' EQ 'PUT').PUT\n         WTO   MF=(E,&DEBUGLB.WTO)\n         AGO   .EXITCHK\n.WTL1    ANOP\n         WTL   MF=(E,&DEBUGLB.WTO)\n         AGO   .EXITCHK\n.PUT     ANOP\n         PUT   &DEBUGDD,&DEBUGLB.WTO+4\n         AGO   .EXITCHK\n.LOG     ANOP\n         BAL   R3,&DEBUGLB.LOG         ===> Sub to output to the log\n         L     R3,&DEBUGRG.03\n         AGO   .EXITCHK\n.EXITCHK ANOP\n.*exit-start-\nDEBU&SYSNDX DS    0H\n         PR    ,                       ===> Return to Caller\nZZA&SYSNDX DC  C'&CSECT'               Callers CSECT name\nZZB&SYSNDX DC  C'&ID'                  Callers ID\n&CNT     SETA  1\n.CNTLOOP ANOP\nZZC&SYSNDX&CNT DC C'&SYSLIST(&CNT,1)='\n&CNT     SETA  &CNT+1\n         AIF   (&CNT LE N'&SYSLIST).CNTLOOP\n&CSECT   CSECT\n         POP   PRINT\n         POP   USING\n.*exit-end-\n         LM    R14,&DBUGBAS,&DEBUGLB.SAV\n         AIF   ('&DEBUGXT' EQ 'NO').EXTERN2\nDEBUG_Z&SYSNDX DS 0H\n.EXTERN2 ANOP\n         AIF   ('&DEBUGRC' EQ 'ZERO').RC2\n         AIF   ('&SYSLIST(1,1)' NE '&DEBUGR1').RC2\n.RC2     ANOP\n         AGO   .EXIT\n.**********************************************************************\n.*       Process the various DATA variables\n.**********************************************************************\n.DATA    ANOP\n         AIF   ('&DATA' EQ 'V').VARS\n         AIF   ('&DATA' EQ 'C').CONS\n         AIF   ('&DATA' EQ 'G').GBLS\n         AGO   .EXIT\n.**********************************************************************\n.*       Global Variables for the DEBUG macro\n.**********************************************************************\n.GBLS    ANOP\n         AIF   ('&CLOSE' EQ 'YES').CLOSE1\n         AIF   ('&DATA' NE 'G').GBLSNOG\n&CSECT   SETC  '&SYSECT'\n&DEBUGLB SETC  '&LABEL'\n&DEBUGLB.000 CSECT ,                   Debug CSECT has been generated\n         AIF   ('&MODE' NE 'YES').NOMODE\n&DEBUGLB.000 AMODE 31                  Debug CSECT has been generated\n&DEBUGLB.000 RMODE ANY                 Debug CSECT has been generated\n.NOMODE  ANOP\n&CSECT   CSECT\n.GBLSNOG ANOP\n&DEBUGRG SETC  '&REG'\n&DEBUGR1 SETC  '&RCVAR'\n&DEBUGRC SETC  '&RC'\n&DEBUGTY SETC  '&TYPE'\n&DEBUGML SETA  &MAXLEN\n&DEBUGOP SETC  '&OPEN'\n&DEBUGDD SETC  '&PRINT'\n&DEBUGTM SETC  '&TIME'\n&DEBUGEP SETC  '&EP'\n&DEBUGRO SETC  '&ROUTCDE'\n&DEBUGXT SETC  '&EXTERNAL'\n&DBUGRNT SETC  '&RENT'\n&DBUGBAS SETC  '&DEBBASE'\n&DPGMBAS SETC  '&PGMBASE'\n         AIF   ('&USING(2)' EQ '').USING2\n&DBUGUSE SETC  '&USING(1),&USING(2)'\n.USING2  ANOP\n         AIF   ('&PGMBASE(2)' EQ '').BASEREG\n&DPGMBAS SETC  '&PGMBASE(1),&PGMBASE(2)'\n         AIF   ('&PGMBASE(3)' EQ '').BASEREG\n&DPGMBAS SETC  '&PGMBASE(1),&PGMBASE(2),&PGMBASE(3)'\n         AIF   ('&PGMBASE(4)' EQ '').BASEREG\n&DPGMBAS SETC  '&PGMBASE(1),&PGMBASE(2),&PGMBASE(3),&PGMBASE(4)'\n.BASEREG ANOP\n&DBUGPGN SETC  'GEN'\n         AIF   ('&PRINTGEN' EQ 'YES').PRNTGEN\n&DBUGPGN SETC  'NOGEN'\n.PRNTGEN ANOP\n         AIF   ('&DEBUGOP' EQ 'NO').EXIT\n.CLOSE1  ANOP\n.*entry-start-\n         STM   R14,R13,&DEBUGLB.SAV\n         L     R15,=A(DBUG&SYSNDX)     Address of the debug entry\n         BALR  R14,R15                 ===> Invoke Debug Routine\n         PUSH  USING\n         PUSH  PRINT\n         PRINT &DBUGPGN\n&DEBUGLB.000 CSECT\nDBUG&SYSNDX DS 0H\n         DROP  ,                       Drop all usings\n         BAKR  R14,0                   Save the callers environment\n         LR    &DBUGBAS,R15            Set Base\n         USING DBUG&SYSNDX,&DBUGBAS\n         USING &CSECT,&DPGMBAS\n         AIF   ('&DBUGUSE' EQ '').USING3\n         USING &DBUGUSE\n.USING3  ANOP\n         AIF   ('&USING2(2)' EQ '').USING2B\n         USING &USING2(1),&USING2(2)\n.USING2B ANOP\n.*entry-end-\n         AIF   ('&CLOSE' EQ 'YES').CLOSE2\n         XC    &DEBUGLB.RB(20),&DEBUGLB.RB Zero the RB\n         LA    R1,&DEBUGLB.RB          Address the SVC RB\n         ST    R1,&DEBUGLB.RBP         Save the RB Pointer Address\n         OI    &DEBUGLB.RBP,X'80'      And turn on the high order bit\n         MVI   0(R1),20                Insert the RB length\n         MVI   1(R1),1                 I want Allocation\n         LA    R14,&DEBUGLB.TUP        Text Unit Pointer Address\n         ST    R14,8(,R1)              Insert into RB\n         LA    R1,&DEBUGLB.RBP         Set up SVC 99\n         SVC   99                      And call it\n                                       SPACE 1\n         XC    &DEBUGLB.OPN,&DEBUGLB.OPN Zero the list\n         OI    &DEBUGLB.OPN,X'80'      Indicate last in the list\n         MVC   &DEBUGDD,&DEBUGLB.DCB   Copy the DCB below the line\n         MVC   &DEBUGLB.DC1,&DEBUGLB.DCC Copy the DCBE below the line\n         LA    R1,&DEBUGLB.DC1         Address of my DCBE\n         ST    R1,&DEBUGDD             Saved in my DCB\n         OPEN  (&DEBUGDD,(OUTPUT)),MODE=31,MF=(E,&DEBUGLB.OPN)\n         AGO   .CLOSE3\n.CLOSE2  ANOP\n         CLOSE &DEBUGDD,MODE=31,MF=(E,&DEBUGLB.OPN)\n         FREEPOOL &DEBUGDD\n.CLOSE3  ANOP\n.*exit-start-\n         PR    ,                       ===> Return to Caller\n&CSECT   CSECT\n         POP   PRINT\n         POP   USING\n.*exit-end-\n         LM    R14,&DBUGBAS,&DEBUGLB.SAV\n         AGO   .EXIT\n*---------------------------------------------------------------------*\n*        Constants for the DEBUG macro                                *\n*---------------------------------------------------------------------*\n.CONS    ANOP\n&DEBUGLB.000 CSECT\n                                       SPACE\n         AIF   ('&DEBUGTY' EQ 'WTL').CONSWTL2\n         AIF   ('&DEBUGTY' EQ 'PUT').CONSPUT2\n&DEBUGLB.CON WTO '&CSECT                                               X\n                                                                     ',X\n               ROUTCDE=&DEBUGRO,MF=L\n&DEBUGLB.LEN EQU *-&DEBUGLB.CON        Length of WTO params\n         AGO   .CONS2\n.CONSWTL2 ANOP\n&DEBUGLB.CON WTL '&CSECT                                               X\n                                                                     ',X\n               MF=L\n&DEBUGLB.LEN EQU *-&DEBUGLB.CON        Length of WTO params\n         AGO   .CONS2\n.CONSPUT2 ANOP\n&MAX     SETA  &DEBUGML+4\n&DEBUGLB.CON DS 0F\n         DC    CL&MAX' '\n&DEBUGLB.LEN EQU *-&DEBUGLB.CON        Length of WTO params\n.CONS2   ANOP\n         AIF   ('&DEBUGTY' NE 'LOG').CONSDEBL\n&DEBUGLB.LOG DS 0H\n         BALR  &DBUGBAS,0\n         USING *,&DBUGBAS\n         USING &CSECT,&DPGMBAS\n         L     R15,&DEBUGEP            SET UP FOR CALL\n         CALL  (15),(DBUGVREP,DBUGSMSG,DBUGF018,&DEBUGLB.WTO+4),       *\n               VL,MF=(E,&DEBUGLB.CAL)\n         L     R15,&DEBUGEP            SET UP FOR CALL\n         CALL  (15),(DBUGVREP,DBUGLMSG,DBUGF082,&DEBUGLB.WTO+23),      *\n               VL,MF=(E,&DEBUGLB.CAL)\n         L     R15,&DEBUGEP            SET UP FOR CALL\n         CALL  (15),(DBUGLOG,DBUGZ001),VL,MF=(E,&DEBUGLB.CAL)\n         BR    R3                      ===> Return to Caller\nDBUGVREP DC    CL8'VREPLACE'           ISPF Constant\nDBUGLOG  DC    CL8'LOG'                ISPF Constant\nDBUGSMSG DC    CL8'ZEDSMSG'            ISPF Constant\nDBUGLMSG DC    CL8'ZEDLMSG'            ISPF Constant\nDBUGZ001 DC    CL8'ISRZ001'            ISPF Constant\nDBUGF018 DC    F'18'                   ISPF Constant\nDBUGF082 DC    F'82'                   ISPF Constant\n.CONSDEBL ANOP\n&DEBUGLB.LNG EQU *-&DEBUGLB.CON\n*        DC    CL(&DEBUGLB.LNG)' '     Filler for DEBUGRTT-240\n         AIF   ('&DEBUGOP' EQ 'NO').CONS3\n&DEBUGLB.DCB DCB DDNAME=&DEBUGDD,DSORG=PS,MACRF=PM,RECFM=FB,           *\n               DCBE=&DEBUGLB.DCC,LRECL=&DEBUGML\n&DEBUGLB.DCL EQU *-&DEBUGLB.DCB        Length of the DCB\n&DEBUGLB.DCC DCBE RMODE31=BUFF\n&DEBUGLB.DEL EQU *-&DEBUGLB.DCC        Length of the DCBE\n                                       SPACE 1\n&DEBUGLB.TUP DC A(&DEBUGLB.TU1)        Text Unit Pointer\n         DC    A(&DEBUGLB.TU2+X'80000000') Text Unit Pointer\n&DEBUGLB.TU1 DC AL2(1,1,8),CL8'&DEBUGDD' DD\n&DEBUGLB.TU2 DC AL2(24,1,1),C'X'       Sysout Class\n                                       SPACE 1\n         AIF   ('&DEBUGTM' EQ 'NO').NOTIME2\n&DEBUGLB.TIM DS 0H\n         TIME  DEC,&DEBUGLB.CLK,DATETYPE=YYYYMMDD,LINKAGE=SYSTEM,      *\n               MF=(E,&DEBUGLB.TMC)\n         UNPK  &DEBUGLB.WK(9),&DEBUGLB.DAT(5) Convert Date to EBCDIC\n         MVC   &DEBUGLB.WTO+4(8),&DEBUGLB.WK Save yyyymmdd\n         UNPK  &DEBUGLB.WK(9),&DEBUGLB.CLK(5) Convert Time to EBCDIC\n         MVC   &DEBUGLB.WTO+13(8),&DEBUGLB.WK Save hhmmssth\n         BR    R3                      ===> Return to Caller\n.NOTIME2 ANOP\n.CONS3   ANOP\n&DEBUGLB.TRT DC C'0123456789ABCDEF'    Debug Translate Table\n&CSECT   CSECT\n         AGO   .EXIT\n.VARS    ANOP\n*---------------------------------------------------------------------*\n*        Variables for the DEBUG macro                                *\n*---------------------------------------------------------------------*\n                                       SPACE\n&DEBUGLB.DB DC D'0'                    CVB/CVD Work Area\n&DEBUGLB.SAV DS 0F                     Register Saver Area\n&DEBUGRG.14 DC F'0'                    Save Area for Register 14\n&DEBUGRG.15 DC F'0'                    Save Area for Register 15\n&DEBUGR1 EQU   &DEBUGRG.15+3           Low order byte of R15\n&DEBUGRG.00 DC F'0'                    Save Area for Register 00\n&DEBUGRG.01 DC F'0'                    Save Area for Register 01\n&DEBUGRG.02 DC F'0'                    Save Area for Register 02\n&DEBUGRG.03 DC F'0'                    Save Area for Register 03\n&DEBUGRG.04 DC F'0'                    Save Area for Register 04\n&DEBUGRG.05 DC F'0'                    Save Area for Register 05\n&DEBUGRG.06 DC F'0'                    Save Area for Register 06\n&DEBUGRG.07 DC F'0'                    Save Area for Register 07\n&DEBUGRG.08 DC F'0'                    Save Area for Register 08\n&DEBUGRG.09 DC F'0'                    Save Area for Register 09\n&DEBUGRG.10 DC F'0'                    Save Area for Register 10\n&DEBUGRG.11 DC F'0'                    Save Area for Register 11\n&DEBUGRG.12 DC F'0'                    Save Area for Register 12\n&DEBUGRG.13 DC F'0'                    Save Area for Register 13\n&DEBUGLB.CLK DC CL8' '                 Save Area for the Time Stamp\n&DEBUGLB.DAT DC CL8' '                 Save Area for the Date Stamp\n&DEBUGLB.XTN DC C' '                   External Debug Control\n&DEBUGLB.TMC TIME MF=L,LINKAGE=SYSTEM  Time Work Area\n         AIF   ('&DBUGRNT' NE 'NO').RENT5\n&DEBUGLB.000 CSECT\n.RENT5   ANOP\n&DEBUGLB.RBP DC A(&DEBUGLB.RB+X'80000000') SVC 99 RB Pointer\n&DEBUGLB.RB DC 5F'0'                   SVC 99 RB\n&DEBUGLB.CAL DC 5F'0'                  Call Parameter List\n&DEBUGLB.WK DC CL9' '                  Debug Work Area\n         DS    0F\n&DEBUGLB.WTO DC CL(&DEBUGLB.LEN)' '    Changeable WTO params\n         DC    CL(&DEBUGLB.LEN)' '     Changeable WTO params\n         DS    0F\n         AIF   ('&DEBUGOP' EQ 'NO').EXIT\n&DEBUGLB.OPN DS D                      Open Exit List\n&DEBUGDD DS    CL(&DEBUGLB.DCL)        Storage for my DCB\n         DS    0F\n&DEBUGLB.DC1 DS CL(&DEBUGLB.DEL)       Storage for my DCBE\n         AIF   ('&DBUGRNT' NE 'NO').RENT6\n&CSECT   CSECT\n.RENT6   ANOP\n                                       SPACE\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEBUGDOC": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x10\\x00\\x1f\\x01\\x10\\x00\\x1f\\x04\\x07\\x00\\xa9\\x00\\xa9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-01-01T00:00:00", "modifydate": "2010-01-01T04:07:56", "lines": 169, "newlines": 169, "modlines": 0, "user": "SBGOLOB"}, "text": "Introduction\nThe Debug macro is used in an assembler program to dump the contents of\nselected storage in either character or hexadecimal format. This allows\na program to be debugged in batch where online debugging is not a viable\noption. The DEBUG macro must be called to initialise the DEBUG\nenvironment before DEBUG activity may take place.\n\nThe DEBUG labels are all prefixed with DEBUG, except for the RC and REGnn\nvariables.\n\nRegister Contents\nNo register contents are lost in the invocation of the DEBUG macro, as all\nregister contents are saved before any DEBUG processing takes place and\nthe contents are restored wh DEBUG processing is complete. The conditionen\ncode is not carried across and therefore is lost\n                                                                        .\n\nCode Generated\nThe majority of code generated by the DEBUG macro resides in a separate\nCSECT named DBUG0000. This CSECT is entered at a unique location for\nevery invocation of the DEBUG macro.  Each invocation of the macro\nrequires 18 bytes in the assembler CSECT being debugged, except for the\nstorage Initialisation parameters DATA=C or DATA=V.\n\n******************** Initial Invocation Parameters *********************\n\nDATA=YES | G | C | V\n=G Generates Global parameters and initialises DEBUG environment, and is\nalso used to CLOSE the DEBUG output file for TYPE=PUT.\n=V Generates storage for variables. The variables reside in either a DS\naddressable by the USING parameter for re-entrant code, or in the main\nProgram CSECT addressable by the PGMBASE parameter. This is dependent on\nthe location of the DEBUG macro with this parameter.\n=C Generates storage for constants. The constants reside in the DEBUG000\nCSECT.\n=YES, default debug action to be taken.\n\nTEST=YES | NO\n=YES, DEBUG code is generated only if SYSPARM(TEST) is coded on the\nassembly.\n=NO, code is generated regardless of the SYSPARM value.\n\nMAXLEN=100\n=n Maximum amount of data that can be displayed in bytes, ie DEBUG\nbuffer size\n\nTYPE=WTO | LOG | PUT | WTL\n=WTO generates a Write To Operator message\n=WTL issues a write to job message log\n=LOG issues a write to ISPF log dataset\n=PUT issues messages to the DCB defined in the PRINT parameter, which\nmust be open.\n\nEP=EPLOC\n=EPLOC Provides the ISPLINK entry point for TYPE=LOG\n\nOPEN=NO | YES\n=YES, open the PRINT DCB for TYPE=PUT\n=NO, do not open the PRINT DCB for TYPE=PUT\n\nCLOSE=NO | YES\n=YES, close the PRINT DCB for TYPE=PUT\n=NO, do not close the PRINT DCB for TYPE=PUT\n\nPRINT=SYSDEBUG | ddname\nDD name of the print output and label on the DCB macro. This DD will\nbe dynamically allocated as a SYSOUT=* file.\n\nTIME=NO | YES\n=YES, insert the current date and time in the debug message in front of\nthe CSECT identifier.\n=NO, do not generate a date and time stamp on the debug message.\n\nROUTCDE=11 | n\n=n ROUTCDE for TYPE=WTO\n\nRC=ZERO | NZERO\n=NZERO on a Global call, and RC is selected on a debug call and the\nvalue of RC is \"0\" then do not debug the statement. RC must be the first\ndata field for this option to work.\n=ZERO, always debug the RC value.\n\nRCVAR=RC | variable name\nRCVAR defines the internal name for the variable that will contain the\nreturn code byte from register 15.\n\nPGMBASE=R12 | Program Base Registers\nPGMBASE tells the DEBUG environment what the program base registers are.\nThis parameter cannot be R2 as R2 is used by the debug routine as its\nbase register.Refer DEBBASE\n\nDEBBASE=R2\nDefines the base register to be used by the DEBUG000 CSECT\n\nRENT=YES | NO\n=YES, the work data area is in the main CSECT\n=NO, the work data area is in the main DSECT.\n\nUSING=(DSECT,Base Register)\nThe USING parameter defines a permanent work area (DSECT) and its base\nregister to allow the DBUG0000 CSECT addressability to that work area.\nThis is coded on the initial invocation of the DEBUG macro and the work\narea is then addressable to all subsequent DEBUG invocations. The base\nregister parameter cannot be R2 as R2 is used by the debug routine as\nits base register. Refer DEBBASE\n\nPRINTGEN=YES | NO\n=YES, all DBUG0000 CSECT code has PRINT GEN\n=NO, all DBUG0000 CSECT code has PRINT NOGEN\n\nREG=REG\nProvide a default prefix for register variables\nNote: Variables REG00 through REG15 are available and contain the\nregister contents at invocation of the DEBUG macro. Variable RC (set by\nRCVAR above) contains the last byte of REG15.\n\nLABEL=DEBUG\nDefault prefix for all generated variable names other than &REG.\n\nMODE=YES | No\n=YES generate AMODE 31 and RMODE ANY\n=NO\n\nEXTERNAL=NO | YES\n=NO\n=YES allows the execution of the macro to be controlled by the variable\n&DEBUG.XTN which if it contains Y the debug code is executed.\n\n******************** Mainline Invocation Parameters ********************\n\nID=value\nID provides an ID value in the DEBUG message.\n\nUSING2=(DSECT,Base Register)\nUSING2 defines a DSECT and its base register to allow the DBUG0000 CSECT\naddressability to that work area. The base register parameter cannot be\nR2 as it is used by debug as its base register. Refer DEBBASE\n\n(Field,Length,Type)\nCoded when ID=value, supplies the \"Field\" name to display, its \"Length\"\nand its \"Type\".  Type is \"X\" for hexadecimal, or \"C\" for character\ndisplay\nNote: This entry may be repeated as often as required.\n\n**************************** Usage Examples ****************************\n\n(1) DEBUG DATA=G,TYPE=PUT,OPEN=YES,MAXLEN=132,USING=(GS,R13)\n(2) DEBUG ID=INITIAL,(EYEBALL,28,C),(REG14,8,X)\n(3) DEBUG ID=DYNALLOC,(RC,1,X),(S99ERROR,2,X),USING2=(S99RB,R9)\n(4) DEBUG DATA=G,CLOSE=YES\n(5) DEBUG DATA=C                  DEBUG Constants\n(6) DEBUG DATA=V                  DEBUG Variables\n\n(1) Initialises the DEBUG environment, specifying TYPE=PUT for IO to the\nSYSDEBUG DCB, OPEN=YES to open the SYSDEBUG DCB, MAXLEN=132 to set the\nSYSDEBUG buffer to 132 bytes and USING=(GS,R13) to pass to all DEBUG\ninvocations addressability to the GS DSECT using R13 as the base\nregister.\n(2) Writes a debug record containing the identifier INITIAL, the\ncontents of the variable EYEBALL in character format for a length of 28\nbytes, the contents of the variable REG14 in hexadecimal for a length of\n8 bytes.\n(3) Write a debug record containing the identifier DYNALLOC, the\ncontents of the variable RC in hexadecimal for 1 byte, the contents of\nS99ERROR in hexadecimal for 2 bytes and the addressability of S99ERROR\nis defined with the USING2 statement.\n(4) Close the SYSDEBUG DCB\n(5) Defines the constants used by the DEBUG macro.\n(6) Defines the variables written to by the debug macro.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISASJCL": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99(\\x1f\\x00\\x99(\\x1f\\x079\\x01-\\x01-\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-08T00:00:00", "modifydate": "1999-10-08T07:39:00", "lines": 301, "newlines": 301, "modlines": 0, "user": "PGILLIS"}, "text": "./ ADD MEMBER=$$$DOC\n               Installing the disassembler\n\n1.  Allocate a SOURCE, MACRO, and JCL library (the source and macros\n    must in separate libraries, some members have the same names).\n    Space on a 3380 is 15 tracks for the source, 5 for the macros, and\n    2 for the JCL.  DCB info for all 3 is RECFM=FB,LRECL=80,BLKSIZE=3120\n\n2.  If you want to keep the disassembler in a separate load library,\n    allocate this library, it does not have to be APF authorized.\n\n3.  Load the source, macro, and JCL libraries.\n\n4.  Edit member DISASMGB in the macro library to select the options you\n    want.\n\n5.  Edit the ASMLINK member of the JCL library to fit your library names\n\n6.  Run the ASMLINK member to assemble and link-edit the disassembler.\n\n7.  The disassembler should be ready for use.  Edit the DISASM member of\n    the JCL library to use your library names.  Members DISASMDC and\n    DISASMTS of the source library are documentation.\n./ ADD MEMBER=ASMLINK\n//T32PGGDI JOB SU8ZSSSI,P.GILLIS,MSGCLASS=X,NOTIFY=T32PGG,REGION=6M\n//*MAIN CLASS=UTIL,LINES=(999,W)\n//*\n//ASMLINK  PROC NAME=,\n//             AP=,\n//             LIST='SYSOUT=*'\n//ASM      EXEC PGM=ASMA90,COND=(4,LT),\n//             REGION=4096K,\n//             PARM='LINECOUNT(55),DECK,NOOBJECT,XREF(SHORT),&AP'\n//SYSPRINT DD   &LIST\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=SIAG.DISASM.MAC,DISP=SHR\n//SYSPUNCH DD   DSN=&&OBJ(&NAME),DISP=(OLD,PASS)\n//SYSIN    DD   DSN=SIAG.DISASM.SRC(&NAME),DISP=SHR\n// PEND\n//* ----------------------------------------------------------------- *\n//*                                                                   *\n//*           ALLOCATE TEMP OBJECT LIBRARY                            *\n//*                                                                   *\n//* ----------------------------------------------------------------- *\n//ALLOC    EXEC PGM=IEFBR14\n//OBJ      DD DSN=&&OBJ,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15,15)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//* ----------------------------------------------------------------- *\n//*                                                                   *\n//*           ASSEMBLE ALL MODULES                                    *\n//*                                                                   *\n//* ----------------------------------------------------------------- *\n//DISASM00 EXEC ASMLINK,NAME=DISASM00\n//DISASM01 EXEC ASMLINK,NAME=DISASM01\n//DISASM02 EXEC ASMLINK,NAME=DISASM02\n//DISASM03 EXEC ASMLINK,NAME=DISASM03\n//DISASM04 EXEC ASMLINK,NAME=DISASM04\n//DISASM05 EXEC ASMLINK,NAME=DISASM05\n//DISASM06 EXEC ASMLINK,NAME=DISASM06\n//DISASM07 EXEC ASMLINK,NAME=DISASM07\n//DISASM08 EXEC ASMLINK,NAME=DISASM08\n//DISASM09 EXEC ASMLINK,NAME=DISASM09\n//DISASMB2 EXEC ASMLINK,NAME=DISASMB2\n//DISASMDB EXEC ASMLINK,NAME=DISASMDB\n//DISASMOP EXEC ASMLINK,NAME=DISASMOP\n//DISASMPR EXEC ASMLINK,NAME=DISASMPR\n//DISASMRR EXEC ASMLINK,NAME=DISASMRR\n//* ----------------------------------------------------------------- *\n//*                                                                   *\n//*           LINK DISASSEMBLER                                       *\n//*                                                                   *\n//* ----------------------------------------------------------------- *\n//LINK     EXEC PGM=HEWLH096,REGION=512K,\n//             PARM='LIST,LET,XREF',\n//             COND=(4,LT)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(15,15))\n//SYSLIB   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSN=SYS3.LOADLIB,DISP=SHR\n//SYSLIN   DD  *\n  INCLUDE SYSLIB(DISASM00)               COMMON MODULE\n  INCLUDE SYSLIB(DISASM01)               MAINLINE\n  INCLUDE SYSLIB(DISASM02)               PARAMETER READER/CONVERTER\n  INCLUDE SYSLIB(DISASM03)               MODULE READER\n  INCLUDE SYSLIB(DISASM04)               CESD RECORD PROCESSOR\n  INCLUDE SYSLIB(DISASM05)               RLD DATA PROCESSOR\n  INCLUDE SYSLIB(DISASM06)               TEXT PRINTER\n  INCLUDE SYSLIB(DISASM07)               DSECT INTERPRETER\n  INCLUDE SYSLIB(DISASM08)               REFERENCE TABLE GENERATOR\n  INCLUDE SYSLIB(DISASM09)               SOURCE CODE GENERATOR\n  INCLUDE SYSLIB(DISASMOP)               OPCODE TABLE\n  INCLUDE SYSLIB(DISASMB2)               B2 INSTRUCTION INTERPRETER\n  INCLUDE SYSLIB(DISASMDB)               DEBUG\n  INCLUDE SYSLIB(DISASMPR)               PRINTING\n  INCLUDE SYSLIB(DISASMRR)               OPERAND VERIFYING\n  ENTRY DISASM01\n  NAME DISASM96(R)\n/*\n//\n./ ADD MEMBER=ASMLINK1\n//T32PGGDI JOB SU8ZSSSI,P.GILLIS,MSGCLASS=X,NOTIFY=T32PGG,REGION=6M,\n//             COND=(4,LT)\n//*MAIN CLASS=UTIL,LINES=(999,W)\n//*\n//ASMLINK  PROC NAME=,\n//             AP=,\n//             LIST='SYSOUT=*'\n//ASM      EXEC PGM=ASMA90,COND=(4,LT),\n//             REGION=4096K,\n//             PARM='LINECOUNT(55),DECK,NOOBJECT,XREF(SHORT),&AP'\n//SYSPRINT DD   &LIST\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=SIAG.DISASM.MAC,DISP=SHR\n//         DD   DSN=T32PGG.ISPF.SOURCE,DISP=SHR\n//SYSPUNCH DD   DSN=&&OBJ(&NAME),DISP=(OLD,PASS)\n//SYSIN    DD   DSN=SIAG.DISASM.SRC(&NAME),DISP=SHR\n// PEND\n//* ----------------------------------------------------------------- *\n//*                                                                   *\n//*           ALLOCATE TEMP OBJECT LIBRARY                            *\n//*                                                                   *\n//* ----------------------------------------------------------------- *\n//ALLOC    EXEC PGM=IEFBR14\n//OBJ      DD DSN=&&OBJ,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15,15)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//* ----------------------------------------------------------------- *\n//*                                                                   *\n//*           ASSEMBLE ALL MODULES                                    *\n//*                                                                   *\n//* ----------------------------------------------------------------- *\n//DISASMB2 EXEC ASMLINK,NAME=DISASMB2,AP='SYSPARM(TEST)'\n//* ----------------------------------------------------------------- *\n//*                                                                   *\n//*           LINK DISASSEMBLER                                       *\n//*                                                                   *\n//* ----------------------------------------------------------------- *\n//LINK     EXEC PGM=HEWLH096,REGION=512K,\n//             PARM='LIST,LET,XREF,MAP',\n//             COND=(4,LT)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(15,15))\n//SYSLIB   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSN=SYS3.LOADLIB,DISP=SHR\n//SYSLIN   DD  *\n  INCLUDE SYSLIB(DISASMB2)\n  INCLUDE SYSLMOD(DISASM96)\n  ENTRY DISASM01\n  NAME DISASM96(R)\n/*\n//*\n//DISASM96 EXEC PGM=DISASM96,REGION=6M\n//STEPLIB  DD DSN=SYS3.LOADLIB,DISP=SHR\n//SYSPRINT DD DSN=&&PRT,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)\n//SYSIN    DD DSN=&&IN,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR,\n//            UNIT=SYSDA,VOL=SER=SMP212\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSPUNCH DD DUMMY\n//DISDEBUG DD SYSOUT=*\n//DEBUGPGG DD SYSOUT=*\n//DISPRINT DD SYSOUT=*\n//DISPUNCH DD SYSOUT=*\n//DISMOD   DD DISP=SHR,DSN=T32PGG.ISPF.LOAD\n//DISIN    DD *\n*        1    1    2    2    3    3    4    4    5    5    6    6    7\n* ..+....0....+....0....+....0....5....0....5....0....5....0....5....0..\n*\nLINES    60\nMODULE   ABEND0C1\nCSECT    ABEND0C1\nLABEL    PDSM\nBASE     R12       000000              000000\n//\nBASE     R11       000000              000FFF\nBASE     R10       000000              001FFE\nBASE     R9        000000              002FFD\n./ ADD MEMBER=DISASM\n//........ JOB .................\n//* ------------------------------------------------------------------*\n//*                                                                   *\n//*                                                                   *\n//*                                                                   *\n//* ------------------------------------------------------------------*\n//DISASM   EXEC PGM=DISASM,REGION=4096K\n//STEPLIB  DD DSN=.............,DISP=SHR                 <-------------\n//* ------------------------------------------------------------------*\n//*        UNNECESSARY DD'S                                           *\n//* ------------------------------------------------------------------*\n//ABNLIGNR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//* ------------------------------------------------------------------*\n//*        ASSEMBLER DD'S                                             *\n//* ------------------------------------------------------------------*\n//SYSPRINT DD DSN=&&PRT,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)\n//SYSIN    DD DSN=&&IN,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSPUNCH DD DUMMY\n//* ------------------------------------------------------------------*\n//*        DIS-ASSEMBLER DD'S                                         *\n//* ------------------------------------------------------------------*\n//DISDEBUG DD SYSOUT=*\n//DISPRINT DD SYSOUT=*\n//DISPUNCH DD DSN=..........,DISP=SHR,                  <--------------\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//DISMOD   DD DSN=.............,DISP=SHR                <--------------\n//*      1    1    2    2    3    3    4    4    5    5    6    6    7\n//* +....0....+....0....+....0....5....0....5....0....5....0....5....0..\n//DISIN    DD *\nLINES    55\nMODULE   MMMMMMM\nCSECT    CCCCCCC\n/*\n//\n./ ADD MEMBER=SAMPLE1\n* ------------------------------------------------------------------- *\n*                                                                     *\n*    There seems to be quite a bit of confusion on how to use the     *\n*    ASM START/ASM END statements to define DSECTs.                   *\n*                                                                     *\n*    This is a sample that will disassemble module DISASM04 of the    *\n*    disassembler itself.                                             *\n*                                                                     *\n*    Execute the disassembler with the following control statements.  *\n*    The SYSLIB DD must include the DISASM.MACLIB.                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLINES    55\nMODULE   DISASM\nCSECT    DISASM04\nUSING    DISASM00            R11\nUSING    ESDDATA             R4\nBASE     R12\nPREFIX   DASM\nSEQ LABEL\nASM START\n         COPY  DISASMGB\n         DISOPT COMLIST=ON,                                            +\n               DALIST=ON\nDISASM00 DISASM00 TYPE=DSECT\n         COPY  DISASMDA\n         COPY  REGEQU\nASM END\n./ ADD MEMBER=SAMPLE2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*    This is another sample using ASM START/ASM END that will         *\n*    disassemble CSECT DITTDAIR of DITTO.                             *\n*                                                                     *\n*    Execute the disassembler with the following control statements.  *\n*    The SYSLIB DD must include the DITTO.MACLIB.                     *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLINES    55\nMODULE   DITTO\nCSECT    DITTDAIR\nUSING    IOB                 R3        476       FFFF\nUSING    IHADCB              R4        476       FFFF\nUSING    UCB       UCBOB     R5        FE        FFFF\nUSING    DYNBLOK             R6\nUSING    DEB                 R7\nUSING    DITTCOMM            R11\nBASE     R12\nPREFIX   DITT\nSEQ LABEL\nASM START\nDITTCOMM DITTCOMM TYPE=DSECT\nDYNBLOK  DYNBLOK  TYPE=DSECT\nUCB      DSECT\n         IEFUCBOB\n         IEZIOB\nIOBLEN   EQU   *-IOB\n         IEZDEB LIST=YES\n         DCBD  DSORG=PS\nDYNDCBL  EQU   *-IHADCB\n         COPY  REGEQU\nASM END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DISASMAC": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99(\\x1f\\x00\\x99(\\x1f\\x079\\x03\\xdc\\x03\\xdc\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-08T00:00:00", "modifydate": "1999-10-08T07:39:00", "lines": 988, "newlines": 988, "modlines": 0, "user": "PGILLIS"}, "text": "./ ADD MEMBER=DBUGBLOK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DEBUG INTERFACE BLOCK                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&NAME    DBUGBLOK &TYPE=\n         AIF      ('&TYPE' EQ 'DSECT').DSECT\n&NAME    DS       0A\n         AGO      .NODSECT\n.DSECT   ANOP\n         AIF      (T'&NAME EQ 'O').NONAME\n&NAME    DSECT\n.NODSECT ANOP\nDBUGDATA DC    A(0)                DEBUG DATA ADDRESS\nDBUGCMD  DC    C' '                COMMAND\n$DBUG    EQU   C' '                .. NORMAL DEBUG\n$DBUGHD  EQU   C'H'                .. PRINT SUB-HEADING\n$DBUGPRT EQU   C'P'                .. PRINT\n         MEXIT\n.NONAME  ANOP\n         MNOTE    12,'NAME REQUIRED WHEN TYPE=DSECT'\n         MEND\n./ ADD MEMBER=DISASMDA\n         AIF ('&DAPRT' EQ 'ON').DA010\n         PRINT OFF\n.DA010   ANOP\n* ------------------------------------------------------------------- *\n*                                                                     *\n*     DISASM's data areas                                             *\n*                                                                     *\n*     There were so many different blocks that making up macros or    *\n*     copy members took more time than it was worth.  Most of the     *\n*     data areas are small, so it doesn't cost much to assemble them  *\n*     all in all the modules.                                         *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        BASE REGISTER DEFINITIONS                                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nBASEDSCT DSECT\nBASENEXT DS   A                   NEXT BASE BLOCK\nBASEEYE  DS   CL8                 EYE CATCHER\nBASEBEGN DS   XL4                 STARTING DISPLACEMENT\nBASEEND  DS   XL4                 ENDING DISPLACEMENT\nBASEDISP DS   XL4                 DISPLACEMENT BASE REFERS TO\nBASEREG  DS   X                   BASE REGISTER\nBASEL    EQU  *-BASEDSCT\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        DATA AREA DEFINITIONS                                        *\n*                                                                     *\n* ------------------------------------------------------------------- *\nDATADSCT DSECT\nDATANEXT DS   A                   NEXT DATA BLOCK\nDATAEYE  DS   CL8                 EYE CATCHER\nDATANAME DS   CL8                 DATA NAME (VCON AND Q TYPES)\nDATALBA  DS   A                   LABEL BLOCK ADDRESS FOR ADCON\nDATALBD  DS   XL4                 DISPLACEMENT FROM LABEL FOR ADCON\nDATABEGN DS   XL4                 STARTING DISPLACEMENT\nDATAEND  DS   XL4                 ENDING DISPLACEMENT\nDATALEN  DS   XL4                 LENGTH\nDATAFLAG DS   X                   SPECIAL FLAGS/INDICATORS\n$DATA31  EQU  X'80'               AD-CON WITH 31-BIT MODE BIT ON\nDATATYPE DS   X                   DATA TYPE\n$DATAUSR EQU  X'01'               .. USER DEFINED\n$DATAACN EQU  X'02'               .. A-CON\n$DATAVCN EQU  X'03'               .. V-CON\n$DATAINT EQU  X'04'               .. INTERNALLY DETECTED\n$DATACXD EQU  X'05'               .. PSEUDO AREA SIZE\n$DATAQ   EQU  X'06'               .. PSEUDO AREA DISPLACEMENT\nDATAL    EQU  *-DATADSCT\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        DSECT DEFINITIONS                                            *\n*                                                                     *\n* ------------------------------------------------------------------- *\nDSCTDSCT DSECT\nDSCTNEXT DS   A                   NEXT DSECT BLOCK\nDSCTEYE  DS   CL8                 EYE CATCHER\nDSCTNAME DS   CL8                 DSECT'S NAME\nDSCTLBA  DS   A                   FIRST LABEL BLOCK'S ADDRESS\nDSCTL    EQU  *-DSCTDSCT\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        EQU DEFINITIONS                                              *\n*                                                                     *\n* ------------------------------------------------------------------- *\nEQUDATA  DSECT\nEQUNEXT  DS    A                  NEXT EQU BLOCK'S ADDRESS\nEQUEYE   DS    CL8                EYECATCHER\nEQULABEL DS    CL8                LABEL ON EQU STATEMENT\nEQUVALUE DS    X                  ASSOCIATED EQU VALUE\nEQUL     EQU   *-EQUDATA\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        ESD REFERENCES                                               *\n*                                                                     *\n* ------------------------------------------------------------------- *\nESDDATA  DSECT\nESDNEXT  DS    A                  NEXT ESD BLOCK'S ADDRESS\nESDEYE   DS    CL8                EYE CATCHER\nESDID    DS    H                  ESD ID\nESDNAME  DS    CL8                ENTRY POINT NAME\nESDTYPE  DS    X                  TYPE\n$ESDSD   EQU   X'00'              .. EXTERNAL SYMBOL\n$ESDER   EQU   X'02'              .. UNRESOLVED EXTERNAL REFERENCE\n$ESDLR   EQU   X'03'              .. LABEL REFERENCE\n$ESDPC   EQU   X'04'              .. PRIVATE CODE DEFINITION\n$ESDCM   EQU   X'05'              .. COMMON MODULE\n$ESDPR   EQU   X'06'              .. PSEUDO REGISTER\n$ESDNULL EQU   X'07'              .. NULL\n$ESDWX   EQU   X'0A'              .. UNRESOLVED WEAK EXTERNAL REFERENCE\n$ESDOV   EQU   X'14'              .. OVERLAY SEGMENT TABLE\nESDADDR  DS    AL3                ADDRESS OF ENTRY POINT\nESDSEG   DS    X                  SEGMENT NUMBER\nESDLEN   DS    AL3                ENTRY LENGTH\nESDL     EQU   *-ESDNAME          ESD DATA LENGTH\nESDDATAL EQU   *-ESDDATA\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        LABEL BLOCK                                                  *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLABLDSCT DSECT\nLABLNEXT DS   A                   NEXT LABEL BLOCK\nLABLEYE  DS   CL8                 EYE CATCHER\nLABLNAME DS   CL8                 LABEL NAME\nLABLDISP DS   XL4                 DISPLACEMENT FROM BASE\nLABLEQU  DS   A                   FIRST EQU BLOCK ADDRESS\nLABLTYPE DS   C                   LABEL TYPE\n$LABLD   EQU  C'D'                .. LABEL AT DATA\n$LABLE   EQU  C'E'                .. LABEL FROM AN ESD ENTRY\n$LABLI   EQU  C'I'                .. LABEL AT AN INSTRUCTION\n$LABLR   EQU  C'R'                .. LABEL FROM AN RLD ENTRY\nLABLL    EQU  *-LABLDSCT\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        OPCODE DEFINITIONS                                           *\n*                                                                     *\n* ------------------------------------------------------------------- *\nOPDSECT  DSECT\nOPMACH   DS    CL2           OPCODE\nOPMNEM   DS    CL6           MNEMONIC\nOPLENGTH DS    H             INSTRUCTION LENGTH\nOPFORM   DS    X             FORMAT\n$OPRR1   EQU   X'00'         .. RR FORMAT 1 (R1,R2)\n$OPRR2   EQU   X'01'         .. RR FORMAT 2 (SVC'S)\n$OPRR3   EQU   X'02'         .. RR FORMAT 3 (BRANCHES)\n$OPRX    EQU   X'03'         .. RX FORMAT\n$OPS     EQU   X'04'         .. S FORMAT\n$OPSI    EQU   X'05'         .. SI (IMMEDIATE) FORMAT\n$OPRS1   EQU   X'06'         .. RS FORMAT 1 (SHIFTS)\n$OPRS2   EQU   X'07'         .. RS FORMAT 2 (BXLE, BXH,  )\n$OPRS3   EQU   X'08'         .. RS FORMAT 3 (MASK TYPE.. CLM, ICM..)\n$OPSS1   EQU   X'09'         .. SS FORMAT 1 (CHARACTER)\n$OPSS2   EQU   X'0A'         .. SS FORMAT 2 (PACKED DECIMAL)\n$OPSS3   EQU   X'0B'         .. SS FORMAT 3 (MVCK, MVCS, MVCP)\n$OPSS4   EQU   X'0C'         .. SS FORMAT 4 (SRP)\n$OPB2    EQU   X'0D'         .. B2 (NO OPERANDS)\n$OPB2S   EQU   X'0E'         .. B2 S-FORMAT\n$OPB2R   EQU   X'0F'         .. B2 R FORMAT\n$OPB2RR  EQU   X'10'         .. B2 RR FORMAT\nOPFLAGS  DS    X             FLAGS\n$OPEXT   EQU   X'80'         .. EXTENDED MNEMONICS\n$OPSVC   EQU   X'40'         .. SVC\n$OPNCMNT EQU   X'20'         .. NO COMMENT\n$OPREF   EQU   X'10'         .. GENERATES A LABEL REFERENCE\n$OPCCA   EQU   X'08'         .. SETS CONDITION CODE, ARITHMETIC\n$OPCCC   EQU   X'04'         .. SETS CONDITION CODE, COMPARE\n$OPCCL   EQU   X'02'         .. SETS CONDITION CODE, LOGICAL\n$OPFLOAT EQU   X'01'         .. FLOATING POINT OPCODE\nOPREGS   DS    X             REGISTER RESTRICTIONS\n$OP1EVEN EQU   X'80'         .. OPERAND 1 MUST BE EVEN\n$OP10246 EQU   X'40'         .. OPERAND 1 MUST BE 0, 2, 4, OR 6\n$OP104   EQU   X'20'         .. OPERAND 1 MUST BE 0 OR 4\n$OP2EVEN EQU   X'08'         .. OPERAND 2 MUST BE EVEN\n$OP20246 EQU   X'04'         .. OPERAND 2 MUST BE 0, 2, 4, OR 6\n$OP204   EQU   X'02'         .. OPERAND 2 MUST BE 0 OR 4\nOPCMNT   DS    CL25          COMMENT IF PRESENT\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        INSTRUCTION OPERAND REFERENCES                               *\n*                                                                     *\n* ------------------------------------------------------------------- *\nREFDSCT  DSECT\nREFNEXT  DS   A                   NEXT REFERENCE BLOCK\nREFEYE   DS   CL8                 EYE CATCHER\nREFOPER1 DS   A                   OPERAND 1 REFERENCE\nREFOPER2 DS   A                   OPERAND 2 REFERENCE\nREFDISP1 DS   XL4                 DISPLACEMENT FROM LABEL\nREFDISP2 DS   XL4                 DISPLACEMENT FROM LABEL\nREFDISPI DS   XL4                 REFERENCING INSTRUCTIONS DISPLACEMENT\nREFL     EQU  *-REFDSCT\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        RELOCATION DATA REFERENCES                                   *\n*                                                                     *\n* ------------------------------------------------------------------- *\nRLDDATA  DSECT\nRLDNEXT  DS    A                  NEXT RLD BLOCK'S ADDRESS\nRLDEYE   DS    CL8                EYE CATCHER\nRLDESD   DS    A                  CORRESPONDING ESD'S ADDRESS\nRLDLEN   DS    H                  CONSTANT'S LENGTH\nRLDDISP  DS    XL4                DISPLACEMENT TO CONSTANT\nRLDTYPE  DS    X                  RLD TYPE\n$RLDACON EQU   X'00'              .. ADCON\n$RLDVCON EQU   X'10'              .. VCON\n$RLDPSDP EQU   X'20'              .. PSEUDO AREA DISPLACEMENT (Q)\n$RLDPSSZ EQU   X'30'              .. PSEUDO AREA SIZE         (CXD)\n$RLDER1  EQU   X'80'              .. UNRESOLVED REFERENCE\n$RLDER2  EQU   X'90'              .. UNRESOLVED REFERENCE\nRLDPTR   DS    XL2                RLD POINTER\nRLDPP    DS    XL2                RLD POSITION POINTER\nRLDDIR   DS    C                  DIRECTION (+ OR -)\nRLDDATAL EQU   *-RLDDATA          RLD DATA LENGTH\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        USING DEFINITIONS                                            *\n*                                                                     *\n* ------------------------------------------------------------------- *\nUSNGDSCT DSECT\nUSNGNEXT DS   A                   NEXT USING BLOCK\nUSNGEYE  DS   CL8                 EYE CATCHER\nUSNGDSNM DS   CL8                 DSECT'S NAME\nUSNGLBNM DS   CL8                 LABEL WITHIN THE DSECT\nUSNGDSA  DS   A                   RELATED DSECT BLOCK'S ADDRESS\nUSNGLBA  DS   A                   LABEL BLOCK'S ADDRESS\nUSNGDISP DS   XL4                 LABEL'S DISPLACEMENT INTO THE DSECT\nUSNGBASE DS   X                   BASE\nUSNGFLAG DS   X                   FLAGS\n$USNGND  EQU  X'80'               .. NO DISPLACEMENTS\nUSNGBEGN DS   XL4                 STARTING DISPLACEMENT\nUSNGEND  DS   XL4                 ENDING DISPLACEMENT\nUSNGL    EQU  *-USNGDSCT\n         AIF  ('&DAPRT' EQ 'ON').DA020\n         PRINT ON\n.DA020   ANOP\n./ ADD MEMBER=DISASMGB\n* ------------------------------------------------------------------- *\n*                                                                     *\n*     GLOBAL OPTIONS.  SEE MACRO DISOPT FOR EXPLANATION OF OPTIONS.   *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         GBLA  &TRNBRG,&MAXL,&MINL\n         GBLC  &TROPT,&DAPRT,&COMPRT\n         DISOPT COMLIST=OFF,        ASSEMBLER'S NAME                   +\n               DALIST=ON,                 PRINT DATA AREA              +\n               MAXLINE=55,          DEFAULT IS 55 LINES PER PAGE       +\n               MINLINE=10,          MINIMUM LINE COUNT ALLOWABLE IS 10 +\n               TRACE=ON,            GENERATE TRACE                     +\n               TRNBR=1000           1000 TRACE ENTRIES\n./ ADD MEMBER=DISASM00\n*---------------------------------------------------------------------*\n*                                                                     *\n*          COMMON AREA MAPPING MACRO                                  *\n*                                                                     *\n*     This macro will generate either the 'common' module CSECT or    *\n*     a DSECT to map the 'common' module.  'Common' is used for       *\n*     constants and work areas that are required by several modules   *\n*     allowing some elimination of duplicated data and to allow       *\n*     inter-module communication.                                     *\n*                                                                     *\n*     The trace table code is also incorporated into the 'DISASM00'.  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&NAME    DISASM00 &TYPE=\n         GBLA  &TRNBRG,&MAXL,&MINL\n         GBLC  &TROPTG,&DAPRT,&COMPRT,&ASMNAME\n         AIF   (T'&NAME EQ 'O').NONAME\n         AIF   ('&TYPE' EQ 'CSECT').CSECT\n         AIF   ('&TYPE' EQ 'DSECT').DSECT\n         MNOTE 12,'INVALID TYPE'\n         MEXIT\n.CSECT   ANOP\n&NAME    CSECT\n         AGO   .NODSECT\n.DSECT   ANOP\n         AIF   ('&COMPRT' EQ 'ON').PRT010\n         PRINT OFF\n.PRT010  ANOP\n&NAME    DSECT\n.NODSECT ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*          Double word for CVB/CVD                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nCOMMDWRD DC    D'0'\n*---------------------------------------------------------------------*\n*                                                                     *\n*          ADDRESS CONSTANTS                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         DC    CL8'DISASM00'\nACOMM    DC    A(DISASM00)         COMMON MODULE\n         DC    CL8'DISASM01'\nA01      DC    V(DISASM01)         MAINLINE MODULE\n         DC    CL8'DISASM02'\nA02      DC    V(DISASM02)         PARAMETER READER\n         DC    CL8'DISASM03'\nA03      DC    V(DISASM03)         MODULE READER\n         DC    CL8'DISASM04'\nA04      DC    V(DISASM04)         CESD record processor\n         DC    CL8'DISASM05'\nA05      DC    V(DISASM05)         RLD record processor\n         DC    CL8'DISASM06'\nA06      DC    V(DISASM06)         MODULE TEXT PRINTER\n         DC    CL8'DISASM07'\nA07      DC    V(DISASM07)         DSECT INTERPRETER\n         DC    CL8'DISASM08'\nA08      DC    V(DISASM08)         ASSIGN LABELS\n         DC    CL8'DISASM09'\nA09      DC    V(DISASM09)         SOURCE GENERATOR\n         DC    CL8'DISASMB2'\nAB2      DC    V(DISASMB2)         OPCODE 'B2' INTERPRETER\n         DC    CL8'DISASMDB'\nADB      DC    V(DISASMDB)         DEBUG\n         DC    CL8'DISASMOP'\nAOP      DC    V(DISASMOP)         OPCODE TABLE\n         DC    CL8'DISASMPR'\nAPR      DC    V(DISASMPR)         PRINT MODULE ADDRESS\n         DC    CL8'DISASMRR'\nARR      DC    V(DISASMRR)         REGISTER CHECKER\n*---------------------------------------------------------------------*\n*                                                                     *\n*          TRACE CONTROL                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         DS    0A\n         DC    CL4'1STX'           FIRST TRACE ENTRY\nTR1ST    DC    A(0)\n         DC    CL4'LAST'           LAST TRACE ENTRY\nTRLAST   DC    A(0)\n         DC    CL4'CURR'           CURRENT TRACE ENTRY\nTRCURR   DC    A(0)\nTRADDR   DC    A(0)                TRACE TABLE STORAGE ADDRESS\nTRR14    DC    A(0)                REGISTER 14 SAVE AREA\nTRDATA1  DC    CL8' '              TRACE DATA ITEM 1\nTRDATA2  DC    CL8' '              TRACE DATA ITEM 2\nTRSIZE   DC    A(&TRNBRG*32)       TRACE TABLE SIZE\n*---------------------------------------------------------------------*\n*                                                                     *\n*          GLOBAL DATA                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nCOMMIO   DC    A(0)                I/O BUFFER ADDRESS\n$IOSIZE  EQU   32760               I/O BUFFER SIZE\nCOMMESD  DC    A(0)                EXTERNAL SYMBOL TABLE ANCHOR\nCOMMRLD  DC    A(0)                RLD TABLE ANCHOR\nCOMMUSNG DC    A(0)                USING TABLE ANCHOR\nCOMMDSCT DC    A(0)                DSECT TABLE ANCHOR\nCOMMBASE DC    A(0)                BASE TABLE ANCHOR\nCOMMDATA DC    A(0)                DATA TABLE ANCHOR\nCOMMDISP DC    A(0)                INSTRUCTION DISPLACEMENT TABLE\nCOMMREF  DC    A(0)                REFERENCE TABLE ANCHOR\nCOMMLABL DC    A(0)                LABEL TABLE ANCHOR\nCOMMCSAD DC    A(0)                CSECT ADDRESS\nCOMMCSEP DC    A(0)                LINK EDIT ASSIGNED ENTRY POINT\nCOMMCSEA DC    A(0)                CSECT ENDING ADDRESS\nCOMMCSLN DC    A(0)                CSECT LENGTH\nCOMMTXT  DC    A(0)                TEXT'S STORAGE ADDRESS\n*---------------------------------------------------------------------*\n*                                                                     *\n*      Sub-heading length is actually a flag byte and a length byte   *\n*                                                                     *\n*        If first byte is X'00', heading is to be centered            *\n*        If first byte is X'FF', heading is not to be centered        *\n*                                                                     *\n*      Second byte is the length for centered and non-centered        *\n*                                                                     *\n*---------------------------------------------------------------------*\nCOMMH4   DC    H'4'                CONSTANT\nCOMMH8   DC    H'8'                CONSTANT\nCOMMH32  DC    H'32'               CONSTANT\nCOMMSUBL DC    H'0'                SUB HEADING LENGTH\nCOMMPFXL DC    H'0'                LABEL PREFIX LENGTH\nCOMMESID DS    XL2                 CSECT's ESDID\nCOMMFLAG DC    X'00'               GLOBAL CONTROL FLAGS\n$ABORT   EQU   X'80'               .. SERIOUS ERROR, ABORT\n$ERROR   EQU   X'40'               .. ERROR HAS OCCURRED\n$CSECT   EQU   X'20'               .. CSECT LOCATED\n$ABEND   EQU   X'10'               .. ABEND AT EXIT\n$ASMIN   EQU   X'08'               .. ASSEMBLER INPUT PRESENT\n$SEQLABL EQU   X'04'               .. SEQUENTIALLY NUMBERED LABELS\n$NOFLOAT EQU   X'02'               .. NO FLOATING POINT INSTRUCTIONS\nCOMMDD   DC    X'00'               DD STATEMENT FLAGS\n$PRTDD   EQU   X'80'               .. DISPRINT DD PRESENT\n$INDD    EQU   X'40'               .. DISIN DD PRESENT\n$MODDD   EQU   X'20'               .. DISMOD DD PRESENT\n$PUNCHDD EQU   X'10'               .. DISPUNCH DD PRESENT\n$DEBUGDD EQU   X'08'               .. DISDEBUG DD PRESENT\nCOMMMOD  DC    CL8' '              MODULE NAME\nCOMMCSNM DC    CL8' '              CSECT NAME\nCOMMPFX  DC    CL4' '              LABEL PREFIX\nCOMMSUBH DC    CL133' '            SUB-HEADING\nCOMMDBSH DC    CL35' '             DEBUG SUB-HEADING\nCOMM0F0F DC    8X'0F'\nCOMM1F1F DC    8X'1F'\nCOMMBLKS DC    80C' '\nCOMMHXCH DC    C'0123456789ABCDEF'\nCOMMCHHX DC    X'000A0B0C0D0E0F000000000000000000'\n         DC    X'00010203040506070809000000000000'\nCOMMNBR  DS    0C\n         DC    C'0 '\n         DC    C'1 '\n         DC    C'2 '\n         DC    C'3 '\n         DC    C'4 '\n         DC    C'5 '\n         DC    C'6 '\n         DC    C'7 '\n         DC    C'8 '\n         DC    C'9 '\n         DC    C'10'\n         DC    C'11'\n         DC    C'12'\n         DC    C'13'\n         DC    C'14'\n         DC    C'15'\n         DC    C'16'\n*---------------------------------------------------------------------*\n*                                                                     *\n*          Printable characters                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nCOMMPRT  DC    256X'FF'\n         ORG   COMMPRT+X'40'\n         DC    X'00'\n         ORG   COMMPRT+X'4A'\n         DC    6X'00'\n         ORG   COMMPRT+X'5A'\n         DC    6X'00'\n         ORG   COMMPRT+X'60'\n         DC    2X'00'\n         ORG   COMMPRT+X'6A'\n         DC    6X'00'\n         ORG   COMMPRT+X'79'\n         DC    4X'00'\n         ORG   COMMPRT+X'7E'\n         DC    2X'00'\n         ORG   COMMPRT+X'81'\n         DC    9X'00'\n         ORG   COMMPRT+X'91'\n         DC    9X'00'\n         ORG   COMMPRT+X'A2'\n         DC    8X'00'\n         ORG   COMMPRT+X'C0'\n         DC    10X'00'\n         ORG   COMMPRT+X'D0'\n         DC    10X'00'\n         ORG   COMMPRT+X'E2'\n         DC    8X'00'\n         ORG   COMMPRT+X'F0'\n         DC    10X'00'\n         ORG   COMMPRT+256\n*---------------------------------------------------------------------*\n*                                                                     *\n*          Non-printable characters                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\nCOMMNPRT DC    256X'00'\n         ORG   COMMNPRT+X'4A'\n         DC    X'FF'\n         ORG   COMMNPRT+X'4C'\n         DC    4X'FF'\n         ORG   COMMNPRT+X'5A'\n         DC    6X'FF'\n         ORG   COMMNPRT+X'60'\n         DC    2X'FF'\n         ORG   COMMNPRT+X'6A'\n         DC    X'FF'\n         ORG   COMMNPRT+X'6C'\n         DC    4X'FF'\n         ORG   COMMNPRT+X'79'\n         DC    4X'FF'\n         ORG   COMMNPRT+X'7E'\n         DC    2X'FF'\n         ORG   COMMNPRT+X'C0'\n         DC    10X'FF'\n         ORG   COMMNPRT+X'D0'\n         DC    10X'FF'\n         ORG   COMMNPRT+X'E2'\n         DC    8X'FF'\n         ORG   COMMNPRT+X'F0'\n         DC    10X'FF'\n         ORG   COMMNPRT+256\nCOMMMAXL DC    PL3'&MAXL'          MAXIMUM LINES PER PAGE\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*          ADD TRACE ENTRY                                            *\n*                                                                     *\n*  During program initialization, DISASM01 acquires storage for the   *\n*  trace table and sets COMM1ST, COMMLAST, and COMMCURR.  DISASM01    *\n*  also sets R11 to the address of DISASM00 and all other modules     *\n*  depend on this remaining unchanged.  Any module except this        *\n*  module may call the trace routine.  Macro ITRACE generates the     *\n*  calling sequence.  R14 is the only register altered by the trace   *\n*  macro.                                                             *\n*                                                                     *\n*  The trace table is a \"wrap-around\" table.  COMM1ST is the first    *\n*  entry's address, COMMLAST is the last entry's address, and         *\n*  COMMCURR is the address of the last entry added to the table.      *\n*  When a trace entry is added to the table, the calling module's     *\n*  name, an 8-byte ID, and up to 2 8-byte fields are captured.        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*      This code depends on:                                          *\n*           R11  'DISASM00' address                                   *\n*           R12  current module's base address                        *\n*                and the module's name must be at 10 bytes (0A hex)   *\n*                into the module                                      *\n*           R14  trace id's address and R14 + 8 will be the return    *\n*                address                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nTRACE000 DS    0H\n         USING &NAME,R11           DEFINE BASE\n         USING TRENTRY,R1          DEFINE BASE\n         STM   R0,R15,TRCESAVE     SAVE ALL REGISTERS\n         ICM   R1,15,TRCURR        CURRENT TRACE ENTRY\n         BZ    TRACE020            NO TRACE TABLE\n         OC    0(TRENTRYL,R1),0(R1)    EMPTY ENTRY?\n         BZ    TRACE010            YES.. USE THIS ENTRY\n         LA    R1,TRENTRYL(R1)     NEXT TRACE ENTRY\n         C     R1,TRLAST           BEYOND END OF TABLE?\n         BNH   TRACE010            NO\n         L     R1,TR1ST            'WRAP' TRACE TABLE\nTRACE010 DS    0H\n         ST    R1,TRCURR           SAVE CURRENT TRACE ENTRY ADDRESS\n         MVC   TREMOD,10(R12)      COPY MODULE NAME\n         MVC   TREID,0(R14)        COPY TRACE ID\n         MVC   TREDATA1,TRDATA1    COPY TRACE DATA 1\n         MVC   TREDATA2,TRDATA2    COPY TRACE DATA 2\n         XC    TRDATA1,TRDATA1     CLEAR TRACE DATA\n         XC    TRDATA2,TRDATA2     CLEAR TRACE DATA\nTRACE020 DS    0H\n         LM    R0,R15,TRCESAVE     RESTORE ALL REGISTERS\n         B     8(R14)              RETURN\nTRCESAVE DS    16F                 REGISTER SAVE AREA\n         LTORG\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*          TRACE TABLE ENTRY                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\nTRENTRY  DSECT\nTREMOD   DS    CL8                 MODULE NAME\nTREID    DS    CL8                 TRACE ID\nTREDATA1 DS    CL8                 TRACE DATA 1\nTREDATA2 DS    CL8                 TRACE DATA 2\nTRENTRYL EQU   *-TRENTRY           ENTRY LENGTH\n         SPACE 2\n         AIF   ('&COMPRT' EQ 'ON').PRT020\n         PRINT ON\n.PRT020  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*          ABEND REASON CODES                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nABEND001 EQU   1                   REQUESTED VIA AN ABEND STATEMENT\nABEND002 EQU   2                   UNKNOWN RETURN CODE FROM BLDL\nABEND003 EQU   3                   UNKNOWN RLD ITEM TYPE\nABEND004 EQU   4                   RLD DATA REMAINING WENT NEGATIVE\nABEND005 EQU   5                   ATTEMPT TO GEN AN INSTR ON ODD ADDR\nABEND006 EQU   6                   UNKNOWN B2 INSTRUCTION IN DISASMB2\n         MEXIT\n.NONAME  ANOP\n         MNOTE 12,'NAME IS REQUIRE WHEN TYPE=DSECT'\n.MEXIT   ANOP\n         MEXIT\n         MEND\n./ ADD MEMBER=DISOPT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*         GLOBAL OPTIONS                                             *\n.*                                                                    *\n.*    THESE OPTIONS ALLOW CUSTOMIZED GENERATION OF DISASM.            *\n.*                                                                    *\n.*     OPTIONS YOU CAN SET ARE:                                       *\n.*                                                                    *\n.*           &TRACE   ON  - ITRACE MACROS WILL GENERATE THE CODE TO   *\n.*                          CAPTURE THE \"ID\" AND DATA1/RDATA1 AND     *\n.*                          DATA2/RDATA2, DISASM01 WILL ACQUIRE AND   *\n.*                          INITIALIZE THE TRACE TABLE CONTROL DATA   *\n.*                          IN DISASM00.                              *\n.*                    OFF - ITRACE MACROS WILL GENERATE NO CODE AT    *\n.*                          ALL.  DISASM01 WILL NOT ACQUIRE THE       *\n.*                          TRACE TABLE STORAGE.  GENERATING DISASM   *\n.*                          WITH &TRACE=OFF WILL REDUCE THE SIZE OF   *\n.*                          THE MODULE BY ABOUT 2K.                   *\n.*                                                                    *\n.*           &TRNBR   SPECIFIES THE NUMBER OF TRACE TABLE ENTRIES.    *\n.*                                                                    *\n.*           &MAXLINE SPECIFIES THE DEFAULT LINE COUNT PER PAGE ON    *\n.*                    DISPRINT AND DISDEBUG.                          *\n.*                                                                    *\n.*           &MINLINE SPECIFIES THE MINIMUM NUMBER OF LINES A USER    *\n.*                    CAN REQUEST VIA THE LINE/LINES/MAXLINES STATE-  *\n.*                    MENT.                                           *\n.*                                                                    *\n.*           &COMLIST ON  - THE COMMON DATA AREA LISTING WILL BE      *\n.*                          PRINTED ON THE ASSEMBLER LISTING.         *\n.*                    OFF - THE AREAS MAPPED BY DISASMDA WILL NOT     *\n.*                          BE PRINTED ON THE ASSEMBLER LISTING.      *\n.*                    ** NOTE THE COMLIST OPTION DOES NOT APPLY TO    *\n.*                    ** TO CSECT DISASM00.                           *\n.*                                                                    *\n.*                                                                    *\n.*           &DALIST  ON  - THE AREAS MAPPED BY DISASMDA WILL BE      *\n.*                          PRINTED ON THE ASSEMBLER LISTING.         *\n.*                    OFF - THE AREAS MAPPED BY DISASMDA WILL NOT     *\n.*                          BE PRINTED ON THE ASSEMBLER LISTING.      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         MACRO\n&NAME    DISOPT &COMLIST=OFF,                                          +\n               &DALIST=OFF,                                            +\n               &MAXLINE=55,                                            +\n               &MINLINE=10,                                            +\n               &TRACE=ON,                                              +\n               &TRNBR=1000\n         GBLA &TRNBRG,&MAXL,&MINL\n         GBLC &TROPT,&DAPRT,&COMPRT\n         LCLA &ERROR\n&ERROR   SETA 0\n         AIF  (T'&TRACE EQ 'O').OPT010\n         AIF  ('&TRACE' EQ 'ON').OPT020\n         AIF  ('&TRACE' EQ 'OFF').OPT020\n         MNOTE 12,'TRACE MUST BE EITHER -ON- OR -OFF-'\n&ERROR   SETA 1\n         AGO  .OPT030\n.OPT010  ANOP\n         MNOTE 12,'TRACE OPTION MUST BE SPECIFIED'\n&ERROR   SETA 1\n         AGO  .OPT030\n.OPT020  DS   0H\n&TROPT   SETC '&TRACE'\n.OPT030  ANOP\n         AIF  (T'&TRNBR EQ 'O').OPT040\n         AIF  (&TRNBR LT 0).OPT050\n         AIF  (&TRNBR GT 9999).OPT060\n&TRNBRG  SETA &TRNBR\n         AGO  .OPT070\n.OPT040  ANOP\n         MNOTE 12,'TRNBR MUST BE SPECIFIED'\n&ERROR   SETA 1\n         AGO  .OPT070\n.OPT050  ANOP\n         MNOTE 12,'TRNBR CANNOT BE LESS THAN ZERO'\n&ERROR   SETA 1\n         AGO  .OPT070\n.OPT060  ANOP\n         MNOTE 12,'TRNBR CANNOT BE GREATER THAN 9999'\n&ERROR   SETA 1\n.OPT070  ANOP\n         AIF  (T'&MAXLINE EQ 'O').OPT080\n         AIF  (&MAXLINE LT 0).OPT090\n         AIF  (&MAXLINE GT 9999).OPT100\n&MAXL    SETA &MAXLINE\n         AGO  .OPT110\n.OPT080  ANOP\n         MNOTE 12,'MAXLINE MUST BE SPECIFIED'\n&ERROR   SETA 1\n         AGO  .OPT110\n.OPT090  ANOP\n         MNOTE 12,'MAXLINE CANNOT BE LESS THAN 0'\n&ERROR   SETA 1\n         AGO  .OPT110\n.OPT100  ANOP\n         MNOTE 12,'MAXLINE CANNOT BE GREATER THAN 9999'\n&ERROR   SETA 1\n.OPT110  ANOP\n         AIF  (T'&MINLINE EQ 'O').OPT120\n         AIF  (&MINLINE LT 0).OPT130\n         AIF  (&MINLINE GT &MAXLINE).OPT140\n&MINL    SETA &MINLINE\n         AGO  .OPT150\n.OPT120  ANOP\n         MNOTE 12,'MINLINE MUST BE SPECIFIED'\n&ERROR   SETA 1\n         AGO  .OPT150\n.OPT130  ANOP\n         MNOTE 12,'MINLINE CANNOT BE LESS THAN ZERO'\n&ERROR   SETA 1\n         AGO  .OPT150\n.OPT140  ANOP\n         MNOTE 12,'MINLINE CANNOT BE GREATER THAN MAXLINE'\n&ERROR   SETA 1\n.OPT150  ANOP\n         AIF  (T'&DALIST EQ 'O').OPT160\n         AIF  ('&DALIST' EQ 'ON').OPT170\n         AIF  ('&DALIST' EQ 'OFF').OPT170\n         MNOTE 12,'DALIST MUST BE -ON- OR -OFF-'\n&ERROR   SETA 1\n         AGO  .OPT180\n.OPT160  ANOP\n         MNOTE 12,'DALIST MUST BE SPECIFIED'\n&ERROR   SETA 1\n         AGO  .OPT180\n.OPT170  ANOP\n&DAPRT   SETC '&DALIST'\n.OPT180  ANOP\n         AIF  (T'&COMLIST EQ 'O').OPT190\n         AIF  ('&COMLIST' EQ 'ON').OPT200\n         AIF  ('&COMLIST' EQ 'OFF').OPT200\n         MNOTE 12,'COMLIST MUST BE -ON- OR -OFF-'\n&ERROR   SETA 1\n         AGO  .OPT210\n.OPT190  ANOP\n         MNOTE 12,'COMLIST MUST BE SPECIFIED'\n&ERROR   SETA 1\n         AGO  .OPT210\n.OPT200  ANOP\n&COMPRT  SETC  '&COMLIST'\n.OPT210  ANOP\n         AIF  (&ERROR EQ 0).EXIT\n         MNOTE 12,'ERRORS IN SPECIFYING OPTIONS'\n.EXIT    ANOP\n         MEND\n         DISOPT TRACE=ON,                                              +\n               TRNBR=1000,                                             +\n               MAXLINE=100,                                            +\n               MINLINE=10,                                             +\n               DALIST=OFF\n./ ADD MEMBER=ITRACE\n.* ------------------------------------------------------------------*\n.*                                                                   *\n.*                        TRACE MACRO                                *\n.*                                                                   *\n.*       The trace function always captures the CSECT name (taken    *\n.*       from the module prefix data) and a TRACE ID (specified on   *\n.*       this macro).                                                *\n.*                                                                   *\n.*       One or two data elements (8 bytes each) may be captured at  *\n.*       any trace point.  The data to be captured may be specified  *\n.*       in either of two ways: DATA1 or RDATA1 and DATA2 or RDATA2. *\n.*       DATA1 and RDATA1 are mutually exclusive as are DATA2 and    *\n.*       RDATA2.  DATA1 and DATA2 specify the address of data to be  *\n.*       captured, RDATA1 and RDATA2 specify a register whose        *\n.*       contents are to be captured.                                *\n.*                                                                   *\n.*       For example:                                                *\n.*                                                                   *\n.*                 ITRACE ID=POINTA,DATA1=VALUE1,RDATA2=R4           *\n.*                                                                   *\n.*          In this case the trace entry would include the CSECT     *\n.*          name, the ID data \"POINTA\", 8 bytes of data beginning    *\n.*          at VALUE1's address and the contents of register 4.      *\n.*                                                                   *\n.* ------------------------------------------------------------------*\n         MACRO\n&NAME    ITRACE &ID=,&DATA1=,&DATA2=,&RDATA1=,&RDATA2=\n         GBLC  &TROPT\n         AIF   (T'&DATA1 NE 'O' AND T'&RDATA1 NE 'O').ERR0010\n         AIF   (T'&DATA2 NE 'O' AND T'&RDATA2 NE 'O').ERR0020\n         AIF   ('&TROPT' EQ 'OFF').MEXIT\n         AIF   (T'&DATA1 EQ 'O').DATA020\n         AIF   ('&DATA1'(1,1) EQ '(').DATA010\n         LA    R14,&DATA1         DATA ADDRESS\n         MVC   TRDATA1,0(R14)     MOVE DATA\n         AGO   .DATA030\n.DATA010 ANOP\n         MVC   TRDATA1,0&DATA1    MOVE DATA\n         AGO   .DATA030\n.DATA020 ANOP\n         AIF   (T'&RDATA1 EQ 'O').DATA030\n         STCM  &RDATA1,15,TRDATA1\n.DATA030 ANOP\n         AIF   (T'&DATA2 EQ 'O').DATA050\n         AIF   ('&DATA2'(1,1) EQ '(').DATA040\n         LA    R14,&DATA2         DATA ADDRESS\n         MVC   TRDATA2,0(R14)     MOVE DATA\n         AGO   .DATA060\n.DATA040 ANOP\n         MVC   TRDATA2,0&DATA2    MOVE DATA\n         AGO   .DATA060\n.DATA050 ANOP\n         AIF   (T'&RDATA2 EQ 'O').DATA060\n         STCM  &RDATA2,15,TRDATA2\n.DATA060 ANOP\n         BAL   R14,TRACE000       ENTER TRACE ROUTINE\n         AIF      (T'&ID EQ 'O').NOID\n&NAME    DC    CL8'&ID'           TRACE ID\n         AGO   .ID\n.NOID    ANOP\n         MNOTE 4,'NO ID GIVEN, ''**NO ID**'' GENERATED'\n&NAME    DC    CL8'**NOID**'\n.ID      ANOP\n         MEXIT\n.ERR0010 ANOP\n         MNOTE 12,'DATA1 AND RDATA1 ARE MUTUALLY EXCLUSIVE'\n         MEXIT\n.ERR0020 ANOP\n         MNOTE 12,'DATA2 AND RDATA2 ARE MUTUALLY EXCLUSIVE'\n.MEXIT   ANOP\n         MEXIT\n         MEND\n./ ADD MEMBER=OPCODE\n         MACRO\n         OPCODE &MACH,                                                 +\n               &MNEM,                                                  +\n               &FORMAT,                                                +\n               &LENGTH,                                                +\n               &COMMENT,                                               +\n               &FLAGS=,                                                +\n               &REGS=,                                                 +\n               &TYPE=DEFINE\n         GBLB &OPSW\n         GBLC &OPTBL(256),&HEXTBL(16)\n         LCLA &SUB1,&SUB2,&SUB3\n         LCLC &OP1,&OP2,&OPTS\n         AIF  (&OPSW).LBL020\n&OPSW    SETB 1\n&SUB1    SETA 1\n.LBL010  ANOP\n&OPTBL(&SUB1) SETC '0'\n&SUB1    SETA &SUB1+1\n         AIF  (&SUB1 LE 256).LBL010\n&HEXTBL(01) SETC '0'\n&HEXTBL(02) SETC '1'\n&HEXTBL(03) SETC '2'\n&HEXTBL(04) SETC '3'\n&HEXTBL(05) SETC '4'\n&HEXTBL(06) SETC '5'\n&HEXTBL(07) SETC '6'\n&HEXTBL(08) SETC '7'\n&HEXTBL(09) SETC '8'\n&HEXTBL(10) SETC '9'\n&HEXTBL(11) SETC 'A'\n&HEXTBL(12) SETC 'B'\n&HEXTBL(13) SETC 'C'\n&HEXTBL(14) SETC 'D'\n&HEXTBL(15) SETC 'E'\n&HEXTBL(16) SETC 'F'\n.LBL020  ANOP\n         AIF  ('&TYPE' EQ 'INDEX').LBL100\n         AIF  ('&TYPE' NE 'DEFINE').ERR70\n         AIF  (T'&MACH EQ 'O').ERR010\n         AIF  (K'&MACH NE 2).ERR020\n         AIF  (T'&LENGTH EQ 'O').ERR080\n         AIF  (&LENGTH EQ 2).LBL025\n         AIF  (&LENGTH EQ 4).LBL025\n         AIF  (&LENGTH NE 6).ERR090\n.LBL025  ANOP\n&OP1     SETC '&MACH'(1,1)\n&OP2     SETC '&MACH'(2,1)\n&SUB1    SETA 1\n.LBL030  ANOP\n         AIF  ('&OP1' EQ '&HEXTBL(&SUB1)').LBL040\n         AIF  (&SUB1 EQ 16).ERR030\n&SUB1    SETA &SUB1+1\n         AGO  .LBL030\n.LBL040  ANOP\n&SUB2    SETA &SUB1\n&SUB1    SETA 1\n.LBL050  ANOP\n         AIF  ('&OP2' EQ '&HEXTBL(&SUB1)').LBL060\n         AIF  (&SUB1 EQ 16).ERR030\n&SUB1    SETA &SUB1+1\n         AGO  .LBL050\n.LBL060  ANOP\n&SUB3    SETA &SUB1\n&SUB1    SETA (16*(&SUB2-1))+&SUB3\n         AIF  ('&OPTBL(&SUB1)' NE '0').ERR040\n&OPTBL(&SUB1) SETC 'MACH&MACH'\n         AIF  (T'&MNEM EQ 'O').ERR050\n         AIF  (T'&FORMAT EQ 'O').ERR060\nMACH&MACH DC   CL2'&MACH'           MACHINE CODE FOR THIS INSTRUCTION\n          DC   CL06'&MNEM'          MNEMONIC\n          DC   AL2(&LENGTH)         INSTRUCTION LENGTH\n          DC   AL1(&FORMAT)         FORMAT CODE\n&OPTS    SETC '0'\n         AIF  (T'&FLAGS EQ 'O').LBL070\n&OPTS    SETC '&FLAGS'\n.LBL070  ANOP\n         AIF  (T'&COMMENT EQ 'O').LBL080\n          DC   AL1(&OPTS)           FLAGS\n         AGO   .LBL0090\n.LBL080  ANOP\n          DC   AL1(&OPTS+$OPNCMNT)  FLAGS + NO COMMENT INDICATOR\n.LBL0090 ANOP\n         AIF   (T'&REGS EQ 'O').LBL009A\n          DC    AL1(&REGS)\n         AGO   .LBL009B\n.LBL009A ANOP\n          DC    AL1(0)              NO REGISTER REQUIREMENTS\n.LBL009B ANOP\n         AIF   (T'&COMMENT EQ 'O').EXIT\n          DC   CL25&COMMENT         COMMENT\n         MEXIT\n.LBL100  ANOP\n&SUB1    SETA 1\n.LBL110  ANOP\n         DC    A(&OPTBL(&SUB1))\n         AIF   (&SUB1 EQ 256).EXIT\n&SUB1    SETA  &SUB1+1\n         AGO   .LBL110\n.ERR010  ANOP\n         MNOTE 12,'MACHINE CODE IS REQUIRED'\n         MEXIT\n.ERR020  ANOP\n         MNOTE 12,'MACHINE CODE MUST BE 2 CHARACTERS'\n         MEXIT\n.ERR030  ANOP\n         MNOTE 12,'MACHINE CODE CONTAINS INVALID HEX CHARACTER'\n         MEXIT\n.ERR040  ANOP\n         MNOTE 12,'MACHINE CODE &MACH IS DUPLICATELY DEFINED'\n         MEXIT\n.ERR050  ANOP\n         MNOTE 12,'MNEMONIC IS REQUIRED'\n         MEXIT\n.ERR060  ANOP\n         MNOTE 12,'INSTRUCTION FORMAT IS REQUIRED'\n         MEXIT\n.ERR070  ANOP\n         MNOTE 12,'INVALID TYPE PARAMETER'\n         MEXIT\n.ERR080  ANOP\n         MNOTE 12,'LENGTH IS REQUIRED'\n         MEXIT\n.ERR090  ANOP\n         MNOTE 12,'LENGTH MUST BE 2, 4, OR 6'\n.EXIT    ANOP\n         MEND\n./ ADD MEMBER=PRTBLOK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PRINTER REQUEST BLOCK                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&NAME    PRTBLOK  &TYPE=\n         AIF      ('&TYPE' EQ 'DSECT').DSECT\n&NAME    DS    0C\n         AGO      .NODSECT\n.DSECT   ANOP\n         AIF      (T'&NAME EQ 'O').NONAME\n&NAME    DSECT\n.NODSECT ANOP\nPRTCMD   DC    X'00'               COMMAND\n$PRTHEAD EQU   C'H'                .. PRINT HEADING\n$PRTSUBH EQU   C'S'                .. PRINT SUB-HEADING\n$PRTPRT  EQU   C'P'                .. PRINT\n$PRTMEM  EQU   C'M'                .. NEW MEMBER\n$PRTCLS  EQU   C'C'                .. CLOSE PRINT\nPRTCC    DC    C' '                CARRIAGE CONTROL\nPRTDATA  DC    CL132' '            PRINT DATA\n         MEXIT\n.NONAME  ANOP\n         MNOTE    12,'NAME REQUIRED WHEN TYPE=DSECT'\n         MEND\n./ ADD MEMBER=REGEQU\nR0       EQU    0\nR1       EQU    1\nR2       EQU    2\nR3       EQU    3\nR4       EQU    4\nR5       EQU    5\nR6       EQU    6\nR7       EQU    7\nR8       EQU    8\nR9       EQU    9\nR10      EQU    10\nR11      EQU    11\nR12      EQU    12\nR13      EQU    13\nR14      EQU    14\nR15      EQU    15\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISASSRC": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x00\\x99(\\x1f\\x01\\x11\\x08o \"\\x1fO\\x1fL\\x00\\x00\\xd2\\xe2\\xc8\\xc1\\xd9\\xd7\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-10-08T00:00:00", "modifydate": "2011-03-27T20:22:26", "lines": 8015, "newlines": 8012, "modlines": 0, "user": "KSHARPE"}, "text": "./ ADD MEMBER=DISASMB2\n         TITLE 'DISASMB2 B2 OPCODE INTERPRETER'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Module name: DISASMB2 - B2 opcode interpreter                      *\n*                                                                     *\n*  Function:                                                          *\n*   B2 opcodes are actually 2-byte opcodes.  All opcodes including    *\n*   B2 are defined in DISASMOP.  The first 256 bytes of DISASMOP is   *\n*   an index to the actual opcode definition.  To keep this index as  *\n*   simple as possible, this module is called to modify the B2 entry  *\n*   depending on the 2nd byte of the opcode.                          *\n*                                                                     *\n*   At entry                                                          *\n*                                                                     *\n*     R0  address of the instruction                                  *\n*     R1  address of the B2 entry in DISASMOP                         *\n*                                                                     *\n*   The B2 entry of DISASMOP will be modified:                        *\n*     .  The mnemonic will be set                                     *\n*     .  The instruction format will be set                           *\n*     .  \"flags\" (whether the instruction causes a data reference)    *\n*        will be set.                                                 *\n*                                                                     *\n* ------------------------------------------------------------------- *\n* Modified : Paul Gillis - P. C. Link Pty. Ltd. 28 September 1999     *\n*            Added all new B2 instructions found in SA22-7209-01      *\n*            and eliminated the abend U0006 as unnecessary            *\n*            This routine could handle the new A4, A5, A6, E4 and E5  *\n*            instructions if required. But I have not made the change *\n* ------------------------------------------------------------------- *\n         COPY  DISASMGB\nDISASMB2 CSECT\nDISASMB2 AMODE 31\n         RMODE 24\n         USING DISASMB2,R12\n         USING DISASM00,R11\n         USING OPDSECT,R4            DEFINE OPCODE DSECT BASE\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     B20000                SKIP EYECATCHER\n         DC    CL8'DISASMB2'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nB20000   DS    0H\n         LR    R2,R0                 COPY INSTRUCTION ADDRESS\n         LR    R4,R1                 COPY INSTRUCTION ADDRESS\n         USING BASEDATA,R2           DEFINE BASE\n         USING B2DSECT,R3            DEFINE BASE\n                                       SPACE 1\n         LA    R3,INSTABB2             B2 Instruction Table Address\n         CLI   0(R2),X'B2'             Instruction code starts B2\n         BE    B20010                  ===> Yes, Use the B2 table\n                                       SPACE 1\n         LA    R3,INSTAB01             01 Instruction Table Address\n         CLI   0(R2),X'01'             Instruction code starts 01\n         BE    B20010                  ===> Yes, Use the 01 table\n         B     B20030                  ===> No, Leave without change\n                                       SPACE 1\nB20010   DS    0H\n         CLC   B2B2,1(R2)            ENTRY FOUND?\n         BE    B20020                YES\n         LA    R3,B2DSECTL(R3)       NEXT ENTRY\n         CLI   0(R3),X'FF'           END OF TABLE?\n         BNE   B20010                NO\n                                       SPACE 1\n         MVC   OPMNEM,=CL6'DC'         Set op code to DC\n         MVC   OPFORM,=AL1($OPB2)      Set no operands\n         MVI   OPFLAGS,0               Clear operand Flags\n         MVI   OPREGS,0                Clear register Flags\n         MVI   OPCMNT,C' '             Clear comment Field\n         MVC   OPCMNT+1(L'OPCMNT-1),OPCMNT 'Clear the comment Field\n         MVC   OPCMNT(2),=CL2'X'''     Insert the hex value\n         UNPK  OPCMNT+2(9),0(5,R2)     Unpack the source data\n         TR    OPCMNT+2(8),TRTABLE-240 Make it all readable\n         MVC   OPCMNT+10(5),=CL5''''   Insert the final quotes\n         CLC   =H'4',OPLENGTH          4 byte instruction length\n         BE    B20030                  ===> Yes, skip 2 byte clearing\n         MVC   OPCMNT+6(5),=CL5''''    Insert the final quotes\n         B     B20030                  YES, code was not found\n                                       SPACE 1\nB20020   DS    0H\n         MVC   OPMNEM,B2MNEM           COPY MNEMONIC\n         MVC   OPFORM,B2FORM           COPY FORMAT\n         MVC   OPFLAGS,B2FLAGS         COPY FLAGS\nB20030   DS    0H\n         LM    R14,R12,12(R13)         RESTORE ALL OTHER REGISTERS\n         SR    R15,R15                 GIVE GOOD RETURN CODE\n         BR    R14                     RETURN TO CALLER\n* ------------------------------------------------------------------ *\n*        01 Instruction Table                                        *\n* ------------------------------------------------------------------ *\n                                       SPACE 1\nINSTAB01 DS    0C\n         DC    X'01',CL6'PR   ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'02',CL6'UPT  ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'FF'\n                                       SPACE 1\n* ------------------------------------------------------------------ *\n*        B2 Instruction Table                                        *\n* ------------------------------------------------------------------ *\n                                       SPACE 1\nINSTABB2 DS    0C\n         DC    X'02',CL6'STIDP',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'04',CL6'SCK  ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'05',CL6'STCK ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'06',CL6'SCKC ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'07',CL6'STCKC',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'08',CL6'SPT  ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'09',CL6'STPT ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'0A',CL6'SPKA ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'0B',CL6'IPK  ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'0D',CL6'PTLB ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'10',CL6'SPX  ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'11',CL6'STPX ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'12',CL6'STAP ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'14',CL6'SIE  ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'18',CL6'PC   ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'19',CL6'SAC  ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'1A',CL6'CFC  ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'21',CL6'IPTE ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'22',CL6'IPM  ',AL1($OPB2R),AL1($OPNCMNT)\n         DC    X'23',CL6'IVSK ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'24',CL6'IAC  ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'25',CL6'SSAR ',AL1($OPB2R),AL1($OPNCMNT)\n         DC    X'26',CL6'EPAR ',AL1($OPB2R),AL1($OPNCMNT)\n         DC    X'27',CL6'ESAR ',AL1($OPB2R),AL1($OPNCMNT)\n         DC    X'28',CL6'PT   ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'29',CL6'ISKE ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'2A',CL6'RRBE ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'2B',CL6'SSKE ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'2C',CL6'TB   ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'2D',CL6'DXR  ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'30',CL6'CSCH ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'31',CL6'HSCH ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'32',CL6'MSCH ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'33',CL6'SSCH ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'34',CL6'STSCH',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'35',CL6'TSCH ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'36',CL6'TPI  ',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'37',CL6'SAL  ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'38',CL6'RSCH ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'39',CL6'STCRW',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'3A',CL6'STCPS',AL1($OPB2S),AL1($OPREF+$OPNCMNT)\n         DC    X'3B',CL6'RCHP ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'3C',CL6'SCHM ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'40',CL6'BAKR ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'44',CL6'SQDR ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'45',CL6'SQER ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'46',CL6'STURA',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'47',CL6'MSTA ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'48',CL6'PALB ',AL1($OPB2R),AL1($OPNCMNT)\n         DC    X'49',CL6'EREG ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'4A',CL6'ESTA ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'4B',CL6'LURA ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'4C',CL6'TAR  ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'4D',CL6'CPYA ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'4E',CL6'SAR  ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'4F',CL6'EARR ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'54',CL6'MVPG ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'55',CL6'MVST ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'57',CL6'CUSE ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'58',CL6'BSG  ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'5D',CL6'CLST ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'5E',CL6'SRST ',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'63',CL6'CMPSC',AL1($OPB2RR),AL1($OPNCMNT)\n         DC    X'79',CL6'SACF ',AL1($OPB2),AL1($OPNCMNT)\n         DC    X'FF'\n         LTORG\nTRTABLE  DC    C'0123456789ABCDEF'     Translate Table\n* ------------------------------------------------------------------ *\n*                                                                    *\n*                                                                    *\n*                                                                    *\n* ------------------------------------------------------------------ *\nBASEDATA DSECT\nBASE     DS     CL4            Instruction data\n* ------------------------------------------------------------------ *\nB2DSECT  DSECT\nB2B2     DS     X              2ND BYTE OF INSTRUCTION\nB2MNEM   DS     CL6            MNEMONIC\nB2FORM   DS     X              INSTRUCTION FORMAT\nB2FLAGS  DS     X              FLAGS\nB2DSECTL EQU    *-B2DSECT\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              DATA AREAS                                            *\n*                                                                    *\n* ------------------------------------------------------------------ *\n         COPY  DISASMDA\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              COMMON DATA MAP                                       *\n*                                                                    *\n* ------------------------------------------------------------------ *\nDISASM00 DISASM00 TYPE=DSECT\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              EQUATES                                               *\n*                                                                    *\n* ------------------------------------------------------------------ *\n         COPY REGEQU\n         END  DISASMB2\n./ ADD MEMBER=DISASMDB\n         TITLE 'DISASMDB - DEBUG MODULE'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASMDB                                             *\n*                                                                    *\n*  Function:                                                         *\n*   If DISDEBUG DD is allocated, many internal fields and data       *\n*   chains will be printed for trouble shooting.                     *\n*                                                                    *\n*   There are two \"functions\".  Normal function is to print the      *\n*   internal fields and run the internal data chains.  The secondary *\n*   function is to print the assembler output for module DISASM07.   *\n*                                                                    *\n*   NOTE:  Several fields are copied to a work field before          *\n*          \"unpacking\" them for printing.  When \"unpacking\" the      *\n*          field, 1 more byte than printed is unpacked.  When the    *\n*          field is the last field in the data area, an S0C4 abend   *\n*          can occur.  Copying the field before unpacking was to     *\n*          prevent these S0C4 abends.  If any data area is modified  *\n*          and some other field is added to the end of the area,     *\n*          beware that if it is unpacked for printing it may need    *\n*          to be copied before unpacking.                            *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB\nDISASMDB CSECT\nDISASMDB AMODE 31\nDISASMDB RMODE 24\n         USING DISASMDB,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     DBUG0000              SKIP EYECATCHER\n         DC    CL8'DISASMDB'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nDBUG0000 DS    0H\n         LR    R9,R1                 COPY PARAMETER BLOCK ADDRESS\n         USING DBUGBLOK,R9           DEFINE BASE\n         LA    R1,SAVEDB             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         ITRACE ID=ENTRY,                                              +\n               DATA1=DBUGCMD\n         TM    COMMDD,$DEBUGDD       DEBUG DD PRESENT?\n         BNO   DBUG1000              NO, TRACE ENTRY BEFORE EXIT\n         TM    DBUGFLAG,$DBUGOPN     DEBUG ALREADY OPEN?\n         BO    DBUG0010              YES\n         OI    DBUGFLAG,$DBUGOPN     INDICATE DCB IS OPEN\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (DISDEBUG,OUTPUT)     OPEN DISDEBUG\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\nDBUG0010 DS    0H\n         CLI   DBUGCMD,$DBUGHD       HEADING?\n         BE    DBUG0300              YES\n         CLI   DBUGCMD,$DBUGPRT      PRINT?\n         BE    DBUG0310              YES\n         BAL   R10,HEAD0000          PRINT DEBUG HEADING\nDBUG0020 DS    0H\n* ------------------------------------------------------------------- *\n*             PRINT TRACE TABLE CONTROL                               *\n* ------------------------------------------------------------------- *\n         UNPK  PRTR1ST(9),TR1ST(5)   UNPACK TRACE 1ST\n         MVZ   PRTR1ST,COMM0F0F      TURN OFF ZONES\n         TR    PRTR1ST,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRTR1ST+8,C' '        RESTORE BLANK\n         UNPK  PRTRLAST(9),TRLAST(5) UNPACK TRACE LAST\n         MVZ   PRTRLAST,COMM0F0F     TURN OFF ZONES\n         TR    PRTRLAST,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRTRLAST+8,C' '       RESTORE BLANK\n         UNPK  PRTRCURR(9),TRCURR(5) UNPACK TRACE CURRENT\n         MVZ   PRTRCURR,COMM0F0F     TURN OFF ZONES\n         TR    PRTRCURR,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRTRCURR+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRTRL),PRTR   TRACE DATA\n         BAL   R10,PRT0000           PRINT TRACE DATA\n* ------------------------------------------------------------------- *\n*             PRINT DISMOD I/O AREA ADDRESS                           *\n* ------------------------------------------------------------------- *\n         UNPK  PRIOA(9),COMMIO(5)    UNPACK I/O BUFFER ADDRESS\n         MVZ   PRIOA,COMM0F0F        TURN OFF ZONES\n         TR    PRIOA,COMMHXCH        TRANSLATE TO PRINTABLE\n         MVI   PRIOA+8,C' '          RESTORE BLANK\n         MVC   PRTDATA(PRIOL),PRIO   TRACE DATA\n         BAL   R10,PRT0000           PRINT TRACE DATA\n* ------------------------------------------------------------------- *\n*             CHASE ESD CHAIN                                         *\n* ------------------------------------------------------------------- *\nDBUG0030 DS    0H\n         ITRACE ID=ESDCHAIN\n         ICM   R3,15,COMMESD         FIRST ESD ENTRY\n         USING ESDDATA,R3            DEFINE BASE\n         BZ    DBUG0050              NO ESD ENTRIES\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0040 DS    0H\n         ITRACE ID=ESDENTRY\n         ST    R3,COMMDWRD           USE DWRD FOR WORK AREA\n         UNPK  PRESDBA(9),COMMDWRD(5)\n         MVZ   PRESDBA,COMM0F0F      TURN OFF ZONES\n         TR    PRESDBA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRESDBA+8,C' '        RESTORE BLANK\n         UNPK  PRESDNXT(9),ESDNEXT(5)  NEXT BLOCK'S ADDRESS\n         MVZ   PRESDNXT,COMM0F0F     TURN OFF ZONES\n         TR    PRESDNXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRESDNXT+8,C' '       RESTORE BLANK\n         MVC   PRESDNM,ESDNAME       COPY ESD NAME\n         UNPK  PRESDTYP(3),ESDTYPE(2)\n         MVZ   PRESDTYP,COMM0F0F     TURN OFF ZONES\n         TR    PRESDTYP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRESDTYP+2,C' '       RESTORE BLANK\n         UNPK  PRESDADR(7),ESDADDR(4)\n         MVZ   PRESDADR,COMM0F0F     TURN OFF ZONES\n         TR    PRESDADR,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRESDADR+6,C' '       RESTORE BLANK\n         UNPK  PRESDSEG(3),ESDSEG(2) UNPACK SEGMENT NUMBER\n         MVZ   PRESDSEG,COMM0F0F     TURN OFF ZONES\n         TR    PRESDSEG,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRESDSEG+2,C' '       RESTORE BLANK\n         MVC   WORKX,ESDLEN          COPY TO WORK AREA\n         UNPK  PRESDLEN(7),WORKX(4)  UNPACK LENGTH\n         MVZ   PRESDLEN,COMM0F0F     TURN OFF ZONES\n         TR    PRESDLEN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRESDLEN+6,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRESDL),PRESD COPY ESD DATA TO PRINT AREA\n         BAL   R10,PRT0000           PRINT ESD DATA\n         ICM   R3,15,ESDNEXT         NEXT ESD BLOCK\n         BNZ   DBUG0040              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE RLD CHAIN                                         *\n* ------------------------------------------------------------------- *\nDBUG0050 DS    0H\n         ITRACE ID=RLDCHAIN\n         ICM   R3,15,COMMRLD         FIRST RLD ENTRY\n         USING RLDDATA,R3            DEFINE BASE\n         BZ    DBUG0070              NO RLD ENTRIES\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0060 DS    0H\n         ITRACE ID=RLDENTRY\n         ST    R3,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRRLDBA(9),COMMDWRD(5)\n         MVZ   PRRLDBA,COMM0F0F      TURN OFF ZONES\n         TR    PRRLDBA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRRLDBA+8,C' '        RESTORE BLANK\n         UNPK  PRRLDNXT(9),RLDNEXT(5)\n         MVZ   PRRLDNXT,COMM0F0F     TURN OFF ZONES\n         TR    PRRLDNXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRRLDNXT+8,C' '       RESTORE BLANK\n         UNPK  PRRLDDSP(9),RLDDISP(5)\n         MVZ   PRRLDDSP,COMM0F0F     TURN OFF ZONES\n         TR    PRRLDDSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRRLDDSP+8,C' '       RESTORE BLANK\n         UNPK  PRRLDTYP(3),RLDTYPE(2)\n         MVZ   PRRLDTYP,COMM0F0F     TURN OFF ZONES\n         TR    PRRLDTYP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRRLDTYP+2,C' '       RESTORE BLANK\n         UNPK  PRRLDLEN(5),RLDLEN(3) UNPACK LENGTH\n         MVZ   PRRLDLEN,COMM0F0F     TURN OFF ZONES\n         TR    PRRLDLEN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRRLDLEN+4,C' '       RESTORE BLANK\n         UNPK  PRRLDPTR(5),RLDPTR(3) UNPACK POINTER\n         MVZ   PRRLDPTR,COMM0F0F     TURN OFF ZONES\n         TR    PRRLDPTR,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRRLDPTR+4,C' '       RESTORE BLANK\n         UNPK  PRRLDPP(5),RLDPP(3)   UNPACK POSITION POINTER\n         MVZ   PRRLDPP,COMM0F0F      TURN OFF ZONES\n         TR    PRRLDPP,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRRLDPP+4,C' '        RESTORE BLANK\n         MVC   PRRLDDIR,RLDDIR       MOVE DIRECTION\n         UNPK  PRRLDESD(9),RLDESD(5) UNPACK ESD BLOCK ADDRESS\n         MVZ   PRRLDESD,COMM0F0F     TURN OFF ZONES\n         TR    PRRLDESD,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRRLDESD+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRRLDL),PRRLD MOVE RLD DATA\n         BAL   R10,PRT0000           PRINT RLD DATA\n         ICM   R3,15,RLDNEXT         NEXT RLD BLOCK\n         BNZ   DBUG0060              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE USING CHAIN                                       *\n* ------------------------------------------------------------------- *\nDBUG0070 DS    0H\n         ITRACE ID=USNGCHN\n         ICM   R3,15,COMMUSNG        FIRST USING ENTRY\n         USING USNGDSCT,R3           DEFINE BASE\n         BZ    DBUG0090              NO USING ENTRIES\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0080 DS    0H\n         ITRACE ID=USNGNTRY\n         ST    R3,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRUSGBA(9),COMMDWRD(5)\n         MVZ   PRUSGBA,COMM0F0F      TURN OFF ZONES\n         TR    PRUSGBA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRUSGBA+8,C' '        RESTORE BLANK\n         UNPK  PRUSGNXT(9),USNGNEXT(5)\n         MVZ   PRUSGNXT,COMM0F0F     TURN OFF ZONES\n         TR    PRUSGNXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRUSGNXT+8,C' '       RESTORE BLANK\n         MVC   PRUSGNME,USNGDSNM     DSECT'S NAME\n         MVC   PRUSGLBL,USNGLBNM     LABEL WITHIN DSECT\n         MVC   PRUSGBSE,USNGBASE     COPY BASE REGISTER\n         TR    PRUSGBSE,COMMHXCH     TRANSLATE TO PRINTABLE\n         UNPK  PRUSGFLG(3),USNGFLAG(2)\n         MVZ   PRUSGFLG,COMM0F0F     TURN OFF ZONES\n         TR    PRUSGFLG,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRUSGFLG+2,C' '       RESTORE BLANK\n         UNPK  PRUSGBGN(9),USNGBEGN(5)\n         MVZ   PRUSGBGN,COMM0F0F     TURN OFF ZONES\n         TR    PRUSGBGN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRUSGBGN+8,C'-'       RESTORE HYPHEN\n         UNPK  PRUSGDSP(9),USNGDISP(5)\n         MVZ   PRUSGDSP,COMM0F0F     TURN OFF ZONES\n         TR    PRUSGDSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRUSGDSP+8,C'-'       RESTORE HYPHEN\n         MVC   WORKX,USNGEND         COPY TO WORK FIELD\n         UNPK  PRUSGEND(9),WORKX(5)  UNPACK\n         MVZ   PRUSGEND,COMM0F0F     TURN OFF ZONES\n         TR    PRUSGEND,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRUSGEND+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRUSNGL),PRUSNG\n         BAL   R10,PRT0000           PRINT USING DATA\n         ICM   R3,15,USNGNEXT        NEXT USING BLOCK\n         BNZ   DBUG0080              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE DSECT CHAIN                                       *\n* ------------------------------------------------------------------- *\nDBUG0090 DS    0H\n         ITRACE ID=DSCTCHN\n         ICM   R3,15,COMMDSCT        FIRST DSECT ENTRY\n         USING DSCTDSCT,R3           DEFINE BASE\n         BZ    DBUG0120              NO DSECT ENTRIES\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0100 DS    0H\n         ITRACE ID=DSCTNTRY\n         ST    R3,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRDSBA(9),DSCTNEXT(5) UNPACK BLOCK ADDRESS\n         MVZ   PRDSBA,COMM0F0F       TURN OFF ZONES\n         TR    PRDSBA,COMMHXCH       TRANSLATE TO PRINTABLE\n         MVI   PRDSBA+8,C' '         RESTORE BLANK\n         UNPK  PRDSNXT(9),DSCTNEXT(5)\n         MVZ   PRDSNXT,COMM0F0F      TURN OFF ZONES\n         TR    PRDSNXT,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRDSNXT+8,C' '        RESTORE BLANK\n         MVC   PRDSNAME,DSCTNAME     COPY DSECT'S NAME\n         MVC   WORKX,DSCTLBA         COPY ADDRESS TO WORK AREA\n         UNPK  PRDSLABL(9),WORKX(5)  UNPACK LABEL BLOCK ADDRESS\n         MVZ   PRDSLABL,COMM0F0F     TURN OFF ZONES\n         TR    PRDSLABL,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDSLABL+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRDSCTL),PRDSCT\n         BAL   R10,PRT0000           PRINT DSECT DATA\n         ICM   R4,15,DSCTLBA         FIRST LABEL FROM DSECT\n         BZ    DBUG0110              NO LABELS\n         BAL   R8,DBUG0190           FOLLOW LABEL CHAIN\nDBUG0110 DS    0H\n         ICM   R3,15,DSCTNEXT        NEXT DSECT\n         BNZ   DBUG0100              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE BASE CHAIN                                        *\n* ------------------------------------------------------------------- *\nDBUG0120 DS    0H\n         ITRACE ID=BASECHN\n         ICM   R3,15,COMMBASE        FIRST BASE ENTRY\n         USING BASEDSCT,R3           DEFINE BASE\n         BZ    DBUG0140              NO DSECT ENTRIES\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0130 DS    0H\n         ITRACE ID=BASENTRY\n         ST    R3,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRBSEBA(9),COMMDWRD(5)\n         MVZ   PRBSEBA,COMM0F0F      TURN OFF ZONES\n         TR    PRBSEBA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRBSEBA+8,C' '        RESTORE BLANK\n         UNPK  PRBSENXT(9),BASENEXT(5)\n         MVZ   PRBSENXT,COMM0F0F     TURN OFF ZONES\n         TR    PRBSENXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRBSENXT+8,C' '       RESTORE BLANK\n         UNPK  PRBSEBGN(9),BASEBEGN(5)\n         MVZ   PRBSEBGN,COMM0F0F     TURN OFF ZONES\n         TR    PRBSEBGN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRBSEBGN+8,C'-'       RESTORE BLANK\n         UNPK  PRBSEEND(9),BASEEND(5)\n         MVZ   PRBSEEND,COMM0F0F     TURN OFF ZONES\n         TR    PRBSEEND,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRBSEEND+8,C' '       RESTORE BLANK\n         UNPK  PRBSEDSP(9),BASEDISP(5)\n         MVZ   PRBSEDSP,COMM0F0F     TURN OFF ZONES\n         TR    PRBSEDSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRBSEDSP+8,C' '       RESTORE BLANK\n         MVC   PRBSEREG,BASEREG      COPY BASE REGISTER\n         TR    PRBSEREG,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVC   PRTDATA(PRBASEL),PRBASE\n         BAL   R10,PRT0000           PRINT BASE DATA\n         ICM   R3,15,BASENEXT        NEXT BASE BLOCK\n         BNZ   DBUG0130              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE DATA BLOCK CHAIN                                  *\n* ------------------------------------------------------------------- *\nDBUG0140 DS    0H\n         ITRACE ID=DATACHN\n         ICM   R3,15,COMMDATA        FIRST DATA ENTRY\n         USING DATADSCT,R3           DEFINE BASE\n         BZ    DBUG0160              NO DSECT ENTRIES\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0150 DS    0H\n         ITRACE ID=DATANTRY\n         ST    R3,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRDTABA(9),COMMDWRD(5)\n         MVZ   PRDTABA,COMM0F0F      TURN OFF ZONES\n         TR    PRDTABA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRDTABA+8,C' '        RESTORE BLANK\n         UNPK  PRDTANXT(9),DATANEXT(5)\n         MVZ   PRDTANXT,COMM0F0F     TURN OFF ZONES\n         TR    PRDTANXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTANXT+8,C' '       RESTORE BLANK\n         UNPK  PRDTABGN(9),DATABEGN(5)\n         MVZ   PRDTABGN,COMM0F0F     TURN OFF ZONES\n         TR    PRDTABGN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTABGN+8,C'-'       RESTORE HYPHEN\n         UNPK  PRDTAEND(9),DATAEND(5)\n         MVZ   PRDTAEND,COMM0F0F     TURN OFF ZONES\n         TR    PRDTAEND,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTAEND+8,C' '       RESTORE BLANK\n         UNPK  PRDTALEN(9),DATALEN(5)\n         MVZ   PRDTALEN,COMM0F0F     TURN OFF ZONES\n         TR    PRDTALEN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTALEN+8,C' '       RESTORE BLANK\n         UNPK  PRDTATYP(3),DATATYPE(2)\n         MVZ   PRDTATYP,COMM0F0F     TURN OFF ZONES\n         TR    PRDTATYP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTATYP+2,C' '       RESTORE BLANK\n         MVC   PRDTANME,DATANAME     COPY DATA NAME\n         UNPK  PRDTALBA(9),DATALBA(5)\n         MVZ   PRDTALBA,COMM0F0F     TURN OFF ZONES\n         TR    PRDTALBA,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTALBA+8,C'+'       RESTORE PLUS SIGN\n         UNPK  PRDTALBD(9),DATALBD(5)\n         MVZ   PRDTALBD,COMM0F0F     TURN OFF ZONES\n         TR    PRDTALBD,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRDTALBD+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRDATAL),PRDATA\n         BAL   R10,PRT0000           PRINT DATA DATA\n         ICM   R3,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   DBUG0150              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE REFERENCE BLOCK CHAIN                             *\n* ------------------------------------------------------------------- *\nDBUG0160 DS    0H\n         ITRACE ID=REFCHAIN\n         ICM   R3,15,COMMREF         FIRST REFERENCE BLOCK\n         USING REFDSCT,R3            DEFINE BASE\n         BZ    DBUG0180              NO REF BLOCK'S\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0170 DS    0H\n         ITRACE ID=REFENTRY\n         ST    R3,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRREFBA(9),REFNEXT(5)\n         MVZ   PRREFBA,COMM0F0F      TURN OFF ZONES\n         TR    PRREFBA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRREFBA+8,C' '        RESTORE BLANK\n         UNPK  PRREFNXT(9),REFNEXT(5)\n         MVZ   PRREFNXT,COMM0F0F     TURN OFF ZONES\n         TR    PRREFNXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRREFNXT+8,C' '       RESTORE BLANK\n         UNPK  PRREFAD1(9),REFOPER1(5)\n         MVZ   PRREFAD1,COMM0F0F     TURN OFF ZONES\n         TR    PRREFAD1,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRREFAD1+8,C'-'       RESTORE HYPHEN\n         UNPK  PRREFO1D(9),REFDISP1(5)\n         MVZ   PRREFO1D,COMM0F0F     TURN OFF ZONES\n         TR    PRREFO1D,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRREFO1D+8,C' '       RESTORE BLANK\n         UNPK  PRREFAD2(9),REFOPER2(5)\n         MVZ   PRREFAD2,COMM0F0F     TURN OFF ZONES\n         TR    PRREFAD2,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRREFAD2+8,C'-'       RESTORE HYPHEN\n         UNPK  PRREFO2D(9),REFDISP2(5)\n         MVZ   PRREFO2D,COMM0F0F     TURN OFF ZONES\n         TR    PRREFO2D,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRREFO2D+8,C' '       RESTORE BLANK\n         MVC   WORKX,REFDISPI        COPY TO WORK AREA\n         UNPK  PRREFDSP(9),WORKX(5)  UNPACK\n         MVZ   PRREFDSP,COMM0F0F     TURN OFF ZONES\n         TR    PRREFDSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRREFDSP+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRREFL),PRREF\n         BAL   R10,PRT0000           PRINT REF DATA\n         ICM   R3,15,REFNEXT         NEXT REF BLOCK\n         BNZ   DBUG0170              LOOP\n* ------------------------------------------------------------------- *\n*             CHASE LABEL CHAIN FOR CSECT                             *\n* ------------------------------------------------------------------- *\nDBUG0180 DS    0H\n         ITRACE ID=CSCTLABL\n         ICM   R4,15,COMMLABL        FIRST REFERENCE BLOCK\n         BZ    DBUG0210              NO CSECT LABELS\n         BAL   R8,DBUG0190           CHASE THE CHAIN\n         B     DBUG0210              PRINT DISPLACEMENT TABLE\n* ------------------------------------------------------------------- *\n*             CHASE LABEL CHAIN FOR DSECTS AND CSECTS                 *\n* ------------------------------------------------------------------- *\nDBUG0190 DS    0H\n         USING LABLDSCT,R4           DEFINE BASE\n         MVI   PRTCC,C'0'            DOUBLE SPACE\nDBUG0200 DS    0H\n         ITRACE ID=LABLNTRY\n         ST    R4,COMMDWRD           USE DWRD AS WORK AREA\n         UNPK  PRLBLBA(9),COMMDWRD(5)\n         MVZ   PRLBLBA,COMM0F0F      TURN OFF ZONES\n         TR    PRLBLBA,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   PRLBLBA+8,C' '        RESTORE BLANK\n         UNPK  PRLBLNXT(9),LABLNEXT(5)\n         MVZ   PRLBLNXT,COMM0F0F     TURN OFF ZONES\n         TR    PRLBLNXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRLBLNXT+8,C' '       RESTORE BLANK\n         MVC   PRLBLNM,LABLNAME      COPY NAME\n         MVC   PRLBLTYP,LABLTYPE     COPY LABEL TYPE\n         UNPK  PRLBLDSP(9),LABLDISP(5)\n         MVZ   PRLBLDSP,COMM0F0F     TURN OFF ZONES\n         TR    PRLBLDSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRLBLDSP+8,C' '       RESTORE BLANK\n         UNPK  PRLBLEQU(9),LABLEQU(5)\n         MVZ   PRLBLEQU,COMM0F0F     TURN OFF ZONES\n         TR    PRLBLEQU,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   PRLBLEQU+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(PRLABLL),PRLABL\n         BAL   R10,PRT0000           PRINT LABL DATA\n         ICM   R4,15,LABLNEXT        NEXT LABL BLOCK\n         BNZ   DBUG0200              LOOP\n         BR    R8                    RETURN\n* ------------------------------------------------------------------- *\n*             PRINT INSTRUCTION DISPLACEMENT TABLE                    *\n* ------------------------------------------------------------------- *\nDBUG0210 DS    0H\n         ICM   R3,15,COMMDISP        INSTRUCTION DISPLACEMENT TABLE\n         BZ    EXIT0000              TABLE NOT ACQUIRED\n         MVI   PRTCC,C'0'            DOUBLE SPACE\n         MVC   PRTDATA(PRDISPL),PRDISP\n         BAL   R10,PRT0000           PRINT HEADING\nDBUG0220 DS    0H\n         LA    R2,PRTDATA            PRINT DATA\n         LA    R1,10                 10 DISPLACEMENTS PER LINE\nDBUG0230 DS    0H\n         CLC   XFFFF,0(R3)           END OF DISPLACEMENT TABLE?\n         BE    DBUG0240              YES\n         UNPK  0(9,R2),0(5,R3)       UNPACK DISPLACEMENT\n         MVZ   0(8,R2),COMM0F0F      TURN OFF ZONES\n         TR    0(8,R2),COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   8(R2),C' '            RESTORE BLANK\n         LA    R2,9(R2)              NEXT IN PRINT AREA\n         LA    R3,4(R3)              NEXT DISPLACEMENT\n         BCT   R1,DBUG0230           LOOP\n         BAL   R10,PRT0000           PRINT DISPLACEMENT DATA\n         B     DBUG0220              BUILD A NEW LINE\nDBUG0240 DS    0H\n         CLC   PRTDATA,PRTDATA-1     LINE EMPTY?\n         BE    EXIT0000              YES, EXIT\n         BAL   R10,PRT0000           PRINT DISPLACEMENT DATA\n         B     EXIT0000              EXIT\n* ------------------------------------------------------------------- *\n*             PRINT SUBHEADING                                        *\n* ------------------------------------------------------------------- *\nDBUG0300 DS    0H\n         BAL   R10,HEAD0000          PRINT HEADING\n         B     EXIT0000              EXIT\n* ------------------------------------------------------------------- *\n*             PRINT DATA                                              *\n* ------------------------------------------------------------------- *\nDBUG0310 DS    0H\n         L     R1,DBUGDATA           DATA ADDRESS\n         MVC   PRTDATA(120),0(R1)    COPY DATA\n         BAL   R10,PRT0000           PRINT\n         B     EXIT0000              EXIT\n* ------------------------------------------------------------------- *\n*             NO DISDEBUG DD PRESENT                                  *\n* ------------------------------------------------------------------- *\nDBUG1000 DS    0H\n         ITRACE ID=NODEBUG           CAUSE TRACE ENTRY\n         B     EXIT0000              EXIT\nPRT0000  DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISDEBUG,PRTCC        WRITE DEBUG OUTPUT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\n         CLI   PRTCC,C' '            SINGLE SPACED?\n         BNE   PRT0010               NO\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\nPRT0010  DS    0H\n         MVC   PRTCC(PRTL),PRTCC-1   CLEAR PRINT I/O AREA\n         CP    LINECT,COMMMAXL       PAGE OVERFLOW?\n         BNHR  R10                   NO\nHEAD0000 DS    0H\n         MVC   PRTCC(DEBUGHDL),DEBUGHD\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISDEBUG,PRTCC        WRITE NEW HEADING\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   PRTCC(PRTL),PRTCC-1   CLEAR PRINT I/O AREA\n         MVC   PRTDATA(L'COMMDBSH),COMMDBSH\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISDEBUG,PRTCC        WRITE SUB HEADING\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   PRTCC(PRTL),PRTCC-1   CLEAR PRINT I/O AREA\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISDEBUG,PRTCC        BLANK LINE\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         ZAP   LINECT,P1             RESET LINE COUNT\n         BR    R10                   RETURN\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nAM24     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         BSM   R0,R14             RETURN IN 24-BIT MODE\nAM31     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         O     R14,X80            SET 31-BIT MODE\n         BSM   R0,R14             RETURN IN 31-BIT MODE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVEDB   DC    18F'0'                REGISTER SAVE AREA\nX80      DC    A(X'80000000')\nDBUGFLAG DC    X'00'\n$DBUGOPN EQU   X'80'                 DCB IS OPEN\nWORKX    DC    XL4'00'\nP1       DC    P'1'\nLINECT   DC    PL3'0'\nXFFFF    DC    X'FFFFFFFF'\n         SPACE 2\n         DC    C' '\nPRTCC    DC    C' '\nPRTDATA  DC    CL132' '\nPRTL     EQU   *-PRTCC\n         SPACE 2\nDEBUGHD  DS    0C\n         DC    C'1               DISASSEMBLER DEBUG'\nDEBUGHDL EQU   *-DEBUGHD\nPRTR     DS    0C\n         DC    C'TRACE TABLE FIRST '\nPRTR1ST  DC    CL8' '\n         DC    C'   LAST '\nPRTRLAST DC    CL8' '\n         DC    C'   CURRENT '\nPRTRCURR DC    CL8' '\n         DC    C' '\nPRTRL    EQU   *-PRTR\nPRIO     DS    0C\n         DC    C' DISMOD I/O AREA ADDRESS '\nPRIOA    DC    CL8' '\n         DC    C' '\nPRIOL    EQU   *-PRIO\nPRESD    DS    0C\n         DC    C'ESD BLOCK '\nPRESDBA  DC    CL8' '\n         DC    C' '\nPRESDNXT DC    CL8' '\n         DC    C'  NAME '\nPRESDNM  DC    CL8' '\n         DC    C'  TYPE '\nPRESDTYP DC    CL2' '\n         DC    C'  ADDRESS '\nPRESDADR DC    CL7' '\n         DC    C'  SEGMENT '\nPRESDSEG DC    CL2' '\n         DC    C'  LENGTH '\nPRESDLEN DC    CL7' '\n         DC    C' '\nPRESDL   EQU   *-PRESD\nPRRLD    DS    0C\n         DC    C'RLD BLOCK '\nPRRLDBA  DC    CL8' '\n         DC    C' '\nPRRLDNXT DC    CL8' '\n         DC    C'  DISP '\nPRRLDDSP DC    CL8' '\n         DC    C'  TYPE '\nPRRLDTYP DC    CL2' '\n         DC    C'  LENGTH '\nPRRLDLEN DC    CL4' '\n         DC    C'  POINTER '\nPRRLDPTR DC    CL4' '\n         DC    C'  POSITION '\nPRRLDPP  DC    CL4' '\n         DC    C'  DIR '\nPRRLDDIR DC    C' '\n         DC    C'  ESD '\nPRRLDESD DC    CL8' '\n         DC    C' '\nPRRLDL   EQU   *-PRRLD\nPRUSNG   DS    0C\n         DC    C'USING '\nPRUSGBA  DC    CL8' '\n         DC    C' '\nPRUSGNXT DC    CL8' '\n         DC    C'  DSECT '\nPRUSGNME DC    CL8' '\n         DC    C'  LABEL '\nPRUSGLBL DC    CL8' '\n         DC    C'  BASE '\nPRUSGBSE DC    C' '\n         DC    C'  FLAGS '\nPRUSGFLG DC    CL2' '\n         DC    C'  DISP '\nPRUSGDSP DC    CL8' '\n         DC    C'  BEGN/END'\nPRUSGBGN DC    CL8' '\n         DC    C'-'\nPRUSGEND DC    CL8' '\n         DC    C' '\nPRUSNGL  EQU   *-PRUSNG\nPRDSCT   DS    0C\n         DC    C'DSECT '\nPRDSBA   DC    CL8' '\n         DC    C' '\nPRDSNXT  DS    CL8' '\n         DC    C'  DSECT NAME '\nPRDSNAME DC    CL8' '\n         DC    C'  1ST LABEL '\nPRDSLABL DC    CL8' '\n         DC    C' '\nPRDSCTL  EQU   *-PRDSCT\nPRBASE   DS    0C\n         DC    C'BASE '\nPRBSEBA  DS    CL8' '\n         DC    C' '\nPRBSENXT DC    CL8' '\n         DC    C'  REGISTER '\nPRBSEREG DC    C' '\n         DC    C'  INSTRUCTION RANGE '\nPRBSEBGN DC    CL9' '\nPRBSEEND DC    CL9' '\n         DC    C'  DISP REFERRED TO '\nPRBSEDSP DC    CL9' '\nPRBASEL  EQU   *-PRBASE\nPRDATA   DS    0C\n         DC    C'DATA '\nPRDTABA  DC    CL8' '\n         DC    C' '\nPRDTANXT DC    CL8' '\n         DC    C'  DISP '\nPRDTABGN DC    CL8' '\n         DC    C'-'\nPRDTAEND DC    CL8' '\n         DC    C'  LENGTH '\nPRDTALEN DC    CL8' '\n         DC    C'  TYPE '\nPRDTATYP DC    CL2' '\n         DC    C'  NAME '\nPRDTANME DC    CL8' '\n         DC    C'  LABEL '\nPRDTALBA DC    CL8' '\n         DC    C'+'\nPRDTALBD DC    CL8' '\n         DC    C' '\nPRDATAL  EQU   *-PRDATA\nPRREF    DS    0C\n         DC    C'REF '\nPRREFBA  DC    CL8' '\n         DC    C' '\nPRREFNXT DC    CL8' '\n         DC    C'  LABEL 1 '\nPRREFAD1 DC    CL8' '\n         DC    C'-'\nPRREFO1D DC    CL8' '\n         DC    C'  LABEL 2 '\nPRREFAD2 DC    CL8' '\n         DC    C'-'\nPRREFO2D DC    CL9' '\n         DC    C'  INSTRUCTION DISP '\nPRREFDSP DC    CL8' '\n         DC    C' '\nPRREFL   EQU   *-PRREF\nPRLABL   DS    0C\n         DC    C'LABEL '\nPRLBLBA  DC    CL8' '\n         DC    C' '\nPRLBLNXT DC    CL8' '\n         DC    C'  LABEL NAME '\nPRLBLNM  DC    CL8' '\n         DC    C'  TYPE '\nPRLBLTYP DC    C' '\n         DC    C'  DISP '\nPRLBLDSP DC    CL8' '\n         DC    C'  EQUATE '\nPRLBLEQU DC    CL8' '\n         DC    C' '\nPRLABLL  EQU   *-PRLABL\nPRDISP   DC    C'INSTRUCTION DISPLACEMENTS:'\nPRDISPL  EQU   *-PRDISP\nDISDEBUG DCB   DDNAME=DISDEBUG,      DEBUG DCB                         +\n               DSORG=PS,             .. SEQUENTIAL                     +\n               LRECL=133,            .. RECORD SIZE                    +\n               RECFM=FBA,            .. RECORD FORMAT                  +\n               MACRF=PM              .. PUT-MOVE MODE\n         LTORG\n         SPACE 2\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              INTERFACE BLOCK                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDBUGBLOK DBUGBLOK TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASMDB\n./ ADD MEMBER=DISASMDC\n1                      DISASSEMBLER\n0 Change history:\n    Dec  93    added \"B2\" instruction module\n    Dec  93    converted code to run in 31-bit mode as much as possible\n    Dec  93    corrected S0C4 abend when generating DC's with 31-bit fla\n    Dec  93    added \"no float\" option\n    Jan  94    added test for 8 byte literal strings\n    Jan  94    added register tests for \"even-odd\", floating point\n    Jan  94    added samples to JCL library\n0 DISASM is a multi-pass disassembler.  Source assembler statements are\n  produced from a CSECT of a linkedited module.  The module may contain\n  multiple CSECT's, however DISASM disassembles one CSECT per execution.\n0 Control statements:\n- Comment statement (optional)\n0 Columns  1 -  1     * (asterisk)\n                      Comments may be specified at any time.  Comments\n                      will be copied to the output listing.\n- ASM START statement (optional)\n0 Columns  1 -  9     Literal 'ASM START'.\n                      Delimits the start of input for the assembler.\n                      Any statements specified are also copied to the\n                      end of the disassembled punched output.  This\n                      allows DSECTs to be assembled so the labels\n                      can be used for data references.  Any DSECT used\n                      in a USING statement must be defined by this\n                      method.  Use care when defining your DSECTs, the\n                      disassembler requires the PRINT option to be on\n                      to determine the DSECT and label names.  If a\n                      macro or copy statement turns the PRINT off, the\n                      DSECT and labels will not be available.\n- ASM END statement (optional)\n0 Columns  1 -  7     Literal 'ASM END'.\n                      Delimits the end of the assembler input.\n- BASE statement (optional)\n0 Columns  1 -  4     Literal 'BASE'.\n          10 - 12     Base register.  Register 1 may be specfied as 1 or\n                      R1, register 10 may be specified as 10 or R10.\n                      Registers 10 to 15 may be specified as A to F or\n                      RA to RF.\n          20 - 27     Starting displacement into the CSECT that the base\n                      register is in effect.  Displacements are given as\n                      hex values 1 to 8 digits long, leading zeros are\n                      not required (0A0 is equivalent to A0).\n          30 - 37     Optional.  Ending displacement into the CSECT that\n                      the base register is in effect.  If omitted, the\n                      ending displacement will be 4096 from the starting\n                      value (in columns 20-27).  Coding is the same as\n                      for the starting displacement.\n          40 - 47     Displacement the base register refers to.  For\n                      example if the base register is R12 and R12 is\n                      used as the base in instructions starting at\n                      +X'20', and R12 is set to point to +X'22C' into\n                      the CSECT, the BASE statement would be:\n0                     BASE     R12       20        22C\n0                     If a base register is defined, a LABEL (or PREFIX)\n                      statement is also required.\n- CSECT statement (optional)\n0 Columns  1 -  5     Literal 'CSECT'.\n          10 - 17     CSECT's name.  If the CSECT is not specified, the\n                      first CSECT in the module will be disassembled.\n- DATA statement (optional)\n0 Columns  1 -  4     Literal 'DATA'.\n          10 - 17     Starting displacement into the CSECT where the dat\n                      begins.  DATA statements allow you to identify\n                      areas that do not contain instructions.  See the\n                      BASE statement for displacement coding syntax.\n          20 - 27     Displacement where the data ends.\n- LABEL statement (optional)\n0 Columns  1 -  5     Literal 'LABEL'.\n             or\n           1 -  6     Literal 'PREFIX'.\n          10 - 14     1 to 4 character label prefix.  Labels generated\n                      due to references within the CSECT will be\n                      PPPPNNNN where PPPP is the prefix specified here\n                      and NNNN is the displacement into the CSECT or\n                      a sequential number (0010, 0020, 0030, etc).\n                      If the prefix is less than 4 characters long, the\n                      numeric portion will be padded on the left with\n                      zeros (labels will always be 8 characters long).\n                      If the LABEL/PREFIX statement is used, base\n                      registers must also be defined.\n- LINE/LINES/MAXLINES statement (optional).\n0 Columns  1 -  4     Literal 'LINE'\n             or\n           1 -  5     Literal 'LINES'\n             or\n           1 -  9     Literal 'MAXLINES'\n          10 - 12     Maximum number of lines to print per page on the\n                      DISPRINT and DISDEBUG data sets.  Line values are\n                      2 to 3 digits, minimum is 10 lines.  Specify the\n                      value left justified, leading zeros may be omitted\n                      Default line count is 60 lines per page.\n- MODULE statement (required)\n0 Columns  1 -  6     Literal 'MODULE'.\n          10 - 17     Load module's name.  This module must be in the\n                      library specified in the DISMOD DD.\n- NO FLOAT statement (optional)\n0 Columns  1 -  8     Literal 'NO FLOAT'.\n             or\n  Colums   1 - 7      Literal 'NOFLOAT'.\n                      Suppresses floating point opcodes from being\n                      considered as valid opcodes.  When you are certain\n                      the module being processed does not use floating\n                      point, suppressing the floating point opcodes\n                      stops the disassembler from interpreting some of\n                      the data areas as instructions.\n1 SEQ LABEL statement (optional)\n0 Columns  1 -  9     Literal 'SEQ LABEL'.\n                      Labels generated for labels within the CSECT will\n                      be PPPPNNNN where PPPP is the prefix specified on\n                      in the LABEL or PREFIX statement and NNNN is eithe\n                      the displacement of the label into the CSECT or a\n                      sequential number.  By default NNNN will be the\n                      displacement in hex.  SEQ LABEL requests the label\n                      be generated with sequential numbers.  This may be\n                      desirable if the source is to be modified... the\n                      labels may no longer be at the same displacement.\n- USING statement (optional)\n0 Columns  1 -  5     Literal 'USING'.\n          10 - 17     DSECT's name.  Any DSECTs referenced on USING\n                      statements must be defined via assembler input.\n          20 - 27     Label within the DSECT.  In some cases the base\n                      register may be set to point to a label within the\n                      DSECT rather than at displacement zero.  If the\n                      base points to displacement zero, leave this\n                      parameter blank.\n          30 - 32     Base register.  See BASE statement for base reg\n                      syntax.\n          40 - 47     If the register specified as the base is used as\n            and       the base in all cases where it appears in the\n          50 - 57     code, leave these parameters blank.  If the base\n                      is only used as a base for the specified DSECT at\n                      in a range of instructions, specify the beginning\n                      displacement in columns 40-47 and the ending\n                      displacement in columns 50-57.  The same base may\n                      be specified for the same DSECT multiple times wit\n                      different ranges if necessary.\n1                 JCL REQUIREMENTS\n0      //....     EXEC PGM=DISASM,REGION=nnnnK                 REQ\n       //STEPLIB  DD DSN=xxxx,DISP=SHR                         OPT\n       //SYSPRINT DD DSN=&&PRT,DISP=(NEW,PASS),                OPT\n       //            UNIT=SYSDA,\n       //            SPACE=(TRK,(15,15)),\n       //            DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)\n       //SYSIN    DD DSN=&&IN,DISP=(NEW,PASS),                 OPT\n       //            UNIT=SYSDA,\n       //            SPACE=(TRK,(15,15)),\n       //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n       //SYSLIB   DD DSN=xxxx,DISP=SHR                         OPT\n       //SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))              OPT\n       //SYSPUNCH DD DUMMY                                     OPT\n       //DISDEBUG DD SYSOUT=*                                  OPT\n       //DISPRINT DD SYSOUT=*                                  REQ\n       //DISPUNCH DD SYSOUT=class                              OPT\n       //DISMOD   DD DSN=xxxx,DISP=SHR                         REQ\n       //DISIN    DD *                                         REQ\n             .\n             control statements\n             .\n       /*\n       //\n0If DISASM is an a LINKLST library the STEPLIB is not required.\n If the assembler input (ASM START/ASM END) is used SYSPRINT, SYSIN,\n SYSLIB, SYSUT1, and SYSPUNCH are required, otherwise they may be\n omitted.\n If the DISPUNCH DD is present, the source will be generated as an\n 80-byte file suitable for input to the assembler.\n Any macros or copy statements specified as assembler input must be\n available in a library in the SYSLIB concatenation.\n1                 ABEND CODES and MESSAGES\n0 ABEND 001     User requested an ABEND via the ABEND statement.\n0 ABEND 002     Unknown return code from BLDL.\n0 ABEND 003     Unknown RLD with unknown type encountered.\n0 ABEND 004     Internal error, RLD data remaining went negative in\n                DISASM05.\n0 ABEND 005     Internal error, attempt to generate an instruction on\n                on an odd address boundary.\n0 DISASM0101I   No DISPUNCH DD present, no source will be generated\n                Informational only.  The DISPUNCH DD was not present\n                in the JCL, no source deck will be produced.\n0 DISASM0102I   ABEND requested, program abnormally terminating\n                For diagnositic purposes, an ABEND command was added\n                to cause an abend just prior to freeing the trace table\n                and terminating.  This message is issued immediately\n                before the abend, and indicates the abend was due to\n                the user's request and not due to a problem.\n                DISASM will also have abended with a user 001.\n0 DISASM0103I   ******* Disassembly complete *******\n                Indicates that the disassembly was successful.\n0 DISASM0104E   DISIN DD statement missing, processing will be aborted\n                DISASM requires the DISIN DD statement.  DISASM must\n                know at minimum which module it is to disassemble.  The\n                MODULE and all other control statements are provided to\n                DISASM via DISIN.\n0 DISASM0105E   DISMOD DD statement missing, processing will be aborted\n                DISASM loads the module to be disassembled from the\n                library specified by the DISMOD DD, this DD is therefore\n                required.\n0 DISASM0106E   Error(s) in control statements, execution aborted\n                Error(s) were detected in the control statements by\n                module DISASM02.  Messages are issued to identify the\n                statement(s) in error.  Correct the control statements\n                and re-run.\n0 DISASM0107E   Error(s) in loading object module, execution aborted\n                Error(s) were encountered by DISASM03 in loading the\n                specified module.  One of the following occurred:\n                   1) the BLDL for the member failed\n                   2) if the specified member was an alias, the\n                      BLDL for the real member failed.\n                   3) the POINT for the member (or real member) failed\n                   4) the requested CSECT was not in the specified\n                      module\n                   5) RLD data overlapped a user defined data area\n                Further messages will have been issued to identify the\n                the cause.\n0 DISASM0108E   Error(s) in printing text, execution aborted\n                Should never occur.  At present there are no errors\n                detected by the text print module, DISASM06.\n0 DISASM0109E   Error(s) in assembling DSECTs, execution aborted\n                Either the return code from the assembler was greater\n                than 4, or some other error in interpreting the DSECTs\n                occurred.  Messages will have been issued to identify\n                the cause.\n0 DISASM0110E   Error(s) in generating label table, execution aborted\n                An error condition was detected by DISASM08.  Messages\n                will have been issued to identify the cause.\n0 DISASM0111E   Error(s) in generating source, execution aborted\n                An error condition was detected by DISASM09.  Messages\n                will have been issued to identify the cause.\n0 DISASM0202W   Sequentially numbered labels have already been requested\n                The SEQ LABEL statement is specified more than once in\n                the control statements.\n0 DISASM0203E   Invalid control statement\n                Columns 1-9 of a control statement contain an unknown\n                statement type.  See the list of control statements\n                for valid control statements and their syntax.\n0 DISASM0204E   Extraneous data in register parameter\n                DISASM checks for several blanks following a register\n                specification on BASE and USING statements.  This check\n                helps to make sure you specified parameters in the\n                correct columns.  If the blanks are not present, this\n                message is issued and the program abort flag set.\n0 DISASM0205E   Invalid register reference\n                The register specified on a BASE or USING statement is\n                invalid.  Valid values are 0-15, A-F, R0-R15, and RA-RF.\n0 DISASM0206E   End displacement is required when begin displacement is\n                On USING statements the beginning and ending displacemen\n                values are optional.  If the beginning displacement is\n                given, the ending displacement is also required.\n0 DISASM0207E   Begin displacement is larger than end displacement\n                The beginning and ending displacement values specify\n                a range of instruction displacements.  The end value\n                must be larger than the begin value.\n0 DISASM0208E   Bad hex digit in displacement\n                An invalid character was found in a hex value.  Valid\n                digits are 0-9 and A-F.\n0 DISASM0209E   Too many digits in displacement\n                Displacement values must be 8 characters or less.\n0 DISASM0210E   End displacement not allowed unless start displacement\n                is specified\n                On USING statements the beginning and ending displacemen\n                values are optional.  If the ending displacement is\n                given, the beginning displacement is also required.\n0 DISASM0211E   Label prefix cannot be blank\n                The prefix value on a PREFIX or LABEL statement has a\n                blank in the first byte.\n0 DISASM0212E   Label prefixes must be 4 characters or less\n                The value on a PREFIX or LABEL statement is more than\n                4 characters long.  Label prefixes must be 4 characters\n                or less.\n0 DISASM0213E   Base register is blank\n                The base register on a BASE or USING statement is blank.\n0 DISASM0214E   Base register name exceeds 3 characters in length\n                The base register on a BASE or USING statement is more\n                than 3 characters long.  Valid values are 0-15, A-F,\n                R0-R15, and RA-RF.\n0 DISASM0215E   'DATA' is reserved for data area prefixes, choose\n                another prefix\n0 DISASM0216E   Invalid digit in LINE/LINES/MAXLINES statement\n                The line count limit specified contains a non-numeric\n                digit.\n0 DISASM0217E   Line count value on a LINE/LINES/MAXLINES statement is\n                too long or contains extraneous data\n                The line count value is 1 to 3 digits.  Either the value\n                is more than 3 digits or there is other data in the\n                next 6 spaces.\n0 DISASM0218E   Line count value on a LINE/LINES/MAXLINES statement is\n                below minimum allowed\n                A minimum allowable line count value is specified in the\n                global options (member DISASMGB) when DISASM is genned.\n                The value you are requesting is below this minimum.\n0 DISASM0219E   Label prefix has already been defined, choose one or the\n                other\n                DISASM only allows 1 label prefix value.  The PREFIX or\n                LABEL statement has been found more than once.  Choose\n                one of the prefixes and delete the second statement.\n0 DISASM0220E   Label prefix must be defined when base register(s) are\n                defined\n                When a BASE is defined, labels will be generated for\n                any points referenced within the CSECT.  Labels require\n                a 1 to 4 character prefix specified by either the LABEL\n                or PREFIX statement.\n0 DISASM0221E   Label prefix not value unless base register(s) are defin\n                Labels for the CSECT cannot be generated unless a BASE\n                is defined.\n0 DISASM0222E   This area overlaps data at xxxx to xxxx\n                An area being defined as a DATA area overlaps another\n                area that has already been defined at xxxx to xxxx.\n0 DISASM0223E   Beginning displacement is larger than ending displacemen\n                The beginning displacement is larger than the ending\n                displacement on a BASE statement.\n0 DISASM0301E   Specified CSECT not found\n                The CSECT specified on the CSECT statement is not a\n                part of the specified MODULE or the module contains no\n                CSECTs.\n0 DISASM0302E   Unknown return code from POINT macro\n                DISASM received a return code from the POINT macro that\n                it could not interpret.\n0 DISASM0303E   DCB EODAD routine driven, end of control records not\n                detected\n                The EODAD routine of the DISMOD DCB should never be\n                driven.  The last record of the requested CSECT should\n                be detected.  This is an internal logic error.\n0 DISASM0304E   Module does not exist in DISMOD library\n                The member specified on the MODULE statement was not\n                found in the DISMOD library.\n0 DISASM0305E   Permanent I/O error\n                BLDL received return code 08 with reason code 01.\n0 DISASM0306E   Insufficient virtual storage\n                BLDL received return code 08 with reason code 04.\n0 DISASM0307E   DEB not in KEY 0-7\n                BLDL received return code 08 with reason code 08.\n0 DISASM0308E   Device does not support block identifier\n                POINT received return code 04 with reason code 00.\n0 DISASM0309E   Incorrect parameter\n                POINT received return code 08 with reason code 01.\n0 DISASM0310E   Incorrect DEB or DEBCHK error\n                POINT received return code 08 with reason code 02.\n0 DISASM0311E   Environmental error\n                POINT received return code 08 with reason code 03.\n0 DISASM0312E   Unsuccessful call to ESTAE\n                POINT received return code 08 with reason code 0B.\n0 DISASM0313E   Unsuccessful GETMAIN\n                POINT received return code 08 with reason code 0C.\n0 DISASM0314E   Input/output error\n                POINT received return code 0C with reason code 00.\n0 DISASM0501E   Unknwon RLD data type\n                RLD data contains an item that is of an unknown type.\n                DISASM will have abended with code user 003.\n0 DISASM0502E   RLD data remaining went negative\n                Internal logic error in module DISASM05.\n                DISASM will have abended with code user 004.\n0 DISASM0503E   RLD pointer larger than number of ESD items\n                Some RLD items have corresponding ESD items.  When\n                the pointer value is non-zero, it is the relative number\n                of the ESD item it is associated with.  In this case the\n                pointer value is larger than the number of ESD items.\n0 DISASM0504E   RLD data at xxxx to xxxx overlpas a user defined data\n                area at xxxx to xxxx\n0 DISASM0701I   Assembler return code was xxxx\n                If the return code is greater than 4, DISASM will abort\n                processing.  If you need to view the assembler output,\n                allocate the DISDEBUG DD.\n0 DISASM0702I   No assembler input, no DSECTs\n0 DISASM0703E   Error assembling DSECTs, check assembler output in DISDE\n                The return code from the assembler was greater than 4.\n0 DISASM0801E   DSECT xxxxxxxx is not present, but is referenced on a\n                USING statement.\n                Either 1) the source for the DSECT was not provided\n                       2) the PRINT of the assembler was turned off\n                       3) the name is misspelled\n                If you are sure the name is correct and the source is\n                present, allocate DISDEBUG and check the assembler outpu\n0 DISASM0802E   Instructions overlap data defined at xxxx to xxxx\n                Instruction lengths are determined by the opcodes.  If\n                a portion of an instruction overlaps into a DATA area,\n                this is considered an error condition.  Either increase\n                the size of the DATA area to include the entire instruc-\n                tion, or decrease the size of the DATA area so it does\n                not overlap the end of the instruction.\n0 DISASM0803W   aaaaaaaa displacement in a bbbbbbbb block is changed\n                from xxxx to yyyy to reference an instruction boundary\n                   aaaaaaaa is either BEGINNING or ENDING\n                   bbbbbbbb is either BASE or USING\n                The beginning and ending displacements on BASE and USING\n                statements must reference instruction boundaries.  This\n                is because the USING or DROP statements generated cannot\n                occur in the middle of an instruction.  If a displacemen\n                is found that is not on instruction boundary, it is forc\n                to the beginning of the preceding instruction.\n0 DISASM0804E   Invalid opcode during reference table generation\n                Internal logic error in DISASM08.\n0 DISASM0805E   Label llllllll is not in DSECT dddddddd as requested on\n                a USING statement\n                If you are sure the label is in the DSECT, allocate\n                DISDEBUG to verify the assembler output.\n0 DISASM0806E   Label not found in DSECT durint reference table generati\n                Internal logic error in DISASM08.\n0 DISASM0808E   Overlapping data areas not detected by DISASM02\n                Interal logic error.\n0 DISASM0809E   Attempt to locate an instruction on an odd displacement\n                boundary\n                Internal error in DISASM08, DISASM will abend with code\n                user 005.\n0 DISASM0901E   Data area overlaps an instruction, should have been\n                detected by DISASM08.\n                Internal logic error.  See explanation of DISASM0802E.\n0DISASM0902E    Invalid opcode detected\n                Internal error.\n0DISASM0903E    DC with length = zero detected\n                Internal error.\n0DISASM0904E    Attempt to generate an instruction on an odd address\n                boundary\n                Internal error.\n1                 Program description\n This disassembler attempts to re-create assembler source from object\n code.  Label references are generated if the base registers for the\n CSECT or DSECTs are defined.\n0CSECT labels will be generated for data referenced within the CSECT\n if BASE statements define the base register(s).  References to\n instructions will cause labels to be generated that occur at the\n displacement of the first byte of the instruction.  If the reference\n is not on the first byte of the instruction, the label will be referred\n to with a \"+displacement\".  For example if a program is self-modifying\n and sets the length in a MVC instruction with a STC that references the\n MVC instruction, the generated source might look like:\n0            .\n             STC   R1,MAIN002C+1\n             .\n             .\n    MAIN002C MVC  DATAOUT(1),0(R2)\n             .\n0Labels will also be generated for any ENTRY points defined in the ESD\n data for the CSECT.\n0DSECT labels require the DSECT's source to be assembled, and the base\n defined via a USING statement.  Assembler-H (IEV90) is invoked\n dynamically to assemble the DSECT(s).  The assembler output listing\n is scanned to determine the DSECT names, label names, and the displace-\n ment to the label in the DSECT.  In order for the disassembler to\n detect DSECTs and the labels, the assembler print must be on.  If any\n macro or copy code turns off the print, the DSECTs and labels will\n be unknown.  Any DSECT referred to by a USING statement must be defined\n by having the assembler assemble it.\n0Assembler source statements are delimited by ASM START/ASM END.  Any\n statements between the ASM START and ASM END statements will be copied\n to the assembler input data set and appended onto the end of the source\n written to DISPUNCH.  Any macros not in the assembler input stream must\n be available in a library in the SYSLIB concatenation.  If the return\n code from the assembler is greater than 4, the disassembler discontinue\n any further processing.  If there is no assembler input, the SYSPRINT,\n SYSIN, SYSUT1, SYSPUNCH, and SYSLIB DD's may be omitted.\n0If the DISPUNCH DD is present, the generated code will also be\n written to this data set as 80-byte records suitable as input to the\n assembler.\n0Object code is considered to be an instruction if:\n    1) it is not in a defined data area\n    2) it is on an even address boundary\n    3) it is a valid opcode\n    4) it does not overlap into a defined data area or RLD item.\n    5) it is followed by another valid opcode or is an unconditional\n       branch or SVC.\n    6) a string of upper or lower case ebcdic is not considered a valid\n       instruction.\n    7) if \"NO FLOAT\" was requested, the instruction cannot be a floating\n       point instruction.\n0THE VALID OPCODES INCLUDE XA, BUT NOT ESA (AR) INSTRUCTIONS.\n0Extended mnemonics are used if possible for branch instructions.\n0SVC's are interpreted if possible (SVC 0A is identified as GETMAIN).\n0The DISDEBUG DD statement is optional.  If present, many internal\n fields and data chains will be printed to aid in debugging problems\n with the disassembler.  The assembler output is copied to DISDEBUG\n for diagnosing errors with the assembler input.\n./ ADD MEMBER=DISASMOP\n          TITLE 'DISASMOP - OPCODE TABLE'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASMOP                                             *\n*                                                                    *\n*  Function:                                                         *\n*     Define valid machine opcodes.                                  *\n*                                                                    *\n*--------------------------------------------------------------------*\n* Modified : Paul Gillis - P. C. Link Pty. Ltd. 28 September 1999    *\n*            Cater for all B2/01 opcodes found in SA22-7209-01       *\n*            and for LAE, LAM and STAM opcodes                       *\n* Modified : Ken Sharpe - 15 March 2011                             KLS\n*            B2 and 01 OPCODE entries need a comment field for use  KLS\n*            by program DISASMB2.                                   KLS\n*--------------------------------------------------------------------*\n         COPY   DISASMGB\nDISASMOP CSECT\nDISASMOP AMODE  31\nDISASMOP RMODE  24\n         ORG    DISASMOP+(256*4)\n* ------------------------------------------------------------------- *\n*        OPCODE TABLE                                                 *\n* ------------------------------------------------------------------- *\n         OPCODE 00,DC,0,2                 DUMMY ENTRY FOR DC'S\n         OPCODE 01,DC,$OPB2,2,' '                                   KLS\n         OPCODE 04,SPM,$OPRR2,2\n         OPCODE 05,BALR,$OPRR1,2,'PERFORM'\n         OPCODE 06,BCTR,$OPRR1,2,'LOOP'\n         OPCODE 07,BCR,$OPRR3,2,FLAGS=$OPEXT\n         OPCODE 0A,SVC,$OPRR2,2,'SVC DESCRIPTION',FLAGS=$OPSVC\n         OPCODE 0B,BSM,$OPRR1,2\n         OPCODE 0C,BASSM,$OPRR1,2\n         OPCODE 0D,BASR,$OPRR1,2\n         OPCODE 0E,MVCL,$OPRR1,2,FLAGS=$OPCCA,REGS=$OP1EVEN+$OP2EVEN\n         OPCODE 0F,CLCL,$OPRR1,2,FLAGS=$OPCCA,REGS=$OP1EVEN+$OP2EVEN\n         OPCODE 10,LPR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 11,LNR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 12,LTR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 13,LCR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 14,NR,$OPRR1,2,FLAGS=$OPCCL\n         OPCODE 15,CLR,$OPRR1,2,FLAGS=$OPCCC\n         OPCODE 16,OR,$OPRR1,2,FLAGS=$OPCCL\n         OPCODE 17,XR,$OPRR1,2,FLAGS=$OPCCL\n         OPCODE 18,LR,$OPRR1,2\n         OPCODE 19,CR,$OPRR1,2,FLAGS=$OPCCC\n         OPCODE 1A,AR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 1B,SR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 1C,MR,$OPRR1,2,REGS=$OP1EVEN\n         OPCODE 1D,DR,$OPRR1,2,REGS=$OP1EVEN\n         OPCODE 1E,ALR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 1F,SLR,$OPRR1,2,FLAGS=$OPCCA\n         OPCODE 20,LPDR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 21,LNDR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 22,LTDR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 23,LCDR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 24,HDR,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 25,LRDR,$OPRR1,2,FLAGS=$OPFLOAT,                       +\n               REGS=$OP10246+$OP204\n         OPCODE 26,MXR,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP104+$OP204\n         OPCODE 27,MXDR,$OPRR1,2,FLAGS=$OPFLOAT,                       +\n               REGS=$OP10246+$OP20246\n         OPCODE 28,LDR,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 29,CDR,$OPRR1,2,FLAGS=$OPCCC+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 2A,ADR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 2B,SDR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 2C,MDR,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 2D,DDR,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 2E,AWR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 2F,SWR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 30,LPER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 31,LNER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 32,LTER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 33,LCER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                +\n               REGS=$OP10246+$OP20246\n         OPCODE 34,HER,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 35,LRER,$OPRR1,2,FLAGS=$OPFLOAT,                       +\n               REGS=$OP10246+$OP20246\n         OPCODE 36,AXR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP104+$OP204\n         OPCODE 37,SXR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP104+$OP204\n         OPCODE 38,LER,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 39,CER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 3A,AER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 3B,SER,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 3C,MER,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 3D,DER,$OPRR1,2,FLAGS=$OPFLOAT,                        +\n               REGS=$OP10246+$OP20246\n         OPCODE 3E,AUR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 3F,SUR,$OPRR1,2,FLAGS=$OPCCA+$OPFLOAT,                 +\n               REGS=$OP10246+$OP20246\n         OPCODE 40,STH,$OPRX,4,FLAGS=$OPREF\n         OPCODE 41,LA,$OPRX,4,FLAGS=$OPREF\n         OPCODE 42,STC,$OPRX,4,FLAGS=$OPREF\n         OPCODE 43,IC,$OPRX,4,FLAGS=$OPREF\n         OPCODE 44,EX,$OPRX,4,FLAGS=$OPREF\n         OPCODE 45,BAL,$OPRX,4,'PERFORM',FLAGS=$OPREF\n         OPCODE 46,BCT,$OPRX,4,'LOOP',FLAGS=$OPREF\n         OPCODE 47,BC,$OPRX,4,FLAGS=$OPEXT+$OPREF\n         OPCODE 48,LH,$OPRX,4,FLAGS=$OPREF\n         OPCODE 49,CH,$OPRX,4,FLAGS=$OPREF+$OPCCC\n         OPCODE 4A,AH,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 4B,SH,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 4C,MH,$OPRX,4,FLAGS=$OPREF\n         OPCODE 4D,BAS,$OPRX,4,FLAGS=$OPREF\n         OPCODE 4E,CVD,$OPRX,4,FLAGS=$OPREF\n         OPCODE 4F,CVB,$OPRX,4,FLAGS=$OPREF\n         OPCODE 50,ST,$OPRX,4,FLAGS=$OPREF\n         OPCODE 51,LAE,$OPRX,4,FLAGS=$OPREF+$OPCCA                  PGG\n         OPCODE 54,N,$OPRX,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 55,CL,$OPRX,4,FLAGS=$OPREF+$OPCCC\n         OPCODE 56,O,$OPRX,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 57,X,$OPRX,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 58,L,$OPRX,4,FLAGS=$OPREF\n         OPCODE 59,C,$OPRX,4,FLAGS=$OPREF+$OPCCC\n         OPCODE 5A,A,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 5B,S,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 5C,M,$OPRX,4,FLAGS=$OPREF\n         OPCODE 5D,D,$OPRX,4,FLAGS=$OPREF,                             +\n               REGS=$OP1EVEN\n         OPCODE 5E,AL,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 5F,SL,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 60,STD,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                  +\n               REGS=$OP10246\n         OPCODE 67,MXD,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                  +\n               REGS=$OP104\n         OPCODE 68,LD,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 69,CD,$OPRX,4,FLAGS=$OPREF+$OPCCC+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 6A,AD,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 6B,SD,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 6C,MD,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 6D,DD,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 6E,AW,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 6F,SW,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 70,STE,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                  +\n               REGS=$OP10246\n         OPCODE 78,LE,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 79,CE,$OPRX,4,FLAGS=$OPREF+$OPCCC+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 7A,AE,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 7B,SE,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 7C,ME,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 7D,DE,$OPRX,4,FLAGS=$OPREF+$OPFLOAT,                   +\n               REGS=$OP10246\n         OPCODE 7E,AU,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 7F,SU,$OPRX,4,FLAGS=$OPREF+$OPCCA+$OPFLOAT,            +\n               REGS=$OP10246\n         OPCODE 80,SSM,$OPS,4,FLAGS=$OPREF\n         OPCODE 82,LPSW,$OPS,4,FLAGS=$OPREF\n         OPCODE 83,DIAG,$OPS,4\n         OPCODE 86,BXH,$OPRS2,4,FLAGS=$OPREF\n         OPCODE 87,BXLE,$OPRS2,4,FLAGS=$OPREF\n         OPCODE 88,SRL,$OPRS1,4\n         OPCODE 89,SLL,$OPRS1,4\n         OPCODE 8A,SRA,$OPRS1,4,FLAGS=$OPCCA\n         OPCODE 8B,SLA,$OPRS1,4,FLAGS=$OPCCA\n         OPCODE 8C,SRDL,$OPRS1,4,                                      +\n               REGS=$OP1EVEN\n         OPCODE 8D,SLDL,$OPRS1,4,                                      +\n               REGS=$OP1EVEN\n         OPCODE 8E,SRDA,$OPRS1,4,FLAGS=$OPCCA,                         +\n               REGS=$OP1EVEN\n         OPCODE 8F,SLDA,$OPRS1,4,FLAGS=$OPCCA,                         +\n               REGS=$OP1EVEN\n         OPCODE 90,STM,$OPRS2,4,FLAGS=$OPREF\n         OPCODE 91,TM,$OPSI,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 92,MVI,$OPSI,4,FLAGS=$OPREF\n         OPCODE 93,TS,$OPS,4,FLAGS=$OPREF+$OPCCA\n         OPCODE 94,NI,$OPSI,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 95,CLI,$OPSI,4,FLAGS=$OPREF+$OPCCC\n         OPCODE 96,OI,$OPSI,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 97,XI,$OPSI,4,FLAGS=$OPREF+$OPCCL\n         OPCODE 98,LM,$OPRS2,4,FLAGS=$OPREF\n         OPCODE 99,TRACE,$OPRS2,4,FLAGS=$OPREF\n         OPCODE 9A,LAM,$OPRS2,4,FLAGS=$OPREF                        PGG\n         OPCODE 9B,STAM,$OPRS2,4,FLAGS=$OPREF                       PGG\n         OPCODE AC,STNSM,$OPSI,4,FLAGS=$OPREF\n         OPCODE AD,STOSM,$OPSI,4,FLAGS=$OPREF\n         OPCODE AE,SIGP,$OPRS2,4,FLAGS=$OPCCA\n         OPCODE AF,MC,$OPSI,4\n         OPCODE B1,LRA,$OPRX,4,FLAGS=$OPREF+$OPCCA\n         OPCODE B2,DC,$OPB2,4,' '                                   KLS\n         OPCODE B6,STCTL,$OPRS2,4,FLAGS=$OPREF\n         OPCODE B7,LCTL,$OPRS2,4,FLAGS=$OPREF\n         OPCODE BA,CS,$OPRS2,4,FLAGS=$OPREF+$OPCCC\n         OPCODE BB,CDS,$OPRS2,4,FLAGS=$OPREF+$OPCCC,                   +\n               REGS=$OP1EVEN\n         OPCODE BD,CLM,$OPRS3,4,FLAGS=$OPREF+$OPCCC\n         OPCODE BE,STCM,$OPRS3,4,FLAGS=$OPREF\n         OPCODE BF,ICM,$OPRS3,4,FLAGS=$OPREF+$OPCCA\n         OPCODE D1,MVN,$OPSS1,6,FLAGS=$OPREF\n         OPCODE D2,MVC,$OPSS1,6,FLAGS=$OPREF\n         OPCODE D3,MVZ,$OPSS1,6,FLAGS=$OPREF\n         OPCODE D4,NC,$OPSS1,6,FLAGS=$OPREF+$OPCCL\n         OPCODE D5,CLC,$OPSS1,6,FLAGS=$OPREF+$OPCCC\n         OPCODE D6,OC,$OPSS1,6,FLAGS=$OPREF+$OPCCL\n         OPCODE D7,XC,$OPSS1,6,FLAGS=$OPREF+$OPCCL\n         OPCODE D9,MVCK,$OPSS3,6,FLAGS=$OPCCA\n         OPCODE DA,MVCP,$OPSS3,6,FLAGS=$OPCCA\n         OPCODE DB,MVCS,$OPSS3,6,FLAGS=$OPCCA\n         OPCODE DC,TR,$OPSS1,6,FLAGS=$OPREF\n         OPCODE DD,TRT,$OPSS1,6,FLAGS=$OPREF+$OPCCA\n         OPCODE DE,ED,$OPSS1,6,FLAGS=$OPREF+$OPCCA\n         OPCODE DF,EDMK,$OPSS1,6,FLAGS=$OPREF+$OPCCA\n         OPCODE E8,MVCIN,$OPSS1,6,FLAGS=$OPREF\n         OPCODE F0,SRP,$OPSS4,6,FLAGS=$OPREF+$OPCCA\n         OPCODE F1,MVO,$OPSS2,6,FLAGS=$OPREF\n         OPCODE F2,PACK,$OPSS2,6,FLAGS=$OPREF\n         OPCODE F3,UNPK,$OPSS2,6,FLAGS=$OPREF\n         OPCODE F8,ZAP,$OPSS2,6,FLAGS=$OPREF+$OPCCA\n         OPCODE F9,CP,$OPSS2,6,FLAGS=$OPREF+$OPCCC\n         OPCODE FA,AP,$OPSS2,6,FLAGS=$OPREF+$OPCCA\n         OPCODE FB,SP,$OPSS2,6,FLAGS=$OPREF+$OPCCA\n         OPCODE FC,MP,$OPSS2,6,FLAGS=$OPREF\n         OPCODE FD,DP,$OPSS2,6,FLAGS=$OPREF\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        INDEX TO OPCODE TABLE                                        *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         ORG    DISASMOP+0\nOPINDEX  DS     0A\n         OPCODE TYPE=INDEX\n         COPY   DISASMDA\n         END    DISASMOP\n./ ADD MEMBER=DISASMPR\n         TITLE 'DISASMPR PRINTER MODULE'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Module name: DISASMPR - Printing module                            *\n*                                                                     *\n*  Function:                                                          *\n*   DISASM was written in multiple CSECTs to keep any one module from *\n*   being excessively large and avoid some base register concerns due *\n*   to size, and to functionally divide up the over-all logic.  Since *\n*   printing was to be necessary from many modules, it seemed best to *\n*   have a separate print module.  All printing except DISDEBUG is    *\n*   done here.                                                        *\n*                                                                     *\n*   The interface block is PRTBLOK.                                   *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         COPY  DISASMGB\nDISASMPR CSECT\nDISASMPR AMODE 31\nDISASMPR RMODE 24\n         USING DISASMPR,R12\n         USING DISASM00,R11\n         USING PRTBLOK,R10           DEFINE PARAMETER BLOCK BASE\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     PRT0000               SKIP EYECATCHER\n         DC    CL8'DISASMPR'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nPRT0000  DS    0H\n         LA    R15,PRTSAVE           OUR SAVE AREA ADDRESS\n         ST    R13,4(R15)            CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R15,8(R13)            CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R15               SET SAVE AREA ADDRESS\n         LR    R10,R1                COPY PARM BLOCK ADDRESS\n         ITRACE ID=ENTRY,            TRACE PRINT MODULE ENTRY          +\n               DATA1=PRTCMD          .. TRACE COMMAND\n         CLI   PRTCMD,$PRTCLS        CLOSE FILES?\n         BE    PRT0300               YES\n         TM    PRTFLAG,$PRTOPEN      IS PRINT FILE OPEN?\n         BO    PRT0010               YES\n         ITRACE ID=PRTOPEN           TRACE PRINT DCB OPENING\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (DISPRINT,OUTPUT)     OPEN DISPRINT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         OI    PRTFLAG,$PRTOPEN      SET 'OPEN' FLAG\nPRT0010  DS    0H\n         CLI   PRTCMD,$PRTHEAD       PRINT HEADING?\n         BE    PRT0100               YES\n         CLI   PRTCMD,$PRTSUBH       PRINT SUB-HEADING?\n         BE    PRT0110               YES\n         CLI   PRTCMD,$PRTPRT        PRINT DATA?\n         BE    PRT0020               YES\n         ABEND 1,DUMP,,USER          ABEND\n         SPACE 2\n* ------------------------------------------------------------------- *\n*                                                                     *\n* ------------------------------------------------------------------- *\nPRT0020  DS    0H\n         ZAP   LINEWORK,P1           SET WORK TO 1\n         CLI   PRTCC,C' '            SINGLE SPACE?\n         BE    PRT0030               YES\n         AP    LINEWORK,P1           ADD 1 TO WORK\n         CLI   PRTCC,C'0'            DOUBLE SPACE\n         BE    PRT0030               YES\n         AP    LINEWORK,P1           ADD 1 TO WORK\nPRT0030  DS    0H\n         AP    LINEWORK,LINECT       NEW LINE COUNT\n         CP    LINEWORK,COMMMAXL     WILL PAGE OVERFLOW?\n         BNH   PRT0040               NO\n         ITRACE ID=PAGEFULL          PAGE IS FULL\n         BAL   R9,PRT0200            PRINT HEADING\nPRT0040  DS    0H\n         ITRACE ID=PRINT             PRINTING DATA\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISPRINT,PRTCC        PRINT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\n         CLI   PRTCC,C' '            SINGLE SPACE?\n         BE    PRT0050               YES\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\n         CLI   PRTCC,C'0'            DOUBLE SPACE\n         BE    PRT0050               YES\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\nPRT0050  DS    0H\n         MVI   PRTDATA,C' '          INTIALIZE PRINT\n         MVC   PRTDATA+1(L'PRTDATA-1),PRTDATA\n         B     PRT9900               EXIT\n* ------------------------------------------------------------------- *\n*             FORCED HEADINGS                                         *\n* ------------------------------------------------------------------- *\nPRT0100  DS    0H\n         ITRACE ID=FORCEDHD          FORCED HEADING\n         BAL   R9,PRT0200            PRINT HEADING\n         B     PRT9900               AND EXIT\n* ------------------------------------------------------------------- *\n*             FORCED SUB-HEADINGS                                     *\n* ------------------------------------------------------------------- *\nPRT0110  DS    0H\n         ITRACE ID=FORCESHD          FORCED SUB-HEADING\n         BAL   R9,PRT0210            PRINT HEADING\n         B     PRT9900               AND EXIT\n* ------------------------------------------------------------------- *\n*             PRINT HEADING                                           *\n* ------------------------------------------------------------------- *\nPRT0200  DS    0H\n         ITRACE ID=PRTHEAD           PRINTING HEADING\n         AP    PAGECT,P1             ADD 1 TO PAGE COUNT\n         MVC   HEADPAGE,PAGEEDWD     SET EDIT WORD\n         ED    HEADPAGE,PAGECT       EDIT PAGE NUMBER\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISPRINT,HEADING      WRITE HEADING\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         ZAP   LINECT,P1             SET LINE COUNT TO 1\nPRT0210  DS    0H\n         SR    R1,R1                 CLEAR REGISTER\n         ICM   R1,1,COMMSUBL+1       SUBHEADING LENGTH\n         BZR   R9                    NO SUB-HEADING\n         CLI   COMMSUBL,X'FF'        NON-CENTERED HEADING?\n         BE    PRT0220               YES\n         LA    R2,L'SUBHWORK         WORK AREA SIZE\n         SR    R2,R1                 MINUS SUBHEADING LENGTH\n         SRL   R2,1                  DIVIDED BY 2\n         MVI   SUBHWORK,C'-'         INITIALIZE WITH HYPHEN\n         MVC   SUBHWORK+1(L'SUBHWORK-1),SUBHWORK\n         LA    R2,SUBHWORK(R2)       ADDRESS FOR CENTERED SUB-HEADING\n         BCTR  R1,0                  FOR EXECUTE\n         EX    R1,SUBHMVC1           MOVE SUB-HEADING\n         B     PRT0230\nPRT0220  DS    0H\n         BCTR  R1,0                  MINUS 1\n         EX    R1,SUBHMVC2           MOVE NON-CENTERED\nPRT0230  DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISPRINT,SUBHCC       PRINT SUBHEADING\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\n         MVI   SUBHWORK,C' '         CLEAR WORK AREA\n         MVC   SUBHWORK+1(L'SUBHWORK-1),SUBHWORK\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISPRINT,SUBHCC       PRINT BLANK LINE\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         AP    LINECT,P1             ADD 1 TO LINE COUNT\n         BR    R9\n* ------------------------------------------------------------------- *\n*             CLOSE PRINTER                                           *\n* ------------------------------------------------------------------- *\nPRT0300  DS    0H\n         ITRACE ID=PRTCLOSE          CLOSING PRINT DCB\n         TM    PRTFLAG,$PRTOPEN      PRINTER OPEN?\n         BNO   PRT9900               NO.. EXIT\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         CLOSE DISPRINT              CLOSE PRINTER\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         NI    PRTFLAG,255-$PRTOPEN  TURN OPEN FLAG OFF\n* ------------------------------------------------------------------- *\n*             EXIT                                                    *\n* ------------------------------------------------------------------- *\nPRT9900  DS    0H\n         ITRACE ID=EXIT              EXITING PRINT MODULE\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nAM24     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         BSM   R0,R14             RETURN IN 24-BIT MODE\nAM31     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         O     R14,X80            SET 31-BIT MODE\n         BSM   R0,R14             RETURN IN 31-BIT MODE\nSUBHMVC1 MVC   0(0,R2),COMMSUBH      COPY SUBHEADING (CENTERED)\nSUBHMVC2 MVC   SUBHWORK(0),COMMSUBH  COPY SUBHEADING (NON-CENTERED)\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              WORK AREAS                                            *\n*                                                                    *\n* ------------------------------------------------------------------ *\nPRTSAVE  DC    18F'0'                REGISTER SAVE AREA\nX80      DC    A(X'80000000')\nPRTFLAG  DC    X'00'\n$PRTOPEN EQU   X'80'\nP1       DC    P'1'                  CONSTANT\nLINECT   DC    PL3'0'                LINE COUNT\nLINEWORK DC    PL3'0'                LINES ADDED BY THIS I/O\nPAGECT   DC    PL3'0'                PAGE COUNT\nPAGEEDWD DC    X'402020202120'       CONSTANT\nHEADING  DS    0C\n         DC    CL01'1'\n         DC    CL53' '\n         DC    CL15'DISASSEMBLER'\n         DC    CL54' '\n         DC    CL04'PAGE'\nHEADPAGE DC    CL06' '\nSUBHCC   DC    C'0'\nSUBHWORK DC    CL133' '\nDISPRINT DCB   DSORG=PS,                     PRINTER DCB               +\n               RECFM=FBA,                    .. RECORD FORMAT          +\n               LRECL=L'PRTCC+L'PRTDATA,      .. RECORD LENGTH          +\n               DDNAME=DISPRINT,              .. DD NAME                +\n               MACRF=PM                      .. MACRO FORMAT\n         LTORG\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              PRINT MODULE INTERFACE BLOCK                          *\n*                                                                    *\n* ------------------------------------------------------------------ *\nPRTBLOK  PRTBLOK  TYPE=DSECT\n         SPACE 2\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              COMMON DATA MAP                                       *\n*                                                                    *\n* ------------------------------------------------------------------ *\nDISASM00 DISASM00 TYPE=DSECT\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              EQUATES                                               *\n*                                                                    *\n* ------------------------------------------------------------------ *\n         COPY REGEQU\n         END  DISASMPR\n./ ADD MEMBER=DISASMRR\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Module name: DISASMRR - Verify operands for RR format instructions *\n*                                                                     *\n*  Function:                                                          *\n*   Some instructions require that the operand(s) be even-odd pairs   *\n*   of registers.  This code verifies the operands for most 'RR'      *\n*   format instructions.                                              *\n*                                                                     *\n*   At entry R8 will be address of the current OPCODE table entry.    *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         COPY  DISASMGB\nDISASMRR CSECT\nDISASMRR AMODE 31\nDISASMRR RMODE 24\n         USING DISASMRR,R12\n         USING OPDSECT,R8            DEFINE OPCODE DSECT BASE\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     VER0000               SKIP EYECATCHER\n         DC    CL8'DISASMRR'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nVER0000  DS    0H\n         TM    OPREGS,X'F0'          RESTRICTIONS ON OPERAND 1?\n         BZ    VER0100               NO\n         TM    1(R5),X'10'           OPERAND 1 AN ODD NUMBER?\n         BO    BAD0000               YES.. BAD\n         TM    OPREGS,$OP1EVEN       JUST INTERESTED IN AN EVEN NUMBER?\n         BO    VER0100               OPERAND 1 IS OK, CHECK OPERAND 2\n         TM    1(R5),X'80'           REGISTER NUMBER 8 OR GREATER?\n         BO    BAD0000               YES.. CANNOT BE VALID\n         TM    OPREGS,$OP10246       NEED 0, 2, 4, OR 6?\n         BO    VER0100               OPERAND 1 IS OK, CHECK OPERAND 2\n         TM    1(R5),X'20'           REGISTER 2 OR 6?\n         BO    BAD0000               YES.. NOT VALID\nVER0100  DS    0H\n         TM    OPREGS,X'0F'          RESTRICTIONS ON OPERAND 2?\n         BZ    GOOD0000              NO.. ALL OPERANDS ARE OK\n         TM    1(R5),X'01'           OPERAND 2 AN ODD NUMBER?\n         BO    BAD0000               YES.. BAD\n         TM    OPREGS,$OP2EVEN       JUST INTERESTED IN AN EVEN NUMBER?\n         BO    GOOD0000              ALL OPERANDS ARE OK\n         TM    1(R5),X'08'           REGISTER NUMBER 8 OR GREATER?\n         BO    BAD0000               YES.. CANNOT BE VALID\n         TM    OPREGS,$OP20246       NEED 0, 2, 4, OR 6?\n         BO    GOOD0000              ALL OPERANDS ARE OK\n         TM    1(R5),X'02'           REGISTER 2 OR 6?\n         BO    BAD0000               YES.. NOT VALID\nGOOD0000 DS    0H\n         SR    R15,R15               OPERAND(S) ARE OK\n         B     EXIT0000              EXIT\nBAD0000  DS    0H\n         LA    R15,8                 OPERAND(S) ARE NOT OK\n* ------------------------------------------------------------------- *\n*             EXIT                                                    *\n* ------------------------------------------------------------------- *\nEXIT0000 DS    0H\n         L     R14,12(R13)           RESTORE R14\n         LM    R0,R12,20(R13)        RESTORE OTHER REGISTERS\n         BR    R14                   RETURN TO CALLER\n* ------------------------------------------------------------------ *\n*                                                                    *\n*              EQUATES                                               *\n*                                                                    *\n* ------------------------------------------------------------------ *\n         COPY DISASMDA\n         COPY REGEQU\n         END  DISASMRR\n./ ADD MEMBER=DISASMTS\n1   I read the article on the disassembler by Alan Field in the\n February issue of Technical Support.  I have used the disassembler\n mentioned in the article (from file 217 of the CBT).  There are\n several things about this disassembler that I thought could be improved\n For example, I wanted the disassembler listing to look as much like the\n original assembler list as possible.  The disassembler did allow DSECTs\n to be defined, but you had to code statements to do this yourself.\n Some parameters were entered via the \"PARM\" on the execute statement,\n others by SYSIN type statements.  There were some fixed size tables\n that could fill up.\n0   I wrote a new disassembler, borrowing from the one on the CBT.  The\n new program produces a listing very similar to assembler output.  DSECT\n are defined by using the actual dsect source or macro.  There are no\n hardcoded fixed size tables that may fill up.  All control parameters\n are entered via \"SYSIN\" type statements.  I admitted up front that ther\n would be problems that would be difficult to trouble shoot, so the\n program has a built in internal trace table.  There turned out to be\n so many internal control blocks that following the chains in a dump\n was very time consuming, so I wrote a \"debug\" program to run the chains\n and format the data at specific points.\n0   Whereas the \"old\" disassembler consisted of 3 modules, mine has 15.\n The individual CSECTs are:\n             DISASM00 - common data and trace table code\n             DISASM01 - mainline\n             DISASM02 - parameter reader/converter\n             DISASM03 - object code reader\n             DISASM04 - ESD data processor\n             DISASM05 - RLD data processor\n             DISASM06 - text printer\n             DISASM07 - assembler interface/dsect interpreter\n             DISASM08 - reference table builder\n             DISASM09 - source code generator\n             DISASMB2 - interprets \"B2xx\" opcodes\n             DISASMDB - debug\n             DISASMOP - opcode table\n             DISASMPR - printer\n             DISASMPR - verifies register operands\n Altogether the code comes to about 38K.\n0   As in the \"old\" disassembler, extended mnemonics are used if possibl\n for branch instructions.  SVC's are interpreted (the macro is not re-\n coded).  Control statements allow the definition of areas that do not\n contain instructions.  If the DISPUNCH DD is allocated, an 80-byte\n card type source deck will be produced that may be used as input to the\n assembler.\n0   Labels generated for the disassembled CSECT have a form PPPPNNNN.\n If the label precedes an instruction, the PPPP is a 1 to 4 character\n user supplied prefix.  If the label preceeds a data area, PPPP is the\n literal \"DATA\".  NNNN is either the displacement into the CSECT where\n the label appears or is a sequentially assigned number (0010, 0020,\n etc).  Sequentially numbered labels may be more desirable if the source\n is to be modified because the label may no longer be at the same\n displacement.\n0   If the disassembler can determine a label, it will use it in the\n generated source.  Instead of a MVC instruction always looking like:\n \"MVC   324(18,R2),21(R3)\", it might look like \"MVC   FIELDB(18),FIELDA\"\n0   ENTRY points will be reproduced from the ESD data.  RLD items will\n cause an ADCON, VCON, Q, or CXD at the point the RLD item exists.\n ADCONs will cause a label to be generated at the point referenced by\n the ADCON.  VCONs and Q type items will have the name inserted:\n \"DC  V(nnnnn)\" or \"Q(nnnnn)\".\n0   I tried to make the program as self documenting and as uncluttered\n as possible.  By breaking it up into multiple CSECTs functions could\n be isolated.  This kept base register problems to a minimum and allowed\n some isolation of testing individual components.\n-                       PROGRAM DESCRIPTION\n   STEP   MODULE\n     1   DISASM01  Acquire trace table storage and initialize the trace\n                   control data in DISASM00.\n     2   DISASM01  Scan the TIOT to determine which DD's are present.\n     3   DISASM01  Verify that all required DD's were present.\n     4   DISASM01  Call the parameter reader, DISASM02.\n     5   DISASM02  Read all control statements.  Each statement is\n                   printed on the DISPRINT listing.  All parameters\n                   set fields or flags in the common module, DISASM00.\n     6   DISASM02  When end-of-file is reached on DISIN, verify that all\n                   required parameters were entered.\n     7   DISASM01  If there were errors detected by DISASM02, an error\n                   message is issued and the program terminates.\n     8   DISASM01  Acquire storage for object module I/O area.\n     9   DISASM01  Call the ojbect module reader, DISASM03.\n    10   DISASM03  Issue a BLDL for the specified module.\n    11   DISASM03  If the BLDL was unsuccessful, interpret the return\n                     A) interpret the BLDL return code\n                     B) print an error message\n                     C) set the abort flag\n                     D) return to mainline\n    12   DISASM03  Interpret data from the directory data (text's TTR,\n                       entry point, module's length, etc).\n    13   DISASM03  Issue a POINT to prepare for reading the module.\n    14   DISASM03  If the POINT was unsuccessful\n                     A) interpret the POINT return code\n                     B) print an error message\n                     C) set the abort flag\n                     D) return to mainline\n    15   DISASM03  Read records from the object module:\n    16   DISASM03  If the record contains\n                     A) CESD records, process them internally.  If this\n                        is the requested CSECT's data, copy the data\n                        into the storage acquired by DISASM04.\n                     B) ESD data, call DISASM04 to process.\n         DISASM04       DISASM04 interprets and prints the ESD data.\n                        ESD info is saved in \"ESDDATA\" blocks chained\n                        from the common data module, DISASM00.  If the\n                        requested CSECT is found, acquire storage for\n                        text, and set the \"CSECT found\" flag.\n                     C) RLD data, call DISASM05 to process.\n         DISASM05       DISASM05 interprets and prints RLD data.  RLD\n                        info is saved in \"RLDDATA\" blocks chained from\n                        the common data module, DISASM00.  DISASM05\n                        verifies that the RLD items are not in an area\n                        defined as data by DATA statements.  If an RLD\n                        item is in a DATA area-\n                             a) print an error message\n                             b) set the abort flag\n                        RLD items are checked to see if they reference\n                        ESD items (like VCONs).  If an RLD item does\n                        reference an ESD entry, the ESD item is linked\n                        to the RLD item so the name can be generated.\n    17   DISASM01  If there were errors detected by DISASM03, DISASM04,\n                   or DISASM05, an error message is issued and the\n                   program terminates.\n    18   DISASM01  Call the object text printer DISASM06.\n    19   DISASM06  Prints the object module in dump type format.\n    20   DISASM01  Call the assembler interface and dsect interpreter,\n                   DISASM07.\n    21   DISASM07  If no assembler input was specified in the DISIN\n                   parameters, issue a message and return to mainline.\n    22   DISASM07  LOAD the assembler, IEV90.\n    23   DISASM07  Link to the assembler.\n    24   DISASM07  Print the assembler return code.\n    25   DISASM07  Read the assembler listing -\n                      A) when a DSECT is detected, add a new DSCTBLOK\n                         to the chain (CSECT's are treated the same\n                         as DSECT's).\n                      B) when a label is detected add it to the label\n                         chain from the current DSECT.\n    26   DISASM08  Chain the USING blocks to the DSECT blocks they\n                   refer to.\n    27   DISASM08  Scan the object code and determine the displacements\n                   where valid instructions occur. Generate DATA blocks\n                   for any areas that do not contain instructions.\n    28   DISASM08  Verify that all BASE and USINGs reference instruction\n                   boundaries.\n    29   DISASM08  Generate LABELs for ENTRY points in the requested\n                   CSECT.\n    30   DISASM08  Generate LABELs for ADCON references.\n    31   DISASM08  Generate the reference table.  If the disassembler\n                   can determine a label in the CSECT or a DSECT,\n                   the \"reference\" will be the address of the LABEL\n                   block and the displacement from that label.\n    32   DISASM09  Source code generation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n./ ADD MEMBER=DISASM00\n         TITLE 'DISASM00 - COMMON DATA MODULE'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM00                                             *\n*                                                                    *\n*  Function:                                                         *\n*              Common data module and trace table.                   *\n*              At initialization time, the mainline module, DISASM01,*\n*              sets R11 to the address of DISASM00.  All other       *\n*              modules depend on this address remaining unchanged.   *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB\nDISASM00 DISASM00 TYPE=CSECT\n         COPY  REGEQU\n         END\n./ ADD MEMBER=DISASM01\n         TITLE 'DISASM01 - MAINLINE'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM01                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Mainline module.                                                 *\n*                                                                    *\n*     STEP                                                           *\n*       1. Set R11 to address of DISASM00 (the common module).       *\n*       2. Acquire storage for the trace table and initialize the    *\n*          control data in DISASM00.                                 *\n*       3. Scan the TIOT to determine which DD's are present.        *\n*       4. Verify required DD's are present.                         *\n*       5. Call the parameter reader module, DISASM02.               *\n*       6. Call the debug module, DISASMDB to print internal data.   *\n*       7. If errors from DISASM02, print message, go to step 21.    *\n*       8. Call the module reader, DISASM03.                         *\n*       9. If errors from DISASM03, print message, go to step 21.    *\n*      10. Call the text printer module DISASM06.                    *\n*      11. Call the debug module, DISASMDB to print internal data.   *\n*      12. If errors from DISASM06, print message, go to step 21.    *\n*      13. Call assembler interface module, DISASM07 to assemble     *\n*          DSECTs and build dsect/dsect label chains.                *\n*      14. Call the debug module, DISASMDB to print internal data.   *\n*      15. If errors from DISASM07, print message, go to step 21.    *\n*      16. Call module DISASM08 to build the internal labels and     *\n*          the reference table.                                      *\n*      17. Call the debug module, DISASMDB to print internal data.   *\n*      18. If errors from DISASM08, print message, go to step 21.    *\n*      19. Call the source code generator, DISASM09.                 *\n*      20. If errors from DISASM09, print message.                   *\n*      21. Free the storage for all internal chains and the trace    *\n*          table.                                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB              COPY GLOBAL OPTIONS\nDISASM01 CSECT\nDISASM01 AMODE 31\nDISASM01 RMODE 24\n         USING DISASM01,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     MAIN0000              SKIP EYECATCHER\n         DC    CL8'DISASM01'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nMAIN0000 DS    0H\n         L     R11,V00               DISASM00'S ADDRESS\n         LA    R1,SAVE01             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n* ------------------------------------------------------------------- *\n*         Initialize trace table                                      *\n* ------------------------------------------------------------------- *\n         AIF   ('&TROPT' EQ 'OFF').NOTR1\n         L     R2,TRSIZE             TRACE TABLE'S SIZE\n         LA    R2,32(R2)             FOR BOUNDARY ROUNDING\n         GETMAIN RU,                 ACQUIRE STORAGE FOR TRACE TABLE   +\n               LV=(R2),              .. SIZE                           +\n               LOC=ANY               .. ANY AREA\n         ST    R1,TRADDR             SAVE TRACE TABLE ADDRESS\n         LA    R1,32(R1)             PLUS 32\n         SRL   R1,5                  ROUND THE ADDRESS TO...\n         SLL   R1,5                  ...NEAREST MULTIPLE OF 32\n         ST    R1,TR1ST              SET FIRST TRACE ENTRY ADDRESS\n         ST    R1,TRCURR             SET CURRENT TRACE ENTRY ADDRESS\n         XC    0(TRENTRYL,R1),0(R1)  INITIALIZE FIRST ENTRY\n         A     R1,TRSIZE             PLUS USED PORTION'S SIZE\n         SH    R1,COMMH32            MINUS 1 ENTRY\n         ST    R1,TRLAST             INITIALIZE LAST ENTRY ADDRESS\n         ITRACE ID=INIT,             INITIAL TRACE ENTRY               +\n               DATA1=TR1ST,          .. FIRST TRACE TABLE ENTRY ADDR   +\n               DATA2=TRLAST          .. LAST TRACE TABLE ENTRY ADDR\n.NOTR1   ANOP\n* ------------------------------------------------------------------- *\n*         Scan TIOT                                                   *\n* ------------------------------------------------------------------- *\n         USING PSA,R0                DEFINE BASE\n         L     R1,PSATNEW            MY TCB'S ADDRESS\n         USING TCB,R1                DEFINE TCB BASE\n         L     R2,TCBTIO             TIOT ADDRESS\n         USING TIOT1,R2              DEFINE BASE\n         LA    R3,TIOENTRY           FIRST TIOT ENTRY\n         USING TIOENTRY,R3           DEFINE BASE\n         SR    R4,R4                 CLEAR FOR LENGTHS\nMAIN0010 DS    0H\n         ICM   R4,1,TIOELNGH         LENGTH OF THIS ENTRY\n         BZ    MAIN0080              END OF TABLE\n         CLC   TIOEDDNM,INDD         DISIN DD?\n         BE    MAIN0030              YES\n         CLC   TIOEDDNM,PRTDD        DISPRINT DD?\n         BE    MAIN0040              YES\n         CLC   TIOEDDNM,LIBDD        DISMOD DD?\n         BE    MAIN0050              YES\n         CLC   TIOEDDNM,PUNCHDD      DISPUNCHDD?\n         BE    MAIN0060              YES\n         CLC   TIOEDDNM,DEBUGDD      DISDEBUG??\n         BE    MAIN0070              YES\nMAIN0020 DS    0H\n         AR    R3,R4                 NEXT TIOT ENTRY\n         B     MAIN0010              LOOP\nMAIN0030 DS    0H\n         ITRACE ID=INDD              DISIN DD FOUND\n         OI    COMMDD,$INDD          INDICATE DISIN IS PRESENT\n         B     MAIN0020\nMAIN0040 DS    0H\n         ITRACE ID=PRTDD             DISPRINT DD FOUND\n         OI    COMMDD,$PRTDD         INDICATE DISPRINT IS PRESENT\n         B     MAIN0020\nMAIN0050 DS    0H\n         ITRACE ID=MODDD             DISMOD DD FOUND\n         OI    COMMDD,$MODDD         INDICATE DISMOD IS PRESENT\n         B     MAIN0020\nMAIN0060 DS    0H\n         ITRACE ID=PUNCHDD           DISPUNCH DD FOUND\n         OI    COMMDD,$PUNCHDD       INDICATE DISPUNCH IS PRESENT\n         B     MAIN0020\nMAIN0070 DS    0H\n         ITRACE ID=DEBUGDD           DISIN DD FOUND\n         OI    COMMDD,$DEBUGDD       INDICATE DISDEBUG IS PRESENT\n         B     MAIN0020\n* ------------------------------------------------------------------- *\n*         Determine DD'S present                                      *\n* ------------------------------------------------------------------- *\nMAIN0080 DS    0H\n         TM    COMMDD,$PRTDD         WAS PRINT DD FOUND?\n         BO    MAIN0090              YES\n         WTO   'DISPRINT DD STATEMENT MISSING, EXECUTION ABORTED'\n         OI    COMMFLAG,$ABORT+$ERROR SET FLAGS\n         B     EXIT0000              AND EXIT\nMAIN0090 DS    0H\n         MVI   PRTCMD,$PRTHEAD       SET COMMAND\n         LA    R1,PRTBLOK            PRINT INTERFACE BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         TM    COMMDD,$INDD          IS DISIN DD PRESENT?\n         BO    MAIN0100              YES\n         MVC   PRTDATA(MSG04L),MSG04\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ABORT+$ERROR SET FLAGS\nMAIN0100 DS    0H\n         TM    COMMDD,$MODDD         DISMOD DD PRESENT?\n         BO    MAIN0110              YES\n         MVC   PRTDATA(MSG05L),MSG05\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ABORT+$ERROR SET FLAGS\nMAIN0110 DS    0H\n         TM    COMMDD,$PUNCHDD       DISPUNCH DD PRESENT?\n         BO    MAIN0120              YES\n         MVC   PRTDATA(MSG01L),MSG01 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\nMAIN0120 DS    0H\n         TM    COMMFLAG,$ABORT       ABORT FLAG SET?\n         BO    EXIT0000              YES, EXIT\n* ------------------------------------------------------------------- *\n*         Call parameter reader                                       *\n* ------------------------------------------------------------------- *\n         L     R15,A02               PARAMETER READER ENTRY POINT\n         BALR  R14,R15               LINK TO PARAMETER CONVERTER\n         MVC   COMMDBSH,A02SUB       SET SUBHEADING\n         BAL   R10,DEBUG000          CALL DEBUG\n         TM    COMMFLAG,$ABORT       SERIOUS ERROR?\n         BNO   MAIN0130              NO\n         MVC   PRTDATA(MSG06L),MSG06 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\n* ------------------------------------------------------------------- *\n*         Call object module reader                                   *\n* ------------------------------------------------------------------- *\nMAIN0130 DS    0H\n         GETMAIN RU,                 ACQUIRE STORAGE FOR I/O BUFFER    +\n               LV=$IOSIZE,           .. SIZE                           +\n               LOC=BELOW             .. 24-BIT AREA\n         ST    R1,COMMIO             SET ADDRESS IN COMM AREA\n         ITRACE ID=CALLA03           TRACE LINK TO MODULE 03\n         L     R15,A03               MODULE READER ENTRY POINT\n         BALR  R14,R15               LINK TO MODULE READER\n         TM    COMMFLAG,$ABORT       SERIOUS ERROR?\n         BNO   MAIN0140              NO\n         MVC   PRTDATA(MSG07L),MSG07 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\n* ------------------------------------------------------------------- *\n*         Call object text printer                                    *\n* ------------------------------------------------------------------- *\nMAIN0140 DS    0H\n         L     R15,A06               MODULE TEXT PRINTER ENTRY POINT\n         BALR  R14,R15               LINK TO TEXT PRINTER\n         MVC   COMMDBSH,A06SUB       SET SUBHEADING\n         BAL   R10,DEBUG000          CALL DEBUG\n         TM    COMMFLAG,$ABORT       SERIOUS ERROR?\n         BNO   MAIN0150              NO\n         MVC   PRTDATA(MSG08L),MSG08 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*         Call the assembler interface to assemble dsects and build   *\n*         the dsect/dsect label chains.                               *\n*                                                                     *\n* ------------------------------------------------------------------- *\nMAIN0150 DS    0H\n         L     R15,A07               DSECT INTERPRETER ENTRY POINT\n         BALR  R14,R15               LINK TO DSECT INTERPRETER\n         MVC   COMMDBSH,A07SUB       SET SUBHEADING\n         BAL   R10,DEBUG000          CALL DEBUG\n         TM    COMMFLAG,$ABORT       SERIOUS ERROR?\n         BNO   MAIN0160              NO\n         MVC   PRTDATA(MSG09L),MSG09 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*         Call internal label and reference table generator.          *\n*                                                                     *\n* ------------------------------------------------------------------- *\nMAIN0160 DS    0H\n         ITRACE ID=CALL08            CALLING LABEL TABLE GENERATOR\n         L     R15,A08               LABEL GENERATOR ENTRY POINT\n         BALR  R14,R15               LINK TO LABEL GENERATOR\n         MVC   COMMDBSH,A08SUB       SET SUBHEADING\n         BAL   R10,DEBUG000          CALL DEBUG\n         TM    COMMFLAG,$ERROR       ANY ERRORS?\n         BNO   MAIN0170              NO\n         MVC   PRTDATA(MSG10L),MSG10\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\n* ------------------------------------------------------------------- *\n*                                                                     *\n* ------------------------------------------------------------------- *\nMAIN0170 DS    0H\n         ITRACE ID=CALL09            CALLING SOURCE GENERATOR\n         L     R15,A09               SOURCE GENERATOR ENTRY POINT\n         BALR  R14,R15               LINK TO SOURCE GENERATOR\n         TM    COMMFLAG,$ERROR       ANY ERRORS?\n         BO    MAIN0180              YES\n         ITRACE ID=SUCCESS\n         MVC   PRTDATA(MSG03L),MSG03 SET FINAL MESSAGE\n         BAL   R10,PRT0000           PRINT FINAL MESSAGE\n         B     EXIT0000              AND EXIT\nMAIN0180 DS    0H\n         MVC   PRTDATA(MSG11L),MSG11\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\n* ------------------------------------------------------------------- *\n*        Link to DEBUG module                                         *\n* ------------------------------------------------------------------- *\nDEBUG000 DS    0H\n         MVI   DBUGCMD,$DBUG         NORMAL DEBUG\n         LA    R1,DBUGBLOK           PARAMETER BLOCK ADDRESS\n         L     R15,ADB               DEBUG MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO DEBUG MODULE\n         BR    R10                   RETURN\nPRT0000  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R10                   RETURN\nEXIT0000 DS    0H\n         TM    COMMFLAG,$ABEND       ABEND REQUESTED?\n         BNO   EXIT0010              NO\n         ITRACE ID=ABEND\n         MVC   PRTDATA(MSG02L),MSG02 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         ABEND ABEND001,DUMP,,USER   GIVE 'EM WHAT THEY ASKED FOR\nEXIT0010 DS    0H\n         ICM   R1,15,COMMIO          I/O BUFFER ADDRESS\n         BZ    EXIT0020              NO BUFFER\n         ITRACE ID=FREEIO,           FREEING I/O STORAGE               +\n               RDATA1=R1             .. I/O AREA'S ADDRESS\n         FREEMAIN RU,A=(1),LV=$IOSIZE FREE I/O BUFFER\nEXIT0020 DS    0H\n         ICM   R1,15,COMMESD         FIRST ESD ENTRY\n         USING ESDDATA,R1            DEFINE BASE\n         BZ    EXIT0040              NO ESD ENTRIES\nEXIT0030 DS    0H\n         L     R2,ESDNEXT            NEXT ENTRY\n         ITRACE ID=FREEESD,          FREEING ESD BLOCK                 +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(R1),LV=ESDDATAL\n         LTR   R1,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0030              LOOP\nEXIT0040 DS    0H\n         ICM   R1,15,COMMTXT         TEXT'S STORAGE ADRESS\n         BZ    EXIT0050              NOT ACQUIRED\n         L     R2,COMMCSLN           STORAGE SIZE\n         LA    R2,32(R2)             PLUS FUDGE FACTOR (SEE DISASM04)\n         ITRACE ID=FREETEXT,         FREEING TEXT'S STORAGE            +\n               RDATA1=R1,            .. TEXT'S ADDRESS                 +\n               RDATA2=R2             .. TEXT'S LENGTH\n         FREEMAIN RU,A=(R1),LV=(R2)  FREE TEXT'S STORAGE\nEXIT0050 DS    0H\n         ICM   R1,15,COMMUSNG        FIRST USING BLOCK\n         USING USNGDSCT,R1           DEFINE BASE\n         BZ    EXIT0070              NO BLOCK'S TO FREE\nEXIT0060 DS    0H\n         L     R2,USNGNEXT           NEXT BLOCK ON CHAIN\n         ITRACE ID=FREEUSNG,         FREEING USING BLOCK'S STORAGE     +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(1),LV=USNGL  FREE THE BLOCK\n         LTR   R1,R2                 COPY ADDRESS\n         BNZ   EXIT0060              FREE ALL BLOCKS\nEXIT0070 DS    0H\n         ICM   R1,15,COMMRLD         FIRST RLD BLOCK\n         USING RLDDATA,R1            DEFINE BASE\n         BZ    EXIT0100              NO RLD BLOCK'S TO FREE\nEXIT0090 DS    0H\n         L     R2,RLDNEXT            NEXT BLOCK'S ADDRESS\n         ITRACE ID=FREERLD,          FREEING RLD DATA                  +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(1),LV=RLDDATAL\n         LTR   R1,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0090              LOOP\nEXIT0100 DS    0H\n         ICM   R1,15,COMMBASE        FIRST BASE BLOCK\n         USING BASEDSCT,R1           DEFINE BASE\n         BZ    EXIT0120              NO BASE BLOCK'S TO FREE\nEXIT0110 DS    0H\n         L     R2,BASENEXT           NEXT BLOCK'S ADDRESS\n         ITRACE ID=FREEBASE,         FREEING BASE BLOCK                +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(1),LV=BASEL  FREE BASE BLOCK STORAGE\n         LTR   R1,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0110              LOOP\nEXIT0120 DS    0H\n         ICM   R1,15,COMMDATA        FIRST DATA BLOCK\n         USING DATADSCT,R1           DEFINE BASE\n         BZ    EXIT0140              NO DATA BLOCK'S TO FREE\nEXIT0130 DS    0H\n         L     R2,DATANEXT           NEXT BLOCK'S ADDRESS\n         ITRACE ID=FREEDATA,         FREEING DATA BLOCK                +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(1),LV=DATAL  FREE DATA BLOCK STORAGE\n         LTR   R1,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0130              LOOP\nEXIT0140 DS    0H\n         ICM   R3,15,COMMDSCT        FIRST DSECT BLOCK\n         USING DSCTDSCT,R3           DEFINE BASE\n         BZ    EXIT0200              NO DSECT BLOCK'S TO FREE\nEXIT0150 DS    0H\n         ICM   R4,15,DSCTLBA         FIRST LABEL IN THIS DSECT\n         USING LABLDSCT,R4           DEFINE BASE\n         BZ    EXIT0190              NO LABEL BLOCKS TO FREE\nEXIT0160 DS    0H\n         ICM   R1,15,LABLEQU         FIRST EQUATE BLOCK\n         BZ    EXIT0180              NO EQUATE BLOCKS\n         USING EQUDATA,R1            DEFINE BASE\nEXIT0170 DS    0H\n         L     R2,EQUNEXT            NEXT EQUATE BLOCK'S ADDRESS\n         ITRACE ID=FREEEQU,          FREEING AN EQU BLOCK              +\n               DATA1=EQULABEL,       .. EQUATE NAME                    +\n               RDATA2=R1             .. EQU BLOCK ADDRESS\n         FREEMAIN RU,A=(1),LV=EQUL   FREE EQUATE BLOCK\n         LTR   R1,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0170              LOOP\nEXIT0180 DS    0H\n         L     R2,LABLNEXT           NEXT LABEL BLOCK'S ADDRESS\n         ITRACE ID=FREELABL,         FREEING A LABEL BLOCK             +\n               DATA1=LABLNAME,       .. LABEL NAME                     +\n               RDATA2=R4             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(4),LV=LABLL  FREE LABEL BLOCK STORAGE\n         LTR   R4,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0160              LOOP\nEXIT0190 DS    0H\n         L     R2,DSCTNEXT           NEXT BLOCK'S ADDRESS\n         ITRACE ID=FREEDSCT,         FREEING DSECT BLOCK               +\n               DATA1=DSCTNAME,       .. DSECT NAME                     +\n               RDATA2=R3             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(3),LV=DSCTL  FREE DSECT BLOCK STORAGE\n         LTR   R3,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0150              LOOP\nEXIT0200 DS    0H\n         ICM   R4,15,COMMLABL        FIRST CSECT LABEL\n         BZ    EXIT0220              NO CSECT LABELS\nEXIT0210 DS    0H\n         L     R2,LABLNEXT           NEXT LABEL BLOCK'S ADDRESS\n         ITRACE ID=FREELABL,         FREEING A LABEL BLOCK             +\n               DATA1=LABLNAME,       .. LABEL NAME                     +\n               DATA2=R4              .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(4),LV=LABLL  FREE LABEL BLOCK STORAGE\n         LTR   R4,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0210              LOOP\nEXIT0220 DS    0H\n         ICM   R1,15,COMMREF         FIRST REFERENCE BLOCK\n         USING REFDSCT,R1            DEFINE BASE\n         BZ    EXIT0240              NO MORE BLOCK'S TO FREE\nEXIT0230 DS    0H\n         L     R2,REFNEXT            NEXT BLOCK'S ADDRESS\n         ITRACE ID=FREEREF,          FREEING REFERENCE BLOCK           +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         FREEMAIN RU,A=(1),LV=REFL   FREE REFERENCE BLOCK STORAGE\n         LTR   R1,R2                 COPY NEXT BLOCK'S ADDRESS\n         BNZ   EXIT0230              LOOP\nEXIT0240 DS    0H\n         ICM   R1,15,COMMDISP        DISPLACEMENT TABLE ACQUIRED?\n         BZ    EXIT0250              NO\n         L     R2,COMMCSLN           CSECT SIZE\n         LA    R2,4(R2)              PLUS 4\n         ITRACE ID=FREEDISP,         FREEMAINING DISPLACEMENT TABLE    +\n               RDATA1=R1,            .. STORAGE ADDRESS                +\n               RDATA2=R2             .. STORAGE SIZE\n         FREEMAIN RU,A=(1),LV=(2)\nEXIT0250 DS    0H\n         ITRACE ID=FREETRCE\n         ICM   R1,15,TRADDR          TRACE TABLE'S ADDRESS\n         BZ    EXIT0260              NOT ACQUIRED\n         L     R2,TRSIZE             TRACE TABLE'S SIZE\n         LA    R2,32(R2)             FOR BOUNDARY ROUNDING\n         FREEMAIN RU,A=(R1),LV=(R2)  FREEMAIN TRACE TABLE\nEXIT0260 DS    0H\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE01   DC    18F'0'                REGISTER SAVE AREA\nV00      DC    V(DISASM00)           COMMON MODULE'S ADDRESS\nINDD     DC    CL8'DISIN'\nPRTDD    DC    CL8'DISPRINT'\nLIBDD    DC    CL8'DISMOD'\nPUNCHDD  DC    CL8'DISPUNCH'\nDEBUGDD  DC    CL8'DISDEBUG'\nA02SUB   DC    CL35'Internal data after module DISASM02'\nA06SUB   DC    CL35'Internal data after module DISASM06'\nA07SUB   DC    CL35'Internal data after module DISASM07'\nA08SUB   DC    CL35'Internal data after module DISASM08'\nMSG01    DC    C'DISASM0101I No DISPUNCH DD present, no source will be +\n               generated'\nMSG01L   EQU   *-MSG01\nMSG02    DC    C'DISASM0102I ABEND requested, program abnormally termin+\n               ating'\nMSG02L   EQU   *-MSG02\nMSG03    DC    C'DISASM0103I ******* Disassembly complete ******'\nMSG03L   EQU   *-MSG03\nMSG04    DC    C'DISASM0104E DISIN DD statement missing, processing wil+\n               l be aborted'\nMSG04L   EQU   *-MSG04\nMSG05    DC    C'DISASM0105E DISMOD DD statement missing, processing wi+\n               ll be aborted'\nMSG05L   EQU   *-MSG05\nMSG06    DC    C'DISASM0106E Error(s) in control parameters, execution +\n               aborted'\nMSG06L   EQU   *-MSG06\nMSG07    DC    C'DISASM0107E Error(S) in loading object module, executi+\n               on aborted'\nMSG07L   EQU   *-MSG07\nMSG08    DC    C'DISASM0108E Error(s) in printing text, execution abort+\n               ed'\nMSG08L   EQU   *-MSG08\nMSG09    DC    C'DISASM0109E Error(s) in assembling DSECTS, execution a+\n               borted'\nMSG09L   EQU   *-MSG09\nMSG10    DC    C'DISASM0110E Error(s) in generating label table, execut+\n               ion aborted'\nMSG10L   EQU   *-MSG10\nMSG11    DC    C'DISASM0111E Error(s) in generating source, execution a+\n               borted'\nMSG11L   EQU   *-MSG11\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              DEBUG MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nDBUGBLOK DBUGBLOK TYPE=CSECT\n         SPACE 2\n         LTORG\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         IHAPSA LIST=NO\n         IKJTCB LIST=NO\n         IEFTIOT1\n         END  DISASM01\n./ ADD MEMBER=DISASM02\n         TITLE 'DISASM02 - PARAMETER READER/INTERPRETER'\n         MACRO\n         REG &REG,&VALUE\n         DC     CL3'&REG'            REGISTER NAME\n         DC     AL1(&VALUE)          VALUE IN INSTRUCTIONS\n         MEND\n         COPY  DISASMGB              COPY GLOBAL DEFINITIONS\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM02                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Read the parameter statements.  All parameter statements         *\n*   including comment statements are copied to DISPRINT.  See the    *\n*   DISASM documentation for a list of the parameter statements      *\n*   and their syntax.                                                *\n*                                                                    *\n*--------------------------------------------------------------------*\nDISASM02 CSECT\nDISASM02 AMODE 31\nDISASM02 RMODE 24\n         USING DISASM02,R12,R10\n         USING DISASM00,R11\n         USING REGDSCT,R4            DEFINE BASE\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         LA    R10,2048(R12)         SET BASE 2..\n         LA    R10,2048(R10)         .. 4K FROM 1ST\n         B     PARM0000              SKIP EYECATCHER\n         DC    CL8'DISASM02'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nPARM0000 DS    0H\n         LA    R1,SAVE02             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (DISIN,INPUT)         OPEN DISIN\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   COMMSUBH(SUBHEADL),SUBHEAD\n         LA    R1,SUBHEADL           SUBHEADING LENGTH\n         STH   R1,COMMSUBL           SET LENGTH\nPARM0010 DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         GET   DISIN,CTLSTMT         READ A CONTROL STATEMENT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   PRTDATA(CTLSTMTL),CTLSTMT\n         BAL   R9,PRT0000            PRINT CONTROL STATEMENT\n         CLI   CTLSTMT,C'*'          IS IT A COMMENT?\n         BE    PARM0010              YES\n         LA    R1,CNTLTBLE           CONTROL TABLE ADDRESS\nPARM0020 DS    0H\n         CLI   0(R1),X'FF'           END OF TABLE?\n         BE    PARM0040              YES\n         CLC   CTLTYPE,0(R1)         DEFINED CONTROL STATEMENT?\n         BE    PARM0030              YES\n         LA    R1,13(R1)             NEXT KEYWORD/ADDRESS\n         B     PARM0020              LOOP\nPARM0030 DS    0H\n         ICM   R15,15,9(R1)          INSERT ADDRESS\n         BR    R15                   BRANCH TO PROPER ROUTINE\nPARM0040 DS    0H\n         MVC   PRTDATA(EMSG03L),EMSG03\n         BAL   R9,PRT0000            PRINT MESSAGE\n         OI    COMMFLAG,$ABORT       SET ABORT FLAG\n         B     PARM0010              READ NEXT STATEMENT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Set ABEND flag                                             *\n*                                                                     *\n* ------------------------------------------------------------------- *\nABEND000 DS    0H\n         ITRACE ID=ABEND             ABEND AT EXIT\n         OI    COMMFLAG,$ABEND       SET ABEND FLAG\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process assembler input                                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nASM0000  DS    0H\n         ITRACE ID=ASMSTART\nASM0010  DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         GET   DISIN,CTLSTMT         READ A CONTROL STATEMENT\n         BAL   R14,AM31              SWITCH TO 24-BIT MODE\n         MVC   PRTDATA(CTLSTMTL),CTLSTMT\n         BAL   R9,PRT0000            PRINT CONTROL STATEMENT\n         CLC   CTLTYPE,CNTLASME      ASSEMBLER INPUT (END)?\n         BE    ASM0030               YES\n         TM    PGMFLAG,$ASMOPEN      ASSEMBLER DCB OPEN?\n         BO    ASM0020               YES\n         OI    PGMFLAG,$ASMOPEN      INDICATE DCB IS OPEN\n         OI    COMMFLAG,$ASMIN       INDICATE ASSEMBLER INPUT PRESENT\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (SYSIN,OUTPUT)        OPEN SYSIN DCB\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\nASM0020  DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   SYSIN,CTLSTMT         COPY CONTROL STATEMENT TO SYSIN\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         B     ASM0010               LOOP UNTIL EOF OR 'ASM END'\nASM0030  DS    0H\n         ITRACE ID=ASMEND\n         B     PARM0010              READ NEXT CONTROL STATEMENT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process BASE statements                                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nBASE0000 DS    0H\n         ITRACE ID=BASE\n         LA    R1,CTL10              REGISTER NAME'S ADDRESS\n         BAL   R9,REG0000            FIND REGISTER TABLE ENTRY\n* ------------------------------------------------------------------- *\n*       R4 POINTS TO REGISTER TABLE ENTRY                             *\n* ------------------------------------------------------------------- *\n         LA    R1,8                  MAX DIGITS\n         LA    R2,CTL20              FIRST CHARACTER OF DISPLACEMENT\n         BAL   R9,HEX0000            CONVERT DISPLACEMENT TO HEX\n         MVC   SAVEBEGN,DISPOUT      SAVE BEGINNING DISPLACEMENT\n         CLC   CTL30,COMMBLKS        ENDING DISPLACEMENT BLANK?\n         BE    BASE0010              YES\n         LA    R1,8                  MAX DIGITS\n         LA    R2,CTL30              FIRST CHARACTER OF DISPLACEMENT\n         BAL   R9,HEX0000            CONVERT DISPLACEMENT TO HEX\n         MVC   SAVEEND,DISPOUT       SAVE ENDING DISPLACEMENT\n         CLC   SAVEBEGN,SAVEEND      BEGIN LARGER THAN END?\n         BH    BASE0060              YES.. INVALID\n         B     BASE0030\nBASE0010 DS    0H\n         ICM   R1,15,SAVEBEGN        BEGINNING POINT\n         AH    R1,H4096              PLUS 4K\n         STCM  R1,15,SAVEEND         SAVE ENDING POINT\nBASE0030 DS    0H\n         LA    R1,8                  MAX DIGITS\n         LA    R2,CTL40              FIRST CHARACTER OF DISPLACEMENT\n         BAL   R9,HEX0000            CONVERT DISPLACEMENT TO HEX\n         LA    R5,COMMBASE           SET PREVIOUS FORWARD POINTER\n         ICM   R3,15,COMMBASE        FIRST BASE ENTRY\n         USING BASEDSCT,R3           DEFINE BASE\n         BZ    BASE0050              NO BLOCK'S ON CHAIN\nBASE0040 DS    0H\n         CLC   BASEBEGN,DISPOUT      INSERT IT HERE?\n         BL    BASE0050              YES\n         LA    R5,BASENEXT           FORWARD POINTER'S ADDRESS\n         ICM   R3,15,BASENEXT        NEXT BASE BLOCK\n         BNZ   BASE0040              LOOP\nBASE0050 DS    0H\n         GETMAIN RU,                 ACQUIRE STORAGE FOR NEW BASE BLOCK+\n               LV=BASEL,             .. SIZE                           +\n               LOC=ANY               .. ANY AREA\n         ITRACE ID=NEWBASE,          NEW BLOCK ACQUIRED                +\n               RDATA1=R1             .. CAPTURE STORAGE ADDRESS\n         ST    R1,0(R5)              CHAIN PREVIOUS BLOCK TO NEW BLOCK\n         ST    R3,BASENEXT-BASEDSCT(R1)   CHAIN NEXT BLOCK TO NEW BLOCK\n         LR    R3,R1                 SET BASE\n         MVC   BASEEYE,CNTLBASE      SET BLOCK IDENTIFIER\n         MVC   BASEBEGN,SAVEBEGN     SET STARTING DISPLACEMENT\n         MVC   BASEEND,SAVEEND       SET ENDING DISPLACEMENT\n         MVC   BASEREG,REGVALUE      SET BASE REGISTER\n         MVC   BASEDISP,DISPOUT      SET DISPLACEMENT BASE REFERS TO\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nBASE0060 DS    0H\n         MVC   PRTDATA(EMSG23L),EMSG23\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010              READ NEXT CONTROL STATEMENT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process CSECT statements                                   *\n*                                                                     *\n* ------------------------------------------------------------------- *\nCSCT0000 DS    0H\n         ITRACE ID=CSCTNAME,         CSECT NAME                        +\n               DATA1=CTLDATA\n         MVC   COMMCSNM,CTLDATA      SET CSECT NAME\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process DATA statements                                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nDATA0000 DS    0H\n         ITRACE ID=DATA\n         LA    R1,8                  MAX DIGITS\n         LA    R2,CTL10              FIRST CHARACTER OF DISPLACEMENT\n         BAL   R9,HEX0000            CONVERT DISPLACEMENT TO HEX\n         MVC   SAVEBEGN,DISPOUT      SAVE BEGINNING DISPLACEMENT\n         LA    R1,8                  MAX DIGITS\n         LA    R2,CTL20              FIRST CHARACTER OF END DISP\n         BAL   R9,HEX0000            CONVERT END DISP TO HEX\n         LA    R2,COMMDATA           DATA BLOCK ANCHOR\n         ICM   R3,15,COMMDATA        FIRST DATA BLOCK\n         USING DATADSCT,R3           DEFINE BASE\n         BZ    DATA0030              NO DATA BLOCKS\nDATA0010 DS    0H\n         CLC   DATAEND,SAVEBEGN      BELOW THIS AREA?\n         BL    DATA0020              YES\n         CLC   DATABEGN,DISPOUT      ABOVE THIS AREA?\n         BH    DATA0030              YES\n         B     DATA0040              OVERLAPS PREVIOUSLY DEFINED AREA\nDATA0020 DS    0H\n         LA    R2,DATANEXT           FORWARD POINTER ADDRESS\n         ICM   R3,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   DATA0010              LOOP\nDATA0030 DS    0H\n         GETMAIN RU,                 ACQUIRE STORAGE FOR NEW DATA BLOCK+\n               LV=DATAL,             .. SIZE                           +\n               LOC=ANY               .. IN ANY AREA\n         ITRACE ID=NEWDATA,          NEW DATA BLOCK ADQUIRED           +\n               RDATA1=R1             .. NEW BLOCK'S ADDRESS\n         ST    R1,0(R2)              PREVIOUS BLOCK TO NEW BLOCK\n         ST    R3,DATANEXT-DATADSCT(R1)   CHAIN NEXT BLOCK TO NEW BLOCK\n         LR    R3,R1                 SET BASE REG\n         MVC   DATAEYE,CNTLDATA      SET BLOCK IDENTIFIER\n         MVC   DATABEGN,SAVEBEGN     SET BEGINNING DISPLACEMENT\n         MVC   DATAEND,DISPOUT       SET ENDING DISPLACEMENT\n         ICM   R0,15,DATABEGN        BEGINNING DISPLACEMENT\n         ICM   R1,15,DATAEND         ENDING DISPLACEMENT\n         SR    R1,R0                 LENGTH - 1\n         LA    R1,1(R1)              TOTAL LENGTH\n         STCM  R1,15,DATALEN         SET LENGTH\n         MVI   DATATYPE,$DATAUSR     USER DEFINED DATA AREA\n         MVC   DATANAME,COMMBLKS     INITIALIZE NAME\n         XC    DATALBA,DATALBA       INITIALIZE DATA BLOCK'S ADDRESS\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nDATA0040 DS    0H\n         ITRACE ID=DATAOVLP          DATA AREA OVERLAP\n         UNPK  EMSG22A(5),DATABEGN(3)\n         MVZ   EMSG22A,COMM0F0F      TURN OFF ZONES\n         TR    EMSG22A,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   EMSG22A+4,C' '        RESTORE BLANK\n         UNPK  EMSG22B(5),DATAEND(3) UNPACK ENDING DISPLACEMENT\n         MVZ   EMSG22B,COMM0F0F      TURN OFF ZONES\n         TR    EMSG22B,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   EMSG22B+4,C' '        RESTORE BLANK\n         MVC   PRTDATA(EMSG22L),EMSG22\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010              READ NEXT CONTROL STATEMENT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          LABEL or PREFIX statements                                 *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLABL0000 DS    0H\n         ITRACE ID=LABEL\n         CLC   COMMPFX,COMMBLKS      PREFIX STILL BLANK?\n         BNE   LABL0030              NO.. DUPLICATED\n         CLI   CTL10,C' '            PREFIX BLANK?\n         BE    LABL0040              YES.. INVALID\n         CLC   CTL10(4),CNTLDATA     PREFIX 'DATA'?\n         BE    LABL0050              YES.. NOT VALID\n         LA    R1,CTL10              FIRST CHARACTER OF PREFIX\n         LA    R2,4                  MAXIMUM LENGTH\n         SR    R3,R3                 INITIALIZE FOR LENGTH\nLABL0010 DS    0H\n         CLI   0(R1),C' '            BLANK?\n         BE    LABL0020              YES\n         LA    R1,1(R1)              NEXT\n         LA    R3,1(R3)              ADD 1 TO LENGTH\n         BCT   R2,LABL0010           LOOP\nLABL0020 DS    0H\n         CLC   COMMBLKS(4),0(R1)     A FEW BLANKS?\n         BNE   LABL0060              NO\n         MVC   COMMPFX,CTL10         SET PREFIX\n         STH   R3,COMMPFXL           SET PREFIX LENGTH\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nLABL0030 DS    0H\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG19L),EMSG19\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nLABL0040 DS    0H\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG11L),EMSG11\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nLABL0050 DS    0H\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG15L),EMSG15\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nLABL0060 DS    0H\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG12L),EMSG12\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010              READ NEXT CONTROL STATEMENT\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Line count statements                                      *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLINE0000 DS    0H\n         ITRACE ID=LINES\n         MVC   LINEIN,LINEIN-1       INITIALIZE WITH ZEROS\n         LA    R1,CTL10              FIRST DIGIT\n         LA    R2,3                  MAX DIGITS\nLINE0010 DS    0H\n         CLI   0(R1),C' '            BLANK\n         BE    LINE0020              YES\n         CLI   0(R1),C'0'            INVALID DIGIT?\n         BL    LINE0030              YES\n         CLI   0(R1),C'9'            INVALID DIGIT?\n         BH    LINE0030              YES\n         MVC   LINEIN(L'LINEIN-1),LINEIN+1 SHIFT DIGITS LEFT 1\n         MVC   LINEIN+2(1),0(R1)     INSERT IN LOW ORDER POSITION\n         LA    R1,1(R1)              NEXT DIGIT\n         BCT   R2,LINE0010           LOOP\nLINE0020 DS    0H\n         CLC   0(6,R1),COMMBLKS      SEVERAL TRAILING BLANKS?\n         BNE   LINE0040              NO\n         PACK  LINEOUT,LINEIN        PACK LINE COUNT\n         CP    LINEOUT,PMIN          LESS THAN MINIMUM?\n         BL    LINE0050              YES\n         ZAP   COMMMAXL,LINEOUT      SET MAX LINE COUNT\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nLINE0030 DS    0H\n         MVC   PRTDATA(EMSG16L),EMSG16\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nLINE0040 DS    0H\n         MVC   PRTDATA(EMSG17L),EMSG17\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nLINE0050 DS    0H\n         MVC   PRTDATA(EMSG18L),EMSG18\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process MODULE Statements                                  *\n*                                                                     *\n* ------------------------------------------------------------------- *\nMOD0000  DS    0H\n         ITRACE ID=MODNAME,          MODULE NAME                       +\n               DATA1=CTLDATA\n         MVC   COMMMOD,CTLDATA       SET MODULE NAME\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process NO FLOAT statements                                *\n*                                                                     *\n* ------------------------------------------------------------------- *\nNOFLOAT0 DS    0H\n         ITRACE ID=NOFLOAT           NO FLOATING POINT INSTRUCTIONS\n         OI    COMMFLAG,$NOFLOAT     SET 'NO FLOATING POINT' FLAG\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Set sequentially numbered labels flag                      *\n*                                                                     *\n* ------------------------------------------------------------------- *\nSEQ0000  DS    0H\n         ITRACE ID=SEQLABEL\n         TM    COMMFLAG,$SEQLABL     ALREADY SET?\n         BO    SEQ0010               YES\n         OI    COMMFLAG,$SEQLABL     SET SEQUENTIALLY NUMBER LABEL FLAG\n         B     PARM0010\nSEQ0010  DS    0H\n         MVC   PRTDATA(WMSG02L),WMSG02\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Process USING statements                                   *\n*                                                                     *\n* ------------------------------------------------------------------- *\nUSNG0000 DS    0H\n         ITRACE ID=USING             USING STATEMENT FOUND\n         LA    R3,COMMUSNG           CURRENT BLOCK IS ANCHOR\n         USING USNGDSCT,R3           DEFINE BASE\nUSNG0010 DS    0H\n         ICM   R1,15,USNGNEXT        NEXT BLOCK ON CHAIN\n         BZ    USNG0020              END OF CHAIN FOUND\n         LR    R3,R1                 COPY ADDRESS\n         B     USNG0010              KEEP FOLLOWING CHAIN\nUSNG0020 DS    0H\n         LA    R1,CTL30              REGISTER NAME'S ADDRESS\n         BAL   R9,REG0000            FIND REGISTER TABLE ENTRY\n* ------------------------------------------------------------------- *\n*       R3 POINTS TO LAST USING BLOCK OR ANCHOR                       *\n*       R4 POINTS TO REGISTER TABLE ENTRY                             *\n* ------------------------------------------------------------------- *\n         CLC   CTL40,COMMBLKS        STARTING DISPLACEMENT ALL BLANK?\n         BE    USNG0070              YES\n         CLC   CTL50,COMMBLKS        ENDING DISPLACEMENT ALL BLANK?\n         BE    USNG0050              YES.. NOT VALID\n         LA    R1,8                  MAXIMUM NUMBER OF DIGITS\n         LA    R2,CTL40              FIRST CHARACTER OF BEGIN DISP\n         BAL   R9,HEX0000            VERIFY/CONVERT BEGIN DISP\n         MVC   SAVEBEGN,DISPOUT      SAVE BEGINNING DISPLACEMENT\n         LA    R1,8                  MAXIMUM NUMBER OF DIGITS\n         LA    R2,CTL50              FIRST CHARACTER OF END DISP\n         BAL   R9,HEX0000            VERIFY/CONVERT END DISP\n         CLC   SAVEBEGN,DISPOUT      BEGIN LARGER THAN END?\n         BH    USNG0060              YES.. ERROR\nUSNG0030 DS    0H\n         GETMAIN RU,                 ACQUIRE STORAGE FOR USING ENTRY   +\n               LV=USNGL,             .. SIZE                           +\n               LOC=ANY               .. IN ANY AREA\n         ITRACE ID=NEWUSNG,                                            +\n               RDATA1=R1             .. TRACE NEW BLOCK'S ADDRESS\n         ST    R1,USNGNEXT           CHANGE TO PREVIOUS BLOCK\n         LR    R3,R1                 COPY BASE\n         MVC   USNGEYE,CNTLUSNG      SET BLOCK IDENTIFIER\n         XC    USNGNEXT,USNGNEXT     CLEAR FORWARD POINTER\n         MVI   USNGFLAG,0            SET ALL FLAGS OFF\n         MVC   USNGDSNM,CTL10        SET DSECT'S NAME\n         MVC   USNGLBNM,CTL20        SET LABEL WITHIN DSECT\n         XC    USNGDSA,USNGDSA       CLEAR DSECT BLOCK'S ADDRESS\n         XC    USNGLBA,USNGLBA       CLEAR LABEL BLOCK'S ADDRESS\n         XC    USNGDISP,USNGDISP     CLEAR LABEL DISP INTO DSECT\n         MVC   USNGBASE,REGVALUE     SET BASE VALUE\n         CLC   CTL40,COMMBLKS        STARTING DISPLACEMENT OMITTED?\n         BE    USNG0040              YES\n         MVC   USNGBEGN,SAVEBEGN     SET BEGINNING DISPLACEMENT\n         MVC   USNGEND,DISPOUT       SET ENDING DISPLACEMENT\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nUSNG0040 DS    0H\n         OI    USNGFLAG,$USNGND      NO DISPLACEMENTS\n         XC    USNGBEGN,USNGBEGN     CLEAR STARTING DISP\n         XC    USNGEND,USNGEND       CLEAR ENDING DISP\n         B     PARM0010              READ NEXT CONTROL STATEMENT\nUSNG0050 DS    0H\n         MVC   PRTDATA(EMSG06L),EMSG06 SET MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nUSNG0060 DS    0H\n         MVC   PRTDATA(EMSG07L),EMSG07 SET MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nUSNG0070 DS    0H\n         CLC   CTL50,COMMBLKS        ENDING DISPLACEMENT BLANK?\n         BE    USNG0030              YES\n         MVC   PRTDATA(EMSG10L),EMSG10\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        Locate register table entry                                  *\n*                                                                     *\n*          R1  is register name's address                             *\n*          R9  is return address                                      *\n*                                                                     *\n*          At exit R4 will point to the register table entry.         *\n*                                                                     *\n*          If any error is found, control is passed to 'PARM0010'.    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nREG0000  DS    0H\n         ITRACE ID=CONVREG\n         CLI   0(R1),C' '            BLANK?\n         BE    REG0050               YES.. INVALID\n         CLC   3(7,R1),COMMBLKS      REFERENCE TOO LONG?\n         BNE   REG0060               YES.. INVALID\n         CLI   2(R1),C' '            3-CHARACTER NAME?\n         BNE   REG0010               YES\n         CLI   1(R1),C' '            2-CHARACTER NAME?\n         BNE   REG0020               YES\n         ITRACE ID=REG1\n         LA    R4,REGTBL1            1-CHARACTER NAME TABLE\n         SR    R2,R2                 SET LENGTH (1 BYTE)\n         B     REG0030               FIND TABLE ENTRY\nREG0010  DS    0H\n         ITRACE ID=REG3\n         LA    R4,REGTBL3            3-CHARACTER NAME TABLE\n         LA    R2,2                  SET LENGTH (3 BYTES)\n         B     REG0030               FIND TABLE ENTRY\nREG0020  DS    0H\n         ITRACE ID=REG2\n         LA    R4,REGTBL2            2-CHARACTER NAME TABLE\n         LA    R2,1                  SET LENGTH (2 BYTES)\nREG0030  DS    0H\n         CLI   0(R4),X'FF'           END OF TABLE?\n         BE    REG0040               YES.. INVALID\n         EX    R2,REGCLC             REGISTER NAME MATCH?\n         BER   R9                    YES\n         LA    R4,REGL(R4)           NEXT REGISTER ENTRY\n         B     REG0030               LOOP\nREG0040  DS    0H\n         ITRACE ID=BADREG\n         MVC   PRTDATA(EMSG05L),EMSG05 SET MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nREG0050  DS    0H\n         ITRACE ID=REGBLANK\n         MVC   PRTDATA(EMSG13L),EMSG13 SET MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nREG0060  DS    0H\n         ITRACE ID=REGLONG\n         MVC   PRTDATA(EMSG14L),EMSG14 SET MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nREGCLC   CLC   REGNAME(0),0(R1)      TEST REGISTER NAME\n* ------------------------------------------------------------------- *\n*                                                                     *\n*          Convert character to hex                                   *\n*                                                                     *\n*          R1 should be the number of characters (up to 8)            *\n*          R2 should be the address of the first character            *\n*          R9 should be the return address                            *\n*                                                                     *\n*             At exit 'DISPOUT' will be the value in hex              *\n*                                                                     *\n*          If any error is found, control is passed to 'PARM0010'.    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nHEX0000  DS    0H\n         MVC   DISPIN,=C'00000000'   INITIALIZE DISP TO ZERO\nHEX0010  DS    0H\n         CLI   0(R2),C' '            END OF DISPLACEMENT?\n         BE    HEX0030               YES\n         CLI   0(R2),C'A'            TOO LOW FOR VALID HEX?\n         BL    HEX0040               YES\n         CLI   0(R2),C'F'            WITHIN A-F?\n         BNH   HEX0020               YES, VALID\n         CLI   0(R2),C'0'            TOO LOW FOR NUMERIC?\n         BL    HEX0040               YES\n         CLI   0(R2),C'9'            TOO HIGH FOR VALID NUMERIC?\n         BH    HEX0040               YES\nHEX0020  DS    0H\n         MVC   DISPIN(L'DISPIN-1),DISPIN+1    SHIFT LEFT 1 DIGIT\n         MVC   DISPIN+L'DISPIN-1(1),0(R2)     SET LOW ORDER DIGIT\n         LA    R2,1(R2)              NEXT DISP CHARACTER\n         BCT   R1,HEX0010            LOOP\n         CLI   0(R2),C' '            BLANK?\n         BNE   HEX0050               NO.. TOO MANY DIGITS\nHEX0030  DS    0H\n         NC    DISPIN,COMM1F1F       PREPARE FOR TRANSLATE\n         TR    DISPIN,COMMCHHX       TRANSLATE FOR PACKING\n         PACK  DISPOUT(5),DISPIN(9)  PACK\n         BR    R9                    GET OUTTA HERE\nHEX0040  DS    0H\n         MVC   PRTDATA(EMSG08L),EMSG08\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nHEX0050  DS    0H\n         MVC   PRTDATA(EMSG09L),EMSG09\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     PARM0010\nPRT0000  DS    0H\n         TM    PGMFLAG,$SUBH         HAS SUB-HEADING BEEN PRINTED?\n         BO    PRT0010               YES\n         OI    PGMFLAG,$SUBH         SET FLAG\n         MVI   PRTCMD,$PRTSUBH       SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\nPRT0010  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R9                    RETURN\nEXIT0000 DS    0H\n         BAL   R14,AM31              FORCE 31-BIT MODE\n         ITRACE ID=PARMEOF           END OF FILE\n         TM    PGMFLAG,$ASMOPEN      ASSEMBLER INPUT OPEN?\n         BNO   EXIT0010              NO\n         ITRACE ID=CLOSEASM          CLOSING SYSIN DCB\n         NI    PGMFLAG,255-$ASMOPEN  INDICATE DCB IS CLOSED\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         CLOSE SYSIN\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\nEXIT0010 DS    0H\n         OC    COMMBASE,COMMBASE     BASE REGISTER(S) DEFINED?\n         BZ    EXIT0020              NO\n         CLC   COMMPFX,COMMBLKS      PREFIX DEFINED?\n         BNE   EXIT0030              YES\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG20L),EMSG20\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     EXIT0030              EXIT\nEXIT0020 DS    0H\n         CLC   COMMPFX,COMMBLKS      PREFIX DEFINED?\n         BE    EXIT0030              NO\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG21L),EMSG21\n         BAL   R9,PRT0000            PRINT MESSAGE\nEXIT0030 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nAM24     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         BSM   R0,R14             RETURN IN 24-BIT MODE\nAM31     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         O     R14,X80            SET 31-BIT MODE\n         BSM   R0,R14             RETURN IN 31-BIT MODE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE02   DC    18F'0'                REGISTER SAVE AREA\nX80      DC    A(X'80000000')\nH4096    DC    H'4096'               4K IN DECIMAL\nPMIN     DC    PL3'&MINL'            MINIMUM LINE COUNT ALLOWED\nPGMFLAG  DC    X'00'\n$SUBH    EQU   X'80'                 SUBHEADING PRINTED\n$ASMOPEN EQU   X'40'                 ASSEMBLER INPUT DCB OPEN\n         SPACE 1\nDISPIN   DC    CL8' '\n         DC    X'00'                 PAD FOR PACKING\nDISPOUT  DC    XL4'00000000'\n         DC    X'00'                 PAD FOR PACKING\n         SPACE 1\n         DC    C'0'\nLINEIN   DC    CL3'000'\nLINEOUT  DC    PL3'0'\n         SPACE 1\nSAVEBEGN DS    XL4                   SAVED BEGINNING DISPLACEMENT\nSAVEEND  DS    XL4                   SAVED ENDING DISPLACEMENT\nSUBHEAD  DC    C' CONTROL STATEMENTS '\nSUBHEADL EQU   *-SUBHEAD\n*---------------------------------------------------------------------*\n*              WARNING MESSAGES                                       *\n*---------------------------------------------------------------------*\nWMSG02   DC    C'DISASM0202W Sequentially numbered labels have already +\n               been requested'\nWMSG02L  EQU   *-WMSG02\n*---------------------------------------------------------------------*\n*              ERROR MESSAGES                                         *\n*---------------------------------------------------------------------*\nEMSG03   DC    C'DISASM0203E Invalid control statement'\nEMSG03L  EQU   *-EMSG03\nEMSG04   DC    C'DISASM0204E Extraneous data in register parameter'\nEMSG04L  EQU   *-EMSG04\nEMSG05   DC    C'DISASM0205E Invalid register reference'\nEMSG05L  EQU   *-EMSG05\nEMSG06   DC    C'DISASM0206E End displacement is required when begin di+\n               splacement is given'\nEMSG06L  EQU   *-EMSG06\nEMSG07   DC    C'DISASM0207E Begin displacement is larger than end disp+\n               lacement'\nEMSG07L  EQU   *-EMSG07\nEMSG08   DC    C'DISASM0208E Bad hex digit in displacement'\nEMSG08L  EQU   *-EMSG08\nEMSG09   DC    C'DISASM0209E Too many digits in displacement'\nEMSG09L  EQU   *-EMSG09\nEMSG10   DC    C'DISASM0210E End displacement not allowed unless start +\n               displacement is specified'\nEMSG10L  EQU   *-EMSG10\nEMSG11   DC    C'DISASM0211E Label prefix cannot be blank'\nEMSG11L  EQU   *-EMSG11\nEMSG12   DC    C'DISASM0212E Label prefixes must be 4 characters or les+\n               s'\nEMSG12L  EQU   *-EMSG12\nEMSG13   DC    C'DISASM0213E Base register is blank'\nEMSG13L  EQU   *-EMSG13\nEMSG14   DC    C'DISASM0214E Base register name exceeds 3 characters in+\n                length'\nEMSG14L  EQU   *-EMSG14\nEMSG15   DC    C'DISASM0215E ''DATA'' is reserved for data area prefixe+\n               s, choose another prefix'\nEMSG15L  EQU   *-EMSG15\nEMSG16   DC    C'DISASM0216E Invalid digit in LINE/LINES/MAXLINES state+\n               ment'\nEMSG16L  EQU   *-EMSG16\nEMSG17   DC    C'DISASM0217E Line count value in LINE/LINES/MAXLINES st+\n               atement is too long or contains extraneous data'\nEMSG17L  EQU   *-EMSG17\nEMSG18   DC    C'DISASM0218E Line count value in LINE/LINES/MAXLINES st+\n               atement is below minimum allowed'\nEMSG18L  EQU   *-EMSG18\nEMSG19   DC    C'DISASM0219E Label prefix has already been defined, cho+\n               ose one or the other'\nEMSG19L  EQU   *-EMSG19\nEMSG20   DC    C'DISASM0220E Label prefix must be defined when base reg+\n               isters are defined'\nEMSG20L  EQU   *-EMSG20\nEMSG21   DC    C'DISASM0221E Label prefix not valid unless base registe+\n               r(s) are defined'\nEMSG21L  EQU   *-EMSG21\nEMSG22   DC    C'DISASM0222E This area overlaps area at '\nEMSG22A  DC    CL4' '\n         DC    C' to '\nEMSG22B  DC    CL4' '\n         DC    C' '\nEMSG22L  EQU   *-EMSG22\nEMSG23   DC    C'DISASM0223E Starting displacement is larger than endin+\n               g displacement'\nEMSG23L  EQU   *-EMSG23\n*---------------------------------------------------------------------*\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nCTLSTMT  DS    0CL80\nCTLTYPE  DC    CL09' '               STATEMENT TYPE\nCTLDATA  DC    CL71' '               RELATED DATA\nCTLSTMTL EQU   *-CTLSTMT\n         ORG   CTLDATA\nCTL10    DS    CL10                  DATA STARTING AT COLUMN 10\nCTL20    DS    CL10                  DATA STARTING AT COLUMN 20\nCTL30    DS    CL10                  DATA STARTING AT COLUMN 30\nCTL40    DS    CL10                  DATA STARTING AT COLUMN 40\nCTL50    DS    CL10                  DATA STARTING AT COLUMN 50\nCTL60    DS    CL10                  DATA STARTING AT COLUMN 60\nCTL70    DS    CL10                  DATA STARTING AT COLUMN 70\n         ORG   CTLSTMT+80\n         SPACE 1\nCNTLTBLE DS    0X\n         DC    CL09'ABEND    ',AL4(ABEND000)\n         DC    CL09'ASM START',AL4(ASM0000)\nCNTLBASE DC    CL09'BASE     ',AL4(BASE0000)\n         DC    CL09'CSECT    ',AL4(CSCT0000)\nCNTLDATA DC    CL09'DATA     ',AL4(DATA0000)\n         DC    CL09'LABEL    ',AL4(LABL0000)\n         DC    CL09'LINE     ',AL4(LINE0000)\n         DC    CL09'LINES    ',AL4(LINE0000)\n         DC    CL09'MAX LINES',AL4(LINE0000)\n         DC    CL09'MODULE   ',AL4(MOD0000)\n         DC    CL09'NO FLOAT ',AL4(NOFLOAT0)\n         DC    CL09'NOFLOAT  ',AL4(NOFLOAT0)\n         DC    CL09'PREFIX   ',AL4(LABL0000)\n         DC    CL09'SEQ LABEL',AL4(SEQ0000)\nCNTLUSNG DC    CL09'USING    ',AL4(USNG0000)\n         DC    X'FF'\nCNTLASME DC    CL09'ASM END'\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              DCB'S                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISIN    DCB   DDNAME=DISIN,         CONTROL STATEMENT DCB             +\n               DSORG=PS,             .. SEQUENTIAL                     +\n               EODAD=EXIT0000,       .. EOF ADDRESS                    +\n               LRECL=80,             .. MUST BE LRECL=80               +\n               MACRF=GM              .. GET-MOVE MODE\nSYSIN    DCB   DDNAME=SYSIN,         ASSEMBLER'S INPUT DCB             +\n               DSORG=PS,             .. SEQUENTIAL                     +\n               LRECL=80,             .. MUST BE LRECL=80               +\n               BLKSIZE=3120,         .. BLOCK SIZE                     +\n               MACRF=PM              .. PUT-MOVE MODE\nREGTBL1  DS    0C                    1-CHARACTER REGISTER NAMES\n         REG   0,0\n         REG   1,1\n         REG   2,2\n         REG   3,3\n         REG   4,4\n         REG   5,5\n         REG   6,6\n         REG   7,7\n         REG   8,8\n         REG   9,9\n         REG   A,10\n         REG   B,11\n         REG   C,12\n         REG   D,13\n         REG   E,14\n         REG   F,15\n         DC    X'FF'\nREGTBL2  DS    0C                    2-CHARACTER REGISTER NAMES\n         REG   R0,0\n         REG   R1,1\n         REG   R2,2\n         REG   R3,3\n         REG   R4,4\n         REG   R5,5\n         REG   R6,6\n         REG   R7,7\n         REG   R8,8\n         REG   R9,9\n         REG   10,10\n         REG   11,11\n         REG   12,12\n         REG   13,13\n         REG   14,14\n         REG   15,15\n         REG   RA,10\n         REG   RB,11\n         REG   RC,12\n         REG   RD,13\n         REG   RE,14\n         REG   RF,15\n         DC    X'FF'\nREGTBL3  DS    0C                    3-CHARACTER REGISTER NAMES\n         REG   R10,10\n         REG   R11,11\n         REG   R12,12\n         REG   R13,13\n         REG   R14,14\n         REG   R15,15\n         DC    X'FF'\n         LTORG\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              REGISTER TABLE                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nREGDSCT  DSECT\nREGNAME  DS    CL3                   REGISTER NAME\nREGVALUE DS    AL1                   VALUE USED IN INSTRUCTIONS\nREGL     EQU   *-REGDSCT\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM02\n./ ADD MEMBER=DISASM03\n         TITLE 'DISASM03 - LOAD MODULE READER'\n         MACRO\n         PROC   &TYPE,&PROC1,&PROC2,&FLAGS\n         LCLC   &A,&OPTS\n&OPTS    SETC   '00'\n         AIF    (T'&FLAGS EQ 'O').PROC20\n&OPTS    SETC   '&FLAGS'\n.PROC20  ANOP\n         DC     X'&TYPE'             RECORD TYPE\n         DC     AL1(&OPTS)           FLAGS\n         AIF    (T'&PROC1 EQ 'O').PROC30\n         DC     AL2(&PROC1-DISASM03) DISPLACEMENT TO PROCESSING ROUTINE\n         AGO    .PROC40\n.PROC30  ANOP\n         DC     AL2(0)               NO PROCESSING ROUTINE\n.PROC40  ANOP\n         AIF    (T'&PROC2 EQ 'O').PROC50\n         DC     AL2(&PROC2-DISASM00) DISPLACEMENT TO MODULE'S ADDRESS\n         MEXIT\n.PROC50  ANOP\n         DC     AL2(0)               NO EXTERNAL PROCESSING MODULE\n         MEND\n         COPY   DISASMGB\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM03                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Object module reader.  Many of the fields in the directory       *\n*   entry are interpreted and printed (module size, whether or not   *\n*   the module has the RENT, REUS, REFR flags, etc).  If the module  *\n*   name is an alias, the real module's directory info will be       *\n*   printed also.  The ESD and RLD info from the module is printed   *\n*   and control blocks built that will be used later for generating  *\n*   labels and ENTRY statements.  Module DISASM04 is called as a     *\n*   sub-function to interpret ESD data.  Module DISASM05 is called   *\n*   as a sub-function to interpret RLD data.                         *\n*                                                                    *\n*   If the module is successfully read and the requested CSECT       *\n*   located, COMMTXT will be set to the CSECT's storage address,     *\n*   COMMCSAD will be the CSECT's address within the load module,     *\n*   COMMCSEP will be the load module's entry point, COMMCSEA will    *\n*   be the CSECT's ending address within the load module, and        *\n*   COMMCSLN will the the CSECT's length.                            *\n*                                                                    *\n*--------------------------------------------------------------------*\nDISASM03 CSECT\nDISASM03 AMODE 31\nDISASM03 RMODE 24\n         USING DISASM03,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     MOD0000               SKIP EYECATCHER\n         DC    CL8'DISASM03'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nMOD0000  DS    0H\n         LA    R1,SAVE03             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (DISMOD,INPUT)        OPEN DISMOD\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   COMMSUBH(SUBHD1L),SUBHD1\n         LA    R1,SUBHD1L            SUBHEADING LENGTH\n         STH   R1,COMMSUBL           SET LENGTH\n         MVC   DIRMEM,COMMMOD        SET MEMBER NAME = MODULE NAME\nMOD0010  DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         BLDL  DISMOD,BLDLIST        ISSUE BLDL\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         LTR   R15,R15               BLDL SUCCESSFUL?\n         BNZ   ERR0010               NO\n         MVC   MSG01MEM,DIRMEM       SET MEMBER NAME\n         TM    DIRINDS,$ALIAS        IS THIS AN ALIAS?\n         BO    MOD0020               YES\n         MVC   MSG01ALS,NO           NOT AN ALIAS\n         B     MOD0030\nMOD0020  DS    0H\n         MVC   MSG01ALS,YES          MEMBER IS AN ALIAS\nMOD0030  DS    0H\n         UNPK  MSG01TXT(7),DIRTTTR(4)\n         MVZ   MSG01TXT,COMM0F0F     TURN OFF ZONES\n         TR    MSG01TXT,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG01TXT+6,C' '       RESTORE BLANK\n         UNPK  MSG01NTE(7),DIRNTTR(4)\n         MVZ   MSG01NTE,COMM0F0F     TURN OFF ZONES\n         TR    MSG01NTE,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG01NTE+6,C' '       RESTORE BLANK\n         MVC   PRTDATA(MSG01L),MSG01 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,DIR#NOTE           NUMBER OF NOTE LIST ENTRIES\n         CVD   R1,COMMDWRD           CONVERT TO DECIMAL\n         MVC   MSG02NTE,=X'40202120' INITIALIZE WITH EDIT WORD\n         ED    MSG02NTE,COMMDWRD+6   EDIT NOTE LIST\n         UNPK  MSG02SZ(7),DIRMSIZE(4) UNPACK MODULE SIZE\n         MVZ   MSG02SZ,COMM0F0F      TURN OFF ZONES\n         TR    MSG02SZ,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   MSG02SZ+6,C' '        RESTORE BLANK\n         MVC   COMMCSEP+1,DIREPA     SAVE ENTRY POINT\n         UNPK  MSG02EPA(7),DIREPA(4) UNPACK ENTRY POINT\n         MVZ   MSG02EPA,COMM0F0F     TURN OFF ZONES\n         TR    MSG02EPA,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02EPA+6,C' '       RESTORE BLANK\n         MVC   MSG02MEM,COMMBLKS     CLEAR MEMBER NAME\n         TM    DIRINDS,$ALIAS        AN ALIAS?\n         BNO   MOD0040               NO\n         MVC   MSG02MEM,DIRRMEM      SET REAL MEMBER NAME\nMOD0040  DS    0H\n         MVC   PRTDATA(MSG02L),MSG02 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         LA    R1,DIRSCTR            START OF VARIABLE PORTION\n         TM    DIRATTR3,$SSI         SSI INFO PRESENT?\n         BNO   MOD0050               NO\n         LA    R1,L'DIRSSI(R1)       SKIP SSI INFO\nMOD0050  DS    0H\n         TM    DIRINDS,$ALIAS        IS THIS AN ALIAS?\n         BNO   MOD0060               NO\n         LA    R1,L'DIRMEP+L'DIRRMEM(R1)\nMOD0060  DS    0H\n         TM    DIRATTR1,$SCTR        SCATTER LOAD?\n         BNO   MOD0070               NO\n         LA    R1,8(R1)              SKIP SCATTER STUFF\nMOD0070  DS    0H\n         UNPK  MSG03ATH(3),1(2,R1)   UNPACK AUTH CODE\n         MVZ   MSG03ATH,COMM0F0F     TURN OFF ZONES\n         TR    MSG03ATH,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG03ATH+2,C' '       RESTORE BLANK\n         MVC   MSG03SSI,COMMBLKS     CLEAR SSI INFO\n         TM    DIRATTR3,$SSI         SSI INFO PRESENT?\n         BNO   MOD0100               NO\n         LA    R1,DIRSCTR            START OF VARIABLE PORTION\n         TM    DIRATTR1,$SCTR        SCATTER LOAD?\n         BNO   MOD0080               NO\n         TM    DIRINDS,$ALIAS        ALIAS?\n         BO    MOD0100               YES.. NO SSI\n         LA    R1,8(R1)              SKIP SCATTER STUFF\n         B     MOD0090\nMOD0080  DS    0H\n         TM    DIRINDS,$ALIAS        ALIAS?\n         BNO   MOD0090               NO\n         LA    R1,L'DIRMEP+L'DIRRMEM(R1)\nMOD0090  DS    0H\n         UNPK  MSG03SSI(9),0(5,R1)   UNPACK SSI INFO\n         MVZ   MSG03SSI,COMM0F0F     TURN OFF ZONES\n         TR    MSG03SSI,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG03SSI+8,C' '       RESTORE BLANK\nMOD0100  DS    0H\n         TM    DIRATTR1,$RENT        RE-ENTRANT?\n         BO    MOD0110               YES\n         MVC   MSG03RNT,NO           NOT RE-ENTRANT\n         B     MOD0120\nMOD0110  DS    0H\n         MVC   MSG03RNT,YES          RE-ENTRANT\nMOD0120  DS    0H\n         TM    DIRATTR1,$REUS        REUSABLE?\n         BO    MOD0130               YES\n         MVC   MSG03RUS,NO           NOT REUSABLE\n         B     MOD0140\nMOD0130  DS    0H\n         MVC   MSG03RUS,YES          REUSABLE\nMOD0140  DS    0H\n         MVC   PRTDATA(MSG03L),MSG03 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         TM    DIRATTR1,$OVRLY       OVERLAY?\n         BO    MOD0150               YES\n         MVC   MSG04OVR,NO           NOT OVERLAY\n         B     MOD0160\nMOD0150  DS    0H\n         MVC   MSG04OVR,YES          OVERLAY\nMOD0160  DS    0H\n         TM    DIRATTR1,$SCTR        SCATTER LOAD?\n         BO    MOD0170               YES\n         MVC   MSG04SCT,NO           NOT SCATTER LOAD\n         B     MOD0180\nMOD0170  DS    0H\n         MVC   MSG04SCT,YES          SCATTER LOAD\nMOD0180  DS    0H\n         TM    DIRATTR1,$EXEC        EXECUTABLE?\n         BO    MOD0190               YES\n         MVC   MSG04EXC,NO           NOT EXECUTABLE\n         B     MOD0200\nMOD0190  DS    0H\n         MVC   MSG04EXC,YES          EXECUTABLE\nMOD0200  DS    0H\n         TM    DIRATTR2,$REFR        REFRESHABLE?\n         BO    MOD0210               YES\n         MVC   MSG04RFR,NO           NO REFRESHABLE\n         B     MOD0220\nMOD0210  DS    0H\n         MVC   MSG04RFR,YES          REFRESHABLE\nMOD0220  DS    0H\n         MVC   PRTDATA(MSG04L),MSG04 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         TM    DIRINDS,$ALIAS        AN ALIAS?\n         BNO   MOD0230               NO\n         MVC   PRTDATA(MSG05L),MSG05 SET MESSAGE\n         MVI   PRTCC,C'0'            SET DOUBLE SPACE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         MVC   DIRMEM,DIRRMEM        CHANGE NAMES\n         B     MOD0010               BLDL FOR REAL MEMBER\nMOD0230  DS    0H\n         MVI   DIRMTTRZ+3,X'00'      FORCE ZERO\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         POINT DISMOD,DIRMTTRZ,TYPE=REL\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         LTR   R15,R15               POINT SUCCESSFUL?\n         BZ    MOD0260               YES\n         STC   R15,POINTR15          SAVE RETURN CODE\n         STC   R0,POINTR0            SAVE REASON CODE\n         LA    R1,PNTMSGS            MESSAGE TABLE ADDRESS\nMOD0240  DS    0H\n         CLI   0(R1),X'FF'           END OF TABLE?\n         BE    ERR0070               YES\n         CLC   PNTCODE,0(R1)         MESSAGE FOUND?\n         BE    MOD0250               YES\n         LA    R1,PNTMSGL(R1)        NEXT MESSAGE\n         B     MOD0240               LOOP\nMOD0250  DS    0H\n         MVC   PRTDATA(PNTMSGL-2),2(R1)\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nMOD0260  DS    0H\n         TM    MODFLAG,$MODEOF       EOF FLAG ON?\n         BO    EXIT0000              YES, EXIT\n         BAL   R10,READ0000          READ A RECORD\n         ITRACE ID=FINDPROC,                                           +\n               DATA1=(R3)            .. CAPTURE 8 BYTES OF DATA\n         LA    R9,PROCTBLE           FIRST PROCESSOR TABLE ENTRY\n         USING PROCDSCT,R9           DEFINE BASE\nMOD0270  DS    0H\n         CLI   0(R9),X'FF'           END OF TABLE\n         BE    MOD0310               NOT LOCATED.. FORGET IT\n         CLC   PROCTYPE,0(R3)        RECORD TYPE FOUND?\n         BE    MOD0280               YES\n         LA    R9,PROCL(R9)          NEXT ENTRY\n         B     MOD0270               LOOP\nMOD0280  DS    0H\n         ITRACE ID=PROCFND,                                            +\n               DATA1=PROCTYPE\n         TM    PROCFLAG,$CSECT       CSECT REQUIRED?\n         BNO   MOD0290               NO\n         TM    COMMFLAG,$CSECT       CSECT LOCATED?\n         BNO   ERR0060               NO\n         TM    0(R3),X'08'           END OF MODULE?\n         BNO   MOD0290               NO\n         ITRACE ID=EOF\n         OI    MODFLAG,$MODEOF       SET EOF FLAG\nMOD0290  DS    0H\n         SR    R15,R15               CLEAR REGISTER\n         ICM   R15,3,PROCXTNL        EXTERNAL PROCESSING MODULE DISP\n         BZ    MOD0300               NO EXTERNAL MODULE\n         AR    R15,R11               PLUS DISASM00 BASE ADDRESS\n         L     R15,0(R15)            RECORD PROCESSOR ENTRY POINT\n         ITRACE ID=CALLXTNL,         CALLING EXTERNAL RECORD PROCESSOR +\n               RDATA1=R15            .. PROCESSOR'S ENTRY POINT ADDR\n         BALR  R14,R15               LINK TO PROCESSOR\nMOD0300  DS    0H\n         SR    R15,R15               CLEAR REGISTER\n         ICM   R15,3,PROCINTL        INTERNAL PROCESSING RTN DISP\n         BZ    MOD0260               NO INTERNAL PROCESSING MODULE\n         AR    R15,R12               PLUS BASE REG\n         ITRACE ID=CALLINTL,         CALLING INTERNAL RECORD PROCESSOR +\n               RDATA1=R15            .. PROCESSOR'S ENTRY POINT ADDR\n         BR    R15                   CALL INTERNAL RECORD PROCESSOR\nMOD0310  DS    0H\n         ITRACE ID=NOPROC            NO PROCESSOR FOR THIS RECORD TYPE\n         B     MOD0260               READ NEXT RECORD\nCSCT0000 DS    0H\n         ITRACE ID=CSECT\n         L     R3,COMMIO             I/O AREA ADDRESS\n         TM    0(R3),X'02'           RLD AND CSECT?\n         BO    CSCT0010              YES\n         LA    R4,16(R3)             CESD ENTRY NUMBER ADDRESS\n         B     CSCT0020\nCSCT0010 DS    0H\n         LH    R4,6(R3)              RLD SECTION LENGTH\n         LA    R4,16(R3,R4)          CESD ENTRY NUMBER ADDRESS\nCSCT0020 DS    0H\n         LH    R5,4(R3)              CSECT INFO LENGTH\n         SRL   R5,2                  CONVERT TO NUMBER OF ENTRIES\n         ITRACE ID=CSECTNBR,                                           +\n               RDATA1=R4,            .. CSECT DATA'S ADDRESS           +\n               RDATA2=R5             .. NUMBER OF ENTRIES\n         SR    R6,R6                 INITIALIZE OFFSET\n         SR    R7,R7                 ASSUME LENGTH IS ZERO\nCSCT0030 DS    0H\n         CLC   COMMESID,0(R4)        CORRECT ESD ID?\n         BE    CSCT0040              YES\n         AH    R6,2(R4)              PLUS LENGTH OF THIS ESD\n         LA    R4,4(R4)              NEXT ESD ID ENTRY\n         BCT   R5,CSCT0030           LOOP\n         B     CSCT0050\nCSCT0040 DS    0H\n         ITRACE ID=ESDFND,                                             +\n               RDATA1=R4             .. ESD ADDRESS\n         LH    R7,2(R4)              TEXT LENGTH\nCSCT0050 DS    0H\n         SR    R2,R2                 CLEAR REGISTER\n         ICM   R2,7,9(R3)            ASSIGNED ADDRESS\n         ITRACE ID=READTEXT\n         BAL   R10,READ0000          READ NEXT TEXT BLOCK\n         LTR   R7,R7                 TEXT LENGTH ZERO?\n         BZ    MOD0260               YES\n         AR    R2,R6                 ADDRESS + DISPLACEMENT\n         S     R2,COMMCSAD           MINUS STARTING ADDRESS\n         A     R2,COMMTXT            PLUS TEXT'S BASE ADDRESS\n         A     R6,COMMIO             DISP + I/O BASE\n         ITRACE ID=MOVETEXT\n         LR    R3,R7                 COPY LENGTH\n         MVCL  R2,R6                 COPY TEXT (WHEW!)\n         B     MOD0260               DONE\nREAD0000 DS    0H\n         ITRACE ID=READ\n         L     R3,COMMIO             I/O BUFFER'S ADDRESS\n         XC    MODDECB,MODDECB       CLEAR ECB\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         READ  MODDECB,              READ LOAD MODULE                  +\n               SF,                   .. SEQUENTIALLY FORWARD           +\n               DISMOD,               .. FROM LODLIB DATA SET           +\n               (R3),                 .. I/O AREA'S ADDRESS             +\n               32760                 .. LENGTH FROM DCB\n         CHECK MODDECB               WAIT FOR READ\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         BR    R10                   RETURN\nEOD00000 DS    0H\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         ITRACE ID=EOD\n         OI    COMMFLAG,$ERROR+$ABORT SET FLAGS\n         MVC   PRTDATA(EMSG3L),EMSG3 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              EXIT\nERR0010  DS    0H\n         MVI   BLDLR0,0              INITIALIZE REASON CODE\n         STC   R15,BLDLR15           SAVE R15\n         CLI   BLDLR15,8             R15 = 8?\n         BNE   ERR0020               NO\n         STC   R0,BLDLR0             SAVE R0\nERR0020  DS    0H\n         LA    R1,BLDLMSGS           FIRST BLDL MESSAGE\nERR0030  DS    0H\n         CLI   0(R1),X'FF'           END OF TABLE?\n         BE    ERR0050               YES\n         CLC   BLDLCODE,0(R1)        PROPER MESSAGE FOUND?\n         BE    ERR0040               YES\n         LA    R1,BLDLMSGL(R1)       NEXT MESSAGE\n         B     ERR0040               LOOP\nERR0040  DS    0H\n         MVC   PRTDATA(BLDLMSGL-2),2(R1)\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ABORT       SET ABORT FLAG\n         B     EXIT0000              AND EXIT\nERR0050  DS    0H\n         ITRACE ID=INVBLDLC,         INVALID BLDLCODE                  +\n               DATA1=BLDLCODE        ..\n         ABEND ABEND002,DUMP,,USER\nERR0060  DS    0H\n         MVC   PRTDATA(EMSG01L),EMSG01\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nERR0070  DS    0H\n         MVC   PRTDATA(EMSG02L),EMSG02\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nPRT0000  DS    0H\n         TM    MODFLAG,$SUBH         HAS SUB-HEADING BEEN PRINTED?\n         BO    PRT0010               YES\n         OI    MODFLAG,$SUBH         SET FLAG\n         MVI   PRTCMD,$PRTSUBH       SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\nPRT0010  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R10                   RETURN\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         CLOSE DISMOD                CLOSE DISMOD\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nAM24     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         BSM   R0,R14             RETURN IN 24-BIT MODE\nAM31     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         O     R14,X80            SET 31-BIT MODE\n         BSM   R0,R14             RETURN IN 31-BIT MODE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE03   DC    18F'0'                REGISTER SAVE AREA\nX80      DC    A(X'80000000')\n* ------------------------------------------------------------------- *\nBLDLIST  DS    0F                                                     |\n         DC    H'1'                  ONE MEMBER                       |\n         DC    H'80'                 LENGTH PER MEMBER                |\nDIRDATA  DS    CL80                                                   |\n         ORG   DIRDATA                                                |\nDIRMEM   DC    CL8' '                MEMBER NAME                      |\nDIRMTTRZ DC    XL4'00000000'         MEMBER'S RELATIVE ADDRESS        |\n         DC    XL1'00'                                                |\nDIRINDS  DC    X'00'                 INDICATORS                       |\n$ALIAS   EQU   X'80'                 .. MEMBER IS AN ALIAS            |\nDIRTTTR  DC    XL3'000000'           TEXT'S RELATIVE ADDRESS          |\n         DC    XL1'00'                                                |\nDIRNTTR  DC    XL3'000000'           NOTE LIST (OR SCATTER LIST) TTR\nDIR#NOTE DC    X'00'                 NUMBER OF NOTE LIST ENTRIES      D\nDIRATTR1 DC    X'00'                 ATTRIBUTE FLAGS                  A\n$RENT    EQU   X'80'                 .. RE-ENTRANT                    T\n$REUS    EQU   X'40'                 .. REUSABLE                      A\n$OVRLY   EQU   X'20'                 .. OVERLAY\n$TEST    EQU   X'10'                 .. UNDER TEST                    R\n$LDONLY  EQU   X'08'                 .. LOAD ONLY                     E\n$SCTR    EQU   X'04'                 .. SCATTER FORMAT                T\n$EXEC    EQU   X'02'                 .. EXECUTABLE                    U\n$1TEXT   EQU   X'01'                 .. 1 TEXT, NO RLD RECORDS        R\nDIRATTR2 DC    X'00'                 ATTRIBUTE FLAGS                  N\n$NOLINK1 EQU   X'80'                 .. NOT PROCESSABLE BY LINK EDIT  E\n$ORGZERO EQU   X'40'                 .. TEXT ORIGIN IS ZERO           D\n$EPZERO  EQU   X'20'                 .. ENTRY POINT IS ZERO\n$NORLD   EQU   X'10'                 .. NO RLD RECORDS                B\n$NOLINK2 EQU   X'08'                 .. NOT PROCESSABLE BY LINK EDIT  Y\n$TESTRAN EQU   X'04'                 .. CONTAINS TESTRAN SYMBOLS\n$LINK    EQU   X'02'                 .. CREATED BY LINKAGE EDITOR     B\n$REFR    EQU   X'01'                 .. REFRESHABLE                   L\nDIRMSIZE DC    XL3'000000'           MODULE'S SIZE                    D\nDIRTXTL  DC    XL2'0000'             TEXT RECORD SIZE                 L\nDIREPA   DC    XL3'000000'           ENTRY POINT\nDIRATTR3 DC    X'00'                                                  |\n$OSLINK  EQU   X'80'                 .. PROCESSED BY O/S LINK EDITOR  |\n$PALIGN  EQU   X'20'                 .. PAGE ALIGNMENT REQUIRED       |\n$SSI     EQU   X'10'                 .. SSI PRESENT                   |\nDIRATTR4 DC    X'00'                 ATTRIBUTES                       |\n$RANY    EQU   X'10'                 .. RMODE=ANY                     |\n$AA31    EQU   X'08'                 .. AMODE=31 (ALIAS)              |\n$AA24    EQU   X'04'                 .. AMODE=24 (ALIAS)              |\n$AM31    EQU   X'02'                 .. AMODE=31 (MAIN)               |\n$AM24    EQU   X'01'                 .. AMODE=24 (MAIN)               |\nDIR#RLD  DC    X'00'                 NUMBER OF RLD'S AFTER 1ST TEXT   |\nDIRSCTR  DC    XL2'0000'             SCATTER LIST LENGTH              |\nDIRTRAN  DC    XL2'0000'             TRANSLATION TABLE LENGTH         |\nDIRTCEST DC    XL2'0000'             CESD NUMBER FOR 1ST TXT RECORD   |\nDIRECESD DC    XL2'0000'             CESD NUMBER FOR ENTRY POINT      |\n         ORG   DIRSCTR               RESET TO VARIABLE PORTION        |\nDIRMEP   DC    XL3'000000'           ENTRY POINT OF MEMBER NAME       |\nDIRRMEM  DC    CL8' '                REAL MEMBER NAME IF ALIAS        |\nDIRSSI   DC    XL4'00000000'         SSI INFO                         |\nDIRAUTHL DC    XL1'00'               AUTH CODE LENGTH                 |\nDIRAUTHC DC    XL1'00'               AUTH CODE                        |\n         ORG   DIRDATA+80                                             |\n* ------------------------------------------------------------------- *\n         SPACE 1\nMODFLAG  DC    X'00'                 PROGRAM FLAGS/SWITCHES\n$SUBH    EQU   X'80'                 .. SUBHEADING PRINTED\n$MODEOF  EQU   X'40'                 .. END OF CONTROL DATA\nBLDLCODE DS    0XL2                  BLDL RETURN CODE/REASON CODE\nBLDLR15  DC    X'00'                 .. R15\nBLDLR0   DC    X'00'                 .. R0\nPNTCODE  DS    0XL2                  POINT RETURN CODE/REASON CODE\nPOINTR15 DC    X'00'                 .. R15\nPOINTR0  DC    X'00'                 .. R0\nNO       DC    CL3'NO'\nYES      DC    CL3'YES'\nSUBHD1   DC    C' LOAD MODULE ATTRIBUTES '\nSUBHD1L  EQU   *-SUBHD1\nMSG01    DS    0C\n         DC    CL12'MEMBER NAME:'\nMSG01MEM DC    CL08' '\n         DC    CL10' '\n         DC    CL06'ALIAS:'\nMSG01ALS DC    CL03' '\n         DC    CL21' '\n         DC    CL09'TEXT TTR:'\nMSG01TXT DC    CL06' '\n         DC    CL15' '\n         DC    CL13'NOTELIST TTR:'\nMSG01NTE DC    CL06' '\n         DC    C' '\nMSG01L   EQU   *-MSG01\nMSG02    DS    0C\n         DC    CL17'NOTELIST ENTRIES:'\nMSG02NTE DC    CL04' '\n         DC    CL09' '\n         DC    CL17'LOAD MODULE SIZE:'\nMSG02SZ  DC    CL06' '\n         DC    CL07' '\n         DC    CL12'ENTRY POINT:'\nMSG02EPA DC    CL06' '\n         DC    CL12' '\n         DC    CL17'REAL MEMBER NAME:'\nMSG02MEM DC    CL8' '\nMSG02L   EQU   *-MSG02\nMSG03    DS    0C\n         DC    CL10'AUTH CODE:'\nMSG03ATH DS    CL02' '\n         DC    CL18' '\n         DC    CL09'SSI INFO:'\nMSG03SSI DC    CL08' '\n         DC    CL13' '\n         DC    CL11'RE-ENTRANT:'\nMSG03RNT DC    CL03' '\n         DC    CL16' '\n         DC    CL09'REUSABLE:'\nMSG03RUS DC    CL03' '\nMSG03L   EQU   *-MSG03\nMSG04    DS    0C\n         DC    CL08'OVERLAY:'\nMSG04OVR DS    CL03' '\n         DC    CL19' '\n         DC    CL13'SCATTER LOAD:'\nMSG04SCT DC    CL03' '\n         DC    CL14' '\n         DC    CL11'EXECUTABLE:'\nMSG04EXC DC    CL03' '\n         DC    CL16' '\n         DC    CL12'REFRESHABLE:'\nMSG04RFR DC    CL03' '\nMSG04L   EQU   *-MSG04\nMSG05    DC    48C'-'\n         DC    CL24' REAL MODULE ATTRIBUTES '\n         DC    48C'-'\nMSG05L   EQU   *-MSG05\nEMSG01   DC    C'DISASM0301E Specified CSECT not found'\nEMSG01L  EQU   *-EMSG01\nEMSG02   DC    C'DISASM0302E Unknown return code from POINT macro'\nEMSG02L  EQU   *-EMSG02\nEMSG3    DC    C'DISASM0303E DCB EODAD routine driven, end of control r+\n               ecords not detected'\nEMSG3L   EQU   *-EMSG3\nBLDLMSGS DS    0C\n         DC    X'0400',CL55'DISASM0304E Module does not exist in DISMOD+\n                library'\nBLDLMSGL EQU   *-BLDLMSGS\n         DC    X'0800',CL55'DISASM0305E Permanent I/O error'\n         DC    X'0804',CL55'DISASM0306E Insufficient virtual storage'\n         DC    X'0808',CL55'DISASM0307E DEB not in KEY 0-7'\n         DC    X'FF'\nPNTMSGS  DS    0C\n         DC    X'0400',CL55'DISASM0308E Device does not support block i+\n               dentifier'\nPNTMSGL  EQU   *-PNTMSGS\n         DC    X'0801',CL55'DISASM0309E Incorrect parameter'\n         DC    X'0802',CL55'DISASM0310E Incorrect DEB or DEBCHK error'\n         DC    X'0803',CL55'DISASM0311E Environmental error'\n         DC    X'080B',CL55'DISASM0312E Unsuccessful call to ESTAE'\n         DC    X'080C',CL55'DISASM0313E Unsuccessful GETMAIN'\n         DC    X'0C00',CL55'DISASM0314E Input/output error'\n         DC    X'FF'\nPROCTBLE DS    0X\n         PROC  01,CSCT0000,,$CSECT            CSECT RECORDS\n         PROC  02,,A05,$CSECT                 RLD RECORDS\n         PROC  03,CSCT0000,A05,$CSECT         CSECT AND RLD RECORDS\n         PROC  05,CSCT0000,,$CSECT            CSECT RECORDS\n         PROC  06,,A05,$CSECT                 RLD RECORDS\n         PROC  07,CSCT0000,A05,$CSECT         CSECT AND RLD RECORDS\n         PROC  0D,CSCT0000,,$CSECT            CSECT RECORDS\n         PROC  0E,,A05,$CSECT                 RLD RECORDS\n         PROC  0F,CSCT0000,A05,$CSECT         CSECT AND RLD RECORDS\n         PROC  20,,A04                        CESD RECORDS\n         DC    X'FF'\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              OBJECT MODULE LIBRARY DCB                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISMOD   DCB   DDNAME=DISMOD,        OBJECT MODULE LIBRARY DCB         +\n               DSORG=PO,             .. PARTITIONED DATA SET           +\n               RECFM=U,              .. UNDEFINED RECORD FORMAT        +\n               EODAD=EOD00000,       .. END OF DATA                    +\n               MACRF=R               .. READ ONLY\n         SPACE 2\n         LTORG\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PROCESSOR TABLE                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nPROCDSCT DSECT\nPROCTYPE DS   X                     RECORD CODE\nPROCFLAG DS   X                     FLAGS\nPROCINTL DS   AL2                   INTERNAL PROCESSING RTN\nPROCXTNL DS   AL2                   EXTERNAL PROCESSING MODULE\nPROCL    EQU  *-PROCDSCT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM03\n./ ADD MEMBER=DISASM04\n         TITLE 'DISASM04 - ESD DATA PROCESSOR'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM04                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Process ESD data as a sub-function of DISASM03.  ESD data is     *\n*   printed and saved in ESDDATA blocks for use in generating labels *\n*   and ENTRY statements.                                            *\n*                                                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB\nDISASM04 CSECT\nDISASM04 AMODE 31\nDISASM04 RMODE 24\n         USING DISASM04,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     ESD0000               SKIP EYECATCHER\n         DC    CL8'DISASM04'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nESD0000  DS    0H\n         LA    R1,SAVE04             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         ITRACE ID=ENTRY\n         MVC   COMMSUBH(SUBHEADL),SUBHEAD\n         LA    R1,SUBHEADL           SUBHEADING LENGTH\n         STH   R1,COMMSUBL           SET LENGTH\n         MVI   COMMSUBL,X'FF'        INDICATE NON-CENTERED\n         TM    ESDFLAG,$SUBH         INITIAL SUB HEADING PRINTED?\n         BO    ESD0010               YES\n         OI    ESDFLAG,$SUBH         SET FLAG\n         MVC   PRTDATA(MSG01L),MSG01 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         MVC   PRTDATA(SUBHEADL-1),SUBHEAD+1\n         BAL   R10,PRT0000           PRINT MESSAGE\nESD0010  DS    0H\n         LA    R4,COMMESD            FIRST ESD RECORD'S ADDRESS\n         USING ESDDATA,R4            DEFINE BASE\nESD0020  DS    0H\n         OC    ESDNEXT,ESDNEXT       MORE ON CHAIN?\n         BZ    ESD0030               NO\n         L     R4,ESDNEXT            FOLLOW THE CHAIN\n         B     ESD0020               LOOP\nESD0030  DS    0H\n         L     R3,COMMIO             I/O AREA ADDRESS\n         MVC   SAVEESD,4(R3)         SAVE ESD ID OF FIRST ITEM\n         LH    R5,6(R3)              SIZE OF ESD DATA\n         SRL   R5,4                  COMPUTE NUMBER OF ESD ENTRIES\n         LA    R6,8(R3)              FIRST ESD ITEM\n         ITRACE ID=PROCESD,                                            +\n               RDATA1=R5,            .. NUMBER OF ESD ENTRIES          +\n               RDATA2=R6             .. FIRST ESD DATA ADDRESS\nESD0040  DS    0H\n         GETMAIN RU,                 ACQUIRE STORAGE FOR ESD DATA      +\n               LV=ESDDATAL,          .. SIZE                           +\n               LOC=ANY\n         ITRACE ID=NEWESD,                                             +\n               RDATA1=R1             .. NEW ESD BLOCK'S ADDRESS\n         ST    R1,ESDNEXT            CHAIN FORWARD\n         LR    R4,R1                 SET NEW BLOCK ADDRESS\n         MVC   ESDEYE,ESD            SET EYECATCHER\n         XC    ESDNEXT,ESDNEXT       CLEAR NEXT BLOCK'S ADDRESS\n         MVC   ESDNAME(ESDL),0(R6)   COPY ESD DATA\n         LH    R1,SAVEESD            CURRENT ESD ID NUMBER\n         STCM  R1,3,ESDID            SET ESD ID\n         LA    R1,1(R1)              ADD 1 TO ESD ID NUMBER\n         STH   R1,SAVEESD            SAVE UPDATED ID\n         MVC   MSG02SYM,ESDNAME      SET NAME\n         OC    MSG02SYM,COMMBLKS     FORCE AT LEAST X'40'S\n         LA    R1,ESDTBLE            FIRST ESD TYPE/DESCRIPTOR\nESD0050  DS    0H\n         CLI   0(R1),X'FF'           END OF TABLE?\n         BE    ESD0060               YES\n         CLC   ESDTYPE,0(R1)         DESCRIPTOR FOUND?\n         BE    ESD0060               YES\n         LA    R1,ESDTBLEL(R1)       NEXT ESD DESCRIPTOR\n         B     ESD0050               LOOP\nESD0060  DS    0H\n         MVC   MSG02TYP,1(R1)        SET ESD TYPE\n         UNPK  MSG02ADR(7),ESDADDR(4)\n         MVZ   MSG02ADR,COMM0F0F     TURN OFF ZONES\n         TR    MSG02ADR,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02ADR+6,C' '       RESTORE BLANK\n         UNPK  MSG02SEG(3),ESDSEG(2) UNPACK SEGMENT NUMBER\n         MVZ   MSG02SEG,COMM0F0F     TURN OFF ZONES\n         TR    MSG02SEG,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02SEG+2,C' '       RESTORE BLANK\n         UNPK  MSG02LEN(7),ESDLEN(4) UNPACK LENGTH\n         MVZ   MSG02LEN,COMM0F0F     TURN OFF ZONES\n         TR    MSG02LEN,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02LEN+6,C' '       RESTORE BLANK\n         UNPK  MSG02ESD(5),ESDID(3)  UNPACK ESD ID\n         MVZ   MSG02ESD,COMM0F0F     TURN OFF ZONES\n         TR    MSG02ESD,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02ESD+4,C' '       RESTORE BLANK\n         MVC   MSG02MSG,COMMBLKS     CLEAR MESSAGE\n         CLI   ESDTYPE,$ESDSD        EXTERNAL SYMBOL?\n         BE    ESD0070               YES\n         CLI   ESDTYPE,$ESDPC        PRIVATE CODE?\n         BNE   ESD0090               NO\nESD0070  DS    0H\n         CLI   COMMCSNM,C' '         CSECT GIVEN?\n         BNE   ESD0080               YES\n         MVC   COMMCSNM,ESDNAME      SET NAME (WILL BE FIRST CSECT)\nESD0080  DS    0H\n         CLC   ESDNAME,COMMCSNM      CORRECT CSECT FOUND?\n         BNE   ESD0090               NO\n         ITRACE ID=CSECTFND\n         SR    R1,R1                 CLEAR REGISTER\n         ICM   R1,7,ESDADDR          CSECT'S ADDRESS\n         ST    R1,COMMCSAD           SET CSECT ADDRESS\n         SR    R2,R2                 CLEAR REGISTER\n         ICM   R2,7,ESDLEN           CSECT LENGTH\n         ST    R2,COMMCSLN           SET CSECT LENGTH\n         AR    R1,R2                 ADDRESS + LENGTH\n         BCTR  R1,0                  MINUS 1\n         ST    R1,COMMCSEA           SAVE ENDING ADDRESS\n         ITRACE ID=CSECTAD,DATA1=COMMCSAD,DATA2=COMMCSEA\n         LA    R2,32(R2)             PREVENT'S 0C4'S IN TEXT PRINTER\n         GETMAIN RU,                 ACQUIRE STORAGE FOR CSECT         +\n               LV=(R2),              .. SIZE                           +\n               LOC=BELOW\n         ST    R1,COMMTXT            SAVE TEXT'S STORAGE ADDRESS\n         MVC   COMMESID,ESDID        SAVE ESD ID OF CSECT\n         OI    COMMFLAG,$CSECT       CSECT HAS BEEN FOUND\n         MVC   MSG02MSG,MSGMSG       SET MESSAGE\nESD0090  DS    0H\n         MVC   PRTDATA(MSG02L),MSG02 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         LA    R6,ESDL(R6)           NEXT ESD DATA\n         BCT   R5,ESD0040            LOOP\n         B     EXIT0000\nPRT0000  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET INTERFACE BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               PRINT SUBHEADING\n         BR    R10                   EXIT\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE04   DC    18F'0'                REGISTER SAVE AREA\nSAVEESD  DC    H'0'\nESDFLAG  DC    X'00'\n$SUBH    EQU   X'80'                 INITIAL SUB HEADING PRINTED\nESD      DC    CL8'ESD'\nSUBHEAD  DC    C'0'\n         DC    CL08' '\n         DC    CL08' SYMBOL '\n         DC    CL02' '\n         DC    CL04'TYPE'\n         DC    CL02' '\n         DC    CL06' ADDR '\n         DC    CL02' '\n         DC    CL03'SEG'\n         DC    CL02' '\n         DC    CL06'LENGTH'\n         DC    CL02' '\n         DC    CL06'ESDID'\nSUBHEADL EQU   *-SUBHEAD\nMSG01    DC    48C'-'\n         DC    CL23' EXTERNAL SYMBOL TABLE '\n         DC    49C'-'\nMSG01L   EQU   *-MSG01\nMSG02    DS    0C\n         DC    CL08' '\nMSG02SYM DC    CL08' '                 EXTERNAL SYMBOL\n         DC    CL02' '\nMSG02TYP DC    CL04' '                 SYMBOL TYPE\n         DC    CL02' '\nMSG02ADR DC    CL06' '                 ADDRESS\n         DC    CL02' '\nMSG02SEG DC    CL02' '                 SEGMENT NUMBER\n         DC    CL03' '\nMSG02LEN DC    CL06' '                 LENGTH\n         DC    CL02' '\nMSG02ESD DC    CL04' '                 ESD ID\n         DC    CL02' '\nMSG02MSG DC    CL15' '                 MESSAGE\nMSG02L   EQU   *-MSG02\nMSGMSG   DC    CL15'REQUESTED CSECT'\nESDTBLE  DS    0C\n         DC    AL1($ESDSD),CL4' SD'\nESDTBLEL EQU   *-ESDTBLE\n         DC    AL1($ESDER),CL4' ER'\n         DC    AL1($ESDLR),CL4' LR'\n         DC    AL1($ESDPC),CL4' PC'\n         DC    AL1($ESDCM),CL4' CM'\n         DC    AL1($ESDPR),CL4' PS'\n         DC    AL1($ESDNULL),CL4'NULL'\n         DC    AL1($ESDWX),CL4' WX '\n         DC    AL1($ESDOV),CL4' OV '\n         DC    X'FF',CL4'UNKN'\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              LITERALS                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LTORG\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM04\n./ ADD MEMBER=DISASM05\n         TITLE 'DISASM05 - RLD DATA PROCESSOR'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM05                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Process RLD records.  This module runs as a sub-function of      *\n*   DISASM03.  RLD data is interpreted and individual fields are     *\n*   represented in RLDDATA blocks chained from field COMMRLD of      *\n*   the common module, DISASM00.                                     *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB\nDISASM05 CSECT\nDISASM05 AMODE 31\nDISASM05 RMODE 24\n         USING DISASM05,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     RLD0000               SKIP EYECATCHER\n         DC    CL8'DISASM05'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nRLD0000  DS    0H\n         LA    R1,SAVE05             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         ITRACE ID=ENTRY\n         MVC   COMMSUBH(SUBHEADL),SUBHEAD\n         LA    R1,SUBHEADL           SUBHEADING LENGTH\n         STH   R1,COMMSUBL           SET LENGTH\n         MVI   COMMSUBL,X'FF'        INDICATE NON-CENTERED\n         TM    RLDFLAG,$SUBH         SUBHEADING PRINTED?\n         BO    RLD0010               YES\n         OI    RLDFLAG,$SUBH         SET FLAG\n         MVC   PRTDATA(MSG01L),MSG01 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         MVC   PRTDATA(SUBHEADL-1),SUBHEAD+1\n         BAL   R10,PRT0000           PRINT MESSAGE\nRLD0010  DS    0H\n         LA    R5,COMMRLD            FIRST RLD RECORD'S ADDRESS\n         USING RLDDATA,R5            DEFINE BASE\nRLD0020  DS    0H\n         OC    RLDNEXT,RLDNEXT       MORE ON CHAIN?\n         BZ    RLD0030               NO\n         L     R5,RLDNEXT            FOLLOW THE CHAIN\n         B     RLD0020               LOOP\nRLD0030  DS    0H\n         L     R4,COMMIO             I/O AREA ADDRESS\n         LH    R6,6(R4)              SIZE OF RLD DATA\n         LA    R7,16(R4)             FIRST RLD ITEM\n         ITRACE ID=PROCRLD,                                            +\n               RDATA1=R6,            .. RLD DATA LENGTH                +\n               RDATA2=R7             .. FIRST RLD DATA ADDRESS\nRLD0040  DS    0H\n         MVC   SAVEPTR,0(R7)         SAVE RLD POINTER\n         MVC   SAVEPP,2(R7)          SAVE POSITION POINTER\n         LA    R7,4(R7)              SKIP RLD AND POSITION POINTERS\n         SH    R6,COMMH4             MINUS LENGTH USED\n         BZ    EXIT0000              NO DATA.. EXIT\nRLD0050  DS    0H\n         ITRACE ID=NEWITEM,                                            +\n               RDATA1=R7,                                              +\n               DATA2=0(R7)\n         CLC   1(3,R7),COMMCSAD+1    ADDRESS TOO LOW?\n         BL    RLD0250               YES..\n         CLC   1(3,R7),COMMCSEA+1    ADDRESS TOO HIGH?\n         BH    RLD0250               YES..\n         GETMAIN RU,                 ACQUIRE STORAGE FOR RLD DATA      +\n               LV=RLDDATAL,          .. SIZE                           +\n               LOC=ANY\n         ITRACE ID=NEWRLD,                                             +\n               RDATA1=R1             .. NEW RLD BLOCK'S ADDRESS\n         ST    R1,RLDNEXT            CHAIN FORWARD\n         LR    R5,R1                 SET NEW BLOCK ADDRESS\n         MVC   RLDEYE,RLD            SET EYECATCHER\n         XC    RLDNEXT,RLDNEXT       CLEAR NEXT BLOCK'S ADDRESS\n         MVC   RLDLEN,0(R7)          SET LENGTH (SORT OF)\n         NI    RLDLEN,X'0F'          TURN OFF 'TYPE' BITS\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,RLDLEN             LENGTH, DIRECTION, AND INDICATOR\n         SRL   R1,2                  SHIFT OUT DIRECTION AND INDICATOR\n         LA    R1,1(R1)              +1 = REAL LENGTH\n         STH   R1,RLDLEN             SAVE LENGTH\n         ICM   R1,7,1(R7)            CONSTANT'S ADDRESS\n         S     R1,COMMCSAD           DISPLACEMENT INTO THIS CSECT\n         STCM  R1,15,RLDDISP         SAVE DATA DISPLACEMENT\n         MVC   RLDPTR,SAVEPTR        SET RLD POINTER\n         MVC   RLDPP,SAVEPP          SET POSITION POINTER\n         MVC   RLDTYPE,0(R7)         SET RLD TYPE\n         NI    RLDTYPE,X'F0'         CLEAR LEN, DIRECTION, INDICATOR\n         TM    0(R7),X'02'           DIRECTION BACKWARD (-) ?\n         BO    RLD0060               YES\n         MVI   RLDDIR,C'+'           SET DIRECTION (PLUS)\n         B     RLD0070\nRLD0060  DS    0H\n         MVI   RLDDIR,C'-'           SET DIRECTION (MINUS)\nRLD0070  DS    0H\n         UNPK  MSG02PTR(5),RLDPTR(3) UNPACK RLD POINTER\n         MVZ   MSG02PTR,COMM0F0F     TURN OFF ZONES\n         TR    MSG02PTR,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02PTR+4,C' '       RESTORE BLANK\n         UNPK  MSG02PP(5),RLDPP(3)   UNPACK POSITION POINTER\n         MVZ   MSG02PP,COMM0F0F      TURN OFF ZONES\n         TR    MSG02PP,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   MSG02PP+4,C' '        RESTORE BLANK\n         LA    R1,RLDTBLE            FIRST RLD TYPE/DESCRIPTOR\nRLD0080  DS    0H\n         CLI   0(R1),X'FF'           END OF TABLE?\n         BE    RLD0090               YES\n         CLC   RLDTYPE,0(R1)         DESCRIPTOR FOUND?\n         BE    RLD0090               YES\n         LA    R1,RLDTBLEL(R1)       NEXT RLD DESCRIPTOR\n         B     RLD0080               LOOP\nRLD0090  DS    0H\n         MVC   MSG02TYP,1(R1)        SET RLD TYPE\n         MVC   MSG02LEN,RLDLEN+1     MOVE LENGTH\n         OI    MSG02LEN,X'F0'        CONVERT TO EBCDIC\n         MVC   MSG02DIR,RLDDIR       COPY DIRECTION\n         UNPK  MSG02DSP(9),RLDDISP(5)\n         MVZ   MSG02DSP,COMM0F0F     TURN OFF ZONES\n         TR    MSG02DSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG02DSP+8,C' '       RESTORE BLANK\n         MVC   MSG02ENM,COMMBLKS     CLEAR NAME\n         SR    R1,R1                 CLEAR REGISTER\n         ICM   R1,3,RLDPTR           RLD POINTER\n         BZ    RLD0150               IGNORE IF ZERO\n         L     R3,COMMESD            FIRST ESD ENTRY\n         USING ESDDATA,R3            DEFINE BASE\n         B     RLD0110               ENTER LOOP\nRLD0100  DS    0H\n         ICM   R3,15,ESDNEXT         NEXT ESD ENTRY\n         BZ    ERR0020               IF ZERO.. BAD NEWS\nRLD0110  DS    0H\n         BCT   R1,RLD0100            LOOP\nRLD0120  DS    0H\n         ST    R3,RLDESD             CHAIN RLD TO ESD\n         MVC   MSG02ENM,ESDNAME      COPY NAME\n         LA    R1,ESDTBLE            FIRST ESD TYPE/DESCRIPTOR\nRLD0130  DS    0H\n         CLI   0(R1),X'FF'           END OF TABLE?\n         BE    RLD0140               YES\n         CLC   ESDTYPE,0(R1)         DESCRIPTOR FOUND?\n         BE    RLD0140               YES\n         LA    R1,ESDTBLEL(R1)       NEXT ESD DESCRIPTOR\n         B     RLD0130               LOOP\nRLD0140  DS    0H\n         MVC   MSG02ETY,1(R1)        SET ESD TYPE\nRLD0150  DS    0H\n         MVC   PRTDATA(MSG02L),MSG02 SET MESSAGE\n         BAL   R10,PRT0000           PRINT RLD MESSAGE\n*--------------------------------------------------------------------*\n*      FIND OUT IF THE RLD DATA IS WITHIN A DEFINED DATA AREA        *\n*--------------------------------------------------------------------*\n         ICM   R0,15,RLDDISP         DISPLACEMENT TO RLD DATA\n         LH    R1,RLDLEN             RLD DATA LENGTH\n         AR    R1,R0                 PLUS BEGINNING DISPLACEMENT\n         BCTR  R1,0                  MINUS 1\n         STCM  R1,15,TEMPEND         ENDING DISPLACEMENT\n         LA    R2,COMMDATA           'LAST' FORWARD POINTER\n         ICM   R8,15,COMMDATA        FIRST 'DATA' BLOCK\n         USING DATADSCT,R8           DEFINE BASE\n         BZ    RLD0170               NO DATA BLOCKS\nRLD0160  DS    0H\n         CLC   RLDDISP,DATABEGN      AT EXACT SAME LOCATION?\n         BE    RLD0230               YES\n         CLC   TEMPEND,DATABEGN      TOO LOW?\n         BL    RLD0170               NOT IN A DEFINED AREA\n         CLC   RLDDISP,DATAEND       TOO HIGH?\n         BNH   RLD0240               IN A DEFINED AREA\n         LA    R2,DATANEXT           LAST FORWARD POINTER\n         ICM   R8,15,DATANEXT        NEXT DATA BLOCK'S ADDRESS\n         BNZ   RLD0160               LOOP\n*--------------------------------------------------------------------*\n*      RLD DATA IS NOT IN A DEFINED AREA                             *\n*--------------------------------------------------------------------*\nRLD0170  DS    0H\n         GETMAIN RU,                 ACQUIRE DATA BLOCK STORAGE        +\n               LV=DATAL,             .. SIZE                           +\n               LOC=ANY\n         ITRACE ID=NEWDATA,          TRACE NEW BLOCKS                  +\n               RDATA1=R1\n         ST    R1,0(R2)              CHAIN TO PREVIOUS BLOCK\n         ST    R8,DATANEXT-DATADSCT(R1)\n         LR    R8,R1                 SET BASE\n         MVC   DATAEYE,DATA          SET EYECATCHER\n         MVC   DATABEGN,RLDDISP      DATA BEGINNING DISPLACEMENT\n         MVC   DATAEND,TEMPEND       DATA ENDING DISPLACEMENT\n         XC    DATALEN(2),DATALEN\n         MVC   DATALEN+2(2),RLDLEN   SET RLD DATA LENGTH\n         MVC   DATANAME,COMMBLKS     INITIALIZE NAME\n         XC    DATALBA,DATALBA       INITIALIZE LABEL BLOCK'S ADDRESS\n         CLI   RLDTYPE,$RLDACON      ADCON?\n         BE    RLD0180               YES\n         CLI   RLDTYPE,$RLDVCON      VCON?\n         BE    RLD0200               YES\n         CLI   RLDTYPE,$RLDER1       UNRESOLVED EXTERNAL REFERENCE?\n         BE    RLD0200               YES\n         CLI   RLDTYPE,$RLDER2       UNRESOLVED EXTERNAL REFERENCE?\n         BE    RLD0200               YES\n         CLI   RLDTYPE,$RLDPSSZ      PSEUDO AREA SIZE?\n         BE    RLD0210               YES\n         CLI   RLDTYPE,$RLDPSDP      PSEUDO AREA DISPLACEMENT?\n         BE    RLD0220               YES\n         MVC   PRTDATA(EMSG01L),EMSG01\n         BAL   R10,PRT0000           PRINT THE MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         ABEND ABEND003,DUMP,,USER   ABEND\nRLD0180  DS    0H\n         CLC   ESDNAME,COMMCSNM      SAME AS REQUESTED CSECT NAME?\n         BNE   RLD0190               NO\n         MVI   DATATYPE,$DATAACN     ADCON\n         B     RLD0250               AND EXIT\nRLD0190  DS    0H\n         UNPK  MSG03DSP(9),RLDDISP(5)\n         MVZ   MSG03DSP,COMM0F0F     CLEAR ZONES\n         TR    MSG03DSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG03DSP+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(MSG03L),MSG03 COPY MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\nRLD0200  DS    0H\n         MVI   DATATYPE,$DATAVCN     VCON\n         MVC   DATANAME,ESDNAME      COPY NAME FOR VCON\n         B     RLD0250               AND EXIT\nRLD0210  DS    0H\n         MVI   DATATYPE,$DATACXD     PSEUDO AREA SIZE\n         B     RLD0250               AND EXIT\nRLD0220  DS    0H\n         MVI   DATATYPE,$DATAQ       PSEUDO AREA DISPLACEMENT\n         MVC   DATANAME,ESDNAME      COPY NAME FOR Q AREA\n         B     RLD0250\nRLD0230  DS    0H\n         CLC   RLDLEN,DATALEN+2      SAME LENGTH?\n         BNE   RLD0240               NO\n         CLI   DATATYPE,$DATAACN     IS DATA AN ADCON?\n         BNE   RLD0240               NO\n         CLI   RLDTYPE,$RLDACON      IS RLD ITEM AN ADCON?\n         BNE   RLD0240               NO\n         ITRACE ID=DUPADCON,                                           +\n               RDATA1=R7,                                              +\n               DATA2=0(R7)\n         MVC   PRTDATA(MSG04L),MSG04\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     RLD0250\nRLD0240  DS    0H\n         ITRACE ID=OVERLAP,                                            +\n               RDATA1=R7,                                              +\n               DATA2=0(R7)\n         NOPR  0\n         UNPK  EMSG04RB(9),RLDDISP(5)\n         MVZ   EMSG04RB,COMM0F0F     CLEAR ZONES\n         TR    EMSG04RB,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   EMSG04RB+8,C' '       RESTORE BLANK\n         UNPK  EMSG04RE(9),TEMPEND(5)\n         MVZ   EMSG04RE,COMM0F0F     CLEAR ZONES\n         TR    EMSG04RE,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   EMSG04RE+8,C' '       RESTORE BLANK\n         UNPK  EMSG04DB(9),DATABEGN(5)\n         MVZ   EMSG04DB,COMM0F0F     CLEAR ZONES\n         TR    EMSG04DB,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   EMSG04DB+8,C' '       RESTORE BLANK\n         UNPK  EMSG04DE(9),DATAEND(5)\n         MVZ   EMSG04DE,COMM0F0F     CLEAR ZONES\n         TR    EMSG04DE,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   EMSG04DE+8,C' '       RESTORE BLANK\n         MVC   PRTDATA(EMSG04L),EMSG04\n         OI    COMMFLAG,$ERROR+$ABORT\n         BAL   R10,PRT0000           PRINT MESSAGE\nRLD0250  DS    0H\n         TM    0(R7),X'01'           RLD/POS PTRS VALID FOR NEXT ITEM?\n         BO    RLD0260               YES\n         MVC   SAVEPTR,4(R7)         SAVE NEW RLD POINTER\n         MVC   SAVEPP,6(R7)          SAVE NEW POSITION POINTER\n         LA    R7,4(R7)              UPDATE DATA ADDRESS\n         SH    R6,COMMH4             MINUS LENGTH USED\n         BZ    EXIT0000              ALL DONE\nRLD0260  DS    0H\n         LA    R7,4(R7)              NEXT RLD ITEM\n         SH    R6,COMMH4             MINUS LENGTH USED\n         BH    RLD0050               PROCESS NEXT RLD ITEM\nERR0010  DS    0H\n         MVC   PRTDATA(EMSG02L),EMSG02\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         ABEND ABEND004,DUMP,,USER\n         B     EXIT0000              AND EXIT\nERR0020  DS    0H\n         MVC   PRTDATA(EMSG03L),EMSG03\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nPRT0000  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET INTERFACE BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               PRINT SUBHEADING\n         BR    R10                   EXIT\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nDWORD    DC    D'0'\nSAVE05   DC    18F'0'                REGISTER SAVE AREA\nRLDFLAG  DC    X'00'\n$SUBH    EQU   X'80'                 SUBHEADING PRINTED\nSAVEPTR  DC    XL2'0000'\nSAVEPP   DC    XL2'0000'\nTEMPEND  DC    XL4'0000'\nRLD      DC    CL8'RLD'\nDATA     DC    CL8'DATA'\nSUBHEAD  DS    0C\n         DC    CL08' '\n         DC    CL06'RELPTR'\n         DC    CL02' '\n         DC    CL16'POSITION POINTER'\n         DC    CL02' '\n         DC    CL10'   TYPE   '\n         DC    CL02' '\n         DC    CL06'LENGTH'\n         DC    CL02' '\n         DC    CL09'DIRECTION'\n         DC    CL05' '\n         DC    CL06' DISP '\n         DC    CL04' '\n         DC    CL10'ESD SYMBOL'\n         DC    CL02' '\n         DC    CL08'ESD TYPE'\nSUBHEADL EQU   *-SUBHEAD\nMSG01    DC    55C'-'\n         DC    CL10' RLD DATA '\n         DC    55C'-'\nMSG01L   EQU   *-MSG01\nMSG02    DS    0C\n         DC    CL09' '\nMSG02PTR DC    CL04' '                 RLD POINTER\n         DC    CL09' '\nMSG02PP  DC    CL04' '                 POSITION POINTER\n         DC    CL08' '\nMSG02TYP DC    CL10' '                 RLD TYPE\n         DC    CL05' '\nMSG02LEN DC    CL01' '                 LENGTH\n         DC    CL08' '\nMSG02DIR DC    CL01' '                 DIRECTION (+ OR -)\n         DC    CL07' '\nMSG02DSP DC    CL08' '                 DISPLACEMENT\n         DC    CL04' '\nMSG02ENM DC    CL08' '                 CORRESPONDING ESD ENTRY NAME\n         DC    CL04' '\nMSG02ETY DC    CL04' '                 CORRESPONDING ESD ENTRY TYPE\nMSG02L   EQU   *-MSG02\nMSG03    DC    C'DISASM0503W RLD item at '\nMSG03DSP DC    CL8' '\n         DC    C' changed from ADCON to VCON, reference is in a differe+\n               nt CSECT'\nMSG03L   EQU   *-MSG03\nMSG04    DC    C'DISASM0504W This RLD item references an ADCON previous+\n               ly encountered'\nMSG04L   EQU   *-MSG04\nEMSG01   DC    C'DISASM0501E Unknown RLD data type'\nEMSG01L  EQU   *-EMSG01\nEMSG02   DC    C'DISASM0502E RLD data remaining went negative'\nEMSG02L  EQU   *-EMSG02\nEMSG03   DC    C'DISASM0503E RLD pointer larger than number of ESD item+\n               s'\nEMSG03L  EQU   *-EMSG03\nEMSG04   DC    C'DISASM0504E RLD data at '\nEMSG04RB DC    CL08' '\n         DC    C' to '\nEMSG04RE DC    CL08' '\n         DC    C' overlaps a user defined data area at '\nEMSG04DB DC    CL08' '\n         DC    C' to '\nEMSG04DE DC    CL08' '\n         DC    C' '\nEMSG04L  EQU   *-EMSG04\nRLDTBLE  DS    0C\n         DC    AL1($RLDACON),CL10'ADCON'\nRLDTBLEL EQU   *-RLDTBLE\n         DC    AL1($RLDVCON),CL10'VCON'\n         DC    AL1($RLDPSSZ),CL10'CXD'\n         DC    AL1($RLDPSDP),CL10'Q'\n         DC    AL1($RLDER1),CL10'UNRESOLVED'\n         DC    AL1($RLDER2),CL10'UNRESOLVED'\n         DC    X'FF',CL10'UNKNOWN'\nESDTBLE  DS    0C\n         DC    AL1($ESDSD),CL4' SD'\nESDTBLEL EQU   *-ESDTBLE\n         DC    AL1($ESDER),CL4' ER'\n         DC    AL1($ESDLR),CL4' LR'\n         DC    AL1($ESDPC),CL4' PC'\n         DC    AL1($ESDCM),CL4' CM'\n         DC    AL1($ESDPR),CL4' PS'\n         DC    AL1($ESDNULL),CL4'NULL'\n         DC    AL1($ESDWX),CL4' WX '\n         DC    AL1($ESDOV),CL4' OV '\n         DC    X'FF',CL4'UNKN'\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n         SPACE 1\n         LTORG\n         SPACE 1\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM05\n./ ADD MEMBER=DISASM06\n         TITLE 'DISASM06 - TEXT PRINTER'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM06                                             *\n*                                                                    *\n*  Function:                                                         *\n*   TEXT printer.  The object module will have already been read     *\n*   into storage by the module reader DISASM03.  Fields COMMTXT and  *\n*   COMMCSLN in DISASM00 will have been set to the address and       *\n*   length of the module in storage.                                 *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB\nDISASM06 CSECT\nDISASM06 AMODE 31\nDISASM06 RMODE 24\n         USING DISASM06,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     TEXT0000              SKIP EYECATCHER\n         DC    CL8'DISASM06'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nTEXT0000 DS    0H\n         LA    R1,SAVE06             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         MVC   COMMSUBH(SUBHEADL),SUBHEAD\n         LA    R1,SUBHEADL           SUBHEADING LENGTH\n         STH   R1,COMMSUBL           SET LENGTH\n         MVI   PRTCMD,$PRTHEAD       FORCED HEADING\n         BAL   R10,PRT0010           PRINT FORCED HEADING\n         L     R3,COMMCSLN           CSECT'S LENGTH\n         L     R4,COMMTXT            TEXT'S ADDRESS\n         XC    TEXTDISP,TEXTDISP     INITIALIZE DISPLACEMENT\nTEXT0020 DS    0H\n         LR    R5,R3                 COPY LENGTH\n         CH    R5,COMMH32            MORE THAN 1 LINE'S WORTH?\n         BNH   TEXT0030              NO\n         LH    R5,COMMH32            LIMIT TO 1 LINE\nTEXT0030 DS    0H\n         MVC   MSG01HX,COMMBLKS      INITIALIZE HEX DATA\n         MVC   MSG01CH,COMMBLKS      INITIALIZE CHARACTER DATA\n         UNPK  MSG01DSP(9),TEXTDISP(5)\n         MVZ   MSG01DSP,COMM0F0F     TURN OFF ZONES\n         TR    MSG01DSP,COMMHXCH     TRANSLATE TO PRINTABLE\n         MVI   MSG01DSP+8,C' '       RESTORE BLANK\n         UNPK  WORKHX1(9),00(5,R4)   UNPACK DATA\n         UNPK  WORKHX2(9),04(5,R4)   UNPACK DATA\n         UNPK  WORKHX3(9),08(5,R4)   UNPACK DATA\n         UNPK  WORKHX4(9),12(5,R4)   UNPACK DATA\n         UNPK  WORKHX5(9),16(5,R4)   UNPACK DATA\n         UNPK  WORKHX6(9),20(5,R4)   UNPACK DATA\n         UNPK  WORKHX7(9),24(5,R4)   UNPACK DATA\n         UNPK  WORKHX8(9),28(5,R4)   UNPACK DATA\n         MVZ   WORKHX1,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX2,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX3,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX4,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX5,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX6,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX7,COMM0F0F      TURN OFF ZONES\n         MVZ   WORKHX8,COMM0F0F      TURN OFF ZONES\n         TR    WORKHX1,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX2,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX3,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX4,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX5,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX6,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX7,COMMHXCH      TRANSLATE TO PRINTABLE\n         TR    WORKHX8,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   WORKHX1+8,C' '        RESTORE BLANK\n         MVI   WORKHX2+8,C' '        RESTORE BLANK\n         MVI   WORKHX3+8,C' '        RESTORE BLANK\n         MVI   WORKHX4+8,C' '        RESTORE BLANK\n         MVI   WORKHX5+8,C' '        RESTORE BLANK\n         MVI   WORKHX6+8,C' '        RESTORE BLANK\n         MVI   WORKHX7+8,C' '        RESTORE BLANK\n         LR    R1,R5                 COPY LENGTH\n         LA    R1,LENTBLE(R1)        PRINT LENGTH'S ADDRESS\n         SR    R2,R2                 CLEAR REGISTER\n         IC    R2,0(R1)              PRINT LENGTH\n         BCTR  R2,0                  MINUS 1 FOR EXECUTE\n         EX    R2,HEXMVC             MOVE HEX DATA\n         LR    R1,R5                 COPY LENGTH\n         BCTR  R1,0                  MINUS 1 FOR EXECUTES\n         EX    R1,CHARMVC            MOVE CHARACTER\n         EX    R1,CHARTR             TRANSLATE UNPRINTABLES TO PERIODS\n         MVC   PRTDATA(MSG01L),MSG01 SET MESSAGE\n         BAL   R10,PRT0000           PRINT TEXT\n         ICM   R1,15,TEXTDISP        CURRENT DISPLACEMENT\n         LA    R1,32(R1)             UPDATE DISPLACEMENT\n         STCM  R1,15,TEXTDISP        SAVE UPDATED DISPLACEMENT\n         LA    R4,32(R4)             NEXT TEXT\n         SR    R3,R5                 MINUS LENGTH PRINTED\n         BNZ   TEXT0020              CONTINUE\n         B     EXIT0000              EXIT\nPRT0000  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\nPRT0010  DS    0H\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R10                   RETURN\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nHEXMVC   MVC   MSG01HX(0),HEXWORK    MOVE HEX TO PRINT MESSAGE\nCHARMVC  MVC   MSG01CH(0),0(R4)      MOVE CHARACTER TO PRINT\nCHARTR   TR    MSG01CH(0),PRTTABLE   TRANSLATE ALL TO PRINTABLE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE06   DC    18F'0'                REGISTER SAVE AREA\nTEXTDISP DC    XL4'00'\nSUBHEAD  DC    C' TEXT '\nSUBHEADL EQU   *-SUBHEAD\nMSG01    DS    0C\nMSG01DSP DC    CL08' '\n         DC    CL03' '\nMSG01HX  DC    CL73' '\n         DC    CL03' '\nMSG01CH  DC    CL32' '\nMSG01L   EQU   *-MSG01\nLENTBLE  DC    AL1(00)                  NOT USED\n         DC    AL1(02)                  WHEN LENGTH = 01\n         DC    AL1(04)                  WHEN LENGTH = 02\n         DC    AL1(06)                  WHEN LENGTH = 03\n         DC    AL1(08)                  WHEN LENGTH = 04\n         DC    AL1(11)                  WHEN LENGTH = 05\n         DC    AL1(13)                  WHEN LENGTH = 06\n         DC    AL1(15)                  WHEN LENGTH = 07\n         DC    AL1(17)                  WHEN LENGTH = 08\n         DC    AL1(20)                  WHEN LENGTH = 09\n         DC    AL1(22)                  WHEN LENGTH = 10\n         DC    AL1(24)                  WHEN LENGTH = 11\n         DC    AL1(26)                  WHEN LENGTH = 12\n         DC    AL1(29)                  WHEN LENGTH = 13\n         DC    AL1(31)                  WHEN LENGTH = 14\n         DC    AL1(33)                  WHEN LENGTH = 15\n         DC    AL1(35)                  WHEN LENGTH = 16\n         DC    AL1(40)                  WHEN LENGTH = 17\n         DC    AL1(42)                  WHEN LENGTH = 18\n         DC    AL1(44)                  WHEN LENGTH = 19\n         DC    AL1(46)                  WHEN LENGTH = 20\n         DC    AL1(49)                  WHEN LENGTH = 21\n         DC    AL1(51)                  WHEN LENGTH = 22\n         DC    AL1(53)                  WHEN LENGTH = 23\n         DC    AL1(55)                  WHEN LENGTH = 24\n         DC    AL1(58)                  WHEN LENGTH = 25\n         DC    AL1(60)                  WHEN LENGTH = 26\n         DC    AL1(62)                  WHEN LENGTH = 27\n         DC    AL1(64)                  WHEN LENGTH = 28\n         DC    AL1(67)                  WHEN LENGTH = 29\n         DC    AL1(69)                  WHEN LENGTH = 30\n         DC    AL1(71)                  WHEN LENGTH = 31\n         DC    AL1(73)                  WHEN LENGTH = 32\nHEXWORK  DS    0C\nWORKHX1  DC    CL8' '\n         DC    CL1' '\nWORKHX2  DC    CL8' '\n         DC    CL1' '\nWORKHX3  DC    CL8' '\n         DC    CL1' '\nWORKHX4  DC    CL8' '\n         DC    CL3' '\nWORKHX5  DC    CL8' '\n         DC    CL1' '\nWORKHX6  DC    CL8' '\n         DC    CL1' '\nWORKHX7  DC    CL8' '\n         DC    CL1' '\nWORKHX8  DC    CL8' '\n         DC    CL1' '\nPRTTABLE DC    256C'.'\n         ORG   PRTTABLE+X'40'\n         DC    C' '\n         ORG   PRTTABLE+X'4A'\n         DC    C'\u00a2.<(+|'\n         DC    X'50'\n         ORG   PRTTABLE+X'5A'\n         DC    C'!$*);\u00ac-/'\n         ORG   PRTTABLE+X'6B'\n         DC    C',%_>?'\n         ORG   PRTTABLE+X'7A'\n         DC    C':#@'\n         DC    X'7D'\n         DC    C'=\"'\n         ORG   PRTTABLE+X'C0'\n         DC    C'{ABCDEFGHI'\n         ORG   PRTTABLE+X'D0'\n         DC    C'}JKLMNOPQR'\n         ORG   PRTTABLE+X'E2'\n         DC    C'STUVWXYZ'\n         ORG   PRTTABLE+X'F0'\n         DC    C'0123456789'\n         ORG   PRTTABLE+256\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n         SPACE 2\n         LTORG\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM06\n./ ADD MEMBER=DISASM07\n         TITLE 'DISASM07 - DSECT ASSEMBLER AND INTERPRETER'\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM07                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Dynamically invoke the assembler (IEV90) to assemble DSECTs.     *\n*   Any method of defining DSECTs that are valid to the assembler    *\n*   may be used, they may be defined inline, by macros, or copy      *\n*   statements.  The disassembler links to the assembler to assemble *\n*   the source, then scans the assembler output to learn the DSECT   *\n*   names, label names, and displacements to the labels.  In order   *\n*   for DISASM to find the names and displacements, the PRINT option *\n*   of the assembler must be on.                                     *\n*                                                                    *\n*   Labels and DSECT names are limited to 8 characters in length.    *\n*                                                                    *\n*   Input to the assembler is delimited by ASM START and ASM END     *\n*   statements.  Any statements between the ASM START and ASM END    *\n*   are copied to SYSIN.  Assembler input statements are listed on   *\n*   the DISPRINT output, but are otherwise ignored.  Any macros not  *\n*   defined inline and any copy elements must be available to the    *\n*   assembler in a library in the SYSLIB concatenation.              *\n*                                                                    *\n*   If the return code from the assembler is greater than 4, the     *\n*   disassembly is aborted.  The assembler output is copied to the   *\n*   DISDEBUG data set if allocated.                                  *\n*                                                                    *\n*   The DSECTs are chained from field COMMDSCT of module DISASM00.   *\n*   The labels within the DSECT are chained from field DSCTLBA.      *\n*   DSCTDSCT maps the DSECT control blocks, LABLDSCT maps the label  *\n*   control blocks.                                                  *\n*                                                                    *\n*--------------------------------------------------------------------*\n         COPY  DISASMGB\nDISASM07 CSECT\nDISASM07 AMODE 31\nDISASM07 RMODE 24\n         USING DISASM07,R12\n         USING DISASM00,R11\n         USING DSCTDSCT,R3           DEFINE BASE\n         USING LABLDSCT,R4           DEFINE BASE\n         USING EQUDATA,R5            DEFINE BASE\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     DSCT0000              SKIP EYECATCHER\n         DC    CL8'DISASM07'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nDSCT0000 DS    0H\n         XC    COMMSUBL,COMMSUBL     NO SUBHEADING\n         LA    R1,SAVE07             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         TM    COMMFLAG,$ASMIN       ANY ASSEMBLER INPUT?\n         BNO   DSCT0300              NO\n         LOAD  EP=IEV90              LOAD THE ASSEMBLER\n         ST    R0,ASMEP              SAVE ASSEMBLER'S ENTRY POINT\n         LR    R15,R0                COPY TO R15\n         LA    R1,AASMPARM           ASSEMBLER PARM LIST ADDRESS\n         ITRACE ID=CALLASM,          CALLING THE ASSEMBLER             +\n               RDATA1=R15,           .. ASSEMBLER'S ENTRY POINT        +\n               RDATA2=R1             .. ASSEMBLER'S PARM LIST ADDRESS\n         BASR  R14,R15               LINK TO ASSEMBLER\n         BAL   R14,AM31              FORCE 31-BIT MODE\n         ITRACE ID=ASMRC,            TRACE ASSEMBLER'S RETURN CODE     +\n               RDATA1=R15            .. RETURN CODE\n         STH   R15,ASMRC             SAVE ASSEMBLER RETURN CODE\n         CVD   R15,COMMDWRD          CONVERT TO DECIMAL\n         MVI   PRTCC,C'0'            DOUBLE SPACE\n         MVC   MSG01RC,=X'40202120'  SET EDIT WORD\n         ED    MSG01RC,COMMDWRD+6    EDIT RETURN CODE\n         MVC   PRTDATA(MSG01L),MSG01 SET MESSAGE\n         BAL   R10,PRT0000           PRINT RETURN CODE MESSAGE\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (SYSPRINT,INPUT)      OPEN SYSPRINT AS INPUT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   COMMDBSH,ASMHEAD      SET HEADING\n         MVI   DBUGCMD,$DBUGHD       SET COMMAND\n         LA    R1,DBUGBLOK           DEBUG PARAMETER BLOCK ADDRESS\n         L     R15,ADB               DEBUG ENTRY POINT\n         BALR  R14,R15               PRINT DEBUG HEADING\n         MVI   DBUGCMD,$DBUGPRT      SET COMMAND\n         LA    R1,ASMSTMT+1          DATA ADDRESS FOR DEBUG\n         ST    R1,DBUGDATA           SET DATA ADDRESS\n         SR    R3,R3                 NO DSECT IS ACTIVE\n         SR    R4,R4                 NO LABEL IS ACTIVE\nDSCT0010 DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         GET   SYSPRINT,ASMSTMT      READ A SYSPRINT RECORD\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         LA    R1,DBUGBLOK           DBUG PARAMETER BLOCK ADDRESS\n         L     R15,ADB               DEBUG ENTRY POINT\n         BALR  R14,R15               LINK TO DEBUG\n         CLC   ASMRC,COMMH4          ASSEMBLER ERROR?\n         BH    DSCT0010              YES\n         ITRACE ID=TEMP1,                                              +\n               DATA1=ASMLABL,                                          +\n               DATA2=ASMDISP\n         CLI   ASMLABL,C'*'          COMMENT STATEMENT?\n         BE    DSCT0010              YES\n         CLC   ASMSTMT+43,SRCSTMT    ASSEMBLER HEADING LINE?\n         BE    DSCT0010              YES, IGNORE IT\n         CLC   XREF,ASMSTMT+45       START OF CROSS REFERENCE?\n         BNE   DSCT0020              NO\n         OI    XREFFLAG,$XREF        SET CROSS REFERENCE FLAG\n         ITRACE ID=XREF              CROSS REFERENCE STARTED\nDSCT0020 DS    0H\n         TM    XREFFLAG,$XREF        CROSS REFERENCE FOUND?\n         BO    DSCT0010              YES\n         CLI   ASMLABL,C' '          LABEL PRESENT?\n         BE    DSCT0010              NO\n         LA    R6,ASMLABL            FIRST BYTE OF LABEL\n         LA    R2,WORKLABL           FIRST BYTE OF WORK LABEL\n         MVC   WORKLABL,COMMBLKS     CLEAR LABEL NAME\n         LA    R1,8                  MAX LOOPS\nDSCT0030 DS    0H\n         CLI   0(R6),C' '            BLANK?\n         BE    DSCT0040              YES\n         MVC   0(1,R2),0(R6)         COPY TO WORK LABEL\n         LA    R2,1(R2)              NEXT\n         LA    R6,1(R6)              NEXT\n         BCT   R1,DSCT0030           LOOP\n         CLI   0(R6),C' '            BLANK?\n         BE    DSCT0040              NO... TOO LONG FOR A LABEL\n         ITRACE ID=LONGLABL\n         B     DSCT0010              READ NEXT SYSPRINT RECORD\nDSCT0040 DS    0H\n         LA    R1,8                  MAX LOOPS\nDSCT0050 DS    0H\n         CLI   0(R6),C' '            BLANK?\n         BNE   DSCT0060              NO\n         LA    R6,1(R6)              NEXT\n         BCT   R1,DSCT0050           LOOP\n         B     DSCT0110              ASSUME IT IS A LABEL\nDSCT0060 DS    0H\n         CLC   DSECTOP(6),0(R6)      DSECT?\n         BE    DSCT0070              YES\n         CLC   CSECTOP,0(R6)         CSECT?  (TREATED LIKE DSECTS)\n         BE    DSCT0070              YES\n         CLC   EQUOP,0(R6)           EQUATE STATEMENT?\n         BNE   DSCT0110              NO\n         LTR   R4,R4                 LABEL BASE SET?\n         BZ    DSCT0010              NO\n         CLC   =C'000',ASMADDR2      FIRST 3 DIGITS ZEROS?\n         BNE   DSCT0010              NO\n         GETMAIN RU,                 LENGTH                            +\n               LV=EQUL,                                                +\n               LOC=ANY\n         LR    R5,R1                 COPY EQU BLOCK ADDRESS\n         ITRACE ID=NEWEQU,           NEW EQUATE                        +\n               RDATA1=R5\n         XC    EQUDATA(EQUL),EQUDATA INITIALIZE THE EQUATE BLOCK\n         MVC   EQUEYE,EQUID          IDENTIFY THIS BLOCK\n         MVC   EQUNEXT,LABLEQU       SET CHAIN ADDRESS\n         ST    R5,LABLEQU            SET NEW BLOCK'S ADDRESS IN LABEL\n         MVC   EQULABEL,WORKLABL     SET LABEL\n         NC    ASMADDR2+3(2),X1F1F   PREPARE FOR PACKING\n         TR    ASMADDR2+3(2),CHXH    TRANSLATE FOR PACKING\n         PACK  DISPOUT(2),ASMADDR2+3(3)\n         MVC   EQUVALUE,DISPOUT      COPY EQUATE VALUE\n         B     DSCT0010\nDSCT0070 DS    0H\n         ITRACE ID=SCANDSCT\n         LA    R2,COMMDSCT           DSECT ANCHOR\n         ICM   R3,15,COMMDSCT        FIRST DSECT BLOCK\n         BZ    DSCT0090              NO DSECTS YET\nDSCT0080 DS    0H\n         CLC   DSCTNAME,WORKLABL     ALREADY ON DSECT CHAIN?\n         BE    DSCT0100              YES.. EXIT WITH BASE SET\n         LR    R2,R3                 COPY ADDRESS\n         ICM   R3,15,DSCTNEXT        NEXT DSECT BLOCK\n         BNZ   DSCT0080              LOOP\nDSCT0090 DS    0H\n         GETMAIN RU,                 ACQUIRE NEW DSECT BLOCK           +\n               LV=DSCTL,                                               +\n               LOC=ANY\n         ST    R1,DSCTNEXT-DSCTDSCT(R2)   CHAIN NEW TO PREVIOUS BLOCK\n         ITRACE ID=NEWDSECT,         NEW DSECT BLOCK                   +\n               RDATA1=R1,            .. BLOCK'S ADDRESS                +\n               DATA2=WORKLABL        .. DSECT'S NAME\n         LR    R3,R1                 SET BASE\n         MVC   DSCTEYE,DSECTOP       SET BLOCK ID\n         XC    DSCTNEXT,DSCTNEXT     ZERO 'NEXT' BLOCK ADDRESS\n         MVC   DSCTNAME,WORKLABL     SET DSECT'S NAME\n         XC    DSCTLBA,DSCTLBA       CLEAR LABEL POINTER\n         B     DSCT0010\nDSCT0100 DS    0H\n         ITRACE ID=DUPDSECT\n         B     DSCT0010\nDSCT0110 DS    0H\n         LTR   R3,R3                 DSECT DETERMINED YET?\n         BZ    DSCT0010              NO\n         CLI   ASMDISP,C'A'          VALID DISPLACEMENT?\n         BL    DSCT0010              NO\n         CLI   ASMDISP,C'F'          VALID DISPLACEMENT?\n         BNH   DSCT0120              YES\n         CLI   ASMDISP,C'0'          VALID DISPLACEMENT?\n         BL    DSCT0010              NO\n         CLI   ASMDISP,C'9'          VALID DISPLACEMENT?\n         BH    DSCT0010              NO\nDSCT0120 DS    0H\n         MVC   DISPIN,ASMDISP        COPY DISPLACEMENT\n         NC    DISPIN,COMM1F1F       PREPARE FOR TRANSLATE\n         TR    DISPIN,COMMCHHX       TRANSLATE FOR PACKING\n         PACK  DISPOUT(4),DISPIN(7)  PACK DISPLACEMENT\n         LA    R2,DSCTLBA            LABEL CHAIN ANCHOR\n         ICM   R4,15,DSCTLBA         FIRST LABEL\n         BZ    DSCT0140              NO LABELS\nDSCT0130 DS    0H\n         CLC   DISPOUT(3),LABLDISP+1 INSERT HERE?\n         BH    DSCT0140              YES\n         LR    R2,R4                 COPY ADDRESS\n         ICM   R4,15,LABLNEXT        NEXT LABEL\n         BNZ   DSCT0130              LOOP\nDSCT0140 DS    0H\n         GETMAIN RU,                 ACQUIRE NEW LABEL BLOCK           +\n               LV=LABLL,                                               +\n               LOC=ANY\n         ITRACE ID=NEWLABL,          NEW LABEL BLOCK                   +\n               RDATA1=R1,            .. BLOCK'S ADDRESS                +\n               DATA2=WORKLABL        .. LABEL'S NAME\n         ST    R1,LABLNEXT-LABLDSCT(R2)  CHAIN PREVIOUS BLOCK TO NEW\n         ST    R4,LABLNEXT-LABLDSCT(R1)  CHAIN NEXT BLOCK TO NEW\n         LR    R4,R1                 SET BASE\n         MVC   LABLEYE,LABEL         SET BLOCK IDENTIFIER\n         MVC   LABLNAME,WORKLABL     SET LABEL NAME\n         MVI   LABLDISP,X'00'        FORCE FIRST BYTE TO ZERO\n         MVC   LABLDISP+1(3),DISPOUT SET DISPLACEMENT TO LABEL\n         MVI   LABLTYPE,$LABLD       DATA TYPE LABEL\n         B     DSCT0010\nDSCT0200 DS    0H\n         CLOSE SYSPRINT\n         BAL   R14,AM31              FORCE AMODE 31\n         CLC   ASMRC,COMMH4          ERROR DURING ASSEMBLY?\n         BNH   EXIT0000              NO\n         ITRACE ID=ASMERROR\n         OI    COMMFLAG,$ERROR+$ABORT\n         MVC   PRTDATA(EMSG01L),EMSG01\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\nDSCT0300 DS    0H\n         ITRACE ID=NOASMIN\n         MVI   PRTCC,C'0'            DOUBLE SPACE\n         MVC   PRTDATA(MSG99L),MSG99 SET MESSAGE\n         BAL   R10,PRT0000           PRINT MESSAGE\n         B     EXIT0000              AND EXIT\nPRT0000  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\nPRT0010  DS    0H\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R10                   RETURN\nEXIT0000 DS    0H\n         OC    ASMEP,ASMEP           ASSEMBLER LOADED?\n         BZ    EXIT0010              NO\n         ITRACE ID=DELASM            DELETE ASSEMBLER\n         DELETE EP=IEV90\nEXIT0010 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nAM24     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         BSM   R0,R14             RETURN IN 24-BIT MODE\nAM31     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         O     R14,X80            SET 31-BIT MODE\n         BSM   R0,R14             RETURN IN 31-BIT MODE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE07   DC    18F'0'                REGISTER SAVE AREA\nX80      DC    A(X'80000000')\nASMEP    DC    A(0)                  ASSEMBLER'S ENTRY POINT\nAASMPARM DC    A(ASMPARM+X'80000000') ASSEMBLER PARM'S\nASMRC    DC    H'0'                  ASSEMBLER'S RETURN CODE\nASMPARM  DC    Y(ASMPARML-2)\n         DC    C'DECK,NOOBJECT'\nASMPARML EQU   *-ASMPARM\nXREF     DC    C' CROSS REFERENCE '\nXREFFLAG DC    X'00'                 CROSS REFERENCE FLAG\n$XREF    EQU   X'80'                 .. CROSS REFERENCE HAS BEEN FOUND\nX1F1F    DC    8X'1F'\n         SPACE 1 0 1 2 3 4 5 6 7 8 9 A B C D E F\nCHXH     DC    X'000A0B0C0D0E0F000000000000000000'  00-0F\n         DC    X'00010203040506070809000000000000'  10-1F\n         SPACE 1\nDSECTOP  DC    CL8'DSECT'\nCSECTOP  DC    CL8'CSECT'\nEQUOP    DC    C'EQU '\nSRCSTMT  DC    C'SOURCE STATEMENT'\nWORKLABL DC    CL8' '\nDISPIN   DC    CL7' '\nDISPOUT  DC    XL4'000000'\nLABEL    DC    CL8'LABEL'\nEQUID    DC    CL8'EQU'\nASMSTMT  DC    CL121' '\nASMSTMTL EQU   *-ASMSTMT\n         ORG   ASMSTMT+1\nASMDISP  DS    CL6\n         ORG   ASMSTMT+29\nASMADDR2 DS    CL5\n         ORG   ASMSTMT+41\nASMLABL  DS    CL8\n         ORG   ASMSTMT+121\nASMHEAD  DC    CL35'ASSEMBLER OUTPUT'\nMSG01    DC    C'DISASM0701I Assembler return code was '\nMSG01RC  DC    CL04' '\nMSG01L   EQU   *-MSG01\nMSG99    DC    C'DISASM0702I No assembler input, no DSECTS'\nMSG99L   EQU   *-MSG99\nEMSG01   DC    C'DISASM0703E Error assembling DSECTS, check assembler o+\n               utput in DISDEBUG'\nEMSG01L  EQU   *-EMSG01\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              DEBUG MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nDBUGBLOK DBUGBLOK TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              ASSEMBLER OUTPUT DCB                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\nSYSPRINT DCB   DDNAME=SYSPRINT,                                        +\n               DSORG=PS,                                               +\n               EODAD=DSCT0200,                                         +\n               MACRF=GM\n         SPACE 2\n         LTORG\n         SPACE 2\n         COPY     DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM07\n./ ADD MEMBER=DISASM08\n         TITLE 'DISASM08 - CSECT LABEL ASSIGNER AND REFERENCE TABLE GEN+\n               ERATOR'\n* ------------------------------------------------------------------- *\n*                                                                     *\n*  MODULE NAME: DISASM08                                              *\n*                                                                     *\n*  FUNCTION:                                                          *\n*   1) Chain the USING blocks to the DSECT blocks they refer to.      *\n*   2) Scan the object code and                                       *\n*         A. Determine the displacements where valid instructions     *\n*            occur.                                                   *\n*         B. Add DATA blocks to represent any areas that do not       *\n*            contain valid instructions and are not already defined   *\n*            by data blocks.                                          *\n*   3) Verify that all BASE and USINGs reference displacements where  *\n*      a valid instruction occurs.  This is because a USING or DROP   *\n*      statement cannot be generated in the middle of an instruction. *\n*   4) Generate label blocks for entry points that occur within the   *\n*      csect.  This info comes from the ESD blocks built by module    *\n*      DISASM04.                                                      *\n*   5) Generate label blocks for the points referenced by ADCONs.     *\n*      This info comes from the RLD blocks built by module DISASM05.  *\n*   6) Scan the object code and generate the REF blocks for data      *\n*      references.                                                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\n* Modified : Paul Gillis - P. C. Link Pty. Ltd. 28 September 1999     *\n*            Cater for all B2/01 opcodes found in SA22-7209-01        *\n* ------------------------------------------------------------------- *\n         COPY  DISASMGB\nDISASM08 CSECT\nDISASM08 AMODE 31\nDISASM08 RMODE 24\n         USING DISASM08,R12\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     LABL0000              SKIP EYECATCHER\n         DC    CL8'DISASM08'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nLABL0000 DS    0H\n         LA    R1,SAVE08             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         ITRACE ID=ENTRY\n* ------------------------------------------------------------------- *\n*        Chain USING blocks to their related DSECT blocks             *\n* ------------------------------------------------------------------- *\n         ICM   R3,15,COMMUSNG        FIRST USING BLOCK'S ADDRESS\n         USING USNGDSCT,R3           DEFINE BASE\n         BZ    LABL0090              END OF CHAIN\nLABL0010 DS    0H\n         ITRACE ID=FINDDSCT,         STARTING SEARCH FOR A DSECT ENTRY +\n               DATA1=USNGDSNM        .. DSECT'S NAME\n         ICM   R2,15,COMMDSCT        FIRST DSECT ENTRY\n         USING DSCTDSCT,R2           DEFINE BASE\nLABL0020 DS    0H\n         BZ    ERR0010               DSECT NOT FOUND\n         ITRACE ID=TESTDSCT,         CHECKING A DSECT ENTRY            +\n               DATA1=DSCTNAME        .. DSECT'S NAME\n         CLC   USNGDSNM,DSCTNAME     DSECT FOUND?\n         BE    LABL0030              YES\n         ICM   R2,15,DSCTNEXT        NEXT DSECT BLOCK\n         B     LABL0020              LOOP\nLABL0030 DS    0H\n         ITRACE ID=DSCTFND,          DSECT ENTRY HAS BEEN FOUND        +\n               RDATA1=R2             .. DSECT BLOCK'S ADDRESS\n         ST    R2,USNGDSA            CHAIN DSECT BLOCK TO USING BLOCK\n         CLC   USNGLBNM,COMMBLKS     LABEL BLANK?\n         BE    LABL0070              YES\n         ICM   R9,15,DSCTLBA         FIRST LABEL IN THE DSECT\n         USING LABLDSCT,R9           DEFINE BASE\n         BZ    LABL0050              NO LABELS\nLABL0040 DS    0H\n         CLC   LABLNAME,USNGLBNM     LABEL LOCATED?\n         BE    LABL0060              YES\n         ICM   R9,15,LABLNEXT        NEXT LABEL\n         BNZ   LABL0040              LOOP\nLABL0050 DS    0H\n         MVC   EMSG05N,USNGLBNM      COPY LABEL NAME\n         MVC   EMSG05D,USNGDSNM      COPY DSECT NAME\n         MVC   PRTDATA(EMSG05L),EMSG05\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     LABL0080\nLABL0060 DS    0H\n         ST    R9,USNGLBA            SET ASSOCIATED LABEL BLOCK ADDRESS\n         MVC   USNGDISP,LABLDISP     SET DISP TO LABEL\n         B     LABL0080              PROCESS NEXT USING\nLABL0070 DS    0H\n         ICM   R9,15,DSCTLBA         ANY LABELS?\n         BZ    LABL0080              NO\n         ST    R9,USNGLBA            SET ASSOCIATED LABEL BLOCK ADDRESS\n         XC    USNGDISP,USNGDISP     SET DISP TO ZERO\nLABL0080 DS    0H\n         ICM   R3,15,USNGNEXT        NEXT USING BLOCK\n         BNZ   LABL0010              LOOP\n         TM    COMMFLAG,$ABORT       SERIOUS ERROR?\n         BO    EXIT0000              YES, STOP NOW\n* ------------------------------------------------------------------- *\n*        Scan the object code and determine the displacements         *\n*        to all valid instructions.  This is necessary because        *\n*        some instructions may reference other instructions to        *\n*        modify them (like zapping in a length).  If an instruction   *\n*        references another at other than the opcode address, the     *\n*        generated label will be 'PRFXNNNN+D'.                        *\n*                                                                     *\n*        'DATA' blocks will be generated to indicate areas that do    *\n*        not have valid opcodes and are not already defined as being  *\n*        data.                                                        *\n*                                                                     *\n*        The hex value for character text is also valid opcodes.      *\n*        To prevent the disassembler from interpreting a string of    *\n*        character data as instructions, 6 consecutive characters     *\n*        will be considered data.                                     *\n*                                                                     *\n*        Each displacement will be 4-bytes.  Worst case would be a    *\n*        module that consists of only 2-byte opcodes.  Each entry     *\n*        will be a 4-byte displacement, so the table's length would   *\n*        be twice the CSECT's size at most.  Four additional bytes    *\n*        are added for end of table flag (X'FFFFFFFF').               *\n* ------------------------------------------------------------------- *\nLABL0090 DS    0H\n         L     R1,COMMCSLN           CSECT'S TOTAL LENGTH\n         SLL   R1,1                  DOUBLE IT\n         LA    R1,4(R1)              PLUS ROOM FOR END OF TABLE FLAG\n         GETMAIN RU,                 ACQUIRE STORAGE FOR INSTR DISP'S  +\n               LV=(1),               .. SIZE                           +\n               LOC=ANY\n         LR    R9,R1                 INITIALIZE DISP TABLE ADDRESS\n         ST    R1,COMMDISP           SAVE DISPLACEMENT TABLE'S ADDRESS\n         L     R5,COMMTXT            TEXT'S STORAGE ADDRESS\n         MVC   0(4,R9),XFFFF         INITIALIZE END OF TABLE FLAG\n         SR    R6,R6                 INITIALIZE DISPLACEMENT\nLABL0100 DS    0H\n         C     R6,COMMCSLN           BEYOND END OF CSECT?\n         BNL   LABL0290              TEST FOR FINAL DATA BLOCK\n         ICM   R7,15,COMMDATA        FIRST DATA BLOCK\n         BZ    LABL0130              NO DATA BLOCKS\n         USING DATADSCT,R7           DEFINE BASE\n         ITRACE ID=DATACHK1,         TESTING FOR DATA AREA             +\n               RDATA1=R6             .. CURRENT DISPLACEMENT\nLABL0110 DS    0H\n         CLM   R6,15,DATABEGN        DATA AREA BEGINNING DISPLACEMENT?\n         BL    LABL0120              THIS AREA IS BELOW CURRENT DISP\n         BE    LABL0280              DATA AREA FOUND\n         CLM   R6,15,DATAEND         TOO HIGH FOR THIS DATA AREA?\n         BH    LABL0120              YES\n         OC    DATASIZE,DATASIZE     DATA OVER-LAPPING DATA?\n         BNZ   ERR0060               YES.. DATA OVERLAPS DATA\n         B     ERR0020               INSTRUCTION OVERLAPS DATA\nLABL0120 DS    0H\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   LABL0110              LOOP\nLABL0130 DS    0H\n         STC   R6,COMMDWRD           SAVE LAST BYTE\n         TM    COMMDWRD,1            ON AN ODD BOUNDARY?\n         BO    LABL0250              YES\n         L     R0,COMMCSLN           CSECT TOTAL LENGTH\n         SR    R0,R6                 MINUS CURRENT DISPLACEMENT\n         CH    R0,COMMH8             8 OR MORE BYTES LEFT?\n         BL    LABL0140              NO\n         TRT   0(8,R5),ALPHATRT      8 ALPHA CHARACTERS IN A ROW?\n         BNZ   LABL0135              NO.. DON'T GIVE UP COMPLETELY\n         LA    R1,8                  SET FOR 8 BYTES\n         B     LABL0260              SKIP THESE 8\nLABL0135 DS    0H\n         TRT   0(6,R5),ALPHATRT      6 ALPHA CHARACTERS IN A ROW?\n         BNZ   LABL0140              NO\n         LA    R1,6                  SKIP 6 BYTES\n         B     LABL0260              SKIP ALL 6\nLABL0140 DS    0H\n         SR    R8,R8                 CLEAR REGISTER\n         ICM   R8,1,0(R5)            INSERT POSSIBLE OPCODE\n         BZ    LABL0250              NOT A VALID OPCODE\n         SLL   R8,2                  MULTIPLY BY 4\n         A     R8,AOP                PLUS BASE ADDRESS\n         ICM   R8,15,0(R8)           OPCODE ENTRY ADDRESS\n         USING OPDSECT,R8            DEFINE BASE\n         BZ    LABL0250              NOT A VALID OPCODE\n         TM    COMMFLAG,$NOFLOAT     FLOATING POINT ALLOWED?\n         BNO   LABL0150              YES\n         TM    OPFLAGS,$OPFLOAT      FLOATING POINT INSTRUCTION?\n         BO    LABL0250              YES.. NOT VALID\nLABL0150 DS    0H\n         CLI   OPREGS,0              ANY REGISTER RESTRICTIONS?\n         BE    LABL015A              NO\n         L     R15,ARR               REGISTER OPERAND CHECKER\n         BALR  R14,R15               CALL REGISTER OPERAND CHECKER\n         LTR   R15,R15               OPERAND(S) VALID?\n         BNZ   LABL0250              NO\nLABL015A DS    0H\n         LH    R1,OPLENGTH           OPCODE LENGTH\n         AR    R1,R6                 DISPLACEMENT OF END OF INSTR + 1\n         BCTR  R1,0                  DISPLACEMENT OF END OF INSTR\n         ICM   R7,15,COMMDATA        FIRST DATA BLOCK\n         BZ    LABL0180              NO DATA BLOCKS\nLABL0160 DS    0H\n         CLM   R1,15,DATABEGN        TOO LOW?\n         BL    LABL0170              YES\n         CLM   R6,15,DATAEND         TOO HIGH?\n         BNH   LABL0250              NO, OVERLAPS INTO DATA\nLABL0170 DS    0H\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   LABL0160              LOOP\nLABL0180 DS    0H\n         ICM   R4,15,COMMESD         FIRST ESD BLOCK\n         USING ESDDATA,R4            DEFINE BASE\n         BZ    LABL0210              NO ESD BLOCKS\nLABL0190 DS    0H\n         CLM   R6,7,ESDADDR          ESD LABEL AT THIS POINT?\n         BE    LABL0240              YES.. FORCE DATA BLOCK NOW\n         BH    LABL0200              NO.. BEYOND THIS ESD ENTRY\n         CLM   R1,7,ESDADDR          SPAN THE ESD ITEM?\n         BH    LABL0250              YES.. INSTRUCTION WOULD SPAN LABEL\nLABL0200 DS    0H\n         ICM   R4,15,ESDNEXT         NEXT ESD ITEM\n         BNZ   LABL0190              LOOP\nLABL0210 DS    0H\n         LH    R1,OPLENGTH           OPCODE LENGTH\n         AR    R1,R6                 NEXT OPCODE'S DISPLACEMENT\n         L     R0,COMMCSLN           CSECT LENGTH\n         SR    R0,R1                 MINUS NEXT OPCODE'S DISPLACEMENT\n         CH    R0,COMMH8             8 OR MORE BYTES LEFT?\n         BL    LABL0240              ACCEPT THE OPCODE\n         LH    R1,OPLENGTH           OPCODE LENGTH\n         AR    R1,R5                 PLUS CURRENT INSTRUCTION ADDRESS\n         TRT   0(6,R1),ALPHATRT      6 ALPHA CHARACTERS IN A ROW?\n         BZ    LABL0220              YES.. CHECK FOR EXCEPTIONS\n         LH    R1,OPLENGTH           OPCODE LENGTH\n         AR    R1,R5                 PLUS CURRENT INSTRUCTION ADDRESS\n         SR    R14,R14               CLEAR REGISTER\n         ICM   R14,1,0(R1)           INSERT POSSIBLE OPCODE\n         BZ    LABL0220              NOT A VALID OPCODE\n         SLL   R14,2                 MULTIPLY BY 4\n         A     R14,AOP               PLUS BASE ADDRESS\n         ICM   R14,15,0(R14)         ANOTHER VALID OPCODE?\n         BZ    LABL0220              NO\n         TM    COMMFLAG,$NOFLOAT     FLOATING POINT ALLOWED?\n         BNO   LABL0240              YES\n         TM    OPFLAGS-OPDSECT(R14),$OPFLOAT  FLOATING POINT?\n         BNO   LABL0240              NO\nLABL0220 DS    0H\n         CLI   0(R5),X'05'           BRANCH AND LINK REGISTER?\n         BE    LABL0240              YES, ALLOW IT\n         CLI   0(R5),X'0A'           SVC?\n         BE    LABL0240              YES, ALLOW IT\n         CLI   0(R5),X'07'           BRANCH REGISTER?\n         BE    LABL0230              YES\n         CLI   0(R5),X'45'           SVC?\n         BE    LABL0240              YES, ALLOW IT\n         CLI   0(R5),X'47'           BRANCH?\n         BNE   LABL0250              NO.. NOT VALID OPCODE\nLABL0230 DS    0H\n         TM    1(R5),X'F0'           UNCONDITIONAL BRANCH?\n         BNO   LABL0250              NO.. NOT VALID OPCODE\nLABL0240 DS    0H\n         BAL   R10,LABL2000          ADD A NEW DATA BLOCK IF NECESSARY\n         STCM  R6,15,0(R9)           SAVE VALID DISPLACEMENT\n         LA    R9,4(R9)              NEXT DISPLACEMENT SLOT\n         MVC   0(4,R9),XFFFF         SET END OF TABLE\n         LH    R1,OPLENGTH           INSTRUCTION'S LENGTH\n         B     LABL0270\nLABL0250 DS    0H\n         LA    R1,1                  NEXT BYTE\nLABL0260 DS    0H\n         L     R0,DATASIZE           DATA AREA SIZE SO FAR\n         AR    R0,R1                 PLUS SKIP AMOUNT\n         ST    R0,DATASIZE           SAVE TOTAL\n         TM    PGMFLAG,$BGNDISP      DISPLACEMENT ALREADY SET?\n         BO    LABL0270              YES\n         OI    PGMFLAG,$BGNDISP      STARTING DISPLACEMENT IS KNOWN\n         ST    R6,DATADISP           SAVE STARTING DISPLACEMENT\nLABL0270 DS    0H\n         AR    R5,R1                 NEXT OBJECT CODE BYTE\n         AR    R6,R1                 NEXT NEXT DISPLACEMENT\n         B     LABL0100              LOOP\nLABL0280 DS    0H\n         BAL   R10,LABL2000          ADD DATA AREA IF NECESSARY\n         ICM   R6,15,DATAEND         ENDING DISPLACEMENT\n         LA    R6,1(R6)              NEXT BYTE\n         LR    R5,R6                 COPY DISPLACEMENT\n         A     R5,COMMTXT            PLUS BASE\n         ITRACE ID=DATASKIP,         DISPLACEMENT SKIPPED DUE TO DATA  +\n               RDATA1=R5,            .. NEW TEXT'S ADDRESS             +\n               RDATA2=R6             .. NEW DISPLACEMENT\n         B     LABL0100              LOOP\n* ------------------------------------------------------------------- *\n*        Add last data block if necessary                             *\n* ------------------------------------------------------------------- *\nLABL0290 DS    0H\n         BAL   R10,LABL2000          ADD DATA BLOCK\n* ------------------------------------------------------------------- *\n*        Verify that all BASE and USINGs reference data areas or      *\n*        instruction boundaries.  This is because DROP and USING      *\n*        statements cannot be generated in the middle of an           *\n*        instruction.  Also I will not generate DROPs or USINGs in    *\n*        data areas (I guess this may cause problems with \"S\" type    *\n*        DC instructions).                                            *\n*                                                                     *\n* ------------------------------------------------------------------- *\n         ICM   R3,15,COMMBASE        FIRST BASE ENTRY\n         USING BASEDSCT,R3\n         BZ    LABL0320              NO BASES DEFINED\nLABL0300 DS    0H\n         MVC   WORKDISP,BASEBEGN     SET BEGINNING DISPLACEMENT\n         MVC   EMSG03A,BEGNDISP      SET 'BEGINNING' IN MESSAGE\n         BAL   R2,LABL0360           CHECK BEGINNING DISPLACEMENT\n         MVC   BASEBEGN,WORKDISP     SET VERIFIED DISPLACEMENT\n         CLC   BASEEND,COMMCSLN      BEYOND END OF CSECT?\n         BNH   LABL0310              NO\n         MVC   BASEEND,COMMCSLN      LIMIT TO CSECT LENGTH\nLABL0310 DS    0H\n         MVC   WORKDISP,BASEEND      SET ENDING DISPLACEMENT\n         MVC   EMSG03A,ENDDISP       SET 'ENDING' IN MESSAGE\n         BAL   R2,LABL0360           CHECK ENDING DISPLACEMENT\n         MVC   BASEEND,WORKDISP      SET VERIFIED DISPLACMENT\n         ICM   R3,15,BASENEXT        NEXT BASE BLOCK\n         BNZ   LABL0300              LOOP\nLABL0320 DS    0H\n         ICM   R3,15,COMMUSNG        FIRST USING ENTRY\n         USING USNGDSCT,R3           DEFINE BASE\n         BZ    LABL0350              NO USINGS\nLABL0330 DS    0H\n         TM    USNGFLAG,$USNGND      DISPLACEMENTS?\n         BO    LABL0340              NO\n         MVC   WORKDISP,USNGBEGN     SET BEGINNING DISPLACEMENT\n         MVC   EMSG03A,BEGNDISP      SET 'BEGINNING' IN MESSAGE\n         BAL   R2,LABL0360           CHECK BEGINNING DISPLACEMENT\n         MVC   USNGBEGN,WORKDISP     SET VERIFIED DISPLACEMENT\n         MVC   WORKDISP,USNGEND      SET ENDING DISPLACEMENT\n         MVC   EMSG03A,ENDDISP       SET 'ENDING' IN MESSAGE\n         BAL   R2,LABL0360           CHECK ENDING DISPLACEMENT\n         MVC   USNGEND,WORKDISP      SET VERIFIED DISPLACEMENT\nLABL0340 DS    0H\n         ICM   R3,15,USNGNEXT        NEXT USING BLOCK\n         BNZ   LABL0330              LOOP\nLABL0350 DS    0H\n         TM    COMMFLAG,$ERROR       ERROR DETECTED YET?\n         BO    EXIT0000              YES.. STOP\n         B     LABL0430\nLABL0360 DS    0H\n         ICM   R7,15,COMMDATA        FIRST DATA\n         BZ    LABL0390              NO DATA AREAS\nLABL0370 DS    0H\n         CLC   WORKDISP,DATABEGN     POSSIBLY IN DATA?\n         BL    LABL0380              NO\n         CLC   WORKDISP,DATAEND      WITHIN DATA?\n         BNHR  R2                    YES, DISP IS OK\nLABL0380 DS    0H\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   LABL0370              LOOP\nLABL0390 DS    0H\n         L     R1,COMMDISP           DISPLACEMENT TABLE ADDRESS\nLABL0400 DS    0H\n         CLC   XFFFF,0(R1)           END OF TABLE REACHED?\n         BE    LABL0420              YES.. INVALID BOUNDARY\n         CLC   WORKDISP,0(R1)        DISPLACEMENT FOUND?\n         BER   R2                    YES.. GOOD\n         BL    LABL0420              INVALID BOUNDARY\nLABL0410 DS    0H\n         LA    R1,4(R1)              NEXT DISPLACEMENT\n         B     LABL0400              LOOP\nLABL0420 DS    0H\n         MVC   EMSG03B,4(R3)         SET BLOCK ID\n         UNPK  EMSG03O(9),WORKDISP(5)\n         MVZ   EMSG03O,COMM0F0F      PREPARE FOR TRANSLATE\n         TR    EMSG03O,COMMHXCH      TRANSLATE FOR PRINTING\n         MVI   EMSG03O+8,C' '        RESTORE BLANK\n         SH    R1,COMMH4             BACK-UP 1 INSTRUCTION\n         MVC   WORKDISP,0(R1)        FORCE DISP TO LAST INSTRUCTION\n         UNPK  EMSG03N(9),WORKDISP(5)\n         MVZ   EMSG03N,COMM0F0F      PREPARE FOR TRANSLATE\n         TR    EMSG03N,COMMHXCH      TRANSLATE FOR PRINTING\n         MVI   EMSG03N+8,C' '        RESTORE BLANK\n         MVC   PRTDATA(EMSG03L),EMSG03\n         BAL   R10,PRT0000           PRINT MESSAGE\n         BR    R2                    RETURN\n* ------------------------------------------------------------------- *\n*        Generate any labels for ENTRY points within the module       *\n* ------------------------------------------------------------------- *\nLABL0430 DS    0H\n         ICM   R4,15,COMMESD         FIRST ESD ENTRY\n         USING ESDDATA,R4            DEFINE BASE\n         BZ    LABL0470              NO ESD ENTRIES\nLABL0440 DS    0H\n         CLI   ESDTYPE,$ESDLR        LABEL?\n         BE    LABL0450              YES\n         CLI   ESDTYPE,$ESDPC        PRIVATE CODE?\n         BNE   LABL0460              NO\nLABL0450 DS    0H\n         CLC   ESDADDR,COMMCSAD+1    BELOW REQUESTED CSECT?\n         BL    LABL0460              YES\n         CLC   ESDADDR,COMMCSEA+1    ABOVE REQUESTED CSECT?\n         BH    LABL0460              YES\n         CLC   ESDNAME,COMMCSNM      CSECT'S NAME?\n         BE    LABL0460              YES\n         SR    R1,R1                 CLEAR REGISTER\n         ICM   R1,7,ESDADDR          SYMBOL'S ADDRESS IN THE CSECT\n         S     R1,COMMCSAD           CONVERT TO DISPLACEMENT\n         STCM  R1,15,WORKDISP        SET DISPLACEMENT\n         MVC   WORKLABL,ESDNAME      SET LABEL NAME\n         MVI   WORKTYPE,$LABLE       LABEL WILL BE FROM AN ESD ENTRY\n         BAL   R10,LABL1150          ADD LABEL\nLABL0460 DS    0H\n         ICM   R4,15,ESDNEXT         NEXT ESD ENTRY\n         BNZ   LABL0440              LOOP\n* ------------------------------------------------------------------- *\n*        Generate labels for ADCON references                         *\n* ------------------------------------------------------------------- *\nLABL0470 DS    0H\n         ICM   R7,15,COMMDATA        FIRST DATA BLOCK\n         BZ    LABL0550              NO DATA AREAS\nLABL0480 DS    0H\n         CLI   DATATYPE,$DATAACN     ADCON?\n         BNE   LABL0540              NO\n         ICM   R1,15,DATABEGN        DISPLACEMENT TO ADCON\n         A     R1,COMMTXT            PLUS BASE ADDRESS\n         CLI   DATALEN+3,4           4-BYTE ADCON?\n         BE    LABL0490              YES\n         CLI   DATALEN+3,3           3-BYTE ADCON?\n         BE    LABL0500              YES\n         CLI   DATALEN+3,2           2-BYTE ADCON?\n         BE    LABL0510              YES\n         XC    WORKDISP(3),WORKDISP  SET BYTES 1-3 TO ZERO\n         MVC   WORKDISP+3(1),0(R1)   COPY DISPLACEMENT\n         B     LABL0520\nLABL0490 DS    0H\n         MVC   WORKDISP,0(R1)        COPY DISPLACEMENT\n         B     LABL0520\nLABL0500 DS    0H\n         MVI   WORKDISP,X'00'        ZERO BYTE 1\n         MVC   WORKDISP+1(3),0(R1)   COPY DISPLACEMENT\n         B     LABL0520\nLABL0510 DS    0H\n         XC    WORKDISP(2),WORKDISP  CLEAR BYTES 1-2\n         MVC   WORKDISP+2(2),0(R1)   COPY DISPLACEMENT\nLABL0520 DS    0H\n         TM    WORKDISP,X'80'        31-BIT MODE BIT ON?\n         BNO   LABL0530              NO\n         OI    DATAFLAG,$DATA31      SET 31-BIT INDICATOR\n         NI    WORKDISP,X'7F'        TURN BIT OFF (NOT PART OF ADDRESS)\nLABL0530 DS    0H\n         MVI   WORKTYPE,$LABLR       LABEL WILL BE FOR RLD DATA\n         ST    R7,SAVERLD            SAVE DATA RLD ITEM'S ADDRESS\n         BAL   R10,LABL1040          ADD LABEL\n         L     R7,SAVERLD            RESTORE DATA RLD ITEM'S ADDRESS\n         MVC   DATALBA,WORKREF       SET LABEL BLOCK ADDRESS\n         MVC   DATALBD,WORKOPD       SET DISPLACEMENT FROM LABEL\nLABL0540 DS    0H\n         ICM   R7,15,DATANEXT        NEXT BLOCK\n         BNZ   LABL0480              LOOP\nLABL0550 DS    0H\n         MVI   WORKTYPE,C' '         CLEAR LABEL TYPE\n* ------------------------------------------------------------------- *\n*        Scan the object code and generate the reference table        *\n* ------------------------------------------------------------------- *\n         LA    R4,COMMREF            REFERENCE TABLE ANCHOR\n         USING REFDSCT,R4            DEFINE BASE\n         L     R5,COMMTXT            TEXT'S STORAGE ADDRESS\n         SR    R6,R6                 INITIALIZE DISPLACEMENT\nLABL0560 DS    0H\n         C     R6,COMMCSLN           BEYOND END OF CSECT?\n         BNL   LABL3000              YES, QUIT\n         ICM   R7,15,COMMDATA        FIRST DATA BLOCK\n         BZ    LABL0590              NOT WITHIN ANY DATA AREA\n         ITRACE ID=DATACHK2,         TESTING FOR DATA AREA             +\n               RDATA1=R6             .. CURRENT DISPLACEMENT\nLABL0570 DS    0H\n         CLM   R6,15,DATABEGN        TOO LOW FOR THIS DATA AREA?\n         BL    LABL0580              YES\n         CLM   R6,15,DATAEND         TOO HIGH FOR THIS DATA AREA?\n         BH    LABL0580              YES\n         ITRACE ID=DATA1             CURRENTLY IN A DATA AREA\n         ICM   R6,15,DATAEND         ENDING DISPLACEMENT\n         LA    R6,1(R6)              NEXT POSSIBLE INSTRUCTION DISP\n         LR    R5,R6                 COPY DISPLACEMENT\n         A     R5,COMMTXT            PLUS BASE ADDRESS\n         ITRACE ID=NEWADDR1,         NEW ADDRESS AND DISP SET          +\n               RDATA1=R5,            .. CURRENT TEXT ADDRESS           +\n               RDATA2=R6             .. CURRENT DISPLACEMENT\n         B     LABL0560              LOOP\nLABL0580 DS    0H\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   LABL0570              LOOP\nLABL0590 DS    0H\n         STC   R6,COMMDWRD           SAVE LAST BYTE\n         TM    COMMDWRD,1            ODD ADDRESS?\n         BO    ERR0070               YES\n         ITRACE ID=NEWOPCDE,         CHECKING AN OPCODE                +\n               DATA1=(R5),           .. CURRENT OPCODE                 +\n               RDATA2=R6             .. CURRENT DISPLACEMENT\n         SR    R8,R8                 CLEAR REGISTER\n         IC    R8,0(R5)              INSERT POSSIBLE OPCODE\n         SLL   R8,2                  MULTIPLY BY 4\n         A     R8,AOP                PLUS BASE ADDRESS\n         ICM   R8,15,0(R8)           OPCODE ENTRY ADDRESS\n         BZ    ERR0030               NOT A VALID OPCODE\n         USING OPDSECT,R8            DEFINE BASE\n         ITRACE ID=OPCODE,           VALID OPCODE                      +\n               RDATA1=R8,            .. OPCODE TABLE ENTRY'S ADDRESS   +\n               DATA2=(R8)            .. PART OF THE OPCODE TABLE ENTRY'\n         CLI   0(R5),X'B2'           2-BYTE OPCODE?\n         BE    LABL0595              ===> Yes, Check it out\n         CLI   0(R5),X'01'           2-BYTE OPCODE?\n         BE    LABL0595              ===> Yes, Check it out\n         B     LABL0600              ===> No\nLABL0595 DS    0H\n         LR    R0,R5                 COPY INSTRUCTION ADDRESS\n         LR    R1,R8                 COPY OPCODE TABLE ENTRY ADDRESS\n         L     R15,AB2               'B2' OPCODES ENTRY POINT\n         BALR  R14,R15               LINK TO DISASMB2\nLABL0600 DS    0H\n         TM    OPFLAGS,$OPREF        REFERENCE GENERATED?\n         BNO   LABL0630              NO\n* ------------------------------------------------------------------- *\n*        Determine if operand 1 references a known BASE, DATA, or     *\n*        USING (DSECT).                                               *\n* ------------------------------------------------------------------- *\n         XC    WORKOP1,WORKOP1       CLEAR REFERENCE 1\n         XC    WORKOP2,WORKOP2       CLEAR REFERENCE 2\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,2(R5)              INSERT BASE AND PART OF DISP\n         SRL   R1,4                  SHIFT BASE TO LOW ORDER BITS\n         STC   R1,WORKBASE           SAVE BASE REG\n         XC    WORKDISP,WORKDISP     CLEAR BYTES 1 AND 2\n         MVC   WORKDISP+2(2),2(R5)   COPY BASE AND DISP\n         NI    WORKDISP+2,X'0F'      LEAVE ONLY DISPLACEMENT\n         BAL   R10,LABL1000          DETERMINE REFERENCE\n         ITRACE ID=OP1REF,           OPERAND 1'S LABEL REFERENCE       +\n               DATA1=WORKREF,        .. LABEL BLOCK'S ADDRESS          +\n               DATA2=WORKOPD         .. DISPLACEMENT FROM LABEL\n         MVC   WORKOP1,WORKREF       SAVE OPERAND 1 REFERENCE\n         MVC   WORKOPD1,WORKOPD      SAVE DISPLACEMENT FROM LABEL\n         CLI   OPLENGTH,6            TWO OPERANDS?\n         BNE   LABL0610              NO\n* ------------------------------------------------------------------- *\n*        Determine if operand 2 references a known BASE, DATA, or     *\n*        USING (DSECT).                                               *\n* ------------------------------------------------------------------- *\nLABL0610 DS    0H\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,4(R5)              INSERT BASE AND PART OF DISP\n         SRL   R1,4                  SHIFT BASE TO LOW ORDER BITS\n         STC   R1,WORKBASE           SAVE BASE REG\n         XC    WORKDISP,WORKDISP     CLEAR WORK AREA\n         MVC   WORKDISP+2(2),4(R5)   COPY BASE AND DISP\n         NI    WORKDISP+2,X'0F'      LEAVE ONLY DISPLACEMENT\n         BAL   R10,LABL1000          DETERMINE REFERENCE\n         ITRACE ID=OP2REF,           OPERAND 2'S LABEL REFERENCE       +\n               DATA1=WORKREF,        .. LABEL BLOCK'S ADDRESS          +\n               DATA2=WORKOPD         .. DISPLACEMENT FROM LABEL\n         MVC   WORKOP2,WORKREF       SAVE OPERAND 2 REFERENCE\n         MVC   WORKOPD2,WORKOPD      SAVE DISPLACEMENT FROM LABEL\nLABL0620 DS    0H\n         OC    WORKOP1(8),WORKOP1    BOTH REFERENCES ZERO?\n         BZ    LABL0630              YES\n         GETMAIN RU,                 ACQUIRE STORAGE FOR REF BLOCK     +\n               LV=REFL,              .. SIZE                           +\n               LOC=ANY\n         ITRACE ID=NEWREF,           NEW REFERENCE BLOCK               +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         ST    R1,REFNEXT            CHAIN TO PREVIOUS BLOCK\n         LR    R4,R1                 SET BASE\n         XC    REFNEXT(REFL),REFNEXT CLEAR BLOCK\n         MVC   REFEYE,REF            SET BLOCK ID TO 'REF'\n         MVC   REFOPER1,WORKOP1      SET OPERAND 1 REFERENCE ENTRY\n         MVC   REFOPER2,WORKOP2      SET OPERAND 2 REFERENCE ENTRY\n         MVC   REFDISP1,WORKOPD1     SET DISPLACEMENT FROM LABEL\n         MVC   REFDISP2,WORKOPD2     SET DISPLACEMENT FROM LABEL\n         STCM  R6,15,REFDISPI        REFERENCING INSTRUCTION'S DISP\nLABL0630 DS    0H\n         AH    R5,OPLENGTH           NEXT INSTRUCTION'S ADDRESS\n         AH    R6,OPLENGTH           NEXT INSTRUCTION'S DISPLACEMENT\n         B     LABL0560\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        Determine if base register is referencing a known BASE,      *\n*        DATA area, or DSECT.  The base register has been isolated    *\n*        in field 'WORKBASE'.                                         *\n*                                                                     *\n*        If a reference is found, 'WORKREF'  will be set to the       *\n*        'LABEL' block assigned to that location.  If no LABEL can    *\n*        determined, 'WORKREF' will be set to zero.                   *\n*                                                                     *\n*        R10 is the return address.                                   *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLABL1000 DS    0H\n         ITRACE ID=FINDLABL,         ATTEMPTING TO FIND A LABEL        +\n               RDATA1=(R6),          .. INSTRUCTION'S DISPLACEMENT     +\n               RDATA2=(R5)           .. INSTRUCTION\n         XC    WORKREF,WORKREF       ASSUME NO VALID REFERENCE\n         ITRACE ID=SRCHBASE          SEARCHING BASE ENTRIES\n         ICM   R3,15,COMMBASE        FIRST BASE ENTRY\n         USING BASEDSCT,R3           DEFINE BASE\nLABL1010 DS    0H\n         BZ    LABL1200              NOT REFERENCING A KNOWN BASE\n         CLC   WORKBASE,BASEREG      CORRECT REGISTER?\n         BNE   LABL1020              NO\n         CLM   R6,15,BASEBEGN        TOO LOW?\n         BL    LABL1020              YES\n         CLM   R6,15,BASEEND         TOO HIGH?\n         BNH   LABL1030              THIS IS A DEFINED BASE\nLABL1020 DS    0H\n         ICM   R3,15,BASENEXT        NEXT BASE\n         B     LABL1010              LOOP\nLABL1030 DS    0H\n         ITRACE ID=BASEFND,          BASE REFERENCE FOUND              +\n               RDATA1=R3,            .. BASE FOR REFERENCE             +\n               DATA2=BASEBEGN        .. A PORTION OF THE ENTRY\n         ICM   R1,15,BASEDISP        DISPLACEMENT TO BASE\n         A     R1,WORKDISP           PLUS DISPLACEMENT FROM BASE\n         STCM  R1,15,WORKDISP        SAVE TOTAL DISPLACEMENT\nLABL1040 DS    0H\n         XC    WORKOPD,WORKOPD       CLEAR DISPLACEMENT FROM LABEL\n         ICM   R7,15,COMMDATA        FIRST DATA ENTRY\nLABL1050 DS    0H\n         BZ    LABL1090              NOT IN A DATA AREA\n         CLC   WORKDISP,DATABEGN     TOO LOW?\n         BL    LABL1060              YES\n         CLC   WORKDISP,DATAEND      TOO HIGH?\n         BNH   LABL1070              NO.. DATA REFERENCED\nLABL1060 DS    0H\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK\n         B     LABL1050              LOOP\n* ------------------------------------------------------------------- *\n*         DATA area referenced                                        *\n* ------------------------------------------------------------------- *\nLABL1070 DS    0H\n         ITRACE ID=DATAREF,          DATA REFERENCE FOUND              +\n               RDATA1=R7,            .. BASE FOR REFERENCE             +\n               DATA2=DATABEGN        .. A PORTION OF THE ENTRY\n         MVC   WORKLABL,DATA         SET NAME TO 'DATA    '\n         XC    WORKOPD,WORKOPD       ASSUME NO DISPLACEMENT\n         CLI   DATATYPE,$DATAUSR     USER DEFINED DATA?\n         BE    LABL1080              YES\n         CLI   DATATYPE,$DATAINT     INTERNALLY DETECTED DATA AREA?\n         BE    LABL1080              YES\n* ------------------------------------------------------------------- *\n*         Data referenced is an RLD item (ADCON, VCON, Q, or CXD).    *\n*         RLD items cannot be sub-divided (we cannot generate         *\n*         a label in the middle of a four byte ADCON for example).    *\n*         The reference will be changed so the label will be defined  *\n*         at the beginning of the RLD and a displacement from the     *\n*         label will be returned in WORKOPD.                          *\n* ------------------------------------------------------------------- *\n         ICM   R0,15,WORKDISP        DISPLACEMENT\n         ICM   R1,15,DATABEGN        DISPLACEMENT\n         STCM  R1,15,WORKDISP        CHANGE TO DATA ORIGIN\n         SR    R0,R1                 MINUS ORIGIN\n         STCM  R0,15,WORKOPD         DISPLACEMENT FROM LABEL\nLABL1080 DS    0H\n         CLI   WORKTYPE,$LABLR       LABEL FOR AN RLD REFERENCE?\n         BE    LABL1150              YES\n         MVI   WORKTYPE,$LABLD       DATA LABEL\n         B     LABL1150\n* ------------------------------------------------------------------- *\n*         CSECT reference from a defined BASE                         *\n* ------------------------------------------------------------------- *\nLABL1090 DS    0H\n         ITRACE ID=CSECTREF,         DATA REFERENCE FOUND              +\n               RDATA1=R3,            .. BASE FOR REFERENCE             +\n               DATA2=BASEBEGN        .. A PORTION OF THE ENTRY\n         CLI   WORKTYPE,$LABLR       WORKING ON A RLD ITEM?\n         BE    LABL1100              YES\n         MVI   WORKTYPE,$LABLI       INSTRUCTION LABEL\nLABL1100 DS    0H\n         MVC   WORKLABL,CHARZERO     SET NAME TO '0000'\n         SR    R15,R15               CLEAR REGISTER\n         ICM   R15,3,COMMPFXL        PREFIX'S LENGTH\n         BZ    LABL1110              PREFIX NOT DEFINED\n         BCTR  R15,0                 FOR EXECUTE\n         EX    R15,LABLBMVC          SET LABEL PREFIX\n         B     LABL1120\nLABL1110 DS    0H\n         MVC   WORKLABL,DATA         SET LABEL PREFIX\nLABL1120 DS    0H\n         L     R1,COMMDISP           DISPLACEMENT TABLE ADDRESS\nLABL1130 DS    0H\n         CLC   XFFFF,0(R1)           END OF TABLE?\n         BE    LABL1140              YES\n         CLC   WORKDISP,0(R1)        DISPLACEMENT FOUND?\n         BE    LABL1150              YES\n         BL    LABL1140              ONE TOO FAR\n         LA    R1,4(R1)              NEXT DISPLACEMENT\n         B     LABL1130              LOOP\nLABL1140 DS    0H\n         C     R1,COMMDISP           FIRST ONE?\n         BER   R10                   YES, NO VALID LABEL\n         SH    R1,COMMH4             BACK-UP 1 DISPLACEMENT\n         ICM   R0,15,WORKDISP        DISPLACEMENT TO DATA REFERENCED\n         S     R0,0(R1)              MINUS DISPLACEMENT TO LABEL\n         ST    R0,WORKOPD            SET DISPLACEMENT FROM LABEL\n         MVC   WORKDISP,0(R1)        SET DISPLACEMENT TO PREV INSTR\n* ------------------------------------------------------------------- *\n*         Determine where this LABEL goes in the CSECT LABEL chain    *\n* ------------------------------------------------------------------- *\nLABL1150 DS    0H\n         ITRACE ID=ADDLABEL,         CSECT REFERENCE                   +\n               DATA1=WORKDISP        .. DISPLACEMENT REFERENCED\n         LA    R3,COMMLABL           FORWARD POINTER'S ADDRESS\n         ICM   R9,15,COMMLABL        FIRST CSECT LABEL\n         USING LABLDSCT,R9           DEFINE BASE\n         BZ    LABL1170              INSERT ON END OF CHAIN\nLABL1160 DS    0H\n         CLC   LABLDISP,WORKDISP     TEST DISPLACEMENT\n         BE    LABL1190              DUPLICATE\n         BH    LABL1170              INSERT NEW NAME HERE\n         LA    R3,LABLNEXT           CURRENT BLOCK'S FWD POINTER ADDR\n         ICM   R9,15,LABLNEXT        NEXT CSECT LABEL\n         BNZ   LABL1160              LOOP\n* ------------------------------------------------------------------- *\n*         A new CSECT LABEL needs to be generated                     *\n* ------------------------------------------------------------------- *\nLABL1170 DS    0H\n         GETMAIN RU,                 ACQUIRE A NEW LABEL BLOCK         +\n               LV=LABLL,             .. SIZE                           +\n               LOC=ANY\n         ITRACE ID=NEWLABL,          NEW CSECT LABEL                   +\n               RDATA1=R1,            .. BLOCK'S ADRESS                 +\n               DATA2=WORKDISP        .. LABEL'S DISPLACEMENT\n         ST    R1,LABLNEXT-LABLDSCT(R3)  PREVIOUS BLOCK'S FWD POINTER\n         ST    R9,LABLNEXT-LABLDSCT(R1)  NEXT BLOCK'S ADDRESS\n         LR    R9,R1                 SET BASE\n         MVC   LABLEYE,LABL          SET BLOCK ID\n         CLI   WORKTYPE,$LABLE       ESD LABEL?\n         BE    LABL1180              YES\n         TM    COMMFLAG,$SEQLABL     SEQUENTIAL LABELS?\n         BO    LABL1180              YES.. SUFFIX WILL BE CREATED LATER\n         UNPK  WORKLABL+4(5),WORKDISP+2(3)\n         MVZ   WORKLABL+4(8),COMM0F0F  TURN OFF ZONES\n         TR    WORKLABL+4(8),COMMHXCH  TRANSLATE TO PRINTABLE\nLABL1180 DS    0H\n         MVC   LABLNAME,WORKLABL     SET LABEL'S NAME\n         MVC   LABLDISP,WORKDISP     SET DISPLACEMENT\n         MVC   LABLTYPE,WORKTYPE     SET LABEL TYPE\nLABL1190 DS    0H\n         ST    R9,WORKREF            SET REFERENCE TO THIS LABEL\n         CLI   LABLTYPE,$LABLD       LABEL TYPE CURRENTLY 'DATA'?\n         BER   R10                   YES\n         CLI   WORKTYPE,$LABLI       WAS REQUEST FOR INSTRUCTION LABEL?\n         BNER  R10                   NO\n         MVC   LABLNAME(4),WORKLABL  CHANGE PREFIX\n         BR    R10\nLABLBMVC MVC   WORKLABL(0),COMMPFX   SET PREFIX\n* ------------------------------------------------------------------- *\n*         No defined CSECT reference was found, try a DSECT           *\n* ------------------------------------------------------------------- *\nLABL1200 DS    0H\n         ITRACE ID=SRCHDSCT          SEARCHING DSECT ENTRIES\n         ICM   R3,15,COMMUSNG        FIRST USING BLOCK\n         USING USNGDSCT,R3           DEFINE BASE\nLABL1210 DS    0H\n         BZR   R10                   NOT REFERENCING A DSECT\n         CLC   WORKBASE,USNGBASE     CORRECT REGISTER?\n         BNE   LABL1220              NO\n         TM    USNGFLAG,$USNGND      DISPLACEMENTS ON USING STATEMENT?\n         BO    LABL1230              NO\n         CLM   R6,15,USNGBEGN        TOO LOW?\n         BL    LABL1220              YES\n         CLM   R6,15,USNGEND         TOO HIGH?\n         BNH   LABL1230              NO, DSECT REFERENCE LOCATED\nLABL1220 DS    0H\n         ICM   R3,15,USNGNEXT        NEXT USING BLOCK\n         B     LABL1210              LOOP\nLABL1230 DS    0H\n         L     R2,USNGDSA            ASSOCIATED DSECT BLOCK'S ADDRESS\n         ITRACE ID=DSCTFND,          DSECT REFERENCE                   +\n               RDATA1=R3,            .. USING BLOCK'S ADDRESS          +\n               RDATA2=R2             .. DSECT BLOCK'S ADDRESS\n         ICM   R9,15,DSCTLBA         FIRST LABEL BLOCK'S ADDRESS\n         BZR   R10                   NO VALID LABEL KNOWN\n         ICM   R0,15,USNGDISP        SET OFFSET INTO DSECT\nLABL1240 DS    0H\n         ICM   R1,15,LABLDISP        DISPLACEMENT TO LABEL\n         SR    R1,R0                 MINUS DISPLACEMENT TO LABEL\n         CLM   R1,15,WORKDISP        DISPLACEMENTS MATCH?\n         BNH   LABL1250              EQUAL OR LOW.. TAKE IT\n         ICM   R9,15,LABLNEXT        NEXT LABEL\n         BNZ   LABL1240              LOOP\n         BR    R10                   RETURN\nLABL1250 DS    0H\n         ITRACE ID=LABLFND,          LABEL WITHIN THE DSECT FOUND      +\n               RDATA1=R9,            .. LABEL BLOCK'S ADDRESS          +\n               DATA2=LABLNAME        .. LABEL\n         ICM   R0,15,WORKDISP        DISPLACEMENT FROM INSTRUCTION\n         SR    R0,R1                 DISPLACEMENT TO LABEL\n         STCM  R0,15,WORKOPD         SAVE DISPLACEMENT FROM THE LABEL\n         ST    R9,WORKREF            LABEL BLOCK'S ADDRESS\n         BR    R10                   RETURN\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        Add DATA blocks                                              *\n*                                                                     *\n*        R10 is the return address                                    *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLABL2000 DS    0H\n         OC    DATASIZE,DATASIZE     ANY DATA\n         BZR   R10                   NO DATA\n         LA    R2,COMMDATA           ANCHOR'S ADDRESS\n         ICM   R7,15,COMMDATA        FIRST DATA AREA\n         BZ    LABL2020              NO DATA AREAS\nLABL2010 DS    0H\n         CLC   DATABEGN,DATADISP     DOES IT GO HERE?\n         BH    LABL2020              YES\n         LA    R2,DATANEXT           NEXT BLOCK'S POINTER\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK'S ADDRESS\n         BNZ   LABL2010              LOOP\nLABL2020 DS    0H\n         GETMAIN RU,                 ACQUIRE STORAGE FOR DATA BLOCK    +\n               LV=DATAL,             .. SIZE                           +\n               LOC=ANY\n         ITRACE ID=NEWDATA,          NEW BLOCK DATA BLOCK              +\n               RDATA1=R1             .. BLOCK'S ADDRESS\n         ST    R1,0(R2)              CHAIN PREVIOUS BLOCK TO NEW\n         ST    R7,DATANEXT-DATADSCT(R1)   CHAIN NEXT BLOCK TO NEW BLOCK\n         LR    R7,R1                 SET BASE\n         MVC   DATAEYE,DATA          SET BLOCK IDENTIFIER\n         MVC   DATABEGN,DATADISP     STARTING DISPLACEMENT\n         LR    R1,R6                 CURRENT DISPLACEMENT\n         C     R1,COMMCSLN           BEYOND END OF CSECT?\n         BL    LABL2030              NO\n         L     R1,COMMCSLN           LIMIT TO CSECT LENGTH\n         B     LABL2040\nLABL2030 DS    0H\n         BCTR  R1,0\nLABL2040 DS    0H\n         STCM  R1,15,DATAEND         ENDING DISPLACEMENT\n         S     R1,DATABEGN           STARTING DISPLACEMENT\n         LA    R1,1(R1)              PLUS 1\n         STCM  R1,15,DATALEN         DATA AREA SIZE\n         XC    DATASIZE,DATASIZE     CLEAR DATA SKIPPED\n         XC    DATADISP,DATADISP     CLEAR STARTING DISPLACEMENT\n         MVI   DATATYPE,$DATAINT     INTERNALLY DETECTED DATA\n         MVC   DATANAME,COMMBLKS     INITIALIZE NAME\n         XC    DATALBA,DATALBA       INITIALIZE LABEL BLOCK ADDRESS\n         XC    DATALBD,DATALBD       INITIALIZE DISPLACEMENT FROM LABEL\n         NI    PGMFLAG,255-$BGNDISP  RESET FLAG\n         BR    R10\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        If sequential LABELs are desired, run the LABEL chain and    *\n*        set the suffix in the non-ESD LABELs.                        *\n*                                                                     *\n* ------------------------------------------------------------------- *\nLABL3000 DS    0H\n         TM    COMMFLAG,$SEQLABL     SEQUENTIALLY NUMBERED LABELS?\n         BNO   EXIT0000              NO\n         ICM   R9,15,COMMLABL        FIRST LABEL\n         BZ    EXIT0000              NO LABELS TO NUMBER\n         ITRACE ID=SEQNBR\nLABL3010 DS    0H\n         CLI   LABLTYPE,$LABLE       ESD TYPE LABEL?\n         BE    LABL3020              YES, DON'T MODIFY IT\n         AP    LABLNBR,P10           ADD TO LABEL COUNTER\n         MVC   EDITWORK,EDITWORD     INITIALIZE WITH EDIT WORD\n         ED    EDITWORK,LABLNBR      EDIT LABEL NUMBER\n         MVC   LABLNAME+4(4),EDITWORK+2\nLABL3020 DS    0H\n         ICM   R9,15,LABLNEXT        NEXT LABEL BLOCK\n         BNZ   LABL3010              LOOP\n         B     EXIT0000              EXIT\nERR0010  DS    0H\n         MVC   EMSG01NM,USNGDSNM     SET DSECT'S NAME\n         MVC   PRTDATA(EMSG01L),EMSG01\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nERR0020  DS    0H\n         UNPK  EMSG02B(9),DATABEGN(5)\n         MVZ   EMSG02B,COMM0F0F      PREPARE FOR TRANSLATE\n         TR    EMSG02B,COMMHXCH      TRANSLATE FOR PRINTING\n         MVI   EMSG02B+8,C' '        RESTORE BLANK\n         UNPK  EMSG02E(9),DATAEND(5) UNPACK ENDING DISPLACEMENT\n         MVZ   EMSG02E,COMM0F0F      PREPARE FOR TRANSLATE\n         TR    EMSG02E,COMMHXCH      TRANSLATE FOR PRINTING\n         MVI   EMSG02E+8,C' '        RESTORE BLANK\n         MVC   PRTDATA(EMSG02L),EMSG02\n         BAL   R10,PRT0000           PRINT MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nERR0030  DS    0H\n         MVC   PRTDATA(EMSG04L),EMSG04\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nERR0040  DS    0H\n         MVC   PRTDATA(EMSG06L),EMSG06\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nERR0060  DS    0H\n         MVC   PRTDATA(EMSG08L),EMSG08\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nERR0070  DS    0H\n         MVC   PRTDATA(EMSG09L),EMSG09\n         BAL   R10,PRT0000           PRINT ERROR MESSAGE\n         OI    COMMFLAG,$ERROR+$ABORT\n         B     EXIT0000              AND EXIT\nPRT0000  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R10                   RETURN\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE08   DC    18F'0'                REGISTER SAVE AREA\nWORKOP1  DC    A(0)                  OPERAND 1 REFERENCE\nWORKOP2  DC    A(0)                  OPERAND 2 REFERENCE\nWORKREF  DC    A(0)                  REFERENCED LABEL BLOCK\nSAVERLD  DC    A(0)                  SAVED RLD DATA ITEM ADDRESS\nWORKOPD  DC    XL4'00'               DISPLACEMENT FROM LABEL\nWORKOPD1 DC    XL4'00'               DISPLACEMENT FROM LABEL (OPER 1)\nWORKOPD2 DC    XL4'00'               DISPLACEMENT FROM LABEL (OPER 2)\nWORKDISP DC    XL4'00'               DISPLACEMENT FROM WORK BASE\nDATADISP DC    XL4'00'               STARTING DISPLACEMENT\nDATASIZE DC    XL4'00'               SIZE OF CURRENT DATA AREA\nPGMFLAG  DC    X'00'\n$BGNDISP EQU   X'01'                 .. DATA AREA BEGIN DISP KNOWN\nLABLNBR  DC    PL3'0'                COUNTER FOR SEQUENTIAL LABELS\nP10      DC    P'10'                 CONSTANT\nEDITWORK DC    X'F02020202020'       EDIT WORK AREA\nEDITWORD DC    X'F02020202020'       CONSTANT\nDSECTOFF DC    XL2'00'               DISPLACEMENT TO LABEL IN DSECT\nWORKLABL DC    CL9' '                TEMP LABEL NAME\nWORKBASE DC    X'00'                 BASE FOR CURRENT OPERAND\nWORKTYPE DC    C' '                  LABEL TYPE BEING CREATED\nREF      DC    CL8'REF'\nESD      DC    CL8'ESD '\nDATA     DC    CL8'DATA'\nLABL     DC    CL8'LABL'\nCHARZERO DC    CL4'0000'\nXFFFF    DC    X'FFFFFFFF'\nBEGNDISP DC    CL09'BEGINNING'\nENDDISP  DC    CL09'ENDING   '\nEMSG01   DC    C'DISASM0801E DSECT '\nEMSG01NM DC    CL08' '\n         DC    C' is not present, but is referenced on a USING statemen+\n               t'\nEMSG01L  EQU   *-EMSG01\nEMSG02   DC    C'DISASM0802E instructions overlap data defined at '\nEMSG02B  DC    CL8' '\n         DC    C' to '\nEMSG02E  DC    CL8' '\n         DC    C' '\nEMSG02L  EQU   *-EMSG02\nEMSG03   DC    C'DISASM0803W '\nEMSG03A  DC    CL9' '\n         DC    C' Displacement in a '\nEMSG03B  DC    CL8' '\n         DC    C' block is changed from '\nEMSG03O  DC    CL8' '\n         DC    C' to '\nEMSG03N  DC    CL8' '\n         DC    C' to reference an instruction boundary'\nEMSG03L  EQU   *-EMSG03\nEMSG04   DC    C'DISASM0804E Invalid opcode during reference table gene+\n               ration'\nEMSG04L  EQU   *-EMSG04\nEMSG05   DC    C'DISASM0805E Label '\nEMSG05N  DC    CL8' '\n         DC    C' is not in DSECT '\nEMSG05D  DC    CL8' '\n         DC    C' as requested on a USING statement'\nEMSG05L  EQU   *-EMSG05\nEMSG06   DC    C'DISASM0806E Label not found in DSECT during reference +\n               table generation'\nEMSG06L  EQU   *-EMSG06\nEMSG08   DC    C'DISASM0808E overlapping data areas not detected by DIS+\n               ASM02'\nEMSG08L  EQU   *-EMSG08\nEMSG09   DC    C'DISASM0809E Attempt to locate an instruction on an odd+\n                displacement boundary'\nEMSG09L  EQU   *-EMSG09\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n         SPACE 2\n         LTORG\nALPHATRT DS    0C 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    00-0F\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    10-1F\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    20-2F\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    30-3F\n         DC    X'00FFFFFFFFFFFFFFFFFFFF00FFFFFFFF'    40-4F BLANK AND .\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFF00FFFFFF'    50-5F *\n         DC    X'0000FFFFFFFFFFFFFFFFFF00FFFFFFFF'    60-6F - / AND ,\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    70-7F\n         DC    X'FF000000000000000000FFFFFFFFFFFF'    80-8F LOWER A-I\n         DC    X'FF000000000000000000FFFFFFFFFFFF'    90-9F LOWER J-R\n         DC    X'FFFF0000000000000000FFFFFFFFFFFF'    A0-AF LOWER S-Z\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    B0-BF\n         DC    X'FF000000000000000000FFFFFFFFFFFF'    C0-CF UPPER A-I\n         DC    X'FF000000000000000000FFFFFFFFFFFF'    D0-DF UPPER J-R\n         DC    X'FFFF0000000000000000FFFFFFFFFFFF'    E0-EF UPPER S-Z\n         DC    X'00000000000000000000FFFFFFFFFFFF'    F0-FF 0-9\n         SPACE 2\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM08\n./ ADD MEMBER=DISASM09\n         TITLE 'DISASM09 - SOURCE CODE GENERATOR'\n         MACRO\n         SVCDEF &SVCNBR,&DESC\n         LCLA   &LEN\n&LEN     SETA   K'&DESC-2\n         DC     AL2(&LEN+5)          TOTAL ENTRY LENGTH\n         DC     AL2(&LEN)            DESCRIPTION'S LENGTH\n         DC     X'&SVCNBR'           SVC NUMBER\n         DC     C&DESC               DESCRIPTION\n         MEND\n         COPY   DISASMGB\n*--------------------------------------------------------------------*\n*                                                                    *\n*  Module name: DISASM09                                             *\n*                                                                    *\n*  Function:                                                         *\n*   Source code generator.                                           *\n*                                                                    *\n*--------------------------------------------------------------------*\nDISASM09 CSECT\nDISASM09 AMODE 31\nDISASM09 RMODE 24\n         USING DISASM09,R12,R10\n         USING DISASM00,R11\n         STM   R14,R12,12(R13)       SAVE REGS\n         LR    R12,R15               SET BASE REG\n         B     GEN0000               SKIP EYECATCHER\n         DC    CL8'DISASM09'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nGEN0000  DS    0H\n         LA    R10,2048(R12)         LOAD 2ND BASE..\n         LA    R10,2048(R10)         .. 4K FROM 1ST BASE\n         LA    R1,SAVE09             OUR SAVE AREA ADDRESS\n         ST    R13,4(R1)             CHAIN CALLER'S SAVE AREA TO OURS\n         ST    R1,8(R13)             CHAIN OUR SAVE AREA TO CALLER'S\n         LR    R13,R1                SET SAVE AREA ADDRESS\n         ITRACE ID=ENTRY\n         TM    COMMDD,$PUNCHDD       IS DISPUNCH DD PRESENT?\n         BNO   GEN0010               NO\n         ITRACE ID=OPENPNCH\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (DISPUNCH,OUTPUT)     OPEN DISPUNCH\n         BAL   R14,AM31              SWITCH TO 24-BIT MODE\nGEN0010  DS    0H\n         MVC   COMMSUBH(SUBHEADL),SUBHEAD\n         LA    R1,SUBHEADL           SUBHEADING LENGTH\n         STH   R1,COMMSUBL           SET LENGTH\n         MVI   COMMSUBL,X'FF'        SET NON-CENTERED INDICATOR\n         MVC   SRCLABL,COMMCSNM      SET CSECT NAME\n         MVC   SRCMNEM,CSCTOPCD      SET MNEMONIC TO 'CSECT'\n         MVC   SRCDISP,CHARZERO      DISPLACEMENT IS ZERO\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT CSECT STATEMENT\n         BAL   R9,PUNCH000           PUNCH CSECT STATEMENT\n* ------------------------------------------------------------------- *\n*      Generate ENTRY statements                                      *\n* ------------------------------------------------------------------- *\n         ICM   R3,15,COMMESD         FIRST ESD ENTRY\n         USING ESDDATA,R3            DEFINE BASE\n         BZ    GEN0050               NO ESD ENTRIES\nGEN0020  DS    0H\n         CLI   ESDTYPE,$ESDLR        LABEL?\n         BE    GEN0030               YES\n         CLI   ESDTYPE,$ESDPC        PRIVATE CODE?\n         BNE   GEN0040               NO\nGEN0030  DS    0H\n         CLC   ESDADDR,COMMCSAD+1    TOO LOW FOR OUR CSECT?\n         BL    GEN0040               YES\n         CLC   ESDADDR,COMMCSEA+1    TOO HIGH FOR OUR CSECT?\n         BH    GEN0040               YES\n         CLC   ESDNAME,COMMCSNM      SAME AS THE CSECT NAME?\n         BE    GEN0040               YES\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE AREA\n         MVC   SRCMNEM,ENTROPCD      SET OPCODE (ENTRY)\n         MVC   SRCOPER(L'ESDNAME),ESDNAME\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT ENTRY STATEMENT\n         BAL   R9,PUNCH000           PUNCH ENTRY STATEMENT\nGEN0040  DS    0H\n         ICM   R3,15,ESDNEXT         NEXT ESD ENTRY\n         BNZ   GEN0020               LOOP\n* ------------------------------------------------------------------- *\n*                                                                     *\n* ------------------------------------------------------------------- *\nGEN0050  DS    0H\n         SR    R3,R3                 INITIALIZE INSTRUCTION DISP\n         STCM  R3,15,DISPI           SET INSTRUCTION DISPLACEMENT\n         L     R4,COMMTXT            INITIALIZE INSTRUCTION ADDRESS\n         ICM   R5,15,COMMLABL        FIRST CSECT LABEL\n         USING LABLDSCT,R5           DEFINE BASE\n         BZ    GEN0060               NO LABELS\n         MVC   DISPL,LABLDISP        SET LABEL DISPLACEMENT\n         B     GEN0070\nGEN0060  DS    0H\n         MVI   DISPL,X'FF'           SET EOF FLAG\nGEN0070  DS    0H\n         ICM   R6,15,COMMREF         FIRST REFERENCE ENTRY\n         USING REFDSCT,R6            DEFINE BASE\n         BZ    GEN0080               NO REFERENCES\n         MVC   DISPR,REFDISPI        SET REFERENCE DISP\n         B     GEN0090\nGEN0080  DS    0H\n         MVI   DISPR,X'FF'           SET EOF FLAG\nGEN0090  DS    0H\n         ICM   R7,15,COMMDATA        FIRST DATA AREA\n         USING DATADSCT,R7           DEFINE BASE\n         BZ    GEN0100               NO DATA AREAS\n         MVC   DISPD,DATABEGN        SET DATA AREA DISPLACEMENT\n         B     GEN0110\nGEN0100  DS    0H\n         MVI   DISPD,X'FF'           SET EOF FLAG\n* ------------------------------------------------------------------- *\n*                                                                     *\n*        Beginning of source generation loop                          *\n*                                                                     *\n* ------------------------------------------------------------------- *\nGEN0110  DS    0H\n         ITRACE ID=GENLOOP,          STARTING GEN LOOP                 +\n               DATA1=DISPI,          .. INSTRUCTION DISPLACEMENT       +\n               DATA2=DISPD           .. NEXT DATA AREA DISPLACEMENT\n         C     R3,COMMCSLN           REACHED END OF MODULE?\n         BNL   GEN0700               YES.. COPY ASSEMBLER INPUT\n         CLC   DISPI,DISPL           GEN A LABEL AT THIS TIME?\n         BNE   GEN0130               NO\n* ------------------------------------------------------------------- *\n*        Generate a LABEL                                             *\n* ------------------------------------------------------------------- *\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE STATEMENT AREA\n         UNPK  SRCDISP(9),DISPI(5)   UNPACK DISPLACEMENT\n         MVZ   SRCDISP,COMM0F0F      TURN OFF ZONES\n         TR    SRCDISP,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   SRCDISP+8,C' '        RESTORE THE BLANK\n         MVC   SRCLABL,LABLNAME      SET LABEL\n         MVC   SRCMNEM,DSOPCD        SET OPCODE TO 'DS'\n         MVC   SRCOPER(L'OPER0C),OPER0C\n         MVC   PRTDATA(SRCL),SRC     COPY STATEMENT TO PRINT\n         BAL   R9,PRT0000            PRINT SOURCE STATEMENT\n         BAL   R9,PUNCH000           PUNCH SOURCE STATEMENT\n         ICM   R5,15,LABLNEXT        NEXT LABEL\n         BNZ   GEN0120\n         MVI   DISPL,X'FF'           SET END OF FILE\n         B     GEN0130\nGEN0120  DS    0H\n         MVC   DISPL,LABLDISP        SET NEW LABEL DISPLACEMENT\n* ------------------------------------------------------------------- *\n*        Test for DATA area                                           *\n* ------------------------------------------------------------------- *\nGEN0130  DS    0H\n         CLC   DISPI,DISPD           IS THIS DATA?\n         BE    GEN0400               YES\n         BH    ERR0010               INTERNAL ERROR\n         TM    DISPI+3,X'01'         DISPLACEMENT ODD?\n         BO    ERR0040               YES\n* ------------------------------------------------------------------- *\n*        Generate DROP statements for USING blocks                    *\n* ------------------------------------------------------------------- *\n         ICM   R2,15,COMMUSNG        FIRST USING BLOCK\n         USING USNGDSCT,R2           DEFINE BASE\n         BZ    GEN0160               NO USING BLOCKS\nGEN0140  DS    0H\n         TM    USNGFLAG,$USNGND      DISPLACEMENTS?\n         BO    GEN0150               NO.. NEVER NEED A DROP\n         CLC   USNGEND,DISPI         TIME FOR 'DROP' STATEMENT?\n         BNE   GEN0150               NO\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE AREA\n         MVC   SRCMNEM,DROPOPCD      SET OPCODE\n         MVI   SRCOPER,C'R'          SET REGISTER PREFIX\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,USNGBASE           BASE REGISTER\n         SLL   R1,1                  MULTIPLY BY 2\n         LA    R1,COMMNBR(R1)        NUMBER'S ADDRESS\n         MVC   SRCOPER+1(2),0(R1)    MOVE NUMBER\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT DROP STATEMENT\n         BAL   R9,PUNCH000           PUNCH DROP STATEMENT\nGEN0150  DS    0H\n         ICM   R2,15,USNGNEXT        NEXT USING BLOCK\n         BNZ   GEN0140               LOOP\n* ------------------------------------------------------------------- *\n*        Generate DROP statements for BASE blocks                     *\n* ------------------------------------------------------------------- *\nGEN0160  DS    0H\n         ICM   R2,15,COMMBASE        FIRST USING BLOCK\n         USING BASEDSCT,R2           DEFINE BASE\n         BZ    GEN0190               NO USING BLOCKS\nGEN0170  DS    0H\n         CLC   BASEEND,DISPI         TIME FOR 'DROP' STATEMENT?\n         BNE   GEN0180               NO\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE AREA\n         MVC   SRCMNEM,DROPOPCD      SET OPCODE\n         MVI   SRCOPER,C'R'          SET REGISTER PREFIX\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,BASEREG            BASE REGISTER\n         SLL   R1,1                  MULTIPLY BY 2\n         LA    R1,COMMNBR(R1)        NUMBER'S ADDRESS\n         MVC   SRCOPER+1(2),0(R1)    MOVE NUMBER\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT DROP STATEMENT\n         BAL   R9,PUNCH000           PUNCH DROP STATEMENT\nGEN0180  DS    0H\n         ICM   R2,15,BASENEXT        NEXT BASE BLOCK\n         BNZ   GEN0170               LOOP\n* ------------------------------------------------------------------- *\n*        Generate USING statements for USING blocks                   *\n* ------------------------------------------------------------------- *\nGEN0190  DS    0H\n         ICM   R2,15,COMMUSNG        FIRST USING BLOCK\n         USING USNGDSCT,R2           DEFINE BASE\n         BZ    GEN0270               NO USING BLOCKS\nGEN0200  DS    0H\n         OC    DISPI,DISPI           INITIAL DISPLACEMENT?\n         BNZ   GEN0210               NO\n         TM    USNGFLAG,$USNGND      DISPLACEMENTS?\n         BO    GEN0230               NO..  GENERATE AT DISP ZERO\n         B     GEN0220               YES.. DISPLACEMENTS MUST MATCH\nGEN0210  DS    0H\n         TM    USNGFLAG,$USNGND      DISPLACEMENTS?\n         BO    GEN0260               NO\nGEN0220  DS    0H\n         CLC   USNGBEGN,DISPI        TIME FOR 'USING' STATEMENT?\n         BNE   GEN0260               NO\nGEN0230  DS    0H\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE AREA\n         MVC   SRCMNEM,USNGOPCD      SET OPCODE\n         MVC   SRCOPER(8),USNGDSNM   SET DSECT'S NAME\n         CLC   USNGLBNM,COMMBLKS     LABEL NAME PRESENT?\n         BE    GEN0235               NO\n         MVC   SRCOPER(8),USNGLBNM   SET LABEL NAME\nGEN0235  DS    0H\n         LA    R1,SRCOPER            FIRST CHARACTER\nGEN0240  DS    0H\n         CLI   0(R1),C' '            BLANK?\n         BE    GEN0250               YES\n         LA    R1,1(R1)              NEXT\n         B     GEN0240               LOOP\nGEN0250  DS    0H\n         ST    R1,GENADDR            SET OUTPUT ADDRESS\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVC   WORKREG,USNGBASE      COPY REGISTER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT USING STATEMENT\n         BAL   R9,PUNCH000           PUNCH USING STATEMENT\nGEN0260  DS    0H\n         ICM   R2,15,USNGNEXT        NEXT USING BLOCK\n         BNZ   GEN0200               LOOP\n* ------------------------------------------------------------------- *\n*        Generate using statements for BASE blocks                    *\n* ------------------------------------------------------------------- *\nGEN0270  DS    0H\n         ICM   R2,15,COMMBASE        FIRST USING BLOCK\n         USING BASEDSCT,R2           DEFINE BASE\n         BZ    GEN0330               NO BASE BLOCKS\nGEN0280  DS    0H\n         CLC   BASEBEGN,DISPI        TIME FOR 'USING' STATEMENT?\n         BNE   GEN0320               NO\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE AREA\n         MVC   SRCMNEM,USNGOPCD      SET OPCODE\n         MVC   SRCOPER(8),COMMCSNM   SET OPERAND (CSECT'S NAME)\n         LA    R1,SRCOPER            CURRENT OUTPUT ADDRESS\nGEN0290  DS    0H\n         CLI   0(R1),C' '            BLANK?\n         BE    GEN0300               YES\n         LA    R1,1(R1)              NEXT\n         B     GEN0290               LOOP\nGEN0300  DS    0H\n         ST    R1,GENADDR            SET ADDRESS\n         ICM   R0,15,BASEDISP        DISPLACEMENT REFERRED TO\n         BZ    GEN0310               DIRECTLY AT CSECT\n         MVI   0(R1),C'+'            INSERT PLUS\n         LA    R1,1(R1)              NEXT\n         ST    R1,GENADDR            SET ADDRESS\n         STCM  R0,15,WORKNBR         SET VALUE\n         BAL   R15,GENNBR00          GENERATE NUMERIC VALUE\nGEN0310  DS    0H\n         BAL   R15,GENCOMMA          INSERT COMMA\n         MVC   WORKREG,BASEREG       COPY REGISTER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT USING STATEMENT\n         BAL   R9,PUNCH000           PUNCH USING STATEMENT\nGEN0320  DS    0H\n         ICM   R2,15,BASENEXT        NEXT BASE BLOCK\n         BNZ   GEN0280               LOOP\n* ------------------------------------------------------------------- *\n*        Generate an instruction                                      *\n* ------------------------------------------------------------------- *\nGEN0330  DS    0H\n         SR    R8,R8                 CLEAR REGISTER\n         ICM   R8,1,0(R4)            POSSIBLE OPCODE\n         BZ    ERR0020               NOT A VALID OPCODE\n         SLL   R8,2                  MULTIPLY BY 4\n         A     R8,AOP                PLUS OPCODE TABLE BASE ADDRESS\n         ICM   R8,15,0(R8)           OPCODE TABLE ENTRY ADDRESS\n         USING OPDSECT,R8            DEFINE BASE\n         BZ    ERR0020               NOT A VALID OPCODE\n         CLI   0(R4),X'B2'           B2 INSTRUCTION?\n         BNE   GEN0340               NO\n         LR    R0,R4                 COPY OPCODE'S ADDRESS\n         LR    R1,R8                 COPY B2'S ADDRESS IN DISASMOP\n         L     R15,AB2               B2 INTERPRETER ENTRY POINT\n         BALR  R14,R15               INTERPRET B2 OPCODE\nGEN0340  DS    0H\n         ITRACE ID=GENINSTR,         GENERATING A VALID INSTRUCTION    +\n               DATA1=(R4),           .. INSTRUCTION                    +\n               DATA2=OPMNEM          .. OPCODE TABLE DATA\n         BAL   R9,GEN0620            GENERATE DISP AND HEX\n         SR    R15,R15               CLEAR REGISTER\n         IC    R15,OPFORM            OPCODE FORM\n         SLL   R15,2                 MULTIPLY BY 4\n         LA    R15,FMTTABLE(R15)     GENERATING ROUTINE'S ADDRESS\n         L     R15,0(R15)            LOAD THE ADDRESS\n         BR    R15                   GENERATE THE INSTRUCTION\nGEN0350  DS    0H\n         TM    OPFLAGS,$OPCCA+$OPCCL+$OPCCC   CONDITION CODE CHANGED?\n         BZ    GEN0360               NO\n         MVC   SAVEFLAG,OPFLAGS      SAVE CONDITION CODE FLAGS\nGEN0360  DS    0H\n         TM    OPFLAGS,$OPNCMNT      COMMENT PRESENT?\n         BO    GEN0370               NO\n         MVC   SRCCMNT,OPCMNT        SET COMMENT\nGEN0370  DS    0H\n         ITRACE ID=PRTSRC\n         MVC   PRTDATA(SRCL),SRC     SET PRINT DATA\n         BAL   R9,PRT0000            PRINT THE GENERATED INSTRUCTION\n         ITRACE ID=PUNCHSRC\n         BAL   R9,PUNCH000           PUNCH SOURCE STATEMENT\n         CLC   DISPI,DISPR           LABEL REFERENCE USED?\n         BNE   GEN0390               NO\n         ICM   R6,15,REFNEXT         NEXT REFERENCE BLOCK\n         BZ    GEN0380               NO MORE REFERENCE BLOCKS\n         MVC   DISPR,REFDISPI        SET DISPLACEMENT\n         ITRACE ID=NEXTREF,          WE HAVE A NEW REFERENCE BLOCK     +\n               DATA1=DISPR           .. INSTRUCTION'S DISPLACEMENT\n         B     GEN0390\nGEN0380  DS    0H\n         ITRACE ID=REFEOF            NO MORE REFERENCE BLOCKS\n         MVI   DISPR,X'FF'           SET EOF FLAG\nGEN0390  DS    0H\n         AH    R3,OPLENGTH           UPDATE DISPLACEMENT\n         AH    R4,OPLENGTH           UPDATE INSTRUCTION ADDRESS\n         STCM  R3,15,DISPI           UPDATE CONTROL DATA\n         ITRACE ID=NEWDISPI,         NEW DISPLACEMENT                  +\n               RDATA1=R3,            .. DISPLACEMENT                   +\n               RDATA2=R4             .. ASSOCIATED STORAGE ADDRESS\n         B     GEN0110               LOOP\n* ------------------------------------------------------------------- *\n*        Generate constants                                           *\n* ------------------------------------------------------------------- *\nGEN0400  DS    0H\n         ITRACE ID=GENDATA,          IN A DATA AREA                    +\n               DATA1=DATABEGN,       .. BEGINNING POINT                +\n               DATA2=DATAEND         .. ENDING POINT\n         L     R8,AOP                OPCODE TABLE ADDRESS\n         L     R8,0(R8)              DC'S DUMMY ENTRY ADDRESS\n         CLI   DATATYPE,$DATAACN     AD-CON?\n         BE    GEN0470               YES\n         CLI   DATATYPE,$DATAVCN     V-CON?\n         BE    GEN0520               YES\n         CLI   DATATYPE,$DATACXD     CXD (PSEUDO AREA SIZE)?\n         BE    GEN0550               YES\n         CLI   DATATYPE,$DATAQ       Q (PSEUDO AREA DISPLACEMENT)?\n         BE    GEN0560               YES\n         MVC   WORKNBR,DATAEND       ASSUME FULL DATA SIZE\n         SR    R9,R9                 CLEAR REGISTER\n         CLI   DISPL,X'FF'           END OF LABELS REACHED?\n         BE    GEN0410               YES\n         ICM   R9,15,DISPL           NEXT LABEL'S DISPLACEMENT\n         BCTR  R9,0                  MINUS 1\n         CLM   R9,15,WORKNBR         LABEL WITHIN DATA?\n         BH    GEN0410               NO\n         STCM  R9,15,WORKNBR         LIMIT TO 1 BYTE BEFORE LABEL\nGEN0410  DS    0H\n         ICM   R9,15,WORKNBR         END OF DATA DISPLACEMENT\n         ICM   R0,15,DISPD           STARTING DISPLACEMENT\n         SR    R9,R0                 NUMBER OF BYTES OF DATA MINUS 1\n         LA    R9,1(R9)              FULL NUMBER OF BYTES\n         CH    R9,COMMH8             MORE THAN 8 BYTES?\n         BNH   GEN0420               NO\n         LH    R9,COMMH8             LIMIT TO 8 BYTES\nGEN0420  DS    0H\n         ITRACE ID=DCLEN1,           LENGTH TO LABEL OR END OF AREA    +\n               RDATA1=R9\n         LTR   R9,R9                 LENGTH ZERO?\n         BZ    ERR0030               YES..\n         TRT   0(1,R4),COMMPRT       PRINTABLE CHARACTER?\n         BZ    GEN0450               YES\n         ITRACE ID=HEXDC\n         LR    R15,R9                COPY LENGTH\n         BCTR  R15,0                 MINUS 1\n         EX    R15,NPRTTRT           SCAN FOR ALL NON-PRINTABLE\n         BZ    GEN0430               ALL NON-PRINTABLE\n         LR    R9,R1                 STOPPING POINT\n         SR    R9,R4                 NUMBER OF BYTES SCANNED\nGEN0430  DS    0H\n         ITRACE ID=DCLEN2,           LENGTH OF HEX DATA                +\n               RDATA1=R9\n         STH   R9,OPLENGTH           SET LENGTH IN DC ENTRY\n         BAL   R9,GEN0620            GENERATE OBJECT AND MNEMONIC\n         MVC   SRCOPER(2),HEXDC      SET OPERAND TO X'\n         LA    R1,SRCOPER+2          STARTING DATA POINT\n         LH    R15,OPLENGTH          DATA LENGTH\nGEN0440  DS    0H\n         UNPK  0(3,R1),0(2,R4)       UNPACK DATA\n         MVZ   0(2,R1),COMM0F0F      TURN OFF ZONES\n         TR    0(2,R1),COMMHXCH      TRANSLATE TO PRINTABLE\n         LA    R1,2(R1)              NEXT IN OUTPUT\n         LA    R3,1(R3)              UPDATE DISPLACEMENT\n         LA    R4,1(R4)              NEXT OBJECT MODULE BYTE\n         BCT   R15,GEN0440           LOOP\n         MVI   0(R1),C''''           INSERT ENDING APOSTROPHE\n         B     GEN0600               PRINT/PUNCH\nGEN0450  DS    0H\n         ITRACE ID=CHARDC\n         LR    R15,R9                COPY LENGTH\n         BCTR  R15,0                 MINUS 1\n         EX    R15,PRTTRT            SCAN FOR ALL PRINTABLE\n         BZ    GEN0460               ALL PRINTABLE\n         LR    R9,R1                 COPY STOPPING POINT\n         SR    R9,R4                 NUMBER OF BYTES SCANNED\n         LR    R15,R9                COPY LENGTH\n         BCTR  R15,0                 MINUS 1\nGEN0460  DS    0H\n         ITRACE ID=DCLEN3,           TO END OF DATA OR HEX DATA        +\n               RDATA1=R9,                                              +\n               RDATA2=R15\n         STH   R9,OPLENGTH           SET LENGTH\n         BAL   R9,GEN0620            GENERATE OBJECT AND MNEMONIC\n         MVC   SRCOPER(2),CHARDC     SET OPERAND TO C'\n         EX    R15,CHDCMVC           MOVE CHARACTER DATA\n         LA    R1,SRCOPER+3(R15)     ENDING POINT\n         MVI   0(R1),C''''           INSERT ENDING APOSTROPHE\n         B     GEN0590\nGEN0470  DS    0H\n         ITRACE ID=GENADCON          GENERATING AN ADCON\n         MVC   OPLENGTH,DATALEN+2    SET LENGTH\n         BAL   R9,GEN0620            GENERATE OBJECT AND MNEMONIC\n         MVC   SRCOPER(2),=C'AL'     SET ADCON-LENGTH\n         MVC   SRCOPER+2(1),DATALEN+3\n         OI    SRCOPER+2,X'F0'       MAKE IT PRINTABLE\n         MVI   SRCOPER+3,C'('        OPEN PARENTHESIS\n         ICM   R1,15,DATALBA         LABEL BLOCK'S ADDRESS\n         MVC   SRCOPER+4(8),LABLNAME-LABLDSCT(R1)\n         LA    R1,SRCOPER+4\nGEN0480  DS    0H\n         CLI   0(R1),C' '            BLANK?\n         BE    GEN0490               YES\n         LA    R1,1(R1)              NEXT\n         B     GEN0480               LOOP\nGEN0490  DS    0H\n         ST    R1,GENADDR            SET CURRENT ADDRESS\n         SR    R0,R0                 CLEAR REGISTER\n         ICM   R0,15,DATALBD         DISPLACEMENT FROM LABEL\n         BZ    GEN0500               NO DISPLACEMENT\n         MVI   0(R1),C'+'            INSERT PLUS SIGN\n         LA    R1,1(R1)              NEXT\n         ST    R1,GENADDR            SAVE ADDRESS\n         STCM  R0,15,WORKNBR         SET DISPLACEMENT\n         BAL   R15,GENNBR00          GENERATE DISPLACEMENT\nGEN0500  DS    0H\n         L     R1,GENADDR            CURRENT ADDRESS\n         TM    DATAFLAG,$DATA31      31-BIT MODE BIT ON?\n         BNO   GEN0510               NO\n         MVC   0(AM31INDL,R1),AM31IND   GEN 31-BIT MODE\n         B     GEN0590               DONE\nGEN0510  DS    0H\n         BAL   R15,GENPRN2           GENERATE CLOSING PARENTHESIS\n         B     GEN0590               DONE\nGEN0520  DS    0H\n         ITRACE ID=GENVCON\n         MVC   OPLENGTH,DATALEN+2    SET LENGTH\n         BAL   R9,GEN0620            GENERATE OBJECT AND MNEMONIC\n         MVC   SRCOPER(2),=C'VL'     SET VCON-LENGTH\n         MVC   SRCOPER+2(1),DATALEN+3\n         OI    SRCOPER+2,X'F0'       MAKE IT PRINTABLE\n         MVI   SRCOPER+3,C'('        OPEN PARENTHESIS\n         MVC   SRCOPER+4(8),DATANAME COPY EXTERNAL SYMBOL NAME\n         LA    R1,SRCOPER+4\nGEN0530  DS    0H\n         CLI   0(R1),C' '            BLANK?\n         BE    GEN0540               YES\n         LA    R1,1(R1)              NEXT\n         B     GEN0530               LOOP\nGEN0540  DS    0H\n         MVI   0(R1),C')'            CLOSING PARENTHESIS\n         B     GEN0590\nGEN0550  DS    0H\n         MVC   OPLENGTH,DATALEN+2    SET LENGTH\n         BAL   R9,GEN0620            GENERATE OBJECT AND MNEMONIC\n         MVC   SRCMNEM,CXDOPCD       CHANGE OPCODE TO CXD\n         B     GEN0590\nGEN0560  DS    0H\n         ITRACE ID=GENQ\n         MVC   OPLENGTH,DATALEN+2    SET LENGTH\n         BAL   R9,GEN0620            GENERATE OBJECT AND MNEMONIC\n         MVC   SRCOPER(2),=C'QL'     SET Q-LENGTH\n         MVC   SRCOPER+2(1),DATALEN+3\n         OI    SRCOPER+2,X'F0'       MAKE IT PRINTABLE\n         MVI   SRCOPER+3,C'('        OPEN PARENTHESIS\n         MVC   SRCOPER+4(8),DATANAME COPY EXTERNAL SYMBOL NAME\n         LA    R1,SRCOPER+4\nGEN0570  DS    0H\n         CLI   0(R1),C' '            BLANK?\n         BE    GEN0580               YES\n         LA    R1,1(R1)              NEXT\n         B     GEN0570               LOOP\nGEN0580  DS    0H\n         MVI   0(R1),C')'            CLOSING PARENTHESIS\nGEN0590  DS    0H\n         AH    R3,OPLENGTH           UPDATE DISPLACEMENT\n         AH    R4,OPLENGTH           NEXT OBJECT MODULE BYTE\nGEN0600  DS    0H\n         MVC   PRTDATA(SRCL),SRC     SET DATA FOR PRINTING\n         BAL   R9,PRT0000            PRINT\n         BAL   R9,PUNCH000           PUNCH\n         STCM  R3,15,DISPI           SET NEW DISPLACEMENT\n         STCM  R3,15,DISPD           SET DATA DISPLACEMENT\n         ITRACE ID=DCDONE,           DC PROCESSING COMPLETE            +\n               DATA1=DISPD,          .. DATA DISPLACEMENT NOW          +\n               DATA2=DATAEND         .. END OF DATA AREA\n         CLC   DISPD,DATAEND         BEYOND END OF DATA AREA?\n         BNH   GEN0110               NO\n         ITRACE ID=NEXTDATA,                                           +\n               RDATA1=R7,            .. CURRENT DATA BLOCK ADDRESS     +\n               DATA2=DATANEXT        .. NEXT DATA BLOCK'S ADDRESS\n         ICM   R7,15,DATANEXT        NEXT DATA BLOCK\n         BNZ   GEN0610               SET NEXT DATA DISP\n         MVI   DISPD,X'FF'           SET END OF FILE\n         B     GEN0110\nGEN0610  DS    0H\n         MVC   DISPD,DATABEGN        SET BEGINNING OF NEXT DATA AREA\n         B     GEN0110\n* ------------------------------------------------------------------- *\n*        Generate displacement, mnemonic, and instruction in hex      *\n* ------------------------------------------------------------------- *\nGEN0620  DS    0H\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE STATEMENT\n         UNPK  SRCDISP(9),DISPI(5)   UNPACK DISPLACEMENT\n         MVZ   SRCDISP,COMM0F0F      TURN OFF ZONES\n         TR    SRCDISP,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   SRCDISP+8,C' '        RESTORE BLANK\n         MVC   SRCMNEM,OPMNEM        SET MNEMONIC\n         LH    R1,OPLENGTH           INSERT INSTRUCTION LENGTH\n         BCTR  R1,0                  ADJUST FOR EXECUTE\n         EX    R1,OBJMVC1            COPY FOR UNPACKING\n         UNPK  OBJOUT1(5),OBJIN(3)   UNPACK OBJECT CODE\n         MVZ   OBJOUT1,COMM0F0F      TURN OFF ZONES\n         TR    OBJOUT1,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   OBJOUT1+4,C' '        RESTORE THE BLANK\n         UNPK  OBJOUT2(5),OBJIN+2(3) UNPACK OBJECT CODE\n         MVZ   OBJOUT2,COMM0F0F      TURN OFF ZONES\n         TR    OBJOUT2,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   OBJOUT2+4,C' '        RESTORE THE BLANK\n         UNPK  OBJOUT3(5),OBJIN+4(3) UNPACK OBJECT CODE\n         MVZ   OBJOUT3,COMM0F0F      TURN OFF ZONES\n         TR    OBJOUT3,COMMHXCH      TRANSLATE TO PRINTABLE\n         MVI   OBJOUT3+4,C' '        RESTORE THE BLANK\n         SLL   R1,1                  MULTIPLY LENGTH BY 2\n         LA    R1,OBJLEN(R1)         TRANSLATE LENGTH TO OUTPUT LENGTH\n         LH    R1,0(R1)              OUTPUT LENGTH\n         EX    R1,OBJMVC2            COPY OUTPUT TO SOURCE AREA\n         LA    R1,SRCOPER            1ST OPERAND BYTE\n         ST    R1,GENADDR            SAVE CURRENT ADDRESS\n         BR    R9\nOBJMVC1  MVC   OBJIN(0),0(R4)        COPY DATA TO BE DISPLAYED\nOBJMVC2  MVC   SRCOBJ1(0),OBJOUT1    COPY DATA TO BE DISPLAYED\n* ------------------------------------------------------------------- *\n*        Copy assembler input statements                              *\n* ------------------------------------------------------------------- *\nGEN0700  DS    0H\n         TM    COMMFLAG,$ASMIN       ANY ASSEMBLER INPUT?\n         BNO   GEN0730               NO\n         ITRACE ID=ASMIN             COPYING ASSEMBLER INPUT\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         OPEN  (SYSIN,INPUT)         OPEN SYSIN\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\nGEN0710  DS    0H\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         GET   SYSIN                 READ A SYSIN STATEMENT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         MVC   SRCLABL(80),0(R1)     COPY TO SOURCE STATEMENT AREA\n         BAL   R9,PUNCH000           COPY TO PUNCH FILE\n         B     GEN0710               LOOP\nGEN0720  DS    0H\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         ITRACE ID=ASMINEND          END OF SYSIN REACHED\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         CLOSE SYSIN                 CLOSE SYSIN\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         B     GEN0800\nGEN0730  DS    0H\n         ITRACE ID=NOASMIN           NO ASSEMBLER INPUT TO COPY\n* ------------------------------------------------------------------- *\n*        Generate REGEQU statement                                    *\n* ------------------------------------------------------------------- *\nGEN0800  DS    0H\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE STATEMENT\n         MVC   SRCMNEM(L'REGEQU),REGEQU\n         BAL   R9,PUNCH000           PUNCH STATEMENT\n* ------------------------------------------------------------------- *\n*        Generate END statement                                       *\n* ------------------------------------------------------------------- *\n         DS    0H\n         MVC   SRC(SRCL),SRC-1       CLEAR SOURCE STATEMENT\n         MVC   SRCMNEM,ENDOPCD       SET OPCODE 'END'\n         MVC   SRCOPER(L'COMMCSNM),COMMCSNM\n         BAL   R9,PUNCH000           PUNCH END STATEMENT\n         B     EXIT0000              ALL DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RR format 1 instructions                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRR100 DS    0H\n         ITRACE ID=GENRR1            GENERATE SVC FORMAT INSTRUCTION\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT REGISTERS\n         SRL   R14,4                 SHIFT R1 TO LOW BITS\n         STC   R14,WORKREG           SET REGISTER\n         BAL   R15,GENREG00          GENERATE R1\n         BAL   R15,GENCOMMA          INSERT COMMA\n         MVC   WORKREG,1(R4)         COPY R1 AND R2\n         NI    WORKREG,X'0F'         LEAVE ONLY R2\n         BAL   R15,GENREG00          GENERATE R2\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RR format 2 instructions                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRR200 DS    0H\n         ITRACE ID=GENRR2            GENERATE SVC FORMAT INSTRUCTION\n         XC    WORKNBR,WORKNBR       CLEAR NUMERIC\n         MVC   WORKNBR+3(1),1(R4)    COPY SVC NUMBER\n         BAL   R15,GENNBR00          GENERATE SVC NUMBER\n         TM    OPFLAGS,$OPSVC        IS THIS AN SVC?\n         BNO   GEN0350               NOPE\n         L     R1,ASVCDESC           SVC DESCRIPTIONS\n         USING SVCDSECT,R1           DEFINE BASE\nGENRR210 DS    0H\n         CLI   SVCLEN,X'FF'          END OF TABLE?\n         BE    GEN0350               YES.. NO SVC COMMENT\n         CLC   SVCNBR,1(R4)          SVC NUMBER LOCATED?\n         BE    GENRR220              YES\n         AH    R1,SVCLEN             NEXT SVC\n         B     GENRR210              LOOP\nGENRR220 DS    0H\n         SR    R15,R15               CLEAR REGISTER\n         ICM   R15,3,SVCCMNTL        COMMENT'S LENGTH\n         BCTR  R15,0                 MINUS 1\n         MVC   OPCMNT,COMMBLKS       INITIALIZE COMMENT\n         EX    R15,SVCCMVC           MOVE SVC COMMENT\n         B     GEN0350               COMPLETE\nSVCCMVC  MVC   OPCMNT(0),SVCCMNT     SET COMMENT\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RR branch instructions                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRR300 DS    0H\n         ITRACE ID=GENRRBR           GENERATE RR MASK TYPE INSTRUCTION\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT MASK\n         SRL   R14,4                 SHIFT TO LOW BITS\n         XC    WORKNBR,WORKNBR       ZERO BYTE 1-3\n         STC   R14,WORKNBR+3         SET BYTE 4\n         TM    SAVEFLAG,$OPCCA       ARITHMETIC MNEMONICS?\n         BO    GENRR310              YES\n         TM    SAVEFLAG,$OPCCC       COMPARE MNEMONICS?\n         BO    GENRR320              YES\n         LA    R1,GENRRCCL           LOGICAL EXTENDED MNEMONICS\n         B     GENRR330\nGENRR310 DS    0H\n         LA    R1,GENRRCCA           ARITHMETIC EXTENDED MNEMONICS\n         B     GENRR330\nGENRR320 DS    0H\n         LA    R1,GENRRCCC           COMPARE EXTENDED MNEMONICS\nGENRR330 DS    0H\n         CLI   0(R1),X'FF'           EXTENDED MNEMONIC NOT FOUND?\n         BE    GENRR340              NO\n         CLM   R14,1,0(R1)           MASK FOUND?\n         BE    GENRR350              YES\n         LA    R1,7(R1)              NEXT MASK/EXTENDED MNEMONIC\n         B     GENRR330              LOOP\nGENRR340 DS    0H\n         BAL   R15,GENNBR00          GENERATE MASK VALUE\n         BAL   R15,GENCOMMA          INSERT COMMA\n         B     GENRR360              GENERATE OPERAND\nGENRR350 DS    0H\n         MVC   SRCMNEM,1(R1)         SET EXTENDED MNEMONIC\nGENRR360 DS    0H\n         MVC   WORKREG,1(R4)         COPY REGISTER\n         NI    WORKREG,X'0F'         LEAVE ONLY REGISTER VALUE\n         BAL   R15,GENREG00          GENERATE REGISTER\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RX format instructions                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRX00  DS    0H\n         ITRACE ID=GENRX             GENERATE RX FORMAT INSTRUCTION\n         TM    OPFLAGS,$OPEXT        EXTENDED FORMATS?\n         BO    GENB000               YES\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT R1 AND INDEX REGISTER\n         SRL   R14,4                 SHIFT R1 INTO LOW BITS\n         STC   R14,WORKREG           SET REGISTER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         BAL   R15,GENCOMMA          INSERT COMMA\n         MVC   WORKX,1(R4)           COPY INDEX REGISTER\n         NI    WORKX,X'0F'           LEAVE ONLY INDEX REGISTER VALUE\n         MVI   WORKOPER,$OPER1+$OPERNDX\n         BAL   R9,GENOP000           GENERATE OPERAND\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate S format instructions                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENS00   DS    0H\n         ITRACE ID=GENS              GENERATE S FORMAT INSTRUCTION\n         MVI   WORKOPER,$OPER1       SET OPERAND 1\n         BAL   R9,GENOP000           GENERATE OPERAND\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate BRANCH instructions                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENB000  DS    0H\n         ITRACE ID=GENBRNCH          GENERATE BRANCH INSTRUCTIONS\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT CONDITION CODE AND REGISTER\n         SRL   R14,4                 SHIFT MASK INTO LOW BITS\n         XC    WORKNBR,WORKNBR       ZERO BYTE 1\n         STC   R14,WORKNBR+3         SET BYTE 4\n         TM    SAVEFLAG,$OPCCA       ARITHMETIC MNEMONICS?\n         BO    GENB010               YES\n         TM    SAVEFLAG,$OPCCC       COMPARE MNEMONICS?\n         BO    GENB020               YES\n         LA    R1,GENBCCL            RR FORM3 EXTENDED MNEMONIC TABLE\n         B     GENB030\nGENB010  DS    0H\n         LA    R1,GENBCCA            ARITHMETIC MNEMONICS\n         B     GENB030\nGENB020  DS    0H\n         LA    R1,GENBCCC            COMPARE MNEMONICS\nGENB030  DS    0H\n         CLI   0(R1),X'FF'           EXTENDED MNEMONIC NOT FOUND?\n         BE    GENB040               NO\n         CLM   R14,1,0(R1)           MASK FOUND?\n         BE    GENB050               YES\n         LA    R1,7(R1)              NEXT MASK/EXTENDED MNEMONIC\n         B     GENB030               LOOP\nGENB040  DS    0H\n         MVC   SRCMNEM,BCOPCD        SET OPCODE TO 'BC'\n         BAL   R15,GENNBR00          GENERATE MASK\n         BAL   R15,GENCOMMA          GENRATE COMMA\n         B     GENB060\nGENB050  DS    0H\n         MVC   SRCMNEM,1(R1)         SET EXTENDED MNEMONIC\nGENB060  DS    0H\n         MVI   WORKOPER,$OPER1+$OPERNDX\n         MVC   WORKX,1(R4)           COPY INDEX REGISTER\n         NI    WORKX,X'0F'           LEAVE ONLY INDEX REGISTER VALUE\n         BAL   R9,GENOP000           GENERATE OPERAND\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate SI format instructions                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENSI00  DS    0H\n         ITRACE ID=GENSI             GENERATE SI FORMAT INSTRUCTION\n         MVI   WORKOPER,$OPER1       OPERAND 1\n         BAL   R9,GENOP000           GENERATE OPERAND\n         L     R15,GENADDR           CURRENT OUTPUT ADDRESS\n         CLC   DISPI,DISPR           LABEL REFERENCE?\n         BNE   GENSI30               NO\n         OC    REFDISP1,REFDISP1     DISPLACEMENT ZERO?\n         BNZ   GENSI30               NO\n         ICM   R2,15,REFOPER1        LABEL REFERENCE?\n         BZ    GENSI30               LABEL NOT REFERENCED\n         DROP  R5\n         USING LABLDSCT,R2           DEFINE BASE\n         ICM   R1,15,LABLEQU         FIRST EQUATE\n         USING EQUDATA,R1            DEFINE BASE\n         BZ    GENSI30\nGENSI10  DS    0H\n         CLC   EQUVALUE,1(R4)        EQUATE VALUE MATCH?\n         BE    GENSI20               YES\n         ICM   R1,15,EQUNEXT         NEXT EQUATE BLOCK\n         BNZ   GENSI10               LOOP\n         B     GENSI30\nGENSI20  DS    0H\n         MVI   0(R15),C','           INSERT COMMA\n         MVC   1(8,R15),EQULABEL     INSERT LABEL\n         B     GEN0350               COMPLETE\nGENSI30  DS    0H\n         MVC   0(3,R15),GENSIDLM     INSERT COMMA AND X'\n         MVC   3(2,R15),SRCOBJ1+2    COPY THE VALUE\n         MVI   5(R15),C''''          INSERT CLOSING QUOTE\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RS format instructions (SHIFTS)               *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRS100 DS    0H\n         ITRACE ID=GENRS1            GENERATE SHIFT TYPE INSTRUCTIONS\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT R1\n         SRL   R14,4                 SHIFT R1 INTO LOW BITS\n         STC   R14,WORKREG           SET REGISTER NUMBER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVI   WORKOPER,$OPER1       OPERAND 1\n         BAL   R9,GENOP000           GENERATE OPERAND\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RS format instructions (BXH, BXLE, ..)        *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRS200 DS    0H\n         ITRACE ID=GENRS2            GENERATE BXH, BXLE, ..\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT R1\n         SRL   R14,4                 SHIFT R1 INTO LOW BITS\n         STC   R14,WORKREG           SET REGISTER NUMBER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVC   WORKREG,1(R4)         SET R3\n         NI    WORKREG,X'0F'         LEAVE ONLY R3\n         BAL   R15,GENREG00          GENERATE REGISTER\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVI   WORKOPER,$OPER1       OPERAND 1\n         BAL   R9,GENOP000           GENERATE OPERAND\n         B     GEN0350               DONE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate RS format instructions (CLM, ICM, ..)         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENRS300 DS    0H\n         ITRACE ID=GENRS3            GENERATE CLM, ICM..\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT R1\n         SRL   R14,4                 SHIFT R1 INTO LOW BITS\n         STC   R14,WORKREG           SET REGISTER NUMBER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         XC    WORKNBR,WORKNBR       SET WORK NUMERIC\n         MVC   WORKNBR+3(1),1(R4)    COPY MASK\n         NI    WORKNBR+3,X'0F'       LEAVE ONLY MASK\n         BAL   R15,GENNBR00          GENERATE MASK\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVI   WORKOPER,$OPER1       SET FOR OPERAND 1\n         BAL   R9,GENOP000           GENERATE LABEL\n         B     GEN0350               DONE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate SS character instructions                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENSS100 DS    0H\n         ITRACE ID=GENSS1            GENERATE SS CHARACTER INSTRUCTIONS\n         MVC   WORKX,1(R4)           SET LENGTH\n         MVI   WORKOPER,$OPER1+$OPERL\n         BAL   R9,GENOP000           GENERATE LABEL 1\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVI   WORKOPER,$OPER2       OPERAND 2, NO LENGTH\n         BAL   R9,GENOP000           GENERATE LABEL 2\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate SS packed decimal instructions                *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENSS200 DS    0H\n         ITRACE ID=GENSS2            GENERATE SS CHARACTER INSTRUCTIONS\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,1(R4)              INSERT LENGTHS\n         SRL   R1,4                  SHIFT L1 TO LOW BITS\n         STC   R1,WORKX              SET LENGTH 1\n         MVI   WORKOPER,$OPER1+$OPERL\n         BAL   R9,GENOP000           GENERATE OPERAND 1\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVC   WORKX,1(R4)           COPY LENGTHS\n         NI    WORKX,X'0F'           LEAVE ONLY L2\n         MVI   WORKOPER,$OPER2+$OPERL\n         BAL   R9,GENOP000           GENERATE OPERAND 2\n         B     GEN0350               COMPLETE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate SS (MVCP, MVCS, MVCK)                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENSS300 DS    0H\n         ITRACE ID=GENSS3            GENERATE SS CHARACTER INSTRUCTIONS\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT R1 AND R3\n         SRL   R14,4                 SHIFT R1 TO LOW BITS\n         STC   R14,WORKX             SET R1 AS IF AN INDEX REGISTER\n         MVI   WORKOPER,$OPER1+$OPERNDX\n         BAL   R9,GENOP000           GENERATE OPERAND\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVI   WORKOPER,$OPER2       OPERAND 2\n         BAL   R9,GENOP000           GENERATE OPERAND\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVC   WORKREG,1(R4)         COPY R1 AND R3\n         NI    WORKREG,X'0F'         LEAVE ONLY R3\n         BAL   R15,GENREG00          GENERATE R3\n         B     GEN0350               COMPLETE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate SS (SRP)                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENSS400 DS    0H\n         ITRACE ID=GENSS4            GENERATE SS CHARACTER INSTRUCTIONS\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,1(R4)             INSERT R1 AND R3\n         SRL   R14,4                 SHIFT R1 TO LOW BITS\n         STC   R14,WORKX             SET R1 AS IF AN INDEX REGISTER\n         MVI   WORKOPER,$OPER1+$OPERL\n         BAL   R9,GENOP000           GENERATE OPERAND\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVI   WORKOPER,$OPER2       OPERAND 2\n         BAL   R9,GENOP000           GENERATE OPERAND\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVC   WORKREG,1(R4)         COPY R1 AND R3\n         NI    WORKREG,X'0F'         LEAVE ONLY R3\n         BAL   R15,GENREG00          GENERATE R3\n         B     GEN0350               COMPLETE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate B2 with no operand format                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENB2000 DS    0H\n         ITRACE ID=GENB2             GENERATE B2\n         B     GEN0350               COMPLETE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate B2 \"S\" format                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENB2S00 DS    0H\n         ITRACE ID=GENB2S            GENERATE B2 \"S\" FORMAT\n         MVI   WORKOPER,$OPER1       SET OPERAND 1\n         BAL   R9,GENOP000           GENERATE OPERAND\n         B     GEN0350               COMPLETE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate B2 \"R\" format                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENB2R00 DS    0H\n         ITRACE ID=GENB2R            GENERATE B2 \"R\" FORMAT\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,3(R4)             INSERT REGISTER\n         SRL   R14,4                 SHIFT TO LOW BITS\n         STC   R14,WORKREG           SET REGISTER\n         BAL   R15,GENREG00          GENERATE REGISTER\n         B     GEN0350               COMPLETE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate B2 \"RR\" format                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENB2RR0 DS    0H\n         ITRACE ID=GENB2RR           GENERATE B2 \"RR\" FORMAT\n         SR    R14,R14               CLEAR REGISTER\n         IC    R14,3(R4)             INSERT REGISTER\n         SRL   R14,4                 SHIFT TO LOW BITS\n         STC   R14,WORKREG           SET REGISTER\n         BAL   R15,GENREG00          GENERATE REGISTER R1\n         BAL   R15,GENCOMMA          GENERATE COMMA\n         MVC   WORKREG,3(R4)         COPY R1 AND R2\n         NI    WORKREG,X'0F'         CLEAR REGISTER R1\n         BAL   R15,GENREG00          GENERATE REGISTER R2\n         B     GEN0350               COMPLETE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate COMMAs                                        *\n*                                                                     *\n*   R15 is the return address                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENCOMMA DS    0H\n         L     R14,GENADDR           CURRENT ADDRESS\n         MVI   0(R14),C','           INSERT COMMA\n         LA    R14,1(R14)            NEXT\n         ST    R14,GENADDR           SAVE ADDRESS\n         BR    R15                   DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate OPEN parenthesis                              *\n*                                                                     *\n*   R15 is the return address                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENPRN1  DS    0H\n         L     R14,GENADDR           CURRENT ADDRESS\n         MVI   0(R14),C'('           INSERT OPEN PARENTHESIS\n         LA    R14,1(R14)            NEXT\n         ST    R14,GENADDR           SAVE ADDRESS\n         BR    R15                   DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate CLOSE parenthesis                             *\n*                                                                     *\n*   R15 is the return address                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENPRN2  DS    0H\n         L     R14,GENADDR           CURRENT ADDRESS\n         MVI   0(R14),C')'           INSERT CLOSE PARENTHESIS\n         LA    R14,1(R14)            NEXT\n         ST    R14,GENADDR           SAVE ADDRESS\n         BR    R15                   DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate REGISTERS                                     *\n*                                                                     *\n*   WORKREG  is the value of the register to Generate                 *\n*                                                                     *\n*   R15 is the return address                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENREG00 DS    0H\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,WORKREG            INSERT REGISTER VALUE\n         SLL   R1,1                  MULTIPLY BY 2\n         LA    R1,COMMNBR(R1)\n         L     R14,GENADDR           CURRENT ADDRESS IN OPER AREA\n         MVI   0(R14),C'R'           SET REGISTER PREFIX\n         MVC   1(2,R14),0(R1)        COPY REGISTER VALUE\n         LA    R14,2(R14)            MINIMUM LENGTH\n         CLI   0(R14),C' '           BLANK?\n         BE    GENREG10              YES\n         LA    R14,1(R14)            2 DIGIT REGISTER NUMBER\nGENREG10 DS    0H\n         ST    R14,GENADDR           SAVE CURRENT ADDRESS\n         BR    R15                   DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate data operands with or without index           *\n*                                                                     *\n*   WORKOPER flags control Generated source                           *\n*                                                                     *\n*   R9 is the return address                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENOP000 DS    0H\n         CLC   DISPI,DISPR           LABEL REFERENCE?\n         BNE   GENOP070              NO\n         TM    WORKOPER,$OPER2       OPERAND 2?\n         BO    GENOP010              YES\n         MVC   WORKNBR,REFDISP1      COPY DISPLACEMENT\n         ICM   R2,15,REFOPER1        LABEL REFERENCE?\n         BZ    GENOP080              LABEL NOT REFERENCED\n         B     GENOP020\nGENOP010 DS    0H\n         MVC   WORKNBR,REFDISP2      COPY DISPLACEMENT\n         ICM   R2,15,REFOPER2        LABEL REFERENCE?\n         BZ    GENOP090              LABEL NOT REFERENCED\nGENOP020 DS    0H\n         L     R14,GENADDR           CURRENT ADDRESS IN SRCOPER\n         MVC   0(L'LABLNAME,R14),LABLNAME\nGENOP030 DS    0H\n         CLI   0(R14),C' '           BLANK?\n         BE    GENOP040              YES\n         LA    R14,1(R14)            NEXT\n         B     GENOP030              LOOP\nGENOP040 DS    0H\n         ST    R14,GENADDR           SAVE ADDRESS\n         OC    WORKNBR,WORKNBR       DISPLACEMENT ZERO?\n         BZ    GENOP050              YES, DIRECT REFERENCE\n         MVI   0(R14),C'+'           INSERT PLUS\n         LA    R14,1(R14)            NEXT\n         ST    R14,GENADDR           SAVE ADDRESS\n         BAL   R15,GENNBR00          GENERATE DISPLACEMENT\nGENOP050 DS    0H\n         TM    WORKOPER,$OPERL       LENGTH WITH OPERAND?\n         BO    GENOP060              YES\n         TM    WORKOPER,$OPERNDX     INDEX WITH OPERAND?\n         BNOR  R9                    NO, DONE\n         CLI   WORKX,0               INDEX ZERO?\n         BER   R9                    YES\n         BAL   R15,GENPRN1           OPEN PARENTHESIS\n         MVC   WORKREG,WORKX         SET REGISTER\n         BAL   R15,GENREG00          GEN REGISTER\n         BAL   R15,GENPRN2           CLOSE PARENTHESIS\n         BR    R9                    DONE\nGENOP060 DS    0H\n         BAL   R15,GENPRN1           OPEN PARENTHESIS\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,WORKX              INSERT LENGTH\n         LA    R1,1(R1)              PLUS 1\n         STCM  R1,15,WORKNBR         SET LENGTH\n         BAL   R15,GENNBR00          GEN LENGTH\n         BAL   R15,GENPRN2           CLOSE PARENTHESIS\n         BR    R9                    DONE\nGENOP070 DS    0H\n         TM    WORKOPER,$OPER2       OPERAND 2?\n         BO    GENOP090              YES\nGENOP080 DS    0H\n         XC    WORKNBR,WORKNBR       CLEAR WORK NUMERIC\n         MVC   WORKNBR+2(2),2(R4)    COPY DISPLACEMENT\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,2(R4)              INSERT BASE 1\n         B     GENOP100\nGENOP090 DS    0H\n         XC    WORKNBR,WORKNBR       CLEAR WORK NUMERIC\n         MVC   WORKNBR+2(2),4(R4)    COPY DISPLACEMENT\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,4(R4)              INSERT BASE 2\nGENOP100 DS    0H\n         NI    WORKNBR+2,X'0F'       LEAVE ONLY DISPLACEMENT\n         SRL   R1,4                  SHIFT TO LOW BITS\n         STC   R1,WORKBASE           SAVE BASE\n         BAL   R15,GENNBR00          GENERATE DISPLACEMENT\n         TM    WORKOPER,$OPERL       LENGTH WITH OPERAND?\n         BO    GENOP120              YES\n         TM    WORKOPER,$OPERNDX     INDEX WITH OPERAND?\n         BNO   GENOP110              NO\n         OC    WORKX(2),WORKX        BASE AND INDEX ZERO?\n         BZR   R9                    YES, DONE\n         B     GENOP120\nGENOP110 DS    0H\n         CLI   WORKBASE,0            BASE ZERO?\n         BER   R9                    YES, DONE\nGENOP120 DS    0H\n         BAL   R15,GENPRN1           OPEN PARENTHESIS\n         TM    WORKOPER,$OPERNDX     INDEX?\n         BNO   GENOP140              NO\n         CLI   WORKX,0               INDEX ZERO?\n         BE    GENOP130              YES\n         MVC   WORKREG,WORKX         SET REGISTER\n         BAL   R15,GENREG00          GEN INDEX\n         CLI   WORKBASE,0            BASE ZERO?\n         BE    GENOP160              YES\nGENOP130 DS    0H\n         BAL   R15,GENCOMMA          GEN COMMA\nGENOP140 DS    0H\n         TM    WORKOPER,$OPERL       LENGTH PRESENT?\n         BNO   GENOP150              NO\n         SR    R1,R1                 CLEAR REGISTER\n         IC    R1,WORKX              INSERT LENGTH\n         LA    R1,1(R1)              PLUS 1\n         ST    R1,WORKNBR            SET LENGTH\n         BAL   R15,GENNBR00          GENERATE LENGTH\n         BAL   R15,GENCOMMA          GEN COMMA\nGENOP150 DS    0H\n         CLI   WORKBASE,0            BASE ZERO?\n         BE    GENOP160              YES\n         MVC   WORKREG,WORKBASE      SET REGISTER\n         BAL   R15,GENREG00          GENERATE BASE REGISTER\nGENOP160 DS    0H\n         BAL   R15,GENPRN2           CLOSING PARENTHESIS\n         BR    R9                    DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              Generate lengths/displacements                         *\n*                                                                     *\n*   WORKNBR will be set to the length or displacement value           *\n*                                                                     *\n*   R15 is the return address                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nGENNBR00 DS    0H\n         STCM  R15,15,GENNBRSV       SAVE R15\n         L     R1,WORKNBR            DISPLACEMENT VALUE\n         CVD   R1,COMMDWRD           CONVERT TO DECIMAL\n         MVC   DISPWORK,DISPEDWD     INITIALIZE WITH EDIT WORD\n         ED    DISPWORK,COMMDWRD+2   EDIT DISPLACEMENT\n         L     R14,GENADDR           CURRENT OUTPUT ADDRESS\n         LA    R15,DISPWORK+2        FIRST POSSIBLE DIGIT\n         LA    R1,10                 MAXIMUM DIGITS\nGENNBR10 DS    0H\n         CLI   0(R15),C' '           BLANK?\n         BE    GENNBR20              YES\n         MVC   0(1,R14),0(R15)       COPY THE DIGIT\n         LA    R14,1(R14)            NEXT\nGENNBR20 DS    0H\n         LA    R15,1(R15)            NEXT\n         BCT   R1,GENNBR10           LOOP\n         ST    R14,GENADDR           SAVE ADDRESS\n         ICM   R15,15,GENNBRSV       RESTORE R15\n         BR    R15                   DONE\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nERR0010  DS     0H\n         MVC   PRTDATA(EMSG01L),EMSG01\n         OI    COMMFLAG,$ERROR\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     EXIT0000              AND EXIT\nERR0020  DS    0H\n         MVC   PRTDATA(EMSG02L),EMSG02\n         OI    COMMFLAG,$ERROR\n         BAL   R9,PRT0000            PRINT MESSAGE\n         DC    H'0'\n         B     EXIT0000              AND EXIT\nERR0030  DS    0H\n         MVC   PRTDATA(EMSG03L),EMSG03\n         OI    COMMFLAG,$ERROR\n         BAL   R9,PRT0000            PRINT MESSAGE\n         B     EXIT0000              AND EXIT\nERR0040  DS    0H\n         MVC   PRTDATA(EMSG04L),EMSG04\n         OI    COMMFLAG,$ERROR\n         BAL   R9,PRT0000            PRINT MESSAGE\n         ABEND ABEND005,DUMP,,USER   ABEND\nPUNCH000 DS    0H\n         TM    COMMDD,$PUNCHDD       IS DISPUNCH DD PRESENT?\n         BNOR  R9                    NO\n         BAL   R14,AM24              SWITCH TO 24-BIT MODE\n         PUT   DISPUNCH,SRCLABL      PUNCH SOURCE STATEMENT\n         BAL   R14,AM31              SWITCH TO 31-BIT MODE\n         BR    R9                    RETURN\nPRT0000  DS    0H\n         TM    PRTFLAG,$SUBH         HAS SUB-HEADING BEEN PRINTED?\n         BO    PRT0010               YES\n         OI    PRTFLAG,$SUBH         SET FLAG\n         MVI   PRTCMD,$PRTHEAD       SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\nPRT0010  DS    0H\n         MVI   PRTCMD,$PRTPRT        SET COMMAND\n         LA    R1,PRTBLOK            SET PARAMETER BLOCK ADDRESS\n         L     R15,APR               PRINT MODULE ENTRY POINT\n         BALR  R14,R15               LINK TO PRINT MODULE\n         BR    R9                    RETURN\nEXIT0000 DS    0H\n         ITRACE ID=EXIT\n         L     R13,4(R13)            RESTORE REGISTER 13\n         LM    R14,R12,12(R13)       RESTORE ALL OTHER REGISTERS\n         SR    R15,R15               GIVE GOOD RETURN CODE\n         BR    R14                   RETURN TO CALLER\nAM24     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         BSM   R0,R14             RETURN IN 24-BIT MODE\nAM31     DS    0H\n         LA    R14,0(R14)         CLEAR HIGH BIT(S)\n         O     R14,X80            SET 31-BIT MODE\n         BSM   R0,R14             RETURN IN 31-BIT MODE\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EXECUTED INSTRUCTIONS                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nNPRTTRT  TRT   0(0,R4),COMMNPRT      SCAN NON-PRINTABLE\nPRTTRT   TRT   0(0,R4),COMMPRT       SCAN PRINTABLE\nCHDCMVC  MVC   SRCOPER+2(0),0(R4)    COPY CHARACTER DATA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nSAVE09   DC    18F'0'                REGISTER SAVE AREA\nX80      DC    A(X'80000000')\nASVCDESC DC    A(SVCDESC)            SVC DESCRIPTIONS\nFMTTABLE DS    0A\n         DC    A(GENRR100)           RR FORMAT 1\n         DC    A(GENRR200)           RR FORMAT 2 (SVC)\n         DC    A(GENRR300)           RR FORMAT 3 (MASK TYPE)\n         DC    A(GENRX00)            RX FORMAT\n         DC    A(GENS00)             S  FORMAT\n         DC    A(GENSI00)            SI FORMAT\n         DC    A(GENRS100)           RS FORMAT 1\n         DC    A(GENRS200)           RS FORMAT 2 (BXLE, BXH, ..)\n         DC    A(GENRS300)           RS FORMAT 3 (MASK TYPE-TM, CLM..)\n         DC    A(GENSS100)           SS FORMAT 1 (CHARACTER-CHARACTER)\n         DC    A(GENSS200)           SS FORMAT 2 (PACKED DECIMAL)\n         DC    A(GENSS300)           SS FORMAT 3 (MVCS, MVCP)\n         DC    A(GENSS400)           SS FORMAT 4 (SRP)\n         DC    A(GENB2000)           B2 WITH NO OPERAND\n         DC    A(GENB2S00)           B2 S FORMAT\n         DC    A(GENB2R00)           B2 R FORMAT\n         DC    A(GENB2RR0)           B2 RR FORMAT\n         SPACE 1\nGENADDR  DC    A(0)                  CURRENT ADDRESS IN SRCOPER AREA\n         SPACE 1\nGENNBRSV DC    A(0)                  R15 SAVE AREA FOR 'GENNBR'\n         SPACE 1\nDISPCNTL DS    0C\n         DC    CL8'INSTR'            EYECATCHER\nDISPI    DC    XL4'000000'           INSTRUCTION DISPLACEMENT\n         DC    CL8'LABEL'            EYECATCHER\nDISPL    DC    XL4'000000'           LABEL DISPLACEMENT\n         DC    CL8'DATA '            EYECATCHER\nDISPD    DC    XL4'000000'           DATA DISPLACEMENT\n         DC    CL8'REF  '            EYECATCHER\nDISPR    DC    XL4'000000'           REFERENCE DISPLACEMENT\n         SPACE 2\nWORKNBR  DC    XL4'00'               LENGTHS/DISPLACEMENTS WORK AREA\nWORKOPER DC    X'00'                 OPERAND TO GENERATE\n$OPER1   EQU   X'80'                 .. OPERAND 1\n$OPER2   EQU   X'40'                 .. OPERAND 2\n$OPERNDX EQU   X'20'                 .. INDEXED OPERAND\n$OPERL   EQU   X'10'                 .. OPERAND WITH LENGTH\nWORKX    DC    X'00'                 INDEX REGISTER OR LENGTH\nWORKBASE DC    X'00'                 BASE REGISTER\nWORKREG  DC    X'00'\n         SPACE 2\n* ------------------------------------------------------------------- *\n*           FLAG/SWITCH BYTES                                         *\n* ------------------------------------------------------------------- *\nPRTFLAG  DC    X'00'                 HEADING FLAGS\n$SUBH    EQU   X'80'                 .. SUBHEADING PRINTED\nSAVEFLAG DC    X'00'                 'FLAG' BYTE FOR EXTENDED MNEMONICS\n         SPACE 1\nAM31IND  DC    C'+X''80000000'')'\nAM31INDL EQU   *-AM31IND\n         SPACE 1\nDISPWORK DC    CL12' '\nDISPEDWD DC    X'402020202020202020202120'\nCSCTOPCD DC    CL6'CSECT'\nENTROPCD DC    CL6'ENTRY'\nDCOPCD   DC    CL6'DC'\nCXDOPCD  DC    CL6'CXD'\nDSOPCD   DC    CL6'DS'\nDROPOPCD DC    CL6'DROP'\nUSNGOPCD DC    CL6'USING'\nREGEQU   DC    C'COPY   REGEQU'\nENDOPCD  DC    CL6'END'\nBCOPCD   DC    CL6'BC'\nOPER0C   DC    CL02'0C'\nHEXDC    DC    C'X'''\nCHARDC   DC    C'C'''\nGENSIDLM DC    C',X'''               DELIMITER AND X'\nCHARZERO DC    CL8'00000000'         CONSTANT\nSUBHEAD  DS    0C\n         DC    CL08'  DISP  '\n         DC    CL02' '\n         DC    CL14'OBJECT CODE'\n         DC    CL05' '\n         DC    CL08' LABEL '\n         DC    CL01' '\n         DC    CL06'OPCODE'\n         DC    CL01' '\n         DC    CL25'OPERANDS'\n         DC    CL05' '\n         DC    CL07'COMMENT'\nSUBHEADL EQU   *-SUBHEAD\n         DC    C' '\nSRC      DS    0C\nSRCDISP  DC    CL08' '               DISPLACEMENT\n         DC    CL02' '\nSRCOBJ1  DC    CL04' '               OBJECT CODE BYTES 1 AND 2\n         DC    CL01' '\nSRCOBJ2  DC    CL04' '               OBJECT CODE BYTES 3 AND 4\n         DC    CL01' '\nSRCOBJ3  DC    CL04' '               OBJECT CODE BYTES 5 AND 6\n         DC    CL05' '\nSRCLABL  DC    CL08' '  01 - 08      LABEL\n         DC    CL01' '  09 - 09\nSRCMNEM  DC    CL06' '  10 - 15      MNEMONIC\n         DC    CL01' '  16 - 16\nSRCOPER  DC    CL35' '  17 - 51      OPERANDS\n         ORG   SRCLABL+46\nSRCCMNT  DC    CL25' '  46 - 71      COMMENTS\n         DC    CL01' '  72 - 72      CONTINUATION COLUMN\nSRCSEQ   DC    CL08' '  73 - 80      STATEMENT SEQUENCE NUMBER\nSRCL     EQU   *-SRC\nOBJIN    DC    CL8' '                INPUT STAGING AREA\nOBJOUT1  DC    CL4' '                OBJECT CODE BYTES 1 AND 2\n         DC    CL1' '\nOBJOUT2  DC    CL4' '                OBJECT CODE BYTES 3 AND 4\n         DC    CL1' '\nOBJOUT3  DC    CL4' '                OBJECT CODE BYTES 5 AND 6\n         DC    CL1' '\nOBJLEN   DS    0H\n         DC    H'01'                 02 BYTES OUT FOR 01 BYTE\n         DC    H'03'                 04 BYTES OUT FOR 02 BYTES\n         DC    H'06'                 07 BYTES OUT FOR 03 BYTES\n         DC    H'08'                 09 BYTES OUT FOR 04 BYTES\n         DC    H'11'                 12 BYTES OUT FOR 05 BYTES\n         DC    H'13'                 14 BYTES OUT FOR 06 BYTES\n         DC    H'13'                 14 BYTES OUT FOR 07 BYTES\n         DC    H'13'                 14 BYTES OUT FOR 08 BYTES\nEMSG01   DC    C'DISASM0901E Data area overlaps in instruction, should +\n               have been detected by DISASM08'\nEMSG01L  EQU   *-EMSG01\nEMSG02   DC    C'DISASM0902E Invalid opcode detected'\nEMSG02L  EQU   *-EMSG02\nEMSG03   DC    C'DISASM0903E DC with length = zero detected'\nEMSG03L  EQU   *-EMSG03\nEMSG04   DC    C'DISASM0904E Attempt to generate instruction on an odd +\n               address boundary'\nEMSG04L  EQU   *-EMSG04\n         SPACE 2\nGENRRCCA DS    0C                    COMPARE MNEMONICS\n         DC    X'00',CL6'NOPR  '     NO-OP\n         DC    X'01',CL6'BOR   '     BRANCH OVERFLOW\n         DC    X'02',CL6'BPR   '     BRANCH PLUS\n         DC    X'04',CL6'BMR   '     BRANCH MINUS\n         DC    X'07',CL6'BNZR  '     BRANCH NOT ZERO\n         DC    X'08',CL6'BZR   '     BRANCH IF ZERO\n         DC    X'0B',CL6'BNMR  '     BRANCH NOT MINUS\n         DC    X'0D',CL6'BNPR  '     BRANCH NOT PLUS\n         DC    X'0E',CL6'BNOR  '     BRANCH NOT OVERFLOW\n         DC    X'0F',CL6'BR    '     UNCONDITIONAL BRANCH\n         DC    X'FF'\nGENRRCCC DS    0C                    ARITHMETIC MNEMONICS\n         DC    X'00',CL6'NOPR  '     NO-OP\n         DC    X'02',CL6'BHR   '     BRANCH HIGH\n         DC    X'04',CL6'BLR   '     BRANCH LOW\n         DC    X'07',CL6'BNER  '     BRANCH NOT EQUAL\n         DC    X'08',CL6'BER   '     BRANCH EQUAL\n         DC    X'0B',CL6'BNLR  '     BRANCH NOT LOW\n         DC    X'0D',CL6'BNHR  '     BRANCH NOT HIGH\n         DC    X'0F',CL6'BR    '     UNCONDITIONAL BRANCH\n         DC    X'FF'\nGENRRCCL DS    0C                    LOGICAL MNEMONICS\n         DC    X'00',CL6'NOPR  '     NO-OP\n         DC    X'01',CL6'BOR   '     BRANCH ONES\n         DC    X'04',CL6'BMR   '     BRANCH MIXED\n         DC    X'07',CL6'BNZR  '     BRANCH NOT ZEROS\n         DC    X'08',CL6'BZR   '     BRANCH IF ZEROS\n         DC    X'0B',CL6'BNMR  '     BRANCH NOT MIXED\n         DC    X'0E',CL6'BNOR  '     BRANCH NOT ONES\n         DC    X'0F',CL6'BR    '     UNCONDITIONAL BRANCH\n         DC    X'FF'\nGENBCCA  DS    0C                    COMPARE MNEMONICS\n         DC    X'00',CL6'NOP   '     NO-OP\n         DC    X'01',CL6'BO    '     BRANCH OVERFLOW\n         DC    X'02',CL6'BP    '     BRANCH PLUS\n         DC    X'04',CL6'BM    '     BRANCH MINUS\n         DC    X'07',CL6'BNZ   '     BRANCH NOT ZERO\n         DC    X'08',CL6'BZ    '     BRANCH IF ZERO\n         DC    X'0B',CL6'BNM   '     BRANCH NOT MINUS\n         DC    X'0D',CL6'BNP   '     BRANCH NOT PLUS\n         DC    X'0E',CL6'BNO   '     BRANCH NOT OVERFLOW\n         DC    X'0F',CL6'B     '     UNCONDITIONAL BRANCH\n         DC    X'FF'\nGENBCCC  DS    0C                    ARITHMETIC MNEMONICS\n         DC    X'00',CL6'NOP   '     NO-OP\n         DC    X'02',CL6'BH    '     BRANCH HIGH\n         DC    X'04',CL6'BL    '     BRANCH LOW\n         DC    X'07',CL6'BNE   '     BRANCH NOT EQUAL\n         DC    X'08',CL6'BE    '     BRANCH EQUAL\n         DC    X'0B',CL6'BNL   '     BRANCH NOT LOW\n         DC    X'0D',CL6'BNH   '     BRANCH NOT HIGH\n         DC    X'0F',CL6'B     '     UNCONDITIONAL BRANCH\n         DC    X'FF'\nGENBCCL  DS    0C                    LOGICAL MNEMONICS\n         DC    X'00',CL6'NOP   '     NO-OP\n         DC    X'01',CL6'BO    '     BRANCH ONES\n         DC    X'04',CL6'BM    '     BRANCH MIXED\n         DC    X'07',CL6'BNZ   '     BRANCH NOT ZEROS\n         DC    X'08',CL6'BZ    '     BRANCH IF ZEROS\n         DC    X'0B',CL6'BNM   '     BRANCH NOT MIXED\n         DC    X'0E',CL6'BNO   '     BRANCH NOT ONES\n         DC    X'0F',CL6'B     '     UNCONDITIONAL BRANCH\n         DC    X'FF'\n*---------------------------------------------------------------------*\n*                                                                     *\n*              PRINT MODULE INTERFACE BLOCK                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRTBLOK  PRTBLOK  TYPE=CSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISPUNCH DCB   DDNAME=DISPUNCH,      SOURCE CODE PUNCHED OUTPUT        +\n               DSORG=PS,             .. SEQUENTIAL                     +\n               LRECL=80,             .. LRECL IS 80                    +\n               MACRF=PM              .. PUT-MOVE MODE\nSYSIN    DCB   DDNAME=SYSIN,         ASSEMBLER INPUT FILE              +\n               DSORG=PS,             .. SEQUENTIAL                     +\n               EODAD=GEN0720,        .. END OF DATA                    +\n               LRECL=80,             .. LRECL IS 80                    +\n               MACRF=GL              .. GET LOCATE MODE\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*              SVC DESCRIPTIONS                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nSVCDESC  DS    0C\n         SVCDEF 00,'EXCP/XDAP'\n         SVCDEF 01,'WAIT/WAITR/PRTOV'\n         SVCDEF 02,'POST'\n         SVCDEF 03,'EXIT'\n         SVCDEF 04,'GETMAIN'\n         SVCDEF 05,'FREEMAIN'\n         SVCDEF 06,'LINK/LINKX'\n         SVCDEF 07,'XCTL/XCTLX'\n         SVCDEF 08,'LOAD'\n         SVCDEF 09,'DELETE'\n         SVCDEF 0A,'GETMAIN/FREEMAIN'\n         SVCDEF 0B,'TIME'\n         SVCDEF 0C,'SYNCH/SYNCHX'\n         SVCDEF 0D,'ABEND'\n         SVCDEF 0E,'SPIE'\n         SVCDEF 0F,'ERREXCP'\n         SVCDEF 10,'PURGE'\n         SVCDEF 11,'RESTORE'\n         SVCDEF 12,'BLDL/FIND (TYPE D)'\n         SVCDEF 13,'OPEN'\n         SVCDEF 14,'CLOSE'\n         SVCDEF 15,'STOW'\n         SVCDEF 16,'OPEN (TYPE=J)'\n         SVCDEF 17,'CLOSE (TYPE=T)'\n         SVCDEF 18,'DEVTYPE'\n         SVCDEF 19,'TRKBAL'\n         SVCDEF 1A,'CATALOG/INDEX/LOCATE'\n         SVCDEF 1B,'OBTAIN'\n         SVCDEF 1D,'SCRATCH'\n         SVCDEF 1E,'RENAME'\n         SVCDEF 1F,'FEOV'\n         SVCDEF 20,'ALLOC'\n         SVCDEF 21,'IOHALT'\n         SVCDEF 22,'MGCR/QEDIT'\n         SVCDEF 23,'WTO/WTOR'\n         SVCDEF 24,'WTL'\n         SVCDEF 25,'SEGLD/SEGWT'\n         SVCDEF 27,'LABEL'\n         SVCDEF 28,'EXTRACT'\n         SVCDEF 29,'IDENTIFY'\n         SVCDEF 2A,'ATTACH/ATTACHX'\n         SVCDEF 2B,'CIRB'\n         SVCDEF 2C,'CHAP'\n         SVCDEF 2D,'OVLYBRCH'\n         SVCDEF 2E,'TIMER'\n         SVCDEF 2F,'STIMER'\n         SVCDEF 30,'DEQ'\n         SVCDEF 33,'SNAP/SNAPX/SDUMP/SDUMPX'\n         SVCDEF 34,'RESTART'\n         SVCDEF 35,'RELEX'\n         SVCDEF 36,'DISABLE'\n         SVCDEF 37,'EOV'\n         SVCDEF 38,'ENQ/RESERVE'\n         SVCDEF 39,'FREEDBUF'\n         SVCDEF 3A,'RELBUF/REQBUF'\n         SVCDEF 3B,'OLTEP'\n         SVCDEF 3C,'STAE/STAI-ESTAE/ESTAI'\n         SVCDEF 3D,'IKJEGS6A'\n         SVCDEF 3E,'DETACH'\n         SVCDEF 3F,'CHKPT'\n         SVCDEF 40,'RDJFCB'\n         SVCDEF 42,'BTAMTEST'\n         SVCDEF 44,'SYNADF/SYNADRLS'\n         SVCDEF 45,'BSP'\n         SVCDEF 46,'GSERV'\n         SVCDEF 47,'ASGNBFR/BUFINQ/RLSEBFR'\n         SVCDEF 49,'SPAR'\n         SVCDEF 4A,'DAR'\n         SVCDEF 4B,'DQUEUE'\n         SVCDEF 4C,'IFBSTAT'\n         SVCDEF 4E,'LSPACE'\n         SVCDEF 4F,'STATUS'\n         SVCDEF 51,'SETPRT'\n         SVCDEF 53,'SMFWTM'\n         SVCDEF 54,'GRAPHICS'\n         SVCDEF 55,'DDRSWAP'\n         SVCDEF 56,'ATLAS'\n         SVCDEF 57,'DOM'\n         SVCDEF 5B,'VOLSTAT'\n         SVCDEF 5C,'TCPEXCP'\n         SVCDEF 5D,'TGET/TPUT'\n         SVCDEF 5E,'TGET/TPUT'\n         SVCDEF 5F,'SYSEVENT'\n         SVCDEF 60,'STAX'\n         SVCDEF 61,'IKJEGS9G'\n         SVCDEF 62,'PROTECT'\n         SVCDEF 63,'DYNALLOC'\n         SVCDEF 64,'IKJEFFIB'\n         SVCDEF 65,'QTIP'\n         SVCDEF 66,'AQCTL'\n         SVCDEF 67,'XLATE'\n         SVCDEF 68,'TOPCTL'\n         SVCDEF 69,'IMGLIB'\n         SVCDEF 6B,'MODESET'\n         SVCDEF 70,'PGRLSE'\n         SVCDEF 71,'PGFIX/PGFREE/PGLOAD/PGOUT'\n         SVCDEF 72,'EXCPVR'\n         SVCDEF 75,'DEBCHK'\n         SVCDEF 77,'TESTAUTH'\n         SVCDEF 78,'GETMAIN/FREEMAIN'\n         SVCDEF 79,'VSAM'\n         SVCDEF 7B,'PURGEDQ'\n         SVCDEF 7C,'TPIO'\n         SVCDEF 7D,'EVENTS'\n         SVCDEF 7E,'MSS(ICB2SVC)'\n         SVCDEF 82,'RACHECK'\n         SVCDEF 83,'RACINIT'\n         SVCDEF 84,'RACLIST'\n         SVCDEF 85,'RACDEF'\n         SVCDEF 89,'ESR'\n         SVCDEF 8A,'PGSER'\n         SVCDEF 8B,'CVAFDIR'\n         DC    X'FF'\n         SPACE 2\n         LTORG\n         SPACE 2\n         COPY  DISASMDA\n*---------------------------------------------------------------------*\n*                                                                     *\n*              COMMON DATA MAP                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDISASM00 DISASM00 TYPE=DSECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*              SVC DSECT                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nSVCDSECT DSECT\nSVCLEN   DS   XL2                LENGTH OF THIS SVC DEFINITION\nSVCCMNTL DS   XL2                LENGTH OF DESCRIPTION\nSVCNBR   DS   X                  SVC NUMBER\nSVCCMNT  DS   0C                 DESCRIPTION\n*---------------------------------------------------------------------*\n*                                                                     *\n*              EQUATES                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         COPY REGEQU\n         END  DISASM09\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GRS": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x19\\x0f\\x00\\x99\\x19\\x0f\\x13\\x02\\x04\\x89\\x04\\x89\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-09T00:00:00", "modifydate": "1999-07-09T13:02:00", "lines": 1161, "newlines": 1161, "modlines": 0, "user": "PGILLIS"}, "text": "++USERMOD(L#FM105) REWORK(1998226)\n/*\n*\n*     Elements:    SRC   - GRS\n*                  PANEL - GRSDATA\n*                  PANEL - GRSTABLE\n*                  PANEL - GRSHELP1\n*                  PANEL - GRSHELP2\n*                  CLIST - GRSREXX\n*\n*     Purpose:     Enq Display program\n*\n*     Reference:   N/A\n*\n*     Environment: Zone:  MVS02T   Product:  Inhouse Code\n*\n*     WARNING:     N/A\n*\n*     Writer:      Paul Gillis\n*\n*     Date:        28/01/97\n*\n*     Change       Date      Inits  Description\n*     History:     ========  =====  ===========\n*\n*                  28/01/97  PGG    Initial Operation version\n*                  06/08/98  PGG    Added Panels and Rexx to assis\n*\n*/ .\n++VER(Z038) FMID(LBASE01) SUP(L#FM088).\n++JCLIN.\n//LKED     EXEC PGM=IEWL,REGION=2000K,\n//         PARM=(XREF,LIST,LET,NCAL,MAP,RENT,REUS,REFR)\n//AUSERMOD DD DSN=SYS1.AUSERMOD,DISP=SHR\n//SYSLMOD  DD DSN=MVS03T.LINKLIB,DISP=SHR\n//SYSLIN   DD *\n     INCLUDE AUSERMOD(GRS)\n     NAME GRS(R)\n++PNLENU(GRSTABLE) DISTLIB(AUSRPLIB) SYSLIB(ISRPLIB).\n)ATTR\n  @ TYPE(OUTPUT) INTENS(LOW) JUST(ASIS) CAPS(OFF)\n  $ TYPE(OUTPUT) INTENS(HIGH) JUST(ASIS) CAPS(OFF)\n 01 TYPE(OUTPUT) INTENS(HIGH) JUST(ASIS) CAPS(OFF)\n  _ TYPE(INPUT)\n  ! TYPE(INPUT) CAPS(OFF)\n)BODY EXPAND(\\\\)\n%-\\-\\- Enqueue Scan Utility -\\-\\-\n%COMMAND ===>_ZCMD                                      \\ \\   %SCROLL ===>_Z   %\n+\n+Job/User Type  System   Scope   Major    Minor Name\n-\\-\\-\n)MODEL\n@GRS\n)Init\n  .HELP = GRSHELP2\n)END\n++PNLENU(GRSDATA)  DISTLIB(AUSRPLIB) SYSLIB(ISRPLIB).\n)attr\n  @ type(output) color(green) intens(low) just(left) caps(on) padc('-')\n  # type(output) color(green) intens(low) just(left) caps(off)\n  ! type(input) intens(high) just(left) caps(on) padc('''')\n)body expand(\\\\)\n%-\\-\\- %Enqueue Scan Utility -\\-\\-\n%Command ===>_zcmd\n+\n+    Resource Major Name%===>_QNAME   %SYSDSN+for dataset ENQs,%*+for all ENQs\n+    Resource Minor Name%===>_RNAME\n+Limit to Jobname/Userid%===>_JNAME   +Enter the Full or Partial Jobname/Userid\n+         Limit to Scope%===>_SCOPE   %STEP, SYSTEM+or%SYSTEMS\n+\n+Note that the Resource Minor Name can be a partial name and all resources\n+that commence with the supplied name prefix will be displayed\n+Do not enclose any names in quotes\n+\n+To display all resources for a Job, use%*+for the Major and Minor names\n+\n+Press%Enter+to proceed,%End+to Exit\n)Init\n  VGET (QNAME RNAME JNAME SCOPE) SHARED\n  if (&qname = &z)\n     &qname = SYSDSN\n  if (&rname = &z & &qname = SYSDSN)\n     &rname = &ZUSER\n  .HELP = GRSHELP1\n)Proc\n  VER(&SCOPE,LIST,STEP,SYSTEM,SYSTEMS,*)\n  VPUT (QNAME RNAME JNAME SCOPE) SHARED\n)END\n++PNLENU(GRSHELP1) DISTLIB(AUSRPLIB) SYSLIB(ISRPLIB).\n)body expand(\\\\)\n%-\\-\\- %Enqueue Scan Utility -\\-\\-\n%Command ===>_zcmd\n+\n+If all entry fields are blank, a list of all Major Names will be displayed\n+\n%Resource Major Name+is a name that groups like resources together\n+\n%Resource Minor Name+is the actual name of the resource being ENQ'd upon\n+and need only contain the first few characters of the resource name\n+\n%Limit to Jobname/Userid+if supplied only the job or users ENQs will be listed\n+\n%Limit to Scope+if supplied will reduce the output to only those in scope\n+\n)END\n++PNLENU(GRSHELP2) DISTLIB(AUSRPLIB) SYSLIB(ISRPLIB).\n)body expand(\\\\)\n%-\\-\\- %Enqueue Scan Utility -\\-\\-\n%Command ===>_zcmd\n+\n+The displayed table has the following headings\n+\n%Job/User Type  System   Scope   Major    Minor Name\n+\n%Job/User  +The Jobname or Userid holding or waiting for an ENQ\n+\n%Type      +The type of ENQ,%EXC+Exclusive or%SHR+Shared%-W+Indicates waiting\n+\n%System    +The 4 character system name and an indicator of%L+ocal or%G+lobal\n+\n%Scope     +Scope is one of%STEP,SYSTEM+or%SYSTEMS\n+\n%Major     +The major name of the resource END'd upon\n+\n%Minor Name+The complete minor name of the resource ENQ'd upon\n)END\n++CLIST(GRSREXX)   DISTLIB(AUSRCLIB) SYSLIB(ISRCLIB).\n/* rexx */\n/*-------------------------------------------------------------------*/\n/* this exec is designed to fron end the GRS command processor by    */\n/* optionally displaying the GRSDATA panel to extract additional     */\n/* information from the user before invoking the GRS command.        */\n/*-------------------------------------------------------------------*/\n\naddress ISPEXEC\n\nqname = word(arg(1),1)\nrname = word(arg(1),2)\njname = word(arg(1),3)\nscope = word(arg(1),4)\n\nupper qname\n\nif qname ,= '' then count = 1\nif rname ,= '' then count = 2\nif jname ,= '' then count = 3\nif scope ,= '' then count = 4\n\n'VGET (ZUSER)'\n\nif qname = SYSDSN & rname = '' then rname = ZUSER\n\n'VPUT (QNAME RNAME JNAME SCOPE) SHARED'\n\nif count < 2 then do\n\n   'DISPLAY PANEL(GRSDATA)'\n   disrc = rc\n\n   do while disrc = 0\n\n     'VGET (QNAME RNAME JNAME SCOPE) SHARED'\n\n     'SELECT CMD(GRS' qname rname jname scope ')'\n\n     'DISPLAY PANEL(GRSDATA)'\n     disrc = rc\n   end\nend\nelse do\n  'SELECT CMD(GRS' qname rname jname scope ')'\nend\n++SRC(GRS) DISTLIB(AUSERSRC) DISTMOD(AUSERMOD).\nGRS      TITLE '- DISPLAY GRS QUEUE INFORMATION'\nGRS      CSECT                                                      PGG\nGRS      AMODE 24                                                   PGG\nGRS      RMODE 24                                                   PGG\n* THIS PROGRAM DOES NOT USE ANY EXTERNAL MACROS OF ITS OWN.\n*====================================================================*\n*                                                                    *\n*  FUNCTION: TSO CP TO DISPLAY MVS ENQUEUE STRUCTURE                 *\n*                                                                    *\n*                                                                    *\n*  ON ENTRY: R1  - PTR TO CPPL                                       *\n*            R13 - STANDARD SAVE AREA                                *\n*            R14 - RETURN ADDRESS                                    *\n*            R15 - ENTRANCE ADDRESS                                  *\n*                                                                    *\n*                                                                    *\n* DEPENDENCIES: MVS SP1.3 PUT LEVEL 8205                             *\n*                                                                    *\n*                                                                    *\n* CSECT NAME : GRS                                                   *\n* MODULE NAME: GRS                                                   *\n* ATTRIBUTES : REENTRANT ,REUSABLE                                   *\n*                                                                    *\n*                                                                    *\n* MACROS/DSECTS : GQSCAN, ISGRIB, IKJCPPL, IKJPSCB, IKJECT ,ENTER    *\n*                 EXIT                                               *\n*                                                                    *\n*                                                                    *\n* AUTHOR:  STEVE CULHANE                                             *\n* DATE  :  OCTOBER ,1982                                             *\n*                                                                    *\n* MODIFIED BY  : PAUL GILLIS                                         *\n* DATE         : JANUARY ,1992                                       *\n*    : UPDATE GQSCAN MACROS TO USE A QNAME LENGTH OF 8 FOR MVS/ESA   *\n*      8 IS SUPPOSED TO BE THE DEFAULT, BUT IT WOULD NOT ASSEMBLE OK *\n*    : INCREASED THE LENGTH OF THE WORK AREA BY A FACTOR OF 10       *\n*    : ADD GRS CSECT STATEMENT AT START OF PROGRAM TO REMOVE \"PC\"    *\n*    : INCREASED THE NUMBER OF MAJOR ENTRIES TO 120                  *\n*    : ADDED LOGIC TO DRIVE AN ISPF TABLE DISPLAY INSTEAD OF TPUTS   *\n*    : ADDED LOGIC TO SCAN THE RNAME FOR A CHARACTER STRING          *\n*    : MOVE THE PPL TO WORKING STORAGE TO MAKE GRS TRULY RE-ENTRANT  *\n*                                                                    *\n* MODIFIED BY  : PAUL GILLIS                                         *\n* DATE         : JANUARY ,1997                                       *\n*    : INCREASED THE NUMBER OF MAJOR ENTRIES TO 120                  *\n*    : TABLE SORT THE MAJOR NAME OUTPUT LIST                         *\n*                                                                    *\n*====================================================================*\n EJECT\n*====================================================================*\n*                                                                    *\n* COMMAND FORMAT:   GRS  MAJOR MINOR JOBNAME/USERID SCOPE            *\n*                                                                    *\n*       WHERE:   MAJOR    - MAJOR QUEUE NAME TO BE FOUND, MAX 8 CHAR.*\n*                           A '*' MAY BE GIVEN WHICH MEANS TO FIND   *\n*                           ALL MAJOR NAMES.                         *\n*                           A '#' PRECEDING ANY STRING DENOTES THIS  *\n*                           AS A SPECIAL COMMAND.                    *\n*                           THE VALID COMMANDS AREA:-                *\n*                           #LIST  - LIST ACTIVE MAJNODES (DEFAULT)  *\n*                           #SUM   - LIST MAJOR NAMES WITH STATS     *\n*                           #W     - LIST WAITING RESOURCES          *\n*                                                                    *\n*                MINOR    - IS THE MINOR QUEUE NAME TO BE FOUND,     *\n*                           MAX 47 CHAR.                             *\n*                           THE COMPARISON IS PERFORMED ON AS MANY   *\n*                           BYTES OF MINOR NAME AS ARE GIVEN IN      *\n*                           THE GRS COMMAND.                         *\n*                            A ''*'' MAY BE GIVEN WHICH MEANS TO     *\n*                           FIND ALL MINOR NAMES.                    *\n*                                                                    *\n*                JOBNAME  - IS THE JOBNAME OR USERID TO BE FOUND,    *\n*                           MAX 8 BYTES.                             *\n*                           THE COMPARISON IS PERFORMED ON AS MANY   *\n*                           AS MANY BYTES OF JOBNAME AS ARE GIVEN    *\n*                           IN THE GRS COMMAND.                      *\n*                           A ''*'' MAY BE GIVEN WHICH MEANS TO      *\n*                           FIND ALL JOBNAMES.                       *\n*                                                                    *\n*                SCOPE    - IS THE SCOPE OF THIS REQUEST             *\n*                           A ''*'' MAY BE GIVEN WHICH MEANS TO      *\n*                           LIST ALL SCOPES.                         *\n*                                                                    *\n*   NOTE ==> A ''#'' FOLLOWED BY A BLANK IN ANY OPERAND WILL         *\n*            SUPPRESS ALL DISPLAYS AND PLACE THE NUMBER OF ENTRIES   *\n*            FOUND IN REGISTER 15                                    *\n*                                                                    *\n* THE OUTPUT OF THE GRS COMMAND IS AS FOLLOWS.                       *\n*                                                                    *\n* JOB/USERID TYPE   SYSTEM  SCOPE   MAJOR MINOR                      *\n* JJJJJJJJ   TTT-W  SSSS-P  XXXXXXX XXXXXXXXXXX....X                 *\n* --------   --- -  ---- -  ------- ----------------                 *\n*                                                                    *\n*                                                                    *\n*                                                                    *\n*                                           __ RESOURCE MINOR NAME   *\n*                                                                    *\n*                                                                    *\n*                                                                    *\n*                               ______________ SCOPE OF REQUEST      *\n*                                              (STEP,SYSTEM OR       *\n*                                                          SYSTEMS)  *\n*                                                                    *\n*                         ____________________ GRS TYPE              *\n*                                                   (L = GLOBAL)     *\n*                                                   (G = GLOBAL)     *\n*                                                                    *\n*                                                                    *\n*                     ________________________ SYSTEM NAME OF        *\n*                                                    REQUESTOR       *\n*                                                                    *\n*                                                                    *\n*                 ____________________________ STATUS OF REQUEST     *\n*                                                   (W - WAITING)    *\n*                                                                    *\n*                                                                    *\n*              _______________________________ TYPE OF REQUEST       *\n*                                                   (SHR - SHARED)   *\n*                                                   (EXC - EXCLUSIVE)*\n*                                                   (RES - RESERVE)  *\n*                                                                    *\n*     ________________________________________ JOBNAME OF REQUESTOR  *\n*                                                                    *\n*====================================================================*\n         EJECT\n         MACRO\n&LABEL   ENTER &SAVEREG=(14,12),&PARMREG=R2,&BASEREG=R3,&GETMAIN=\n         LCLA  &COUNT\n         LCLC  &USING\n         GBLC  &GETLTH\n         GBLC  &GETSP\n&GETLTH  SETC  '&GETMAIN(1)'\n&GETSP   SETC  '&GETMAIN(2)'\n***********************************************************************\n*                                                                     *\n*        REGISTER EQUATES                                             *\n*                                                                     *\n***********************************************************************\n         YREGS\nF0       EQU   0\nF2       EQU   2\nF4       EQU   4\nF6       EQU   6\n&USING   SETC  '&SYSECT'\n         AIF   ('&LABEL' EQ '').NOLABEL\n&USING   SETC  '&LABEL'\n&LABEL   CSECT\n.NOLABEL ANOP\n         B     32(0,15)                     BRANCH AROUND CONSTANTS\n         DC    CL1' '\n         DC    CL9'&USING'                  CSECT NAME\n         DC    CL9'&SYSDATE'                DATE OF ASSEMBLY\n         DC    CL9'&SYSTIME'                TIME OF ASSEMBLY\n         AIF   ('&SAVEREG' EQ '').NOSAVE\n         SAVE  &SAVEREG                     SAVE REGISTERS\n         LR    &PARMREG,1                   SAVE PARAMETER POINTER\n&USING   SETC  '&USING,&BASEREG(1)'\n         LR    &BASEREG(1),15               SET UP FIRST BASE REGISTER\n         AIF   ('&BASEREG(2)' EQ '').USING\n&COUNT   SETA  1\n         LA    15,4095                      SET UP BASE REGISTERS ...\n.LOOP    LA    &BASEREG(&COUNT+1),1(15,&BASEREG(&COUNT))   SET BASE\n&USING   SETC  '&USING,&BASEREG(&COUNT+1)'\n&COUNT   SETA  &COUNT+1\n         AIF   ('&BASEREG(&COUNT+1)' NE '').LOOP\n.USING   USING &USING\n.NOSAVE  AIF   ('&GETMAIN(1)' EQ '').LOCAL\n         GETMAIN   R,LV=&GETMAIN(1),SP=&GETMAIN(2)\n         AGO   .COMMON\n.LOCAL   CNOP  0,4                          ALIGN TO WORD BOUNDARY\n         BAL   1,*+4+18*4                   SET SAVEAREA ADDRESS\n         DS    18A                          ALLOCATE SAVEAREA\n.COMMON  ST    13,4(0,1)                    SET BACKWARD POINTER\n         ST    1,8(0,13)                    SET FORWARD POINTER\n         LR    13,1                         SET SAVEAREA REGISTER\n         MEND\n         MACRO\n&LABEL   EXIT  &SAVEREG=(14,12),&RETCODE=0\n         GBLC  &GETLTH\n         GBLC  &GETSP\n         LCLC  &RR\n&RR      SETC  '&RETCODE'\n&LABEL   DC    0H'0'\n         AIF   ('&GETLTH' EQ '').NOFREE\n         LR    1,13                         SAVE SAVEAREA ADDRESS\n.NOFREE  L     13,4(0,13)                   RESTORE SAVEAREA\n         AIF   ('&GETLTH' EQ '').LOCAL\n         AIF   ('&SAVEREG' EQ '' OR '&RETCODE'(1,1) NE '(').FREE\n&RR      SETC  '&RETCODE'(2,1)\n         LR    14,&RR                      SAVE RETURN CODE\n.FREE    FREEMAIN  R,LV=&GETLTH,A=(1),SP=&GETSP\n         AIF   ('&SAVEREG' EQ '' OR '&RETCODE'(1,1) NE '(').LOCAL\n         LR    15,14                         RESTORE RETURN CODE\n&RR      SETC  '(15)'\n.LOCAL   AIF   ('&SAVEREG' EQ '').COMMON\n         L     14,12(13,0)                 RESTORE REGISTER 14\n         LM    0,12,20(13)                  RESTORE REGISTERS\n         MVI   12(13),X'FF'                SET RETURN INDICATION\n         AIF   ('&RETCODE'(1,1) EQ '(').FINALE\n         LA    15,&RR\n.FINALE  ANOP\n         BR    R14                         RETURN\n.COMMON  MEND\n         EJECT\nGRS      ENTER PARMREG=R2,BASEREG=R12,GETMAIN=WLEN\n         SPACE\n         USING WORKAREA,R13\n         MVC   MYID,=CL8'GRS'\n         MVI   FLAG1,X'00'\n                                       SPACE 1\n***********************************************************************\n*        CHECK TO SEE IF RUNNING UNDER ISPF OR NOT                    *\n***********************************************************************\n                                       SPACE 1\n         MVI   TPUT,0                  INDICATE NOT USING TPUT      PGG\n         MVI   VGRS,C' '               BLANK OUT THE ENTIRE LINE    PGG\n         MVC   VGRS+1(L'VGRS-1),VGRS                                PGG\n         LINK  EPLOC=ISPQRY            ASK ISPF IF ENVIRONMENT IS OKPGG\n         LTR   R15,R15                 WELL WAS IT                  PGG\n         BNZ   NOISPF                  ===> NO, SKIP ISPF PROCESSINGPGG\n         LOAD  EPLOC=ISPLINK           GET ISPF LINKAGE MODULE      PGG\n         ST    R0,EPLOC                SAVE ADDRESS FOR CALLS       PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(VDEFINE,CGRS,VGRS,CHAR,F79),VL,MF=(E,SPFCALL)  PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(VDEFINE,CHDR,VHDR,CHAR,F01),VL,MF=(E,SPFCALL)  PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(TBCREATE,GRSTABLE,0,CTBL,NOWRITE),             PGG*\n               VL,MF=(E,SPFCALL)                                    PGG\n         B     ALLDONE                 ===> TERMINATE PROGRAM       PGG\nNOISPF   DS    0H                                                   PGG\n         MVI   TPUT,1                  INDICATE USING TPUT          PGG\nALLDONE  DS    0H                                                   PGG\n                                       SPACE 1\n         EJECT\n*====================================================================*\n*                                                                    *\n*     ESTABLISH ADDRESSABILITY TO TSO CONTROL BLOCKS.                *\n*     INITIALIZE PARSE PARAMETER LIST                                *\n*     PARSE GRS COMMAND                                              *\n*                                                                    *\n*====================================================================*\n*\n         LR    R8,R2                    SAVE POINTER CPPL\n         USING CPPL,R8                  AND ESTABLISH BASE\n         L     R6,CPPLPSCB              PSCB ADDRESSABILITY\n         USING PSCB,R6\n         LA    R1,PPLECBS               SET UP THE PARSE PARM LIST  PGG\n         ST    R1,PPLECB                                            PGG\n         L     R1,=V(PCL)               SET UP THE PARSE PARM LIST  PGG\n         ST    R1,PPLPCL                                            PGG\n         LA    R1,PPLANS                SET UP THE PARSE PARM LIST  PGG\n         ST    R1,PPLANSWR                                          PGG\n*\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n         LA    R1,PPLUPT               POINT TO IT\n         LINK  EP=IKJPARS\n         B     *+4(R15)                BRANCH ON RETURNED CODE\n         B     PARSOK\n         B     ERROR1\n         B     EXIT                    USER ATTNED OUT\n         B     U1004                   PROGRAM BUG\n         B     ERROR2                  SPACE NOT AVAILABLE IN REGION\n         B     ERROR3                  INVALID PARM\n                       EJECT\n*====================================================================*\n*                                                                    *\n*     MOVE POSITIONAL PARAMETERS AND THEIR EXECUTE LENGTH TO OUR     *\n*     WORK AREA AND PASS CONTROL TO REQUIRED ROUTINE                 *\n*                                                                    *\n*====================================================================*\n*\nPARSOK   L     R7,PPLANS               CHECK ANSWER ADDRESS\n         LTR   R7,R7\n         BZ    U1004                   PARSE ERROR\n         MVC   MAJOR,BLANKS            CLEAR MAJOR SAVE AREA\n         MVC   MINOR,BLANKS            CLEAR MINOR SAVE AREA\n         MVC   JOBNAME,BLANKS          CLEAR JOBNAME SAVE AREA\n         USING IKJPARMD,R7\n         LH    R4,QNAME+4              GET LENGTH OF MAJOR\n         BCTR  R4,0                     SUBTRACT 1 FOR EXECUTE\n         STH   R4,MAJORL               SAVE IT\n         L     R3,QNAME                ----> MAJOR\n         EX    R4,MMAJOR\n         LH    R4,RNAME+4              GET LENGTH OF MINOR\n         BCTR  R4,0                     SUBTRACT 1 FOR EXECUTE\n         STH   R4,MINORL               SAVE IT\n         L     R3,RNAME                ----> MINOR\n         EX    R4,MMINOR\n         LH    R4,JNAME+4              GET LENGTH OF MINOR\n         BCTR  R4,0                     SUBTRACT 1 FOR EXECUTE\n         STH   R4,JOBNAMEL             SAVE IT\n         L     R3,JNAME                ----> JOBNAME\n         EX    R4,MJOBNAME\n         LH    R4,GSCOPE+4             GET LENGTH OF SCOPE\n         BCTR  R4,0                     SUBTRACT 1 FOR EXECUTE\n         STH   R4,SCOPEL               SAVE IT\n         L     R3,GSCOPE               ----> SCOPE\n         EX    R4,MSCOPE\n                         SPACE\n         CLI   SCOPE,C'#'              TURN ON NODISP\n         BE    FLIPIT\n         CLI   JOBNAME,C'#'            TURN ON NODISP\n         BE    FLIPIT\n         CLI   MINOR,C'#'              TURN ON NODISP\n         BE    FLIPIT\n         CLC   MAJOR(2),=C'# '         TURN ON NODISP\n         BNE   NOFLIP\nFLIPIT   OI    FLAG1,NODISP\nNOFLIP   XC    TOKEN,TOKEN             CLEAR TOKEN AREA\n         XR    R7,R7                   CLEAR RECORD COUNT\n         CLI   MAJOR,C'#'              SPECIAL COMMAND ?\n         BNE   SCANI\n         CLI   MAJOR+1,C' '            NO DISPLAY WANTED\n         BE    SCANI\n         CLC   =C'LIST',MAJOR+1        DO WE WANT A LIST OF MAJORS ?\n         BE    #LISTI                  ..YES\n         B     ERROR7\n                         SPACE 2\nMMAJOR   MVC   MAJOR(*-*),0(R3)        * BY\nMMINOR   MVC   MINOR(*-*),0(R3)        *    EXECUTE\nMJOBNAME MVC   JOBNAME(*-*),0(R3)      *            ONLY\nMSCOPE   MVC   SCOPE(*-*),0(R3)        *            ONLY\n                       EJECT\n*====================================================================*\n*                                                                    *\n*        MAJOR/MINOR/JOBNAME/SCOPE SCAN REQUEST                      *\n*                                                                    *\n*====================================================================*\n*\nSCANI    TM    FLAG1,NODISP\n         BO    SCAN1\n                                       SPACE 1                      PGG\n         MVI   VHDR,C'C'               SORT FIELD FOR HEADERS       PGG\n         LA    R1,L'HEADING1           GET LENGTH OF VARIABLE       PGG\n         LA    R15,HEADING1            GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRX            PROCESS A STANDARD ENTRY     PGG\n         LA    R1,79                   GET LENGTH OF VARIABLE       PGG\n         LA    R15,HEADING2            GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRX            PROCESS A STANDARD ENTRY     PGG\n         MVI   VHDR,C'D'               SORT FIELD FOR ENTRIES       PGG\n                                       SPACE 1                      PGG\nSCAN1    LA    R3,AREA                 ---> REPLY AREA\n         XR    R4,R4                   CLEAR MAJOR NAME REGISTER\n         CLI   MAJOR,C'*'              ALL MAJOR NAMES REQUIRED ?\n         BE    SCANALL                 YES\n         CLI   MAJOR,C'#'              ALL MAJOR NAMES REQUIRED ?\n         BE    SCANALL                 YES\n         LA    R4,MAJOR                ---> QUEUE NAME IF RQD\nSCANALL  LA    R5,TOKEN                ---> TOKEN AREA\n         CLC   =C'STEP',SCOPE\n         BNE   SCOPE1A\n         GQSCAN AREA=((R3),LAREA),RESNAME=((R4),,,,8),TOKEN=(R5),   PGG*\n               SCOPE=STEP,REQLIM=MAX,MF=(E,GQPARM)\n         B     GQSCANE\n                              SPACE\nSCOPE1A  CLC   =C'SYSTEMS',SCOPE\n         BNE   SCOPE1B\n         GQSCAN AREA=((R3),LAREA),RESNAME=((R4),,,,8),TOKEN=(R5),   PGG*\n               SCOPE=SYSTEMS,REQLIM=MAX,MF=(E,GQPARM)\n         B     GQSCANE\n                              SPACE\nSCOPE1B  CLC   =C'SYSTEM',SCOPE\n         BNE   SCOPE1C\n         GQSCAN AREA=((R3),LAREA),RESNAME=((R4),,,,8),TOKEN=(R5),   PGG*\n               SCOPE=SYSTEM,REQLIM=MAX,MF=(E,GQPARM)\n         B     GQSCANE\n                              SPACE\nSCOPE1C  GQSCAN AREA=((R3),LAREA),RESNAME=((R4),,,,8),TOKEN=(R5),   PGG*\n               SCOPE=ALL,REQLIM=MAX,MF=(E,GQPARM)\n         B     GQSCANE\n                              SPACE\nGQSCANE  B     *+4(R15)               BRANCH ON RETURNED CODE\n         B     SCANOK\n         B     ERROR4                 NO MATCH FOUND\n         B     SCANOK                 WORK AREA OVERFLOW\n         B     ERROR6                 ABNORMAL RETURN CODE\n         B     ERROR6                 ABNORMAL RETURN CODE\n                         SPACE\n*============================================*\n*                                            *\n*   SCAN DATA RETURNED BY GQSCAN             *\n*                                            *\n*   REGISTER USAGE:                          *\n*       R3  - LENGTH OF EACH RIB             *\n*       R4  - LENGTH OF EACH RIBE            *\n*       R5  - WORK REGISTER AND BAL          *\n*       R6  - NUMBER OF RIBS                 *\n*       R7  - NUMBER OF ENTRIES DISPLAYED    *\n*       R8  - PTR TO RIBE                    *\n*       R9  - PTR TO RIBVAR                  *\n*       R10 - PTR TO RIB                     *\n*       R11 - NUMBER OF RIBES                *\n*                                            *\n*                                            *\n*============================================*\n*\nSCANOK   LTR   R0,R0                  DID WE VALID LENGTHS\n         BZ    U999                   NO\n         LTR   R1,R1                  ANY RIBS\n         BZ    U999                   NO\n         ST    R0,RIBLEN              SAVE RIB/RIBE LENGTHS\n         LR    R6,R1                  NO OF RIBS\n         LH    R3,RIBLEN              LENGTH OF RIB\n         LH    R4,RIBELEN             LENGTH OF RIBE\n         LA    R10,AREA\n         USING RIB,R10                POINTER TO CURRENT RIB\nNEXTRIB  LTR   R10,R10                IS IT A VALID PTR\n         BZ    U999                   NO\n         LA    R9,0(R3,R10)           ----> VARIABLE SECTION\n         USING RIBVAR,R9\n         LR    R8,R9\n         AH    R8,RIBVLEN             ----> RIBE\n         L     R11,RIBNRIBE           NO. OF RIBES\n         USING RIBE,R8\n*============================================*\n*  MOVE INFO FROM RIB                        *\n*============================================*\nRIBES    MVC   DISPLAY,BLANKS         CLEAR DISPLYA AREA\n         MVC   DMAJOR,RIBQNAME        DISPLAY MAJOR NAME\n         MVC   DSYSTEM+4(2),=C'-L'    DEFAULT LOCAL RESOURCE\n         TM    RIBSCOPE,RIBGLBL       LOCAL OR GLOBAL ?\n         BNO   SC1                    LOCAL..THEN ITS SETUP\n         MVC   DSYSTEM+4(2),=C'-G'    GLOBAL\nSC1      TM    RIBSCOPE,RIBSYSS       SYSTEMS ?\n         BNO   SC2\n         MVC   DSCOPE,=CL9'SYSTEMS'\n         B     RIBVBL\nSC2      TM    RIBSCOPE,RIBSYS        SYSTEM ?\n         BNO   SC3\n         MVC   DSCOPE,=CL9'SYSTEM'\n         B     RIBVBL\nSC3      TM    RIBSCOPE,RIBSTEP       STEP\n         BNO   SC4\n         MVC   DSCOPE,=CL9'STEP'\n         B     RIBVBL\nSC4      MVC   DSCOPE,=CL9'*********'\n*============================================*\n*  MOVE INFO FROM RIBVAR                     *\n*============================================*\nRIBVBL   CLI   MINOR,C'#'             ARE WE DOING A COUNT ONLY ?\n         BE    PMINOR                 YES.. CHECK JOBNAME\n         CLI   MINOR,C'*'             ALL MINOR NAMES ?\n         BE    PMINOR                 YES.. CHECK JOBNAME\n         CLI   MINOR,C'+'             AM I LOOKING FOR A STRING     PGG\n         BE    SCANMINR               WITHIN THE MINOR NAME         PGG\n         LH    R2,MINORL              LENGTH-1 FOR COMPARE\n         EX    R2,CMINOR\n         BNE   RIBEX\nPMINOR   XR    R5,R5                  CLEAR REGISTER\n         IC    R5,RIBRNMLN            LENGTH OF RESOURCE NAME\n         BCTR  R5,0\n         CH    R5,=H'40'\n         BNH   LENOK\n         LH    R5,=H'40'\nLENOK    EX    R5,TESTCHAR           TEST FOR NON PRINTABLES\n         BZ    ALLPRNT               ALL PRINTABLE\n*        BAL   R5,CONVRNME             DO NOT CONVERT TO HEX        PGG\n         EX    R5,MRNAME               MOVE NAME INTO BUFFER        PGG\n         EX    R5,TRNAME               MAKE IT PRINTABLE            PGG\n         B     SCANJOB\n                                       SPACE 1                      PGG\n***********************************************************************\n*        PROCESS TO FIND A STRING WITHIN THE RNAME FIELD            PGG *\n***********************************************************************\n                                       SPACE 1                      PGG\nSCANMINR DS    0H                                                   PGG\n         LA    R15,RIBRNAME            ADDRESS THE MINOR NAME       PGG\n         LA    R14,0                   AND THEN                     PGG\n         IC    R14,RIBRNMLN            GET ITS LENGTH               PGG\n         LA    R1,0(R14,R15)           LAST CHARACTER OF RNAME      PGG\n         SH    R1,MINORL               LESS LENGTH OF COMPARE NAME  PGG\n         LH    R14,MINORL              LENGTH FOE EXECUTED CLC      PGG\n         BCTR  R14,0                   LESS ONE FOR THE +           PGG\nSCANLOOP DS    0H                                                   PGG\n         EX    R14,CLCRNAME            LOOK FOR THE STRING          PGG\n         BE    PMINOR                  FOUND IT, DISPLAY RESULTS    PGG\n         LA    R15,1(R15)              WORK OUR WAY THROUGH IT      PGG\n         CR    R15,R1                  HAVE I GOT TO THE END YET    PGG\n         BH    RIBEX                   ===> YES, IGNORE THIS ENTRY  PGG\n         B     SCANLOOP                CONTINUE LOOPING             PGG\nCLCRNAME CLC   0(*-*,R15),MINOR+1      COMPARE THE TWO FIELDS       PGG\n                                       SPACE 1                      PGG\nALLPRNT  EX    R5,MRNAME\n*============================================*\n*  MOVE INFO FROM RIBE                       *\n*  WE MUST BE SURE THAT A RIBE WAS RETURNED  *\n*  PRIOR TO PUT 8205 THE NO.OF RIBES WAS     *\n*  BEING RETURNED INCORRECTLY.               *\n*============================================*\nSCANJOB  CLI   JOBNAME,C'#'\n         BE    ALLJOBS\n         CLI   JOBNAME,C'*'\n         BE    ALLJOBS\n         LTR   R11,R11                HAVE WE GOT A RIBE ?\n         BZ    RIBEX                  NO MATCH\n         LH    R2,JOBNAMEL\n         EX    R2,CJOBNAME\n         BNE   RIBEX\nALLJOBS  LTR   R11,R11                HAVE WE GOT A RIBE ?\n         BZ    DISPIT\n         MVC   DSYSTEM(4),RIBESYSN    DISPLAY SYSTEM ID\n         MVC   DJOBNAME,RIBEJBNM\n         MVC   DTYPE,=C'SHR'         DEFAULT SHARED RESOURCE\n         TM    RIBERFLG,RIBETYPE\n         BO    NOEXCL\n         MVC   DTYPE,=C'EXC'         NO ITS EXCLUSIVE\nNOEXCL   TM    RIBERFLG,RIBERESV\n         BNO   NORESV\n         MVC   DTYPE,=C'RES'\nNORESV   TM    RIBESFLG,RIBESTAT     WAITING FOR RESOURCE ?\n         BO    DISPIT                NO\n         MVC   DETYPE,=C'-W'         INDICATE WAITING FOR RESOURCE\n*============================================*\n*  TPUT THE DATA TO THE SCREEN               *\n*  INCREMENT COUNTER.                        *\n*============================================*\nDISPIT   TM    FLAG1,NODISP\n         BO    NDISPIT\n         LA    R1,L'DISPLAY            GET LENGTH OF VARIABLE       PGG\n         LA    R15,DISPLAY             GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\nNDISPIT  LA    R7,1(R7)              INCREMENT COUNTER\nRIBEX    LTR   R11,R11\n         BZ    NORIBES\n         BCT   R11,NEXTRIBE\nNORIBES  L     R11,RIBNRIBE           NO. OF RIBES\n         AH    R10,RIBVLEN            LENGTH OF RIB VARIABLE\n         AH    R10,RIBLEN             LENGTH OF RIB FIXED\n         MH    R11,RIBELEN            TOTAL LENGTH OF ALL RIBES\n         ALR   R10,R11                ---> NEXT RIB\n         BCT   R6,NEXTRIB\nANYMORE  CLC   TOKEN,=X'00000000'    ANY MORE DATA ?\n         BNE   SCAN1\n         LTR   R7,R7                 WERE WE SUCCESSFUL\n         BZ    ERROR4                NO\n         B     EXIT\n         SPACE\nNEXTRIBE LA    R8,0(R4,R8)            ----> NEXT RIBE\n         B     RIBES\n                SPACE  2\nTRNAME   TR    DMINOR(*-*),TRTABLE                                  PGG\nMRNAME   MVC   DMINOR(*-*),RIBRNAME\nCMINOR   CLC   MINOR(*-*),RIBRNAME\nCJOBNAME CLC   JOBNAME(*-*),RIBEJBNM\nTESTCHAR TRT   RIBRNAME(*-*),CHARTBL\n                       EJECT\n*====================================================================*\n*                                                                    *\n*   PROCESS #LIST COMMAND                                            *\n*                                                                    *\n*   REGISTER USAGE:                                                  *\n*       R3  - WORK FOR BXLE                                          *\n*       R4  - WORK FOR BXLE                                          *\n*       R5  - WORK FOR BXLE                                          *\n*       R6  - NUMBER OF RIBS                                         *\n*       R7  - NUMBER OF ENTRIES DISPLAYED                            *\n*       R10 - PTR TO RIB                                             *\n*       R11 - NUMBER OF RIBES                                        *\n*                                                                    *\n*====================================================================*\n*\n#LISTI   LA    R3,@MAJORS                 START OF TABLE\n         LA    R4,L'@MAJORS             LENGTH OF EACH ENTRY\n         LA    R5,@MAJORE               END OF TABLE\nCLRMT1   MVC   0(8,R3),=8XL1'00'         CLEAR ENTRY\n         BXLE  R3,R4,CLRMT1             CLEAR ENTIRE TABLE\n                        SPACE\n#LIST    LA    R3,AREA                 ---> REPLY AREA\n         LA    R5,TOKEN                ---> TOKEN AREA\n         GQSCAN AREA=((R3),L'AREA),TOKEN=(R5),SCOPE=ALL,REQLIM=0,      *\n               MF=(E,GQPARM)\n         B     *+4(R15)               BRANCH ON RETURNED CODE\n         B     LISTOK\n         B     ERROR4                 NO MATCH FOUND\n         B     LISTOK                 WORK AREA OVERFLOW\n         B     ERROR6                 ABNORMAL RETURN CODE\n         B     ERROR6                 ABNORMAL RETURN CODE\n                         SPACE 2\nLISTOK   LTR   R0,R0                  DID WE VALID LENGTHS\n         BZ    U999                   NO\n         LTR   R1,R1                  ANY RIBS\n         BZ    U999                   NO\n         ST    R0,RIBLEN              SAVE RIB/RIBE LENGTHS\n         LR    R6,R1                  NO OF RIBS\n         LA    R10,AREA\n         USING RIB,R10                POINTER TO CURRENT RIB\nNXTSRIB  LTR   R10,R10                IS IT A VALID PTR\n         BZ    U999                   NO\n         CLC   MAJOR,RIBQNAME         PREVIOUS ONE EQUAL ?\n         BE    DONTADD                YES DONT ADD IT\n         MVC   MAJOR,RIBQNAME         SAVE NEW ONE\n         LA    R3,@MAJORS                 START OF TABLE\n         LA    R4,L'@MAJORS             LENGTH OF EACH ENTRY\n         LA    R5,@MAJORE               END OF TABLE\nSCANMT1  CLI   0(R3),X'00'              NULL ENTRY IN TABLE ?\n         BE    ADDMT1                   ... YES\n         CLC   RIBQNAME,0(R3)           IS IT ALREADY THERE\n         BE    DONTADD                  ... YES\n         BXLE  R3,R4,SCANMT1            TRY IT\n         B     ERROR5\n         SPACE\nADDMT1   MVC   0(8,R3),RIBQNAME         ADD IT TO THE TABLE\nDONTADD  L     R11,RIBNRIBE           NO. OF RIBES\n         AH    R10,RIBVLEN            LENGTH OF RIB VARIABLE\n         AH    R10,RIBLEN             LENGTH OF RIB FIXED\n         MH    R11,RIBELEN            TOTAL LENGTH OF ALL RIBES\n         ALR   R10,R11                ---> NEXT RIB\n         BCT   R6,NXTSRIB\n         CLC   TOKEN,=X'00000000'    ANY MORE DATA ?\n         BNE   #LIST                 GET SOME MORE\n                     SPACE\nPLIST    TM    FLAG1,NODISP\n         BO    PLIST2\n         MVI   VHDR,C'A'               SORT FIELD FOR HEADERS       PGG\n         LA    R1,L'HEADING3           GET LENGTH OF VARIABLE       PGG\n         LA    R15,HEADING3            GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRX            PROCESS A STANDARD ENTRY     PGG\n         LA    R1,L'HEADING4           GET LENGTH OF VARIABLE       PGG\n         LA    R15,HEADING4            GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRX            PROCESS A STANDARD ENTRY     PGG\n         MVI   VHDR,C'B'               SORT FIELD FOR ENTRIES       PGG\nPLIST2   LA    R3,@MAJORS                 START OF TABLE\n         LA    R4,L'@MAJORS             LENGTH OF EACH ENTRY\n         LA    R5,@MAJORE               END OF TABLE\nPLIST3   CLI   0(R3),X'00'            NULL ENTRY ?\n         BE    #LISTE                 YES, MUST BE END OF TABLE\n         MVC   LMAJOR,0(R3)           PREPARE TO PRINT\n         TM    FLAG1,NODISP\n         BO    PLIST4\n         LA    R1,L'LISTM              GET LENGTH OF VARIABLE       PGG\n         LA    R15,LISTM               GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\nPLIST4   LA    R7,1(R7)               INCREMENT COUNTER\n         BXLE  R3,R4,PLIST3             TRY IT\n#LISTE   LTR   R7,R7                 WERE WE SUCCESSFUL\n         BNZ   EXIT\n         B     ERROR4\n                       EJECT\n*====================================================================*\n*                                                                    *\n*   CONVERT HEX RESOURCE NAME TO PRINTABLE CHARACTERS                *\n*                                                                    *\n*====================================================================*\nCONVRNME STM   R3,R11,SAVE3TOB       SAVE REGISTER CONTENTS\n         MVC   DMINOR(2),=C'X'''\n         XR    R7,R7                   CLEAR REGISTER\n         IC    R7,RIBRNMLN             LENGTH OF DATA TO CONVERT\n         CH    R7,=H'19'               MAXIMUM ALLOWED\n         BNH   SIZEOK                  ITS WITHIN LIMITS\n         LA    R7,22                   SET AT MAX ALLOWED\nSIZEOK   LA    R6,RIBRNAME             VALUE WE ARE CONVERTING\n         LA    R4,DMINOR+2             MOVE PATTERN FOR EDIT TO WORK\n         LA    R9,HEXTAB               CONVERSION TABLE\nLOOPR    XR    R3,R3                   CLEAR REGISTER\n         IC    R3,0(R6)                LOAD CURRENT HEX BYTE\n         SRL   R3,4                    SHIFT IT OVER HALF A BYTE\n         LA    R3,0(R3,R9)             OFFSET WITH PRINTABLES\n         MVC   0(1,R4),0(R3)           MOVE IT TO PRINT LINE\n         XR    R3,R3                   CLEAR REGISTER\n         IC    R3,0(R6)                LOAD CURRENT HEX BYTE AGAIN\n         N     R3,=X'0000000F'         CLEAR ALL BUT LOW 4 BITS\n         LA    R3,0(R3,R9)             POINTER TO PRINTABLE CHAR\n         MVC   1(1,R4),0(R3)           MOVE IN APPROP VALUE\n         LA    R6,1(R6)                POINT TO NEXT HEX BYTE\n         LA    R4,2(R4)                POINT TO NEX PRINT POSITION\n         BCT   R7,LOOPR\n         MVI   0(R4),C''''\n         LM    R3,R11,SAVE3TOB       RESTORE REGISTER CONTENTS\n         BR    R5                    RETURN TO CALLER\n                       EJECT\n*====================================================================*\n*                                                                    *\n*    RETURN TO CALLER                                                *\n*                                                                    *\n*====================================================================*\n*\nEXIT     DS    0H                                                   PGG\n         CLI   TPUT,1                  WAS I USING TPUT             PGG\n         BE    EXIT1                   ===> YES, SKIP ISPF DISPLAY  PGG\n         TM    FLAG1,NODISP                                         PGG\n         BO    SKIPSORT                                             PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(TBSORT,GRSTABLE,SGRS),VL,MF=(E,SPFCALL)        PGG\nSKIPSORT DS    0H                                                   PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(TBTOP,GRSTABLE),VL,MF=(E,SPFCALL)              PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(TBDISPL,GRSTABLE,GRSTABLE),VL,MF=(E,SPFCALL)   PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(TBEND,GRSTABLE),VL,MF=(E,SPFCALL)              PGG\nEXIT1    DS    0H                                                   PGG\n         DELETE EPLOC=ISPLINK          KILL ISPF LINKAGE MODULE     PGG\n         EXIT RETCODE=(7)                                           PGG\n         EJECT\n                    SPACE 2\n         PRINT NOGEN\nPCL      IKJPARM\n         SPACE\nQNAME    IKJIDENT 'MAJOR NAME',ASTERISK,MAXLNTH=8,FIRST=ALPHA,         *\n               OTHER=ANY,DEFAULT='#LIST'\n         SPACE\nRNAME    IKJIDENT 'RESOURCE NAME',ASTERISK,MAXLNTH=47,FIRST=ANY,       *\n               OTHER=ANY,DEFAULT='*'\n         SPACE\nJNAME    IKJIDENT 'JOB NAME',ASTERISK,MAXLNTH=8,FIRST=ANY,OTHER=ANY,   *\n               DEFAULT='*'\n         SPACE\nGSCOPE   IKJIDENT 'SCOPE',ASTERISK,MAXLNTH=8,FIRST=ANY,OTHER=ANY,      *\n               DEFAULT='*'\n         SPACE\n         IKJENDP\n         PRINT GEN\n         EJECT\n***********************************************************************\n*        ROUTINE TO ADD AN ENTRY TO THE TABLE                       PGG *\n***********************************************************************\n                                       SPACE 1                      PGG\nADDENTRX DS    0H                                                   PGG\n         ST    R14,SAVER14             SAVE RETURN ADDRESS          PGG\n         CLI   TPUT,1                  WAS I USING TPUT             PGG\n         BE    TPUTA                   ===> YES, SKIP ISPF TBADD    PGG\n         BR    R14                     ===> RETURN TO CALLER        PGG\n                                       SPACE 1                      PGG\nADDENTRY DS    0H                                                   PGG\n         ST    R14,SAVER14             SAVE RETURN ADDRESS          PGG\n         CLI   TPUT,1                  WAS I USING TPUT             PGG\n         BE    TPUTA                   ===> YES, SKIP ISPF TBADD    PGG\n         BCTR  R1,0                    LESS ONE FOR EXECUTED MOVE   PGG\n         MVI   VGRS,C' '               BLANK OUT THE ENTIRE LINE    PGG\n         MVC   VGRS+1(L'VGRS-1),VGRS                                PGG\n         EX    R1,MOVEISPF             MOVE THE DATA INTO ISPF VAR  PGG\n         L     R15,EPLOC               A(ISPF LINKAGE MODULE)       PGG\n         CALL  (15),(TBADD,GRSTABLE),VL,MF=(E,SPFCALL)              PGG\n         B     TPUTB                   SKIP OVER THE TPUT           PGG\nTPUTA    DS    0H                                                   PGG\n         LR    R0,R1                   PUT LENGTH INTO R0           PGG\n         LR    R1,R15                  PUT ADDRESS INTO R1          PGG\n         TPUT  (1),(0),R                                            PGG\nTPUTB    DS    0H                                                   PGG\n         L     R14,SAVER14             RESTORE RETURN ADDRESS       PGG\n         BR    R14                     ===> RETURN TO CALLER        PGG\nMOVEISPF MVC   VGRS(*-*),0(R15)        MOVE THE DATA INTO BUFFER    PGG\n                                       SPACE 1                      PGG\n*====================================================================*\n*                                                                    *\n*    ERROR ROUTINES                                                  *\n*                                                                    *\n*====================================================================*\n*\nERROR1   DS    0H\n         LA    R1,L'MSG1               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG1                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     EXIT\n                                SPACE\nERROR2   DS    0H\n         LA    R1,L'MSG2               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG2                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     EXIT\n                                SPACE\nERROR3   DS    0H\n         LA    R1,L'MSG3               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG3                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     EXIT\n                                SPACE\nERROR4   TM    FLAG1,NODISP\n         BO    EXIT\n         LA    R1,L'MSG4               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG4                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     EXIT\n                                SPACE\nERROR5   DS    0H\n         LA    R1,L'MSG5               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG5                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     PLIST\n                                SPACE\nERROR6   DS    0H\n         LA    R1,L'MSG6               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG6                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     EXIT\n                                SPACE\nERROR7   DS    0H\n         LA    R1,L'MSG7               GET LENGTH OF VARIABLE       PGG\n         LA    R15,MSG7                GET ADDRESS OF VARIABLE      PGG\n         BAL   R14,ADDENTRY            PROCESS A STANDARD ENTRY     PGG\n         B     EXIT\n                                SPACE\nU999     ABEND 999,DUMP\n         B     EXIT\n                                SPACE\nU1004    ABEND 1004,DUMP\n         B     EXIT\n                                SPACE 3\n         EJECT\n*====================================================================*\n*                                                                    *\n*    CONSTANTS                                                       *\n*                                                                    *\n*====================================================================*\n*\nHEADING1 DC    C'JOB/USER TYPE  SYSTEM   SCOPE   MAJOR    MINOR NAME'\nHEADING2 DC    79CL1'-'\nHEADING3 DC    C'          MAJOR NAME'\nHEADING4 DC    C'          ----------'\nMSG1     DC    C'INCOMPLETE PARAMETERS'\nMSG2     DC    C'NOT ENOUGH SPACE IN REGION'\nMSG3     DC    C'INVALID PARAMETERS'\nMSG4     DC    C'NO RESOURCES MATCHED YOUR REQUEST'\nMSG5     DC    C'TABLE OVERFLOW - SOME ENTRIES LOST'\nMSG6     DC    C'QUEUE SCAN ENCOUNTERED AN ABNORMAL SITUATION'\nMSG7     DC    C'INVALID SUBCOMMAND ENTERED - REQUEST IGNORED'\nBLANKS   DC    CL100' '\n         SPACE\nCHARTBL  DC    256X'FF'                 TABLE FOR XLATE AND TEST\n         ORG   CHARTBL+C' '\n         DC    X'00'\n         ORG   CHARTBL+C'.'\n         DC    6X'00'\n         ORG   CHARTBL+C'$'\n         DC    7X'00'\n         ORG   CHARTBL+C','\n         DC    5X'00'\n         ORG   CHARTBL+C':'\n         DC    5X'00'\n         ORG   CHARTBL+C'A'\n         DC    9X'00'\n         ORG   CHARTBL+C'J'\n         DC    9X'00'\n         ORG   CHARTBL+C'S'\n         DC    8X'00'\n         ORG   CHARTBL+C'0'\n         DC    10X'00'\n         ORG\n                            SPACE\nTRTABLE  DC    256C'.'                 TABLE FOR TRANSLATE          PGG\n         ORG   TRTABLE+C'$'                                         PGG\n         DC    C'$'                                                 PGG\n         ORG   TRTABLE+C'#'                                         PGG\n         DC    C'#@'                                                PGG\n         ORG   TRTABLE+C','                                         PGG\n         DC    C','                                                 PGG\n         ORG   TRTABLE+C':'                                         PGG\n         DC    C':'                                                 PGG\n         ORG   TRTABLE+C'A'                                         PGG\n         DC    C'ABCDEFGHI'                                         PGG\n         ORG   TRTABLE+C'J'                                         PGG\n         DC    C'JKLMNOPQR'                                         PGG\n         ORG   TRTABLE+C'S'                                         PGG\n         DC    C'STUVWXYZ'                                          PGG\n         ORG   TRTABLE+C'0'                                         PGG\n         DC    C'0123456789'                                        PGG\n         ORG   ,                                                    PGG\n                            SPACE 1                                 PGG\nHEXTAB   DC    C'0123456789ABCDEF'\n                            SPACE 2\n         LTORG\n***********************************************************************\n*        ISPF CONSTANTS                                               * *\n***********************************************************************\n                                       SPACE 1                      PGG\n         LTORG ,                                                    PGG\nISPQRY   DC    CL8'ISPQRY'             ISPF QUERY ROUTINE           PGG\nISPLINK  DC    CL8'ISPLINK'            ISPF LINK ROUTINE            PGG\nVDEFINE  DC    CL8'VDEFINE'            ISPF CONSTANT                PGG\nVREPLACE DC    CL8'VREPLACE'           ISPF CONSTANT                PGG\nCHAR     DC    CL8'CHAR'               ISPF CONSTANT                PGG\nTBCREATE DC    CL8'TBCREATE'           ISPF CONSTANT                PGG\nTBADD    DC    CL8'TBADD'              ISPF CONSTANT                PGG\nTBEND    DC    CL8'TBEND'              ISPF CONSTANT                PGG\nTBTOP    DC    CL8'TBTOP'              ISPF CONSTANT                PGG\nTBDISPL  DC    CL8'TBDISPL'            ISPF CONSTANT                PGG\nTBSORT   DC    CL8'TBSORT'             ISPF CONSTANT                PGG\nNOWRITE  DC    CL8'NOWRITE'            ISPF CONSTANT                PGG\nCGRS     DC    C'(GRS)'                ISPF VARIABLE NAME           PGG\nCHDR     DC    C'(HDR)'                ISPF VARIABLE NAME           PGG\nCTBL     DC    C'(GRS,HDR)'            ISPF VARIABLE NAME           PGG\nSGRS     DC    C'(HDR,C,A,GRS,C,A)'    ISPF VARIABLE NAME           PGG\nGRSTABLE DC    CL8'GRSTABLE'           ISPF TABLE AND PANEL NAME    PGG\nF01      DC    F'01'                   LENGTH VALUE OF 1            PGG\nF79      DC    F'79'                   LENGTH VALUE OF 79           PGG\n         DS    0D                      DOUBLE WORD ALIGNEMENT       PGG\n         EJECT\n*====================================================================*\n*                                                                    *\n*    WORKAREA DSECTS                                                 *\n*                                                                    *\n*====================================================================*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                  SAVE AREA\nMYID     DS    CL8                   DUMP EYEBALL\nSAVE3TOB DS    10F                  INTERNAL SAVE AREA\nTOKEN    DS    F                    TOKEN AREA USED BY GQSCAN\nMAJORL   DS    H                    LENGTH OF MAJOR NAME\nMAJOR    DS    CL8                  MAJOR NAME\nMINORL   DS    H                    LENGTH OF MINOR NAME\nMINOR    DS    CL47                 MINOR NAME\nJOBNAMEL DS    H                    LENGTH OF JOB/USERID\nJOBNAME  DS    CL8                  JOB USERID\nSCOPEL   DS    H                    LENGTH OF SCOPE\nSCOPE    DS    CL8                  SCOPE\n         SPACE\nFLAG1    DS    X\nNODISP   EQU   X'80'\n         SPACE\n         DS    0F\nRIBLEN   DS    H                    LENGTH OF RIB\nRIBELEN  DS    H                    LENGTG OF RIBE\n                        SPACE\nGQPARM   GQSCAN SCOPE=ALL,MF=L\n                        SPACE\nDISPLAY  DS    0CL79\nDJOBNAME DS    CL8\n         DS    CL1\nDTYPE    DS    CL3\nDETYPE   DS    CL2\n         DS    CL1\nDSYSTEM  DS    CL8\n         DS    CL1\nDSCOPE   DS    CL7\n         DS    CL1\nDMAJOR   DS    CL8\n         DS    CL1\nDMINOR   DS    CL38\n         DS    CL10\n                        SPACE\nLISTM    DS    0CL40\n         DS    CL32\nLMAJOR   DS    CL8\n                        SPACE\n         DS    0F\n@MAJORS  DC    119XL8'00'          *120                             PGG\n@MAJORE  DC    XL8'00'             *    ENTRIES\n                                       SPACE 1                      PGG\n***********************************************************************\n*        ISPF VARIABLES                                             PGG *\n***********************************************************************\n                                       SPACE 1                      PGG\nVGRS     DS    CL79                    SYSTEM ID FOR ISPF           PGG\nVHDR     DS    C                       ISPF VARIABLE CONTENTS       PGG\nEPLOC    DS    F                       ENTRY POINT ADDRESS          PGG\nSAVER14  DS    F                       RETURN ADDRESS SAVE AREA     PGG\nSPFCALL  DS    5F                      CALL PARAMETER LIST          PGG\nTPUT     DS    X                       TPUT INDICATOR               PGG\n                                       SPACE 1                      PGG\n*====================================================================*\n*                                                                    *\n*    PARSE PARAMETER LIST                                            *\n*                                                                    *\n*====================================================================*\n*\nPPLUPT   DS    A(0)\nPPLECT   DS    A(0)\nPPLECB   DS    A(PPLECBS)\nPPLPCL   DS    A(PCL)\nPPLANSWR DS    A(PPLANS)\nPPLCBUF  DS    A(0)\nPPLUWA   DS    A(0)\nPPLECBS  DS    A(0)\nPPLANS   DS    A(0)  ANSWER PLACE\nAREA     DS    10CL30000                                            PGG\n         DS    0D                      DOUBLE WORD ALIGNEMENT       PGG\nLAREA    EQU   *-AREA                                               PGG\nWLEN     EQU   *-WORKAREA\n         EJECT\n*====================================================================*\n*                                                                    *\n*    OTHER REQUIRED DSECTS                                           *\n*                                                                    *\n*====================================================================*\n*\n         ISGRIB\n                          SPACE 2\n         IKJCPPL\n                          SPACE 2\n         IKJPSCB\n                          SPACE 2\n         IKJECT\n                          SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPLBLD00": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x00\\x02\\x00\\x02\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 2, "newlines": 2, "modlines": 0, "user": "PGILLIS"}, "text": "//NEWVOL   SET NEWVOL=RESN01\n//OLDVOL   SET OLDVOL=RESN02\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPLBLD90": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x00%\\x00%\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 37, "newlines": 37, "modlines": 0, "user": "PGILLIS"}, "text": "//IPLBLD90 JOB CLASS=P,MSGCLASS=X,REGION=64M,NOTIFY=&SYSUID,\n//             COND=(16,EQ)\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//*\n//OLD      EXEC PGM=LISTVTOC\n//STEPLIB  DD  DISP=SHR,DSN=PPPYG.TOOLS.ISPLLIB\n//VTOCDD   DD  DISP=SHR,UNIT=SYSDA,VOL=SER=&OLDVOL\n//SYSPRINT DD  DISP=(,PASS),DSN=&&OLD,UNIT=SYSDA,SPACE=(CYL,1)\n//SYSUDUMP DD  SYSOUT=*\n//*\n//NEW      EXEC PGM=LISTVTOC\n//STEPLIB  DD  DISP=SHR,DSN=PPPYG.TOOLS.ISPLLIB\n//VTOCDD   DD  DISP=SHR,UNIT=SYSDA,VOL=SER=&NEWVOL\n//SYSPRINT DD  DISP=(,PASS),DSN=&&NEW,UNIT=SYSDA,SPACE=(CYL,1)\n//SYSUDUMP DD  SYSOUT=*\n//*\n//ISRSUPC  EXEC PGM=ISRSUPC,PARM=(LONGL,LINECMP,REFMOVR,DLREFM)\n//OLDDD    DD  DISP=SHR,DSN=&&OLD\n//NEWDD    DD  DISP=SHR,DSN=&&NEW\n//OUTDD    DD  DISP=(,PASS),DSN=&&OUTDD,UNIT=SYSDA,SPACE=(CYL,1)\n//*\n//PRINTCMP EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=(SHR,PASS),DSN=&OUTDD\n//SYSUT2   DD  SYSOUT=*\n//*\n//RUNREXX  EXEC PGM=IKJEFT01,PARM='%IPLVOLXP'\n//SYSPROC  DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS\n//SYSTSPRT DD  SYSOUT=*\n//SYSTERM  DD  DUMMY\n//SYSTSIN  DD  DUMMY\n//DATASETS DD  DISP=(SHR,PASS),DSN=&&OUTDD\n//TRGVOL   DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS(IPLBLD91)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPLBLD91": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x02\\xb5\\x02\\xb5\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 693, "newlines": 693, "modlines": 0, "user": "PGILLIS"}, "text": "//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0001 EXEC IPLCOMPR,CDSN=SYS1.ADFMAC1\n//STEP0002 EXEC IPLCOMPR,CDSN=SYS1.LOCAL.LPALIB\n//STEP0003 EXEC IPLCOMPR,CDSN=SYS1.CBRDBRM\n//STEP0004 EXEC IPLCOMPR,CDSN=SYS1.CMDLIB\n//STEP0005 EXEC IPLCOMPR,CDSN=SYS1.COBOL.V34.SIGYCLST\n//STEP0006 EXEC IPLCOMPR,CDSN=SYS1.COBOL.V34.SIGYCOMP\n//STEP0007 EXEC IPLCOMPR,CDSN=SYS1.COBOL.V34.SIGYMAC\n//STEP0008 EXEC IPLCOMPR,CDSN=SYS1.COBOL.V34.SIGYPROC\n//STEP0009 EXEC IPLCOMPR,CDSN=SYS1.COBOL.V34.SIGYSAMP\n//STEP0010 EXEC IPLCOMPR,CDSN=SYS1.COBOLRW.SCXRCOBA\n//STEP0011 EXEC IPLCOMPR,CDSN=SYS1.COBOLRW.SCXRCOBQ\n//STEP0012 EXEC IPLCOMPR,CDSN=SYS1.COBOLRW.SCXRJCL\n//STEP0013 EXEC IPLCOMPR,CDSN=SYS1.COBOLRW.SCXRPREC\n//STEP0014 EXEC IPLCOMPR,CDSN=SYS1.COBOLRW.TCXRRUN\n//STEP0015 EXEC IPLCOMPR,CDSN=SYS1.CSSLIB\n//STEP0016 EXEC IPLCOMPR,CDSN=SYS1.DBBLIB\n//STEP0017 EXEC IPLCOMPR,CDSN=SYS1.DFQLLIB\n//STEP0018 EXEC IPLCOMPR,CDSN=SYS1.DFQMLIB\n//STEP0019 EXEC IPLCOMPR,CDSN=SYS1.DFQPLIB\n//STEP0020 EXEC IPLCOMPR,CDSN=SYS1.DGTCLIB\n//STEP0021 EXEC IPLCOMPR,CDSN=SYS1.DGTLLIB\n//STEP0022 EXEC IPLCOMPR,CDSN=SYS1.DGTMLIB\n//STEP0023 EXEC IPLCOMPR,CDSN=SYS1.DGTPLIB\n//STEP0024 EXEC IPLCOMPR,CDSN=SYS1.DGTSLIB\n//STEP0025 EXEC IPLCOMPR,CDSN=SYS1.DGTTLIB\n//STEP0026 EXEC IPLCOMPR,CDSN=SYS1.ENDVR.LPALIB\n//STEP0027 EXEC IPLCOMPR,CDSN=SYS1.FIX.LINKLIB\n//STEP0028 EXEC IPLCOMPR,CDSN=SYS1.FIX.LINKLIBE\n//STEP0029 EXEC IPLCOMPR,CDSN=SYS1.FIX.LPALIB\n//STEP0030 EXEC IPLCOMPR,CDSN=SYS1.HELP\n//STEP0031 EXEC IPLCOMPR,CDSN=SYS1.HELPENP\n//STEP0032 EXEC IPLCOMPR,CDSN=SYS1.HRFCLST\n//STEP0033 EXEC IPLCOMPR,CDSN=SYS1.HRFMSG\n//STEP0034 EXEC IPLCOMPR,CDSN=SYS1.HRFPANL\n//STEP0035 EXEC IPLCOMPR,CDSN=SYS1.HRFSKEL\n//STEP0036 EXEC IPLCOMPR,CDSN=SYS1.IBM.PARMLIB\n//STEP0037 EXEC IPLCOMPR,CDSN=SYS1.IBM.PROCLIB\n//STEP0038 EXEC IPLCOMPR,CDSN=SYS1.ICQABTXT\n//STEP0039 EXEC IPLCOMPR,CDSN=SYS1.ICQCCLIB\n//STEP0040 EXEC IPLCOMPR,CDSN=SYS1.ICQILIB\n//STEP0041 EXEC IPLCOMPR,CDSN=SYS1.ICQMLIB\n//STEP0042 EXEC IPLCOMPR,CDSN=SYS1.ICQPLIB\n//STEP0043 EXEC IPLCOMPR,CDSN=SYS1.ICQSLIB\n//STEP0044 EXEC IPLCOMPR,CDSN=SYS1.ICQTABLS\n//STEP0045 EXEC IPLCOMPR,CDSN=SYS1.IGDVBS1\n//STEP0046 EXEC IPLCOMPR,CDSN=SYS1.IMAGELIB\n//STEP0047 EXEC IPLCOMPR,CDSN=SYS1.LINKLIB\n//STEP0048 EXEC IPLCOMPR,CDSN=SYS1.LPALIB\n//STEP0049 EXEC IPLCOMPR,CDSN=SYS1.MACLIB\n//STEP0050 EXEC IPLCOMPR,CDSN=SYS1.MIGLIB\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0051 EXEC IPLCOMPR,CDSN=SYS1.MODGEN\n//STEP0052 EXEC IPLCOMPR,CDSN=SYS1.MSGENP\n//STEP0053 EXEC IPLCOMPR,CDSN=SYS1.MSGENU\n//STEP0054 EXEC IPLCOMPR,CDSN=SYS1.NFSLIBE\n//STEP0055 EXEC IPLCOMPR,CDSN=SYS1.NFSMAC\n//STEP0056 EXEC IPLCOMPR,CDSN=SYS1.NFSSAMP\n//STEP0057 EXEC IPLCOMPR,CDSN=SYS1.NFSTARB\n//STEP0058 EXEC IPLCOMPR,CDSN=SYS1.NOR1.LINKLIB\n//STEP0059 EXEC IPLCOMPR,CDSN=SYS1.NOR1.TCPPARMS\n//STEP0060 EXEC IPLCOMPR,CDSN=SYS1.NOR2.LINKLIB\n//STEP0061 EXEC IPLCOMPR,CDSN=SYS1.NOR2.TCPPARMS\n//STEP0062 EXEC IPLCOMPR,CDSN=SYS1.NUCLEUS\n//STEP0063 EXEC IPLCOMPR,CDSN=SYS1.RG1LOAD\n//STEP0064 EXEC IPLCOMPR,CDSN=SYS1.RG1MAC\n//STEP0065 EXEC IPLCOMPR,CDSN=SYS1.SACBCNTL\n//STEP0066 EXEC IPLCOMPR,CDSN=SYS1.SADMCDA\n//STEP0067 EXEC IPLCOMPR,CDSN=SYS1.SADMCFO\n//STEP0068 EXEC IPLCOMPR,CDSN=SYS1.SADMDAT\n//STEP0069 EXEC IPLCOMPR,CDSN=SYS1.SADMGDF\n//STEP0070 EXEC IPLCOMPR,CDSN=SYS1.SADMIMG\n//STEP0071 EXEC IPLCOMPR,CDSN=SYS1.SADMMAP\n//STEP0072 EXEC IPLCOMPR,CDSN=SYS1.SADMMOD\n//STEP0073 EXEC IPLCOMPR,CDSN=SYS1.SADMMSG\n//STEP0074 EXEC IPLCOMPR,CDSN=SYS1.SADMOPS\n//STEP0075 EXEC IPLCOMPR,CDSN=SYS1.SADMPCF\n//STEP0076 EXEC IPLCOMPR,CDSN=SYS1.SADMPNL\n//STEP0077 EXEC IPLCOMPR,CDSN=SYS1.SADMSAM\n//STEP0078 EXEC IPLCOMPR,CDSN=SYS1.SADMSYM\n//STEP0079 EXEC IPLCOMPR,CDSN=SYS1.SADRYLIB\n//STEP0080 EXEC IPLCOMPR,CDSN=SYS1.SAFHFORT\n//STEP0081 EXEC IPLCOMPR,CDSN=SYS1.SAMPLIB\n//STEP0082 EXEC IPLCOMPR,CDSN=SYS1.SAOPEXEC\n//STEP0083 EXEC IPLCOMPR,CDSN=SYS1.SAOPMENU\n//STEP0084 EXEC IPLCOMPR,CDSN=SYS1.SAOPPENU\n//STEP0085 EXEC IPLCOMPR,CDSN=SYS1.SASMMAC1\n//STEP0086 EXEC IPLCOMPR,CDSN=SYS1.SASMMAC2\n//STEP0087 EXEC IPLCOMPR,CDSN=SYS1.SASMMOD1\n//STEP0088 EXEC IPLCOMPR,CDSN=SYS1.SASMMOD2\n//STEP0089 EXEC IPLCOMPR,CDSN=SYS1.SASMPUT2\n//STEP0090 EXEC IPLCOMPR,CDSN=SYS1.SASMSAM1\n//STEP0091 EXEC IPLCOMPR,CDSN=SYS1.SASMSAM2\n//STEP0092 EXEC IPLCOMPR,CDSN=SYS1.SAXREXEC\n//STEP0093 EXEC IPLCOMPR,CDSN=SYS1.SBDTCLI0\n//STEP0094 EXEC IPLCOMPR,CDSN=SYS1.SBDTCMD\n//STEP0095 EXEC IPLCOMPR,CDSN=SYS1.SBDTHELP\n//STEP0096 EXEC IPLCOMPR,CDSN=SYS1.SBDTLIB\n//STEP0097 EXEC IPLCOMPR,CDSN=SYS1.SBDTLINK\n//STEP0098 EXEC IPLCOMPR,CDSN=SYS1.SBDTLPA\n//STEP0099 EXEC IPLCOMPR,CDSN=SYS1.SBDTMAC\n//STEP0100 EXEC IPLCOMPR,CDSN=SYS1.SBDTMSG\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0101 EXEC IPLCOMPR,CDSN=SYS1.SBDTPNL0\n//STEP0102 EXEC IPLCOMPR,CDSN=SYS1.SBDTSAMP\n//STEP0103 EXEC IPLCOMPR,CDSN=SYS1.SBLSCLI0\n//STEP0104 EXEC IPLCOMPR,CDSN=SYS1.SBLSKEL0\n//STEP0105 EXEC IPLCOMPR,CDSN=SYS1.SBLSMSG0\n//STEP0106 EXEC IPLCOMPR,CDSN=SYS1.SBLSPNL0\n//STEP0107 EXEC IPLCOMPR,CDSN=SYS1.SBLSTBL0\n//STEP0108 EXEC IPLCOMPR,CDSN=SYS1.SBPXEXEC\n//STEP0109 EXEC IPLCOMPR,CDSN=SYS1.SBPXMENU\n//STEP0110 EXEC IPLCOMPR,CDSN=SYS1.SBPXPENU\n//STEP0111 EXEC IPLCOMPR,CDSN=SYS1.SBPXTENU\n//STEP0112 EXEC IPLCOMPR,CDSN=SYS1.SCBCCMP\n//STEP0113 EXEC IPLCOMPR,CDSN=SYS1.SCBCDOC\n//STEP0114 EXEC IPLCOMPR,CDSN=SYS1.SCBCIMG\n//STEP0115 EXEC IPLCOMPR,CDSN=SYS1.SCBCJCL\n//STEP0116 EXEC IPLCOMPR,CDSN=SYS1.SCBCPNL\n//STEP0117 EXEC IPLCOMPR,CDSN=SYS1.SCBCPRC\n//STEP0118 EXEC IPLCOMPR,CDSN=SYS1.SCBCSAM\n//STEP0119 EXEC IPLCOMPR,CDSN=SYS1.SCBCSKL\n//STEP0120 EXEC IPLCOMPR,CDSN=SYS1.SCBCUTL\n//STEP0121 EXEC IPLCOMPR,CDSN=SYS1.SCBDCLST\n//STEP0122 EXEC IPLCOMPR,CDSN=SYS1.SCBDHENU\n//STEP0123 EXEC IPLCOMPR,CDSN=SYS1.SCBDMENU\n//STEP0124 EXEC IPLCOMPR,CDSN=SYS1.SCBDPENU\n//STEP0125 EXEC IPLCOMPR,CDSN=SYS1.SCBDTEMP\n//STEP0126 EXEC IPLCOMPR,CDSN=SYS1.SCBDTENU\n//STEP0127 EXEC IPLCOMPR,CDSN=SYS1.SCCNCMP\n//STEP0128 EXEC IPLCOMPR,CDSN=SYS1.SCCNDOC\n//STEP0129 EXEC IPLCOMPR,CDSN=SYS1.SCCNJCL\n//STEP0130 EXEC IPLCOMPR,CDSN=SYS1.SCCNPRC\n//STEP0131 EXEC IPLCOMPR,CDSN=SYS1.SCCNSAM\n//STEP0132 EXEC IPLCOMPR,CDSN=SYS1.SCCNUTL\n//STEP0133 EXEC IPLCOMPR,CDSN=SYS1.SCDRTABL\n//STEP0134 EXEC IPLCOMPR,CDSN=SYS1.SCDSSAMP\n//STEP0135 EXEC IPLCOMPR,CDSN=SYS1.SCEEBIND\n//STEP0136 EXEC IPLCOMPR,CDSN=SYS1.SCEEBND2\n//STEP0137 EXEC IPLCOMPR,CDSN=SYS1.SCEECICS\n//STEP0138 EXEC IPLCOMPR,CDSN=SYS1.SCEECLST\n//STEP0139 EXEC IPLCOMPR,CDSN=SYS1.SCEECMAP\n//STEP0140 EXEC IPLCOMPR,CDSN=SYS1.SCEECPP\n//STEP0141 EXEC IPLCOMPR,CDSN=SYS1.SCEEGXLT\n//STEP0142 EXEC IPLCOMPR,CDSN=SYS1.SCEEH\n//STEP0143 EXEC IPLCOMPR,CDSN=SYS1.SCEEH.ARPA.H\n//STEP0144 EXEC IPLCOMPR,CDSN=SYS1.SCEEH.H\n//STEP0145 EXEC IPLCOMPR,CDSN=SYS1.SCEEH.NET.H\n//STEP0146 EXEC IPLCOMPR,CDSN=SYS1.SCEEH.NETINET.H\n//STEP0147 EXEC IPLCOMPR,CDSN=SYS1.SCEEH.SYS.H\n//STEP0148 EXEC IPLCOMPR,CDSN=SYS1.SCEEH.T\n//STEP0149 EXEC IPLCOMPR,CDSN=SYS1.SCEELIB\n//STEP0150 EXEC IPLCOMPR,CDSN=SYS1.SCEELKED\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0151 EXEC IPLCOMPR,CDSN=SYS1.SCEELKEX\n//STEP0152 EXEC IPLCOMPR,CDSN=SYS1.SCEELOCL\n//STEP0153 EXEC IPLCOMPR,CDSN=SYS1.SCEELOCX\n//STEP0154 EXEC IPLCOMPR,CDSN=SYS1.SCEELPA\n//STEP0155 EXEC IPLCOMPR,CDSN=SYS1.SCEEMAC\n//STEP0156 EXEC IPLCOMPR,CDSN=SYS1.SCEEMSGP\n//STEP0157 EXEC IPLCOMPR,CDSN=SYS1.SCEEOBJ\n//STEP0158 EXEC IPLCOMPR,CDSN=SYS1.SCEEPROC\n//STEP0159 EXEC IPLCOMPR,CDSN=SYS1.SCEERUN\n//STEP0160 EXEC IPLCOMPR,CDSN=SYS1.SCEERUN2\n//STEP0161 EXEC IPLCOMPR,CDSN=SYS1.SCEESAMP\n//STEP0162 EXEC IPLCOMPR,CDSN=SYS1.SCEESPC\n//STEP0163 EXEC IPLCOMPR,CDSN=SYS1.SCEESPCO\n//STEP0164 EXEC IPLCOMPR,CDSN=SYS1.SCEEUMAP\n//STEP0165 EXEC IPLCOMPR,CDSN=SYS1.SCEEUTBL\n//STEP0166 EXEC IPLCOMPR,CDSN=SYS1.SCIMXML\n//STEP0167 EXEC IPLCOMPR,CDSN=SYS1.SCLBCPP\n//STEP0168 EXEC IPLCOMPR,CDSN=SYS1.SCLBDLL\n//STEP0169 EXEC IPLCOMPR,CDSN=SYS1.SCLBDLL2\n//STEP0170 EXEC IPLCOMPR,CDSN=SYS1.SCLBSID\n//STEP0171 EXEC IPLCOMPR,CDSN=SYS1.SCMXDBRM\n//STEP0172 EXEC IPLCOMPR,CDSN=SYS1.SCSFCLI0\n//STEP0173 EXEC IPLCOMPR,CDSN=SYS1.SCSFHDRS\n//STEP0174 EXEC IPLCOMPR,CDSN=SYS1.SCSFMOD0\n//STEP0175 EXEC IPLCOMPR,CDSN=SYS1.SCSFMOD1\n//STEP0176 EXEC IPLCOMPR,CDSN=SYS1.SCSFMSG0\n//STEP0177 EXEC IPLCOMPR,CDSN=SYS1.SCSFOBJ\n//STEP0178 EXEC IPLCOMPR,CDSN=SYS1.SCSFPNL0\n//STEP0179 EXEC IPLCOMPR,CDSN=SYS1.SCSFSKL0\n//STEP0180 EXEC IPLCOMPR,CDSN=SYS1.SCSFTLIB\n//STEP0181 EXEC IPLCOMPR,CDSN=SYS1.SCTVJCL\n//STEP0182 EXEC IPLCOMPR,CDSN=SYS1.SCTVMOD\n//STEP0183 EXEC IPLCOMPR,CDSN=SYS1.SCUNHF\n//STEP0184 EXEC IPLCOMPR,CDSN=SYS1.SCUNIMG\n//STEP0185 EXEC IPLCOMPR,CDSN=SYS1.SCUNJCL\n//STEP0186 EXEC IPLCOMPR,CDSN=SYS1.SCUNLOCL\n//STEP0187 EXEC IPLCOMPR,CDSN=SYS1.SCUNMENU\n//STEP0188 EXEC IPLCOMPR,CDSN=SYS1.SCUNTBL\n//STEP0189 EXEC IPLCOMPR,CDSN=SYS1.SDFQPSRC\n//STEP0190 EXEC IPLCOMPR,CDSN=SYS1.SDGICMD\n//STEP0191 EXEC IPLCOMPR,CDSN=SYS1.SDGIHPEU\n//STEP0192 EXEC IPLCOMPR,CDSN=SYS1.SDGIJCL\n//STEP0193 EXEC IPLCOMPR,CDSN=SYS1.SDGILMD\n//STEP0194 EXEC IPLCOMPR,CDSN=SYS1.SDGILPA\n//STEP0195 EXEC IPLCOMPR,CDSN=SYS1.SDGIMSEU\n//STEP0196 EXEC IPLCOMPR,CDSN=SYS1.SDGIPNEU\n//STEP0197 EXEC IPLCOMPR,CDSN=SYS1.SDGISAM\n//STEP0198 EXEC IPLCOMPR,CDSN=SYS1.SDGISK\n//STEP0199 EXEC IPLCOMPR,CDSN=SYS1.SDGISKEU\n//STEP0200 EXEC IPLCOMPR,CDSN=SYS1.SDGITBEU\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0201 EXEC IPLCOMPR,CDSN=SYS1.SDGITUEU\n//STEP0202 EXEC IPLCOMPR,CDSN=SYS1.SDGTPSRC\n//STEP0203 EXEC IPLCOMPR,CDSN=SYS1.SDGTTSRC\n//STEP0204 EXEC IPLCOMPR,CDSN=SYS1.SDITMOD1\n//STEP0205 EXEC IPLCOMPR,CDSN=SYS1.SDITPLIB\n//STEP0206 EXEC IPLCOMPR,CDSN=SYS1.SDITSAM1\n//STEP0207 EXEC IPLCOMPR,CDSN=SYS1.SDMSSVM\n//STEP0208 EXEC IPLCOMPR,CDSN=SYS1.SDMSSVMS\n//STEP0209 EXEC IPLCOMPR,CDSN=SYS1.SDWWDLPA\n//STEP0210 EXEC IPLCOMPR,CDSN=SYS1.SEAGALT\n//STEP0211 EXEC IPLCOMPR,CDSN=SYS1.SEAGJENU\n//STEP0212 EXEC IPLCOMPR,CDSN=SYS1.SEAGMENU\n//STEP0213 EXEC IPLCOMPR,CDSN=SYS1.SEAGSAM\n//STEP0214 EXEC IPLCOMPR,CDSN=SYS1.SEDGEXE1\n//STEP0215 EXEC IPLCOMPR,CDSN=SYS1.SEDGMENU\n//STEP0216 EXEC IPLCOMPR,CDSN=SYS1.SEDGPENU\n//STEP0217 EXEC IPLCOMPR,CDSN=SYS1.SEDGPSRC\n//STEP0218 EXEC IPLCOMPR,CDSN=SYS1.SEEQINST\n//STEP0219 EXEC IPLCOMPR,CDSN=SYS1.SEOXFONT\n//STEP0220 EXEC IPLCOMPR,CDSN=SYS1.SEOXIENU\n//STEP0221 EXEC IPLCOMPR,CDSN=SYS1.SEOXOENU\n//STEP0222 EXEC IPLCOMPR,CDSN=SYS1.SEOX1ENU\n//STEP0223 EXEC IPLCOMPR,CDSN=SYS1.SEOX2ENU\n//STEP0224 EXEC IPLCOMPR,CDSN=SYS1.SEOX3ENU\n//STEP0225 EXEC IPLCOMPR,CDSN=SYS1.SEOX4ENU\n//STEP0226 EXEC IPLCOMPR,CDSN=SYS1.SEOYAENU\n//STEP0227 EXEC IPLCOMPR,CDSN=SYS1.SEOYBENU\n//STEP0228 EXEC IPLCOMPR,CDSN=SYS1.SEOYCLIB\n//STEP0229 EXEC IPLCOMPR,CDSN=SYS1.SEOYGENU\n//STEP0230 EXEC IPLCOMPR,CDSN=SYS1.SEOYIENU\n//STEP0231 EXEC IPLCOMPR,CDSN=SYS1.SEOYIPRF\n//STEP0232 EXEC IPLCOMPR,CDSN=SYS1.SEOYLENU\n//STEP0233 EXEC IPLCOMPR,CDSN=SYS1.SEOYLEXS\n//STEP0234 EXEC IPLCOMPR,CDSN=SYS1.SEOYLOAD\n//STEP0235 EXEC IPLCOMPR,CDSN=SYS1.SEOYLPA\n//STEP0236 EXEC IPLCOMPR,CDSN=SYS1.SEOYMC30\n//STEP0237 EXEC IPLCOMPR,CDSN=SYS1.SEOYMC40\n//STEP0238 EXEC IPLCOMPR,CDSN=SYS1.SEOYMENU\n//STEP0239 EXEC IPLCOMPR,CDSN=SYS1.SEOYOENU\n//STEP0240 EXEC IPLCOMPR,CDSN=SYS1.SEOYPENU\n//STEP0241 EXEC IPLCOMPR,CDSN=SYS1.SEOYPROC\n//STEP0242 EXEC IPLCOMPR,CDSN=SYS1.SEOYSAMP\n//STEP0243 EXEC IPLCOMPR,CDSN=SYS1.SEOYSENU\n//STEP0244 EXEC IPLCOMPR,CDSN=SYS1.SEOYTENU\n//STEP0245 EXEC IPLCOMPR,CDSN=SYS1.SEOYXENU\n//STEP0246 EXEC IPLCOMPR,CDSN=SYS1.SEOY1ENU\n//STEP0247 EXEC IPLCOMPR,CDSN=SYS1.SEOY2ENU\n//STEP0248 EXEC IPLCOMPR,CDSN=SYS1.SEOY4ENU\n//STEP0249 EXEC IPLCOMPR,CDSN=SYS1.SEPHBOK1\n//STEP0250 EXEC IPLCOMPR,CDSN=SYS1.SEPHCLB1\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0251 EXEC IPLCOMPR,CDSN=SYS1.SEPHCLIB\n//STEP0252 EXEC IPLCOMPR,CDSN=SYS1.SEPHDAT1\n//STEP0253 EXEC IPLCOMPR,CDSN=SYS1.SEPHLOD1\n//STEP0254 EXEC IPLCOMPR,CDSN=SYS1.SEPHMSG1\n//STEP0255 EXEC IPLCOMPR,CDSN=SYS1.SEPHPNL1\n//STEP0256 EXEC IPLCOMPR,CDSN=SYS1.SEPHSAMP\n//STEP0257 EXEC IPLCOMPR,CDSN=SYS1.SEPHSAM1\n//STEP0258 EXEC IPLCOMPR,CDSN=SYS1.SEPHTAB\n//STEP0259 EXEC IPLCOMPR,CDSN=SYS1.SEPHTBL1\n//STEP0260 EXEC IPLCOMPR,CDSN=SYS1.SEPWBENU\n//STEP0261 EXEC IPLCOMPR,CDSN=SYS1.SEPWCENU\n//STEP0262 EXEC IPLCOMPR,CDSN=SYS1.SEPWMAC1\n//STEP0263 EXEC IPLCOMPR,CDSN=SYS1.SEPWMOD1\n//STEP0264 EXEC IPLCOMPR,CDSN=SYS1.SEPWMOD2\n//STEP0265 EXEC IPLCOMPR,CDSN=SYS1.SEPWMOD3\n//STEP0266 EXEC IPLCOMPR,CDSN=SYS1.SEPWMOD4\n//STEP0267 EXEC IPLCOMPR,CDSN=SYS1.SEPWPENU\n//STEP0268 EXEC IPLCOMPR,CDSN=SYS1.SEPWSRC1\n//STEP0269 EXEC IPLCOMPR,CDSN=SYS1.SEPWSRC2\n//STEP0270 EXEC IPLCOMPR,CDSN=SYS1.SERBCLS\n//STEP0271 EXEC IPLCOMPR,CDSN=SYS1.SERBLINK\n//STEP0272 EXEC IPLCOMPR,CDSN=SYS1.SERBLPA\n//STEP0273 EXEC IPLCOMPR,CDSN=SYS1.SERBMENU\n//STEP0274 EXEC IPLCOMPR,CDSN=SYS1.SERBPENU\n//STEP0275 EXEC IPLCOMPR,CDSN=SYS1.SERBPWSV\n//STEP0276 EXEC IPLCOMPR,CDSN=SYS1.SERBT\n//STEP0277 EXEC IPLCOMPR,CDSN=SYS1.SERBTENU\n//STEP0278 EXEC IPLCOMPR,CDSN=SYS1.SEUVACF\n//STEP0279 EXEC IPLCOMPR,CDSN=SYS1.SEUVDBRM\n//STEP0280 EXEC IPLCOMPR,CDSN=SYS1.SEUVEXEC\n//STEP0281 EXEC IPLCOMPR,CDSN=SYS1.SEUVEXP\n//STEP0282 EXEC IPLCOMPR,CDSN=SYS1.SEUVFEXC\n//STEP0283 EXEC IPLCOMPR,CDSN=SYS1.SEUVFLIB\n//STEP0284 EXEC IPLCOMPR,CDSN=SYS1.SEUVFSAM\n//STEP0285 EXEC IPLCOMPR,CDSN=SYS1.SEUVHDR\n//STEP0286 EXEC IPLCOMPR,CDSN=SYS1.SEUVHDRK\n//STEP0287 EXEC IPLCOMPR,CDSN=SYS1.SEUVIDL\n//STEP0288 EXEC IPLCOMPR,CDSN=SYS1.SEUVLIB\n//STEP0289 EXEC IPLCOMPR,CDSN=SYS1.SEUVLIBK\n//STEP0290 EXEC IPLCOMPR,CDSN=SYS1.SEUVLIBS\n//STEP0291 EXEC IPLCOMPR,CDSN=SYS1.SEUVLINK\n//STEP0292 EXEC IPLCOMPR,CDSN=SYS1.SEUVLPA\n//STEP0293 EXEC IPLCOMPR,CDSN=SYS1.SEUVMSG\n//STEP0294 EXEC IPLCOMPR,CDSN=SYS1.SEUVPNL\n//STEP0295 EXEC IPLCOMPR,CDSN=SYS1.SEUVPRC\n//STEP0296 EXEC IPLCOMPR,CDSN=SYS1.SEZACMAC\n//STEP0297 EXEC IPLCOMPR,CDSN=SYS1.SEZACMTX\n//STEP0298 EXEC IPLCOMPR,CDSN=SYS1.SEZADBCX\n//STEP0299 EXEC IPLCOMPR,CDSN=SYS1.SEZADBRM\n//STEP0300 EXEC IPLCOMPR,CDSN=SYS1.SEZADPIL\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0301 EXEC IPLCOMPR,CDSN=SYS1.SEZADSIL\n//STEP0302 EXEC IPLCOMPR,CDSN=SYS1.SEZADSIM\n//STEP0303 EXEC IPLCOMPR,CDSN=SYS1.SEZADSIP\n//STEP0304 EXEC IPLCOMPR,CDSN=SYS1.SEZAINST\n//STEP0305 EXEC IPLCOMPR,CDSN=SYS1.SEZALIBN\n//STEP0306 EXEC IPLCOMPR,CDSN=SYS1.SEZALNK2\n//STEP0307 EXEC IPLCOMPR,CDSN=SYS1.SEZALOAD\n//STEP0308 EXEC IPLCOMPR,CDSN=SYS1.SEZALPA\n//STEP0309 EXEC IPLCOMPR,CDSN=SYS1.SEZAMENU\n//STEP0310 EXEC IPLCOMPR,CDSN=SYS1.SEZANCLS\n//STEP0311 EXEC IPLCOMPR,CDSN=SYS1.SEZANMAC\n//STEP0312 EXEC IPLCOMPR,CDSN=SYS1.SEZANPNL\n//STEP0313 EXEC IPLCOMPR,CDSN=SYS1.SEZAOLDX\n//STEP0314 EXEC IPLCOMPR,CDSN=SYS1.SEZAPENU\n//STEP0315 EXEC IPLCOMPR,CDSN=SYS1.SEZARNT1\n//STEP0316 EXEC IPLCOMPR,CDSN=SYS1.SEZARNT2\n//STEP0317 EXEC IPLCOMPR,CDSN=SYS1.SEZARNT3\n//STEP0318 EXEC IPLCOMPR,CDSN=SYS1.SEZARNT4\n//STEP0319 EXEC IPLCOMPR,CDSN=SYS1.SEZAROE1\n//STEP0320 EXEC IPLCOMPR,CDSN=SYS1.SEZAROE2\n//STEP0321 EXEC IPLCOMPR,CDSN=SYS1.SEZAROE3\n//STEP0322 EXEC IPLCOMPR,CDSN=SYS1.SEZARPCL\n//STEP0323 EXEC IPLCOMPR,CDSN=SYS1.SEZATCP\n//STEP0324 EXEC IPLCOMPR,CDSN=SYS1.SEZATCPX\n//STEP0325 EXEC IPLCOMPR,CDSN=SYS1.SEZATELX\n//STEP0326 EXEC IPLCOMPR,CDSN=SYS1.SEZAXAWL\n//STEP0327 EXEC IPLCOMPR,CDSN=SYS1.SEZAXLD1\n//STEP0328 EXEC IPLCOMPR,CDSN=SYS1.SEZAXLD2\n//STEP0329 EXEC IPLCOMPR,CDSN=SYS1.SEZAXMLB\n//STEP0330 EXEC IPLCOMPR,CDSN=SYS1.SEZAXTLB\n//STEP0331 EXEC IPLCOMPR,CDSN=SYS1.SEZAX11L\n//STEP0332 EXEC IPLCOMPR,CDSN=SYS1.SFOMDATA\n//STEP0333 EXEC IPLCOMPR,CDSN=SYS1.SFOMHDRS\n//STEP0334 EXEC IPLCOMPR,CDSN=SYS1.SFOMOBJ\n//STEP0335 EXEC IPLCOMPR,CDSN=SYS1.SGIMCLS0\n//STEP0336 EXEC IPLCOMPR,CDSN=SYS1.SGIMLMD0\n//STEP0337 EXEC IPLCOMPR,CDSN=SYS1.SGIMMENU\n//STEP0338 EXEC IPLCOMPR,CDSN=SYS1.SGIMPENU\n//STEP0339 EXEC IPLCOMPR,CDSN=SYS1.SGIMSENU\n//STEP0340 EXEC IPLCOMPR,CDSN=SYS1.SGIMTENU\n//STEP0341 EXEC IPLCOMPR,CDSN=SYS1.SGLDEXEC\n//STEP0342 EXEC IPLCOMPR,CDSN=SYS1.SGLDEXPC\n//STEP0343 EXEC IPLCOMPR,CDSN=SYS1.SGLDHDRC\n//STEP0344 EXEC IPLCOMPR,CDSN=SYS1.SGLDSAMP\n//STEP0345 EXEC IPLCOMPR,CDSN=SYS1.SGSKSAMP\n//STEP0346 EXEC IPLCOMPR,CDSN=SYS1.SHASLNKE\n//STEP0347 EXEC IPLCOMPR,CDSN=SYS1.SHASMAC\n//STEP0348 EXEC IPLCOMPR,CDSN=SYS1.SHASMENU\n//STEP0349 EXEC IPLCOMPR,CDSN=SYS1.SHASMIG\n//STEP0350 EXEC IPLCOMPR,CDSN=SYS1.SHASPARM\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0351 EXEC IPLCOMPR,CDSN=SYS1.SHASPNL0\n//STEP0352 EXEC IPLCOMPR,CDSN=SYS1.SHASSAMP\n//STEP0353 EXEC IPLCOMPR,CDSN=SYS1.SHASSRC\n//STEP0354 EXEC IPLCOMPR,CDSN=SYS1.SIBMAM24\n//STEP0355 EXEC IPLCOMPR,CDSN=SYS1.SIBMCALL\n//STEP0356 EXEC IPLCOMPR,CDSN=SYS1.SIBMCAL2\n//STEP0357 EXEC IPLCOMPR,CDSN=SYS1.SIBMMATH\n//STEP0358 EXEC IPLCOMPR,CDSN=SYS1.SIBMTASK\n//STEP0359 EXEC IPLCOMPR,CDSN=SYS1.SICECLIB\n//STEP0360 EXEC IPLCOMPR,CDSN=SYS1.SICELINK\n//STEP0361 EXEC IPLCOMPR,CDSN=SYS1.SICELPA\n//STEP0362 EXEC IPLCOMPR,CDSN=SYS1.SICEMENU\n//STEP0363 EXEC IPLCOMPR,CDSN=SYS1.SICEPENU\n//STEP0364 EXEC IPLCOMPR,CDSN=SYS1.SICEPROC\n//STEP0365 EXEC IPLCOMPR,CDSN=SYS1.SICESAMP\n//STEP0366 EXEC IPLCOMPR,CDSN=SYS1.SICESLIB\n//STEP0367 EXEC IPLCOMPR,CDSN=SYS1.SICESRCE\n//STEP0368 EXEC IPLCOMPR,CDSN=SYS1.SICETLIB\n//STEP0369 EXEC IPLCOMPR,CDSN=SYS1.SICEUSER\n//STEP0370 EXEC IPLCOMPR,CDSN=SYS1.SIEAHDR.H\n//STEP0371 EXEC IPLCOMPR,CDSN=SYS1.SIEAHDRV.H\n//STEP0372 EXEC IPLCOMPR,CDSN=SYS1.SIEALNKE\n//STEP0373 EXEC IPLCOMPR,CDSN=SYS1.SIEAMIGE\n//STEP0374 EXEC IPLCOMPR,CDSN=SYS1.SIEASID\n//STEP0375 EXEC IPLCOMPR,CDSN=SYS1.SIFALIB\n//STEP0376 EXEC IPLCOMPR,CDSN=SYS1.SIMWSDCK\n//STEP0377 EXEC IPLCOMPR,CDSN=SYS1.SIMWTBL1\n//STEP0378 EXEC IPLCOMPR,CDSN=SYS1.SIOAIBIN\n//STEP0379 EXEC IPLCOMPR,CDSN=SYS1.SIOAJAVA\n//STEP0380 EXEC IPLCOMPR,CDSN=SYS1.SIOALMOD\n//STEP0381 EXEC IPLCOMPR,CDSN=SYS1.SIOAMMOD\n//STEP0382 EXEC IPLCOMPR,CDSN=SYS1.SIOASAMP\n//STEP0383 EXEC IPLCOMPR,CDSN=SYS1.SIOEEXEC\n//STEP0384 EXEC IPLCOMPR,CDSN=SYS1.SIOELMOD\n//STEP0385 EXEC IPLCOMPR,CDSN=SYS1.SIOEMSGE\n//STEP0386 EXEC IPLCOMPR,CDSN=SYS1.SIOEPNLE\n//STEP0387 EXEC IPLCOMPR,CDSN=SYS1.SIOEPROC\n//STEP0388 EXEC IPLCOMPR,CDSN=SYS1.SIOESAMP\n//STEP0389 EXEC IPLCOMPR,CDSN=SYS1.SISFEXEC\n//STEP0390 EXEC IPLCOMPR,CDSN=SYS1.SISFHELP\n//STEP0391 EXEC IPLCOMPR,CDSN=SYS1.SISFJCL\n//STEP0392 EXEC IPLCOMPR,CDSN=SYS1.SISFLINK\n//STEP0393 EXEC IPLCOMPR,CDSN=SYS1.SISFLOAD\n//STEP0394 EXEC IPLCOMPR,CDSN=SYS1.SISFLPA\n//STEP0395 EXEC IPLCOMPR,CDSN=SYS1.SISFMLIB\n//STEP0396 EXEC IPLCOMPR,CDSN=SYS1.SISFPLIB\n//STEP0397 EXEC IPLCOMPR,CDSN=SYS1.SISFSLIB\n//STEP0398 EXEC IPLCOMPR,CDSN=SYS1.SISFSRC\n//STEP0399 EXEC IPLCOMPR,CDSN=SYS1.SISFTLIB\n//STEP0400 EXEC IPLCOMPR,CDSN=SYS1.SISPALIB\n//IPLBLD91 JOB NONE,PGG,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)\n//INCLUDE  INCLUDE MEMBER=IPLBLD00\n//STEP0401 EXEC IPLCOMPR,CDSN=SYS1.SISPCLIB\n//STEP0402 EXEC IPLCOMPR,CDSN=SYS1.SISPEXEC\n//STEP0403 EXEC IPLCOMPR,CDSN=SYS1.SISPGENU\n//STEP0404 EXEC IPLCOMPR,CDSN=SYS1.SISPGMLI\n//STEP0405 EXEC IPLCOMPR,CDSN=SYS1.SISPGUI\n//STEP0406 EXEC IPLCOMPR,CDSN=SYS1.SISPHELP\n//STEP0407 EXEC IPLCOMPR,CDSN=SYS1.SISPLOAD\n//STEP0408 EXEC IPLCOMPR,CDSN=SYS1.SISPLPA\n//STEP0409 EXEC IPLCOMPR,CDSN=SYS1.SISPMACS\n//STEP0410 EXEC IPLCOMPR,CDSN=SYS1.SISPMENU\n//STEP0411 EXEC IPLCOMPR,CDSN=SYS1.SISPPENU\n//STEP0412 EXEC IPLCOMPR,CDSN=SYS1.SISPSAMP\n//STEP0413 EXEC IPLCOMPR,CDSN=SYS1.SISPSENU\n//STEP0414 EXEC IPLCOMPR,CDSN=SYS1.SISPSLIB\n//STEP0415 EXEC IPLCOMPR,CDSN=SYS1.SISPTENU\n//STEP0416 EXEC IPLCOMPR,CDSN=SYS1.SISTASGD\n//STEP0417 EXEC IPLCOMPR,CDSN=SYS1.SISTASN1\n//STEP0418 EXEC IPLCOMPR,CDSN=SYS1.SISTCLIB\n//STEP0419 EXEC IPLCOMPR,CDSN=SYS1.SISTCMIP\n//STEP0420 EXEC IPLCOMPR,CDSN=SYS1.SISTDAT1\n//STEP0421 EXEC IPLCOMPR,CDSN=SYS1.SISTDAT2\n//STEP0422 EXEC IPLCOMPR,CDSN=SYS1.SISTGDMO\n//STEP0423 EXEC IPLCOMPR,CDSN=SYS1.SISTMAC1\n//STEP0424 EXEC IPLCOMPR,CDSN=SYS1.SOLVEOPS.MSLPLOAD\n//STEP0425 EXEC IPLCOMPR,CDSN=SYS1.SORTLIB\n//STEP0426 EXEC IPLCOMPR,CDSN=SYS1.SORTLPA\n//STEP0427 EXEC IPLCOMPR,CDSN=SYS1.SVCLIB\n//STEP0428 EXEC IPLCOMPR,CDSN=SYS1.SYSVIEW.SCSYLPA\n//STEP0429 EXEC IPLCOMPR,CDSN=SYS1.TCPIP.OS27.PARMS\n//STEP0430 EXEC IPLCOMPR,CDSN=SYS1.UADS\n//STEP0431 EXEC IPLCOMPR,CDSN=SYS1.VTAMLIB\n//STEP0432 EXEC IPLCOMPR,CDSN=SYS2.CAI.PPOPTION\n//STEP0433 EXEC IPLCOMPR,CDSN=SYS2.IMAGELIB\n//STEP0434 EXEC IPLCOMPR,CDSN=SYS2.LINKLIB\n//STEP0435 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAICICS\n//STEP0436 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAICLIB\n//STEP0437 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAIISPM\n//STEP0438 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAIISPP\n//STEP0439 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAILIB\n//STEP0440 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAIMAC\n//STEP0441 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAIPDSE\n//STEP0442 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAIPROC\n//STEP0443 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.CAISRC\n//STEP0444 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.EXP\n//STEP0445 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.MIBLIB\n//STEP0446 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.PPOPTION\n//STEP0447 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.SRCLIB\n//STEP0448 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.TNG.CAILIB\n//STEP0449 EXEC IPLCOMPR,CDSN=SYS3.CACOMMON.TNG.CUSLIB\n//STEP0450 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.COBIN\n//STEP0451 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.CTRANS\n//STEP0452 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.DBRMLIB\n//STEP0453 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.GTFDATA\n//STEP0454 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.IUIMAPS\n//STEP0455 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.LINKLIB\n//STEP0456 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.LOADCICS\n//STEP0457 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.LOADLIB\n//STEP0458 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.MIBLIB\n//STEP0459 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.MODEL\n//STEP0460 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.NULLFILE\n//STEP0461 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.OBJLIBC\n//STEP0462 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.PRODDATA\n//STEP0463 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SAMPLIB\n//STEP0464 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SCREEN\n//STEP0465 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SPFHLIB\n//STEP0466 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SPFMLIB\n//STEP0467 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SPFPLIB\n//STEP0468 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SPFSLIB\n//STEP0469 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.SPFTLIB\n//STEP0470 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.TGTREQ\n//STEP0471 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.USERASM\n//STEP0472 EXEC IPLCOMPR,CDSN=SYS3.CADBMS.XMESSAGE\n//STEP0473 EXEC IPLCOMPR,CDSN=SYS3.CAFAVER.LINKLIB\n//STEP0474 EXEC IPLCOMPR,CDSN=SYS3.CAHYPBUF.CAIISPC\n//STEP0475 EXEC IPLCOMPR,CDSN=SYS3.CAHYPBUF.CAIISPM\n//STEP0476 EXEC IPLCOMPR,CDSN=SYS3.CAHYPBUF.CAIISPP\n//STEP0477 EXEC IPLCOMPR,CDSN=SYS3.CAHYPBUF.CAILIB\n//STEP0478 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CAILIB\n//STEP0479 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CAIMAC\n//STEP0480 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLJ43CML\n//STEP0481 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLJ43CPL\n//STEP0482 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLJ43CSL\n//STEP0483 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLJ43CTL\n//STEP0484 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLU43EML\n//STEP0485 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLU43EPL\n//STEP0486 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLU43ESL\n//STEP0487 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLU43ETL\n//STEP0488 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLU43REX\n//STEP0489 EXEC IPLCOMPR,CDSN=SYS3.CALIBR.CLU43THL\n//STEP0490 EXEC IPLCOMPR,CDSN=SYS3.CASMFDIR.CAILIB\n//STEP0491 EXEC IPLCOMPR,CDSN=SYS3.CASMFDIR.CAIPROC\n//STEP0492 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.INSTALL\n//STEP0493 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.LOADLIB\n//STEP0494 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.SAMEXEC\n//STEP0495 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.SAMMSG0\n//STEP0496 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.SAMPJCL\n//STEP0497 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.SAMPNL0\n//STEP0498 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.SAMSKL0\n//STEP0499 EXEC IPLCOMPR,CDSN=SYS3.CAVTAPE.SAMTBL0\n//STEP0500 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAICLIB\n//STEP0501 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAIISPM\n//STEP0502 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAIISPP\n//STEP0503 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAIISPT\n//STEP0504 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAILIB\n//STEP0505 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAIMAC\n//STEP0506 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAIPROC\n//STEP0507 EXEC IPLCOMPR,CDSN=SYS3.CA1.CAISRC\n//STEP0508 EXEC IPLCOMPR,CDSN=SYS3.CA1.PPOPTION\n//STEP0509 EXEC IPLCOMPR,CDSN=SYS3.CA1CPYCT.CAILIB\n//STEP0510 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLCXCNTL\n//STEP0511 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLCXEXEC\n//STEP0512 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLCXLOAD\n//STEP0513 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLCXMENU\n//STEP0514 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLCXPENU\n//STEP0515 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLMSCNTL\n//STEP0516 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLMSLOAD\n//STEP0517 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLMSMENU\n//STEP0518 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLMSPENU\n//STEP0519 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLMSSAMP\n//STEP0520 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLMSSENU\n//STEP0521 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTAUTH\n//STEP0522 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTCLIB\n//STEP0523 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTHENU\n//STEP0524 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTINCL\n//STEP0525 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTINST\n//STEP0526 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTLOAD\n//STEP0527 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTMENU\n//STEP0528 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTPENU\n//STEP0529 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTRBLD\n//STEP0530 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTSAMP\n//STEP0531 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTSENU\n//STEP0532 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SLXTTABL\n//STEP0533 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SMXDAAFX\n//STEP0534 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SMXDAUTH\n//STEP0535 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SMXDO65L\n//STEP0536 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SMXDPDSE\n//STEP0537 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.SMXDSAMP\n//STEP0538 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.TS22.SMXDAAFX\n//STEP0539 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.TS22.SMXDAUTH\n//STEP0540 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.TS22.SMXDO62L\n//STEP0541 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.TS22.SMXDPDSE\n//STEP0542 EXEC IPLCOMPR,CDSN=SYS3.COMPWARE.TS22.SMXDSAMP\n//STEP0543 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.CLIST\n//STEP0544 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.DEMOSRCE\n//STEP0545 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.ISPFMSG\n//STEP0546 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.JCLLIB\n//STEP0547 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.LOADLIB\n//STEP0548 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.PANELS\n//STEP0549 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.PARMLIB\n//STEP0550 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.SKELS\n//STEP0551 EXEC IPLCOMPR,CDSN=SYS3.DATAINV.TEXT\n//STEP0552 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.AUTHLIB\n//STEP0553 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.CONLIB\n//STEP0554 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.ISPMLIB\n//STEP0555 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.ISPPLIB\n//STEP0556 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.ISPSLIB\n//STEP0557 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.ISPTLIB\n//STEP0558 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.ISRCLIB\n//STEP0559 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.JCLLIB\n//STEP0560 EXEC IPLCOMPR,CDSN=SYS3.ENDVR.SOURCE\n//STEP0561 EXEC IPLCOMPR,CDSN=SYS3.FILEAID.CLIST\n//STEP0562 EXEC IPLCOMPR,CDSN=SYS3.FILEAID.ISPMLIB\n//STEP0563 EXEC IPLCOMPR,CDSN=SYS3.FILEAID.ISPPLIB\n//STEP0564 EXEC IPLCOMPR,CDSN=SYS3.FILEAID.ISPSLIB\n//STEP0565 EXEC IPLCOMPR,CDSN=SYS3.FILEAID.ISPTLIB\n//STEP0566 EXEC IPLCOMPR,CDSN=SYS3.FILEAID.LOAD\n//STEP0567 EXEC IPLCOMPR,CDSN=SYS3.IOA.ISPSLIB\n//STEP0568 EXEC IPLCOMPR,CDSN=SYS3.IOA.ISPTLIB\n//STEP0569 EXEC IPLCOMPR,CDSN=SYS3.IOA.LOAD\n//STEP0570 EXEC IPLCOMPR,CDSN=SYS3.IOA.LOADE\n//STEP0571 EXEC IPLCOMPR,CDSN=SYS3.IOA1.CLIST\n//STEP0572 EXEC IPLCOMPR,CDSN=SYS3.IOA1.CTRANS\n//STEP0573 EXEC IPLCOMPR,CDSN=SYS3.IOA1.DOC\n//STEP0574 EXEC IPLCOMPR,CDSN=SYS3.IOA1.IOAENV\n//STEP0575 EXEC IPLCOMPR,CDSN=SYS3.IOA1.ISMSGENG\n//STEP0576 EXEC IPLCOMPR,CDSN=SYS3.IOA1.KSL\n//STEP0577 EXEC IPLCOMPR,CDSN=SYS3.IOA1.MAC\n//STEP0578 EXEC IPLCOMPR,CDSN=SYS3.IOA1.MSGENG\n//STEP0579 EXEC IPLCOMPR,CDSN=SYS3.IOA1.PANELENG\n//STEP0580 EXEC IPLCOMPR,CDSN=SYS3.IOA1.SIML\n//STEP0581 EXEC IPLCOMPR,CDSN=SYS3.IOA1.SSAROMOD\n//STEP0582 EXEC IPLCOMPR,CDSN=SYS3.LRS.DRS.CNTL\n//STEP0583 EXEC IPLCOMPR,CDSN=SYS3.LRS.DRS.LOAD\n//STEP0584 EXEC IPLCOMPR,CDSN=SYS3.LRS.LOAD\n//STEP0585 EXEC IPLCOMPR,CDSN=SYS3.LRS.VSV.LOAD\n//STEP0586 EXEC IPLCOMPR,CDSN=SYS3.MXG.LOADLIB\n//STEP0587 EXEC IPLCOMPR,CDSN=SYS3.MXG.SOURCLIB\n//STEP0588 EXEC IPLCOMPR,CDSN=SYS3.MXG.USER.SOURCLIB\n//STEP0589 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANCLIB\n//STEP0590 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANDBRM\n//STEP0591 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANDB2J\n//STEP0592 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANJLIB\n//STEP0593 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANLOAD\n//STEP0594 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANMLIB\n//STEP0595 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANOPTS\n//STEP0596 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANPLIB\n//STEP0597 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANSAMP\n//STEP0598 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANSLIB\n//STEP0599 EXEC IPLCOMPR,CDSN=SYS3.RIO.VANTLIB\n//STEP0600 EXEC IPLCOMPR,CDSN=SYS3.SAS.CONFIG\n//STEP0601 EXEC IPLCOMPR,CDSN=SYS3.SAS.ENW0.SASMSG\n//STEP0602 EXEC IPLCOMPR,CDSN=SYS3.SAS.LIBE\n//STEP0603 EXEC IPLCOMPR,CDSN=SYS3.SAS.LIBRARY\n//STEP0604 EXEC IPLCOMPR,CDSN=SYS3.SAS.NEWS\n//STEP0605 EXEC IPLCOMPR,CDSN=SYS3.SAS.TKMVSENV\n//STEP0606 EXEC IPLCOMPR,CDSN=SYS3.SAS.W0.AUTOLIB\n//STEP0607 EXEC IPLCOMPR,CDSN=SYS3.SENTINEL.LOAD\n//STEP0608 EXEC IPLCOMPR,CDSN=SYS3.SOLVE.NMB5.ASTEXEC\n//STEP0609 EXEC IPLCOMPR,CDSN=SYS3.SOLVE.NMB5.MELOAD\n//STEP0610 EXEC IPLCOMPR,CDSN=SYS3.SOLVE.NMB5.MSLOAD\n//STEP0611 EXEC IPLCOMPR,CDSN=SYS3.SOLVE.NMB5.MSTEXEC\n//STEP0612 EXEC IPLCOMPR,CDSN=SYS3.SOLVE.NMB5.SNLOAD\n//STEP0613 EXEC IPLCOMPR,CDSN=SYS3.SOLVE.NMB5.SNTEXEC\n//STEP0614 EXEC IPLCOMPR,CDSN=SYS3.SOLVEMAI.ACSAMP\n//STEP0615 EXEC IPLCOMPR,CDSN=SYS3.SOLVEMAI.ACTEXEC\n//STEP0616 EXEC IPLCOMPR,CDSN=SYS3.SOLVEMAI.LPALOAD\n//STEP0617 EXEC IPLCOMPR,CDSN=SYS3.SOLVEMAI.MSLOAD\n//STEP0618 EXEC IPLCOMPR,CDSN=SYS3.SOLVEMAI.MSSAMP\n//STEP0619 EXEC IPLCOMPR,CDSN=SYS3.SOLVEMAI.MSTEXEC\n//STEP0620 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.ASTEXEC\n//STEP0621 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.MELOAD\n//STEP0622 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.MSCMDLIB\n//STEP0623 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.MSLNKLST\n//STEP0624 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.MSLOAD\n//STEP0625 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.MSTEXEC\n//STEP0626 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.SSIPARM\n//STEP0627 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.SSLOAD\n//STEP0628 EXEC IPLCOMPR,CDSN=SYS3.SOLVEOPS.SSTEXEC\n//STEP0629 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.AGNT.SCSYMIB\n//STEP0630 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.AGNT.SCSYPDSE\n//STEP0631 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.AGNT.SCSYSAMP\n//STEP0632 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYCAP\n//STEP0633 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYCLST\n//STEP0634 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYCMS\n//STEP0635 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYHELP\n//STEP0636 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYINST\n//STEP0637 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYISPF\n//STEP0638 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYLOAD\n//STEP0639 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYMAC\n//STEP0640 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYMAP\n//STEP0641 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYMIB\n//STEP0642 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYPANL\n//STEP0643 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYPARM\n//STEP0644 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYPLOT\n//STEP0645 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYPROF\n//STEP0646 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYREXX\n//STEP0647 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.BASE.SCSYSAMP\n//STEP0648 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.EZTR.SCSYMAC\n//STEP0649 EXEC IPLCOMPR,CDSN=SYS3.SYSVIEW.EZTR.SCSYSAMP\n//STEP0650 EXEC IPLCOMPR,CDSN=SYS3.VRS.BCSLOAD\n//STEP0651 EXEC IPLCOMPR,CDSN=SYS3.VRS.BPSLOAD\n//STEP0652 EXEC IPLCOMPR,CDSN=SYS3.VRS.CNTL\n//STEP0653 EXEC IPLCOMPR,CDSN=SYS3.VRS.DLIB\n//STEP0654 EXEC IPLCOMPR,CDSN=SYS3.VRS.LOAD\n//STEP0655 EXEC IPLCOMPR,CDSN=SYS3.VRS.LOAD.D010609\n//STEP0656 EXEC IPLCOMPR,CDSN=SYS3.VRS.SOURCE\n//STEP0657 EXEC IPLCOMPR,CDSN=SYS4.RESVOL.JCL.BACKUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPLCOMPR": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x00\\x11\\x00\\x11\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 17, "newlines": 17, "modlines": 0, "user": "PGILLIS"}, "text": "//IPLCOMPR PROC CDSN=\n//OLDPDS   EXEC PGM=LISTDIR\n//STEPLIB  DD  DISP=SHR,DSN=PPPYG.TOOLS.ISPLLIB\n//SYSUT1   DD  DISP=SHR,DSN=&CDSN,UNIT=SYSDA,VOL=SER=&OLDVOL\n//SYSPRINT DD  DISP=(,PASS),DSN=&&OLD,UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUDUMP DD  SYSOUT=*\n//*\n//NEWPDS   EXEC PGM=LISTDIR\n//STEPLIB  DD  DISP=SHR,DSN=PPPYG.TOOLS.ISPLLIB\n//SYSUT1   DD  DISP=SHR,DSN=&CDSN,UNIT=SYSDA,VOL=SER=&NEWVOL\n//SYSPRINT DD  DISP=(,PASS),DSN=&&NEW,UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUDUMP DD  SYSOUT=*\n//*\n//ISRSUPC  EXEC PGM=ISRSUPC,PARM=(DELTAL,LINECMP,REFMOVR,DLREFM)\n//OLDDD    DD  DISP=(OLD,DELETE),DSN=&&OLD\n//NEWDD    DD  DISP=(OLD,DELETE),DSN=&&NEW\n//OUTDD    DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPLVOLXP": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x003\\x003\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 51, "newlines": 51, "modlines": 0, "user": "PGILLIS"}, "text": "/* rexx */\n/* written to generate the jcl to build z/OS IPL volume */\n/* P. Gillis - MAY 2005 */\n/* P. Gillis - AUGUST 2007 - Ignore lines with * in column 1         */\n/*                         - Do not generate any secondary extents   */\n/*                         - Handle PS and PO datasets               */\n/*                         - LINKLIB and NUCLEUS do not use RLSE     */\n/* P. Gillis - January 2008- Support member copies                   */\n/* P. Gillis - August  2008- Convert to load mod lib compares        */\ntrace o\nj = 0\nk = 0\ns = 0\njobid = 'IPLBLD91'\n\n\"Execio * diskr datasets (finis stem datasets.\"\ndo i = 1 to datasets.0\n   y = substr(datasets.i,4,1)\n   z = substr(datasets.i,6,9)\n   if y /= '-' & index(z,'.') > 1 then do\n      dsnin = strip(substr(datasets.i,6,44))\n      mbr = index(dsnin,'(')\n      x = listdsi(\"'\"dsnin\"' \"      \" directory\")\n      if sysdsorg = 'PO' /* & sysrecfm = 'U' */ then do\n         x = jobcard()\n         j = j + 1\n         trgvol.j = '//'step' EXEC IPLCOMPR,CDSN='dsnin\n      end\n   end\nend\ntrgvol.0 = j\n\"Execio * diskw trgvol (finis stem trgvol.\"\nexit 0\njobcard: ,\n  if s = 0 | s =  50 | s = 100 | s = 150 | s = 200 |,\n             s = 250 | s = 300 | s = 350 | s = 400 then ,\n  do\n     j = j + 1\n     trgvol.j = '//'jobid' JOB NONE,PGG,MSGCLASS=X,' || ,\n                'NOTIFY=&SYSUID'\n     j = j + 1\n     trgvol.j = '//*'\n     j = j + 1\n     trgvol.j = '//JCLLIB   JCLLIB ORDER=(PPPYG.CBT471.FILE382.PDS)'\n     j = j + 1\n     trgvol.j = '//INCLUDE  INCLUDE MEMBER=IPLBLD00'\n  end\n  s = s + 1\n  length = 8 - length(s)\n  step = substr('STEP0000',1,length) || s\nreturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPFSTAT": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x00\\x13\\x00\\x13\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 19, "newlines": 19, "modlines": 0, "user": "PGILLIS"}, "text": "*\n* Mapping for PDS/PDSE ISPF Statistics\n* Requires macro IHAPDS PDSBLDL=NO and NI PDS2LUSR,X'1F' = x'0F' and\n* RECFM = (V or F)\n*\n          ORG   PDS2USRD\nPDS3VERN  DS    CL1                    Version Number x'01-99'\nPDS3MODN  DS    CL1                    Modification Level x'00-99'\nPDS3SCLM  DS    CL1                    SCLM Flags\nPDS3SECS  DS    CL1                    Last Modified Seconds\nPDS3CDAT  DS    CL4                    Create Date CCYYDDDF\nPDS3MDAT  DS    CL4                    Last Modified Date CCYYDDDF\nPDS3HH    DS    CL1                    Last Modified Hours\nPDS3MM    DS    CL1                    Last Modified Minutes\nPDS3LINE  DS    XL2                    Number of Lines\nPDS3INIT  DS    XL2                    Initial Number of Lines\nPDS3MOD   DS    XL2                    Number of Modified Lines\nPDS3USER  DS    CL8                    Userid\nPDS3RSVD  DS    CL2                    Reserved\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTDIR": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01@\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x02t\\x02t\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.64", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 628, "newlines": 628, "modlines": 0, "user": "PGILLIS"}, "text": "LISTDIR  TITLE 'Extract directory information from PDS datasets'\n*---------------------------------------------------------------------*\n*                                                                     *\n* Module Name:          LISTDIR                                       *\n*                                                                     *\n* Operating System:     z/OS 1.4                                      *\n*                                                                     *\n* Function:             This program is designed to extract data from *\n*                       the diretcory of a PDS and return it to the   *\n*                       caller.                                       *\n*                                                                     *\n* Purpose:              List contents of a pds directory.             *\n*                                                                     *\n* Module Type:          Program or Sub-Routine                        *\n*                                                                     *\n* Language:             High Level Assembler                          *\n*                                                                     *\n* Attributes:           Key 8                                         *\n*                       Problem State                                 *\n*                       Re-Entrant                                    *\n*                       AMODE(31)                                     *\n*                       RMODE(31)                                     *\n*                       BAKR/PR                                       *\n*                       ISPF Environment                              *\n*                                                                     *\n* Entry point:          LISTDSI                                       *\n*                                                                     *\n* Input Parms: (PGM)    DDname of dataset to list directory of        *\n* Input Parms: (SUB)    W1 --> INIT/DATA/TERM                         *\n*                       W2 --> Data Buffer                            *\n*                                                                     *\n* Input DD:             None                                          *\n*                                                                     *\n* Output DD:            SYSPRINT                                      *\n*                       The SYSPRINT file contains the catalog data   *\n*                                                                     *\n* Return codes:         Zero                                          *\n*                                                                     *\n* Abend codes:          None                                          *\n*                                                                     *\n* Register Usage:       R0  - Work                                    *\n*                       R1  - Work                                    *\n*                       R2  - Work                                    *\n*                       R3  - Work                                    *\n*                       R4  - Work                                    *\n*                       R5  - Work                                    *\n*                       R6  - Work                                    *\n*                       R7  - Work                                    *\n*                       R8  - Work                                    *\n*                       R9  - Secondary Sub-Routine Return Address    *\n*                       R10 - Primary Sub-Routine Return Address      *\n*                       R11 - Work                                    *\n*                       R12 - Base Register #1                        *\n*                       R13 - Working Storage Base Register           *\n*                       R14 - Return Address and Work                 *\n*                       R15 - Entry Point, Return Code and Work       *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Author:               Paul Gillis, P. C. Link Pty. Ltd.             *\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* V01    04/08/2008     Initial Version                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nLISTDIR  CSECT\nLISTDIR  AMODE 31\nLISTDIR  RMODE 24\n                                       SPACE 1\n         USING LISTDIR,R15\n         B     SKIPEYE                 ===> Skip the Eyeball\nWSLENGTH DC    A(GSLENG)               Working STorage Length\nEYEBALL  DC    CL28'LISTDIR  V01 &SYSDATC &SYSTIME'\nSKIPEYE  DS    0H\n         BAKR  R14,0\n         LAE   R12,0(R15,0)            Set up Base Reg (GR and AR)\n         DROP  R15\n         USING LISTDIR,R12\n         TM    0(R1),X'80'             Standard Parameter List\n         BO    SKIPPARM                ===> Yes, I'm a standard program\n                                       SPACE 1\n         L     R2,4(R1)                Pointer to obtained storage\n         L     R13,0(R2)               A(obtained storage)\n         USING GS,R13\n         L     R2,0(R1)                Save the Parameter Register\n         MVC   CALLPARM,0(R2)          First character of 1st parm\n         B     SKIPF1SA                Skip standard stuff\n                                       SPACE 1\nSKIPPARM DS    0H\n         L     R2,0(R1)                Save the Parameter Register\n         L     R0,WSLENGTH             Storage Length\n         STORAGE OBTAIN,LENGTH=(0),LOC=BELOW,BNDRY=PAGE\n         LR    R13,R1                  Address the work Area\n         LR    R0,R1                   Clear obtained storage\n         L     R1,WSLENGTH             Clear obtained storage\n         SR    R15,R15                 Clear obtained storage\n         MVCL  R0,R14                  Clear obtained storage\n         MVC   F1SA,=C'F1SA'           Indicate BAKR/PR used\n         MVI   PARM,C' '               Clear the PARM field\n         MVC   PARM+1(L'PARM-1),PARM   with blanks\n         LH    R1,0(R2)                Length of parm field\n         BCTR  R1,0                    Less one for EX MVC\n         EX    R1,MVCPARM              Copy the parameter\n                                       SPACE 1\nSKIPF1SA DS    0H\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Determine order of processing                                *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         CLI   CALLPARM,C'I'           Initialise data and open files\n         BE    CALLINIT                ===> Yes, perform that action\n         CLI   CALLPARM,C'D'           Extract a data record\n         BE    CALLDATA                ===> Yes, perform that action\n         CLI   CALLPARM,C'T'           Clean up and close files\n         BE    CALLTERM                ===> Yes, perform that action\n\n*---------------------------------------------------------------------*\n*        Call each routine collectively                               *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         BAL   R10,INIT                ===> Initialise and open files\nCALLLOOP DS    0H\n         BAL   R10,DATA                ===> Get data records\n         LTR   R15,R15                 EOD?\n         BZ    CALLLOOP                ===> No, keep looping\n         BAL   R10,TERM                ===> Clean up and close files\n         L     R0,WSLENGTH             Obtained storage length\n         LR    R1,R13                  Obtained storage address\n         STORAGE RELEASE,LENGTH=(0),ADDR=(1)\n         XR    R15,R15                 Set Return Code\n         PR    ,                       Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Call each routine individually                               *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nCALLINIT DS    0H\n         BAL   R10,INIT                ===> Initialise and open files\n         PR    ,                       Return to caller\n                                       SPACE 1\nCALLDATA DS    0H\n         BAL   R10,DATA                ===> Get data records\n         PR    ,                       Return to caller\n                                       SPACE 1\nCALLTERM DS    0H\n         BAL   R10,TERM                ===> Clean up and close files\n         PR    ,                       Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        INIT: Initialise the routine                                 *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nINIT     DS    0H\n         CLI   CALLPARM,0              Sub or Std?\n         BNE   INIT0010                ===> Sub, skip SYSPRINT\n         MVC   SYSPRINT,SYSPRINTC      Move DCB below the line\n         MVC   SYSPRINTE,SYSPRINTEC    Move DCBE below the line\n         LA    R1,SYSPRINTE            A(DCBE)\n         ST    R1,SYSPRINT             And save it in the DCB\n         XC    SYSPRINTO,SYSPRINTO     Zero the list\n         OI    SYSPRINTO,X'80'         Indicate last in the list\n         OPEN  (SYSPRINT,(OUTPUT)),MODE=31,MF=(E,SYSPRINTO)\nINIT0010 DS    0H\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        INIT: Initialise the PDS Directory                           *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   DIRECT,DIRECTC          Move DCB below the line\n         MVC   DIRECTE,DIRECTEC        Move DCBE below the line\n         LA    R1,DIRECTE              A(DCBE)\n         ST    R1,DIRECT               And save it in the DCB\n         LA    R14,DIRECT              A(DCB)\n         USING IHADCB,R14\n         LA    R6,JFCBAREA             Address the JFCB\n         USING JFCB,R6\n         ST    R6,JEXLST               Save in the exit list\n         MVI   JEXLST,X'87'            Insert the JFCB call\n         LA    R1,JEXLST               A(Exit List)\n         STCM  R1,7,DCBEXLSA           And save it in the DCB\n         DROP  R14\n         XC    DIRECTO,DIRECTO         Zero the list\n         OI    DIRECTO,X'80'           Indicate last in the list\n         RDJFCB DIRECT,MF=(E,DIRECTO)\n         LTR   R15,R15                 Read OK?\n         BNZ   ERROR#02                ===> No, Abend\n         LA    R14,DIRECT              A(DCB)\n         USING IHADCB,R14\n         XR    R1,R1                   Zero R1\n         STCM  R1,7,DCBEXLSA           And save it in the DCB\n         XC    DIRECTO,DIRECTO         Zero the list\n         OI    DIRECTO,X'80'           Indicate last in the list\n         OPEN  (DIRECT,(INPUT)),MODE=31,MF=(E,DIRECTO)\n         TM    DIRECT+DCBOFLGS-IHADCB,X'10'\n         BZ    ERROR#01\n                                       SPACE 1\n         MVI   RECORD,C' '             Clear the output record\n         MVC   RECORD+1(L'RECORD-1),RECORD\n         MVC   DSNEQ,=C'DSN='\n         MVC   VOLEQ,=C'VOL='\n         MVC   DSN,JFCBDSNM\n         MVC   VOL,JFCBVOLS\n         PUT   SYSPRINT,RECORD\n         MVI   RECORD,C' '             Clear the output record\n         MVC   RECORD+1(L'RECORD-1),RECORD\n         DROP  R6\n                                       SPACE 1\n*        LOOP THROUGH THE DIRECTORY\n                                       SPACE 1\nUNLOD020 DS    0H\n         GET   DIRECT,DIRECTIN\n         LA    R8,DIRECTIN+2\n         USING PDS2,R8\n         LA    R9,DIRECTIN\n         AH    R9,DIRECTIN\nUNLOD030 DS    0H\n         CLC   PDS2NAME,=8X'FF'        Member name all FFs?\n         BE    UNLOD110                ===> yes, we are done\nUNLOD031 DS    0H\n         MVI   RECORD,C' '             Clear the record for output\n         MVC   RECORD+1(L'RECORD-1),RECORD\n         MVC   MEMBER,PDS2NAME         Save Member Name\n         TM    PDS2INDC,PDS2ALIS       Is this an alias?\n         BZ    UNLOD032\n         MVC   TRUENAME,=CL8'ALIAS'    It's an alias\nUNLOD032 DS    0H\n         NI    PDS2INDC,X'1F'          AND THE DIRECTORY FLAGS\n         CLI   PDS2INDC,X'0F'          ISPF Statistics?\n         BE    UNLODFV                 ===> Yes, print ISPF stats\n         CLI   PDS2INDC,X'00'          No ISPF Statistics?\n         BE    UNLODFV                 ===> Yes, Print member name\n         CLI   PDS2INDC,X'17'          No ISPF Statistics? But what?\n         BE    UNLODFV                 ===> Yes, Print member name\nUNLODU   DS    0H\n         BAL   R11,PRINTU              ===> Print the directory\n         B     UNLOD105                ===> Skip\nUNLODFV  DS    0H\n         BAL   R11,PRINTFV             ===> Print the directory\nUNLOD105 DS    0H\n         PUT   SYSPRINT,RECORD         Output the record\nUNLOD106 DS    0H\n         SR    R15,R15                 CLEAR REG15\n         IC    R15,PDS2INDC            INSERT INTO REG15\n         AR    R15,R15                 DOUBLE REG15\n         LA    R8,12(R15,R8)           POINT REG10 TO NEXT MEMBER\n         CR    R8,R9                   COMPARE WITH DIRECTORY LENGTH\n         BNL   UNLOD020                GET ANOTHER DIRECTORY RECORD\n         B     UNLOD030                CHECK CURRENT MEMBER FOR EOF.\n                                       SPACE 3\nUNLOD110 DS    0H\n         XR    R15,R15                 Zero rc from init every time\n         BR    R10                     ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        DATA: Get next entry from the PDS                            *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nDATA     DS    0H\n         LA    R15,16                  RC=16 from data every time\n         BR    R10                     ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        TERM: Free up PDS resources                                  *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nTERM     DS    0H\n         CLI   CALLPARM,0              Sub or Std?\n         BNE   TERM0010                ===> Sub, skip SYSPRINT\n         CLOSE SYSPRINT,MODE=31,MF=(E,SYSPRINTO)\nTERM0010 DS    0H\n         CLOSE DIRECT,MODE=31,MF=(E,DIRECTO)\n         BR    R10                     ===> Return to caller\n                                       SPACE 1\nERROR#01 ABEND 1,DUMP\nERROR#02 ABEND 2,DUMP\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        PRINTFV: Output print data for Load Module Library           *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nPRINTFV  DS    0H\n         CLI   PDS2INDC,X'00'          No ISPF Statistics?\n         BE    PRINTFV9                ===> Yes, Print member name\n         CLI   PDS2INDC,X'17'          No ISPF Statistics? But what?\n         BE    PRINTFV9                ===> Yes, Print member name\n                                       SPACE 1\n*        UNPK  WORK(3),PDS3VERN(2)     Version\n*        TR    WORK(2),TRTABLE-240\n         XR    R14,R14\n         ICM   R14,1,PDS3VERN\n         CVD   R14,DB\n         UNPK  WORK(3),DB+6(2)\n         OI    WORK+2,X'F0'\n         MVC   VER,WORK+1\n         MVI   DOT1,C'.'\n                                       SPACE 1\n*        UNPK  WORK(3),PDS3MODN(2)     Modification\n*        TR    WORK(2),TRTABLE-240\n         XR    R14,R14\n         ICM   R14,1,PDS3MODN\n         CVD   R14,DB\n         UNPK  WORK(3),DB+6(2)\n         OI    WORK+2,X'F0'\n         MVC   MOD,WORK+1\n                                       SPACE 1\n         UNPK  WORK(9),PDS3CDAT(5)     Create Date\n         TR    WORK(8),TRTABLE-240\n         MVC   CDATE,WORK\n                                       SPACE 1\n         CLC   CDATE,=C'00'            Century = 19\n         BE    CENT1\n         MVC   CDATE(2),=C'20'\n         B     CENT2\nCENT1    DS    0H\n         MVC   CDATE(2),=C'19'\nCENT2    DS    0H\n                                       SPACE 1\n         UNPK  WORK(9),PDS3MDAT(5)     Update Date\n         TR    WORK(8),TRTABLE-240\n         MVC   UPDATE,WORK\n                                       SPACE 1\n         CLC   UPDATE,=C'00'           Century = 19\n         BE    CENT3\n         MVC   UPDATE(2),=C'20'\n         B     CENT4\nCENT3    DS    0H\n         MVC   UPDATE(2),=C'19'\nCENT4    DS    0H\n                                       SPACE 1\n         UNPK  WORK(3),PDS3HH(2)       Update Time HH\n         TR    WORK(2),TRTABLE-240\n         MVC   HH,WORK\n         MVI   COLON1,C':'\n                                       SPACE 1\n         UNPK  WORK(3),PDS3MM(2)       Update Time MM\n         TR    WORK(2),TRTABLE-240\n         MVC   MM,WORK\n         MVI   COLON2,C':'\n                                       SPACE 1\n         UNPK  WORK(3),PDS3SECS(2)     Update Time SS\n         TR    WORK(2),TRTABLE-240\n         MVC   SS,WORK\n                                       SPACE 1\n*        UNPK  WORK(5),PDS3LINE(3)     Lines\n*        TR    WORK(4),TRTABLE-240\n         XR    R14,R14\n         ICM   R14,3,PDS3LINE          Lines Updated\n         CVD   R14,DB\n         UNPK  WORK(5),DB+5(3)\n         OI    WORK+4,X'F0'\n         MVC   LINES,WORK\n                                       SPACE 1\n         XR    R14,R14\n         ICM   R14,3,PDS3INIT          Lines Initial\n         CVD   R14,DB\n         UNPK  WORK(5),DB+5(3)\n         OI    WORK+4,X'F0'\n         MVC   LINEINIT,WORK\n                                       SPACE 1\n         XR    R14,R14\n         ICM   R14,3,PDS3MOD           Lines Updated\n         CVD   R14,DB\n         UNPK  WORK(5),DB+5(3)\n         OI    WORK+4,X'F0'\n         MVC   LINEMOD,WORK\n                                       SPACE 1\n         MVC   USERID,PDS3USER\n                                       SPACE 1\n                                       SPACE 1\n*        PROCESS THE NEXT MEMBER\nPRINTFV9 DS    0H\n         BR    R11                     ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        PRINTU: Output print data for Load Module Library            *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nPRINTU   DS    0H\n                                       SPACE 1\n         UNPK  WORK(7),PDS2STOR(4)     Module Size\n         TR    WORK(6),TRTABLE-240\n         MVC   SIZE,WORK\n                                       SPACE 1\n         TM    PDS2ATR1,PDS2RENT       Re-Entrant\n         BZ    PRINT010\n         MVC   RN,=C'RN'               Mark it so\nPRINT010 DS    0H\n         TM    PDS2ATR1,PDS2REUS       Re-usable\n         BZ    PRINT015\n         MVC   RU,=C'RU'               Mark it so\nPRINT015 DS    0H\n         TM    PDS2ATR1,PDS2OVLY       Overlay\n         BZ    PRINT020\n         MVC   OV,=C'OV'               Mark it so\nPRINT020 DS    0H\n         TM    PDS2ATR1,PDS2LOAD       Only Loadable\n         BZ    PRINT025\n         MVC   OL,=C'OL'               Mark it so\nPRINT025 DS    0H\n         TM    PDS2ATR1,PDS2SCTR       Scatter\n         BZ    PRINT030\n         MVC   SC,=C'SC'               Mark it so\nPRINT030 DS    0H\n         TM    PDS2ATR1,PDS2EXEC       Executable\n         BO    PRINT035\n         MVC   NX,=C'NX'               Mark it not so\n                                       SPACE 1\nPRINT035 DS    0H\n         TM    PDS2FTB2,PDSMAMOD       AMODE\n         BZ    PRINTA24\n         BO    PRINTANY\n         TM    PDS2FTB2,BIT6\n         BO    PRINTA31\n         MVC   AM,=C' 64'              AM=64\n         B     PRINT040\nPRINTA24 DS    0H\n         MVC   AM,=C' 24'              AM=24\n         B     PRINT040\nPRINTA31 DS    0H\n         MVC   AM,=C' 31'              AM=31\n         B     PRINT040\nPRINTANY DS    0H\n         MVC   AM,=C'ANY'              AM=Any\n         B     PRINT040\n                                       SPACE 1\nPRINT040 DS    0H\n         MVC   RM,=C' 24'\n         TM    PDS2FTB2,PDSLRMOD       RMODE\n         BZ    PRINT045\n         MVC   RM,=C'ANY'\n                                       SPACE 1\nPRINT045 DS    0H\n         TM    PDS2ATR2,PDS2REFR       Refreshable\n         BZ    PRINT050\n         MVC   RF,=C'RF'\n                                       SPACE 1\nPRINT050 DS    0H\n         LA    R7,PDSBCLN(R8)          Next offset\n         TM    PDS2ATR1,PDS2SCTR       Scatter\n         BZ    PRINT055\n         LA    R7,PDSS01LN(R7)         Next offset\nPRINT055 DS    0H\n         TM    PDS2INDC,PDS2ALIS       Alias\n         BZ    PRINT060\n         DROP  R8\n         USING PDSS02,R7\n         MVC   TRUENAME,PDS2MNM\n         LA    R7,PDSS02LN(R7)         Next offset\nPRINT060 DS    0H\n         DROP  R7\n         USING PDS2,R8\n         TM    PDS2FTB1,PDS2SSI        SSI Info present\n         BZ    PRINT065\n         DROP  R8\n         LR    R14,R7\n         XR    R15,R15\n         SRDA  R14,1\n         LTR   R15,R15\n         BZ    PRINT061\n         LA    R7,1(R7)                Up R7 by 1\nPRINT061 DS    0H\n         USING PDSS03,R7\n         UNPK  WORK(9),PDSSSIWD(5)     SSI Information Word\n         TR    WORK(8),TRTABLE-240\n         MVC   SSI,WORK\n         LA    R7,PDSS03LN(R7)         Next offset\nPRINT065 DS    0H\n         DROP  R7\n         USING PDS2,R8\n         TM    PDS2FTB1,PDSAPFLG       APF is valid\n         BZ    PRINT070\n         DROP  R8\n         USING PDSS04,R7\n         UNPK  WORK(3),PDSAPFAC(2)     APF Code\n         TR    WORK(2),TRTABLE-240\n         MVC   AC,WORK\n         LA    R7,PDSS04LN(R7)         Next offset\nPRINT070 DS    0H\n         DROP  R7\n                                       SPACE 1\n*        PROCESS THE NEXT MEMBER\n         BR    R11                     ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Constants and Literals                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nSYSPRINTC DCB  MACRF=PM,DSORG=PS,DDNAME=SYSPRINT,RECFM=FB,             *\n               LRECL=80,DCBE=SYSPRINTEC\nSYSPRINTL  EQU *-SYSPRINTC\nSYSPRINTEC DCBE RMODE31=BUFF\nSYSPRINTEL EQU *-SYSPRINTEC\n                                       SPACE 1\nDIRECTC  DCB   DDNAME=SYSUT1,DEVD=DA,EODAD=UNLOD110,MACRF=(GM),        *\n               DSORG=PS,RECFM=F,LRECL=256,BLKSIZE=256,DCBE=DIRECTEC\nDIRECTL  EQU   *-DIRECTC\nDIRECTEC DCBE  RMODE31=BUFF\nDIRECTEL EQU   *-DIRECTEC\n                                       SPACE 1\nTRTABLE  DC    C'0123456789ABCDEF'     Translate Table\n         LTORG ,\n         CNOP  0,8                     Terminate on a Double Word Bdy.\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Working Storage                                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nMVCPARM  MVC   PARM(*-*),2(R2)         Save the parm field\n         LTORG ,\n         CNOP  0,8                     Finish on DB boundary\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Working Storage                                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nGS       DSECT\nSAVEAREA DS    F                       Save area for called routines\nF1SA     DS    F                       F1SA indicates BAKR/PR used\n         DS    16F                     GPR save area\n                                       SPACE 1\nDB       DS    D                       Double Work Work Area * 1\nWORK     DS    2D                      Double Work Work Area * 2\nPARM     DS    CL8                     PARM passed by direct caller\n                                       SPACE 1\nRECORD   DS    CL255                   Output Record\n         ORG   RECORD\nMEMBER   DS    CL8                     Member Name\n         DS    C\nTRUENAME DS    CL8                     Alias True Name Entry\n         DS    C\nSIZE     DS    CL6                     Module Size\n         DS    C\nAC       DS    CL2                     Module Auth Code\n         DS    C\nAM       DS    CL3                     Module Amode\n         DS    C\nRM       DS    CL3                     Module Rmode\n         DS    C\nRF       DS    CL2                     Module Attribute Refr\n         DS    C\nRN       DS    CL2                     Module Attribute Rent\n         DS    C\nRU       DS    CL2                     Module Attribute Reus\n         DS    C\nNX       DS    CL2                     Module Attribute Not Executable\n         DS    C\nOV       DS    CL2                     Module Attribute Overlay\n         DS    C\nTE       DS    CL2                     Module Attribute Test\n         DS    C\nOL       DS    CL2                     Module Attribute Only Loadable\n         DS    C\nSC       DS    CL2                     Module Attribute Scatter\n         DS    C\nSSI      DS    CL8                     Module SSI\n         ORG   ,\n         ORG   SIZE\nVER      DS    CL2                     Version\nDOT1     DS    C\nMOD      DS    CL2                     Modification\n         DS    C\nCDATE    DS    CL8                     Creation Date\n         DS    C\nUPDATE   DS    CL8                     Last Updated Date\n         DS    C\nHH       DS    CL2                     Last Updated Time HH\nCOLON1   DS    C\nMM       DS    CL2                     Last Updated Time MM\nCOLON2   DS    C\nSS       DS    CL2                     Last Updated Time SS\n         DS    C\nLINES    DS    CL5                     Lines\n         DS    C\nLINEINIT DS    CL5                     Lines Initial\n         DS    C\nLINEMOD  DS    CL5                     Lines Modified\n         DS    C\nUSERID   DS    CL8                     Userid\n         ORG   RECORD\nVOLEQ    DS    CL4                     VOL=\nVOL      DS    CL6\n         DS    C\nDSNEQ    DS    CL4                     DSN=\nDSN      DS    CL44\n         ORG   ,\n                                       SPACE 1\nSAVEREGS DS    2F                      Save R4 and R5 between calls\n                                       SPACE 1\nSYSPRINTO DS   D                       Open Parameter List\nSYSPRINT  DS   CL(SYSPRINTL)           DCB\nSYSPRINTE DS   CL(SYSPRINTEL)          DCBE\n                                       SPACE 1\nDIRECTO  DS    D                       Open Parameter List\nDIRECT   DS    CL(DIRECTL)             DCB\nDIRECTE  DS    CL(DIRECTEL)            DCBE\n                                       SPACE 1\nDIRECTIN DS    CL256                   Directory Buffer\n                                       SPACE 1\nEPLOC2   DS    F                       CSI Entry Point\nCALLPARM DS    C                       1st character of 1st parm\nRETURNCD DS    F                       Return Code\n                                       SPACE 1\nJEXLST   DS    X'87',AL3(JFCBAREA)     Exit List\nJFCBAREA DS    XL176                   Area for the JFCB to be stored\n                                       SPACE 1\n         CNOP  0,8                     Terminate on a Double Word Bdy.\nGSLENG   EQU   *-GS                    Length of Storage to obtain\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        DSECTs                                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         TITLE 'CB-Map DCBD'\n         DCBD  DEVD=DA,DSORG=PS\n                                       SPACE 1\n         TITLE 'CB-Map Directory'\n         IHAPDS PDSBLDL=NO\n         COPY  ISPFSTAT                ISPF Statistics\n                                       SPACE 1\n         TITLE 'YREGS'\n         YREGS\n                                       SPACE 1\nJFCB     DSECT\n         IEFJFCBN\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTDIR$": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x00\\x14\\x00\\x14\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 20, "newlines": 20, "modlines": 0, "user": "PGILLIS"}, "text": "//LISTDIR$ JOB ACCT#,,CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID,REGION=0M\n//*\n//ASSEMBLY EXEC ASMACL,PARM.C='OBJECT,NODECK,RENT' ,SYSPARM(TEST)'\n//C.SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//           DD  DISP=SHR,DSN=SYS1.MODGEN\n//           DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS\n//C.SYSIN    DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS(LISTDIR)\n//L.SYSLMOD  DD  DISP=SHR,DSN=&SYSUID..TOOLS.ISPLLIB(LISTDIR)\n//*\n//DUMMY    EXEC PGM=LISTDIR,PARM='SYSUT1'\n//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..TOOLS.ISPLLIB\n//SYSUT1   DD  DISP=SHR,DSN=SYS1.MIGLIB\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//*\n//DUMMY    EXEC PGM=LISTDIR,PARM='SYSUT1'\n//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..TOOLS.ISPLLIB\n//SYSUT1   DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTVTO$": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 15, "newlines": 15, "modlines": 0, "user": "PGILLIS"}, "text": "//LISTVTO$ JOB ACCT#,,CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID,REGION=0M,\n//             COND=(0,NE)\n//*\n//ASSEMBLY EXEC ASMACL\n//C.SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//           DD  DISP=SHR,DSN=SYS1.MODGEN\n//           DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS\n//C.SYSIN    DD  DISP=SHR,DSN=PPPYG.CBT471.FILE382.PDS(LISTVTOC)\n//L.SYSLMOD  DD  DISP=SHR,DSN=PPPYG.TOOLS.ISPLLIB(LISTVTOC)\n//*\n//DUMMY    EXEC PGM=LISTVTOC\n//STEPLIB  DD  DISP=SHR,DSN=PPPYG.TOOLS.ISPLLIB\n//VTOCDD   DD  DISP=SHR,UNIT=SYSDA,VOL=SER=RESN01\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTVTOC": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00!\\x01\\t6_\\x01\\t6_\\x11&\\x01`\\x01`\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2009-12-31T00:00:00", "modifydate": "2009-12-31T11:26:21", "lines": 352, "newlines": 352, "modlines": 0, "user": "PGILLIS"}, "text": "LISTVTOC TITLE 'List VTOC Contents'\n*---------------------------------------------------------------------*\n*                                                                     *\n* Module Name:          LISTVTOC                                      *\n*                                                                     *\n* Operating System:     z/OS 1.4                                      *\n*                                                                     *\n* Function:             This program is designed to extract the VTOC  *\n*                       records from a specified volume and then to   *\n*                       output that data to a print file.             *\n*                                                                     *\n* Purpose:              List contents of a VTOC                       *\n*                                                                     *\n* Module Type:          Program or Sub-Routine                        *\n*                                                                     *\n* Language:             High Level Assembler                          *\n*                                                                     *\n* Attributes:           Key 8                                         *\n*                       Problem State                                 *\n*                       Re-Entrant                                    *\n*                       AMODE(31)                                     *\n*                       RMODE(31)                                     *\n*                       BAKR/PR                                       *\n*                       ISPF Environment                              *\n*                                                                     *\n* Entry point:          LISTVTOC                                      *\n*                                                                     *\n* Input Parms: (PGM)    None                                          *\n* Input Parms: (SUB)    W1 --> INIT/DATA/TERM                         *\n*                       W2 --> Data Buffer                            *\n*                                                                     *\n* Input DD:             VTOCDD                                        *\n*                       The VTOCDD is used solely to identify the     *\n*                       volume serial that is to be listed.           *\n*                                                                     *\n* Output DD:            SYSPRINT                                      *\n*                       The SYSPRINT file contains the VTOC listing   *\n*                                                                     *\n* Return codes:         Zero                                          *\n*                                                                     *\n* Abend codes:          U0001 - Open of VTOCDD failed                 *\n*                       U0002 - Read of VTOCDD failed                 *\n*                       U0003 - Error in CVAF processing              *\n*                                                                     *\n* Register Usage:       R0  - Work                                    *\n*                       R1  - Work                                    *\n*                       R2  - Work                                    *\n*                       R3  - Work                                    *\n*                       R4  - Work                                    *\n*                       R5  - Work                                    *\n*                       R6  - Work                                    *\n*                       R7  - Work                                    *\n*                       R8  - Work                                    *\n*                       R9  - Secondary Sub-Routine Return Address    *\n*                       R10 - Primary Sub-Routine Return Address      *\n*                       R11 - Work                                    *\n*                       R12 - Base Register #1                        *\n*                       R13 - Working Storage Base Register           *\n*                       R14 - Return Address and Work                 *\n*                       R15 - Entry Point, Return Code and Work       *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Author:               Paul Gillis, P. C. Link Pty. Ltd.             *\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* V01    26/03/2005     Initial Version                               *\n* V02    28/03/2005     Fully 31/31 and re-entrant                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nLISTVTOC CSECT\nLISTVTOC AMODE 31\nLISTVTOC RMODE 31\n                                       SPACE 1\n         USING LISTVTOC,R15\n         B     SKIPEYE                 ===> Skip the Eyeball\nWSLENGTH DC    A(GSLENG)               Working STorage Length\nEYEBALL  DC    CL28'LISTVTOC V02 &SYSDATC &SYSTIME'\nSKIPEYE  DS    0H\n         BAKR  R14,0\n         LAE   R12,0(R15,0)            Set up Base Reg (GR and AR)\n         DROP  R15\n         USING LISTVTOC,R12\n         TM    0(R1),X'80'             Standard Parameter List\n         BO    SKIPPARM                ===> Yes, I'm a standard program\n                                       SPACE 1\n         L     R2,4(R1)                Pointer to obtained storage\n         L     R13,0(R2)               A(obtained storage)\n         USING GS,R13\n         L     R2,0(R1)                Save the Parameter Register\n         MVC   CALLPARM,0(R2)          First character of 1st parm\n         B     SKIPF1SA                Skip standard stuff\n                                       SPACE 1\nSKIPPARM DS    0H\n         L     R0,WSLENGTH             Storage Length\n         STORAGE OBTAIN,LENGTH=(0),LOC=BELOW,BNDRY=PAGE\n         LR    R13,R1                  Address the work Area\n         LR    R0,R1                   Clear obtained storage\n         L     R1,WSLENGTH             Clear obtained storage\n         SR    R15,R15                 Clear obtained storage\n         MVCL  R0,R14                  Clear obtained storage\n         MVC   F1SA,=C'F1SA'           Indicate BAKR/PR used\n                                       SPACE 1\nSKIPF1SA DS    0H\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Determine order of processing                                *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         CLI   CALLPARM,C'I'           Initialise data and open files\n         BE    CALLINIT                ===> Yes, perform that action\n         CLI   CALLPARM,C'D'           Extract a data record\n         BE    CALLDATA                ===> Yes, perform that action\n         CLI   CALLPARM,C'T'           Clean up and close files\n         BE    CALLTERM                ===> Yes, perform that action\n\n         BAL   R10,INIT                ===> Initialise and open files\nCALLLOOP DS    0H\n         BAL   R10,DATA                ===> Get data records\n         LTR   R15,R15                 EOD?\n         BZ    CALLLOOP                ===> No, keep looping\n         BAL   R10,TERM                ===> Clean up and close files\n         L     R0,WSLENGTH             Obtained storage length\n         LR    R1,R13                  Obtained storage address\n         STORAGE RELEASE,LENGTH=(0),ADDR=(1)\n         XR    R15,R15                 Set Return Code\n         PR    ,                       Return to caller\n                                       SPACE 1\nCALLINIT DS    0H\n         BAL   R10,INIT                ===> Initialise and open files\n         PR    ,                       Return to caller\n                                       SPACE 1\nCALLDATA DS    0H\n         BAL   R10,DATA                ===> Get data records\n         PR    ,                       Return to caller\n                                       SPACE 1\nCALLTERM DS    0H\n         BAL   R10,TERM                ===> Clean up and close files\n         PR    ,                       Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        INIT: Open The VTOC                                          *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nINIT     DS    0H\n         CLI   CALLPARM,0              Sub or Std?\n         BNE   INIT0010                ===> Sub, skip SYSPRINT\n         MVC   SYSPRINT,SYSPRINTC      Move DCB below the line\n         MVC   SYSPRINTE,SYSPRINTEC    Move DCBE below the line\n         LA    R1,SYSPRINTE            A(DCBE)\n         ST    R1,SYSPRINT             And save it in the DCB\n         XC    SYSPRINTO,SYSPRINTO     Zero the list\n         OI    SYSPRINTO,X'80'         Indicate last in the list\n         OPEN  (SYSPRINT,(OUTPUT)),MODE=31,MF=(E,SYSPRINTO)\n         MVI   RECORD,C' '             Clear the output record\n         MVC   RECORD+1(L'RECORD-1),RECORD\nINIT0010 DS    0H\n                                       SPACE 1\n         MVC   VTOCDD,VTOCDDC          Move DCB below the line\n         LA    R2,VTOCDD               Address the DCB\n         USING IHADCB,R2\n         LA    R3,JFCBAREA             Address the JFCB\n         ST    R3,JEXLST               Save in the exit list\n         MVI   JEXLST,X'87'            Insert the JFCB call\n         LA    R1,JEXLST               A(Exit List)\n         STCM  R1,7,DCBEXLSA           And save it in the DCB\n         USING JFCB,R3\n         XC    VTOCDDO,VTOCDDO         Zero the list\n         OI    VTOCDDO,X'80'           Indicate last in the list\n         RDJFCB VTOCDD,MF=(E,VTOCDDO)\n         LTR   R15,R15                 Read OK?\n         BNZ   INIT0020                ===> No, Abend\n         MVI   JFCBDSNM,X'04'          Want to read the VTOC\n         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM  Fill with hex 04\n         OI    JFCBTSDM,JFCNWRIT       Do not rewrite it\n         DROP  R3\n         OPEN  (VTOCDD,(INPUT)),TYPE=J,MF=(E,VTOCDDO)\n         TM    DCBOFLGS,DCBOFOPN       Open Work OK?\n         BO    INIT0030                ===> No, Abend\n         WTO   'LISTVTOC-01 Open of VTOCDD Failed',ROUTCDE=(11)\n         ABEND 1,DUMP                  OPEN DCB failure\nINIT0020 DS    0H\n         WTO   'LISTVTOC-02 Read VTOCDD JFCB Failed',ROUTCDE=(11)\n         ABEND 2,DUMP                  RDJFCB failure\nINIT0030 DS    0H\n         XR    R5,R5                   Zero F1 DSCB Counter\n         XR    R4,R4                   Zero the register for DEB\n         XR    R3,R3                   Zero the return code\n         ICM   R4,7,DCBDEBA            Insert the DEB address\n         DROP  R2\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        INIT: Get the first VTOC record                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         XC   BUFLIST(BFLHLN+BFLELN),BUFLIST Zero Buffer List\n         OI   BFLHFL,BFLHDSCB          Read DSCB\n         MVI  BFLHNOE,1                One Buffer List Entry\n         LA   R1,DS1FMTID              Address of DSCB buffer\n         ST   R1,BFLEBUF               Insert into Buffer List\n         MVI  BFLELTH,DSCBLTH          Read data portion of DSCB\n         MVC   CVPL,CVPLC              Copy the CVPL below the line\n         LA   R7,CVPL                  Save the address of the map\n         USING CVPLMAP,R7              R1 is set by CVAF\n         CVAFSEQ DEB=(R4),MF=(E,CVPL),BUFLIST=BUFLIST,DSN=DS1DSNAM\n         BAL   R9,STATUSCK             ===> Check Call Status\n         LTR   R15,R15                 EOD?\n         BNZR  R10                     ===> Return to caller\n         BAL   R9,VTOCDATA             ===> Process the Data\n         BR    R10                     ===> Return to caller\n         DROP  R7\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        DATA: Process the next data record                           *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nDATA     DS    0H\n         CVAFSEQ ACCESS=GT,MF=(E,CVPL),BUFLIST=BUFLIST,DSN=DS1DSNAM\n         BAL   R9,STATUSCK             ===> Check Call Status\n         LTR   R15,R15                 EOD?\n         BNZR  R10                     ===> Return to caller\n         BAL   R9,VTOCDATA             ===> Process the Data\n         XR    R15,R15                 Set RC=0\n         BR    R10                     ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        TERM: Free up VTOC CVAF resources                            *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nTERM     DS    0H\n         CVAFDIR ACCESS=RLSE,          Release CVAF buffers and IOArea *\n               BUFLIST=0,              dont release user buffer list   *\n               IXRCDS=NOKEEP,          release VIER buffers            *\n               MF=(E,CVPL)\n         CLOSE VTOCDD,MF=(E,VTOCDDO)\n         CLOSE SYSPRINT,MODE=31,MF=(E,SYSPRINTO)\n         BR    R10                     ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Secondary Sub-Routines: VTOC Error Checking                  *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nSTATUSCK DS   0H\n         LA   R7,CVPL                  Save the address of the map\n         USING CVPLMAP,R7              R1 is set by CVAF\n         LTR  R15,R15                  Any errors detected\n         BZR   R9                      ===> No, process the DSCB\n                                       SPACE 1\n         C     R15,=F'4'               RC=4?\n         BNE   OTHERERR                ===> No, More Serious Error\n         CLI   CVSTAT,STAT032          Status=EOD?\n         BER   R9                      ===> Yes, All done\n         LTR   R5,R5                   Read any VTOC entries\n         BNZR  R9                      ===> Yes, ignore the error\n                                       SPACE 1\nOTHERERR DS   0H\n         LA   R3,1(0,0)                R3=1\n         LNR  R3,R3                    Negative count = Error\n         LR   R6,R15                   Retain the RC\n         XR   R8,R8                    Retain the RC\n         IC   R8,CVSTAT                Get the CVAF status\n         WTO   'LISTCSI-03 Error in CVAF processing',ROUTCDE=(11)\n         WTO   'LISTCSI-03 RC in R8, CVSTAT in R6',ROUTCDE=(11)\n         ABEND 3,DUMP                  Die horribly scumbag\n         DROP R7\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Secondary Sub-Routines: VTOC Data Handling                   *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nVTOCDATA DS    0H\n         CLI   CALLPARM,0              Do I want to do this\n         BE    VTOC0010                ===> No, skip it\n         BR    R9\nVTOC0010 DS    0H\n         CLI   DS1DSNAM,X'04'          F4 DSCB\n         BER   R9                      ===> Yes, Ignore it\n         MVC   RECORD(L'DS1DSNAM),DS1DSNAM\n         PUT   SYSPRINT,RECORD\n         BR    R9                      ===> Return to caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Constants and Literals                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         LTORG ,\n         CNOP  0,8                     Terminate on a Double Word Bdy.\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Working Storage                                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nCVPLC    CVAFSEQ ACCESS=GTEQ,          Read DSCB                       *\n               IXRCDS=KEEP,            Keep VIER in storage            *\n               MF=L\nCVPLL    EQU   *-CVPLC                 Length of CVPL\n                                       SPACE 1\nSYSPRINTC DCB  MACRF=PM,DSORG=PS,DDNAME=SYSPRINT,RECFM=FB,             X\n               LRECL=80,DCBE=SYSPRINTEC\nSYSPRINTL  EQU *-SYSPRINTC\nSYSPRINTEC DCBE RMODE31=BUFF\nSYSPRINTEL EQU *-SYSPRINTEC\n                                       SPACE 1\nVTOCDDC  DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=VTOCDDC\nVTOCDDL  EQU   *-VTOCDDC\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Working Storage                                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nGS       DSECT\nSAVEAREA DS    F                       Save area for called routines\nF1SA     DS    F                       F1SA indicates BAKR/PR used\n         DS    16F                     GPR save area\n         IECSDSL1 (1)                  F1 DSCB\nDSCBLTH  EQU  *-IECSDSL1-L'DS1DSNAM    Length of data portion of DSCB\n         DC    18F'0'                  Overlaid Storage\n                                       SPACE 1\nSYSPRINTO DS   D                       Open Parameter List\nSYSPRINT  DS   CL(SYSPRINTL)           DCB\nSYSPRINTE DS   CL(SYSPRINTEL)          DCBE\n                                       SPACE 1\nVTOCDDO  DS    D                       Open Parameter List\nVTOCDD   DS    CL(VTOCDDL)             DCB\nJEXLST   DS    X'87',AL3(JFCBAREA)     Exit List\nJFCBAREA DS    XL176                   Area for the JFCB to be stored\n                                       SPACE 1\nBUFLIST  ICVAFBFL DSECT=NO             Buffer List\nCVPL     DS    CL(CVPLL)               CVPL\n                                       SPACE 1\nCALLPARM DS    C                       1st character of 1st parm\nRECORD   DS    CL80                    Output Record\n                                       SPACE 1\n         CNOP  0,8                     Terminate on a Double Word Bdy.\nGSLENG   EQU   *-GS                    Length of Storage to obtain\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        DSECTs                                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         TITLE 'CB-Map CVAF Parameter List'\nCVPLMAP  ICVAFPL DSECT=YES             Map the CVPL\n         TITLE 'CB-Map DCBD'\n         DCBD  DEVD=DA,DSORG=PS\n         TITLE 'CB-Map JFCB'\nJFCB     DSECT\n         IEFJFCBN\n         TITLE 'YREGS'\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHELL": {"ttr": 6658, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x15\\x01\\x10\\x00\\x1f\\x01\\x10\\x00\\x1f\\x129\\x00T\\x00T\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-01-01T00:00:00", "modifydate": "2010-01-01T12:39:15", "lines": 84, "newlines": 84, "modlines": 0, "user": "PGILLIS"}, "text": "SHELL    TITLE 'PROGRAM SHELL'\nSHELL    CSECT\nSHELL    AMODE 31\nSHELL    RMODE ANY\n         SAVE  (14,12),,'SHELL V01 &SYSDATC &SYSTIME'\n         LR    R12,R15                 Set up Base Reg (GR and AR)\n         USING SHELL,R12\n         LR    R2,R1                   Save the Parameter Register\n                                       SPACE 1\n         L     R0,=A(GSLENG)           Storage Length\n         STORAGE OBTAIN,LENGTH=(0),LOC=BELOW,BNDRY=PAGE\n         ST    R13,4(,R1)              Back Pointer\n         ST    R1,8(,R13)              Forward pointer\n         LR    R13,R1                  Address the work Area\n         USING GS,R13\n         LA    R1,DB                   Clear obtained storage\n         LR    R0,R1                   Clear obtained storage\n         L     R1,=A(CLRLENG)          Clear obtained storage\n         SR    R15,R15                 Clear obtained storage\n         MVCL  R0,R14                  Clear obtained storage\n                                       SPACE 1\n         DEBUG DATA=G,TYPE=PUT,MAXLEN=200,OPEN=YES,                    *\n               PGMBASE=R12,USING=(GS,R13)\n         DEBUG ID=BEGIN,(SHELL+5,28,C)\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Program Initialisation                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         L     R9,0(R2)                Address the Parm\n         DEBUG ID=BEGIN,(PARML,2,X),(PARMC,24,C),USING2=(PARM,R9)\n                                       SPACE 1\n         L     R8,CVTPTR               A(CVT)\n         USING CVTMAP,R8\n         MVC   SYSTEMNM,CVTSNAME       Save the System Name\n         DEBUG ID=BEGIN,(SYSTEMNM,8,C)\n         CLC   =CL8'NOR2',CVTSNAME     Is this NOR2\n         BE    ABEND0C1                ---> Yes, abend\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Program Termination                                          *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         DEBUG DATA=G,CLOSE=YES\n         L     R0,=A(GSLENG)           Obtained Storage Length\n         LR    R1,R13                  Obtained Storage Address\n         L     R2,4(R13)               Callers Save Area\n         STORAGE RELEASE,LENGTH=(0),ADDR=(1)\n         LR    R13,R2                  Restore Callers Save Area\n         SR    R15,R15                 Set the Return Code\n         RETURN (14,12),RC=(15)        ===> Return to Caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Constants and Literals                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nABEND0C1 DC    X'0000'                 Force an abend if executed\n         LTORG ,\n         DEBUG DATA=C                  Debug Constants\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Working Storage                                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nGS       DSECT\nSAVEAREA DS    18F                     Register Save Area\nDB       DS    D                       Work Area\nSYSTEMNM DS    CL8                     Work Area\n         DEBUG DATA=V                  Debug Variables\n         CNOP  0,8                     Terminate on a Double Word Bdy.\nCLRLENG  EQU   *-DB\nGSLENG   EQU   *-GS                    Length of obtained storage\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        DSECTs                                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nPARM     DSECT\nPARML    DS    XL2                     Parameter Length\nPARMC    DS    0C                      Parameter Value\n                                       SPACE 1\n         YREGS\n         CVT   DSECT=YES,PRINT=NO\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYSTEM": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x19\\x0f\\x00\\x99\\x19\\x0f\\x13\\x01\\x035\\x035\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-09T00:00:00", "modifydate": "1999-07-09T13:01:00", "lines": 821, "newlines": 821, "modlines": 0, "user": "PGILLIS"}, "text": "++ USERMOD(L#FM114) REWORK(1999147)\n/*\n*\n*     Elements:    SYSTEM / IPL Command\n*\n*     Purpose:     Provide System Information\n*\n*     Reference:   None\n*\n*     Environment: Zone:  MVS01T   Product:  RTS Inhouse Code\n*\n*     WARNING:     None\n*\n*     Writer:      Paul Gillis\n*\n*     Date:       11/09/97\n*\n*     Change       Date      Inits  Description\n*     History:     ========  =====  ===========\n*\n*                  11/09/97  PGG    new version of the code\n*                  25/08/98  PGG    Fix date conversion error\n*                  27/05/99  PGG    Re Write of cmd to include symbols\n*\n*/ .\n++VER(Z038) FMID(LBASE01) SUP(L#FM106).\n++JCLIN.\n//LINK1  EXEC   PGM=HEWL,PARM='LIST,XREF,MAP'\n//SYSPRINT  DD SYSOUT=A\n//AUSERMOD  DD DSN=SYS1.AUSERMOD,DISP=SHR\n//SYSLMOD   DD DSN=MVS01T.LINKLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN    DD *\n INCLUDE AUSERMOD(SYSTEM)\n ALIAS IPL\n NAME SYSTEM(R)\n++PNL (SYSTEM) DISTLIB(AUSERSRC) SYSLIB(ISRPLIB).\n)ATTR\n  @ TYPE(OUTPUT) INTENS(LOW) JUST(ASIS) CAPS(OFF)\n  $ TYPE(OUTPUT) INTENS(HIGH) JUST(ASIS) CAPS(OFF)\n 01 TYPE(OUTPUT) INTENS(HIGH) JUST(ASIS) CAPS(OFF)\n  _ TYPE(INPUT)\n  ! TYPE(INPUT) CAPS(OFF)\n)BODY EXPAND(\\\\)\n%-\\-\\- System IPL Details on &ZSYSID-\\-\\-\n%COMMAND ===>_ZCMD                                      \\ \\   %SCROLL ===>_Z   %\n+\n-\\-\\-\n)MODEL\n@SYSTEM\n)END\n++SRC (SYSTEM) DISTLIB(AUSERSRC) DISTMOD(AUSERMOD).\nSYSTEM   TITLE 'SYSTEM - DISPLAY IPL DETAILS.'\n*---------------------------------------------------------------------*\n*                                                                     *\n* Module Name:          SYSTEM                                        *\n*                                                                     *\n* Operating System:     OS/390 V2R4                                   *\n*                                                                     *\n* Function:             Display IPL Details                           *\n*                                                                     *\n* Module Type:          Procedure                                     *\n*                                                                     *\n* Language:             Assembler                                     *\n*                                                                     *\n* Attributes:           Key 8                                         *\n*                       Problem State                                 *\n*                       Not Re-entrant                                *\n*                       AMODE(31)                                     *\n*                       RMODE(24)                                     *\n*                       BAKR/PR                                       *\n*                                                                     *\n* Entry point:          SYSTEM                                        *\n*                                                                     *\n* Input:                None                                          *\n*                                                                     *\n* Exit:                 Normal                                        *\n*                                                                     *\n* Return codes:         Zero                                          *\n*                                                                     *\n* Abend codes:          None                                          *\n*                                                                     *\n* Author:               Paul Gillis, P. C. Link Pty. Ltd.             *\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n*        26/05/1999     Savagely rewritten the original code          *\n*                                                                     *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nSYSTEM   CSECT\nSYSTEM   AMODE 31\nSYSTEM   RMODE 24\n         BAKR  R14,0\n         LAE   R12,0(R15,0)            Set up Base Reg (GR and AR)\n         USING SYSTEM,R12\n         B     SKIPEYE                 ===> Skip the Eyeball\n         DC    C'SYSTEM &SYSDATC &SYSTIME'\nSKIPEYE  DS    0H\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Initialisation                                               *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         LR    R1,R13                  SAVE SAVEAREA POINTER.\n         LA    R13,SAVEAREA            POINT TO MY SAVEAREA.\n         ST    R1,4(R13)               SAVE PREVIOUS SAVEAREA.\n         ST    R13,8(R1)               SAVE CURRENT SAVEAREA.\n                                       SPACE 1\n         LINK  EPLOC=ISPQRY            AM I RUNNING UNDER ISPF\n         LTR   R15,R15                 CHECK THE ISPQRY RETURN CODE\n         BNZ   SKIPISPF                ---> NO, TRY SYSUT2\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Initialise the ISPLINK environment                           *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         OI    GENFLAG,GENSPF          INDICATE SPF PROCESSING REQD.\n         LOAD  EPLOC=ISPLINK           LOAD ISPLINK.\n         ST    R0,EPLOC                SAVE ADDRESS OF THE ROUTINE.\n         L     R15,EPLOC               A(ISLINK)\n         CALL  (15),(VDEFINE,CSYSTEM,RECORD,CHAR,F79),VL\n         L     R15,EPLOC               A(ISLINK)\n         CALL  (15),(TBCREATE,SYSTABLE,0,CSYSTEM,NOWRITE),VL\n         B     B011                    SKIP THE OPEN CODE\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Check on and optionally open the SYSUT2 DD                   *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nSKIPISPF DS    0H\n         MVC   DDNAME,=CL8'SYSUT2'     LOOK FOR THIS DDNAME\n         BAL   R10,FINDTIOT            SEE IF I HAVE IT ALLOCATED\n         TM    GENFLAG,GENSYSUT        SYSUT2 DD PRESENT\n         BZ    B011                    ---> NO\n         OI    GENFLAG,GENDCB          INDICATE DCB PROCESSING REQD.\n         OPEN  (SYSUT2,(OUTPUT)),MODE=31\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- System Id                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nB011     DS    0H\n         L     R5,CVTPTR               GET THE CVT ADDRESS\n         S     R5,=F'256'              R5 --> CVTFIX.\n         USING CVTFIX,R5\n         MVC   RECORD(L'L00),L00       'Put in the Constants\n         MVC   SYSTEMID,CVTSNAME       GET THE SYSTEM ID\n         BAL   R10,OUTPUT              Output the variable/record\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- IPL date and time                      *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L01),L01       'Put in the Constants\n         L     R6,CVTSMCA              GET ADDRESS OF COMMON EXTENSION.\n         USING SMCABASE,R6             MAP IT.\n         MVC   DATE,SMCAIDTE           Save the date\n         MVC   TIME,SMCAITME           Save the time\n         BAL   R10,DATETIME            Process the date and time\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- Current date and time                  *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L01C),L01C     'Put in the Constants\n         TIME  BIN                     Extract The current time\n         STM   R0,R1,TIME              Save the date\n         BAL   R10,DATETIME            Process the date and time\n         BAL   R10,OUTPUT              Output the variable/record\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- Operating System Level                 *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L02),L02       'Put in the Constants\n         MVC   SPLEVEL,CVTPRODN        GET CONTROL PROGRAM NAME.\n         BAL   R10,OUTPUT              Output the variable/record\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- IPL Load parms                         *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L03),L03       'Put in the Constants\n         L     R6,CVTECVT              GET ADDRESS OF EXTENDED CVT\n         USING ECVT,R6                 MAP IT.\n         MVC   IPLPARM,ECVTLOAD        GET IPL PARAMETERS\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- Private Storage below the Line         *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L04),L04       'Put in the Constants\n         L     R6,CVTGDA               GET ADDRESS OF GLOBAL DATA AREA\n         USING GDA,R6                  MAP IT.\n         L     R1,GDAPVTSZ             GET PRIVATE STORAGE SIZE\n         SRL   R1,10                   DIVIDE BY 1024\n         CVD   R1,DB                   CONVERT TO DECIMAL\n         UNPK  PVTSIZE,DB+5(3)         CONVERT TO EBCDIC\n         OI    PVTSIZE+4,X'F0'         AND MAKE THE SIGN PRINTABLE\n         MVI   K,C'K'                  Insert the constant K\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- Nucleus Id                             *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L05),L05       'Put in the Constants\n         L     R6,CVTEXT2              GET ADDRESS OF COMMON EXTENSION.\n         USING CVTXTNT2,R6\n         MVC   NUCLEUS,=C'IEANUC0'     Insert the Nucleus constant\n         MVC   NUCID,CVTNUCLS          Nucleus Id\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- SMF Id                                 *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L06),L06       'Put in the Constants\n         L     R6,CVTSMCA              GET ADDRESS OF COMMON EXTENSION.\n         USING SMCABASE,R6             MAP IT.\n         MVC   SMFID,SMCASID           GET SMF SYSTEM ID.\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- CPU Id                                 *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L14),L14       'Put in the Constants\n         L     R6,PSAPCCAV-PSA(R0)     GET ADDRESS OF PCCA.\n         USING PCCA,R6                 MAP IT.\n         MVC   CPUCODE,PCCACPID+0      GET CPU CODE.\n         MVC   CPULPAR,PCCACPID+2      GET CPU LPAR.\n         MVC   CPUID,PCCACPID+4        GET CPU ID.\n         MVC   CPUTYPE,PCCACPID+8      GET CPU TYPE.\n         MVI   DASH1,C'-'              insert a dash\n         MVI   DASH2,C'-'              insert a dash\n         MVI   DASH3,C'-'              insert a dash\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- Master Catalog Name                    *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L08),L08       'Put in the Constants\n         L     R6,CVTCBSP              GET ADDRESS OF ACB STRUCTURE.\n         L     R7,20(R6)               GET ADDRESS OF CAXWA CHAIN.\nB090     LTR   R7,R7                   IS IT VALID ?\n         BZ    B101                    * NO, BYPASS.\n         TM    8(R7),X'04'             IS IT THE MASTER CATALOG ?\n         BO    B100                    * YES, BYPASS.\n         L     R7,4(R7)                GET NEXT CATALOG ENTRY.\n         B     B090                    GO CHECK IF VALID.\nB100     MVC   CATNAME,52(R7)          GET MASTER CATALOG NAME.\n         BAL   R10,OUTPUT              Output the variable/record\nB101     DS    0H\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- Master Catalog Volser and Unit address *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L10),L10       'Put in the Constants\n         MVC   DSN,52(R7)              *\n         BAL   R10,DYNALLOC            ALLOCATE THE MASTER CATALOG\n         USING UCBCMSEG,R14\n         MVC   VOLSER,UCBVOLI\n         UNPK  UNIT(5),UCBCHAN(3)      GET THE 4 DIGIT DEVICE ADDRESS\n         TR    UNIT(4),TRTABLE-240     CONVERT TO EBCDIC\n         MVC   ON,=C'on'               Insert a nice constant\n         MVI   BLANK2,C' '             AND CLEAR THE SIGN BYTE\n         BAL   R10,DYNFREE             FREE THE MASTER CATALOG\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R14\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- IPL Volser and Unit address            *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L09),L09       'Put in the Constants\n         L     R6,CVTSYSAD             GET ADDRESS OF SYSRES UCB.\n         USING UCBCMSEG,R6             MAP IT.\n         MVC   VOLSER,UCBVOLI          GET IPL VOLUME NAME.\n         UNPK  UNIT(5),UCBCHAN(3)      GET THE 4 DIGIT DEVICE ADDRESS\n         TR    UNIT(4),TRTABLE-240     CONVERT TO EBCDIC\n         MVC   ON,=C'on'               Insert a nice constant\n         MVI   BLANK2,C' '             AND CLEAR THE SIGN BYTE\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R6\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- NSP Volser and Unit address            *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L11),L11       'Put in the Constants\n         MVC   DSN,=CL44'SYS2.NSP.LOADLIB'\n         BAL   R10,DYNALLOC            ALLOCATE THE MASTER CATALOG\n         USING UCBCMSEG,R14\n         MVC   VOLSER,UCBVOLI\n         UNPK  UNIT(5),UCBCHAN(3)      GET THE 4 DIGIT DEVICE ADDRESS\n         TR    UNIT(4),TRTABLE-240     CONVERT TO EBCDIC\n         MVC   ON,=C'on'               Insert a nice constant\n         MVI   BLANK2,C' '             AND CLEAR THE SIGN BYTE\n         BAL   R10,DYNFREE             FREE THE MASTER CATALOG\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R14\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- PARMLIB Volser and Unit address        *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'L15),L15       'Put in the Constants\n         MVC   DSN,=CL44'SYS1.PARMLIB'\n         BAL   R10,DYNALLOC            Allocate parmlib\n         USING UCBCMSEG,R14\n         MVC   VOLSER,UCBVOLI\n         UNPK  UNIT(5),UCBCHAN(3)      GET THE 4 DIGIT DEVICE ADDRESS\n         TR    UNIT(4),TRTABLE-240     CONVERT TO EBCDIC\n         MVC   ON,=C'on'               Insert a nice constant\n         MVI   BLANK2,C' '             AND CLEAR THE SIGN BYTE\n         BAL   R10,DYNFREE             Free parmlib\n         BAL   R10,OUTPUT              Output the variable/record\n         DROP  R14\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Extract and Output -- System Symbol Variables                *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         MVC   RECORD(L'NAME00),NAME00 'Put in the Constants\n         BAL   R10,OUTPUT              Output the variable/record\n                                       SPACE 1\n         L     R3,CVTECVT              A(ECVT)\n         USING ECVT,R3\n         L     R4,ECVTSYMT             A(SYMT)\n                                       SPACE 1\n         LH    R5,2(R4)                Number of entries in the list\n         LA    R4,4(R4)                Start of the list\n         LR    R3,R4                   Save it for increments\nLOOP1    DS    0H\n         LM    R6,R9,0(R3)             load the values\n         AR    R6,R4                   Set the address\n         AR    R8,R4                   Set the address\n         BCTR  R7,0                    Less one for the EXd MVC\n         EX    R7,MVCNAME              Move the variable name\n         LTR   R9,R9                   Is there a value\n         BZ    LOOP2                   ===> No, skip the value move\n         BCTR  R9,0                    Less on for the EXd MVC\n         EX    R9,MVCVAR               Move the variable value\nLOOP2    DS    0H\n         BAL   R10,OUTPUT              Output the variable/record\n         LA    R3,16(R3)               Increment the base\n         BCT   R5,LOOP1                ===> loop through the entries\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Program termination                                          *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         TM    GENFLAG,GENSPF          SPF OPTION SPECIFIED ?\n         BZ    R010                    ---> No, Finished\n         L     R15,EPLOC               A(ISLINK)\n         CALL  (15),(TBTOP,SYSTABLE),VL\n         L     R15,EPLOC               A(ISLINK)\n         CALL  (15),(TBDISPL,SYSTABLE,SYSTABLE),VL\n         L     R15,EPLOC               A(ISLINK)\n         CALL  (15),(TBEND,SYSTABLE),VL\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Close up and return to caller                                *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nR010     DS    0H\n         TM    GENFLAG,GENDCB          WAS DCB PROCESSING REQD.\n         BZ    R020                    ---> No, Finished\n         CLOSE SYSUT2,MODE=31\nR020     DS    0H\n         XR    R15,R15                 Zero the RC\n         PR    ,                       Return to Caller\n         DROP  R5\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Dynamic Deallocation Subroutine                              *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nDYNFREE  DS    0H\n         LA    R9,SVC99RB              ADDRESS THE SVC RB\n         USING S99RB,R9\n         XC    SVC99RB,SVC99RB         ZERO THE RB\n         MVI   S99RBLN,RBLEN           INSERT THE RB LENGTH\n         MVI   S99VERB,S99VRBUN        I WANT DE-ALLOCATION\n         LA    R1,TUFREE               GET TEXT UNIT POINTER ADDRESS\n         ST    R1,S99TXTPP             INSERT THAT INTO THE RB\n         LA    R1,SVC99RBP             SET UP SVC 99\n         DYNALLOC                      AND CALL IT\n         BR    R10                     ===> RETURN TO CALLER\n         DROP  R9                      ===> RETURN TO CALLER\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Dynamic Allocation Subroutine                                *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nDYNALLOC DS    0H\n         XC    SVC99RB,SVC99RB         ZERO THE RB\n         LA    R9,SVC99RB              ADDRESS THE SVC RB\n         USING S99RB,R9\n         MVI   S99RBLN,RBLEN           INSERT THE RB LENGTH\n         MVI   S99VERB,S99VRBAL        I WANT DE-ALLOCATION\n         LA    R1,TUALLOC              GET TEXT UNIT POINTER ADDRESS\n         ST    R1,S99TXTPP             INSERT THAT INTO THE RB\n         LA    R1,SVC99RBP             SET UP SVC 99\n         DYNALLOC                      AND CALL IT\n         DROP  R9\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        TIOT scan routine - look for allocated ddname                *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nFINDTIOT DS    0H\n         SR    R14,R14                 ZERO THE JFCB LENGTH REG\n         L     R15,CVTPTR              GET THE CVT ADDRESS\n         S     R15,=F'256'             R15 --> CVTFIX.\n         USING CVTFIX,R15\n         L     R15,CVTTCBP             GET THE TCB WORDS\n         L     R15,4(0,R15)            GET THE CURRENT TCB\n         USING TCB,R15\n         L     R15,TCBTIO              GET THE ADDRESS OF THE TIOT\n         USING TIOT,R15\n         LA    R15,TIOENTRY            ADDRESS THE FIRST DD ENTRY\n         DROP  R15\n         USING TIOENTRY,R15\n         SR    R1,R1                   ZERO THE TIOT LENGTH REG\nLOOPTIOT DS    0H\n         ICM   R1,1,TIOELNGH           INSERT THE LENGTH OF THE TIOTE\n         BZ    ENDTIOT                 ===> END OF DD ENTRIES\n         TM    TIOESTTA,TIOSLTYP       IS THIS ENTRY IN USE\n         BO    BUMPTIOT                ===> NO, IGNORE IT\n         CLC   TIOEDDNM,DDNAME         FOUND THE DDNAME\n         BE    FOUNDDDN                ===> YES, TURN ON A FLAG\n                                       SPACE 1\nBUMPTIOT DS    0H\n         AR    R15,R1                  NEXT TIOT ENTRY\n         B     LOOPTIOT                ===> LETS CHECK THIS ONE OUT\n                                       SPACE 1\nFOUNDDDN DS    0H\n         ICM   R14,7,TIOEFSRT          GET THE UCB ADDRESS\n         CLC   =CL8'SYSUT2',DDNAME     IS THIS THE SYSUT2 DD\n         BNE   ENDTIOT                 ---> NO, TERMINATE REQUEST\n         OI    GENFLAG,GENSYSUT        INDICATE I HAVE FOUND IT\nENDTIOT  DS    0H\n         BR    R10                     RETURN TO CALLER\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Output Routine                                               *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nOUTPUT   DS    0H\n         TM    GENFLAG,GENSPF          SPF option\n         BO    OUTPUTI                 ===> Yes, Call ISPLINK\n         TM    GENFLAG,GENDCB          DCB option\n         BO    OUTPUTP                 ===> Yes, issue PUT\n         LA    R0,L'RECORD             'Length of Record\n         LA    R1,RECORD               Address of Record\n         TPUT  (1),(0)                 tell the user\n         B     OUTPUTX                 ===> return\nOUTPUTI  DS    0H\n         L     R15,EPLOC               A(ISLINK)\n         CALL  (15),(TBADD,SYSTABLE),VL\n         B     OUTPUTX                 ===> return\nOUTPUTP  DS    0H\n         PUT   SYSUT2,RECORD           Output the data\nOUTPUTX  DS    0H\n         MVC   RECORD,BLANK            Clear the Workarea\n         MVI   EQUALS,C'='             Stick in the equals sign\n         BR    R10                     ===> return\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Subroutine to format the date and time                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nDATETIME DS    0H\n         XR    R0,R0                   CLEAR WORK REGISTER.\n         XR    R2,R2                   *\n         L     R1,TIME                 GET IPL TIME.\n         D     R0,=A(60*60*100)        CALCULATE HOURS.\n         CVD   R1,DOUBLE               CONVERT TO DECIMAL.\n         L     R2,DOUBLE+4             R2 = 00000HH+.\n         SRL   R2,4                    R2 = 000000HH.\n         SLL   R2,12                   R2 = 000HH000.\n         SRDL  R0,32                   SET UP FOR DIVIDE.\n         D     R0,=A(60*100)           CALCULATE MINUTES.\n         CVD   R1,DOUBLE               CONVERT TO DECIMAL.\n         A     R2,DOUBLE+4             R2 = 000HHMM+.\n         ST    R2,SAVETIME             SAVE RESOLVED IPL TIME.\n         L     R0,DATE                 GET IPL DATE - YYDDD+.\n         SRDL  R0,16                   R0 = YY\n         STH   R0,YEAR                 SAVE IT.\n         SRL   R1,16                   R1 = DDD+\n         LA    R3,19                   SET LEAP YEAR MASK.\n         NR    R3,R0                   TEST FOR LEAP YEAR IN EVEN DEC ?\n         BZ    B020                    * YES, BYPASS.\n         X     R3,=F'18'               R3 = 0 IF LEAP YEAR IN ODD DEC.\nB020     LR    R4,R0                   SAVE YEAR, R4 = 000000YY\n         XC    DOUBLE,DOUBLE           CLEAR WORKAREA.\n         ST    R1,DOUBLE+4             STORE DAYSPMON FOR CONVERSION.\n         CVB   R2,DOUBLE               CONVERT DDD+ TO BINARY.\n         XR    R1,R1                   CLEAR MONTH COUNTER.\nB030     LA    R1,1(R1)                INCREMENT MONTH COUNTER.\n         CH    R1,=H'3'                IS IT MARCH ?\n         BNE   B040                    * NO BYPASS.\n         LTR   R3,R3                   IS IT LEAP YEAR ?\n         BNZ   B040                    * NO, BYPASS.\n         BCTR  R2,0                    * ELSE, REDUCE DAYS BY 1.\nB040     XR    R0,R0                   CLEAN THE REGISTER\n         IC    R0,DAYSPMON-1(R1)       GET NO OF DAYS FOR THIS MONTH.\n         SR    R2,R0                   MONTH RESOLVED ?\n         BP    B030                    * NO, KEEP TRYING.\n         AR    R2,R0                   * ELSE, REVERSE LAST SUBTRACT.\n         BP    B050                    BYPASS.\n         LA    R2,29                   MAKE IT 29TH FEB IF NECESSARY.\n         BCTR  R1,0                    SUBTRACT 1 FROM MONTHS COUNTER.\nB050     STH   R2,BDAY                 SAVE DAY.\n         STH   R1,BMONTH               SAVE MONTH.\n         CVD   R1,DOUBLE               CONVERT MONTH.\n         L     R1,DOUBLE+4             R1 = 00000MM+.\n         SRL   R1,4                    R1 = 000000MM.\n         SLL   R1,8                    R1 = 0000MM00.\n         AR    R4,R1                   R4 = 0000MMYY.\n         CVD   R2,DOUBLE               CONVERT DAY.\n         L     R2,DOUBLE+4             R2 = 00000DD+.\n         SRL   R2,4                    R2 = 000000DD.\n         SLL   R2,16                   R2 = 00DD0000.\n         AR    R4,R2                   R4 = 00DDMMYY.\n         SLL   R4,4                    R4 = 0DDMMYY0.\n         LA    R2,15                   GET +VE SIGN.\n         OR    R4,R2                   INSERT SIGN.\n         ST    R4,SAVEDATE             STORE RESOLVED DATE.\n         XC    DOUBLE,DOUBLE           CLEAR WORK AREA.\n         LH    R1,YEAR                 GET IPL YEAR.\n         SLL   R1,4                    R1 = 00000YY0.\n         OR    R1,R2                   R1 = 00000YY+.\n         ST    R1,DOUBLE+4             SAVE IT.\n         CVB   R1,DOUBLE               CONVERT TO BINARY.\n         STH   R1,BYEAR                SAVE IT.\n         AH    R1,=H'1900'             ADJUST FOR CENTURY.\n         STH   R1,BCENTURY             SAVE IT.\n         LH    R1,BDAY                 SET N = DAY.\n         LH    R15,BCENTURY            GET YEAR.\n         LH    R14,BMONTH              GET MONTH.\n         CH    R14,=H'2'               IS IT FEBRUARY ?\n         BH    B080                    * NO, BYPASS.\n         BE    B060                    * YES, BYPASS.\n         LA    R14,13                  SET M=13.\n         B     B070                    BYPASS.\nB060     LA    R14,14                  SET M=14.\nB070     BCTR  R15,0                   DECREMENT YEAR COUNTER.\nB080     LR    R0,R14                  SAVE MONTH.\n         ALR   R0,R0                   GET 2M.\n         ALR   R1,R0                   SET N = N + 2M\n         LR    R0,R15                  SAVE REDEFINED YEAR.\n         LA    R14,1(R14)              GET M+1.\n         MH    R14,=H'3'               GET 3(M+1).\n         SRDL  R14,32                  SHIFT INTO R15, ZERO R14.\n         D     R14,=F'5'               GET 3(M+1)/5 IN R15.\n         ALR   R1,R15                  SET N = N + 3(M+1)/5.\n         LR    R15,R0                  GET YEAR.\n         ALR   R1,R15                  SET N = N + Y.\n         SLR   R14,R14                 ZERO WORK REGISTER.\n         D     R14,=F'4'               GET Y/4.\n         ALR   R1,R15                  SET N = N + Y/4.\n         LR    R15,R0                  GET YEAR.\n         SLR   R14,R14                 ZERO WORK REGISTER.\n         D     R14,=F'100'             GET Y/100.\n         SLR   R1,R15                  SET N = N - Y/100.\n         LR    R15,R0                  GET Y.\n         SLR   R14,R14                 ZERO WORK REGISTER.\n         D     R14,=F'400'             GET Y/400.\n         ALR   R1,R15                  SET N = N + Y/400.\n         LA    R15,2                   GET 2.\n         ALR   R1,R15                  SET N = N + 2.\n         SLR   R0,R0                   ZERO WORK REGISTER.\n         D     R0,=F'7'                SET N = N/7.\n         STH   R0,WEEKDAY              SAVE REMAINDER.\n         LR    R1,R0                   GET N.\n         MH    R1,=AL2(DAYLNTH)        MULTIPLE BY ENTRY LENGTH.\n         XR    R2,R2                   CLEAR WORK REGISTER.\n         IC    R2,DAYTABLE(R1)         GET DAY LENGTH.\n         BCTR  R2,0                    DECREMENT FOR TRUE LENGTH.\n         LA    R14,DAYTABLE+1(R1)      POINT TO DAY.\n         LA    R15,MSG2DATA            POINT TO IPL DATE.\n         EX    R2,MVCPROSE             MOVE NAME.\n         LA    R15,2(R2,R15)           INCREMENT TO PROSE MONTH.\n                                       SPACE 1\n         LH    R1,BMONTH               GET CURRENT MONTH (BINARY).\n         BCTR  R1,0                    DECREMENT FOR OFFSET.\n         MH    R1,=AL2(MONLNTH)        MULTIPLE BY ENTRY LENGTH.\n         XR    R2,R2                   CLEAR WORK REGISTER.\n         IC    R2,MONTABLE(R1)         GET DAY LENGTH.\n         BCTR  R2,0                    DECREMENT FOR TRUE LENGTH.\n         LA    R14,MONTABLE+1(R1)      POINT TO MONTH.\n         EX    R2,MVCPROSE             MOVE NAME.\n         LA    R15,2(R2,R15)           INCREMENT TO PROSE DATE.\n         MVC   EDITWORK,DATEMASK       GET DATE MASK - DD/MM/YY.\n         ED    EDITWORK,SAVEDATE       MAKE DATE PRINTABLE.\n         MVC   0(2,R15),EDITWORK+2     MOVE DATE.\n         MVI   2(R15),C','             INSERT COMMA.\n         LA    R15,4(R15)              INCREMENT TO PROSE YEAR.\n         LH    R1,BCENTURY             GET CURRENT CENTURY.\n         CVD   R1,DOUBLE               CONVERT CENTURY.\n         MVC   EDITWORK,YEARMASK       GET YEAR MASK - YYYY.\n         ED    EDITWORK(6),DOUBLE+5    MAKE YEAR PRINTABLE.\n         MVC   0(4,R15),EDITWORK+2     MOVE YEAR.\n         LA    R15,5(R15)              INCREMENT OUTPUT POINTER.\n         MVC   0(2,R15),=C'AT'         MOVE SEPERATOR.\n         LA    R15,2(R15)              INCREMENT TO PROSE TIME.\n         MVC   0(7,R15),TIMEMASK       RESET EDIT MASK.\n         ED    0(7,R15),SAVETIME+1     GET IPL TIME (HHMM).\n         BR    R10                     ===> Return to Caller\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Constants, Literals and Variables                            *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         LTORG\nTBCREATE DC    CL8'TBCREATE'           ISPF CONSTANT\nTBADD    DC    CL8'TBADD'              ISPF CONSTANT\nTBEND    DC    CL8'TBEND'              ISPF CONSTANT\nTBTOP    DC    CL8'TBTOP'              ISPF CONSTANT\nTBDISPL  DC    CL8'TBDISPL'            ISPF CONSTANT\nNOWRITE  DC    CL8'NOWRITE'            ISPF CONSTANT\nCSYSTEM  DC    C'(SYSTEM)'             ISPF VARIABLE NAME\nSYSTABLE DC    CL8'SYSTEM'             ISPF TABLE AND PANEL NAME\nF79      DC    F'79'                   LENGTH VALUE OF 79\nSAVEAREA DC    18F'0'                  REGISTER SAVEAREA.\n                                       SPACE 1\nEPLOC DC       F'0'                    ADDRESS OF ISPLINK.\nDOUBLE   DC    D'0'                    WORK AREA.\n                                       SPACE 1\nSAVEDATE DC    F'0'                    DATE SAVEAREA.\nSAVETIME DC    F'0'                    TIME SAVEAREA.\nTIME     DC    F'0'                    DATE SAVEAREA.\nDATE     DC    F'0'                    TIME SAVEAREA.\n                                       SPACE 1\nYEAR     DC    H'0'                    YEAR     (DECIMAL).\nWEEKDAY  DC    H'0'                    WEEK DAY (BINARY).\nBDAY     DC    H'0'                    DAY      (BINARY).\nBMONTH   DC    H'0'                    MONTH    (BINARY).\nBYEAR    DC    H'0'                    YEAR     (BINARY).\nBCENTURY DC    H'0'                    CENTURY  (BINARY).\n                                       SPACE 1\nMVCPROSE MVC   0(0,R15),0(R14)         EXECUTED MOVE.\n                                       SPACE 1\nEDITWORK DC    XL10'00'                EDIT WORK AREA.\n                                       SPACE 1\nYEARMASK DC    X'402120202020'         EDIT MASK - YYYY.\nDATEMASK DC    X'40212020612020612020' DATE EDIT MASK - (DD/MM/YY).\nTIMEMASK DC    X'402120207A2020'       TIME EDIT MASK - (HH:MM).\n                                       SPACE 1\nGENFLAG  DC    X'00'                   GENERAL FLAG BYTE.\nGENSPF   EQU   X'80'                   SPF PROCESSING REQD.\nGENDCB   EQU   X'40'                   DCB PROCESSING REQD.\nGENSYSUT EQU   X'20'                   SYSUT2 DD FOUND\n                                       SPACE 1\nISPQRY   DC    CL8'ISPQRY'             ISPQRY  MODULE NAME.\nISPLINK  DC    CL8'ISPLINK'            ISPLINK MODULE NAME.\n                                       SPACE 1\nVDEFINE  DC    CL8'VDEFINE '           ISPF FUNCTIONS.\n                                       SPACE 1\nCHAR     DC    CL8'CHAR'\n                                       SPACE 1\nDAYSPMON DC    AL1(31,28,31,30,31,30,31,31,30,31,30,31)\n                                       SPACE 1\nMONTABLE DC    AL1(7),CL9'January'     MONTH TABLE.\nMONLNTH  EQU   *-MONTABLE              MONTH ENTRY LENGTH.\n         DC    AL1(8),CL9'February'    *\n         DC    AL1(5),CL9'March'       *\n         DC    AL1(5),CL9'April'       *\n         DC    AL1(3),CL9'May'         *\n         DC    AL1(4),CL9'June'        *\n         DC    AL1(4),CL9'July'        *\n         DC    AL1(6),CL9'August'      *\n         DC    AL1(9),CL9'September'   *\n         DC    AL1(7),CL9'October'     *\n         DC    AL1(8),CL9'November'    *\n         DC    AL1(8),CL9'December'    *\n                                       SPACE 1\nDAYTABLE DC    AL1(8),CL9'Saturday'    DAY TABLE.\nDAYLNTH  EQU   *-DAYTABLE              DAY ENTRY LENGTH.\n         DC    AL1(6),CL9'Sunday'      *\n         DC    AL1(6),CL9'Monday'      *\n         DC    AL1(7),CL9'Tuesday'     *\n         DC    AL1(9),CL9'Wednesday'   *\n         DC    AL1(8),CL9'Thursday'    *\n         DC    AL1(6),CL9'Friday'      *\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Output record constants                                      *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nL00      DC    C'System IPL Status Display for '\nL01      DC    C'Last IPL Performed on '\nL01C     DC    C'Current Date and Time '\nL02      DC    C'Operating System Level'\nL03      DC    C'IPL Load Parm used was'\nL04      DC    C'Max Private below 16 Meg.'\nL05      DC    C'Nucleus Id'\nL06      DC    C'SMF Id'\nL14      DC    C'CPU Serial Number and Type'\nL08      DC    C'Master Catalog is'\nL10      DC    C'Master Catalog is on'\nL09      DC    C'System IPL Volser'\nL11      DC    C'SYS2.NSP.LOADLIB is on'\nL15      DC    C'SYS1.PARMLIB is on'\nNAME00   DC    C'Symbolic Variable               Value'\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Output record and its redefinitions                          *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nBLANK    DC    C' '\nRECORD   DC    CL80' '\n         ORG   RECORD+30\nEQUALS   DS    C                       = sign inserted here\n         ORG   RECORD+L'L00 '\nSYSTEMID DS    CL8\n         ORG   RECORD+L'L01 '\nMSG2DATA DS    CL40                    IPL date and time\n         ORG   RECORD+32\nSPLEVEL  DS    CL8                     Operating System level\n         ORG   RECORD+32\nIPLPARM  DS    CL8                     IPL Parameters\n         ORG   RECORD+32\nPVTSIZE  DS    CL5                     Private Storage below the line\nK        DS    C\n         ORG   RECORD+32\nNUCLEUS  DS    C'IEANUC0'\nNUCID    DS    C                       Nucleus Id\n         ORG   RECORD+32\nSMFID    DS    CL4                     SMF Id\n         ORG   RECORD+32\nCPUCODE  DS    CL2                     CPU Code\nDASH1    DS    C\nCPULPAR  DS    CL2                     CPU Lpars\nDASH2    DS    C\nCPUID    DS    CL4                     CPU Id\nDASH3    DS    C\nCPUTYPE  DS    CL4                     CPU Type\n         ORG   RECORD+32\nCATNAME  DS    CL44                    Master catalog dsn\n         ORG   RECORD+32\nVOLSER   DS    CL6                     Volume Serial\n         DS    C\nON       DS    CL2\n         DS    C\nUNIT     DS    CL4                     Unit Address\nBLANK2   DS    C\n         ORG   RECORD\nNAME     DS    CL12                    Variable Name\n         DS    CL20\nCONTENT  DS    CL50                    Variable content\n         ORG   ,                       Reset Origin\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        Other data                                                   *\n*---------------------------------------------------------------------*\n                                       SPACE 1\nSYSUT2   DCB   DDNAME=SYSUT2,MACRF=PM,RECFM=FB,LRECL=80,               *\n               BLKSIZE=0,DSORG=PS,DCBE=DCBE\nDCBE     DCBE  RMODE31=BUFF\n                                       SPACE 1\nDB       DC    D'0'                    DOUBLE WORD WORK AREA\nSVC99RBP DC    A(SVC99RB+X'80000000')  SVC 99 RB POINTER\nSVC99RB  DC    5F'0'                   SVC 99 RB\nRBLEN    EQU   S99RBEND-S99RB\n                                       SPACE 1\nTUDSN    DC    AL2(DALDSNAM,1,44)\nDSN      DC    CL44' '                 PROVIDED DSN\nTUDDN    DC    AL2(DALRTDDN,1,8)       RETURN A DD NAME\nDDNAME   DC    CL8'        '           DDNAME\n                                       SPACE 1\nTUALLOC  DC    A(TUDSN)                TEXT UNIT POINTERS\n         DC    A(TUDISP)               TEXT UNIT POINTERS\nTUFREE   DC    X'80',AL3(TUDDN)        LAST TEXT UNIT POINTER\n                                       SPACE 1\nTUDISP   DC    AL2(DALSTATS,1,1)       ALLOCATION STATUS\n         DC    X'08'                   DISP=SHR\n                                       SPACE 1\nTRTABLE  DC    C'0123456789ABCDEF'     HEX/EBCDIC TRANSLATE TABLE\n                                       SPACE\nMVCNAME  MVC   NAME(*-*),0(R6)         Copy the variable name\nMVCVAR   MVC   CONTENT(*-*),0(R8)      Copy the variable content\n                                       SPACE 1\n         DC    S(*),S(*),S(*),S(*)\n         CNOP  0,8                     TERMINATES ON DOUBLE WORD BDY.\n                                       SPACE 1\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n                                       SPACE 1\n         ASASYMBP ,                    MAPPING OF SYMBP AREA\n         IHAPSA\n         IHAPCCA\n         CVT   DSECT=YES,PREFIX=YES\n         IHAECVT ,\n         IHAGDA  ,\n         IEFUCBOB                      MAP THE UCB.\n         IEESMCA\n         IEFZB4D0 ,                    DYNAMIC ALLOCATION - PARM LIST\n         IEFZB4D2 ,                    DYNAMIC ALLOCATION - KEYS\nTIOT     DSECT\n         IEFTIOT1\n         IKJTCB\n*        AMCBS\n*        IGGCAXWA\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNLOAD": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x19\\x0f\\x00\\x99\\x19\\x0f\\x13\\x02\\x01\\x7f\\x01\\x7f\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-09T00:00:00", "modifydate": "1999-07-09T13:02:00", "lines": 383, "newlines": 383, "modlines": 0, "user": "PGILLIS"}, "text": "UNLOAD TITLE 'CONVERTS A DATASET FROM PARTITIONED TO SEQUENTIAL'\n***********************************************************************\n*                                                                     *\n*   *** UNLOAD *** PDS UNLOAD UTILITY                                 *\n*                                                                     *\n*                    WRITTEN SEPTEMBER 1982                           *\n*                    AUTHOR  P.GILLIS                                 *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*   INPUT.                                                            *\n*                                                                     *\n*      1.  OPTIONAL PARAMETER FIELD IN THE FOLLWING FORMAT            *\n*                                                                     *\n*          PARM='XX,YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY'      *\n*                                                                     *\n*          XX - THE COLUMN NUMBER IN THE SUPPLIED DATA WHERE THE      *\n*               MEMBER NAME WILL BE INSERTED. NOTE THAT THAT DATA     *\n*               WILL BE OUTPUT BEFORE EACH UNLOADED MEMBER. IF NO     *\n*               PARAMETER FIELD IS PRESENT THEN NO RECORD WILL BE     *\n*               WRITTEN BEFORE EACH MEMBER.                           *\n*                                                                     *\n*          YY - THIS DATA WILL BE WRITTEN AS A RECORD BEFORE EACH     *\n*               UNLOADED MEMBER.                                      *\n*                                                                     *\n*      2.  SYSUT1                                                     *\n*                                                                     *\n*          THIS IS THE INPUT FILE AND MUST BE A PARTITIONED DATASET   *\n*          NOTE:- LOAD MODULE LIBRARIES ARE NOT SUPPORTED. THE ONLY   *\n*          RECFM SUPPORTED IS FIXED OR VARIABLE                       *\n*                                                                     *\n*   OUTPUT.                                                           *\n*                                                                     *\n*      1.  SYSPRINT                                                   *\n*                                                                     *\n*          MESSAGE FILE FOR ERROR MESSAGES AND AUDIT TRAILS           *\n*                                                                     *\n*      2.  SYSUT2                                                     *\n*                                                                     *\n*          THIS IS THE OUTPUT FILE AND MUST BE A SEQUENTIAL DATASET   *\n*                                                                     *\n*      3.  RETURN CODES                                               *\n*                                                                     *\n*          RC=0  PROGRAM COMPLETED SUCCESSFULLY                       *\n*          RC=16 SYSPRINT DDNAME MISSING                              *\n*                SYSUT1 DDNAME MISSING                                *\n*                SYSUT2 DDNAME MISSING                                *\n*          RC=8  INPUT DATASET IS NOT PARTITIONED                     *\n*          RC=8  INPUT DATASET HAS RECFM=U                            *\n*          RC=8  OUTPUT DATASET INVALID                               *\n*                                                                     *\n***********************************************************************\n TITLE 'UPD#XXX UNLOADS DATASET FROM PARTITIONED TO SEQUENTIAL'\nUNLOAD   CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING UNLOAD,R12        ESTABLISH COMMON BASE\n         USING DIRECTRY,R10\n         SAVE  (14,12),,UNLOAD\n         LR    R12,R15             ESTABLISH PROGRAM BASE\n         LA    R14,SAVEAREA        ADDRESS OF SAVE AREA\n         ST    R13,4(R14)          SAVE CALLERS SAVEAREA ADDRESS\n         ST    R14,8(R13)          AND SAVE IT IN PREVIOUS SAVE AREA\n         XR    R15,R15             ZERO REGISTER 15\n         ST    R15,8(R14)          ZERO THE NEXT SAVE AREA CHAIN\n         LR    R13,R14             GET ADDRESS CURRENT SAVE AREA\n                                   SPACE 1\n* HANDLE PARM FIELD PROCESSING\n                                   SPACE 1\n         L     R2,0(R1)            ADDRESS OF PARM FIELD\n         LH    R3,0(R2)            LENGTH OF PARM FIELD\n         LTR   R3,R3               IS IT THERE AT ALL\n         BZ    UNLOD010            -> NO\n         LA    R2,2(R2)            FIRST BYTE IN FIELD\n         LR    R5,R2               REMEMBER START ADDRESS\n         LA    R4,0                LENGTH OF NUMERIC FIELD\nUNLOD001 DS    0H\n         CLI   0(R2),C','          FOUND TERMINATING COMMA\n         BE    UNLOD002            -> YES\n         TM    0(R2),X'F0'         NUMERIC\n         BNO   UNLOD002            -> NO\n         LA    R2,1(R2)            INCREMENT ADDRESS OF PARM\n         LA    R4,1(R4)            INCREMENT COUNTER\n         BCT   R3,UNLOD001         CONTINUE FOR A WHILE\n         CH    R4,=H'3'            DO NOT HANDLE > 3 DIGITS\n         BH    UNLOD003\nUNLOD002 DS    0H\n         LTR   R4,R4\n         BZ    UNLOD003            MUST HAVE AT LEAST ONE\n         BCTR  R4,0\n         EX    R4,PACK             CONVERT IT TO\n         CVB   R6,DB                 DECIMAL\n         LA    R1,FBSEPER          ADDRESS OF WHERE TO PUT IT\n         AR    R1,R6               PLUS OFFSET\n         BCTR  R1,0                LESS ONE FOR COLUMN POSITION\n         ST    R1,MEMBERAD         AND SAVE IT\nUNLOD003 DS    0H\n         LA    R2,1(R2)            SKIP OVER THE COMMA THAT IS THERE ?\n         BCTR  R3,0                AND DECREMENT BY ONE\n         OI    FLAGS,MEMBERDT\n         LTR   R3,R3               HAVE I GOT ANY DATA\n         BZ    UNLOD010            -> NO\n         LA    R6,13(R6)            CHECK FOR LENGTH\n         STH   R6,VBSEPER          SAVE FOR VARIABLE I/O\n         BCTR  R3,0                LESS ONE FOR THE MOVE\n         EX    R3,MVC\n         CH    R3,VBSEPER\n         BNH   UNLOD010            -> LENGTH OK\n         STH   R3,VBSEPER          SAVE NEW LENGTH\n                                   SPACE 1\n* OPEN SYSPRINT, SYSUT1 AND SYSUT2\n                                   SPACE 1\nUNLOD010 DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         TM    SYSPRINT+DCBOFLGS-IHADCB,X'10'\n         BZ    ERROR#00            NO DD FOR SYSPRINT\n                                   SPACE 1\n         OPEN  (DIRECT,(INPUT))\n         TM    DIRECT+DCBOFLGS-IHADCB,X'10'\n         BZ    ERROR#01            NO DD FOR SYSUT1\n                                   SPACE 1\n         OPEN  (SYSUT1,(INPUT))\n         TM    SYSUT1+DCBOFLGS-IHADCB,X'10'\n         BZ    ERROR#01            NO DD FOR SYSUT1\n         LH    R0,SYSUT1+DCBBLKSI-IHADCB\n         ST    R0,BUFFERLN         BECOMES THE BUFFER LENGTH\n         GETMAIN RU,LV=(0),BNDRY=PAGE\n         ST    R1,BUFFERAD         BUFFER ADDRESS\n         L     R1,=A(SYSUT1RF)\n         USING SYSUT1RF,R1\n         MVC   SYSUT1RF,SYSUT1+DCBRECFM-IHADCB\n         MVC   SYSUT1LR,SYSUT1+DCBLRECL-IHADCB\n         MVC   SYSUT1BL,SYSUT1+DCBBLKSI-IHADCB\n         DROP  R1\n                                   SPACE 3\n         OPEN  (SYSUT2,(OUTPUT))\n         TM    SYSUT2+DCBOFLGS-IHADCB,X'10'\n         BZ    ERROR#02            NO DD FOR SYSUT2\n         TM    SYSUT2+DCBRECFM-IHADCB,DCBRECV\n         BZ    UNLOD020\n         OI    FLAGS,VB\n                                   SPACE 1\n*        LOOP THROUGH THE DIRECTORY\n                                   SPACE 1\nUNLOD020 DS    0H\n         GET   DIRECT,DIRECTIN\n         LA    R10,DIRECTIN+2      ADDRESS THE MEMBER NAME\n         LA    R9,DIRECTIN\n         AH    R9,DIRECTIN\nUNLOD030 DS    0H\n         CLC   MEMBER,=8X'FF'      IS MEMBER NAME = X'FFFFFFFF'\n         BE    UNLOD110            -> YES. TERMINATE THE PROGRAM\n         CLI   MEMBER,C'$'         IS MEMBER NAME NATIONAL\n         BE    UNLOD031            -> YES, PROCESS IT\n         CLI   MEMBER,C'#'         IS MEMBER NAME NATIONAL\n         BE    UNLOD031            -> YES, PROCESS IT\n         CLI   MEMBER,C'@'         IS MEMBER NAME NATIONAL\n         BE    UNLOD031            -> YES, PROCESS IT\n         CLI   MEMBER,C'A'         IS MEMBER NAME ALPHABETIC\n         BL    UNLOD106            -> NO, SKIP IT\nUNLOD031 DS    0H\n         MVC   PRINTMEM,MEMBER     SAVE THE MEMBER ADDRESS\n         TM    DIRFLAGS,ALIAS      IS THIS AN ALIAS ENTRY\n         BZ    UNLOD032\n         MVC   NUMRECS,=CL10' ALIAS'\n         B     UNLOD105\nUNLOD032 DS    0H\n         ZAP   RECOUNT,=P'0'       ZERO RECORD COUNTER\n         L     R1,MEMBERAD\n         MVC   0(8,R1),MEMBER      SAVE THE MEMBER ADDRESS\n         TM    FLAGS,MEMBERDT      OUTPUT MEMBER DATA ?\n         BZ    UNLOD040\n         TM    FLAGS,VB            OUTPUT DATA VARIABLE\n         BZ    UNLOD035\n         PUT   SYSUT2,VBSEPER\n         B     UNLOD040\nUNLOD035 DS    0H\n         PUT   SYSUT2,FBSEPER\n                                   SPACE 1\n*        PROCESS THE NEXT MEMBER\n                                   SPACE 1\nUNLOD040 DS    0H\n         LA    R8,SYSUT1           ADDRESS OF DCB\n         L     R7,BUFFERAD         ADDRESS OF BUFFER\n         LA    R6,8(R10)           ADDRESS OF TTR\n         FIND  (8),(10),D          FIND THE START OF THE MEMBER\nUNLOD050 DS    0H\n         READ  PDSDECB,SF,(8),(7),'S'\n         CHECK PDSDECB             MAKE SURE I HAVE GOT IT\n         LH    R6,SYSUT1+DCBLRECL-IHADCB\n         LH    R4,SYSUT1+DCBBLKSI-IHADCB\n         L     R15,PDSDECB+16\n         SH    R4,14(R15)          LENGTH OF SHORT BLOCK\n         LR    R0,R4               SAVE IN CASE ITS VB\n         SRDA  R4,32               SET UP FOR DIVIDE\n         DR    R4,R6               GET NUMBER OF RECORDS IN BLOCK\nUNLOD060 DS    0H\n         TM    SYSUT1+DCBRECFM-IHADCB,DCBRECV    RECFM=V..\n         BZ    UNLOD080            -> NO\n         LR    R4,R0               RESTORE BLOCK LENGTH IN R4\n         S     R4,=F'4'            LESS BLOCK DESCRIPTOR\n         LA    R7,4(R7)            SKIP OVER BLOCK DESCRIPTOR\nUNLOD070 DS    0H\n         LH    R6,0(R7)            LOAD RECORD DESCRIPTOR\n         PUT   SYSUT2,0(R7)\n         AP    RECOUNT,=P'1'       INCREMENT RECORD COUNT\n         LA    R7,0(R6,R7)         POINT TO NEXT RECORD\n         SR    R4,R6\n         BP    UNLOD070            -> CONTINUE UNTILL BLOCK COPIED\n         L     R7,BUFFERAD         RESTORE BUFFER ADDRESS\n         B     UNLOD050            LOOP THROUGH UNTILL DONE\n                                   SPACE 1\nUNLOD080 DS    0H\n         PUT   SYSUT2,0(R7)\n         AP    RECOUNT,=P'1'       INCREMENT RECORD COUNT\n         LA    R7,0(R6,R7)         POINT TO NEXT RECORD\n         BCT   R5,UNLOD080         -> AND PUT IT\n         L     R7,BUFFERAD         RESTORE BUFFER ADDRESS\n         B     UNLOD050            LOOP THROUGH UNTILL DONE\n                                   SPACE 1\nUNLOD100 DS    0H\n         MVC   NUMRECS,PATTERN     SET UP PATTERN FOR\n         ED    NUMRECS,RECOUNT     THE RECORD COUNT\nUNLOD105 DS    0H\n         PUT   SYSPRINT,PRNTCNTL\nUNLOD106 DS    0H\n         SR    R15,R15             CLEAR REG15\n         NI    DIRFLAGS,X'1F'      AND THE DIRECTORY FLAGS\n         IC    R15,DIRFLAGS        INSERT INTO REG15\n         AR    R15,R15             DOUBLE REG15\n         LA    R10,12(R15,R10)     POINT REG10 TO NEXT MEMBER\n         CR    R10,R9              COMPARE WITH DIRECTORY LENGTH\n         BNL   UNLOD020            GET ANOTHER DIRECTORY RECORD\n         B     UNLOD030            CHECK CURRENT MEMBER FOR EOF.\n                                   SPACE 3\n* CLOSE SYSPRINT, SYSUT1 AND SYSUT2, THEN RETURN TO CALLER\n                                   SPACE 1\nUNLOD110 DS    0H\n         CLOSE SYSUT2\nUNLOD120 DS    0H\n         L     R0,BUFFERLN         BUFFER LENGTH\n         L     R1,BUFFERAD         BUFFER ADDRESS\n         FREEMAIN RU,LV=(0),A=(1)\n         CLOSE SYSUT1\n         CLOSE DIRECT\nUNLOD130 DS    0H\n         CLOSE SYSPRINT\nUNLOD140 DS    0H\n         XR    R15,R15             SET RETURN CODE\n         IC    R15,RETCODE         TO REQUIRED VALUE\n         L     R13,4(R13)          RESTORE CALLERS SAVE AREA ADDRESS\n         RETURN (14,12),,RC=(15)\n                                       SPACE 3\nERROR#00 DS    0H\n         MVI   RETCODE,16\n         B     UNLOD140\n                                       SPACE 3\nERROR#01 DS    0H\n         MVI   RETCODE,16\n         B     UNLOD130\n                                       SPACE 3\nERROR#02 DS    0H\n         MVI   RETCODE,16\n         B     UNLOD120\n                                       SPACE 3\n         PRINT NOGEN\n         DS    0F\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,EXLST=PRINTLS,                 *\n               DSORG=PS,RECFM=FBA,LRECL=133\n         DS    0F\nDIRECT   DCB   DDNAME=SYSUT1,DEVD=DA,EODAD=UNLOD110,MACRF=(GM),        *\n               DSORG=PS,RECFM=F,LRECL=256,BLKSIZE=256\n         DS    0F\nSYSUT1   DCB   DDNAME=SYSUT1,DSORG=PO,MACRF=(R),EODAD=UNLOD100\n         DS    0F\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM,EXLST=SYSUT2LS\n         DS    0F\n         PRINT GEN\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n         DC    S(*),S(*),S(*),S(*)\n                                       SPACE 3\nDB       DC    D'0'\nSAVEAREA DC    18F'0'\nBUFFERLN DC    F'0'\nBUFFERAD DC    F'0'\nRECOUNT  DC    PL4'0'\nDIRECTIN DC    256C' '\nVBSEPER  DC    H'8'\n         DC    H'0'\nFBSEPER  DC    256C' '\nMEMBERAD DC    A(FBSEPER)\n         DC    C' '\nPRNTCNTL DC    C' '\nPRINTMEM DC    CL8' '\nNUMRECS  DC    CL10' '\n         DC    CL116' '\nPATTERN  DC    X'40206B2020206B202120'\nRETCODE  DC    X'00'\nFLAGS    DC    X'00'\nMEMBERDT EQU   X'80'\nVB       EQU   X'40'\n                                   SPACE 3\nPACK     PACK  DB,0(*-*,R5)        PACK THE PARM NUMBERS\nMVC      MVC   FBSEPER(*-*),0(R2)\n                                   SPACE 3\n         LTORG\nSYSUT2LS DC    0F'0',X'85',AL3(SYSUT2EX)\nPRINTLS  DC    0F'0',X'85',AL3(PRINTEX)\nPRINTEX  DS    0H\n         DROP  ,\n         USING PRINTEX,R15\n         USING IHADCB,R1\n         OC    DCBBLKSI,DCBBLKSI   BLOCKSIZE CODED\n         BCR   7,R14               -> YES\n         MVC   DCBBLKSI,DCBLRECL   DEFAULT BLOCKSIZE IS LRECL\n         BR    R14                 AND RETURN\nSYSUT2EX DS    0H\n         DROP  ,\n         USING SYSUT2EX,R15\n         USING IHADCB,R1\n         TM    DCBRECFM,DCBRECF    RECFM=F\n         BO    SYSUT202            -> YES\n         TM    DCBRECFM,DCBRECV    RECFM=V\n         BO    SYSUT202            -> YES\n         MVC   DCBRECFM,SYSUT1RF   USE THE SYSUT1 RECFM\nSYSUT202 DS    0H\n         OC    DCBLRECL,DCBLRECL   LRECL CODED\n         BNZ   SYSUT204            -> YES\n         MVC   DCBLRECL,SYSUT1LR   USE SYSUT1'S LRECL\nSYSUT204 DS    0H\n         OC    DCBBLKSI,DCBBLKSI   BLOCKSIZE CODED\n         BCR   7,R14               -> YES\n         MVC   DCBBLKSI,SYSUT1BL   USE SYSUT1'S BLKSIZE\n         BR    R14                 AND RETURN\nSYSUT1RF DC    H'0'\nSYSUT1LR DC    H'0'\nSYSUT1BL DC    H'0'\n         LTORG ,\n         DROP  R1,R15\nDIRECTRY DSECT\nMEMBER   DS    CL8\nTTR      DS    CL3\nDIRFLAGS DS    CL1\nALIAS    EQU   X'80'\nTTRNS    EQU   X'60'\nUSERDATA EQU   X'3F'\nVV       DS    CL1\nMM       DS    CL1\nUNK      DS    CL2\nCCC      DS    CL1\nCYY      DS    CL1\nCDATE    DS    PL2\nMCC      DS    CL1\nMYY      DS    CL1\nMDATE    DS    PL2\nMHOUR    DS    CL1\nMMIN     DS    CL1\nSIZE     DS    CL2\nINIT     DS    CL2\nMOD      DS    CL2\nID       DS    CL8\n         PRINT NOGEN\n         DCBD  DSORG=(PO,PS)\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNLOAD$": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x19\\x0f\\x00\\x99\\x19\\x0f\\x13\\x02\\x00\\x12\\x00\\x12\\x00\\x00\\xd7\\xc7\\xc9\\xd3\\xd3\\xc9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-09T00:00:00", "modifydate": "1999-07-09T13:02:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "PGILLIS"}, "text": "//*\n//* Note that this JCL will unload a partitioned dataset\n//* and convert it into a flat file, adding any control\n//* card you like in between members. The control card is\n//* defined in the parm, as is the two byte numeric position\n//* where you want the member name inserted.\n//*\n//* Note that the input lrecl and the output lrecl do not\n//* have to match. This assists in stripping off line numbers\n//*\n//UNLOAD   EXEC PGM=UNLOAD,PARM='15,./ ADD MEMBER=XXXXXXXX'\n//STEPLIB  DD  DISP=SHR,DSN=ZPG.ISPF.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=SHR,DSN=ZPG.T2.TEXT\n//SYSUT2   DD  DISP=(,CATLG),DSN=ZPG.T3.TEXT,\n//             RECFM=FB,LRECL=72,BLKSIZE=27936,UNIT=SYSDA,\n//             SPACE=(TRK,(25,25),RLSE)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT382/FILE382.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT382", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}