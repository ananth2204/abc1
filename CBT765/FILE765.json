{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012741000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE765.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE765.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x07'", "DS1TRBAL": "b'a\\xe2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x052\\x00\\x05\\x052\\x00\\x0c\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04K\\x00\\x00\\x01\\x07&/\\x01\\x07&/\\t3\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@'", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-09-19T00:00:00", "modifydate": "2007-09-19T09:33:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-475"}, "text": "REGULAR CBT TAPE - VERSION 475    FILE:  765\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT475.FILE765\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,270 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/19/07    09:33:14    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INTRO": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\x10D\\x00K\\x00K\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T10:44:25", "lines": 75, "newlines": 75, "modlines": 0, "user": "SBGOLOB"}, "text": "Forms-based Authentication for the IBM HTTP Server for z/OS\n-----------------------------------------------------------\n\nThis REXX program and some supporting PL/I programs implement\nforms-based authentication for the IBM HTTP Server for z/OS.\n\nWe're a poor, State-run, academic institution so we can't afford\nto buy expensive software like the Websphere Application Server\nwhere such things as forms-based authentication are built-in (I\ndon't know if it is or not, but was told that was the case).\n\nWe have the HTTP server that comes as part of the base z/OS\nsystem. But, being that we are an academic institution, our\nnetwork tends to be open to to just about anybody and our\ncustomers need to be able to access our systems from around the\nworld. For us, it's important that we have a secure (i.e.\nencrypted) login process.\n\nAlso, many of our customers utilize two-factor authentication\ntokens such as RSA's SecurID tokens or PassGo Technology's\nDigiPass tokens. We needed an authentication mechanism that took\nthat into account.\n\nThis program runs as a GWAPI/REXX pre-exit.\n\nTo use this program, edit your HTTP server's configuration file.\nOn my system, it is /etc/httpd.conf (I think that's the default).\nAssuming that you copied the REXX program to directory /myGWAPI,\ndefine the program as a pre-exit:\n\n  PreExit /usr/lpp/internet/bin/IMWX00.so:IMWX00/myGWAPI/RACFauthR.rx\n\nI don't know if it's necessary or not, but we defined protection\ndirectives for the applications that will be authenticating -- we\nwere originally using BASIC authentication and never took out the\ndirectives.  In case this thing needs it, I figured I'd better\nlet you know what we had:\n\n  Protection ITS_User {\n          ServerId        ITS_User\n          AuthType        Basic\n          PasswdFile      %%SAF%%\n          Mask            All\n  }\nProtect /MVSDS*         ITS_User %%CLIENT%%\nProtect /RACFmaint*     ITS_User %%CLIENT%%\n\nService /MVSDS*     /usr/lpp/internet/bin/mvsds.so:mvsdsGet*\nService /RACFmaint* /usr/lpp/internet/bin/IMWX00.so:IMWX00/myGWAPI/RACFmaint.rx\n\nThe PL/I programs are compiled and linked into a load library\nthat is in the HTTP server's STEPLIB. We're using the IBM\nEnterprise PL/I for z/OS v3r4 compiler. We also had to do\n\n  RDEFINE PROGRAM ** ADDMEM('MY.IMWLOAD'//NOPADCHK) UACC(READ)\nfor the load library.\n\nI didn't include our stylesheets and images because I don't think\nanybody would be interested in using them. The stylesheets I use\nwere set up as an inside joke -- our web applications still look\nlike \"green screen\" 3270 stuff (see the screenshot.jpg).\n\nI hope this is useful to somebody.\n\n-- Stephen\n\nStephen Y Odo\nSr Systems Programmer\nUniversity of Hawai'i Information Technology Services\n2565 McCarthy Mall\nKeller Hall, Room 102A\nHonolulu, HI  96822\n(808)956-2383\nStephen@Hawaii.Edu\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\t\\x06\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T09:06:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     contribution to the CBT tape\nFrom:        Stephen Y Odo <stephen@hawaii.edu>\nDate:        Tue, 28 Aug 2007 17:07:22 -1000\nTo:          sbgolob@cbttape.org\n\nHi,\n\nWant to contribute the attached file.\n\nIt's something I wrote to do forms-based authentication with the\nHTTP server for z/OS (the one that comes free with z/OS).\n\nIt's not very polished. And it's kinda slow.  It's really just a\nproof-of-concept thing that never went much further.  But I hope\nit is useful to somebody.\n\n--Stephen\n\n\nFormsBasedAuthentication.zip\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE765": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04K\\x00\\x00\\x01\\x07&/\\x01\\x07&/\\t3\\x00e\\x00e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@'", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-09-19T00:00:00", "modifydate": "2007-09-19T09:33:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "CBT-475"}, "text": "//***FILE 765 is from Stephen Odo and contains a home-grown forms   *   FILE 765\n//*           based authentication system for the IBM HTTP Server   *   FILE 765\n//*           for z/OS.  The following information describes this   *   FILE 765\n//*           system:                                               *   FILE 765\n//*                                                                 *   FILE 765\n//*           Forms-based Authentication for the                    *   FILE 765\n//*              IBM HTTP Server for z/OS                           *   FILE 765\n//*              ------------------------                           *   FILE 765\n//*                                                                 *   FILE 765\n//*     This is something I wrote to do forms-based                 *   FILE 765\n//*     authentication with the HTTP server for z/OS (the           *   FILE 765\n//*     one that comes free with z/OS).                             *   FILE 765\n//*                                                                 *   FILE 765\n//*     It's not very polished. And it's kinda slow.  It's          *   FILE 765\n//*     really just a proof-of-concept thing that never went        *   FILE 765\n//*     much further.  But I hope it is useful to somebody.         *   FILE 765\n//*                                                                 *   FILE 765\n//*     This REXX program and some supporting PL/I programs         *   FILE 765\n//*     implement forms-based authentication for the IBM HTTP       *   FILE 765\n//*     Server for z/OS.                                            *   FILE 765\n//*                                                                 *   FILE 765\n//*     We're a poor, State-run, academic institution so we         *   FILE 765\n//*     can't afford to buy expensive software like the             *   FILE 765\n//*     Websphere Application Server where such things as           *   FILE 765\n//*     forms-based authentication are built-in (I don't know       *   FILE 765\n//*     if it is or not, but was told that was the case).           *   FILE 765\n//*                                                                 *   FILE 765\n//*     We have the HTTP server that comes as part of the base      *   FILE 765\n//*     z/OS system. But, being that we are an academic             *   FILE 765\n//*     institution, our network tends to be open to to just        *   FILE 765\n//*     about anybody and our customers need to be able to          *   FILE 765\n//*     access our systems from around the world. For us, it's      *   FILE 765\n//*     important that we have a secure (i.e. encrypted) login      *   FILE 765\n//*     process.                                                    *   FILE 765\n//*                                                                 *   FILE 765\n//*     Also, many of our customers utilize two-factor              *   FILE 765\n//*     authentication tokens such as RSA's SecurID tokens or       *   FILE 765\n//*     PassGo Technology's DigiPass tokens. We needed an           *   FILE 765\n//*     authentication mechanism that took that into account.       *   FILE 765\n//*                                                                 *   FILE 765\n//*     This program runs as a GWAPI/REXX pre-exit.                 *   FILE 765\n//*                                                                 *   FILE 765\n//*     To use this program, edit your HTTP server's                *   FILE 765\n//*     configuration file.  On my system, it is                    *   FILE 765\n//*     /etc/httpd.conf (I think that's the default).  Assuming     *   FILE 765\n//*     that you copied the REXX program to directory /myGWAPI,     *   FILE 765\n//*     define the program as a pre-exit:                           *   FILE 765\n//*                                                                 *   FILE 765\n//*       PreExit /usr/lpp/internet                                 *   FILE 765\n//*       /bin/IMWX00.so:IMWX00/myGWAPI/RACFauthR.rx                *   FILE 765\n//*                                                                 *   FILE 765\n//*     I don't know if it's necessary or not, but we defined       *   FILE 765\n//*     protection directives for the applications that will be     *   FILE 765\n//*     authenticating -- we were originally using BASIC            *   FILE 765\n//*     authentication and never took out the directives.  In       *   FILE 765\n//*     case this thing needs it, I figured I'd better let you      *   FILE 765\n//*     know what we had:                                           *   FILE 765\n//*                                                                 *   FILE 765\n//*       Protection ITS_User {                                     *   FILE 765\n//*               ServerId        ITS_User                          *   FILE 765\n//*               AuthType        Basic                             *   FILE 765\n//*               PasswdFile      %%SAF%%                           *   FILE 765\n//*               Mask            All                               *   FILE 765\n//*       }                                                         *   FILE 765\n//*     Protect /MVSDS*         ITS_User %%CLIENT%%                 *   FILE 765\n//*     Protect /RACFmaint*     ITS_User %%CLIENT%%                 *   FILE 765\n//*                                                                 *   FILE 765\n//*     Service /MVSDS*     /usr/lpp/internet/bin                   *   FILE 765\n//*     /mvsds.so:mvsdsGet*                                         *   FILE 765\n//*                                                                 *   FILE 765\n//*     Service /RACFmaint* /usr/lpp/internet/bin                   *   FILE 765\n//*     /IMWX00.so:IMWX00/myGWAPI/RACFmaint.rx                      *   FILE 765\n//*                                                                 *   FILE 765\n//*     The PL/I programs are compiled and linked into a load       *   FILE 765\n//*     library that is in the HTTP server's STEPLIB. We're         *   FILE 765\n//*     using the IBM Enterprise PL/I for z/OS v3r4 compiler.       *   FILE 765\n//*     We also had to do                                           *   FILE 765\n//*                                                                 *   FILE 765\n//*       RDEFINE PROGRAM **                                        *   FILE 765\n//*       ADDMEM('MY.IMWLOAD'//NOPADCHK) UACC(READ)                 *   FILE 765\n//*     for the load library.                                       *   FILE 765\n//*                                                                 *   FILE 765\n//*     I didn't include our stylesheets and images because I       *   FILE 765\n//*     don't think anybody would be interested in using them.      *   FILE 765\n//*     The stylesheets I use were set up as an inside joke --      *   FILE 765\n//*     our web applications still look like \"green screen\"         *   FILE 765\n//*     3270 stuff (see the screenshot.jpg).                        *   FILE 765\n//*                                                                 *   FILE 765\n//*     I hope this is useful to somebody.                          *   FILE 765\n//*                                                                 *   FILE 765\n//*     -- Stephen                                                  *   FILE 765\n//*                                                                 *   FILE 765\n//*     Stephen Y Odo                                               *   FILE 765\n//*     Sr Systems Programmer                                       *   FILE 765\n//*     University of Hawai'i Information Technology Services       *   FILE 765\n//*     2565 McCarthy Mall                                          *   FILE 765\n//*     Keller Hall, Room 102A                                      *   FILE 765\n//*     Honolulu, HI  96822                                         *   FILE 765\n//*     (808)956-2383                                               *   FILE 765\n//*     Stephen@Hawaii.Edu                                          *   FILE 765\n//*                                                                 *   FILE 765\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "B64DEC": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\x106\\x01!\\x01!\\x00\\x00\\xe2\\xe3\\xc5\\xe5\\xd6\\xc4\\xd6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T10:36:21", "lines": 289, "newlines": 289, "modlines": 0, "user": "STEVODO"}, "text": "*Process Margins(2,72,1),Nonumber,Optimize(TIME),A,X,Ag,System(MVS);\n /********************************************************************/\n /*                                                                  */\n /*   B64dec                                                         */\n /*   ------------------------------------------------------------   */\n /*   Decode a Base64-encoded string.                                */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*   Usage:                                                         */\n /*     outString = B64dec(inString)                                 */\n /*                                                                  */\n /*   Where:                                                         */\n /*     inString is a Base64-encoded string up to 32756 bytes in     */\n /*     length.  outString will be the Base64-decoded inString.      */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*                                                                  */\n /*   Modification History:                                          */\n /*     20Aug2007 SYO   Initial version                              */\n /*                                                                  */\n /********************************************************************/\n\n1B64dec: Procedure\n         (Rsvd1, Rsvd2, Rsvd3, Rsvd4, Args, EvalBlk@@)\n         Options(Main,Reentrant,NoExecOps) Reorder;\n   Declare\n     Rsvd1                   Pointer,\n     Rsvd2                   Pointer,\n     Rsvd3                   Pointer,\n     Rsvd4                   Pointer,\n     Args                    Fixed Binary(31,0),\n     EvalBlk@@               Pointer,\n\n     ArgIn                   Character(32756) Varying Aligned Init(''),\n\n     Bits24                  Bit(24) Based(Bytes3@),\n     Bytes3                  Character(3) Aligned Initial(' '),\n     Bytes3@                 Pointer Aligned Initial(SysNull),\n     Debug                   Bit(1) Aligned Initial(False),\n     HiVal                   Pointer Aligned Initial(SysNull),\n     I                       Fixed Binary(31,0) Initial(0),\n     J                       Fixed Binary(31,0) Initial(0),\n     ParmOffset              Fixed Binary(31,0) Initial(0),\n     ParmString              Character(1024) Aligned Initial(' '),\n     Pau                     Bit(1) Aligned Initial(False),\n     RC                      Fixed Binary(31,0) Initial(0),\n     RClen                   Fixed Binary(31,0) Initial(0),\n     RCodeData               Character(32756) Varying Aligned Init(''),\n     RCodeLen                Fixed Binary(31,0) Initial(0),\n     VarName                 Character(255) Aligned Initial(' '),\n     VarValue                Character(255) Aligned Initial(' '),\n     WorkArea                Character(4096) Aligned Initial(' '),\n     WorkString              Character(255) Varying Aligned Initial(''),\n\n     InitFunc                Character(8) Aligned Initial(' '),\n     InitParmModName         Character(8) Aligned Initial(' '),\n     InitParmListAddr        Pointer Aligned Initial(SysNull),\n     InitUserFldAddr         Pointer Aligned Initial(SysNull),\n     InitRsvdPtr             Pointer Aligned Initial(SysNull),\n     InitEnvBlkAddr          Pointer Aligned Initial(SysNull),\n     InitRsn                 Fixed Binary(31,0) Initial(0),\n     InitStrgWkAddr          Pointer Aligned Initial(SysNull),\n     InitRC                  Fixed Binary(31,0) Initial(0),\n     InitECTaddr             Pointer Aligned Initial(SysNull),\n\n     RltFunc                 Character(8) Aligned Initial(' '),\n     RltEvalBlk@             Pointer Aligned Initial(SysNull),\n     RltRClen                Fixed Binary(31,0) Initial(0),\n     RltEnvBlk@              Pointer Aligned Initial(SysNull),\n     RltRC                   Fixed Binary(31,0) Initial(0),\n\n     EvalBlk@                Pointer Aligned Initial(SysNull),\n     01 EvalBlk              Based(EvalBlk@),\n       02 EvPad1             Fixed Binary(31,0) Unaligned,\n       02 EvSize             Fixed Binary(31,0) Unaligned,\n       02 EvLen              Fixed Binary(31,0) Unaligned,\n       02 EvPad2             Fixed Binary(31,0) Unaligned,\n       02 EvData             Character(32756),\n\n     01 ShVBlock             Unaligned,\n       02 ShVNext            Fixed Binary(31,0) Initial(0),\n       02 ShVUser            Fixed Binary(31,0) Initial(0),\n       02 ShVCode            Character(1),\n       02 ShVRet             Character(1),\n       02 Filler             Character(2),\n       02 ShVBufL            Fixed Binary(31,0),\n       02 ShVNamA            Pointer,\n       02 ShVNamL            Fixed Binary(31,0),\n       02 ShVValA            Pointer,\n       02 ShVValL            Fixed Binary(31,0),\n\n     Addr                    Builtin,\n     Length                  Builtin,\n     Null                    Builtin,\n     PLIRetC                 Builtin,\n     PLIRetV                 Builtin,\n     Repeat                  Builtin,\n     Substr                  Builtin,\n     SysNull                 Builtin,\n     Translate               Builtin,\n     Trim                    Builtin,\n     Unspec                  Builtin,\n     UpperCase               Builtin,\n     Verify                  Builtin,\n\n     IRXEXC                  Entry\n                             External Options(Assembler,Inter,Retcode),\n     IRXINIT                 Entry\n                             External Options(Assembler,Inter,Retcode),\n     IRXRLT                  Entry\n                             External Options(Assembler,Inter,Retcode)\n   ;\n\n   Declare\n     Sysprint                File Stream Print Output\n   ;\n\n   Declare\n     B64alphabet             Character(65) Static Aligned Initial\n                             (('ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||\n                               'abcdefghijklmnopqrstuvwxyz' ||\n                               '0123456789' ||\n                               '+/=')),\n     False                   Bit(1) Static Aligned Initial('0'B),\n     True                    Bit(1) Static Aligned Initial('1'B)\n   ;\n\n /*===================================================================*/\n /*   Initialization.                                                 */\n /*===================================================================*/\n EvalBlk@ = EvalBlk@@;\n Bytes3@ = Addr(Bytes3);\n Unspec(HiVal) = 'FFFFFFFF'BX;\n\n RC = 0;\n RClen = (EvalBlk.EvSize * 8) - 16;\n RCodeData = 'FAIL 9999';\n RCodeLen = Length(RCodeData);\n\n /* Process the arguments --------------------------------------------*/\n RC = ProcessArgs(Args);\n If (RC \u00ac= 0) Then Go To Quit;\n If (Length(ArgIn) > 32756) Then Do;\n     RcodeData = 'FAIL Input length exceeds maximum 32,756 bytes';\n     RCodeLen = Length(RCodeData);\n     Go To Quit;\n   End;\n\n /* Load address of IRXxxxxx entry points ----------------------------*/\n If (RC = 0) Then\n   Do;\n     Fetch IRXINIT;\n     Fetch IRXEXC;\n     Fetch IRXRLT;\n\n     InitFunc = 'FINDENVB';\n     InitParmModName = '        ';\n     InitParmListAddr = SysNull;\n     InitUserFldAddr = SysNull;\n     InitRsvdPtr = SysNull;\n     InitEnvBlkAddr = SysNull;\n     InitRsn = 0;\n     InitStrgWkAddr = SysNull;\n     InitRC = 0;\n     InitECTaddr = SysNull;\n     Call IRXINIT(InitFunc, InitParmModName, InitParmListAddr,\n          InitUserFldAddr, InitRsvdPtr, InitEnvBlkAddr, InitRsn,\n          InitStrgWkAddr, InitRC, InitECTaddr);\n\n     If (InitRsn \u00ac= 0) Then Do;\n         Put String(RCodeData) Edit\n           ('FAIL IRXINIT RC=',InitRC,' RSN=',InitRsn)\n           (A,P'99999',A,P'99999');\n         RCodeLen = Length(RCodeData);\n         GoTo Quit;\n       End;\n   End  /*  of \"If(RC=0)Then Do\"  */;\n\n /*===================================================================*/\n /*   Decode the input string.                                        */\n /*===================================================================*/\n RCodeData = '';\n Do While(ArgIn \u00ac= '');\n    Bits24 = '000000'BX;\n    Do I = 1 To 4;\n      J = Index(B64alphabet, Substr(ArgIn,I,1)) - 1;\n      If (J \u00ac= 64) Then\n        Substr(Bits24,((I-1)*6)+1,6) = Substr(Unspec(J), 27, 6);\n    End  /*  of \"Do I=1 To 4\"  */;\n    If (Substr(ArgIn, 3, 2) = '==') Then Do;\n        RCodeData = RCodeData || Substr(Bytes3, 1, 1);\n      End  /*  of \"If(XX==)Then Do\"  */;\n    Else If (Substr(ArgIn, 4, 1) = '=') Then Do;\n        RCodeData = RCodeData || Substr(Bytes3, 1, 2);\n      End  /*  of \"If(XXX=)Then Do\"  */;\n    Else Do;\n        RCodeData = RCodeData || Bytes3;\n      End  /*  of \"If(XXXX)Then Do\"  */;\n    If (Length(ArgIn) > 4) Then\n      ArgIn = Substr(ArgIn, 5);\n    Else\n      ArgIn = '';\n End  /*  of \"Do While(ArgIn\u00ac='')\"  */;\n RCodeLen = Length(RCodeData);\n\n /*===================================================================*/\n /*   Clean up and quit.                                              */\n /*===================================================================*/\n /* Set return data in Evaluation Block ------------------------------*/\n Quit:\n   If (RClen < RCodeLen) Then Do;\n       RltFunc = 'GETBLOCK';\n       RltEvalBlk@ = SysNull;\n       RltRClen = ((Trunc(RCodeLen / 8) + 1) * 8) + 16;\n       RltEnvBlk@ = SysNull;\n       RltRC = 0;\n       Call IRXRLT(RltFunc, RltEvalBlk@, RltRClen, RltEnvBlk@, RltRC);\n       EvalBlk@ = RltEvalBlk@;\n     End;\n   Substr(EvalBlk.EvData, 1, RCodeLen) = RCodeData;\n   EvalBlk.EvLen = RCodeLen;\n\n   /* Set R15 --------------------------------------------------------*/\n   Call PliRetC(0);\n\n   /* Quit -----------------------------------------------------------*/\n   Return;\n\n1/*********************************************************************/\n /*                                                                   */\n /*   ProcessArgs                                                     */\n /*   -------------------------------------------------------------   */\n /*   Process the input arguments.                                    */\n /*                                                                   */\n /*********************************************************************/\n\n   ProcessArgs:  Procedure(Args) Options(Reentrant) Reorder\n                 Returns(Fixed Binary(31,0));\n     Declare\n       Args                  Fixed Binary(31,0),\n\n       Arg#                  Fixed Binary(31,0) Initial(0),\n       I                     Fixed Binary(31,0) Initial(0),\n       Pau                   Bit(1) Aligned Initial(False),\n       WorkStr               Character(32756) Varying Aligned Init(''),\n\n       ArgStrPtr             Pointer Aligned Initial(Null),\n       01 ArgStr(255)        Based(ArgStrPtr),\n         02 Ptr              Pointer Unaligned,\n         02 Len              Fixed Binary(31,0) Unaligned,\n       ArgData               Character(255) Based,\n\n       RC                    Fixed Binary(31,0) Initial(0)\n     ;\n\n     ArgStrPtr = Addr(Args);\n\n     Pau = False;\n     Arg# = 0;\n     I = 0;\n     Do While(\u00ac Pau);\n       I = I + 1;\n\n       If (ArgStr(I).Ptr = HiVal) Then\n         Pau = True;\n       Else Do;\n           WorkStr = Substr(ArgStr(I).Ptr->ArgData,1,ArgStr(I).Len);\n\n           Arg# = Arg# + 1;\n           Select (Arg#);\n             When (1)  Do;\n                 ArgIn = WorkStr;\n               End  /*  of \"When(1) Do\"  */;\n             Otherwise Do;\n                 /*---------- 1   5   10   15   20   25 --------------*/\n                 RCodeData = 'FAIL too many arguments';\n                 RCodeLen = Length(RCodeData);\n                 RC = 16;\n                 Pau = True;\n               End  /*  of \"Otherwise Do\"  */;\n           End  /*  of \"Select(Arg#)\"  */;\n         End  /*  of \"If(not-end-of-args)Then...Else Do\"  */;\n     End  /*  of \"Do While(\u00acPau)\"  */;\n\n     Return(RC);\n   End  /*  of procedure \"ProcessArgs\"  */;\n\n\n End  /*  of Procedure \"B64dec\" */;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "B64ENC": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\x10B\\x010\\x010\\x00\\x00\\xe2\\xe3\\xc5\\xe5\\xd6\\xc4\\xd6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T10:42:17", "lines": 304, "newlines": 304, "modlines": 0, "user": "STEVODO"}, "text": "*Process Margins(2,72,1),Nonumber,Optimize(TIME),A,X,Ag,System(MVS);\n /********************************************************************/\n /*                                                                  */\n /*   B64enc                                                         */\n /*   ------------------------------------------------------------   */\n /*   Encode an arbitrary string into Base64 format.                 */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*   Usage:                                                         */\n /*     outString = B64enc(inString)                                 */\n /*                                                                  */\n /*   Where:                                                         */\n /*     inString is an arbitrary string up to 24,567 bytes in        */\n /*     length.  outString will be the Base64-encoded inString.      */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*                                                                  */\n /*   Modification History:                                          */\n /*     20Aug2007 SYO   Initial version                              */\n /*                                                                  */\n /********************************************************************/\n\n1B64enc: Procedure\n         (Rsvd1, Rsvd2, Rsvd3, Rsvd4, Args, EvalBlk@@)\n         Options(Main,Reentrant,NoExecOps) Reorder;\n   Declare\n     Rsvd1                   Pointer,\n     Rsvd2                   Pointer,\n     Rsvd3                   Pointer,\n     Rsvd4                   Pointer,\n     Args                    Fixed Binary(31,0),\n     EvalBlk@@               Pointer,\n\n     ArgIn                   Character(32756) Varying Aligned Init(''),\n\n     Bits24                  Bit(24) Aligned Initial('000000'BX),\n     Debug                   Bit(1) Aligned Initial(False),\n     HiVal                   Pointer Aligned Initial(SysNull),\n     I                       Fixed Binary(31,0) Initial(0),\n     Index4(4)               Fixed Binary(15,0) Initial((4)(0)),\n     ParmOffset              Fixed Binary(31,0) Initial(0),\n     ParmString              Character(1024) Aligned Initial(' '),\n     Pau                     Bit(1) Aligned Initial(False),\n     RC                      Fixed Binary(31,0) Initial(0),\n     RClen                   Fixed Binary(31,0) Initial(0),\n     RCodeData               Character(32756) Varying Aligned Init(''),\n     RCodeLen                Fixed Binary(31,0) Initial(0),\n     VarName                 Character(255) Aligned Initial(' '),\n     VarValue                Character(255) Aligned Initial(' '),\n     WorkArea                Character(4096) Aligned Initial(' '),\n     WorkString              Character(255) Varying Aligned Initial(''),\n\n     InitFunc                Character(8) Aligned Initial(' '),\n     InitParmModName         Character(8) Aligned Initial(' '),\n     InitParmListAddr        Pointer Aligned Initial(SysNull),\n     InitUserFldAddr         Pointer Aligned Initial(SysNull),\n     InitRsvdPtr             Pointer Aligned Initial(SysNull),\n     InitEnvBlkAddr          Pointer Aligned Initial(SysNull),\n     InitRsn                 Fixed Binary(31,0) Initial(0),\n     InitStrgWkAddr          Pointer Aligned Initial(SysNull),\n     InitRC                  Fixed Binary(31,0) Initial(0),\n     InitECTaddr             Pointer Aligned Initial(SysNull),\n\n     RltFunc                 Character(8) Aligned Initial(' '),\n     RltEvalBlk@             Pointer Aligned Initial(SysNull),\n     RltRClen                Fixed Binary(31,0) Initial(0),\n     RltEnvBlk@              Pointer Aligned Initial(SysNull),\n     RltRC                   Fixed Binary(31,0) Initial(0),\n\n     EvalBlk@                Pointer Aligned Initial(SysNull),\n     01 EvalBlk              Based(EvalBlk@),\n       02 EvPad1             Fixed Binary(31,0) Unaligned,\n       02 EvSize             Fixed Binary(31,0) Unaligned,\n       02 EvLen              Fixed Binary(31,0) Unaligned,\n       02 EvPad2             Fixed Binary(31,0) Unaligned,\n       02 EvData             Character(32756),\n\n     01 ShVBlock             Unaligned,\n       02 ShVNext            Fixed Binary(31,0) Initial(0),\n       02 ShVUser            Fixed Binary(31,0) Initial(0),\n       02 ShVCode            Character(1),\n       02 ShVRet             Character(1),\n       02 Filler             Character(2),\n       02 ShVBufL            Fixed Binary(31,0),\n       02 ShVNamA            Pointer,\n       02 ShVNamL            Fixed Binary(31,0),\n       02 ShVValA            Pointer,\n       02 ShVValL            Fixed Binary(31,0),\n\n     Addr                    Builtin,\n     Length                  Builtin,\n     Null                    Builtin,\n     PLIRetC                 Builtin,\n     PLIRetV                 Builtin,\n     Repeat                  Builtin,\n     Substr                  Builtin,\n     SysNull                 Builtin,\n     Translate               Builtin,\n     Trim                    Builtin,\n     Unspec                  Builtin,\n     UpperCase               Builtin,\n     Verify                  Builtin,\n\n     IRXEXC                  Entry\n                             External Options(Assembler,Inter,Retcode),\n     IRXINIT                 Entry\n                             External Options(Assembler,Inter,Retcode),\n     IRXRLT                  Entry\n                             External Options(Assembler,Inter,Retcode)\n   ;\n\n   Declare\n     Sysprint                File Stream Print Output\n   ;\n\n   Declare\n     B64alphabet             Character(65) Static Aligned Initial\n                             (('ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||\n                               'abcdefghijklmnopqrstuvwxyz' ||\n                               '0123456789' ||\n                               '+/=')),\n     False                   Bit(1) Static Aligned Initial('0'B),\n     True                    Bit(1) Static Aligned Initial('1'B)\n   ;\n\n /*===================================================================*/\n /*   Initialization.                                                 */\n /*===================================================================*/\n EvalBlk@ = EvalBlk@@;\n Unspec(HiVal) = 'FFFFFFFF'BX;\n\n RC = 0;\n RClen = (EvalBlk.EvSize * 8) - 16;\n RCodeData = 'FAIL 9999';\n RCodeLen = Length(RCodeData);\n\n /* Process the arguments --------------------------------------------*/\n RC = ProcessArgs(Args);\n If (RC \u00ac= 0) Then Go To Quit;\n If (Length(ArgIn) > 24566) Then Do;\n     RcodeData = 'FAIL Input length exceeds maximum 24,566 bytes';\n     RCodeLen = Length(RCodeData);\n     Go To Quit;\n   End;\n\n /* Load address of IRXxxxxx entry points ----------------------------*/\n If (RC = 0) Then\n   Do;\n     Fetch IRXINIT;\n     Fetch IRXEXC;\n     Fetch IRXRLT;\n\n     InitFunc = 'FINDENVB';\n     InitParmModName = '        ';\n     InitParmListAddr = SysNull;\n     InitUserFldAddr = SysNull;\n     InitRsvdPtr = SysNull;\n     InitEnvBlkAddr = SysNull;\n     InitRsn = 0;\n     InitStrgWkAddr = SysNull;\n     InitRC = 0;\n     InitECTaddr = SysNull;\n     Call IRXINIT(InitFunc, InitParmModName, InitParmListAddr,\n          InitUserFldAddr, InitRsvdPtr, InitEnvBlkAddr, InitRsn,\n          InitStrgWkAddr, InitRC, InitECTaddr);\n\n     If (InitRsn \u00ac= 0) Then Do;\n         Put String(RCodeData) Edit\n           ('FAIL IRXINIT RC=',InitRC,' RSN=',InitRsn)\n           (A,P'99999',A,P'99999');\n         RCodeLen = Length(RCodeData);\n         GoTo Quit;\n       End;\n   End  /*  of \"If(RC=0)Then Do\"  */;\n\n /*===================================================================*/\n /*   Encode the input string.                                        */\n /*===================================================================*/\n RCodeData = '';\n Do While(ArgIn \u00ac= '');\n   /* Extract the next 3 input characters ----------------------------*/\n   Bits24 = '000000'BX;\n   Select(Length(ArgIn));\n     When (1) Do;\n         Substr(Bits24,1,8) = Unspec(Substr(ArgIn,1,1));\n         ArgIn = '';\n         Unspec(Index4(1)) = '00'BX || '00'B || Substr(Bits24,1,6);\n         Unspec(Index4(2)) = '00'BX || '00'B || Substr(Bits24,7,6);\n         Index4(3) = 64;\n         Index4(4) = 64;\n       End;\n     When (2) Do;\n         Substr(Bits24,1,16) = UnSpec(Substr(ArgIn,1,2));\n         ArgIn = '';\n         Unspec(Index4(1)) = '00'BX || '00'B || Substr(Bits24,1,6);\n         Unspec(Index4(2)) = '00'BX || '00'B || Substr(Bits24,7,6);\n         Unspec(Index4(3)) = '00'BX || '00'B || Substr(Bits24,13,6);\n         Index4(4) = 64;\n       End;\n     Otherwise Do;\n         Bits24 = Unspec(Substr(ArgIn,1,3));\n         If (Length(ArgIn) \u00ac= 3) Then\n           ArgIn = Substr(ArgIn, 4);\n         Else\n           ArgIn = '';\n         Unspec(Index4(1)) = '00'BX || '00'B || Substr(Bits24,1,6);\n         Unspec(Index4(2)) = '00'BX || '00'B || Substr(Bits24,7,6);\n         Unspec(Index4(3)) = '00'BX || '00'B || Substr(Bits24,13,6);\n         Unspec(Index4(4)) = '00'BX || '00'B || Substr(Bits24,19,6);\n       End;\n   End  /*  of \"Select\"  */;\n\n   /* Output as 4 bytes ----------------------------------------------*/\n   Do I = 1 To 4;\n     RCodeData = RCodeData ||\n                 Substr(B64alphabet, Index4(I)+1, 1);\n   End;\n End  /*  of \"Do While(ArgIn\u00ac='')\"  */;\n RCodeLen = Length(RCodeData);\n\n /*===================================================================*/\n /*   Clean up and quit.                                              */\n /*===================================================================*/\n /* Set return data in Evaluation Block ------------------------------*/\n Quit:\n   If (RClen < RCodeLen) Then Do;\n       RltFunc = 'GETBLOCK';\n       RltEvalBlk@ = SysNull;\n       RltRClen = ((Trunc(RCodeLen / 8) + 1) * 8) + 16;\n       RltEnvBlk@ = SysNull;\n       RltRC = 0;\n       Call IRXRLT(RltFunc, RltEvalBlk@, RltRClen, RltEnvBlk@, RltRC);\n       EvalBlk@ = RltEvalBlk@;\n     End;\n   Substr(EvalBlk.EvData, 1, RCodeLen) = RCodeData;\n   EvalBlk.EvLen = RCodeLen;\n\n   /* Set R15 --------------------------------------------------------*/\n   Call PliRetC(0);\n\n   /* Quit -----------------------------------------------------------*/\n   Return;\n\n1/*********************************************************************/\n /*                                                                   */\n /*   ProcessArgs                                                     */\n /*   -------------------------------------------------------------   */\n /*   Process the input arguments.                                    */\n /*                                                                   */\n /*********************************************************************/\n\n   ProcessArgs:  Procedure(Args) Options(Reentrant) Reorder\n                 Returns(Fixed Binary(31,0));\n     Declare\n       Args                  Fixed Binary(31,0),\n\n       Arg#                  Fixed Binary(31,0) Initial(0),\n       I                     Fixed Binary(31,0) Initial(0),\n       Pau                   Bit(1) Aligned Initial(False),\n       WorkStr               Character(32756) Varying Aligned Init(''),\n\n       ArgStrPtr             Pointer Aligned Initial(Null),\n       01 ArgStr(255)        Based(ArgStrPtr),\n         02 Ptr              Pointer Unaligned,\n         02 Len              Fixed Binary(31,0) Unaligned,\n       ArgData               Character(255) Based,\n\n       RC                    Fixed Binary(31,0) Initial(0)\n     ;\n\n     ArgStrPtr = Addr(Args);\n\n     Pau = False;\n     Arg# = 0;\n     I = 0;\n     Do While(\u00ac Pau);\n       I = I + 1;\n\n       If (ArgStr(I).Ptr = HiVal) Then\n         Pau = True;\n       Else Do;\n           WorkStr = Substr(ArgStr(I).Ptr->ArgData,1,ArgStr(I).Len);\n\n           Arg# = Arg# + 1;\n           Select (Arg#);\n             When (1)  Do;\n                 ArgIn = WorkStr;\n               End  /*  of \"When(1) Do\"  */;\n             Otherwise Do;\n                 /*---------- 1   5   10   15   20   25 --------------*/\n                 RCodeData = 'FAIL too many arguments';\n                 RCodeLen = Length(RCodeData);\n                 RC = 16;\n                 Pau = True;\n               End  /*  of \"Otherwise Do\"  */;\n           End  /*  of \"Select(Arg#)\"  */;\n         End  /*  of \"If(not-end-of-args)Then...Else Do\"  */;\n     End  /*  of \"Do While(\u00acPau)\"  */;\n\n     Return(RC);\n   End  /*  of procedure \"ProcessArgs\"  */;\n\n\n End  /*  of Procedure \"B64enc\" */;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEEDTOK": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\x10B\\x01(\\x01(\\x00\\x00\\xe2\\xe3\\xc5\\xe5\\xd6\\xc4\\xd6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T10:42:56", "lines": 296, "newlines": 296, "modlines": 0, "user": "STEVODO"}, "text": "*Process Margins(2,72,1),Nonumber,Optimize(TIME),A,X,Ag,System(MVS);\n /********************************************************************/\n /*                                                                  */\n /*   NeedTok                                                        */\n /*   ------------------------------------------------------------   */\n /*   Check a Security Token                                         */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*   Usage:                                                         */\n /*     rc = NeedTok(RACFid)                                         */\n /*                                                                  */\n /*     Where                                                        */\n /*       RACFid is a valid RACF ID.                                 */\n /*       If the RACF user is required to use a token to login       */\n /*       rc = \"OK Y\".  If the RACF user is not required to use      */\n /*       a token to login, rc = \"OK N\".  If an internal error       */\n /*       occured, rc will start with \"FAIL\".                        */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*                                                                  */\n /*   Modification History:                                          */\n /*     30Jul2007 SYO   Initial version                              */\n /*                                                                  */\n /********************************************************************/\n\n1NeedTok: Procedure\n          (Rsvd1, Rsvd2, Rsvd3, Rsvd4, Args, EvalBlk@)\n          Options(Main,Reentrant,NoExecOps) Reorder;\n   Declare\n     Rsvd1                   Pointer,\n     Rsvd2                   Pointer,\n     Rsvd3                   Pointer,\n     Rsvd4                   Pointer,\n     Args                    Fixed Binary(31,0),\n     EvalBlk@                Pointer,\n\n     ArgUserID               Character(255) Varying Aligned Initial(''),\n\n     Debug                   Bit(1) Aligned Initial(False),\n     HiVal                   Pointer Aligned Initial(SysNull),\n     I                       Fixed Binary(31,0) Initial(0),\n     ParmOffset              Fixed Binary(31,0) Initial(0),\n     ParmString              Character(1024) Aligned Initial(' '),\n     Pau                     Bit(1) Aligned Initial(False),\n     RC                      Fixed Binary(31,0) Initial(0),\n     RClen                   Fixed Binary(31,0) Initial(0),\n     RCodeData               Character(255) Aligned Initial(' '),\n     RCodeLen                Fixed Binary(31,0) Initial(0),\n     VarName                 Character(255) Aligned Initial(' '),\n     VarValue                Character(255) Aligned Initial(' '),\n     WorkArea                Character(4096) Aligned Initial(' '),\n     WorkString              Character(255) Varying Aligned Initial(''),\n\n     InitFunc                Character(8) Aligned Initial(' '),\n     InitParmModName         Character(8) Aligned Initial(' '),\n     InitParmListAddr        Pointer Aligned Initial(SysNull),\n     InitUserFldAddr         Pointer Aligned Initial(SysNull),\n     InitRsvdPtr             Pointer Aligned Initial(SysNull),\n     InitEnvBlkAddr          Pointer Aligned Initial(SysNull),\n     InitRsn                 Fixed Binary(31,0) Initial(0),\n     InitStrgWkAddr          Pointer Aligned Initial(SysNull),\n     InitRC                  Fixed Binary(31,0) Initial(0),\n     InitECTaddr             Pointer Aligned Initial(SysNull),\n\n     01 EvalBlk              Based(EvalBlk@),\n       02 EvPad1             Fixed Binary(31,0) Unaligned,\n       02 EvSize             Fixed Binary(31,0) Unaligned,\n       02 EvLen              Fixed Binary(31,0) Unaligned,\n       02 EvPad2             Fixed Binary(31,0) Unaligned,\n       02 EvData             Character(255),\n\n     01 ShVBlock             Unaligned,\n       02 ShVNext            Fixed Binary(31,0) Initial(0),\n       02 ShVUser            Fixed Binary(31,0) Initial(0),\n       02 ShVCode            Character(1),\n       02 ShVRet             Character(1),\n       02 Filler             Character(2),\n       02 ShVBufL            Fixed Binary(31,0),\n       02 ShVNamA            Pointer,\n       02 ShVNamL            Fixed Binary(31,0),\n       02 ShVValA            Pointer,\n       02 ShVValL            Fixed Binary(31,0),\n\n     Addr                    Builtin,\n     Length                  Builtin,\n     Null                    Builtin,\n     PLIRetC                 Builtin,\n     PLIRetV                 Builtin,\n     Repeat                  Builtin,\n     Substr                  Builtin,\n     SysNull                 Builtin,\n     Translate               Builtin,\n     Trim                    Builtin,\n     Unspec                  Builtin,\n     UpperCase               Builtin,\n     Verify                  Builtin,\n\n     IRXEXC                  Entry\n                             External Options(Assembler,Inter,Retcode),\n\n     IRXINIT                 Entry\n                             External Options(Assembler,Inter,Retcode),\n\n     SEXMITOS                Entry\n                             External Options(Assembler,Inter,Retcode)\n   ;\n\n   Declare\n     Sysprint                File Stream Print Output\n   ;\n\n   Declare\n     Digits                  Character(10) Static Aligned\n                             Initial('0123456789'),\n     False                   Bit(1) Static Aligned Initial('0'B),\n     True                    Bit(1) Static Aligned Initial('1'B)\n   ;\n\n /*===================================================================*/\n /*   Initialization.                                                 */\n /*===================================================================*/\n Unspec(HiVal) = 'FFFFFFFF'BX;\n\n RC = 0;\n RClen = (EvalBlk.EvSize * 8) - 16;\n RCodeData = 'FAIL 9999';\n RCodeLen = 9;\n\n /* Process the arguments --------------------------------------------*/\n RC = ProcessArgs(Args);\n\n /* Load address of IRXxxxxx entry points ----------------------------*/\n If (RC = 0) Then\n   Do;\n     Fetch IRXINIT;\n     Fetch IRXEXC;\n\n     InitFunc = 'FINDENVB';\n     InitParmModName = '        ';\n     InitParmListAddr = SysNull;\n     InitUserFldAddr = SysNull;\n     InitRsvdPtr = SysNull;\n     InitEnvBlkAddr = SysNull;\n     InitRsn = 0;\n     InitStrgWkAddr = SysNull;\n     InitRC = 0;\n     InitECTaddr = SysNull;\n     Call IRXINIT(InitFunc, InitParmModName, InitParmListAddr,\n          InitUserFldAddr, InitRsvdPtr, InitEnvBlkAddr, InitRsn,\n          InitStrgWkAddr, InitRC, InitECTaddr);\n\n     If (InitRsn \u00ac= 0) Then Do;\n         RCodeData = ' ';\n         Put String(RCodeData) Edit\n           ('FAIL IRXINIT RC=',InitRC,' RSN=',InitRsn)\n           (A,P'99999',A,P'99999');\n         RCodeLen = 32;\n         RC = 16;\n         GoTo Quit;\n       End;\n   End  /*  of \"If(RC=0)Then Do\"  */;\n\n /*===================================================================*/\n /*   Process the request.                                            */\n /*===================================================================*/\n /* Got an ID? -------------------------------------------------------*/\n   If (ArgUserID = '') Then Do;\n       /*---------- 1   5   10   15   20   25 ----------*/\n       RCodeData = 'FAIL Null RACF ID is invalid';\n       RCodeLen = 28;\n       RC = 16;\n       GoTo Quit;\n     End /* of \"If(token-null)Then Do\"  */;\n\n /* See if the user is required to have a token ----------------------*/\n   WorkString = 'FUNCTION=REQUEST' ||\n                ',USERID=' || ArgUserID ||\n                ',XMSID=XMS1,APPL=NEEDTOK,TERMID=' ||\n                ArgUserID || ',RETAREA=';\n\n   ParmOffset = Length(WorkString);\n\n   ParmString = WorkString || Repeat(' ',63) || ';';\n\n   Call SEXMITOS(ParmString, WorkArea);\n   RC = PliRetV();\n\n   Select (Substr(ParmString,ParmOffset+1,4));\n     When ('3599') Do;   /* Token required ---------------------------*/\n         /*---------- 1   5   10   15   20   25   30   35 ------------*/\n         RCodeData = 'OK Y CKSE' || Substr(ParmString,ParmOffset+1,4);\n         RCodeLen = 13;\n         RC = 16;\n         GoTo Quit;\n       End;\n     When ('3600') Do;   /* Token & Password required ----------------*/\n         /*---------- 1   5   10   15   20   25   30   35 ------------*/\n         RCodeData = 'OK Y CKSE' || Substr(ParmString,ParmOffset+1,4);\n         RCodeLen = 13;\n         RC = 16;\n         GoTo Quit;\n       End;\n     Otherwise Do;\n         /*---------- 1   5   10   15   20   25   30   35 ------------*/\n         RCodeData = 'OK N CKSE' || Substr(ParmString,ParmOffset+1,4);\n         RCodeLen = 13;\n         RC = 16;\n         GoTo Quit;\n       End;\n   End  /*  of \"Select(rc)\"  */;\n\n /*===================================================================*/\n /*   Clean up and quit.                                              */\n /*===================================================================*/\n /* Set return code in Evaluation Block ------------------------------*/\n Quit:\n   If (RClen > RCodeLen) Then Do;\n       EvalBlk.EvData = Substr(RCodeData, 1, RCodeLen);\n       EvalBlk.EvLen = RCodeLen;\n     End  /*  of \"If(RClen>RCodeLen)Then Do\"  */;\n   Else Do;\n       EvalBlk.EvData = '-1';\n       EvalBlk.EvLen = 2;\n     End;\n\n   /* Set R15 --------------------------------------------------------*/\n   Call PliRetC(0);\n\n   /* Quit -----------------------------------------------------------*/\n   Return;\n\n1/*********************************************************************/\n /*                                                                   */\n /*   ProcessArgs                                                     */\n /*   -------------------------------------------------------------   */\n /*   Process the input arguments.                                    */\n /*                                                                   */\n /*********************************************************************/\n\n   ProcessArgs:  Procedure(Args) Options(Reentrant) Reorder\n                 Returns(Fixed Binary(31,0));\n     Declare\n       Args                  Fixed Binary(31,0),\n\n       Arg#                  Fixed Binary(31,0) Initial(0),\n       I                     Fixed Binary(31,0) Initial(0),\n       Pau                   Bit(1) Aligned Initial(False),\n       WorkStr               Character(255) Varying Aligned Initial(''),\n\n       ArgStrPtr             Pointer Aligned Initial(Null),\n       01 ArgStr(255)        Based(ArgStrPtr),\n         02 Ptr              Pointer Unaligned,\n         02 Len              Fixed Binary(31,0) Unaligned,\n       ArgData               Character(255) Based,\n\n       RC                    Fixed Binary(31,0) Initial(0)\n     ;\n\n     ArgStrPtr = Addr(Args);\n\n     Pau = False;\n     Arg# = 0;\n     I = 0;\n     Do While(\u00ac Pau);\n       I = I + 1;\n\n       If (ArgStr(I).Ptr = HiVal) Then\n         Pau = True;\n       Else Do;\n           WorkStr = Substr(ArgStr(I).Ptr->ArgData,1,ArgStr(I).Len);\n\n           Arg# = Arg# + 1;\n           Select (Arg#);\n             When (1)  Do;\n                 If (Substr(WorkStr, 1, 1) = '*') Then Do;\n                     Debug = True;\n                     WorkStr = Substr(WorkStr, 2);\n                   End;\n                 ArgUserID = UpperCase(WorkStr);\n               End  /*  of \"When(1) Do\"  */;\n             Otherwise Do;\n                 /*---------- 1   5   10   15   20   25 --------------*/\n                 RCodeData = 'FAIL too many arguments';\n                 RCodeLen = 23;\n                 RC = 16;\n                 Pau = True;\n               End  /*  of \"Otherwise Do\"  */;\n           End  /*  of \"Select(Arg#)\"  */;\n         End  /*  of \"If(not-end-of-args)Then...Else Do\"  */;\n     End  /*  of \"Do While(\u00acPau)\"  */;\n\n     Return(RC);\n   End  /*  of procedure \"ProcessArgs\"  */;\n\n\n End  /*  of Procedure \"NeedTok\" */;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACAUTH": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\x10C\\x01A\\x01A\\x00\\x00\\xe2\\xe3\\xc5\\xe5\\xd6\\xc4\\xd6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T10:43:43", "lines": 321, "newlines": 321, "modlines": 0, "user": "STEVODO"}, "text": "*Process Margins(2,72,1),Nonumber,Optimize(TIME),A,X,Ag,System(MVS);\n /********************************************************************/\n /*                                                                  */\n /*   RACauth                                                        */\n /*   ------------------------------------------------------------   */\n /*   Authenticate a user against RACF via NC-PASS                   */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*   Usage:                                                         */\n /*     rc = RACauth(RACFid, Password, NewPassword, Token)           */\n /*                                                                  */\n /*     Where                                                        */\n /*     - RACFid and Password are the RACF ID and password we are    */\n /*       attempting to authenticate.                                */\n /*     - NewPassword is a new password.  Supplied only if changing  */\n /*       the RACF ID's password.                                    */\n /*     - Token is the value currently displayed on the security     */\n /*       token associated with this RACF ID                         */\n /*                                                                  */\n /*   ------------------------------------------------------------   */\n /*                                                                  */\n /*   Modification History:                                          */\n /*     29Jun2007 SYO   Initial version                              */\n /*                                                                  */\n /********************************************************************/\n\n1RACauth: Procedure\n          (Rsvd1, Rsvd2, Rsvd3, Rsvd4, Args, EvalBlk@)\n          Options(Main,Reentrant,NoExecOps) Reorder;\n   Declare\n     Rsvd1                   Pointer,\n     Rsvd2                   Pointer,\n     Rsvd3                   Pointer,\n     Rsvd4                   Pointer,\n     Args                    Fixed Binary(31,0),\n     EvalBlk@                Pointer,\n\n     ArgUserID               Character(255) Varying Aligned Initial(''),\n     ArgPassword             Character(255) Varying Aligned Initial(''),\n     ArgNewPassword          Character(255) Varying Aligned Initial(''),\n     ArgToken                Character(255) Varying Aligned Initial(''),\n\n     Debug                   Bit(1) Aligned Initial(False),\n     HiVal                   Pointer Aligned Initial(SysNull),\n     I                       Fixed Binary(31,0) Initial(0),\n     ParmOffset              Fixed Binary(31,0) Initial(0),\n     ParmString              Character(1024) Aligned Initial(' '),\n     Pau                     Bit(1) Aligned Initial(False),\n     RC                      Fixed Binary(31,0) Initial(0),\n     RClen                   Fixed Binary(31,0) Initial(0),\n     RCodeData               Character(255) Aligned Initial(' '),\n     RCodeLen                Fixed Binary(31,0) Initial(0),\n     VarName                 Character(255) Aligned Initial(' '),\n     VarValue                Character(255) Aligned Initial(' '),\n     WorkArea                Character(4096) Aligned Initial(' '),\n     WorkString              Character(255) Varying Aligned Initial(''),\n\n     InitFunc                Character(8) Aligned Initial(' '),\n     InitParmModName         Character(8) Aligned Initial(' '),\n     InitParmListAddr        Pointer Aligned Initial(SysNull),\n     InitUserFldAddr         Pointer Aligned Initial(SysNull),\n     InitRsvdPtr             Pointer Aligned Initial(SysNull),\n     InitEnvBlkAddr          Pointer Aligned Initial(SysNull),\n     InitRsn                 Fixed Binary(31,0) Initial(0),\n     InitStrgWkAddr          Pointer Aligned Initial(SysNull),\n     InitRC                  Fixed Binary(31,0) Initial(0),\n     InitECTaddr             Pointer Aligned Initial(SysNull),\n\n     01 EvalBlk              Based(EvalBlk@),\n       02 EvPad1             Fixed Binary(31,0) Unaligned,\n       02 EvSize             Fixed Binary(31,0) Unaligned,\n       02 EvLen              Fixed Binary(31,0) Unaligned,\n       02 EvPad2             Fixed Binary(31,0) Unaligned,\n       02 EvData             Character(255),\n\n     01 ShVBlock             Unaligned,\n       02 ShVNext            Fixed Binary(31,0) Initial(0),\n       02 ShVUser            Fixed Binary(31,0) Initial(0),\n       02 ShVCode            Character(1),\n       02 ShVRet             Character(1),\n       02 Filler             Character(2),\n       02 ShVBufL            Fixed Binary(31,0),\n       02 ShVNamA            Pointer,\n       02 ShVNamL            Fixed Binary(31,0),\n       02 ShVValA            Pointer,\n       02 ShVValL            Fixed Binary(31,0),\n\n     Addr                    Builtin,\n     Length                  Builtin,\n     Null                    Builtin,\n     PLIRetC                 Builtin,\n     PLIRetV                 Builtin,\n     Repeat                  Builtin,\n     Substr                  Builtin,\n     SysNull                 Builtin,\n     Translate               Builtin,\n     Trim                    Builtin,\n     Unspec                  Builtin,\n     UpperCase               Builtin,\n     Verify                  Builtin,\n\n     IRXEXC                  Entry\n                             External Options(Assembler,Inter,Retcode),\n\n     IRXINIT                 Entry\n                             External Options(Assembler,Inter,Retcode),\n\n     SEXMITOS                Entry\n                             External Options(Assembler,Inter,Retcode)\n   ;\n\n   Declare\n     Sysprint                File Stream Print Output\n   ;\n\n   Declare\n     Digits                  Character(10) Static Aligned\n                             Initial('0123456789'),\n     False                   Bit(1) Static Aligned Initial('0'B),\n     True                    Bit(1) Static Aligned Initial('1'B)\n   ;\n\n /*===================================================================*/\n /*   Initialization.                                                 */\n /*===================================================================*/\n Unspec(HiVal) = 'FFFFFFFF'BX;\n\n RC = 0;\n RClen = (EvalBlk.EvSize * 8) - 16;\n RCodeData = 'FAIL 9999';\n RCodeLen = 9;\n\n /* Process the arguments --------------------------------------------*/\n RC = ProcessArgs(Args);\n\n /* Load address of IRXxxxxx entry points ----------------------------*/\n If (RC = 0) Then\n   Do;\n     Fetch IRXINIT;\n     Fetch IRXEXC;\n\n     InitFunc = 'FINDENVB';\n     InitParmModName = '        ';\n     InitParmListAddr = SysNull;\n     InitUserFldAddr = SysNull;\n     InitRsvdPtr = SysNull;\n     InitEnvBlkAddr = SysNull;\n     InitRsn = 0;\n     InitStrgWkAddr = SysNull;\n     InitRC = 0;\n     InitECTaddr = SysNull;\n     Call IRXINIT(InitFunc, InitParmModName, InitParmListAddr,\n          InitUserFldAddr, InitRsvdPtr, InitEnvBlkAddr, InitRsn,\n          InitStrgWkAddr, InitRC, InitECTaddr);\n\n     If (InitRsn \u00ac= 0) Then Do;\n         RCodeData = ' ';\n         Put String(RCodeData) Edit\n           ('FAIL IRXINIT RC=',InitRC,' RSN=',InitRsn)\n           (A,P'99999',A,P'99999');\n         RCodeLen = 32;\n         RC = 16;\n         GoTo Quit;\n       End;\n   End  /*  of \"If(RC=0)Then Do\"  */;\n\n /*===================================================================*/\n /*   Process the request.                                            */\n /*===================================================================*/\n /* Do some sanity checks --------------------------------------------*/\n   If (ArgUserID = '') Then Do;\n       /*---------- 1   5   10   15   20   25 ----------*/\n       RCodeData = 'FAIL Null RACF ID is invalid';\n       RCodeLen = 28;\n       RC = 16;\n       GoTo Quit;\n     End /* of \"If(token-null)Then Do\"  */;\n\n /* Authenticate the user --------------------------------------------*/\n   WorkString = 'FUNCTION=LOGON' ||\n                ',USERID=' || ArgUserID ||\n                ',PASSWORD=' || ArgPassword;\n   If (ArgToken \u00ac= '') Then Do;\n       WorkString = WorkString ||\n                ',PRN=' || ArgToken;\n     End  /*  of \"If(ArgToken\u00ac='')Then Do\"  */;\n   If (ArgNewPassword \u00ac= '') Then Do;\n       WorkString = WorkString ||\n                ',NEWPASS=' || ArgNewPassword;\n     End  /*  of \"If(ArgNewPassword\u00ac='')Then Do\"  */;\n   WorkString = WorkString ||\n                ',XMSID=XMS1,APPL=RACAUTH,TERMID=' ||\n                ArgUserID || ',RETAREA=';\n\n   ParmOffset = Length(WorkString);\n\n   ParmString = WorkString || Repeat(' ',63) || ';';\n\n   Call SEXMITOS(ParmString, WorkArea);\n   RC = PliRetV();\n\n   If (Substr(ParmString, ParmOffset+1, 4) = '0000') Then Do;\n       Put String(RCodeData) Edit\n         ('OK ', RC, ' ', Substr(ParmString,ParmOffset+1,4))\n         (A,P'9999',A,A);\n       RCodeLen = 3 + 4 + 1 + 4;\n       RC = 0;\n     End  /*  of \"If(RC=0)Then Do\"  */;\n   Else Do;\n       Put String(RCodeData) Edit\n         ('FAIL ', RC, ' ', Substr(ParmString,ParmOffset+1,4))\n         (A,P'9999',A,A);\n       RCodeLen = 5 + 4 + 1 + 4;\n       RC = 16;\n     End  /*  of \"If(RC=0)Then...Else Do\"  */;\n\n /*===================================================================*/\n /*   Clean up and quit.                                              */\n /*===================================================================*/\n /* Set return code in Evaluation Block ------------------------------*/\n Quit:\n   If (RClen > RCodeLen) Then Do;\n       EvalBlk.EvData = Substr(RCodeData, 1, RCodeLen);\n       EvalBlk.EvLen = RCodeLen;\n     End  /*  of \"If(RClen>RCodeLen)Then Do\"  */;\n   Else Do;\n       EvalBlk.EvData = '-1';\n       EvalBlk.EvLen = 2;\n     End;\n\n   /* Set R15 --------------------------------------------------------*/\n   Call PliRetC(0);\n\n   /* Quit -----------------------------------------------------------*/\n   Return;\n\n1/*********************************************************************/\n /*                                                                   */\n /*   ProcessArgs                                                     */\n /*   -------------------------------------------------------------   */\n /*   Process the input arguments.                                    */\n /*                                                                   */\n /*********************************************************************/\n\n   ProcessArgs:  Procedure(Args) Options(Reentrant) Reorder\n                 Returns(Fixed Binary(31,0));\n     Declare\n       Args                  Fixed Binary(31,0),\n\n       Arg#                  Fixed Binary(31,0) Initial(0),\n       I                     Fixed Binary(31,0) Initial(0),\n       Pau                   Bit(1) Aligned Initial(False),\n       WorkStr               Character(255) Varying Aligned Initial(''),\n\n       ArgStrPtr             Pointer Aligned Initial(Null),\n       01 ArgStr(255)        Based(ArgStrPtr),\n         02 Ptr              Pointer Unaligned,\n         02 Len              Fixed Binary(31,0) Unaligned,\n       ArgData               Character(255) Based,\n\n       RC                    Fixed Binary(31,0) Initial(0)\n     ;\n\n     ArgStrPtr = Addr(Args);\n\n     Pau = False;\n     Arg# = 0;\n     I = 0;\n     Do While(\u00ac Pau);\n       I = I + 1;\n\n       If (ArgStr(I).Ptr = HiVal) Then\n         Pau = True;\n       Else Do;\n           WorkStr = Substr(ArgStr(I).Ptr->ArgData,1,ArgStr(I).Len);\n\n           Arg# = Arg# + 1;\n           Select (Arg#);\n             When (1)  Do;\n                 If (Substr(WorkStr, 1, 1) = '*') Then Do;\n                     Debug = True;\n                     WorkStr = Substr(WorkStr, 2);\n                   End;\n                 ArgUserID = UpperCase(WorkStr);\n               End  /*  of \"When(1) Do\"  */;\n             When (2)  Do;\n                 ArgPassword = WorkStr;\n                 /* don't UPPERCASE after move to z/OS 1.7 */\n                 ArgPassword = UpperCase(ArgPassword);\n               End  /*  of \"When(2) Do\"  */;\n             When (3)  Do;\n                 ArgNewPassword = WorkStr;\n                 /* don't UPPERCASE after move to z/OS 1.7 */\n                 ArgNewPassword = UpperCase(ArgNewPassword);\n               End  /*  of \"When(3) Do\"  */;\n             When (4)  Do;\n                 ArgToken = WorkStr;\n                 If (Verify(ArgToken, Digits) \u00ac= 0) Then Do;\n                     /*---------- 1   5   10   15   20   25 ----------*/\n                     RCodeData = 'FAIL Token not numeric';\n                     RCodeLen = 22;\n                     RC = 16;\n                     Pau = True;\n                   End /* of \"If(token-not-numeric)Then Do\"  */;\n               End  /*  of \"When(4) Do\"  */;\n             Otherwise Do;\n                 /*---------- 1   5   10   15   20   25 --------------*/\n                 RCodeData = 'FAIL too many arguments';\n                 RCodeLen = 23;\n                 RC = 16;\n                 Pau = True;\n               End  /*  of \"Otherwise Do\"  */;\n           End  /*  of \"Select(Arg#)\"  */;\n         End  /*  of \"If(not-end-of-args)Then...Else Do\"  */;\n     End  /*  of \"Do While(\u00acPau)\"  */;\n\n     Return(RC);\n   End  /*  of procedure \"ProcessArgs\"  */;\n\n\n End  /*  of Procedure \"RACauth\" */;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFAUTH": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x07$\\x1f\\x01\\x07&\\x1f \"\\x01\\xc0\\x03\\x10\\x00\\x00\\xe2\\xe3\\xc5\\xd7\\xc8\\xc5\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-09-18T20:22:03", "lines": 448, "newlines": 784, "modlines": 0, "user": "STEPHEN"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SCREENSH": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07$\\x1f\\x01\\x07$\\x1f\\t\\x18\\x05{\\x05{\\x00\\x00\\xd1\\xd7\\xc7@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-29T00:00:00", "modifydate": "2007-08-29T09:18:00", "lines": 1403, "newlines": 1403, "modlines": 0, "user": "JPG"}, "mimetype": "image/jpeg", "datatype": "binary", "extension": ".jpg"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT765/FILE765.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT765", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}