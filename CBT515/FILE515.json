{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012239000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE515.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE515.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0b\\x02'", "DS1TRBAL": "b'\\xd5*'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xdb\\x00\\x02\\x03\\xdb\\x00\\r\\x00\\x0c'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13\\x1f\\x01\\x01\\x13\\x1f\\x11Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-11T00:00:00", "modifydate": "2001-05-11T11:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 435    FILE:  515\n\n    ORIGINAL DSNAME:  WSBG.CBT435.FILE515\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    6160    PO\n\n   30 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,171 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/11/01    11:59:13    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13\\x0f\\x01\\x01\\x13\\x0f\\x136\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-10T00:00:00", "modifydate": "2001-05-10T13:36:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SAYB"}, "text": "This is a bunch of rexx functions and some ispf stuff.\n\n@CSR            - get data from ispf screen under cursor\nASM@CSR         - build @csr\nASMDEQ          - build rxdeq\nASMENQ          - build rxenq\nASMSLEEP        - build sleep\nASMSPFP         - build lgnspf\nASMWTOR         - build rxwtor\nASMXL           - build xl\nAXBASML         - proc for assemblies\nLGN@ENT         - entry macro\nLGN@RET         - exit  macro\nLGNASML         - proc for assemblies\nLGNSPF          - Rexx function to return ISPF parms for LOGON proc exec\nLGNSRCH         - binary search macro\nLGNUDEFD        - part of lgnspf\nLGNUDEFE        - part of lgnspf\nLGNUDEFN        - part of lgnspf\nLGNUDEFP        - part of lgnspf\nRLTPLST         - plist to call rltsub\nRLTSUB          - s/routine to return rexx result\nRXDEQ           - issue DEQ macro from rexx exec\nRXENQ           - issue ENQ macro from rexx exec\nRXWTOR          - issue WTO/WTOR from rexx exec\nSLEEP           - wait for specified number of seconds; ATTN terminates\nSPFDOC          - doc for lgnspf\nXL              - get the data from the screen and display a list of\n                  datasets if data is a dataset name; works in edit,\n                  browse and sdsf.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##NOTE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13\\x1f\\x01\\x01\\x13\\x1f\\x119\\x00\\x14\\x00\\x14\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-11T00:00:00", "modifydate": "2001-05-11T11:39:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "WSBG"}, "text": "Golob, Sam\nFrom:   Brodsky, Alex [brodsky-alex@Aramark.com]\nSent:   Thursday, May 10, 2001 3:20 PM\nTo:     sbgolob@attglobal.net\nCc:     abrodsky@sse.com\nSubject:        cbt tape contributions\nHi, Sam,\nI am attaching my contributions to the cbt tape, mostly rexx\nfunctions written in assembler.\n\nPlease let me know if you received it, and if more info is\nneeded.\n\n\nCheers,\nAlex Brodsky\n\n\nP.S. please use abrodsky@sse.com for emails:\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@CSR": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x003o\\x01\\x003o\\x15#\\x00v\\x00v\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-01T00:00:00", "modifydate": "2000-12-01T15:23:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "SAYB"}, "text": "@CSR     CSECT\n@CSR     AMODE 31\n@CSR     RMODE ANY\n         SAVE  (14,12),,@CSR.AXB.&SYSDATE.&SYSTIME\n         LR    R12,R15\n         USING @CSR,R12\n         LR    R6,R1             ; Plist address\n         USING @CSRPL,R6\n         CLC   @CSREYE(4),=CL4'@CSR'  ; Correct call?\n         BNE   EXIT8             ; No\n         XR    R15,R15           ; Error code\n***********************************************************************\n*  I lifted this code from BR program in file 183 on CBT tape         *\n*  and changed it a little.                                           *\n***********************************************************************\n*        Scan data at the cursor position for a dsname                *\n*                                                                     *\n*        Some of this code has been lifted from ISPCDSN,              *\n*        (file 270 of the CBT tape), I hope they don't mind.          *\n*                                                                     *\n*        The TLD address is retrieved from ISPTASK's register 1,      *\n*        as done by ISPEXEC and ISPLINK.  If BR is invoked as a       *\n*        program, ISPF passes the TLD address in the second word      *\n*        of the parameter list built by the SELECT service; when      *\n*        BR is invoked as a command, no TLD address is passed, as     *\n*        far as I know.                                               *\n*  TLD pointers (decimal):                                            *\n*    +128    - current screen image                                   *\n*    +166    - offset to cursor                                       *\n*    +192    - screen width                                           *\n*    +344    - current  panelid                                       *\n*    +352    - previous panelid                                       *\n*                                                                     *\n***********************************************************************\n         USING PSA,0\nCURSOR   L     R1,PSATOLD              PSATOLD (MY TCB)\n         USING TCB,R1\n*LOOP\nCURSOR11 L     R2,TCBFSA               TCBFSA - save area.\n         CLI   40(R2),C'I'             R5 SLOT CONTAINS 'ISPF'\n         BNE   CURSOR14                NO, JUMP\n         CLI   24(R2),X'00'            IS R1 A 24-BIT ADDR?\n         BNE   CURSOR14                NO, JUMP\n         ICM   R2,B'1111',24(R2)       R1 SLOT (ADDR OF TLD PTR)\n         BZ    CURSOR14                NO, JUMP\n         CLI   0(R2),X'00'             IS IT A CLEAN 24-BIT ADDR?\n         BNE   CURSOR14                NO, JUMP\n         L     R2,0(,R2)               R2->TLD\n         CLC   =C'TLD',0(R2)           IS THIS REALLY A TLD?\n         BE    CURSOR19                YES, EXIT LOOP\nCURSOR14 L     R1,TCBOTC               TCBOTC (MOTHER TASK)\n         CL    R1,TCBJSTCB             IS IT THE JSTCB?\n         BNE   CURSOR11                NO, CHECK FOR A TLD\n*ENDLOOP\n*  TLD not found.\n         B     EXIT8                   ; exit with \"no-dsname\" rc\n         DROP  R1                      ; TCB addressability\n*\n*        TLD located, now get the line address and cursor\n*        position.\n*\nCURSOR19 SLR   R0,R0\n         LH    R1,166(,R2)             get cursor offset (TLDCSR)\n         L     R3,192(,R2)             screen width (TLDCLSWD)\n         ST    R3,DTLSZ                ; will be dataline size\n         DR    R0,R3                   get line # (R0) and offset (R1)\n         LR    R5,R0                   cursor offset in line\n         MR    R0,R3                   get offset to current line\n         AL    R1,096(,R2)             change offset to addr (TLDCLSP)\n         LR    R4,R1                   Current line in screen image\n         LA    R5,1(,R5)               ; Cursor column\n         ST    R5,CURPOSC              ; ... 1-based\n* Copy the current line to a buffer; R3 is still a screen width.\n*--------------------------------------------------------------------+\n         BCT   R3,*+10                 ; Around executed instruction \u00b3\n         MVC   DATALINE(0),0(R4)       ; *** executed ***            \u00b3\n         EX    R3,*-6                  ; Copy this screen line       \u00b3\n*--------------------------------------------------------------------+\n         B     EXIT\nEXIT8    LA    R15,8\nEXIT     DS    0H\n*        L     R15,RETCODE              ; get the return code.\n         RETURN (14,12),RC=(15)         RETURN TO OS\n         EJECT ,\n         DS   0D\n         LTORG\nR0     EQU   0\nR1     EQU   1\nR2     EQU   2\nR3     EQU   3\nR4     EQU   4\nR5     EQU   5\nR6     EQU   6\nR7     EQU   7\nR8     EQU   8\nR9     EQU   9\nR10    EQU   10\nR11    EQU   11\nR12    EQU   12\nR13    EQU   13\nR14    EQU   14\nR15    EQU   15\n*\n* Map the call to @CSR\n*\n@CSRPL   DSECT\n@CSREYE  DS    CL4'@CSR'\nDTLSZ    DS    F                  ; Dataline size for MACRO\nCURPOSC  DS    F                  ; Cursor column\nDATALINE DS    CL256' '           ; File data line for Edit macro.\nL@CSRPL  EQU   *-@CSRPL           ; Plist size\n*\n* Macros\n*\n       PRINT GEN\n       IKJTCB\n       IHAPSA\n       END   @CSR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE515": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x01\\x02_\\x01\\x01\\x13\\x1f\\x11X\\x00)\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2001-05-11T11:58:00", "lines": 41, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 515 is from Alex Brodsky, and contains a sizable          *   FILE 515\n//*           collection of REXX functions and ISPF stuff.  You     *   FILE 515\n//*           should find these interesting and useful.             *   FILE 515\n//*                                                                 *   FILE 515\n//*           email:   abrodsky@sse.com                             *   FILE 515\n//*                                                                 *   FILE 515\n//*     This is a bunch of REXX functions and some ISPF stuff.      *   FILE 515\n//*                                                                 *   FILE 515\n//*     @CSR            - get data from ISPF screen under           *   FILE 515\n//*                       cursor                                    *   FILE 515\n//*     ASM@CSR         - build @csr                                *   FILE 515\n//*     ASMDEQ          - build rxdeq                               *   FILE 515\n//*     ASMENQ          - build rxenq                               *   FILE 515\n//*     ASMSLEEP        - build sleep                               *   FILE 515\n//*     ASMSPFP         - build lgnspf                              *   FILE 515\n//*     ASMWTOR         - build rxwtor                              *   FILE 515\n//*     ASMXL           - build xl                                  *   FILE 515\n//*     AXBASML         - proc for assemblies                       *   FILE 515\n//*     LGN@ENT         - entry macro                               *   FILE 515\n//*     LGN@RET         - exit  macro                               *   FILE 515\n//*     LGNASML         - proc for assemblies                       *   FILE 515\n//*     LGNSPF          - REXX function to return ISPF parms        *   FILE 515\n//*                       for LOGON proc exec                       *   FILE 515\n//*     LGNSRCH         - binary search macro                       *   FILE 515\n//*     LGNUDEFD        - part of lgnspf                            *   FILE 515\n//*     LGNUDEFE        - part of lgnspf                            *   FILE 515\n//*     LGNUDEFN        - part of lgnspf                            *   FILE 515\n//*     LGNUDEFP        - part of lgnspf                            *   FILE 515\n//*     RLTPLST         - plist to call rltsub                      *   FILE 515\n//*     RLTSUB          - s/routine to return REXX result           *   FILE 515\n//*     RXDEQ           - issue DEQ macro from REXX exec            *   FILE 515\n//*     RXENQ           - issue ENQ macro from REXX exec            *   FILE 515\n//*     RXWTOR          - issue WTO/WTOR from REXX exec             *   FILE 515\n//*     SLEEP           - wait for specified number of seconds;     *   FILE 515\n//*                       ATTN terminates                           *   FILE 515\n//*     SPFDOC          - doc for lgnspf                            *   FILE 515\n//*     XL              - get the data from the screen and          *   FILE 515\n//*                       display a list of datasets if data is     *   FILE 515\n//*                       a dataset name; works in edit, browse     *   FILE 515\n//*                       and sdsf.                                 *   FILE 515\n//*                                                                 *   FILE 515\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASM@CSR": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x003o\\x01\\x01\\x13\\x0f\\x11\\x12\\x00\\x14\\x00\\x17\\x00\\x04\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2000-12-01T00:00:00", "modifydate": "2001-05-10T11:12:00", "lines": 20, "newlines": 23, "modlines": 4, "user": "SAYB"}, "text": "//ALEXTEST JOB ....\n//*\n//* ASM/LKED @CSR COMMAND\n//*\n//*\n//* 12/98 AXB\n// JCLLIB ORDER=ALEX.ASM                       <--- CHANGE THAT\n//@CSR     EXEC AXBASML,\n//         AMEMB=@CSR,\n//         SRCDSN=ALEX.ASM,\n//         ASMPARM='NODECK,OBJECT,NOESD,NORLD,NOXREF,RENT',\n//         LNKPARM='XREF,LIST,MAP,RENT,AMODE=31',\n//         LOADLIB=ALEX.LOAD,                  <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.AMODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY @CSR\n NAME @CSR(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMDEQ": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x10\\x0f\\x01\\x01\\x13\\x0f\\x11\\x13\\x00&\\x00)\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-04-10T00:00:00", "modifydate": "2001-05-10T11:13:00", "lines": 38, "newlines": 41, "modlines": 0, "user": "SAYB"}, "text": "//ALEXDEQ  JOB ...\n//*\n//* ASSEMBLE EVALBLOK S/ROUTINE\n//*\n//* 03/2001 AXB\n// JCLLIB ORDER=ALEX.ASM                              <--- CHANGE THAT\n//RLTSUB   EXEC LGNASML,\n//         AMEMB=RLTSUB,\n//         SRCDSN=ALEX.ASM,\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                         <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY RLTSUB\n NAME RLTSUB(R)\n//*\n//* ASSEMBLE RXDEQ    REXX FUNCTION\n//*   AND GENERATE EXECUTABLE MODULE.\n//* 04/2001 AXB\n//RXDEQ    EXEC LGNASML,\n//         AMEMB=RXDEQ,\n//         SRCDSN=ALEX.ASM,                           <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                         <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n INCLUDE SYSLMOD(RLTSUB)\n ORDER   RXDEQ\n ENTRY RXDEQ\n NAME RXDEQ(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMENQ": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\t\\x9f\\x01\\x01\\x13\\x0f\\x11\\x14\\x00&\\x00)\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-04-09T00:00:00", "modifydate": "2001-05-10T11:14:00", "lines": 38, "newlines": 41, "modlines": 0, "user": "SAYB"}, "text": "//ALEXENQ  JOB ...\n//*\n//* ASSEMBLE EVALBLOK S/ROUTINE\n//*\n//* 03/2001 AXB\n// JCLLIB ORDER=ALEX.ASM                              <--- CHANGE THAT\n//RLTSUB   EXEC LGNASML,\n//         AMEMB=RLTSUB,\n//         SRCDSN=ALEX.ASM,                           <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                         <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY RLTSUB\n NAME RLTSUB(R)\n//*\n//* ASSEMBLE RXENQ    REXX FUNCTION\n//*   AND GENERATE EXECUTABLE MODULE.\n//* 04/2001 AXB\n//RXENQ    EXEC LGNASML,\n//         AMEMB=RXENQ,\n//         SRCDSN=ALEX.ASM,                           <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                         <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n INCLUDE SYSLMOD(RLTSUB)\n ORDER   RXENQ\n ENTRY RXENQ\n NAME RXENQ(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMSLEEP": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x03\\x8f\\x01\\x01\\x13\\x0f\\x11\\x14\\x00&\\x00K\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-02-07T00:00:00", "modifydate": "2001-05-10T11:14:00", "lines": 38, "newlines": 75, "modlines": 0, "user": "SAYB"}, "text": "//ALEXSLEE JOB ...\n//*\n//* ASSEMBLE EVALBLOK S/ROUTINE FOR ISPF LOGON PROC PROGRAM\n//*\n//* 01/2001 AXB\n// JCLLIB ORDER=ALEX.ASM                         <--- CHANGE THAT\n//RLTSUB   EXEC LGNASML,\n//         AMEMB=RLTSUB,\n//         SRCDSN=ALEX.ASM,                      <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                    <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY RLTSUB\n NAME RLTSUB(R)\n//*\n//* ASSEMBLE SLEEP REXX FUNCTION\n//*   AND GENERATE EXECUTABLE MODULE.\n//* 02/2001 AXB\n//SLEEPM   EXEC LGNASML,\n//         AMEMB=SLEEP,\n//         SRCDSN=ALEX.ASM,                      <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                    <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n INCLUDE SYSLMOD(RLTSUB)\n ORDER   SLEEP\n ENTRY SLEEP\n NAME SLEEP(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMSPFP": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x01\\x01\\x02/\\x01\\x01\\x13\\x0f\\x12Y\\x00J\\x00\\x16\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2001-01-22T00:00:00", "modifydate": "2001-05-10T12:59:00", "lines": 74, "newlines": 22, "modlines": 0, "user": "SAYB"}, "text": "//ALEXSPFP JOB ...\n//*\n//* ASSEMBLE EVALBLOK S/ROUTINE FOR ISPF LOGON PROC PROGRAM\n//*\n//* 01/2001 AXB\n// JCLLIB ORDER=ALEX.ASM                            <--- CHANGE THAT\n//RLTSUB   EXEC LGNASML,\n//         AMEMB=RLTSUB,\n//         SRCDSN=ALEX.ASM,                         <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                       <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY RLTSUB\n NAME RLTSUB(R)\n//*\n//* ASSEMBLE UDEF TABLE FOR ISPF LOGON PROC - EXCEPTIONS\n//*\n//LGNUDEFE EXEC LGNASML,\n//         AMEMB=LGNUDEFE,\n//         SRCDSN=ALEX.ASM,                         <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                       <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY LGNUDEFE\n NAME LGNUDEFE(R)\n//*\n//* ASSEMBLE UDEF TABLE FOR ISPF LOGON PROC - DEFAULTS\n//*\n//LGNUDEFD EXEC LGNASML,\n//         AMEMB=LGNUDEFD,\n//         SRCDSN=ALEX.ASM,                           <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                         <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY LGNUDEFD\n NAME LGNUDEFD(R)\n//*\n//* ASSEMBLE REXX FUNCTION TO USE ISPF LOGON PROC TABLE\n//*   AND GENERATE EXECUTABLE MODULE.\n//* 01/2001 AXB\n//LGNSPF   EXEC LGNASML,\n//         AMEMB=LGNSPF,\n//         SRCDSN=ALEX.ASM,                           <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=YOUR.LINKLIB,                      <--- CHANGE THAT\n//*        LOADLIB=CPAC.LINKLIB,                         2.9\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.TMPLMOD DD DISP=SHR,DSN=ALEX.LOAD                 <--- CHANGE THAT\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n INCLUDE TMPLMOD(LGNUDEFE)\n INCLUDE TMPLMOD(LGNUDEFD)\n INCLUDE TMPLMOD(RLTSUB)\n ORDER   LGNSPF\n ENTRY LGNSPF\n NAME LGNSPF(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMWTOR": {"ttr": 538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x01\\x08o\\x01\\x01\\x13\\x0f\\x12Y\\x00&\\x00)\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-03-27T00:00:00", "modifydate": "2001-05-10T12:59:00", "lines": 38, "newlines": 41, "modlines": 0, "user": "SAYB"}, "text": "//ALEXWTO  JOB ...\n//*\n//* ASSEMBLE EVALBLOK S/ROUTINE\n//*\n//* 03/2001 AXB\n// JCLLIB ORDER=ALEX.ASM                          <--- CHANGE THAT\n//RLTSUB   EXEC LGNASML,\n//         AMEMB=RLTSUB,\n//         SRCDSN=ALEX.ASM,                       <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                     <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n ENTRY RLTSUB\n NAME RLTSUB(R)\n//*\n//* ASSEMBLE RXWTOR   REXX FUNCTION\n//*   AND GENERATE EXECUTABLE MODULE.\n//* 02/2001 AXB\n//RXWTOR   EXEC LGNASML,\n//         AMEMB=RXWTOR,\n//         SRCDSN=ALEX.ASM,                       <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM,RENT',\n//         LNKPARM='XREF,MAP,LIST,RENT',\n//         LOADLIB=ALEX.LOAD,                     <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n INCLUDE SYSLMOD(RLTSUB)\n ORDER   RXWTOR\n ENTRY RXWTOR\n NAME RXWTOR(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMXL": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x003o\\x01\\x01\\x13\\x0f\\x13\\x00\\x00\\x16\\x00\\x1c\\x00\\x05\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-12-01T00:00:00", "modifydate": "2001-05-10T13:00:00", "lines": 22, "newlines": 28, "modlines": 5, "user": "SAYB"}, "text": "//ALEXTEST JOB ...\n//*\n//* ASM/LKED XL   COMMAND\n//*\n//*\n//* 11/98 AXB\n// JCLLIB ORDER=ALEX.ASM                      <--- CHANGE THAT\n//XL       EXEC AXBASML,\n//         AMEMB=XL,\n//         SRCDSN=ALEX.ASM,                   <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,NOESD,NORLD,NOXREF,RENT',\n//         LNKPARM='XREF,LIST,MAP,RENT,AMODE=31',\n//         LOADLIB=ALEX.LOAD,                 <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MODGEN,\n//         LNK1=SYS1.CSSLIB\n//L.SYSLIN DD   *\n INCLUDE OBJECT\n INCLUDE SYSLMOD(@CSR)\n ENTRY XL\n NAME XL(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AXBASML": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x003o\\x01\\x01\\x13\\x0f\\x13\\x01\\x00&\\x00&\\x00\\x02\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-12-01T00:00:00", "modifydate": "2001-05-10T13:01:00", "lines": 38, "newlines": 38, "modlines": 2, "user": "SAYB"}, "text": "//AXBASML  PROC AMEMB=,\n//         SRCDSN=ALEX.ASM,                      <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM',\n//         LNKPARM='XREF,LET,LIST',\n//         LOADLIB=ALEX.LOAD,                    <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MACLIB,\n//         MAC3=SYS1.MACLIB,\n//         MAC4=SYS1.MACLIB,\n//         LNK1=SYS1.CSSLIB,\n//         LNK2=SYS1.CSSLIB\n//*-----------------------------------------------\n//* ASSEMBLE AND LINKEDIT MOST OF MY STUFF.\n//*\n//* 08/96 AXB\n//*-----------------------------------------------\n//A        EXEC PGM=ASMA90,PARM='&ASMPARM',REGION=2M\n//SYSLIB   DD   DISP=SHR,DSN=&SRCDSN\n//         DD   DISP=SHR,DSN=&MAC1\n//         DD   DISP=SHR,DSN=&MAC2\n//         DD   DISP=SHR,DSN=&MAC3\n//         DD   DISP=SHR,DSN=&MAC4\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSPUNCH DD   SYSOUT=*,DCB=(LRECL=80,BLKSIZE=23440)\n//SYSTERM  DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5)),\n//             DCB=(LRECL=80,BLKSIZE=400),DSN=&&LOADSET\n//SYSIN    DD   DSN=&SRCDSN(&AMEMB),DISP=SHR\n//L        EXEC PGM=IEWL,\n//             PARM='&LNKPARM',REGION=2M,COND=(4,LT,A)\n//OBJECT   DD   DSN=&&LOADSET,DISP=(OLD,DELETE)\n//SYSLIB   DD   DISP=SHR,DSN=&LNK1\n//         DD   DISP=SHR,DSN=&LNK2\n//SYSLMOD  DD   DISP=SHR,DSN=&LOADLIB\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(3,2))\n//SYSPRINT DD   SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=3509)\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LGN@ENT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x13\\x0f\\x13\\x01\\x00-\\x00-\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-05-10T13:01:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SAYB"}, "text": "         MACRO\n.* ------------------------------------------*\n.* Entry linkage for most modules            *\n.*                                           *\n.* 07/2000 axb allow for worklen > 4096      *\n.*                                           *\n.*                                           *\n.* 10/2000 axb extra parms for s/routine call*\n.*                                           *\n.* ------------------------------------------*\n&LABEL   LGN@ENT  &WHAT,&WORK=WORKAREA,&WORKL=WORKLEN\n         AIF ('&WHAT' EQ 'CSECT').CSECT\n         AIF ('&WHAT' EQ 'ENTRY').ENTRY\n         MNOTE 16,'Incorrect LGN@ENT parameter'\n         MEXIT\n.CSECT   ANOP\n&LABEL   CSECT\n         AGO   .COMMON\n.ENTRY   ANOP\n         ENTRY  &LABEL\n&LABEL   DS    0H\n         AGO   .COMMON\n.COMMON  ANOP\n         USING &LABEL,R15                ; Address program.\n         SAVE  (14,12),,&LABEL..SSE.ALEX.BRODSKY.&SYSDATE.&SYSTIME\n         LR    R12,R15            ; Set program base.\n         DROP  R15\n         USING &LABEL,R12,R11         ; Address program.\n         LA    R11,2048(R12)\n         LA    R11,2048(R11)\n* 'STORAGE OBTAIN,LENGTH=&WORKL,ADDR=(R1),LOC=BELOW,COND=NO'\n         STORAGE OBTAIN,LENGTH=&WORKL,ADDR=(R1),LOC=BELOW,COND=NO\n         LA    R6,0(R1)           ; Target addr\n         L     R7,=A(&WORKL)      ; Target size\n         LR    R8,R6              ; source=target\n         SR    R9,R9              ; clear area\n         MVCL  R6,R8              ; ...\n         ST    R1,8(R13)          ; Chain saveareas.\n         ST    R13,4(R1)          ; ...\n         LR    R13,R1             ; ...\n         USING &WORK,R13\n****     XC    RETCODE(4),RETCODE ; Set normal return code - 0\n         L     R1,4(,R13)         ; Get to the prev savearea\n         LM    R0,R10,20(R1)      ; Restore entry registers\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGN@RET": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x02?\\x14\\x10\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-01-23T14:10:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SAYB"}, "text": "         MACRO\n.* ------------------------------------------*\n.* Exit  linkage for most modules            *\n.*                                           *\n.* 06/2000 axb                               *\n.*                                           *\n.* 10/2000 axb extra parms for s/routine call*\n.*                                           *\n.* ------------------------------------------*\n&LABEL   LGN@RET  &WORKL=WORKLEN,&RC=RETCODE\n.*   exit from the s/routine\n&LABEL   DS    0H\n         L     R15,&RC            ; Get return code.\n         LR    R1,R13             ; Address save area.\n         L     R13,4(,R13)        ; Address prev save area.\n         ST    R15,16(R13)        ; Set return code.\n* 'STORAGE RELEASE,ADDR=(R1),LENGTH=&WORKL,COND=NO'\n         STORAGE RELEASE,ADDR=(R1),LENGTH=&WORKL,COND=NO\n         LM    R14,R12,12(R13)    ; Retcode already set\n         LTR   R15,R15            ; Set condition code\n         BR    R14\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGNASML": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x003o\\x01\\x01\\x13\\x0f\\x13\\x02\\x00&\\x00&\\x00\\x03\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-12-01T00:00:00", "modifydate": "2001-05-10T13:02:00", "lines": 38, "newlines": 38, "modlines": 3, "user": "SAYB"}, "text": "//LGNASML  PROC AMEMB=,\n//         SRCDSN=ALEX.ASM,                    <--- CHANGE THAT\n//         ASMPARM='NODECK,OBJECT,TERM',\n//         LNKPARM='XREF,LET,LIST',\n//         LOADLIB=ALEX.LOAD,                  <--- CHANGE THAT\n//         MAC1=SYS1.MACLIB,\n//         MAC2=SYS1.MACLIB,\n//         MAC3=SYS1.MACLIB,\n//         MAC4=SYS1.MACLIB,\n//         LNK1=SYS1.CSSLIB,\n//         LNK2=SYS1.CSSLIB\n//*-----------------------------------------------\n//* ASSEMBLE AND LINKEDIT MOST OF MY STUFF.\n//*\n//* 08/96 AXB\n//*-----------------------------------------------\n//A        EXEC PGM=ASMA90,PARM='&ASMPARM',REGION=2M\n//SYSLIB   DD   DISP=SHR,DSN=&SRCDSN\n//         DD   DISP=SHR,DSN=&MAC1\n//         DD   DISP=SHR,DSN=&MAC2\n//         DD   DISP=SHR,DSN=&MAC3\n//         DD   DISP=SHR,DSN=&MAC4\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSPUNCH DD   SYSOUT=*,DCB=(LRECL=80,BLKSIZE=23440)\n//SYSTERM  DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5)),\n//             DCB=(LRECL=80,BLKSIZE=400),DSN=&&LOADSET\n//SYSIN    DD   DSN=&SRCDSN(&AMEMB),DISP=SHR\n//L        EXEC PGM=IEWL,\n//             PARM='&LNKPARM',REGION=2M,COND=(4,LT,A)\n//OBJECT   DD   DSN=&&LOADSET,DISP=(OLD,DELETE)\n//SYSLIB   DD   DISP=SHR,DSN=&LNK1\n//         DD   DISP=SHR,DSN=&LNK2\n//SYSLMOD  DD   DISP=SHR,DSN=&LOADLIB\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(3,2))\n//SYSPRINT DD   SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=3509)\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LGNSPF": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x13\\x0f\\x13\\x03\\x013\\x01\\x1b\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-05-10T13:03:00", "lines": 307, "newlines": 283, "modlines": 0, "user": "SAYB"}, "text": "LGNSPF      TITLE 'Rexx function to return ISPF parms for LOGON proc'\nLGNSPF      AMODE 31\nLGNSPF      RMODE ANY\n*----------------------------------------------------------------------\nLGNSPF   LGN@ENT  CSECT\n*\n* End of housekeeping statements.\n*\nSTART    DS    0H\n         ST    R0,ENV            ; save ENVB ptr\n         LR    R9,R1             ; Get the EFPL address\n         USING EFPL,R9           ; Extended function plist\n*\n* Init IRXEXCOM plist\n*\n         LA    R2,KCEXCOM        ; Get the character ID\n         ST    R2,EXCOMP1        ; Save as first parm address\n         XC    EXCOMP2(L'EXCOMP2+L'EXCOMP3),EXCOMP2 ; Make them 0\n         LA    R2,SHVB            ; Get the SHVBLOCK address\n         ST    R2,EXCOMP4         ; Save as a fourth argument\n         OI    EXCOMP4,X'80'      ; Flag the fourth as a last arg\n*\n* Init SHVBLOCK's.\n*\n         LA    R2,UVARCNT         ; that many vars to set\n         LA    R3,SHVB            ; Get to the first block\n         USING SHVBLOCK,R3        ; Tell assembler\n         LA    R4,UVART           ; vars table\n         USING DUVART,R4          ; map it as well\nLP01     DS    0H\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK ; Init to zeros.\n         LA    R1,SHVBLEN(,R3)    ; Next block address\n         ST    R1,SHVNEXT         ; chain them together\n*        XC    SHVNEXT(4),SHVNEXT ; Zero for the last block\n*        XC    SHVUSER(4),SHVUSER ; No user info\n         LA    R1,DUVAR           ; var name address\n         ST    R1,SHVNAMA         ; ...\n         MVC   SHVNAML+2(2),DUVARL ; Set the var name length\n         MVI   SHVCODE,SHVSTORE   ; Uppercase 'S' for SET\n         LA    R3,SHVBLEN(,R3)    ; Next block\n         LA    R4,UVARTSZ(,R4)    ; Next rexx var descriptor\n         BCT   R2,LP01            ; init all blocks\n         S     R3,=A(SHVBLEN)     ; Prev block\n         XC    SHVNEXT(4),SHVNEXT ; Zero for the last block\n         DROP  R3                 ; shvblock\n         DROP  R4                 ; var table\n*\n* Init result string. Exit code will set the result to\n*  whatever is pointed to by 'RESULT' variable.\n*\n* Look at RLTPLST macro for the format of RESULT variable\n*\n         L     R1,EFPLEVAL        ; Get the evalblock address\n         ST    R1,EVB             ; save it for exit routine\n         LA    R1,KCOK            ; result=0\n         ST    R1,RESULT          ; for a good return\n*\n* Now look at REXX input args, should be one.\n*\n         MVC   KEY(7),BLANKS      ; prepare\n*--------------------------------------------------------------------*\n* Now look at arguments passed by the caller.\n*  We only need one argument.\n*\n*  If argument is not supplied (pointer is zero) or\n*  missing entirely (we hit the fence, 8X'FF'), we move RC=16\n*  the result area and exit the function.\n*\n*  At this time extra arguments are ignored.\n*\n*--------------------------------------------------------------------*\n         L     R4,EFPLARG         ; Pointer to the arguments\n         USING ARGTABLE_ENTRY,R4  ; Map the entry\n         ICM   R2,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   INCORARGS          ; Wrong!\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   INCORARGS          ; Wrong!\n**       LA    R4,ARGTABLE_NEXT   ; Adjust the base - next entry\n         DROP  R4                 ; ARGTABLE_ENTRY\n*\n* Make sure that the entry is no more than 7 chars long\n*\n         C     R3,=F'7'           ; ???\n         BH    INCORARGS          ; too long\n         BCT   R3,*+10            ; around instr\n         MVC   KEY(0),0(R2)       ; *** executed ***\n         EX    R3,*-6             ; fill up the search key\n\n*\n* Get the address of IRXEXCOM from IRXEXTE\n*\n         L     R1,ENV             ; ENVBLOCK address\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R1) ; IRXEXTE address\n         USING IRXEXTE,R1         ; Tell assembler\n         MVC   ZZZEXCOM(4),IRXEXCOM ; Var access routine\n         DROP  R1\n*\n*----------------------------------------------------------------\n*  Binary search for the key in pre-built table.\n*    Table is sorted at generation time by the macro.\n*  *** this is a search for exceptions using full parameter,\n*  *** that is probably a userid.\n*----------------------------------------------------------------\n         OI    EXCEPTIONS,L'EXCEPTIONS  ; mark the first path\n         L     R10,LGNUDEFE      ; table pointer - exceptions\n*\n* Here twice, if exception is not located, then entered for\n*   defaults table search.\n*\nISEARCH  DS    0H\n         LM    R5,R8,0(R10)      ; get the header values.\n         LGNSRCH (R5),           ; address of a table                  *\n               LAST=(R6),        ; last entry address                  *\n               LV=(R7),          ; length of each entry                *\n               KEY=KEY,          ; search key                          *\n               NONE=NOT_FOUND_E, ; if key not found in table           *\n               FOUND=FOUND,      ; if key is found  in table           *\n               KLV=(R8),         ; key length                          *\n               KEYOFF=0,         ; key offset                          *\n               SEQ=A             ; sorted in ascending seq\n*\n* Keyword not found in exception table.\n*   Now we will search in the defailts table, made up from the\n*    first letter of a userid.\n*\nNOT_FOUND_E DS 0H\n         TM    DEFAULTS,L'DEFAULTS  ; defaults?\n         BO    NOT_FOUND            ; Yes, could not find an entry\n         MVC   KEY+1(L'KEY-1),BLANKS ; leave only 1st letter\n         NI    EXCEPTIONS,255-L'EXCEPTIONS\n         OI    DEFAULTS,L'DEFAULTS  ; now looking for defaults\n         L     R10,LGNUDEFD      ; table pointer - defaults\n         B     ISEARCH           ; and look up again\n*\n* Keyword found in a table, R1 points to entry there.\n*  this path is taken for both defaults and exeptions.\n*\nFOUND     DS   0H\n          LR   R2,R1\n          USING DUDEF,R2          ; map table entry\n*\n* add info to SHVBLOCK's.\n*\n         LA    R6,UVARCNT         ; that many vars to set\n         LA    R3,SHVB            ; Get to the first block\n         USING SHVBLOCK,R3        ; Tell assembler\n         LA    R4,UVART           ; vars table\n         USING DUVART,R4          ; map it as well\n         SLR   R5,R5              ; Prepare\nLP02     DS    0H\n*\n         ICM   R5,B'0011',DUVARD  ; var displacement\n         LA    R1,DUDEF(R5)       ; Var address\n         ICM   R5,B'0011',DUVARVL ; var size or 0\n         BNZ   LP03               ; if non-zero -ok\n         ICM   R1,B'1111',0(R1)   ; if zero - was a ptr to struct\n         SLR   R5,R5              ; ... AL1(size),C'value'\n         IC    R5,0(,R1)          ;  and get the size and\n         LA    R1,1(,R1)          ;  adjust the var address\nLP03     DS    0H\n         ST    R1,SHVVALA         ; value address\n         ST    R5,SHVVALL         ; value size\n*\n         LA    R3,SHVBLEN(,R3)    ; Next block\n         LA    R4,UVARTSZ(,R4)    ; Next rexx var descriptor\n         BCT   R6,LP02            ; add to all blocks\n*\n         DROP  R2                 ; table entry\n         DROP  R3                 ; shvblock\n         DROP  R4                 ; var table\n*\n* Finally, call IRXEXCOM to set all the variables\n*\n*\n         L     R0,ENV             ; Optional environment block addr\n         LA    R1,EXCOM           ; IRXEXCOM plist\n         L     R15,ZZZEXCOM       ; Saved address of routine\n         BALR  R14,R15            ; Go there\n*        LINK  EP=IRXEXCOM,MF=(E,EXCOM) ; CALL IT.\n*\n* At this time we are not analyzing return code from IRXEXCOM,\n*   if it is non-zero, set the routine return code to it and\n*   this will result in exec termination.\n*\n         ST    R15,RETCODE        ; from IRXEXCOM\n         B     EXIT\n*\n*--------------------------------------------------------------------*\n*                    Exits; Retcode loaded from RETCODE\n*--------------------------------------------------------------------*\nNOT_FOUND DS   0H\n         LA    R1,KCNFOUND        ; result=24\n         ST    R1,RESULT          ; and dont set variables for now\n         B     EXIT\nINCORARGS DS   0H\n         LA    R1,KCNARGS         ; result=16\n         ST    R1,RESULT          ; and dont set variables for now\n         B     EXIT\n*--------------------------------------------------------------------*\n*                    EXIT\n*--------------------------------------------------------------------*\nEXIT     DS    0H\n*\n* Allocate EVALBLOCK if needed and move the result data there\n*\n         LA    R1,RLTSUB$         ; RLTSUB plist\n         L     R15,=V(RLTSUB)     ; Routine address\n         BALR  R14,R15            ; Call it\n*\n* Rexx will set the result.\n*\nEXIT0    LGN@RET                  bye\n         EJECT\n*--------------------------------------------------------------------*\n*     Constants and work areas\n*--------------------------------------------------------------------*\n*\nBLANKS   DC    CL80' '             ; Handy\n*\nKCEXCOM  DC    CL8'IRXEXCOM'      ; NEED FOR THE CALL TO IRXEXCOM\n*\n* Return RC=16 if no arguments or incorr args.\n*\nKCNARGS  DC    AL4(KCNARGSE-KCNARGS-4) ; Return rc=16\n         DC    C'16'\nKCNARGSE EQU   *\n*\n* Found in a table, rexx variables set.\n*\nKCOK     DC    AL4(KCOKE-KCOK-4)  ; Error message length\n         DC    C'0'               ; return 0\nKCOKE    EQU   *\n*\n* Not found in a table.\n*\nKCNFOUND DC    AL4(KCNFOUNDE-KCNFOUND-4)  ; Error message length\n         DC    C'24'\nKCNFOUNDE EQU  *\n*\nLGNUDEFD DC    V(LGNUDEFD)         ; Parameters table - defaults\nLGNUDEFE DC    V(LGNUDEFE)         ; Parameters table - exceptions\n*\n* map entries from the user/ispf command table\n*\n         LGNUDEFN VART=YES\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n***************************************\n* Workarea dsect. R13 points to it.   *\n***************************************\nWORKAREA DSECT\nSAVEAREA DS    18F                ; Registers save area\nRETCODE  DS    F                  ; Return code\nRSNCODE  DS    F                  ; Reason code\nCALLPL   DS    10F                ; for Call macro\n*\nKEY      DS    CL7                ; search key\nLGNFLG   DS    X                  ; flag\nEXCEPTIONS EQU  LGNFLG,X'80'      ; processing exceptions\nDEFAULTS   EQU  LGNFLG,X'40'      ; processing defaults\n*\n* Plist to call RLTSUB\n*\nRLTSUB$  RLTPLST DSECT=NO\n*\nZZZEXCOM DS    F                ; IRXEXCOM address from IRXEXTE\n*.\n*. IRXEXCOM plist - short version.\n*.\nEXCOM    DS    0D                 ; IRXEXCOM plist\nEXCOMP1  DS    F                  ; Points to CL8'IRXEXCOM'\nEXCOMP2  DS    F                  ; Should BE 0.\nEXCOMP3  DS    F                  ; Should BE 0.\nEXCOMP4  DS    F                  ; Point to first SHVBLOCK\n         ORG   EXCOMP4\n         DC    X'80',AL3(0)       ; Last parameter\n         ORG   ,\n*\n         DS    0D\nSHVB     DS    XL(SHVBLEN*UVARCNT)'00' ; Place for SHVBLOCK's\n*----------------\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*--------------------------------------------------------------------*\n         PRINT ON\n*--------------------------------------------------------------------*\n* MACROS.\n*--------------------------------------------------------------------*\n*\n* Map the entry\n*\n         LGNUDEFN DSECT=YES\n*\n         YREGS               ; Registers equates\n*--------------------------------------------------------------------*\n* REXX MACROS.\n*--------------------------------------------------------------------*\n         IRXENVB                  ; ENVIRONMENT BLOCK (R0 ON ENTRY)\n         IRXEFPL DSECT=YES        ; EXTERNAL FUNCTION PLIST (R1)\n         IRXARGTB                 ; MAP THE ARGUMENT LIST.\n         IRXSHVB                  ; SHARED VARIABLES BLOCK\n         IRXEVALB                 ; EVALBLOCK TO RETURN RESULT.\n         IRXEXTE                  ; EXTERNAL ENTRY POINTS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGNSRCH": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x02?\\x14\\x14\\x01\\x1a\\x01\\x1a\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-01-23T14:14:00", "lines": 282, "newlines": 282, "modlines": 0, "user": "SAYB"}, "text": "*ASSEMBLY EDECK\n         MACRO\n&NAME LGNSRCH &START,&END,&LAST=,&LV=,&LA=,                            X\n               &KEY=,&KEYOFF=0,&KLV=,&KLA=,&SEQ=A,                     X\n               &FOUND=,&NONE=,&REG=1,                                  X\n               &DOC=NO\n LCLA &N,&B\n* A.ISEARCH (V0.1) 12/05/78 RKC                                         SEAR0005\n* A.ISEARCH (V0.1) 04/97 axb minor change - no self-modifications.      SEAR0005\n         AIF   ('&NAME' EQ '').NONAME                                   SEAR0009\n&NAME    DC    0H'0'                                                    SEAR0010\n.NONAME  ANOP\n         AIF   ('&LV' EQ '').NOLV1                                      SEAR0014\n         AIF   ('&LV'(1,1) EQ '(').LVR1                                 SEAR0015\n         AIF   (T'&LV EQ 'N').LVN                                       SEAR0016\n         LA    0,&LV              LV= NUMBER                            SEAR0017\n         AGO   .NOLV1                                                   SEAR0018\n.LVR1    ANOP\n         LR    0,&LV(1)            LV= REG                              SEAR0020\n.NOLV1   ANOP\n         AIF   ('&LA' EQ '').NOLA1                                      SEAR0022\n         AIF   ('&LA'(1,1) EQ '(').LAR1                                 SEAR0023\n         L     0,&LA              LA= FULLWORD                          SEAR0024\n         AGO   .NOLA1                                                   SEAR0025\n.LAR1    ANOP\n         L     0,0&LA             LA= REG                               SEAR0027\n.NOLA1   ANOP\n         AIF   ('&KLV&KLA' NE '').YESKL                                 SEAR0029\n         LR    1,0                SAVE KEY LENGTH FOR LATER             SEAR0030\n.YESKL   ANOP\n         LR    15,0               COPY LENGTH                           SEAR0032\n         BCTR  15,0                TO CLEAR BOTTOM BIT, TURN LOWER ON   SEAR0033\n         XR    15,0                  AND GET DIFFERENT BITS             SEAR0034\n         NR    0,15                  WINDING UP WITH ONLY LOWEST BIT    SEAR0035\n         AGO   .LENE                                                    SEAR0036\n.LVN     ANOP\n&N       SETA  &LV                                                      SEAR0038\n&B       SETA  1                                                        SEAR0039\n         AIF   (&N GT 0).NLOOP                                          SEAR0040\n         MNOTE 8,' LV= MUST BE A POSITIVE NUMBER ********************'  SEAR0041\n         AGO   .NLOOPE                                                  SEAR0042\n.NLOOP   ANOP\n         AIF   (&N/2*2 NE &N).NLOOPE                                    SEAR0044\n&B       SETA  &B*2                                                     SEAR0045\n&N       SETA  &N/2                                                     SEAR0046\n         AGO   .NLOOP                                                   SEAR0047\n.NLOOPE  ANOP\n         LA    0,&B               LOW ORDER BIT OF LENGTH               SEAR0049\n.LENE    ANOP\n         AIF   ('&KLV' EQ '').NOKLV                                     SEAR0052\n         AIF   ('&KLV'(1,1) EQ '(').KLVR                                SEAR0053\n         AIF   (T'&KLV EQ 'N').KEYLN                                    SEAR0054\n         LA    1,&KLV             KLV= NON-NUMERIC                      SEAR0055\n         AGO   .NOKLA                                                   SEAR0056\n.KLVR    ANOP\n         LR    1,&KLV(1)          KLV= REG                              SEAR0058\n.NOKLV   ANOP\n         AIF   ('&KLA' EQ '').NOKLA                                     SEAR0060\n         AIF   ('&KLA'(1,1) EQ '(').KLAR                                SEAR0061\n         L     1,&KLA              KLA= FULLWORD                        SEAR0062\n         AGO   .NOKLA                                                   SEAR0063\n.KLAR    ANOP\n         L     1,0&KLA            KLA= REG                              SEAR0065\n.NOKLA   ANOP\n         AIF   ('&KLA&KLV' EQ '' AND T'&LV EQ 'N').KEYLN                SEAR0067\n         BCTR  1,0                DECREMENT FOR MACHINE INSTR.          SEAR0068\n*****    STC   1,CLC&SYSNDX+1         AND SETUP THE COMPARE.            SEAR0069\n         LR    2,1               ; Use R2 for execute.\n.KEYLN   ANOP\n         AIF   ('&START'(1,1) EQ '(').STARTR                            SEAR0072\n         LA    14,&START          START=                                SEAR0073\n         AGO   .STARTE                                                  SEAR0074\n.STARTR  ANOP\n         LR    14,&START(1)       GET START FROM REG                    SEAR0076\n.STARTE  ANOP\n         AIF   ('&LAST' EQ '').NOLAST                                   SEAR0079\n         AIF   ('&LAST'(1,1) EQ '(').LASTR                              SEAR0080\n         LA    15,&LAST           LAST=                                 SEAR0081\n         AGO   .LASTE                                                   SEAR0082\n.LASTR   ANOP\n         LR    15,&LAST(1)        LAST= REG                             SEAR0084\n.LASTE   ANOP\n         B     LOOP&SYSNDX        START LOOP                            SEAR0086\n         AGO   .ENDE                                                    SEAR0087\n.NOLAST  ANOP\n         AIF   ('&END'(1,1) EQ '(').ENDR                                SEAR0089\n         LA    &REG,&END          END=                                  SEAR0090\n         AGO   .ENDE                                                    SEAR0091\n.ENDR    ANOP\n         LR    &REG,&END(1)       GET END FROM REG                      SEAR0093\n.ENDE    ANOP\nHIGH&SYSNDX    LR  15,&REG        GET LATEST FAILURE                    SEAR0096\n         AIF   ('&LV' EQ '').NOLV2                                      SEAR0097\n         AIF   ('&LV'(1,1) EQ '(').LVR2                                 SEAR0098\n         LA    &REG,&LV             AND SUBTRACT LENGTH                 SEAR0099\n         SR    15,&REG                    FROM IT AS UPPER BOUNDS.      SEAR0100\n         AGO   .NOLA2                                                   SEAR0101\n.LVR2    ANOP\n         SR    15,&LV(1)          AND SUBTRACT LENGTH AS UPPER BOUND.   SEAR0103\n.NOLV2   ANOP\n         AIF   ('&LA' EQ '').NOLA2                                      SEAR0105\n         AIF   ('&LA'(1,1) EQ '(').LAR2                                 SEAR0106\n         S     15,&LA               AND SUBTRACT LENGTH FROM IT         SEAR0107\n         AGO   .NOLA2                                                   SEAR0108\n.LAR2    ANOP\n         S     15,0&LA             AND SUBTRACT LENGTH AS UPPER BOUND.  SEAR0110\n.NOLA2   ANOP\nLOOP&SYSNDX LR &REG,15            GET LENGTH REMAINING                  SEAR0113\n         SR    &REG,14              AND SEE IF POINTERS HAVE CROSSED    SEAR0114\n         BM    EOF&SYSNDX .           YES, GO GIVE HIGHER ADDR.  RKC0.1 SEAR0115\n         NR    &REG,0                   NO, SEE IF DIFFERENCE IS ODD    SEAR0116\n         BZ    NOTO&SYSNDX                                              SEAR0117\n         AIF   ('&LV' EQ '').NOLV3                                      SEAR0118\n         AIF   ('&LV'(1,1) EQ '(').LVR3                                 SEAR0119\n         LA    &REG,&LV           USE LV= TO MAKE ODD INTO EVEN  RKC0.1 SEAR0120\n         AGO   .NOLV3                                                   SEAR0121\n.LVR3    ANOP\n         LR    &REG,&LV(1) .      USE LV= TO MAKE ODD INTO EVEN  RKC0.1 SEAR0123\n.NOLV3   ANOP\n         AIF   ('&LA' EQ '').NOLA3                                      SEAR0125\n         AIF   ('&LA'(1,1) EQ '(').LAR3                                 SEAR0126\n         L     &REG,&LA           USE LA= TO MAKE ODD INTO EVEN  RKC0.1 SEAR0127\n         AGO   .NOLA3                                                   SEAR0128\n.LAR3    ANOP\n         L     &REG,0&LA   .      USE LA= TO MAKE ODD INTO EVEN  RKC0.1 SEAR0130\n.NOLA3   ANOP\nNOTO&SYSNDX DC 0H'0'                                                    SEAR0132\n         AR    &REG,14    .       LOWER BOUND (MADE EVEN)        RKC0.1 SEAR0133\n         AR    &REG,15    .       TO CALCULATE DOUBLE+DIFFERENCE RKC0.1 SEAR0134\n         SRL   &REG,1             WE ARE NOW HALF WAY BETWEEN THE TWO.  SEAR0135\n         AIF   ('&KLV' EQ '').CLCNKLV                                   SEAR0137\n         AIF   ('&KLV'(1,1) EQ '(').CLC0                                SEAR0138\n         AIF   (T'&KLV EQ 'N').CLCN                                     SEAR0139\n         AGO   .CLC0                                                    SEAR0140\n.CLCNKLV ANOP\n         AIF   ('&KLA' NE '').CLC0                                      SEAR0142\n         AIF   ('&LV' EQ '').CLC0                                       SEAR0143\n         AIF   ('&LV'(1,1) EQ '(').CLC0                                 SEAR0144\n         AIF   (T'&LV EQ 'N').CLCLVN                                    SEAR0145\n.CLC0    ANOP\n         B     *+10\nCLC&SYSNDX CLC &KEYOFF.(0,&REG),&KEY IS IT THIS KEY?                    SEAR0147\n         EX    2,*-6\n         AGO   .NOTCLC0                                                 SEAR0148\n.CLCN    ANOP\n         CLC   &KEYOFF.(&KLV,&REG),&KEY IS IT THIS KEY?                 SEAR0150\n         AGO   .NOTCLC0                                                 SEAR0151\n.CLCLVN  ANOP\n         CLC   &KEYOFF.(&LV,&REG),&KEY IS IT THIS KEY?                  SEAR0153\n.NOTCLC0 ANOP\n         AIF   ('&SEQ'(1,1) EQ 'D').SEQD                                SEAR0156\n         AIF   ('&SEQ'(1,1) EQ 'A').SEQA                                SEAR0157\n         MNOTE 4,'SEQ=&SEQ INVALID, SEQ=A ASSUMED.'                     SEAR0158\n.SEQA    ANOP\n         BH    HIGH&SYSNDX        THIS ENTRY IS HIGHER THAN KEY         SEAR0160\n         AGO   .SEQE                                                    SEAR0161\n.SEQD    ANOP\n         BL    HIGH&SYSNDX        THIS ENTRY IS ABOVE KEY               SEAR0163\n.SEQE    ANOP\n         AIF   ('&FOUND' EQ '').NOFOUND                                 SEAR0166\n         AIF   ('&FOUND'(1,1) EQ '(').FOUNDR                            SEAR0167\n         BE    &FOUND             GO TO FOUND=                          SEAR0168\n         AGO   .FOUNDE                                                  SEAR0169\n.FOUNDR  ANOP\n         BCR   8,&FOUND(1)        GO TO FOUND= REG                      SEAR0171\n         AGO   .FOUNDE                                                  SEAR0172\n.NOFOUND ANOP\n         BE    EQ&SYSNDX          THIS ENTRY IS IT                      SEAR0174\n.FOUNDE  ANOP\n         AIF   ('&LV' EQ '').NOLV4                                      SEAR0177\n         AIF   ('&LV'(1,1) EQ '(').LVR4                                 SEAR0178\n         AIF   ('&LV'(K'&LV,1) EQ ')').NOTN4                            SEAR0179\n         LA    14,&LV.(&REG)      FAILING ENTRY IS LOW                  SEAR0180\n         AGO   .NOLV4                                                   SEAR0181\n.NOTN4   ANOP\n         LA    14,&LV             ADD LENGTH (POSSIBLY BASE-DISPLACEM)  SEAR0183\n         AR    14,&REG                TO FAILING ENTRY AS LOWER BOUND.  SEAR0184\n         AGO   .NOLV4                                                   SEAR0185\n.LVR4    ANOP\n         LA    14,0(&REG,&LV(1))  FAILING ENTRY PLUS LENGTH IS LOW-BND  SEAR0187\n.NOLV4   ANOP\n         AIF   ('&LA' EQ '').NOLA4                                      SEAR0189\n         LR    14,&REG             ADD LENGTH TO FAILING ENTRY ADDR     SEAR0190\n         AIF   ('&LA'(1,1) EQ '(').LAR4                                 SEAR0191\n         A     14,&LA               AS LOWER BOUNDS.                    SEAR0192\n         AGO   .NOLA4                                                   SEAR0193\n.LAR4    ANOP\n         A     14,0&LA               AS LOWER BOUNDS.                   SEAR0195\n.NOLA4   ANOP\n         B     LOOP&SYSNDX                                              SEAR0198\nEOF&SYSNDX LR  &REG,14            GIVE USER NEXT HIGHER FAILING ADDR    SEAR0199\n         AIF   ('&NONE' EQ '').NOEOF                                    SEAR0200\n         AIF   ('&NONE'(1,1) EQ '(').EOFR                               SEAR0201\n         B     &NONE              NONE=                                 SEAR0202\n         AGO   .NOEOF                                                   SEAR0203\n.EOFR    ANOP\n         BR    &NONE(1)           NONE= REG                             SEAR0205\n.NOEOF   ANOP\n         AIF   ('&FOUND' NE '').NOEQ                                    SEAR0207\nEQ&SYSNDX DC   0H'0'                                                    SEAR0208\n.NOEQ    ANOP\n         AIF   ('&DOC' EQ 'YES').DOC                                    SEAR0211\n         MEXIT                                                          SEAR0212\n.DOC     ANOP\n         MNOTE *,' '                                                    SEAR0214\n         MNOTE *,'BINARY SEARCH OF FIXED LENGTH TABLE IN MEMORY'        SEAR0215\n         MNOTE *,'****************************************************' SEAR0216\n         MNOTE *,' '                                                    SEAR0217\n         MNOTE *,' USAGE:'                                              SEAR0218\n         MNOTE *,' THE FOLLOWING GIVES THE PARAMETERS FOR THE MACRO,'   SEAR0219\n         MNOTE *,'  WITH OPTIONAL PARAMETERS SHOWN IN PARENTHESES,'     SEAR0220\n         MNOTE *,'  AND CHOICES SHOWN ONE ABOVE THE OTHER.'             SEAR0221\n         MNOTE *,' '                                                    SEAR0222\n         MNOTE *,'   LGNSRCH  START,END  ,LV=,KEY=,(REG=1)'             SEAR0223\n         MNOTE *,'                  LAST=,LA=,    '                     SEAR0224\n         MNOTE *,'                                             ' RKC0.1 SEAR0225\n         MNOTE *,'            - - - - - - - - - - - - - - -    ' RKC0.1 SEAR0226\n         MNOTE *,' '                                                    SEAR0227\n         MNOTE *,'            ,(KLV=),(KEYOFF=0),(SEQ=A)'               SEAR0228\n         MNOTE *,'            ,(KLA=)'                                  SEAR0229\n         MNOTE *,'                                             ' RKC0.1 SEAR0230\n         MNOTE *,'            - - - - - - - - - - - - - - -    ' RKC0.1 SEAR0231\n         MNOTE *,' '                                                    SEAR0232\n         MNOTE *,'            ,(FOUND=),(NONE=),(DOC=NO)'               SEAR0233\n         MNOTE *,' '                                                    SEAR0234\n         MNOTE *,'WHERE:'                                               SEAR0235\n         MNOTE *,' START IS THE ADDR OF FIRST ENTRY IN TABLE.'          SEAR0236\n         MNOTE *,'   IT MAY BE RX-TYPE OR REGISTER NOTATION.'           SEAR0237\n         MNOTE *,' END IS THE ADDR JUST BEYOND THE TABLE.'              SEAR0238\n         MNOTE *,' LAST= IS THE ADDR OF LAST ENTRY IN TABLE.'           SEAR0239\n         MNOTE *,'   ONE OR THE OTHER MUST BE GIVEN, BUT NOT BOTH.'     SEAR0240\n         MNOTE *,'   EITHER MAY BE RX-TYPE OR REGISTER NOTATION.'       SEAR0241\n         MNOTE *,' LV= IS THE LENGTH VALUE (OF EACH ENTRY).'            SEAR0242\n         MNOTE *,' LA= IS THE ADDR OF A FULLWORD GIVING LENGTH.'        SEAR0243\n         MNOTE *,'   ONE OR THE OTHER MUST BE GIVEN, BUT NOT BOTH.'     SEAR0244\n         MNOTE *,'   BOTH MAY BE RX-TYPE OR REGISTER NOTATION.'         SEAR0245\n         MNOTE *,'    AND LV= MAY ALSO BE A NUMBER'                     SEAR0246\n         MNOTE *,' KEY= IS THE ADDR OF KEY TO COMPARE FOR.'             SEAR0247\n         MNOTE *,'   IT MAY BE RS-TYPE NOTATION ONLY.'                  SEAR0248\n         MNOTE *,' '                                                    SEAR0249\n         MNOTE *,' THE FOLLOWING ARE OPTIONAL:'                         SEAR0250\n         MNOTE *,' '                                                    SEAR0251\n         MNOTE *,' REG= IS THE VALUE OF REGISTER TO USE AS POINTER'     SEAR0252\n         MNOTE *,'   IF OMMITTED, THEN 1 IS USED'                       SEAR0253\n         MNOTE *,'   (OTHER SPECIAL REGISTERS MAY NOT BE USED)'         SEAR0254\n         MNOTE *,' NONE=  IS THE ADDR TO BRANCH TO IF NOT FOUND.'   0.1 SEAR0255\n         MNOTE *,'   IT MAY BE RX-TYPE OR REGISTER NOTATION'            SEAR0256\n         MNOTE *,'   IF NOT GIVEN, THEN NOT FOUND WILL FALL THRU'       SEAR0257\n         MNOTE *,' FOUND= IS ADDR TO BRANCH TO WHEN ENTRY EQUALS KEY'   SEAR0258\n         MNOTE *,'   MAY BE RX-TYPE OR REGISTER NOTATION'               SEAR0259\n         MNOTE *,'   IF NOT GIVEN, THEN EQUAL CONDITION WILL FALL THRU' SEAR0260\n         MNOTE *,' KLV= IS VALUE OF KEY LENGTH TO USE FOR COMPARE.'     SEAR0261\n         MNOTE *,' KLA= IS ADDR OF FULLWORD WHICH HAS KEY LENGTH.'      SEAR0262\n         MNOTE *,'   ONE OR THE OTHER MAY BE GIVEN, BUT NOT BOTH.'      SEAR0263\n         MNOTE *,'   EITHER MAY BE RX-TYPE OR REGISTER NOTATION.'       SEAR0264\n         MNOTE *,'   KLV= MAY ALSO BE A NUMBER.'                        SEAR0265\n         MNOTE *,'   ENTRY LENGTH WILL BE USED IF NEITHER GIVEN'        SEAR0266\n         MNOTE *,' KEYOFF= IS THE VALUE TO OFFSET INTO ENTRY BY.'       SEAR0267\n         MNOTE *,'   IT MUST BE AN ABSOLUTE VALUE LESS THAN RECLEN.'    SEAR0268\n         MNOTE *,'   IF NOT GIVEN, ZERO WILL BE ASSUMED'                SEAR0269\n         MNOTE *,'   NOTE THAT IF KEYOFF= IS GIVEN, THEN KEY LENGTH'    SEAR0270\n         MNOTE *,'    MUST ALSO BE GIVEN, SINCE KEYOFF+KEYL<=LENGTH'    SEAR0271\n         MNOTE *,' SEQ= IS THE SEQUENCE THE KEYS ARE IN.'               SEAR0272\n         MNOTE *,'   A IS FOR ASCENDING, D IS FOR DESCENDING.'          SEAR0273\n         MNOTE *,'   IF NOT GIVEN THEN SEQ=A IS ASSUMED.'               SEAR0274\n         MNOTE *,' '                                                    SEAR0275\n         MNOTE *,'NOTES:'                                               SEAR0276\n         MNOTE *,' IF EQUAL KEY IS FOUND THEN THE ADDR WILL BE IN REG'  SEAR0277\n         MNOTE *,'  AND IF FOUND= IS GIVEN THEN BRANCH WILL OCCUR.'     SEAR0278\n         MNOTE *,' IF EQUAL KEY NOT FOUND THEN ADDR OF NEXT HIGHER'     SEAR0279\n         MNOTE *,'  ENTRY WILL BE IN REG, ALTHOUGH IT IS YOUR PROBLEM'  SEAR0280\n         MNOTE *,'  TO MAKE SURE IT ISN''T BEYOND LAST ENTRY.'          SEAR0281\n         MNOTE *,'  WHEN KEY IS NOT FOUND, THE NONE= BRANCH WILL BE'    SEAR0282\n         MNOTE *,'   TAKEN IF GIVEN.'                                   SEAR0283\n         MNOTE *,' EVEN THOUGH YOU CANNOT USE REGISTER'          RKC0.1 SEAR0284\n         MNOTE *,'  NOTATION FOR KEY=, DON''T FORGET THAT THE'   RKC0.1 SEAR0285\n         MNOTE *,'  NORMAL WAY TO GIVE A LOCATION OFF OF A'      RKC0.1 SEAR0286\n         MNOTE *,'  REGISTER IS, FOR EXAMPLE, 0(R2) !'           RKC0.1 SEAR0287\n         MNOTE *,' '\n         MNOTE *,' Registers 0,1,14,15 are always used, 2 can also'\n         MNOTE *,'    be used'\n         MEND                                                           SEAR0288\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGNUDEFD": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x01\\x02O\\x01\\x01\\x13\\x0f\\x13\\x06\\x00A\\x02!\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-01-24T00:00:00", "modifydate": "2001-05-10T13:06:00", "lines": 65, "newlines": 545, "modlines": 0, "user": "SAYB"}, "text": "LGNUDEFD CSECT\nLGNUDEFD AMODE 31\nLGNUDEFD RMODE ANY\n*---------------------------------------------------------------\n* define ISPF/TSO logon proc parameters for users - defaults\n*   for the first letter of a user name.\n*\n* See the other module - LGNUDEF - for exceptions.\n*\n*  Macro defaults:\n*\n*    LOGOFF=YES\n*    CMD='PANEL(xxx@MSTR) NOLOGO', where xxx is set to PFX,\n*         for example, SYS@MSTR.\n*    PFX should be 3 bytes long\n*\n*  Don't worry about inserting entries in order, macro\n*    LGNUDEFP sorts all the entries in ascending order.\n*\n*\n*\n*\n* 01/2001 axb\n*---------------------------------------------------------------\n* Changes:\n*\n* 03/2001 axb  initial default panel is always ISR@PRIM\n*---------------------------------------------------------------\n* 1) define entries for the whole alphabet.\n LGNUDEFN USER=A,PFX=SYS,LOGOFF=N      default cmd\n LGNUDEFN USER=B,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=C,PFX=OPS,LOGOFF=N      default cmd\n LGNUDEFN USER=D,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=E,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=F,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=G,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=H,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=I,PFX=MSD,LOGOFF=Y,     <- logoff user                  *\n               CMD='CMD(%ZZZQMF) NOLOGO'\n LGNUDEFN USER=J,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=K,PFX=MSD,LOGOFF=N      default cmd\n LGNUDEFN USER=L,PFX=MSD,LOGOFF=N      default cmd\n LGNUDEFN USER=M,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=N,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=O,PFX=OPS,LOGOFF=N      default cmd\n LGNUDEFN USER=P,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=Q,PFX=MSD,LOGOFF=N      default cmd\n LGNUDEFN USER=R,PFX=MSD,LOGOFF=N      default cmd\n LGNUDEFN USER=S,PFX=SYS,LOGOFF=N      default cmd\n LGNUDEFN USER=T,PFX=MSD,LOGOFF=N      default cmd\n LGNUDEFN USER=U,PFX=USR,LOGOFF=Y,     <- logoff user                  *\n               CMD='PANEL(ISR@PRIM) OPT(Q) NEWAPPL(ISR) NOLOGO'\n LGNUDEFN USER=V,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=W,PFX=USR,LOGOFF=N      default cmd\n LGNUDEFN USER=X,PFX=MSD,LOGOFF=N      default cmd\n LGNUDEFN USER=Y,PFX=SYS,LOGOFF=N      default cmd\n LGNUDEFN USER=Z,PFX=MSD,LOGOFF=N      default cmd\n*\n*\n* 2) Generate all entries - macro sorts them in ascending order.\n*    header is also created, to be used by the calling module.\n*\n*\n         LGNUDEFP ,\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGNUDEFE": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x01\\x02O\\x01\\x01\\x13\\x0f\\x13\\x08\\x004\\x00\\xae\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-01-24T00:00:00", "modifydate": "2001-05-10T13:08:00", "lines": 52, "newlines": 174, "modlines": 0, "user": "SAYB"}, "text": "LGNUDEFE CSECT\nLGNUDEFE AMODE 31\nLGNUDEFE RMODE ANY\n*---------------------------------------------------------------\n* define ISPF/TSO logon proc parameters for users\n*   exceptions to the 1st letter of a userid.\n*\n*\n*  Macro defaults:\n*\n*    LOGOFF=YES\n*    CMD='PANEL(xxx@MSTR) NOLOGO', where xxx is set to PFX,\n*         for example, SYS@MSTR.\n*    PFX should be 3 bytes long\n*\n*  Don't worry about inserting entries in order, macro\n*    LGNUDEFP sorts all the entries in ascending order.\n*\n*\n*\n*\n* 01/2001 axb\n*---------------------------------------------------------------\n* Changes:\n*\n* 03/2001 axb  initial default panel is always ISR@PRIM\n*---------------------------------------------------------------\n* 1) define all the entries.\n LGNUDEFN USER=IBMUSER,PFX=SYS,LOGOFF=N      default cmd\n*\n LGNUDEFN USER=UUUU,PFX=USR,LOGOFF=Y,                                  *\n               CMD='PANEL(ISR@PRIM) OPT(Q) NEWAPPL(ZZZ) NOLOGO'\n*\n LGNUDEFN USER=CCCC,PFX=OPS,LOGOFF=Y,                                  *\n               CMD='PANEL(ISR@PRIM) NEWAPPL(ISR) NOLOGO'\n*\n* 2) Generate all entries - macro sorts them in ascending order.\n*    header is also created, to be used by the calling module.\n*\n*\n         LGNUDEFP ,\n* --------------------------------------------------------------\n*\n* Misc csects for the calling module - this is just to test macro.\n*\n* LGNUDEFN VART=YES\n*\n* Generate the DSECT to map the table entry - again,\n*  needed only for the calling module - this is just to test macro.\n*\n* LGNUDEFN DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGNUDEFN": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x13\\x0f\\x13\\t\\x00\\x9f\\x00\\x9a\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-05-10T13:09:00", "lines": 159, "newlines": 154, "modlines": 0, "user": "SAYB"}, "text": "         MACRO\n.* ----------------------------------------------------\n.* Generate entries for ISPF/TSO logon proc table\n.*  for Aramark.\n.*\n.*  Macro parms:\n.*    USER        - TSO userid\n.*    PFX         - panels prefix for this userid\n.*                  (3 bytes long, e.g. SYS)\n.*    LOGOFF      - Yes\u00a6No   user will/will not be logged off\n.*                           after exit from ISPF\n.*    CMD         - initial ispf command;\n.*                  ISPSTART cmd is issued after allocations.\n.*\n.*    defaults:\n.*\n.*    LOGOFF=YES\n.*    CMD         - PANEL(xxx@MSTR) NOLOGO, where xxx is\n.*                   a panel prefix. For example, if prefix\n.*                   is set to AXB and CMD not specified,\n.*                   PANEL(AXB@MSTR) NOLOGO is generated as\n.*                   initial ISPF command.\n.*\n.* 01/2001 axb\n.* ----------------------------------------------------\n.* Changes:\n.*\n.* 03/2001 axb   initial panel is always ISR@PRIM\n.* ----------------------------------------------------\n&NM      LGNUDEFN &USER=,&PFX=,&LOGOFF=YES,&CMD=,&DSECT=NO,&VART=NO\n         AIF   ('&DSECT' EQ 'YES').DSECT\n         AIF   ('&VART'  EQ 'YES').VART\n.* gen a bunch of ptrs; LGNUDEFP will fill them up.\n         GBLB  &NFIRST\n         AIF   (&NFIRST).SKIPHDR\n&NFIRST  SETB  1                        not first time\nUDEFHDR  DS    0F        header; is filled up below\n         DS    AL4(0)                   table address\n         DS    AL4(0)                   last entry address\n         DS    AL4(0)                   entry length\n         DS    AL4(0)                   key length\n.SKIPHDR ANOP\n.* make sure nothing is missing.\n         AIF   ('&USER' EQ '').NOUSER\n         AIF   ('&PFX' EQ '').NOPFX\n         AIF   (K'&PFX NE 3).BADPFX\n&OFF     SETC  '0'\n         AIF   ('&LOGOFF' EQ 'N' OR '&LOGOFF' EQ 'NO').JOFF\n&OFF     SETC  '1'\n         AIF   ('&LOGOFF' EQ 'Y' OR '&LOGOFF' EQ 'YES').JOFF\n         AGO   .BADOFF\n.JOFF    ANOP\n.* set a default for the initial command in case CMD parm is\n.*     not used\n.* 0301axb &CMDP    SETC  'PANEL(&PFX.@MSTR) NOLOGO'     default\n&CMDP    SETC  'PANEL(ISR@PRIM) NOLOGO'     default\n         AIF   ('&CMD' EQ '').JCMD\n&CMDP    SETC  '&CMD'\n         AIF   ('&CMDP'(1,1) NE '''').JCMD    leading quotes\n&CMDP    SETC  '&CMDP'(2,K'&CMDP-2)\n.JCMD    ANOP\n.* see if this command has already been declared\n         GBLA  &CMDC           ; count of entries - unique commands\n         GBLC  &CMDE(1)        ; unique commands\n         AIF   (&CMDC EQ 0).NOTYET   first time\n.* search thru defined commands.\n&CNT     SETA  1\n.TOPCMD  ANOP\n&TEMP    SETC  '&CMDE(&CNT)'\n         AIF   ('&TEMP' EQ '&CMDP').SEEN\n&CNT     SETA  &CNT+1\n         AIF   (&CNT LE &CMDC).TOPCMD\n.*\n.* new entry\n.*\n.NOTYET  ANOP\n&CMDC    SETA  &CMDC+1               one more unique command\n&CMDE(&CMDC) SETC '&CMDP'            another global to use\n&LBL     SETC  'CMD&CMDC'            entry label\n&LBLL    SETC  'LCMD&CMDC'           size\n&LBL     DC    AL1(&LBLL),C'&CMDP'   ; unique ISPF command\n&LBLL    EQU   *-&LBL-1              ; command size\n         AGO   .GENENT\n.*\n.* This is not unique entry\n.*\n.SEEN    ANOP\n&LBL     SETC  'CMD&CNT'            point to prev. defined label\n.*\n.GENENT  ANOP\n.* Gen the table entry - add to in-storage globals.\n         GBLA  &OMLC           ; count of entries\n         GBLC  &OMLU(1)        ; users\n         GBLC  &OMLP(1)        ; prefixes\n         GBLC  &OMLL(1)        ; logoff's\n         GBLC  &OMLI(1)        ; initial commands\n&OMLC    SETA  &OMLC+1           incr count of entries\n.* pad the user to be the same size for sort to work.\n&USERN   SETC  '&USER.>>>>>>>'\n&USERN   SETC  '&USERN'(1,7)\n&OMLU(&OMLC) SETC '&USERN'       insert user\n&OMLP(&OMLC) SETC '&PFX'         insert prefix\n&OMLL(&OMLC) SETC '&OFF'         insert logoff\n&OMLI(&OMLC) SETC '&LBL'         insert initial command\n.*\n.* eventually entries are sorted - that's what is created.\n.*\n.*       DC    CL7'&USER'         ; Userid\n.*       DC    CL3'&PFX'          ; Panels prefix\n.*       DC    CL1'&OFF'          ; Logoff\n.*       DC    AL4(&LBL)          ; ptr to initial ispf command\n         MEXIT\n.* -------------------------------------------------------\n.* Generate DSECTs for the module that loops thru the table\n.* -------------------------------------------------------\n.DSECT   ANOP\nDUDEF    DSECT\nDU@USR   DS    CL7                ; Userid\nDU@PFX   DS    CL3                ; Prefix\nDU@OFF   DS    CL1                ; Logoff\nDU@CMD   DS    AL4                ; ptr to Initial ISPF command\nLDUDEF   EQU   *-DUDEF            ; entry size.\n*\nDUVART   DSECT\nDUVARL   DS    AL2                ; var name size\nDUVAR    DS    CL8                ; var name value\nDUVARD   DS    AL2                ; var displacement\nDUVARVL  DS    AL2                ; var size, strip blanks.\nLDUVART  EQU   *-DUVART\n         MEXIT\n.* -------------------------------------------------------\n.* Generate REXX vars table - same module\n.* -------------------------------------------------------\n.VART    ANOP\nUVARTCNT DS    0H\n         DC    AL2(UVARCNT)       ; that many rexx vars to set\nUVART  DC AL2(6),CL8'DU@USR',AL2(DU@USR-DUDEF),AL2(L'DU@USR)\nUVARTSZ  EQU   *-UVART            see LDUVART in dsect\n       DC AL2(6),CL8'DU@PFX',AL2(DU@PFX-DUDEF),AL2(L'DU@PFX)\n       DC AL2(6),CL8'DU@OFF',AL2(DU@OFF-DUDEF),AL2(L'DU@OFF)\n       DC AL2(6),CL8'DU@CMD',AL2(DU@CMD-DUDEF),AL2(0)\nUVARCNT  EQU   (*-UVART)/UVARTSZ   that many rexx vars to set\n         MEXIT\n.*\n.* Error messages\n.*\n.NOUSER ANOP\n MNOTE 12,'UDEF001E User is not specified'\n         MEXIT\n.NOPFX  ANOP\n MNOTE 12,'UDEF002E Prefix is not specified'\n         MEXIT\n.BADPFX ANOP\n MNOTE 12,'UDEF003E Prefix is not correct, should be 3 bytes long'\n         MEXIT\n.BADOFF ANOP\n MNOTE 12,'UDEF004E Logoff parm should be either YES, Y, NO or N'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LGNUDEFP": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x13\\x0f\\x13\\x15\\x00\\x98\\x00\\x94\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-05-10T13:15:00", "lines": 152, "newlines": 148, "modlines": 0, "user": "SAYB"}, "text": "         MACRO\n&NM      LGNUDEFP\n.* -------------------------------------------------------\n.* Sort all the entries defined previously by UDEFN macro\n.*   and generate an assembler table.\n.*\n.* Bubble sort is used, performance is not a consideration.\n.*\n.* This is REXX code for reference:\n.*\n.*   srtflg = 1\n.*   lstsz = omlu.0\n.*   do while srtflg = 1\n.*      srtflg = 0\n.*       do i = 1 to lstsz - 1\n.*             j = i +1\n.*             if omlu.i > omlu.j then\n.*                  do\n.*                     srtflg = 1\n.*                     temp = omlu.j\n.*                     omlu.j = omlu.i\n.*                     omlu.i = temp\n.*                  end /* do */\n.*       end i /* do */\n.*        lstsz = lstsz - 1\n.*   end /* do */\n.*\n.* Note that duplicate entries are not accepted.\n.*\n.* 01/2001 axb\n.*\n.* Note that if you defined too many entries,\n.*  ACTR needs to be adjusted.\n.*\n.* -------------------------------------------------------\n         GBLA  &OMLC              count of entries\n         GBLC  &OMLU(1)           users\n         GBLC  &OMLP(1)           prefixes\n         GBLC  &OMLL(1)           logoff's\n         GBLC  &OMLI(1)           initial ispf commands\n.*\n         AIF   ('&OMLC' EQ '0').ORDER\n.*\n.* Sort the entries by userid - simple bubble sort\n.*   some changes from REXX - dont use DO ... END constructs\n.*\n.*\n&SRTFLG  SETB  1\n&LSTSZ   SETA  &OMLC\n.LAB1    ANOP\n         AIF   (NOT &SRTFLG).OUT\n&SRTFLG  SETB  0\n&I       SETA  1\n.LAB2    ANOP\n&J       SETA  &I+1\n         AIF   ('&OMLU(&I)' LT '&OMLU(&J)').LAB2E\n         AIF   ('&OMLU(&I)' EQ '&OMLU(&J)').DUP\n&SRTFLG  SETB  1\n.*\n.* swap the elements - start\n.*\n.* -> user\n&TEMP    SETC  '&OMLU(&J)'\n&OMLU(&J) SETC '&OMLU(&I)'\n&OMLU(&I) SETC '&TEMP'\n.* -> prefix\n&TEMP    SETC  '&OMLP(&J)'\n&OMLP(&J) SETC '&OMLP(&I)'\n&OMLP(&I) SETC '&TEMP'\n.* -> logoff\n&TEMP    SETC  '&OMLL(&J)'\n&OMLL(&J) SETC '&OMLL(&I)'\n&OMLL(&I) SETC '&TEMP'\n.* -> ispf\n&TEMP    SETC  '&OMLI(&J)'\n&OMLI(&J) SETC '&OMLI(&I)'\n&OMLI(&I) SETC '&TEMP'\n.*\n.* swap the elements - end\n.*\n.*\n.LAB2E   ANOP\n&I       SETA  &I+1\n&LST2    SETA  &LSTSZ-1\n         AIF   (&I LE &LST2).LAB2\n&LSTSZ   SETA  &LSTSZ-1\n         AGO   .LAB1\n\n.*\n.* done sorting. Create Header.\n.*\n.OUT     ANOP\n         ORG   UDEFHDR                  ; beginning of module\n         DC    AL4(TAB@1)               ; table address\n         DC    AL4(TAB@&OMLC)           ; last entry address\n         DC    AL4(7+3+1+4)             ; lentry length\n         DC    AL4(7)                   ; key length\n         ORG   ,                        ; back to entries\n.*\n.* Generate all entries\n.*\n&CNT     SETA  1\n\n.GENLOOP ANOP\n&USR     SETC  '&OMLU(&CNT)'      user\n&PFX     SETC  '&OMLP(&CNT)'      prefix\n&OFF     SETC  '&OMLL(&CNT)'      logoff\n&CMD     SETC  '&OMLI(&CNT)'      ispf command\n.*\n.* Remove the pad from a user entry (added for sort)\n.*\n&LAST    SETA  K'&USR\n.PAD1    ANOP\n&TMP     SETC  '&USR'(&LAST,1)\n         AIF   ('&TMP' NE  '>').BPAD\n&LAST    SETA  &LAST-1\n         AGO   .PAD1\n.BPAD    ANOP\n&USRT    SETC  '&USR'(1,&LAST)\n.*\n.*\nTAB@&CNT DC    CL7'&USRT'         ; User\n         DC    CL3'&PFX'          ; prefix\n         DC    CL1'&OFF'          ; logoff\n         DC    AL4(&CMD)          ; ptr to ispf command\n.*\n&CNT     SETA  &CNT+1\n         AIF   (&CNT LE &OMLC).GENLOOP\n.*\n         MEXIT\n.*\n.* Error messages\n.*\n.ORDER   ANOP\n MNOTE 12,'UDEFP001E Count is zero - no entries'\n         MEXIT\n.DUP     ANOP\n&USR     SETC  '&OMLU(&I)'      user\n.*\n.* Remove the pad from a user entry (added for sort)\n.*\n&LAST    SETA  K'&USR\n.PAD2    ANOP\n&TMP     SETC  '&USR'(&LAST,1)\n         AIF   ('&TMP' NE  '>').BPAD2\n&LAST    SETA  &LAST-1\n         AGO   .PAD2\n.BPAD2   ANOP\n&USRT    SETC  '&USR'(1,&LAST)\n MNOTE 12,'UDEFP002E Duplicate macro for user &USRT'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RLTPLST": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x02?\\x12\\t\\x00&\\x00&\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-01-23T12:09:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SAYB"}, "text": "         MACRO\n&NAME    RLTPLST &DSECT=\n.*\n.* Define plist to call RLTSUB in the calling program as well\n.* as a DSECT in the RLTSUB to map the plist.\n.*\n.* 06/95 axb\n.*\n         AIF   ('&DSECT' NE 'YES').NODSECT\nRLTPLST  DSECT\n         AGO   .COMMON\n.NODSECT ANOP\n&NAME    DS    0F\n.COMMON  ANOP\nRLTPLST_SAVEAREA DS 18F           ; Save area for RLTSUB\nRESULT   DS    F                  ; address of result, in a format\n*                                 ; AL4(LENGTH), C'RESULT_DATA'\nEVB      DS    F                  ; EVALBLOCK address.\nENV      DS    F                  ; Saved address of ENVIRONMENT BLOCK\n*.\n*. IRXRLT plist\n*.\nRLTPL    DS    0D                 ; IRXRLT plist for getting EVALBLOCK\nRLTPL1   DS    F                  ; Points to CL8'GETBLOCK'\nRLTPL2   DS    F                  ; Points to EVALBLOCK address\n*                                 ; ...to be returned, A(RLTA2)\nRLTPL3   DS    F                  ; Points to the length of a data\n*                                 ; ...area in the requested EVALBLOCK,\n*                                 ; ...A(RLTA3)\n         ORG   RLTPL3\n         DC    X'80',AL3(0)       ; Last parameter, set in program\n         ORG   ,\n*\nRLTA2    DS    F                  ; 0 on entry; EVALBLOCK address\n*                                 ; ... returned\nRLTA3    DS    F                  ; Length of data for new EVALBLOCK\n*                                 ; ... set by the program\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RLTSUB": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x02?\\x01\\x01\\x02?\\x12\\t\\x00\\xa4\\x00\\xa4\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-23T00:00:00", "modifydate": "2001-01-23T12:09:00", "lines": 164, "newlines": 164, "modlines": 0, "user": "SAYB"}, "text": "RLTSUB      TITLE 'Move result into EVALBLOCK'\nRLTSUB      AMODE 31\nRLTSUB      RMODE ANY\n*----------------------------------------------------------------------\n* This s/routine is called with address of plist in r1.\n* (look at RLTPLST macro for details).\n*\n* First IRXRLT is called with GETBLOCK function to request\n* the EVALBLOK of the appropriate size. After that, result data\n* is moved into the EVALBLOK. REXX kernel will take care of setting\n* the result variable.\n*\n*\n*06/95 Alex Brodsky\n*----------------------------------------------------------------------\nRLTSUB      CSECT\n         USING RLTSUB,R15            ; Address program\n         SAVE  (14,12),,RLTSUB.ALEX.BRODSKY.&SYSDATE.&SYSTIME\n         LR    R12,R15            ; Set program base\n         DROP  R15\n         USING RLTSUB,R12         ; Address program\n         LR    R9,R1              ; Get the plist address\n         USING RLTPLST,R9         ; Plist for the program\n* chain saveareas\n         LA    R1,RLTPLST_SAVEAREA ; Plist savearea address\n         ST    R1,8(R13)          ; ... chain\n         ST    R13,4(R1)          ; ... ... save\n         LR    R13,R1             ; ... ... ... areas\n* chain saveareas\n*--------------------------------------------------------------------*\n* Initialize IRXRLT plist.\n*  We may need to use it if data to be returned will not fit into\n*  (REXX) preallocated EVALBLOK\n*  Note that unlike VM, REXX pre-allocates a small EVALBLOK\n*  for use, and if size of it is not enough, IRXRLT should be called.\n*  The size of a preallocated EVALBLOK is stored in the\n*  EVALBLOCK_EVSIZE (in dwords). The available area for result\n*  has a length of EVSIZE*8-16.\n*  REXX documents the size of data area in the EVALBLOK as 250 bytes.\n*\n*--------------------------------------------------------------------*\n         LA    R2,KCGETB          ; Plist identifier\n         ST    R2,RLTPL1          ; Save the address\n         LA    R2,RLTA2           ; Get the unused parameter\n         ST    R2,RLTPL2          ; ... address in the plist\n*                                 ; ... where EVALBLOCK address\n*                                 ; ... will be returned\n         XC    RLTA2(4),RLTA2     ; Not used for GETBLOCK function\n         LA    R2,RLTA3           ; Get the address of length\n         ST    R2,RLTPL3          ; and save in the plist\n         OI    RLTPL3,X'80'       ; Last parameter there\n*.\n         L     R15,EVB    ; GET THE ADDR OF EVALBLOCK ADDRESS\n         L     R15,0(,R15)        ; GET THE EVALBLOCK ADDRESS\n         USING EVALBLOCK,R15      ; TELL ASSEMBLER\n         L     R14,EVALBLOCK_EVSIZE ; FIGURE OUT\n         SLL   R14,3              ; ... AVAILABLE AREA\n         S     R14,=F'16'         ; ... MINUS PREFIX SIZE\n*\n         L     R3,RESULT          ; POINT TO RESULT THING\n         LA    R2,0(,R3)          ; GET THE LENGTH ADDRESS\n         L     R2,0(,R3)          ; GET THE LENGTH\n         ST    R2,RLTA3           ; SAVE IN IRXRLT PARM\n*.\n*. SEE IF WE HAVE ENOUGH STORAGE FOR RESULT DATA.\n*. R14 - AVAILABLE IN THE EVALBLOCK\n*.\n         CR    R14,R2             ; DO WE HAVE ENOUGH?\n         BNL   EXIT1              ; YES, SKIP IRXRLT CALL.\n*.\n*. PREALLOCATED EVALBLOCK IS NOT LARGE ENOUGH TO RETURN THE\n*. RESULT. WE NEED TO CALL IRXRLT TO ALLOCATE A NEW EVALBLOCK\n*.\n*\n* GET THE ADDRESS OF IRXRLT FROM IRXEXTE\n*\n         L     R1,ENV             ; ENVBLOCK ADDRESS\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R1) ; IRXEXTE ADDRESS\n         USING IRXEXTE,R1         ; TELL ASSEMBLER\n         L     R15,IRXRLT         ; RESULT ROUTINE\n         DROP  R1\n*\n         L     R0,ENV             ; OPTIONAL ENVIRONMENT BLOCK\n         LR    R5,R0\n         LA    R1,RLTPL           ; IRXRLT PLIST\n         BALR  R14,R15            ; CALL IT\n***      LINK  EP=IRXRLT,MF=(E,RLTPL) ; CALL IT\n*\n*\n* NOW WE HAVE TO SAVE THE RETURNED ADDRESS.\n*\n         L     R15,EVB            ; ADDRESS OF EVALBLOCK ADDRESS\n         MVC   0(4,R15),RLTA2     ; ADDRESS RETURNED HERE.\n         L     R15,0(,R15)        ; NOW EVALBLOCK ADDRESS\n*\n* MOVE THE DATA INTO EVALBLOCK.\n*\n         ST    R2,EVALBLOCK_EVLEN ; SAVE THE DATA LENGTH\n         LA    R6,EVALBLOCK_EVDATA ; TO: ADDRESS\n         LR    R7,R2              ; TO: LENGTH\n         LA    R4,4(,R3)          ; FROM: ADDRESS\n         LR    R5,R2              ; FROM: LENGTH\n         MVCL  R6,R4              ; MOVE THE DATA\n         B     EXIT0              ; DONE.\n*\n* HERE IF PREALLOCATED EVALBLOCK IS LARGE ENOUGH.\n*  THE NEXT 3 INSTRUCTIONS ARE JUST IN CASE BECAUSE IT IS\n*  DOCUMENTED THAT PREALLOCATED EVALBLOCK HAS 250 BYTES AVAILABLE\n*  FOR DATA TO BE RETURNED.\n*\nEXIT1    DS    0H\n         C     R2,=F'255'         ; MORE THAN MVC CAN HANDLE?\n         BNH   *+8                ; NO\n         LA    R2,255             ; CUT THE MESSAGE SHORT.\n         ST    R2,EVALBLOCK_EVLEN ; SAVE THE DATA LENGTH\n         BCT   R2,*+10            ; MOVE THE DATA\n         MVC   EVALBLOCK_EVDATA(0),4(R3) ; *** EXECUTED ***\n         EX    R2,*-6             ; ... INTO EVALBLOCK\n         DROP  R15                ; EVALBLOCK\n*\n* Return to caller. REXX will eventually set result.\n*\nEXIT0    DS    0H\n         L     R13,4(,R13)        ; Previous save area\n         RETURN (14,12),RC=0\n*--------------------------------------------------------------------*\n*     CONSTANTS\n*--------------------------------------------------------------------*\nKCGETB   DC    CL8'GETBLOCK'      ; NEED FOR IRXRLT CALL.\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n         RLTPLST DSECT=YES\n         SPACE 2\n         PRINT ON\nR0       EQU   0\nR1       EQU   1    RLTPLST address passed by caller\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9    RLTPLST base\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12   BASE\nR13      EQU   13   Savearea\nR14      EQU   14\nR15      EQU   15\n*\n*--------------------------------------------------------------------*\n* REXX MACROS.\n*--------------------------------------------------------------------*\n         PRINT OFF,NOGEN\n         IRXENVB                  ; ENVIRONMENT BLOCK (R0 ON ENTRY)\n         IRXEFPL DSECT=YES        ; EXTERNAL FUNCTION PLIST (R1)\n         IRXARGTB                 ; MAP THE ARGUMENT LIST.\n         IRXEVALB                 ; EVALBLOCK TO RETURN RESULT.\n         IRXEXTE                  ; EXTERNAL ENTRY POINTS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXDEQ": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x10\\x0f\\x01\\x01\\x13\\x0f\\x13\\x19\\x02Z\\x02\\x90\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-04-10T00:00:00", "modifydate": "2001-05-10T13:19:00", "lines": 602, "newlines": 656, "modlines": 0, "user": "SAYB"}, "text": "RXDEQ       TITLE 'Issue DEQ from REXX for a single resource'\nRXDEQ       AMODE 31\nRXDEQ       RMODE ANY\n*----------------------------------------------------------------------\n* When called as an external rexx subroutine this program will\n*  issue DEQ for a specified (single) resource.\n*  *** it is practically the same as RXENQ program ***\n*\n*\n* Multiple resource specification (as in DEQ macro) is not supported.\n*  Also UCB-related parameters are not supported.\n*\n*\n*   R15 is always set to 0; if arguments are missing or\n*      something equally ugly happened, it is set to 1,\n*      therefore exec terminates;\n*\n*   Result is set to a return code from DEQ macro.\n*\n*   Parameters:\n*      1st - qname, truncated or padded to 8 bytes (major name).\n*            *** no defaults ***\n*      2nd - rname (minor name). from 1 to 255 chars long, taken as\n*            supplied. leading/trailing blanks are not removed.\n*            *** no defaults ***\n*      3rd - either of the three:\n*              STEP    - address space scope\n*              SYSTEM  - more than one address space scope\n*              SYSTEMS - more than one system        scope\n*            *** STEP is a default ***\n*      4th - either of the five:\n*              RET=HAVE   - conditional control\n*              RET=NONE   - unconditional request, note that will\n*                           abend if not satisfied. x'130', I think\n*            *** RET=NONE is a default as in DEQ macro ***\n*      5th - either of the two:\n*              RNL=YES\n*              RNL=NO\n*            *** RNL=YES is a default as in DEQ macro ***\n*\n*   Examples:\n*    result = RXDEQ('XXXCMD','XXXCMD','SYSTEMS','RET=HAVE');\n*   As is customary in rexx, optional arguments can be omitted,\n*    for example:\n*    result = RXDEQ('XXXCMD','XXXCMD',,'RET=HAVE');\n* this results in scope being STEP (default).\n*\n* Note that this function can be used standalone as well as a part\n* of rexx function package\n*\n* Also note that DEQ plist is hand-built and only single resource\n*  is supported.\n*\n* Parameters for DEQ must match exactly with parameters for\n*  corresponding ENQ macro.\n*\n* Flag bits specification (non-auth form of macro),\n*  (determined after assembly of misc macros)\n*\n* PELFLG2:\n*    x'80'       - last arg specification\n*    x'40'       - rnl=yes    makes it x'c0' = 192\n*    x'04'       - rnl=no     makes it x'84' = 132\n*\n* PELFLAG:\n*    x'40'       - SYSTEM\n*    x'48'       - SYSTEMS\n*    x'01'       - HAVE\n*\n*\n*04/2001 Alex Brodsky\n*----------------------------------------------------------------------\nRXDEQ    LGN@ENT   CSECT\n*already LM    R0,R1,20(R1)       ; Restore ENVB and EFPL pointers\n         ST    R0,ENV             ; Save it for calls to rexx services\n         SPACE 3\nSTART    DS    0H\n         LR    R9,R1              ; Get the EFPL address\n         USING EFPL,R9            ; Extended function plist\n*------------------------------------------------------\n* Get the address of IRXEXCOM and IRXSAY from IRXEXTE\n*------------------------------------------------------\n         L     R1,ENV             ; ENVBLOCK address\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R1) ; IRXEXTE address\n         USING IRXEXTE,R1         ; Tell assembler\n         MVC   ZZZEXCOM(4),IRXEXCOM ; Var access routine\n         MVC   ZZZSAY(4),IRXSAY     ; say routine\n         DROP  R1\n         SPACE 3\n*--------------------------------------------------------------------*\n* Initialize all the necessary plists.\n*--------------------------------------------------------------------*\n*. Init the EVALBLOK.\n*.  Move an address of a result string in the\n*.   RESULT variable.\n*.  RLTSUB routine code will set the RESULT with whatever\n*.   is pointed to by 'RESULT' variable\n*.\n         L     R2,EFPLEVAL        ; Get the EVALBLOCK address\n         ST    R2,EVB             ; Save it for exit routine.\n         MVC   KCOTH(LKCOK),KCOK  ; Init the retcode result\n         LA    R2,KCOTH           ; Point to retcode from WTO\n         ST    R2,RESULT          ; ...\n*\n         mvc   qname(8),blanks    ; init qname\n\n*--------------------------------------------------------------------*\n* Now look at arguments passed by the caller.\n*  If argument is not supploed (pointer is zero) or\n*  missing entirely (we hit the fence, 8X'FF'), we will issue\n*  a message and exit this function.\n*--------------------------------------------------------------------*\n         L     R4,EFPLARG         ; Pointer to arguments\n         USING ARGTABLE_ENTRY,R4  ; Map the entry\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    bad_qname          ; No arguments.\n* ARG 1 - qname. must be present and no more than 8 bytes\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   bad_qname          ; Wrong!\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   bad_qname          ; Wrong!\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n*\n         C     R3,=F'8'           ; cannot be more\n         BH    bad_qname          ; terminate exec\n         L     R2,AP              ; get qname address\n         BCT   R3,*+10            ; --copy qname------+\n         MVC   qname(0),0(R2)     ; *** executed ***  |\n         EX    R3,*-6             ; <-----------------+\n* qname address in plist\n         LA    R0,qname\n         st    r0,aqname          ; save in deq plist\n***\n* ARG 2 - rname. must be present and no more than 255 bytes\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    bad_rname          ; No argument(s)\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   bad_rname          ; Wrong!\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   bad_rname          ; Wrong!\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n*\n         C     R3,=F'255'         ; cannot be more\n         BH    bad_rname          ; terminate exec\n         stc   r3,PELMILEN        ; else save in deq plist\n         L     R2,AP              ; get rname address\n         BCT   R3,*+10            ; --copy rname------+\n         MVC   rname(0),0(R2)     ; *** executed ***  |\n         EX    R3,*-6             ; <-----------------+\n* rname address in plist\n         LA    R0,rname\n         st    r0,arname          ; save in deq plist\n***\n***\n*** other args can be defaulted.\n***  set plist to use same defaults as DEQ macro.\n***    STEP              no flags\n***    RET=NONE          no flags\n***    RNL=YES\n         MVI   PELFLG2,192        ; rnl=yes, last arg list.\n***\n***\n         SPACE 2\n         LA    R5,3               ; 3 more args\n* ARG 3-5 - Can be either STEP/SYSTEM/SYSTEMS/RET=whatever/RNL=\ntest_next_arg ds 0h\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    issue_deq          ; Use default for others\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   jna                ; Appears missing, check next\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   jna                ; Appears missing, check next\n         ST    R3,LP              ; Save the length\n         BAL   R7,process_parm    ; look at it\n         BNZ   bad_other          ; error\njna      LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n         BCT   R5,test_next_arg   ; and look at it.\n**\n         DROP  R4                 ; ARGTABLE_ENTRY\n         DROP  R9                 ; EFPL\n*=================================================================\nissue_deq ds 0H\n         DEQ   MF=(E,DEQ_PL)\n         LTR   R15,R15\n         BZ    EXIT               ; no errors, exit to caller\n** multiple args are not supported\n         SLR   R1,R1              ; Prepare\n         IC    R1,3(,R15)         ; get the retcode (RELRET?)\n** convert retcode to printable and set rc variable.\ncvtretcode  ds    0h\n         LA    R0,16              ; max size\n         BAL   R8,CVTBDS          ; convert to printable\n         B     EXIT\n         EJECT\n*--------------------------------\n* Process the parm\n*  AP  - parm address\n*  LP  - parm length\n*  R7  - linkage register\n*\n*--------------------------------\nprocess_parm ds 0H\n         stm   r0,r14,save_process_parm\n         lm    r5,r6,lp            ; parm length and address\n*\n         LTR   R5,R5              ; Get length of the field\n         BZ    pp_end_nok         ; Invalid size\n*\n* Uppercase the parm.\n*\n         BCT   R5,*+10            ; ----->-------------+\n         TR    0(0,R6),UPPER      ; *** executed ***   |\n         EX    R5,*-6             ; <------------------+\n         LA    R5,1(,R5)          ; restore r5\n*\n         LA    R1,parmtab\n         using pt,r1              ; map the entry\nploop    ds    0H\n         icm   r2,B'1100',ptks    ; kwrd  size\n         BZ    pp_end_nok         ; last entry, bad keyword\n         SRL   r2,16              ; into low order bytes\n         cr    r5,r2              ; should be exact size there\n         bne   ploop_next         ; no. get next parmtab entry\n         BCT   r2,*+10            ; --lookup in table--+\n         CLC   0(0,R6),ptval      ; *** executed ***   |\n         ex    R2,*-6             ; <------------------+\n         be    kwrd_found         ; found this keyword\nploop_next ds  0H\n         la    r1,ptel(,R1)\n         B     ploop              ; keep searching the table\n*\nkwrd_found ds 0H\n         ICM   r15,B'1111',ptpr    ; routine address\n         Balr  r14,r15            ; call it\n         bz    pp_end_ok\npp_end_nok ds 0h\n         Cli  *,x'93'              ; cc .ne. 0\n         b   pp_end               ; and leave\npp_end_ok ds 0h\n         cli  *,x'95'              ; cc=0\npp_end   ds   0H\n         lm    r0,r14,save_process_parm\n         br    r7                  ; back to caller\n         drop  r1                 ; un_map the entry\n*---------------------------------------\n* Processing routines for each keyword\n*\n*  r1 = table entry for the parm\n*\n*  r14 - linkage\n*\n*---------------------------------------\np_scope ds 0h\np_ret   equ p_scope\np_rnl   equ p_scope\n         stm    r0,r14,save_psp\n         using pt,r1              ; map the entry\n*\n* see if dupl parm\n*   I think there is a new instr to do that.\n*\n*\n         slr   r3,r3              ; prepare\n         ic    r3,ptseq\n\n         b     *+8\n         tm    dupparm,x'00'\n         ex    r3,*-4\n         bo    ps_nok              ; duplicate parm\n\n         ic    r3,ptseq+1\n         b     *+8\n         tm    dupparm+1,x'00'\n         ex    r3,*-4\n         bo    ps_nok              ; duplicate parm\nps_u     ds     0h                 ; unique parm\n         clc    ptval(3),=cl3'RNL' ; rnl processing?\n         bne    ps_not_rnl         ; no, set flag\n         mvc    pelflg2(1),ptpfc   ; for rnl set pelflg2 flag.\n         b     ps_ok\nps_not_rnl ds 0h\n         ic    r3,ptpfc            ; flag value\n         b     *+8\n         oi    pelflag,x'00'\n         ex    R3,*-4              ; set the flag in deq plist\n         b     ps_ok\nps_ok    cli    *,x'95'            ; set cc .eq. 0\n         lm     r0,r14,save_psp\n         br     r14\nps_nok   cli    *,x'93'            ; set cc .ne. 0\n         lm     r0,r14,save_psp\n         br     r14\n         drop  r1                 ; un_map the entry\n         SPACE  3\n********************************************\n* Parms table:\n*  al2   keyword size\n*  al4   processing routine address\n*  al2   flag offset in plist\n*  al1   flag value\n*  al2   value flag for duplicates test\n*  cl12  keyword\n*\n********************************************\nparmtab  ds    0H\n dc al2(4),al4(p_scope)\n DC al2(PELFLAG-DEQ_PL),AL1(@STEP),XL2'8000',CL12'STEP'\n*\n dc al2(6),al4(p_scope)\n dc al2(PELFLAG-DEQ_PL),AL1(@SYSTEM),XL2'4000',CL12'SYSTEM'\n*\n dc al2(7),al4(p_scope)\n dc al2(PELFLAG-DEQ_PL),AL1(@SYSTEMS),XL2'2000',CL12'SYSTEMS'\n*\n dc al2(8),al4(p_ret)\n dc al2(PELFLAG-DEQ_PL),AL1(@HAVE),XL2'0800',CL12'RET=HAVE'\n*\n dc al2(8),al4(p_ret)\n dc al2(PELFLAG-DEQ_PL),AL1(@NONE),XL2'0100',CL12'RET=NONE'\n*\n dc al2(7),al4(p_rnl)\n dc al2(PELFLG2-DEQ_PL),AL1(192),XL2'0080',CL12'RNL=YES'\n*\n dc al2(6),al4(p_rnl)\n dc al2(PELFLG2-DEQ_PL),AL1(132),XL2'0040',CL12'RNL=NO'\n         dc    al2(0)                ; last entry\n         EJECT ,\n*--------------------------------------------------------------------*\n* Incorrect call - arguments missing or wrong.\n*--------------------------------------------------------------------*\nbad_qname DS   0H\n         LA    R1,ERM001          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nbad_rname DS   0H\n         LA    R1,ERM002          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nbad_other   ds 0H\n         LA    R1,ERM004          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nINCORARGS DS   0H\n         BAL   R14,issue_error    ; ...\n**       MVI   KCOTH+4,C'8'       ; rc=8\n         MVC   RETCODE(4),=F'1'   ; terminate the exec.\n         B     EXIT               ; Return to caller.\n         SPACE 2\n************************************************\n* issue error message\n*  R1 - error message address\n*    first 4 bytes of the message is text size.\n************************************************\nissue_error ds 0h\n        stm  r0,r15,save_say\n\n* set up irxsay plist\n         LA    R2,KCWRITEERR      ; -> CL8'WRITEERR'\n         ST    R2,saywr           ; 1st parm\n         la    r2,astring\n         st    r2,saystra         ; 2nd parm\n         la    r2,lstring\n         st    r2,saystrl         ; 3rd parm\n         oi    saystrl,x'80'      ; is the last parm\n\n         ICM   R0,B'1111',0(R1)   ; size is 1st 4 bytes\n         LA    R1,4(,R1)          ; position at text\n\n         st    r1,astring         ; build error message address\n         st    r0,lstring         ; build error message size\n\n         L     R0,ENV             ; Optional environment block address\n         LA    R1,say             ; IRXSAY plist\n         L     R15,ZZZSAY         ; Saved address\n         BALR  R14,R15            ; Go there\n*\n         lm   r0,r15,save_say\n         br   r14                 ; back to caller\n*--------------------------------------------------------------------\n* Convert to printable dec, remove leading blanks after conversion.\n*   R1 - value to convert\n*   R0 - output size\n*--------------------------------------------------------------------\nCVTBDS   DS    0H\n         LR    R15,R0              ; Size\n         IC    R3,=C' '            ; sign if positive or 0\n         LTR   R1,R1               ; is it?\n         BNM   CVTBDS_01            ; yes\n         LPR   R1,R1               ; make positive\n         IC    R3,=C'-'            ; sign if negative\nCVTBDS_01 DS    0H\n         CVD   R1,DWORD            ; -> decimal\n         MVC   DECCVT(L'PATTERN),PATTERN  ; Init\n         LA  R1,DECCVT+L'PATTERN-1  ; First byte after sign. starter\n*                                   ; ... (last byte of pattern)\n         EDMK  DECCVT(L'PATTERN),DWORD ; convert to printable\n         CLM   R3,B'0001',=C'-'\n         BNE   CVTBDS_02\n         BCTR  R1,0                ; byte before first non-zero\n         STC   R3,0(R1)            ; sign in front\nCVTBDS_02 DS    0H\n* Now we move all specified data to common area, can be truncated\n         C     R15,=F'16'          ; over the max?\n         BNH   *+8\n         LA    R15,16\n*\n* Compute the data size\n*\n         LA    R3,DECCVT+L'PATTERN ; Byte after last\n         SR    R3,R1               ; Converted data size\n*\n         CR    R15,R3              ; Requested less than converted?\n         BNH   *+6\n         LR    R15,R3\n*\n         ST    R15,CVTOUT          ; Save size\n*\n         BCT   R15,*+10\n         MVC   CVTOUT+4(0),0(R1)   ; *** executed ***\n         EX    R15,*-6             ; Move and trunc from the left\n*\n         BR    R8                  ; Done\n         SPACE 3\n*\n*\n*--------------------------------------------------------------------*\n*                    EXIT\n*--------------------------------------------------------------------*\nEXIT     DS    0H\n*\n* Allocate EVALBLOCK if needed and move the result data there\n*\n         LA    R1,RLTSUB$         ; RLTSUB plist\n         L     R15,=V(RLTSUB)     ; Routine address\n         BALR  R14,R15            ; Call it\n*\n* Rexx will set the result.\n*\nEXIT0    LGN@RET RC=RETCODE       ; Return code\n         EJECT ,\n*--------------------------------------------------------------------*\n*     CONSTANTS AND WORK AREAS\n*--------------------------------------------------------------------*\nKCEXCOM  DC    CL8'IRXEXCOM'      ; Need for the call to IRXEXCOM\nKCWRITEERR DC  CL8'WRITEERR'      ; For IRXSAY\nblanks   dc    cl80' '              ; handy\nKCOK     DC    AL4(KCOKE-KCOK-4)    ; Result length\n         DC    X'F0'                ; C'0'\nKCOKE    EQU   *\nLKCOK    EQU   *-KCOK\n*\nEDMASK   DC    X'2020202020202021'\n*\nXFFS     DC    X'FFFFFFFF'       ; to test for args\n*\n* Error messages\n*\nERM001 DC AL4(LERM001),C'RXDEQ001E Incorrect or missing qname'\nLERM001 EQU *-ERM001-4\n*\nERM002 DC AL4(LERM002),C'RXDEQ002E Incorrect or missing rname'\nLERM002 EQU *-ERM002-4\n*\nERM004 DC AL4(LERM004)\n DC C'RXDEQ004E Either scope, request or RNL parm is incorrect'\nLERM004 EQU *-ERM004-4\n*\n* Translate to uppercase\n*\n         DS    0D\nUPPER    DC    256AL1(*-UPPER)\n         ORG   UPPER+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPPER+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPPER+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         DS    0D\nPATTERN  DC    CL16' '\n         ORG   PATTERN\n         DC    X'40',13X'20'\nPSS      DC    X'2120'                 ; signif. starter\n         ORG   ,\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n*\n* WORKAREA DSECT. R13 points to it.\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                ; Registers save area\nRETCODE  DS    F                  ; Retcode - 0\nsave_process_parm ds 16f          ; save area for process_parm\nsave_psp          ds 16f          ; subparm save area\nsave_say          ds 16f\ndword    ds    d                  ; work area for conversion\ncvtchar  ds    cl8                ; and to printable\ndupparm  ds    xl2                ; duplicate parm flag\nDECCVT   DS    CL16               ; Area for dec conversions\n*\n* Plist to call RLTSUB\n*\nRLTSUB$  RLTPLST DSECT=NO\n*\n* Do not change the order of the next 2 fields.\n*\nLP       DS    F                  ; Length of parameter\nAP       DS    F                  ; Address of parameter\n*\n* This is a return value (RC or RETCODE) for this function.\n*  supposed to be up to 8.\n*\n*\nKCOTH    DS    F                  ; size\n         DS    XL16               ; Retcode, printable.\nCVTOUT   EQU   KCOTH\n*\n* DEQ flags definition for the flag 2.\n*\n@STEP    EQU   0                  ; STEP    specified\n@SYSTEM  EQU   X'40'              ; SYSTEM  is specified\n@SYSTEMS EQU   (X'40'+X'08')      ; SYSTEMS is specified\n@HAVE    EQU   X'01'              ; RET=HAVE\n@NONE    EQU   0                  ; RET=NONE\n\n**************************************************\n* DEQ macro plist  - similar to ENQ\n**************************************************\nDEQ_PL   DS    0F\nPELFLG2  DS    AL1(0)             ; flag\nPELMILEN DS    AL1(0)             ; rname length\nPELFLAG  DS    AL1(0)             ; flag 2\nPELRET   DS    AL1(0)             ; return code byte\nAQNAME   DS    A(0)               ; qname address\nARNAME   DS    A(0)               ; rname address\n*\nQNAME    DS    CL8                ; place for qname\nRNAME    DS    CL255              ; place for rname\nzzzexcom ds    f                  ; irxexcom address from irxexte\nzzzsay   ds    f                  ; irxsay   address from irxexte\n*\n* irxexcom  plist\n*\nEXCOM    DS    0D                 ; IRXEXCOM plist\nEXCOMP1  DS    F                  ; Points to cl8'IRXEXCOM'\nEXCOMP2  DS    F                  ; Should be 0.\nEXCOMP3  DS    F                  ; Should be 0.\nEXCOMP4  DS    F                  ; Point to first SHVBLOCK\n         ORG   EXCOMP4\n         DC    X'80',AL3(0)       ; Last parameter\n         ORG   ,\n*\n* irxsay plist and pointers --------------------------------+\n*                                                           |\nsay      ds    0d                                           |\nsaywr    ds    a                  ; ptr to write/writeerr   |\nsaystra  ds    a                  ; ptr to a(string)        |\nsaystrl  ds    a                  ; ptr to F'string_length' |\n         org   saystrl                                      |\n         DC    X'80',AL3(0)       ; Last parameter          |\n         ORG   ,                                            |\nastring  ds    a                  ; a(string)               |\nlstring  ds    f                  ; length of string        |\n* <---------------------------------------------------------+\n         DS    0D\nSHVB     DS    XL(SHVBLEN)'00'    ; Place for SHVBLOCK\n*----------------\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*--------------------------------------------------------------------*\n*\n* Map parm table entry\n*\npt     dsect\nptks   ds   al2             ; kwrd size in table\nptpr   ds   al4             ; processing routine\nptpfd  ds   al2             ; flag displ\nptpfc  ds   al1             ; flag value\nptseq  ds   al2             ; flags for dups check\nptval  ds   cl12            ; kwrd value\nptel     equ   *-pt                  ; entry length\n*\n         YREGS\n         PRINT ON\n*--------------------------------------------------------------------*\n* REXX MACROS.\n*--------------------------------------------------------------------*\n         IRXENVB                  ; Environment block (R0 on entry)\n         IRXEFPL DSECT=YES        ; External function plist (R1)\n         IRXARGTB                 ; Map the argument list.\n         IRXSHVB                  ; Shared variables block\n         IRXEVALB                 ; EVALBLOCK to return result.\n         IRXEXTE                  ; External entry points\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXENQ": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x01\\x01\\t\\x9f\\x01\\x01\\x13\\x0f\\x13\"\\x02\\x8f\\x03\\x1c\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-04-09T00:00:00", "modifydate": "2001-05-10T13:22:00", "lines": 655, "newlines": 796, "modlines": 0, "user": "SAYB"}, "text": "RXENQ       TITLE 'Issue ENQ from REXX for a single resource'\nRXENQ       AMODE 31\nRXENQ       RMODE ANY\n*----------------------------------------------------------------------\n* When called as an external rexx subroutine this program will\n*  issue ENQ for a specified (single) resource.\n*\n* Multiple resource specification (as in ENQ macro) is not supported.\n*\n*   R15 is always set to 0; if arguments are missing or\n*      something equally ugly happened, it is set to 1,\n*      therefore exec terminates;\n*\n*   Result is set to a return code from ENQ macro.\n*\n*   Parameters:\n*      1st - qname, truncated or padded to 8 bytes (major name)\n*            dont use any that required the caller to be in\n*            authorized state, like beginning with SYSZ)\n*            *** no defaults ***\n*      2nd - rname (minor name). from 1 to 255 chars long, taken as\n*            supplied. leading/trailing blanks are not removed.\n*            *** no defaults ***\n*      3rd - either E (exclusive) or S (shared) request.\n*            *** no defaults ***\n*      4th - either of the three:\n*              STEP    - address space scope\n*              SYSTEM  - more than one address space scope\n*              SYSTEMS - more than one system        scope\n*            *** STEP is a default as in ENQ macro ***\n*      5th - either of the five:\n*              RET=CHNG   - always exclusive, ignore E/S in 3rd parm\n*              RET=HAVE   - conditional control\n*              RET=TEST   - test for enq\n*              RET=USE    - get control only if resource is available\n*              RET=NONE   - unconditional request, note that will\n*                           abend if not satisfied. x'138', I think\n*            *** RET=NONE is a default as in ENQ macro ***\n*      6th - either of the two:\n*              RNL=YES\n*              RNL=NO\n*            *** RNL=YES is a default as in ENQ macro ***\n*\n*   Examples:\n*    result = RXENQ('XXXCMD','XXXCMD','E','SYSTEMS','RET=HAVE');\n*   As is customary in rexx, optional arguments can be omitted,\n*    for example:\n*    result = RXENQ('XXXCMD','XXXCMD','E',,'RET=HAVE');\n* this results in scope being STEP (default).\n*\n* Note that this function can be used standalone as well as a part\n* of rexx function package\n*\n* Also note that ENQ plist is hand-built and only single resource\n*  is supported.\n*\n* Dont forget to issue DEQ for the resource.\n*\n* Flag bits specification (non-auth form of macro)\n*\n* PELFLG2:\n*    x'80'       - last arg specification\n*    x'40'       - rnl=yes    makes it x'c0' = 192\n*    x'04'       - rnl=no     makes it x'84' = 132\n*\n* PELFLAG:\n*    x'80'       - shared (\"S\")\n*    x'40'       - SYSTEM\n*    x'48'       - SYSTEMS\n*    x'02'       - CHNG\n*    x'01'       - HAVE\n*    x'07'       - TEST\n*    x'03'       - USE\n*\n*\n*04/2001 Alex Brodsky\n*----------------------------------------------------------------------\nRXENQ    LGN@ENT   CSECT\n*already LM    R0,R1,20(R1)       ; Restore ENVB and EFPL pointers\n         ST    R0,ENV             ; Save it for calls to rexx services\n         SPACE 3\nSTART    DS    0H\n         LR    R9,R1              ; Get the EFPL address\n         USING EFPL,R9            ; Extended function plist\n*------------------------------------------------------\n* Get the address of IRXEXCOM and IRXSAY from IRXEXTE\n*------------------------------------------------------\n         L     R1,ENV             ; ENVBLOCK address\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R1) ; IRXEXTE address\n         USING IRXEXTE,R1         ; Tell assembler\n         MVC   ZZZEXCOM(4),IRXEXCOM ; Var access routine\n         MVC   ZZZSAY(4),IRXSAY     ; say routine\n         DROP  R1\n         SPACE 3\n*--------------------------------------------------------------------*\n* Initialize all the necessary plists.\n*--------------------------------------------------------------------*\n*. Init the EVALBLOK.\n*.  Move an address of a result string in the\n*.   RESULT variable.\n*.  RLTSUB routine code will set the RESULT with whatever\n*.   is pointed to by 'RESULT' variable\n*.\n         L     R2,EFPLEVAL        ; Get the EVALBLOCK address\n         ST    R2,EVB             ; Save it for exit routine.\n         MVC   KCOTH(LKCOK),KCOK  ; Init the retcode result\n         LA    R2,KCOTH           ; Point to retcode from WTO\n         ST    R2,RESULT          ; ...\n*\n         mvc   qname(8),blanks    ; init qname\n\n*--------------------------------------------------------------------*\n* Now look at arguments passed by the caller.\n*  If argument is not supploed (pointer is zero) or\n*  missing entirely (we hit the fence, 8X'FF'), we will issue\n*  a message and exit this function.\n*--------------------------------------------------------------------*\n         L     R4,EFPLARG         ; Pointer to arguments\n         USING ARGTABLE_ENTRY,R4  ; Map the entry\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    bad_qname          ; No arguments.\n* ARG 1 - qname. must be present and no more than 8 bytes\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   bad_qname          ; Wrong!\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   bad_qname          ; Wrong!\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n*\n         C     R3,=F'8'           ; cannot be more\n         BH    bad_qname          ; terminate exec\n         L     R2,AP              ; get qname address\n         BCT   R3,*+10            ; --copy qname------+\n         MVC   qname(0),0(R2)     ; *** executed ***  |\n         EX    R3,*-6             ; <-----------------+\n* qname address in plist\n         LA    R0,qname\n         st    r0,aqname          ; save in enq plist\n***\n* ARG 2 - rname. must be present and no more than 255 bytes\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    bad_rname          ; No argument(s)\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   bad_rname          ; Wrong!\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   bad_rname          ; Wrong!\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n*\n         C     R3,=F'255'         ; cannot be more\n         BH    bad_rname          ; terminate exec\n         stc   r3,PELMILEN        ; else save in enq plist\n         L     R2,AP              ; get rname address\n         BCT   R3,*+10            ; --copy rname------+\n         MVC   rname(0),0(R2)     ; *** executed ***  |\n         EX    R3,*-6             ; <-----------------+\n* rname address in plist\n         LA    R0,rname\n         st    r0,arname          ; save in enq plist\n***\n* ARG 3 - exclusive/shared. either S or E\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    bad_control        ; No argument(s)\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   bad_control        ; Wrong!\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   bad_control        ; Wrong!\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n*\n         C     R3,=F'1'           ; cannot be more\n         BH    bad_control        ; terminate exec\n*\n         L     R2,AP              ; get rname address\n         CLI   0(R2),C'E'         ; wants exclusive?\n         be    process_4th_arg    ; no flags then\n         CLI   0(R2),C'S'         ; wants shared?\n         bne   bad_control        ; no, terminate exec\n         oi    pelflag,@shared    ; yes, set flag in enq plist\nprocess_4th_arg ds 0h\n***\n*** other args can be defaulted.\n***  set plist to use same defaults as ENQ macro.\n***    STEP              no flags\n***    RET=NONE          no flags\n***    RNL=YES\n         MVI   PELFLG2,192        ; rnl=yes, last arg list.\n***\n***\n         SPACE 2\n         LA    R5,3               ; 3 more args\n* ARG 4-6 - Can be either STEP/SYSTEM/SYSTEMS/RET=whatever/RNL=\ntest_next_arg ds 0h\n         CLC   0(8,R4),=XL8'FFFFFFFFFFFFFFFF' ; end of ARGTABLE?\n         BE    issue_enq          ; Use default for others\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   jna                ; Appears missing, check next\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   jna                ; Appears missing, check next\n         ST    R3,LP              ; Save the length\n         BAL   R7,process_parm    ; look at it\n         BNZ   bad_other          ; error\njna      LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n         BCT   R5,test_next_arg   ; and look at it.\n**\n         DROP  R4                 ; ARGTABLE_ENTRY\n         DROP  R9                 ; EFPL\n*=================================================================\nissue_enq ds 0H\n         ENQ   MF=(E,ENQ_PL)\n         LTR   R15,R15\n         BZ    EXIT               ; no errors, exit to caller\n** multiple args are not supported\n         SLR   R1,R1              ; Prepare\n         IC    R1,3(,R15)         ; get the retcode (RELRET?)\n         C     R1,=F'18'          ; need message?\n         BNE   cvtretcode\n         LA    R1,ERM102          ; envirom error\n         BAL   R14,issue_error    ; ... r1 is preserved\n** convert retcode to printable and set rc variable.\ncvtretcode  ds    0h\n         LA    R0,16              ; max size\n         BAL   R8,CVTBDS          ; convert to printable\n         B     EXIT\n         EJECT\n*--------------------------------\n* Process the parm\n*  AP  - parm address\n*  LP  - parm length\n*  R7  - linkage register\n*\n*--------------------------------\nprocess_parm ds 0H\n         stm   r0,r14,save_process_parm\n         lm    r5,r6,lp            ; parm length and address\n*\n         LTR   R5,R5              ; Get length of the field\n         BZ    pp_end_nok         ; Invalid size\n*\n* Uppercase the parm.\n*\n         BCT   R5,*+10            ; ----->-------------+\n         TR    0(0,R6),UPPER      ; *** executed ***   |\n         EX    R5,*-6             ; <------------------+\n         LA    R5,1(,R5)          ; restore r5\n*\n         LA    R1,parmtab\n         using pt,r1              ; map the entry\nploop    ds    0H\n         icm   r2,B'1100',ptks    ; kwrd  size\n         BZ    pp_end_nok         ; last entry, bad keyword\n         SRL   r2,16              ; into low order bytes\n         cr    r5,r2              ; should be exact size there\n         bne   ploop_next         ; no. get next parmtab entry\n         BCT   r2,*+10            ; --lookup in table--+\n         CLC   0(0,R6),ptval      ; *** executed ***   |\n         ex    R2,*-6             ; <------------------+\n         be    kwrd_found         ; found this keyword\nploop_next ds  0H\n         la    r1,ptel(,R1)\n         B     ploop              ; keep searching the table\n*\nkwrd_found ds 0H\n         ICM   r15,B'1111',ptpr    ; routine address\n         Balr  r14,r15            ; call it\n         bz    pp_end_ok\npp_end_nok ds 0h\n         Cli  *,x'93'              ; cc .ne. 0\n         b   pp_end               ; and leave\npp_end_ok ds 0h\n         cli  *,x'95'              ; cc=0\npp_end   ds   0H\n         lm    r0,r14,save_process_parm\n         br    r7                  ; back to caller\n         drop  r1                 ; un_map the entry\n*---------------------------------------\n* Processing routines for each keyword\n*\n*  r1 = table entry for the parm\n*\n*  r14 - linkage\n*\n*---------------------------------------\np_scope ds 0h\np_ret   equ p_scope\np_rnl   equ p_scope\n         stm    r0,r14,save_psp\n         using pt,r1              ; map the entry\n*\n* see if dupl parm\n*   I think there is a new instr to do that.\n*\n*\n         slr   r3,r3              ; prepare\n         ic    r3,ptseq\n\n         b     *+8\n         tm    dupparm,x'00'\n         ex    r3,*-4\n         bo    ps_nok              ; duplicate parm\n\n         ic    r3,ptseq+1\n         b     *+8\n         tm    dupparm+1,x'00'\n         ex    r3,*-4\n         bo    ps_nok              ; duplicate parm\nps_u     ds     0h                 ; unique parm\n         clc    ptval(3),=cl3'RNL' ; rnl processing?\n         bne    ps_not_rnl         ; no, set flag\n         mvc    pelflg2(1),ptpfc   ; for rnl set pelflg2 flag.\n         b     ps_ok\nps_not_rnl ds 0h\n         ic    r3,ptpfc            ; flag value\n         b     *+8\n         oi    pelflag,x'00'\n         ex    R3,*-4              ; set the flag in enq plist\n         b     ps_ok\nps_ok    cli    *,x'95'            ; set cc .eq. 0\n         lm     r0,r14,save_psp\n         br     r14\nps_nok   cli    *,x'93'            ; set cc .ne. 0\n         lm     r0,r14,save_psp\n         br     r14\n         drop  r1                 ; un_map the entry\n         SPACE  3\n********************************************\n* Parms table:\n*  al2   keyword size\n*  al4   processing routine address\n*  al2   flag offset in plist\n*  al1   flag value\n*  al2   value flag for duplicates test\n*  cl12  keyword\n*\n********************************************\nparmtab  ds    0H\n dc al2(4),al4(p_scope)\n DC al2(PELFLAG-ENQ_PL),AL1(@STEP),XL2'8000',CL12'STEP'\n*\n dc al2(6),al4(p_scope)\n dc al2(PELFLAG-ENQ_PL),AL1(@SYSTEM),XL2'4000',CL12'SYSTEM'\n*\n dc al2(7),al4(p_scope)\n dc al2(PELFLAG-ENQ_PL),AL1(@SYSTEMS),XL2'2000',CL12'SYSTEMS'\n*\n dc al2(8),al4(p_ret)\n dc al2(PELFLAG-ENQ_PL),AL1(@CHNG),XL2'1000',CL12'RET=CHNG'\n*\n dc al2(8),al4(p_ret)\n dc al2(PELFLAG-ENQ_PL),AL1(@HAVE),XL2'0800',CL12'RET=HAVE'\n*\n dc al2(8),al4(p_ret)\n dc al2(PELFLAG-ENQ_PL),AL1(@TEST),XL2'0400',CL12'RET=TEST'\n*\n dc al2(7),al4(p_ret)\n dc al2(PELFLAG-ENQ_PL),AL1(@USE),XL2'0200',CL12'RET=USE'\n*\n dc al2(8),al4(p_ret)\n dc al2(PELFLAG-ENQ_PL),AL1(@NONE),XL2'0100',CL12'RET=NONE'\n*\n dc al2(7),al4(p_rnl)\n dc al2(PELFLG2-ENQ_PL),AL1(192),XL2'0080',CL12'RNL=YES'\n*\n dc al2(6),al4(p_rnl)\n dc al2(PELFLG2-ENQ_PL),AL1(132),XL2'0040',CL12'RNL=NO'\n         dc    al2(0)                ; last entry\n         EJECT ,\n*--------------------------------------------------------------------*\n* Incorrect call - arguments missing or wrong.\n*--------------------------------------------------------------------*\nbad_qname DS   0H\n         LA    R1,ERM001          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nbad_rname DS   0H\n         LA    R1,ERM002          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nbad_control ds 0H\n         LA    R1,ERM003          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nbad_other   ds 0H\n         LA    R1,ERM004          ; issue error message\n         B     incorargs          ; ...\n         SPACE 1\nINCORARGS DS   0H\n         BAL   R14,issue_error    ; ...\n**       MVI   KCOTH+4,C'8'       ; rc=8\n         MVC   RETCODE(4),=F'1'   ; terminate the exec.\n         B     EXIT               ; Return to caller.\n         SPACE 2\n************************************************\n* issue error message\n*  R1 - error message address\n*    first 4 bytes of the message is text size.\n************************************************\nissue_error ds 0h\n        stm  r0,r15,save_say\n\n* set up irxsay plist\n         LA    R2,KCWRITEERR      ; -> CL8'WRITEERR'\n         ST    R2,saywr           ; 1st parm\n         la    r2,astring\n         st    r2,saystra         ; 2nd parm\n         la    r2,lstring\n         st    r2,saystrl         ; 3rd parm\n         oi    saystrl,x'80'      ; is the last parm\n\n         ICM   R0,B'1111',0(R1)   ; size is 1st 4 bytes\n         LA    R1,4(,R1)          ; position at text\n\n         st    r1,astring         ; build error message address\n         st    r0,lstring         ; build error message size\n\n         L     R0,ENV             ; Optional environment block address\n         LA    R1,say             ; IRXSAY plist\n         L     R15,ZZZSAY         ; Saved address\n         BALR  R14,R15            ; Go there\n*\n         lm   r0,r15,save_say\n         br   r14                 ; back to caller\n*--------------------------------------------------------------------\n* Convert to printable dec, remove leading blanks after conversion.\n*   R1 - value to convert\n*   R0 - output size\n*--------------------------------------------------------------------\nCVTBDS   DS    0H\n         LR    R15,R0              ; Size\n         IC    R3,=C' '            ; sign if positive or 0\n         LTR   R1,R1               ; is it?\n         BNM   CVTBDS_01            ; yes\n         LPR   R1,R1               ; make positive\n         IC    R3,=C'-'            ; sign if negative\nCVTBDS_01 DS    0H\n         CVD   R1,DWORD            ; -> decimal\n         MVC   DECCVT(L'PATTERN),PATTERN  ; Init\n         LA  R1,DECCVT+L'PATTERN-1  ; First byte after sign. starter\n*                                   ; ... (last byte of pattern)\n         EDMK  DECCVT(L'PATTERN),DWORD ; convert to printable\n         CLM   R3,B'0001',=C'-'\n         BNE   CVTBDS_02\n         BCTR  R1,0                ; byte before first non-zero\n         STC   R3,0(R1)            ; sign in front\nCVTBDS_02 DS    0H\n* Now we move all specified data to common area, can be truncated\n         C     R15,=F'16'          ; over the max?\n         BNH   *+8\n         LA    R15,16\n*\n* Compute the data size\n*\n         LA    R3,DECCVT+L'PATTERN ; Byte after last\n         SR    R3,R1               ; Converted data size\n*\n         CR    R15,R3              ; Requested less than converted?\n         BNH   *+6\n         LR    R15,R3\n*\n         ST    R15,CVTOUT          ; Save size\n*\n         BCT   R15,*+10\n         MVC   CVTOUT+4(0),0(R1)   ; *** executed ***\n         EX    R15,*-6             ; Move and trunc from the left\n*\n         BR    R8                  ; Done\n         SPACE 3\n*\n*\n*--------------------------------------------------------------------*\n*                    EXIT\n*--------------------------------------------------------------------*\nEXIT     DS    0H\n*\n* Allocate EVALBLOCK if needed and move the result data there\n*\n         LA    R1,RLTSUB$         ; RLTSUB plist\n         L     R15,=V(RLTSUB)     ; Routine address\n         BALR  R14,R15            ; Call it\n*\n* Rexx will set the result.\n*\nEXIT0    LGN@RET RC=RETCODE       ; Return code\n         EJECT ,\n*--------------------------------------------------------------------*\n*     CONSTANTS AND WORK AREAS\n*--------------------------------------------------------------------*\nKCEXCOM  DC    CL8'IRXEXCOM'      ; Need for the call to IRXEXCOM\nKCWRITEERR DC  CL8'WRITEERR'      ; For IRXSAY\nblanks   dc    cl80' '              ; handy\nKCOK     DC    AL4(KCOKE-KCOK-4)    ; Result length\n         DC    X'F0'                ; C'0'\nKCOKE    EQU   *\nLKCOK    EQU   *-KCOK\n*\nEDMASK   DC    X'2020202020202021'\n*\nXFFS     DC    X'FFFFFFFF'       ; to test for args\n*\n* Error messages\n*\nERM001 DC AL4(LERM001),C'RXENQ001E Incorrect or missing qname'\nLERM001 EQU *-ERM001-4\n*\nERM002 DC AL4(LERM002),C'RXENQ002E Incorrect or missing rname'\nLERM002 EQU *-ERM002-4\n*\nERM003 DC AL4(LERM003),C'RXENQ003E Incorrect or missing control'\nLERM003 EQU *-ERM003-4\n*\nERM004 DC AL4(LERM004)\n DC C'RXENQ004E Either scope, request or RNL parm is incorrect'\nLERM004 EQU *-ERM004-4\n*\nERM102 DC AL4(LERM102),C'RXENQ102E Environmental error from ENQ macro'\nLERM102 EQU *-ERM102-4\n*\n* Translate to uppercase\n*\n         DS    0D\nUPPER    DC    256AL1(*-UPPER)\n         ORG   UPPER+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPPER+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPPER+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         DS    0D\nPATTERN  DC    CL16' '\n         ORG   PATTERN\n         DC    X'40',13X'20'\nPSS      DC    X'2120'                 ; signif. starter\n         ORG   ,\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n*\n* WORKAREA DSECT. R13 points to it.\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                ; Registers save area\nRETCODE  DS    F                  ; Retcode - 0\nsave_process_parm ds 16f          ; save area for process_parm\nsave_psp          ds 16f          ; subparm save area\nsave_say          ds 16f\ndword    ds    d                  ; work area for conversion\ncvtchar  ds    cl8                ; and to printable\ndupparm  ds    xl2                ; duplicate parm flag\nDECCVT   DS    CL16               ; Area for dec conversions\n*\n* Plist to call RLTSUB\n*\nRLTSUB$  RLTPLST DSECT=NO\n*\n* Do not change the order of the next 2 fields.\n*\nLP       DS    F                  ; Length of parameter\nAP       DS    F                  ; Address of parameter\n*\n* This is a return value (RC or RETCODE) for this function.\n*  suppose to be up to 18.\n*\n*\nKCOTH    DS    F                  ; size\n         DS    XL16               ; Retcode, printable.\nCVTOUT   EQU   KCOTH\n*\n* ENQ flags definition for the flag 2.\n*\n@SHARED  EQU   X'80'              ; C'S' is specified\n@STEP    EQU   0                  ; STEP    specified\n@SYSTEM  EQU   X'40'              ; SYSTEM  is specified\n@SYSTEMS EQU   (X'40'+X'08')      ; SYSTEMS is specified\n@CHNG    EQU   X'02'              ; RET=CHNG\n@HAVE    EQU   X'01'              ; RET=HAVE\n@TEST    EQU   (X'04'+X'02'+X'01') ; RET=TEST\n@USE     EQU   (X'02'+X'01')      ; RET=USE\n@NONE    EQU   0                  ; RET=NONE\n\n**************************************************\n* ENQ macro plist\n**************************************************\nENQ_PL   DS    0F\nPELFLG2  DS    AL1(0)             ; flag\nPELMILEN DS    AL1(0)             ; rname length\nPELFLAG  DS    AL1(0)             ; flag 2\nPELRET   DS    AL1(0)             ; return code byte\nAQNAME   DS    A(0)               ; qname address\nARNAME   DS    A(0)               ; rname address\n*\nQNAME    DS    CL8                ; place for qname\nRNAME    DS    CL255              ; place for rname\nzzzexcom ds    f                  ; irxexcom address from irxexte\nzzzsay   ds    f                  ; irxsay   address from irxexte\n*\n* irxexcom  plist\n*\nEXCOM    DS    0D                 ; IRXEXCOM plist\nEXCOMP1  DS    F                  ; Points to cl8'IRXEXCOM'\nEXCOMP2  DS    F                  ; Should be 0.\nEXCOMP3  DS    F                  ; Should be 0.\nEXCOMP4  DS    F                  ; Point to first SHVBLOCK\n         ORG   EXCOMP4\n         DC    X'80',AL3(0)       ; Last parameter\n         ORG   ,\n*\n* irxsay plist and pointers --------------------------------+\n*                                                           |\nsay      ds    0d                                           |\nsaywr    ds    a                  ; ptr to write/writeerr   |\nsaystra  ds    a                  ; ptr to a(string)        |\nsaystrl  ds    a                  ; ptr to F'string_length' |\n         org   saystrl                                      |\n         DC    X'80',AL3(0)       ; Last parameter          |\n         ORG   ,                                            |\nastring  ds    a                  ; a(string)               |\nlstring  ds    f                  ; length of string        |\n* <---------------------------------------------------------+\n         DS    0D\nSHVB     DS    XL(SHVBLEN)'00'    ; Place for SHVBLOCK\n*----------------\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*--------------------------------------------------------------------*\n*\n* Map parm table entry\n*\npt     dsect\nptks   ds   al2             ; kwrd size in table\nptpr   ds   al4             ; processing routine\nptpfd  ds   al2             ; flag displ\nptpfc  ds   al1             ; flag value\nptseq  ds   al2             ; flags for dups check\nptval  ds   cl12            ; kwrd value\nptel     equ   *-pt                  ; entry length\n*\n         YREGS\n         PRINT ON\n*--------------------------------------------------------------------*\n* REXX MACROS.\n*--------------------------------------------------------------------*\n         IRXENVB                  ; Environment block (R0 on entry)\n         IRXEFPL DSECT=YES        ; External function plist (R1)\n         IRXARGTB                 ; Map the argument list.\n         IRXSHVB                  ; Shared variables block\n         IRXEVALB                 ; EVALBLOCK to return result.\n         IRXEXTE                  ; External entry points\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXWTOR": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01C\\x00\\x00\\x01\\x01\\x08o\\x01\\x01\\t?\\tQ\\x03\\x1c\\x00\\xf1\\x00\\x00\\xe2\\xc1\\xe9\\xc2@@@@@@'", "ispf": {"version": "01.67", "flags": 0, "createdate": "2001-03-27T00:00:00", "modifydate": "2001-04-03T09:51:00", "lines": 796, "newlines": 241, "modlines": 0, "user": "SAZB"}, "text": "RXWTOR      TITLE 'Issue WTO or WTOR from REXX'\nRXWTOR      AMODE 31\nRXWTOR      RMODE ANY\n*----------------------------------------------------------------------\n* When called as an external rexx subroutine this program will\n*  issue WTO or WTOR to the console.\n*\n*   R15 is always set to 0; if arguments are missing or\n*      something equally ugly happened, it is set to 1,\n*      therefore exec terminates;\n*\n*   Result is set either 0 it everything went fine, or\n*    is set to 8 and error message is issued.\n*\n*   Parameters:\n*      Parens are required for 2nd - 4th parameters\n*      (n-m) specification (see WTO macro) is not supported for these.\n*\n*\n*   1st - message to be sent, must be first and must be present.\n*   next 3 in any order, none is required\n*   DESC=(n,n,...n) - descriptor codes.\n*                     Example: DESC=(2,3,7) or DESC=(2).\n*   ROUTCDE=(n,n,...n) - routing codes.\n*                     Example: ROUTCDE=(1,11) or ROUTCDE=(11)\n*   REPLY=(YES)     - uses WTOR macro, returns operator's reply\n*                     in rexx variable REPLY.\n*                     Null reply is not allowed and\n*                     wtor is reissued.\n*\n*   Examples:\n*    result = RXWTOR(\"This is a wto message\",'DESC=(2)');\n*    rc = RXWTOR('Reply U to continue','DESC=(2)','ROUTCDE=(1)',\n*         'REPLY=(YES)');\n*\n* Note that this function can be used standalone as well as a part\n* of rexx function package\n*\n* Also note that WTO/WTOR plists are hand-built and just DESC and\n*  ROUTCDE options are supported.\n*\n*\n*04/2001 Alex Brodsky\n*----------------------------------------------------------------------\nRXWTOR   LGN@ENT   CSECT\n*already LM    R0,R1,20(R1)       ; Restore ENVB and EFPL pointers\n         ST    R0,ENV             ; Save it for calls to rexx services\n         SPACE 3\nSTART    DS    0H\n         LR    R9,R1              ; Get the EFPL address\n         USING EFPL,R9            ; Extended function plist\n*------------------------------------------------------\n* Get the address of IRXEXCOM and IRXSAY from IRXEXTE\n*------------------------------------------------------\n         L     R1,ENV             ; ENVBLOCK address\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R1) ; IRXEXTE address\n         USING IRXEXTE,R1         ; Tell assembler\n         MVC   ZZZEXCOM(4),IRXEXCOM ; Var access routine\n         MVC   ZZZSAY(4),IRXSAY     ; say routine\n         DROP  R1\n         SPACE 3\n*--------------------------------------------------------------------*\n* Initialize all the necessary plists.\n*--------------------------------------------------------------------*\n*. Init the EVALBLOK.\n*.  Move an address of a result string in the\n*.   RESULT variable.\n*.  RLTSUB routine code will set the RESULT with whatever\n*.   is pointed to by 'RESULT' variable\n*.\n         L     R2,EFPLEVAL        ; Get the EVALBLOCK address\n         ST    R2,EVB             ; Save it for exit routine.\n         MVC   KCOTH(LKCOTH),KCOK ; Init the retcode result\n         LA    R2,KCOTH           ; Point to retcode from WTO\n         ST    R2,RESULT          ; ...\n*\n*--------------------------------------------------------------------*\n* Now look at arguments passed by the caller.\n*  If argument is not supploed (pointer is zero) or\n*  missing entirely (we hit the fence, 8X'FF'), we will issue\n*  a message and exit this function.\n*--------------------------------------------------------------------*\n         L     R4,EFPLARG         ; Pointer to arguments\n         USING ARGTABLE_ENTRY,R4  ; Map the entry\n* ARG 1 - message, MUST BE PRESENT.\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   INCORARGS          ; Wrong!\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   INCORARGS          ; Wrong!\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n*\n* Copy message to WTO plist, also set flags for default message.\n*\n         LM    R5,R6,LP           ; Get the length and address\n         C     R5,=F'120'         ; Greater than 120 bytes?\n         BH    INCORARGS          ; Invalid length\n         LTR   R5,R5              ; Get length of the field\n         BZ    INCORARGS          ; Invalid size\n*\n         LA    R0,4(,R5)          ; size + 4\n         STCM  R0,B'0011',WTO_LEN  ; and save in plist\n         BCT   R5,*+10\n         MVC   WTO_TXT(0),0(R6) ; *** executed ***\n         EX    R5,*-6\n         SPACE 2\n* ARG 2 - Can be either ROUTCDE=, DESC= or REPLY= or nothing at all.\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   issue_wto          ; Nothing else, issue wto.\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   issue_wto          ; Nothing else, issue wto.\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n         BAL   R7,process_parm    ; look at it\n         BNZ   INCORARGS          ; error\n* ARG 3 - Can be either ROUTCDE=, DESC= or REPLY= or nothing at all.\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   issue_wto_or_wtor  ; Nothing else, issue wto or wtor\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   issue_wto_or_wtor  ; Nothing else, issue wto or wtor\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; Adjust base - next entry\n         BAL   R7,process_parm    ; look at it\n         BNZ   INCORARGS          ; error\n* ARG 4 - Can be either ROUTCDE=, DESC= or REPLY= or nothing at all.\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BNP   issue_wto_or_wtor  ; Nothing else, issue wto or wtor\n         ST    R3,AP              ; Save the address\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BNP   issue_wto_or_wtor  ; Nothing else, issue wto or wtor\n         ST    R3,LP              ; Save the length\n         LA    R4,ARGTABLE_NEXT   ; adjust base - next entry\n         BAL   R7,process_parm    ; look at it\n         BNZ   INCORARGS          ; error\n* ARG 5 - Should not be there.\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; Get the address\n         BP    INCORARGS          ; error\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; Get the length\n         BP    INCORARGS          ; error\n**\n         DROP  R4                 ; ARGTABLE_ENTRY\n         DROP  R9                 ; EFPL\n*=================================================================\nissue_wto_or_wtor ds 0H\n         TM    @reply,L'@reply    ; was reply= in plist?\n         BNO   issue_wto          ; no, issue wto.\n         SPACE 2\nissue_wtor ds  0H\n*\n* determine what to place in plist\n*\n         xc    wtor_ecb(4),wtor_ecb ; if not the first time\n         LA    R0,reply             ; fill up reply address\n         st    r0,wtor_ra           ; ...\n         oi    wtor_ra,x'80'        ; ...\n         mvi   wtor_rl,reply_length ; and reply length\n\n         la    r0,wtor_ecb          ; fill up ecb address\n         st    r0,wtor_ea           ; ..\n\n* copy message to wtor plist\n\n         SLR   r2,r2                ; prepare\n         icm   r2,B'0011',wto_len   ; message size\n         BCT   R2,*+10              ; ------------------+\n         MVC   WTOR_TXT(0),WTO_TXT  ; *** executed ***  |\n         EX    R2,*-6               ; <-----------------+\n*\n* move flags after the message. Might not be needed.\n*\n         LA    R1,WTOR_PL           ; plist address\n         la    r1,(12+1)(R1,r2)         ; addr after the message\n         mvc   0(2,r1),wto_desc     ; first desc codes\n         mvc   2(2,r1),wto_rout     ; then routing codes\n\n* text size\n         la    r2,(4+1)(,r2)        ; msg length +4 + 1 (bct).\n         stc   r2,wtor_len          ; save in plist\n\n         MVC   WTOR_MCS(2),MCSFLAG  ; presume non-default\n         TM    @ROUTCDE,L'@ROUTCDE  ; any route codes?\n         BO    issue_wtor_02        ; yes, can issue wtor\n         TM    @DESC,L'@DESC        ; any dest  codes?\n         BO    issue_wtor_02        ; yes, can issue wtor\n         xc    wtor_mcs(2),wtor_mcs ; default wtor\nissue_wtor_02 ds 0H\n         mvi   reply,c' '\n         mvc   reply+1(reply_length-1),reply ; clear to blanks\n         WTOR  MF=(E,WTOR_PL)\n         LTR   R15,R15\n         BZ    ISSUE_WAIT\n         LA    R1,ERM003          ; issue error message\n         BAL   R14,issue_error    ; ...\n         MVI   KCOTH+4,C'8'       ; rc=8\n         B     EXIT\nissue_wait ds 0h\n         WAIT  ECB=WTOR_ECB\n*\n* Make sure that reply is not blank, and strip blanks from it.\n*\n         la    r2,reply           ; buffer address\n         la    r3,reply_length    ; its size\n         la    r1,0(r2,r3)        ; byte after last of reply buffer\nfind_reply ds 0h                  ; <-------------------+\n         bctr  r1,0               ; back off 1 byte     |\n         cli   0(r1),c' '         ; still blank?        |\n         bne   fr_01              ; no.                 |\n         bct   r3,find_reply      ; --------------------+\n         b     issue_wtor         ; re-issue wtor if just blanks\nfr_01    ds    0h                 ; <-------------------+\n* strip leading blanks                                  |\n         cli   0(r2),c' '                               |\n         bne   fr_02                                    |\n         la    r2,1(,r2)                                |\n         bct   r3,fr_01           ; scan forward -------+\n* cannot fall through\nfr_02    ds    0H\n*\n* R2 - reply address\n* R3 - reply size\n         b     set_reply          ; set reply and exit to caller\n*\n*\nissue_wto DS   0H\n*\n* determine what to place in plist\n*\n         MVC   WTO_MCS(2),MCSFLAG   ; presume non-default\n         TM    @ROUTCDE,L'@ROUTCDE  ; any route codes?\n         BO    issue_wto_02         ; yes, need to copy flags\n         TM    @DESC,L'@DESC        ; any dest  codes?\n         BNO   issue_wto_00         ; no, user default format of wto\nissue_wto_02 ds 0H\n*\n* move flags after the message.\n*\n         LA    R1,WTO_PL            ; plist address\n         SLR   r2,r2                ; prepare\n         icm   r2,B'0011',wto_len   ; message size\n         la    r1,0(R1,r2)          ; addr after the message\n         mvc   0(2,r1),wto_desc     ; first desc codes\n         mvc   2(2,r1),wto_rout     ; then routing codes\n         B     issue_wto_01         ; issue wto\n*\n* Default wto plist, no flags.\n*\nissue_wto_00 ds 0H\n         XC    WTO_MCS(2),WTO_MCS ; no flags for default wto\nissue_wto_01 ds 0H\n         WTO   MF=(E,WTO_PL)\n         LTR   R15,R15\n         BZ    EXIT               ; no errors, exit to caller\n         LA    R1,ERM002          ; issue error message\n         BAL   R14,issue_error    ; ...\n         MVI   KCOTH+4,C'8'       ; rc=8\n         B     EXIT\n         EJECT\n*\n* set the rexx variable REPLY to the value of reply from operator,\n*  then exit to caller\n*\n* R2 - reply address\n* R3 - reply size\n*\nset_reply ds 0H\n*\n* Set irxexcom plist\n*\n         LA    R0,KCEXCOM         ; Point to character id\n         ST    R0,EXCOMP1         ; Save as a first parm address\n         XC    EXCOMP2(L'EXCOMP2+L'EXCOMP3),EXCOMP2 ; make these 0\n         LA    R0,SHVB            ; Get the SHVBLOCK address\n         ST    R0,EXCOMP4         ; Save as a fourth argument\n         OI    EXCOMP4,X'80'      ; Flag the fourth as a last arg\n*.\n*. Now SHVBLOCK - shared variables block.\n*.\n         LA    R5,SHVB            ; Get to the first block\n         USING SHVBLOCK,R5        ; Tell assembler\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK ; Init to zeros.\n*        XC    SHVNEXT(4),SHVNEXT ; Zero since it is a last block\n*        XC    SHVUSER(4),SHVUSER ; No user info\n*        MVI   SHVCODE,SHVSYSET   ; Lowercase 'S' for symbolic set\n         MVI   SHVCODE,SHVSTORE   ; Uppercase 'S' for set\n*\n* var name - REPLY\n*\n         la    r1,KCREPLY\n         ST    R1,SHVNAMA         ; addr of name\n         MVC   SHVNAML(4),=A(L'KCREPLY)  ; and its size there\n*\n* now value address and size\n*\n         ST    R2,SHVVALA         ; value address\n         st    r3,shvvall         ; and its size\n*\n         L     R0,ENV             ; Optional environment block address\n         LA    R1,EXCOM           ; IRXEXCOM plist\n         L     R15,ZZZEXCOM       ; Saved address\n         BALR  R14,R15            ; Go there\n*        LINK  EP=IRXEXCOM,MF=(E,EXCOM) ; ..\n         b     exit\n         drop  r5                 ; shvblock\n         EJECT ,\n*--------------------------------\n* Process the parm.\n*  AP  - parm address\n*  LP  - parm length\n*  R7  - linkage register\n*\n*--------------------------------\nprocess_parm ds 0H\n         stm   r0,r14,save_process_parm\n         lm    r5,r6,lp            ; parm length and address\n*\n         LTR   R5,R5              ; Get length of the field\n         BZ    pp_end_nok         ; Invalid size\n*\n* Uppercase the parm.\n*\n         BCT   R5,*+10            ; ----->-------------+\n         TR    0(0,R6),UPPER      ; *** executed ***   |\n         EX    R5,*-6             ; <------------------+\n         LA    R5,1(,R5)          ; restore r5\n*\n         LA    R1,parmtab\nploop    ds    0H\n         icm   r2,B'1100',0(R1)   ; entry size\n         BZ    pp_end_nok         ; last entry, bad keyword\n         SRL   r2,16              ; into low order bytes\n         cr    r5,r2              ; at least that much\n         bnh   ploop_next         ; no. get next parmtab entry\n         BCT   r2,*+10            ; --lookup in table--+\n         CLC   0(0,R6),(2+4)(R1)  ; *** executed ***   |\n         ex    R2,*-6             ; <------------------+\n         be    kwrd_found         ; found this keyword\nploop_next ds  0H\n         la    r1,ptel(,R1)\n         B     ploop              ; keep searching the table\n*\nkwrd_found ds 0H\n         sr    r5,r2              ; value size after C'='\n         bz    pp_end_nok         ; only keyword there\n         ar    r6,r2              ; position at value after C'='\n         cli   0(r6),c'('         ; need closing paren if so\n         bne   kf_01              ; no\n         la    r6,1(,r6)\n         bct   r5,*+8             ; adjust length if possible-----+\n         b     pp_end_nok         ; only keyword and paren        |\n         la    r14,0(r5,r6)       ; position at the end of arg <--+\n         bctr  r14,0\n         cli   0(r14),c')'        ; closing paren there?\n         bne   pp_end_nok         ; no, should be\n         bct   r5,*+8             ; adjust length if possible-----+\n         b     pp_end_nok         ; only keyword and parens       |\nkf_01    ICM   r15,B'1111',2(r1)   ; routine address <------------+\n         Balr  r14,r15            ; call it\n         bz    pp_end_ok\npp_end_nok ds 0h\n         Cli  *,x'93'              ; cc .ne. 0\n         b   pp_end               ; and leave\npp_end_ok ds 0h\n         cli  *,x'95'              ; cc=0\npp_end   ds   0H\n         lm    r0,r14,save_process_parm\n         br    r7                  ; back to caller\n*---------------------------------------\n* Processing routines for each keyword\n*\n*  r5 = parm size\n*  r6 - parm address, no parens anymore\n*\n*  r14 - linkage\n*\n*  routing codes are flags in the 2-bytes field for\n*    codes from 1 to 16, from left to right.\n* routecode 1 - bit position 15\n* routecode 2 - bit position 14\n* ....\n* routecode 16- bit position 0\n*\n* shift can be computed as 16-routcode\n*\n* same is true for desc codes\n*\n*\n*---------------------------------------\nprocess_routcde ds 0h\n         stm    r0,r14,save_psp\n         tm     @routcde,L'@routcde\n         BO     prc_nok            ; 2nd time\n         oi     @routcde,L'@routcde  ; set a flag\nprc_loop ds     0H\n         bal    r14,get_next       ; next routing code value\n         bnz    prc_nok            ; errors\n         ltr    r1,r1              ; result=0?\n         be     prc_ok             ; yes, all processed, cc=0\n* we dont support routcde >12 or zero\n         c      r1,=f'12'\n         bh     prc_nok            ; too big\n         slr    r2,r2              ; prepare\n         icm    r2,b'0011',wto_rout ; accumulator\n         la     r3,1               ; bit to shift\n         s      r1,=f'16'\n         lpr    r1,r1              ; 16 - routecode\n         sll    r3,0(R1)           ; and shift that many pos to left\n         or     r2,r3              ; update accumulator\n         stcm   r2,B'0011',wto_rout ; save in plist\nprc_ok   cli    *,x'95'            ; set cc .eq. 0\n         lm     r0,r14,save_psp\n         br     r14\nprc_nok  cli    *,x'93'            ; set cc .ne. 0\n         lm     r0,r14,save_psp\n         br     r14\n         SPACE  3\n*--------------------------------\n* process desc= parameter\n*--------------------------------\nprocess_desc    ds 0h\n         stm    r0,r14,save_psp\n         tm     @desc,L'@desc\n         BO     prd_nok            ; 2nd time\n         oi     @desc,L'@desc      ; set a flag\nprd_loop ds     0H\n         bal    r14,get_next       ; next routing code value\n         bnz    prd_nok            ; errors\n         ltr    r1,r1              ; result=0?\n         bz     prd_ok             ; yes, all processed, cc=0\n* we dont support desc >13 or zero\n         c      r1,=f'13'\n         bh     prd_nok            ; too big\n         slr    r2,r2              ; prepare\n         icm    r2,b'0011',wto_desc ; accumulator\n         la     r3,1               ; bit to shift\n         s      r1,=f'16'\n         lpr    r1,r1              ; 16 - desc\n         sll    r3,0(R1)           ; and shift that many pos to left\n         or     r2,r3              ; update accumulator\n         stcm   r2,B'0011',wto_desc ; save in plist\n         slr    r1,r1              ; set cc=0\nprd_ok   cli    *,x'95'            ; set cc .eq. 0\n         lm     r0,r14,save_psp\n         br     r14\nprd_nok  cli    *,x'93'            ; set cc .ne. 0\n         lm     r0,r14,save_psp\n         br     r14\n         SPACE  3\n*----------------------------------------------\n* process reply=yes parameter\n*  r5 = parm size\n*  r6 - parm address, no parens anymore\n*\n* only accept yes or no , y or n as well.\n*\n*----------------------------------------------\nprocess_reply   ds 0h\n         stm    r0,r14,save_psp\n         c      r5,=f'3'           ; too long?\n         bh     prr_nok            ; yes\n         c      r5,=f'1'\n         bl     prr_nok\n         sll    r5,2               ; times 4 for branch table\n         b      prr_what(r5)       ;\n* branch table\nprr_what b      prr_nok            ; r5=0\n         b      prr_yn             ; r5 = 1, Y or N\n         b      prr_no             ; r5 = 2, NO\n         b      prr_yes            ; r5 = 3, YES\n*\n* REPLY=(Y) or REPLY=(N) was specified (maybe)\n*\nprr_yn   ds     0h\n         cli    0(r6),c'Y'\n         be     prr_set_yes\n         cli    0(r6),c'N'\n         be     prr_set_no\n         b      prr_nok            ; wrong, need Y or N\n*\n* REPLY=(YES) was specified (maybe)\n*\nprr_yes  ds     0h\n         clc    0(3,r6),=c'YES'    ; the only one 3 bytes long\n         be     prr_set_yes\n         b      prr_nok\n*\n* REPLY=(NO) was specified (maybe)\n*\nprr_no   ds     0h\n         clc    0(2,r6),=c'NO'     ; the only one 2bytes long\n         bne    prr_nok\n*\n* REPLY=(NO) desired (default). Will use WTO.\n*\nprr_set_no  ds     0h\n         tm     @reply,L'@reply    ; 2nd time?\n         bo     prr_nok\n         b      prr_ok             ; flag is not set already\n*\n* REPLY=(YES) desired. Will use WTOR.\n*\nprr_set_yes ds     0h\n         tm     @reply,L'@reply    ; 2nd time?\n         bo     prr_nok\n         oi     @reply,l'@reply    ; else set flag\nprr_ok   cli    *,x'95'            ; set cc .eq. 0\n         b      prr_both\nprr_nok  cli    *,x'93'            ; set cc .ne. 0\nprr_both lm     r0,r14,save_psp\n         br     r14\n*\n\n*-------------------------------------------------------------\n* Get next subparm from values separated by commas,\n*  values all numeric, cannot be zero, result is converted\n*  to binary and returned in r1.\n*\n*\n* R5 - length to scan\n* r6 - addr\n*\n* if there is nothing more to return - r1 is set to 0\n*\n* bad data - cc .ne. 0 is set, else cc=0\n*\n* r14 - linkage reg\n*\n*-------------------------------------------------------------\nget_next  ds   0H\n         ltr   r5,r5              ; any data left?\n         bz    gn_eof             ; no, leave\n         lr    r2,r6              ; copy start address\ngtn_0    ds    0H\n         cli   0(r2),c','\n         be    gn_got\n         cli   0(r2),c'0'         ; validate data\n         bl    gn_nok             ; less than 0\n         cli   0(r2),c'9'         ; validate data\n         bh    gn_nok             ; or more than 9\n         la    r2,1(,r2)          ; next position\n         bct   r5,gtn_0           ; scan\n         la    r5,1               ; to compensave for bctr later\n* r2 at next byte after kwrd\ngn_got   ds    0H\n         lr    r3,r2              ; save addr\n         sr    r2,r6              ; compute size\n         lr    r1,r6              ; start address for conversion\n         la    r6,1(,r3)          ; either after comma or useless\n         bctr  r5,0               ; - 1 = size left or 0\n*\n* now: r2 - size to convert, r1-address\n*\n         c     r2,=f'2'           ; more than 2 digits?\n         bh    gn_nok             ; cannot be\n         xc    cvtdec,cvtdec      ; for debugging\n         bctr  r2,0               ; -1\n         b     *+10               ; ---always around---+\n         pack  cvtdec,0(0,r1)     ; *** executed ***   |\n         ex    r2,*-6             ; <------------------+\n         cvb   r1,cvtdec          ; convert to bin\n         b     gn_ok\n\ngn_nok   cli  *,x'93'             ; cc .ne. 0 bad data\n         br   r14\n\ngn_eof   slr  r1,r1               ; nothing to process anymore\ngn_ok    cli  *,x'95'             ; cc=0 good return\n         br   r14\n         SPACE 2\n********************************************\n* Parms table:\n*  al2   keyword size\n*  al4   processing routine address\n*  cl14  keyword\n*\n********************************************\nparmtab  ds    0H\n         dc    al2(9),al4(process_routcde),CL14'ROUTCDE=('\nptel     equ   *-parmtab             ; entry length\n         dc    al2(6),al4(process_desc),CL14'DESC=('\n         dc    al2(7),al4(process_reply),CL14'REPLY=('    ; for wtor\n         dc    al2(0)                ; last entry\n         EJECT ,\n*\n*--------------------------------------------------------------------*\n* Incorrect call - arguments missing or wrong.\n* Set rc to 8 and issue error message\n*--------------------------------------------------------------------*\nINCORARGS DS   0H\n         LA    R1,ERM001          ; issue error message\n         BAL   R14,issue_error    ; ...\n         MVI   KCOTH+4,C'8'       ; rc=8\n         B     EXIT               ; Return to caller.\n         SPACE 2\n************************************************\n* issue error message\n*  R1 - error message address\n*    first 4 bytes of the message is text size.\n************************************************\nissue_error ds 0h\n        stm  r0,r14,save_say\n\n* set up irxsay plist\n         LA    R2,KCWRITEERR      ; -> CL8'WRITEERR'\n         ST    R2,saywr           ; 1st parm\n         la    r2,astring\n         st    r2,saystra         ; 2nd parm\n         la    r2,lstring\n         st    r2,saystrl         ; 3rd parm\n         oi    saystrl,x'80'      ; is the last parm\n\n         ICM   R0,B'1111',0(R1)   ; size is 1st 4 bytes\n         LA    R1,4(,R1)          ; position at text\n\n         st    r1,astring         ; build error message address\n         st    r0,lstring         ; build error message size\n\n         L     R0,ENV             ; Optional environment block address\n         LA    R1,say             ; IRXSAY plist\n         L     R15,ZZZSAY         ; Saved address\n         BALR  R14,R15            ; Go there\n*\n         lm   r0,r14,save_say\n         br   r14                 ; back to caller\n*\n*--------------------------------------------------------------------*\n*                    EXIT\n*--------------------------------------------------------------------*\nEXIT     DS    0H\n*\n* Allocate EVALBLOCK if needed and move the result data there\n*\n         LA    R1,RLTSUB$         ; RLTSUB plist\n         L     R15,=V(RLTSUB)     ; Routine address\n         BALR  R14,R15            ; Call it\n*\n* Rexx will set the result.\n*\nEXIT0    LGN@RET RC=RETCODE       ; Return code\n         EJECT ,\n*--------------------------------------------------------------------*\n*     CONSTANTS AND WORK AREAS\n*--------------------------------------------------------------------*\nKCEXCOM  DC    CL8'IRXEXCOM'      ; Need for the call to IRXEXCOM\nKCREPLY  DC    CL5'REPLY'         ; Variable name to be set\nKCWRITEERR DC  CL8'WRITEERR'      ; For IRXSAY\nblanks   dc    cl80' '              ; handy\nKCOK     DC    AL4(KCOKE-KCOK-4)    ; Result length\n         DC    X'F0'                ; C'0'\nKCOKE    EQU   *\n*\n* Misc values for WTO macro\n*\nMCSFLAG  DC    B'1000000000000000'      MCSFLAGS\n*\nXFFS     DC    X'FFFFFFFF'       ; to test for args\n*\n* Error messages\n*\nERM001 DC AL4(LERM001),C'RXWTO001E Incorrect argument(s)'\nLERM001 EQU *-ERM001-4\n*\nERM002 DC AL4(LERM002),C'RXWTO002E Error from WTO macro'\nLERM002 EQU *-ERM002-4\n*\nERM003 DC AL4(LERM003),C'RXWTO003E Error from WTOR macro'\nLERM003 EQU *-ERM003-4\n*\n* Translate to uppercase\n*\n         DS    0D\nUPPER    DC    256AL1(*-UPPER)\n         ORG   UPPER+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPPER+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPPER+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n*\n* WORKAREA DSECT. R13 points to it.\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                ; Registers save area\nRETCODE  DS    F                  ; Retcode - 0\nsave_process_parm ds 16f          ; save area for process_parm\nsave_psp          ds 16f          ; subparm save area\nsave_say          ds 16f\ncvtdec   ds    d                  ; work area for conversion\n*\n* Plist to call RLTSUB\n*\nRLTSUB$  RLTPLST DSECT=NO\n*\n* Do not change the order of the next 2 fields.\n*\nLP       DS    F                  ; Length of parameter\nAP       DS    F                  ; Address of parameter\n*\n* This is a return value (RC or RETCODE) for this function.\n*\n* RC is set to 8 if error occurs - incorr argument, wto, wtor.\n*\nKCOTH    DS    F                  ; size\n         DS    X                  ; Last byte of retcode in hex\nLKCOTH   EQU   *-KCOTH\n*\n* Flag to mark misc options.\n*\nFLAG     DS    X'00'\n*@TEXT   EQU   FLAG,X'80'         ; message  parameter processed\n@ROUTCDE EQU   FLAG,X'40'         ; ROUTCDE= parameter processed\n@DESC    EQU   FLAG,X'20'         ; DESC=    parameter processed\n@REPLY   EQU   FLAG,X'10'         ; REPLY=   parameter processed\n\n**************************************************\n* WTO macro plist - ROUTCDE/DESC specified or not.\n**************************************************\nWTO_PL   DS    0F\nWTO_LEN  DS    XL2                ; text length + 4\nWTO_MCS  DS    XL2                ; mcsflags\nWTO_TXT  DS    CL120' '           ; room for a message\n         DS    XL8                ; just a placeholder\nWTO_DESC DS    XL2                ; descriptor codes\nWTO_ROUT DS    XL2                ; routing codes\n*\n***************************************************\n* WTOR macro plist - ROUTCDE/DESC specified or not.\n***************************************************\nWTOR_PL  DS    0F\nWTOR_RA  DS    A                  ; reply address+x'80000000'\nWTOR_EA  DS    A                  ; ecb address\nWTOR_RL  DS    X                  ; reply length\nWTOR_LEN DS    XL1                ; text length + 4\nWTOR_MCS DS    XL2                ; mcsflags\nWTOR_TXT DS    CL120' '           ; room for a message\n         DS    XL8                ; just a placeholder\nWTOR_DESC EQU  WTO_DESC,2         ; descriptor codes, copied after msg\nWTOR_ROUT EQU  WTO_ROUT,2         ; routing codes\n*\nreply ds cl120' '                 ; area for reply from operator\nreply_length equ l'reply\n*\nwtor_ecb ds    f                  ; ecb for wtor macro\n*\nzzzexcom ds    f                  ; irxexcom address from irxexte\nzzzsay   ds    f                  ; irxsay   address from irxexte\n*\n* irxexcom  plist\n*\nEXCOM    DS    0D                 ; IRXEXCOM plist\nEXCOMP1  DS    F                  ; Points to cl8'IRXEXCOM'\nEXCOMP2  DS    F                  ; Should be 0.\nEXCOMP3  DS    F                  ; Should be 0.\nEXCOMP4  DS    F                  ; Point to first SHVBLOCK\n         ORG   EXCOMP4\n         DC    X'80',AL3(0)       ; Last parameter\n         ORG   ,\n*\n* irxsay plist\n*\nsay      ds    0d\nsaywr    ds    a                  ; ptr to write/writeerr\nsaystra  ds    a                  ; ptr to a(string)\nsaystrl  ds    a                  ; ptr to F'string_length'\n         org   saystrl\n         DC    X'80',AL3(0)       ; Last parameter\n         ORG   ,\nastring  ds    a                  ; a(string)\nlstring  ds    f                  ; length of string\n*\n         DS    0D\nSHVB     DS    XL(SHVBLEN)'00'    ; Place for SHVBLOCK\n*----------------\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*--------------------------------------------------------------------*\n         YREGS\n         PRINT ON\n*--------------------------------------------------------------------*\n* REXX MACROS.\n*--------------------------------------------------------------------*\n         IRXENVB                  ; Environment block (R0 on entry)\n         IRXEFPL DSECT=YES        ; External function plist (R1)\n         IRXARGTB                 ; Map the argument list.\n         IRXSHVB                  ; Shared variables block\n         IRXEVALB                 ; EVALBLOCK to return result.\n         IRXEXTE                  ; External entry points\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLEEP": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SLEEP       TITLE 'Wait a few seconds (or more)'\nSLEEP       AMODE 31\nSLEEP       RMODE ANY\n*----------------------------------------------------------------------\n* When called as an external rexx subroutine this program will\n* wait for a given number of seconds.\n*\n*   R15 is always set to 0; if arguments are missing or\n*      something equally ugly happened, it is set to 1,\n*      therefore exec terminates;\n*\n*   Result is set to '0' if\n*      we are terminated because if time expiration, and is\n*      set to 1 if wait was terminated by attention.\n*\n*   Example: rc = sleep('5');\n*\n*\n* Note that this function can be used standalone as well as a part\n* of rexx function package\n*\n*\n*03/95 Alex Brodsky\n*----------------------------------------------------------------------\nSLEEP       CSECT\n         USING SLEEP,R15            ; ADDRESS PROGRAM.\n         SAVE  (14,12),,SLEEP.ALEX.BRODSKY.&SYSDATE.&SYSTIME\n         LR    R12,R15            ; SET PROGRAM BASE.\n         DROP  R15\n         USING SLEEP,R12            ; ADDRESS PROGRAM.\n*---------------\n*      ENTER AMODE 31 - not necessary, rexx runs in 31-bit mode\n         L     R10,AMODES         ; SETUP FOR BSM\n         L     R2,AMODES+4        ; SETUP FOR BSM\n         BSM   R10,R2             ; SAVE OLD AMODE - SET AMODE31.\nAMODES   DC    A(EXITX)           ; ADDRESS TO EXIT.\n         DC    A(ENTRY31+X'80000000') ; ENTER ENTRY31 IN AMODE 31.\nENTRY31  DS    0H\n*---------------\n         LA    R0,WORKLEN         ; SET LENGTH AND\n         GETMAIN R,LV=(0)         ; GET DYNAMIC SAVE AREA.\n         LA    R6,0(R1)\n         LA    R7,WORKLEN         ; CLEAR SAVE AREA.\n         SR    R8,R8\n         SR    R9,R9\n         MVCL  R6,R8 .            ; CLEAR GETMAIN AREA.\n         ST    R1,8(R13)          ; CHAIN SAVEAREAS.\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING WORKAREA,R13\n         ST    R10,EXITMODE       ; SAVE OLD MODE AND EXIT ADDRESS.\n         XC    RETCODE(4),RETCODE ; SET NORMAL RETURN CODE - 0\n         L     R1,4(,R13)         ; GET TO THE PREV SAVEAREA\n         LM    R0,R1,20(R1)       ; RESTORE ENVB AND EFPL POINTERS\n         ST    R0,ENV             ; SAVE IT FOR CALLS TO REXX SERVICES\n         SPACE 3\nSTART    DS    0H\n         LR    R9,R1              ; GET THE EFPL ADDRESS\n         USING EFPL,R9            ; EXTENDED FUNCTION PLIST\n*--------------------------------------------------------------------*\n* INITIALIZE ALL THE NECESSARY PLISTS.\n*--------------------------------------------------------------------*\n*. INIT THE EVALBLOK.\n*.  MOVE AN ADDRESS OF A CL1'0' RESULT STRING IN THE\n*.  RESULT VARIABLE.\n*.  RLTSUB routine CODE WILL SET THE RESULT WITH WHATEVER\n*.  IS POINTED TO BY 'RESULT' VARIABLE.\n*.\n         L     R2,EFPLEVAL        ; GET THE EVALBLOCK ADDRESS\n         ST    R2,EVB             ; SAVE IT FOR EXIT ROUTINE.\n         LA    R2,KCOK0           ; POINT TO CL1'0'\n         ST    R2,RESULT          ; ...\n*\n*--------------------------------------------------------------------*\n* NOW LOOK AT ARGUMENTS PASSED BY THE CALLER.\n*  IF ARGUMENT IS NOT SUPPLIED (POINTER IS ZERO) OR\n*  MISSING ENTIRELY (WE HIT THE FENCE, 8X'FF'), WE MOVE MESSAGE TO\n*  THE RESULT AREA AND EXIT THE FUNCTION.\n*--------------------------------------------------------------------*\n         L     R4,EFPLARG         ; POINTER TO THE ARGUMENTS\n         USING ARGTABLE_ENTRY,R4  ; MAP THE ENTRY\n* ARG 1 - INTERVAL, MUST BE PRESENT.\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_PTR ; GET THE ADDRESS\n         BNP   INCORARGS          ; WRONG!\n         ST    R3,AP              ; SAVE THE ADDRESS\n         ICM   R3,B'1111',ARGTABLE_ARGSTRING_LENGTH ; GET THE LENGTH\n         BNP   INCORARGS          ; WRONG!\n         ST    R3,LP              ; SAVE THE LENGTH\n         LA    R4,ARGTABLE_NEXT   ; AJUST BASE - NEXT ENTRY\n* ARG 2 - NOTHING YET. IGNORE IF SUPPLIED\n         DROP  R4                 ; ARGTABLE_ENTRY\n         DROP  R9                 ; EFPL\nCONTINUE DS    0H\n*=================================================================\n* Now we will convert the input argument to binary seconds\n*\n         LM    R0,R1,LP           ; Get the length and address\n         C     R0,=F'5'           ; Greater than 5  digits?\n         BH    INCORARGS          ; Invalid length\n         LTR   R2,R0              ; Get length of the field\n         BZ    INCORARGS          ; Invalid size\n         LR    R3,R1              ; Save the address of source\n         BCT   R2,ADBTRT          ; Decr for EX and br around\nDBTRT    TRT   0(0,R3),CVTXD      ; *** EXECUTED ***\nADBTRT   EX    R2,DBTRT           ; Try to find a non-digit\n         BNZ   INCORARGS          ; Error, a non-decimal digit\n         B     ADBPK              ; Br around executed instruction\nDBPK     PACK  CVTDEC,0(0,R3)     ; *** EXECUTED ***\nADBPK    EX    R2,DBPK            ; Pack digits into packed dec\n         CP    CVTDEC,=PL8'86400' ; More than 24 hours?\n         BH    INCORARGS          ; Yes, too large for a register\n         MP    CVTDEC,=PL4'100'   ; Need for STIMER\n         CVB   R1,CVTDEC          ; Convert to binary\n         ST    R1,TIMEINT         ; And save for STIMER\n*=================================================================\n         MVC   ECBMARK(8),=CL8'-----ECB'   ; Pointer to ECB\n         LA    R3,ECB1                     ; ... for STIMERM\n         STCM  R3,B'1111',ECBMARK          ; ... PARM\n         LA    R3,STAXLIST     ; Load address of STAX parm\n STAX  ATTNEXIT,USADDR=ECB1,MF=(E,(3))  ; Issue STAX macro\n         LA    R3,STIMER_SET_L  ; Load address of plist\n         LA    R4,TIMEID\n         LA    R5,TIMEINT\n    STIMERM SET,ID=(4),BINTVL=(5),WAIT=NO,EXIT=TIMEEXIT,MF=(E,(3)),    *\n               PARM=ECBMARK\n         WAIT  1,ECB=ECB1\n*\n* Determine, why are we here?\n*\n*  We will exit with rc=1 if teminated by ATTN, else - rc=0\n*\n         LA    R2,KCOK1           ; POINT TO CL1'1'\n         TM    ECB1+3,ATTNHIT  ; Attention termination?\n         BO    CANCEL_TIMER       ; Yes\n         LA    R2,KCOK0           ; POINT TO CL1'0'\n         TM    ECB1+3,EXPIRED  ; Interval expired?\n         BO    KILL_STAX          ; Yes\nCANCEL_TIMER DS 0H\n         LA    R3,STIMER_CAN_L  ; Load address of plist\n         LA    R4,TIMEID\n*        STIMERM CANCEL,ID=(4),MF=(E,(3)) ; Cancel the timer\nKILL_STAX DS   0H\n         STAX ,\n         B     OUT\n*=================================================================\nOUT      DS    0H\n         ST    R2,RESULT          ; Save result for exit routine\n         B     EXIT               ; ... and go there\n*--------------------------------------------------------------------*\n* INCORRECT CALL - ARGUMENTS MISSING, ETC.\n* SET RETCODE TO 1\n*--------------------------------------------------------------------*\nINCORARGS DS   0H\n         MVI   RETCODE+3,1        ; GENERATE THE ERROR MESSAGE\n         B     EXIT               ; RETURN TO CALLER.\n*--------------------------------------------------------------------*\n*                    EXIT\n*--------------------------------------------------------------------*\nEXIT     DS    0H\n*\n* Allocate EVALBLOCK if needed and move the result data there\n*\n         LA    R1,RLTSUB$         ; RLTSUB plist\n         L     R15,=V(RLTSUB)     ; Routine address\n         BALR  R14,R15            ; Call it\n*\n* Rexx will set the result.\n*\nEXIT0    DS    0H\n         L     R15,RETCODE        ; GET RETURN CODE.\n         L     R10,EXITMODE       ; SET FOR RETURN TO CALLER'S AMODE.\n         LR    R1,R13             ; ADDRESS SAVE AREA.\n         L     R13,4(,R13)        ; ADDRESS PREV SAVE AREA.\n         ST    R15,16(R13)        ; SET RETURN CODE.\n         LA    R0,WORKLEN         ; SET LENGTH AND\n         FREEMAIN R,A=(1),LV=(0)  ; FREE WORKAREA.\n         BSM   0,R10\nEXITX    DS    0H\n         RETURN (14,12)\n         EJECT\n*-----------------------------------------*\n* TSO attn exit                           *\n*                                         *\n* Does not do much - gets the address of  *\n* ECB (passed as parameter to STAX macro  *\n* and POSTs it to wake up WAIT macro.      *\n*\n*-----------------------------------------*\nATTNEXIT DS   0H\n         USING *,R15\n         L     R2,8(,R1)          ; Get the USADDR\n         POST  (2),ATTNHIT        ; Wake up\n         BR    R14                ; Back to TSO\n*-----------------------------------------*\n* TSO STIMERM exit                        *\n*                                         *\n* Does not do much - gets the address of  *\n* ECB (passed as parameter to STIMERM     *\n* and POSTs it to wake up WAIT macro.      *\n*\n*-----------------------------------------*\nTIMEEXIT DS   0H\n         USING *,R15\n         L     R2,4(,R1)          ; Get the PARM\n         POST  (2),EXPIRED        ; Wake up\n         BR    R14                ; Back to TSO\n*--------------------------------------------------------------------*\n*     CONSTANTS AND WORK AREAS\n*--------------------------------------------------------------------*\nKCOK0    DC    AL4(KCOK0E-KCOK0-4)  ; RESULT LENGTH\n         DC    C'0'                 ; NO MATCH\nKCOK0E   EQU   *\n*\nKCOK1    DC    AL4(KCOK1E-KCOK1-4)  ; RESULT LENGTH\n         DC    C'1'                 ' MATCH\nKCOK1E   EQU   *\n*\n* Translate and test table for dec to bin conversion routine\n*\n         DS    0D\nCVTXD    DC    256AL1(1)          ; non-digits\n         ORG   CVTXD+C'0'\n         DC    AL1(0,0,0,0,0,0,0,0,0,0)   ; digits 0 to 9\n         ORG   ,\n*\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n*\n* WORKAREA DSECT. R13 points to it.\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                ; REGISTERS SAVE AREA\nEXITMODE DS    A                  ; CALLERS AMODE\nRETCODE  DS    F                  ; RETCODE\n*\n* Plist to call RLTSUB\n*\nRLTSUB$  RLTPLST DSECT=NO\n*\n* Do not change the order of the next 2 fields.\n*\nLP       DS    F                  ; Length of parameter\nAP       DS    F                  ; Address of parameter\n*\nCVTDEC   DS    D'0'               ; Work area\n*\n* ECB\n*\nECBMARK  DC    CL8'nnnn-ECB'      ; Will be an address of ECB1\nECB1     DC    F'0'     ; ECB for the wait macro\n*\n* ID for the STIMER macro\n*\nTIMEID   DC    A(1)\n*\n* Interval timer wait (in seconds).\n*\nTIMEINT  DC    A(10*100)\n*\n* STAX macro plist\n*\nSTAXLIST STAX  ATTNEXIT,MF=L\n*\n* Stimer set plist\n*\nSTIMER_SET_L STIMERM SET,MF=L\nSTIMER_CAN_L STIMERM CANCEL,MF=L\nBP       DS    CL1      ; BYTE OF PATTERN\nBP1      DS    CL1      ; NEXT BYTE OF PATTERN\nBS       DS    CL1      ; BYTE OF STRING\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*--------------------------------------------------------------------*\n         PRINT ON\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12   BASE\nR13      EQU   13   WORKAREA BASE\nR14      EQU   14\nR15      EQU   15\n*\nATTNHIT  EQU   1\nEXPIRED  EQU   2\n*--------------------------------------------------------------------*\n* REXX MACROS.\n*--------------------------------------------------------------------*\n         IRXENVB                  ; ENVIRONMENT BLOCK (R0 ON ENTRY)\n         IRXEFPL DSECT=YES        ; EXTERNAL FUNCTION PLIST (R1)\n         IRXARGTB                 ; MAP THE ARGUMENT LIST.\n         IRXEVALB                 ; EVALBLOCK TO RETURN RESULT.\n         IRXEXTE                  ; EXTERNAL ENTRY POINTS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPFDOC": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x01\\x02O\\x01\\x01\\x13\\x0f\\x13'\\x00W\\x00W\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-24T00:00:00", "modifydate": "2001-05-10T13:27:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "SAYB"}, "text": "doc for the REXX function ISPF logon proc enhancement\n-----------------------------------------------------\n\n- REXX function is written in assembler to do the following:\n   - given the input argument (probably, userid) locate in\n     either Exception table or Default table the following\n     values:\n      - Prefix - e.g. USR, SYS, OPS, etc.\n      - Logoff flag - either 1 (logoff after exiting from ISPF) or 0.\n      - Initial ISPF command as a parameter to ISPSTART.\n\n- LOGON proc will call this exec and then determine extra allocations,\n  if needed, and other changes, if needed, to a standard logon\n  sequence.\n\n- REXX function has the following components:\n  - ASMSPFP        - jcl to build\n  - LGN@ENT        - entry macro\n  - LGN@RET        - return macro\n  - LGNASML        - proc used by ASMSPFP\n  - LGNSPF         - main module.\n  - LGNSRCH        - macro to perform binary search in a table\n  - LGNUDEFD       - data module, to define Defaults table\n  - LGNUDEFE       - data module, to define exceptions table\n  - LGNUDEFN       - macro to be used in the data module(s), to define\n                     an entry\n  - LGNUDEFP       - macro to be used in the data module(s), to\n                     generate appropriate table\n\n- Logic.\n  - LGNUDEFD defaults module is built for the first character\n    of a userid - the whole alphabet.\n  - LGNUDEFE exception module is build for users that are exceptions,\n    if, for example, you would want to exclude U user from logging\n    off after exiting from ISFP.\n    - see comments inside these modules for coding rules.\n      Note that LGNUDEFP macro generates a table sorted in ascending\n      order.\n\n  - LGNSPF module accepts only the 1st argument, it ignores the\n    rest of arguments. If no arguments are passed to the function,\n    if exits with rc<>0 thus forcing the calling exec to terminate.\n\n    First, lookup is performed in the exception data table, and if\n    entry is found - rexx variables are set and function exits with\n    rc=0.\n\n    The following variables are set from the table entry:\n      DU@USR    - matching user entry from either table.\n                  It is either 1 character long, if defaults table\n                  was used, or userid if exception table was used.\n                  Note that the length of this variable is always\n                  equal to 7, padded with blanks if necessary.\n      DU@PFX    - prefix, always 3 bytes long.\n      DU@OFF    - Y or N, logoff flag.\n      DU@CMD    - initial ISPF command, for example\n                  PANEL(SYS@MSTR) NOLOGO\n\n- How to add another user.\n\n  - if user fits the default profile (for example, userids that\n    start with C'S' have prefix=SYS, logoff is set to N and the\n    default command is PANEL(SYS@MSTR) NOLOGO - then nothing needs\n    to be done.\n  - if user does not fit the default profile, then code an entry\n    in the LGNUDEFE data module describing the user's parameters),\n    then run ASMSPFP job to rebuild the LGNSPF module.\n    Since this module is probably placed in link-listed library,\n    LLA REFRESH needs to be done to pick up the change.\n\n- how to add an extra field.\n\n  - fields are defined in a few places in LGNDEFN macro -\n     - DUDEF - dsect to describe the table entry\n     - UVARTCNT - csect to describe rexx variables that are set.\n     - DUVART   - dsect to describe UVARTCNT\n     - and code in the macro that adds each entry to a global array.\n  - macro LGNUDEFP sorts the global array, so code will have to be\n     added there for an extra element.\n     If too many entries are defined, use ACTR assembler instruction\n      to increase max loop counter.\n\n  - Module LGNSPF does not have to be changed unless there is a change\n    in entry processing logic.\n\n  - change LGNUDEFD/LGNUDEFE data modules to reflect the added field\n  - rebuild the LGNSPF module.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XL": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x003o\\x01\\x003o\\x15\\x18\\x03k\\x03k\\x00\\x00\\xe2\\xc1\\xe8\\xc2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-01T00:00:00", "modifydate": "2000-12-01T15:18:00", "lines": 875, "newlines": 875, "modlines": 0, "user": "SAYB"}, "text": "         MACRO\n&NAME    ISPLINK &OPRNDS,&RC=,&ERROR=\n         GBLB  &IHBSWA\n&IHBSWA  SETB  1                       VL=1\n&NAME    LA    R1,ISPLINK_PLIST        ; ISPLINK parm list\n         IHBOPLST ,&OPRNDS,MF=(E,(1))\n         L     R15,ISPLINK@            ; Address from load\n         BALR  R14,R15                 ; Invoke ISPLINK\n         AIF   (T'&RC EQ 'O').ERR\n         ST    R15,&RC                 ; Save retcode\n.ERR     ANOP\n         AIF   (T'&ERROR EQ 'O').MEND\n         LTR   R15,R15                 ; Set condition code\n         BNZ   &ERROR\n.MEND    MEND\n*\nXL          TITLE 'Produce a 3.4 list of datasets using LM* services'\nXL          AMODE 31\nXL          RMODE ANY\n*----------------------------------------------------------------------\n* Produce a 3.4 list of datasets using LM* services\n*\n* If there is an error from ISPF service, ISPF message will be\n* displayed.\n*\n*  This example does not use IKJ* parsing macros, just to show how\n*   to code without it. Also, since this program can be called as\n*   SELECT(PGM), there will not be a CPPL available. The same is\n*   true, I think, for the edit macro call.\n*\n*\n* Call format:\n*\n*              XL DSN(dataset_name_mask) VOL(xxxxxx)\n*     or\n*              XL dataset_name_mask\n*\n*  If arguments are not present, ISPF prefix is used as a dsn mask\n*  (only for TSO XL format).\n*  Order of arguments is not important.\n*  Unidentified data is ignored, if after the last argument.\n*===================================================================\n* This program can be called as follows:\n*\n*1). TSO CMD call.\n*\n*   TSO XL dataset_name\n*   TSO XL DSN(dataset_name)\n*   TSO XL DSN(dataset_name) VOL(volser)\n*   TSO XL VOL(volser)\n*\n*2). ISPF PGM call.\n*\n*   Set in the command table (ISR) -\n*     XL   0  SELECT SUSPEND PGM(XL) MODE(FSCR) PARM(&ZPARM)\n*   Call from the command line\n*   with parameters the same as in CMD call.\n*\n*3) ISPF and SDSF point and shoot.\n*\n*    Define the command table entry (ISR, ISF) as in 2).\n*    Set PFkey to XL.\n*    Position the cursor under dataset name and press PFkey\n*\n*4). ISPF edit macro.\n*\n*    Set pfkey to !XL, and:\n*    a) type args on the command line and press pfkey\n*          or\n*    b) position cursor under the dataset name and press pfkey.\n*\n*  This program attempts to resolve GDG relative generation number,\n*  like xxx.xxxxx(0) or (-1), etc. using LOCATE/CAMLST. if\n*  it is positive or otherwise considered incorrect, it is\n*  ignored, for example, for  XXXX.XXXXX(MMMM) - (MMMM) will be\n*  ignored and XXXX.XXXXX will be DSLIST'ed.\n*\n* 12/98 axb\n*----------------------------------------------------------------------\nXL       CSECT\n         USING XL,R15                ; Address program.\n         SAVE  (14,12),,XL.SSE.ALEX.BRODSKY.&SYSDATE.&SYSTIME\n         LR    R12,R15            ; Set program base.\n         DROP  R15\n         USING XL,R12,R11         ; Address program.\n         LA    R11,2048(R12)\n         LA    R11,2048(R11)\n         LA    R0,WORKLEN         ; Set length and\n         GETMAIN R,LV=(0)         ; ... get dynamic save area.\n         LA    R6,0(R1)\n         LA    R7,WORKLEN         ; Clear save area.\n         SR    R8,R8\n         SR    R9,R9\n         MVCL  R6,R8              ; Clear GETMAIN area.\n         ST    R1,8(R13)          ; Chain saveareas.\n         ST    R13,4(R1)          ; ...\n         LR    R13,R1             ; ...\n         USING WORKAREA,R13\n****     XC    RETCODE(4),RETCODE ; Set normal return code - 0\n         L     R1,4(,R13)         ; Get to the prev savearea\n         LM    R0,R1,20(R1)       ; Restore parm pointers\n         SPACE 3\n*\n* End of housekeeping statements.\n*\nSTART    DS    0H\n         USING @CSRPL,@CSRP   ; Dependent using\n         MVC   @CSREYE(4),=CL4'@CSR'\n         LR    R10,R1\n*----------------------------------------------------------------\n*  See if ISPF is active, get the prefix, if needed.\n*----------------------------------------------------------------\n*\n* Load the ISPLINK interface module address and save it.\n*\n         LOAD  EPLOC=@ISPLINK\n         ST    R0,ISPLINK@             ; Save ISPLINK address\n*\n         ISPLINK (@CONTROL,@ERRORS,@RETURN),RC=RETCODE,ERROR=EXIT\n*\n* Init misc areas.\n*\n         MVC   DSN(L'DSN),BLANKS       ; Prepare\n         MVC   VOL(L'VOL),BLANKS       ; ...\n         MVC   TSTGDG(8),=8C'0'        ; Init for GDG testing\n         MVC   TMPCOLSZ(4),=F'5'       ; Variable size\n         MVC   TMPLINESZ(4),=F'6'      ; Variable size\n         MVC   RELGDG(L'RELGDG),BLANKS ; Prepare\n*\n* determine if we are called as SELECT(PGM) or SELECT(CMD).\n*  - if SELECT(PGM), then R1 points to a buffer, 1st halfword\n*    is a size, the rest - parm. High order bit is set.\n*  - if SELECT(CMD), then R1 points to CPPL. High order bit not set.\n*\n*\n         ICM   R15,B'1111',0(R10) ; see if called as PGM\n         BNM   TSOCMD             ; No\n         LH    R4,0(,R15)         ; Parm size\n         LTR   R4,R4              ; Anything there?\n         BNZ   PGM                ; Yes, definitely PGM\n* Could be edit macro. Issue first macro cmd - ISREDIT MACRO (INARG)\n* if error try to get the data from the screen.\n*\n    ISPLINK (@ISREDIT,@ISREM1SZ,@ISREM1),ERROR=ATCURSORP\n*\n* Yes, it is an edit macro. See if there is an argument, and if\n*   so interpret just like PGM or CMD argument(s).\n*   if error, use default parm.\n*\n         OI    EDITMAC,L'EDITMAC        ; Set a flag\n         MVC   TMPWORD(4),=AL4(L'INARG) ; Target size\n*\n* Copy the variable from the pool to our work area\n    ISPLINK (@VCOPY,=C'(INARG)',TMPWORD,INARG,@MOVE),ERROR=DEFPARM\n         ICM   R4,B'1111',TMPWORD   ; Parm size?\n         BNP   ATCURSOR             ; Nothing there, see if at cursor\n         LA    R3,INARG             ; Parm address\n         B     JOIN_CMD_PGM         ; Join common processing\n*\n* We are not an edit macro. Let's try to get the data from the\n* ISPF (internally) maintained Logical Display Table.\n*\nATCURSORP DS   0H\n         ICM   R15,B'1111',@CSRADDR ; Is routine available?\n         BZ    DEFPARM              ; No, did not LKED\n         LA    R1,@CSRP             ; Get the plist\n         BALR  R14,R15              ; will do\n         LTR   R15,R15              ; Any luck there?\n         BNZ   DEFPARM              ; Forget it.\n         B     JOIN_FROM_ATCURSORP  ; Try to get DSN this way.\n*\n* We were called as Edit macro, without arguments.\n*  See if we can get DSN from the cursor position.\n*\nATCURSOR DS    0H\n*\n* Get the cursor position - line number and column number.\n*  ISREDIT (LINE,COL) = CURSOR\n*\n    ISPLINK (@ISREDIT,@ISRLCCSZ,@ISRLCC),ERROR=DEFPARM\n*\n* Get the LINE and COL. See if cursor was on command line.\n*   Will use it later to restore cursor position.\n*   Be carefull not to change the variables order.\n*\n    ISPLINK (@VCOPY,=C'(COL,LINE)',TMPCOLSZ,TMPCOL,@MOVE),ERROR=DEFPARM\n*   ISPLINK (@VCOPY,=C'(COL)',TMPCOLSZ,TMPCOL,@MOVE),ERROR=DEFPARM\n*   ISPLINK (@VCOPY,=C'(LINE)',TMPLINESZ,TMPLINE,@MOVE),ERROR=DEFPARM\n         PACK  DWORD,TMPCOL+2(3)    : convert from printable\n         CVB   R4,DWORD             ; Cursor position - column\n         ST    R4,CURPOSC           ; Save cursor position (col).\n         LTR   R4,R4                ; Cursor on command line?\n         BNZ   EDMAC01              ; No. continue.\n*\n* Set error message - Place cursor on DSN - and exit.\n*\n    ISPLINK (@VREPLACE,@ZEDSMSG,@ZEDSMSG1SZ,ZEDSMSG1),RC=RETCODE,ERROR=*\n               EXIT\n    ISPLINK (@VREPLACE,@ZEDLMSG,@ZEDLMSG1SZ,ZEDLMSG1),RC=RETCODE,ERROR=*\n               EXIT\n         MVC   ZERMSG(8),@ISRZ000 ; Set error message number\n         B     EXIT\n*\n* Cursor on the data line.\n*\nEDMAC01  DS    0H\n*\n* Get the data line under the cursor (only 255 bytes).\n*  ISREDIT (DATALINE) = LINE .ZCSR\n*\n    ISPLINK (@ISREDIT,@ISRDLCSZ,@ISRDLC),ERROR=DEFPARM\n*\n* Copy this variable into a buffer. Note that the size will be\n*   returned in DTLSZ variable.\n*\n         MVC   DTLSZ(4),=AL4(L'DATALINE) ; Work buffer size (256)\n  ISPLINK (@VCOPY,=C'(DATALINE)',DTLSZ,DATALINE,@MOVE),ERROR=DEFPARM\nJOIN_FROM_ATCURSORP DS 0H\n         BAL   R14,GETDSN      ; Attempt to find DSN on the data line\n         BZ    DEFPARM         ; ... and then use it.\n*\n* Set error message - Could not find DSN - and exit.\n*\n    ISPLINK (@VREPLACE,@ZEDSMSG,@ZEDSMSG2SZ,ZEDSMSG2),RC=RETCODE,ERROR=*\n               EXIT\n    ISPLINK (@VREPLACE,@ZEDLMSG,@ZEDLMSG2SZ,ZEDLMSG2),RC=RETCODE,ERROR=*\n               EXIT\n         MVC   ZERMSG(8),@ISRZ000 ; Set error message number\n         B     MACEXIT            ; Restore cursor position end exit\n*\n* We were called as SELECT(PGM)\n*\nPGM      DS    0H\n         LA    R3,2(,R15)         ; Parm address\n         B     JOIN_CMD_PGM       ; Join common processing\n*\n* We were called as SELECT(CMD) or TSO CMD\n*\nTSOCMD   DS    0H\n*\n* Get the parm from CPPL.\n*  if the parm is bad, DSN will be left blank.\n*\n*\n         USING CPPL,R10           ; Establish CPPL mapping\n         L     R2,CPPLCBUF        ; Command buffer\n*\n         LH    R4,0(R2)           ; Command buffer size\n         LH    R3,2(R2)           ; Offset to parms start\n         SH    R4,=H'4'           ; Subtract 2 halfwords size\n         SR    R4,R3              ; See what's left\n         BNP   DEFPARM            ; Not much...\n         LA    R3,4(R2,R3)        ; Position at parm start\n*\n* SELECT(PGM)\n* SELECT(CMD)\n* Edit macro\n*    all come here eventually\n*\nJOIN_CMD_PGM   DS 0H\n* Now the parm size is in R4.\n         CH    R4,=H'80'\n         BH    DEFPARM            ; Too much...\n         BAL   R14,PARSEPARM      ; Get the data supplied\n         DROP  R10\nDEFPARM  DS    0H\n*----------------------------------------------------------------\n*  Continue. Call VDEFINE service.\n*----------------------------------------------------------------\nVDEFINE  ISPLINK (@VDEFINE,@LISTIDV,LISTIDV,@CHAR,L8),RC=RETCODE\n         ISPLINK (@VDEFINE,@DSN,DSN,@CHAR,L44)\n         ISPLINK (@VDEFINE,@VOL,VOL,@CHAR,L6)\n         ISPLINK (@VDEFINE,@ZERRMSG,ZERMSG,@CHAR,L8)\n         ISPLINK (@VDEFINE,@ZPREFIX,ZPREFIX,@CHAR,L8)\n* If dsn not supplied, use prefix\n         CLI     DSN,C' '\n         BNE     LMDINIT\n* If volume is supplied and dsn is not, dont use prefix\n         CLI     VOL,C' '\n         BNE     LMDINIT\n         ISPLINK (@VGET,@ZPREFIX,@SHARED)\n         MVC     DSN(8),ZPREFIX\n*\n* In case of an error, error message will be set by the ISPF service\n*  and we will keep RC=0 to have the cursor restore process work.\n*  (I think it is back on the command line if rc<> 0).\n*\nLMDINIT  ISPLINK (@LMDINIT,@LISTIDV,DSN,VOL),ERROR=MACEXIT\nLMDDISP  ISPLINK (@LMDDISP,LISTIDV,@VOLUME,@YES)\nLMDFREE  ISPLINK (@LMDFREE,LISTIDV)\n*        B     EXIT0\n*\n*--------------------------------------------------------------------*\n*                    Exits\n*--------------------------------------------------------------------*\nMACEXIT  DS    0H                 ; Exit after edit macro.\n         TM    EDITMAC,L'EDITMAC  ; Were we called as a macro?\n         BNO   EXIT               ; No\n*\n* Restore cursor position before the call.\n*  We could've issued a more direct command CURSOR= linenum colnum\n*   but this looks neat.\n*\n    ISPLINK (@VREPLACE,=C'(COL,LINE)',TMPCOLSZ,TMPCOL)\n    ISPLINK (@ISREDIT,@ISRCRCSZ,@ISRCRC)   ; CURSOR=(LINE,COL)\nEXIT     DS    0H\n         CLI   ZERMSG,C' '        ; ??\n         BE    EXIT0\n         CLI   ZERMSG,X'00'       ; ??\n         BE    EXIT0\n         ISPLINK (@SETMSG,ZERMSG) ; Error message set by ISPF function\nEXIT0    DS    0H\n         ISPLINK (@VRESET)        ; Undo VDEFINE's\n         L     R15,RETCODE        ; Get return code.\n         LR    R1,R13             ; Address save area.\n         L     R13,4(,R13)        ; Address prev save area.\n         ST    R15,16(R13)        ; Set return code.\n         LA    R0,WORKLEN         ; Set length and\n         FREEMAIN R,A=(1),LV=(0)  ; ... free workarea.\nEXITX    DS    0H\n         RETURN (14,12)           ; Retcode already set\n         EJECT\n*--------------------------------------------------------------------*\n* Parse the parm supplied.\n*--------------------------------------------------------------------*\nPARSEPARM DS 0H\n         MVI   PARMFLAG,0         ; Prepare the flag\n***      LA    R3,4(R2,R3)        ; Position at parm start\n*----------------------------------------------------------------+\n         BCT   R4,*+10            ; Around instr                 \u00b3\n         MVC   PARM(0),0(R3)      ; *** executed ***             \u00b3\n         EX    R4,*-6             ; Copy the parm                \u00b3\n*----------------------------------------------------------------+\n         TR    PARM(L'PARM),UPCASE ; xlate all to uppercase\n         LA    R3,PARM            ; Use uppercased parm from now...\n         LA    R5,0(R3,R4)        ; Last byte of parm\n*\n* See if dataset name only, no prefix\n*\n         CLC   0(L'PFXDSN,R3),PFXDSN    ; Correct DSN prefix?\n         BE    PARSEPARM_001      ; Yes\n         CLC   0(L'PFXVOL,R3),PFXVOL    ; Correct VOL prefix?\n         BE    PARSEPARM_001      ; Yes\n* Interpret this data as dataset name.\n*----------------------------------------------------------------+\n         B     *+10               ; Around instr                 \u00b3\n         MVC   DSN(0),0(R3)       ; *** executed ***             \u00b3\n         EX    R4,*-6             ; Copy the parm as dsn         \u00b3\n*----------------------------------------------------------------+\n         B     PARSEPARM_OUT      ; ... and let ISPF figure it out\nPARSEPARM_001  DS  0H\n         BAL   R7,GETKWRD         ; Extract the keyword\n         BNZ   PARSEPARM_OUT\n         BAL   R7,GETNB           ; Next keyword parm\n         BNZ   PARSEPARM_OUT\n         BAL   R7,GETKWRD         ; Extract the keyword\n* The rest of command line is ignored\nPARSEPARM_OUT DS 0H\n          BR   R14\n****\n* Get the keyword from the keyword parm\n*   R3 - parm address\n*   R4 - parm size - 1\n****\nGETKWRD  DS    0H\n* first determine what is it that is being extracted and set\n* some related values\n         CLC   0(L'PFXDSN,R3),PFXDSN    ; Extracting DSN parm?\n         BE    GETKWRD_DSN      ; Yes\n         CLC   0(L'PFXVOL,R3),PFXVOL    ; Correct VOL prefix?\n         BE    GETKWRD_VOL        ; Yes\nGETKWRD_NOK DS 0H\n         CLI   *,X'93'            ; Set cc<>0\n         BR    R7                 ; out\nGETKWRD_OK DS 0H\n         CLI   *,X'95'            ; Set cc=0\n         BR    R7                 ; out\n* DSN(xxxx.xxx.xxx)\nGETKWRD_DSN   DS 0H\n         TM    PARMDSN,L'PARMDSN  ; Already extracted?\n         BO    GETKWRD_NOK        ; Yes\n         LA    R8,DSN             ; Point to DSN\n         L     R9,L44             ; ... and max size\n         L     R6,PFXDSNSZ        ; ... and prefix size\n         OI    PARMDSN,L'PARMDSN  ; Mark as already extracted\n         B     GETKWRD_001\n* VOL(xxxxxx)\nGETKWRD_VOL   DS 0H\n         TM    PARMVOL,L'PARMVOL  ; Already extracted?\n         BO    GETKWRD_NOK        ; Yes\n         LA    R8,VOL             ; Point to VOL\n         L     R9,L6              ; ... and max size\n         L     R6,PFXVOLSZ        ; ... and prefix size\n         OI    PARMVOL,L'PARMVOL  ; Mark as already extracted\n         B     GETKWRD_001\n** all values are set for kwrd extraction\nGETKWRD_001 DS 0H\n         AR    R3,R6              ; at the keyword value\n         SR    R4,R6              ; adjust size\n         BNP   GETKWRD_NOK        ; Not much there\n* Look for closing paren\n*---------------------------------------------------------------+\n         B     *+10               ; Around the instruction      \u00b3\n         TRT   0(0,R3),CLBANANA   ; *** executed ***            \u00b3\n         EX    R4,*-6             ; ...                         \u00b3\n*---------------------------------------------------------------+\n         BZ    GETKWRD_NOK        ; Not there\n         LR    R2,R1              ; \")\" address\n         SR    R2,R3              ; Keyword value size\n         BNP   GETKWRD_NOK        ; Not much there\n         CR    R2,R9              ; Too long for the approp value?\n         BH    GETKWRD_NOK        ; Yes\n*---------------------------------------------------------------+\n         BCT   R2,*+10                                          \u00b3\n         MVC   0(0,R8),0(R3)      ; *** executed ***            \u00b3\n         EX    R2,*-6             ; Copy approp value           \u00b3\n*---------------------------------------------------------------+\n         CR    R1,R5              ; Anything else there?\n         BE    GETKWRD_NOK        ; No, we are done\n         LR    R4,R5              ; Compute new\n         SR    R4,R1              ; ... size\n         LTR   R4,R4              ; ???\n         BNP   GETKWRD_NOK        ; Ignore the rest, we are done\n         BCTR  R4,0               ; Size - 1\n         LA    R3,1(,R1)          ; Next byte after \")\"\n         B     GETKWRD_OK         ; ... and leave s/routine\nGETNB    DS 0H\n* Look for first non-blank\n*---------------------------------------------------------------+\n         B     *+10               ; Around the instruction      \u00b3\n         TRT   0(0,R3),NONBLANK   ; *** executed ***            \u00b3\n         EX    R4,*-6             ; First non-blank             \u00b3\n*---------------------------------------------------------------+\n         BZ    GETNB_NOK          ; Not there, ignore the rest\n         LR    R4,R5              ; Compute new\n         SR    R4,R1              ; ... size -1;\n         LTR   R4,R4              ; ???\n         BNP   GETNB_NOK          ; Ignore the rest, we are done\n         LR    R3,R1              ; reload new address\n         B     GETKWRD_OK         ; ... and leave s/routine\nGETNB_NOK DS 0H\n         CLI   *,X'93'            ; Set cc<>0\n         BR    R7                 ; out\nGETNB_OK DS 0H\n         CLI   *,X'95'            ; Set cc=0\n         BR    R7                 ; out\n         EJECT ,\n*--------------------------------------------------------------------*\n* GETDSN  - attempt to extract dsn from the file line under the\n*           cursor.\n*   CURPOSC  - cursor position.\n*   DATALINE - data line from the file (under the cursor)\n*   DTLSZ    - dataline size\n*\n*   Cursor must be under the dataset.\n*   This is how dataset name is isolated.\n*\n* 1. scan back from the cursor position for the first blank,\n*    open paren or start of the line; position on valid start char.\n*\n* 2. starting at (1), locate the first blank or end-of-line\n*\n* 3. Starting at (1), locate \"(\" - open paren\n*\n* 3.1.   \"(\" found.\n*\n*           Starting at (3.1), locate \")\" - close paren\n*\n* 3.1.1.       \")\" found\n*                  isolate word in parens. if numeric, process as GDG\n*                  if not - goto 4.\n*\n* 3.1.2        \")\" not found.  goto 4.\n*\n* 3.2    \"(\" not found.  goto 4.\n*\n* 4.  Word starts at (1), ends at (3.1) - 1. Process as a dataset.\n*\n*\n*--------------------------------------------------------------------*\nGETDSN   DS   0H\n         STM  R14,R12,SAVE_GETDSN   ; Save registers\n*\n* Set up translation tables. Good chars first.\n*\n         MVI  GOODCHAR,C' '\n         MVC  GOODCHAR+1(255),GOODCHAR    ; Bad chars to blanks\n*033099  MVI  GOODCHAR+C'''',C''''        ; This is ok\n         MVI  GOODCHAR+C'.',C'.'          ; and this...\n         MVI  GOODCHAR+C'-',C'-'          ; and this...\n         MVI  GOODCHAR+C'(',C'('          ; and this...\n         MVI  GOODCHAR+C')',C')'          ; and this...\n         MVI  GOODCHAR+C'$',C'$'          ; and this...\n         MVC  GOODCHAR+C'#'(2),=C'#@'     ; This is ok too\n         MVC  GOODCHAR+C'a'(9),=C'ABCDEFGHI' ; Uppercase this guys\n         MVC  GOODCHAR+C'j'(9),=C'JKLMNOPQR' ; these too\n         MVC  GOODCHAR+C's'(8),=C'STUVWXYZ'  ; ...\n         MVC  GOODCHAR+C'A'(9),=C'ABCDEFGHI' ; Alpha\n         MVC  GOODCHAR+C'J'(9),=C'JKLMNOPQR' ; ...\n         MVC  GOODCHAR+C'S'(8),=C'STUVWXYZ'  ; ...\n         MVC  GOODCHAR+C'0'(10),=C'0123456789' ; Num\n*\n* Now translate all bad chars to blanks\n*\n         L    R3,DTLSZ         ; Line size\n         LA   R4,DATALINE      ; File line address\n         L    R5,CURPOSC       ; Cursor column\n         BCTR R5,0               ; Make it zero-based\n*----------------------------------------------------------------+\n         BCT  R3,*+10            ; Around executed instruction   \u00b3\n         TR   0(0,R4),GOODCHAR   ; *** executed ***              \u00b3\n         EX   R3,*-6             ; Get rid of undesirable chars  \u00b3\n*----------------------------------------------------------------+\n         LA   R6,0(R4,R5)        ; Byte over the cursor position\n         CLI  0(R6),C' '         ; Any good stuff there?\n         BE   GETDSN_NOK         ; No, should be on valid char\n*\n* Scan back for the first blank or the line start, or open paren.\n*\nXLL001   DS   0H\n         CLI  0(R6),C' '         ; Are we there yet?\n         BE   XLL002             ; Yes\n         CLI  0(R6),C'('         ; Are we there yet?\n         BE   XLL002             ; Yes\n         BCTR R6,0               ; back off 1 byte\n         CR   R6,R4              ; At the beginning if the line?\n         BNL  XLL001             ; No\nXLL002   LA   R6,1(,R6)          ; Now under the 1st nonblank\n*\n* R6 is now the address of first non-blank char of (maybe) dsn.\n*  Let's try to locate the first blank.\n*\n         LA   R7,0(R4,R3)        ; Last byte of the line\n         SR   R7,R6              ; Size - 1 from non-blank up\n         LTR  R7,R7\n         BNP  GETDSN_NOK\n*----------------------------------------------------------------+\n         B    *+10               ; Around executed instruction   \u00b3\n         TRT  0(0,R6),YESBLANK   ; *** executed ***              \u00b3\n         EX   R7,*-6             ; Go look for the blank         \u00b3\n*----------------------------------------------------------------+\n         BZ   XLL003             ; CC=0 blank not found\n         LR   R7,R1              ; Blank address\n         SR   R7,R6              ; String size - 1.\n         BCTR R7,0               ; ...\n*\n* R6 - start of (maybe) dsn\n* R7 - size - 1\n*\nXLL003   DS   0H\n         LA   R4,0(R6,R7)        ; Last byte address\n* Look for opening paren\nXLL105   DS   0H\n*---------------------------------------------------------------+\n         B     *+10               ; Around the instruction      \u00b3\n         TRT   0(0,R6),OPBANANA   ; *** executed ***            \u00b3\n         EX    R7,*-6             ; ... See if there            \u00b3\n*---------------------------------------------------------------+\n         BZ    GETDSN_MOVE        ; No.  LMM* will decide.\n*\n*-- \"(\" located.\n*        isolate word in parens. if too big or null, ignore it\n*        and move stuff before the \"(\" as dsn.\n*\n         LR    R2,R1              ; Save R1 for the future\n         LR    R5,R7              ; save the size\n         LA    R3,1(,R2)          ; Byte after (\n         CLI   0(R3),C'('         ; This is not good\n         BE    GETDSN_MOVE_1      ; Unbalanced parens\n         CLI   0(R3),C')'         ; Anything inside parens?\n         BE    GETDSN_MOVE_1      ; No, reject this stuff\n* R4 is still last byte address - )\n         SR    R4,R3              ; Size of member or GDG\n         LTR   R4,R4              ; One more time, just in case...\n         BNP   GETDSN_MOVE_1      ; ...\n         C     R4,=F'8'           ; Cannot be more than 8 bytes long\n         BH    GETDSN_MOVE_1      ; Too big.\n* See if we've got the relative generation number. \"+\" is possible,\n* but is kind of useless since it is not created yet...\n* therefore, it is translated to blanks in the beginning of GETDSN\n         CLC   0(3,R2),=C'(0)'    ; Current generation?\n         BE    GDG002             ; Yes, call LOCATE.\n         CLI   0(R3),C'-'         ; Possibly GDG?\n         BNE   MEMBER_NAME        ; No, could be a member name\n         BCTR  R4,0               ; Size - 1;\n*\n* R4 - size -1; r3 - first byte address of GDG/member name.\n*  but we know that the first byte of it is \"-\"\nGDG001   DS    0H\n*---------------------------------------------------------------+\n         BCT   R4,*+10            ; Around executed instruction \u00b3\n         MVZ   TSTGDG(0),1(R3)    ; *** executed ***            \u00b3\n         EX    R4,*-6             ; See if numeric              \u00b3\n*---------------------------------------------------------------+\n* TSTGDG must be 8C'0' for the thing inside parens to be numeric.\nGDG002   DS    0H\n         CLC   TSTGDG(8),=8C'0'   ; All digits were numeric?\n         BNE   GETDSN_NOK         ; No, fail this\n*\n* We are reasonably certain that we've got a GDG specification\n* Let's try to get the real dataset name out of a catalog.\n* Again, R6 - first byte address, R7 - size-1.\n* I think that GDG name cannot be more that 44 bytes.\n*\n         C     R7,=F'43'           ; Too big?\n         BH    GETDSN_NOK          ; Yes, fail this\n*\n* Prepare for LOCATE macro\n*  Init the CAMLST in work area\n*  fill up the DSN, that will be expanded\n*  Fill up CAMLST in work area.\n*\n*---------------------------------------------------------------+\n         B     *+10               ; Around executed instruction \u00b3\n         MVC   RELGDG(0),0(R6)    ; *** executed ***            \u00b3\n         EX    R7,*-6             ; Copy to work area           \u00b3\n*---------------------------------------------------------------+\n         MVC   EXPAND_GDG(LMODEL_GDG),MODEL_GDG ; CAMLST\n         MVI   LOCAREA,0           ; dont care about this\n         LA    R0,RELGDG           ; Input/output dsn\n         ST    R0,EXPAND_GDG+4     ; Save in plist\n         LA    R0,LOCAREA          ; Work area address\n         ST    R0,EXPAND_GDG+12    ; Save in plist\n         LOCATE EXPAND_GDG         ; see if we can do it.\n         LTR   R15,R15            ; Success?\n         BNZ   GETDSN_NOK         ; Forget it\n         MVC   DSN(L'RELGDG),RELGDG  ; Copy full gdg name\n         B     GETDSN_OK          ; Leave with full dsn name\n*\nGETDSN_MOVE_1 EQU  MEMBER_NAME\n*+* for now we can assume that this is a member name.\n*+* We will ignore it, move what we think is a dataset name to\n*+* DSN and get out.\n*+* R2 is a ( address, R6 - start of dsn address\nMEMBER_NAME DS 0H\n         SR    R2,R6              ; Size of data in question\n*---------------------------------------------------------------+\n         BCT   R2,*+10            ; Around executed instruction \u00b3\n         MVC   DSN(0),0(R6)       ; *** executed ***            \u00b3\n         EX    R2,*-6             ; Copy the dataset name       \u00b3\n*---------------------------------------------------------------+\n         B     GETDSN_OK          ; ...and leave\n*\n* When we decided that DSN is close to be correct, move it to the\n*  DSN buffer and leave\n*\nGETDSN_MOVE DS 0H\n*------------------------------------------------------------------+\n         B    *+10                  ; Around executed instruction  \u00b3\n         MVC  DSN(0),0(R6)          ; *** executed ***             \u00b3\n         EX   R7,*-6                ; Copy the DSN                 \u00b3\n*------------------------------------------------------------------+\n         B    GETDSN_OK             ; And leave this code\n*\n* Exit from GETDSN s/routine.\n*\nGETDSN_NOK CLI   *,X'93'            ; Set cc<>0\n         B     GETDSN_OUT           ; out\nGETDSN_OK  DS   0H\n* delete possible trailing \")\"\n         MVI  GOODCHAR+C'(',C' '    ; blank both out\n         MVI  GOODCHAR+C')',C' '    ; ...\n         TR   DSN(L'DSN),GOODCHAR   ; and get rid of them\n         CLI   *,X'95'              ; Set cc=0\nGETDSN_OUT LM   R14,R12,SAVE_GETDSN   ; Restore registers\n         BR    R14                  ; out\n*--------------------------------------------------------------------*\n*     Constants and work areas\n*--------------------------------------------------------------------*\n*\n         WXTRN @CSR\n@CSRADDR DC    V(@CSR)\n*\nL6       DC    F'6'               ; VOL variable size\nL8       DC    F'8'               ; LISTIDV size\nL44      DC    F'44'              ; DSN variable size\n*\n* ISPLINK stuff.\n*\n@ADDPOP  DC    CL8'ADDPOP'\n@CHAR    DC    CL8'CHAR'\n@CONTROL DC    CL8'CONTROL'\n@DSN     DC    CL8'DSN'             ; DSN variable name\n@ERRORS  DC    CL8'ERRORS'\n@ISPLINK DC    CL8'ISPLINK'\n*                        line   col\n@ISRCRC  DC    C'CURSOR=(LINE,COL)'   ; Restore cursor position\n@ISRDLC  DC    C'(DATALINE) = LINE .ZCSR' ; Get data line\n@ISREDIT DC    CL8'ISREDIT'         ; Service name\n@ISREM1  DC    C'MACRO (INARG)'  ; first macro command\n@ISRLCC  DC    C'(LINE,COL) = CURSOR' ; Get cursor position\n@ISRZ000 DC    CL8'ISRZ000'         ; Message id\n@LISTIDV DC    CL8'LISTIDV'\n@LMDDISP DC    CL8'LMDDISP'\n@LMDFREE DC    CL8'LMDFREE'\n@LMDINIT DC    CL8'LMDINIT'\n@MOVE    DC    CL8'MOVE'             ; for VCOPY\n@REMPOP  DC    CL8'REMPOP'\n@RETURN  DC    CL8'RETURN'\n@SETMSG  DC    CL8'SETMSG'\n@SHARED  DC    CL8'SHARED'\n@VCOPY   DC    CL8'VCOPY'\n@VDEFINE DC    CL8'VDEFINE'\n@VGET    DC    CL8'VGET'\n@VOL     DC    CL8'VOL'               ; VOL variable name\n@VOLUME  DC    CL8'VOLUME'\n@VREPLACE DC   CL8'VREPLACE'\n@VRESET  DC    CL8'VRESET'\n@YES     DC    CL8'YES'               ; confirm delete\n@ZEDSMSG  DC   CL8'ZEDSMSG'\n@ZEDLMSG  DC   CL8'ZEDLMSG'\n@ZERRMSG DC    CL8'ZERRMSG'\n@ZPREFIX DC    CL8'ZPREFIX'\n*\n* Model for the CAMLST. Copied to working storage.\n*\nMODEL_GDG CAMLST NAME,(8),,(9)\nLMODEL_GDG EQU *-MODEL_GDG\n         DS    0D\nUPCASE   DC    X'000102030440060708090A0B0C0D0E0F'  ; Translate table\n         DC    X'101112131415161718191A1B1C1D1E1F'  ; .for input parm\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*\n* Look for opening/closing paren TRT tables\n*\nOPBANANA DC    256X'00'\n         ORG   OPBANANA+C'('\n         DC    C'('\n         ORG   ,\nCLBANANA DC    256X'00'\n         ORG   CLBANANA+C')'\n         DC    C')'\n         ORG   ,\n*\n* Look for first blank   TRT table\n*\nYESBLANK DC    256X'00'\n         ORG   YESBLANK+C' '\n         DC    C' '\n         ORG   ,\n*\n* Look for the first non-blank TRT table\n*\nNONBLANK DC    256AL1(*-NONBLANK)    ; Fill it up\n         ORG   NONBLANK+C' '\n         DC    X'00'\n         ORG   ,\n*\n         DS    0F\nPFXDSNSZ DC    AL4(L'PFXDSN)       ; Size of PARM DSN pfx\nPFXVOLSZ DC    AL4(L'PFXVOL)       ; Size of PARM VOL pfx\n@ISRCRCSZ DC   AL4(L'@ISRCRC)  ; Size of restore cursor  command\n@ISRDLCSZ DC   AL4(L'@ISRDLC)  ; Size of get dataline    command\n@ISREM1SZ DC   AL4(L'@ISREM1)  ; Size of 1st command\n@ISRLCCSZ DC   AL4(L'@ISRLCC)  ; Size of cursor position command\n@ZEDSMSG1SZ DC AL4(L'ZEDSMSG1) ; Size of 1st short message\n@ZEDLMSG1SZ DC AL4(L'ZEDLMSG1) ; Size of 1st long  message\n@ZEDSMSG2SZ DC AL4(L'ZEDSMSG2) ; Size of 2nd short message\n@ZEDLMSG2SZ DC AL4(L'ZEDLMSG2) ; Size of 2nd long  message\n*\nPFXDSN   DC    CL4'DSN('           ; dsn(xxx.xxx.xxxxx)\nPFXVOL   DC    CL4'VOL('           ; vol(xxxxxx)\nBLANKS   DC    CL80' '             ; Handy\nZEDSMSG1 DC    C'Place cursor on DSN'\nZEDLMSG1 DC    C'Place cursor on DSN and rerun this command'\nZEDSMSG2 DC    C'Could not locate DSN'\nZEDLMSG2 DC    C'Could not find DSN on the file line under the cursor'\n*\n         DS    0D\n         LTORG\n*--------------------------------------------------------------------*\n*                    DSECTS\n*--------------------------------------------------------------------*\n*\n* Workarea dsect. R13 points to it.\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                ; Registers save area\nRETCODE  DS    F                  ; Return code\nSAVE_GETDSN DS 16F                ; Save area for GETDSN s/routine\n*\n* Data for LOCATE macro - expand GDG\n*\n*  EXPAND_GDG CAMLST NAME,RELGDG,,LOCAREA\nEXPAND_GDG CAMLST NAME,(8),,(9)\nRELGDG   DS    CL44' '            ; e.g. JUNK.JUNK(-3)\nLOCAREA  DS    0D\n         DS    265X'00'           ; Results\n*\n*\nISPLINK_PLIST DS 10F              ; plist to call ISPLINK\nRC       DS    F                  ; Retcode after ISPLINK\nISPLINK@ DS    F                  ; Address from load\nTMPWORD  DS    F                  ; Just a temp fullword\nDWORD    DS    D                  ; Dword for misc work\n@CSRP    DS    XL(L@CSRPL)'00'    ; Plist to call @CSR\n* DTLSZ    DS    F                  ; Dataline size for MACRO\n* CURPOSC  DS    F                  ; Cursor column\n* DATALINE DS    CL256' '           ; File data line for Edit macro.\n         SPACE 2\nINARG    DS    CL80' '            ; Input arg from edit macro\n         ORG   ,\n* Keep next 2 together, do not change order.\nTMPCOL   DS    XL5                ; Cursor position before the MACRO\nTMPLINE  DS    XL6                ; Line   position before the MACRO\n* Keep next 2 together, do not change order.\nTMPCOLSZ DS    F\nTMPLINESZ DS   F\n*\nTSTGDG   DS    CL8' '             ; For GDG testing\n*\nDSN      DS    CL56' '            ; Dataset name from parm\nVOL      DS    CL6' '             ; Volser from parm\nPARM     DS    CL80' '            ; Parm supplied by a caller\nLISTIDV  DS    CL8' '             ; Output from LMDINIT\nZERMSG   DS    CL8' '             ; Error message ID variable\nZPREFIX  DS    CL8' '             ; Another ISPF variable\n*\nPARMFLAG DS    XL1'00'            ; Parm parsing flag\nPARMDSN  EQU   PARMFLAG,X'80'     ; DSN extracted\nPARMVOL  EQU   PARMFLAG,X'40'     ; Vol extracted\nDSNQ     EQU   PARMFLAG,X'20'     ; DSN in the file, in quotes\nEDITMAC  EQU   PARMFLAG,X'10'     ; Edit macro\n*\n* Translate tables for the dataset name isolation\n*\nGOODCHAR DS    XL256'00'\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*--------------------------------------------------------------------*\n         PRINT ON\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12   BASE\nR13      EQU   13   WORKAREA BASE\nR14      EQU   14\nR15      EQU   15\n*\n* Map the call to @CSR\n*\n@CSRPL   DSECT\n@CSREYE  DS    CL4'@CSR'\nDTLSZ    DS    F                  ; Dataline size for MACRO\nCURPOSC  DS    F                  ; Cursor column\nDATALINE DS    CL256' '           ; File data line for Edit macro.\nL@CSRPL  EQU   *-@CSRPL           ; Plist size\n*--------------------------------------------------------------------*\n* MACROS.\n*--------------------------------------------------------------------*\n         IKJCPPL                              COMMAND PROCESSOR LIST\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT515/FILE515.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT515", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}