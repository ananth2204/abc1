{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012722000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1175720, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 15, "INMDSNAM": "CBT.V500.FILE751.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1175720, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1175720, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE751.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x14\\t'", "DS1TRBAL": "b'8\\xfa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x1c\\x00\\x00\\x05\\x1d\\x00\\x05\\x00\\x15'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x08\\x01\\x150\\x8f\\x01\\x150\\x8f\\x13\\x02\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2015-11-04T00:00:00", "modifydate": "2015-11-04T13:02:08", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  751\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE751\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 56 MEMBERS COUNTED; CUMULATIVE SIZE IS 10,817 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/04/15    13:02:07    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x001\\x01\\x05!\\x0f\\x01\\x10\\x11O\\x15\\x19\\x025\\x00\\xe4\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2005-07-29T00:00:00", "modifydate": "2010-04-24T15:19:31", "lines": 565, "newlines": 228, "modlines": 0, "user": "SOMITCW"}, "text": "$ - Is the first data set in our master catalog and the\nfirst data in the VTOC of our system resident disk volume.\nIt is used for a model DSCB when creating generation data\nsets and used for a volume reference for JCL locks.\nWe have a RACF group of $ and data set profile $.**(G) to\nallow $ to be allocated and the disk volume to be backed up.\n\nSample JCL to create $:\n\nMove whatever is in the sysres VTOC after the format 4\nand format 5 DSCB so $ will go to that location.\n//IEFBR14 EXEC PGM=IEFBR14\n//X DD DSN=$,DISP=(,KEEP),\n// SPACE=(TRK,0),UNIT=SYSDA,VOL=REF=SYS1.LINKLIB\n//* Do not add RECFM, LRECL, or BLKSIZE because all\n//* generation data set ever created will not match.\n\nIf gen is needed to separate device types for virtual\nand real tape drives, use non-compatable tape types.\nPerhaps: 3480 and 3590\nOr see methods listed for MDL from Bus-Tech:\nhttp://www.bustech.com/\n\n$DOC - Poor list that you are looking at.\n\n$HASP050 - MPF exit to help prevent JES2 SPOOL from filling.\n\n$TMOUNT - Sample VSE tape mount program.\n\n$VIRTAPE - Some old E-Mail about the tape programs.\n\n@FILE751 - Something that one of the Sams added.\n\nCMD - Issues operator commands and calls program from\na PARM or CMDIN DD statement.\n\nCONDCHEK - LINKs other program and checks the condition\ncode for zero.  If the returning condition is not zero,\nthe step is abended with the abend code of the return code.\n\nCVTUSER - DSECT to describe CVTUSER area to hold pointers\nand values for tapes and other functions.\nUsed by programs:  IEC507D, IEC512I, IGXMSGEX, IOS000I,\nLGNIXIT, SAVEPSWD, DFHJC450, TAPERSET, TAPESAVE,\nTAPESYNC, TAPESYN2, and many others.\n\nDATEYMD - Obsolete Rexx EXEC to store dates.\n\nDELAY - Program that pauses the current process.\nIt can be issued from BATCH, TSO CALL, as a TSO CP,\nand Rexx function.\n\nFLEXESV7 - Flex-ES tape options and information.\n\nIEALPA00 - Sample SYS1.PARMLIB member showing how to\nadd IGXMSGEX to MPLA for testing.\n\nIEASVC00 - Sample SYS1.PARMLIB member showing how to\nadd SVC 230 (IGC0023{) for tape mounting.\n\nIEA404A - Obsolete MPF exit to keep consoles from\nbacking up.  IBM claims that the problem is fixed but\nif you don't trust them, this will take care of it.\n\nIEC507D - MPF exit to disallow operator writing over date\nprotected tapes.\n\nIEC512I - MPF exit to intercept MVS console message: IEC512I\nIf for a re-mount for a specific tape, IGXMSGEX mount of a\ntape that did not match, normally a mount loop would occur.\nIEC512I stores the tape vol ser in the CVTUSER area to let\nIGXMSGEX know to not mount the tape again.  If for an error\non a scratch tape request, no action is taken to block the\nnext scratch tape from being selected and used.\n\nIEC534D - MPF exit. Prevent tape relabel.\nIEE366I - MPF exit. Starts SMF dump JOB.\nIEF099I - MPF exit. Tell TSO users if their JOB is waiting on data sets.\nMostly from: http://home-2.worldonline.nl/~jjaeger/\nIEF251I - MPF exit. E-Mail if \"UNABLE TO ALLOCATE\" message. See SETWHEN\nIEF450I - MPF exit. E-Mail if a JOB abends.  See program SETWHEN.\n\nIGC0023{ - User SVC 230 to issue P/390 tape mount CCW\nThis SVC accepts a tape volume serial number and\ntape drive Unit Control Block pointed to by registers\nzero and one and issues a CCW command code 4B to the\ntape device with mount information ( tape file specs ).\nTo call the SVC, use code like:\n\n     LA    R0,VOLSER     Load address of the requested vol ser\n     L     R1,UCBADDR    Load the UCB address\n     SVC   C'W'          Issue the autoloadCCW SVC\n     B     FINISHED      It either worked or not, go exit\n\nCCW issued to the tape device number will be something like:\nCCW      CCW  X'4B',FILESPEC,X'20',21  Mount tape CCW\nFILESPEC DC   CL21'/tapeC/C01/C01234.aws'\n\n   If SYS1.PARMLIB(IEASVCxx) specifies APF(YES) then the\ncaller to this SVC must be APF or otherwise authorized.\n\nIGXMSGEX - Is an SMS exit that is normally used to allow an\ninstallation to change the messages that are displayed on\n3480 and 3490 tape drives.  The exit is in a good spot to\nissue automount ccw commands to the tape drive because:\n1. The specific tape number or scratch tape request is\nin the data to be displayed.\n2. The data to be displayed also shows that the request\nis for a mount or for some other request.\n3. Since SMS is about to issue a CCW to the tape drive,\nit is a good time to insert our CCW.\nIGXMSGEX determines if a specific tape or scratch tape\nis needed by checking the two 8 byte messages that will\nbe sent to the tape drive.  If either message starts\nwith an 'M', then the next six bytes are either the\ntape vol ser to mount or 'PRIVAT' for a scratch tape\nrequest.  The program does not check for 'SCRTCH'\nbecause 'SCRTCH' is normally only an indication of\na JCL problem.  Either a work tape is being called\nfor or a deferred mount is needed:\n//xxxxxxxx DD UNIT=TAPE should go to disk space\n//IEHINITT DD UNIT=(TAPE,,DEFER)  DEFER is needed\nOr the program could be changed to ignore \"SCRTCH\".\nIf message 1 starts with '*IEC701', then the\nmiddle 6 bytes of message 2 contain the tape number\nto mount.  If a scratch tape request, TAPEBITS is\nchecked and updated to provide a specific scratch tape\nvol ser.  Tapes are logically grouped in groups of one\nthousand tapes.  IGXMSGEX and TAPEBITS keep track of\nthe highest tape number in use.  If all tapes are in\nuse up to that number, the tape pool high water mark\nis expanded by eight tapes.  After a specific tape\nnumber is provided or determined, then SVC 230\n( IGC0023{ ) is issued to mount the tape.\nFor OS/390 2.4.0, IGXMSGEX is linked into IGX00030\n( ESR SVC 109 function 30 ) and may require an IPL to\nimplement.  The updated IGX00030 needs to be in an\nLPALSTxx data set or in SYS1.PARMLIB(IEALPAxx).\n\nIOS000I  - MPF exit. To notify on some disk error messages.\nIST1132I - MPF exit. To activate JES2 links when VTAM CDRM comes up.\nLLAFRESH - MPF exit. To refresh LLA when LinkList I/O error because\nsomeone compressed a LinkList data set.\n\nMPFLST00 - Sample SYS1.PARMLIB MPF list.\n\nMSG - PROC to start command and program scripts.\n\nREPLYCAN - MPF exit to reply cancel to \"REPLY DEVICE NAME OR 'CANCEL'\"\n\nREPLYF - was MPF exit to unload read-only tapes:\nIEC510D,SUP(NO),USEREXIT(REPLYF)   Reply 'F' Unload file protected tape\nWith automountCCW, IEC510D is no longer in MPFLSTxx\n\nREPLYM - MPF exit to unload incorrect, wrong, or tape to be labelled:\nIEC514D,SUP(NO),USEREXIT(REPLYM)   Reply 'M' for DCK or label error\nWith automountCCW, IEC514D is no longer in MPFLST to leave the error\ntape on the tape drive and not mount it repeatedly.\nIEC534D,SUP(NO),USEREXIT(REPLYM)   Reply 'M' for wrong vol ser mounted\nWith automountCCW, IEC534D is no longer in MPFLST to leave the error\ntape on the tape drive and not mount it repeatedly.\nIEC701D,SUP(NO),USEREXIT(REPLYM)   Reply 'M' to initialize a tape\nWith automountCCW, it is too dangerous to leave MPF exit IEC701D\nactive all of the time.  One JOB could clear all tapes in a library\nin a few seconds with no checks for date protection.\nIEC704A,SUP(NO),USEREXIT(REPLYM)   Reply 'M' to unload NL tapes\nIEC704A works with IEC512I to prevent mount loops.\nIEC704A allows JOBs calling for scratch tapes to get a new\nscratch tapes and IEC512I stops requests for a specific bad tape.\n\nREPLYU - MPF exit. To reply \"U\".\nREPLYY - MPF exit. To reply \"Y\".\n\nSETWHEN - Program to store D, N, W for Day, Night, or Week-end\nin common memory so other utilities can quickly check to E-Mail\nor not.\n\nTape - Test program to see if automount CCW work.\nSample TAPE PROC follows:\n//TAPE    EXEC PGM=TAPE,TIME=1\n//*\n//* No required DD statements so running as a sub-system is easier\n//* For testing, a SYSUDUMP will prevent running as a subsystem.\n//*\n//* SYSUDUMP DD  SYSOUT=*  For debug.  Remove to run as sub-system\n//*\n//STCLOCK  DD  DISP=OLD,DSN='Only one TAPE STC can run at a time',\n//             VOL=REF=$\n//*\n//* This PROC allows an operator or an MPF routine\n//* to mount tapes on Flex-ES virtual tape drives,\n//*\n//* Console command format is:\n//*\n//* S TAPE,SUB=MSTR       to run as a sub-system\n//* S TAPE.TAPE,SUB=MSTR  to run as a sub-system\n//* S TAPE                to run as a started task\n//* S TAPE.TAPE           to run as a started task\n//* F TAPE,cccu,volser    to mount a tape\n//* P TAPE                to stop the TAPE sub-system or STC\n//*\n//* Console command examples:\n//*\n//* modify tape,0187,C00123\n//* f tape,182,A00213\n//*\n//* Notes:\n//*\n//* Unit address must be three or four characters.\n//* Volser must be 6 characters.\n//*\n\nTAPEBITS - DSECT to describe memory bit map of tapes.\nUsed by programs: IEC512I, TAPE, TAPENEW, TAPESAVE,\nTAPESYNC, and TAPESYN2.\n\nTAPEBLP - Extracts tape information from the label of a\ntape and formats in TAPESMF output format.  It is used\nto update TAPESMF information for tapes that do not or\nno longer have SMF data available.\nOne tape, ranges of tapes, or both can be called for.\n\n//SOMITCWT JOB (xxxxxxxx,xxxx,9999,9999,9999),TAPEBLPJ-SOMITCW,\n//             CLASS=x,MSGCLASS=x,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//TAPEBLP EXEC PGM=TAPEBLP\nC00106-C00114\n//INPUT    DD  DISP=SHR,DSN=IF.TAPE.NOT.FOUND.PLEASE.CANCEL.SOMITCWT,\n//             UNIT=(TAPE,,DEFER),VOL=SER=INTRNL,LABEL=(,BLP)\n//VOLUMES  DD  DISP=MOD,DSN=SYSx.TAPES.LPAR-B.VOLUMES\n//DATASETS DD  DISP=MOD,DSN=SYSx.TAPES.LPAR-B.DATASETS\n//SYSUDUMP DD  SYSOUT=*\n\nTAPEDRPD - Drops old record from data that TAPESMF extracted\nfrom SMF type 14 and 15 tape records and converted to display.\nTAPEDRPD does for the LPAR DATASETS data set what TAPEDRPV\ndoes for the LPAR VOLUMES data set.\n\nTAPEDRPV - - Drops TAPESMF records from the LPAR VOLUMES\ndata sets after they have been merged into the combined\nVOLUMES data set.\n\nSample JCL:\n\n//SORTVOL EXEC PGM=SORT,RD=R\n//SYSOUT   DD  SYSOUT=*\n SORT FIELDS=(1,44,CH,A) Sort Vol, Date, Time, F.Seq, Code, Exp, MaxExp\n SUM FIELDS=NONE         Drops records duplicated in columns 1-44 Why?\n//SORTIN   DD  DISP=OLD,DSN=STOR.TAPES.LPAR-B.VOLUMES\n//SORTOUT  DD  DISP=(,CATLG,DELETE),DSN=STOR.TAPES.LPAR-B.VOLBKUP(+1)   ,\n//             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n//             DCB=$,RECFM=FB,LRECL=171\n//SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//*\n//* TAPE system; Drop Volume Records step\n//DROPVOL EXEC PGM=TAPEDRPV,RD=R\n//REGIONAL DD  DISP=SHR,DSN=STOR.TAPES.LPAR-B.VOLBKUP(+1)      Compared\n//COMBINED DD  DISP=SHR,DSN=STOR.TAPES.COMBINED.VOLUMES        Compared\n//REPLACE  DD  DISP=OLD,DSN=STOR.TAPES.LPAR-B.VOLUMES          Replaced\n\nTAPEDSCT - DSECT of record lay-out of SMF tape information files.\n\nTAPENEW - Creates a new tape bit pattern file.\nIf a bit is one, then the tape is in use.\nIf a bit is zero, then the tape is available for use.\nTAPENEW will assume that all tapes are scratch tapes.\nBefore the tape bits are put into production with\nTAPESAVE, make certain that either all tapes in the\nrange are scratch tapes or are date protected.\nTAPESYNC could run soon after TAPESAVE is started\nto indicate tapes are active before they are used\nfor scratch tapes.  Full sequence could be:\nTAPENEW runs, TAPESAVE started to load TAPEBITS\ninto memory, SMFDUMP and TAPESMF updates tape\nVOLUMES data set, TAPESYNC updates TAPEBITS in\nmemory.  If IGXMSGEX is running and IGC0023{ is\navailable, then scratch tapes could then be mounted\nfrom TAPEBITS.\n\nSample TAPENEW JCL:\n\n//JOB JOB JOB,JOB JOB\n//TAPENEW EXEC PGM=TAPENEW,PARM=C  for volsers C00000 through C99999\n//TAPEDATA DD  DISP=(,CATLG,DELETE),DSN=SYS1.TAPES.C00000.C99999,\n//             SPACE=(TRK,1),VOL=REF=SYS1.PARMLIB\n//* will be DSORG=PS, RECFM=F, LRECL=12524, and BLKSIZE=12524\n\nTAPEOFF - Lists tape volume serial numbers to be E-Mailed\nso they are available for disaster recovery.\n\nTAPEOFFC - Obsolete Rexx exec to create SCO UnixWare \"cp\"\ncommands to copy tape images for grouping to copy to a\nphysical SCSI tape.  We only do sftp to multople offsite\nlocations so stopped sending a physical tape offsite.\n\nTAPEOLD - Drops old record from data that TAPESMF extracted\nfrom SMF type 15 tape records and converted to display.\nSince tapes are reused and only the information for the\ncurrent tape is needed to calculate EXPDT for scratch or\nactive lists, someway was needed to drop old records.\nAnother description would be:  The tape combined VOLUMES\ndata set should only have one record for each tape volume.\nAs record are merged in, previous records for the volumes\nmust be dropped.  Program TAPEOLD does the dropping.\n\nSample JCL:\n\n//SORTACT EXEC PGM=SORT,PARM='RC16=ABE',RD=R\n//SYSOUT   DD  SYSOUT=*\n*             VolSer   Created   Ind.-Code      EXPDT---D\n SORT FIELDS=(1,6,CH,A,8,23,CH,D,35,1,CH,D)    ,37,8,CH,D)\n//SORTIN   DD  DISP=OLD,DSN=STOR.TAPES.COMBINED.VOLUMES\n//         DD  DISP=OLD,DSN=STOR.TAPES.LPAR-A.VOLUMES\n//         DD  DISP=OLD,DSN=STOR.TAPES.LPAR-B.VOLUMES\n//         DD  DISP=OLD,DSN=STOR.TAPES.LPAR-C.VOLUMES\n//SORTOUT  DD  DISP=(,CATLG,DELETE),DSN=STOR.TAPES.COMBINED.SORT(+1),\n//             UNIT=SYSDA,SPACE=(TRK,(150,150),RLSE),\n//             DCB=$,RECFM=FB,LRECL=171\n//*\n//TAPEOLD EXEC PGM=TAPEOLD\n//SORTED   DD  DISP=SHR,DSN=STOR.TAPES.COMBINED.SORT(+1) input\n//VOLUMES  DD  DISP=OLD,DSN=STOR.TAPES.COMBINED.VOLUMES replaced\n//SYSUDUMP DD  SYSOUT=*\n\nTAPERSET - Changes the TAPEBITS in memory to a new current vol\nser number and sets a new tape pool high-water-mark which is\nthe tape pool soft limit.  If no PARM is specified, then both\nnumbers are set to zero.   Tapes are grouped with eight tapes\nto a byte, so the vol ser numbers set are rounded off by 8.\nTAPERSET is used if the number of tapes needed is reduced and\nfewer groups of 8 tapes are wanted to be used for the initial\nscratch tape pool.  The pool will expand again as needed.\n\nSample TAPERSET JCL:\n\n//TAPERSET EXEC PGM=TAPERSET  optional ,PARM=(C00123,C00999)\n//SYSUDUMP DD  SYSOUT=*\n//LOCK     DD  DISP=OLD,DSN='TAPERSET is running',VOL=REF=$\n\nTAPESAVE - Loads TAPEBITS from disk to memory.  Re-writes disk\nTAPEBITS from memory every minute that TAPEBITS was updated.\nTAPESAVE normally should start on IPL and be shut down\nwhen the system is shut down.  If TAPESAVE is stopped and\nstarted, the TAPEBITS in memory will continue to be used.\nManually editting SYS1.TAPES.x00000.x99999 will not work\nunless an IPL is done before TAPESAVE is restarted or a new\ntape scratch pool is switched to:  SYS1.TAPES.y00000.y99999\n\n    Sample JCL for TAPESAVE:\n\n//TAPESAVE EXEC PGM=TAPESAVE,TIME=1439\n//TAPEDATA DD  DISP=OLD,DSN=SYS1.TAPES.C00000.C99999\n//* For testing, run as a JOB or STC with a\n//* //SYSUDUMP DD SYSOUT=* DD statement.\n//* SUBSYS of MSTR cannot have SYSOUT=anything\n\n    Sample start command:\n\nSTART TAPESAVE,SUB=MSTR\nFor SUB=MSTR, the data set must be in the master\ncatalog or the UNIT and VOL=SER must be specified.\n\n    Sample stop command:\n\nSTOP TAPESAVE\n\nTAPESMF - Extracts tape EXPDT and other information in SMF\nrecord type 15 and records in a data set in display format.\nThe data can be used to track tape usage and generate tape\nscratch list and active list data.  Sample JCL:\n\n//TAPESMF EXEC PGM=TAPESMF\n//*\n//* Input back up SMF data set\n//SMFIN    DD  DSN=BKUP.SMFDUMP.DAILY,DISP=SHR\n//*\n//* Input and output tapes. For historical records?\n//DATASETS DD  DISP=MOD,DSN=STOR.TAPES.LPAR-A.DATASETS\n//*\n//* First label of output tapes.  To keep track of scratch and active.\n//VOLUMES  DD  DISP=MOD,DSN=STOR.TAPES.LPAR-A.VOLUMES\n//*\n//* Never needed if present\n//SYSUDUMP DD  SYSOUT=*\n\nTAPESTAT - Reads labels of a tape, ranges of tapes,\nor both to determine the status of:\nError, MisMatch, No-Label, Expire-today, Expired, or Protected.\nNo output information is written for empty tapes.\nA tape is considered empty if it has a data set name\nof all zeroes ( from IEHINIT or HETINIT ) or a data\nset name of 'EMPTY.TAPE' ( from TAPEZERO ).\nTAPESTAT uses EXCP to issue the P/390 automountCCW\nto mount tapes, rewind, read VOL1, and HDR1, and\nunload the tapes.\nOPEN is bypassed to prevent tape usage from being\nrecorded in SMF.  APF authorization is required to\nallow OPEN to be bypassed.\n\nThere is a space between each output field.\nOutput records fields are:\nVolser\nStatus\nData set name ( only last 17 bytes are in the tape label )\nCreation date\nExpiration date\nInternal label vol ser if a mis-match\n\nSample descriptions and output records:\n\n  Tape C01111 called for but internal label is C02222\nC01111 MisMatch  .SYSLOG.G1234V00 04123 05001 C02222\n\n  Tape C01122 is has expired but has not been erased\nC01122 Expired   VSYSRES.G0123V00 05260 05290\n\n  Tape C01234 is date protected until 2007/301\nC01234 Protected SMFDUMP.G0012V00 05301 07301\n\n  The output file can be used to find tape\nerrors ( no label, vol ser mismatch, others?  ).\n\n  The output file can also be used to find tapes\nthat have expired but not yet cleared of data.\nSORT can be used to select 'Expired' records to\npass to program TAPEZERO to scratch the tapes\nand free the disk space that they use.\n\nFor TAPESTAT sample JCL, see TAPESYN2.\n\nTAPESYNC - TAPESYN2 is normally better than TAPESYNC.\nTAPESYNC uses formatted SMF data for input which can\nbe incorrect because of tapes being initialized.\nTAPESYNC updates memory resident TAPEBITS to indicate\nwhich specific tape volumes are date protected so\nshould not be attempted to be used as scratch tapes.\nIf TAPESYNC or TAPESYN2 never run, all tapes will\neventually show as in use and none will be allowed to\nbe used as scratch.  Program TAPESAVE copies memory\nTAPEBITS to disk every minute so TAPESYNC and IGXMSGEX\nchanges are not lost.  It might be best to run SMFDUMP\nand TAPESMF shortly before TAPESYNC, but since MPF exit\nIEC507D prevents date protected tapes from being\nwritten over and automountCCW code would just call for\nthe next tape so TAPESYNC does not require the most\ncurrent data.  Also, it could take weeks between the\nautomountCCW code getting back to select the same tape\nagain.  Tapes in the same byte use could be attempted\nimmediately.  It would be best to not run TAPESYNC\nwhile tape drives are in use on the instance or LPAR.\nFlex-ES allows one tape image to be on two virtual tape\ndrives at a time and really makes a mess of the tape\nimage.  TAPESYNC should run on each instance because\neach instance should have its TAPEBITS in memory.\nRunning TAPESYNC once per week or month may be enough?\nIt needs to run more often than the scratch pool tape\nwraps tape vol sers.\n\nSample TAPESYNC JCL:\n\n//JOB JOB JOB,JOB JOB\n/*MESSAGE Best to run after tape data set updated and\n/*MESSAGE before new tapes are created\n//TAPESYNC EXEC PGM=TAPESYNC\n//VOLUMES  DD  DISP=SHR,DSN=STOR.TAPES.COMBINED.VOLUMES\n//         DD  DISP=SHR,DSN=STOR.TAPES.LPAR#001.VOLUMES\n//         DD  DISP=SHR,DSN=STOR.TAPES.LPAR#002.VOLUMES\n//         DD  DISP=SHR,DSN=STOR.TAPES.LPAR#003.VOLUMES\n//SYSUDUMP DD  SYSOUT=*\n\nTAPESYN2 - TAPESYN2 is normally better than TAPESYNC.\nTAPESYN2 updates memory resident TAPEBITS to indicate\nwhich specific tape volumes are date protected so\nshould not be attempted to be used as scratch tapes.\nIf TAPESYNC or TAPESYN2 never run, all tapes will\neventually show as in use and none will be allowed to\nbe used as scratch.  Program TAPESAVE copies memory\nTAPEBITS to disk every minute so TAPESYN2 and\nIGXMSGEX changes are not lost.\nTAPESYN2 uses the output of TAPESTAT for input\nwhich is as accurate as possible.\nAll tape volume serial numbers in input except ones\nlisted as \"Exp\" are marked in memory as protected.\nTape volumes not in input won't be marked protected.\nTapes that program TAPESTAT determined as \"Empty\"\nare not included in the data that TAPESYN2 reads.\nIt is best to run TAPESTAT shortly before TAPESYN2,\nbut since MPF exit IEC507D prevents date protected\ntapes from being written over and automountCCW code\nwould just call for the next tape, TAPESYN2 does not\nrequire the most current data.  Also, it could take\nweeks between the automountCCW code getting back to\nselect the same tape again.  Tapes in the same byte\nuse could be attempted immediately.  It would be best\nto not run TAPESYN2 while tape drives are in use on\nthe instance or LPAR.  Flex-ES allows one tape image\nto be on two virtual tape drives at a time and really\nmakes a mess of the tape image.  TAPESYN2 should run\non each instance because each instance should have its\nTAPEBITS in memory.  Running TAPESYN2 once per week or\nmonth may be enough?  It needs to run more often than\nthe scratch pool tape wraps tape vol sers.\n\nSample TAPESTAT, TAPEZERO, and TAPESYN2 JCL:\n\n//JOB JOB JOB,JOB JOB\n/*MESSAGE All tape drives should be locked out in\n/*MESSAGE the first step\n//*\n//TAPESTAT EXEC PGM=TAPESTAT\n//TAPESTAT DD  UNIT=(TAPE,32,DEFER)\nC00000-C02999\n//STATS    DD  DISP=(,CATLG,CATLG),DSN=STOR.TAPES.STATS(+1),\n//             UNIT=SYSDA,SPACE=(TRK,(1,15),RLSE),\n//             DCB=$,RECFM=FB,LRECL=59\n//SYSUDUMP DD  SYSOUT=*\n//LOCK     DD  DISP=OLD,DSN='TAPESTAT is running',VOL=REF=$\n//*\n//SORT    EXEC PGM=SORT\n//SYSOUT   DD  SYSOUT=*\n SORT FIELDS=COPY\n    INCLUDE COND=(8,4,CH,EQ,C'Expi')  Copy expired tape records\n//* INCLUDE COND=(8,3,CH,EQ,C'Exp') Copy all expired tape records\n//* Use 3 byte compare to also get tapes that expire today\n//SORTIN   DD  DISP=SHR,DSN=STOR.TAPES.STATS(+1)\n//SORTOUT  DD  UNIT=SYSDA,SPACE=(TRK,(1,15)),DISP=(,PASS)\n//*\n//TAPEZERO EXEC PGM=TAPEZERO\n//SYSIN    DD  DISP=(SHR,DELETE),DSN=*.SORT.SORTOUT\n//TAPE     DD  UNIT=(TAPE,,DEFER)\n//* RECFM=FB,LRECL=20,BLKSIZE=20 Forced by program for TAPE DD\n//SYSUDUMP DD  SYSOUT=*\n//LOCK     DD  DISP=OLD,DSN='TAPEZERO is running',VOL=REF=$\n//*\n//TAPESYN2 EXEC PGM=TAPESYN2\n//STATS    DD  DISP=SHR,DSN=STOR.TAPES.STATS(+1)\n//* RECFM=FB forced and normally LRECL=59\n//SYSUDUMP DD  SYSOUT=*\n//LOCK1    DD  DISP=OLD,DSN='TAPESYN2 is running',VOL=REF=$\n//LOCK2    DD  DISP=SHR,DSN='BKDAILY is running',VOL=REF=$\n//LOCK3    DD  DISP=SHR,DSN='BKWEEKLY is running',VOL=REF=$\n//*\n//EMAIL IF ABEND OR RC GT 4 THEN DO -\n  xmitip e-mail or other message goes here\n//EMAIL ENDIF\n\nTAPEZERO - Erases tapes by writing a 20 byte record as\nthe first data set on the tape.  TAPEZERO uses normal\nOPEN so the tape label retention date is checked and\nthe rewrite of the tape is recorded in SMF.\nTAPEZERO is needed so large tape images don't hold\nexcessive disk space before they are used as scratch\ntapes.  If the tape pool wraps often, running TAPEZERO\nmay not be needed.  TAPESTAT and TAPESYN2 may be enough\nto keep disk space usage for tapes low?  Input for\nTAPEZERO is RECFM=FB records containing the vol ser to\nover-write.  TAPEZERO uses OPEN TYPE=J to request which\ntape volume is to be mounted.  The tape data set name is\nDSN=EMPTY.TAPE so TAPESTAT can identify the tapes as\nempty tapes.\n\nFor TAPEZERO sample JCL, see TAPESYN2.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$HASP050": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00E\\x00\\x94(\\x7f\\x01\\t5\\x1f\\x161\\x00\\x97\\x00\\x86\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1994-10-14T00:00:00", "modifydate": "2009-12-17T16:31:45", "lines": 151, "newlines": 134, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCW$ JOB (????????,????,1439,9999,9999),$HASP050-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//$HASP050 EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  UNIT=SYSDA        ,VOL=SER=??????\n//         DD  DISP=SHR,DSN=SYS1.MODGEN   ,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE '$HASP050 - - - Start SPOOL clean-up PROC'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Change log:\n*\n* 1994-10-17 WAM  Changed GETMAIN and FREEMAIN R to RU.\n*\n* 1994-02-07 WAM  Program written.\n*\n*    When message:\n*   $HASP050 JES2 RESOURCE SHORTAGE OF ???? - ??% UTILIZATION REACH\n*      displays, WTO processing calls this program as an MPF exit.\n*      If the $HASP050 message is for JNUM, JQES, JOES, or TGS and\n*      utilization from 95 to 99 percent, this exit issues commands:\n*      S SPOOL,MEMBER=SPOOL95  or\n*      S SPOOL,MEMBER=SPOOL96  or\n*      S SPOOL,MEMBER=SPOOL97  or\n*      S SPOOL,MEMBER=SPOOL98  or\n*      S SPOOL,MEMBER=SPOOL99  depending on the percent utilized,\n*      otherwise, no action is taken.\n*      SYS1.PARMLIB(MPFLST00) defines the exit to the operating system.\n*      SYS1.PARMLIB(CONSOL00) defines MPFLST00 to the system.\n*\n*      Sample SPOOL PROC:\n*\n* //CMD     EXEC PGM=CMD\n* //CMDIN    DD  DSN=xxxx.PARMLIB(&MEMBER),DISP=SHR\n*\n*      Sample SPOOL95 PARM:\n*\n* *\n* *    This member used by MPF exit $HASP050,\n* *    If SPOOL is at 95% in use.\n* *    The 60 second delays are so JES2 does not try\n* *    to run all commands at once and hog the system.\n* *\n* $OQ,Q=X,CANCEL,A=2\n* 'DELAY   '60\n* $OQ,Q=R,CANCEL,A=15\n* 'DELAY   '60\n* $OQ,ALL,CANCEL,A=30\n* 'DELAY   '60\n* $PQ,ALL,A=30\n* *\n*\n*      Sample MPFLST00 PARM:\n*\n* $HASP050,SUP(NO),USEREXIT($HASP050) Starts SPOOL purge PROC\n*\n*    To disable all MPF exits, enter operator command 'SET MPF=NO'.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         PRINT ON,GEN,NODATA\n$HASP050 CSECT ,\n$HASP050 AMODE 31\n$HASP050 RMODE ANY\n         STM   R14,R12,12(R13)    Save caller's registers\n         LR    R12,R15            Load the program's base register\n         USING $HASP050,R12       Give the assembler the new base\n         L     R11,0(,R1)         Load the address of COMM.TASK\n*                                 User exit routine parameter list\n         L     R11,CTXTTXPJ-CTXT(,R11)  Load address of message text\n*\nFINDDASH DS    0H\n* $HASP050 JES2 RESOURCE SHORTAGE OF JNUM - 95% UTILIZATION REACHED\n* $HASP050 JES2 RESOURCE SHORTAGE OF JQES - 95% UTILIZATION REACHED\n* $HASP050 JES2 RESOURCE SHORTAGE OF JOES - 95% UTILIZATION REACHED\n* $HASP050 JES2 RESOURCE SHORTAGE OF TGS - 95% UTILIZATION REACHED\n         CLI   0(R11),C'-'        See if a dash found\n         BE    GOTDASH\n         LA    R11,1(,R11)        Bump to check next char. for a dash\n         B     FINDDASH           Go to check next char. for a dash\nGOTDASH  DS    0H\n         SH    R11,H5             Back up 5 bytes to check for 'JOES'\n         CLC   0(4,R11),JNUM      See if we found Job NUMbers\n         BE    PERCENT            'JNUM' found, go check percent\n         CLC   0(4,R11),JQES      See if we found JOB Queue ElementS\n         BE    PERCENT            'JQES' found, go check percent\n         CLC   0(4,R11),JOES      See if we found JOB Output ElementS\n         BE    PERCENT            'JOES' found, go check percent\n         CLC   1(3,R11),TGS       See if we found 'TGS'\n         BNE   EXITEXIT           'TGS' not found, go exit the exit\nPERCENT  DS    0H\n         CLI   9(R11),C'%'        See if there is a percent sign\n         BNE   EXITEXIT           '%' not found, go exit this exit\n         CLC   7(2,R11),NINETY5   See if at least 95%\n         BL    EXITEXIT           Less than 95%, go exit this exit\n         GETMAIN RU,LV=CMDLEN,SP=230,LOC=(BELOW,ANY)\n*                                 Get some storage below-the-line\n         LR    R2,R1              Save address of the storage acquired\n         MVC   0(CMDLEN,R2),TEMPLATE  Copy the command for SVC 34\n         MVC   24(2,R2),7(R11)    Move the percentage to START command\n*         Commands built will be S SPOOL,MEMBER=SPOOL95 through 99\n         SLR   R0,R0              Clear register zero for SVC 34\n         SVC   34                 Issue operator command\n         FREEMAIN RU,LV=CMDLEN,A=(2),SP=230\n*                                 Free the below-the-line storage\nEXITEXIT DS    0H\n         DROP  R12                Drop addressability to this program\n         LM    R14,R12,12(R13)    Restore caller's registers\n         SLR   R15,R15            Set return code to zero\n         BR    R14                Return to caller\n*\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*       Constants, equates, and DSECTs\n*\n*      ( Note: Re-enterent code does not allow work areas here )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nH5       DC    H'5'               Constant for subtraction\nNINETY5  DC    CL2'95'            Constant for compare\nTEMPLATE DC    AL2(CMDLEN),AL2(0),CL23'S SPOOL,MEMBER=SPOOLXX '\nCMDLEN   EQU   *-TEMPLATE         Length ot the command list\nTGS      DC    CL3'TGS'           Constant for compare\nJNUM     DC    CL4'JNUM'          Constant for compare\nJQES     DC    CL4'JQES'          Constant for compare\nJOES     DC    CL4'JOES'          Constant for compare\n         SPACE 3\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         EJECT ,\n         LTORG ,                  Separate literals from DSECTs\n         IEZVX100 ,               COMM.TASK user exit routine parm.list\n         SPACE 3\n         END   ,                  The end of the exit\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????($HASP050),SPACE=   ,\n//*            UNIT=SYSDA,VOL=SER=??????\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TMOUNT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x07\\x02\\x9f\\x01\\t4\\x7f 3\\x00\\xc7\\x00\\xc8\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-01-29T00:00:00", "modifydate": "2009-12-13T20:33:47", "lines": 199, "newlines": 200, "modlines": 0, "user": "SOMITCW"}, "text": "From:\nhttp://listserv.lehigh.edu/lists/archives/vse-l/att-1728/01-TMOUNT.txt\n\n* $$ JOB JNM=TMOUNT,DISP=D,CLASS=0\n// JOB TMOUNT COMPILE PROGRAM TMOUNT\n// LIBDEF *,CATALOG=PRD2.CONFIG\n// OPTION ERRS,SXREF,SYM,NODECK,CATAL\n   PHASE TMOUNT,*\n// EXEC ASMA90,SIZE=(ASMA90,64K),PARM='EXIT(LIBEXIT(EDECKXIT)),SIZE(MAXC\n               -200K,ABOVE)'\nTMOUNT   CSECT\n         SPACE 1\n*---------------------------------------------------------------------*\n*   TMOUNT - VSE VERSION II                                           *\n*                                                                     *\n*   THE TMOUNT COMMAND IS USED FROM VSE ON THE P/390 TO TELL THE      *\n*   AWSTAPE MANAGER WHICH OS/2 FILE TO USE WHEN THE USER WRITES TO    *\n*   THIS DEVICE.  IT CAN ALSO BE USED TO QUERY WHAT OS/2 FILE IS      *\n*   CURRENTLY ASSOCIATED WITH THE DEVICE.                             *\n*                                                                     *\n*   TWO SPECIAL CCW OPCODES ARE SUPPORTED BY THE AWSTAPE EMUALTOR:    *\n*     X'4B'  - ASSIGN A DOS FILEID TO THE DEVICE. (WAS '4B' 6/30)     *\n*     X'E4'  - SENSE FILEID - RETURN THE NAME OF THE ASSIGNED DOS FILE*\n*                                                                     *\n*     THE EMULATED TAPE HAS TO BE ASSIGNED TO SYS014                  *\n*\n*   E.G  // JOB TMOUNT                                                *\n*        // ASSGN SYS014,580                                          *\n*        // EXEC TMOUNT,REAL,SIZE=AUTO,PARM='580 D:TEST.TAP'          *\n*        OR                                                           *\n*        // EXEC TMOUNT,REAL,SIZE=AUTO,PARM='580 (QUERY'              *\n*        /*                                                           *\n*        /&                                                           *\n*                                                                     *\n*                                                                     *\n*   AWSTAPE HAS A LIMIT OF 17 CHARACTERS IN A DOS FILEID.  THAT       *\n*   LIMIT IS ENFORCED ENTIRELY IN AWSTAPE.                            *\n*                                                                     *\n*   THIS PROGRAM IS PROVIDED ON AN AS-IS BASIS.                       *\n*   IT HAS NOT BEEN TESTED ON R/390                                   *\n*   NO MAINTENANCE WILL BE DONE AND NO APARS WILL BE ACCEPTED         *\n*                                                                     *\n*   COMMENTS AND SUGGESTION ARE WELCOME                               *\n*                                                                     *\n*   AUTHOR:  CHUCK BERGHORN                                           *\n*   REVISED FOR VSE:  CHRISTIAN TOEPSCH    (TOEPSCH@DE.IBM.COM)       *\n*---------------------------------------------------------------------*\n         SPACE 1\n         PRINT GEN\n         BALR  R8,0\n         USING *,R8\n         CR    R15,R1                  TEST FOR PARM=\n         BE    NOPARM                  NO PARM SPECIFIED, RETURN\n         L     R2,0(R1)                GET PARAMETER ADDRESS\n         SR    R3,R3                   CLEAR R3\n         LH    R3,0(R2)                GET PARMLENGTH\n         AH    R3,=X'0001'             ADJUST MOVE LENGTH\n         EX    R3,MOVEINST             DO THE MOVE\n         CLC   PARMLEN,=X'0015'        PARMLEN > THAN 21?\n         BH    TOOLONG                 PARMS TOO LONG, RETURN\n         OPEN  CONSOLE                 PREPARE TO WRITE TO CONSOLE\n         MVC   MSGOUT,MSGSTART\n         PUT   CONSOLE                 PRINT OUT THIS MESSAGE\n*---------------------------------------------------------------------*\n*     END OF PROLOGUE                                                 *\n*---------------------------------------------------------------------*\n         CLI   PARMDAT,C'('            ANY OPTIONS?\n         BNE   NOOPT                   NO, DO SETFILE\n         CLC   PARMDAT+1(5),=C'QUERY'  IS IT A QUERY?\n         BE    DOQUERY\n         B     BADOPT\n*---------------------------------------------------------------------*\n*   QUERY THE CURRENT FILE THAT IS THE VIRTUAL TAPE                   *\n*---------------------------------------------------------------------*\nDOQUERY  DS    0H                      SET UP TO DO A QUERY\n         MVC   MSGOUT,TMPQUERY\n         MVC   MSGOUT+42(4),PARMDEV    INSERT DEVADDR FROM PARM\n         PUT   CONSOLE                 PRINT OUT THIS MESSAGE\n*\n* DO THE QUERY\n*\n         EXCP  QDCCB                   FIND OUT THE CURRENT FILE\n         WAIT  QDCCB                   WAIT FOR IT TO HAPPEN\n         MVC   MSGOUT,DOSFID           PREPARE MESSAGE AND DISPLAY\n         PUT   CONSOLE                 RESULT OF QUERY\n         LA    R15,0                   SET RETURN CODE\n         B     RETURN\nMOVEINST MVC   RADDR(01),0(R2)         GET PARMS\nMOVEINS2 MVC   DOSFID(01),PARMDAT      MOVE FILENAME\n*---------------------------------------------------------------------*\n*  CODE TO SET A NEW FILENAME EQUAL TO THE VIRTUAL TAPE...            *\n*---------------------------------------------------------------------*\nNOOPT    DS    0H                      ASSUME ATTEMPT TO SET FILENAME\n         CLI   PARMDAT+1,C':'          WAS A DRIVE LETTER SPECIFIED\n         BNE   BADFILE\n         CLC   PARMDAT,MSGBLANK        ANY FILENAME SPECIFIED\n         BE    BADFILE                 NO, BAD FILENAME\n         MVC   MSGOUT,TMPNOOPT\n         MVC   MSGOUT+49(4),PARMDEV    PUT DEVADDR IN MESSAGE\n         PUT   CONSOLE\n         LH    R6,PARMLEN              THIS IS THE LENGTH HALFW\n         LA    R4,PARMDAT              THIS IS THE DATA\n         S     R6,PLUS4                SUBTRACT DEVADDR LENGTH AND\n         STH   R6,SDCCW+6              STORE LENGTH IN CCW\n         SH    R6,=X'0001'             ADJUST MOVE LENGTH\n         EX    R6,MOVEINS2             DO THE MOVE\n         MVC   MSGOUT,MSGBLANK         CLEAR MESSAGE AREA\n         MVC   MSGOUT,DOSFID           FILENAME IN MESSAGE\n         PUT   CONSOLE                 DISPLAY IT\n         EXCP  SDCCB                   SET THE FILENAME INTO MOUNT\n         WAIT  SDCCB                   WAIT FOR THIS TO HAPPEN\n         LA    R15,0                   SET RETURN CODE\n         B     RETURN                  EXIT\n*---------------------------------------------------------------------*\n* ERROR CONDITIONS                                                    *\n*---------------------------------------------------------------------*\nNOPARM   DS    0H\n         MVC   MSGOUT,MSGOPT25         SUBSTITUTE VSE MSG\n         PUT   CONSOLE                 SHOW THIS MESSAGE\n         LA    R15,4\n         B     RETURN\nBADOPT   DS    0H\n         MVC   MSGOUT,MSGOPT24         SUBSTITUTE VSE MSG\n         PUT   CONSOLE                 SHOW THIS MESSAGE\n         LA    R15,8\n         B     RETURN\nBADFILE  DS    0H\n         MVC   MSGOUT,MSGNOF5          SUBSTITUTE VSE MSG\n         PUT   CONSOLE                 SHOW THIS MESSAGE\n         LA    R15,12\n         B     RETURN\nTOOLONG  DS    0H\n         MVC   MSGOUT,MSGLNG6          SUBSTITUTE VSE MSG\n         PUT   CONSOLE                 SHOW THIS MESSAGE\n         LA    R15,16\n         B     RETURN\n*---------------------------------------------------------------------*\n*     EXIT CODE                                                       *\n*---------------------------------------------------------------------*\nRETURN   DS    0H\n         MVC   MSGOUT,MSGEND           TMP MSG TO SHOW COMPLETION\n         PUT   CONSOLE                 TMP - PUT OUT THIS MESSAGE\n         CLOSE CONSOLE\n         EOJ\n*\n*\nCONSOLE  DTFCN DEVADDR=SYSLOG,IOAREA1=MSGOUT,RECFORM=FIXUNB,           X\n               TYPEFLE=CMBND,BLKSIZE=80,INPSIZE=17\nMSGOUT   DS    CL80\nMSGSTART DC    CL80'*** BEGINNING OF VSE MOUNT ***'\nMSGEND   DC    CL80'*** END OF VSE MOUNT ***'\nMSGNOF5  DC    CL80'AWSMNT001E  NO OR INCORRECT FILEID SPECIFIED'\nMSGLNG6  DC    CL80'AWSMNT002E  DOS FILENAME TOO LONG'\nMSGOPT24 DC    CL80'AWSMNT003E  NO OR INVALID OPTION SPECIFIED'\nMSGOPT25 DC    CL80'AWSMNT004E  NO PARM= GIVEN'\nTMPQUERY DC    CL80'AWSMNT005E QUERY VIRTUAL TAPE AT ADDRESS '\nTMPNOOPT DC    CL80'AWSMNT006E ASSIGNING TO VIRTUAL TAPE AT ADDRESS '\nMSGBLANK DC    CL80' '\n*\nRADDR    DS    0CL40            USED TO SAVE PARMS\nPARMLEN  DC    CL2' '           PARAMETER LENGTH\nPARMDEV  DC    CL4' '           DEVADDR FROM PARMS\nPARMDAT  DC    CL36' '          DATA FROM PARMS (QUERY\n*                               OR FULL QUALIFIED FILENAME\nDOSFID   DC    CL80' '\n*\n*\nQDCCB    CCB   SYS014,QDCCW\nSDCCB    CCB   SYS014,SDCCW\nQDCCW    CCW   X'4B',DOSFID,X'60',1\n         CCW   X'E4',DOSFID,X'20',L'DOSFID\nSDCCW    CCW   X'4B',DOSFID,X'20',L'DOSFID\n*\n*\nPLUS4    DC    F'4'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n/*\n// IF  $MRC GT 4 THEN\n// GOTO NOLNK\n// EXEC LNKEDT\n/. NOLNK\n/&\n* $$ EOJ\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$VIRTAPE": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00Y\\x01\\x07\\x02\\x9f\\x01\\t4\\x7f!)\\x00r\\x01.\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2007-01-29T00:00:00", "modifydate": "2009-12-13T21:29:59", "lines": 114, "newlines": 302, "modlines": 0, "user": "SOMITCW"}, "text": "*\n* Long after this note was sent, Fish added CCW X'4B' support\n* to Hercules.  See Hercules configuration option \"automount\"\n*\n* Another problem I found about later:\n* SCO UnixWare 7.1.3.3 NFS to RedHat needs -proto tcp to\n* not corrupt data.  The default of -proto udp appears\n* to work but a couple of bytes every few million will\n* be corrupt.  -proto tcp session can hang if the ethernet\n* connection is broken.  One side stays up but not the other.\n* umount and mount should fix.\n*\n*\nSubject:     Re: Virtual Tape Robot (was Bad SCSI tape - outage)\nFrom:        - - <somitcw@yahoo.com>\nDate:        Sun, 28 Jan 2007 11:41:12 -0500\nTo:          lbaaxb@verizon.net\nCC:          SKnutson@CBTtape.org,SBGolob@attglobal.net\n\n   I've got dozens of programs.  I assume that you want\nsome of my IGXMSGEX programs.  See attached.\n\n   I have no intention of creating a software package.\n\n   The sample code is only needed for P/390 and\nFlex-ES systems and is not ready for CBT but I guess\nthat Sam and Sam can look at it.  There are pieces\nof one of my tape volume management systems that\nsomeone might find helpful.  There are no install or\ncustomizing instructions for the incomplete sample\nprograms but member TAPE$DOC gives some hints.\nSam and Sam have seen other trash that I wrote.\n\n   Did anyone ever add P/390 automountCCW to\nHercules?  It would be easy for someone other than\nme to do.  I have a couple of copies of almost specs.\n01-TMOUNT and a CCW trace from the Flex-ES list.\nNeither are mine but I've attach them also.  Until/unless\nHercules supports P/390 automountCCW, DIAG 8 is\nnot as secure but could be used.  Just update SVC 'W'.\n\n   Warning:  After I put this in production, the operator's\njob dropped to a weekly IPL and creating one SDLT per week\nfor off site data storage.  Don't mess with this code or\noperators will have to be trained for other areas.\n\n   Let me know if you need other assembler, perl scripts,\nRexx scripts, JCL sample, etc.\n\nAt 08:51 1/28/2007, Alex wrote:\nWould you mind sending your \"stuff\" to CBT tape?\nif you dont have time to package it I can set it up on\nour Flex test system (if permitted) and package it.\nAnyway, please send me whatever you can share.\n\nthanks in advance,\n\nAlex\n\n----- Original Message ----- From: \"- -\" <somitcw@YAHOO.COM>\nTo: <FLEX-ES@LISTSERV.UGA.EDU>\nSent: Saturday, January 27, 2007 10:24 PM\nSubject: Re: Virtual Tape Robot (was Bad SCSI tape - outage)\n\nOn Fri, 26 Jan 2007 20:58:07 -0500,\nAndreas F. Geissbuehler <afg0510@VIDEOTRON.CA> wrote:\n- - - snipped - - -\nI don't want to make any sales pitch although\n- - - snipped - - -\n\n  Your product sounds interesting but it would be\nsimplier and more efficient if it used P/390 Flex-ES\nauto-mount-CCW to mount tapes.  You can mount 50 to\n100 tapes per second.  Read the labels of 3,000 tapes\nin less than a minute.  To check my tape libraries,\nI can check my already collected SMF data or I can\nscan tape labels at a rate of the entire tape pool\nof any instance in less than a minute.\n\n  Instead of chmod of tape files, OS/390 and zOS\nRETPD= is what tape labels were designed for.\n\n  All OS/390 or zOS tape processing code is in\nOS/390 or zOS.  Tape shuffling on UnixWare/Linux\ndisk not wanted and not needed.\n\n  If you need off-site data storage, I recommend\nnative NFS instead of Windows style ifs samba.\ni.e. Native zOS tools for zOS and native unix type\ntools for unix like systems.\n\n  I have a perl script that does an ls for local\nand remote directories and uses cp to copy any\ntape images that have mis-matched byte counts.\nThere is no reason to down load a list of tapes\nto be copied from zOS or OS/390. i.e. Unix tools\nfor unix actions and OS/390 tools for OS/390\nactions.  I will cron the perl script some day\nbut started testing with at and never bothered\nto switch.\n\n  Your scratch tapes are the same size so am I\nto assume that you have compression turned off?\nWriting a shorter data file for scratch should\nkeep it below a disk sector.  I use 20 bytes:\nDSNAME   DC    CL44'EMPTY.TAPE '  Data set name for cleared tapes\nOUTREC   DC    CL20'TAPEZERO empty tape.'  Data written to tape\nThe 44 bytes is for open type J\n\n  All are welcome to my IGXMSGEX or other sample\ncode, just ask.  It is all written specifically\nfor my system so will have to be modified before\nit can be tested.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE751": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x02\\x01\\x150\\x8f\\x01\\x150\\x8f\\x13\\x02\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2015-11-04T00:00:00", "modifydate": "2015-11-04T13:02:02", "lines": 13, "newlines": 13, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 751 contains some valuable tape handling facility code.   *   FILE 751\n//*           Much of this code was developed on (or for) P/390,    *   FILE 751\n//*           FLEX-ES systems, and Hercules systems but it is up    *   FILE 751\n//*           to the user to decide what is useful for him or her.  *   FILE 751\n//*           See member $DOC.                                      *   FILE 751\n//*                                                                 *   FILE 751\n//*           E-Mail:  somitcw@yahoo.com                            *   FILE 751\n//*                                                                 *   FILE 751\n//*  Note:  Member IGC0023{ which is SVC 230 has been renamed       *   FILE 751\n//*         in this pds, to member name IGC00230.  If necessary,    *   FILE 751\n//*         when it is installed, the load module should be         *   FILE 751\n//*         renamed back to IGC0023{.                               *   FILE 751\n//*                                                                 *   FILE 751\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CMD": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x11\\x01\\t0o\\x01\\x10\\x11O\\x13@\\x01B\\x01P\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2009-11-02T00:00:00", "modifydate": "2010-04-24T13:40:11", "lines": 322, "newlines": 336, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWC JOB (????????,????,1439,9999),CMD-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//*\n//* Run this JOB to install program CMD\n//*\n//HLASMCL EXEC HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//             PARM.L='RENT,AC=1'\n//SYSLIB   DD\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN or SYS1.MODGEN\nPASS     TITLE 'CMD - - - Enter operator commands and run programs'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    This program accepts control statements.  One control\n* statement can come from a PARM and many from DDNAME CMDIN.\n* Either or both PARM and DDNAME CMDIN can be used.\n* If neither are used, CMD will bomb because of no input.\n*\n*    There is a quarter of a second delay between processing\n* control statements.\n*\n*    Bug: If there is a CMDIN DD statement, CMD cannot\n* call itself to call itself to call itself to execute a\n* command or program.  Several levels of CMD cannot\n* or should not open the same CMDIN DD statement at the\n* same time.  If this is changed, should the highest\n* level CMD be the one that opens CMDIN DD statement?\n* There could be several lower and lowest levels.\n*\n*    Control card image information:\n*\n*    If column 72 is not blank, it indicates a continued\n* statement.  Maximum of three card images per statement.\n* Column 1 through 71 are used on each card image.\n*\n*    There are three types of control statements allowed:\n*\n* 1. An asterick in column one normally indicates a comment.\n*    A value in column 72 will NOT continue a comment.\n*    An asterick in column 1 card image after a non-comment\n*    card image that is continued causes the column 1 asterick\n*    card image to be processed as a continuation of the\n*    previous card image, not as a comment.\n*\n* 2. A tick mark in column one and ten indicate a program is\n*    to be LINKed.  Any non-blank starting in columns 11\n*    are the PARM to be passed to the program.\n*    Column ten is not really checked so could be an equal-sign.\n*    The idea and method of calling programs came from\n*    PTW's program AUTOIPL.   I believe program AUTOIPL was\n*    on the CBT tape?\n*\n* 3. Any statement that does start with an asterick or tick\n*    mark is an operator command to be issued with SVC 34\n*\n*     This program must be authorized to use SVC 34 which\n* restricts it to not have non-APF libraries in any STEPLIB\n* or JOBLIB.\n*\n* Changed: 2009-11-02\n*          Renamed program from COMMAND to CMD to not conflict\n*          with VCCS JCL that uses DDname SYSIN for COMMAND.\n*\n* Written: 2008-10-05\n*          Adapted for use with Turnkey MVS system.\n*\n* R13 = Save area and work area base register.\n* R12 = Program base register.\n* R11 = Maximum condition code accumulator.\n* R10 = Indicate at least one valid input.  Input statement counter.\n* R9  = Length of data in statement.\n* R8  = Link register for routines CMD and PGM.\n*\n* Sample JCL:\n*\n* //STOP    PROC M=STOP\n* //CMD     EXEC PGM=CMD,TIME=1439\n* //CMDIN    DD  DISP=SHR,DSN=SYS2.SCRIPTS(&M)\n*\n* //CMD     EXEC PGM=CMD,PARM='DISPLAY T'          Display time\n* //CMD     EXEC PGM=CMD,PARM='''DELAY   ''5'      Wait 5 seconds\n* //CMD     EXEC PGM=CMD,PARM='STOP TSO'           Stop TSO\n*\n*    Note: DDNAME CMDIN was used instead of SYSIN to allow\n* programs to be called that used DDNAME SYSIN.\n*\n*    Note: If an abend is needed when a LINKed program\n* returns a non-zero return code, use program CONDCHEK\n* instead of this program.  Or use this program to call\n* CONDCHEK to call the needed program.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nCMD      CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'CMD.V1.R1.M0.&SYSDATE..&SYSTIME' Save Reg.s\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING CMD,R12            Give the assembler the new base\n         L     R2,0(,R1)          Save the address of the parms\n         LA    R0,WORKLEN         Load work area size for GETMAIN\n         GETMAIN RU,LV=(0)        Get storage for work space\n         XC    0(CLEARLEN,R1),0(R1)  Clear DSECT start to binary zeroes\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         SLR   R11,R11            Clear max-cond-code register\n         SLR   R10,R10            Clear the commands issued indicator\n         USING SAVEAREA,R13       Tell assembler register for savearea\n*        XC    CMDPAD,CMDPAD      Clear SVC34 field to zeroes\n         LA    R1,EPLOC           Load address of program name to LINK\n         ST    R1,LINK            Store addr.of program name for LINK\n         LH    R3,0(,R2)          Load the length of the PARM\n         LTR   R3,R3              See if PARM length is zero\n         BZ    CKCMDIN            No PARM - check CMDIN\n         LR    R9,R3              Save length for CMD or PGM routine\n         MVI   CMDDATA,X'40'      Space out command/program work area\n         MVC   CMDDATA+1(L'CMDDATA-1),CMDDATA Blank cmd/pgm work area\n         BCTR  R3,0               Drop length by 1 for EXecute of MVC\n         EX    R3,MVC             Move the PARM to the command field\n         CLI   CMDDATA,X'7D'      See if a tick mark for program\n         BE    PARMPGM            Is program, go to go to link\n         BAL   R8,DOCMD           Perform command routine\n         B     CKCMDIN            Go check for CMDIN data\nMVC      MVC   CMDDATA(0),2(R2)   Dummy move for above EXecute\nPARMPGM  DS    0H\n         BAL   R8,DOPGM           Perform program routine\n*        B     CKCMDIN            Go check for CMDIN data\nCKCMDIN  DS    0H\n         MVC   EXTRLIST,EXTRACT   Prime the extract list in the DSECT\n         LA    R1,EXTRLIST        Load address of the EXTRACT list\n         LA    R2,TIOT            Load address of the TIOT hold area\n         EXTRACT (R2),MF=(E,(1))  Get the TIOT address\n         L     R1,TIOT            Load the address of the TIOT\n         SLR   R2,R2              Clear a work register\n         LA    R1,24(,R1)         Bump past the header\nCKCMDIN2 DS    0H\n         ICM   R2,B'0001',0(R1)   Load the length of an entry\n         BZ    ENDOFJOB           End of TIOT, no CMDIN, go to EOJ\n         CLC   4(8,R1),CL8CMDIN   See if DDNAME 'CMDIN' is in JCL\n         BE    OPEN               If found, go OPEN it\n         ALR   R1,R2              Bump to next TIOT entry\n         B     CKCMDIN2           Go to check next TIOT entry\nOPEN     DS    0H\n         MVC   CMDIN,DCB          Prime the CMDIN DCB in the DSECT\n         LA    R1,CMDIN           Load address of the CMDIN DCB\n         ST    R1,OPENLIST        Store address of DCB in OPENLIST\n         OI    OPENLIST,X'80'     Indicate end of list\n         LA    R1,OPENLIST        Load address of OPEN/CLOSE parmeters\n         OPEN  MF=(E,(1))         OPEN the input control card file\n         TM    CMDIN+48,X'10'     OPEN okay ?\n         BZ    OPENERR            If OPEN failed, go to ABEND\nNEXTREC  DS    0H\n         STIMER WAIT,BINTVL=QUARSEC  Wait for 1/4 second\n         MVI   CMDDATA,X'40'      Space out command/program work area\n         MVC   CMDDATA+1(L'CMDDATA-1),CMDDATA Blank cmd/pgm work area\n         GET   CMDIN,CMDDATA      Get an input record\n         CLI   CMDDATA,C'*'       See if a comment\n         BE    NEXTREC            Is a comment, throw away after delay\n         MVC   CMDDATA+72(8),SPACES  Clear statement sequence numbers\n         CLI   CMDDATA+71,X'40'   See if statement is continued\n         BE    GOTDATA            Statement not continued, go process\n         GET   CMDIN,CMDDATA+71   Get a second input record\n         MVC   CMDDATA+143(8),SPACES  Clear statement sequence numbers\n         CLI   CMDDATA+142,X'40'  See if statement is continued again\n         BE    GOTDATA            Statement not continued, go process\n         GET   CMDIN,CMDDATA+142  Get a third input record\n         MVC   CMDDATA+214(8),SPACES  Clear statement sequence numbers\n*  Maximum of three card images to build a statement.\n*  Since program PARMs should be limited to 100 bytes and\n*  console commands should be limited to 126 bytes,\n*  so allowing 213 bytes input data may be excessive.\nGOTDATA  DS    0H\n         MVCIN MVCIN,CMDDATA+L'CMDDATA-1  Reverse data to find length\n         TRT   MVCIN(L'MVCIN),TABLE  Find last non-blank\n         BZ    NEXTREC            No data, go ignore statement\n         LA    R2,MVCIN           Load address of the data\n         SLR   R1,R2              Find the length of spaces\n         LA    R9,L'MVCIN         Load length of the data field\n         SLR   R9,R1              Find the length of data\n         CLI   CMDDATA,X'7D'      See if a tickmark to indicate program\n         BE    PROGRAM            Is program, go link to it\n         BAL   R8,DOCMD           Is command, perform it\n         B     NEXTREC            Go get next input statement\nPROGRAM  DS    0H\n         BAL   R8,DOPGM           Perform routine to link program\n         B     NEXTREC            Go get next input statement\nDOCMD    DS    0H\n         LA    R9,4(,R9)          Adjust length for word before command\n         STH   R9,CMDLEN          Store full length for SVC 34\n         MODESET MODE=SUP,KEY=ZERO  Switch to supervisor mode\n         SLR   R0,R0              Set console number to zero\n         LA    R1,CMDLEN          Load address of command buffer\n         CLI   CMDDATA,C'Q'       See if QUIESCE command\n         BNE   SVC34              Not QUIESCE, use hardcpy for console\n         LA    R0,3               Set console 0009 as console\n* This code should check what is the current master console\n* and not assume that console number three is it\nSVC34    DS    0H\n         SVC   34                 Issue the operator command SVC\n         LA    R10,1(,R10)        Indicate that commands were issued\n         CLR   R15,R11            See if new high-cond-code\n         BH    NEWHICC            New high-cond-code, go update R11\nNZERO    DS    0H\n         MODESET MODE=PROB,KEY=NZERO  Switch back to problem state\n         BR    R8                 Return to main-line program\nNEWHICC  DS    0H\n         LR    R11,R15            Save new max-cond-code\n         B     NZERO              Go to problem state, get next record\nDOPGM    DS    0H\n         MVC   EPLOC,CMDDATA+1    Copy program name for LINK\n         SH    R9,H10             Adjust length for program PARM length\n         STH   R9,CMDDATA+8       Store PARM length for program parm\n         LA    R9,CMDDATA+8       Load address of PARM for program\n         ST    R9,PARMPTR         Store address in PARM address list\n         OI    PARMPTR,X'80'      Mark first address in list as last\n         LA    R1,PARMPTR         Load address of PARM pointer for LINK\n         LA    R15,LINK           Load address of LINK parameter list\n         SVC   6                  LINK requested program\n         LA    R10,1(,R10)        Indicate program attempted or did run\n         CLR   R15,R11            See if new high-cond-code\n         BNHR  R8                 Not high, return to main-line program\n         LR    R11,R15            Save new max-cond-code\n         BR    R8                 Return to main-line program\nENDFILE  DS    0H\n         LA    R1,OPENLIST        Load address of OPEN/CLOSE parameters\n         CLOSE MF=(E,(1))         Close the input control card file\nENDOFJOB DS    0H\n         LTR   R10,R10            See if there were no commands issued\n         BZ    NOCOMMND           If no commands, go abend\n         LA    R0,WORKLEN         Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         FREEMAIN RU,LV=(0),A=(1) Free work area's storage\n         LR    R15,R11            Restore MGCR's highest return code\n         RETURN (14,12),RC=(15)   Return to caller with MGCR ret-code\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Error ABEND routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nOPENERR  DS    0H\n         WTO   'CMD - OPEN for DD CMDIN failed.  How?',ROUTCDE=(1,11)\n         ABEND 1211,DUMP          Abend, with a dump\nNOCOMMND DS    0H\n         WTO   'CMD - Must have a PARM or DD CMDIN',ROUTCDE=(1,11)\n         WTO   'CMD - Program abending',ROUTCDE=(1,11)\n         ABEND 1212,DUMP          Abend, with dump\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Constants and literals\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n*                  H H M M S S T H\nH10      DC    H'10'              Length of program name and tick marks\nQUARSEC  DC    F'25'              Wait time of 1/4 second for STIMER\nCL8CMDIN DC    CL8'CMDIN '        Constant for compare\nSPACES   DC    CL8' '             Constant of spaces to clear seq.no.\nEXTRACT  EXTRACT *-*,'S',FIELDS=TIOT,MF=L  Dummy EXTRACT macro\nEXTRLEN  EQU   *-EXTRACT          Length of EXTRACT list\nDCB      DCB   DDNAME=CMDIN,DSORG=PS,MACRF=GM,EODAD=ENDFILE,LRECL=80,  C\n               RECFM=FB\nDCBLEN   EQU   *-DCB              Length of CMDIN's DCB\nTABLE    DC    64AL1(1),AL1(0),191AL1(1)  Table for finding non-space\n*\n         LTORG ,                  In case someone uses literals\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs and Register EQUates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nLINK     DS    D                  Will be the executed LINK MACRO\n* LINK first word is pointer to EPLOC, secord word is zero LINK DCB\n*\nTIOT     DS    A(*-*)             Address of the Task I/O Table\nPARMPTR  DS    A(*-*)             PARM address list for LINKed program\nEPLOC    DS    CL8                Will be name of program for LINK\nOPENLIST DS    A(*-*),A           OPEN/CLOSE parameter list\nEXTRLIST DS    XL(EXTRLEN)        Will be the real EXTRACT list\n         DS    0D                 Insure DCB alignment\nCMDIN    DS    XL(DCBLEN)         Will be the real DCB list\n* * * * * * * * * * * The following 5 lines must stay together\n         DS    0D                 Align pgm PARM to half before full\n         DS    H                  Align pgm.PARM.len. to half ere full\nCMDLEN   DS    H                  Length of the command to be executed\nCMDPAD   DS    H                  Pad, always binary zeroes\nCLEARLEN EQU   *-SAVEAREA         Size of data to clear\nCMDDATA  DS    CL256              Command to execute from PARM or GET\n* * * * * * * * * * * The preceeding 5 lines must stay together\nMVCIN    DS    CL256              Data reversed to find last non-space\n*\nWORKLEN  EQU   *-SAVEAREA         Work area length to GETMAIN/FREEMAIN\n         EJECT\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=\n NAME CMD\n//*\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONDCHEK": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x00\\x93'\\x7f\\x01\\x10\\x11O\\x14\\x11\\x00\\x80\\x00\\x80\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-10-04T00:00:00", "modifydate": "2010-04-24T14:11:27", "lines": 128, "newlines": 128, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWC JOB (????????,????,1439,9999),CONDCHEK-SOMITCW,\n//         CLASS=?,MSGCLASS=?,\n//         NOTIFY=SOMITCW,COND=(0,NE)\n//ASMHCL   EXEC HLASMCL\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=------\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR,UNIT=SYSDA,VOL=SER=------\nPASS     TITLE 'Utility to LINK other programs and check the Cond Code'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      This program LINKs other program and checks the condition code\n*    for zero.  If the returning condition is not zero, the step is\n*    abended with the abend code of the return code.\n*\n*      The name of the program to be LINKed is supplied from the\n*    PARM field of an EXEC statement.  An additional PARM may also\n*    be specified to be passed to the program being LINKed.\n*\n*      The first eight characters of the PARM field is used for the\n*    name of the program to be linked.  If any additional parameters\n*    are placed in the PARM field, they are passed to the linked\n*    program.  If no parm field is on the EXEC statement at all,\n*    the default program of IDCAMS is LINKed.\n*\n*    Examples:\n*\n*      To LINK IDCAMS:\n*    //IDCAMS   EXEC PGM=CONDCHEK,RD=R\n*    //SYSPRINT DD  SYSOUT=*\n*    //SYSIN    DD  DSN=P.CTLCARD(REPRO),DISP=SHR\n*    //SYSUT1   DD  DSN=INPUT.TAPE,DISP=SHR,DCB=BUFNO=5\n*    //SYSUT2   DD  DSN=COPY.OF.TAPE,DISP=(,KEEP),UNIT=TAPE,\n*    //             DCB=(RECFM=FB,LRECL=100,BLKSIZE=32700)\n*\n*      To LINK IEBDG:\n*    //IEBDG    EXEC PGM=CONDCHEK,PARM=IEBDG,RD=R\n*    //SYSPRINT DD  SYSOUT=*\n*     DSD OUTPUT=(SYSUT2)\n*     CREATE QUANTITY=1500,FILL=X'00'\n*    //SYSUT2   DD  DSN=NEW.BDAM.FILE,DISP=(,CATLG,DELETE),\n*    //             UNIT=SYSDA,SPACE=(CYL,50,RLSE),DCB=(RECFM=F,\n*    //             LRECL=19069,BLKSIZE=19069,BUFNO=3)\n*\n*      To LINK IEBISAM:\n*    //IEBISAM  EXEC PGM=CONDCHEK,PARM='IEBISAM PRINTL',RD=R\n*    //SYSPRINT DD  SYSOUT=*\n*    //SYSUT1   DD  DSN=ISAM.OR.VSAM.KEYED.FILE,DISP=SHR\n*    //SYSUT2   DD  SYSOUT=A,OUTLIM=500\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nCONDCHEK CSECT ,\n         STM   R14,R12,12(R13)    Save caller's registers\n         BALR  R12,R0             Set base register\n         USING *,R12              Give system the base register\n         ST    R13,SAVE+4         Save the address of the old save area\n         LA    R0,SAVE            Load address of the new save area\n         ST    R0,8(,R13)         Connect save area chain\n         LR    R13,R0             Move in new save area\n         L     R1,0(,R1)          Load the address of the PARM field\n         LH    R11,0(,R1)         Load the length of the PARM\n         LTR   R11,R11            See if the PARM has a length\n         BZ    DEFAULT            LINK to the default program if zero\n         SH    R11,EIGHT          See if the PARM is greater than eight\n         BNP   MOVEPROG           No extra PARM to pass to LINKed pgm\n         STH   R11,PARMSIZE       Save PARM size to pass to LINKed pgm\n         BCTR  R11,R0             Subtract one for MVC length\n         EX    R11,MVC1           Move PARM to be passed to LINKed pgm\n         MVC   PGMNAME,2(R1)      Move program for LINK\n*\nLINK     DS    0H\n         LINK  EPLOC=PGMNAME,PARAM=PARMSIZE,VL=1  LINK to program\n         LTR   R10,R15            See if Condition/Return Code is zero\n         BNZ   ABEND              Abend the program if Return not zero\n*\n         L     R13,SAVE+4         Restore the old register thirteen\n         L     R14,12(,R13)       Restore the return address\n         LM    R0,R12,20(R13)     Restore registers zero to twelve\n         BR    R14                Return to caller\n*\nDEFAULT  DS    0H\n         MVC   PGMNAME,IDCAMS     Use default program to LINK\n         B     LINK               Go to LINK program\n*\nMOVEPROG DS    0H\n         LA    R11,7(,R11)        Set PARM length to move program name\n         EX    R11,MVC2           Move program name for LINK\n         B     LINK               Go to LINK the program\n*\nABEND    DS    0H\n         WTO   'Program error, check listing',ROUTCDE=(1,11)\n*                                 Tell the operator of the error\n         LR    R1,R10             Load abend code for SVC 13\n         SVC   13                 Abend this task, no dump\n         SPACE 2\nMVC1     MVC   PARMS(1),10(R1)    Move PARM for LINKed program\nMVC2     MVC   PGMNAME(1),2(R1)   Move program name\n         EJECT\nSAVE     DC    18F'0'             Register save area\n*\nPGMNAME  DC    CL8' '             Program to be LINKed\nIDCAMS   DC    CL8'IDCAMS '       Default program to LINK\n*\nEIGHT    DC    H'8'               Constant for subtraction\n*\n         CNOP  2,4                Align following DC and DS\nPARMSIZE DC    X'0000'            Size of PARM to be passed\nPARMS    DS    XL92               PARM field to be passed\n         SPACE\nR0       EQU   0                  Register equates\nR1       EQU   1                  Register equates\nR2       EQU   2                  Register equates\nR3       EQU   3                  Register equates\nR4       EQU   4                  Register equates\nR5       EQU   5                  Register equates\nR6       EQU   6                  Register equates\nR7       EQU   7                  Register equates\nR8       EQU   8                  Register equates\nR9       EQU   9                  Register equates\nR10      EQU   10                 Register equates\nR11      EQU   11                 Register equates\nR12      EQU   12                 Register equates\nR13      EQU   13                 Register equates\nR14      EQU   14                 Register equates\nR15      EQU   15                 Register equates\n         END   ,\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=,\n//             UNIT=SYSDA,VOL=SER=------\n   NAME CONDCHEK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CVTUSER": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\"\\x00\\x94\\x18\\x7f\\x01\\t4\\x7f D\\x00\\x1d\\x00\\x03\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1994-07-06T00:00:00", "modifydate": "2009-12-13T20:44:22", "lines": 29, "newlines": 3, "modlines": 0, "user": "SOMITCW"}, "text": "*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*  MPF exit ????.SORC????(IEC507D)  uses XCVTUVOL.\n*  MPF exit ????.SORC????(IEC512I)  updates XCVTSKIP.\n*  DFP exit ????.SORC????(IGXMSGEX) uses XCVTTAPE.\n*  MPF exit ????.SORC????(IOS000I)  uses XCVTUTIM.\n* ACF2 exit ????.SORC????(LGNIXIT)  uses XCVTPSWD. old, delete programs\n* Batch PGM ????.SORC????(SAVEPSWD) uses XCVTPSWD. old, delete programs\n*  MPF exit ????.SORC????(DFHJC450) uses XCVTJOUR.\n* SubSystem ????.SORC????(TAPESAVE) uses XCVTTAPE.\n* Batch PGM ????.SORC????(TAPESYNC) uses XCVTTAPE.\n* Batch PGM ????.SORC????(SETWHEN)  uses XCVTWHEN.\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nXCVTUSER DSECT ,\nXCVTUEYE DS    CL8                7 bytes of 'CVTUSER' and 1 byte X'01'\nXCVTUVOL DS    XL6                VOLSER from message used by IEC507D\nXCVTWHEN DS    CL1                D-N-W, Day, Night, Week-end indicator\n         DS    XL1                Space available for expansion\nXCVTUTIM DS    XL6                CYYDDDHHMMSS Century, Year,Day, Hour,\n*                                 Minute, and Second, used by IOS000I\n         DS    XL2                Space available for expansion\nXCVTPSWD DS    F                  ACF2 LGNIXIT anchor, used by SAVEPSWD\nXCVTJOUR DS    F                  DFHJC4508 Journal PRIM or SECO\nXCVTTAPE DS    XL4                TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* TAPESKIP DS    CL6              TAPESKIP was old name for XCVTSKIP\nXCVTSKIP DS    CL6                IEC512I tape vol ser to ignore\n         DS    XL22               Space available for expansion\nXCVTUSIZ EQU   *-XCVTUSER         Length of area pointed to by CVTUSER\n*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DATEYMD": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x06\\x01o\\x01\\t4\\x7f F\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-01-16T00:00:00", "modifydate": "2009-12-13T20:46:32", "lines": 28, "newlines": 28, "modlines": 0, "user": "SOMITCW"}, "text": "        /* Rexx EXEC to set date in directory names for\n           SFTP from SCO to Linux.*/\n        /* This REXX EXEC is used in ????.JCLLIB(TAPEOFF) */\n\n        /*   Variable searched for and changed to the date is:\n           YYYY.MM.DD               */\n\n        thedate = DATE('S')\n        yyyy    = SUBSTR(thedate,1,4)\n        mm      = SUBSTR(thedate,5,2)\n        dd      = SUBSTR(thedate,7,2)\n        thedate = yyyy'.'mm'.'dd\n\n        \"EXECIO * DISKR\" SYSUT1 \"(FINIS STEM in.\"\n\n        out.  = \"\"\n        out.0 = 0\n\n        DO i = 1 TO in.0\n          location = POS('YYYY.MM.DD',in.i)\n          IF location > 0 THEN\n            in.i = OVERLAY(thedate,in.i,location,10)\n          out.i = in.i\n          END\n\n        out.0 = i\n\n        \"EXECIO * DISKW\" SYSUT2 \"(FINIS STEM out.\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELAY": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\t1\\x01p\\x01p\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T09:31:00", "lines": 368, "newlines": 368, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWD JOB (????????,????,1439,9999),DELAY-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//*\n//HLASMCL EXEC PROC=HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//  PARM.L=(TERM,LIST,RENT,REUS,REFR)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\nPASS     TITLE 'DELAY - - - Set an STIMER with user specified value'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program accepts the PARM in batch, TSO, or Rexx format,\n*  and delays the process for the requested number of seconds and\n*  hundredths of a second.  If tenths or hundredths of a second\n*  are needed, then PARM must contain a decimal point.\n*\n*     If called as a Rexx function, the actual wait time accepted\n*  will be the returned data.\n*\n*     Original DELAY program was a batch or called program only\n*  and only waited for seconds, not hundredths.\n*\n*     Updated 2010-04-26  To not abend when called without a PARM or\n*  when a Rexx EXEC passes a PARM of '.'.\n*\n*     Updated 2010-04-24  To allow running as a TSO CP, REXX\n*  external function, or batch program.  The update also allows\n*  tenths and hundredths of a second to be specified.\n*\n*     Tur(n)key #3 location of old version: SYS1.SETUP.ASM(DELAY)\n*\n*  //DELAY#1 EXEC PGM=DELAY,PARM=5      Wait five seconds\n*  //DELAY#2 EXEC PGM=DELAY,PARM=1.2    Wait one and one-fifth seconds\n*  //DELAY#3 EXEC PGM=DELAY,PARM='.01'  Minimum wait time\n*  //DELAY#4 EXEC PGM=DELAY,PARM=0      Will give minimum of .01\n*\n*  /* Rexx */\n* SAY DELAY(\"1.23\")      /* Will wait 1.23 seconds and then SAY 1.23 */\n* SAY DELAY(\"01.23456\")  /* Will wait 1.23 seconds and then SAY 1.23 */\n* CALL DELAY(\".2\")       /* Will wait for one-fifth of a second */\n* xxxx = DELAY(\"3\")      /* Will wait three seconds and SET xxxx = 3 */\n*\n*  READY\n* delay 1\n*  READY\n*\n*  Blame: somitcw@yahoo.com\n*\n* R13 = Register save area and work area\n* R12 = Base register\n* R11 = Input PARM list address\n* R10 = Address of input PARM seconds\n* R9  = Input PARM seconds length ( Should end up being 0 to 8 )\n* R8  = Address of input PARM hundreds of seconds\n* R7  = Input PARM hundreds of seconds length ( Should end up 0,1,or 2)\n* R6  = Address of Rexx return data if called as a Rexx function\n* R5  = Length of Rexx return data if called as a Rexx function\n* R4  = Rexx Evaluation Block if called as a Rexx function\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDELAY    CSECT ,\nDELAY    AMODE ANY                Addressing mode of ANY\nDELAY    RMODE ANY                Residency mode of ANY\n         SAVE  (14,12),,'DELAY.&SYSDATE..&SYSTIME'    Save Reg.s\n         LR    R12,R15            Load the program's base register\n         USING DELAY,R12          Give the assembler the base reg.\n         LA    R11,0(,R1)         Save the address of the PARM list\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(WORKSIZE,R1),0(R1)  Clear DSECT to binary zeroes\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING WORKAREA,R13       Tell assembler of save area base reg.\n         MVC   PARMDISP,ZEROES    Initialize PARM convert area\n         LTR   R11,R11            See if the PARM register is zero\n         BZ    PACK               No PARM, go default to .01 seconds\n         ICM   R1,B'1111',0(R11)  See if first word of PARM list zero\n         BZ    REXXIN             Is REXX function PARM, go process\n         LA    R1,0(,R1)          Clear high-order bit or byte\n         LTR   R1,R1              See if the PARM address is zero\n         BZ    PACK               No PARM, go default to .01 seconds\n         TM    0(R11),X'80'       See if a batch program PARM\n         BO    BATCHIN            Is MVS batch program PARM, go process\n         CLI   2(R1),X'00'        See if TSO CP\n         BZ    TSOCPIN            Is TSO CP PARM format, go process\n         B     ERRPARM            PARM format not recognized, go abend\n*\n* REXX function arguments format\nREXXIN   DS    0H\n         L     R10,16(,R11)       Load address of argument addr&length\n         ICM   R9,B'1111',4(R10)  Load length of REXX argument\n         BNP   PACK               Not positive=no argument, go default\n         L     R10,0(,R10)        Load address of REXX argument\n         B     EATZEROS           Go to cleanup and format the argument\n*\n* TSO CP input PARM format\nTSOCPIN  DS    0H\n         SLR   R2,R2              Clear work register for ICM\n         ICM   R2,B'0011',2(R1)   Load the PARM displacement\n         BZ    PACK               No displacement, go default to .01\n         LA    R2,4(,R2)          Add length of first word of CPPL\n         LR    R10,R1             Load address of TSO CP command block\n         AR    R10,R2             Add displacement to calc PARM address\n         LA    R10,0(,R10)        Load address of REXX argument\n         SLR   R9,R9              Prepare to get PARM length\n         ICM   R9,B'0011',0(R1)   Get CPPL length\n         SLR   R9,R2              Get PARM data length\n         B     EATZEROS           Go to cleanup and format the argument\n*\n* Batch input PARM format\nBATCHIN  DS    0H\n         LA    R10,2(,R1)         Load address of the PARM data\n         SLR   R9,R9              Prepare to get PARM length\n         ICM   R9,B'0011',0(R1)   Get PARM length\n         BZ    PACK               No PARM length, go take default .01\n*        B     EATZEROS           Go to cleanup and format the argument\n*\n* Drop leading zeroes\nEATZEROS DS    0H\n         LTR   R9,R9              See if PARM length is zero\n         BZ    PACK               PARM was all zeroes, go assume 0.01\n         CLI   0(R10),C'0'        See if first byte is zero\n         BNE   FINDDOT            Leading zeroes dropped, go find dec.\n         LA    R10,1(,R10)        Move past a leading zero\n         BCTR  R9,0               Drop PARM length by one\n         B     EATZEROS           Go back to check for more leading 0's\n*\n* Find decimal point\nFINDDOT  DS    0H\n         LTR   R9,R9              See if PARM length is zero bytes\n         BZ    PACK               PARM 0, go use default of .01 seconds\n         LA    R10,0(,R10)        Clean PARM data location address\n         LR    R1,R9              Get length of PARM\n         BCTR  R1,0               Get length of PARM for EX instruction\n         EX    R1,TRT             Find if a decimal point in PARM\n         BZ    MOVWHOLE           Is whole number, skip decimal process\n         BH    ENDDOT             PARM has ending decimal point\n         LA    R8,1(,R1)          Load location of decimal fraction\n         LA    R1,0(,R1)          Clean period location address\n         SLR   R1,R10             Find length of whole number\n         LR    R7,R9              Find length of decimal part of number\n         SLR   R7,R1              Find length of decimal part of number\n         BCTR  R7,0               Find length of decimal part of number\n         LR    R9,R1              Save length of whole number\n         MVC   PARMDISP+8(1),0(R8)  Move first byte of decimal to pack\n         BCTR  R7,0               Drop length of fraction bytes by one\n         LTR   R7,R7              See if a second byte\n         BZ    MOVWHOLE           No other byte to move, go move whole\n         MVC   PARMDISP+9(1),1(R8)  Move second byte of dec. to pack\n         B     MOVWHOLE           No more bytes to move, go do whole no\n*\nTRT      TRT   0(*-*,R10),DOTTABLE  Find if decimal point in PARM\n*\nENDDOT   DS    0H\n         BCTR  R9,0               Drop ending period from PARM\n         LTR   R9,R9              See if any PARM left\n         BZ    PACK               PARM only a decimal point, go default\n*\nMOVWHOLE DS    0H\n* R10 is location of whole number part of the PARM\n* R9  is length of whole number part of the PARM\n         LTR   R9,R9              See if any whole number to move\n         BZ    PACK               No whole number, go pack fraction\n         CH    R9,H8              See if PARM whole no. over 8 bytes\n         BH    PARMLONG           If over 8 bytes, go abend\n         LA    R1,PARMDISP+8      Find where to move PARM to\n         SLR   R1,R9              Find where to move PARM whole number\n         LR    R2,R9              Load length of PARM whole number\n         BCTR  R2,0               Adjust PARM whole no. length for EX\n         EX    R2,MVCPARM         Copy PARM whole number for convert\n         B     PACK               Go pack and CVB the PARM and wait\n*\nMVCPARM  MVC   0(*-*,R1),0(R10)   Dummy copy for above EXecute\n*\nPACK     DS    0H\n         MVC   PARMCOMP,ZEROES    See if PARM is numeric\n         MVZ   PARMCOMP,PARMDISP  See if PARM is numeric\n         CLC   PARMCOMP,ZEROES    See if PARM is numeric\n         BNE   PARMINV            PARM not numeric, go abend\n         CLC   PARMDISP,TWOGIG    See if PARM greater than 21474836.47\n         BH    PARMLONG           PARM too great, go abend\n         PACK  PARMPACK,PARMDISP  Change display data to packed format\n         OI    PARMPACK+7,X'0F'   Insure a valid and positive sign\n         CVB   R1,PARMPACK        Change packed data to binary data\n         LTR   R1,R1              See of time of zero requested\n         BNZ   STORTIME           Not zero time, go store time\n         LA    R1,1               Set default of .01 seconds\n         MVI   PARMDISP+9,C'1'    Set default of .01 seconds\nSTORTIME DS    0H\n         ST    R1,TIME            Set time for STIMER to delay\n         ICM   R1,B'1111',0(R11)  See if first word of PARM list zero\n         BNZ   STIMER             Not REXX function PARM, go wait\n         L     R4,20(,R11)        Load REXX evaluation block address\n         L     R4,0(,R4)          Load REXX evaluation block address\n         CLI   7(R4),8            Insure REXX Eval.block 9 double words\n         BL    STIMER ? Abend ?   Eval. block too short, skip update\n         MVC   REXXRETD(8),PARMDISP  Copy whole number of seconds\n         MVI   REXXRETD+8,C'.'   Put decimal point for REXX return\n         MVC   REXXRETD+9(2),PARMDISP+8  Put decimal number for ret.\n         LA    R6,REXXRETD        Load address of max. data to return\n         LA    R5,11              Load maximum length to return\nEATLEAD0 DS    0H\n         CLI   0(R6),C'0'         See if a leading zero\n         BNE   NOWDOT             No more leading zeroes, go handle dot\n         LA    R6,1(,R6)          Bump to next REXX return data address\n         BCTR  R5,0               Drop length of REXX return data by 1\n         B     EATLEAD0           Go back to eat more leading zeroes\n*\nNOWDOT   DS    0H\n         CLI   REXXRETD+10,C'0'   See if trailing zero in hundredth pos\n         BNE   STORREXX           Not trailing, go store REXX ret. data\n         BCTR  R5,0               Drop length of REXX return data by 1\n         CLI   REXXRETD+9,C'0'    See if trailing zero in tenths pos.\n         BNE   STORREXX           Not trailing, go store REXX ret. data\n         BCTR  R5,0       zero    Drop length of REXX return data by 1\n         BCTR  R5,0       period  Drop length of REXX return data by 1\n*\nSTORREXX DS    0H\n         ST    R5,8(,R4)          Store return data length\n         BCTR  R5,0               Adjust length for following EX instr.\n         EX    R5,MVCREXX         Move REXX return data to REXX eval.\n*\nSTIMER   DS    0H\n         STIMER WAIT,BINTVL=TIME  Wait for requested number of seconds\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R1)         Restore the caller's save area addr.\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=0      Return to caller w/retcode of zero\n*\nMVCREXX  MVC   16(*-*,R4),0(R6)   Move REXX output data\n*\n         EJECT ,\nERRPARM  DS    0H\n         WTO   'DELAY - PARM not Batch, TSO-CP, or REXX, abending',    C\n               ROUTCDE=(1,11)\n         ABEND 1111               Abend, no dump\n*\nPARMLONG DS    0H\n         WTO   'DELAY - Abending, PARM too long, max is 21474836.47',  C\n               ROUTCDE=(1,11)\n         ABEND 1112               Abend, no dump\n*\nPARMINV  DS    0H\n         WTO   'DELAY - Abending because PARM is not numeric',         C\n               ROUTCDE=(1,11)\n         ABEND 1113               Abend, no dump\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Constants and literals\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nH8       DC    H'8'               Constant for comparing PARM length\n*\nTWOGIG   DC    CL10'2147483647'   To init PARM display area\n*\nZEROES   DC    CL10'0000000000'   Value to init&check PARM display area\n*\n         LTORG ,                  In case someone uses literals\nDOTTABLE DC    0D'0',XL256'00'    TRT table to find decimal points\n         ORG   DOTTABLE+C'.'      Overlay the period position\n         DC    CL1'.'             Overlay the period position\n         ORG   ,                  Overlay the period position\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs and register equates follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nWORKAREA DSECT ,\n*\nSAVEAREA DS    18F                Register save area\n*\nPARMPACK DS    D                  PARM converted to packed area\nPARMDISP DS    CL10               PARM display-format area\nPARMCOMP DS    CL10               Area to check PARM for being numeric\nREXXRETD DS    CL11               Rexx return data work area\nTIME     DS    F                  Delay in hundredths/seconds in binary\n*\nWORKSIZE EQU   *-SAVEAREA\n*\n         IKJCPPL ,                TSO Command Processor Parameter List\n*\n* Rexx External Functions Parm List labels from TSO/E MACRO IRXEFPL\n* Old MACLIBs do not have Program Product TSO/E MACROs\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DSECT=YES for DSECT\n* If DSECT=YES\n* EFPL     DSECT ,\n* EFPLCOM  DS A     * Reserved\n* EFPLBARG DS A     * Reserved\n* EFPLEARG DS A     * Reserved\n* EFPLFB   DS A     * Reserved\n* EFPLARG  DS A     * Pointer to Arguments Table\n* EFPLEVAL DS A     * Pointer to address of EvalBlock\n*\n* Rexx Argument Table labels from TSO/E MACRO IRXARGTB\n* Old MACLIBs do not have Program Product TSO/E MACROs and\n* labels are too long for old assemblers like IFOX00,\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DECLARE=NO for DSECT\n* If DECLARE=NO\n* ARGTABLE_ENTRY DSECT ,                 REXX Argument Table Entry\n*          DS  0D                        Align on doubleword boundary\n* ARGTABLE_ARGSTRING_PTR    DS  A        Address of the argument string\n* ARGTABLE_ARGSTRING_LENGTH DS  F        Length of the argument string\n* ARGTABLE_NEXT             DS  0D       Next ARGTABLE entry\n*          DS  0D                        Align on doubleword boundary\n* ARGSTRING DSECT ,                      REXX Argument String\n* ARGTABLE_END DC  XL8'FFFFFFFFFFFFFFFF' End of ARGTABLE marker\n*\n* Rexx Evaluation Block labels from TSO/E MACRO IRXEVALB\n* Old MACLIBs do not have Program Product TSO/E MACROs and\n* labels are too long for old assemblers like IFOX00,\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DECLARE=NO for DSECT\n* If DECLARE=NO\n* EVALBLOCK DSECT ,              REXX Evaluation Block\n* EVALBLOCK_EVPAD1 DS  F         Reserved - set to binary zero\n* EVALBLOCK_EVSIZE DS  F         Size of EVALBLOCK in double words\n* EVALBLOCK_EVLEN  DS  F         Length of data\n* EVALBLOCK_EVPAD2 DS  F         Reserved - set to binary zero\n* EVALBLOCK_EVDATA DS  C         Result\n* Notes: EVALBLOCK_EVLEN is X'80000000' on input to indicate if\n* a new length is stored to indicate data returned.\n* EVALBLOCK_EVDATA is the first byte of the data but cannot\n* exceed EVALBLOCK_EVLEN\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//*\n//L.SYSLMOD  DD  DISP=SHR,DSN=????.LOAD????\n NAME DELAY\n//*\n//CHECKCC EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELAYOLD": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x10\\x11O\\x01\\x10\\x11O\\x13P\\x01g\\x01g\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-04-24T00:00:00", "modifydate": "2010-04-24T13:50:10", "lines": 359, "newlines": 359, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWD JOB (????????,????,1439,9999),DELAY-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//*\n//HLASMCL EXEC PROC=HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//  PARM.L=(TERM,LIST,RENT,REUS,REFR)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\nPASS     TITLE 'DELAY - - - Set an STIMER with user specified value'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program accepts the PARM in batch, TSO, or Rexx format,\n*  and delays the process for the requested number of seconds and\n*  hundredths of a second.  If tenths or hundredths of a second\n*  are needed, then PARM must contain a decimal point.\n*\n*     If called as a Rexx function, the actual wait time accepted\n*  will be the returned data.\n*\n*  Tur(n)key #3 location: SYS1.SETUP.ASM(DELAY)\n*\n*  Original DELAY program was a batch or called program only\n*  and only waited for seconds, not hundredths.\n*\n*  Updated 2010-04-24  To allow running as a TSO CP, REXX external\n*  function, or batch program.  Also allowed hundredths of a second\n*  to be specified.\n*\n*  //DELAY#1 EXEC PGM=DELAY,PARM=5      Wait five seconds\n*  //DELAY#2 EXEC PGM=DELAY,PARM=1.2    Wait one and one-fifth seconds\n*  //DELAY#3 EXEC PGM=DELAY,PARM='.01'  Minimum wait time\n*  //DELAY#4 EXEC PGM=DELAY,PARM=0      Will give minimum of .01\n*\n*  /* Rexx */\n* SAY DELAY(\"1.23\")      /* Will wait 1.23 seconds and then SAY 1.23 */\n* SAY DELAY(\"01.23456\")  /* Will wait 1.23 seconds and then SAY 1.23 */\n* CALL DELAY(\".2\")       /* Will wait for one-fifth of a second */\n* xxxx = DELAY(\"3\")      /* Will wait three seconds and SET xxxx = 3 */\n*\n*  READY\n* delay 1\n*  READY\n*\n*  Blame: somitcw@yahoo.com\n*\n* R13 = Register save area and work area\n* R12 = Base register\n* R11 = Input PARM list address\n* R10 = Address of input PARM seconds\n* R9  = Input PARM seconds length ( Should end up being 0 to 8 )\n* R8  = Address of input PARM hundreds of seconds\n* R7  = Input PARM hundreds of seconds length ( Should end up 0,1,or 2)\n* R6  = Address of Rexx return data if called as a Rexx function\n* R5  = Length of Rexx return data if called as a Rexx function\n* R4  = Rexx Evaluation Block if called as a Rexx function\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDELAY    CSECT ,\nDELAY    AMODE ANY                Addressing mode of ANY\nDELAY    RMODE ANY                Residency mode of ANY\n         SAVE  (14,12),,'DELAY.&SYSDATE..&SYSTIME'    Save Reg.s\n         LR    R12,R15            Load the program's base register\n         USING DELAY,R12          Give the assembler the base reg.\n         LR    R11,R1             Save the address of the PARM list\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(WORKSIZE,R1),0(R1)  Clear DSECT to binary zeroes\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING WORKAREA,R13       Tell assembler of save area base reg.\n         MVC   PARMDISP,ZEROES    Initialize PARM convert area\n         LTR   R11,R11            See if the PARM register is zero\n         BZ    PACK               No PARM, go default to .01 seconds\n         ICM   R1,B'1111',0(R11)  See if first word of PARM list zero\n         BZ    REXXIN             Is REXX function PARM, go process\n         CLI   2(R1),X'00'        See if TSO CP\n         BZ    TSOCPIN            Is TSO CP PARM format, go process\n         TM    0(R11),X'80'       See if a batch program PARM\n         BO    BATCHIN            Is MVS batch program PARM, go process\n         B     ERRPARM            PARM format not recognized, go abend\n*\n* REXX function arguments format\nREXXIN   DS    0H\n         L     R10,16(,R11)       Load address of argument addr&length\n         ICM   R9,B'1111',4(R10)  Load length of REXX argument\n         BNP   PACK               Not positive=no argument, go default\n         L     R10,0(,R10)        Load address of REXX argument\n         B     EATZEROS           Go to cleanup and format the argument\n*\n* TSO CP input PARM format\nTSOCPIN  DS    0H\n         SLR   R2,R2              Clear work register for ICM\n         ICM   R2,B'0011',2(R1)   Load the PARM displacement\n         LA    R2,4(,R2)          Add length of first word of CPPL\n         LR    R10,R1             Load address of TSO CP command block\n         AR    R10,R2             Add displacement to calc PARM address\n         LA    R10,0(,R10)        Load address of REXX argument\n         SLR   R9,R9              Prepare to get PARM length\n         ICM   R9,B'0011',0(R1)   Get CPPL length\n         SLR   R9,R2              Get PARM data length\n         B     EATZEROS           Go to cleanup and format the argument\n*\n* Batch input PARM format\nBATCHIN  DS    0H\n         LA    R10,2(,R1)         Load address of the PARM data\n         SLR   R9,R9              Prepare to get PARM length\n         ICM   R9,B'0011',0(R1)   Get PARM length\n*        B     EATZEROS           Go to cleanup and format the argument\n*\n* Drop leading zeroes\nEATZEROS DS    0H\n         LTR   R9,R9              See if PARM length is zero\n         BZ    PACK               PARM was all zeroes, go assume 0.01\n         CLI   0(R10),C'0'        See if first byte is zero\n         BNE   FINDDOT            Leading zeroes dropped, go find dec.\n         LA    R10,1(,R10)        Move past a leading zero\n         BCTR  R9,0               Drop PARM length by one\n         B     EATZEROS           Go back to check for more leading 0's\n*\n* Find decimal point\nFINDDOT  DS    0H\n         LTR   R9,R9              See if PARM length is zero bytes\n         BZ    PACK               PARM 0, go use default of .01 seconds\n         LA    R10,0(,R10)        Clean PARM data location address\n         LR    R1,R9              Get length of PARM\n         BCTR  R1,0               Get length of PARM for EX instruction\n         EX    R1,TRT             Find if a decimal point in PARM\n         BZ    MOVWHOLE           Is whole number, skip decimal process\n         BH    ENDDOT             PARM has ending decimal point\n         LA    R8,1(,R1)          Load location of decimal fraction\n         LA    R1,0(,R1)          Clean period location address\n         SLR   R1,R10             Find length of whole number\n         LR    R7,R9              Find length of decimal part of number\n         SLR   R7,R1              Find length of decimal part of number\n         BCTR  R7,0               Find length of decimal part of number\n         LR    R9,R1              Save length of whole number\n         MVC   PARMDISP+8(1),0(R8)  Move first byte of decimal to pack\n         BCTR  R7,0               Drop length of fraction bytes by one\n         LTR   R7,R7              See if a second byte\n         BZ    MOVWHOLE           No other byte to move, go move whole\n         MVC   PARMDISP+9(1),1(R8)  Move second byte of dec. to pack\n         B     MOVWHOLE           No more bytes to move, go do whole no\n*\nTRT      TRT   0(*-*,R10),DOTTABLE  Find if decimal point in PARM\n*\nENDDOT   DS    0H\n         BCTR  R9,0               Drop ending period from PARM\n*\nMOVWHOLE DS    0H\n* R10 is location of whole number part of the PARM\n* R9  is length of whole number part of the PARM\n         LTR   R9,R9              See if any whole number to move\n         BZ    PACK               No whole number, go pack fraction\n         CH    R9,H8              See if PARM whole no. over 8 bytes\n         BH    PARMLONG           If over 8 bytes, go abend\n         LA    R1,PARMDISP+8      Find where to move PARM to\n         SLR   R1,R9              Find where to move PARM whole number\n         LR    R2,R9              Load length of PARM whole number\n         BCTR  R2,0               Adjust PARM whole no. length for EX\n         EX    R2,MVCPARM         Copy PARM whole number for convert\n         B     PACK               Go pack and CVB the PARM and wait\n*\nMVCPARM  MVC   0(*-*,R1),0(R10)   Dummy copy for above EXecute\n*\nPACK     DS    0H\n         MVC   PARMCOMP,ZEROES    See if PARM is numeric\n         MVZ   PARMCOMP,PARMDISP  See if PARM is numeric\n         CLC   PARMCOMP,ZEROES    See if PARM is numeric\n         BNE   PARMINV            PARM not numeric, go abend\n         CLC   PARMDISP,TWOGIG    See if PARM greater than 21474836.47\n         BH    PARMLONG           PARM too great, go abend\n         PACK  PARMPACK,PARMDISP  Change display data to packed format\n         OI    PARMPACK+7,X'0F'   Insure a valid and positive sign\n         CVB   R1,PARMPACK        Change packed data to binary data\n         LTR   R1,R1              See of time of zero requested\n         BNZ   STORTIME           Not zero time, go store time\n         LA    R1,1               Set default of .01 seconds\n         MVI   PARMDISP+9,C'1'    Set default of .01 seconds\nSTORTIME DS    0H\n         ST    R1,TIME            Set time for STIMER to delay\n         ICM   R1,B'1111',0(R11)  See if first word of PARM list zero\n         BNZ   STIMER             Not REXX function PARM, go wait\n         L     R4,20(,R11)        Load REXX evaluation block address\n         L     R4,0(,R4)          Load REXX evaluation block address\n         CLI   7(R4),8            Insure REXX Eval.block 9 double words\n         BL    STIMER ? Abend ?   Eval. block too short, skip update\n         MVC   REXXRETD(8),PARMDISP  Copy whole number of seconds\n         MVI   REXXRETD+8,C'.'   Put decimal point for REXX return\n         MVC   REXXRETD+9(2),PARMDISP+8  Put decimal number for ret.\n         LA    R6,REXXRETD        Load address of max. data to return\n         LA    R5,11              Load maximum length to return\nEATLEAD0 DS    0H\n         CLI   0(R6),C'0'         See if a leading zero\n         BNE   NOWDOT             No more leading zeroes, go handle dot\n         LA    R6,1(,R6)          Bump to next REXX return data address\n         BCTR  R5,0               Drop length of REXX return data by 1\n         B     EATLEAD0           Go back to eat more leading zeroes\n*\nNOWDOT   DS    0H\n         CLI   REXXRETD+10,C'0'   See if trailing zero in hundredth pos\n         BNE   STORREXX           Not trailing, go store REXX ret. data\n         BCTR  R5,0               Drop length of REXX return data by 1\n         CLI   REXXRETD+9,C'0'    See if trailing zero in tenths pos.\n         BNE   STORREXX           Not trailing, go store REXX ret. data\n         BCTR  R5,0       zero    Drop length of REXX return data by 1\n         BCTR  R5,0       period  Drop length of REXX return data by 1\n*\nSTORREXX DS    0H\n         ST    R5,8(,R4)          Store return data length\n         BCTR  R5,0               Adjust length for following EX instr.\n         EX    R5,MVCREXX         Move REXX return data to REXX eval.\n*\nSTIMER   DS    0H\n         STIMER WAIT,BINTVL=TIME  Wait for requested number of seconds\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R1)         Restore the caller's save area addr.\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=0      Return to caller w/retcode of zero\n*\nMVCREXX  MVC   16(*-*,R4),0(R6)   Move REXX output data\n*\n         EJECT ,\nERRPARM  DS    0H\n         WTO   'DELAY - PARM not Batch, TSO-CP, or REXX, abending',    C\n               ROUTCDE=(1,11)\n         ABEND 1111               Abend, no dump\n*\nPARMLONG DS    0H\n         WTO   'DELAY - Abending, PARM too long, max is 21474836.47',  C\n               ROUTCDE=(1,11)\n         ABEND 1112               Abend, no dump\n*\nPARMINV  DS    0H\n         WTO   'DELAY - Abending because PARM is not numeric',         C\n               ROUTCDE=(1,11)\n         ABEND 1113               Abend, no dump\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Constants and literals\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nH8       DC    H'8'               Constant for comparing PARM length\n*\nTWOGIG   DC    CL10'2147483647'   To init PARM display area\n*\nZEROES   DC    CL10'0000000000'   Value to init&check PARM display area\n*\n         LTORG ,                  In case someone uses literals\nDOTTABLE DC    0D'0',XL256'00'    TRT table to find decimal points\n         ORG   DOTTABLE+C'.'      Overlay the period position\n         DC    CL1'.'             Overlay the period position\n         ORG   ,                  Overlay the period position\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs and register equates follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nWORKAREA DSECT ,\n*\nSAVEAREA DS    18F                Register save area\n*\nPARMPACK DS    D                  PARM converted to packed area\nPARMDISP DS    CL10               PARM display-format area\nPARMCOMP DS    CL10               Area to check PARM for being numeric\nREXXRETD DS    CL11               Rexx return data work area\nTIME     DS    F                  Delay in hundredths/seconds in binary\n*\nWORKSIZE EQU   *-SAVEAREA\n*\n         IKJCPPL ,                TSO Command Processor Parameter List\n*\n* Rexx External Functions Parm List labels from TSO/E MACRO IRXEFPL\n* Old MACLIBs do not have Program Product TSO/E MACROs\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DSECT=YES for DSECT\n* If DSECT=YES\n* EFPL     DSECT ,\n* EFPLCOM  DS A     * Reserved\n* EFPLBARG DS A     * Reserved\n* EFPLEARG DS A     * Reserved\n* EFPLFB   DS A     * Reserved\n* EFPLARG  DS A     * Pointer to Arguments Table\n* EFPLEVAL DS A     * Pointer to address of EvalBlock\n*\n* Rexx Argument Table labels from TSO/E MACRO IRXARGTB\n* Old MACLIBs do not have Program Product TSO/E MACROs and\n* labels are too long for old assemblers like IFOX00,\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DECLARE=NO for DSECT\n* If DECLARE=NO\n* ARGTABLE_ENTRY DSECT ,                 REXX Argument Table Entry\n*          DS  0D                        Align on doubleword boundary\n* ARGTABLE_ARGSTRING_PTR    DS  A        Address of the argument string\n* ARGTABLE_ARGSTRING_LENGTH DS  F        Length of the argument string\n* ARGTABLE_NEXT             DS  0D       Next ARGTABLE entry\n*          DS  0D                        Align on doubleword boundary\n* ARGSTRING DSECT ,                      REXX Argument String\n* ARGTABLE_END DC  XL8'FFFFFFFFFFFFFFFF' End of ARGTABLE marker\n*\n* Rexx Evaluation Block labels from TSO/E MACRO IRXEVALB\n* Old MACLIBs do not have Program Product TSO/E MACROs and\n* labels are too long for old assemblers like IFOX00,\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DECLARE=NO for DSECT\n* If DECLARE=NO\n* EVALBLOCK DSECT ,              REXX Evaluation Block\n* EVALBLOCK_EVPAD1 DS  F         Reserved - set to binary zero\n* EVALBLOCK_EVSIZE DS  F         Size of EVALBLOCK in double words\n* EVALBLOCK_EVLEN  DS  F         Length of data\n* EVALBLOCK_EVPAD2 DS  F         Reserved - set to binary zero\n* EVALBLOCK_EVDATA DS  C         Result\n* Notes: EVALBLOCK_EVLEN is X'80000000' on input to indicate if\n* a new length is stored to indicate data returned.\n* EVALBLOCK_EVDATA is the first byte of the data but cannot\n* exceed EVALBLOCK_EVLEN\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//*\n//L.SYSLMOD  DD  DISP=SHR,DSN=????.LOAD????\n NAME DELAY\n//*\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLEXESV7": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x07\\x00\\x8f\\x01\\x07\\x00\\x8f\"E\\x006\\x006\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-01-08T00:00:00", "modifydate": "2007-01-08T22:45:41", "lines": 54, "newlines": 54, "modlines": 0, "user": "SOMITCW"}, "text": "   Flex-ES V7 AWSTAPE needed options:\nallowmountccws                   ( allow P/390 auto mount CCWs )\nawscompressalldata         ( compress tape no matter what OS/390 says )\nawswritesegmentsize 65535  ( do not break blocks into chunks )\nnonewtape         ( causes Flex-ES to not create tapes automagically )\n\"awsnewtape\", \"nonewtape\", and neither are mutually exclusive.\n\n   Flex-ES V7 AWSTAPE unwanted options:\nallowdisconnects ( don't )   ( separates CE/DE if specified )\nautoloader n/a                   ( does not help or hurt )\nawscompressdata ( don't )  ( would let OS/390 turn IDRC on and off )\nawsnewtape               ( allows tapes to be created automagically,\n                           will be AWSTAPEs )\nmaxwritesize ( don't )   ( splits large tapes into multiple tapes\n                           while writting )\nnoidrc ( don't )         ( makes 3480 tape to claim that it\n                           does not support IDRC )\nnooldtape ( never )      ( always create a new tape.  weird. )\n\nfakecompress [ -? ] | { [ -o ] [ -s size ] inputtape outputtape }\n-o says don't write over existing output file.\n-s is chunk size from 1-64535 ( probably means 1-65535 )\nfakecompress -o -s 65535 C00123.aws ../C00c/C00123.aws\n\ncd /tapeC\nmv C00 /tapeA/\nmkdir C00\ncd /tapeA/C00\nfor i in C00*;do fakecompress -os 65535 $i /tapeC/C00/$i;done\n\nJohn McKown:\nYou must be in the UNIX/Linux side and logged onto a\nuser who has WRITE access to the files and subdirectory\nin which the FakeTape volumes.\nEnter the following commands:\n\n\"cd /directory/containing/the/faketape/files\nfor i in *;do fakecompress -o $i $i.compressed.aws;done\n\nThis will create a new file in the same directory,\nwith a prefix equal to the input file name and with\na suffix of \".compressed.aws\". Use any suffix you want.\nYou cannot do an \"in place\" compress from my reading.\n\nAnother possibility is to put the output file in a\nsecond, new, subdirectory with the old file names.\nYou'd do that something like:\n\ncd /directory/containing/the/faketape/files\nfor i in *;do fakecompress -o $i\n/directory/to/contain/the/compressed/awstapes/$i;done\n\n--\nJohn McKown\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEALPA00": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00C\\x01\\x08'o\\x01\\t4\\x7f V\\x00\\xaa\\x00\\xca\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-10-02T00:00:00", "modifydate": "2009-12-13T20:56:43", "lines": 170, "newlines": 202, "modlines": 0, "user": "SOMITCW"}, "text": "INCLUDE LIBRARY(????.LOAD????) MODULES(\n             IGGPRE00,      /* DISK VOLUME DFSMSDFP EXIT USING RACF  */\n             IGX00030)      /* IGXMSGEX FOR FLEX-ES TAPE MOUNTS      */\nINCLUDE LIBRARY(SYS1.CMDLIB) MODULES(\n             ALLOCATE,\n             ATTRIB,\n             ICQAMLD0,\n             ICQAMLF0,\n             ICQAMLI0,\n             ICQCAL00,\n             ICQCAL06,\n             IKJEFY05,\n             IKJEFY50,\n             IKJEGAT,\n             IKJEGCPY,\n             IKJEGDEB,\n             IKJEGEQU,\n             IKJEGGO,\n             IKJEGLSA,\n             IKJEGLST,\n             IKJEGPCH,\n             IKJEGTCB,\n             LISTBC,\n             PROFILE,\n             SEND,\n             SYNC,\n             SE,            /*   ALIAS OF SEND                       */\n /*          ACFPROF,            ALIAS OF PROFILE                    */\n             ALLOC,         /*   ALIAS OF ALLOCATE                   */\n             ATTR,          /*   ALIAS OF ATTRIB                     */\n             IKJEES73,      /*   ALIAS OF LISTBC                     */\n             IKJEFY04,      /*   ALIAS OF IKJEFY05                   */\n             IKJEFY06,      /*   ALIAS OF IKJEFY05                   */\n             IKJEGCAL,      /*   ALIAS OF IKJEGGO                    */\n             IKJEGDRP,      /*   ALIAS OF IKJEGEQU                   */\n             IKJEGRUN,      /*   ALIAS OF IKJEGGO                    */\n             IKJRBBCR,      /*   ALIAS OF SYNC                       */\n             LISTB,         /*   ALIAS OF LISTBC                     */\n             PR,            /*   ALIAS OF IKJEFY50                   */\n             PRINTDS,       /*   ALIAS OF IKJEFY50                   */\n             PROF)          /*   ALIAS OF PROFILE                    */\nINCLUDE LIBRARY(????.LE.SCEERUN) MODULES(\n             CEEBINIT,      /*  03C908'X                             */\n /*          CEEKDS,                                                 */\n /*          CEEMMS,                                                 */\n             CEEPLPKA,\n             IGZCEV5,       /*  002210'X                             */\n             IGZCMGEN,\n             IGZCMLT,\n             IGZCPAC,       /*  01B9D0'X                             */\n             IGZCPCO,       /*  013ED8'X                             */\n             IGZEINI,\n             IGZEPLF,\n             ILBOACS,\n             ILBOANE,\n             ILBOANF,\n             ILBOATB,\n             ILBOCHN,\n             ILBOCKP,\n             ILBOCMM,\n             ILBOCVB,\n             ILBODBG,\n             ILBODSP,\n             ILBODTE,\n             ILBOETB,\n             ILBOEXT,\n             ILBOFLW,\n             ILBOINS,\n             ILBOINT,\n             ILBOITB,\n             ILBOPRM,\n             ILBOQIO,\n             ILBOSCH,\n             ILBOSDB,\n             ILBOSGM,\n             ILBOSMG,       /*  000EC8'X                             */\n             ILBOSPA,\n             ILBOSRT,\n             ILBOSSN,\n             ILBOSTT,\n             ILBOUTB,\n             ILBOVMO,\n             ILBOWTB,\n             CEEEV005,      /*   ALIAS OF IGZCEV5                    */\n             IIGZMSGT,      /*   ALIAS OF IGZCMLT                    */\n             ILBOACS0,      /*   ALIAS OF ILBOACS                    */\n             ILBOACS1,      /*   ALIAS OF ILBOACS                    */\n             ILBOANE0,      /*   ALIAS OF ILBOANE                    */\n             ILBOANF0,      /*   ALIAS OF ILBOAFE                    */\n             ILBOATB0,      /*   ALIAS OF ILBOATB                    */\n             ILBOCHN0,      /*   ALIAS OF ILBOCHN                    */\n             ILBOCKP0,      /*   ALIAS OF ILBOCKP                    */\n             ILBOCKP1,      /*   ALIAS OF ILBOCKP                    */\n             ILBOCMM0,      /*   ALIAS OF ILBOCMM                    */\n             ILBOCVB0,      /*   ALIAS OF ILBOCVB                    */\n             ILBOCVB1,      /*   ALIAS OF ILBOCVB                    */\n             ILBODBG0,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG1,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG2,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG3,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG4,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG5,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG6,      /*   ALIAS OF ILBODBG                    */\n             ILBODBG7,      /*   ALIAS OF ILBODBG                    */\n             ILBODSP0,      /*   ALIAS OF ILBODSP                    */\n             ILBODSS0,      /*   ALIAS OF ILBODSP                    */\n             ILBODTE0,      /*   ALIAS OF ILBODTE                    */\n             ILBODTE1,      /*   ALIAS OF ILBODTE                    */\n             ILBODTE2,      /*   ALIAS OF ILBODTE                    */\n             ILBODTE3,      /*   ALIAS OF ILBODTE                    */\n             ILBODTE4,      /*   ALIAS OF ILBODTE                    */\n             ILBOETB0,      /*   ALIAS OF ILBOETB                    */\n             ILBOEXT0,      /*   ALIAS OF ILBOEXT                    */\n             ILBOEXT1,      /*   ALIAS OF ILBOEXT                    */\n             ILBOFLW0,      /*   ALIAS OF ILBOFLW                    */\n             ILBOFLW1,      /*   ALIAS OF ILBOFLW                    */\n             ILBOFLW2,      /*   ALIAS OF ILBOFLW                    */\n             ILBOINS0,      /*   ALIAS OF ILBOINS                    */\n             ILBOINT0,      /*   ALIAS OF ILBOINT                    */\n             ILBOITB0,      /*   ALIAS OF ILBOITB                    */\n             ILBOPRM0,      /*   ALIAS OF ILBOPRM                    */\n             ILBOQIO0,      /*   ALIAS OF ILBOQIO                    */\n             ILBOQIO1,      /*   ALIAS OF ILBOQIO                    */\n             ILBOSCH0,      /*   ALIAS OF ILBOSCH                    */\n             ILBOSDB0,      /*   ALIAS OF ILBOSDB                    */\n             ILBOSGM0,      /*   ALIAS OF ILBOSGM                    */\n             ILBOSGM1,      /*   ALIAS OF ILBOSGM                    */\n             ILBOSGM2,      /*   ALIAS OF ILBOSGM                    */\n             ILBOSGM3,      /*   ALIAS OF ILBOSGM                    */\n             ILBOSMG0,      /*   ALIAS OF ILBOSMG                    */\n             ILBOSPA0,      /*   ALIAS OF ILBOSPA                    */\n             ILBOSPA1,      /*   ALIAS OF ILBOSPA                    */\n             ILBOSPA2,      /*   ALIAS OF ILBOSPA                    */\n             ILBOSRT0,      /*   ALIAS OF ILBOSRT                    */\n             ILBOSSN0,      /*   ALIAS OF ILBOSSN                    */\n             ILBOSSN1,      /*   ALIAS OF ILBOSSN                    */\n             ILBOSTT0,      /*   ALIAS OF ILBOSTT                    */\n             ILBOSTT2,      /*   ALIAS OF ILBOSTT                    */\n             ILBOUTB0,      /*   ALIAS OF ILBOUTB                    */\n             ILBOVMO0,      /*   ALIAS OF ILBOVMO                    */\n             ILBOVMO1,      /*   ALIAS OF ILBOVMO                    */\n             ILBOWTB0)      /*   ALIAS OF ILBOWTB                    */\nINCLUDE LIBRARY(SYS1.LINKLIB) MODULES(\n             HEWLD,\n             IEWBLINK,\n             HEWL,          /*   ALIAS OF IEWBLINK                   */\n             HEWLDI,        /*   ALIAS OF HEWLD                      */\n             HEWLDRGO,      /*   ALIAS OF IEWBLINK                   */\n             HEWLH096,      /*   ALIAS OF IEWBLINK                   */\n             HEWLOAD,       /*   ALIAS OF IEWBLINK                   */\n             HEWLOADR,      /*   ALIAS OF IEWBLINK                   */\n             IEWBLDGO,      /*   ALIAS OF IEWBLINK                   */\n             IEWBLOAD,      /*   ALIAS OF IEWBLINK                   */\n             IEWBLODI,      /*   ALIAS OF IEWBLINK                   */\n             IEWL,          /*   ALIAS OF IEWBLINK                   */\n             IEWLDRGO,      /*   ALIAS OF IEWBLINK                   */\n             IEWLOAD,       /*   ALIAS OF IEWBLINK                   */\n             IEWLOADI,      /*   ALIAS OF IEWBLINK                   */\n             IEWLOADR,      /*   ALIAS OF IEWBLINK                   */\n             LINKEDIT,      /*   ALIAS OF IEWBLINK                   */\n             LOADER)        /*   ALIAS OF IEWBLINK                   */\nINCLUDE LIBRARY(????.IMS???.RESLIB)    MODULES(\n             IGC0020B,\n             DFSAFMD0)\n/*\n/* *  DO NOT ADD THESE, THEY CAUSE S906 ABENDS IN IMS MESSAGE REGIONS\n/* *\n/* *         ILBONTR,       /*    C88  COBOL-USED BY IMS             */\n/* *         ILBONTR0,      /*   1187  ALIAS OF COBOL-USED BY IMS    */\n/* *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEASVC00": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x11\\x00\\x97\\x15_\\x01\\t4\\x7f!9\\x00\\x0c\\x00+\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1997-06-04T00:00:00", "modifydate": "2009-12-13T21:39:11", "lines": 12, "newlines": 43, "modlines": 0, "user": "SOMITCW"}, "text": "  SVCPARM 252,REPLACE,TYPE(3),EPNAME(IGC0025B),APF(NO),NPRMPT(NO)\n                            /* 252 - SAS FRONT-END USER SVC          */\n  SVCPARM 230,REPLACE,TYPE(3),EPNAME(IGC0023{),APF(YES),NPRMPT(NO)\n                            /* 230 - TAPE AUTOMOUNTCCW ISSUER        */\n  SVCPARM 216,REPLACE,TYPE(3),EPNAME(DFHCSVC),APF(NO),NPRMPT(NO)\n                            /* 216 - CICS(CSVC)                      */\n  SVCPARM 215,REPLACE,TYPE(6),EPNAME(DFHHPSVC),APF(NO),NPRMPT(NO)\n                            /* 215 - CICS(HPSVC)                     */\n  SVCPARM 203,REPLACE,TYPE(2),EPNAME(IGC203),APF(NO),NPRMPT(NO)\n                            /* 203 - IMS ?.?                         */\n  SVCPARM 202,REPLACE,TYPE(4),EPNAME(IGC0020B),APF(NO),NPRMPT(NO)\n                            /* 202 - IMS ?.? ( DBRC )                */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEA404A": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00Q\\x01\\x01\\x19?\\x01\\t4\\x7f!\\x16\\x00l\\x00k\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2001-07-12T00:00:00", "modifydate": "2009-12-13T21:16:51", "lines": 108, "newlines": 107, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IEA404A-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEA404A  EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB    ,UNIT=SYSDA,VOL=SER=??????\n//         DD  DISP=SHR,DSN=SYS1.MODGEN    ,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'IEA404A - Clear console buffers if full'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: IEA404A\n*\n*   Author: I ain't saying.\n*\n*   Date-written: 2001-07-12\n*\n*   Change Log:\n*\n* xx-xx-xx xxxxxxx\n*  x.x.x.\n*\n*\n*   Remarks:\n*\n*    This MPF routine intercepts message IEA404A and issues\n*  operator command 'K Q,R=HC,L=1' whenever the message occurs.\n*  The control command will route all messages pending for console\n*  number 1 to go to hardcpy on disk and free the buffers.\n*  A potential problem is that tape mounts messages and WTOR\n*  messages may also be rerouted, so the operator could miss them.\n*  To activate this exit:\n*    link to a Link-List data set\n*    issue operator command: F LLA,REFRESH\n*    code the following line in member MPFLST00 of SYS1.PARMLIB:\n*    IEA404A,SUP(NO),USEREXIT(IEA404A)\n*    and issue operator command: SET MPF=00\n*\n*    SET MPF=NO will disable MPF if needed due to errors.\n*\n*   Sample message:\n*\n* *IEA404A SEVERE WTO BUFFER SHORTAGE - 100% FULL\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIEA404A  CSECT ,\nIEA404A  AMODE 31\nIEA404A  RMODE ANY\n         SAVE  (14,12),,IEA404A.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING IEA404A,R12        Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n*\n*        LA    R9,CTXTTMSG+8      Start hunt for data after msgid\n* Label CTXTTMSG has:\n* IEA404A SEVERE WTO BUFFER SHORTAGE - 100% FULL\n*\n         DROP  R10,R11            Don't need DSECT registers anymore\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  KCMD               Issue SVC 34 with cmd address in R1\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n         DROP  R12                Don't need base register anymore\n*\nCT       DC    CL2'CT'            Constant for compare\nKCMD     DC    AL2(40),AL2(0),CL36'CONTROL Q,R=HC,L=1 MPF EXIT IEA404A'\n*                                  123456789 123456789 123456789 12345\n*\n         LTORG ,                  In case someone adds literals\n*\n*  Following mapped by SYS1.MODGEN(IEZVX100) ???????\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id, if any\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         CVT   DSECT=YES    MVS's Communications Vector Table\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    E\nR3       EQU   3                      G\nR4       EQU   4                        I\nR5       EQU   5                          S\nR6       EQU   6                            T\nR7       EQU   7                              E\nR8       EQU   8                                R\nR9       EQU   9                  E\nR10      EQU   10                   Q\nR11      EQU   11                     U\nR12      EQU   12                       A\nR13      EQU   13                         T\nR14      EQU   14                           E\nR15      EQU   15                             S\n         END   ,\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE= ,\n//*            UNIT=SYSDA,VOL=SER=??????\n NAME IEA404A\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEC507D": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00F\\x00\\x96$\\x7f\\x01\\t4\\x7f!9\\x00\\xb8\\x00\\x99\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1996-09-03T00:00:00", "modifydate": "2009-12-13T21:39:46", "lines": 184, "newlines": 153, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),IEC507D-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEC507D  EXEC HLASMCL,PARM.C=(TERM,NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????  For the CVTUSER DSECT\nPASS     TITLE 'IEC507D - Reply ''M'' to date protect tape/disk WTOR'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: IEC507D ( original source was REPLYU )\n*\n*   Author: Murphy from CBT325 tape file 25 member AUTOWTOR\n*\n*   Date-written: 1985-12-17\n*\n*   Change Log:\n*\n* 2005-9-2 Moved DSECT XCVTUSER below the line for AMODE 24 programs.\n*  W.A.M.\n*\n* 1996-9-3 Added DSECT XCVTUSER so area pointed to by the CVTUSER\n*  W.A.M.  field in the CVT could be shared by MPF routine IOS000I.\n*\n* 1994-7-6 Added logic to save the volser from the first part of\n*  W.A.M.  message IEC507D to know if the second part should reply\n*          'M' to the message.\n*\n*   Remarks:\n*\n*        Automatically give reply of 'M' to message IEC507D, unless\n*   it's for a SCTHnn tape, then the operator must reply.\n*   The tricky thing is that message IEC507D is really two messages.\n*   The first message gives the tape volume serial number and the\n*   second message asks the operator to accept or not accept the\n*   data protected tape.  This program saves the tape volume serial\n*   number from the first message for use in the second message.\n*   CVTUSER area points to storage in the sqa to hold the volser.\n*   IEC507D,SUP(NO),USEREXIT(IEC507D) needs to go in MPF member in\n*   SYS1.PARMLIB, then use SET MPF=XX whatever member you set it to.\n*\n*   Sample messages:\n*\n*   *IEC507D E 0403,C00642,VNVRAD0D,ADRDSSU,RPT1FLES.G2801V00\n*   *19 IEC507D REPLY 'U'-USE OR 'M'-UNLOAD\n*    REPLY 19,M\n*    MPF exit 'REPLYM' replied 'M' to *19\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIEC507D  CSECT ,\nIEC507D  AMODE 31\nIEC507D  RMODE ANY\n         SAVE  (14,12),,IEC507D.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING IEC507D,R12        Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n         L     R9,16              Load the address of the CVT\n         ICM   R8,B'1111',CVTUSER-CVT(R9)  Address CVTUSER points to\n         BZ    NOCVTUSR           If CVTUSER zeroes, go get one\nGOTUSER  DS    0H\n         USING XCVTUSER,R8        Tell assembler about dsect\n         CLC   XCVTUEYE,CCVTUSER  See if the CVTUSER area is mine\n         BNE   BADUSER            If someone else has CVTUSER, go tell\n         CLI   CTXTRPID,C'0'      See if a reply id number is present\n         BNL   HAVEID             If reply id number, go to reply\n*                                 If no number, extract volser\n         LA    R9,CTXTTMSG+12     Start hunt for comma\n* Label CTXTTMSG has 'IEC507D E cuu,volser,jobname,stepname,dsname'\nLOOP     DS    0H\n         CLI   0(R9),C','         See if comma found\n         LA    R9,1(,R9)          Point to next byte of message\n         BNE   LOOP               If no comma yet, go try next byte\n         MVC   XCVTUVOL,0(R9)     Save the volser in CVTUSER area\n         B     RETURN             Go to exit, message first line okay\nHAVEID   DS    0H\n         CLC   XCVTUVOL(4),SCTH   See if last volser is a SCTHnn tape\n         BE    RETURN             SCTHnn tape, let operator reply\n         DROP  R8                 Drop pointer to area for CVTUSER\n         GETMAIN RU,LV=WORKLEN,LOC=BELOW,SP=229  Get MYDSECT storage\n         LR    R9,R1              Address of work area for SVC 34 & WTO\n         USING MYDSECT,R9         Addressability to my DSECT\n         MVC   CMD(15),REPLYCMD   Move model command to SVC 34 buffer\n         MVC   CMDNUM,CTXTRPID    Insert reply id number\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  CMD                Issue SVC 34 with cmd address in R1\n         MVC   WTOEXEC,WTOLIST    Prime Write-To-Operator message buff.\n         MVC   WTOEXEC+37(2),CTXTRPID  Put replyid in WTO message\n         WTO   MF=(E,WTOEXEC)     Send message to the operator\n         FREEMAIN RU,LV=WORKLEN,A=(R9),SP=229  Release MYDSECT area\n         DROP  R9,R10,R11\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nNOCVTUSR DS    0H\n   GETMAIN RU,LV=XCVTUSIZ,LOC=BELOW,SP=245 Get 48 byte CVTUSER SQA area\n*                                 CSA would make more sense than SQA,\n*                                 but someday I may need fixed storage\n* Warning:  The area pointed to by the CVTUSER field is used both by\n*           MPF programs IEC507D and IOS000I.\n         LR    R8,R1              Save address of storage gotten\n         USING XCVTUSER,R8        Tell assembler about dsect\n         XC    XCVTUSER(XCVTUSIZ),XCVTUSER  Clear CVTUSER pointed area\n         MVC   XCVTUEYE,CCVTUSER  Move 'CVTUSERn' to CVTUSER area\n         SLR   R7,R7              Clear a register for the 'CS' inst.\n* CS - If R7 and CVTUSER are equal, then R8 is stored in CVTUSER\n* CS - If R7 and CVTUSER are not equal, then CVTUSER is loaded to R7\n         CS    R7,R8,CVTUSER-CVT(R9)  Set CVTUSER address in CVT\n         BE    GOTUSER            Got CVTUSER now, go back to main line\n* Some other user put CVTUSER in CVT first, free the new one\n         FREEMAIN RU,LV=XCVTUSIZ,A=(R8),SP=245  Free extra SQA storage\n         LR    R8,R7              Use the first CVTUSER area address\n         B     GOTUSER            Got CVTUSER now, go back to main line\n         DROP  R8                 Drop pointer to area for CVTUSER\n*\nBADUSER  DS    0H\n         WTO   'MPF exit IEC507D found a bad CVTUSER area',ROUTCDE=11\n         B     RETURN             Exit the exit quick\n*\nCT       DC    CL2'CT'            Constant for compare\nSCTH     DC    CL4'SCTH'          Constant for compare\nCCVTUSER DC    CL7'CVTUSER',XL1'1' Constant to init and check CVTUSER\nREPLYCMD DC    AL2(15),AL2(0),CL11'REPLY XX,M '  Model reply command\nWTOLIST  WTO   'MPF exit IEC507D replied ''M'' to *XX',ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\n*\n         COPY  CVTUSER            User DSECT in ????.SORC????\n*\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'1'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n*                                 Minute, and Second, used by IOS000I\n*          DS    XL26             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\nMYDSECT  DSECT ,\nWTOEXEC  DS    CL(CNCLMSG)\nCMD      DS    XL2                Length of the command with header\n         DS    XL2                always binary zeroes\n         DS    CL6                Will be 'REPLY '\nCMDNUM   DS    CL2                Will be the reply id number\n         DS    CL3                Will be ',M '\nWORKLEN  EQU   *-MYDSECT          Length of my DSECT\n*\n*  Following mapped by SYS1.MODGEN(IEZVX100) ???????\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         CVT   DSECT=YES    MVS's Communications Vector Table\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    E\nR3       EQU   3                      G\nR4       EQU   4                        I\nR5       EQU   5                          S\nR6       EQU   6                            T\nR7       EQU   7                              E\nR8       EQU   8                                R\nR9       EQU   9                  E\nR10      EQU   10                   Q\nR11      EQU   11                     U\nR12      EQU   12                       A\nR13      EQU   13                         T\nR14      EQU   14                           E\nR15      EQU   15                             S\n         END   ,\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=\n NAME IEC507D\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEC512I": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x13\\x01\\x04\"/\\x01\\t4\\x7f!1\\x00\\xe9\\x00m\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2004-08-09T00:00:00", "modifydate": "2009-12-13T21:31:13", "lines": 233, "newlines": 109, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IEC512I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEC512I  EXEC HLASMCL,PARM.C=(TERM,NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS     TITLE 'IEC512I - MPF exit to cause tape mount loops to stop'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*       This program will stop a tape mount loop when a JOB\n*   calls for specific volume and that volume has a problem.\n*\n*       If the automatic tape mount routine mounted a bad tape,\n*   it will do it again and cause a loop of mounts and rejects.\n*\n*       This exit will store the volser of the tape volume\n* being called for that is in a loop in an area used but\n* the SVC mounting the tapes.  The SVC checks the area for\n* each tape mounted.  If there is a match, the SVC will\n* just ignore the request to mount the tape one time and\n* clear the vol ser from the area.\n*\n*   MPF exit name: IEC512I\n*\n*   Date-Written: 2004-08-09\n*   ReWritten:    2005-09-01\n*\n*   Blame: somitcw@yahoo.com\n*\n* Some messages related to IEC512I that is described in the code:\n*\n* *IEC501A M 0400,012345,SL,COMP,SOMITCWI,IEBGENER,NLTAPE\n* *IEC501A M 0415,012,SL,COMP,SHORT,IEBGENER,NLTAPE\n*\n* *IEF233A M 040A,PRIVAT,SL,VSTOR21,ADRDSSU,BKUP.VSTOR21.G0354V00\n*        |\n* *IEF233D M 041F,A00000,,MOUNT,41F, 241\n*          SYS04201.T075420.RA000.MOUNT.R0100203,\n*          OR RESPOND TO IEF455D MESSAGE\n* *14 IEF455D MOUNT A00000 ON 041F FOR MOUNT 41F OR REPLY 'NO'\n*\n*  IEC502E R 0405,B00154,SL,VPUBD19,ADRDSSU\n*  IEF234E K 0412,B00138,PVT,VSTOR1E,ADRDSSU\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         PRINT ON,GEN,DATA\nIEC512I  CSECT ,\nIEC512I  AMODE 31\nIEC512I  RMODE ANY\n         SAVE  (14,12),,IEC512I.&SYSDATE..&SYSTIME\n*        Saves registers and inserts programname, date, ane time\n         LR    R12,R15            Load address of entry point\n         USING IEC512I,R12        Give assembler the base register\n         L     R11,0(,R1)         Load the CTXT address\n         USING CTXT,R11           Addressing CTXT\n         CLC   0(2,R11),CT        Insure that we have a CTXT\n         BNE   RETURN             I'm lost, get out\n         GETMAIN RU,LV=WORKL,LOC=BELOW,SP=229\n         LR    R10,R1             Address of save and work area\n         USING MYDSECT,R10        Addressing the save and work area\n         L     R11,CTXTTXPJ       Load address of message text DSECT\n         USING CTXTATTR,R11       Message attributes\n         LA    R1,CTXTTMSG        Address of the message to find volser\n         DROP  R11                Don't need address of CTXTATTR now\n*\n* Label CTXTTMSG has:\n* 0123456789 123456789 123456789 123456789\n* IEC512I LBL ERR 0412,B00135,SL,B00123,SL,SOMITCWI,IEBGENER,NLTAPE\n* IEC512I LBL ERR 041D,XX,SL,012,SL,SHORT,IEBGENER,NLTAPE\n*  or\n* IEC512I LBL ERR 0400,      ,NL,B00123,SL,SOMITCWI,IEBGENER,NLTAPE\n* IEC512I LBL ERR 0415,      ,NL,012,SL,SHORT,IEBGENER,NLTAPE\n*  or\n* IEC512I LBL ERR 0400,      ,NL,PRIVAT,SL,SOMITCWI,IEBGENER,NLTAPE\n* IEC512I LBL ERR 0401,      ,NL,PRIVAT,SL,SHORT,IEBGENER,NLTAPE\n*    The first is a call for tape B00123, but B00135 was mounted.\n*       and a call for 012 and XX was mounted.\n*    The second is a call for tape B00123, but an NL tape was mounted.\n*       and a call for 012 and an NL tape was mounted\n*    The third is a call for an scratch tape.\n*    The first and second are permanent errors and would cause the\n*    system to loop with automatic tape mounts if the JOB wasn't\n*    cancelled.\n*    The last message will correct itself with the next tape mount.\n*\n         MVC   WTOEXEC,WTOLIST    Prime WTO PARM list with template\n* Find the called for volume serial number\nFINDVOL  DS    0H\n         TRT   0(30,R1),TABLE     Find first comma in message\n         BZ    LOST               No comma found, go issue msg and exit\n         TRT   1(8,R1),TABLE      Find second comma in message\n         BZ    LOST               No comma found, go issue msg and exit\n         TRT   1(8,R1),TABLE      Find third comma in message\n         BZ    LOST               No comma found, go issue msg and exit\n         MVC   VOLCALL,1(R1)      Move volume serial called for to WTO\n         CLC   VOLCALL,PRIVAT     See if a scratch tape request\n         BE    FREEMAIN           Error won't cause loop, go ignore\n*\n         L     R1,16              Load the address of the CVT\n         USING CVT,R1             Give assembler the CVT mapping\n         L     R1,CVTUSER         Load the address of the CVT user area\n         USING XCVTUSER,R1        Give assembler the CVTUSER mapping\n         CLC   XCVTUEYE,CVTUSER1  See if the CVTUSER area is valid\n         BNE   NOCVTUSR           Area not valid, can't stop mount loop\n         MVC   XCVTSKIP,VOLCALL   Send bad vol ser to skip next mount\n         LA    R1,WTOEXEC         Load address of WTO list\n         WTO   MF=(E,(1))         Issue tape skipped message\nFREEMAIN DS    0H\n         FREEMAIN RU,LV=WORKL,A=(R10),SP=229\n         DROP  R10                Save area gone, tell assembler\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller\n*\nNOCVTUSR DS    0H\n         WTO   'MPF IEC512I - No CVTUSER, can''t stop loop',ROUTCDE=11\n         B     FREEMAIN           Go exit without getting job done\n*\nLOST     DS    0H\n         WTO   'MPF IEC512I - Messages is short on commas',ROUTCDE=11\n         B     FREEMAIN           Go exit without getting job done\n*\n         DROP  R12                Don't need base register anymore\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nCT       DC    CL2'CT'            Constant for compare\n*\nPRIVAT   DC    CL6'PRIVAT'        Constant for compare\n*\n* The X'1' is the DSECT version number\nCVTUSER1 DC    CL7'CVTUSER',XL1'1'  Constant to check CVTUSER\nTAPEBIT1 DC    CL7'TAPEBIT',XL1'1'  Constant to check TAPEBIT\n*\nTABLE    DC    256X'0'            Table to find commas\n         ORG   TABLE+C','         Back up the location counter\n         DC    CL1','             Add comma to the comma search table\n         ORG   ,                  Return the location counter to normal\n*\n*               456789 12345678\nWTOLIST  WTO   'MPF IEC512I - xxxxxx mount will be skipped next time', C\n               ROUTCDE=11,MF=L\nWTOLEN   EQU   *-WTOLIST\n*\n         LTORG ,                  Put literal pool here\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nMYDSECT  DSECT ,\nWTOEXEC  DS    XL(WTOLEN)         WTO parameter list\nVOLCALL  EQU   WTOEXEC+18,6,C'C'  Vol ser called for\nWORKL    EQU   *-MYDSECT          Length of the DSECT\n*\n*        COPY  IEZVX100           Copy DSECT\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4          Pointer to major line text\nCTXTTXPN DS    CL4          Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2          Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         COPY  CVTUSER            Copy CVTUSER DSECT\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* XCVTSKIP DS    CL6              IEC512I tape vol ser to ignore\n*          DS    XL6              Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\n*\nTAPEBITS DSECT ,\n         COPY  TAPEBITS           Copy TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n*          DS    CL6              TAPESKIP moved to CVTUSER as XCVTSKIP\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              Displacement to return to zero\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* * TAPEBIT0 EQU   X'80'            First tape within a byte\n* * TAPEBIT1 EQU   X'40'            Second tape within a byte\n* * TAPEBIT2 EQU   X'20'            Third tape within a byte\n* * TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* * TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* * TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* * TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* * TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    e\nR3       EQU   3                      g\nR4       EQU   4                        i\nR5       EQU   5                          s\nR6       EQU   6                            t\nR7       EQU   7                              e\nR8       EQU   8                                r\nR9       EQU   9                  E\nR10      EQU   10                   q\nR11      EQU   11                     u\nR12      EQU   12                       a\nR13      EQU   13                         t\nR14      EQU   14                           e\nR15      EQU   15                             s\n         END   ,\n//L.SYSLMOD  DD  DISP=SHR,DSN=????.LOAD????,SPACE=\n NAME IEC512I\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEC534D": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x15\\x00\\x98\\x11\\x9f\\x01\\t4\\x7f!\\x17\\x00h\\x00\\xa7\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1998-04-29T00:00:00", "modifydate": "2009-12-13T21:17:15", "lines": 104, "newlines": 167, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),IEC534D-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEC534D  EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB   ,UNIT=SYSDA,VOL=SER=??????\n//         DD  DISP=SHR,DSN=SYS1.MODGEN   ,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'IEC534D - Reply ''M'' to unload wrong tape mounted'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: IEC534D ( originally was REPLYU )\n*\n*   Author: Murphy from CBT325 tape file 25 member AUTOWTOR\n*\n*   Re-written by: I ain't saying.\n*\n*   Date re-written:  4-29-98\n*\n*   Change Log:\n*\n* xx-xx-xx x\n*  x.x.x.  x\n*\n*   Remarks:\n*\n*        Automatically give reply of 'M' to message IEC534D.\n*   The tricky thing is that message IEC534D is really two messages.\n*   *IEC534D A 0180,ABC001,SL,JOB12345,JOBSTEP1.PROCSTEP\n*   *01 IEC534D REPLY 'U'-USE OR 'M'-UNLOAD\n*   The first message gives the tape volume serial number and the\n*   second message asks the operator to re-label and write over or\n*   not to re-label and not write over wrong vol ser tape.\n*   The first message is ignored.  'M' is replied to the second.\n*   IEC534D,SUP(NO),USEREXIT(IEC534D) goes in the MPFLSTxx member\n*   of SYS1.PARMLIB, then use SET MPF=XX for the member suffix.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIEC534D  CSECT ,\nIEC534D  AMODE 31\nIEC534D  RMODE ANY\n         LCLA  &N                 Declare arithmetic local variable\n&N       SETA  0                  Change from zero to zero\n.REGS    ANOP  ,\n         AIF   (&N GT 15).FINREGS Only define 16 registers\nR&N      EQU   &N                 A register equate\n&N       SETA  &N+1               Add one for mthe next register number\n         AGO   .REGS              Go back to generate the next equate\n.FINREGS ANOP  ,\n         SAVE  (14,12),,IEC534D.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING IEC534D,R12        Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n         CLI   CTXTRPID,C'0'      See if a reply id number is present\n         BL    RETURN             No reply id, go exit this exit\n         GETMAIN RU,LV=WORKLEN,LOC=BELOW,SP=229  Get MYDSECT storage\n         LR    R9,R1              Address of work area for SVC 34 & WTO\n         USING MYDSECT,R9         Addressability to my DSECT\n         MVC   CMD(15),REPLYCMD   Move model command to SVC 34 buffer\n         MVC   CMDNUM,CTXTRPID    Insert reply id number\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  CMD                Issue SVC 34 with cmd address in R1\n         MVC   WTOEXEC,WTOLIST    Prime Write-To-Operator message buff.\n         MVC   WTOEXEC+37(2),CTXTRPID  Put replyid in WTO message\n         WTO   MF=(E,WTOEXEC)     Send message to the operator\n         FREEMAIN RU,LV=WORKLEN,A=(R9),SP=229  Release MYDSECT area\n         DROP  R9,R10,R11\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nCT       DC    CL2'CT'            Constant for compare\nREPLYCMD DC    AL2(15),AL2(0),CL11'REPLY XX,M '  Model reply command\nWTOLIST  WTO   'MPF exit IEC534D replied ''M'' to *XX',ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\n*\nMYDSECT  DSECT ,\nCMD      DS    XL2                Length of the command with header\n         DS    XL2                always binary zeroes\n         DS    CL6                Will be 'REPLY '\nCMDNUM   DS    CL2                Will be the reply id number\n         DS    CL3                Will be ',M '\nWTOEXEC  DS    CL(CNCLMSG)\nWORKLEN  EQU   *-MYDSECT          Length of my DSECT\n*\n*  Following mapped by SYS1.MODGEN(IEZVX100) ???????\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         END   ,\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=   ,\n//*            UNIT=SYSDA,VOL=SER=??????\n NAME IEC534D\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEE366I": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00 \\x00\\x97\\x11\\x8f\\x01\\t4\\x7f!\\x18\\x00h\\x00g\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1997-04-28T00:00:00", "modifydate": "2009-12-13T21:18:20", "lines": 104, "newlines": 103, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IEE366I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEE366I  EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB   ,UNIT=SYSDA,VOL=SER=??????\n//         DD  DISP=SHR,DSN=SYS1.MODGEN   ,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'IEE366I - Start SMF DUMP if data is being buffered'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: IEE366I\n*\n*   Author: I ain't saying.\n*\n*   Date-written: 4-28-97\n*\n*   Change Log:\n*\n* xx-xx-xx xxxxxxx\n*  x.x.x.\n*\n*\n*   Remarks:\n*\n*        This MPF routine intercepts message IEE366I and issues\n*   operator command 'START R,Q=SMFDUMP' whenever the message occurs.\n*   To activate this exit:\n*       link to a Link-List data set\n*       issue operator command: F LLA,REFRESH\n*       code the following line in member MPFLST00 of SYS1.PARMLIB:\n*       IEE366I,SUP(NO),USEREXIT(IEE366I)\n*       and issue operator command: SET MPF=00\n*\n*       SET MPF=NO will disable MPF if needed due to errors.\n*\n*   Sample message:\n*\n* IEE366I NO SMF DATA SETS AVAILABLE--DATA BEING BUFFERED TIME=01:16:42\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIEE366I  CSECT ,\nIEE366I  AMODE 31\nIEE366I  RMODE ANY\n         SAVE  (14,12),,IEE366I.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING IEE366I,R12        Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n*\n*        LA    R9,CTXTTMSG+8      Start hunt for data after msgid\n* Label CTXTTMSG has:\n* IEE366I NO SMF DATA SETS AVAILABLE--DATA BEING BUFFERED TIME=01:16:42\n*\n         DROP  R10,R11            Don't need DSECT registers anymore\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  STARTCMD           Issue SVC 34 with cmd address in R1\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n         DROP  R12                Don't need base register anymore\n*\nCT       DC    CL2'CT'            Constant for compare\nSTARTCMD DC    AL2(40),AL2(0),CL36'START R,Q=SMFDUMP  MPF EXIT IEE366I'\n*                                  123456789 123456789 123456789 12345\n*\n         LTORG ,                  In case someone adds literals\n*\n*  Following mapped by SYS1.MODGEN(IEZVX100) ???????\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id, if any\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         CVT   DSECT=YES    MVS's Communications Vector Table\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    E\nR3       EQU   3                      G\nR4       EQU   4                        I\nR5       EQU   5                          S\nR6       EQU   6                            T\nR7       EQU   7                              E\nR8       EQU   8                                R\nR9       EQU   9                  E\nR10      EQU   10                   Q\nR11      EQU   11                     U\nR12      EQU   12                       A\nR13      EQU   13                         T\nR14      EQU   14                           E\nR15      EQU   15                             S\n         END   ,\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=  ,\n//*            UNIT=SYSDA,VOL=SER=??????\n NAME IEE366I\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEF099I": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x06\\x01\\x00%\\x9f\\x01\\t4\\x7f! \\x00\\xd4\\x00\\xd3\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2000-09-15T00:00:00", "modifydate": "2009-12-13T21:20:06", "lines": 212, "newlines": 211, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IEF099I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//* ./ ADD NAME=MPF$NTFY  01 01 93200 93227 120839 0174 0169 0001 T2JJ\n//* IBMUSERA JOB ACCT,'JAN JAEGER',NOTIFY=IBMUSER,COND=(0,NE)           NONUMBER\n//ASMA90   EXEC PGM=ASMA90,PARM='DECK,NOOBJ,XREF(SHORT)'                NONUMBER\n//SYSTERM  DD  SYSOUT=*                                                 NONUMBER\n//SYSPRINT DD  SYSOUT=*                                                 NONUMBER\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB                                 NONUMBER\n//         DD  DISP=SHR,DSN=SYS1.MODGEN                                 NONUMBER\n//         DD  DISP=SHR,DSN=SYS1.JES2.SHASMAC                           NONUMBER\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,10)                             NONUMBER\n//SYSPUNCH DD  DSN=&&PUNCH,DISP=(NEW,PASS),UNIT=SYSALLDA,SPACE=(CYL,10) NONUMBER\n TITLE 'MPF EXIT TO NOTIFY USER OF MESSAGES ISSUED BY BATCH JOB'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*       http://home-2.worldonline.nl/~jjaeger/\n*\n* Justification:\n*   USERS NEED TO BE NOTIFIED OF CERTAIN MESSAGES WHILE BATCH JOB IS\n*   STILL RUNNING (SUCH AS IEF099I JOB XXXXXXX WAITING FOR DATASETS).\n*   THIS MPF EXIT WILL SEND THE CONTENTS OF THE MESSAGE THRU THE JES\n*   NOTIFY FUNCTION TO THE USER IF A NOTIFY WAS SPECIFIED ON THE\n*   JOBCARD.\n*\n* FUNCTION:\n*   THIS MPF EXIT WILL CHECK THE PRESENCE OF A NOTIFY USERID/NODE\n*   ON THE BATCH JOB ISSUEING THE MESSAGE.  IF A NOTIFY USERID EXISTS\n*   THEN THIS EXIT WILL USE THE JES NOTIFY USER FUNCTION TO SEND THE\n*   MESSAGE ISSUED TO THE USER ON THE SPECIFIED NODE.\n*\n* LOGIC:\n*   OBTAIN A WORKAREA IN SP230\n*   FIND JES2 CONTROL BLOCKS THRU THE LIFE-OF-JOB SSIB\n*   DO ACRONYM AND VERSION CHECK ON THE JES2 SJB\n*   CHECK FOR NOTIFY USERID IN THE JES JCT\n*   INITIALIZE SSOB AND SSNU\n*   COPY MESSAGE ADDRESS AND LENGTH FROM CTXT TO SSNU\n*   CALL IEFJSREQ\n*   IF MESSAGE WAS SEND SUCCESSFULL THEN REQUEST MINOR LINES\n*   RELEASE WORKAREA\n*   RETURN TO CALLER\n*\n* REGISTER USAGE:\n*   R0    WORK\n*   R1    ENTRY PARAMETER + WORK\n*   R2    TCB\n*   R3    JSCB\n*   R4    SSIB\n*   R5    SJB\n*   R6    JCT\n*   R7-R9 NOT USED\n*   R10   CTXTATTR\n*   R11   CTXT\n*   R12   PROGRAM BASE\n*   R13   WORKAREA INCLUDING STANDARD OS SAVEAREA\n*   R14   RETURN ADDR + WORK\n*   R15   ENTRY POINT ADDRESS + WORK\n*\n* ATTRIBUTES:\n*   AMODE(31),RMODE(ANY),REFR,AC(0),OL\n*   THE OL (ONLY LOADABLE) ATTRIBUTE IS NOT REQUIRED BUT RECOMMENDED\n*   BECAUSE MPF EXITS ARE LOAD-ED INTO CSA AND SUBSEQUENTLY BRANCHED\n*   TO.  THEY ARE NEVER LINK-ED ATTACH-ED OR XCTL-ED TO.\n*\n* HISTORY:\n*   DATE       BY              COMMENTS\n*   28/02/93   JAN JAEGER      INITIAL VERSION\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nMPF$NTFY RSECT ,\nMPF$NTFY AMODE 31\nMPF$NTFY RMODE ANY\n         B     SKIPHDR-*(,R15)\n         DC    AL1(L'EYECATCH)\nEYECATCH DC    C'MPF$NTFY-J.JAEGER-&SYSDATE.-&SYSTIME.'\nSKIPHDR  DS    0H\n         BAKR  R14,0                   STACK REGISTERS\n         LR    R12,R15                 SET BASE REGISTER\n         USING MPF$NTFY,R12\n*\n         L     R11,0(,R1)              POINT TO PARAMETER LIST\n         USING CTXT,R11\n*\n         STORAGE OBTAIN,               OBTAIN WORKAREA                 X\n               LENGTH=WORKLEN,                                         X\n               SP=230\n*\n         MVC   4(4,R1),=CL4'F1SA'      INDICATE LINKAGE STACK USED\n         LR    R13,R1\n         USING WORKAREA,R13\n         USING SSOB,WORKSSOB           THIS IS A NICE FEATURE OF HLASM\n         USING PSA,R0                  THIS ALWAYS WORKS\n*\n         ICM   R2,B'1111',PSATOLD\n         BZ    ERREXIT                 NOT IN TCB MODE\n         USING TCB,R2\n         SLR   R3,R3                   TCBJSCBB IS A 24 BIT ADDRESS\n         ICM   R3,B'0111',TCBJSCBB     JSCB ADDRESS\n         BZ    ERREXIT                 NO JSCB FOUND\n         USING IEZJSCB,R3\n         ICM   R3,B'1111',JSCBACT      POINT TO ACTIVE JSCB\n         BZ    ERREXIT                 NO ACTIVE JSCB FOUND\n         ICM   R4,B'1111',JSCBSSIB     SSIB ADDRESS\n         BZ    ERREXIT                 NO LIFE-OF-JOB SSIB\n         USING SSIB,R4\n         ICM   R5,B'1111',SSIBSUSE     SJB ADDR\n         BZ    ERREXIT                 NO SJB FOUND\n*\n         USING SJB,R5\n         CLC   SJBID,=CL4'SJB'         CHECK ID OF SJB\n         BNE   ERREXIT\n         CLI   SJBVRSN,SJBCURVN        CHECK VERSION LEVEL\n         BNE   ERREXIT\n         ICM   R6,B'1111',SJBJCT       GET JCT ADDRESS\n         BZ    ERREXIT                 NO JCT PRESENT\n         USING JCT,R6\n*\n         TM    JCTNOTUS,X'BF'          CHECK PRESENCE OF NOTIFY USERID\n         BZ    EXIT                    NO NOTIFY USERID\n*\n         LA    R1,SSOB                 INITIALIZE SSOB POINTER\n         ST    R1,SSOBPTR\n         OI    SSOBPTR,X'80'           SET HIGH ORDER BIT ON\n         XC    WORKSSOB,WORKSSOB       CLEAR IEFSSREQ PARAMETER LIST\n*\n         MVC   SSOBID,=CL4'SSOB'       INITIALIZE HEADER\n         MVC   SSOBLEN,=AL2(SSOBHSIZ)\n         MVC   SSOBFUNC,=AL2(SSOBSSNU) NOTIFY USER FUNCTION\n         LA    R1,SSNUBGN              POINT TO SSNU SECTION\n         ST    R1,SSOBINDV             STORE IN SSOB\n         MVC   SSNUID,=CL4'SSNU'       INITIALIZE HEADER\n         MVC   SSNULEN,=AL2(SSNUSIZE)\n         MVI   SSNUVER,SSNUCVER\n         TM    JCTNNODE,X'BF'          CHECK PRESENCE OF NOTIFY NODE\n         BZ    NOJCTNOD                NO NODE PRESENT\n         MVC   SSNUNODE,JCTNNODE       NOTIFICATION NODE\nNOJCTNOD DS    0H\n         MVC   SSNUUSER,JCTNOTUS       NOTIFICATION USER\n*\n         ICM   R10,B'1111',CTXTTXPN    ADDRESS IF MINOR LINES\n         BNZ   ISMINOR\n         ICM   R10,B'1111',CTXTTXPJ    ADDRESS OF MAJOR LINES\n         BZ    ERREXIT                 NO MESSAGE AT ALL\nISMINOR  DS    0H\n         USING CTXTATTR,R10\n         ICM   R9,B'0011',CTXTTLEN     PICK UP LENGTH OF MESSAGE\n         BZ    ERREXIT                 NULL MESSAGE\n         LA    R8,CTXTTMSG             ADDRESS OF MESSAGE\n         STH   R9,SSNUMLEN             MESSAGE LENGTH\n         ST    R8,SSNUMSG              MESSAGE ADDRESS\n*\n         LA    R1,SSOBPTR\n         IEFSSREQ ,                    CALL IEFJSREQ FOR NU FUNCTION\n         LTR   R15,R15\n         BNZ   ERREXIT                 SUBSYSTEM INTERFACE ERROR\n         CLC   SSOBRETN,=AL4(SSNUOKB)  RETURNCODE WORSE THEN WARNING\n         BH    ERREXIT                 SUBSYSTEM FUNCTION ERROR\n         CLC   SSNUERCD,=AL2(SSNUMSGT) TRUNCATED IS STILL ACCEPTABLE\n         BH    ERREXIT                 NOTIFY USER ERROR\n*\n         OI    CTXTRFB1,CTXTRPML       REQUEST MINOR LINES FOR MLWTO\n*\nERREXIT  DS    0H                      ON ERROR SIMPLY EXIT\nEXIT     DS    0H\n         LR    R1,R13\n         STORAGE RELEASE,              RELEASE WORKAREA                X\n               LENGTH=WORKLEN,                                         X\n               SP=230,                                                 X\n               ADDR=(1)\n*\n         PR    ,                       RETURN TO CALLER\n*\n         LTORG ,                       PUT LITERALS AT END OF CSECT\n*\nWORKAREA DSECT ,\nSAVEAREA DS    18F                     SAVEAREA MUST BE FIRST\nSSOBPTR  DS    A                       POINTER TO SSOB FOR IEFSSREQ\nWORKSSOB DS    XL(SSNULEN8)            SSOB + SSNU\nWORKLEN  EQU   *-WORKAREA\n*\n         PUSH  PRINT\n         PRINT NOGEN\n         IEZVX100 ,                    MPF EXIT PARAMETER LIST\n         CVT   DSECT=YES               REQUIRED BY IEFSSREQ\n         IEFJESCT ,                    REQUIRED BY IEFSSREQ\n         IHAPSA ,                      POINTS TO TCB\n         IKJTCB ,                      POINTS TO JSCB\n         IEZJSCB ,                     POINTS TO SSIB\n         IEFJSSIB ,                    POINTS TO SJB\n         IEFSSOBH ,                    SSOB HEADER FOR IEFSSREQ\nSSOBGN   EQU   *                       NU IS NOT SUPPORTED BY IEFJSSOB\n         IAZSSNU ,                     NOTIFY USER SSOB EXTENSION\n         $SJB  ,                       POINTS TO JCT\n         $JCT  ,                       CONTAINS NOTIFY INFO FROM JES2\n         $HASPEQU ,                    REQUIRED BY $SJB\n         $BUFFER ,                     REQUIRED BY $JCT\n         $TQE  ,                       REQUIRED BY $JCT\n         IFGRPL ,                      REQUIRED BY $BUFFER\n         POP   PRINT\n*\n         END   MPF$NTFY,(JAN JAEGER,0101,95059)\n//IEWL     EXEC PGM=IEWL,                                               NONUMBER\n//          PARM='XREF,AMODE=31,RMODE=ANY,REFR,OL'                      NONUMBER\n//SYSPRINT DD  SYSOUT=*                                                 NONUMBER\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,10)                             NONUMBER\n//SYSLMOD  DD  DISP=SHR,DSN=????.LOAD????                               NONUMBER\n//SYSLIN   DD  DISP=(SHR,DELETE),DSN=&&PUNCH                            NONUMBER\n//         DD  *                                                        NONUMBER\n SETCODE AC(1)\n NAME IEF099I                                                           NONUMBER\n//* NAME MPF$NTFY(R)                                                    NONUMBER\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEF251I": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00A\\x01\\x07\\x01?\\x01\\t4\\x7f!X\\x00\\x9e\\x00\\x0e\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2007-01-13T00:00:00", "modifydate": "2009-12-13T21:58:41", "lines": 158, "newlines": 14, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IEF251I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEF251I  EXEC HLASMCL,PARM.C=(TERM,NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS     TITLE 'IEF251I - MPF exit to E-Mail device allocation failure'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*       When a JOB or started task fails due to device\n*   allocation, this exit will E-Mail a note.\n*\n*   MPF exit name: IEF251I\n*\n*   Date-Written: 2007-06-13\n*\n*   Blame: somitcw@yahoo.com\n*\n*   Dependencies:\n*   ????.PROCLIB(ERR251I)  for: S ERR251,JOB=????????\n*   ????.???????(ERR251I)  for: Rexx EXEC to issue XMITIP\n*   SYS1.PARMLIB(MPFLST??) for: MPF list to call exit\n*\n*  IEF251I jjobname {procstep} stepname - JOB CANCELLED (in SYSOUT)\n*  Explanation:  During device allocation for a job,\n*  one of the following occurred:\n*  o   The operator entered a CANCEL command.\n*  o   The operator replied CANCEL to message IEF238D.\n*  o   A subsystem requested cancellation in response\n*     to a request to allocate a subsystem data set.\n*\n*  IEF244I FRSDOWNL FRSDOWN STEPYY - UNABLE TO ALLOCATE 2 UNIT(S) 381\n*          AT LEAST 2 OFFLINE UNIT(S) NEEDED.\n*  IEF877E FRSDOWNL NEEDS 1 UNIT(S) 382\n*  FOR FRSDOWN STEPYY FOCSTACK\n*  FOR VOLUME SCRTCH-   1\n*  OFFLINE\n*  0100-013C 013E-0147 0210-022F\n*  :\n*  IEF878I END OF IEF877E FOR FRSDOWNL FRSDOWN STEPYY FOCSTACK\n*  REPLY 53,CANCEL\n*  MPF exit REPLYCAN Replied 'CANCEL' to IEF238D\n* *53 IEF238D FRSDOWNL - REPLY DEVICE NAME OR 'CANCEL'.\n*  IEE600I REPLY TO 53 IS;CANCEL\n*  IEF251I FRSDOWNL JOB CANCELLED\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         PRINT ON,GEN,DATA\nIEF251I  CSECT ,\nIEF251I  AMODE 31\nIEF251I  RMODE ANY\n         SAVE  (14,12),,IEF251I.&SYSDATE..&SYSTIME\n*        Saves registers and inserts program-name, date, and time\n         LR    R12,R15            Load address of entry point\n         USING IEF251I,R12        Give assembler the base register\n         L     R11,0(,R1)         Load the CTXT address\n         USING CTXT,R11           Addressing CTXT\n         CLC   0(2,R11),CT        Insure that we have a CTXT\n         BNE   RETURN             I'm lost, get out\n         GETMAIN RU,LV=WORKL,LOC=BELOW,SP=229\n         LR    R10,R1             Address of save and work area\n         USING MYDSECT,R10        Addressing the save and work area\n         L     R11,CTXTTXPJ       Load address of message text DSECT\n         USING CTXTATTR,R11       Message attributes\n*\n* Label CTXTTMSG in DSECT CTXTATTR has:\n* IEF251I SMFDUMPW JOB CANCELLED\n*\n         MVC   STARTCMD,STARTDUM  Prime MGCR PARM list with template\n         MVC   WTOLIST,WTOLDUM    Prime WTO PARM list with template\n         MVC   JOBNAME1,CTXTTMSG+8  Put JOB name in start command\n         MVC   JOBNAME2,CTXTTMSG+8  Put JOB name in WTO\n         DROP  R11                Don't need addr. of CTXTATTR anymore\n*\n         SLR   R0,R0              Clear MGCR authorization codes\n         LA    R1,STARTCMD        Load address of start command\n*        MGCR  (1)                Issue the start command\n         SVC   34                 Issue the start command\n         LA    R1,WTOLIST         Load address of WTO list\n*        WTO   MF=(E,(1))         Issue \"Issued: START\" WTO\n         SVC   35                 Issue \"Issued: START\" WTO\nFREEMAIN DS    0H\n         FREEMAIN RU,LV=WORKL,A=(R10),SP=229\n         DROP  R10                Save area gone, tell assembler\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12                Don't need base register anymore\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nCT       DC    CL2'CT'            Constant for compare\n* Start to E-Mail  01     23       456789 123456789 123456\nSTARTDUM DC    AL2(30),AL2(0),CL26'START ERR251I,JOB=???????? '\nSTARTLEN EQU   *-STARTDUM         Length of start command\n*\n         DS    0F                 Insure some alignment\n*               456789 123456789 123456789 123456789 123456789\nWTOLDUM  WTO   'MPF exit IEF251I - Issued: START ERR251I,JOB=????????',C\n               ROUTCDE=11,MF=L\nWTOLEN   EQU   *-WTOLDUM\n*\n         LTORG ,                  Put literal pool here\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nMYDSECT  DSECT ,\n         DS    0D                 Insure double word boundary\nSTARTCMD DS    CL(STARTLEN)       Place to put start command\nJOBNAME1 EQU   STARTCMD+22,8,C'C' Name of JOB that failed\n*\nWTOLIST  DS    XL(WTOLEN)         WTO parameter list\nJOBNAME2 EQU   WTOLIST+49,8,C'C'  Name of JOB that failed\nWORKL    EQU   *-MYDSECT          Length of the DSECT\n*\n*        COPY  IEZVX100           Copy DSECT\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4          Pointer to major line text\nCTXTTXPN DS    CL4          Pointer to minor line text\n*\n* Many other including:\n* CTXTJBNM DS    CL8  NAME OF JOB THAT ISSUED MESSAGE\n* CTXTSYSN DS    CL8  NAME OF SYSTEM ON WHICH WTO ORIGINATED\n*\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    e\nR3       EQU   3                      g\nR4       EQU   4                        i\nR5       EQU   5                          s\nR6       EQU   6                            t\nR7       EQU   7                              e\nR8       EQU   8                                r\nR9       EQU   9                  E\nR10      EQU   10                   q\nR11      EQU   11                     u\nR12      EQU   12                       a\nR13      EQU   13                         t\nR14      EQU   14                           e\nR15      EQU   15                             s\n         END   ,\n//L.SYSLMOD  DD  DSN=????.LOAD????,DISP=SHR,SPACE=\n NAME IEF251I\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEF450I": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x01\\x01\\x06\\x19\\x1f\\x01\\t4\\x7f!Y\\x00\\xc7\\x00\"\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2006-07-10T00:00:00", "modifydate": "2009-12-13T21:59:01", "lines": 199, "newlines": 34, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IEF450I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IEF450I  EXEC HLASMCL,PARM.C=(TERM,NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS     TITLE 'IEF450I - MPF exit to E-Mail JOB abends'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*       When a JOB abends during nightly or week-end production,\n*   this MPF exit will start a started-task to send E-Mail.\n*\n*   MPF exit name: IEF450I\n*\n*   Date-Written: 2007-06-15\n*\n*   Blame: somitcw@yahoo.com\n*\n*   Dependencies:\n*   ????.PROCLIB(ERR450I)  for: S ERR450I,M='JOBNAME message'\n*   ????.???????(ERR450I)  for: Rexx EXEC to issue XMITIP\n*   SYS1.PARMLIB(MPFLST??) for: MPF list to call exit\n*\n*  123456789 123456789 123456789 123456789 123456789 123456789 12345678\n* IEF450I SRRUNKPA SELECT RADSS - ABEND=S222 U0000 REASON=00000000\n*\n* If a JOB ( not TSU or STC ), Night or Week-end ( not week day )\n* s err450i,m='J01234 SRRUNKPA SELECT RADSS - ABEND=S222 U0000\n*    REASON=00000000'\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         PRINT ON,GEN,DATA\nIEF450I  CSECT ,\nIEF450I  AMODE 31\nIEF450I  RMODE ANY\n         SAVE  (14,12),,IEF450I.&SYSDATE..&SYSTIME\n*        Saves registers and inserts program-name, date, and time\n         LR    R12,R15            Load address of entry point\n         USING IEF450I,R12        Give assembler the base register\n         L     R11,PSAAOLD-PSA    Load ASCB current address\n         USING ASCB,R11           Addressing for ASCB\n         ICM   R11,B'1111',ASCBJBNI See if a JOB ( Not TSU,STC,other )\n         BZ    RETURN             Not a JOB, get out\n         L     R11,FLCCVT-PSA     Load Communication Vector Table addr\n         USING CVT,R11            Addressing for CVT\n         L     R11,CVTUSER        Load CVT user address\n         USING XCVTUSER,R11       Addressing for CVT user area\n         CLI   XCVTWHEN,C'D'      See if weekday daytime\n         BE    RETURN             Day time on week day, get out\n         L     R11,0(,R1)         Load the CTXT address\n         USING CTXT,R11           Addressing for CTXT\n         CLC   0(2,R11),CT        Insure that we have a CTXT\n         BNE   RETURN             I'm lost, get out\n         GETMAIN RU,LV=WORKL,LOC=BELOW,SP=229\n         LR    R10,R1             Address of save and work area\n         USING MYDSECT,R10        Addressing the save and work area\n         L     R11,CTXTTXPJ       Load address of message text DSECT\n         USING CTXTATTR,R11       Message attributes\n*\n* Label CTXTTMSG in DSECT CTXTATTR has:\n* IEF450I job-name procstep job-step - ABEND=S222 U0000 REASON=00000000\n*\n         MVC   STARTCMD,STARTDUM  Prime MGCR PARM list with template\n         MVC   WTOLIST,WTOLDUM    Prime WTO PARM list with template\n         MVC   JOBMSG1,CTXTTMSG+8 Put error message in start command\n         MVC   JOBMSG2,CTXTTMSG+8 Put error message in WTO\n         DROP  R11                Don't need addr. of CTXTATTR anymore\n*\n         SLR   R0,R0              Clear MGCR authorization codes\n         LA    R1,STARTCMD        Load address of start command\n*        MGCR  (1)                Issue the start command\n         SVC   34                 Issue the start command\n         LA    R1,WTOLIST         Load address of WTO list\n*        WTO   MF=(E,(1))         Issue \"Issued: START\" WTO\n         SVC   35                 Issue \"Issued: START\" WTO\nFREEMAIN DS    0H\n         FREEMAIN RU,LV=WORKL,A=(R10),SP=229\n         DROP  R10                Save area gone, tell assembler\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12                Don't need base register anymore\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nCT       DC    CL2'CT'            Constant for compare\n* Start to E-Mail\nSTARTDUM DC    AL2(83),AL2(0)     Start command\n         DC    CL45'START ERR450I,M=''job-name procstep job-step -'\n         DC    CL34' abend=s222 u0000 reason=00000000'''\nSTARTLEN EQU   *-STARTDUM         Length of start command\n*\n         DS    0F                 Insure some alignment        5\nWTOLDUM  WTO   'MPF exit IEF450I - issued: START ERR450I,M=''job-name p+\n               rocstep job-step - abend=s222 u0000 reason=00000000''', +\n               ROUTCDE=11,MF=L\nWTOLEN   EQU   *-WTOLDUM\n*\n         LTORG ,                  Put literal pool here\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nMYDSECT  DSECT ,\n         DS    0D                 Insure double word boundary\nSTARTCMD DS    CL(STARTLEN)       Place to put start command\nJOBMSG1  EQU   STARTCMD+21,61,C'C' Location for command error message\n*\nWTOLIST  DS    XL(WTOLEN)         WTO parameter list\nJOBMSG2  EQU   WTOLIST+48,61,C'C' Location for WTO error message\nWORKL    EQU   *-MYDSECT          Length of the DSECT\n*\n*        COPY  IEZVX100           Copy DSECT\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n*\n* Many other including:\n* CTXTJBNM DS    CL8  NAME OF JOB THAT ISSUED MESSAGE\n* CTXTSYSN DS    CL8  NAME OF SYSTEM ON WHICH WTO ORIGINATED\n*\nCTXTATTR DSECT ,\nCTXTTLEN DS    H                  Text length\nCTXTTLMX DS    H                  Maximum length of text\nCTXTTFLG DS    XL2                Message type flags\nCTXTTMSG DS    CL126\n*\n* Following DSECT name is PSA\n         IHAPSA DSECT=YES,LIST=YES  Prefixed Save Area\n* PSATOLD  DC    A                Pointer to the home (current) TCB\n* PSAAOLD  DC    A                Pointer to the home (current) ASCB\n*\n* Following DSECT name is CVT\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n* CVTUSER DC   A                  Points to XCVTUSER\n*\n* Following DSECT name is ASCB\n         IHAASCB DSECT=YES,LIST=YES  Address Space Control Block\n* ASCBJBNI DS    A -              Pointer to JOBname field for\n* *                               initiated programs or zero\n*\n* Following DSECT name is TCB\n*        IKJTCB DSECT=YES,LIST=YES  Task Control Block\n* TCBJSCB    DS    0A\n* TCBJSCBB   DS    AL3\n*\n* Following DSECT name is IEZJSCB\n*        IEZJSCB ,                JOB Step Control Block\n* JSCBSSIB   DS    A\n*\n* Following DSECT name is SSIB\n*        IEFJSSIB ,               Sub-System Indentification block\n* SSIBJBID DS    CL8              Job Identifier or Subsystem name\n*\n         COPY CVTUSER             Copy the CVTUSER area DSECT\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n* XCVTWHEN DS    CL1              D-N-W Day, Night, Week-end indicator\n*          DS    XL1              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* * TAPESKIP DS    CL6            TAPESKIP was old name for XCVTSKIP\n* XCVTSKIP DS    CL6              IEC512I tape vol ser to ignore\n*          DS    XL22             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    e\nR3       EQU   3                      g\nR4       EQU   4                        i\nR5       EQU   5                          s\nR6       EQU   6                            t\nR7       EQU   7                              e\nR8       EQU   8                                r\nR9       EQU   9                  E\nR10      EQU   10                   q\nR11      EQU   11                     u\nR12      EQU   12                       a\nR13      EQU   13                         t\nR14      EQU   14                           e\nR15      EQU   15                             s\n         END   ,\n//L.SYSLMOD  DD  DSN=????.LOAD????,DISP=SHR,SPACE=\n NAME IEF450I\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IGC00230": {"ttr": 2060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00C\\x01\\x12\\x00o\\x01\\x12\\x00o\\x10)\\x01L\\x01L\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2012-01-06T00:00:00", "modifydate": "2012-01-06T10:29:43", "lines": 332, "newlines": 332, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (xxxxxxxx,xxxx,1439,9999),'IGC0023{-SOMITCW',\n//             CLASS=x,MSGCLASS=x,\n//             NOTIFY=SOMITCW,\n//             PERFORM=xx,COND=(0,NE)\n//HLASMCL  EXEC PROC=HLASMCL,\n//             PARM.C='TERM,NODECK,LIST,OBJECT,RENT,XREF(FULL)',\n//             PARM.L=(LIST,REFR,REUS,RENT,XREF,NCAL)\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS     TITLE 'IGC0023{ - - - User SVC to issue P/390 tape mount CCW '\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Change log:\n*\n* 2011-12-16 Moved back one byte and expanded DDEBUCB and DEBUCB from\n*  W.A.M.    three bytes to four.  Changed the STCM DEBUCB to ST.\n*\n* 2006-06-07 Moved all tapes back to their standard scratch areas.\n*  W.A.M.    B***** tapes go to /tapeB\n*            A***** tapes go to /tapeA\n*            All others go to /tapeC\n*\n* 2006-02-25 Moved all \"B\" tapes except B00 to /TapeC\n*  W.A.M.\n*\n*   Note: As coded, /tapeC/C01/C01234.aws must match the format of\n* the Flex-ES tape pool and files for the mount to work correctly.\n*\n*   Note:  If real physical tape drives move from channel 5,\n* then the CLI for UCBCHAN should change.\n*\n*    This SVC accepts a tape volume serial number and\n* tape drive Unit Control Block pointed to by registers\n* zero and one and issues a CCW command code 4B to the\n* tape device with mount information ( tape file specs ).\n*\n*   Register zero will point to the volume serial number\n* to be mounted on the unit.\n*\n*   Register one will point to the Unit Control Block to\n* mount the tape on.\n*\n*    CCW issued to the tape device number will be something like:\n* CCW CCW X'4B',FILESPEC,X'20',21  Mount tape CCW\n* FILESPEC DC  CL21'/tapeC/C01/C01234.aws'  Tape file specification\n*\n*    If SYS1.PARMLIB(IEASVCxx) specifies APF(YES) then the\n* caller to this SVC must be APF or otherwise authorized.\n*\n*     This SVC must be linkedited into SYS1.LPALIB.\n* It must run as a type 3 or 4 SVC.\n* It must be defined in SYS1.PARMLIB(IEASVCxx) something like:\n* SVCPARM 230,REPLACE,TYPE(3),EPNAME(IGC0023{),APF(YES),NPRMPT(NO)\n*      /* 230 - Tape automountCCW issuer                           */\n*      /* 230 = SVC C'W'                                           */\n*      /* 227 = SVC C'T' might make more sense to some people.     */\n*\n*    Registers:\n*     R0  Volume serial address on entry.  Copied to R11.\n*     R1  UCB address on entry.  Copied to R12.\n*     R2  Not used.\n*     R3  Not used. CVT address.\n*     R4  Not used. TCB address.\n*     R5  Not used. SVRB address.\n*     R6  Base register.\n*     R7  Not used. ASCB base register.\n*     R8  Not used.\n*     R9  Work register.\n*     R10 To save R14 to return to caller.\n*     R11 Address of the tape volume serial to mount R0.\n*     R12 Address of the UCB from R1.\n*     R13 Save area for IOSINT?? and control blocks.\n*     R14 Return address on entry and return.  Copied to R10.\n*     R15 Return code of 0 on all returns.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n         PRINT ON,GEN,DATA\nIGC00230 CSECT ,\nIGC00230 AMODE 31                 Addressing mode above 16M line\nIGC00230 RMODE ANY                Allow loading anywhere in storage\n         USING *,R6               Give assembler the base register\n         B     START              Branch around core mark\n         DC    AL1(23),CL23'IGC0023{.&SYSDATE..&SYSTIME'  Coremark\n*\nSTART    DS    0H\n         LR    R10,R14            Save return address\n         LR    R11,R0             Save volume serial address\n         USING VOLDSECT,R11       Give the assembler the vol.ser.reg.\n         LR    R12,R1             Save UCB address\n         USING UCB,R12            Give assembler the UCB register\n         CLI   UCBCHAN,X'05'      See if a real tape drive\n         BE    NOFREE             Is channel 5, get out now\n         LA    R0,SAVESIZE        Load work area size for GETMAIN\n         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)  Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         LR    R13,R1             Put save areas in R13\n         USING SAVEAREA,R13       Give the assembler the save area reg.\n*\n*    Fill in DEB, DCB, IOB, and CCW fields\n         MVC   DEBVT(DEBLEN),DDEBVT   Copy DEB template\n         LA    R9,DCB             Load address of DCB\n         STCM  R9,B'0111',DEBDCB  Store DCB address in DEB\n         LA    R9,DEBVT           Load address of DEB Vector table\n         STCM  R9,B'0111',DEBIOVT Store vector table addr. in DEB\n         ST    R12,DEBUCB         Store UCB address in the DEB\n         MVC   DCB(DCBLEN),DDCB   Copy DEB template\n         LA    R9,DEB             Load address of DEB\n         STCM  R9,B'0111',DCBDEB  Store DEB address in DCB\n         MVC   IOB(DIOBLEN),DIOB  Copy IOB templates\n         LA    R9,ECB             Load address of Event Contr.Blk\n         STCM  R9,B'0111',IOBECB  Store ECB address in IOB\n         LA    R9,IOBCCW          Load addr.of Chan. Command Word\n         ST    R9,IOBCCWA         Store CCW address in IOB\n         LA    R9,DCB             Load address of Data Control Block\n         ST    R9,IOBDCB          Store DCB address in IOB\n         LA    R9,MOUNT           Load address of mount command\n         STCM  R9,B'0111',IOBCCW+1 Store mount command address\n         MVC   MOUNT,DMOUNT       Copy mount command template\n         MVC   MOUNT1,VOLSER      Complete file system name for mount\n         MVC   MOUNT3,VOLSER      Move in directory name for mount\n         MVC   MOUNT6,VOLSER      Move in vol ser for mount\n         CLI   VOLSER,C'A'        Should file system name be tapeA?\n         BE    VOLFIN             If tapeA, file system resolved\n         CLI   VOLSER,C'B'        Should file system name be tapeB?\n         BE    VOLFIN             If tapeB, file system resolved\n         MVI   MOUNT1,C'C'        Not tapeA or tapeB, set tapeC\n         DROP  R11                Don't need volume serial pointer now\nVOLFIN   DS 0H\n*\n* mount tape\n         XC    ECB,ECB            Clear left over garbage in ECB\n         EXCP  IOB                Issue automountccw\n*        WTO   'SVC 230 - EXCP for IOB done',ROUTCDE=11\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    NOWAIT             Already posted, weird, tape may be\n* offline or something else to cause OS/390 to not have outstanding\n* I/O to the tape drive which allowed the mount to complete.\n*\n* If using IOS MACROs in normal code, watch out for the save area use.\n* IOS MACROs overlay the caller's caller's R13 address.  Can be nasty.\n*        L     R1,4(,R13)         Save old R13 from IOS overlay\n         IOSINTRP UCB=(R12)       Interrupt old tape I/O for new\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    NOWAIT             Posted because IOSINTRP redrove I/O\n         WAIT  ECB=ECB            Wait for mount to complete\n*\nNOWAIT   DS    0H\n         LA    R0,SAVESIZE        Load work area size for FREEMAIN\n         FREEMAIN RU,LV=(0),A=(R13)  Free work area's storage\n         DROP  R13                Drop work area base register\nNOFREE   DS    0H                 If no GETMAIN, FREEMAIN bypassed\n         LR    R14,R10            Restore return address\n         SLR   R15,R15            Set the return code to zero\n         BR    R14                Return to caller\n         DROP  R6                 Drop base register\n         DROP  R12                Drop UCB using\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants and model control blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         DS    0D                Align to a double word\n*\nBINTABLE DC    XL64'0'            Translate display hex to real hex\n         ORG   BINTABLE+1        Set location counter to letters ABCDEF\n         DC    XL6'0A0B0C0D0E0F'  Constant for letters ABCDEF\n         ORG   ,                  Reset location counter\n         ORG   BINTABLE+48        Set location counter to digits 0-9\n         DC    XL10'00010203040506070809'  Set number values\n         ORG   ,                  Reset location counter\n*\n* APPEND   DC    X'0B0E'          Dummy I/O appendage routine BSM 0,R14\n*\n* DEB template\n         DS    0D                 Insure alignment\nDDEBVT   DS    0XL20              Data Extent Appendage Vector Table\n         DC    A(PSARET-PSA)  0   I/O appendage end-of-extent\n         DC    A(PSARET-PSA)  4   I/O appendage Start I/O\n         DC    A(PSARET-PSA)  8   I/O appendage Pgm.Contl.Intr.\n         DC    A(PSARET-PSA) 12   I/O appendage Channel end\n         DC    A(PSARET-PSA) 16   I/O appendage Abnormal end\nDDEBPREF DS    0XL16              DEB Prefix table\n         DC    3A(0)       20     Reserved?\n         DC    XL1'06'     32     Number of double-words in DEB ( 06 )\n         DC    XL1'00'     33     Unknown Access method type\n         DC    H'0'        34     Offset in DEB table for this DEB\nDDEB     DS    0XL36\n         DC    A(0)        36     Address of TCB for this DCB\n         DC    AL1(4)      40     4 bytes in Acc.Meth.Dependent section\n         DC    AL3(0)      41     Address of next DEB in chain\n         DC    X'C0000000' 44     DEBDISP new data set\n         DC    XL1'30'     48     DEBOPATB Data set positioning leave\n         DC    AL3(0)      49     Addr.of first IOB in purge chain\n         DC    A(0)        52     Pointer to related request\n         DC    A(0)        56     Address of locate parameter list\n         DC    XL1'0F'     60     Indicate a DEB\nDDEBDCB  DC    AL3(*-*)    61     Address of DCB or ACB\n         DC    AL1(2)      64     Half-words in DEB dev.dependent sect.\nDDEBIOVT DC    AL3(*-*)    65     Addr. I/O app. vector table DEBVT\nDDEBDEV  DS    0XL4               Device dependent secion\nDDEBUCB  DC    A(*-*)      68     Address of UCB\n         DC    F'0'        72     ?\n         DC    F'0'        76     ?\n         DC    F'0'        80     ?\nDEBLEN   EQU   *-DDEBVT    84     Length of the DEB\n*\n* DCB template\nDDCB     DS    0D\n         DC    10F'0'             40 byte unused for EXCP foundation\n         DC    H'0'               TIOT offset\n         DC    B'11010000'        MACRF byte 1\n* DCBMRECP EQU   DCBBIT0        EXECUTE CHANNEL PROGRAM (EXCP) ---\n* DCBMRFE  EQU   DCBBIT1        FOUNDATION EXTENSION IS PRESENT (EXCP)\n* DCBMRCI  EQU   DCBBIT3        COMMON INTERFACE (EXCP)\n         DC    B'00001000'        MACRF byte 2\n* DCBMR5WD EQU   DCBBIT4        FIVE-WORD DEVICE INTERFACE (EXCP)\n         DC    A(*-*)             Will be the address of the DEB\n         DC    X'10000000'        OFLGS last I/O operation was a write\n*        DC    X'00000000'        OFLGS last I/O operation was read\n         DC    5F'0'              5 word EXCP device interface\nDCBLEN   EQU   *-DDCB             Length of the DCB\n*\n* IOB templates\nDIOB     DS    0D                 IOB to mount a tape\n         DC    XL4'42000000'  0   Command Chaining and nonsequential\n* IOBCMDCH EQU   X'40' -   COMMAND CHAINING USED IN CHANNEL PROGRAM\n* IOBUNREL EQU   X'02' -   IOB UNRELATED FLAG (I.E., NONSEQUENTIAL)\n         DC    XL1'7F'        4   Addr. of expected I/O completion code\nDIOBECB  DC    AL3(*-*)       5   Address of the ECB\n         DC    D'0'           8   Channel Status Word\nDIOBCCWA DC    A(*-*)        16   Address of the Channel Command Words\nDIOBDCB  DC    A(*-*)        20   Address of the Data Control Block\n         DC    A(0)          24   IOB Restart\n         DC    XL4'00010000' 28   Flags and counters\n*   Don't know what the bit means.  DEBE had it, so why not use it?\n         DC    D'0'          32   Seek address MBBCCHHR ? ? ? ?\nDIOBCCW  CCW   X'4B',*-*,X'20',L'DMOUNT  Mount tape CCW\nDIOBLEN  EQU   *-DIOB             Size of IOB template\n*\nDMOUNT   DC    CL21'/tape?/???/??????.aws'  Mount command\nMOUNTLEN EQU   *-DMOUNT           Length of mount command\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nVOLDSECT DSECT ,\nVOLSER   DS    CL6                Tape volume serial from calling pgm.\n*\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nCLEARSIZ EQU   *-SAVEAREA\n*\nECB      DS    F                  Event Control Block for mount\nECBPOST  EQU   X'40'              Indicator that ECB was posted\n*\nDWORK    DS    D                  Double word work area\n*\n         DS    0D                 Align the following DEB\nDEBVT    DS    5F                 Five words DEB vector table\nDEBPREF  DS    XL16               DEB Prefix table\nDEB      DS    XL(DEBLEN)         Data Extent Block\nDEBDCB   EQU   DEBVT+61,3         Address of DCB or ACB\nDEBIOVT  EQU   DEBVT+65,3         Addr. I/O app. vector table DDEBVT\nDEBUCB   EQU   DEBVT+68,4         Address of UCB\n*\n         DS    0D                 Align the following DCB\nDCB      DS    XL(DCBLEN)         Tape DCB\nDCBDEB   EQU   DCB+45,3           DEB address in the DCB\n*\n         DS    0D                 Align IOB to double word boundary\nIOB      DS    XL(DIOBLEN)        Input and Output Block\nIOBCSW   EQU   IOB+8,8            Channel Status Word\nIOBECB   EQU   IOB+5,3            Address of Event Control Block\nIOBCCWA  EQU   IOB+16,4           Address of Channel Command Words\nIOBDCB   EQU   IOB+20,4           Address of Data Control Block\nIOBCCW   EQU   IOB+40,8           Tape mount CCW\n*\nMOUNT    DS    XL(MOUNTLEN)       Mount command '/tape?/???/??????.aws'\nMOUNT1   EQU   MOUNT+5,1          Last byte of file-system name\nMOUNT3   EQU   MOUNT+7,3          First three bytes of tape VolSer\nMOUNT6   EQU   MOUNT+11,6         Tape VolSer\n*\nSAVESIZE EQU   *-SAVEAREA\n*\nUCB      DSECT ,                  Provide DSECT statement for UCB\n         IEFUCBOB ,               Unit Control Block mapping\n*\n         DCBD  DSORG=PS,DEVD=DA   Data Control Block DSECT IHADCB\n*\nPSA      IHAPSA DSECT=YES         Prefix Storage Area\n*\nIOCSTUFF DSECT ,\n         IECDIOCM ,               I/O Communication area DSECT\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table for IOS\n*\nIGC00230 CSECT ,\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DISP=SHR,DSN=SYS1.LPALIB,SPACE=\n   NAME IGC0023{\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IGXMSGEX": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00D\\x01\\x06\\x19\\x8f\\x01\\t4\\x7f E\\x02\\x1e\\x01\\x9d\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2006-07-17T00:00:00", "modifydate": "2009-12-13T20:45:44", "lines": 542, "newlines": 413, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IGXMSGEX-SOMITCW,\n//         CLASS=?,MSGCLASS=?,\n//         COND=(4,LT),NOTIFY=SOMITCW\n//*\n//IEBCOPY EXEC PGM=IEBCOPY,PARM='SIZE=3072K'   ,COND=ONLY\n//SYSPRINT DD  SYSOUT=*\n COPY   OUTDD=O1,INDD=I1,LIST=YES\n SELECT MEMBER=IGX00030\n//I1       DD  DISP=SHR,DSN=SYS1.LPALIB\n//O1       DD  DISP=SHR,DSN=????.LOAD????\n//*\n//* For OS/390 2.4.0 with this JCL, you must MPLA\n//* ( or FLPA ) the change into the system.\n//*\n//* SYS1.PARMLIB(IEALPA00)\n//* INCLUDE LIBRARY(SYSx.LOADxxxx) MODULES(\n//*  IGX00030)  /* IGXMSGEX for Flex-ES tape mounts */\n//*\n//* Newer systems may have IGXMSGEX as a separate\n//* load module so member name might not be IGX00030 ?\n//*\n//REFRESH1 EXEC PGM=COMMAND,PARM='MODIFY LLA,REFRESH'\n//*\n//IGXMSGEX EXEC PROC=SMPE,PARM='CSI=SYS1VNEW.MVSSPV5.GLOBAL.CSI'\n//SMPMTS   DD  DISP=SHR,DSN=SYS1NEW.SMPMTS\n//SYSLIB   DD  DISP=SHR,DSN=SYS1NEW.SMPMTS\n//         DD  DISP=SHR,DSN=SYS1NEW.MACLIB\n//         DD  DISP=SHR,DSN=SYS1NEW.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\n//LPALIB   DD  DISP=SHR,DSN=????.LOAD????\n//* SMPLOG   DD  DSN=SYS1.SMPLOG,DISP=MOD\n//SMPPTFIN DD  *\n++ USERMOD(IGXMSGX) REWORK(1994315) .\n++ VER(Z038) FMID(HDZ11D0) PRE(UW73466) .\n++ SRC(IGXMSGEX) DISTLIB(AEDGSRC1) .\nPASS TITLE 'IGXMSGEX - - - Mount tapes displayed on tape drives'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program is exit SMS IGXMSGEX that gets control\n*  immediately before a message is displayed on a tape drive.\n*\n*    This exit will display to the console:\n* 1. The tape drive hardware address.\n* 2. The message that the tape drive will display.\n*\n*    This program will also issue SVC W ( SVC 230 ) to issue\n* a P/390 auto-mount-CCW ( CCW X'4B' ) to mount any requested\n* tapes on the requested tape drive.\n*\n*    If the mount request is for a scratch tape, this exit\n* will select a scratch tape to be mounted.\n*\n* Date written: 2005-08-30\n*\n* Blame: somitcw@Yahoo.com\n*\n*\n* Change log:\n*\n* 2008-07-05 Added display of control byte to message WAM000I\n*   W.A.M.   Old format was:\n*             WAM000I T 0405,KB00058 ,MB00504S\n*            New format is:\n*             WAM000I T 0405,F0,DA00048 ,MPRIVATS\n*             WAM000I T 0405,50,*IEC701 , A12345\n*             WAM000I T 041C,48,MPRIVATS,\n*             WAM000I T 0405,40, C00123 ,\n*             WAM000I T 0405,28,DC01234 ,\n*             WAM000I T 0405,28,KC01234 ,\n*             WAM000I T 0405,28,RC01234 ,\n*             WAM000I T 041C,20, A00484S,\n*             Above for unmount/mount, IEHINITT mount,\n*             Mount-blink, change data set, Dismount-blink,\n*             Keep-blink, Remove-blink, and tape accepted.\n*\n* 2007-09-12 Added skip for tape requested to recover from a\n*   W.A.M.   file protect message *IEC509A/DIEC509\n*            *IEC501A M 0405,B00504,SL,COMP,SOMITCWT,TAPEZERO\n*             WAM000I T 0405,KB00058 ,MB00504S\n*             WAM000I T 0405, B00504S,\n*            *IEC509A F 0405,B00504,SOMITCWT,TAPEZERO\n*             WAM000I T 0405,DIEC509 ,MB00504S\n*             WAM000I T 0405, B00504S,\n*            *IEC509A F 0405,B00504,SOMITCWT,TAPEZERO\n*             WAM000I T 0405,DIEC509 ,MB00504S\n*             WAM000I T 0405, B00504S,\n*            *IEC509A F 0405,B00504,SOMITCWT,TAPEZERO\n*\n* 2006-10-03 Change TAPEHIGH from increasing 1000 tapes at a time to\n*   W.A.M.   be a high water mark of the tape numbers used.\n*            Since there are 8 tapes to a byte, the pool will\n*            expand 8 tapes at a time unless the high water\n*            mark is set higher with program TAPERSET.\n*\n* 2006-07-17 Corrected and simplified logic used to search for\n*   W.A.M.   scratch tapes.\n*\n* 2005-10-04 Changed TAPESKIP ( in TAPEBITS ) to XCVTSKIP ( in\n*   W.A.M.   CVTUSER ).  Added use of R5 to map to CVTUSER.\n*\n* 2005-09-05 Added \"CLI UCBCHAN,X'05'\" so requests to real tape\n*   W.A.M.   drives do not have an automountCCW issued for them.\n*\n* 2005-08-30 Created the IGXMSGEX exit from IGXTRACE.\n*   W.A.M.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nIGXMSGEX CSECT ,\nIGXMSGEX AMODE 31\nIGXMSGEX RMODE ANY\n         PRINT ON,GEN,DATA        Need all information\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'IGXMSGEX.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING IGXMSGEX,R12       Give the assembler the new base\n         USING PLIST,R1           Give the assembler the PARM list reg.\n         LM    R2,R3,PLIST        Load UCB addr. & message text addr.\n         DROP  R1                 Finished with the parameter list\n         USING UCB,R2             Give assembler the UCB register\n         USING MSGTEXT,R3         Give assembler the message text reg.\n         GETMAIN RC,LV=SAVELEN    Get a save and work area\n         LTR   R15,R15            Insure that GETMAIN worked\n         BZ    CONTINUE           GETMAIN worked, go continue\n         WTO   'IGXMSGEX - GETMAIN failed, no tape mount',ROUTCDE=2\n         B     NOMOUNT            Bypass trying to mount tape\nCONTINUE DS    0H\n         XC    0(CLEARLEN,R1),0(R1)  Clear the save/work area\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13       Point the assembler to the save area\n         MVC   WTOLIST,DUMWTO     Copy WTO MF=L template to work area\n         UNPK  WTOLIST+14(5),UCBCHAN(3) Copy UCB hardware addr\n         TR    WTOLIST+14(4),TABLE-240 Translate address for display\n         MVI   WTOLIST+18,C','    Put a comma after the address\n         UNPK  WTOLIST+19(3),CONTROL(2)  Unpack control byte\n         TR    WTOLIST+19(2),TABLE-240 Translate X'CA'-'CF' to C'A'-'F'\n         MVI   WTOLIST+21,C','    Put a comma after the address\n         MVC   WTOLIST+22(8),MSG1 Copy first message display date\n         MVC   WTOLIST+31(8),MSG2 Copy second message display date\n         WTO   MF=(E,WTOLIST)     Issue the write to operator\n*\n         CLI   UCBCHAN,X'05'      See if a real tape drive\n         BE    EXIT               Is channel 5, get out now\n*\n*        OI    CONTROL,ACL        Just leave Auto.Cart.Loader bit on\n*                                 Don't need to turn it on again\n*                                 Don't turn it off either\n*\n         L     R5,16              Load the address of the CVT\n         USING CVT,R5             Give the assembler the CVT DSECT\n         L     R5,CVTUSER         Load the CVT user area address\n         USING XCVTUSER,R5        Give assembler the CVTUSER mapping\n         CLC   XCVTUEYE,CVTUSER1  See if eye-catcher matches\n         BNE   NOCVTUSR           No match so cannot locate XCVTSKIP\n         L     R11,XCVTTAPE       Load address\n         USING TAPEBITS,R11       Give assembler the TAPEBITS mapping\n         CLC   TAPEEYE,TAPEBIT1   See if eye-catcher matches\n         BNE   NOBITS             No match so cannot locate TAPEBITS\n* R5  now has the address of CVTUSER area\n* R11 now has the address of TAPEBITS\n         B     CHECKMSG          Go check messages to find tape request\n*\nNOCVTUSR DS    0H\n*        WTO  'IGXMSGEX - Could not find CVTUSER in memory',ROUTCDE=11\n         SLR   R5,R5              Cannot find XCVTUSER, clear pointer\n*\nNOBITS   DS    0H\n         SLR   R11,R11            Cannot find TAPEBITS, clear pointer\n*\nCHECKMSG DS    0H\n*\n* I haven't seen a call for \"SCRTCH\" for years and assume that normal\n* scratch requests are for \"PRIVAT\".  More specifically \"MPRIVATS\".\n* Calling for a tape without (TAPE,,DEFER) and no DSNAME and default\n* DISP of NEW,DELETE,DELETE can cause a \"SCRTCH\" mount.\n* In most cases, \"SCRTCH\" should be ignored because the program\n* does not need a scratch tape but will set a specific vol ser\n* before opening the tape.\n* This exit will attempt to mount a tape with a vol ser of \"SCRTCH\"\n* which will fail and the application program can do what it wants.\n* A better method might to check for \"SCRTCH\" and ignore the\n* mount request but put out a message to fix the JCL.\n* Another option is to treat a \"SCRTCH\" mount request like a \"PRIVAT\"\n* mount request and waste a scratch tape until TAPESYN2 runs.\n         CLC   MPRIVAT,MSG1       See if message1 is for a scratch tape\n         BE    FINDTAPE           Message 1 is for scratch, go find one\n         CLC   MPRIVAT,MSG2       See if message2 is for a scratch tape\n         BE    FINDTAPE           Message 2 is for scratch, go find one\n*\n         LA    R10,MSG1           Load address of first message\n         CLI   0(R10),C'M'        See if a call for a specific tape\n         BE    MOUNT              If mount, go mount\n         CLC   DIEC509,MSG1       See if msg1 is file protect remount\n         BE    EXIT               Message 1 is remount loop, skip mount\n         LA    R10,MSG2           Load address of second message\n         CLI   0(R10),C'M'        See if a call for a specific tape\n         BE    MOUNT              If mount, go mount\n*\n         CLC   IEC701,MSG1        See if an IEHINITT display\n         BNE   EXIT               No mount requested of any type\n* R10 still has the needed MSG2 address\n         B     MOUNT              Go to mount a tape\n*\n*\nFINDTAPE DS    0H\n         LTR   R11,R11            See if a valid TAPEBITS found\n         BNZ   FIND2              TAPEBITS found, can select scratch\n         WTO   'IGXMSGEX - Cannot find scratch tape volume',ROUTCDE=11\n         WTO   'IGXMSGEX - Did TAPESAVE start?',ROUTCDE=11\n         B     EXIT               No TAPEBITS, can not select scratch\nFIND2    DS    0H\n*\n* TAPEDISP is the last, current, or next byte to contain a zero bit\n* ( which will indicate a scratch tape ).\n*\n* TAPEHIGH indicates the high tape byte in use since TAPENEW or\n* TAPERSET has run.  It defines the upper soft limit of the tape\n* pool.\n*\n*    Following logic:\n* If TAPEDISP points to byte with bit available, use it\n* If TAPEDISP to TAPEHIGH points to byte with bit available, use\n* first tape within the range.\n* If no bits from TAPEDISP to TAPEHIGH, search from tape zero to end\n* of the tape bits ( 12,500 bytes, 100,000 bits ).\n* If first byte found is after TAPEHIGH, TAPEHIGH will be set to be\n* equal to the new high water mark.\n*\n         LA    R6,TAPES           Load addr.of beginning of tape bits\n         AH    R6,TAPEDISP        Find address of current displacement\n         CLI   0(R6),X'FF'        See if all bits are in use\n         BNE   BIT2TAPE           A tape available, go use it\n* Initial search for byte with zero bit in it\n         LH    R7,TAPEHIGH        Load displacement of high-water-mark\n         SH    R7,TAPEDISP        Find number of bytes to search\n         BNP   RETRY              End of TAPEHIGH, search from zero\n         LA    R6,1(,R6)          TAPEDISP byte already checked\n         LA    R8,0               Clear CLCL data register\n         LA    R9,255             Clear CLCL length/pad register\n         SLL   R9,24              Put pad in first bits and zero length\n         CLCL  R6,R8              Find a byte that is not X'FF'\n         BZ    RETRY              No non-full bytes were found\n* R6 has the address of a byte that has a bit that is zero ( scratch )\nBIT2TAPE DS    0H\n         LA    R7,TAPES           Load address of tapes\n         LR    R8,R6              Load new displacement address\n         SLR   R8,R7              Find relative displacement\n         STH   R8,TAPEDISP        Store new or current displacement\n         SLR   R9,R9              Clear work register\n         IC    R9,0(,R6)          Load the byte to find bit\n         IC    R9,BITTABLE(R9)    Find which bit is zero\n         CH    R9,H8              See if no zero bit in byte\n         BE    BITSTOLE           Some other mount stole the bit\n         SLR   R7,R7              Clear work register\n         IC    R7,BITS(R9)        Load the bit mask for TM and OI\n* Should serialize around EX for TM, BO, and EX for OI\n         EX    R7,TM              See if tape is still available\n         BO    BITSTOLE           Tape was stolen\n         EX    R7,OI              Turn the BIT on for tape found\n* Should serialize around EX for TM, BO, and EX for OI\n         OI    TAPEUPD,1          Mark TAPEBITS update to write to disk\n         SLL   R8,3               Multiply displacement by 8 bits/byte\n         ALR   R8,R9              Add tape within byte for tape number\n         CVD   R8,DWORK           Convert tape number to packed decimal\n         UNPK  VOLSER+1(5),DWORK+5(3)  Unpack the tape number\n         OI    VOLSER+5,X'F0'     Correct the sign\n         MVC   VOLSER(1),TAPECHAR Add first byte of tape number\n         LA    R0,VOLSER          Load address of VOLSER to be mounted\n         B     MOUNT4             Go mount the tape on the drive\nTM       TM    0(R6),0            See if tape still available\nOI       OI    0(R6),0            Mark scratch tape as in use tape\n*\nRETRY    DS    0H\n         WTO   'IGXMSGEX - Searching from tape zero',ROUTCDE=11\n         LA    R6,TAPES           Load address of TAPE bits\n         LH    R7,TAPEMAX         Load displacement of end of TAPEBITS\n         LA    R8,0               Clear CLCL data register\n         LA    R9,255             Clear CLCL length/pad register\n         SLL   R9,24              Put pad in first bits and zero length\n         CLCL  R6,R8              Find a byte that is not X'FF'\n         BZ    ALLUSED            No non-full bytes were found\n         LH    R7,TAPEHIGH        Load current soft pool limit displac.\n         LA    R7,TAPES(R7)       Load current soft pool limit address\n         CLR   R6,R7              See if soft limit must raise\n         BNH   BIT2TAPE           Within pool, convert bits to tape no.\n* Dead   LH    R10,TAPEHIGH       Load the old limit\n* Dead   LA    R10,125(,R10)      Bump high limit by 1000 tapes\n* Dead   STH   R10,TAPEHIGH       Save new high limit\n         LA    R7,TAPES           Load address of tapes\n         LR    R8,R6              Load new high water mark address\n         SLR   R8,R7              Find relative displacement\n         STH   R8,TAPEHIGH        Store new high water mark displ.\n         WTO   'IGXMSGEX - Tape pool high water mark raised',ROUTCDE=11\n         B     BIT2TAPE           Go back to convert bits to tape numbr\n*\nMOUNT    DS    0H\n         LTR   R5,R5              See if CVTUSER was found\n         BZ    MOUNT3             CVTUSER not found, go skip skip check\n*        BNZ   MOUNT2             CVTUSER found, go check XCVTSKIP\nMOUNT2   DS    0H\n         CLC   XCVTSKIP,1(R10)    See if tape has an IEC512I error\n         BE    SKIP               Tape has a problem, go skip mount\nMOUNT3   DS    0H\n         LA    R0,1(,R10)         Load address of the requested vol ser\nMOUNT4   DS    0H\n         LR    R1,R2              Load the UCB address\n         SVC   C'W'               Issue the autoloadCCW SVC\n         B     EXIT               Mission complete, go exit\n*\nALLUSED  DS    0H\n         WTO   'IGXMSGEX - All tapes used, need new tape pool',        C\n               ROUTCDE=11\n         B     EXIT\n*\nSKIP     DS    0H\n         XC    XCVTSKIP,XCVTSKIP  Clear tape to skip, already skipped\n         WTO   'IGXMSGEX - Tape is one to skip mount for',ROUTCDE=11\n         B     EXIT               Due to previous error, skip mount\n*\nBITSTOLE DS    0H\n         WTO   'IGXMSGEX - Byte found, but bit stolen',ROUTCDE=11\n         B     EXIT\n*\nEXIT     DS    0H\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN RC,LV=SAVELEN,A=(1)  Free work area's storage\nNOMOUNT  DS    0H\n         ICM   R15,B'1111',EDGMSGEX  Load the next routine address\n         BZ    RETURN             If no next routine, return to caller\n         LM    R0,R12,20(R13)     Restore caller's registers\n         BR    R15                Branch to next routine\nRETURN   DS    0H\n         RETURN (14,12),RC=0      Return to caller with return code 0\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants and model control blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0F                 Insure that WTO is aligned\nDUMWTO   WTO   'WAM000I T 0400,xx,xxxxxxxx,xxxxxxxx',ROUTCDE=11,MF=L\n*               456789 123456789 123456789 12345678\nWTOLEN   EQU   *-DUMWTO\n*\nMPRIVAT  DC    CL7'MPRIVAT'       Compare for scratch tape request\n*\nDIEC509  DC    CL7'DIEC509'       Compare for file-protect remount loop\n*\nIEC701   DC    CL7'*IEC701'       IEHINITT tape mount message\n*\nH8       DC    H'8'               Constant for compare\n*\nTAPEMAX  DC    H'12500'           Maximum TAPEBITS TAPES displacement\n*\n* ANOMSGEX DC    V(ANOMSGEX)        ? ? ? ?\nEDGMSGEX DC    V(EDGMSGEX)        Next routine ( DFSMSrmm MSG exit )\n*\n         DS    0D                 Why not align?\n*\nCVTUSER1 DC    CL7'CVTUSER',X'01' Compare for CVT user area found\nTAPEBIT1 DC    CL7'TAPEBIT',X'01' Compare for TAPEBITS area found\n*\nTABLE    DC    CL16'0123456789ABCDEF'  Packed-unsigned to display\n*\nBITTABLE DC    128X'00'           Find bit in byte\n         DC     64X'01'           Find bit in byte\n         DC     32X'02'           Find bit in byte\n         DC     16X'03'           Find bit in byte\n         DC      8X'04'           Find bit in byte\n         DC      4X'05'           Find bit in byte\n         DC      2X'06'           Find bit in byte\n         DC      1X'07'           Find bit in byte\n         DC      1X'08'           No bits in byte\n*\nBITS     DC    XL8'8040201008040201'  Bit to set on\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\nSAVEAREA DSECT ,\n         DS    9D                 Register save area, not used\n*\n*\nCLEARLEN EQU   *-SAVEAREA\n*\n*\nDWORK    DS    D                  Double word work area\n*\nWTOLIST  DS    XL(WTOLEN)         Write To Operator parameter list\n*\nVOLSER   DS    CL6                Volume serial to pass to SVC 230\n*\nSAVELEN  EQU   *-SAVEAREA         Length of SAVEAREA\n*\n*\n*  Parameter list pointed to be register 1\nPLIST    DSECT ,\nUCBA     DS    A                  UCB address\nMSGTEXTA DS    A                  Message text address\n*\n*\n*  Message text structure\nMSGTEXT  DSECT ,\nCONTROL  DS    CL1\nACL      EQU   X'01'              ACL request bit\nMSG1     DS    CL8                first message\nMSG2     DS    CL8                second message\n*\n*  Control byte?\n*\n* Bits 0 - 2 New Message Overlay:\n*\n* (*) When lit the messages in bytes 1-8 and 9-16 are\n* overlayed with a drive message when the drive next\n* starts tape motion\n*\n* (*) Bit 1 overlays the messages in bytes 1-8 and 9-16\n* with a drive message only when the tape cartridge is\n* physically removed from the drive.\n*\n* (*) Bit 2 overlays the messages in bytes 1-8 and 9-16\n* with a drive message only when the drive becomes ready.\n*\n* (*) Bits 0, 1, 2 displays the messages in bytes 1-8 and\n* 9-16 until a tape cartridge has been physically removed\n* from the drive. Then, display only the message in bytes\n* 9-16 until the drive becomes ready.\n*\n*\n* FCB_FS is high order three bits ( 0-2 )\n* FCB_FS_RESET_DISPLAY: // 0x80\n* FCB_FS_MOUNT:       // 0x40\n* FCB_FS_UNMOUNT:     // 0x20\n* FCB_FS_NOP:         // 0x60\n* FCB_FS_UMOUNTMOUNT: // 0xE0\n* FCB_AM X'10' Alternate ( when set and mount and/or\n*  dismount, two messages display )\n* FCB_AM X'10' Alternate ( when set, next two bits ignored )\n* FCB_BM X'08' Blinking\n* FCB_M2 X'04' Message 2 ( may mean only message #2 to display? )\n* FCB_AL X'01' AutoLoader\n*\n* \"When bit 7 (FCB_AL) is active and bits 0-2 (FCB_FS) specify\n*         a Mount Message, then only the first eight characters of the\n*         message are displayed and bits 3-5 (FCB_AM, FCB_BM, FCB_M2)\n*         are ignored.\"\n* \"When bit 7 (FCB_AL) is active and bits 0-2 (FCB_FS) specify\n*         a Demount/Mount message, then only the last eight characters\n*         of the message are displayed. Bits 3-5 (FCB_AM, FCB_BM,\n*         FCB_M2 are ignored.\"\n* \"When bit 3 (FCB_AM) is set to 1, then bits 4 (FCB_BM) and 5\n*         (FCB_M2) are ignored.\"\n*\n         COPY  CVTUSER\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* XCVTSKIP DS    XL6              IEC512I tape vol ser to ignore\n*          DS    XL6              Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\n*\nTAPEBITS DSECT ,\n         COPY  TAPEBITS\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n*          DS    CL6              TAPESKIP moved to CVTUSER as XCVTSKIP\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              High-water-mark and soft pool limit\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* * TAPEBIT0 EQU   X'80'            First tape within a byte\n* * TAPEBIT1 EQU   X'40'            Second tape within a byte\n* * TAPEBIT2 EQU   X'20'            Third tape within a byte\n* * TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* * TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* * TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* * TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* * TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\n*\nUCB      DSECT ,                  provide DSECT statement for UCB\n         IEFUCBOB ,               Unit Control Block mapping\n*\n*\nIGXMSGEX CSECT ,                  End the DSECTs\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//SYSIN  DD *\n SET BOUNDARY(GLOBAL).\n  REJECT SELECT(IGXMSGX) BYPASS(APPLYCHECK).\n  RESETRC.\n  RECEIVE SYSMOD SELECT(IGXMSGX).\n SET BOUNDARY(TARGET).\n  APPLY SELECT(IGXMSGX) ASSEM REDO.\n//*\n//REFRESH2 EXEC PGM=COMMAND,PARM='MODIFY LLA,REFRESH'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOS000I": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00Q\\x00\\x96$\\x7f\\x01\\t4\\x7f!@\\x00\\xae\\x00\\xa8\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1996-09-03T00:00:00", "modifydate": "2009-12-13T21:40:51", "lines": 174, "newlines": 168, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999,9999),IOS000I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IOS000I  EXEC HLASMCL,PARM.C=(TERM,NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????     for CVTUSER DSECT\nPASS     TITLE 'IOS000I - Tell operator if there disk errors'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: IOS000I\n*\n*   Date-written: 1996-9-3\n*\n*   Blame: somitcw@yahoo.com\n*\n*   Change Log:\n*\n* 2005-9-2 Moved CVTUSER below the line for other programs ( TAPESAVE )\n*  W.A.M.\n*\n*\n*   Remarks:\n*\n*        This MPF routine checks message IOS000I to see if it is for\n*   disk error.  A message is issued for the first disk error to occur\n*   in each hour.  The time the message is issued is stored in an area\n*   pointed to by the CVTUSER field in the CVT.  The MVS ANCHOR\n*   facility would be the modern way to save the time of the error,\n*   but this was copied from old code and saved research.\n*   To activate this exit, code the following line in member MPFLST00\n*   of SYS1.PARMLIB:\n*   IOS000I,SUP(NO),USEREXIT(IOS000I)\n*   and issue operator command: SET MPF=00\n*   SET MPF=NO will disable MPF if needed due to errors.\n*\n*   Note: This routine depends on disk being on channel 01.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIOS000I  CSECT ,\nIOS000I  AMODE 31\nIOS000I  RMODE ANY\n         SAVE  (14,12),,IOS000I.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING IOS000I,R12        Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n*                                 If no number, extract volser\n         LA    R9,CTXTTMSG+8      Start hunt for a number after msgid\n* Label CTXTTMSG has:\n* 'IOS000I 01FA,02,DCK,9E,0200,,000A0004,WORK21,IMSIMAGE,' another line\n* 'IOS000I ccuu,pp,err,cc,ssss,,cccchhhh,volser,jobname,sense'\n* ccuu=chan,cntl.unit,unit\n* pp=path\n* err=error. i.e. DCK,IOE,EQC,BUS,CCC, - - -\n* ccuu=chan,cntl.unit,unit\n* ssss=status\n* cccchhhh=cylinder and head\n* volser=disk or tape volume serial number\n* jobname=MVS JOB name\n* sense=sense code\nLOOP     DS    0H\n         CLI   0(R9),C'0'         See if channel starts with zero\n         LA    R9,1(,R9)          Bump message pointer by one byte\n         BL    LOOP               If not numeric, go try next byte\n         BH    RETURN             If higher than zero, get out\n         CLI   0(R9),C'8'         See if channel 8 ( i.e. X'08' )\n         BE    GOTDISK            New disk are on channel 8, go process\n         CLI   0(R9),C'1'         See if channel 1 ( i.e. X'01' )\n         BNE   RETURN             Go to exit, not new or old disks\nGOTDISK  DS    0H\n         TIME  DEC                Get the date and time in regs 1 and 0\n         XR    R0,R1              Reverse registers zero and one\n         XR    R1,R0              Reverse registers zero and one\n         XR    R0,R1              Reverse registers zero and one\n* Now R0=0CYYDDDF R1=HHMMSSTH     Century,yr,day,hr,min,sec,1/10,1/100\n         SRL   R0,4               Drop the packed decimal sign X'F'\n         SLDL  R0,8               Move hours to register zero\n* Now R0=CYYDDDHH R1=MMSSTH00\n         L     R9,16              Load the address of the CVT\n         ICM   R8,B'1111',CVTUSER-CVT(R9)  Address CVTUSER points to\n         BZ    NOCVTUSR           If CVTUSER zeroes, go get one\nGOTCVTU  DS    0H\n         USING XCVTUSER,R8        Tell assembler about dsect\n         CLC   XCVTUEYE,CCVTUSER  See if the CVTUSER area is mine\n         BNE   BADUSER            If someone else has CVTUSER, go tell\n         CL    R0,XCVTUTIM        See if oper. already notified this hr\n         BE    RETURN             Aready notified this hour, ignore\n         ST    R0,XCVTUTIM        Save time that oper. will be notified\n         STCM  R1,B'1100',XCVTUTIM+4   time that oper. will be notified\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  STARTCMD           Issue SVC 34 with cmd address in R1\n         DROP  R8,R10,R11\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nNOCVTUSR DS    0H\n   GETMAIN RU,LV=XCVTUSIZ,LOC=BELOW,SP=245 Get 48 byte CVTUSER SQA area\n*                                 CSA would make more sense than SQA,\n*                                 but someday I may need fixed storage\n* Warning:  The area pointed to by the CVTUSER field is used both by\n*           MPF programs IEC507D and IOS000I.\n         LR    R8,R1              Save address of storage gotten\n         USING XCVTUSER,R8        Tell assembler about dsect\n         XC    XCVTUSER(XCVTUSIZ),XCVTUSER  Clear CVTUSER pointed area\n         MVC   XCVTUEYE,CCVTUSER  Move 'CVTUSERn' to CVTUSER area\n         SLR   R7,R7              Clear a register for the 'CS' inst.\n* CS - If R7 and CVTUSER are equal, then R8 is stored in CVTUSER\n* CS - If R7 and CVTUSER are not equal, then CVTUSER is loaded to R7\n         CS    R7,R8,CVTUSER-CVT(R9)  Set CVTUSER address in CVT\n         BE    GOTCVTU            Got CVTUSER now, go back to main line\n* Some other user put CVTUSER in CVT first, free the new one\n         FREEMAIN RU,LV=XCVTUSIZ,A=(R8),SP=245  Free extra SQA storage\n         LR    R8,R7              Use the first CVTUSER area address\n         B     GOTCVTU            Got CVTUSER now, go back to main line\n         DROP  R8                 Drop pointer to area for CVTUSER\n*\nBADUSER  DS    0H\n         WTO   'MPF exit IOS000I found a bad CVTUSER area',ROUTCDE=11\n         B     RETURN             Exit the exit quick\n*\nCT       DC    CL2'CT'            Constant for compare\nSCTH     DC    CL4'SCTH'          Constant for compare\nCCVTUSER DC    CL7'CVTUSER',XL1'1' Constant to init and check CVTUSER\nSTARTCMD DC    AL2(38),AL2(0),CL34'START MSG,M=IOS000I from MPF EXIT '\n*\n         COPY  CVTUSER            CVTUSER DSECT in ????.SORC????\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'1'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL26             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\n*  Following mapped by SYS1.MODGEN(IEZVX100) ???????\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         CVT   DSECT=YES    MVS's Communications Vector Table\n*\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    E\nR3       EQU   3                      G\nR4       EQU   4                        I\nR5       EQU   5                          S\nR6       EQU   6                            T\nR7       EQU   7                              E\nR8       EQU   8                                R\nR9       EQU   9                  E\nR10      EQU   10                   Q\nR11      EQU   11                     U\nR12      EQU   12                       A\nR13      EQU   13                         T\nR14      EQU   14                           E\nR15      EQU   15                             S\n         END   ,\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=\n NAME IOS000I\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IST1132I": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x16\\x00\\x94\\x03\\x8f\\x01\\t4\\x7f!5\\x00u\\x00u\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1994-02-07T00:00:00", "modifydate": "2009-12-13T21:35:16", "lines": 117, "newlines": 117, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),IST1132I-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//IST1132I EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  UNIT=SYSDA,VOL=SER=??????\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN   ,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'IST1132I - - - START NJE LINK WHEN CDRM BECOMES ACTIVE'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* CHANGE LOG:\n*\n*   2-7-94 WAM  PROGRAM WRITTEN.\n*\n*    WHEN MESSAGE:\n*   IST1132I ???????.?CDRM?? IS ACTIVE, TYPE = CDRM\n*      DISPLAYS, WTO PROCESSING CALLS THIS PROGRAM AS AN MPF EXIT.\n*      IF THE IST1132I MESSAGE HAS 'TYPE = CDRM', THEN A START\n*      COMMAND IS ISSUED FOR MSG WITH THE M= KEYWORD SET TO\n*      THE CDRM NAME.\n*      OTHERWISE NO ACTION IS TAKEN.\n*      SYS1.PARMLIB(MPFLST00) DEFINES THE EXIT TO THE OPERATING SYSTEM.\n*      SYS1.PARMLIB(CONSOL00) DEFINES MPFLST00 TO THE SYSTEM.\n*\n*    TO DISABLE ALL MPF EXITS ENTER OPERATOR COMMAND 'SET MPF=NO'.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         PRINT ON,GEN,NODATA\nIST1132I CSECT ,\nIST1132I AMODE 31\nIST1132I RMODE ANY\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15            LOAD THE PROGRAM'S BASE REGISTER\n         USING IST1132I,R12       GIVE THE ASSEMBLER THE NEW BASE\n         L     R11,0(,R1)         LOAD THE ADDRESS OF THE COMM.TASK\n*                                 USER EXIT ROUTINE PARAMETER LIST\n*                                 GET SOME STORAGE BELOW-THE-LINE\n         L     R10,CTXTTXPJ-CTXT(,R11)  LOAD ADDRESS OF MESSAGE TEXT\n         LR    R11,R10            LOAD ADDRESS OF MESSAGE TEXT AGAIN\n*\nFINDCOMA DS    0H\n* IST1132I ???????.?CDRM?? IS ACTIVE, TYPE = CDRM\n         CLI   0(R11),C','        SEE IF A COMMA FOUND\n         BE    GOTCOMMA           COMMA FOUND, GO TO PROCESS\n         LA    R11,1(,R11)        BUMP TO CHECK NEXT CHAR. FOR A COMMA\n         B     FINDCOMA           GO TO CHECK NEXT CHAR. FOR A COMMA\nGOTCOMMA DS    0H\n         CLC   2(11,R11),TYPECDRM  SEE IF 'TYPE = CDRM' IN MESSAGE\n         BNE   EXITEXIT           'CDRM' NOT FOUND, GO EXIT THE EXIT\n         SH    R11,H9             BACK 9 BYTES TO CHECK FOR 'IS ACTIVE'\n         CLC   0(9,R11),ISACTIVE  SEE IF MESSAGE SAYS 'IS ACTIVE'\n         BNE   EXITEXIT           'ACT' NOT FOUND, GO EXIT THE EXIT\nFPERIOD  DS    0H\n         CLI   0(R10),C','        SEE IF A COMMA FOUND\n         BE    EXITEXIT           COMMA FOUND, GONE TOO FAR, GO EXIT\n         CLI   0(R10),C'.'        SEE IF A PERIOD FOUND\n         BE    PERIOD             PERIOD FOUND, GO ISSUE THE 'S MSG,-'\n         LA    R10,1(,R10)        BUMP TO CHECK NEXT CHAR. FOR A COMMA\n         B     FPERIOD            GO TO CHECK NEXT CHAR. FOR A COMMA\nPERIOD   DS    0H\n         GETMAIN R,LV=CMDLEN,SP=230,LOC=(BELOW,ANY)\n         LR    R2,R1              SAVE ADDRESS OF THE STORAGE ACQUIRED\n         MVC   0(CMDLEN,R2),TEMPLATE  COPY THE COMMAND FOR SVC 34\n         SLR   R11,R10            FIND THE LENGTH OF THE CDRM NAME\n         SH    R11,H3             FIND THE LENGTH OF THE CDRM NAME\n         EX    R11,MVC            MOVE THE CDRM NAME TO START COMMAND\n*         COMMANDS BUILT WILL BE S MSG,M=CDRMNAME\n         SLR   R0,R0              CLEAR REGISTER ZERO FOR SVC 34\n         SVC   34                 ISSUE OPERATOR COMMAND\n*                                 FREE THE BELOW-THE-LINE STORAGE\n         FREEMAIN R,LV=CMDLEN,A=(2),SP=230\nEXITEXIT DS    0H\n         DROP  R12                DROP ADDRESSABILITY TO THIS PROGRAM\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS\n         SLR   R15,R15            SET RETURN CODE TO ZERO\n         BR    R14                RETURN TO CALLER\n*\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*       CONSTANTS, EQUATES, AND DSECTS                                *\n*                                                                     *\n*      ( NOTE: RE-ENTERENT CODE DOES NOT ALLOW WORK AREAS HERE )      *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nMVC      MVC   12(0,R1),1(R10)    MOVE THE CDRM NAME TO START COMMAND\nH3       DC    H'3'               CONSTANT FOR SUBTRACTION\nH9       DC    H'9'               CONSTANT FOR SUBTRACTION\nTEMPLATE DC    AL2(CMDLEN),AL2(0),CL17'S MSG,M=X        '\nCMDLEN   EQU   *-TEMPLATE         LENGTH OF THE COMMAND LIST\nTYPECDRM DC    CL11'TYPE = CDRM'  CONSTANT FOR COMPARE\nISACTIVE DC    CL9'IS ACTIVE'     CONSTANT FOR COMPARE\n         SPACE 3\nR0       EQU   0                  REGISTER EQUATE FOR REGISTER 0\nR1       EQU   1                  REGISTER EQUATE FOR REGISTER 1\nR2       EQU   2                  REGISTER EQUATE FOR REGISTER 2\nR3       EQU   3                  REGISTER EQUATE FOR REGISTER 3\nR4       EQU   4                  REGISTER EQUATE FOR REGISTER 4\nR5       EQU   5                  REGISTER EQUATE FOR REGISTER 5\nR6       EQU   6                  REGISTER EQUATE FOR REGISTER 6\nR7       EQU   7                  REGISTER EQUATE FOR REGISTER 7\nR8       EQU   8                  REGISTER EQUATE FOR REGISTER 8\nR9       EQU   9                  REGISTER EQUATE FOR REGISTER 9\nR10      EQU   10                 REGISTER EQUATE FOR REGISTER 10\nR11      EQU   11                 REGISTER EQUATE FOR REGISTER 11\nR12      EQU   12                 REGISTER EQUATE FOR REGISTER 12\nR13      EQU   13                 REGISTER EQUATE FOR REGISTER 13\nR14      EQU   14                 REGISTER EQUATE FOR REGISTER 14\nR15      EQU   15                 REGISTER EQUATE FOR REGISTER 15\n         EJECT ,\n         LTORG ,                  PREVENT LITERALS IN DSECTS\n         IEZVX100 ,               COMM.TASK USER EXIT ROUTINE PARM.LIST\n         SPACE 3\n         END   ,                  THE END OF THE PROGRAM\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????(IST1132I),SPACE=  ,\n//*            UNIT=SYSDA,VOL=SER=??????\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LLAFRESH": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\"\\x00\\x990?\\x01\\t4\\x7f Y\\x00i\\x00j\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-10-30T00:00:00", "modifydate": "2009-12-13T20:59:22", "lines": 105, "newlines": 106, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),LLAFRESH-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//LLAFRESH EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\n//         DD  DSN=SYS1.MODGEN,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\nLLAFRESH TITLE '* * * Automatic Refresh of LLA * * *'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: LLAFRESH\n*\n*   Author: I ain't saying.\n*\n*   Date-written: 1999-10-30\n*\n*   Change Log:\n*\n* xx-xx-xx xxxxxxx\n*  x.x.x.\n*\n*   Remarks:\n*\n*     When a LinkList data set was compressed on one SYSRES that was\n*   shared with another system, I didn't remember to refresh Library\n*   LookAside on the second.  68 production JOBs abended trying to\n*   start before the operator caught it in one and a half minutes.\n*\n*        This MPF routine intercepts message IEW4009I and issues\n*   operator command 'MODIFY LLA,REFRESH' whenever the message occurs.\n*   This exit will refresh LLA on the first abend.\n*\n*   To activate this exit:\n*       Link to an LPA-List data set\n*       ( MPF exits are normally in LinkList, but this\n*       exit is used to recover from LinkList errors. )\n*       If it were LinkList, issue operator command: F LLA,REFRESH\n*       Since it is LPA-List, IPL to pick up the exit\n*       Code the following line in member MPFLST00 of SYS1.PARMLIB:\n*       IEW4009I,SUP(NO),USEREXIT(LLAFRESH)\n*       and issue operator command: SET MPF=00\n*\n*       SET MPF=NO will disable all MPF exits, if needed due to errors.\n*\n*    Three samples of the messages:\n*\n*CSV031I LIBRARY ACCESS FAILED FOR MODULE QWIKREF1, RETURN CODE 24,\n*REASON CODE 26080021, DDNAME *LNKLST*\n*LLAFRESH FETCH FAILED FOR MODULE QWIKREF1 FROM DDNAME -LNKLST- BECAUSE\n*OF AN I/O ERROR.\n*IEW4005I FETCH FOR MODULE QWIKREF1 FROM DDNAME -LNKLST- FAILED BECAUSE\n*IEWFETCH ISSUED RC 0F AND REASON 40\n*\n*CSV031I LIBRARY ACCESS FAILED FOR MODULE SAVEPSWD, RETURN CODE 24,\n*REASON CODE 26080021, DDNAME *LNKLST*\n*CSV028I ABEND106-28  JOBNAME=SAVEPSWD  STEPNAME=SAVEPSWD\n*IEW4009I FETCH FAILED FOR MODULE SAVEPSWD FROM DDNAME -LNKLST- BECAUSE\n*OF AN I/O ERROR.\n*IEW4005I FETCH FOR MODULE SAVEPSWD FROM DDNAME -LNKLST- FAILED BECAUSE\n*IEWFETCH ISSUED RC 0F AND REASON 40\n*\n*IEW4009I FETCH FAILED FOR MODULE WTOR     FROM DDNAME -LNKLST- BECAUSE\n*OF AN I/O ERROR.\n*IEW4005I FETCH FOR MODULE WTOR     FROM DDNAME -LNKLST- FAILED BECAUSE\n*IEWFETCH ISSUED RC 0F AND REASON 40\n*CSV031I LIBRARY ACCESS FAILED FOR MODULE WTOR    , RETURN CODE 24,\n*REASON CODE 26080021, DDNAME *LNKLST*\n*CSV028I ABEND106-28  JOBNAME=DLREG378  STEPNAME=GOSIS\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MACRO\n         REGS  ,                  MACRO to define register equates\n         LCLA  REG                Define variable\n&REG     SETA  0                  Insure that variable is Initialized\n.LOOP    ANOP\n         AIF   (&REG GT 15).END   Get out if all done\nR&REG    EQU   &REG               Register equate\n&REG     SETA  &REG+1             Bump register number\n         AGO   .LOOP              Go back to do the next register\n.END     ANOP\n         MEND\nLLAFRESH CSECT ,\nLLAFRESH AMODE 31\nLLAFRESH RMODE ANY\n         SAVE  (14,12),,LLAFRESH.&SYSDATE..&SYSTIME Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING LLAFRESH,R12       Give assembler program's base reg.\n*\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  MODIFY             Issue SVC 34 with cmd address in R1\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n         DROP  R12                Don't need base register anymore\n*\nMODIFY   DC  AL2(42),AL2(0),CL38'MODIFY LLA,REFRESH  MPF EXIT LLAFRESH'\n*                                123456789 123456789 123456789 1234567\n*\n         LTORG ,                  In case someone adds literals\n*\n         REGS  ,                  Generate register equates\n         END   ,\n//L.SYSLMOD DD DSN=SYS1.LPALIB,DISP=SHR,SPACE=,\n//             UNIT=SYSDA,VOL=SER=??????\n NAME LLAFRESH\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFLST00": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00U\\x00\\x97\\x15o\\x01\\t4\\x7f!\\x14\\x00\\x18\\x004\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "1997-06-05T00:00:00", "modifydate": "2009-12-13T21:14:55", "lines": 24, "newlines": 52, "modlines": 0, "user": "SOMITCW"}, "text": "$HASP050,SUP(NO),USEREXIT($HASP050) /* Starts SPOOL purge PROC       */\n$HASP100                            /* JOB on READER                 */\n$HASP317                        /* jjjjjjjj nnnn data sets cancelled */\nDFS000IA,SUP(YES),RETAIN(NO)        /* ?????                         */\nDFS000IB,SUP(YES),RETAIN(NO)        /* MSG. TP (IMS)                 */\nIEA404A,SUP(NO),USEREXIT(IEA404A)   /* WTO buffer shortage-100% full */\nIEC507D,SUP(NO),USEREXIT(IEC507D)   /* Reply 'M' to date protect msg */\nIEC512I,SUP(NO),USEREXIT(IEC512I)   /* Tape mount loop preventor     */\nIEC704A,SUP(NO),USEREXIT(REPLYM)    /* Reply 'M' to unload NL tapes  */\nIEE366I,SUP(NO),USEREXIT(IEE366I)   /* Start SMFDUMP if data buffered*/\nIEF099I,SUP(NO),USEREXIT(IEF099I)   /* JOB Waiting for Data Sets     */\nIEF238D,SUP(NO),USEREXIT(REPLYCAN)  /* Device name or cancel         */\nIEF251I,SUP(NO),USEREXIT(IEF251I)   /* Device error JOB cancelled    */\nIEF450I,SUP(NO),USEREXIT(IEF450I)   /* Night time JOB abend          */\nIEW4009I,SUP(NO),USEREXIT(LLAFRESH) /* Refreshes LLA on fetch error  */\nIKT012D,SUP(NO),USEREXIT(REPLYU)    /* Reply 'U' TCAS TERMINATION    */\nIOS000I,SUP(NO),USEREXIT(IOS000I)   /* Tell operator if disk error   */\nIST1132I,SUP(NO),USEREXIT(IST1132I) /* Starts JES2 links             */\n/* Messages deleted 2005-09-08                                   */\n/* IEC510D,SUP(NO),USEREXIT(REPLYF)    Reply 'F' unload file protect */\n/* IEC514D,SUP(NO),USEREXIT(REPLYM) Reply 'M' for DCK or label error */\n/* IEC701D,SUP(NO),USEREXIT(REPLYM)   Reply 'M' to initialize a tape */\n/* IEC534D,SUP(NO),USEREXIT(IEC534D)  Reply 'M' to tape relabel msg  */\n/* Many other changes deleted from this member                       */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSG": {"ttr": 2576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00T\\x00\\x90\\x17\\x7f\\x01\\x10\\x11O\\x14F\\x00\\x06\\x00\\x03\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1990-06-26T00:00:00", "modifydate": "2010-04-24T14:46:54", "lines": 6, "newlines": 3, "modlines": 0, "user": "SOMITCW"}, "text": "//         PROC M=MSGSTART,P=AUTOIPL\n//* If P=CMD, then DDNAME CMDIN should be DDNAME=IEFRDER\n//IEFPROC  EXEC PGM=&P,TIME=1\n//IEFRDER  DD  DSN=DATA.CENTER.PARMLIB(&M),DISP=SHR\n//SYSPRINT DD  SYSOUT=X,HOLD=YES\n//SYSUDUMP DD  SYSOUT=(C,,DUMP),HOLD=YES\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REPLYCAN": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00P\\x01\\x050\\x0f\\x01\\t4\\x7f!5\\x00\\x84\\x00z\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2005-10-27T00:00:00", "modifydate": "2009-12-13T21:35:50", "lines": 132, "newlines": 122, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWR JOB (????????,????,1,1),REPLYCAN-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//REPLYCAN EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\nREPLYCAN TITLE '* * * Automatic reply ''CANCEL'' to WTORs * * *'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Title: REPLYCAN\n*\n* Original Author: Murphy from CBT325 Tape file 25 member AUTOWTOR\n*\n* Current Blame: SOMITCW@yahoo.com\n*\n* Date-Rewritten: 2005-10-27\n*\n* Remarks:\n*\n*     Automatically give reply of CANCEL to message IEF238D.\n* IEF238D,SUP(NO),USEREXIT(REPLYCAN) needs to go in MPFLSTxx in\n* SYS1.PARMLIB, then use SET MPF=xx whatever member you set it to.\n*\n*  IEF244I TAPEZERO TAPESTAT - UNABLE TO ALLOCATE 1 UNIT(S)\n*          AT LEAST 1 OFFLINE UNIT(S) NEEDED.\n*  IEF877E TAPEZERO NEEDS 1 UNIT(S)\n*  FOR TAPESTAT TAPESTAT\n*  FOR VOLUME SCRTCH-   1\n*  OFFLINE, NOT ACCESSIBLE\n*  0500-0501 05A0-05A1\n*  :\n*  IEF878I END OF IEF877E FOR TAPEZERO TAPESTAT TAPESTAT\n* *49 IEF238D TAPEZERO - REPLY DEVICE NAME OR 'CANCEL'.\n*  IEE600I REPLY TO 49 IS;CANCEL\n*  IEF251I TAPEZERO JOB CANCELLED\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREPLYCAN CSECT ,\nREPLYCAN AMODE 31\nREPLYCAN RMODE ANY\n         SAVE  (14,12),,REPLYCAN.&SYSDATE..&SYSTIME\n*        Saves registers and inserts program, date, and time\n         LR    R12,R15            Load address of entry point\n         USING REPLYCAN,R12\n         LR    R9,R1\n         L     R5,0(,R1)\n         USING CTXT,R5            Addressing CTXT\n         CLC   0(2,R5),=C'CT'\n         BNE   RETURN\n         GETMAIN RU,LV=WORKL,LOC=BELOW,SP=229\n         LR    R3,R1              Address of work area/savearea\n         USING SAVDSECT,R3        Addressability\n         ST    R13,SAVEAREA+4     Store caller savearea address (HSA)\n         ST    R3,8(,R13)         Add of program save in caller (LSA)\n         LR    R13,R3             Address of savearea in R13\n         L     R2,CTXTTXPJ\n         USING CTXTATTR,R2        Msg attributes\n         LA    R4,CTXTTMSG        Address of text area\n         USING MSGTEXT,R4\n         MVC   WTOEXEC,WTOLIST\n         MVC   WTOEXEC+42(8),MSGID   Message ID 'IEF238D '\n         XC    MGCRPL(MGCRLTH),MGCRPL  Clear parameter list\n         MVC   MGCRTEXT(L'TXTINSRT),TXTINSRT Move in reply buffer\n         MVC   REPLY,CTXTRPID     Insert reply id\n         LA    R1,(MGCRTEXT-MGCRPL)+L'TXTINSRT  Get MGCRPL length\n         STC   R1,MGCRLGTH        Save length in MGCRPL\n         SR    R0,R0\n         MGCR  MGCRPL\n         DROP  R2,R4\n         WTO   MF=(E,WTOEXEC)\nFREERET  L     R13,4(,R13)        Address of calling program savearea\n         FREEMAIN RU,LV=WORKL,A=(3),SP=229\nRETURN   SR    R15,R15\n         RETURN (14,12),RC=(15)\n*\nTXTINSRT DC    CL16'REPLY xx,CANCEL '  Reply\n*               456789 123456789 123456789 '123456'789 123456789\nWTOLIST  WTO   'MPF exit REPLYCAN Replied ''CANCEL'' to xxxxxxxx ',    C\n               ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    e\nR3       EQU   3                      g\nR4       EQU   4                        i\nR5       EQU   5                          s\nR6       EQU   6                            t\nR7       EQU   7                              e\nR8       EQU   8                                r\nR9       EQU   9                  E\nR10      EQU   10                   q\nR11      EQU   11                     u\nR12      EQU   12                       a\nR13      EQU   13                         t\nR14      EQU   14                           e\nR15      EQU   15                             s\nSAVDSECT DSECT ,\nSAVEAREA DS    18F\n         DS    0F\nWTOEXEC  DS    CL(CNCLMSG)\nMGCR     IEZMGCR DSECT=NO\n         ORG   MGCRTEXT\nCOMMAND  DS    CL6\nREPLY    DS    CL2\nREPLYMSG DS    CL8\n         ORG   ,\nWORKL    EQU   *-SAVEAREA\n*\n*        IEZVX100 DSECT=YES       CTXT DSECT\n*\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\n*\nCTXTATTR DSECT ,\n         DS    CL6                Six byte attribute header before msg\nCTXTTMSG DS    CL126\n*\nMSGTEXT  DSECT ,\nMSGID    DS    CL8\nJOBDATA  DS    CL8\n         ORG   MSGTEXT\n         DS    CL4\nWTORID   DS    CL8\n*\n         END   ,\n//L.SYSLMOD  DD  DSN=????.LOAD????,DISP=SHR,SPACE=\n NAME REPLYCAN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REPLYF": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x15\\x00\\x99#\\x8f\\x01\\t4\\x7f Y\\x00g\\x00g\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-08-26T00:00:00", "modifydate": "2009-12-13T20:59:15", "lines": 103, "newlines": 103, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),REPLYF-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//REPLYF  EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\n//         DD  DSN=SYS1.MODGEN,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'REPLYF - Reply ''F'' to unload file protected tapes'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: REPLYF ( originally was REPLYU then REPLYM )\n*\n*   Author: Murphy from CBT325 tape file 25 member AUTOWTOR\n*\n*   Re-written by: I ain't saying.\n*\n*   Date re-written: 99-08-26\n*\n*   Change Log:\n*\n* xx-xx-xx x\n*  x.x.x.  x\n*\n*   Remarks:\n*\n*        This MPF exit to automatically give reply of 'F' to message:\n*   IEC510D REPLY 'U'-USE OR 'F'-UNLOAD\n*\n*      File protected tape that MAY be updated ( file may be added ).\n*  *IEC510D F 0400,ABC001,JOBNAME,DDNAME,DATA.SET.NAME\n* *58 IEC510D REPLY 'U'-USE OR 'F'-UNLOAD\n*\n*   IEC510D,SUP(NO),USEREXIT(REPLYF)   Reply 'F', File Protected tape\n*   goes in the MPFLSTxx member of SYS1.PARMLIB, then use the\n*   SET MPF=XX console command.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREPLYF   CSECT ,\nREPLYF   AMODE 31\nREPLYF   RMODE ANY\n         LCLA  &N                 Declare arithmetic local variable\n&N       SETA  0                  Change &N from zero to zero\n.REGS    ANOP  ,\n         AIF   (&N GT 15).FINREGS Only define 16 registers\nR&N      EQU   &N                 A register equate\n&N       SETA  &N+1               Add one for mthe next register number\n         AGO   .REGS              Go back to generate the next equate\n.FINREGS ANOP  ,\n         SAVE  (14,12),,REPLYF.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING REPLYF,R12         Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n         CLI   CTXTRPID,C'0'      See if a reply id number is present\n         BL    RETURN             No reply id, go exit this exit\n         GETMAIN RU,LV=WORKLEN,LOC=BELOW,SP=229  Get MYDSECT storage\n         LR    R9,R1              Address of work area for SVC 34 & WTO\n         USING MYDSECT,R9         Addressability to my DSECT\n         MVC   CMD(15),REPLYCMD   Move model command to SVC 34 buffer\n         MVC   CMDNUM,CTXTRPID    Insert reply id number\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  CMD                Issue SVC 34 with cmd address in R1\n         MVC   WTOEXEC,WTOLIST    Prime Write-To-Operator message buff.\n         MVC   WTOEXEC+38(2),CTXTRPID  Put replyid in WTO message\n         WTO   MF=(E,WTOEXEC)     Send message to the operator\n         FREEMAIN RU,LV=WORKLEN,A=(R9),SP=229  Release MYDSECT area\n         DROP  R9,R10,R11\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nCT       DC    CL2'CT'            Constant for compare\nREPLYCMD DC    AL2(15),AL2(0),CL11'REPLY XX,F '  Model reply command\nWTOLIST  WTO 'MPF exit ''REPLYF'' replied ''F'' to *XX',ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\n*\nMYDSECT  DSECT ,\nCMD      DS    XL2                Length of the command with header\n         DS    XL2                always binary zeroes\n         DS    CL6                Will be 'REPLY '\nCMDNUM   DS    CL2                Will be the reply id number\n         DS    CL3                Will be ',F '\nWTOEXEC  DS    CL(CNCLMSG)\nWORKLEN  EQU   *-MYDSECT          Length of my DSECT\n*\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         END   ,\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=,\n//             UNIT=SYSDA,VOL=SER=??????\n NAME REPLYF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REPLYM": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00R\\x00\\x98\\x12\\x1f\\x01\\t4\\x7f Y\\x00z\\x00x\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-05-01T00:00:00", "modifydate": "2009-12-13T20:59:52", "lines": 122, "newlines": 120, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),REPLYM-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//REPLYM  EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\n//         DD  DSN=SYS1.MODGEN,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'REPLYM - Reply ''M'' to unload wrong tapes mounted'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: REPLYM ( originally was REPLYU )\n*\n*   Author: Murphy from CBT325 tape file 25 member AUTOWTOR\n*\n*   Re-written by: I ain't saying.\n*\n*   Date re-written:   5-1-98\n*\n*   Change Log:\n*\n* xx-xx-xx x\n*  x.x.x.  x\n*\n*   Remarks:\n*\n*        This MPF exit to automatically give reply of 'M' to messages\n*   IEC514D, IEC534D, and IEC701D.\n*\n*      Could not read label on output tape:\n*  *IEC514D DCK OR LBL ERR 0523,ABC123,JOBNAME,STEPNAME,OUTPUT.DSNAME\n*  *08 IEC514D REPLY 'M'-UNLOAD OR 'A'-ABEND\n*\n*\n*      Wrong output vol ser for 3480 ( wrong label type for others ):\n*  *IEC534D A 0180,ABC001,SL,JOBNAME,JOBSTEP,PROCSTEP\n*  *01 IEC534D REPLY 'U'-USE OR 'M'-UNLOAD\n*\n*      Tape being initialized ( IEHINITT ):\n*  * IEC701D M cua,VOLUME TO BE LABELED volser\n*\n*  ( Message IEC507D has it's own exit because of special processing )\n*\n*   The tricky thing is that messages IEC514D and IEC534D are\n*   really two messages each.\n*   The first message gives the tape volume serial number and the\n*   second message asks the operator to re-label and write over or\n*   not to re-label and not write over wrong vol ser tape.\n*   The first message is ignored.  'M' is replied to the second.\n* noIEC514D,SUP(NO),USEREXIT(REPLYM)no Reply 'M', DCK or label error\n* noIEC534D,SUP(NO),USEREXIT(REPLYM)no Reply 'M', wrong vol ser mounted\n* noIEC701D,SUP(NO),USEREXIT(REPLYM)no Reply 'M', to initialize a tape\n*   IEC704A,SUP(NO),USEREXIT(REPLYM)   Reply 'M' to unload NL tapes\n*   goes in the MPFLSTxx member of SYS1.PARMLIB, then use the\n*   SET MPF=XX console command.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREPLYM   CSECT ,\nREPLYM   AMODE 31\nREPLYM   RMODE ANY\n         LCLA  &N                 Declare arithmetic local variable\n&N       SETA  0                  Change &N from zero to zero\n.REGS    ANOP  ,\n         AIF   (&N GT 15).FINREGS Only define 16 registers\nR&N      EQU   &N                 A register equate\n&N       SETA  &N+1               Add one for mthe next register number\n         AGO   .REGS              Go back to generate the next equate\n.FINREGS ANOP  ,\n         SAVE  (14,12),,REPLYM.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING REPLYM,R12         Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n         CLI   CTXTRPID,C'0'      See if a reply id number is present\n         BL    RETURN             No reply id, go exit this exit\n         GETMAIN RU,LV=WORKLEN,LOC=BELOW,SP=229  Get MYDSECT storage\n         LR    R9,R1              Address of work area for SVC 34 & WTO\n         USING MYDSECT,R9         Addressability to my DSECT\n         MVC   CMD(15),REPLYCMD   Move model command to SVC 34 buffer\n         MVC   CMDNUM,CTXTRPID    Insert reply id number\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  CMD                Issue SVC 34 with cmd address in R1\n         MVC   WTOEXEC,WTOLIST    Prime Write-To-Operator message buff.\n         MVC   WTOEXEC+38(2),CTXTRPID  Put replyid in WTO message\n         WTO   MF=(E,WTOEXEC)     Send message to the operator\n         FREEMAIN RU,LV=WORKLEN,A=(R9),SP=229  Release MYDSECT area\n         DROP  R9,R10,R11\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nCT       DC    CL2'CT'            Constant for compare\nREPLYCMD DC    AL2(15),AL2(0),CL11'REPLY XX,M '  Model reply command\nWTOLIST  WTO 'MPF exit ''REPLYM'' replied ''M'' to *XX',ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\n*\nMYDSECT  DSECT ,\nCMD      DS    XL2                Length of the command with header\n         DS    XL2                always binary zeroes\n         DS    CL6                Will be 'REPLY '\nCMDNUM   DS    CL2                Will be the reply id number\n         DS    CL3                Will be ',M '\nWTOEXEC  DS    CL(CNCLMSG)\nWORKLEN  EQU   *-MYDSECT          Length of my DSECT\n*\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         END   ,\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=,\n//             UNIT=SYSDA,VOL=SER=??????\n NAME REPLYM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REPLYU": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00P\\x00\\x91\\x14O\\x01\\t4\\x7f  \\x00r\\x00N\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1991-05-24T00:00:00", "modifydate": "2009-12-13T20:20:50", "lines": 114, "newlines": 78, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWR JOB (????????,????,1,1),REPLYU-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//REPLYU   EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR\nREPLYU   TITLE '* * * AUTOMATIC REPLY TO WTORS * * *'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*   TITLE: REPLYU                                                     *\n*                                                                     *\n*   AUTHOR: MURPHY FROM CBT325 TAPE FILE 25 MEMBER AUTOWTOR           *\n*                                                                     *\n*   DATE-WRITTEN: 12/17/85                                            *\n*                                                                     *\n*   DATE-MODIFIED: 5-24-91                                            *\n*                                                                     *\n*   REMARKS:                                                          *\n*                                                                     *\n*        AUTOMATICALLY GIVE REPLY OF U TO MESSAGE ICK003D.            *\n*   ICK003D,SUP(NO),USEREXIT(REPLYU) NEED TO GO IN MPF MEMBER IN      *\n*   SYS1.PARMLIB, THEN USE SET MPF=XX WHATEVER MEMBER YOU SET IT TO.  *\n*   SEE MPFLST03 FOR EXAMPLE.                                         *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREPLYU   CSECT ,\nREPLYU   AMODE 31\nREPLYU   RMODE ANY\n         SAVE  (14,12),,REPLYU.&SYSDATE..&SYSTIME\n*        SAVES REGISTERS AND INSERTS PROGRAM, DATE, AND TIME\n         LR    R12,R15            LOAD ADDRESS OF ENTRY POINT\n         USING REPLYU,R12\n         LR    R9,R1\n         L     R5,0(,R1)\n         USING CTXT,R5            ADDRESSING CTXT\n         CLC   0(2,R5),=C'CT'\n         BNE   RETURN\n         GETMAIN RU,LV=WORKL,LOC=BELOW,SP=229\n         LR    R3,R1              ADDRESS OF WORK AREA/SAVEAREA\n         USING SAVDSECT,R3        ADDRESSABILITY\n         ST    R13,SAVEAREA+4     STORE CALLER SAVEAREA ADDRESS (HSA)\n         ST    R3,8(,R13)         ADD OF PROGRAM SAVE IN CALLER(LSA)\n         LR    R13,R3             ADDRESS OF SAVEAREA IN R13\n         L     R2,CTXTTXPJ\n         USING CTXTATTR,R2        MSG ATTRIBUTES\n         LA    R4,CTXTTMSG        ADDRESS OF TEXT AREA\n         USING MSGTEXT,R4\n         MVC   WTOEXEC,WTOLIST\n         MVC   WTOEXEC+22(8),MSGID   MESSAGE NUMBER\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINSRT),TXTINSRT MOVE IN REPLY BUFFER\n         MVC   REPLY,CTXTRPID     INSERT REPLY ID\n         LA    R1,(MGCRTEXT-MGCRPL)+L'TXTINSRT  GET MGCRPL LENGTH\n         STC   R1,MGCRLGTH        SAVE LENGTH IN MGCRPL\n         SR    R0,R0\n         MGCR  MGCRPL\n         DROP  R2,R4\n         WTO   MF=(E,WTOEXEC)\nFREERET  L     R13,4(,R13)        ADDRESS OF CALLING PROGRAM SAVEAREA\n         FREEMAIN RU,LV=WORKL,A=(3),SP=229\nRETURN   SR    R15,R15\n         RETURN (14,12),RC=(15)\nTXTINSRT DC    CL11'REPLY XX,U '  REPLY\nWTOLIST  WTO   'REPLYU REPLIED TO MSGNUMB - AS SELECTED BY MPF',       X\n               ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\nR0       EQU   0\nR1       EQU   1                  R\nR2       EQU   2                    E\nR3       EQU   3                      G\nR4       EQU   4                        I\nR5       EQU   5                          S\nR6       EQU   6                            T\nR7       EQU   7                              E\nR8       EQU   8                                R\nR9       EQU   9                  E\nR10      EQU   10                   Q\nR11      EQU   11                     U\nR12      EQU   12                       A\nR13      EQU   13                         T\nR14      EQU   14                           E\nR15      EQU   15                             S\nSAVDSECT DSECT ,\nSAVEAREA DS    18F\n         DS    0F\nWTOEXEC  DS    CL(CNCLMSG)\nMGCR     IEZMGCR DSECT=NO\n         ORG   MGCRTEXT\nCOMMAND  DS    CL6\nREPLY    DS    CL2\nREPLYMSG DS    CL3\n         ORG   ,\nWORKL    EQU   *-SAVEAREA\nMSGTEXT  DSECT ,\nMSGID    DS    CL8\nJOBDATA  DS    CL8\n         ORG   MSGTEXT\n         DS    CL4\nWTORID   DS    CL8\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4          POINTER TO MAJOR LINE TEXT\nCTXTTXPN DS    CL4          POINTER TO MINOR LINE TEXT\n         DS    CL8\nCTXTRPID DS    CL2          REPLY ID\n         END   ,\n//L.SYSLMOD  DD  DSN=????.LOAD????(REPLYU),DISP=OLD,SPACE=,\n//             UNIT=SYSDA,VOL=SER=------\n//CHECKCC  EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REPLYY": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x17\\x01\\x00\\x15_\\x01\\t4\\x7f Y\\x00_\\x00_\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2000-06-03T00:00:00", "modifydate": "2009-12-13T20:59:17", "lines": 95, "newlines": 95, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWI JOB (????????,????,1439,9999),REPLYY-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//REPLYY  EXEC HLASMCL,PARM.C=(NODECK,OBJECT,RENT),\n//             PARM.L='REFR,RENT,REUS,AC=1,LIST,MAP'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\n//         DD  DSN=SYS1.MODGEN,DISP=SHR,UNIT=SYSDA,VOL=SER=??????\nPASS     TITLE 'REPLYY - Reply ''Y'' to JES2 Multi System SPOOL Lock'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   Title: REPLYY ( originally was REPLYU then REPLYM,F,C, and now Y )\n*\n*   Author: Murphy from CBT325 tape file 25 member AUTOWTOR\n*\n*   Re-written by: I ain't saying.\n*\n*   Date re-written: 2000-06-03\n*\n*   Change Log:\n*\n* xx-xx-xx x\n*  x.x.x.  x\n*\n*   Remarks:\n*\n* *01 $HASP454 SHOULD JES2 BYPASS THE MULTI-MEMBER INTEGRITY LOCK? ('Y'\n*    OR 'N')\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nREPLYY   CSECT ,\nREPLYY   AMODE 31\nREPLYY   RMODE ANY\n         LCLA  &N                 Declare arithmetic local variable\n&N       SETA  0                  Change &N from zero to zero\n.REGS    ANOP  ,\n         AIF   (&N GT 15).FINREGS Only define 16 registers\nR&N      EQU   &N                 A register equate\n&N       SETA  &N+1               Add one for mthe next register number\n         AGO   .REGS              Go back to generate the next equate\n.FINREGS ANOP  ,\n         SAVE  (14,12),,REPLYY.&SYSDATE..&SYSTIME  Save caller's regs.\n         LR    R12,R15            Load address of entry point\n         USING REPLYY,R12         Give assembler program's base reg.\n         L     R11,0(,R1)         Load the address of the CTXT\n         USING CTXT,R11           Addressing CTXT\n         L     R10,CTXTTXPJ       Load address of major line text\n         USING CTXTATTR,R10       Addressing message attributes & text\n         CLC   0(2,R11),CT        See if a real CTXT is found\n         BNE   RETURN             If not a CTXT, get out quick\n         CLI   CTXTRPID,C'0'      See if a reply id number is present\n         BL    RETURN             No reply id, go exit this exit\n         GETMAIN RU,LV=WORKLEN,LOC=BELOW,SP=229  Get MYDSECT storage\n         LR    R9,R1              Address of work area for SVC 34 & WTO\n         USING MYDSECT,R9         Addressability to my DSECT\n         MVC   CMD(15),REPLYYMD   Move model command to SVC 34 buffer\n         MVC   CMDNUM,CTXTRPID    Insert reply id number\n         SLR   R0,R0              Set SVC 34 full authorization\n         MGCR  CMD                Issue SVC 34 with cmd address in R1\n         MVC   WTOEXEC,WTOLIST    Prime Write-To-Operator message buff.\n         MVC   WTOEXEC+38(2),CTXTRPID  Put replyid in WTO message\n         WTO   MF=(E,WTOEXEC)     Send message to the operator\n         FREEMAIN RU,LV=WORKLEN,A=(R9),SP=229  Release MYDSECT area\n         DROP  R9,R10,R11\nRETURN   DS    0H\n         SLR   R15,R15            Set a return code of zero\n         RETURN (14,12),RC=(15)   Return to caller, return code zero\n*\nCT       DC    CL2'CT'            Constant for compare\nREPLYYMD DC    AL2(15),AL2(0),CL11'REPLY XX,Y '  Model reply command\nWTOLIST  WTO 'MPF exit ''REPLYY'' replied ''Y'' to *XX',ROUTCDE=11,MF=L\nCNCLMSG  EQU   *-WTOLIST\n*\nMYDSECT  DSECT ,\nCMD      DS    XL2                Length of the command with header\n         DS    XL2                always binary zeroes\n         DS    CL6                Will be 'REPLY '\nCMDNUM   DS    CL2                Will be the reply id number\n         DS    CL3                Will be ',Y '\nWTOEXEC  DS    CL(CNCLMSG)\nWORKLEN  EQU   *-MYDSECT          Length of my DSECT\n*\nCTXT     DSECT ,\n         DS    CL8\nCTXTTXPJ DS    CL4                Pointer to major line text\nCTXTTXPN DS    CL4                Pointer to minor line text\n         DS    CL8\nCTXTRPID DS    CL2                Reply id\nCTXTATTR DSECT ,\n         DS    CL6\nCTXTTMSG DS    CL126\n*\n         END   ,\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=,\n//             UNIT=SYSDA,VOL=SER=??????\n NAME REPLYY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETWHEN": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00B\\x01\\x06\"\\x0f\\x01\\x10\\x11O\\x143\\x00\\xba\\x00\\xa7\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2006-08-08T00:00:00", "modifydate": "2010-04-24T14:33:42", "lines": 186, "newlines": 167, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWS JOB (????????,????,1439,9999,9999),SETWHEN-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//             PARM.L=RENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN or SYS1.AMODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'SETWHEN - - - Set Day, Night, Week-end indicator'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    MPF exits IEF378I, IEF450I, and IEF453I need to know if an\n*  abend or JCL error occurred during nightly or week-end\n*  processing to know whether to ignore, send E-Mail, or send\n*  a Cell-Phone Text-message.  This program updates one byte\n*  in the area pointed to by CVTUSER to indicate D, N, or W.\n*\n*     Sample JCL:\n*\n* //xxxxxxxS JOB (xxxxxxxx,xxxx,1439,9999,9999),SETWHENJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=&SYSUID,COND=(0,NE)\n* //SETWHEN EXEC PGM=SETWHEN,PARM=D\n* //SYSUDUMP DD  SYSOUT=*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSETWHEN  CSECT ,\nSETWHEN  AMODE 31                 Addressing mode of 31\nSETWHEN  RMODE ANY                Residency mode of anywhere\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'SETWHEN.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LA    R11,0(,R1)         Save the PARM register\n         LR    R12,R15            Load the program's base register\n         USING SETWHEN,R12        Give the assembler the new base\n         LA    R0,SAVESIZE        Load reg. save area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for reg. save area space\n         XC    0(SAVESIZE,R1),0(R1)  Clear register save area\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13       Give assembler register for DSECT\n*                                 Save area just for convention, no use\n* Find the PARM\n         LTR   R11,R11            Insure that there is a PARM list addr\n         BZ    NOPARM             No address, go abend because no PARM\n         L     R11,0(,R11)        Load the PARM address\n         LA    R11,0(,R11)        Strip high-order bit if present\n         LTR   R11,R11            Insure that there is a PARM addr\n         BZ    NOPARM             No address, go abend because no PARM\n         CLI   1(R11),1           Insure that the PARM is one byte\n         BNE   NOPARM             Go abend if no valid length PARM\n         LA    R11,2(,R11)        Load the address of the PARM byte\n*                                 Save area just for convention, no use\n* Find CVTUSER area\n         L     R10,16             Load the address of the CVT\n         USING CVT,R10            Give assembler the CVT mapping\n         ICM   R9,B'1111',CVTUSER Load address of the CVT user area\n         USING XCVTUSER,R9        Give assembler the CVTUSER mapping\n         BNZ   GOTUSER            Have CVTUSER, skip getting a new one\n*    Create CVTUSER if needed ( GETMAIN, init, chain )\n         MODESET KEY=ZERO         Switch to key zero\n   GETMAIN RU,LV=XCVTUSIZ,LOC=BELOW,SP=245 Get 48 byte CVTUSER SQA area\n*                                 CSA would make more sense than SQA,\n*                                 but someday I may need fixed storage\n         LR    R9,R1              Save address of storage gotten\n         USING XCVTUSER,R9        Tell assembler about dsect\n         XC    XCVTUSER(XCVTUSIZ),XCVTUSER  Clear CVTUSER pointed area\n         MVC   XCVTUEYE,CVTUSER1  Move 'CVTUSERn' to CVTUSER area\n         SLR   R8,R8              Clear a register for the 'CS' inst.\n* CS - If R8 and CVTUSER are equal, then R9 is stored in CVTUSER\n* CS - If R8 and CVTUSER are not equal, then CVTUSER is loaded to R8\n         CS    R8,R9,CVTUSER      Set CVTUSER address in CVT\n         DROP  R10                Don't need pointer to CVT anymore\n         BE    NEWUSER            Got CVTUSER now, go back to main line\n* Some other program put CVTUSER in CVT first, free the new one\n         FREEMAIN RU,LV=XCVTUSIZ,A=(R9),SP=245   Free extra SQA storage\n         LR    R9,R8              Use the first CVTUSER area address\n*        B     NEWUSER            Got CVTUSER now, now check it\nNEWUSER  DS    0H\n         MODESET KEY=NZERO        Go back to key 8\nGOTUSER  DS    0H\n         CLC   XCVTUEYE,CVTUSER1  See if the CVTUSER area is mine\n         BNE   BADUSER            If someone else has CVTUSER, go tell\n*\n* Update XCVTWHEN in memory\n*\nUPDATE   DS    0H\n         MODESET KEY=ZERO         Switch to key zero\n         MVC   XCVTWHEN,0(R11)    Set D, N, or W\n         MODESET KEY=NZERO        Switch to key eight\n         LA    R0,SAVESIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nNOPARM   DS    0H\n         WTO 'SETWHEN - PARM is missing or invalid',ROUTCDE=11\n         WTO 'SETWHEN - valid PARMs are D, N, and W',ROUTCDE=11\n         WTO 'SETWHEN - Program is abending',ROUTCDE=11\n         ABEND 123                Abend without a dump\n*\nBADUSER  DS    0H\n         WTO  'SETWHEN - CVTUSER area not valid',ROUTCDE=11\n         WTO  'SETWHEN - Some other software must be using',ROUTCDE=11\n         WTO  'SETWHEN - Program is abending',ROUTCDE=11\n         ABEND 234                Abend without a dump\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0D                 Align Constants area\n*\n* The X'1' is the DSECT version number\nCVTUSER1 DC    CL7'CVTUSER',XL1'1'  Constant to check CVTUSER\n*\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nSAVESIZE EQU   *-SAVEAREA\n*\n         COPY CVTUSER             Copy the CVTUSER area DSECT\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n* XCVTWHEN DS    CL1              D-N-W Day, Night, Week-end indicator\n*          DS    XL1              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* * TAPESKIP DS    CL6            TAPESKIP was old name for XCVTSKIP\n* XCVTSKIP DS    CL6              IEC512I tape vol ser to ignore\n*          DS    XL22             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   SETCODE AC(1)\n   NAME SETWHEN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPE": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01<\\x00\\x01\\x01\\x04\"_\\x01\\x10\\x11O\\x15\\'\\x02&\\x01\\xe2\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.60", "flags": 0, "createdate": "2004-08-12T00:00:00", "modifydate": "2010-04-24T15:27:01", "lines": 550, "newlines": 482, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPE-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//             PARM.L='RENT,AC=1'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=????.SORC????\n//         DD  DISP=SHR,DSN=SYS1.MODGEN or SSY1.AMODGEN\nPASS TITLE 'TAPE - - - Mounts tapes in Flex-ES'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program accepts MODIFY operator commandsd\n*  and sends mount CCWs to tape drives to give Flex-ES\n*  the file specs for a tape file.\n*\n*  The format of the console modify command is:\n*  f tape,cccu,volser\n*  To request that tape N00321 be mounted on tape\n*  drive 415, the command would be:\n*  f tape,0415,A00321 or\n*  f tape,415,A00321\n*\n*  Tape vol sers starting with an \"A\" are in /tapeA\n*  Tape vol sers starting with an \"B\" are in /tapeB\n*  All other tapes are in file system /tapeC\n*\n*  The first three bytes of the volser is also the\n*  directory name for the tapes.\n*  Tape TX1234 would have file spec:\n*  /tapeC/TX1/TX1234.aws\n*\n*  Warning...  If we ever convert to four digit\n* dynamic tape UCBs above the line, then IOSLOOK\n* should be converted to UCBLOOK or UCBSCAN with\n* appropriate PIN/NOPIN and UCBPIN UNPIN.\n*\n*     Sample JCL:\n*\n* //TAPE    EXEC PGM=TAPE,TIME=1439\n* //* No required DD statements so running as a sub-system is easier\n* //STCLOCK  DD  DISP=OLD,DSN='Only one TAPE STC can run at a time',\n* //             VOL=REF=SYS1.LINKLIB\n*\n*     Sample console start command:\n*\n* s tape,sub=mstr\n*\n*     Sample stop command:\n*\n* p tape\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         PRINT ON,GEN,DATA        Want to see all\nTAPE     CSECT ,\nTAPE     AMODE 24                 Addressing mode of 24 for EXCP MACRO\nTAPE     RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPE.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPE,R12           Give the assembler the new base\n         LA    R0,SAVESIZE        Load work area size for GETMAIN\n         GETMAIN RU,LV=(0)        Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n*\n*    Fill in EXTRACT, DCB, IOB, and CCW fields\n         MVC   EXTRACT(DUMLEN),DUMEXT  Move EXTRACT MACRO list\n         MVC   DEBVT(DEBLEN),DDEBVT    Copy DEB template\n         LA    R11,DCB            Load address of DCB\n         STCM  R11,B'0111',DEBDCB Store DCB address in DEB\n         LA    R11,DEBVT               Load address of DEB Vector table\n         STCM  R11,B'0111',DEBIOVT     Store vector table addr. in DEB\n         MVC   DCB(DCBLEN),DDCB   Copy DEB template\n         LA    R11,DEB                 Load address of DEB\n         STCM  R11,B'0111',DCBDEB Store DEB address in DCB\n         MVC   IOB(DIOBLEN),DIOB  Copy IOB templates\n         LA    R11,ECB            Load address of Event Contr.Blk\n         STCM  R11,B'0111',IOBECB Store ECB address in IOB\n         LA    R11,IOBCCW         Load addr.of Chan. Command Word\n         ST    R11,IOBCCWA        Store CCW address in IOB\n         LA    R11,DCB            Load address of Data Control Block\n         ST    R11,IOBDCB         Store DCB address in IOB\n         LA    R11,MOUNT          Load address of mount command\n         STCM  R11,B'0111',IOBCCW+1 Store mount command address\n         MVC   MOUNT,DMOUNT       Copy mount command template\n         EXTRACT TIOT,'S',FIELDS=(TIOT,COMM),MF=(E,EXTRACT)\n         L     R11,TIOT           Load the address of the STC name\n*        ENQ   (QNAME,(R11),E,8,SYSTEM), See if STC TAPE active      X\n*              RET=USE,                  See if STC TAPE active      X\n*              MF=(E,(R??))              See if STC TAPE active\n*        LTR   R10,R15            See if TAPE already running\n*        BNZ   ERRORDUP           If TAPE already running, get out\n         L     R11,COMM           Load address of Communication Area\n* Communications area (mapped by IEZCOM)\n         USING COMLIST,R11        Tie IEZCOM to R10\n*\n         ICM   R10,B'1111',COMCIBPT  Load addr.of Command Input Buffer\n         USING CIBLIST,R10        Tie IEZCIB to R10\n         BZ    CIBSET             No start CIB, go allow Modify CIBs\n         WTO   'TAPE - Initial CIB',ROUTCDE=11\n         BAL   R9,DISPCIB         Display the CID to the console\n* CIBSTART EQU   X'04' -  Command code for START\n         CLI   CIBVERB,CIBSTART   See if initial CIB from start command\n         BNE   CIBSET             Not known CIB, go ignore it for now\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(10)  Free the start CIB\nCIBSET   DS    0H\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=34  Allow 34 pending Modifies\nCIBFIND  DS    0H\n         ICM   R10,B'1111',COMCIBPT  Load addr.of Command Input Buffer\n         BZ    WAIT               No CIB found, go wait for next POST\n*\n* CIBSTOP  EQU   X'40' -  Command code for STOP\n* CIBMODFY EQU   X'44' -  Command code for MODIFY\n         CLI   CIBVERB,CIBSTOP    See if a Stop console command\n         BE    EOJ                Operator issue Stop, so end-of-job\n         CLI   CIBVERB,CIBMODFY   See if a Modify console command\n         BE    MODIFY             Got modify, go process it\n         WTO   'TAPE - Following unknown CIB will be freed',ROUTCDE=11\n         BAL   R9,DISPCIB         Unknown CIB, perform display for it\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(10)  Free the unknown CIB\n         B     CIBFIND            Go back to find another CIB\n*\nMODIFY   DC    0H\n         CLI   CIBDATLN+1,10      See if three byte unit address\n         BE    MODTHREE           Go process three byte unit address\n         CLI   CIBDATLN+1,11      See if four byte unit address\n         BE    MODFOUR            Go process four byte unit address\n         BNE   BADDATA1           Invalid data, go display error\nMODTHREE DS    0H\n         CLI   CIBDATA+3,C','     See if three byte tape drive number\n         BNE   BADDATA2           Invalid data, go display error\n         MVI   UNIT,C'0'          Add leading zero to unit address\n         MVC   UNIT+1(3),CIBDATA  Move in rest of unit address\n         MVC   VOLSER,CIBDATA+4   Move volser for processing\n         B     UCBFIND            Go find UCB for tape drive\n*\nMODFOUR  DS    0H\n         CLI   CIBDATA+4,C','     See if four byte tape drive number\n         BNE   BADDATA3           Invalid data, go display error\n         MVC   UNIT,CIBDATA       Move in the unit address\n         MVC   VOLSER,CIBDATA+5   Move volser for processing\nUCBFIND  DS    0H\n         OC    UNIT,UPCASE        Upper case the tape address\n         OC    VOLSER,UPCASE      Upper case the volume serial number\n         TR    UNIT,BINTABLE-192  Translate display hex to real hex\n         PACK  DWORK(3),UNIT(5)   Translate display hex to real hex\n         SLR   R6,R6              Clear work register\n         ICM   R6,B'0011',DWORK   Load tape device address\n         MODESET MODE=SUP         Switch to supevisor mode for IOSLOOK\n         AL    R13,F8             IOSLOOK uses strange save area\n         IOSLOOK DEV=(6),UCB=(7)  Use device address to find UCB addr.\n         SL    R13,F8             IOSLOOK uses strange save area\n* R15 will have the return code of zero or four\n         LR    R6,R15             Save IOSLOOK ret.code before MODESET\n         MODESET MODE=PROB        Switch back to problem state\n         LTR   R6,R6              Check the IOSLOOK return code\n         BNZ   UCBERROR           Go print error if IOSLOOK failed\n         WTO   'TAPE - IOSLOOK for UCB worked...',ROUTCDE=11\n* R7 contains the address of the UCB\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(10)  Free the Modify CIB\n         B     GOMOUNT            UCB and VOLSER found, go mount tape\n*        B     CIBFIND            Go find another CIB\n*\n* Wait for next Modify console command\nWAIT     DS    0H\n         L     R8,COMECBPT        Load address of COMM. ECB pointer\n         WAIT  ECB=(8)            Wait for a Modify or Stop\n         B     CIBFIND\n*\nDISPCIB  DS    0H\n         SLR   R8,R8              Clear a counter register\n         IC    R8,CIBLEN          Load number double words in CIB\n         LR    R7,R10             Load address of start of CIB\n         LA    R6,0               Set start of CIB address\n         MVC   DISPWTO,DISPDUM    Move WTO template to work area\nDISPCIB2 DS    0H\n         CVD   R6,DWORK           Convert binary displacement to dec.\n         UNPK  DISPWTO+8(3),DWORK+6(2) Put CIB displacement in WTO\n         MVC   DWORK(8),0(R7)     Move data to convert to display\n         OI    DISPWTO+10,X'F0'   Correct the sign\n         UNPK  DISPWTO+12(9),DWORK(5) Unpack first part of double word\n         MVI   DISPWTO+20,X'40'   Set extra byte to a space\n         UNPK  DISPWTO+21(9),DWORK+4(5) Unpack rest of double word\n         MVI   DISPWTO+29,X'4B'   Set extra byte to a resiod\n         TR    DISPWTO+12(8),HEXTABLE-240 Change X'FA'-'FF' to C'A'-'F'\n         TR    DISPWTO+21(8),HEXTABLE-240 Change X'FA'-'FF' to C'A'-'F'\n         WTO   MF=(E,DISPWTO)     Display the CIB data\n         LA    R6,8(,R6)          Bump to next displacement\n         LA    R7,8(,R7)          Bump to next displacement\n         BCTR  R8,0               Subtract number of doublewords to do\n         LTR   R8,R8              See if all double words displayed\n         BNZ   DISPCIB2           Go back to display next double word\n         BR    R9                 Return to main-line code\n*\nGOMOUNT  DS    0H\n         STCM  R7,B'0111',DEBUCB  Store UCB address in the DEB\n         MVC   MOUNT1,VOLSER      Complete file system name for mount\n         MVC   MOUNT3,VOLSER      Move in directory name for mount\n         MVC   MOUNT6,VOLSER      Move in vol ser for mount\n         CLI   MOUNT1,C'A'        Should file system name be tapeA?\n         BE    VOLFIN             If tapeA, file system resolved\n         CLI   MOUNT1,C'B'        Should file system name be tapeB?\n         BE    VOLFIN             If tapeB, file system resolved\n         MVI   MOUNT1,C'C'        Not tapeA or tapeB, set tapeC\nVOLFIN   DS 0H\n*\n* mount tape\n         XC    ECB,ECB            Clear left over garbage in ECB\n         MODESET KEY=ZERO         PSW Key 0 for EXCP with own DEB\n         WTO   'MODESET zero done',ROUTCDE=11\n         EXCP  IOB                Issue automountccw\n         WTO   'EXCP for IOB done',ROUTCDE=11\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    NOWAIT             Already posted, weird, tape may be\n* offline or something else to cause OS/390 to not have outstanding\n* I/O to the tape drive which allowed the mount to complete.\n         MODESET MODE=SUP         Switch to supervisor mode\n         L     R1,4(,R13)         Save old register 13 from IOSINTRP\n         IOSINTRP UCB=(R7)        Interrupt old tape I/O for new\n         MODESET MODE=PROB        Switch to problem state\n*        SYSx.MVS220.SOURCE(IEE3103D)\n*        SYS1.MODGEN(IOSINTRP)\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    NOWAIT             Posted because IOSINTRP cleared I/O\n         WTO   'WAIT for ECB started',ROUTCDE=11\n         WAIT  ECB=ECB            Wait for mount to complete\n         WTO   'WAIT for ECB done',ROUTCDE=11\nNOWAIT   DS    0H\n         MODESET KEY=NZERO        Switch back to non-key zero ( 8 )\n         WTO   'MODESET NZERO done',ROUTCDE=11\n         B     WAIT               Go back and wait for next modify\n*\nEOJ      DS    0H\n         WTO   'TAPE - STOP console command accepted',routcde=11\n         BAL   R9,DISPCIB         Perform display for STOP CIB\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(10)  Free the stop CIB\nEOJQUICK DS    0H\n         LA    R0,SAVESIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN RU,LV=(0),A=(1) Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nERRORDUP DS    0H\n         WTO   'TAPE - STC is already running, will exit',ROUTCDE=11\n         B     EOJQUICK           Exit ptogram quickly\n*\nUCBERROR DS    0H\n         WTO   'TAPE - UCB address not found by IOSLOOK',ROUTCDE=11\n         B     BADDATA            Go free the bad CIB\n*\nBADDATA1 DS    0H\n         WTO   'TAPE - Following CIB has bad data length',ROUTCDE=11\n         B     BADDATA            Go free the bad CIB\n*\nBADDATA2 DS    0H\n        WTO   'TAPE - Following CIB has no comma xxx,xxxxxx',ROUTCDE=11\n         B     BADDATA            Go free the bad CIB\n*\nBADDATA3 DS    0H\n       WTO   'TAPE - Following CIB has no comma xxxx,xxxxxx',ROUTCDE=11\n         WTO   'TAPE - or volume serial number is too long',ROUTCDE=11\n*        B     BADDATA            Go free the bad CIB\nBADDATA  DS    0H\n         BAL   R9,DISPCIB         Perform display for invalid data CIB\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(10)  Free the invalid Modify CIB\n         WTO   'Expected format is: F TAPE,ccu,volser',ROUTCDE=11\n         B     CIBFIND            Go find another CIB\n*\nBADUSER  DS    0H\n         WTO   'Sub-System TAPE found a bad CVTUSER area',ROUTCDE=11\n         WTO   'Scratch tape numbers cannot be determined',ROUTCDE=11\n         B     CIBFIND            Go check for another CIB\n*\nBADBITS  DS    0H\n         WTO   'Sub-System TAPE found a bad TAPEBITS area',ROUTCDE=11\n         WTO   'Scratch tape numbers cannot be determined',ROUTCDE=11\n         B     CIBFIND            Go check for another CIB\n*\n         DROP  R10                Don't need CIB addressibilty anymore\n         DROP  R11                Don't need COMM addressibilty anymore\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants and model control blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n         DS    0D                Align to a double word\n* QNAME    DC    CL8'ONE-STC '     ENQ major name\n*\n* The X'1' is the DSECT version number\nCCVTUSER DC    CL7'CVTUSER',XL1'1'  Constant to check CVTUSER\nCTAPEBIT DC    CL7'TAPEBIT',XL1'1'  Constant to check TAPEBIT\n*\nBINTABLE DC    XL64'0'            Display hex to hex table\n         ORG   BINTABLE+1        Set location counter to letters ABCDEF\n         DC    XL6'0A0B0C0D0E0F'  Constant for letters ABCDEF\n         ORG   ,                  Reset location counter\n         ORG   BINTABLE+48        Set location counter to digits 0-9\n         DC    XL10'00010203040506070809'  Set number values\n         ORG   ,                  Reset location counter\n*\nHEXTABLE DC    CL16'0123456789ABCDEF'  Display hex data trans. table\n*\n* The TAPETABL is used to find a byte with a free bit\n* and the first bit free within the byte with one TRT\n* instruction for each 256 bytes of the TAPEBITS table.\nTAPETABL DC    128X'80'           Tape bit table first 128 bytes\n         DC     64X'40'           Tape bit table first  64 bytes\n         DC     32X'20'           Tape bit table first  32 bytes\n         DC     16X'10'           Tape bit table first  16 bytes\n         DC      8X'08'           Tape bit table first   8 bytes\n         DC      4X'04'           Tape bit table first   4 bytes\n         DC      2X'02'           Tape bit table first   2 bytes\n         DC       X'01'           Tape bit table first   1 byte\n         DC       X'00'           Tape bit table first   1 byte\n*\nF8       DC    F'8'               Save area offset for IOSLOOK\n*\nDISPDUM  WTO   'CIB+000 XXXXXXXX XXXXXXXX.',ROUTCDE=11,MF=L\nDISPLEN  EQU   *-DISPDUM          Length of WTO\n*\nUPCASE   DC    XL6'404040404040'  Data to upper case unit and volser\n*\nDUMEXT   EXTRACT *-*,'S',FIELDS=(TIOT,COMM),MF=L  Model EXTRACT\nDUMLEN   EQU     *-DUMEXT         Calculate length of EXTRACT\n*\n* APPEND   DC    X'0B0E'          Dummy I/O appendage routine BSM 0,R14\n*\n* DEB template\n         DS    0D                 Insure alignment\nDDEBVT   DS    0XL20              Data Extent Appendage Vector Table\n         DC    A(PSARET-PSA)  0   I/O appendage end-of-extent\n         DC    A(PSARET-PSA)  4   I/O appendage Start I/O\n         DC    A(PSARET-PSA)  8   I/O appendage Pgm.Contl.Intr.\n         DC    A(PSARET-PSA) 12   I/O appendage Channel end\n         DC    A(PSARET-PSA) 16   I/O appendage Abnormal end\nDDEBPREF DS    0XL16              DEB Prefix table\n         DC    3A(0)       20     Reserved?\n         DC    XL1'06'     32     Number of double-words in DEB ( 06 )\n         DC    XL1'00'     33     Unknown Access method type\n         DC    H'0'        34     Offset in DEB table for this DEB\nDDEB     DS    0XL36\n         DC    A(0)        36     Address of TCB for this DCB\n         DC    AL1(4)      40     4 bytes in Acc.Meth.Dependent section\n         DC    AL3(0)      41     Address of next DEB in chain\n         DC    X'C0000000' 44     DEBDISP new data set\n         DC    XL1'30'     48     DEBOPATB Data set positioning leave\n         DC    AL3(0)      49     Addr.of first IOB in purge chain\n         DC    A(0)        52     Pointer to related request\n         DC    A(0)        56     Address of locate parameter list\n         DC    XL1'0F'     60     Indicate a DEB\nDDEBDCB  DC    AL3(*-*)    61     Address of DCB or ACB\n         DC    AL1(2)      64     Half-words in DEB dev.dependent sect.\nDDEBIOVT DC    AL3(*-*)    65     Addr. I/O app. vector table DEBVT\nDDEBDEV  DS    0XL4               Device dependent secion\n         DC    XL1'00'     68     Tape Modeset   ? X'D3' ?\nDDEBUCB  DC    AL3(*-*)    69     Address of UCB\n         DC    F'0'        72     ?\n         DC    F'0'        76     ?\n         DC    F'0'        80     ?\nDEBLEN   EQU   *-DDEBVT    84     Length of the DEB\n*\n* DCB template\nDDCB     DS    0D\n         DC    10F'0'             40 byte unused for EXCP foundation\n         DC    H'0'               TIOT offset\n         DC    B'11010000'        MACRF byte 1\n* DCBMRECP EQU   DCBBIT0        EXECUTE CHANNEL PROGRAM (EXCP) ---\n* DCBMRFE  EQU   DCBBIT1        FOUNDATION EXTENSION IS PRESENT (EXCP)\n* DCBMRCI  EQU   DCBBIT3        COMMON INTERFACE (EXCP)\n         DC    B'00001000'        MACRF byte 2\n* DCBMR5WD EQU   DCBBIT4        FIVE-WORD DEVICE INTERFACE (EXCP)\n         DC    A(*-*)             Will be the address of the DEB\n         DC    X'10000000'        OFLGS last I/O operation was a write\n*        DC    X'00000000'        OFLGS last I/O operation was read\n         DC    5F'0'              5 word EXCP device interface\nDCBLEN   EQU   *-DDCB             Length of the DCB\n*\n* IOB templates\nDIOB     DS    0D                 IOB to mount a tape\n         DC    XL4'42000000'  0   Command Chaining and nonsequential\n* IOBCMDCH EQU   X'40' -   COMMAND CHAINING USED IN CHANNEL PROGRAM\n* IOBUNREL EQU   X'02' -   IOB UNRELATED FLAG (I.E., NONSEQUENTIAL)\n         DC    XL1'7F'        4   Addr. of expected I/O completion code\nDIOBECB  DC    AL3(*-*)       5   Address of the ECB\n         DC    D'0'           8   Channel Status Word\nDIOBCCWA DC    A(*-*)        16   Address of the Channel Command Words\nDIOBDCB  DC    A(*-*)        20   Address of the Data Control Block\n         DC    A(0)          24   IOB Restart\n         DC    XL4'00010000' 28   Flags and counters\n*   Don't know what the bit means.  DEBE had it, so why not use it?\n         DC    D'0'          32   Seek address MBBCCHHR ? ? ? ?\nDIOBCCW  CCW   X'4B',*-*,X'20',L'DMOUNT  Mount tape CCW\nDIOBLEN  EQU   *-DIOB             Size of IOB template\n*\nDMOUNT   DC    CL21'/tape?/???/??????.aws'  Mount command\nMOUNTLEN EQU   *-DMOUNT           Length of mount command\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nECB      DS    F                  Event Control Block for mount\nECBPOST  EQU   X'40'              Indicator that ECB was posted\n*\nCLEARSIZ EQU   *-SAVEAREA\n*\n*\nDWORK    DS    D                  Double word work area\n*\nUNIT     DS    CL4                Tape drive unit address\n*\nTIOT     DS    F,D                TIOT word and COMM words\nCOMM     EQU   TIOT+4,8           Address of the Communication area\n*\nVOLSER   DS    CL6                Tape volume serial to mount\n*\nEXTRACT  DS    XL(DUMLEN)         EXTRACT list to get TIOT or COMM\n*\nDISPWTO  DS    XL(DISPLEN)        Display CIB WTO\n*\n         DS    0D                 Align the following DEB\nDEBVT    DS    5F                 Five words DEB vector table\nDEBPREF  DS    XL16               DEB Prefix table\nDEB      DS    XL(DEBLEN)         Data Extent Block\nDEBDCB   EQU   DEBVT+61,3         Address of DCB or ACB\nDEBIOVT  EQU   DEBVT+65,3         Addr. I/O app. vector table DDEBVT\nDEBUCB   EQU   DEBVT+69,3         Address of UCB\n*\n         DS    0D                 Align the following DCB\nDCB      DS    XL(DCBLEN)         Tape DCB\nDCBDEB   EQU   DCB+45,3           DEB address in the DCB\n*\n         DS    0D                 Align IOB to double word boundary\nIOB      DS    XL(DIOBLEN)        Input and Output Block\nIOBCSW   EQU   IOB+8,8            Channel Status Word\nIOBECB   EQU   IOB+5,3            Address of Event Control Block\nIOBCCWA  EQU   IOB+16,4           Address of Channel Command Words\nIOBDCB   EQU   IOB+20,4           Address of Data Control Block\nIOBCCW   EQU   IOB+40,8           Tape mount CCW\n*\nMOUNT    DS    XL(MOUNTLEN)       Mount command '/tape?/???/??????.aws'\nMOUNT1   EQU   MOUNT+5,1          Last byte of file-system name\nMOUNT3   EQU   MOUNT+7,3          First three bytes of tape VolSer\nMOUNT6   EQU   MOUNT+11,6         Tape VolSer\n*\nSAVESIZE EQU   *-SAVEAREA\n*\n*\n         COPY  CVTUSER            User DSECT from ????.SORC????\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n*          DS    XL12             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\n*\nTAPEBITS DSECT ,\n         COPY  TAPEBITS           Copy TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n* TAPESKIP DS    CL6              IEC512I tape vol ser to ignore\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              Displacement to return to zero\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* TAPEBIT0 EQU   X'80'            First tape within a byte\n* TAPEBIT1 EQU   X'40'            Second tape within a byte\n* TAPEBIT2 EQU   X'20'            Third tape within a byte\n* TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n         DCBD  DSORG=PS,DEVD=DA   Data Control Block DSECT IHADCB\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\nPSA      IHAPSA DSECT=YES         Prefix Storage Area\n*\nIEZCOM   DSECT ,\n         IEZCOM ,                 Communications area\n*\n* IEZIOB   DSECT ,\n*        IEZIOB ,                 Input/Output Block\n*\nCIBLIST  DSECT ,\n         IEZCIB ,                 Command Input Buffer\n*\nIOCSTUFF DSECT ,\n         IECDIOCM ,               I/O Communication area DSECT\n*\nTAPE     CSECT ,\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TAPE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPEBITS": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0c\\x00&\\x01\\x04\\x17O\\x01\\x06'o\\x16\\x04\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@\"", "ispf": {"version": "01.12", "flags": 0, "createdate": "2004-06-22T00:00:00", "modifydate": "2006-10-03T16:04:26", "lines": 17, "newlines": 17, "modlines": 0, "user": "SOMITCW"}, "text": "TAPEEYE  DS    D                  DSECT eye-catcher CL7'TAPEBIT',XL1'1'\nTAPEOLD  DS    A                  Addr of old TAPEBITS record to delete\n         DS    CL6                TAPESKIP moved to CVTUSER as XCVTSKIP\nTAPEDISP DS    XL2                Last TAPES byte that had a free bit\nTAPEHIGH DS    XL2                High-water-mark and soft pool limit\nTAPEUPD  DS    XL1                Tape bits updated, need writing\nTAPECHAR DS    CL1                First byte of tapes described next\nTAPES    DS    XL12500            Bits for 100,000 tapes ?00000-?99999\n* TAPEBIT0 EQU   X'80'              First tape within a byte\n* * TAPEBIT1 EQU X'40'              Second tape within a byte\n* TAPEBIT2 EQU   X'20'              Third tape within a byte\n* TAPEBIT3 EQU   X'10'              Fourth tape within a byte\n* TAPEBIT4 EQU   X'08'              Fifth tape within a byte\n* TAPEBIT5 EQU   X'04'              Sixth tape within a byte\n* TAPEBIT6 EQU   X'02'              Seventh tape within a byte\n* TAPEBIT7 EQU   X'01'              Eighth tape within a byte\nTAPELEN  EQU   *-TAPEEYE          Length of TAPEBITS data record\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEBLP": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00Q\\x01\\x01\\x14\\x9f\\x01\\t4\\x7f  \\x01\\xbc\\x00\\xed\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2001-05-29T00:00:00", "modifydate": "2009-12-13T20:20:51", "lines": 444, "newlines": 237, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPEBLP-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS TITLE 'TAPEBLP - - - Extracts tape label info for TAPE System'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    This tape reads control cards to determine which tapes to load\n*  data for.  Tapes requested have the the first three records read\n*  from each tape, which should be the VOL1, HDR1, and HDR2 labels.\n*  Data from the tape labels is added to the TAPES VOLUMES and\n*  DATASETS data sets.\n*\n*    One record is created for each tape and written to both data sets.\n*\n*     Sample JCL:\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPEBLPJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=SOMITCW,COND=(0,NE)\n* //TAPEBLP EXEC PGM=TAPEBLP\n* //STEPLIB  DD  DSN=????.LOAD????,DISP=SHR\n* TAPE01\n* TAPE03-TAPE08\n* TAPE12\n* TAPE37-TAPE44\n* TAPE86\n* //INPUT    DD  UNIT=(TAPE,,DEFER)\n* //VOLUMES  DD  DSN=ACCUMULATED.TAPE.VOLUMES,DISP=MOD,\n* //             RECFM=FB,LRECL=171,BLKSIZE=0\n* //DATASETS DD  DSN=ACCUMULATED.TAPE.DATASETS,DISP=MOD,\n* //             RECFM=FB,LRECL=171,BLKSIZE=0\n* //SYSUDUMP DD  SYSOUT=*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPEBLP  CSECT ,\nTAPEBLP  AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPEBLP  RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPEBLP.&SYSDATE..&SYSTIME'  Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPEBLP,R12        Give the assembler the new base\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n* OPEN\n         USING INFMJFCB,JFCB      Tell assembler of JFCB address\n         LA    R1,EXLST           Load address of the DCB exit list\n         STCM  R1,B'0111',INPUT+DCBEXLSA-IHADCB  Put EXLST addr. in DCB\n         LA    R1,JFCB            Load addr.for JOB File Control Block\n         ST    R1,EXLST           Store addr.for JOB File Control Block\n         MVI   EXLST,X'87'        Indicate last exit and JFCB\n         RDJFCB INPUT             Prime the JFCB\n         MVI   JFCBLTYP,JFCBLP    Indicate Label=(,BLP) ( APF Auth )\n         MVI   JFCBNVOL,X'1'      Indicate one volume serial\n         OI    JFCBFLG3,JFCDQDSP  Dequeue volume serial no. on dismount\nL        EQU   L'MOUNTDSN         Length of first of data set name\n         MVC   JFCBDSNM(L),MOUNTDSN  Put data set name in JFCB\n         MVI   JFCBDSNM+L+6,X'40' Clear rest of DSNAME area\n         MVC   JFCBDSNM+L+7(44-L+7),JFCBDSNM+L+6  Clear rest of DSNAME\n         OPEN  (SYSIN,INPUT)      Open the input control cards\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN  See if SYSIN opened\n         BZ    ABEND1A            If OPEN failed, go abend\n         OPEN  (VOLUMES,EXTEND)   Open first output FB data file\n         OPEN  (DATASETS,EXTEND)  Open last output FB data file\nGETSYSIN DS    0H\n         GET   SYSIN,VOLSERS      Get volume record\n         MVC   ABEND3M+16(13),VOLSERS  Save input volumes for error msg\n         CLI   VOLSERS+6,C'-'     See if a hyphen\n         BNE   READVOL            Not minus sign, only 1 volume serial\n         CLC   VOLSERS(6),VOLSERS+7  See if low volume serial first\n         BH    ABEND1B            First volume higher, go abend\nREADVOL  DS    0H\n         MVC   JFCBVOLS(6),VOLSERS  Store volser to read\n         MVC   JFCBDSNM+L(6),VOLSERS  Store volser to read in DSNAME\n         OI    JFCBTSDM,JFCVSL    Indicate Volume serial list changed\n* Clear input data area to spaces\n         MVI   INRECS,X'40'       Clear the input data area\n         MVC   INRECS+1(L'INRECS-1),INRECS  Clear the input data area\n* Clear output record area to spaces\n         MVI   RECORD,X'40'       Clear the output record area\n         MVC   RECORD+1(L'RECORD-1),RECORD Clear the output record area\n         OPEN  (INPUT,INPUT),TYPE=J  Open the input tape label\n         GET   INPUT,IN1          Get first tape label record\n         GET   INPUT,IN2          Get second tape label record\n* If 76 zeroes on HDR1 label, tape was never used\n         CLC   IN2+4(75),IN2+5    See if new tape\n         BNE   CHKASCII           Not new tape, go check for ASCII tape\n         MVC   CL@DATE+1(10),NEVRUSED  Put 'Never Used' as Create Date\n         B     NOHDR2             New tape, skip reading HDR2\nCHKASCII DS    0H\n         CLI   INRECS,X'56'       See if an ASCII VOL1 header\n         BE    ASCII              ASCII tape, skip reading HDR2\n         GET   INPUT,IN3          Get third tape label record\n* If DOS/VS or DOS/VSE tape, GET INPUT,IN3 will fall to EODAD=NOHDR2\nNOHDR2   DS    0H\n         CLI   INRECS,C'V'        See if an EBCDIC VOL1 header\n         BE    EBCDIC             A good tape label, go process\n         B     ABEND2             Not standard label, go abend\nASCII    DS    0H\n         MVC   ASCIIWTO+16(6),VOLSERS\nASCIIWTO WTO   'TAPEBLP xxxxxx is an ASCII tape, it will be processed',X\n               ROUTCDE=11\n         XLATE INRECS+1,159,TO=E  Translate label from ASCII to EBCDIC\n         MVC   CL@DATE+1(10),ASCTAPE  Set DATE to 'ASCII Tape'\n*        CLI   IN3,X'40'          See if ASCII data HDR2 was read\n*        BE    EBCDIC             Still EBCDIC space, skip XLATE\n*        XLATE IN3,80,TO=E        Translate label from ASCII to EBCDIC\nEBCDIC   DS    0H\n         CLOSE (INPUT,DISP)       Close and unload the input tape label\n* VOLSER\n         CLC   INVOL,VOLSERS      See if volume mounted was one called\n         BE    MOVEVOL            Mounted volume matches, go process\n         MVC   VOLWTO+21(6),VOLSERS  Display volume serial requested\n         MVC   VOLWTO+44(6),INVOL    Display volume serial mounted\n         MVC   VOLWTO2+21(6),INVOL   Display volume serial mounted\nVOLWTO   WTO   'TAPEBLP Tape xxxxxx called for, but yyyyyy mounted',   +\n               ROUTCDE=(1,11)\nVOLWTO2  WTO   'TAPEBLP Tape yyyyyy will be processed',ROUTCDE=(1,11)\n         MVC   CL@MM(6),VOLSERS   Set close-time as requested vol ser\n         MVC   CL@TH(3),EXTERNAL  Set close-time as requested vol ser\nMOVEVOL  DS    0H\n         MVC   VOLSER,INVOL       Move volume serial no. to output rec.\n* Tape create date as close date\n         CLI   INRECS,X'56'       See if an ASCII VOL1 header\n         BE    NOCREDT            Is ASCII, don't do ASCII date\n         CLC   INCRDATE+1(5),ZEROES  See if creation date ( new tape? )\n         BE    NOCREDT            No CREDT, leave output field blanks\n*                                 blank=19xx, 1=20xx, 2=21xx, etc.\n         CLI   INCRDATE,X'40'     See if years 1900 through 1999\n         BNE   MOVECR20           Not 19xx, go start year with 20\n         MVC   CL@DATE+1(2),C19   Move '19' for 1990 through 1999\n         B     MOVECRYR           Go finish the create/close date\nMOVECR20 DS    0H\n         MVC   CL@DATE+1(2),C20   Move '20' for 2000 through 2099\nMOVECRYR DS    0H\n         MVC   CL@DATE+3(2),INCRDATE+1 Move create year last two digits\n         MVI   CL@DATE+5,C'.'     Move create year last two digits\n         MVC   CL@DATE+6(3),INCRDATE+3  Move create day to close day\nNOCREDT  DS    0H\n* Tape create time\n*\n*  tape create time is not available and will be left blank\n*\n* File sequence number ( LABEL=(???,SL)\n         MVI   FILESEQN+5,C'1'    Move file sequence number output\n* Indicator is always 'O' for Output/created data set, i.e. not read\n         MVI   CODE+1,C'O'        Put output/create indicator in record\n* Expiration date\n         CLI   INRECS,X'56'       See if an ASCII VOL1 header\n         BE    PROCDSN            Is ASCII, don't do ASCII date\n         CLC   INEXDATE+1(5),ZEROES  See if any expiration date\n         BNE   ISEXPDT            Is EXPDT, go convert it\n         CLI   CL@DATE,X'F0'      See if a Close/Create date\n         BL    PROCDSN            No Create or expire date, don't move\n         MVC   EX@YEAR(9),CL@DATE No expire date, use create date\n         B     PROCDSN            Skip format of EXPDT\nISEXPDT  DS    0H\n*                                 blank=19xx, 1=20xx, 2=21xx, etc.\n         CLI   INEXDATE,X'40'     See if years 1900 through 1999 a\n         BNE   MOVEEX20           Not 19xx, go start year with 20\n         MVC   EX@YEAR+1(2),C19   Move '19' for 1990 through 1999\n         B     MOVEEXYR           Return to format remainder of EX@DATE\nMOVEEX20 DS    0H\n         MVC   EX@YEAR+1(2),C20   Move '20' for 2000 through 2099\nMOVEEXYR DS    0H\n         MVC   EX@YEAR+3(2),INEXDATE+1 Move expire year last two digits\n         MVI   EX@YEAR+5,C'.'     Move expire year last two digits\n         MVC   EX@YEAR+6(3),INEXDATE+3  Move expire day\n* Data set name\nPROCDSN  DS    0H\n         MVC   DSNAME(17),INDSN   Move DDNAME to output record\n* Volume Sequence Number\n         CLI   INVOLSEQ+3,X'40'   See if a Volume Sequence Number\n         BNH   NOVOLSEQ           No number, skip move\n         PACK  DWORK(3),INVOLSEQ  Pack the Volume Sequence Number\n         MVC   VOLSEQN,MASK4      Move EDit mask to output Vol.Seq.No.\n         ED    VOLSEQN,DWORK+1    Move Volume Sequence Number\nNOVOLSEQ DS    0H\n* Block count written on tape\n*\n*  tape block count is not available and will be left blank\n*  ( I'm not going to spin down a tape just to get a block count )\n*\n* See if a HDR2\n         CLI   IN3,C'H'           See if a header 2 record read\n         BNE   PUTS               No HDR2, skip DCB/JOB/STEP processing\n* Record Format\n         MVC   RECFM+1(1),INRECFM1  Move F, V, or U to RECFM\n         MVC   RECFM+4(1),INRECFM2  Move Carraige Control A, M, or ' '\n         CLI   INRECFM3,C'R'      See of both Blocked and Span./Stan.\n         BNE   RECFMMVC           Not 'R', go do normal move\n         MVI   RECFM+2,C'B'       Show RECFM as blocked\n         MVI   RECFM+3,C'S'       Show RECFM as Spanned or Standard\n         B     SQUISH             Go compress spaces out of RECFM\nRECFMMVC DS    0H\n         MVC   RECFM+2(1),INRECFM3  Move B, S, or a space\nSQUISH   DS    0H\n         CLI   RECFM+3,X'40'      See if RECFM third byte is a space\n         BNE   SQUISH2            Not blank, go check next byte\n         MVC   RECFM+3(2),RECFM+4 Remove the space\nSQUISH2  DS    0H\n         CLI   RECFM+2,X'40'      See if RECFM second byte is a space\n         BNE   SQUISH3            Not blank, go check next byte\n         MVC   RECFM+2(3),RECFM+3 Remove the space\nSQUISH3  DS    0H\n         CLI   RECFM+1,X'40'      See if RECFM first byte is a space\n         BNE   SQUISHX            Not blank, go to end of squish\n         MVC   RECFM+1(4),RECFM+2 Remove the space\nSQUISHX  DS    0H\n* Logical Record Length\n         PACK  DWORK(3),INLRECL   Pack the Logical Record Length\n         MVC   LRECL(6),MASK6     Move EDit mask to output LRECL\n         ED    LRECL(6),DWORK     EDit the LRECL to output record\n* Block Size\n         PACK  DWORK(3),INBLKSZ   Pack the Block Size\n         MVC   BLKSIZE(6),MASK6   Move EDit mask to output BLKSIZE\n         ED    BLKSIZE(6),DWORK    EDit the BLKSIZE to output record\n* JOB name\n         MVC   JOBNAME,INJOB      Move JOB name to output record\n* STEP name\n         MVC   STEPNAME,INSTEP    Move STEP name to output record\n*\n* The end\nPUTS     DS    0H\n         PUT   VOLUMES,RECORD     PUT an output record\n         PUT   DATASETS,RECORD    PUT an output record\n* Calculate the next volume serial number\n         CLI   VOLSERS+6,C'-'     See if a range of volumes specified\n         BNE   GETSYSIN           No range, go read next SYSIN record\n         CLC   VOLSERS(6),VOLSERS+7  See if at end of range\n         BNL   GETSYSIN           At end of range, go get next SYSIN\n         LA    R1,VOLSERS+6       Load addr. past last byte of volser\n         LA    R2,VOLSERS         Load address of first byte of volser\nCARRY    DS    0H\n         BCTR  R1,0               Back up one digit to previous char.\n         CR    R1,R2              See if before volume serial number\n         BL    ABEND3             Backed up too far, go abend\n         TM    0(R1),X'09'        See if hex 89,99,A9,B9,C9,D9,E9,or F9\n         BO    ENDSIN9            Is X'?9', go (clear and carry) or add\n         IC    R3,0(,R1)          Load the byte to update\n         LA    R3,1(,R3)          Increment volser\n         STC   R3,0(,R1)          Replace the byte that is updated\n         B     READVOL            Go to process calculated vol. serial\nENDSIN9  DS    0H\n         TM    0(R1),X'B9'        See if numeric ( X'F9' or X'B9' )\n         BO    NUMERIC            Is numeric, go zero and carry\n         TM    0(R1),X'99'        See if X'D9' or X'99' ( R or r )\n         BO    NOONE              No E1 or A1, go to set to E2 or A2\n         TM    0(R1),X'A9'        See if X'E9' or X'A9' ( Z or z )\n         BO    Z                  Is a Z, go to set to A or a and carry\n         IC    R3,0(,R1)          Load the byte to update\n         LA    R3,8(,R3)          Add 16 and subtract 8\n         STC   R3,0(,R1)          Replace the byte that is updated\n         B     READVOL            Go to process calculated vol. serial\nNOONE    DS    0H\n         NI    0(R1),X'E2'        Zero bits X'19' to go from R/r to S/s\n         OI    0(R1),X'A2'        Set to X'E2' or X'A2' ( S or s )\n         B     READVOL            Go to process calculated vol. serial\nZ        DS    0H\n         NI    0(R1),X'C1'        Set from Z or z to A or a\n         B     CARRY              Go add to previous character\nNUMERIC  DS    0H\n         NI    0(R1),X'F0'        Set digit to zero\n         B     CARRY              Go add to previous character\n*\n* The end\nEODAD    DS    0H\n         CLOSE VOLUMES            Close first output date file\n         CLOSE DATASETS           Close last output date file\n         CLOSE SYSIN              Close control card file\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\nABEND1A  DS    0H\n         WTO   'TAPEBLP SYSIN failed to OPEN.',ROUTCDE=11\n         B     ABEND1BX           Go do more messages and abend\n*\nABEND1B  DS    0H\n         WTO   'TAPEBLP SYSIN control card is invalid.',ROUTCDE=11\n         MVC   ABEND1BM+16(13),VOLSERS  Move bad data to display\nABEND1BM WTO   'TAPEBLP xxxxxx-yyyyyy is backwards.',ROUTCDE=11\nABEND1BX DS    0H\n         WTO   'TAPEBLP Valid control cards are needed.',ROUTCDE=11\n         WTO   'TAPEBLP Volume Serial number in 1-6 or',ROUTCDE=11\n         WTO   'TAPEBLP range in 1-6 and 8-13 with',ROUTCDE=11\n         WTO   'TAPEBLP a dash between.',ROUTCDE=11\n         WTO   'TAPEBLP Program abending without a dump.',ROUTCDE=11\n         ABEND 1                  Abend without a dump\n*\nABEND2   DS    0H\n         WTO   'TAPEBLP Can only process labeled tapes.',ROUTCDE=11\n         WTO   'TAPEBLP First record doesn''t start VOL1.',ROUTCDE=11\n         WTO   'TAPEBLP Program abending with a dump.',ROUTCDE=11\n         ABEND 2,DUMP             Abend with a dump\n*\nABEND3   DS    0H\n         WTO   'TAPEBLP Volume serial greater than 999999.',ROUTCDE=11\nABEND3M  WTO   'TAPEBLP xxxxxx-yyyyyy is invalid.',ROUTCDE=11\n         WTO   'TAPEBLP Program abending with a dump.',ROUTCDE=11\n         ABEND 3,DUMP             Abend with a dump\n*\n*\nC19      DC   CL2'19'             Constant for nineteen hundreds\nC20      DC   CL2'20'             Constant for years 2000 through 2099\nMASK4    DC   XL4'40202120'       EDit mask for Vol.Seq.Number\nMASK6    DC   XL6'402020202120'   EDit mask for LRECL and BLKSIZE\nASCTAPE  DC   CL10'ASCII Tape'    Constant for ASCII date\nZEROES   DC   CL5'00000'          Constant to compare\nMOUNTDSN DC   CL11'MOUNT TAPE='   Constant to set JFCB data set name\nNEVRUSED DC   CL10'Never Used'    Constant create date if tape empty\nEXTERNAL DC   CL3'Ext'            Wrong volume indicator\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nCLEARSIZ EQU   *-SAVEAREA\n         SPACE 1\nDWORK    DS    D                  CVD work area\n*\nINRECS   DS    0CL240             Input record area\nIN1      DS    CL80               VOL1 label\nIN2      DS    CL80               HDR1 label\nIN3      DS    CL80               HDR2 label if any\nINVOL    EQU   INRECS+004,06,C'C' Input volume serial number\n* HDR1 follows\nINDSN    EQU   INRECS+084,17,C'C' Input data set name\nINVOLSEQ EQU   INRECS+107,04,C'C' Vol Seq. Number  ( 4 )\n* IN?    EQU   INRECS+111,04,C'C' File Seq. Number ( 4 ) Always 1\nINCRDATE EQU   INRECS+121,06,C'C' Input creation date\nINEXDATE EQU   INRECS+127,06,C'C' Input expiration date\n* Optional HDR2 follows\nINRECFM1 EQU   INRECS+164,01,C'C' RECFM F, V, or U ( 1 )\nINBLKSZ  EQU   INRECS+165,05,C'C' Input block size\nINLRECL  EQU   INRECS+170,05,C'C' LRECL            ( 5 )\nINJOB    EQU   INRECS+177,08,C'C' Input JOB name\nINSTEP   EQU   INRECS+186,08,C'C' Input JOB-STEP name\nINRECFM2 EQU   INRECS+196,01,C'C' A, M, or ' ' CC  ( 1 )\nINRECFM3 EQU   INRECS+198,01,C'C' B, S, R, or ' '  ( 1 ) R=B+S\n*\n         SPACE 1\n         COPY  TAPEDSCT           VOLUMES and DATASETS record layout\n* RECORD   DS  0CL171\n* VOLSER   DS  CL6    '??????'    Volume serial number\n* CL@DATE  DS  CL9   ' YYYY.DDD'  Date that tape was closed, YYYY.DDD\n* CL@HH    DS  CL3    ' HH'       Hour of day that tape was closed\n* CL@MM    DS  CL3    ':MM'       Minute of hour that tape was closed\n* CL@SS    DS  CL3    ':SS'       Second of minute that tape was closed\n* CL@TH    DS  CL3    '.TH'       Hundredth of second tape was closed\n* FILESEQN DS  CL6    ' nnnnn'    File sequence number\n* CODE     DS  CL2    ' O'  ' I'  Output or Input entry indicator code\n* EX@YEAR  DS  CL5    ' yyyy'     Tape expire year\n* EX@PER   DS  CL1    '.'         Period, separates EX@YEAR from EX@DAY\n* EX@DAY   DS  CL3    'ddd'       Tape expire day\n* SCRDATE  DS  CL9    ' yyyy.ddd' Date the tape is put on Scratch list\n*          DS  CL1    ' '         Space\n* DSNAME   DS  CL44               Data set name\n* VOLSEQN  DS  CL4    ' nnn'      Volume sequence number\n* BLKCOUNT DS  CL10   ' zzzzzzzzn'  Block count on the tape\n* RECFM    DS  CL5    ' FBSA'     Record format of data set\n* LRECL    DS  CL7    ' zzzznK'   Logical record length of data set\n* BLKSIZE  DS  CL6    ' zzzzn'    Block size of data set\n*          DS  CL1    ' '         Space\n* SYSTEM   DS  CL4                SMF ID for the system name\n*          DS  CL1    ' '         Space\n* JOBNAME  DS  CL8                JOB name\n*          DS  CL1    ' '         Space\n* STEPNAME DS  CL8                Step name\n*          DS  CL1    ' '         Space\n* PGMNAME  DS  CL8                Program name\n*          DS  CL1    ' '         Space\n* DDNAME   DS  CL8                DDNAME\n*\nVOLSERS  DS    CL80               SYSIN input area\n         SPACE 1\nEXLST    DS    0F,XL1,XL3         Exit List X'87',AL3(JFCB)\nJFCB     DS    XL176              JOB File Control Block\n         SPACE 1\nWORKSIZE EQU   *-SAVEAREA\n         SPACE 1\n         DCBD  DSORG=PS,DEVD=DA   Map the Data Control Block\n         SPACE 1\n         IEFJFCBN LIST=YES        Map the JOB File Control Block\n         SPACE 1\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPEBLP  CSECT ,\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=EODAD,             +\n               RECFM=FB,LRECL=80\nINPUT    DCB   DDNAME=INPUT,DSORG=PS,MACRF=GM,EODAD=NOHDR2,            +\n               RECFM=F,LRECL=80,BLKSIZE=80,EXLST=EXLST-EXLST\nVOLUMES  DCB   DDNAME=VOLUMES,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\nDATASETS DCB   DDNAME=DATASETS,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   SETCODE AC(1)\n   NAME TAPEBLP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEDRPD": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00X\\x01\\x01\\x14?\\x01\\t4\\x7f!B\\x00\\xd4\\x00\\xd6\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-05-23T00:00:00", "modifydate": "2009-12-13T21:42:58", "lines": 212, "newlines": 214, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPEDRPD-SOMITCW,         JOB02723\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS TITLE 'TAPEDRPD - - Drops records already on COMBINED DATASETS ds'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program reads a sorted copy of the active tapes DATASETS\n*  data set along with the COMBINED DATASETS data set.  Any record\n*  that is in the sorted copy of the regional DATASETS data set\n*  but is not in the COMBINED DATASETS data set are copied to\n*  replace the regional DATASETS data set.  Records that have been\n*  copied to and exist in the COMBINED DATASETS data set are not\n*  copied, so they are dropped from regional DATASETS data set.\n*\n*     Sample JCL:\n*\n* //*\n* //* TAPEDRPV drops records in the regional VOLUMES data sets that\n* //* have been copied to the COMBINED VOLUMES data set.  It\n* //* copies the regional VOLUMES data set to a backup data set\n* //* dropping any records with the same volser, close dates&time,\n* //* indicator code, and expire dates.  This JOB then compares\n* //* the COMBINED VOLUMES data sets to only copy records to the\n* //* regional VOLUMES data set that have NOT already been moved\n* //* to the COMBINED VOLUMES data sets.\n* //*\n* //* VOLUMES data set processing is first half of following JCL\n* //*\n* //VOLSORT EXEC PGM=SORT,RD=R\n* //SYSOUT   DD  SYSOUT=*\n*  SORT FIELDS=(1,171,CH,A)  Sort entire record\n*  SUM FIELDS=(1,44)         Drops records duplicated in columns 1-44\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),\n* //*            DSN=????.TAPES.????????.VOLSUM(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //*\n* //DROPVOL EXEC PGM=TAPEDRPV,RD=R\n* //REGIONAL DD  DISP=SHR,DSN=????.TAPES.????????.VOLSUM(+1)  Compared\n* //COMBINED DD  DISP=SHR,DSN=????.TAPES.COMBINED.VOLUMES     Compared\n* //REPLACE  DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES     Replaced\n* //*\n* //* DATASETS data set processing follows\n* //*\n* //DSSORT  EXEC PGM=SORT,RD=R\n* //SYSOUT   DD  SYSOUT=*\n*  SORT FIELDS=(1,171,CH,A)  Sort entire record\n*  SUM FIELDS=(1,44)         Drops records duplicated in columns 1-44\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.DATASETS\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),\n* //             DSN=????.TAPES.????????.DS-SUM(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //*\n* //DROPDS  EXEC PGM=TAPEDRPD,RD=R\n* //REGIONAL DD  DISP=SHR,DSN=????.TAPES.????????.DS-SUM(+1)  Compared\n* //COMBINED DD  DISP=SHR,DSN=????.TAPES.COMBINED.DATASETS    Compared\n* //REPLACE  DD  DISP=OLD,DSN=????.TAPES.????????.DATASETS    Replaced\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPEDRPD CSECT ,\nTAPEDRPD AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPEDRPD RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPEDRPD.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPEDRPD,R12       Give the assembler the new base\n* Initialize\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13       Tell assembler that R13 is save area\n* OPEN\n         OPEN  (REGIONAL,INPUT)   Open the local sorted input file\n         GET   REGIONAL           Get the first record for this LPAR\n         LR    R11,R1             Save the first record address\n         OPEN  (COMBINED,INPUT)   Open the COMBINED sorted input file\n         GET   COMBINED           Get the first record for all LPARs\n         LR    R10,R1             Save the first record address\n         OPEN  (REPLACE,OUTPUT)   Open the rewrite output FB data file\n         CLI   0(R11),X'40'       See if any volser\n         BH    COMPARE            Is a volser, must not be header\n         PUT   REPLACE,(R11)      Is not volser, write the header\n         GET   REGIONAL           Get another REGIONAL record\n         LR    R11,R1             Save the first record address\n* Main loop follows\nCOMPARE  DS    0H\n         CLC   0(33,R11),0(R10)   See if a duplicate Vol, Date, F.Seq.\n         BL    WRITE              Not duplicate, go copy\n         BE    GETREG             Duplicate, skip copy, get next REG.\n*        BH    GETCOMB            REGIONAL vol too high, get next COMB.\nGETCOMB  DS    0H\n         GET   COMBINED           Get COMBINED until REGIONAL is equal\n         LR    R10,R1             Save the record address\n         B     COMPARE            Go get the next volume input record\nWRITE    DS    0H\n         PUT   REPLACE,(R11)      Put the current REGIONAL record\n*        B     GETREG             Go get the next volume input record\nGETREG   DS    0H\n         GET   REGIONAL           Get REGIONAL until COMBINED is equal\n         LR    R11,R1             Save the record address\n         B     COMPARE            Go get the next volume input record\n* End-Of-Data routines follow\nEODCOMB  DS    0H\n         TM    REPLACE+DCBOFLGS-IHADCB,DCBOFOPN  Insure output opened\n         BZ    ABEND1             Abend because COMBINED was empty\nPUTLOOP  DS    0H\n         PUT   REPLACE,(R11)      Put the current REGIONAL record\n         GET   REGIONAL           Get next record or take EODAD exit\n         LR    R11,R1             Save the first record address\n         B     PUTLOOP            Return to write the new record\nEODREG   DS    0H\n         TM    REPLACE+DCBOFLGS-IHADCB,DCBOFOPN  Insure output opened\n         BZ    ABEND2             Abend because REGIONAL was empty\n         CLOSE REPLACE            Close the OUTPUT data set\n         CLOSE REGIONAL           Close the regional data set\n         CLOSE COMBINED           Close the combined data set\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* Abend routines follow\nABEND1   DS   0H\n         WTO  'COMBINED input data set is empty',ROUTCDE=11\n         B    ABEND               Go abend\nABEND2   DS   0H\n         WTO  'REGIONAL input data set is empty',ROUTCDE=11\n*        B    ABEND               Go abend\nABEND    DS   0H\n         WTO  'TAPEDRPD will abend',ROUTCDE=11\n         WTO  'The output data set was not opened',ROUTCDE=11\n         ABEND 1                  Abend without a dump\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LTORG ,                  If any literals, put them here\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nREGIONAL DCB   DDNAME=REGIONAL,DSORG=PS,MACRF=GL,EODAD=EODREG,         +\n               RECFM=FB,LRECL=171\nCOMBINED DCB   DDNAME=COMBINED,DSORG=PS,MACRF=GL,EODAD=EODCOMB,        +\n               RECFM=FB,LRECL=171\nREPLACE  DCB   DDNAME=REPLACE,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nCLEARSIZ EQU   *-SAVEAREA\nWORKSIZE EQU   *-SAVEAREA\n         SPACE 1\n         DCBD  DSORG=PS,DEVD=DA   DCB mapping Dsect IHADCB\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TAPEDRPD(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEDRPV": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00H\\x01\\x01\\x13O\\x01\\t4\\x7f!C\\x00\\xd7\\x00\\xcf\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2001-05-14T00:00:00", "modifydate": "2009-12-13T21:43:48", "lines": 215, "newlines": 207, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPEDRPV-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS TITLE 'TAPEDRPV - - Drops records that are on COMBINED VOLUMES DS'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program reads a sorted copy of the active tapes VOLUMES\n*  data set along with the COMBINED VOLUMES data set.  Any record\n*  that is in the sorted copy of the regional data set that is not\n*  in the corresponding COMBINED are copied to replace the VOLUMES\n*  data set.  Records that have been copied to and exist in the\n*  COMBINED data set is not copied, so they are dropped from\n*  regional data sets.\n*\n*     Sample JCL:\n*\n* //*\n* //* TAPEDRPV drops records in the VOLUMES data sets that have been\n* //* copied to the COMBINED data sets.  It copies the regional data\n* //* set to a backup data set, then copies it back dropping any\n* //* records with the same volser, and an equal or higher create date.\n* //*\n* //* This JOB then compares the COMBINED VOLUMES data set to only\n* //* copy records to the regional data sets that have NOT already\n* //* been moved to the COMBINED data sets.\n* //*\n* //* VOLUMES data set processing is first half of following JCL\n* //*\n* //VOLSORT EXEC PGM=SORT,RD=R\n* //SYSOUT   DD  SYSOUT=*\n*  SORT FIELDS=(1,171,CH,A)  Sort entire record\n*  SUM FIELDS=(1,44)         Drops records duplicated in columns 1-44\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),\n* //*            DSN=????.TAPES.????????.VOLSUM(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //*\n* //VOLDROP EXEC PGM=TAPEDRPV,RD=R\n* //REGIONAL DD  DISP=SHR,DSN=????.TAPES.????????.VOLSUM(+1)  Compared\n* //COMBINED DD  DISP=SHR,DSN=????.TAPES.COMBINED.VOLUMES     Compared\n* //REPLACE  DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES     Replaced\n* //*\n* //* DATASETS data set processing follows\n* //*\n* //DSSORT  EXEC PGM=SORT,RD=R\n* //SYSOUT   DD  SYSOUT=*\n*  SORT FIELDS=(1,171,CH,A)  Sort entire record\n*  SUM FIELDS=(1,44)         Drops records duplicated in columns 1-44\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.DATASETS\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),\n* //             DSN=????.TAPES.????????.DS-SUM(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n* //*\n* //DSDROP  EXEC PGM=TAPEDRPV,RD=R\n* //REGIONAL DD  DISP=SHR,DSN=????.TAPES.????????.DS-SUM(+1)  Compared\n* //COMBINED DD  DISP=SHR,DSN=????.TAPES.COMBINED.DATASETS    Compared\n* //REPLACE  DD  DISP=OLD,DSN=????.TAPES.????????.DATASETS    Replaced\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPEDRPV CSECT ,\nTAPEDRPV AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPEDRPV RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPEDRPV.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPEDRPV,R12       Give the assembler the new base\n* Initialize\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13       Tell assembler that R13 is save area\n* OPEN\n         OPEN  (REGIONAL,INPUT)   Open the local sorted input file\n         GET   REGIONAL           Get the first record for this LPAR\n         LR    R11,R1             Save the first record address\n         OPEN  (COMBINED,INPUT)   Open the COMBINED sorted input file\n         GET   COMBINED           Get the first record for all LPARs\n         LR    R10,R1             Save the first record address\n         OPEN  (REPLACE,OUTPUT)   Open the rewrite output FB data file\n         CLI   0(R11),X'40'       See if any volser\n         BH    COMPAREV           Is a volser, must not be header\n         PUT   REPLACE,(R11)      Is not volser, write the header\n         GET   REGIONAL           Get another REGIONAL record\n         LR    R11,R1             Save the first record address\n* Main loop follows\nCOMPAREV DS    0H\n         CLC   0(6,R11),0(R10)    See if same volume serial number\n         BH    GETCOMB            REGIONAL vol too high, get next COMB.\n         BL    WRITE              Less than COMBINED, go copy\n*        BE    COMPARED           Duplicate VOL, go check date of Vol.\nCOMPARED DS    0H\n         CLC   7(26,R11),7(R10)   See if a duplicate Date and File Seq.\n         BNH   GETREG             Same or lower date, skip copy\n*        BH    GETCOMB            REGIONAL date higher, get next COMB.\nGETCOMB  DS    0H\n         GET   COMBINED           Get COMBINED until REGIONAL is equal\n         LR    R10,R1             Save the record address\n         B     COMPAREV           Go compare next volume input record\nWRITE    DS    0H\n         PUT   REPLACE,(R11)      Put the current REGIONAL record\nGETREG   DS    0H\n         GET   REGIONAL           Get next record or take EODAD exit\n         LR    R11,R1             Save the first record address\n         B     COMPAREV           Go compare next volume input record\n* End-Of-Data routines follow\nEODCOMB  DS    0H\n         TM    REPLACE+DCBOFLGS-IHADCB,DCBOFOPN  Insure output opened\n         BZ    ABEND1             Abend because COMBINED was empty\nPUTLOOP  DS    0H\n         PUT   REPLACE,(R11)      Put the current REGIONAL record\n         GET   REGIONAL           Get next record or take EODAD exit\n         LR    R11,R1             Save the first record address\n         B     PUTLOOP            Return to write the new record\nEODREG   DS    0H\n         TM    REPLACE+DCBOFLGS-IHADCB,DCBOFOPN  Insure output opened\n         BZ    ABEND2             Abend because REGIONAL was empty\n         CLOSE REPLACE            Close the OUTPUT data set\n         CLOSE REGIONAL           Close the regional data set\n         CLOSE COMBINED           Close the combined data set\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* Abend routines follow\nABEND1   DS   0H\n         WTO  'COMBINED input data set is empty',ROUTCDE=11\n         B    ABEND               Go abend\nABEND2   DS   0H\n         WTO  'REGIONAL input data set is empty',ROUTCDE=11\n*        B    ABEND               Go abend\nABEND    DS   0H\n         WTO  'TAPEDRPV will abend',ROUTCDE=11\n         WTO  'The output data set was not opened',ROUTCDE=11\n         ABEND 1                  Abend without a dump\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LTORG ,                  If any literals, put them here\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nREGIONAL DCB   DDNAME=REGIONAL,DSORG=PS,MACRF=GL,EODAD=EODREG,         +\n               RECFM=FB,LRECL=171\nCOMBINED DCB   DDNAME=COMBINED,DSORG=PS,MACRF=GL,EODAD=EODCOMB,        +\n               RECFM=FB,LRECL=171\nREPLACE  DCB   DDNAME=REPLACE,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nCLEARSIZ EQU   *-SAVEAREA\nWORKSIZE EQU   *-SAVEAREA\n         SPACE 1\n         DCBD  DSORG=PS,DEVD=DA   DCB mapping Dsect IHADCB\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TAPEDRPV(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEDSCT": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x04\\x15?\\x01\\x04\\x15?\\x13B\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-01T00:00:00", "modifydate": "2004-06-01T13:42:44", "lines": 30, "newlines": 30, "modlines": 0, "user": "SOMITCW"}, "text": "RECORD   DS    0CL171\nVOLSER   DS    CL6    '??????'    Volume serial number\nCL@DATE  DS    CL9   ' YYYY.DDD'  Date that tape was closed, YYYY.DDD\nCL@HH    DS    CL3    ' HH'       Hour of day that tape was closed\nCL@MM    DS    CL3    ':MM'       Minute of hour that tape was closed\nCL@SS    DS    CL3    ':SS'       Second of minute that tape was closed\nCL@TH    DS    CL3    '.TH'       Hundredth of second tape was closed\nFILESEQN DS    CL6    ' nnnnn'    File sequence number\nCODE     DS    CL2    ' O'  ' I'  Output or Input entry indicator code\nEX@YEAR  DS    CL5    ' yyyy'     Tape expire year\nEX@PER   DS    CL1    '.'         Period, separates EX@YEAR from EX@DAY\nEX@DAY   DS    CL3    'ddd'       Tape expire day\nSCRDATE  DS    CL9    ' yyyy.ddd' Date the tape is put on Scratch list\n         DS    CL1    ' '         Space\nDSNAME   DS    CL44               Data set name\nVOLSEQN  DS    CL4    ' nnn'      Volume sequence number\nBLKCOUNT DS    CL10   ' zzzzzzzzn'  Block count on the tape\nRECFM    DS    CL5    ' FBSA'     Record format of data set\nLRECL    DS    CL7    ' zzzznK'   Logical record length of data set\nBLKSIZE  DS    CL6    ' zzzzn'    Block size of data set\n         DS    CL1    ' '         Space\nSYSTEM   DS    CL4                SMF ID for the system name\n         DS    CL1    ' '         Space\nJOBNAME  DS    CL8                JOB name\n         DS    CL1    ' '         Space\nSTEPNAME DS    CL8                Step name\n         DS    CL1    ' '         Space\nPGMNAME  DS    CL8                Program name\n         DS    CL1    ' '         Space\nDDNAME   DS    CL8                DDNAME\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPENEW": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x14\\x01\\x04\\x17O\\x01\\t4\\x7f E\\x00\\xc8\\x01\\x9c\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2004-06-22T00:00:00", "modifydate": "2009-12-13T20:45:14", "lines": 200, "newlines": 412, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPENEW-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//             PARM.L=RENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'TAPENEW - - - Creates a new tape bit pattern scratch file'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program reads a PARM and writes one record\n*  to disk that is a bit pattern of the tapes in use\n*  and scratch tapes.  Program TAPESAVE can be used to\n*  switch from a different range of vol sers to this\n*  range but will not switch from a range to itself.\n*  The record has a 24 byte header and 12500 bytes\n*  that represents 100,000 tapes.\n*  ( 100,000Tapes / 8BitsPerByte = 12500Bytes )\n*\n*     After TAPESAVE loads a TAPEBITS record in memory,\n*  IGCMSGEX picks scratch tapes by selecting \"0\" bits\n*  and changes the bits to \"1\" bits to indicate that\n*  a tape has been written to.\n*     TAPESYNC can update the tapes in use or not in use bits.\n*     TAPESYN2 can update the tapes in use or not in use bits.\n*     TAPESAVE will update the record by copying the memory\n*  TAPEBITS to disk every minute that there is a change.\n*     TAPERSET can set the next tape group to be used and a\n*  high-water-mark ( soft limit ) for pool size.\n*\n*     Change log:\n*\n* 2006-10-03  Changed TAPEHIGH to start at zero instead of 124.\n*   W.A.M.    TAPEHIGH is the tape number high-water-mark and\n*             soft-limit for the tape pool.\n*\n*     Sample JCL:\n*\n* //JOB JOB JOB,JOB JOB\n* //TAPENEW EXEC PGM=TAPENEW,PARM=C  for volsers C00000 through C99999\n* //TAPEDATA DD  DISP=(,CATLG,DELETE),DSN=SYS1.TAPES.C00000.C99999,\n* //             SPACE=(TRK,1),VOL=REF=SYS1.PARMLIB\n* //* will be DSORG=PS, RECFM=F, LRECL=12524, and BLKSIZE=12524\n*\n*     Blame: somitcw@comcast.net\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nCLEARSIZ EQU   *-SAVEAREA\n*\nOPENLIST DS    F                  OPEN/CLOSE parameter list\n*\n         DS    0D                 Align the following DCB\nTAPEDATA DS    XL(DCBLEN)         TAPEDATA DCB\n*\nTAPEBITS DS    0D                 Record to write to disk\n         COPY  TAPEBITS           Copy TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n* TAPESKIP DS    CL6              IEC512I tape vol ser to ignore\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              High-water-mark aka soft pool limit\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* TAPEBIT0 EQU   X'80'            First tape within a byte\n* TAPEBIT1 EQU   X'40'            Second tape within a byte\n* TAPEBIT2 EQU   X'20'            Third tape within a byte\n* TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\nSAVELEN  EQU   *-SAVEAREA    Length of SAVEAREA\n*\n*\nTAPENEW  CSECT ,\nTAPENEW  AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPENEW  RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPENEW.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPENEW,R12        Give the assembler the new base\n         ICM   R2,B'1111',0(R1)   Load the PARM address\n         BZ    NOPARM             If no PARM address, go abend\n         CLI   1(R2),X'1'         See if PARM is exactly one byte\n         BNE   BADPARM            PARM more or less than 1 byte, abend\n         IC    R2,2(,R2)          Load PARM data byte\n         L     R0,FSAVELEN        Load work area size for GETMAIN\n         GETMAIN RU,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n*    Build the output record\n         XC    TAPEEYE(TAPES-TAPEEYE),TAPEEYE  Clear TAPEBITS header\n         MVC   TAPEEYE,CTAPEBIT   Move in TAPEBITS eye catcher\n         STC   R2,TAPECHAR        1st byte of tape volume serial number\n* Gone   MVI   TAPEHIGH+1,1000/8-1  Set soft top tape number\n* When TAPEHIGH is reached, TAPEDISP is set back to zero\n         LA    R2,TAPES           Load address of the bit pattern\n         L     R3,FTAPELEN        Load the length of tape bit pattern\n         SLR   R4,R4              Clear MVCL input location\n         LA    R5,X'00'           Load the MVCL pad character\n* X'00' indicates eight scratch tapes.\n* Tapes start as scratch tapes.\n* X'FF' would indicate all eight tapes are in use.\n         SLL   R5,24              Place pad char. and clear length\n         MVCL  R2,R4              Fill the bit pattern with X'00'\n         MVC   TAPEDATA,DUMDCB    Copy DCB template\n*    Open TAPEDATA DCB\n         MVI   OPENLIST,X'80'     Set OPEN/CLOSE parm to open one DCB\n         OPEN  (TAPEDATA,OUTPUT),MF=(E,OPENLIST)  Open TAPEDATA DCB\n         PUT   TAPEDATA,TAPEBITS  Write the record\n*\nEOJ      DS    0H\n         MVI   OPENLIST,X'80'     Set only one DCB to CLOSE\n         CLOSE TAPEDATA,MF=(E,OPENLIST) Close a TAPEDATA DCB\n         L     R0,FSAVELEN        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN RU,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nNOPARM   DS    0H\nBADPARM  DS    0H\n         WTO   'TAPENEW requires a one byte tape volume prefix PARM',  C\n               ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants and model control blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* The X'1' is the DSECT version number\nCTAPEBIT DC    CL7'TAPEBIT',XL1'1' Constant to init and check TAPEBIT\n*\nFTAPELEN DC    A(L'TAPES)         Length of TAPE bit pattern\nFSAVELEN DC    A(SAVELEN)         Length of SAVEAREA DSECT in memory\n*\n*\nDUMDCB   DCB   DDNAME=TAPEDATA,   DDNAME of TAPEDATA                   C\n               DSORG=PS,          Data Set Organization                C\n               MACRF=PM,          MACRO reference                      C\n               BUFNO=1,           Only one buffer needed for the recordC\n               RECFM=F,           Fixed, unblocked record              C\n               LRECL=TAPELEN      Record is 12524 bytes\nDCBLEN   EQU   *-DUMDCB           Length of the DCB\n*\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TAPENEW\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPENEWJ": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x02\\x01\\x04\\x17O\\x01\\x06%\\x8f\\x119\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-06-22T00:00:00", "modifydate": "2006-09-15T11:39:02", "lines": 8, "newlines": 8, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPENEW-SOMITCW,\n//             CLASS=x,MSGCLASS=x,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//TAPENEW EXEC PGM=TAPENEW,PARM=A  for volsers A00000 through A99999\n//TAPEDATA DD  DISP=(,CATLG,DELETE),DSN=SYS1.TAPES.A00000.A99999,\n//             SPACE=(TRK,1),VOL=REF=SYS1.PARMLIB\n//* will be DSORG=PS, RECFM=F, LRECL=12524, and BLKSIZE=12524\n//* Using SYS1. data set allows easy running of TAPESAVE as SUB=MSTR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEOFF": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x006\\x00\\x98&O\\x01\\x10\\x11O\\x13W\\x01\\xa8\\x00\\xd0\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "1998-09-21T00:00:00", "modifydate": "2010-04-24T13:57:36", "lines": 424, "newlines": 208, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999),TAPEOFF-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,PERFORM=??,COND=(0,NE)\n//HLASMCL EXEC PROC=HLASMCL\n//SYSLIB   DD  DISP=SHR DSN=SYS1.MACLIB ,UNIT=SYSDA ,VOL=SER=??????\n//         DD  DISP=SHR,DSN=SYS1.AMODGEN or SYS1.MODGEN\nPASS     TITLE 'TAPEOFF - Program to list offsite tapes.'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program function:\n*\n*        1. SYSIN statements with an asterisk in column one are\n*           not printed or processed.  i.e. An unprinted full\n*           line comment.\n*\n*        2. SYSIN statements with 'Comment:' in columns one through\n*           eight printed.  i.e. A printed 72 byte comment.\n*\n*        3. Other control cards from SYSIN, contain a data set\n*           name in columns 1 thru 44.  The data set name may\n*           have a relative or an absolute generation number.\n*           It does not have to be a generation data set.\n*           Example:\n*           BKUP.VSTOR02(-3) or BKUP.VPUB002.G____V00\n*           Relative and alias data set names are translated to\n*           absolute data set names during lookup and for print.\n*\n*        4. Comments in columns 45 through 72 on data set control\n*           cards are copied to the print line with the updated\n*           data set name.  i.e. The DSN altered control card is\n*           printed.  The feature is useful for supplying the disk\n*           unit address that is backed up to the tape.  Makes\n*           disaster recovery restore easier if an E-Mail copy of\n*           the report is sent after weekly disk volume back ups.\n*\n*        5. The volume information for the data set is then obtained\n*           from the catalog and the number of volumes containing\n*           the data set are checked.  If the data set resides on\n*           more than 20 volumes, a warning message is issued and\n*           this program abends.\n*\n*        6. The report can be printed or E-Mailed.\n*\n*        7. The report can be read by a Rexx or other script to\n*           extract tape volume serial numbers to create .bat,\n*           .rc, and sftp commands to copy tape images to offsite\n*           locations, USB drive, and SDLT tapes.\n*           Note: If using USB drives, use the ones that have an\n*           e-scsi connection on the other side.  They are much\n*           faster.\n*           Note2: Unless some limit has been set, no tape data\n*           data sets will span a tape volume.  i.e. There might\n*           not be anymore multiple tape volume data sets?\n*\n*           /* see if position 1 blank */\n*           IF SUBSTR(in.i,1,1) = ' ' THEN DO\n*             /* See if position 2 non-blank */\n*             IF SUBSTR(in.i,2,1) <> ' ' THEN DO\n*               vol = SUBSTR(in.i,2,6)\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*    Sample JCL:\n*\n* //TAPEOFF  JOB (????????,????,1439,9999),TAPEOFF-SOMITCW,\n* //         CLASS=?,MSGCLASS=?\n* //*\n* //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* //*\n* //* Lists and E-Mails list of disaster recovery tapes\n* //*\n* //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* //*\n* //TAPEOFF EXEC PGM=TAPEOFF\n* //SYSPRINT DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(TRK,(1,1))  FBA x 73\n* //SYSIN    DD  DISP=SHR,DSN=name?of?Data?Center.PARMLIB(TAPEOFF)\n* Comment: 3490=400-41F 3400=890 Console=080-081 non-SNA-CRT=082-087\n* Comment: OSA=B42-B43=127.123.231.234 CTCA=B00(CENTRAL)&D00(NORTHERN)\n* * Data set name for 44 bytes                  UNIT  3390\n* BKUP.VPAGE00(0)                              cuu=D00 -3 RETPD=31 Full\n* BKUP.VPAGE01(0)                              cuu=D01 -3 RETPD=31 Full\n* BKUP.VPAGE02(0)                              cuu=D02 -3 RETPD=31 Full\n* BKUP.VPAGE03(0)                              cuu=D03 -3 RETPD=31 Full\n* BKUP.VPAGE04(0)                              cuu=D04 -3 RETPD=31 Full\n* BKUP.VPAGE05(0)                              cuu=D05 -3 RETPD=31 Full\n* BKUP.VSYSRES(0)                              cuu=D06 -3 RETPD=31 Full\n* BKUP.VSYSCAT(0)                              cuu=D07 -3 RETPD=31 Full\n* BKUP.VSYSLIB(0)                              cuu=D08 -3 RETPD=31 Full\n* BKUP.VSPOOL9(0)                              cuu=D09 -3 RETPD=31 VTOC\n* BKUP.VSPOOLA(0)                              cuu=D0A -3 RETPD=31 VTOC\n* BKUP.VDB000B(0)                              cuu=D0B -3 RETPD=31 Full\n* BKUP.VDB000C(0)                              cuu=D0C -3 RETPD=31 Full\n* BKUP.VDB000D(0)                              cuu=D0D -3 RETPD=31 Full\n* BKUP.VDB000E(0)                              cuu=D0E -3 RETPD=31 Full\n* BKUP.VDB000F(0)                              cuu=D0F -3 RETPD=31 Full\n* BKUP.VCICS10(0)                              cuu=D10 -3 RETPD=31 AllD\n* * CICS Journal file extent should be dumped: ALLDATA(*.*.JOUR*.**)\n* BKUP.VCICS11(0)                              cuu=D11 -3 RETPD=31 Full\n* BKUP.VCICS12(0)                              cuu=D12 -3 RETPD=31 Full\n* BKUP.VCICS13(0)                              cuu=D13 -3 RETPD=31 Full\n* BKUP.VCICS14(0)                              cuu=D14 -3 RETPD=31 Full\n* BKUP.VCICS15(0)                              cuu=D15 -3 RETPD=31 Full\n* BKUP.VCICS16(0)                              cuu=D16 -3 RETPD=31 Full\n* BKUP.VCICS17(0)                              cuu=D17 -3 RETPD=31 Full\n* BKUP.VCICS18(0)                              cuu=D18 -3 RETPD=31 Full\n* BKUP.VIMS019(0)                              cuu=D19 -3 RETPD=31 Full\n* BKUP.VIMS01A(0)                              cuu=D1A -3 RETPD=31 Full\n* BKUP.VIMS01B(0)                              cuu=D1B -3 RETPD=31 Full\n* BKUP.VIMS01C(0)                              cuu=D1C -3 RETPD=31 Full\n* BKUP.VIMS01D(0)                              cuu=D1D -3 RETPD=31 Full\n* BKUP.VIMS01E(0)                              cuu=D1E -3 RETPD=31 Full\n* BKUP.VIMS01F(0)                              cuu=D1F -3 RETPD=31 Full\n* BKUP.VSTOR20(0)                              cuu=D20 -9 RETPD=31 Full\n* BKUP.VSTOR21(0)                              cuu=D21 -9 RETPD=31 Full\n* BKUP.VSTOR22(0)                              cuu=D22 -9 RETPD=31 Full\n* BKUP.VSTOR23(0)                              cuu=D23 -9 RETPD=31 Full\n* BKUP.VSTOR24(0)                              cuu=D24 -9 RETPD=31 Full\n* BKUP.VSTOR25(0)                              cuu=D25 -9 RETPD=31 Full\n* BKUP.VSTOR26(0)                              cuu=D26 -9 RETPD=31 Full\n* BKUP.VPUBD27(0)                              cuu=D27 -9 RETPD=31 Full\n* BKUP.VPUBD28(0)                              cuu=D28 -9 RETPD=31 Full\n* BKUP.VPUBD29(0)                              cuu=D29 -9 RETPD=31 Full\n* BKUP.VPUBD2A(0)                              cuu=D2A -9 RETPD=31 Full\n* BKUP.VPUBD2B(0)                              cuu=D2B -9 RETPD=31 Full\n* BKUP.VPUBD2C(0)                              cuu=D2C -9 RETPD=31 Full\n* BKUP.VPUBD2D(0)                              cuu=D2D -9 RETPD=31 Full\n* BKUP.VSPAREE(0)                              cuu=D2E -9 RETPD=31 Full\n* BKUP.VSPAREF(0)                              cuu=D2F -9 RETPD=31 Full\n* //SYSUDUMP DD  SYSOUT=*\n* //*\n* //*\n* //PRINT   EXEC PGM=IEBGENER  Print TAPEOFF report to SPOOL\n* //SYSPRINT DD  SYSOUT=*\n* //SYSIN    DD  DUMMY\n* //SYSUT1   DD  DISP=(SHR,PASS),DSN=*.TAPEOFF.SYSPRINT\n* //SYSUT2   DD  SYSOUT=(*,,REPT)\n* //*\n* //EMAIL   EXEC PGM=IKJEFT1B  E-Mail DSNs, disk CCCU, tape volsers\n* //SYSTSPRT DD  SYSOUT=*\n* //SYSTSIN  DD  *\n*\n*  XMITIP SOMITCW@YAHOO.com +\n*  FROM SOMITCW@DATA.CENTER.com +\n*  REPLYTO SOMITCW@YAHOO.com +\n*  SUBJECT '&cdate DataCenter TAPEOFF report' +\n*  MSGT 'See attached report for DataCenter disaster recovery.' +\n*  FORMAT TXT/txt +\n*  FILEDD REPORT +\n*  FILEDESC DataCenter_TAPEOFF_Disaster_Recovery_Report +\n*  FILENAME TAPEOFF.&cdate.Data.Center.txt\n*\n* //SYSPROC  DD  DISP=SHR,DSN=????.XMITIP.EXEC\n* //REPORT   DD  DISP=(SHR,DELETE),DSN=*.TAPEOFF.SYSPRINT\n* //\n*\n*\n*    Date updated: 2010-01-22 W.A.M.\n*        Allowed full line \"Comment:\" statements.\n*        Changed output print file from LRECL=80 to LRECL=73\n*\n*    Date updated: 2009-12-13 W.A.M.\n*        Allowed asterisk in column 1 to be an ignored comment.\n*        Comment statement will not print nor be processed.\n*\n*    Date updated: 2009-12-05 W.A.M.\n*        Print 1-72 of control card instead of 1-44 to allow comments.\n*\n*    Date written: 1998-9-21\n*\n*    Blame: somitcw@yahoo.com\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         PRINT GEN\nTAPEOFF  CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPEOFF.&SYSDATE..&SYSTIME' Save reg.s\n         LA    R12,SAVEAREA       Load the address of the new save area\n         ST    R12,8(,R13)        Connect old and new save areas\n         ST    R13,4(,R12)        Connect old and new save areas\n         LR    R13,R12            Connect old and new save areas\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPEOFF,R12        Give the assembler the new base\n         OPEN  (SYSIN,,SYSPRINT,OUTPUT) OPEN the files\n         LA    R7,999             Indicate page full ( to get header )\n         L     R1,16              Load address of CVT\n         USING CVT,R1             Tell assembler where CVT address is\n         MVC   SSSSSSSS,CVTSNAME  Move system name to print header\n         DROP  R1\n*\nGETLOOP  DS    0H\n         GET   SYSIN              Read a card image\n         LR    R11,R1             Copy address of the input record\n         USING RECORD,R11         Tell assembler where record is\n         CLI   RECORD,C'*'        See if a comment record\n         BE    GETLOOP            Is comment, go back to skip procesing\n         MVC   COMMENTU,RECORD    Copy possible comment indicator\n         OC    COMMENTU,SPACES    Upper-case possible comment indicator\n         CLC   COMMENTU,COMMENT   See if a comment to print\n         BNE   LOCATE             Not a print comment, go look up DSN\n         MVC   DSNLINE+1(72),RECORD  Copy comment line for print\n         LA    R7,2(,R7)          Double space line-per-page counter\n         C     R7,FIFTY6          See if page is already full\n         BH    NEWPAGE1           Over 56 lines, go start new page\nGETLOOP2 DS    0H\n         PUT   SYSPRINT,DSNLINE   Print a full line comment\n         B     GETLOOP            Go get next SYSIN record\nLOCATE   DS    0H\n         ST    R11,LOCLIST+4      Store input record address in CAMLST\n         LOCATE LOCLIST           Read a catalog entry\n         LTR   R15,R15            See if zero return code\n         BNE   LOCATERR           If not zero, write error msg\n         MVC   DSNLINE+1(72),RECORD  Copy dsname and comment for print\n         LA    R7,2(,R7)          Double space line-per-page counter\n         C     R7,FIFTY6          See if page is already full\n         BH    NEWPAGE2           Over 56 lines, go start new page\nGETLOOP3 DS    0H\n         PUT   SYSPRINT,DSNLINE   Print the data set name\n         LH    R5,LOCAREA         Load volume count for data set\n         C     R5,=F'20'          More than 20 volser's?\n         BNH   COPYVOLS           No - continue processing data set\n         B     VOL20ERR           If high, write error message, abend\nCOPYVOLS DS    0H\n         LA    R6,LOCAREA+6       Load current colser pointer\n         LA    R8,VOLLINE+L'VOLLINE-1  Find end of vol ser print area\nCOPYVOL2 DS    0H\n         MVI   VOLLINE,C' '       Space out vol ser print line\n         MVC   VOLLINE+1(72),VOLLINE  Space out vol ser print line\n         LA    R4,VOLLINE+1       Load address of vol ser print area\nCOPYLOOP DS    0H\n         CR    R4,R8              Will vol ser fit on print line?\n         BH    NEWLINE            No - Go print line, and start one\n         MVC   0(6,R4),0(R6)      Copy vol ser to print line\n         LA    R4,8(,R4)          Bump up current table entry pointer\n         LA    R6,12(,R6)         Bump up current volser pointer\n         S     R5,=F'1'           Sub 1 from table entry avail ctr\n         BP    COPYLOOP           If not last volser - go to loadloop\n         LA    R7,1(,R7)          Single space line-per-page counter\n         PUT   SYSPRINT,VOLLINE   Print volumes for data set\n         B     GETLOOP            Go get next data set\n*\nEOF      DS    0H\n         CLOSE (SYSIN,,SYSPRINT)  CLOSE the files\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         RETURN (14,12),,RC=0     Return to caller\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Sub-routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nNEWPAGE1 DS    0H\n         BAL   R9,NEWPAGE         Perform printing page heading\n         B     GETLOOP2           Return to print full comment line\n*\nNEWPAGE2 DS    0H\n         BAL   R9,NEWPAGE         Perform printing page heading\n         B     GETLOOP3           Return to print data set name line\n*\nNEWPAGE  DS    0H\n         TIME  DEC                Get current time and date\n         ST    R0,TIME            Save the time in HHMMSSTH format\n         UNPK  WORK(7),TIME       Unpack the time as HHMMSST\n         MVC   HH,WORK            Move the hour\n         MVC   MM,WORK+2          Move the minute\n         MVC   SS,WORK+4          Move the second\n         ST    R1,DATE            Save the date in 0CYYDDDF format\n         AP    DATE,P1900000      Add 1900.000 to the century indicator\n         OI    DATE+3,X'0F'       Correct the sign for printing\n         UNPK  WORK(7),DATE       Unpack the date as CCYYDDD\n         MVC   YYYY,WORK          Move the year\n         MVC   DDD,WORK+4         Move the day number of the year\n         AP    PAGENUM,ONE        Find new page number\n         UNPK  PPP,PAGENUM        Put page number in page heading\n         OI    PPP+2,X'F0'        Fix the page number sign\n         PUT   SYSPRINT,PAGETOP   Go to top of new page\n         PUT   SYSPRINT,HEADER    Write the page heading\n         SLR   R7,R7              Clear the line number counter\n         BR    R9                 Return to NEWPAGE1 or NEWPAGE2\n*\nNEWLINE  DS    0H\n         LA    R7,1(,R7)          Single space line-per-page counter\n         PUT   SYSPRINT,VOLLINE   Load volume count for data set\n         B     COPYVOL2           Return to print next vol ser line\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Error Routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nLOCATERR DS    0H\n         MVC   DSNLINE+1(72),RECORD  Copy dsname and comment for print\n         PUT   SYSPRINT,DSNLINE   Print the data set name\n         WTO   'LOCATE Failed, TAPEOFF program Abending...',ROUTCDE=11\n         ABEND 123,DUMP\n*\nVOL20ERR DS    0H\n         WTO   'Maximum of 20 tapes for a data set..',ROUTCDE=11\n         WTO   'TAPEOFF program abending..',ROUTCDE=11\n         ABEND 321,DUMP\n*\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nONE      DC    P'1'               To increment page number\nSPACES   DC    CL8' '             Constant to upper-case for compare\nCOMMENT  DC    CL8'COMMENT:'      Constant to identify comments\nP1900000 DC    PL4'1900000'       Constant to convert date to Y2K\nFIFTY6   DC    A(56)              Number of lines per page\nPAGETOP  DC    CL73'1 '           Top of page\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Workarea\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nWORK     DS    D                  Double word work area\nSAVEAREA DC    18F'0'             Register save area\n*\nPAGENUM  DC    PL2'0'             Current page number\nCOMMENTU DS    CL8                Upper-cased input CL8'Comment:'\nDATE     DS    F                  Hold area for CCYYDDDF date\nTIME     DS    F                  Hold area for HHMMSSTH time\n*\nLOCLIST  CAMLST NAME,*-*,,LOCAREA   Locate data set parameter list\n*\nLOCAREA  DS    0D\n         DS    265C               Area to receive catalog information\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Report Data Area\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nHEADER   DC    CL43'  hostsite Off Site Tapes by Data Set Name '\n         DC    CL30'  hh:mm:ss ccyy-ddd   Page nnn'\nSSSSSSSS EQU   HEADER+2,8         Label for Host name in the header\nHH       EQU   HEADER+45,2        Label for the hour in the header\nMM       EQU   HEADER+48,2        Label for the minute in the header\nSS       EQU   HEADER+51,2        Label for the second in the header\nYYYY     EQU   HEADER+54,4        Label for the year in the header\nDDD      EQU   HEADER+59,3        Label for day-of-year in the header\nPPP      EQU   HEADER+70,3        Label for the page number in header\n\nDSNLINE  DC    CL73'0 '           Data set name to print\n* DSNLINE is also used for full line comments\nVOLLINE  DC    CL73'  '           Vol sers to print\n\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Data Control Blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nSYSIN    DCB   DDNAME=SYSIN,                                           *\n               MACRF=GL,                                               *\n               RECFM=FB,                                               *\n               LRECL=80,                                               *\n               DSORG=PS,                                               *\n               EODAD=EOF\n*\nSYSPRINT DCB   DDNAME=SYSPRINT,                                        *\n               MACRF=PM,                                               *\n               RECFM=FBA,                                              *\n               LRECL=73,                                               *\n               DSORG=PS\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Literal Pool\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         LTORG ,\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\nRECORD   DSECT ,                  Input record\n         DS    CL80               Input record\n*\n         CVT   DSECT=YES          Dsect for Communication Vector Table\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE= , , , , , ,\n//* * * * * UNIT=SYSDA,VOL=SER=------\n   NAME TAPEOFF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPEOFFC": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x12\\x01\\x041\\x7f\\x01\\t4\\x7f T\\x00B\\x00=\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-11-12T00:00:00", "modifydate": "2009-12-13T20:54:12", "lines": 66, "newlines": 61, "modlines": 0, "user": "SOMITCW"}, "text": "        /* Rexx EXEC TAPEOFF to read the TAPEOFF ( tape offsite )\n           report and create an MS-DOS .bat file and SCO UnixWare\n           scripts.\n\n           .bat files are never used.  There are better ways to\n           scratch tapes.  DDNAME BAT should be dummied out.\n\n           The .bat file is to create empty .aws tape images\n           to replace scratched tapes.  DDNAME BAT should be\n           dummied out.\n\n           The .cp script is to copy tapes for off site data\n           transmission.\n\n           .bat file records look like:\n       hetinit -d C01234.aws C01234 ?.?.?.?.\n           with one record for each tape image.\n\n          .cp has a header record that looks like:\n       echo 'About to copy ????/???? tapes'; date\n\n          .cp has a trailer record that looks like:\n       echo 'All ????/???? tapes copied'; date\n\n          .cp has two records for each tape image like:\n       cp /tapeC/C01/C01234.aws /tapeA/offsite/C/C01234.aws\n       echo 'C01234 copied from /tapeC/C01 to /tapeA/offsite/C'\n                                                                 */\n\n\n        \"EXECIO * DISKR VOLS (FINIS STEM in.\"\n\n        cp.   = \"\"\n        cp.0  = 0\n        c     = 1\n        cp.c  = \"echo 'About to copy ????/???? tapes'; date\"\n        bat.  = \"\"\n        bat.0 = 0\n        b     = 0\n\n        DO i = 1 TO in.0\n\n          /* see if position 1 blank */\n          IF SUBSTR(in.i,1,1) = ' ' THEN DO\n            /* See if position 2 non-blank */\n            IF SUBSTR(in.i,2,1) <> ' ' THEN DO\n              vol = SUBSTR(in.i,2,6)\n              vo = SUBSTR(in.i,2,3)\n              v = SUBSTR(in.i,2,1)\n              c = c + 1\n  cp.c = \"cp /tape\"v\"/\"vo\"/\"vol\".aws /tapeA/offsite/\"v\"/\"vol\".aws\"\n              c = c + 1\n  cp.c = \"echo '\"vol \"copied from /tape\"v\"/\"vo\" to /tapeA/offsite/\"v\"'\"\n              b = b + 1\n              bat.b = 'hetinit -d' vol'.aws' vol '?.?.?.?.'\n            END\n          END\n        END\n\n          c = c + 1\n          cp.c  = \"echo 'All ????/???? tapes copied'; date\"\n          cp.0  = c\n        \"EXECIO * DISKW CP (FINIS STEM cp.\"\n          bat.0  = b\n        \"EXECIO * DISKW BAT (FINIS STEM bat.\"\n        EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPEOLD": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00B\\x01\\x01\\x12\\x8f\\x01\\t4\\x7f!Y\\x00\\xbb\\x00\\xbb\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-05-08T00:00:00", "modifydate": "2009-12-13T21:59:42", "lines": 187, "newlines": 187, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPEOLD-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,REGION=4M,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS TITLE 'TAPEOLD - - - Drops old record with same vol ser as new'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program reads a sorted copy of the active tapes VOLUMES\n*  data set.  The VOLUMES data set contains one record for each tape\n*  plus new records for tapes just written.  The volume records in\n*  the VOLUMES data set are from information for the first data set\n*  written on each tape.  Only the most current vol ser is kept.\n*  If two volume records have the same close date and close time,\n*  then the record with the highest indicator code is kept.\n*  The indicator code on each record shows the status of the record,\n*  record, either has or has not been scratched.\n* I = Record of a tape data set read for input ( not in this data set )\n* O = New output tape data set that has been written\n* S = is to be scratched ( Selected ) S honored after expiration date\n* X = If tape volume has appeared on a scratch list ( Scratched )\n*\n*     Sample JCL:\n*\n* //*\n* //* * * * * * Start of tape management\n* //*\n* //* TAPESMF extracts tape information from SMF data.\n* //* Tape vol sers starting TS are Tech. Support tapes.\n* //* Tape vol sers starting AS are Application Support FRS tapes.\n* //* Tape vol sers starting 008 and 009 are considered NVCC tapes.\n* //* Tapes written on file number one are added to both data sets.\n* //* All tape data sets accessed are added to the DATASETS data set.\n* //* A previous entry for each vol ser should normally already be\n* //* in the VOLUMES data set.\n* //*\n* //TAPESMF EXEC PGM=TAPESMF\n* //SMFIN    DD  DSN=BACKUP.SMFDUMPD,DISP=SHR\n* //* All input/output tapes\n* //DATASETS DD  DISP=MOD,DSN=????.TAPES.????????.DATASETS(+0)\n* //* New output tapes\n* //VOLUMES  DD  DISP=MOD,DSN=????.TAPES.????????.VOLUMES\n* //SYSUDUMP DD  SYSOUT=*\n* //*\n* //* Following sorts the VOLUMES tape file to drop old records\n* //* for tapes that have been written over.\n* //* After TAPEOLD runs, there will only be one record for\n* //* each file on each tape in the VOLUMES data set.\n* //*\n* //* Data sets are kept on shared disk volume ??????, so\n* //* all processing after TAPEOLD can be run on ????/????.\n* //*\n* //* First step 'SORT' inverts the accessed close date and time so\n* //* the most current record for each tape is kept.\n* //* If duplicate tape number with duplicate close date and time,\n* //* the highest indicator code is kept.\n* //*\n* //* Second step 'TAPEOLD' drops old tape records for tapes that\n* //* re-written.\n* //*\n* //SORTACT EXEC PGM=SORT,PARM='RC16=ABE',RD=R\n* //SYSOUT   DD  SYSOUT=*\n* *             VolSer   Created   Ind.-Code      EXPDT---D\n*  SORT FIELDS=(1,6,CH,A,8,23,CH,D,35,1,CH,D)    ,37,8,CH,D)\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),DSN=????.TAPES.????????.SORT(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(150,150),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //*\n* //TAPEOLD EXEC PGM=TAPEOLD\n* //SORTED   DD  DISP=SHR,DSN=????.TAPES.????????.SORT(+1) input\n* //VOLUMES  DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES replaced\n* //SYSUDUMP DD  SYSOUT=*\n* //*\n* //SORTHST EXEC PGM=SORT,PARM='RC16=ABE',RD=R\n* //SYSOUT   DD  SYSOUT=*\n* *     volser, close-date, close-time, File-seq-Number, indicator-code\n*  SORT FIELDS=(1,35,CH,A)\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.DATASETS(+0)\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),\n* //             DSN=????.TAPES.????????.DATASETS(+1),\n* //             VOL=REF=*.SORTIN,SPACE=(TRK,(150,150),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //*\n* //* * * * * * End of NVCC tape management\n* //*\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPEOLD  CSECT ,\nTAPEOLD  AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPEOLD  RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPEOLD.&SYSDATE..&SYSTIME'  Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPEOLD,R12        Give the assembler the new base\n* Initialize\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n         MVI   CURRVOL,X'FF'      Insure first vol ser compare works\n* OPEN\n         OPEN  (SORTED,INPUT)     Open the sorted input file\n         OPEN  (VOLUMES,OUTPUT)   Open the rewrite output FB data file\nGET      DS    0H\n         GET   SORTED             Get an sorted record( Address in R1 )\n         LR    R11,R1             Put address where it is safe\n         CLC   CURRVOL,0(R11)     See if a duplicate, but old vol ser\n         BE    GET                Is duplicate, do not copy\n         MVC   CURRVOL,0(R11)     Save the vol ser for the next compare\n         PUT   VOLUMES,(R11)      PUT most current unique volume record\n         B     GET                Go get the next volume input record\nEODAD    DS    0H\n         CLOSE VOLUMES            Close the output rewritten file\n         CLOSE SORTED             Close the sorted input data file\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LTORG ,                  If any literals, put them here\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSORTED   DCB   DDNAME=SORTED,DSORG=PS,MACRF=GL,EODAD=EODAD,RECFM=FB\nVOLUMES  DCB   DDNAME=VOLUMES,DSORG=PS,MACRF=PM,RECFM=FB\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nCLEARSIZ EQU   *-SAVEAREA\nCURRVOL  DC    XL6'FFFFFFFFFFFF'  To hold current volume serial number\n         SPACE 1\nWORKSIZE EQU   *-SAVEAREA\n         SPACE 1\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TAPEOLD(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEOLDJ": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x000\\x01\\x01\\x12\\x8f\\x01\\x06%\\x8f\\x11\\x06\\x00$\\x00$\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-05-08T00:00:00", "modifydate": "2006-09-15T11:06:30", "lines": 36, "newlines": 36, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPEOLDJ-SOMITCW,\n//             CLASS=x,MSGCLASS=x,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//*\n//* Following sorts the VOLUMES tape file to drop old records\n//* for tapes that have been written over.\n//* After TAPEOLD runs, there will only be one record for\n//* each file on each tape in the VOLUMES data set.\n//*\n//* Data sets are kept on shared disk volume ???VOL, so\n//* all processing after TAPEOLD can be run on LPAR#0002.\n//*\n//* First step 'SORT' inverts the accessed close date and time so\n//* the most current record for each tape is kept.\n//* If duplicate tape number with duplicate close date and time,\n//* the highest indicator code is kept.\n//*\n//* Second step 'TAPEOLD' drops old tape records for tapes that\n//* re-written on.\n//*\n//SORTACT EXEC PGM=SORT,PARM='RC16=ABE',RD=R\n//SYSOUT   DD  SYSOUT=*\n*             VolSer   Created   Ind.-Code      EXPDT---D\n SORT FIELDS=(1,6,CH,A,8,23,CH,D,35,1,CH,D)    ,37,8,CH,D)\n//SORTIN   DD  DISP=OLD,DSN=STOR.TAPES.LPAR#0002.VOLUMES\n//SORTOUT  DD  DISP=(,CATLG,DELETE),DSN=STOR.TAPES.LPAR#0002.SORT(+1),\n//             UNIT=SYSDA,SPACE=(TRK,(150,150),RLSE),\n//             DCB=$,RECFM=FB,LRECL=171\n//*\n//TAPEOLD EXEC PGM=TAPEOLD\n//SORTED   DD  DISP=SHR,DSN=STOR.TAPES.LPAR#0002.SORT(+1) input\n//VOLUMES  DD  DISP=OLD,DSN=STOR.TAPES.LPAR#0002.VOLUMES replaced\n//* VOLUMES  DD  DISP=(,CATLG),DCB=STOR.TAPES.COMBINED.VOLUMES,\n//*              DSN=STOR.TAPES.LPAR#0002.VOLUMES,    FBx171\n//*              UNIT=SYSDA,SPACE=(TRK,(75,75),RLSE)\n//SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPERSET": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x007\\x01\\x06(o\\x01\\x10\\x11O\\x157\\x01\\x15\\x01\\x0b\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2006-10-13T00:00:00", "modifydate": "2010-04-24T15:37:37", "lines": 277, "newlines": 267, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPERSET-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'TAPERSET - - - Updates TAPEBITS in memory to start at zero'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    If the tape pool expands because no TAPESYN2 or no\n*  TAPESYNC runs for a long time or other reason, running\n*  program will drop the current tape and high-water-mark\n*  back to the beginning or to numbers set.\n*  The tape pool high will expand again as tapes are used.\n*  Only the memory copy of TAPEBITS is updated,\n*  but TAPESAVE will write to disk.\n*\n*    I set the tape range to start at zero immediately\n* before the weekly SMF DUMP JOB writes the weekly SMF data\n* to tape.  That way I can expect a low number tape so high\n* numbered tapes will not be used when there is a long RETPD\n* like the weekly SMF DUMP tape.  I could also run TAPEZERO\n* or TAPESYN2 before or after TAPERSET to make more low\n* number tapes available, but that would be over-kill for me.\n*\n*     Change log:\n*\n* 2006-10-13 Added ability to use a PARM.\n*\n* 2006-10-03 Changed high-water-mark to be reset to zero instead\n*            of 124 ( tape x00999 ).\n*\n*     Sample JCL:\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPERSEJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=SOMITCW,COND=(0,NE)\n* //TAPERSET EXEC PGM=TAPERSET,  If no PARM, tape zero is assumed\n* //             PARM=(C00123,   Set current tape number to 123\n* //             C00999)         Set high-water tape number to 999\n* //*                            Tape numbers are rounded by eight\n* //* STEPLIB DD  DISP=SHR,DSN=an.apf.authorized.library\n* //SYSUDUMP DD  SYSOUT=*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPERSET CSECT ,\nTAPERSET AMODE 31                 Addressing mode of 31\nTAPERSET RMODE ANY                Residency mode of anywhere\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPERSET.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPERSET,R12       Give the assembler the new base\n         LA    R2,0(,R1)          Save PARM register, clear high byte\n         LA    R0,SAVESIZE        Load reg. save area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for reg. save area space\n         XC    0(SAVESIZE,R1),0(R1)  Clear register save area\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13       Give assembler register for DSECT\n*                                 Save area just for convention, no use\n* Find TAPEBITS\n         L     R11,16             Load the address of the CVT\n         USING CVT,R11            Give assembler the CVT mapping\n         L     R11,CVTUSER        Load the address of the CVT user area\n         USING XCVTUSER,R11       Give assembler the CVTUSER mapping\n         CLC   XCVTUEYE,CVTUSER1  See if the CVTUSER area is valid\n         BNE   NOCVTUSR           Area not valid, can't access TAPEBITS\n         L     R11,XCVTTAPE       Load TAPEBITS address\n         USING TAPEBITS,R11       Give assembler the TAPEBITS mapping\n         CLC   TAPEEYE,TAPEBIT1   See if the TAPEBITS area is valid\n         BNE   NOBITS             Area not valid, can't access TAPEBITS\n*\n* Initialize assumed current and high-water-mark vol number to set\n         MVC   VOLCURR,VOLINIT    Initialize current vol default\n         MVC   VOLHIGH,VOLINIT    Initialize high-water vol default\n         MVC   VOLWORK,VOLINIT    Initialize numeric check area\n*\n* Check if PARM and process\n         LTR   R2,R2              See of PARM list address is zero\n         BZ    UPDATE             Go set current and high tape to zero\n         L     R3,0(,R2)          Load address of the PARM\n         LTR   R3,R3              See of PARM address is zero\n         BZ    UPDATE             Go set current and high tape to zero\n         CLC   0(2,R3),H0         See if PARM length is zero\n         BZ    UPDATE             Go set current and high tape to zero\n         CLC   0(2,R3),H13        See if PARM a valid length\n         BNE   BADPARM1           Bad PARM length, go abend\n         CLC   TAPECHAR,2(R3)     See if current tape pool\n         BNE   BADPARM2           Not current pool, go abend\n         CLC   2(1,R3),9(R3)      See if both number in same pool\n         BNE   BADPARM2           Not same pool, go abend\n         MVZ   VOLWORK,3(R3)      See if current volser is numeric\n         CLC   VOLWORK,VOLINIT    See if current volser is numeric\n         BNE   BADPARM4           Volume serial not numeric, go abend\n         MVZ   VOLWORK,10(R3)     See if current volser is numeric\n         CLC   VOLWORK,VOLINIT    See if current volser is numeric\n         BNE   BADPARM3           Volume serial not numeric, go abend\n         MVC   VOLCURR,3(R3)      Copy new current tape number to work\n         MVC   VOLHIGH,10(R3)     Copy new high-water-mark to work\n*\n* Update TAPEBITS in memory\n*\nUPDATE   DS    0H\n         PACK  DWORK,VOLCURR      Pack new current vol ser number\n         CVB   R4,DWORK           Load vol ser in register\n         SRL   R4,3               Find new current vol displacement\n         PACK  DWORK,VOLHIGH      Pack new high vol ser number\n         CVB   R5,DWORK           Load vol ser in register\n         SRL   R5,3               Find new high vol displacement\n         CLR   R4,R5              See if high is equal or high\n         BH    BADPARM4           Current is higher than high, go abend\n         MODESET KEY=ZERO         Switch to key zero\n*        XC    TAPEBITS+12(6),TAPEBITS+12  Clear old TAPESKIP\n         STH   R4,TAPEDISP        Set new current tape number byte\n         STH   R5,TAPEHIGH        Set new high-water-mark/soft-limit\n         MVI   TAPEUPD,1          TAPESAVE will write TAPEBITS to disk\n         MODESET KEY=NZERO        Switch to key eight\n         LA    R0,SAVESIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nNOCVTUSR DS    0H\n         WTO  'TAPERSET - No CVTUSER area, program abending',ROUTCDE=11\n         ABEND 123                Abend without a dump\n*\nNOBITS   DS    0H\n         WTO 'TAPERSET - No TAPEBITS area, program abending',ROUTCDE=11\n         ABEND 234                Abend without a dump\n*\nBADPARM1 DS    0H\n         LH    R1,0(,R3)          Load bad PARM length\n         CVD   R1,DWORK           Convert binary number to packed dec.\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  BADWTO1+31(5),DWORK+5(3)  Put PARM length in WTO\nBADWTO1  WTO   'TAPERSET - PARM length xxxxx is invalid',ROUTCDE=11\n         B     ABEND345           Go abend for bad PARM\n*\nBADPARM2 DS    0H\n         WTO   'TAPERSET - PARM tape number not in pool',ROUTCDE=11\n         MVC   BADWTO2+36(1),TAPECHAR  Move first tape vol byte to WTO\nBADWTO2  WTO   'TAPERSET - Current pool is \"x\"',ROUTCDE=11\n         B     PARMIS             Go abend for bad PARM\n*\nBADPARM3 DS    0H\n         WTO   'TAPERSET - Vol sers not in correct format',ROUTCDE=11\n         WTO   'TAPERSET - Last 5 bytes must be numeric',ROUTCDE=11\n         B     PARMIS             Go abend for bad PARM\n*\nBADPARM4 DS    0H\n         WTO   'TAPERSET - Vol sers not correct values',ROUTCDE=11\n         WTO   'TAPERSET - Current is higher than high',ROUTCDE=11\n         WTO   'TAPERSET - Current should not be higher',ROUTCDE=11\n*        B     PARMIS             Go abend for bad PARM\nPARMIS   DS    0H\n         MVC   PARMWTO+32(13),2(R3)  Copy bad PARM to WTO\nPARMWTO  WTO   'TAPERSET - Bad PARM is: xxxxxx,xxxxxx',ROUTCDE=11\nABEND345 DS    0H                 Bad PARM abend\n         MVC   ABENDWTO+35(1),TAPECHAR Move first tape vol byte to WTO\n         MVC   ABENDWTO+42(1),TAPECHAR Move first tape vol byte to WTO\nABENDWTO WTO   'TAPERSET - Format is PARM=(x00123,x00999)',ROUTCDE=11\n         WTO   'TAPERSET - First is new current tape vol',ROUTCDE=11\n         WTO   'TAPERSET - Second is new high-water-mark',ROUTCDE=11\n         WTO   'TAPERSET - Program abending',ROUTCDE=11\n         ABEND 345                Abend without a dump\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0D                 Align Constants area\n*\n* The X'1' is the DSECT version number\nCVTUSER1 DC    CL7'CVTUSER',XL1'1'  Constant to check CVTUSER\nTAPEBIT1 DC    CL7'TAPEBIT',XL1'1'  Constant to check TAPEBIT\n*\nVOLINIT  DC    CL5'00000'         Assumed current and high vol to set\n*\nH0       DC    H'0'               Constant for compare\nH13      DC    H'13'              Constant for compare\n*\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nDWORK    DS    D                  Double word work area\nVOLCURR  DS    CL5                Current vol ser to set\nVOLHIGH  DS    CL5                Tape pool high-water-mark to set\nVOLWORK  DS    CL5                Area to check for numeric\nSAVESIZE EQU   *-SAVEAREA\n*\n         COPY CVTUSER             Copy the CVTUSER area DSECT\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* * TAPESKIP DS    CL6            TAPESKIP was old name for XCVTSKIP\n* XCVTSKIP DS    CL6              IEC512I tape vol ser to ignore\n*          DS    XL22             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\nTAPEBITS   DSECT ,\n           COPY  TAPEBITS         Copy the TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n*          DS    CL6              TAPESKIP moved to CVTUSER as XCVTSKIP\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              High-water-mark aka soft tape limit\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* * TAPEBIT0 EQU   X'80'            First tape within a byte\n* * * TAPEBIT1 EQU  X'40'           Second tape within a byte, dup.name\n* * TAPEBIT2 EQU   X'20'            Third tape within a byte\n* * TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* * TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* * TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* * TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* * TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Register Equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   SETCODE AC(1)\n   NAME TAPERSET\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPERSTJ": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x06(o\\x01\\x07\\x00\\x8f!U\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2006-10-13T00:00:00", "modifydate": "2007-01-08T21:55:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPERSTJ-SOMITCW,\n//             CLASS=x,MSGCLASS=x,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//TAPERSET EXEC PGM=TAPERSET,  If no PARM, tape zero is assumed\n//             PARM=(A00047,   Set current tape number to 40-47\n//             A00495)         Set high-water tape number to 488-495\n//*                            Tape numbers are rounded by eight\n//* STEPLIB DD  DISP=SHR,DSN=an.apf.authorized.library\n//SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPESAVE": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00\\x19\\x01\\x04\\x16\\x9f\\x01\\t4\\x7f!F\\x01\\xb1\\x01c\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2004-06-17T00:00:00", "modifydate": "2009-12-13T21:46:19", "lines": 433, "newlines": 355, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPESAVE-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//             PARM.L='RENT,AC=1'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'TAPESAVE - - - Load and saves scratch tape bit pattern'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program reads a binary bit pattern record\n*  that indicates which tape volumes are available\n*  scratch tapes.  If the record is already in the SQA\n*  for the volume range, the copy in the SQA is used.\n*  If no record is in the SQA for the volume range,\n*  this program will copy the record to the SQA and\n*  eventually delete any old records.\n*\n*  The record is kept in the SQA for other JOBs to pick\n*  scratch tapes or mark inuse tapes as scratch tapes.\n*  Exit IGXMSGEX picks scratch tapes and marks the SQA\n*  tape indicator as \"tape in use\" and program TAPESYNC\n*  marks SQA tape indicators as scratch again.\n*  To change from one scratch pool to another, just\n*  change the JCL to the new data set name, stop this\n*  program, and restart it.  The new tape bits will be\n*  read into SQA and the old one will be FREEMAINed in\n*  a minute or longer.  DDNAME is TAPEDATA.\n*\n*  This program then wakes up every minute and if the SQA\n*  record has been updated, it is written out to disk to\n*  overlay the disk copy.\n*\n*  Blame: somitcw@yahoo.com\n*\n*  Sample JCL:\n*\n* //TAPESAVE EXEC PGM=TAPESAVE,TIME=1439\n* //TAPEDATA DD  DISP=OLD,DSN=SYS1.TAPES.C00000.C99999\n* //* For testing, run as a JOB or STC with a\n* //* //SYSUDUMP DD SYSOUT=* DD statement.\n* //* SUBSYS of MSTR cannot have SYSOUT=anything\n*\n*  Sample start command:\n*\n* START TAPESAVE,SUB=MSTR\n* For SUB=MSTR, the data set must be in the master catalog.\n*\n*  Sample stop command:\n*\n* STOP TAPESAVE\n* STOP TAPESAVE may take a minute.\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESAVE CSECT ,\nTAPESAVE AMODE 24                 Addressing mode of 24 for EXCP\nTAPESAVE RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPESAVE.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPESAVE,R12       Give the assembler the new base\n         LA    R0,SAVESIZE        Load work area size for GETMAIN\n         GETMAIN RU,LV=(0)        Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n*    GETMAIN memory to read block.\n         GETMAIN RU,LOC=BELOW,LV=TAPELEN   Get 12524 byte TAPEBITS area\n         LR    R11,R1             Save address to read into\n*        USING TAPEBITS,R11       Indicate address of temp. TAPEBITS\n*    Fill in EXTRACT, DCB, IOB, and CCW fields\n         MVC   EXTRACT(DUMLEN),DUMEXT  Move EXTRACT MACRO list\n         EXTRACT COMM,'S',FIELDS=(COMM),MF=(E,EXTRACT)  Get COMM\n         MVC   TAPEDATA(DUMMYLEN),DUMMY   Copy DCB/IOB/SEEK template\n         LA    R1,ECB             Load address of the Event Control Blk\n         ST    R1,IOBECBA         Store ECB address in Input/Output Blk\n         LA    R1,CCWIN           Load address of Channel Command Words\n         ST    R1,IOBCCWA         Store read CCW address in IOB\n         STCM  R1,B'0111',INTIC   Store input TIC to address\n         LA    R1,SEARCH          Load Search-id-equal disk address\n         STCM  R1,B'0111',INSEARCH Store input CCHHR search address\n         STCM  R1,B'0111',OUTSRCH Store output CCHHR search address\n         STCM  R11,B'0111',INDATA Store input buffer address\n*    Open TAPEDATA DCB\n         MVI   OPENLIST,X'80'     Set OPEN/CLOSE parm to open one DCB\n         OPEN  (TAPEDATA,UPDAT),MF=(E,OPENLIST)  Open TAPEDATA DCB\n*    Fill in SEEK fields\n         LA    R1,TAPEDATA        Load address of the TAPEDATA DCB\n         ST    R1,IOBDCBA         Store addr of the TAPEDATA DCB in IOB\n         USING IHADCB,R1          Tie DCB with DCB DSECT with R1\n         L     R1,DCBDEBAD        Load address of Data Extent Block\n         DROP  R1                 R1 has IEZDEB address now\n         MVC   CCHH,38(R1)        Move Cylinder-Head from DEBSTRCC&HH\n         MVI   R,X'1'             Set record number to search and read\n*    Read block\n         EXCP  IOB                Read a block\n         WAIT  ECB=ECB            Wait for read to complete\n*    See if CVTUSER create needed\nNEWSQA   DS    0H\n         MODESET KEY=ZERO         Need KEY zero to replace CVTUSER\n         L     R10,16             Load the address of the CVT\n         USING CVT,R10            Give assembler the CVT address\n         ICM   R9,B'1111',CVTUSER   Address CVTUSER points to\n         BNZ   GOTUSER            If CVTUSER, skip getting a new one\n*    Create CVTUSER if needed ( GETMAIN, init, chain )\n   GETMAIN RU,LV=XCVTUSIZ,LOC=BELOW,SP=245 Get 48 byte CVTUSER SQA area\n*                                 CSA would make more sense than SQA,\n*                                 but someday I may need fixed storage\n         LR    R9,R1              Save address of storage gotten\n         USING XCVTUSER,R9        Tell assembler about dsect\n         XC    XCVTUSER(XCVTUSIZ),XCVTUSER  Clear CVTUSER pointed area\n         MVC   XCVTUEYE,CCVTUSER  Move 'CVTUSERn' to CVTUSER area\n         SLR   R8,R8              Clear a register for the 'CS' inst.\n* CS - If R8 and CVTUSER are equal, then R9 is stored in CVTUSER\n* CS - If R8 and CVTUSER are not equal, then CVTUSER is loaded to R8\n         CS    R8,R9,CVTUSER      Set CVTUSER address in CVT\n         DROP  R10                Don't need pointer to CVT anymore\n         BE    GOTUSER            Got CVTUSER now, go back to main line\n* Some other program put CVTUSER in CVT first, free the new one\n         FREEMAIN RU,LV=XCVTUSIZ,A=(R9),SP=245   Free extra SQA storage\n         LR    R9,R8              Use the first CVTUSER area address\n*        B     GOTUSER            Got CVTUSER now, now check it\nGOTUSER  DS    0H\n         MODESET KEY=NZERO        Go back to key 8\n         CLC   XCVTUEYE,CCVTUSER  See if the CVTUSER area is mine\n         BNE   BADUSER            If someone else has CVTUSER, go tell\n         L     R9,XCVTTAPE        Load address of the tape bits\n         USING TAPEBITS,R9        Indicate memory TAPEBITS pointer\n*\n* R11=block-read-from-disk\n* R9=TAPEBITS-in-memory or zero\n*\n         CLI   ECB,X'7F'          See if a good read\n         BNE   CHECKSQA           Not good, go see if memory data okay\n         CLC   CTAPEBIT,0(R11)    See if a valid input record\n         BNE   CHECKSQA           Disk copy not valid, go check SQA\n* disk copy was read okay and appears valid\n         CLC   CTAPEBIT,TAPEEYE   See if SQA memory copy okay\n         BNE   REPLSQA            SQA BITS bad, go replace with disk\n         CLC   TAPECHAR,TAPECHAR-TAPEEYE(R11)  See is disk/SQA same?\n         BNE   REPLSQA            New scratch pool, go replace SQA\n         B     FREEDISK           Go to free disk input buffer\n*\nCHECKSQA DS    0H\n* Disk copy had read error, can memory copy be used?\n         CLC   CTAPEBIT,TAPEEYE   See if there is a SQA copy of bits\n         BNE   READERR            Neither copy good, go abend\n*\nREPLSQA  DS    0H\n     GETMAIN RU,LV=TAPELEN,LOC=BELOW,SP=245  Get new TAPE bits SQA area\n         LR    R8,R1              Save address of new SQA TAPEBITS\n         LR    R2,R1              Load MVCL address of new SQA TAPEBITS\n         L     R3,FTAPELEN        Load length to move to ( 12524 )\n         LR    R4,R11             Load MVCL address of disk TAPEBITS\n         L     R5,FTAPELEN        Load length to move from ( 12524 )\n         MODESET KEY=ZERO         Need KEY zero to update XCVTUSER\n         MVCL  R2,R4              Move disk copy of TAPEBITS to SQA\nCSAGAIN  DS    0H\n         L     R10,16             Load address of CVT\n         USING CVT,R10            Give assembler the CVT address\n         L     R10,CVTUSER        Load address of the CVT user area\n         USING XCVTUSER,R10       Give assembler the XCVTUSER pointer\n* CS - If R9 and XCVTTAPE are equal, then R8 is stored in XCVTTAPE\n* CS - If R9 and XCVTTAPE are not equal, then XCVTTAPE is loaded to R9\n         CS    R9,R8,XCVTTAPE     Store new SQA address\n         DROP  R10                Don't need XCVTUSER address anymore\n         BNE   CSAGAIN            CS didn't store, go try again\n         ST    R9,TAPEOLD-TAPEBITS(,R8)  Save old SQA address\n         DROP  R9                 TAPEBITS will switch to R10 later\n         MODESET KEY=NZERO        Switch back to key 8\nFREEDISK DS    0H\n         FREEMAIN RU,LV=TAPELEN,A=(R11) Free disk input buffer\n         LA    R1,CCWOUT          Load address of Channel Command Words\n         ST    R1,IOBCCWA         Store rewrite CCW address in IOB\n         STCM  R1,B'0111',OUTTIC  Store output TIC to address\n         MVI   R,X'1'             Change record number for write\n*\n*\nWAITLOOP DS    0H\n         STIMER WAIT,BINTVL=MINUTE Wait for 6000 hundredth of seconds\n         L     R10,16             Load address of CVT\n         USING CVT,R10            Give assembler the CVT address\n         L     R10,CVTUSER        Load address of the CVT user area\n         USING XCVTUSER,R10       Give assembler the XCVTUSER pointer\n         L     R10,XCVTTAPE       Load address of tape bits\n         USING TAPEBITS,R10       Tie TAPE bits DSECT to register 10\n         CLI   TAPEUPD,0          Any bits updated since last rewrite\n         BZ    FREEOLD            No update, no rewrite, check for FREE\n         STCM  R10,B'0111',OUTDATA  Store output buffer address\n         MODESET KEY=ZERO         Need KEY zero to update XCVTUSER\n         MVI   TAPEUPD,0          Clear bits updated status\n         MODESET KEY=NZERO        Switch back to normal protection key\n         EXCP  IOB                Go rewrite\n         WAIT  ECB=ECB            Wait for rewrite to complete\n         CLI   ECB,X'7F'          See if a good rewrite\n         BNE   WRITEERR           Not good, go abend\nFREEOLD  DS    0H\n         LR    R9,R10             Save TAPEBITS address\n         LR    R1,R10             Save TAPEBITS address\nFINDEND  DS    0H\n         LR    R2,R10             Save address of on back in chain\n         LR    R10,R1             Set address of place in chain\n         ICM   R1,B'1111',TAPEOLD Find end of chain\n         BNZ   FINDEND            Still more old SQA tape bits blocks\n         CLR   R9,R10             See if real SQA is the only copy\n         BE    CHKSTOP            Don't free only copy\n         ST    R1,TAPEOLD-TAPEBITS(,R2) Clear pointer to block to free\n         FREEMAIN RU,LV=TAPELEN,A=(R10),SP=245  Free old SQA bits\nCHKSTOP  DS    0H\n         L     R10,COMM            Load address of Communication Area\n* communications area (mapped by IEZCOM)\n         USING COMLIST,R10        Tie IEZCOM to R10\n         ICM   R9,B'1111',COMCIBPT Load address of Command Input Buffer\n         BZ    WAITLOOP           No CIB command, go back to wait\n         DROP  R10                Don't need COMM addressibilty anymore\n         USING CIBLIST,R9         Tie IEZCIB to R9\nCHECKCIB DS    0H\n         CLI   CIBVERB,CIBSTOP    See if operator did \"STOP TAPESAVE\"\n         BE    EOJ                Operator issue STOP, so end-of-job\n         ICM   R9,B'1111',CIBNEXT See if another CIB\n         DROP  R9                 Don't need CIB addressibilty anymore\n         BNZ   CHECKCIB           Go check the next Command Input Buff\n         B     WAITLOOP           No STOP command, go back to wait\n*\n*\nEOJ      DS    0H\n         MVI   OPENLIST,X'80'     Set only one DCB to OPEN or CLOSE\n         CLOSE TAPEDATA,MF=(E,OPENLIST) Close a TAPEDATA DCB\n         LA    R0,SAVESIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN RU,LV=(0),A=(1) Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nBADUSER  DS    0H\n         WTO   'Sub-System TAPESAVE found a bad CVTUSER area',         C\n               ROUTCDE=11\n         ABEND 1111,DUMP          Abend with a dump\n*\nREADERR  DS    0H\n         WTO   'Sub-System TAPESAVE had a read error on TAPEDATA',     C\n               ROUTCDE=11\n         ABEND 1112,DUMP          Abend with a dump\n*\nWRITEERR DS    0H\n         MODESET KEY=ZERO         Need KEY zero to update XCVTUSER\n         OI    TAPEUPD-TAPEBITS(R10),1  Record didn't get written\n         MODESET KEY=NZERO        Switch back to normal protection key\n         WTO   'Sub-System TAPESAVE had a write error on TAPEDATA',    C\n               ROUTCDE=11\n         LM    R2,R3,IOBCSW       For debug\n         L     R4,ECB             For debug\n         ABEND 1113,DUMP          Abend with a dump\n*\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants and model control blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* The X'1' is the DSECT version number\nCCVTUSER DC    CL7'CVTUSER',XL1'1' Constant to init and check CVTUSER\nCTAPEBIT DC    CL7'TAPEBIT',XL1'1' Constant to init and check TAPEBIT\n*\nMINUTE   DC    F'6000'            Wait time: 6000 hundredth of seconds\nFTAPELEN DC    AL4(TAPELEN)       Length of TAPEBITS DSECT in memory\n*\n*\nDUMEXT   EXTRACT *-*,'S',FIELDS=(COMM),MF=L  Model EXTRACT for COMM\nDUMLEN   EQU     *-DUMEXT         Calculate length of EXTRACT\n*\n*\nDUMMY    DS    0D                 I/O Template\nDUMDCB   DCB   DDNAME=TAPEDATA,   DDNAME of TAPEDATA                   C\n               MACRF=E,           MACRO reference                      C\n               DSORG=PS           Data Set Organization\nDCBLEN   EQU   *-DUMDCB           Length of the DCB\nDUMIOB   DS    0D                 IOB TO READ A COUNT FIELD\n         DC    XL4'40000000'      Command Chaining used\n         DC    A(*-*)             Address of the ECB\n         DC    D'0'               Channel Status Word\n         DC    A(*-*)             Address of the Channel Command Words\n         DC    A(*-*)             Address of the Data Control Block\n         DC    A(0)               IOB Restart\n         DC    XL4'0'             Flags and counters\n         DC    D'0'               Seek address MBBCCHHR (will fill in)\nDUMCCWI  CCW   X'31',*-*,X'40',5  Search for record to read\n         CCW   8,*-8,0,0          TIC back until search complete\n         CCW   X'06',*-*,0,12524  Read the DATA portion of the record\nDUMCCWO  CCW   X'31',*-*,X'40',5  Find record before one to rewrite\n         CCW   8,*-8,0,0          TIC back until search complete\n         CCW   X'05',*-*,0,12524  Rewrite the DATA of next record\nDUMMYLEN EQU   *-DUMMY            Size of I/O template\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nTIOT     DS    F                  Address of the Task I/O Table\nCOMM     DS    F                  Address of the Communication area\nOPENLIST DS    F                  OPEN/CLOSE parameter list\nECB      DS    F                  Event Control Block for DCB\n*\nCLEARSIZ EQU   *-SAVEAREA\n*\n*\nEXTRACT  DS    XL(DUMLEN)         EXTRACT list to get COMM\n*\n*\n* Do not insert code between here and SAVESIZE\n* A template will be copied on the following fields\n         DS    0D                 Align the following DCB, IOB, etc.\nTAPEDATA DS    XL(DCBLEN)         TAPEDATA DCB\n         DS    0D                 Align IOB to double word boundary\nIOB      DS    0XL32              Input and Output Block\n         DS    XL4                XL4'40000000' Command Chaining used\nIOBECBA  DS    A                  Address of Event Control Block\nIOBCSW   DS    D                  Channel Status Word\nIOBCCWA  DS    A                  Address of Channel Command Words\nIOBDCBA  DS    A                  Address of Data Control Block\n         DS    A                  IOB Restart\n         DS    XL4                Flags and counters\nIOBSEEK  DS    D                  Seek address\nSEARCH   EQU   IOBSEEK+3,5        Cylinder, head, and record to search\nCCHH     EQU   IOBSEEK+3,4        Cylinder and head to seek to\nCC       EQU   IOBSEEK+3,2        Cylinder to seek\nHHR      EQU   IOBSEEK+5,3        Track and record to search for\nHH       EQU   IOBSEEK+5,2        Track to seek to\nR        EQU   IOBSEEK+7,1        Record to search for\nCCWIN    DS    3D                 Input Channel Command Words\nINSEARCH EQU   CCWIN+01,3         Address of the search address\nINTIC    EQU   CCWIN+09,3         Address to TIC back to\nINDATA   EQU   CCWIN+17,3         Address to read DATA into\nCCWOUT   DS    3D                 Output Channel Command Words\nOUTSRCH  EQU   CCWOUT+01,3        Address of the search address\nOUTTIC   EQU   CCWOUT+09,3        Address to TIC back to\nOUTDATA  EQU   CCWOUT+17,3        Address to rewrite DATA from\n         SPACE 1\nSAVESIZE EQU   *-SAVEAREA\n*\n*\n         COPY  CVTUSER            User DSECT from ????.SORC????\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n*          DS    XL12             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\n*\nTAPEBITS DSECT ,\n         COPY  TAPEBITS           Copy TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n* TAPESKIP DS    CL6              IEC512I tape vol ser to ignore\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              Displacement to return to zero\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* TAPEBIT0 EQU   X'80'            First tape within a byte\n* TAPEBIT1 EQU   X'40'            Second tape within a byte\n* TAPEBIT2 EQU   X'20'            Third tape within a byte\n* TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n         DCBD  DSORG=PS,DEVD=DA   Data Control Block DSECT IHADCB\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\nIEZCOM   DSECT ,\n         IEZCOM ,                 Communications area\n*\nCIBLIST  DSECT ,\n         IEZCIB ,                 Command Input Buffer\n*\nTAPESAVE CSECT ,\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TSPESAVE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPESMF": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01*\\x00\\x19\\x00\\x995o\\x01\\t4\\x7f\"\\x00\\x01\\xc1\\x01K\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.42", "flags": 0, "createdate": "1999-12-22T00:00:00", "modifydate": "2009-12-13T22:00:19", "lines": 449, "newlines": 331, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPESMF-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(4,LT)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'TAPESMF - - - Extracts tape EXPDT from SMF record type 15'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program reads a VBS copy of SMF records type 14 and 15\n*  and extracts all tape records.  Three files are created.\n*\n*  DATASETS is data for all OPEN/CLOSE to all data sets on all tapes.\n*  VOLUMES is data for tape volumes that first label was re-written.\n*  VOLOUT is data for tape volumes were updated, i.e. to go offsite.\n*  VOLOUT is obsolete.  Replaced by a perl script.\n*\n* There is an indicator code on each record to show the status of the\n* record, either has or has not been scratched.\n* I = Record of a tape data set read for input\n* O = New output tape data set that has been written\n* S = is to be scratched ( Selected ) S honored after expiration date\n* X = If tape volume has appeared on a scratch list ( Scratched )\n* S and X are obsolete.  Tape scratch is now handled with P/390\n* and Flex-ES automountCCW programs TAPESTAT and TAPESYN2.\n*\n*     Sample JCL:\n*\n* //*\n* //* * * * * * Start of tape management\n* //*\n* //* TAPESMF extracts tape information from SMF data.\n* //* Tape vol sers starting ?? are ????. ??????? tapes.\n* //* Tape vol sers starting ?? are ??????????? ??????? ??? tapes.\n* //* Tape vol sers starting ??? and ??? are considered ???? tapes.\n* //* Tapes written on file number one are added to both data sets.\n* //* All tape data sets accessed are added to the DATASETS data set.\n* //* A previous entry for each vol ser should normally already be\n* //* in the VOLUMES data set.\n* //*\n* //TAPESMF EXEC PGM=TAPESMF\n* //SMFIN    DD  DSN=BACKUP.SMFDUMPD,DISP=SHR\n* //* All input/output tapes\n* //DATASETS DD  DISP=MOD,DSN=????.TAPES.????????.DATASETS(+0)\n* //* New output tapes\n* //VOLUMES  DD  DISP=MOD,DSN=????.TAPES.????????.VOLUMES\n* //* All output tapes\n* //VOLOUT   DD  DISP=MOD,DSN=????.MIRROR.????????.VOLUMES\n* //* or\n* //VOLOUT   DD  DUMMY\n* //SYSUDUMP DD  SYSOUT=*\n* //*\n* //* Following sorts the VOLUMES tape file to drop old records\n* //* for tapes that have been written over.\n* //* After TAPEOLD runs, there will only be one record for\n* //* each file on each tape in the VOLUMES data set.\n* //*\n* //* Data sets are kept on shared disk volume ??????, so\n* //* all processing after TAPEOLD can be run on ????/????.\n* //*\n* //* First step 'SORT' inverts the accessed close date and time so\n* //* the most current record for each tape is kept.\n* //* If duplicate tape number with duplicate close date and time,\n* //* the highest indicator code is kept.\n* //*\n* //* Second step 'TAPEOLD' drops old tape records for tapes that\n* //* re-written.\n* //*\n* //SORTACT EXEC PGM=SORT,PARM='RC16=ABE',RD=R\n* //SYSOUT   DD  SYSOUT=*\n* *             VolSer   Created   Ind.-Code      EXPDT---D\n*  SORT FIELDS=(1,6,CH,A,8,23,CH,D,35,1,CH,D)    ,37,8,CH,D)\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),DSN=????.TAPES.????????.SORT(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(150,150),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //*\n* //TAPEOLD EXEC PGM=TAPEOLD\n* //SORTED   DD  DISP=SHR,DSN=????.TAPES.????????.SORT(+1) input\n* //VOLUMES  DD  DISP=OLD,DSN=????.TAPES.????????.VOLUMES replaced\n* //SYSUDUMP DD  SYSOUT=*\n* //*\n* //SORTHST EXEC PGM=SORT,PARM='RC16=ABE',RD=R\n* //SYSOUT   DD  SYSOUT=*\n* *     volser, close-date, close-time, File-seq-Number, indicator-code\n*  SORT FIELDS=(1,35,CH,A)\n* //SORTIN   DD  DISP=OLD,DSN=????.TAPES.????????.DATASETS(+0)\n* //SORTOUT  DD  DISP=(,CATLG,DELETE),\n* //             DSN=????.TAPES.????????.DATASETS(+1),\n* //             VOL=REF=*.SORTIN,SPACE=(TRK,(150,150),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=171\n* //*\n* //* * * * * * End of ???? tape management\n* //*\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESMF  CSECT ,\nTAPESMF  AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPESMF  RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPESMF.&SYSDATE..&SYSTIME'  Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPESMF,R12        Give the assembler the new base\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n* OPEN\n         OPEN  (SMFIN,INPUT)      Open the SMF input VBS file\n         OPEN  (DATASETS,EXTEND)  Open the DATASETS output FB data file\n         OPEN  (VOLUMES,EXTEND)   Open the write output FB data file\n         OPEN  (VOLOUT,EXTEND)    Open other write output FB data file\nGET      DS    0H\n         GET   SMFIN              Get an SMF record ( Address in R1 )\n         LR    R11,R1             Put address where it is safe\n         USING SMFRCD14,R11       Give Assembler addressibility\n         USING JFCB,SMFJFCB1      Give Assembler addressibility\n         CLI   SMF14RTY,14        See if type 14 record\n         BL    GET                Below 14, go skip record\n         CLI   SMF14RTY,15        See if type 15 record\n         BH    GET                Above 15, go skip record\n         TM    SMF14RIN,X'20'     See if a DASD record\n         BO    GET                is DASD, go skip record, we want tape\n         SLR   R1,R1              Prepare a work register\n         IC    R1,JFCBNVOL        Load number of volumes\n         LTR   R1,R1              See if no volumes\n         BZ    GET                no volumes, go to skip the record\n         MVI   RECORD,X'40'       Put space in output data record\n         MVC   RECORD+1(L'RECORD-1),RECORD  Clear record to spaces\n* VOLSER\n         MVC   VOLSER,SMFSRTEV    Copy volume serial no. to output rec.\n* Tape closed date\n         ICM   R1,B'1111',SMF14DTE  Load date record written 0CYYDDDF\n         ST    R1,DWORK           Save the date that tape was closed\n         AP    DWORK(4),P1900000  Correct the century\n         MVC   CL@DATE,DATEMASK   Copy edit mask to output record\n         ED    CL@DATE,DWORK      Format date CCYYDDDF\n* Tape closed time\n         ICM   R3,B'1111',SMF14TME  Load time in hundredth second\n         SLR   R2,R2              Clear the high order dividend\n         D     R2,F100            Find hundreds of a second\n         CVD   R2,DWORK           Save remainder ( hundreds of second\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  CL@TH,DWORK+6(2)   Unpack hundredth of second\n         MVI   CL@TH,C'.'         Put decimal point over leading zero\n         SLR   R2,R2              Clear top of dividend for divide\n         D     R2,F60             Find second within the minute\n         CVD   R2,DWORK           Save remainder ( seconds\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  CL@SS,DWORK+6(2)   Unpack number of second\n         MVI   CL@SS,C':'         Put colon over leading zero\n         SLR   R2,R2              Clear top of dividend for divide\n         D     R2,F60             Find number of a minutes\n         CVD   R2,DWORK           Save remainder ( minute of hour\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  CL@MM,DWORK+6(2)   Unpack minute within the hour\n         MVI   CL@MM,C':'         Put colon over leading zero\n         CVD   R3,DWORK           Save product ( hour in the day\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  CL@HH,DWORK+6(2)   Unpack hour in the day\n         MVI   CL@HH,C' '         Put space over leading zero\n* File sequence number ( LABEL=(???,SL)\n         LH    R1,JFCBFLSQ        Load file sequence number\n         CVD   R1,DWORK           Convert file sequence no. to decimal\n         MVC   FILESEQN,MASK5     Copy mask to file seq. no. output\n         ED    FILESEQN,DWORK+5   Copy file sequence no. to output\n*  If new output record mark 'O', if input record mark 'I'\n         MVI   CODE+1,C'O'        Put output indicator code in record\n         CLI   SMF14RTY,15        See if output type SMF record\n         BE    ISTYPE15           Is output, go leave the 'O' ind.code\n         MVI   CODE+1,C'I'        Else, put 'input' ind.code in record\n         B     ENDEXPDT           No EXPDT in SMF for tape reads\nISTYPE15 DS    0H\n* Expiration date\n         MVC   EX@YEAR(9),CL@DATE Assume close date for expiration date\n         CLC   JFCBXPDT,ZEROES    See if any expiration date\n         BE    ENDEXPDT           No EXPDT, leave close date for EXPDT\n         SLR   R1,R1              Clear work register\n         IC    R1,JFCBXPDT        Load expire year relative to 1900\n         AH    R1,H1900           Add 1900 for absolute year\n         CVD   R1,DWORK           Convert year to decimal\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  EX@YEAR,DWORK+5(3) Copy expire date year to output\n         MVI   EX@YEAR,X'40'      Clear byte before the year\n         MVI   EX@PER,X'4B'       Put period output data record\n         LH    R1,JFCBXPDT+1      Load expire day of the year\n         CVD   R1,DWORK           Convert day to decimal\n         OI    DWORK+7,X'0F'      Correct the sign\n         UNPK  EX@DAY,DWORK+6(2)  Unpack expire day number to output\nENDEXPDT DS    0H\n* Data set name\n         MVC   DSNAME,JFCBDSNM    Copy DSNAME to output record\n* Volume number within data set\n         SLR   R1,R1              Prepare a work register\n         IC    R1,JFCBNVOL        Load no.of volumes ( also vol.no )\n         CVD   R1,DWORK           Convert volume sequence no.to decimal\n         MVC   VOLSEQN,MASK3      Copy mask to volume seq. no. output\n         ED    VOLSEQN,DWORK+6    Copy volume sequence no. to output\n* Block count written on tape\n         L     R1,SMFDCBBL        Load block count of tape\n         CVD   R1,DWORK           Convert block count to decimal\n         MVC   BLKCOUNT,MASK9     Copy edit pattern to output record\n         ED    BLKCOUNT,DWORK+3   Copy block count to output record\n* RECFM\n*        TM    JFCRECFM,JFCUND    See if RECFM=U    JFCB less accurate?\n         TM    SMFDCBRF,JFCUND    See if RECFM=U     DCB more accurate?\n         BO    RECFMU             Is RECFM=U, go store U\n         TM    SMFDCBRF,JFCFIX    See if RECFM=F\n         BO    RECFMF             Is RECFM=F, go store F\n         TM    SMFDCBRF,JFCVAR    See if RECFM=V\n         BO    RECFMV             Is RECFM=V, go store V\n         TM    SMFDCBRF,JFCVARD   See if RECFM=D ( Variable ASCII )\n         BZ    ENDRECFM           Don't know what, skip RECFM\nRECFMD   DS    0H\n         MVI   RECFM+1,C'D'       Put D in output record for RECFM\n         B     BLOCKED            Go see of data is blocked\nRECFMU   DS    0H\n         MVI   RECFM+1,C'U'       Put U in output record for RECFM\n         B     CC                 Go see of carraige control\nRECFMV   DS    0H\n         MVI   RECFM+1,C'V'       Put V in output record for RECFM\n         B     BLOCKED            Go see of data is blocked\nRECFMF   DS    0H\n         MVI   RECFM+1,C'F'       Put F in output record for RECFM\n*        B     BLOCKED            Go see of data is blocked\nBLOCKED  DS    0H\n         TM    SMFDCBRF,JFCRFB    See if RECFM=B\n         BZ    SPANNED            Not blocked,go check Spanned/standard\n         MVI   RECFM+2,C'B'       Put B in output record for RECFM\nSPANNED  DS    0H\n         TM    SMFDCBRF,JFCRFS    See if RECFM=S Spanned or Standard\n         BZ    CC                 Not RECFM=S,go check Carraige Control\n         MVI   RECFM+3,C'S'       Put S in output record for RECFM\nCC       DS    0H\n         TM    SMFDCBRF,JFCASA    See if RECFM=A ( ASA CC )\n         BZ    CCM                Not RECFM=A, go check machine CC\n         MVI   RECFM+4,C'A'       Put A in output record for RECFM\nCCM      DS    0H\n         TM    SMFDCBRF,JFCMAC    See if RECFM=M ( ASA CC )\n         BZ    COMPRESS           Not RECFM=M, go compress RECFM data\n         MVI   RECFM+4,C'M'       Put M in output record for RECFM\nCOMPRESS DS    0H\n         CLI   RECFM+3,X'40'      See if third byte of RECFM is blank\n         BNE   RECFM2             Is not blank, don't compress out\n         MVC   RECFM+3(2),RECFM+4 Compress space out\nRECFM2   DS    0H\n         CLI   RECFM+2,X'40'      See if second byte of RECFM is blank\n         BNE   ENDRECFM           Is not blank, don't compress out\n         MVC   RECFM+2(3),RECFM+3 Compress space out\nENDRECFM DS    0H\n* LRECL\n         LH    R1,JFCLRECL        Logical RECord Length of data set\n         CVD   R1,DWORK           Convert LRECL to decimal\n         MVC   LRECL(6),MASK5     Copy edit pattern to output record\n         ED    LRECL(6),DWORK+5   Copy LRECL to output record\n         TM    JFCBFLG3,JFCBBFTK  See if LRECL=?????K\n         BZ    ENDLRECL           LRECL bytes, not K, don't store K\n         MVI   LRECL+6,C'K'       Indicate that LRECL is specified in K\nENDLRECL DS    0H\n* BLKSIZE\n         LH    R1,JFCBLKSI        Load block size of data set\n         CVD   R1,DWORK           Convert BLKSIZE to decimal\n         MVC   BLKSIZE,MASK5      Copy edit pattern to output record\n         ED    BLKSIZE,DWORK+5    Copy BLKSIZE to output record\n* System name\n         MVC   SYSTEM,SMF14SID    Copy SMF System id to output record\n* JOB name\n         MVC   JOBNAME,SMF14JBN   Copy JOB name to output record\n* See if Step name and Program name are available\n         TM    SMF14RIN+1,SMF14XSG  See if SMF record has extended info\n         BZ    NOEXINFO           No extended info, skip step&pgm names\n         LH    R1,SMF14SXS        Load the length of extended info.\n         BCTR  R1,0               Find length without length field\n         BCTR  R1,0               Find length without length field\n         SLR   R3,R3              Clear a work register\n         IC    R3,SMF14SUC        Load the size of the UCB segment\n         LA    R2,SMF14XIC(R3)    Load address of first extended info.\n         USING SMF14XIC,R2        Tell assembler where R2 points\nFINDSTEP DS    0H\n         CLI   SMF14STY,SMF14STP  See if step&pgm names extention\n         BE    GOTSTEP            Step&pgm extention, go process\n         SH    R1,SMF14ESL        Skip to next extention\n         BZ    NOEXINFO           No more extentions, no step&pgm names\n         AH    R2,SMF14ESL        Skip to next extention\n         B     FINDSTEP           Go check the next extention\nGOTSTEP  DS    0H\n         LA    R2,4(,R2)          Bump around length & segment type\n         USING SMF14SPI,R2        Point to step&pgm name info address\n         MVC   STEPNAME,SMF14SPN  Copy JOB or PROC STEP to output\n* Program name\n         MVC   PGMNAME,SMF14PGN   Copy program name to output\n         DROP  R2                 Don't need addressibility anymore\nNOEXINFO DS    0H\n* DDNAME\n         MVC   DDNAME,SMFTIOE5    Copy DDNAME to output record\n* Put all records to the DATASETS file\n         PUT   DATASETS,RECORD    PUT a DATASETS output record\n*\n* If an output record and it is either the first data set on a\n* tape volume or after the first tape of a data set, also write\n* to the VOLUMES file\n* e.g. Tape X and Y are written.\n* Tape X has 14 data sets written on it, of which the last data set\n* overflows to tape Y.\n* The VOLUMES data set will get a record for the first data set on\n* tape X and a record for the first data set on tape Y which shows\n* as data set #14.\n* GOTONE   DS    0H\n         CLI   CODE+1,C'O'        See if an output record\n         BNE   GET                Not output, don't put to VOLUMES file\n         PUT   VOLOUT,RECORD      All output volumes for offsite mirror\n         CLI   JFCBNVOL,X'01'     See if NOT first tape of data set\n         BH    PUTVOL             Not first, put to VOLUMES file\n         CLC   JFCBFLSQ,H1        See if the first file of the tape\n         BNE   GET                Not first, don't put to VOLUMES file\nPUTVOL   DS    0H\n         PUT   VOLUMES,RECORD     PUT label=1 output record to VOLUMES\n         B     GET                Go get the next SMF input record\nEODAD    DS    0H\n         CLOSE DATASETS           Close the output DATASETS file\n         CLOSE VOLUMES            Close the output write file\n         CLOSE VOLOUT             Close the all output write file\n         CLOSE SMFIN              Close the SMF input data file\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LTORG ,                  If any literals, put them here\nDATEMASK DC   XL9'40212020204B202020'  Date edit mask nnnn.nnn\nH1       DC   H'1'                Constant for compare\nH1900    DC   H'1900'             Constant to calculate year\nZEROES   DC   F'0'                Constant to compare\nF100     DC   F'100'              Divisor to convert time\nF60      DC   F'60'               Divisor to convert time\nP1900000 DC   PL4'1900000'        Convert century for CL@DATE\nMASK3    DC   XL4'40202120'       Edit mask for 3 digit numbers\nMASK5    DC   XL6'402020202120'   Edit mask for 5 digit numbers\nMASK9    DC   XL10'40202020202020202120'  Edit mask for 9 digit numbers\n*\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSMFIN    DCB   DDNAME=SMFIN,DSORG=PS,MACRF=GL,EODAD=EODAD,RECFM=VBS,   +\n               BFTEK=A   ( RECFM=VBS Locate mode system buffering )\n*              BFTEK=A   Means that the system will put VBS records\n*              BFTEK=A   back together before giving you its address.\n* No LRECL specified to cause ABEND for attempt to read enpty data set\nDATASETS DCB   DDNAME=DATASETS,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\nVOLUMES  DCB   DDNAME=VOLUMES,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\nVOLOUT   DCB   DDNAME=VOLOUT,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=171\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nCLEARSIZ EQU   *-SAVEAREA\n         SPACE 1\nDWORK    DS    D                  CVD work area\n         SPACE 1\n         COPY  TAPEDSCT           Volume record layout\n* RECORD   DS    0CL171\n* VOLSER   DS    CL6    '??????'\n* CL@DATE  DS    CL9   ' YYYY.DDD'\n* CL@HH    DS    CL3    ' HH'\n* CL@MM    DS    CL3    ':MM'\n* CL@SS    DS    CL3    ':SS'\n* CL@TH    DS    CL3    '.TH'\n* FILESEQN DS    CL6    ' nnnnn'\n* CODE     DS    CL2    ' O'  ' I'\n* EX@YEAR  DS    CL5    ' yyyy'\n* EX@PER   DS    CL1    '.'\n* EX@DAY   DS    CL3    'ddd'\n* SCRDATE  DS    CL9    ' yyyy.ddd' Date the tape is put on Scratchlist\n*          DS    CL1    ' '         Space\n* DSNAME   DS    CL44               Data set name\n* VOLSEQN  DS    CL4    ' nnn'      Volume sequence number\n* BLKCOUNT DS    CL10   ' zzzzzzzzn'  Block count on the tape\n* RECFM    DS    CL5    ' FBSA'     Record format of data set\n* LRECL    DS    CL7    ' zzzznK'   Logical record length of data set\n* BLKSIZE  DS    CL6    ' zzzzn'    Block size of data set\n*          DS    CL1    ' '         Space\n* SYSTEM   DS    CL4                SMF ID for the system name\n*          DS    CL1    ' '         Space\n* JOBNAME  DS    CL8                JOB name\n*          DS    CL1    ' '         Space\n* STEPNAME DS    CL8                Step name\n*          DS    CL1    ' '         Space\n* PGMNAME  DS    CL8                Program name\n*          DS    CL1    ' '         Space\n* DDNAME   DS    CL8                DDNAME\n         SPACE 1\nWORKSIZE EQU   *-SAVEAREA\n         SPACE 1\nSMFRCD14 DSECT ,\n         IFASMFR 15               DSECT for SMF record type 15\n         SPACE 1\nJFCB     DSECT ,\n         IEFJFCBN LIST=YES        JOB File Control Block in SMF record\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   NAME TAPESMF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPESTAT": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00A\\x01\\x06(o\\x01\\t4\\x7f!S\\x02n\\x02n\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2006-10-13T00:00:00", "modifydate": "2009-12-13T21:53:41", "lines": 622, "newlines": 622, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPESTAT-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\nPASS TITLE 'TAPESTAT - - - Extracts tape label info from tape labels'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Start Change Log:\n*\n* 2006-10-13 Removed check for tape vol sers ending with 5 numbers.\n*  W.A.M.    Changed range processing to increment one digit at a\n*            time in case only the last digits are numeric.\n*\n* 2006-06-07 Moved all tapes back to their standard scratch areas.\n*  W.A.M.    B***** tapes go to /tapeB\n*            A***** tapes go to /tapeA\n*            All others go to /tapeC\n*\n* 2006-05-10 Moved \"A\" tapes except \"A00\" tapes from /tapeA to /tapeC\n*  W.A.M.\n*\n* 2006-02-25 Moved \"B\" tapes except \"B00\" tapes from /tapeB to /tapeC\n*  W.A.M.\n*\n* 2005-12-19 Changed program to unload tapes present after error.\n*  W.A.M.    Expanded output date format from YYDDD to YYYY.DDD\n*\n* 2005-10-21 Stop writing 'Empty' tape records.\n*  W.A.M.\n*\n* End Change Log:\n*\n*\n*  This program reads SYSIN to determine which tapes to read.\n*  It can read individual tapes, ranges of tapes, and both.\n*\n*  It will list information about the tape to a data set as:\n*  Error-*** - Leading tape mark, read error, etc.\n*  MisMatch - Internal vol ser not same as vol ser requested.\n*  No-Label - Two blocks of data before a label.\n*  Expired - Retention date past.  Data has not been cleared.\n*  Exp-Today - Retention date is today's date.\n*  Protected - Retention has not past.  Tape is date protected.\n*  Previously, it would also list:\n*  Empty - Freshly relabeled or data cleared. ( no longer written )\n*\n*  Output fields are:\n*  Vol ser requested\n*  Status\n*  Last 17 bytes of data set name\n*  Creation date\n*  Expiration date\n*  Internal vol ser if a mis-match, else blank\n*\n*\n* Some sample out records:\n*\n*   Tape C01111 called for but internal label is C02222\n* C01111 MisMatch  .SYSLOG.G1234V00 2003.001 2005.001 C02222\n*\n*   Tape C01122 is has expired but has not been erased\n* C01122 Expired   VSYSRES.G0123V00 2005.255 2005.285\n*\n*   Tape C01234 is date protected until 2007/301\n* C01234 Protected SMFDUMP.G0012V00 2005.301 2007.301\n*\n*  The output file can be used to find tape errors\n*  ( no label, vol ser mismatch, others? ).\n*\n*  The output can also be used to know what tapes have\n*  expired but have not been cleared to free space in\n*  the disk area tape pool.\n*\n*  This program will issue mount, rewind, read, read, and\n*  rewind-unload CCWs without opening any tape so SMF data\n*  will not be updated for any tape.\n*\n*  If there is an EXCP error, a separate SENSE CCW will\n*  be issued to clear any bad status on the tape drive.\n*  Sense is also checked to see if a separate\n*  Rewind-Unload is needed.  The separate Rewind-Unload\n*  is issued if sense indicates a tape is present on the\n*  drive.  An oddity in Flex-ES would cause it to unload\n*  the tape anyway when the next tape is called for.\n*\n* * * * See program TAPEZERO for additional use and JCL * * *\n*\n* * * * Possible future enhancement? * * *\n* Add parm of vol ser format mask, i.e. PARM=ANANNN\n* with \"A\" meaning alphabetic, \"N\" meaning numeric, $ for national?\n*\n*  Date-written: 2005-10-17\n*\n*  Blame: somitcw@yahoo.com\n*\n*     Sample JCL:\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPEZERJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=xxxxxxx,COND=(0,NE)\n* //TAPESTAT EXEC PGM=TAPESTAT\n* //STEPLIB  DD  DISP=SHR,DSN=xxxx.APF.LOADxxxx\n* C00000-C00999\n* C01234\n* C02000-C02999\n* //TAPESTAT DD  UNIT=(TAPE,,DEFER)\n* //STATS    DD  DISP=(,CATLG,DELETE),DSN=????.TAPES.STATS(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=59\n* //SYSUDUMP DD  SYSOUT=*\n*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESTAT CSECT ,\nTAPESTAT AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPESTAT RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPESTAT.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPESTAT,R12       Give the assembler the new base\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(CLEARSIZ,R1),0(R1)  Clear SAVEAREA in DSECT\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n         TIME  ,   0CYYDDDF       Get today's date in R1, time in R0\n         ST    R1,DWORK           Convert today's date to decimal\n         OI    DWORK+3,X'0F'      Correct the sign for numeric display\n         UNPK  TODAY,DWORK+1(3)   Unpack today's date in YYDDD format\n* If there was a real DCB, either RDJFCB or OPEN might be\n* better than searching the TIOT ?\n         EXTRACT TIOT,'S',FIELDS=TIOT  Get the tape I/O table address\n         L     R11,TIOT           Load address of the TIOT\n         LA    R11,24(,R11)       Bump past TIOT header\n         USING TIOENTRY,R11       Give assembler TIOT DD entry address\n         SLR   R10,R10            Clear a work register\nTIOTLOOP DS    0H\n         ICM   R10,B'0001',TIOELNGH  Load the length of the entry\n         BZ    NODD               TAPESTAT DD statement missing, abend\n         CLC   TIOEDDNM,TAPEDD    See if tape DDNAME found\n         BE    DDFOUND            DD found, go save UCB address\n         AR    R11,R10            Bump to the next TIOT DD entry\n         B     TIOTLOOP           Go back to check new DD entry\nDDFOUND  DS    0H\n         ICM   R11,B'0111',TIOEFSRT  Load tape DD UCB address\n         DROP  R11                Don't need TIOT entry address anymore\n         STCM  R11,B'0111',DEBUCB Store UCB address in DEB\n* R11 contains the UCB address\n         OPEN  SYSIN              OPEN the control statement data set\n         OPEN  (STATS,OUTPUT)     OPEN the output statistics file\n*\n* IOSINTRP to blow away OS/390 outstanding IOSB for the tape drive.\n* PURGE PURGE or PURGE QUIESCE might make more sense, but I use\n* IOSINTRP after an EXCP and before the WAIT for other tape access.\n*\n         MODESET MODE=SUP,KEY=ZERO  Switch to supervisor mode, key zero\n         L     R1,4(,R13)         Save old register 13 from IOSINTRP\n         IOSINTRP UCB=(R11)       Interrupt old tape I/O for new\n         MODESET MODE=PROB,KEY=NZERO Switch to problem state, key eight\nGET      DS    0H\n         GET   SYSIN              Read an input record\n         CLI   0(R1),X'5C'        See if a ( C'*' ) comment statement\n         BE    GET                Comment, do not process, return\n         CLI   0(R1),X'40'        See if vol ser starts blank\n         BE    GET                Consider comment, do not process\n         MVC   INPUT(13),0(R1)    Copy record to process\n* INPUT has 13 bytes like: C01234-C01345 or just one vol ser\n* dead   TRT   INPUT+1(5),TABLE   See if first vol ser is numeric\n* dead   BNZ   BADSYSIN           Invalid vol ser, go abend\n         CLI   INPUT+6,C'-'       See if a range of vol sers\n         BNE   GOTVOL             Not a range, skip validation for 2nd\n         CLC   INPUT(1),INPUT+7   See if valid range\n         BNE   BADSYSIN           Not valid range, go abend\n         CLC   INPUT+1(5),INPUT+8 See if low number vol ser first\n         BH    BADSYSIN           First number higher, go abend\n* dead   TRT   INPUT+8(5),TABLE   See if second vol ser is numeric\n* dead   BNZ   BADSYSIN           Invalid vol ser, skip\nGOTVOL   DS    0H\n         MVC   MOUNT1,INPUT       Complete file system to mount tape\n         MVC   MOUNT3,INPUT       Set directory to mount tape from\n         MVC   MOUNT6,INPUT       Set vol ser to mount\n         CLI   MOUNT1,C'B'        See if ????/???? main tape pool\n         BE    GOTVOL2            Pool name correct, skip other checks\n         CLI   MOUNT1,C'A'        See if ???????? main tape pool\n         BE    GOTVOL2            Pool name correct, skip other checks\n         MVI   MOUNT1,C'C'        Set ????/???? tape pool tape pool\nGOTVOL2  DS    0H\n         LA    R10,CCWREAD        Load address of normal tape read\n         ST    R10,IOBCCWA        Store CCW string address for EXCP\n         MVI   INVOL1,C'?'        Clear input VOL1 and HDR1 area\n         MVC   INVOL1+1(159),INVOL1  Clear input VOL1 and HDR1 area\n* read tape\n         XC    ECB,ECB            Clear any left over garbage in ECB\n         MODESET KEY=ZERO         PSW Key 0 for EXCP with own DEB\n         EXCP  IOB                Issue automountccw\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    NOWAIT             Already posted, skip WAIT SVC\n         WAIT  ECB=ECB            Wait for mount to complete\nNOWAIT   DS    0H\n         MODESET KEY=NZERO        Switch back to non-key zero ( 8 )\n         CLI   ECB,X'7F'          See if an error\n         BE    READOKAY           Bypass extra unload if no error\n         LA    R10,CCWSENSE       Load address of sense CCW string\n         ST    R10,IOBCCWA        Store CCW string address for EXCP\n         XC    ECB,ECB            Clear any left over garbage in ECB\n         MODESET KEY=ZERO         PSW Key 0 for EXCP with own DEB\n         EXCP  IOB                Issue sense CCW\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    NOWAIT2            Already posted, skip WAIT SVC\n         WAIT  ECB=ECB            Wait for sense to complete\nNOWAIT2  DS    0H\n         MODESET KEY=NZERO        Switch back to non-key zero ( 8 )\n         MVC   OUTSTAT,ERROR      Move 'Error-***' to output record\n         UNPK  SENSE00(9),SENSE+00(5)  Unpack first word of sense\n         UNPK  SENSE04(9),SENSE+04(5)  Unpack first word of sense\n         UNPK  SENSE08(9),SENSE+08(5)  Unpack first word of sense\n         UNPK  SENSE0C(9),SENSE+12(5)  Unpack first word of sense\n         UNPK  SENSE10(9),SENSE+16(5)  Unpack first word of sense\n         UNPK  SENSE14(9),SENSE+20(5)  Unpack first word of sense\n         UNPK  SENSE18(9),SENSE+24(5)  Unpack first word of sense\n         UNPK  SENSE1C(9),SENSE+28(5)  Unpack first word of sense\n         TR    SENSEOUT,TABLEEBC-240 Translate X'FA'-X'FF' to C'A'-C'F'\n         MVI   SENSE00+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE04+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE08+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE0C+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE10+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE14+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE18+8,X'40'    Space out garbage byte after UNPK/TR\n         MVI   SENSE1C+8,X'40'    Space out garbage byte after UNPK/TR\n         WTO   'TAPESTAT - Tape error encountered, detail follows:'\n         MVC   WTOVOL,INPUT       Move expected vol ser to display\n         WTO   MF=(E,WTOSENSE)    Display sense information\n*\n*  If SENSE+21 has the X'10' bit on, then a tape is mounted\n*  and this program will unload it.  Even if not unloaded,\n*  a Flex-ES flaw will cause it to unload when the next\n*  tape is requested.\n*\n*        TM    SENSE+21,X'10'     See if tape is present\n*        BZ    WRITE              No tape on drive, do not unload\n         TM    SENSE+00,X'40'     See if tape drive has Int.Req.\n         BO    WRITE              No tape on drive, do not unload\n         LA    R10,CCWRUN         Load address of sense CCW string\n         ST    R10,IOBCCWA        Store CCW string address for EXCP\n         XC    ECB,ECB            Clear any left over garbage in ECB\n         MODESET KEY=ZERO         PSW Key 0 for EXCP with own DEB\n         EXCP  IOB                Issue sense CCW\n         TM    ECB,ECBPOST        Was ECB posted?\n         BO    WRITE              Already posted, skip WAIT SVC\n         WAIT  ECB=ECB            Wait for sense to complete\n*\nNOWAIT3  DS    0H\n         MODESET KEY=NZERO        Switch back to non-key zero ( 8 )\n         WTO   'TAPESTAT - Tape unloaded',ROUTCDE=11\n         B     WRITE              Go complete and write output record\n*\nREADOKAY DS    0H\n         CLC   VOL1,INVOL1        See if a standard label tape\n         BE    SL                 Is standard label, skip no-label\n         MVC   OUTSTAT,NOLABEL    Move 'No-Label ' to output record\n         B     WRITE              Go complete and write output record\nSL       DS    0H\n         CLC   INVOL,INPUT        See if vol ser requested was read\n         BE    MATCHED            Vol sers matched, skip MisMatch\n         MVC   OUTSTAT,MISMATCH   Move 'MisMatch ' to output record\n         MVC   OUTOTHER,INVOL     Move read vol ser to output record\n         B     WRITE              Go complete and write output record\nMATCHED  DS    0H\n         CLC   EMPTAPE,INDSN      See if an empty tape\n* Next line commented out 2005-10-21, to bypass writing \"Empty\"\n*        BE    NODATA             Is empty, go report to output file\n* Next line added 2005-10-21, to bypass writing \"Empty\" tape records\n         BE    WRITE3             Go skip writing output     2005-10-21\n         CLC   ZEROES,INDSN       See if initialized tape\n* Next line commented out 2005-10-21, to bypass writing \"Empty\"\n*        BE    NODATA             Is initialized, go report to output\n* Next line added 2005-10-21, to bypass writing \"Empty\" tape records\n         BE    WRITE3             Go skip writing output     2005-10-21\n* Warning, Century is ignored so tapes with an expiration\n* date of 1999.365 and 1999.366 will almost never expire.\n         CLC   TODAY,INEXPDT+1    See if tape data set has expired\n         BH    EXPTAPE            Tape expired before today, go report\n         BE    EXPNOW             Tape expires today, go report\n         MVC   OUTSTAT,PROTECTD   Move 'Protected ' to output record\n         B     WRITE              Go complete and write output record\n*                                 *\n* Next four lines commented out 2005-10-21, to bypass writing \"Empty\"\n* NODATA   DS    0H                 *\n*        MVC   OUTSTAT,EMPTY      Move 'Empty ' to output record\n*        MVC   OUTEXPDT,OUTEXPDT-1  Clear expiration date\n*        B     WRITE2             Go complete and write output record\n*                                 *\nEXPNOW   DS    0H                 *\n         MVC   OUTSTAT,EXPTODAY   Move 'Exp-Today ' to output record\n         B     WRITE              Go complete and write output record\n*                                 *\nEXPTAPE  DS    0H                 *\n         MVC   OUTSTAT,EXPIRED    Move 'Expired ' to output record\n*        B     WRITE              Go complete and write output record\nWRITE    DS    0H\n         MVI   OUTCREDT,C'2'      Assume a century 2000 date\n         MVC   OUTCREDT+1(3),INCREDT  Move creation year CYY\n         MVI   OUTCREDT+4,C'.'    Insert a period\n         MVC   OUTCREDT+5(3),INCREDT+3  Move creation day\n         CLI   INCREDT,X'40'      See if a space for century ( 1900 )\n         BNE   EXPDT              Not a 1900 year, go process EXPDT\n         MVC   OUTCREDT(2),C19    Move 1900 century to output CREDT\nEXPDT    DS    0H\n         MVI   OUTEXPDT,C'2'      Assume a century 2000 date\n         MVC   OUTEXPDT+1(3),INEXPDT  Move expiration year CYY\n         MVI   OUTEXPDT+4,C'.'    Insert a period\n         MVC   OUTEXPDT+5(3),INEXPDT+3  Move expiration day\n         CLI   INEXPDT,X'40'      See if a space for century ( 1900 )\n         BNE   WRITE2             Not a 1900 year, skip '19' move\n         MVC   OUTEXPDT(2),C19    Move 1900 century to output EXPDT\nWRITE2   DS    0H\n         MVC   OUTVOL,INPUT       Move volume being read\n         MVC   OUTDSN,INDSN       Move data set name read from tape\n         PUT   STATS,OUTREC       Write an output record\n* Next line added 2005-10-21, to bypass writing \"Empty\" tape records\nWRITE3   DS    0H                                            2005-10-21\n         MVC   OUTOTHER,OUTOTHER-1  Space out \"other\" data\n         CLI   INPUT+6,C'-'       See if a range of tapes\n         BNE   GET                Not a range, go get next SYSIN\n         CLC   INPUT(6),INPUT+7   See if range completed processing\n         BNL   GET                Range complete, go get next SYSIN\n* dead   PACK  DWORK(3),INPUT+1(5)  Convert the tape number to COMP-3\n* dead   AP    DWORK(3),P1        Add one to the tape number\n* dead   UNPK  INPUT+1(5),DWORK(3)  Store new tape number\n* dead   OI    INPUT+5,X'F0'      Correct sign\n         LA    R9,INPUT+5         Load addr.past last byte to increment\nNEXTAPE  DS    0H\n         TM    0(R9),X'09'        See if maximum number in a digit\n         BO    NEXTAPE2           Is last, go clear and back up\n         IC    R1,0(,R9)          Load the digit to increment\n         LA    R1,1(,R1)          Bump number/letter by one\n         STC   R1,0(,R9)          Store new digit\n         B     GOTVOL             Go process the next volume\nNEXTAPE2 DS    0H\n         NI    0(R9),X'F0'        Set digit to zero\n         BCTR  R9,0               Back up one byte\n         B     NEXTAPE            Go back to increment previous digit\n*\n* The end\nEODAD    DS    0H\n         CLOSE STATS              Close output date file\n         CLOSE SYSIN              Close control statement file\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\nNODD     DS    0H\n         WTO   'TAPESTAT - TAPESTAT DD statement missing.',ROUTCDE=11\n         WTO   'TAPESTAT - It should look something like:',ROUTCDE=11\n         WTO 'TAPESTAT - //TAPESTAT DD UNIT=(TAPE,32,DEFER)',ROUTCDE=11\n         WTO   'TAPESTAT - Program abending without a dump.',ROUTCDE=11\n         ABEND 1                  Abend without a dump\n*\nBADSYSIN DS    0H\n         WTO   'TAPESTAT - SYSIN control card is invalid.',ROUTCDE=11\n         MVC   BADSYSI2+19(13),INPUT    Move bad data to display\nBADSYSI2 WTO   'TAPESTAT - xxxxxx-yyyyyy in not valid.',ROUTCDE=11\n         WTO   'TAPESTAT - Valid control cards are needed.',ROUTCDE=11\n         WTO   'TAPESTAT - Volume Serial number in 1-6 or',ROUTCDE=11\n         WTO   'TAPESTAT - range in 1-6 and 8-13 with',ROUTCDE=11\n         WTO   'TAPESTAT - a dash between.',ROUTCDE=11\n         WTO   'TAPESTAT - 1st character of each matching.',ROUTCDE=11\n         WTO   'TAPESTAT - Program abending without a dump.',ROUTCDE=11\n         ABEND 2                  Abend without a dump\n*\n*\nC19      DC    CL2'19'            Constant for 1900-1999 century\n*\nEMPTAPE  DC    CL11'EMPTY.TAPE '  Empty tape data set name\n*\nZEROES   DC    17C'0'             New initialized tape data set name\n*\nTODAY    DS    CL5                Date in YYDDD format\n*\n         DS    0D                 Align constants and work areas\n*\nSENSE    DS    XL32               Area to read sense information\n*\nWTOSENSE WTO   'Tape xxxxxx Sense: xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx-C\n               xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx-',ROUTCDE=11,MF=L\n         ORG   WTOSENSE+4         Back up the location counter\n         DC    CL5'Tape '         Part of WTO\nWTOVOL   DS    CL6                Vol ser of tape with error\n         DC    CL8' Sense: '      Part of WTO\nSENSEOUT DS    0CL72              Output display sense area\nSENSE00  DC    CL8'x',CL1' '      First word of sense in display format\nSENSE04  DC    CL8'x',CL1' '      Second word of sense in display\nSENSE08  DC    CL8'x',CL1' '      Third word of sense in display\nSENSE0C  DC    CL8'x',CL1' '      Fourth word of sense in display\nSENSE10  DC    CL8'x',CL1' '      Fifth word of sense in display format\nSENSE14  DC    CL8'x',CL1' '      Sixth word of sense in display\nSENSE18  DC    CL8'x',CL1' '      Seventh word of sense in display\nSENSE1C  DC    CL8'x',CL1' '      Eight word of sense in display\n         ORG   ,                  Resume with old location counter\n*\n         DS    0D                 Align constants and work areas\n*\n* dead TABLE    DC    256X'1'            Table to verify numeric\n* dead   ORG   TABLE+C'0'         Back up to display zero in table\n* dead   DC    10X'0'             Mark all numeric positions as valid\n* dead   ORG   ,                  Reset the location counter\n*\nTABLEEBC DC    CL16'0123456789ABCDEF'  Convert unpacked to display\n*\nTIOT     DS    F                  Task I/O Table address holder\n*\nVOL1     DC    CL4'VOL1'          Volume serial label begin\n*\nINVOL1   DS    CL80               Volume serial read in\nINVOL    EQU   INVOL1+4,6,C'C'    Input volume serial number\nINHDR1   DS    CL80               Header 1 label read in\nINDSN    EQU   INHDR1+4,17,C'C'   Data set name on tape\n* Note: C in INCREDT CYYDDD is blank for 1900, 0 for 2000, 1 for 2100\nINCREDT  EQU   INHDR1+41,6,C'C'   CYYDDD creation date read in\nINEXPDT  EQU   INHDR1+47,6,C'C'   CYYDDD expiration date read in\n*\nERROR    DC    CL9'Error-***'     Message type for output file\nNOLABEL  DC    CL9'No-Label'      Message type for output file\nMISMATCH DC    CL9'MisMatch'      Message type for output file\n* Next line commented out 2005-10-21, to bypass writing \"Empty\"\n* EMPTY    DC    CL9'Empty'         Message type for output file\nEXPIRED  DC    CL9'Expired'       Message type for output file\nEXPTODAY DC    CL9'Exp-Today'     Message type for output file\nPROTECTD DC    CL9'Protected'     Message type for output file\n*\nP1       DC    PL1'1'             Constant for addition\n*\nINPUT    DS    CL13               Input volume or volume range\n*\nOUTREC   DS    0CL59\nOUTVOL   DS    CL6                Tape volume serial requested\n         DC    CL1' '             Space\nOUTSTAT  DS    CL9                Output Status of the tape volume\n* Error, MisMatch, No-Label, Empty, Expired, or Protected\n         DC    CL1' '             Space\nOUTDSN   DS    CL17               Data set name from the tape label\n         DC    CL1' '             Space\nOUTCREDT DS    CL8                Creation date in YYYY.DDD format\n         DC    CL1' '             Space\nOUTEXPDT DS    CL8                Expiration date in YYYY.DDD format\n         DC    CL1' '             Space\nOUTOTHER DC    CL6' '             Errors like internal vol ser, etc.\n*\nECB      DC    F'0'               Event Control Block for EXCP\nECBPOST  EQU   X'40'              Indicator that ECB was posted\n*\n*\n* TAPESTAT DEB\n         DS    0D                 Insure alignment\nDEBVT    DS    0XL20              Data Extent Appendage Vector Table\n         DC    A(PSARET-PSA)  0   I/O appendage end-of-extent\n         DC    A(PSARET-PSA)  4   I/O appendage Start I/O\n         DC    A(PSARET-PSA)  8   I/O appendage Pgm.Contl.Intr.\n         DC    A(PSARET-PSA) 12   I/O appendage Channel end\n         DC    A(PSARET-PSA) 16   I/O appendage Abnormal end\n* DEB Prefix table\n         DC    3A(0)       20     Reserved?\n         DC    XL1'06'     32     Number of double-words in DEB ( 06 )\n         DC    XL1'00'     33     Unknown Access method type\n         DC    H'0'        34     Offset in DEB table for this DEB\nDEB      DS    0XL36\n         DC    A(0)        36     Address of TCB for this DCB\n         DC    AL1(4)      40     4 bytes in Acc.Meth.Dependent section\n         DC    AL3(0)      41     Address of next DEB in chain\n         DC    X'C0000000' 44     DEBDISP new data set\n         DC    XL1'30'     48     DEBOPATB Data set positioning leave\n         DC    AL3(0)      49     Addr.of first IOB in purge chain\n         DC    A(0)        52     Pointer to related request\n         DC    A(0)        56     Address of locate parameter list\n         DC    XL1'0F'     60     Indicate a DEB\n         DC    AL3(DCB)    61     Address of DCB or ACB\n         DC    AL1(2)      64     Half-words in DEB dev.dependent sect.\n         DC    AL3(DEBVT)  65     Addr. I/O app. vector table DEBVT\n* DEB Device dependent secion\n         DC    XL1'00'     68     Tape Modeset   ? X'D3' ?\nDEBUCB   DC    AL3(*-*)    69     Address of UCB\n         DC    F'0'        72     ?\n         DC    F'0'        76     ?\n         DC    F'0'        80     ?\n*\n* TAPESTAT DCB\nDCB      DS    0D\n         DC    10F'0'             40 byte unused for EXCP foundation\n         DC    H'0'               TIOT offset\n         DC    B'11010000'        MACRF byte 1\n* DCBMRECP EQU   DCBBIT0        EXECUTE CHANNEL PROGRAM (EXCP) ---\n* DCBMRFE  EQU   DCBBIT1        FOUNDATION EXTENSION IS PRESENT (EXCP)\n* DCBMRCI  EQU   DCBBIT3        COMMON INTERFACE (EXCP)\n         DC    B'00001000'        MACRF byte 2\n* DCBMR5WD EQU   DCBBIT4        FIVE-WORD DEVICE INTERFACE (EXCP)\n         DC    A(DEB)             Address of the DEB\n         DC    X'10000000'        OFLGS last I/O operation was a write\n*        DC    X'00000000'        OFLGS last I/O operation was read\n         DC    5F'0'              5 word EXCP device interface\n*\n*\n* IOB - Input/Output Block\nIOB      DS    0D                 IOB to mount a tape\n         DC    XL4'42000000'  0   Command Chaining and nonsequential\n* IOBCMDCH EQU   X'40' -   COMMAND CHAINING USED IN CHANNEL PROGRAM\n* IOBUNREL EQU   X'02' -   IOB UNRELATED FLAG (I.E., NONSEQUENTIAL)\n         DC    XL1'7F'        4   Addr. of expected I/O completion code\n         DC    AL3(ECB)       5   Address of the ECB\n         DC    D'0'           8   Channel Status Word\nIOBCCWA  DC    A(*-*)        16   Address of the Channel Command Words\n         DC    A(DCB)        20   Address of the Data Control Block\n         DC    A(0)          24   IOB Restart\n         DC    XL4'00010000' 28   Flags and counters\n*   Don't know what the bit means.  DEBE had it, so why not use it?\n         DC    D'0'          32   Seek address MBBCCHHR ? ? ? ?\n*\n*\n* X'80' Data Chaining\n* X'40' Command Chaining\n* X'20' Suppress Incorrect Length\n* X'10' Skip data transfer\n* X'08' Program Controlled Interruption\n* X'04' Indirect Data Address Word\n*\nCCWREAD  CCW   X'4B',MOUNT,X'60',L'MOUNT  Mount tape CCW\n         CCW   X'07',0,X'60',1    Rewind the tape\n         CCW   X'02',INVOL1,X'60',80  Read the VOL1 label\n         CCW   X'02',INHDR1,X'60',80  Read the HDR1 label\nCCWRUN   CCW   X'0F',0,X'20',1    Rewind-unload the tape\n*\nCCWSENSE CCW   X'04',SENSE,X'20',32  Read sense information\n*\n* The sense is checked to see if a tape is still on the\n* drive to know if an unload is needed.  Tape sense byte 21\n* should have bit X'10' on if a tape is loaded.\n* Since Flex-ES will unload the tape when the next one\n* is called for, an unload is not required.  If the\n* last tape, the operating system will unload the tape.\n*\nMOUNT    DC    CL21'/tape?/???/??????.aws'  Mount command\nMOUNT1   EQU   MOUNT+5,1          Last byte of file-system name\nMOUNT3   EQU   MOUNT+7,3          First three bytes of tape VolSer\nMOUNT6   EQU   MOUNT+11,6         Tape VolSer\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Data Control Blocks Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,RECFM=FB,EODAD=EODAD\nSTATS    DCB   DDNAME=STATS,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=59\nTAPEDD   DC    CL8'TAPESTAT'      DDNAME of tape\nTAPEDCB  DS    0D\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\nCLEARSIZ EQU   *-SAVEAREA\n         SPACE 1\n*\nDWORK    DS    D                  Double word work area\n*\nWORKSIZE EQU   *-SAVEAREA\n*\n*\n*\n         DCBD  DSORG=PS,DEVD=DA   Map the Data Control Block\n*\n         IEFTIOT1 ,               Map the Task Input/Output Table\n*\nPSA      IHAPSA DSECT=YES         Prefix Storage Area\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\nIOCSTUFF DSECT ,\n         IECDIOCM ,               I/O Communication area DSECT\n*\n*\nTAPESTAT CSECT ,\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DISP=SHR,DSN=????.LOAD????,SPACE=\n   SETCODE AC(1)\n   NAME TAPESTAT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPESYNC": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\r\\x00\\x17\\x01\\x05'\\x8f\\x01\\t4\\x7f E\\x01(\\x01%\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@\"", "ispf": {"version": "01.13", "flags": 0, "createdate": "2005-10-05T00:00:00", "modifydate": "2009-12-13T20:45:17", "lines": 296, "newlines": 293, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPESYNC-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'TAPESYNC - - - Updates TAPEBITS in memory for tapes in use'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    This tape reads a tape volumes data set with the tape\n*  expiration date in columes 37 through 44 and replaces\n*  TAPEBITS in memory with a new copy showing all tapes\n*  available except the ones that have a expiration date\n*  in the future.\n*\n*     Sample JCL:\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPESYNJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=SOMITCW,COND=(0,NE)\n* //TAPESYNC EXEC PGM=TAPESYNC\n* //STEPLIB  DD  DISP=SHR,DSN=????.LOAD????\n* //VOLUMES  DD  DISP=SHR,DSN=ACCUMULATED.TAPE.VOLUMES\n* //         DD  DISP=SHR,DSN=NEWER.LOCAL.TAPE.VOLUMES\n* //         DD  DISP=SHR,DSN=SOME.REMOTE.TAPE.VOLUMES\n* //* RECFM=FB forced and all normally LRECL=171\n* //SYSUDUMP DD  SYSOUT=*\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESYNC CSECT ,\nTAPESYNC AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPESYNC RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPESYNC.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPESYNC,R12       Give the assembler the new base\n         LH    R0,WORKLEN         Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         LR    R2,R1              Copy address of save area for MVCL\n         LH    R3,WORKLEN         Load length to clear with MVCL\n         SLR   R4,R4              Clear the MVCL from address\n         SLR   R5,R5              Clear the MVCL pad and from length\n         MVCL  R2,R4              Clear save area\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n* Get date\n         TIME  DEC                Get today's date in 0CYYDDDF format\n         ST    R1,DWORK           Store date to convert to display\n         AP    DWORK(4),P1900000  Change century number to a year no.\n         MVC   TODAY,MASK         Move YYYY.DDD EDit mask for date\n         ED    TODAY,DWORK        Convert P'YYYYDDDF' to C'YYYY.DDD'\n* Get TAPEBITS\n         L     R11,16             Load the address of the CVT\n         USING CVT,R11            Give assembler the CVT mapping\n         L     R11,CVTUSER        Load the address of the CVT user area\n         USING XCVTUSER,R11       Give assembler the CVTUSER mapping\n         CLC   XCVTUEYE,CVTUSER1  See if the CVTUSER area is valid\n         BNE   NOCVTUSR           Area not valid, can't access TAPEBITS\n         L     R11,XCVTTAPE       Load TAPEBITS address\n         USING TAPEBITS,R11       Give assembler the TAPEBITS mapping\n         CLC   TAPEEYE,TAPEBIT1   See if the TAPEBITS area is valid\n         BNE   NOBITS             Area not valid, can't access TAPEBITS\n* OPEN\n         MVC   VOLUMES(DUMDCBLN),DUMDCB  Move in DCB to work area\n         MVI   OPENLIST,X'80'     Mark only one DCB to open\n         OPEN  (VOLUMES,INPUT),MF=(E,OPENLIST)  Open VOLUMES file\nGET      DS    0H\n         GET   VOLUMES            Get volume record\n         LR    R10,R1             Save address of input volume record\n         USING RECIN,R10          Tell assembler where\n         CLC   TAPECHAR,VOLSER    vol ser start with TAPEBITS char.?\n         BNE   GET                Not one of our tapes, go ignore\n         TRT   VOLSER+1(5),TABLE  See if rest of vol ser numeric\n         BNZ   GET                Not five numerics, go ignore\n         CLC   PERM1,EX@YEAR+1    See if tape never expires 1999.365\n         BE    PROTECTD           Tape never expires, go turn bit on\n         CLC   PERM2,EX@YEAR+1    See if tape never expires 1999.366\n         BE    PROTECTD           Tape never expires, go turn bit on\n         CLC   TODAY,EX@YEAR+1    See if tape is expired or not\n         BNL   GET                Tape expired, bypass turning bit on\n*\n* Update new tape bits\n*\nPROTECTD DS    0H\n         PACK  DWORK,VOLSER+1(5)  Pack the numeric part of the vol ser\n         CVB   R8,DWORK           Load the tape number into a register\n         SLR   R9,R9              Clear a work register\n         SRDL  R8,3               Divide tape number by 8\n         SRL   R9,29              Find remainder\n* R8 contains the displacement of the byte to update within NEWBITS\n* R9 contains the displacement within BITS for the or mask\n         LA    R8,NEWBITS(R8)     Load the address of byte to update\n         LA    R9,BITS(R9)        Load the address of the bit mask\n         OC    0(1,R8),0(R9)      Mark the tape number as in use\n         B     GET                Go back to get another volume record\n*\n* The end\nEODAD    DS    0H\n         MVI   OPENLIST,X'80'     Mark only one DCB to CLOSE\n         CLOSE VOLUMES,MF=(E,OPENLIST)  Close VOLUMES file\n         LA    R2,TAPES           Load address of the old tape bits\n         LH    R3,H12500          Load the length of the old tape bits\n         LA    R4,NEWBITS         Load address of the new tape bits\n         LR    R5,R3              Load the length of the new tape bits\n         MODESET KEY=ZERO         Switch to key zero\n         MVCL  R2,R4              Overlay old tape bits with new\n         MVI   TAPEUPD,1          TAPESAVE will write TAPEBITS to disk\n         MODESET KEY=NZERO        Switch to key eight\n         LH    R0,WORKLEN         Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nNOCVTUSR DS    0H\n         WTO  'TAPESYNC - No CVTUSER area, program abending',ROUTCDE=11\n         ABEND 123                Abend without a dump\n*\nNOBITS   DS    0H\n         WTO 'TAPESYNC - No TAPEBITS area, program abending',ROUTCDE=11\n         ABEND 234                Abend without a dump\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0D                 Align Constants area\n*\nWORKLEN  DC    AL2(WORKSIZE)      Length of work area\n*\nH12500   DC    H'12500'           Length of bits for 100,000 tapes\n*\nP1900000 DC    PL4'1900000'       Constant to fix date's century\nMASK     DC    XL8'202020204B202020'  EDit mask for YYYY.DDD date\nPERM1    DC    CL8'1999.365'      Compare for never expire tape\nPERM2    DC    CL8'1999.366'      Compare for never expire tape\n*\n* The X'1' is the DSECT version number\nCVTUSER1 DC    CL7'CVTUSER',XL1'1'  Constant to check CVTUSER\nTAPEBIT1 DC    CL7'TAPEBIT',XL1'1'  Constant to check TAPEBIT\n*\nTABLE    DC    256X'1'            Table to check for numerics in volser\n         ORG   TABLE+240          Back up location counter to numbers\n         DC    10X'0'             Overlay numbers for TRT to not find\n         ORG   ,                  Return location counter to normal\n*\nBITS     DC    XL8'8040201008040201'  Bit to set on\n*\nDUMDCB   DCB   DDNAME=VOLUMES,DSORG=PS,MACRF=GL,RECFM=FB,EODAD=EODAD\nDUMDCBLN EQU   *-DUMDCB\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nDWORK    DS    D                  CVD work area\n*\nTODAY    DS    D                  Today in YYYY.DDD format\n*\nOPENLIST DS    D                  OPEN/CLOSE list\n*\nVOLUMES  DS    0D,XL(DUMDCBLN)    Input Volumes Data Control Block\n*\nNEWBITS  DS    XL12500            New TAPEBITS being created\n*\nWORKSIZE EQU   *-SAVEAREA\n*\n         SPACE 1\nRECIN    DSECT ,\n         COPY  TAPEDSCT           VOLUMES and DATASETS record layout\n* RECORD   DS   0CL171\n* VOLSER   DS   CL6    '??????'    Volume serial number\n* CL@DATE  DS   CL9   ' YYYY.DDD'  Date that tape was closed, YYYY.DDD\n* CL@HH    DS   CL3    ' HH'       Hour of day that tape was closed\n* CL@MM    DS   CL3    ':MM'       Minute of hour that tape was closed\n* CL@SS    DS   CL3    ':SS'       Second of minute that tape was close d\n* CL@TH    DS   CL3    '.TH'       Hundredth of second tape was closed\n* FILESEQN DS   CL6    ' nnnnn'    File sequence number\n* CODE     DS   CL2    ' O'  ' I'  Output or Input entry indicator code\n* EX@YEAR  DS   CL5    ' yyyy'     Tape expire year\n* EX@PER   DS   CL1    '.'         Period, separates EX@YEAR from EX@DA Y\n* EX@DAY   DS   CL3    'ddd'       Tape expire day\n* SCRDATE  DS   CL9    ' yyyy.ddd' Date the tape is put on Scratch list\n*          DS   CL1    ' '         Space\n* DSNAME   DS   CL44               Data set name\n* VOLSEQN  DS   CL4    ' nnn'      Volume sequence number\n* BLKCOUNT DS   CL10   ' zzzzzzzzn'  Block count on the tape\n* RECFM    DS   CL5    ' FBSA'     Record format of data set\n* LRECL    DS   CL7    ' zzzznK'   Logical record length of data set\n* BLKSIZE  DS   CL6    ' zzzzn'    Block size of data set\n*          DS   CL1    ' '         Space\n* SYSTEM   DS   CL4                SMF ID for the system name\n*          DS   CL1    ' '         Space\n* JOBNAME  DS   CL8                JOB name\n*          DS   CL1    ' '         Space\n* STEPNAME DS   CL8                Step name\n*          DS   CL1    ' '         Space\n* PGMNAME  DS   CL8                Program name\n*          DS   CL1    ' '         Space\n* DDNAME   DS   CL8                DDNAME\n*\n         COPY CVTUSER             Copy the CVTUSER area DSECT\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* * TAPESKIP DS    CL6            TAPESKIP was old name for XCVTSKIP\n* XCVTSKIP DS    CL6              IEC512I tape vol ser to ignore\n*          DS    XL22             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\nTAPEBITS   DSECT ,\n           COPY  TAPEBITS         Copy the TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n*          DS    CL6              TAPESKIP moved to CVTUSER as XCVTSKIP\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              Displacement to return to zero\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* * TAPEBIT0 EQU   X'80'            First tape within a byte\n* * * TAPEBIT1 EQU  X'40'           Second tape within a byte, dup.name\n* * TAPEBIT2 EQU   X'20'            Third tape within a byte\n* * TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* * TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* * TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* * TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* * TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESYNC CSECT ,\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n//*          UNIT=3390,VOL=SER=------\n   SETCODE AC(1)\n   NAME TAPESYNC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPESYN2": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x003\\x01\\x06!O\\x01\\t4\\x7f E\\x01\\x11\\x01\\x13\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2006-08-02T00:00:00", "modifydate": "2009-12-13T20:45:33", "lines": 273, "newlines": 275, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPESYN2-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=????.SORC????\nPASS TITLE 'TAPESYN2 - - - Updates TAPEBITS in memory for tapes in use'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    This tape reads a tape statistic data set to determine\n* which tape are not expired and marks them as protected\n* in TAPEBITS in memory.  Only expired tapes will be\n* eligiable to be used as scratch tapes.\n*\n*    By checking for not-expired instead of are-protected,\n* tapes that are in error, mislabeled, or other issues\n* will not be used as scratch tapes.\n*\n*    This program is the same as TAPESYNC except for the\n* input data set.  TAPESYNC uses data that came from SMF\n* records that do not account for tapes being reinitialized.\n* This program uses a tape statistic data set that was\n* created by reading tape labels so should be more accurate\n* for the tapes that were checked.\n*\n*     Sample JCL:\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPESYNJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=SOMITCW,COND=(0,NE)\n* //TAPESYN2 EXEC PGM=TAPESYN2\n* //STATS    DD  DISP=SHR,DSN=xxxx.TAPES.STATS(0)\n* //* RECFM=FB forced and normally LRECL=59\n* //SYSUDUMP DD  SYSOUT=*\n*\n* Written: 2006-08-02\n*\n* Blame: somitcw @ comcast.net\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESYN2 CSECT ,\nTAPESYN2 AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPESYN2 RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPESYN2.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPESYN2,R12       Give the assembler the new base\n         LH    R0,WORKLEN         Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         LR    R2,R1              Copy address of save area for MVCL\n         LH    R3,WORKLEN         Load length to clear with MVCL\n         SLR   R4,R4              Clear the MVCL from address\n         SLR   R5,R5              Clear the MVCL pad and from length\n         MVCL  R2,R4              Clear save area\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n* Get TAPEBITS\n         L     R11,16             Load the address of the CVT\n         USING CVT,R11            Give assembler the CVT mapping\n         L     R11,CVTUSER        Load the address of the CVT user area\n         USING XCVTUSER,R11       Give assembler the CVTUSER mapping\n         CLC   XCVTUEYE,CVTUSER1  See if the CVTUSER area is valid\n         BNE   NOCVTUSR           Area not valid, can't access TAPEBITS\n         L     R11,XCVTTAPE       Load TAPEBITS address\n         USING TAPEBITS,R11       Give assembler the TAPEBITS mapping\n         CLC   TAPEEYE,TAPEBIT1   See if the TAPEBITS area is valid\n         BNE   NOBITS             Area not valid, can't access TAPEBITS\n* OPEN\n         MVC   STATS(DUMDCBLN),DUMDCB  Move in DCB to work area\n         MVI   OPENLIST,X'80'     Mark only one DCB to open\n         OPEN  (STATS,INPUT),MF=(E,OPENLIST)  Open STATS file\nGET      DS    0H\n         GET   STATS              Get volume record\n         LR    R10,R1             Save address of input volume record\n         USING INREC,R10          Tell assembler where\n         CLC   TAPECHAR,INVOL     vol ser start with TAPEBITS char.?\n         BNE   GET                Not one of our tapes, go ignore\n         TRT   INVOL+1(5),TABLE   See if rest of vol ser numeric\n         BNZ   GET                Not five numerics, go ignore\n         CLC   EXPI(3),INSTAT     See if tape has expired\n         BE    GET                Tape has expires, do not protect\n*\n* Update new tape bits\n*\nPROTECTD DS    0H\n         PACK  DWORK,INVOL+1(5)   Pack the numeric part of the vol ser\n         CVB   R8,DWORK           Load the tape number into a register\n         SLR   R9,R9              Clear a work register\n         SRDL  R8,3               Divide tape number by 8\n         SRL   R9,29              Find remainder\n* R8 contains the displacement of the byte to update within NEWBITS\n* R9 contains the displacement within BITS for the or mask\n         LA    R8,NEWBITS(R8)     Load the address of byte to update\n         LA    R9,BITS(R9)        Load the address of the bit mask\n         OC    0(1,R8),0(R9)      Mark the tape number as in use\n         B     GET                Go back to get another volume record\n*\n* The end\nEODAD    DS    0H\n         MVI   OPENLIST,X'80'     Mark only one DCB to CLOSE\n         CLOSE STATS,MF=(E,OPENLIST)  Close STATS file\n         LA    R2,TAPES           Load address of the old tape bits\n         LH    R3,H12500          Load the length of the old tape bits\n         LA    R4,NEWBITS         Load address of the new tape bits\n         LR    R5,R3              Load the length of the new tape bits\n         MODESET KEY=ZERO         Switch to key zero\n         MVCL  R2,R4              Overlay old tape bits with new\n         MVI   TAPEUPD,1          TAPESAVE will write TAPEBITS to disk\n         MODESET KEY=NZERO        Switch to key eight\n         LH    R0,WORKLEN         Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nNOCVTUSR DS    0H\n         WTO  'TAPESYN2 - No CVTUSER area, program abending',ROUTCDE=11\n         ABEND 123                Abend without a dump\n*\nNOBITS   DS    0H\n         WTO 'TAPESYN2 - No TAPEBITS area, program abending',ROUTCDE=11\n         ABEND 234                Abend without a dump\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0D                 Align Constants area\n*\nWORKLEN  DC    AL2(WORKSIZE)      Length of work area\n*\nH12500   DC    H'12500'           Length of bits for 100,000 tapes\n*\nEXPI     DC    CL4'Exp'           To compare for an expired tape\n*\n* The X'1' is the DSECT version number\nCVTUSER1 DC    CL7'CVTUSER',XL1'1'  Constant to check CVTUSER\nTAPEBIT1 DC    CL7'TAPEBIT',XL1'1'  Constant to check TAPEBIT\n*\nTABLE    DC    256X'1'            Table to check for numerics in volser\n         ORG   TABLE+240          Back up location counter to numbers\n         DC    10X'0'             Overlay numbers for TRT to not find\n         ORG   ,                  Return location counter to normal\n*\nBITS     DC    XL8'8040201008040201'  Bit to set on\n*\nDUMDCB   DCB   DDNAME=STATS,DSORG=PS,MACRF=GL,RECFM=FB,EODAD=EODAD\nDUMDCBLN EQU   *-DUMDCB\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nDWORK    DS    D                  CVD work area\n*\nOPENLIST DS    D                  OPEN/CLOSE list\n*\nSTATS    DS    0D,XL(DUMDCBLN)    Input STATS Data Control Block\n*\nNEWBITS  DS    XL12500            New TAPEBITS being created\n*\nWORKSIZE EQU   *-SAVEAREA\n*\n         SPACE 1\nINREC    DSECT ,\nINRECRD  DS    0CL59              From program TAPESTAT\nINVOL    DS    CL6                Tape volume serial requested\n         DC    CL1' '             Space\nINSTAT   DS    CL9                Output Status of the tape volume\n* Error, MisMatch, No-Label, Empty, Expired, or Protected\n         DC    CL1' '             Space\nINDSN    DS    CL17               Data set name from the tape label     d\n         DC    CL1' '             Space\nINCREDT  DS    CL8                Creation date in YYYY.DDD format\n         DC    CL1' '             Space\nINEXPDT  DS    CL8                Expiration date in YYYY.DDD format\n         DC    CL1' '             Space                                 Y\nINOTHER  DC    CL6' '             Errors like internal vol ser, etc.\n*\n         COPY CVTUSER             Copy the CVTUSER area DSECT\n* XCVTUSER DSECT ,\n* XCVTUEYE DS    CL8              7 bytes of 'CVTUSER' and 1 byte X'01'\n* XCVTUVOL DS    XL6              VOLSER from message used by IEC507D\n*          DS    XL2              Space available for expansion\n* XCVTUTIM DS    XL6              CYYDDDHHMMSS Century, Year,Day, Hour,\n* *                               Minute, and Second, used by IOS000I\n*          DS    XL2              Space available for expansion\n* XCVTPSWD DS    F                ACF2 LGNIXIT anchor, used by SAVEPSWD\n* XCVTJOUR DS    F                DFHJC4508 Journal PRIM or SECO\n* XCVTTAPE DS    XL4              TAPE, TAPESAVE, TAPESYNC, & IGXMSGEX\n* * TAPESKIP DS    CL6            TAPESKIP was old name for XCVTSKIP\n* XCVTSKIP DS    CL6              IEC512I tape vol ser to ignore\n*          DS    XL22             Space available for expansion\n* XCVTUSIZ EQU   *-XCVTUSER       Length of area pointed to by CVTUSER\n*\nTAPEBITS   DSECT ,\n           COPY  TAPEBITS         Copy the TAPEBITS DSECT\n* TAPEEYE  DS    D                DSECT eye-catcher CL7'TAPEBIT',XL1'1'\n* TAPEOLD  DS    A                Addr of old TAPEBITS record to delete\n*          DS    CL6              TAPESKIP moved to CVTUSER as XCVTSKIP\n* TAPEDISP DS    XL2              Last TAPES byte that had a free bit\n* TAPEHIGH DS    XL2              Displacement to return to zero\n* TAPEUPD  DS    XL1              Tape bits updated, need writing\n* TAPECHAR DS    CL1              First byte of tapes described next\n* TAPES    DS    XL12500          Bits for 100,000 tapes ?00000-?99999\n* * TAPEBIT0 EQU   X'80'            First tape within a byte\n* * * TAPEBIT1 EQU  X'40'           Second tape within a byte, dup.name\n* * TAPEBIT2 EQU   X'20'            Third tape within a byte\n* * TAPEBIT3 EQU   X'10'            Fourth tape within a byte\n* * TAPEBIT4 EQU   X'08'            Fifth tape within a byte\n* * TAPEBIT5 EQU   X'04'            Sixth tape within a byte\n* * TAPEBIT6 EQU   X'02'            Seventh tape within a byte\n* * TAPEBIT7 EQU   X'01'            Eighth tape within a byte\n* TAPELEN  EQU   *-TAPEEYE        Length of TAPEBITS data record\n*\n         CVT   DSECT=YES,LIST=YES Communication Vector Table\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DATA CONTROL BLOCKS FOLLOW\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPESYN2 CSECT ,\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=\n   SETCODE AC(1)\n   NAME TAPESYN2\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAPEZERO": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x003\\x01\\x05)?\\x01\\t4\\x7f  \\x00\\xbf\\x00\\xbc\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2005-10-20T00:00:00", "modifydate": "2009-12-13T20:20:33", "lines": 191, "newlines": 188, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWT JOB (????????,????,1439,9999,9999),TAPEZERO-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//HLASMCL  EXEC HLASMCL,PARM.C=(NORENT,OBJECT,NODECK,TERM),\n//             PARM.L=NORENT\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\nPASS TITLE 'TAPEZERO - Clears expired tapes to save disk space'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*    This program reads SYSIN records and uses the first\n*  six bytes for a vol ser of a tape to erase.\n*\n*    Input SYSIN must have a valid vol ser in\n*  columns 1 through 6 or this program will abend.\n*\n*     Two sample JCLs:\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPEZERJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=SOMITCW,COND=(0,NE)\n* //TAPEZERO EXEC PGM=TAPEZERO\n* A00482 SYSIN is forced to RECFM=FB and needs a LRECL 6 or greater.\n* A00483 Only the first six bytes of each record are used.\n* A00486 Columns 7 through the end of record can be comments.\n* //TAPE     DD  UNIT=(TAPE,,DEFER)\n* //* RECFM=FB,LRECL=20,BLKSIZE=20 Forced by program\n* //SYSUDUMP DD  SYSOUT=*\n*\n* //xxxxxxxT JOB (xxxxxxxx,xxxx,1439,9999,9999),TAPEZERJ-xxxxxxxx,\n* //         CLASS=x,MSGCLASS=x,\n* //         NOTIFY=SOMITCW,COND=(0,NE)\n* //*\n* //TAPESTAT EXEC PGM=TAPESTAT\n* //STEPLIB  DD  DISP=SHR,DSN=xxxx.APF.LOADxxxx\n* C00000-C02999\n* //TAPESTAT DD  UNIT=(TAPE,32,DEFER)   Tie up all tape drives\n* //STATS    DD  DISP=(,CATLG,DELETE),DSN=SYSx.TAPES.STATS(+1),\n* //             UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n* //             DCB=$,RECFM=FB,LRECL=53\n* //SYSUDUMP DD  SYSOUT=*\n* //LOCK     DD  DISP=OLD,DSN='TAPESTAT is running',VOL=REF=$\n* //*\n* //SORT    EXEC PGM=SORT\n* //SYSOUT   DD  SYSOUT=*\n*  SORT FIELDS=COPY\n*  INCLUDE COND=(8,4,CH,EQ,C'Expi')  Copy expired tape records\n* //SORTIN   DD  DISP=SHR,DSN=SYSx.TAPES.STATS(+1)\n* //SORTOUT  DD  UNIT=SYSDA,SPACE=(TRK,(15,15)),DISP=(,PASS)\n* //*\n* //TAPEZERO EXEC PGM=TAPEZERO\n* //SYSIN    DD  DISP=(SHR,DELETE),DSN=*.SORT.SORTOUT\n* //TAPE     DD  UNIT=(TAPE,,DEFER)\n* //* RECFM=FB,LRECL=20,BLKSIZE=20 Forced by program\n* //SYSUDUMP DD  SYSOUT=*\n* //LOCK     DD  DISP=OLD,DSN='TAPEZERO is running',VOL=REF=$\n* //LOCK     DD  DISP=SHR,DSN='DAYBKUP is running',VOL=REF=$\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nTAPEZERO CSECT ,\nTAPEZERO AMODE 24                 Addressing mode of 24 for GET MACRO\nTAPEZERO RMODE 24                 Residency mode of 24 because of AMODE\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'TAPEZERO.&SYSDATE..&SYSTIME' Save Registers\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load the program's base register\n         USING TAPEZERO,R12       Give the assembler the new base\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(WORKSIZE,R1),0(R1)  Clear the work area\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING SAVEAREA,R13\n* OPEN SYSIN\n         OPEN  (SYSIN,INPUT)      Open SYSIN file\n* Read tape JOB File Control Block\n         RDJFCB TAPE              Read tape JFCB into storage\n         USING THEJFCB,JFCB       Tell assembler where the JFCB is\n         MVC   JFCBDSNM,DSNAME    Move 'EMPTY.TAPE ' to tape DSNAME\n         MVI   JFCBNVOL,1         Number of vol sers in JFCB\n*\nGET      DS    0H\n         GET   SYSIN              Get volume record\n         LR    R11,R1             Save address of input volume record\n         CLI   0(R11),X'40'       See if vol ser starts blank\n         BNH   BADVOL             Volser starts blank or less, go abend\n         TRT   1(5,R11),TABLE     See if volser ends with five numerics\n         BNZ   BADVOL             Volser last 5 bytes not numeric,abend\n         MVC   JFCBVOLS,0(R11)    Move vol ser to clear for OPENJ\n         OPEN  (TAPE,OUTPUT),TYPE=J  OPEN the tape as OUTPUT to clear\n         PUT   TAPE,OUTREC        Write 'TAPEZERO empty tape.'\n         CLOSE TAPE               CLOSE the tape\n         B     GET                Go do the next tape\n*\n* The end\nEODAD    DS    0H\n         CLOSE SYSIN              Close input SYSIN file\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R13)        Restore caller's save area address\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=(15)   Return to caller with FREEMAIN retcde\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Error routines\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nBADVOL   DS    0H\n         WTO 'TAPEZERO - Received a bad SYSIN record',ROUTCDE=11\n         WTO 'TAPEZERO - First six bytes are not a vol ser',ROUTCDE=11\n         WTO 'TAPEZERO - First byte must not be blank',ROUTCDE=11\n         WTO 'TAPEZERO - Last five bytes must be numeric',ROUTCDE=11\n         WTO 'TAPEZERO - Bad record starts with:',ROUTCDE=11\n         MVC  BADWTO+19(33),0(R11)  Put bad record in WTO message\nBADWTO   WTO  'TAPEZERO - 123456789 123456789 123456789 123',ROUTCDE=11\n         ABEND 123                Abend without a dump\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0D                 Align Constants area\n*\nDSNAME   DC    CL44'EMPTY.TAPE '  Data set name for cleared tapes\n*\nOUTREC   DC    CL20'TAPEZERO empty tape.'  Data written to tape\n*\n*\nTABLE    DC    256X'1'            Table to check for numerics in volser\n         ORG   TABLE+240          Back up location counter to numbers\n         DC    10X'0'             Overlay numbers for TRT to not find\n         ORG   ,                  Return location counter to normal\n*\nJFCB     DS    XL176              Area for JFCB for RDJFCB and OPENJ\n*\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,RECFM=FB,EODAD=EODAD\n*\nTAPE     DCB   DDNAME=TAPE,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=20,        C\n               BLKSIZE=20,EXLST=EXLST\n*\nEXLST    DC    X'87',AL3(JFCB)    Where RDJFCB puts the JFCB\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs Follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\nSAVEAREA DSECT ,\n         DS    9D                 Register save area\n*\nWORKSIZE EQU   *-SAVEAREA\n*\nTHEJFCB  DSECT ,\n         IEFJFCBN LIST=YES        Map the JOB File Control Block\n*\n*\nTAPEZERO CSECT ,\n         LTORG ,                  In case someone adds literals\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     REGISTER EQUATES\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//L.SYSLMOD DD DSN=????.LOAD????,DISP=SHR,SPACE=   ,\n   NAME TAPEZERO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT751/FILE751.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT751", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}