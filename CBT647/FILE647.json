{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012525000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1293292, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE647.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE647.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x15\\t'", "DS1TRBAL": "b'ZP'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x97\\x00\\x0b\\x04\\x99\\x00\\x02\\x00\\x16'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x00\\x01\\x01\\x11\\x10\\x0f\\x01\\x11\\x10\\x0f\\x02G\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-04-10T00:00:00", "modifydate": "2011-04-10T02:47:01", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-482"}, "text": "REGULAR CBT TAPE - VERSION 482    FILE:  647\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT482.FILE647\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 24 MEMBERS COUNTED; CUMULATIVE SIZE IS 11,814 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/10/11    02:47:01    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00I\\x01\\x07\\x12/\\x01\\x07\\x12/\\x12B\\x00F\\x00F\\x00\\x00\\xe5\\xf1K\\xf9K\\xf3@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2007-05-02T12:42:49", "lines": 70, "newlines": 70, "modlines": 0, "user": "V1.9.3"}, "text": "NAME     - PARSEXML\n\nTITLE    - A REXX XML PARSER\n\nVERSION  - 1.9.3\n\nFUNCTION - This is a Rexx XML parser that you can append to your\n           own Rexx source. You can then parse xml files into an\n           in-memory model and access the model via a DOM-like\n           API.\n\n           This version has been tested on TSO (using TSO/REXX) and\n           on Win32 and Ubuntu Linux 6.06 LTS (using Regina Rexx 3.3).\n\n\nMEMBERS  - The list of members in the distribution PDS are:\n\n           $$$DOC   - This file.\n           ASSERT   - Unit test assertion plumbing.\n           CARDPNG  - An image of a punched card (card.png)\n           DEVISIO  - An example of removing unwanted XML tags.\n           GPL      - The GNU General Public License.\n           IDLFILE  - An example IDL input for for IDL2WSDL rexx.\n           IDL2WSDL - EntireX IDL to WSDL file converter.\n           IO       - Basic Rexx I/O routines.\n           JCL2XML  - JCL to XML and GraphML file converter.\n           PAPERPNG - An image of an A4 sheet of paper (paper.png)\n           PARSEXML - The Rexx parser source.\n           PRETTY   - A pretty printer showing how to use the parser.\n           REXXPP   - A Rexx INCLUDE pre-processor.\n           SOAP     - A Rexx SOAP client.\n           TESTMOD  - Unit tests for XML modification API\n           TESTNEW  - Unit tests for XML creation API\n           TESTXML  - A sample xml file\n\nNOTES    - 1. The image files will have to be downloaded to your PC\n              in BINARY mode and renamed to:\n                CARDPNG -> card.png\n               PAPERPNG -> paper.png\n              ...or, you can source your own images.\n\nINSTALL  - 1. Copy the distribution library to your Rexx library.\n\n           2. Execute the REXXPP INCLUDE pre-processor by running:\n\n              REXXPP yourlib(PRETTY) PRETTYPP\n\n              This will append PARSEXML to PRETTY and create PRETTYPP.\n              You will be prompted for the location of each include\n              file that cannot be found.\n              Obviously, you can just use the editor if you prefer!\n\n           3. Execute PRETTYPP to parse the TESTXML file by:\n\n              PRETTYPP yourlib(TESTXML)   (NOBLANKS\n\n              If you supply any options, be sure to put a space before\n              the opening parenthesis. A closing parenthesis is\n              optional.\n\n           4. Repeat steps 2 and 3 for each of the other sample Rexx\n              procedures if you want.\n\nUSAGE      - See the PARSEXML rexx procedure for more information\n\n\n\nAUTHOR     - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>\n\n----------------------------END OF $$$DOC-------------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$DOC1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00@\\x01\\x11\\x10\\x0f\\x01\\x11\\x10\\x0f\\x02\\x12\\x006\\x006\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2011-04-10T00:00:00", "modifydate": "2011-04-10T02:12:40", "lines": 54, "newlines": 54, "modlines": 0, "user": "V2.0.1"}, "text": "NAME     - PARSEXML\n\nTITLE    - A REXX XML PARSER\n\nVERSION  - 2.0.0\n\nFUNCTION - This is a Rexx XML parser that you can append to your\n           own Rexx source. You can then parse xml files into an\n           in-memory model and access the model via a DOM-like\n           API.\n\n           This version has been tested on TSO (using TSO/REXX) and\n           on Win32 and Ubuntu Linux 6.06 LTS (using Regina Rexx 3.3).\n\n\nMEMBERS  - The list of members in the distribution PDS are:\n\n           README       - This file.\n           ASSERT       - Unit test assertion plumbing.\n           DEVISIO      - An example of removing unwanted XML tags.\n           IDLFILE      - An example IDL input for for IDL2WSDL rexx.\n           IDL2WSDL     - EntireX IDL to WSDL file converter.\n           IO           - Basic Rexx I/O routines.\n           JCL2XML      - JCL to XML and GraphML file converter.\n           PARSEXML     - The Rexx parser source.\n           PRETTY       - A pretty printer showing how to use the parser.\n           REXXPP       - A Rexx INCLUDE pre-processor.\n           SOAP         - A Rexx SOAP client.\n           TESTMOD      - Unit tests for XML modification API\n           TESTNEW      - Unit tests for XML creation API\n           TESTXML      - A sample xml file\n\nINSTALL  - 1. Copy the distribution library to your Rexx library.\n\n           2. Execute the REXXPP INCLUDE pre-processor by running:\n\n              REXXPP yourlib(PRETTY) PRETTYPP\n\n              This will append PARSEXML to PRETTY and create PRETTYPP.\n              You will be prompted for the location of each include\n              file that cannot be found.\n              Obviously, you can just use the editor if you prefer!\n\n           3. Execute PRETTYPP to parse the TESTXML file by:\n\n              PRETTYPP yourlib(TESTXML)   (NOBLANKS\n\n              If you supply any options, be sure to put a space before\n              the opening parenthesis. A closing parenthesis is\n              optional.\n\n           4. Repeat steps 2 and 3 for each of the other sample Rexx\n              procedures if you want.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x06\\x14_\\x01\\x06\\x14_\\tR\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-05-25T00:00:00", "modifydate": "2006-05-25T09:52:53", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     File 647 - Rexx XML parser v1.9\nFrom:        Andrew Armstrong <andrew_armstrong@unwired.com.au>\nDate:        Thu, 25 May 2006 17:38:14 +1000\nTo:          Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nThis is an update to File 647 (rexx XML parser) package.\nNew in V1.9:\n\n1. New: IDL2WSDL - Converts an EntireX Interface Definition\n   Language (IDL) file to a Web Services Description Language (WSDL)\n   file.  This could be useful for people who want to re-implement\n   SoftwareAG EntireX applications as Web Services (on CICS for\n   example).\n\n2. Updated: REXXPP - An improved Rexx include pre-processor now\n   prompts the user when a file to be included cannot be found.\n\nCheers,\nA.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x07\\x13\\x7f\\x01\\x07\\x13\\x7f\\x07I\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-05-17T00:00:00", "modifydate": "2007-05-17T07:49:06", "lines": 20, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     File 647 (Rexx XML Parser) v1.9.3\nFrom:        Andrew Armstrong <andrew_armstrong@unwired.com.au>\nDate:        Wed, 02 May 2007 17:52:04 +1000\nTo:          Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nI have attached another update (1.9.3) to CBT File 647 (Rexx XML\nParser). This version has been improved with bug fixes and code\ncontributions from Alessandro Battilani (Banca Intessa, Italy)\nand Herbert Frommwieser and Anne Feldmeier (BMW, Germany).\n\nThe JCL-to-XML converter (jcl2xml.rexx) has seen the most changes\n- including support for JES3 statements and Tivoli Workload\nScheduler directives. The change logs at the beginning of each\nrexx file have more detail.\n\nCheers,\nA.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE3": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x11\\x10\\x0f\\x01\\x11\\x10\\x0f\\x02E\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-04-10T00:00:00", "modifydate": "2011-04-10T02:45:32", "lines": 26, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: REXX INCLUDE ?\nFrom:     Andrew Armstrong <androidarmstrong@GMAIL.COM>\nDate:     Sat, 9 Apr 2011 02:26:20 -0500\n\nFWIW, I wrote an \"INCLUDE\" processor for Rexx as part of my Rexx\nXML Parser many moons ago. I've recently published it as a\nSourceForge project (more current than the CBT647 file - no\noffence to CBT guys, it's just that I like the subversion version\ncontrol that sourceforge provides). See:\n\nhttp://sourceforge.net/projects/rexxxmlparser/\n\n...and browse the SVN code repository for rexxpp.rex. It's nothing\nmagical (i.e. any rexx programmer could have done it) but I found\nit useful for my purposes.\n\nThe idea is that you run it to regenerate your Rexx source which\nhas the INCLUDE directives embedded as comments. A new Rexx source\nfile is produced with all the most current \"included\" source files.\nYou could do that at run time, but it would be additional overhead.\nProbably best to just regenerate your source files whenever an\n\"included\" file changes.\n\nCheers,\nAndrew.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE647": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x00I\\x01\\x11\\x10\\x0f\\x01\\x11\\x10\\x0f\\x02F\\x00H\\x00H\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-04-10T00:00:00", "modifydate": "2011-04-10T02:46:49", "lines": 72, "newlines": 72, "modlines": 0, "user": "CBT-482"}, "text": "//***FILE 647 is an XML parser written in REXX, from Andrew J.      *   FILE 647\n//*           Armstrong.                                            *   FILE 647\n//*                                                                 *   FILE 647\n//*           email:  andrew_armstrong@unwired.com.au               *   FILE 647\n//*                                                                 *   FILE 647\n//*     NAME     - PARSEXML                                         *   FILE 647\n//*                                                                 *   FILE 647\n//*     TITLE    - A REXX XML PARSER                                *   FILE 647\n//*                                                                 *   FILE 647\n//*     VERSION  - 2.0.0                                            *   FILE 647\n//*                                                                 *   FILE 647\n//*     FUNCTION - This is a Rexx XML parser that you can           *   FILE 647\n//*                append to your own Rexx source. You can then     *   FILE 647\n//*                parse xml files into an in-memory model and      *   FILE 647\n//*                access the model via a DOM-like API.             *   FILE 647\n//*                                                                 *   FILE 647\n//*                This version has been tested on TSO (using       *   FILE 647\n//*                TSO/REXX) and on Win32 and Ubuntu Linux 6.06     *   FILE 647\n//*                LTS (using Regina Rexx 3.3).                     *   FILE 647\n//*                                                                 *   FILE 647\n//*     MEMBERS  - The list of members in the distribution PDS      *   FILE 647\n//*                are:                                             *   FILE 647\n//*                                                                 *   FILE 647\n//*                README    - This file.                           *   FILE 647\n//*                ASSERT    - Unit test assertion plumbing.        *   FILE 647\n//*                DEVISIO   - An example of removing unwanted      *   FILE 647\n//*                            XML tags.                            *   FILE 647\n//*                IDLFILE   - An example IDL input for for         *   FILE 647\n//*                            IDL2WSDL rexx.                       *   FILE 647\n//*                IDL2WSDL  - EntireX IDL to WSDL file converter.  *   FILE 647\n//*                IO        - Basic Rexx I/O routines.             *   FILE 647\n//*                JCL2XML   - JCL to XML and GraphML file converter*   FILE 647\n//*                PARSEXML  - The Rexx parser source.              *   FILE 647\n//*                PRETTY    - A pretty printer showing how to      *   FILE 647\n//*                            use the parser.                      *   FILE 647\n//*                REXXPP    - A Rexx INCLUDE pre-processor.        *   FILE 647\n//*                SOAP      - A Rexx SOAP client.                  *   FILE 647\n//*                TESTMOD   - Unit tests for XML modification API  *   FILE 647\n//*                TESTNEW   - Unit tests for XML creation API      *   FILE 647\n//*                TESTXML   - A sample xml file                    *   FILE 647\n//*                                                                 *   FILE 647\n//*     NOTES    - 1. The image files will have to be downloaded    *   FILE 647\n//*                   to your PC in BINARY mode and renamed to:     *   FILE 647\n//*                                                                 *   FILE 647\n//*                     CARDPNG -> card.png                         *   FILE 647\n//*                    PAPERPNG -> paper.png                        *   FILE 647\n//*                   ...or, you can source your own images.        *   FILE 647\n//*                                                                 *   FILE 647\n//*     USAGE      - See the PARSEXML rexx procedure for more       *   FILE 647\n//*                  information                                    *   FILE 647\n//*                                                                 *   FILE 647\n//*     AUTHOR     - Andrew J. Armstrong                            *   FILE 647\n//*                  email:  <andrew_armstrong@unwired.com.au>      *   FILE 647\n//*                                                                 *   FILE 647\n//*     HISTORY                                                     *   FILE 647\n//*     Date     By       Reason (most recent at the top pls)       *   FILE 647\n//*     -------- -------- ------------------------------------      *   FILE 647\n//*                                                                 *   FILE 647\n//*     20051014 AJA      Version 1.7                               *   FILE 647\n//*     20050610 AJA      Version 1.6                               *   FILE 647\n//*     20040706 AJA      Added creation/modification support.      *   FILE 647\n//*     20031216 AJA      Bugfix: _parseElement with no attrs       *   FILE 647\n//*                       causes crash.                             *   FILE 647\n//*     20031031 AJA      Correctly parse '/' in attributes.        *   FILE 647\n//*                       Fixed entity resolution.                  *   FILE 647\n//*     20030912 AJA      Bugfix: Initialize sXmlData first.        *   FILE 647\n//*                       Bugfix: Correctly parse a naked '>'       *   FILE 647\n//*                       present in an attribute value.            *   FILE 647\n//*                       Enhancement: DUMP option now displays     *   FILE 647\n//*                       first part of each text node.             *   FILE 647\n//*     20030901 AJA      Initial version.                          *   FILE 647\n//*                                                                 *   FILE 647\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSERT": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00I\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00g\\x00^\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:49", "lines": 103, "newlines": 94, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: assert.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - ASSERT                                                 **\n**                                                                   **\n** FUNCTION - Unit test assertion plumbing.                          **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - n/a                                                    **\n**                                                                   **\n** NOTES    - 1. You will have to either append the ASSERT rexx code **\n**               manually to your Rexx source, or run your Rexx      **\n**               source through the REXXPP rexx pre-processor.       **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               rexxpp yourrexx xyz                                 **\n**                                                                   **\n**               ...and then run the resulting 'xyz' rexx procedure: **\n**                                                                   **\n**               xyz                                                 **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20060803 AJA Added message number to messages.         **\n**            20050517 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n  parse source . . sSourceFile .\n  parse value sourceline(1) with . sVersion\n  say 'Unit test routines' sVersion\n  say 'You cannot invoke this rexx by itself!'\n  say\n  say 'This rexx is a collection of subroutines to be called'\n  say 'from your own rexx procedures. You should either:'\n  say '  - Append this procedure to your own rexx procedure,'\n  say '    or,'\n  say '  - Append the following line to your rexx:'\n  say '    /* INCLUDE' sSourceFile '*/'\n  say '    ...and run the rexx preprocessor:'\n  say '    rexxpp myrexx myrexxpp'\n  say '    This will create myrexxpp by appending this file to myrexx'\nexit\n\nassertEquals: procedure\n  parse arg expected,actual,message\n  if actual <> expected\n  then call failNotEquals expected,actual,message\nreturn\n\nassertTrue: procedure\n  parse arg condition,message\n  if condition = 0\n  then call failNotEquals 1,condition,message\nreturn\n\nassertFalse: procedure\n  parse arg condition,message\n  if condition = 1\n  then call failNotEquals 0,condition,message\nreturn\n\nfailNotEquals: procedure:\n  parse arg expected,actual,message\n  reason = 'expected:<'expected'> but was:<'actual'>'\n  if message = ''\n  then say 'ASS001E Assertion failed:' reason\n  else say 'ASS002E Assertion failed:' message reason\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUX2SVG": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x10\\x0f\\x01\\x11\\x10\\x0f\\x02\\x15\\x06\\x9d\\x06\\x9d\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-04-10T00:00:00", "modifydate": "2011-04-10T02:15:00", "lines": 1693, "newlines": 1693, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: aux2svg.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - AUX2SVG                                                **\n**                                                                   **\n** FUNCTION - Creates a graphical representation of a CICS auxiliary **\n**            trace printout by using Scalable Vector Graphics (SVG).**\n**            The SVG markup represents the trace data in the form   **\n**            of a Unified Modelling Language (UML) Sequence Diagram **\n**            (or at least something quite like it).                 **\n**                                                                   **\n**            The 'actors' (for example, programs) are listed side-  **\n**            by-side at the top of the diagram. A life line is      **\n**            drawn vertically below each actor. Interactions        **\n**            between actors (for example, calls and returns) are    **\n**            represented as arrows drawn between the life lines.    **\n**            The vertical axis is time. Each interaction is labeled **\n**            on the left of the diagram with the relative time in   **\n**            seconds since the start of the trace and the task id.  **\n**            All the interactions for a task are assigned the same  **\n**            unique color. Each interaction is annotated with the   **\n**            trace sequence number, to enable you to refer back to  **\n**            the original trace record for more detail, and a summ- **\n**            ary of the call and return values. Exception responses **\n**            are shown in red.                                      **\n**                                                                   **\n**            You choose which actors you are interested in by       **\n**            specifying one or more domain names. For example, if   **\n**            you want to visualize TCP/IP socket activity, you      **\n**            might specify the PG (program) and SO (socket) domains:**\n**                                                                   **\n**              aux2svg mytrace.txt (PG SO                           **\n**                                                                   **\n**            If you want to examine a storage allocation problem    **\n**            you might specify the SM (storage manager) domain:     **\n**                                                                   **\n**              aux2svg mytrace.txt (SM                              **\n**                                                                   **\n**            By default, ALL domains are selected but this can take **\n**            a long time to process. It is best to restrict the     **\n**            actors to a few domains that you are interested in.    **\n**                                                                   **\n**            More documentation is at:                              **\n**                                                                   **\n**            http://sites.google.com/site/auxiliarytracevisualizer  **\n**                                                                   **\n**                                                                   **\n** USAGE    - You can run this Rexx on an IBM mainframe, or on a PC  **\n**            by using either Regina Rexx or ooRexx from:            **\n**                                                                   **\n**               http://regina-rexx.sourceforge.net                  **\n**               http://oorexx.sourceforge.net                       **\n**                                                                   **\n**            If you run aux2svg on your mainframe, you should use   **\n**            ftp to download the resulting svg and html files by:   **\n**                                                                   **\n**            ftp yourmainframe                                      **\n**            youruserid                                             **\n**            yourpassword                                           **\n**            quote site sbdataconn=(IBM-1047,ISO8859-1)             **\n**            get 'your.output.html' your.output.html                **\n**            get 'your.output.svg'  your.output.svg                 **\n**                                                                   **\n**            It is easier to download the CICS trace print file and **\n**            run aux2svg.rexx on your PC using Regina Rexx by:      **\n**                                                                   **\n**            rexx aux2svg.rexx your.trace.txt (options...           **\n**                                                                   **\n**            You can view the resulting SVG file using either:      **\n**                                                                   **\n**            1. Mozilla Firefox 1.5, or later, has native SVG rend- **\n**               ering capability.                                   **\n**                                                                   **\n**            2. Microsoft Internet Explorer 6 with the Adobe SVG    **\n**               Viewer plugin installed. The plugin is free from    **\n**               www.adobe.com. Open the html file created by this   **\n**               Rexx if you want to scroll the output in the        **\n**               browser. Alternatively, you could publish the html  **\n**               file on a web server and point your browser at that **\n**               web server. Adobe SVG Viewer supports the following **\n**               mouse/key actions:                                  **\n**               LeftButton+Ctrl           Zoom in                   **\n**               LeftButton+Ctrl+Shift     Zoom out                  **\n**               LeftButton+Alt            Move                      **\n**               LeftButton+Alt+Shift      Move constrained          **\n**               Tool tips are not supported by this viewer yet.     **\n**                                                                   **\n**            3. Apache Batik Squiggle program with Sun Java 1.3 or  **\n**               later installed. Batik is free from www.apache.org  **\n**               To run Squiggle: java -jar batik-squiggle.jar       **\n**               Squiggle supports the following mouse/key actions:  **\n**               LeftButton+Ctrl (+drag)   Zoom in to rectangle      **\n**               LeftButton+Shift (+drag)  Move                      **\n**               RightButton+Ctrl (+drag)  Rotate                    **\n**               RightButton+Shift (+drag) Zoom (in or out)          **\n**               Squiggle shows tool tips when you hover the mouse   **\n**               over items that have a tool tip defined.            **\n**                                                                   **\n**            4. Microsoft Visio 2003 or later.                      **\n**                                                                   **\n** SYNTAX   - AUX2SVG infile [(options...]                           **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = Name of file to read auxtrace printout from.**\n**            options  = DETAIL - Include hex data for each record.  **\n**                       XML    - Create xml file from input file.   **\n**                       HTML   - Create HTML file wrapper for SVG.  **\n**                                This allows you to scroll the SVG  **\n**                                in Internet Explorer.              **\n**                       EVENT  - Process input EVENT trace records. **\n**                       DATA   - Process input DATA trace records.  **\n**                       To negate any of the above options, prefix  **\n**                       the option with NO. For example, NOHTML.    **\n**                       xx     - One or more 2-letter domain names  **\n**                                that you want to process. The      **\n**                                default is all trace domains and   **\n**                                can be much slower. For example,   **\n**                                to show socket activity you would  **\n**                                specify PG and SO.                 **\n**                                                                   **\n** LOGIC    - 1. Create an in-memory <svg> document.                 **\n**                                                                   **\n**            2. Create an in-memory <auxtrace> element, but do not  **\n**               connect it to the <svg> document.                   **\n**                                                                   **\n**            3. Scan the auxiliary trace output and convert each    **\n**               pair of ENTRY/EXIT trace entries into a single XML  **\n**               <trace> element. Add each <trace> element to the    **\n**               <auxtrace> element and nest the <trace> elements.   **\n**               The <auxtrace> element is a temporary representation**\n**               of the auxiliary trace data and will be discarded   **\n**               and/or written to an output file later.             **\n**                                                                   **\n**            4. Walk through the tree of <trace> elements and when  **\n**               an interesting <trace> element is found, add        **\n**               appropriate SVG markup to the <svg> element in order**\n**               to visualize the <trace> element.                   **\n**                                                                   **\n**            5. Output an SVG document by using the PrettyPrinter   **\n**               routine to 'print' the <svg> element to a file.     **\n**                                                                   **\n**            6. Output an XML document by using the PrettyPrinter   **\n**               routine to 'print' the <auxtrace> element (only if  **\n**               the XML option was specified).                      **\n**                                                                   **\n** EXAMPLE  - 1. To investigate a socket programming problem:        **\n**                                                                   **\n**               AUX2SVG auxtrace.txt (PG SO DETAIL XML              **\n**                                                                   **\n**               This will create the following files:               **\n**                 auxtrace.svg  - SVG representation of trace.      **\n**                 auxtrace.html - HTML to scroll the SVG.           **\n**                 auxtrace.xml  - XML representation of trace.      **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20060120 AJA Conform to CSS2 requirements of           **\n**                         Mozilla Firefox 1.5 (font-size must       **\n**                         have a unit, stroke-dasharray must        **\n**                         use a comma as a delimiter).              **\n**            20051027 AJA Draw colored arrow heads.                 **\n**            20051026 AJA Set xml name space to 'svg' (oops!).      **\n**            20051025 AJA Minor changes. Fixed bug in parsexml.     **\n**            20051018 AJA Documentation corrections. Enhanced       **\n**                         getDescriptionOfCall() for CC, GC,        **\n**                         DS and AP domains.                        **\n**            20051014 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn' ('sOptions')'\n\n  numeric digits 16\n  parse value sourceline(1) with . sVersion\n  say 'AUX000I CICS Auxiliary Trace Visualizer' sVersion\n  if sFileIn = ''\n  then do\n    say 'Syntax:'\n    say '   aux2svg infile [(options]'\n    say\n    say 'Where:'\n    say '   infile  = CICS auxiliary trace print file'\n    say '   options = DETAIL - Include hex data for each record.'\n    say '             XML    - Create xml file from input file.'\n    say '             HTML   - Create HTML file wrapper for SVG.'\n    say '                      This allows you to scroll the SVG'\n    say '                      in Internet Explorer.'\n    say '             EVENT  - Include EVENT trace records.'\n    say '             DATA   - Include DATA trace records.'\n    say '             To negate of the above options, prefix the'\n    say '             option with NO. For example, NOHTML.'\n    say '             xx     - One or more 2-letter domain names'\n    say '                      that you want to process. The'\n    say '                      default is all trace domains and'\n    say '                      can be much slower. For example,'\n    say '                      to show socket activity you would'\n    say '                      specify PG and SO.'\n    exit\n  end\n  say 'AUX001I Scanning CICS auxiliary trace in' sFileIn\n\n  sOptions = 'NOBLANKS' translate(sOptions)\n  call initParser sOptions /* DO THIS FIRST! Sets g. vars to '' */\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call setFileNames sFileIn\n  call setOptions sOptions\n  call Prolog\n\n  doc = createDocument('svg')\n\n  call scanAuxTraceFile\n\n  if g.!OPTION.DUMP\n  then call _displayTree\n\n  if g.!OPTION.XML\n  then do\n    call setDocType /* we don't need a doctype declaration */\n    call prettyPrinter g.!FILEXML,,g.!AUXTRACE\n  end\n\n  call buildSVG\n\n  call setPreserveWhitespace 1 /* to keep newlines in <desc> tags */\n  call prettyPrinter g.!FILESVG\n\n  if g.!OPTION.HTML\n  then call createHTML\n\n  call Epilog\nexit\n\n/* The auxtrace input filename is supplied by the user.\nThe names of the SVG, XML and HTML output files are automatically\ngenerated from the input file filename. The generated file names also\ndepend on the operating system. Global variables are set as follows:\ng.!FILETXT = name of input text file  (e.g. auxtrace.txt)\ng.!FILESVG = name of output SVG file  (e.g. auxtrace.svg)\ng.!FILEXML = name of output XML file  (e.g. auxtrace.xml)\ng.!FILEHTM = name of output HTML file (e.g. auxtrace.html)\n*/\nsetFileNames: procedure expose g.\n  parse arg sFileIn\n  if g.!ENV = 'TSO'\n  then do\n    parse var sFileIn sDataset'('sMember')'\n    if sMember <> ''\n    then do /* make output files members in the same PDS */\n      sPrefix = strip(left(sMember,7)) /* room for a suffix char */\n      sPrefix = translate(sPrefix) /* translate to upper case */\n      g.!FILETXT = translate(sFileIn)\n      /* squeeze the file extension into the member name...*/\n      g.!FILESVG = sDataset'('strip(left(sPrefix'SVG',8))')'\n      g.!FILEXML = sDataset'('strip(left(sPrefix'XML',8))')'\n      g.!FILEHTM = sDataset'('strip(left(sPrefix'HTM',8))')'\n    end\n    else do /* make output files separate datasets */\n      g.!FILETXT = translate(sFileIn)\n      g.!FILESVG = sDataset'.SVG'\n      g.!FILEXML = sDataset'.XML'\n      g.!FILEHTM = sDataset'.HTML'\n    end\n  end\n  else do\n    sFileName  = getFilenameWithoutExtension(sFileIn)\n    g.!FILETXT = sFileIn\n    g.!FILESVG = sFileName'.svg'\n    g.!FILEXML = sFileName'.xml'\n    g.!FILEHTM = sFileName'.html'\n  end\nreturn\n\ngetFilenameWithoutExtension: procedure expose g.\n  parse arg sFile\n  parse value reverse(sFile) with '.'sRest\nreturn reverse(sRest)\n\nscanAuxTraceFile: procedure expose g.\n  g.!AUXTRACE = createElement('auxtrace')\n  g.!FILEIN = openFile(g.!FILETXT)\n  g.!K = 0   /* Trace entry count */\n  g.!KD = 0  /* Trace entry delta since last progress message */\n\n  sLine = getLineContaining('CICS - AUXILIARY TRACE FROM')\n  parse var sLine 'CICS - AUXILIARY TRACE FROM ',\n                   sDate ' - APPLID' sAppl .\n  call setAttributes g.!AUXTRACE,,\n       'date',sDate,,\n       'appl',sAppl\n\n  g.!ROWS = 0\n  bAllDomains = words(g.!DOMAIN_FILTER) = 0\n  sEntry = getFirstTraceEntry()\n  parse var g.!ENTRYDATA.1 '='g.!FIRSTSEQ'=' .\n  do while g.!RC = 0\n    parse var sEntry sDomain xType sModule sAction sParms\n    if g.!FREQ.sDomain = ''\n    then do\n      g.!FREQ.sDomain = 0\n      if g.!DOMAIN.sDomain = ''\n      then say 'AUX002W Unknown domain \"'sDomain'\" found in' sEntry\n    end\n    g.!FREQ.sDomain = g.!FREQ.sDomain + 1\n    if bAllDomains | wordpos(sDomain,g.!DOMAIN_FILTER) > 0\n    then do\n      parse var g.!ENTRYDATA.1 'TASK-'nTaskId . 'TIME-'sTime .,\n                               'INTERVAL-'nInterval . '='nSeq'=' .\n      if g.!TASK.nTaskId = '' /* if task is new */\n      then do\n        call initStack nTaskId\n        e = createElement('task')\n        call pushStack nTaskId,e\n        g.!TASK.nTaskId = e\n        call appendChild e,g.!AUXTRACE\n        call setAttribute e,'taskid',nTaskId\n      end\n      task = g.!TASK.nTaskId\n\n      nElapsed = getElapsed(sTime)\n      select\n        when sAction = 'ENTRY' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = strip(sParms)\n          select\n            when left(sParms,1) = '-' then do /* if new style parms */\n              /* ENTRY - FUNCTION(xxx) yyy(xxx) ... */\n              sParms = space(strip(sParms,'LEADING','-'))\n              if pos('FUNCTION(',sParms) > 0\n              then do\n                parse var sParms 'FUNCTION('sFunction')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n              end\n              else do\n                if left(sParms,1) = '*'\n                /* e.g. '** Decode of parameter list failed **' */\n                then sFunction = sParms\n                else parse var sParms sFunction sParms\n              end\n            end\n            when pos('REQ(',sParms) > 0 then do /* old style parms */\n              /* ENTRY function                 REQ(xxx) ... */\n              parse var sParms sFixed'REQ('sParms\n              sParms = 'REQ('sParms\n              parse var sFixed sFunction sRest\n              sParms = 'PARMS('sRest')'\n            end\n            otherwise do /* old style parms */\n              /* ENTRY function parms                        */\n              /* ENTRY FUNCTION(function) parms              */\n              if pos('FUNCTION(',sParms) > 0\n              then do\n                parse var sParms 'FUNCTION('sFunction')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n              end\n              else do\n                parse var sParms sFunction sParms\n              end\n            end\n          end\n          parent = peekStack(nTaskId)\n          e = createElement('trace')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'taskid',nTaskId\n          call setParmAttributes e,sParms\n          if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n          then call appendDetail e,'on-entry'\n          call pushStack nTaskId,e\n        end\n        when sAction = 'EXIT' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = strip(sParms)\n          sReason = ''\n          sAbend = ''\n          select\n            when left(sParms,1) = '-' then do\n              /* EXIT - FUNCTION(xxx) yyy(xxx) ... */\n              sParms = space(strip(sParms,'LEADING','-'))\n              if pos('FUNCTION(',sParms) > 0\n              then do\n                parse var sParms 'FUNCTION('sFunction')',\n                               1 'RESPONSE('sResponse')',\n                               1 'REASON('sReason')',\n                               1 'ABEND_CODE('sAbend')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n                n = wordpos('RESPONSE('sResponse')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n              end\n              else do\n                if left(sParms,1) = '*'\n                /* e.g. '** Decode of parameter list failed **' */\n                then do\n                  sFunction = ''\n                  sResponse = ''\n                end\n                else parse var sParms sFunction sResponse sParms\n                sReason   = ''\n                sAbend    = ''\n              end\n            end\n            when pos('REQ(',sParms) > 0 then do\n              /* EXIT function response         REQ(xxx) ... */\n              /* EXIT response                  REQ(xxx) ... */\n              parse var sParms sFixed'REQ('sParms\n              sParms = 'REQ('sParms\n              if words(sFixed) = 1\n              then do\n                sFunction = ''\n                sResponse = strip(sFixed)\n              end\n              else do\n                parse var sFixed sFunction sResponse .\n              end\n            end\n            when pos('FUNCTION(',sParms) > 0 then do\n              /* EXIT FUNCTION(xxx) RESPONSE(xxx) parms ...  */\n                parse var sParms 'FUNCTION('sFunction')',\n                               1 'RESPONSE('sResponse')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n                n = wordpos('RESPONSE('sResponse')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n            end\n            otherwise do\n              parse var sParms sFunction sParms\n            end\n          end /* select */\n          parent = popStack(nTaskId)\n          if parent <> g.!AUXTRACE\n          then do\n            call setAttributes parent,,\n                 'exitrow',g.!ROWS,,\n                 'response',sResponse,,\n                 'exitseq',nSeq\n            sCompoundReason = strip(sReason sAbend)\n            if sCompoundReason <> ''\n            then call setAttribute parent,'reason',sCompoundReason\n            call setParmAttributes parent,sParms\n          end\n          if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n          then call appendDetail parent,'on-exit'\n        end\n        when sAction = 'EVENT' then do\n          if g.!OPTION.EVENT\n          then do\n            g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n            sParms = space(strip(strip(sParms),'LEADING','-'))\n            parse var sParms sFunction sParms\n            parent = peekStack(nTaskId)\n            e = createElement('event')\n            call appendChild e,parent\n            call setAttributes e,,\n                 'seq',nSeq,,\n                 'row',g.!ROWS,,\n                 'elapsed',nElapsed,,\n                 'interval',getInterval(sTime),,\n                 'domain',sDomain,,\n                 'module','DFH'sModule,,\n                 'function',sFunction,,\n                 'parms',sParms,,\n                 'taskid',nTaskId\n            if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n            then call appendDetail e,'detail'\n          end\n        end\n        when sAction = 'CALL' then do\n          sParms = space(strip(strip(sParms),'LEADING','-'))\n          parse var sParms sFunction sParms\n          parent = peekStack(nTaskId)\n          e = createElement('call')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'taskid',nTaskId\n          call setParmAttributes e,sParms\n        end\n        when sAction = '*EXC*' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = space(strip(sParms,'LEADING','-'))\n          parse var sParms sFunction sParms\n          parent = peekStack(nTaskId)\n          e = createElement('exception')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'parms',sParms,,\n               'taskid',nTaskId\n        end\n        when sAction = 'DATA' then do\n          if g.!OPTION.DATA\n          then do\n            g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n            sParms = space(strip(strip(sParms),'LEADING','-'))\n            parse var sParms sFunction sParms\n            parent = peekStack(nTaskId)\n            e = createElement('data')\n            call appendChild e,parent\n            call setAttributes e,,\n                 'seq',nSeq,,\n                 'row',g.!ROWS,,\n                 'elapsed',nElapsed,,\n                 'interval',getInterval(sTime),,\n                 'domain',sDomain,,\n                 'module','DFH'sModule,,\n                 'function',sFunction,,\n                 'taskid',nTaskId\n            if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n            then call appendDetail e,'detail'\n          end\n        end\n        when sAction = 'RESUMED' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = space(strip(strip(sParms),'LEADING','-'))\n          parse var sParms sFunction sParms\n          parent = peekStack(nTaskId)\n          e = createElement('resumed')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'taskid',nTaskId\n          call setParmAttributes e,sParms\n        end\n        when sAction = 'PC' then do\n          /* this trace type does not seem to add any value */\n        end\n        otherwise do\n          parent = peekStack(nTaskId)\n          call appendChild createTextNode(sEntry),parent\n          say 'AUX003E Unknown trace entry <'sAction'>:' sEntry\n        end\n      end\n    end\n    sEntry = getTraceEntry()\n  end\n  rc = closeFile(g.!FILEIN)\n  say 'AUX004I Processed' g.!K-1 'trace entries'\n  say 'AUX005I Domain processing summary:'\n  do i = 1 to g.!DOMAIN.0\n    sDomain = g.!DOMAIN.i\n    sDesc   = g.!DOMAIN.sDomain\n    if bAllDomains | wordpos(sDomain,g.!DOMAIN_FILTER) > 0\n    then sFilter = 'Requested'\n    else sFilter = '         '\n    if g.!FREQ.sDomain > 0\n    then sFound  = 'Found' right(g.!FREQ.sDomain,5)\n    else sFound  = '           '\n    say 'AUX006I   'sFilter sFound sDomain sDesc\n  end\nreturn\n\ninitStack: procedure expose g.\n  parse arg task\n  g.!T.task = 0         /* set top of stack index for task */\nreturn\n\npushStack: procedure expose g.\n  parse arg task,item\n  tos = g.!T.task + 1   /* get new top of stack index for task */\n  g.!E.task.tos = item  /* set new top of stack item */\n  g.!T.task = tos       /* set new top of stack index */\nreturn\n\npopStack: procedure expose g.\n  parse arg task\n  tos = g.!T.task       /* get top of stack index for task */\n  item = g.!E.task.tos  /* get item at top of stack */\n  g.!T.task = max(tos-1,1)\nreturn item\n\npeekStack: procedure expose g.\n  parse arg task\n  tos = g.!T.task       /* get top of stack index for task */\n  item = g.!E.task.tos  /* get item at top of stack */\nreturn item\n\ngetLineContaining: procedure expose g.\n  parse arg sSearchArg\n  sLine = getLine(g.!FILEIN)\n  do while g.!RC = 0 & pos(sSearchArg, sLine) = 0\n    sLine = getLine(g.!FILEIN)\n  end\nreturn sLine\n\ngetNextLine: procedure expose g.\n  sLine = getLine(g.!FILEIN)\n  if g.!RC = 0\n  then do\n    cc = left(sLine,1)\n    select\n      when cc = '0' then sLine = '' /* ASA double space */\n      when cc = '1' then do         /* ASA page eject */\n        sLine = getLine(g.!FILEIN)  /* skip blank line after title */\n        if sLine <> ''\n        then say 'AUX007W Line after heading is not blank:' sLine\n        sLine = getLine(g.!FILEIN)  /* read next data line */\n      end\n      when sLine = '<<<<  STARTING DATA FROM NEXT EXTENT  >>>>' then,\n        sLine = ''\n      otherwise nop\n    end\n  end\nreturn sLine\n\ngetFirstTraceEntry: procedure expose g.\n  sLine = getNextLine()\n  parse var sLine sDomain xType sModule .\n  do while g.!RC = 0 & length(sDomain) <> 2\n    sLine = getNextLine()\n    parse var sLine sDomain xType sModule .\n  end\nreturn getTraceEntry(sLine)\n\ngetTraceEntry: procedure expose g.\n  parse arg sEntry\n  /* The general format of a trace entry is something like:\n\nOld style:\n dd tttt mmmm action ...fixed_width_stuff... parms...\n                     moreparms...\n\n               TASK-nnnnn ....timing info etc...........  =seqno=\n                 1-0000  ...hex dump.... *...character dump...*\n                 2-0000  ...hex dump.... *...character dump...*\n                   0020  ...hex dump.... *...character dump...*\n                         .\n                         .\n                 n-0000  ...hex dump.... *...character dump...*\n                         .\n                         .\n\nNew style:\n dd tttt mmmm action - parms...\n                     moreparms...\n\n               TASK-nnnnn ....timing info etc...........  =seqno=\n                 1-0000  ...hex dump.... *...character dump...*\n                 2-0000  ...hex dump.... *...character dump...*\n                   0020  ...hex dump.... *...character dump...*\n                         .\n                         .\n                 n-0000  ...hex dump.... *...character dump...*\n                         .\n                         .\n\n  */\n  sLine = getNextLine()\n  do while g.!RC = 0 & left(strip(sLine),5) <> 'TASK-'\n    sEntry = sEntry strip(sLine)\n    sLine = getNextLine()\n  end\n  g.!ENTRYDATA.0 = 0\n  do i = 1 while g.!RC = 0 & sLine <> ''\n    g.!ENTRYDATA.i = sLine\n    g.!ENTRYDATA.0 = i\n    sLine = getNextLine()\n  end\n  g.!K = g.!K + 1\n  g.!KD = g.!KD + 1\n  if g.!KD >= 1000\n  then do\n    say 'AUX008I Processed' g.!K 'trace entries'\n    g.!KD = 0\n  end\nreturn sEntry\n\ngetElapsed: procedure expose g.\n  parse arg nHH':'nMM':'nSS\n  nThisOffset = ((nHH*60)+nMM)*60+nSS\n  if g.!FIRSTOFFSET = ''\n  then g.!FIRSTOFFSET = nThisOffset\nreturn nThisOffset - g.!FIRSTOFFSET\n\ngetInterval: procedure expose g.\n  parse arg sTime\n  nThisOffset = getElapsed(sTime) /* seconds from start of trace */\n  if g.!PREVOFFSET = ''\n  then nInterval = 0\n  else nInterval = nThisOffset - g.!PREVOFFSET\n  g.!PREVOFFSET = nThisOffset\nreturn nInterval\n\nsetParmAttributes: procedure expose g.\n  parse arg e,sParms\n  if pos('(',sParms) > 0\n  then do while sParms <> ''\n    parse var sParms sName'('sValue')'sParms\n    sName = getValidAttributeName(sName)\n    if wordpos(sName,'FIELD-A FIELD-B') > 0\n    then parse var sValue sValue .\n    call setAttribute e,space(sName,0),strip(sValue)\n  end\n  else do\n    if sParms <> ''\n    then call setAttribute e,'parms',sParms\n  end\nreturn\n\nbuildSVG: procedure expose g.\n  say 'AUX009I Building SVG'\n\n  g.!LINEDEPTH = 12\n\n  doc = getDocumentElement()\n  call setDocType 'PUBLIC \"-//W3C//DTD SVG 1.1//EN\"',\n                  '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"'\n\n  call setAttributes doc,,\n       'xmlns','http://www.w3.org/2000/svg',,\n       'xmlns:xlink','http://www.w3.org/1999/xlink'\n\n  title = createElement('title')\n  call appendChild title,doc\n  sAppl = getAttribute(g.!AUXTRACE,'appl')\n  sDate = getAttribute(g.!AUXTRACE,'date')\n  sTitle = 'CICS auxiliary trace of' sAppl 'captured on' sDate\n  call appendChild createTextNode(sTitle),title\n\n  call addTooltip doc,,\n       'Created by CICS Auxiliary Trace Visualizer' sVersion 'see',\n       'http://sourceforge.net/projects/rexxxmlparser/'\n\n  g.!STYLE = createElement('style')\n  call appendChild g.!STYLE,doc\n\n  call setAttribute g.!STYLE,'type','text/css'\n\n  queue\n  queue '.background  {fill:white;}'\n  queue '.actors      {text-anchor:middle;' ||,\n                      'fill:lemonchiffon;stroke:slateblue;}'\n  queue '.lifeline    {stroke:yellowgreen;stroke-dasharray:5,2;' ||,\n                      'fill:none;}'\n  queue '.seq         {fill:gray;}'\n  queue '.arrows      {stroke-width:2;fill:none;}'\n  queue '.return      {stroke-dasharray:2,3;}'\n  queue '.annotation  {stroke:none;font-size:6px;}'\n  queue '.ltr         {text-anchor:start;}'\n  queue '.rtl         {text-anchor:end;}'\n  queue '.error       {fill:red;}'\n  queue 'text.dump    {font-family:monospace;font-size:10px;}'\n  queue 'text         {font-family:Arial;font-size:10px;fill:black;' ||,\n                      'stroke:none;}'\n  queue\n  styles = createCDATASection(pullLines())\n  call appendChild styles,g.!STYLE\n\n  defs = createElement('defs')\n  call appendChild defs,doc\n  path = createElement('path')\n  call appendChild path,defs\n  call setAttributes path,,\n       'id','arrow',,\n       'd','M 0 0 L 10 5 L 0 10 z'\n  circle = createElement('circle')\n  call appendChild circle,defs\n  call setAttributes circle,,\n       'id','circle',,\n       'cx',5,'cy',5,'r',5\n\n  background = createElement('rect')\n  call appendChild background,doc\n\n  g.!ACTOR_NODES = ''\n  call getActors g.!AUXTRACE\n  lifelinebg = createElement('g')\n  call setAttribute lifelinebg,'class','background'\n  lifelines = createElement('g')\n  call setAttribute lifelines,'class','lifeline'\n  g = createElement('g')\n  call setAttribute g,'class','actors'\n  call appendChild createComment(' Life lines'),doc\n  call appendChild lifelinebg,doc\n  call appendChild lifelines,doc\n  call appendChild createComment(' Actor rectangles'),doc\n  call appendChild g,doc\n  w = 60 /* width of an actor rectangle */\n  h = 22 /* height of an actor rectangle */\n  x = w  /* horizontal position of actor rectangle */\n  do i = 1 to words(g.!ACTOR_NODES) /* for each actor... */\n    node = word(g.!ACTOR_NODES,i)\n    sActor = getActorName(node)\n    sDomain = getAttribute(node,'domain')\n    xMid = x + w/2\n    /* Draw the life line background (for tooltips)... */\n    rect = createElement('rect')\n    call appendChild rect,lifelinebg\n    call setAttributes rect,,\n         'x',xMid-5,,\n         'y',h,,\n         'width',10,,\n         'height',0 /* placeholder...see below */\n    /* Add a tooltip for this life line background rect... */\n    call addTooltip rect,sActor\n    /* Draw the life line... */\n    line = createElement('line')\n    call appendChild line,lifelines\n    call setAttributes line,,\n         'x1',xMid,,\n         'y1',h,,\n         'x2',xMid,,\n         'y2',0 /* placeholder...see below */\n    /* Add an identical tooltip for this life line... */\n    call addTooltip line,sActor\n    g.!X.sActor = xMid /* remember where this actor is by name */\n    /* Draw the rectangle to contain the actor name... */\n    rect = createElement('rect')\n    call appendChild rect,g\n    call setAttributes rect,,\n         'x',x,,\n         'y',0,,\n         'width',w,,\n         'height',h,,\n         'rx',1,,\n         'ry',1\n    /* Draw the domain name and actor name within the rectangle... */\n    text = createElement('text')\n    call appendChild text,g\n    call setAttributes text,'y',9\n    domain = createElement('tspan')\n    actor = createElement('tspan')\n    call appendChild domain,text\n    call appendChild actor,text\n    call setAttributes domain,'x',xMid\n    call setAttributes actor,'x',xMid,'dy',10\n    select\n      when isProgram(node),\n        then call appendChild createTextNode('program'),domain\n      when isSocket(node),\n        then call appendChild createTextNode('socket'),domain\n      otherwise,\n        call appendChild createTextNode(sDomain),domain\n    end\n    call appendChild createTextNode(sActor),actor\n    x = x + w + 5\n  end\n\n  nImageWidth = x + w /* room on the right for a longish message */\n\n  call appendChild createComment(' Actor relationships'),doc\n  g = createElement('g')\n  call appendChild g,doc\n  call setAttribute g,'class','arrows'\n\n  g.!FIRSTARROW = 2 * g.!LINEDEPTH /* vertical offset of first arrow */\n  tasks = getChildren(g.!AUXTRACE)\n  do i = 1 to words(tasks)\n    task = word(tasks,i)\n    nTaskId = getAttribute(task,'taskid')\n    h = getHue(i)\n    s = getSaturation(i)\n    v = getValue(i)\n    sColor = hsv2rgb(h,s,v)\n    style = createTextNode('.task'nTaskId '{stroke:'sColor';}')\n    call appendChild style,g.!STYLE\n    style = createTextNode('.fill'nTaskId '{fill:'sColor';}')\n    call appendChild style,g.!STYLE\n    call createMarkers defs,nTaskId\n    call drawArrows g,task\n  end\n\n  nImageHeight = (2 + g.!ROWS + 1 ) * g.!LINEDEPTH\n  call setAttributes doc,,\n       'height',nImageHeight,,\n       'width',nImageWidth,,\n       'viewBox','-10 -10' nImageWidth+10 nImageHeight+10\n  call setAttributes background,,\n       'class','background',,\n       'x',0,,\n       'y',0,,\n       'height',nImageHeight,,\n       'width',nImageWidth\n   g.!WIDTH = nImageWidth\n   g.!HEIGHT = nImageHeight\n\n  /* Now we know the image height we can update the lifeline depth */\n  nodes = getChildren(lifelinebg)\n  do i = 1 to words(nodes)\n    node = word(nodes,i)\n    call setAttribute node,'height',nImageHeight\n  end\n  nodes = getChildren(lifelines)\n  do i = 1 to words(nodes)\n    node = word(nodes,i)\n    call setAttribute node,'y2',nImageHeight\n  end\n\n  /* Finally, remove unreferenced marker definitions...*/\n  nodes = getChildren(defs)\n  do i = 1 to words(nodes)\n    node = word(nodes,i)\n    if getNodeName(node) = 'marker'\n    then do\n      sId = getAttribute(node,'id')\n      if g.!MARKER.sId = ''\n      then call removeChild node\n    end\n  end\n\nreturn\n\ncreateMarkers: procedure expose g.\n  parse arg defs,nTaskId\n/*\n    <marker id=\"ArrowXXXXX\" viewBox=\"0 0 10 10\" refX=\"7\" refY=\"5\"\n            orient=\"auto\">\n      <use xlink:href=\"#arrow\"/>\n    </marker>\n*/\n  marker = createElement('marker')\n  call appendChild marker,defs\n  call setAttributes marker,,\n       'id','Arrow'nTaskId,,\n       'class','fill'nTaskId,,\n       'viewBox','0 0 10 10',,\n       'refX',7,,\n       'refY',5,,\n       'orient','auto'\n  use = createElement('use')\n  call appendChild use,marker\n  call setAttribute use,'xlink:href','#arrow'\n/*\n    <marker id=\"CircleXXXXX\" viewBox=\"0 0 10 10\" refX=\"8\" refY=\"5\">\n      <use xlink:href=\"#circle\"/>\n    </marker>\n*/\n  marker = createElement('marker')\n  call appendChild marker,defs\n  call setAttributes marker,,\n       'id','Circle'nTaskId,,\n       'class','fill'nTaskId,,\n       'viewBox','0 0 10 10',,\n       'refX',8,,\n       'refY',5\n  use = createElement('use')\n  call appendChild use,marker\n  call setAttribute use,'xlink:href','#circle'\nreturn\n\naddTooltip: procedure expose g.\n  parse arg node,sTip\n  tooltip = createElement('desc')\n  call appendChild tooltip,node\n  call appendChild createTextNode(sTip),tooltip\nreturn\n\ngetHue: procedure expose g.\n  arg n\nreturn (g.!HUE_INIT + (n-1) * g.!HUE_STEP) // 360\n\ngetSaturation: procedure expose g.\n  arg n\n  n = g.!SAT_LEVELS - 1 - (n-1) // g.!SAT_LEVELS\nreturn g.!SAT_MIN + n * g.!SAT_STEP\n\ngetValue: procedure expose g.\n  arg n\n  n = g.!VAL_LEVELS - 1 - (n-1) // g.!VAL_LEVELS\nreturn g.!VAL_MIN + n * g.!VAL_STEP\n\nhsv2rgb: procedure\n  parse arg h,s,v\n  /*\n  Hue (h) is from 0 to 360, where 0 = red and 360 also = red\n  Saturation (s) is from 0.0 to 1.0 (0 = least color, 1 = most color)\n  Value (v) is from 0.0 to 1.0 (0 = darkest, 1 = brightest)\n  */\n  v = 100 * v /* convert to a percentage */\n  if s = 0 /* if grayscale */\n  then do\n    v = format(v,,2)'%'\n    rgb = 'rgb('v','v','v')'\n  end\n  else do\n    sextant = trunc(h/60) /* 0 to 5 */\n    fraction = h/60 - sextant\n    p = v * (1 - s)\n    q = v * (1 - s * fraction)\n    r = v * (1 - s * (1 - fraction))\n    v = format(v,,2)'%'\n    p = format(p,,2)'%'\n    q = format(q,,2)'%'\n    r = format(r,,2)'%'\n    select\n      when sextant = 0 then rgb = 'rgb('v','r','p')'\n      when sextant = 1 then rgb = 'rgb('q','v','p')'\n      when sextant = 2 then rgb = 'rgb('p','v','r')'\n      when sextant = 3 then rgb = 'rgb('p','q','v')'\n      when sextant = 4 then rgb = 'rgb('r','q','v')'\n      when sextant = 5 then rgb = 'rgb('v','p','q')'\n      otherwise rgb = 'rgb(0,0,0)' /* should not happen :) */\n    end\n  end\nreturn rgb\n\n\npullLines: procedure expose g.\n  sLines = ''\n  do queued()\n    parse pull sLine\n    sLines = sLines || sLine || g.!LF\n  end\nreturn sLines\n\ngetActors: procedure expose g.\n  parse arg node\n  sActor = getActorName(node)\n  if sActor <> '' & g.!ACTOR.sActor = ''\n  then do /* if this node is a new actor */\n      g.!ACTOR_NODES = g.!ACTOR_NODES node\n      g.!ACTOR.sActor = 1 /* we've seen it now */\n  end\n  children = getChildren(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call getActors child\n  end\nreturn\n\ngetActorName: procedure expose g.\n  parse arg node\n  select\n    when node = g.!AUXTRACE then do\n      sActor = '<<cics>>'\n    end\n    when getNodeName(node) = 'task' then do\n      sActor = '<<cics>>'\n    end\n    when isProgram(node) then do\n      sActor = getAttribute(node,'PROGRAM_NAME')\n      if sActor = '' then sActor = getAttribute(node,'PROGRAM')\n      if sActor = '' then sActor = '<<program>>'\n    end\n    when isSocket(node) then do\n      sActor = getAttribute(node,'SOCKET_TOKEN')\n      if sActor = '' then sActor = '<<socket>>'\n    end\n    otherwise sActor = getAttribute(node,'module')\n  end\nreturn sActor\n\nisProgram: procedure expose g.\n  parse arg node\n  sDomain = getAttribute(node,'domain')\n  sFunction = getAttribute(node,'function')\n  bIsProgram = sDomain = 'PG' &,\n     wordpos(sFunction,'LINK LINK_EXEC INITIAL_LINK',\n                       'LOAD LOAD_EXEC LINK_URM') > 0\n  bIsProgram = bIsProgram | (sDomain = 'AP' &,\n     wordpos(sFunction,'START_PROGRAM') > 0)\nreturn bIsProgram\n\nisSocket: procedure expose g.\n  parse arg node\n  sModule = getAttribute(node,'module')\n  sFunction = getAttribute(node,'function')\n  bIsSocket = sModule = 'DFHSOCK' &,\n     wordpos(sFunction,'SEND RECEIVE CONNECT CLOSE') > 0\nreturn bIsSocket\n\ndrawArrows: procedure expose g.\n  parse arg g,source\n  if isActor(source)\n  then do\n    children = getChildren(source)\n    do i = 1 to words(children)\n      target = word(children,i)\n      if isActor(target)\n      then do /* we can draw an arrow between actors */\n        sClass = 'task'getAttribute(target,'taskid')\n        group = createElement('g')\n        call appendChild group,g\n        call setAttribute group,'class',sClass\n        call drawArrow group,source,target,'call'\n        call drawArrows group,target\n        call drawArrow group,target,source,'return'\n      end\n      else do\n        call drawArrows g,target\n      end\n    end\n  end\n  else do\n    children = getChildren(caller)\n    do i = 1 to words(children)\n      child = word(children,i)\n      call drawArrows g,child\n    end\n  end\nreturn\n\nisActor: procedure expose g.\n  parse arg node\n  bIsActor = getActorName(node) <> '' | getNodeName(node) = 'task'\nreturn bIsActor\n\ndrawArrow: procedure expose g.\n  parse arg g,source,target,sClass\n  /* the source actor invokes a function on the target actor */\n  bIsCall = sClass = 'call' /* ...else it is a return arrow */\n  if bIsCall\n  then nRow = getAttribute(target,'row')\n  else nRow = getAttribute(source,'exitrow')\n  if nRow = '' then return /* <event> has no 'return' arrow */\n  y = g.!FIRSTARROW + g.!LINEDEPTH * nRow\n  sSourceActor = getActorName(source)\n  sTargetActor = getActorName(target)\n  sFunction = getAttribute(target,'function')\n\n  /* Group the arrow, text and optional tooltip together */\n  arrow = createElement('g')\n  call appendChild arrow,g\n\n  /* Draw the elapsed time and task id of this <trace> entry...*/\n  sTaskId = getAttribute(target,'taskid')\n  if bIsCall\n  then do\n    call appendChild createComment(' 'sTargetActor),arrow\n    elapsed = createElement('text')\n    call appendChild elapsed,arrow\n    call setAttributes elapsed,'x',0,'y',y\n    nElapsed = getAttribute(target,'elapsed')\n    sElapsed = '+'left(format(nElapsed,,6),8,'0')' 'sTaskId\n    call appendChild createTextNode(sElapsed),elapsed\n  end\n\n  /* Draw the arrow for this call or return...*/\n  line = createElement('line')\n  call appendChild line,arrow\n  tooltip = createElement('desc') /* tool tip for this arrow */\n  call appendChild tooltip,line\n  if \\bIsCall\n  then call setAttribute line,'class',sClass\n  x1 = g.!X.sSourceActor\n  x2 = g.!X.sTargetActor\n  if x1 < x2 /* if left-to-right arrow */\n  then do\n    x1b = x1 + 2\n    x2 = x2 - 2\n    sDir = 'ltr'\n  end\n  else do\n    x1b = x1 - 2\n    x2 = x2 + 2\n    sDir = 'rtl'\n  end\n  call setAttributes line,,\n       'x1',x1,,\n       'y1',y,,\n       'x2',x2,,\n       'y2',y\n  if sSourceActor = sTargetActor\n  then do\n    sId = 'Circle'sTaskId\n    g.!MARKER.sId = 1 /* remember that we have used this marker */\n    call setAttribute line,'marker-end','url(#'sId')'\n  end\n  else do\n    sId = 'Arrow'sTaskId\n    g.!MARKER.sId = 1 /* remember that we have used this marker */\n    call setAttribute line,'marker-end','url(#'sId')'\n  end\n\n  /* Annotate the arrow...*/\n  annotation = createElement('text')\n  call appendChild annotation,arrow\n  call setAttributes annotation,,\n       'class','annotation' sDir,,\n       'x',x1b,,\n       'y',y-2\n  if bIsCall\n  then do /* annotate the invoking arrow */\n    sExtra = getDescriptionOfCall(target)\n    sModule = getAttribute(target,'module')\n    if getNodeName(target) = 'exception'\n    then call setAttribute annotation,'class','annotation error' sDir\n  end\n  else do /* annotate the returning arrow */\n    sExtra = ''\n    sModule = getAttribute(source,'module')\n    sFunction = getAttribute(source,'function')\n    sResponse = getAttribute(source,'response')\n    if sResponse = '' |,\n       sResponse = 'NORMAL' |,\n       sResponse = 'RESPONSE(OK)'\n    then sResponse = 'OK'\n    select\n      when sSourceActor = sTargetActor then,\n        sExtra = sFunction sResponse\n      when sResponse = 'OK' then,\n        sExtra = sResponse\n      otherwise,\n        sExtra = sResponse getAttribute(source,'reason')\n    end\n    if sResponse <> 'OK'\n    then call setAttribute annotation,'class','annotation error' sDir\n  end\n\n  /* Every arrow is annotated with the trace sequence number... */\n  tspanSeq = createElement('tspan')\n  call setAttribute tspanSeq,'class','seq'\n  if bIsCall\n  then nSeq = getAttribute(target,'seq')\n  else nSeq = getAttribute(source,'exitseq')\n  call appendChild createTextNode(nSeq),tspanSeq\n\n  /* Some arrows have extra info near the sequence number... */\n  if sDir = 'ltr' /* if left-to-right arrow */\n  then do /* e.g. 001234 LOAD_EXEC ------------------>  */\n    call appendChild tspanSeq,annotation\n    if sExtra <> ''\n    then do\n      tspanExtra = createElement('tspan')\n      call appendChild createTextNode(sExtra),tspanExtra\n      call appendChild tspanExtra,annotation\n    end\n  end\n  else do /* e.g. <----------- PROGRAM_NOT_FOUND 001235 */\n    if sExtra <> ''\n    then do\n      tspanExtra = createElement('tspan')\n      call appendChild createTextNode(sExtra),tspanExtra\n      call appendChild tspanExtra,annotation\n    end\n    call appendChild tspanSeq,annotation\n  end\n\n  /* Now create a tool tip for this line */\n  sTip = nSeq sExtra\n  select\n    when sModule = 'DFHSOCK' then do\n      if sFunction = 'SEND'\n      then sTip = sTip getSocketDetail(target,'on-entry')\n      if sFunction = 'RECEIVE'\n      then sTip = sTip getSocketDetail(source,'on-exit')\n    end\n    when getNodeName(target) = 'data' then do\n      sTip = sTip getDataDetail(target)\n    end\n    otherwise nop\n  end\n  call appendChild createTextNode(sTip),tooltip\nreturn\n\ngetSocketDetail: procedure expose g.\n  parse arg node,sContainer\n  detail = getChildrenByName(node,sContainer)\n  args = getChildrenByName(detail,'arg')\n  if words(args) < 2 then return ''\n  data = word(args,2) /* arg2 contains the packet payload */\n  sData = getText(getFirstChild(data)) /* ...a CDATA node */\nreturn sData\n\ngetDataDetail: procedure expose g.\n  parse arg node\n  sData = ''\n  detail = getChildrenByName(node,'detail')\n  if detail <> ''\n  then do\n    args = getChildrenByName(detail,'arg')\n    do i = 1 to words(args)\n      data = word(args,i)\n      sData = sData getText(getFirstChild(data))\n    end\n  end\nreturn sData\n\ngetDescriptionOfCall: procedure expose g.\n  parse arg node\n  sDesc = ''\n  sDomain = getAttribute(node,'domain')\n  sFunction = getAttribute(node,'function')\n  select\n    when sDomain = 'PG' then do\n      sProgram = getAttribute(node,'PROGRAM_NAME')\n      select\n        when sProgram <> '' then,\n          sDesc = '('sProgram')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'AP' then do\n      select\n        when sFunction = 'START_PROGRAM' then,\n          sDesc = '('getAttribute(node,'PROGRAM')')'\n        when sFunction = 'WRITE_TRANSIENT_DATA' then,\n          sDesc = '('getAttribute(node,'QUEUE')')'\n        when sFunction = 'READ_UPDATE_INTO' then,\n          sDesc = '('getAttribute(node,'FILE_NAME')')'\n        when sFunction = 'LOCATE' then,\n          sDesc = getAttribute(node,'TABLE')'(' ||,\n                  getAttribute(node,'KEY')')'\n        when wordpos(sFunction,'GET_QUEUE',\n                               'PUT_QUEUE',\n                               'DELETE_QUEUE') > 0 then,\n          sDesc = '('getAttribute(node,'RECORD_TYPE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'BA' then do\n      select\n        when wordpos(sFunction,'PUT_CONTAINER',\n                               'GET_CONTAINER_SET',\n                               'GET_CONTAINER_INTO',\n                               'DELETE_CONTAINER') > 0 then,\n          sDesc = '('getAttribute(node,'CONTAINER_NAME')')'\n        when wordpos(sFunction,'ADD_ACTIVITY',\n                               'LINK_ACTIVITY',\n                               'CHECK_ACTIVITY') > 0 then,\n          sDesc = '('getAttribute(node,'ACTIVITY_NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'WB' then do\n      select\n        when wordpos(sFunction,'PUT_QUEUE',\n                               'DELETE_QUEUE',\n                               'GET_QUEUE') > 0 then,\n          sDesc = '('getAttribute(node,'RECORD_TYPE')')'\n        when wordpos(sFunction,'START_BROWSE',\n                               'READ_NEXT',\n                               'END_BROWSE') > 0 then,\n          sDesc = '('getAttribute(node,'DATA_TYPE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'SM' then do\n      select\n        when sFunction = 'GETMAIN' then do\n            if hasAttribute(node,'STORAGE_CLASS')\n            then do\n              xLen = getAttribute(node,'GET_LENGTH')\n              sDesc = getAttribute(node,'ADDRESS'),\n                      getAttribute(node,'STORAGE_CLASS'),\n                      \"LENGTH=X'\"xLen\"' (\"x2d(xLen)')',\n                      getAttribute(node,'REMARK')\n            end\n            else,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      'SUBPOOL',\n                      getAttribute(node,'REMARK')\n        end\n        when sFunction = 'FREEMAIN' then do\n          select\n            when hasAttribute(node,'STORAGE_CLASS') then,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      getAttribute(node,'STORAGE_CLASS'),\n                      getAttribute(node,'REMARK')\n            when hasAttribute(node,'SUBPOOL_TOKEN') then,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      'SUBPOOL',\n                      getAttribute(node,'REMARK')\n            otherwise,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      getAttribute(node,'REMARK')\n          end\n        end\n        otherwise nop\n      end\n    end\n    when sDomain = 'DD' then do\n      select\n        when sFunction = 'LOCATE' then,\n          sDesc = getAttribute(node,'DIRECTORY_NAME')'(' ||,\n                  getAttribute(node,'NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'TS' then do\n      select\n        when wordpos(sFunction,'MATCH',\n                               'DELETE',\n                               'READ_INTO',\n                               'READ_SET',\n                               'READ_AUX_DATA',\n                               'WRITE') > 0 then,\n          sDesc = 'QUEUE('getAttribute(node,'QUEUE_NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'XS' then do\n      select\n        when sFunction = 'CHECK_CICS_RESOURCE' then,\n          sDesc = getAttribute(node,'RESOURCE_TYPE')'(' ||,\n                  getAttribute(node,'RESOURCE')') ACCESS(' ||,\n                  getAttribute(node,'ACCESS')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'XM' then do\n      select\n        when sFunction = 'ATTACH' then,\n          sDesc = 'TRANS('getAttribute(node,'TRANSACTION_ID')')'\n        when sFunction = 'INQUIRE_MXT' then,\n          sDesc = 'LIMIT('getAttribute(node,'MXT_LIMIT')')',\n                  'ACTIVE('getAttribute(node,'CURRENT_ACTIVE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'EM' then do\n      select\n        when wordpos(sFunction,'FIRE_EVENT',\n                               'DEFINE_ATOMIC_EVENT',\n                               'DELETE_EVENT',\n                               'RETRIEVE_REATTACH_EVENT') > 0 then,\n          sDesc = '('getAttribute(node,'EVENT')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'DU' then do\n      select\n        when wordpos(sFunction,'TRANSACTION_DUMP',\n                               'COMMIT_TRAN_DUMPCODE',\n                               'LOCATE_TRAN_DUMPCODE') > 0 then,\n          sDesc = '('getAttribute(node,'TRANSACTION_DUMPCODE')')',\n                     getAttribute(node,'DUMPID')\n        when wordpos(sFunction,'INQUIRE_SYSTEM_DUMPCODE') > 0 then,\n          sDesc = '('getAttribute(node,'SYSTEM_DUMPCODE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'CC' then do\n      select\n        when wordpos(sFunction,'GET') > 0 then,\n          sDesc = getAttribute(node,'TYPE')'(' ||,\n                  getAttribute(node,'NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'GC' then do\n      select\n        when wordpos(sFunction,'WRITE') > 0 then,\n          sDesc = getAttribute(node,'TYPE')'(' ||,\n                  getAttribute(node,'NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'DS' then do\n      select\n        when wordpos(sFunction,'SUSPEND',\n                               'WAIT_MVS',\n                               'WAIT_OLDW') > 0 then,\n          sDesc = getAttribute(node,'RESOURCE_TYPE')'(' ||,\n                  getAttribute(node,'RESOURCE_NAME')')'\n        otherwise nop\n      end\n    end\n    otherwise nop\n  end\n  if getNodeName(node) = 'trace'\n  then sPrefix = sFunction\n  else sPrefix = getNodeName(node)':' sFunction\nreturn strip(sPrefix sDesc)\n\nsetOptions: procedure expose g.\n  parse arg sOptions\n  /* set default options... */\n  g.!OPTION.EVENT   = 1 /* Process input EVENT trace records? */\n  g.!OPTION.DATA    = 1 /* Process input DATA trace records? */\n  g.!OPTION.DETAIL  = 0 /* Output trace detail? */\n  g.!OPTION.XML     = 0 /* Output XML file? */\n  g.!OPTION.HTML    = 1 /* Output HTML file? */\n  g.!DOMAIN_FILTER = ''\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n      if length(sOption) = 2 then,\n        g.!DOMAIN_FILTER = g.!DOMAIN_FILTER sOption\n      else do\n        if left(sOption,2) = 'NO'\n        then do\n          sOption = substr(sOption,3)\n          g.!OPTION.sOption = 0\n        end\n        else g.!OPTION.sOption = 1\n      end\n  end\nreturn\n\nProlog:\n  if g.!ENV = 'TSO'\n  then g.!LF = '15'x\n  else g.!LF = '0A'x\n\n  /* Constants for generating line colors */\n  g.!HUE_INIT   = 151 /* random(0,360) */\n  g.!HUE_STEP   = 43  /* random(0,360) */\n  g.!SAT_MIN    = 1.0\n  g.!SAT_MAX    = 1.0\n  g.!SAT_LEVELS = 2\n  g.!SAT_STEP   = (g.!SAT_MAX - g.!SAT_MIN) / (g.!SAT_LEVELS - 1)\n  g.!VAL_MIN    = 0.5\n  g.!VAL_MAX    = 0.8\n  g.!VAL_LEVELS = 2\n  g.!VAL_STEP   = (g.!VAL_MAX - g.!VAL_MIN) / (g.!VAL_LEVELS - 1)\n\n  g.!DOMAIN.0 = 0 /* Number of domains */\n  call addDomain 'AP','Application Domain'\n  call addDomain 'BA','Business Application Manager Domain'\n  call addDomain 'CC','CICS Catalog Domain'\n  call addDomain 'GC','Global Catalog Domain'\n  call addDomain 'LC','Local Catalog Domain'\n  call addDomain 'DD','Directory Domain'\n  call addDomain 'DH','Document Handler Domain'\n  call addDomain 'DM','Domain Manager Domain'\n  call addDomain 'DP','Debugging Profiles Domain'\n  call addDomain 'DS','Dispatcher Domain'\n  call addDomain 'DU','Dump Domain'\n  call addDomain 'EJ','Enterprise Java Domain'\n  call addDomain 'EM','Event Manager Domain'\n  call addDomain 'EX','External CICS Interface Domain'\n  call addDomain 'EI','External CICS Interface over TCP/IP Domain'\n  call addDomain 'FT','Feature Domain'\n  call addDomain 'II','IIOP Domain'\n  call addDomain 'KE','Kernel Domain'\n  call addDomain 'LD','Loader Domain'\n  call addDomain 'LG','Log Manager Domain'\n  call addDomain 'LM','Lock Manager Domain'\n  call addDomain 'ME','Message Domain'\n  call addDomain 'MN','Monitoring Domain'\n  call addDomain 'NQ','Enqueue Domain'\n  call addDomain 'OT','Object Transaction Domain'\n  call addDomain 'PA','Parameter Manager Domain'\n  call addDomain 'PG','Program Manager Domain'\n  call addDomain 'PI','Pipeline Manager Domain'\n  call addDomain 'PT','Partner Domain'\n  call addDomain 'RM','Recovery Manager Domain'\n  call addDomain 'RX','RRMS Domain'\n  call addDomain 'RZ','Request Streams Domain'\n  call addDomain 'SH','Scheduler Domain'\n  call addDomain 'SJ','Java Virtual Machine Domain'\n  call addDomain 'SM','Storage Manager Domain'\n  call addDomain 'SO','Socket Domain'\n  call addDomain 'ST','Statistics Domain'\n  call addDomain 'TI','Timer Domain'\n  call addDomain 'TR','Trace Domain'\n  call addDomain 'TS','Temporary Storage Domain'\n  call addDomain 'US','User Domain'\n  call addDomain 'WB','Web Domain'\n  call addDomain 'XM','Transaction Manager Domain'\n  call addDomain 'XS','Security Manager Domain'\nreturn\n\naddDomain: procedure expose g.\n  parse arg sDomain,sDesc\n  if g.!DOMAIN.sDomain = ''\n  then do\n    nDomain = g.!DOMAIN.0       /* Number of domains */\n    nDomain = nDomain + 1\n    g.!DOMAIN.sDomain = sDesc   /* e.g. g.!DOMAIN.AP = 'App Domain'  */\n    g.!DOMAIN.nDomain = sDomain /* e.g. g.!DOMAIN.1 = 'AP'           */\n    g.!DOMAIN.0 = nDomain\n  end\nreturn\n\n/* Embed the svg in an html file to allow the browser to scroll it */\ncreateHTML: procedure expose g.\n  html = openFile(g.!FILEHTM,'OUTPUT')\n  if g.!rc = 0\n  then do\n    say 'AUX010I Creating' g.!FILEHTM\n    queue '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0',\n          'Transitional//EN\">'\n    queue '<html>'\n    queue '  <body>'\n    queue '    <object data=\"'g.!FILESVG'\"',\n                      'width=\"'g.!WIDTH'\"',\n                      'height=\"'g.!HEIGHT'\"',\n                      'type=\"image/svg+xml\"></object>'\n    queue '  </body>'\n    queue '</html>'\n    do queued()\n      parse pull sLine\n      call putLine html,sLine\n    end\n    rc = closeFile(html)\n    say 'AUX011I Created' g.!FILEHTM\n  end\n  else do\n    say 'AUX012E Could not create' g.!FILEHTM'. Return code' g.!rc\n  end\nreturn\n\nEpilog: procedure expose g.\nreturn\n\n\ngetValidAttributeName: procedure expose g.\n  parse arg sName\n  sName = space(sName,0)\n  sName = strip(sName,'LEADING','-')\n  if datatype(left(sName,1),'WHOLE')\n  then sName = 'X'sName /* must start with an alphabetic */\nreturn sName\n\n\nappendDetail: procedure expose g.\n  parse arg e,sName\n  x = createElement(sName)\n  call appendChild x,e\n  sData = ''\n  do i = 2 to g.!ENTRYDATA.0\n    sLine = strip(g.!ENTRYDATA.i,'LEADING')\n    parse var sLine nArg'-0000 '\n    if datatype(nArg,'WHOLE')\n    then do\n      if sData <> ''\n      then call appendDetailArg x,sData\n      parse var sLine nArg'-'sData\n      sData = sData || g.!LF\n    end\n    else do\n      sData = sData || sLine || g.!LF\n    end\n  end\n  if sData <> ''\n  then call appendDetailArg x,sData\nreturn\n\nappendDetailArg: procedure expose g.\n  parse arg parent,sData\n  a = createElement('arg')\n  call appendChild a,parent\n  call appendChild createCDATASection(g.!LF || sData),a\nreturn\n\n/*INCLUDE pretty.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CARDPNG": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x07\\x12/\\x01\\x07\\x12/\\x12B\\x07I\\x07I\\x00\\x00\\xe5\\xf1K\\xf9K\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2007-05-02T12:42:49", "lines": 1865, "newlines": 1865, "modlines": 0, "user": "V1.9.3"}, "mimetype": "image/png", "datatype": "binary", "extension": ".png"}, "DEVISIO": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00I\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00\\xd9\\x00\\xd1\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:49", "lines": 217, "newlines": 209, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: devisio.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - DEVISIO                                                **\n**                                                                   **\n** FUNCTION - Removes non-SVG markup from SVG documents created by   **\n**            Microsoft Visio. The Microsoft-specific extensions are **\n**            identified by the 'v:' name space.                     **\n**                                                                   **\n** USAGE    - You can run this Rexx on an IBM mainframe, or on a PC  **\n**            by using Regina Rexx from:                             **\n**                                                                   **\n**               http://regina-rexx.sourceforge.net                  **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - DEVISIO infile outfile [(options...]                   **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = Microsoft Visio SVG file.                   **\n**            outfile  = SVG file.                                   **\n**            options  = Options                                     **\n**                                                                   **\n** NOTES    - 1. You will have to either append the PARSEXML and     **\n**               PRETTY source files manually to this file, or run   **\n**               this file through the REXX rexx pre-processor.      **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               tso rexxpp your.rexx.lib(devisio)                   **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20051026 AJA Initial version.                          **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n\n  numeric digits 16\n  parse value sourceline(1) with . sVersion\n  say 'VIS000I Microsoft Visio SVG extensions remover' sVersion\n  if sFileIn = ''\n  then do\n    say 'Syntax:'\n    say '   devisio infile outfile (options'\n    say\n    say 'Where:'\n    say '   infile  = Microsoft Visio SVG file'\n    say '   outfile = SVG file (without Microsoft extensions)'\n    exit\n  end\n\n  sOptions = 'NOBLANKS' translate(sOptions)\n  call initParser sOptions /* DO THIS FIRST! Sets g. vars to '' */\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call Prolog\n\n  /* Open the specified file and parse it */\n  nParseRC = parseFile(sFileIn)\n  doc = getDocumentElement()\n\n  g.!PREFIXES = getVisioNamespacePrefixes(doc)\n  say 'VIS002I Removing elements and attributes with prefixes:',\n      g.!PREFIXES\n\n  call removeVisioTags doc\n\n  call findAllReferences doc\n\n  call removeUnusedReferences doc\n\n  /* fix ups to make the svg render properly...*/\n  call setAttributes doc,,\n               'xml:space','default',,\n               'xmlns:xlink','http://www.w3.org/1999/xlink'\n\n  call prettyPrinter sFileOut\n\n  call Epilog\nexit\n\ngetVisioNamespacePrefixes: procedure expose g.\n  parse arg doc\n  sAttrNames = getAttributeNames(doc)\n  sPrefixes = ''\n  do i = 1 to words(sAttrNames)\n    sAttrName = word(sAttrNames,i)\n    if left(sAttrName,6) = 'xmlns:'\n    then do\n      sNameSpace = getAttribute(doc,sAttrName)\n      if pos('schemas.microsoft.com',sNameSpace) > 0\n      then do\n        sPrefix = substr(sAttrName,7)\n        sPrefixes = sPrefixes sPrefix\n        say 'VIS001I Removing' sAttrName'='getAttribute(doc,sAttrName)\n        call removeAttribute doc,sAttrName\n      end\n    end\n  end\nreturn strip(sPrefixes)\n\nremoveVisioTags: procedure expose g.\n  parse arg node\n  sTagName = getNodeName(node)\n  if isVisioExtension(sTagName)\n  then call removeChild node\n  else do\n    if sTagName = 'marker' /* HACK: fixes Visio 2003 bug */\n    then call setAttribute node,'overflow','visible'\n    sAttrNames = getAttributeNames(node)\n    do i = 1 to words(sAttrNames)\n      sAttrName = word(sAttrNames,i)\n      if isVisioExtension(sAttrName)\n      then call removeAttribute node,sAttrName\n    end\n    children = getChildNodes(node)\n    do i = 1 to words(children)\n      child = word(children,i)\n      call removeVisioTags child\n    end\n  end\nreturn\n\nisVisioExtension: procedure expose g.\n  parse arg sTagName .\n  if wordpos(sTagName,'title desc') > 0 then return 1\n  if pos(':',sTagName) = 0              then return 0\n  parse arg sPrefix':'\n  if wordpos(sPrefix,g.!PREFIXES) > 0   then return 1\nreturn 0\n\nfindAllReferences: procedure expose g.\n  parse arg node\n  sText = getNodeValue(node)\n  do while pos('url(#',sText) > 0\n    parse var sText 'url(#'sId')'sText\n    sRef = '#'sId\n    g.!ID.sRef = 1\n  end\n  if hasAttribute(node,'xlink:href')\n  then do\n    sId = getAttribute(node,'xlink:href')\n    if left(sId,1) = '#' /* is it a local reference? */\n    then g.!ID.sId = 1 /* For example: g.!ID.#mrkr13-14 = 1 */\n  end\n  children = getChildNodes(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call findAllReferences child\n  end\nreturn\n\nremoveUnusedReferences: procedure expose g.\n  parse arg node\n  if hasAttribute(node,'id')\n  then do\n    sId = getAttribute(node,'id')\n    sRef = '#'sId\n    if g.!ID.sRef <> 1\n    then call removeAttribute node,'id'\n  end\n  children = getChildNodes(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call removeUnusedReferences child\n  end\nreturn\n\n\nProlog: procedure expose g.\nreturn\n\nEpilog: procedure expose g.\nreturn\n\n/*INCLUDE pretty.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GPL": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x07\\x12/\\x01\\x07\\x12/\\x12B\\x01\\x1a\\x01\\x1a\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2007-05-02T12:42:50", "lines": 282, "newlines": 282, "modlines": 0, "user": "V2.0.1"}, "text": "/*\n      GNU GENERAL PUBLIC LICENSE\n         Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n       Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n      GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n       NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n       END OF TERMS AND CONDITIONS\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IDLFILE": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00Y\\x00Y\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 89, "newlines": 89, "modlines": 0, "user": "V2.0.1"}, "text": "/*********************************************************************\n/** This is an example IDL file that you can process using the\n/** IDL2WSDL rexx procedure.\n/*********************************************************************\nlibrary 'TalkingClock' is\n  program 'getTime' is\n    define data parameter\n    1 result   (A32)   Out\n    end-define\n\n  program 'Sprechen' is\n    define data parameter\n    1 result   (AV80)   Out\n    end-define\n\n  program 'Speak' is\n    define data parameter\n    1 result   (AV80)   Out\n    end-define\n\nlibrary 'Security' is\n  program 'changePassword' is\n    define data parameter\n    1 userid   (A8)   In\n    1 password   (A8)   In\n    1 newPassword   (A8)   In\n    1 result   ('SecurityContext')   Out\n    end-define\n\n  program 'verify' is /*Authenticate a userid\n    define data parameter\n    1 userid   (A8)   In\n    1 password   (A8)   In\n    1 result   ('SecurityContext')   Out\n    end-define\n\n  program 'authorise' is /*Authorise access to a resource\n    define data parameter\n    1 userid   (A8)   In\n    1 password   (A8)   In\n    1 resource   (A44)   In\n    1 result   ('SecurityContext')   Out\n    end-define\n\n/*The result of a Security operation is a collection of return and reason codes\n  struct 'SecurityContext' is\n    define data parameter\n    1 userid   (A8)\n    1 success   (L)\n    1 returnCode   (B4)\n    1 reasonCode   (B4)\n    1 reason   (AV80)\n    end-define\n\n/*Preceding comment lines\nlibrary 'Gamut':'Gamut Alias' is\n  /*Same line comment\n  struct 'aStructure' is\n    define data parameter\n    1 aVar2   (D)\n    1 aVar3   (A1)\n    1 aVar4   (BV)\n    1 aVar5   (F4)\n    1 aVar6   (I4)\n    1 aVar7   (L)\n    1 aVar8   (N8.3)\n    1 aVar9   (NU8.3)\n    1 aVar10   (P8.3)\n    1 aVar11   (PU8.3)\n    1 aVar12   (T)\n    1 aGroup\n      2 aVar1   (AV80/1,2,3)    aligned\n      2 aGroup2\n        3 aVar3   (AV)\n        3 aVar2   (AV)\n    end-define\n\n  /*Preceding comment lines\n  program 'Operation':'Operation Alias' is /*Same line comment\n    define data parameter\n    1 aParm1   (A1)   In\n    1 aParm2   (AV)   Out\n    1 aStructureRef   ('aStructure')   In\n    1 aStructureRef2   ('aStructure')   Out\n    1 aStructureRef3   ('aStructure')   In Out\n    end-define\n\n\n** End of file\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IDL2WSDL": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x04l\\x04d\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 1132, "newlines": 1124, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: idl2wsdl.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - IDL2WSDL                                               **\n**                                                                   **\n** FUNCTION - Converts an EntireX Interface Definition Language (IDL)**\n**            file into a Web Services Description Language (WSDL)   **\n**            file.  It may be useful for sites that want to         **\n**            re-implement an EntireX application as a Web Service.  **\n**            It takes the tedium of converting the relatively easy  **\n**            to understand IDL file format into the hideously       **\n**            complex WSDL file format.                              **\n**                                                                   **\n**                                                                   **\n** USAGE    - You can run this Rexx on an IBM mainframe, or on a PC  **\n**            by using Regina Rexx from:                             **\n**                                                                   **\n**               http://regina-rexx.sourceforge.net                  **\n**                                                                   **\n**                                                                   **\n** SYNTAX     IDL2WSDL infile [url [ns  [ (options [)] ]]]'          **\n**                                                                   **\n**            Where,                                                 **\n**            infile  = Name of your EntireX Interface Definition    **\n**                      Language (IDL) file. For example:            **\n**                      example.idl                                  **\n**            url     = URL of the service. For example:             **\n**                      http://10.1.2.3:8080/cics/cwba/soapima       **\n**            ns      = Namespace of the service. For example:       **\n**                      http://myservice.example.org                 **\n**            options = RPC      - Remote Procedure Call (style)     **\n**                      DOCUMENT - XML document (style)              **\n**                      ENCODED  - Parameters defined inline (use)   **\n**                      LITERAL  - Parameters defined by schema (use)**\n**                      WRAPPED  - Special case of DOCUMENT LITERAL  **\n**                      XML      - Create XML file (for debugging)   **\n**                                                                   **\n**            Valid style and use combinations are:                  **\n**            WRAPPED            <-- This is the default             **\n**            DOCUMENT LITERAL                                       **\n**            RPC LITERAL                                            **\n**            RPC ENCODED                                            **\n**                                                                   **\n** NOTES    - 1. This Rexx uses the Rexx XML parser in CBT FILE 647  **\n**               from www.cbttape.org.                               **\n**               You will have to either append the PARSEXML and     **\n**               PRETTY source files manually to this file, or run   **\n**               this file through the REXX rexx pre-processor.      **\n**                                                                   **\n**               To use the pre-processor on TSO, run:               **\n**                                                                   **\n**               tso rexxpp your.rexx.lib(idl2wsdl)                  **\n**                                                                   **\n**               To use the pre-processor on Windows, run:           **\n**                                                                   **\n**               rexx rexxpp idl2wsdl.rexx idl2wsdl.new              **\n**                                                                   **\n**               ...and then rename the .new file to .rexx           **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20060525 AJA Update documentation.                     **\n**            20060216 AJA User must supply URL & namespace.         **\n**            20051106 AJA Support RPC/DOC + ENC/LIT/WRAPPED.        **\n**            20051102 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sURL sNamespace' ('sOptions')'\n\n  numeric digits 16\n  parse value sourceline(1) with . sVersion\n  say 'IDL000I EntireX IDL to WSDL File Converter' sVersion\n  if sFileIn = ''\n  then do\n    say 'Syntax:'\n    say '   IDL2WSDL infile url ns (options'\n    say\n    say 'Where:'\n    say '   infile  = EntireX IDL input file. For example:'\n    say '             example.idl'\n    say '   url     = URL of the service. For example:'\n    say '             http://10.1.2.3:8080/cics/cwba/soapima'\n    say '   ns      = Namespace of the service. For example:'\n    say '             http://myservice.example.org'\n    say '   options = RPC      - Remote Procedure Call (style)'\n    say '             DOCUMENT - XML document (style)'\n    say '             ENCODED  - Parameters defined inline (use)'\n    say '             LITERAL  - Parameters defined by schema (use)'\n    say '             WRAPPED  - Special case of DOCUMENT LITERAL'\n    say '             XML      - Create XML file (for debugging)'\n    say\n    say '   Valid option combinations are:'\n    say '     WRAPPED'\n    say '     DOCUMENT LITERAL'\n    say '     RPC LITERAL'\n    say '     RPC ENCODED'\n    exit\n  end\n  say 'IDL001I Reading EntireX IDL file in' sFileIn\n\n\n  sOptions = 'NOBLANKS' translate(sOptions)\n  call initParser sOptions /* DO THIS FIRST! Sets g. vars to '' */\n  call setDocType /* we don't need a doctype declaration */\n\n  g.!FILEIDL = sFileIn\n  g.!URL = prompt(sURL,,\n                  'Enter URL of this service',,\n                  'http://10.1.2.3:8080/cics/cwba/soapima/')\n  g.!NAMESPACE = prompt(sNamespace,,\n                  'Enter XML namespace of this service',,\n                  'http://myservice.example.org')\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call setOptions sOptions\n  call Prolog\n\n  /* Read the IDL file into an in-memory XML document */\n  idl = scanEntireXIdlFile()\n\n  sFileName = getFilenameWithoutExtension(sFileIn)\n  libraries = getChildNodes(idl)\n  do i = 1 to words(libraries)\n    library = word(libraries,i)\n    sLibrary = getAttribute(library,'name')\n    call createWSDL sFileName'.'sLibrary,library\n  end\n\n  call Epilog\nexit\n\nprompt: procedure expose g.\n  parse arg sReply,sPrompt,sDefault\n  if sReply = ''\n  then do\n    say 'IDL000R' sPrompt '['sDefault']:'\n    parse pull sReply\n    if sReply = '' then sReply = sDefault\n  end\nreturn sReply\n\n\n/*\n<wsdl:definitions targetNamespace=\"yournamespace\"\n    xmlns:apachesoap=\"http://xml.apache.org/xml-soap\"\n    xmlns:impl=\"yournamespace\"\n    xmlns:intf=\"yournamespace\"\n    xmlns:soapenc=\"http://schemas.xmlsoap.org/soap/encoding/\"\n    xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n    xmlns:wsdlsoap=\"http://schemas.xmlsoap.org/wsdl/soap/\"\n    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    .\n    .\n</wsdl:definitions>\n*/\ncreateWSDL: procedure expose g.\n  parse arg sFile,node\n  if g.!OPTION.XML\n  then call prettyPrinter sFile'.xml',,node\n\n  /* Build the high-level WSDL file structure... */\n  g.!DEFS     = createElement('wsdl:definitions')\n  g.!TYPES    = createElement('wsdl:types')\n  g.!PORTTYPE = createElement('wsdl:portType')\n  g.!BINDING  = createElement('wsdl:binding')\n  g.!SERVICE  = createElement('wsdl:service')\n\n  /* The porttype, binding and service elements are more-or-less the\n     same for all combinations of style and use, so build them now... */\n  call defineDefinitions node\n  call defineTypes node\n  call definePortType node\n  call defineBinding node\n  call defineService node\n  call appendChild g.!TYPES,g.!DEFS\n\n\n  /* Now add message elements depending on style and use... */\n  select\n    when g.!OPTION.WRAPPED then,\n      call createDocWrapped node\n    when g.!OPTION.DOCUMENT & g.!OPTION.LITERAL then,\n      call createDocLiteral node\n    when g.!OPTION.RPC & g.!OPTION.LITERAL then,\n      call createRpcLiteral node\n    when g.!OPTION.RPC & g.!OPTION.ENCODED then,\n      call createRpcEncoded node\n    otherwise,\n      call createDocWrapped node\n  end\n\n  call appendChild g.!PORTTYPE,g.!DEFS\n  call appendChild g.!BINDING,g.!DEFS\n  call appendChild g.!SERVICE,g.!DEFS\n\n  /* Serialise the WSDL document to a file... */\n  call prettyPrinter sFile'.wsdl',,g.!DEFS\nreturn\n\n\ndefineDefinitions: procedure expose g.\n  parse arg node\n  call setAttributes g.!DEFS,,\n       'targetNamespace',g.!NAMESPACE,,\n       'xmlns:impl',g.!NAMESPACE,,\n       'xmlns:intf',g.!NAMESPACE,,\n       'xmlns:wsdl','http://schemas.xmlsoap.org/wsdl/',,\n       'xmlns:wsdlsoap','http://schemas.xmlsoap.org/wsdl/soap/',,\n       'xmlns:xsd','http://www.w3.org/2001/XMLSchema'\n\n  if g.!OPTION.ENCODED\n  then call setAttribute g.!DEFS,,\n       'xmlns:soapenc','http://schemas.xmlsoap.org/soap/encoding/'\n\n  call appendChild createComment('Created by EntireX IDL-to-WSDL',\n       'converter V1.0 on' date() time() userid()),g.!DEFS\n\n  if g.!OPTION.WRAPPED\n  then call appendChild createComment('Style='getStyle() '(wrapped)',\n            'Use='getUse()),g.!DEFS\n  else call appendChild createComment('Style='getStyle(),\n            'Use='getUse()),g.!DEFS\nreturn\n\n/*\n<wsdl:types>\n    <schema targetNamespace=\"yournamespace\"\n            xmlns=\"http://www.w3.org/2001/XMLSchema\">\n        <import\n            namespace=\"http://schemas.xmlsoap.org/soap/encoding/\"/>\n        <complexType name=\"SecurityContext\">\n            <sequence>\n                <element name=\"reason\" nillable=\"true\"\n                         type=\"soapenc:string\"/>\n                <element name=\"reasonCode\" nillable=\"true\"\n                         type=\"soapenc:int\"/>\n                <element name=\"returnCode\" nillable=\"true\"\n                         type=\"soapenc:int\"/>\n                <element name=\"success\" nillable=\"true\"\n                         type=\"soapenc:boolean\"/>\n                <element name=\"userid\" nillable=\"true\"\n                         type=\"soapenc:string\"/>\n            </sequence>\n        </complexType>\n    </schema>\n</wsdl:types>\n*/\ndefineTypes: procedure expose g.\n  parse arg node\n  g.!SCHEMA = createElement('schema')\n  call appendChild g.!SCHEMA,g.!TYPES\n  if g.!OPTION.DOCUMENT | g.!OPTION.WRAPPED\n  then call setAttribute g.!SCHEMA,'elementFormDefault','qualified'\n  call setAttributes g.!SCHEMA,,\n       'targetNamespace',g.!NAMESPACE,,\n       'xmlns','http://www.w3.org/2001/XMLSchema'\n  if g.!OPTION.ENCODED\n  then do\n    import = createElement('import')\n    call appendChild import,g.!SCHEMA\n    call setAttribute import,,\n         'namespace','http://schemas.xmlsoap.org/soap/encoding/'\n  end\n  structuresnode = getChildrenByName(node,'structures')\n  structures = getChildren(structuresnode)\n  do i = 1 to words(structures)\n    struct = word(structures,i)\n    call appendComplexType struct,g.!SCHEMA\n  end\nreturn\n\n/*\n<wsdl:operation name=\"verify\">\n    <wsdl:input message=\"impl:verifyRequest\"\n                name=\"verifyRequest\"/>\n    <wsdl:output message=\"impl:verifyResponse\"\n                 name=\"verifyResponse\"/>\n</wsdl:operation>\n*/\ndefinePortType: procedure expose g.\n  parse arg node\n  sService = getAttribute(node,'name')\n  call setAttribute g.!PORTTYPE,'name',sService\n  programs = getChildrenByName(node,'programs')\n  if programs <> ''\n  then do\n    programs = getChildren(programs)\n    do i = 1 to words(programs)\n      program = word(programs,i)\n      sOperation = getAttribute(program,'name')\n      operation = createElement('wsdl:operation')\n      call appendChild operation,g.!PORTTYPE\n      call setAttribute operation,'name',sOperation\n      input = createElement('wsdl:input')\n      call appendChild input,operation\n      call setAttributes input,,\n           'message','impl:'sOperation'Request',,\n           'name',sOperation'Request'\n      output = createElement('wsdl:output')\n      call appendChild output,operation\n      call setAttributes output,,\n           'message','impl:'sOperation'Response',,\n           'name',sOperation'Response'\n    end\n  end\nreturn\n\n/*\n<wsdl:binding name=\"SecuritySoapBinding\"\n              type=\"impl:Security\">\n  <wsdlsoap:binding style=\"rpc\"\n                    transport=\"http://schemas.xmlsoap.org/soap/http\"/>\n  <wsdl:operation name=\"verify\">\n  <wsdlsoap:operation soapAction=\"\"/>\n    <wsdl:input name=\"verifyRequest\">\n        <wsdlsoap:body\n            encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"\n            namespace=\"yournamespace\"\n            use=\"encoded\"/>\n    </wsdl:input>\n    <wsdl:output name=\"verifyResponse\">\n        <wsdlsoap:body\n            encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"\n            namespace=\"yournamespace\"\n            use=\"encoded\"/>\n    </wsdl:output>\n  </wsdl:operation>\n    .\n    .\n</wsdl:binding>\n*/\ndefineBinding: procedure expose g.\n  parse arg node\n  sService = getAttribute(node,'name')\n  call setAttributes g.!BINDING,,\n       'name',sService'SoapBinding',,\n       'type','impl:'sService\n  soapbinding = createElement('wsdlsoap:binding')\n  call appendChild soapbinding,g.!BINDING\n  call setAttributes soapbinding,,\n       'style',getStyle(),,\n       'transport','http://schemas.xmlsoap.org/soap/http'\n  programs = getChildrenByName(node,'programs')\n  if programs <> ''\n  then do\n    programs = getChildren(programs)\n    do i = 1 to words(programs)\n      program = word(programs,i)\n      sOperation = getAttribute(program,'name')\n      operation = createElement('wsdl:operation')\n      call setAttribute operation,'name',sOperation\n      call appendChild operation,g.!BINDING\n      soapoperation = createElement('wsdlsoap:operation')\n      call appendChild soapoperation,operation\n      call setAttribute soapoperation,'soapAction',''\n\n      input = createElement('wsdl:input')\n      call appendChild input,operation\n      call setAttribute input,'name',sOperation'Request'\n      body = createElement('wsdlsoap:body')\n      call appendChild body,input\n      if g.!OPTION.ENCODED\n      then call setAttribute body,,\n           'encodingStyle','http://schemas.xmlsoap.org/soap/encoding/'\n      call setAttributes body,,\n           'namespace',g.!NAMESPACE,,\n           'use',getUse()\n\n      output = createElement('wsdl:output')\n      call appendChild output,operation\n      call setAttribute output,'name',sOperation'Response'\n      body = createElement('wsdlsoap:body')\n      call appendChild body,output\n      if g.!OPTION.ENCODED\n      then call setAttribute body,,\n           'encodingStyle','http://schemas.xmlsoap.org/soap/encoding/'\n      if g.!OPTION.RPC\n      then call setAttribute body,'namespace',g.!NAMESPACE\n      call setAttribute body,'use',getUse()\n    end\n  end\nreturn\n\ngetStyle: procedure expose g.\n  if g.!OPTION.RPC\n  then sStyle = 'rpc'\n  else sStyle = 'document'\nreturn sStyle\n\ngetUse: procedure expose g.\n  if g.!OPTION.ENCODED\n  then sUse = 'encoded'\n  else sUse = 'literal'\nreturn sUse\n\n/*\n<wsdl:service name=\"SecurityService\">\n    <wsdl:port binding=\"impl:SecuritySoapBinding\"\n               name=\"Security\">\n        <wsdlsoap:address\n            location=\"http://10.9.2.31:5080/axis/services/Security\"/>\n    </wsdl:port>\n</wsdl:service>\n*/\ndefineService: procedure expose g.\n  parse arg node\n  sService = getAttribute(node,'name')\n  call setAttribute g.!SERVICE,'name',sService'Service'\n  port = createElement('wsdl:port')\n  call appendChild port,g.!SERVICE\n  call setAttributes port,,\n       'binding','impl:'sService'SoapBinding',,\n       'name',sService\n  addr = createElement('wsdlsoap:address')\n  call appendChild addr,port\n  call setAttribute addr,,\n       'location',g.!URL || sService\nreturn\n\n/*\nstyle=document, use=literal [WS-I compliant, with restrictions]\n\nElements of the SOAP body are the names of XML Schema elements that\ndescribe each parameter (there is no wrapper operation and no multi-ref)\n\n   <soap:body>\n     <arg1Element>5</arg1Element>\n     <arg2Element>5.0</arg2Element>\n   </soap:body>\n\n*/\ncreateDocLiteral: procedure expose g.\n  parse arg node\n  say 'IDL003I Generating WSDL style=DOCUMENT use=LITERAL'\n  /*\n  <wsdl:message name=\"changePasswordRequest\">\n      <wsdl:part name=\"userid\" element=\"xsd:string\"/>\n      <wsdl:part name=\"password\" element=\"xsd:string\"/>\n      <wsdl:part name=\"newPassword\" element=\"xsd:string\"/>\n  </wsdl:message>\n  <wsdl:message name=\"changePasswordResponse\">\n      <wsdl:part name=\"changePasswordReturn\"\n                 element=\"impl:SecurityContext\"/>\n  </wsdl:message>\n      .\n      .\n  */\n  programs = getChildrenByName(node,'programs')\n  if programs <> ''\n  then do\n    programs = getChildren(programs)\n    do i = 1 to words(programs)\n      program = word(programs,i)\n      sOperation = getAttribute(program,'name')\n      request  = createElement('wsdl:message')\n      call appendChild request,g.!DEFS\n      call setAttribute request,'name',sOperation'Request'\n      response = createElement('wsdl:message')\n      call appendChild response,g.!DEFS\n      call setAttribute response,'name',sOperation'Response'\n      parms = getChildren(program)\n      do j = 1 to words(parms)\n        parm = word(parms,j)\n        sType = getAttribute(parm,'type')\n        if sType <> '' /* if it is not a group */\n        then do\n          sName = getAttribute(parm,'name')\n          sDir  = getAttribute(parm,'direction')\n          if wordpos('In',sDir) > 0\n          then call appendPartSchema sName,sType,request\n          if wordpos('Out',sDir) > 0\n          then call appendPartSchema sOperation'Return',sType,response\n        end\n      end\n    end\n  end\nreturn\n\n/*\n<wsdl:part name=\"userid1\" element=\"impl:userid1\"/>\n                                         |\n                  .----------------------'\n                  |\n                  V\n<element name=\"userid1\" type=\"xsd:string\"/>\nor\n<element name=\"userid1\" type=\"impl:schemaReference\"/>\n*/\nappendPartSchema: procedure expose g.\n  parse arg sName,sEntireXType,node\n  sElementName = sName\n  if g.!USED.sElementName = 1 /* If this name is already used */\n  then do\n    do i = 1 by 1 until g.!USED.sNameX = ''\n      sNameX = sElementName || i\n    end\n    sElementName = sNameX\n  end\n  g.!USED.sElementName = 1\n  element = createElement('element')\n  call appendChild element,g.!SCHEMA\n  call setAttributes element,,\n       'name',sElementName,,\n       'type',getSchemaEncoding(sEntireXType)\n  part = createElement('wsdl:part')\n  call appendChild part,node\n  call setAttributes part,,\n       'name',sName,,\n       'element','impl:'sElementName\nreturn\n\n\n/*\nstyle=wrapped\n\nSpecial case of DOCLIT where there is only one parameter and it has the\nsame qname as the operation. In such cases, there is no actual type with\nthe name. The elements are treated as parameters to the operation\n\n   <soap:body>\n      <one-arg-same-name-as-operation>\n         <arg1Element>5</arg1Element>\n         <arg2Element>5.0</arg2Element>\n      </one-arg-same-name-as-operation>\n   </soap:body>\n\n*/\ncreateDocWrapped: procedure expose g.\n  parse arg node\n  say 'IDL003I Generating WSDL style=DOCUMENT (WRAPPED) use=LITERAL'\n  /*\n  <wsdl:message name=\"verifyRequest\">\n      <wsdl:part element=\"impl:verify\" name=\"parameters\"/>\n  </wsdl:message>\n  <wsdl:message name=\"verifyResponse\">\n      <wsdl:part element=\"impl:verifyResponse\" name=\"parameters\"/>\n  </wsdl:message>\n      .\n      .\n  */\n  programs = getChildrenByName(node,'programs')\n  if programs <> ''\n  then do\n    programs = getChildren(programs)\n    do i = 1 to words(programs)\n      program = word(programs,i)\n      sOperation = getAttribute(program,'name')\n      sRequestElement = sOperation\n      sResponseElement = sOperation'Response'\n\n      call appendMessage sOperation'Request',sRequestElement\n      call appendMessage sOperation'Response',sResponseElement\n\n      request  = getSequence(sRequestElement)\n      response = getSequence(sResponseElement)\n      parms = getChildren(program)\n      do j = 1 to words(parms)\n        parm = word(parms,j)\n        sType = getAttribute(parm,'type')\n        if sType <> '' /* if it is not a group */\n        then do\n          sName = getAttribute(parm,'name')\n          sDir  = getAttribute(parm,'direction')\n          if wordpos('In',sDir) > 0\n          then call appendWrapped sName,sType,request\n          if wordpos('Out',sDir) > 0\n          then call appendWrapped sOperation'Return',sType,response\n        end\n      end\n    end\n  end\nreturn\n\nappendMessage: procedure expose g.\n  parse arg sMessageName,sElementName\n  message = createElement('wsdl:message')\n  call appendChild message,g.!DEFS\n  call setAttribute message,'name',sMessageName\n  part = createElement('wsdl:part')\n  call appendChild part,message\n  call setAttributes part,,\n       'name','parameters',,\n       'element','impl:'sElementName\nreturn\n\n/*\n  <element name=\"verify\">\n      <complexType>\n          <sequence>\n              <element name=\"userid\" type=\"xsd:string\"/>\n              <element name=\"password\" type=\"xsd:string\"/>\n          </sequence>\n      </complexType>\n  </element>\n  <element name=\"verifyResponse\">\n      <complexType>\n          <sequence>\n              <element name=\"verifyReturn\"\n                       type=\"impl:SecurityContext\"/>\n          </sequence>\n      </complexType>\n  </element>\n*/\ngetSequence: procedure expose g.\n  parse arg sName\n  element = createElement('element')\n  call appendChild element,g.!SCHEMA\n  call setAttribute element,'name',sName\n  complexType = createElement('complexType')\n  call appendChild complexType,element\n  sequence = createElement('sequence')\n  call appendChild sequence,complexType\nreturn sequence\n\n/*\n   <element name=\"userid\" type=\"xsd:string\"/>\n   or\n   <element name=\"verifyReturn\" type=\"impl:schemaReference\"/>\n*/\nappendWrapped: procedure expose g.\n  parse arg sName,sEntireXType,sequence\n  element = createElement('element')\n  call appendChild element,sequence\n  call setAttributes element,,\n       'name',sName,,\n       'type',getSchemaEncoding(sEntireXType)\nreturn\n\n/*\nstyle=document, use=encoded [NOT WS-I compliant]\n\nThere is no enclosing operation name element, but the parmeters are\nencoded using SOAP encoding. This mode is not (well?) supported by\nApache Axis.\n\n*/\ncreateDocEncoded: procedure expose g.\n  parse arg node\n  say 'IDL099W WSDL style=DOCUMENT use=ENCODED not supported'\nreturn\n\n/*\nstyle=rpc, use=literal\n\nFirst element of the SOAP body is the operation.\nThe operation contains elements describing the parameters,\nwhich are not serialized as encoded (and no multi-ref)\n\n   <soap:body>\n      <operation>\n         <arg1>5</arg1>\n         <arg2>5.0</arg2>\n      </operation>\n   </soap:body>\n\n*/\ncreateRpcLiteral: procedure expose g.\n  parse arg node\n  say 'IDL003I Generating WSDL style=RPC use=LITERAL'\n  /*\n  <wsdl:message name=\"changePasswordRequest\">\n      <wsdl:part name=\"userid\" type=\"xsd:string\"/>\n      <wsdl:part name=\"password\" type=\"xsd:string\"/>\n      <wsdl:part name=\"newPassword\" type=\"xsd:string\"/>\n  </wsdl:message>\n  <wsdl:message name=\"changePasswordResponse\">\n      <wsdl:part name=\"changePasswordReturn\"\n                 type=\"impl:SecurityContext\"/>\n  </wsdl:message>\n      .\n      .\n  */\n  programs = getChildrenByName(node,'programs')\n  if programs <> ''\n  then do\n    programs = getChildren(programs)\n    do i = 1 to words(programs)\n      program = word(programs,i)\n      sOperation = getAttribute(program,'name')\n      request  = createElement('wsdl:message')\n      call appendChild request,g.!DEFS\n      call setAttribute request,'name',sOperation'Request'\n      response = createElement('wsdl:message')\n      call appendChild response,g.!DEFS\n      call setAttribute response,'name',sOperation'Response'\n      parms = getChildren(program)\n      do j = 1 to words(parms)\n        parm = word(parms,j)\n        sType = getAttribute(parm,'type')\n        if sType <> '' /* if it is not a group */\n        then do\n          sName = getAttribute(parm,'name')\n          sDir  = getAttribute(parm,'direction')\n          if wordpos('In',sDir) > 0\n          then call appendPartType sName,sType,request\n          if wordpos('Out',sDir) > 0\n          then call appendPartType sOperation'Return',sType,response\n        end\n      end\n    end\n  end\nreturn\n\n/*\nstyle=rpc, use=encoded [NOT WS-I compliant]\n\nFirst element of the SOAP body is the operation.\nThe operation contains elements describing the parameters,\nwhich are serialized as encoded (possibly multi-ref)\n\n   <soap:body>\n      <operation>\n         <arg1 xsi:type=\"xsd:int\">5</arg1>\n         <arg2 xsi:type=\"xsd:float\">5.0</arg2>\n      </operation>\n   </soap:body>\n\n*/\ncreateRpcEncoded: procedure expose g.\n  parse arg node\n  say 'IDL003I Generating WSDL style=RPC use=ENCODED'\n  /*\n  <wsdl:message name=\"changePasswordRequest\">\n      <wsdl:part name=\"userid\" type=\"soapenc:string\"/>\n      <wsdl:part name=\"password\" type=\"soapenc:string\"/>\n      <wsdl:part name=\"newPassword\" type=\"soapenc:string\"/>\n  </wsdl:message>\n  <wsdl:message name=\"changePasswordResponse\">\n      <wsdl:part name=\"changePasswordReturn\"\n                 type=\"impl:SecurityContext\"/>\n  </wsdl:message>\n      .\n      .\n  */\n  programs = getChildrenByName(node,'programs')\n  if programs <> ''\n  then do\n    programs = getChildren(programs)\n    do i = 1 to words(programs)\n      program = word(programs,i)\n      sOperation = getAttribute(program,'name')\n      request  = createElement('wsdl:message')\n      call appendChild request,g.!DEFS\n      call setAttribute request,'name',sOperation'Request'\n      response = createElement('wsdl:message')\n      call appendChild response,g.!DEFS\n      call setAttribute response,'name',sOperation'Response'\n      parms = getChildren(program)\n      do j = 1 to words(parms)\n        parm = word(parms,j)\n        sType = getAttribute(parm,'type')\n        if sType <> '' /* if it is not a group */\n        then do\n          sName = getAttribute(parm,'name')\n          sDir  = getAttribute(parm,'direction')\n          if wordpos('In',sDir) > 0\n          then call appendPartType sName,sType,request\n          if wordpos('Out',sDir) > 0\n          then call appendPartType sOperation'Return',sType,response\n        end\n      end\n    end\n  end\nreturn\n\n/*\n<wsdl:part name=\"userid\" type=\"soapenc:string\"/>\nor\n<wsdl:part name=\"operationReturn\" type=\"impl:schemaReference\"/>\n*/\nappendPartType: procedure expose g.\n  parse arg sName,sEntireXType,node\n  part = createElement('wsdl:part')\n  call appendChild part,node\n  call setAttributes part,,\n       'name',sName,,\n       'type',getEncoding(sEntireXType)\nreturn\n\n/*\n<complexType name=\"SecurityContext\">\n    <sequence>\n        <element name=\"reason\" nillable=\"true\"\n                 type=\"soapenc:string\"/>\n        <element name=\"reasonCode\" nillable=\"true\"\n                 type=\"soapenc:int\"/>\n        <element name=\"returnCode\" nillable=\"true\"\n                 type=\"soapenc:int\"/>\n        <element name=\"success\" nillable=\"true\"\n                 type=\"soapenc:boolean\"/>\n        <element name=\"userid\" nillable=\"true\"\n                 type=\"soapenc:string\"/>\n    </sequence>\n</complexType>\n*/\nappendComplexType: procedure expose g.\n  parse arg struct,schema\n  sStructureName = getAttribute(struct,'name')\n  complexType = createElement('complexType')\n  call appendChild complexType,schema\n  call setAttribute complexType,'name',sStructureName\n  sequence = createElement('sequence')\n  call appendChild sequence,complexType\n  parms = getChildNodes(struct)\n  do i = 1 to words(parms)\n    parm = word(parms,i)\n    nLevel = getAttribute(parm,'level')\n    sName  = getAttribute(parm,'name')\n    sType  = getAttribute(parm,'type')\n    sDirection = getAttribute(parm,'direction')\n    select\n      when sType = '' then do\n        /* ignore an EntireX grouping level */\n      end\n      when left(sType,1) = \"'\" then do\n        parse var sType \"'\"sRef\"'\"\n      end\n      otherwise do\n        call appendElement sName,sType,sequence\n      end\n    end\n  end\nreturn\n\n/*\n<sequence>\n    <element name=\"reason\" nillable=\"true\"\n             type=\"soapenc:string\"/>\n    <element name=\"reasonCode\" nillable=\"true\"\n             type=\"soapenc:int\"/>\n    <element name=\"returnCode\" nillable=\"true\"\n             type=\"soapenc:int\"/>\n    <element name=\"success\" nillable=\"true\"\n             type=\"soapenc:boolean\"/>\n    <element name=\"userid\" nillable=\"true\"\n             type=\"soapenc:string\"/>\n</sequence>\n*/\nappendElement: procedure expose g.\n  parse arg sName,sEntireXType,sequence\n  element = createElement('element')\n  call appendChild element,sequence\n  call setAttributes element,,\n       'name',sName,,\n       'nillable','true',,\n       'type',getEncoding(sEntireXType)\nreturn\n\ngetEncoding: procedure expose g.\n  parse arg sEntireXType\n  if g.!OPTION.ENCODED\n  then sEncoding = getSoapEncoding(sEntireXType)\n  else sEncoding = getSchemaEncoding(sEntireXType)\nreturn sEncoding\n\n/* Map an EntireX data type to a SOAP encoded type */\ngetSoapEncoding: procedure expose g.\n  parse arg sEntireXType . 1 sType1 +1 1 sType2 +2\n  select\n    when sType1 = 'A' then do /* alphanumeric */\n      if sType2 = 'AV'        /* variable length */\n      then sEncoding = 'soapenc:string'\n      else sEncoding = 'soapenc:string'\n    end\n    when sType1 = 'B' then do /* binary */\n      if sType2 = 'BV'        /* variable length */\n      then sEncoding = 'soapenc:int'\n      else sEncoding = 'soapenc:int'\n    end\n    when sType1 = 'D' then do /* date */\n      sEncoding = 'soapenc:date'\n    end\n    when sType1 = 'F' then do /* floating point */\n      sEncoding = 'soapenc:float'\n    end\n    when sType1 = 'I' then do /* integer */\n      sEncoding = 'soapenc:int'\n    end\n    when sType1 = 'L' then do /* logical */\n      sEncoding = 'soapenc:boolean'\n    end\n    when sType1 = 'N' then do /* numeric */\n      if sType2 = 'NU'        /* unsigned */\n      then sEncoding = 'soapenc:decimal'\n      else sEncoding = 'soapenc:decimal'\n    end\n    when sType1 = 'P' then do /* packed decimal */\n      if sType2 = 'PU'        /* unsigned */\n      then sEncoding = 'soapenc:decimal'\n      else sEncoding = 'soapenc:decimal'\n    end\n    when sType1 = 'T' then do /* time */\n      sEncoding = 'soapenc:time'\n    end\n    when sType1 = \"'\" then do /* reference to a struct */\n      parse var sEntireXType \"'\"sReference\"'\"\n      sEncoding = 'impl:'sReference\n    end\n    otherwise do\n      sEncoding = 'soapenc:anyType'\n    end\n  end\nreturn sEncoding\n\n/* Map an EntireX data type to an XML schema data type */\ngetSchemaEncoding: procedure expose g.\n  parse arg sEntireXType . 1 sType1 +1 1 sType2 +2\n  select\n    when sType1 = 'A' then do /* alphanumeric */\n      if sType2 = 'AV'        /* variable length */\n      then sEncoding = 'xsd:string'\n      else sEncoding = 'xsd:string'\n    end\n    when sType1 = 'B' then do /* binary */\n      if sType2 = 'BV'        /* variable length */\n      then sEncoding = 'xsd:int'\n      else sEncoding = 'xsd:int'\n    end\n    when sType1 = 'D' then do /* date */\n      sEncoding = 'xsd:date'\n    end\n    when sType1 = 'F' then do /* floating point */\n      sEncoding = 'xsd:float'\n    end\n    when sType1 = 'I' then do /* integer */\n      sEncoding = 'xsd:int'\n    end\n    when sType1 = 'L' then do /* logical */\n      sEncoding = 'xsd:boolean'\n    end\n    when sType1 = 'N' then do /* numeric */\n      if sType2 = 'NU'        /* unsigned */\n      then sEncoding = 'xsd:decimal'\n      else sEncoding = 'xsd:decimal'\n    end\n    when sType1 = 'P' then do /* packed decimal */\n      if sType2 = 'PU'        /* unsigned */\n      then sEncoding = 'xsd:decimal'\n      else sEncoding = 'xsd:decimal'\n    end\n    when sType1 = 'T' then do /* time */\n      sEncoding = 'xsd:time'\n    end\n    when sType1 = \"'\" then do /* reference to a struct */\n      parse var sEntireXType \"'\"sReference\"'\"\n      sEncoding = 'impl:'sReference\n    end\n    otherwise do\n      sEncoding = 'xsd:anyType'\n    end\n  end\nreturn sEncoding\n\n\ngetFilenameWithoutExtension: procedure expose g.\n  parse arg sFile\n  parse value reverse(sFile) with '.'sRest\nreturn reverse(sRest)\n\nscanEntireXIdlFile: procedure expose g.\n  idl = createElement('idl')\n  g.!FILEIN = openFile(g.!FILEIDL)\n  sLine = getNextLine()\n  do while g.!RC = 0 & sLine <> '** End of file'\n    parse var sLine sAction sName ' is'\n    select\n      when sAction = 'library' then do\n        parse var sName sName':'sAlias\n        sName  = strip(sName,'BOTH',\"'\")\n        sAlias = strip(sAlias,'BOTH',\"'\")\n        library = createElement('library')\n        call setAttributes library,,\n             'name',sName,,\n             'alias',sAlias\n        call appendChild library,idl\n        structures = createElement('structures')\n        call appendChild structures,library\n        programs = createElement('programs')\n        call appendChild programs,library\n      end\n      when sAction = 'program' then do\n        parse var sName sName':'sAlias\n        sName  = strip(sName,'BOTH',\"'\")\n        sAlias = strip(sAlias,'BOTH',\"'\")\n        program = createElement('program')\n        call setAttributes program,,\n             'name',sName,,\n             'alias',sAlias\n        call appendChild program,programs\n        call getParameters program\n      end\n      when sAction = 'struct' then do\n        parse var sName sName':'sAlias\n        g.!STRUCT = sName\n        sName  = strip(sName,'BOTH',\"'\")\n        sAlias = strip(sAlias,'BOTH',\"'\")\n        struct = createElement('struct')\n        call setAttributes struct,,\n             'name',sName,,\n             'alias',sAlias\n        call appendChild struct,structures\n        call getParameters struct\n      end\n      otherwise do\n        say 'IDL002E Unknown IDL file input line:' sLine\n      end\n    end\n    sLine = getNextLine()\n  end\n  rc = closeFile(g.!FILEIN)\nreturn idl\n\ngetParameters: procedure expose g.\n  parse arg parent\n  sLine = getLineContaining('define data parameter')\n  if g.!RC <> 0 then return\n  sLine = getNextLine()\n  do while g.!RC = 0 & sLine <> 'end-define'\n    parse var sLine nLevel sName '('sType')' sDirection\n    parm = createElement('parm')\n    call appendChild parm,parent\n    call setAttributes parm,,\n         'level',nLevel,,\n         'name',strip(sName),,\n         'type',sType\n    if sDirection <> ''\n    then call setAttribute parm,'direction',strip(sDirection)\n    sLine = getNextLine()\n  end\nreturn\n\ngetLineContaining: procedure expose g.\n  parse arg sSearchArg\n  sLine = getLine(g.!FILEIN)\n  do while g.!RC = 0 & pos(sSearchArg, sLine) = 0\n    sLine = getLine(g.!FILEIN)\n  end\nreturn sLine\n\ngetNextLine: procedure expose g.\n  sLine = removeWhiteSpace(getLine(g.!FILEIN))\n  do while g.!RC = 0 & (sLine = '' | left(sLine,2) = '/*')\n    sLine = removeWhiteSpace(getLine(g.!FILEIN))\n  end\n  if pos('/*',sLine) > 0\n  then parse var sLine sLine '/*' .\nreturn sLine\n\nsetOptions: procedure expose g.\n  parse upper arg sOptions\n  /* set default options... */\n  g.!OPTION.DUMP     = 0\n  g.!OPTION.XML      = 0\n  g.!OPTION.RPC      = 0\n  g.!OPTION.DOCUMENT = 0\n  g.!OPTION.ENCODED  = 0\n  g.!OPTION.LITERAL  = 0\n  g.!OPTION.WRAPPED  = 0\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n    g.!OPTION.sOption = 1\n  end\n  if g.!OPTION.RPC | g.!OPTION.DOCUMENT |,\n     g.!OPTION.ENCODED | g.!OPTION.LITERAL | g.!OPTION.WRAPPED\n  then nop\n  else do /* Set the default style... */\n    g.!OPTION.WRAPPED  = 1\n  end\n  if g.!OPTION.WRAPPED\n  then do\n    g.!OPTION.DOCUMENT = 1\n    g.!OPTION.LITERAL  = 1\n    g.!OPTION.RPC      = 0\n    g.!OPTION.ENCODED  = 0\n  end\n  if g.!OPTION.DOCUMENT then g.!OPTION.RPC = 0\n  if g.!OPTION.RPC      then g.!OPTION.DOCUMENT = 0\n  if g.!OPTION.LITERAL  then g.!OPTION.ENCODED = 0\n  if g.!OPTION.ENCODED  then g.!OPTION.LITERAL = 0\nreturn\n\nProlog:\n  if g.!ENV = 'TSO'\n  then g.!LF = '15'x\n  else g.!LF = '0A'x\n  doc = createDocument('dummy') /* just to get structures in place */\nreturn\n\nEpilog: procedure expose g.\nreturn\n\n/*INCLUDE pretty.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IO": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00\\xea\\x00\\xe2\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 234, "newlines": 226, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: io.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - IO                                                     **\n**                                                                   **\n** FUNCTION - Simple I/O routines.                                   **\n**                                                                   **\n** API      - The routines in this module are:                       **\n**                                                                   **\n**            openFile(filename,options,attrs)                       **\n**                Opens the specified file with the specified options**\n**                and returns a file handle to be used in other I/O  **\n**                operations. By default the file will be opened for **\n**                input. Specify 'OUTPUT' to open it for output.     **\n**                For TSO, you can specify any operand of the TSO    **\n**                ALLOCATE command in the third operand. For example:**\n**                rc = openFile('MY.FILE','OUTPUT','RECFM(F,B)'      **\n**                              'LRECL(80) BLKSIZE(27920)')          **\n**                                                                   **\n**            closeFile(handle)                                      **\n**                Closes the file specified by 'handle' (which was   **\n**                returned by the openFile() routine.                **\n**                                                                   **\n**            getLine(handle)                                        **\n**                Reads the next line from the file specified by     **\n**                'handle'.                                          **\n**                                                                   **\n**            putLine(handle,data)                                   **\n**                Appends the specified data to the file specified   **\n**                by 'handle'.                                       **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --------------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20061017 AJA Added support for UNIX environment.       **\n**                         Tested on Ubuntu Linux 6.06 LTS.          **\n**            20050930 AJA Initial version.                          **\n**                                                                   **\n**********************************************************************/\n\n  parse source . . sSourceFile .\n  parse value sourceline(1) with . sVersion\n  say 'Simple Rexx I/O routines' sVersion\n  say 'You cannot invoke this rexx by itself!'\n  say\n  say 'This rexx is a collection of subroutines to be called'\n  say 'from your own rexx procedures. You should either:'\n  say '  - Append this procedure to your own rexx procedure,'\n  say '    or,'\n  say '  - Append the following line to your rexx:'\n  say '    /* INCLUDE' sSourceFile '*/'\n  say '    ...and run the rexx preprocessor:'\n  say '    rexxpp myrexx myrexxpp'\n  say '    This will create myrexxpp by appending this file to myrexx'\nexit\n\n/*-------------------------------------------------------------------*\n * Open a file\n *-------------------------------------------------------------------*/\n\nopenFile: procedure expose g.\n  parse arg sFile,sOptions,sAttrs\n  hFile = ''\n  select\n    when g.!ENV = 'TSO' then do\n      bOutput = wordpos('OUTPUT',sOptions) > 0\n      bQuoted = left(sFile,1) = \"'\"\n      if bQuoted then sFile = strip(sFile,,\"'\")\n      parse var sFile sDataset'('sMember')'\n      if sMember <> '' then sFile = sDataset\n      if bQuoted then sFile = \"'\"sFile\"'\"\n      if bOutput\n      then 'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n      else 'LMINIT  DATAID(hFile) DATASET(&sFile)'\n      if sMember <> ''\n      then do /* Open a member of a PDS */\n        'LMOPEN  DATAID(&hFile) OPTION(INPUT)' /* Input initially */\n        /* ... can't update ISPF stats when opened for output */\n        g.!MEMBER.hFile = sMember\n        'LMMFIND DATAID(&hFile) MEMBER('sMember') STATS(YES)'\n        if bOutput\n        then do\n          if rc = 0\n          then g.!STATS.hFile = zlvers','zlmod','zlc4date\n          else g.!STATS.hFile = '1,0,0000/00/00'\n          'LMCLOSE DATAID(&hFile)'\n          'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        end\n      end\n      else do /* Open a sequential dataset */\n        'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        if rc <> 0 /* If dataset does not already exist... */\n        then do /* Create sequential dataset then open it */\n          'LMCLOSE DATAID(&hFile)'\n          'LMFREE  DATAID(&hFile)'\n          address TSO 'ALLOCATE DATASET('sFile') NEW CATALOG',\n                      'SPACE(5,15) TRACKS RECFM(V,B)',\n                      'LRECL('g.!OPTION.WRAP.1 + 4')',\n                      'BLKSIZE(27990)' sAttrs\n          if bOutput\n          then do\n            'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n            'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n          end\n          else do\n            'LMINIT  DATAID(hFile) DATASET(&sFile)'\n            'LMOPEN  DATAID(&hFile) OPTION(INPUT)'\n          end\n        end\n      end\n      g.!OPTIONS.hFile = sOptions\n      g.!rc = rc /* Return code from LMOPEN */\n    end\n    otherwise do\n      if wordpos('OUTPUT',sOptions) > 0\n      then junk = stream(sFile,'COMMAND','OPEN WRITE REPLACE')\n      else junk = stream(sFile,'COMMAND','OPEN READ')\n      hFile = sFile\n      if stream(sFile,'STATUS') = 'READY'\n      then g.!rc = 0\n      else g.!rc = 4\n    end\n  end\nreturn hFile\n\n/*-------------------------------------------------------------------*\n * Read a line from the specified file\n *-------------------------------------------------------------------*/\n\ngetLine: procedure expose g.\n  parse arg hFile\n  sLine = ''\n  select\n    when g.!ENV = 'TSO' then do\n      'LMGET DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN(nLine) MAXLEN(32768)'\n      g.!rc = rc\n      sLine = strip(sLine,'TRAILING')\n      if sLine = '' then sLine = ' '\n    end\n    otherwise do\n      g.!rc = 0\n      if chars(hFile) > 0\n      then sLine = linein(hFile)\n      else g.!rc = 4\n    end\n  end\nreturn sLine\n\n/*-------------------------------------------------------------------*\n * Append a line to the specified file\n *-------------------------------------------------------------------*/\n\nputLine: procedure expose g.\n  parse arg hFile,sLine\n  select\n    when g.!ENV = 'TSO' then do\n      g.!LINES = g.!LINES + 1\n      'LMPUT DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN('length(sLine)')'\n    end\n    otherwise do\n      junk = lineout(hFile,sLine)\n      rc = 0\n    end\n  end\nreturn rc\n\n/*-------------------------------------------------------------------*\n * Close the specified file\n *-------------------------------------------------------------------*/\n\ncloseFile: procedure expose g.\n  parse arg hFile\n  rc = 0\n  select\n    when g.!ENV = 'TSO' then do\n      if g.!MEMBER.hFile <> '', /* if its a PDS */\n      & wordpos('OUTPUT',g.!OPTIONS.hFile) > 0 /* opened for output */\n      then do\n        parse value date('STANDARD') with yyyy +4 mm +2 dd +2\n        parse var g.!STATS.hFile zlvers','zlmod','zlc4date\n        zlcnorc  = min(g.!LINES,65535)   /* Number of lines   */\n        nVer = right(zlvers,2,'0')right(zlmod,2,'0')  /* vvmm */\n        nVer = right(nVer+1,4,'0')       /* vvmm + 1          */\n        parse var nVer zlvers +2 zlmod +2\n        if zlc4date = '0000/00/00'\n        then zlc4date = yyyy'/'mm'/'dd   /* Creation date     */\n        zlm4date = yyyy'/'mm'/'dd        /* Modification date */\n        zlmtime  = time()                /* Modification time */\n        zluser   = userid()              /* Modification user */\n        'LMMREP DATAID(&hFile) MEMBER('g.!MEMBER.hFile') STATS(YES)'\n      end\n      'LMCLOSE DATAID(&hFile)'\n      'LMFREE  DATAID(&hFile)'\n    end\n    otherwise do\n      if stream(hFile,'COMMAND','CLOSE') = 'UNKNOWN'\n      then rc = 0\n      else rc = 4\n    end\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCL2XML": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\t\\xdd\\x11\\xa8\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 2525, "newlines": 4520, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 7 $\n$Id: jcl2xml.rex 7 2009-09-05 07:24:32Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - JCL2XML                                                **\n**                                                                   **\n** FUNCTION - Creates an XML and GraphML representation of JCL.      **\n**                                                                   **\n**            This is the first step in creating stunning visual     **\n**            documentation of your JCL. GraphML (Graph Markup       **\n**            Language) is an XML standard for decribing the nodes   **\n**            and edges in a graph - in the mathematical sense.      **\n**            In plain English it describes boxes connected by lines **\n**            in a diagram.                                          **\n**                                                                   **\n**            The GraphML output can be viewed by a GraphML editor   **\n**            such as yEd from yWorks (www.yworks.com) and exported  **\n**            to SVG or PDF format for posting on your intranet.     **\n**                                                                   **\n**            The XML output can be used for any purpose. For        **\n**            example, you may transform it using XSLT, say, into    **\n**            documentation. You could also use it to recreate your  **\n**            JCL will all COND= steps replaced by IF/THEN/ELSE.     **\n**                                                                   **\n** USAGE    - You can run this Rexx on an IBM mainframe or on a PC   **\n**            with no code changes.                                  **\n**                                                                   **\n**            If you run JCL2XML on your PC, you should use Regina   **\n**            Rexx from:                                             **\n**                                                                   **\n**               http://regina-rexx.sourceforge.net                  **\n**                                                                   **\n**            or ooRexx from:                                        **\n**                                                                   **\n**               http://oorexx.sourceforge.net                       **\n**                                                                   **\n**            If you run JCL2XML on your mainframe, you should use   **\n**            ftp to download the resulting files to your PC by:     **\n**                                                                   **\n**            ftp yourmainframe                                      **\n**            youruserid                                             **\n**            yourpassword                                           **\n**            quote site sbdataconn=(IBM-1047,ISO8859-1)             **\n**            get 'your.xml'  your.xml                               **\n**            get 'your.gml'  your.graphml                           **\n**                                                                   **\n**            Alternatively, you can download your JCL to a PC and   **\n**            run JCL2XML on your PC by:                             **\n**                                                                   **\n**            rexx jcl2xml.rexx your.jcl                             **\n**                                                                   **\n**            This will read your.jcl and create your.xml and        **\n**            your.graphml.                                          **\n**                                                                   **\n**            With the GraphML output on your PC, you can use a      **\n**            GraphML editor such as yEd from www.yworks.com to      **\n**            view a flowchart-style representation of the JCL.      **\n**            To do this with yEd:                                   **\n**                                                                   **\n**            1. Start yEd by running yed.exe                        **\n**            2. Open the graphml file created by jcl2xml. You will  **\n**               see crap piled on crap at this stage because the    **\n**               graph has not been layed out yet...                 **\n**            3. Choose Layout from the main menu                    **\n**            4. Choose Orthogonal from the Layout dropdown          **\n**            5. Choose UML Style from the Orthogonal dropdown       **\n**            6. Click the Apply button. The result is a reasonable  **\n**               attempt to layout the graph. You can tweak the      **\n**               layout by clicking and dragging boxes and lines.    **\n**               Displaying and snapping to grid lines is helpful    **\n**               while doing the tweaking.                           **\n**            7. If you intend to do this layout often, then click   **\n**               the Dock button to move this dialog box to the      **\n**               left hand side of the window. You will now be able  **\n**               to just click the 'play' button to layout the       **\n**               graph instead of having to choose Layout from the   **\n**               main menu all over again.                           **\n**            8. Now you can export the resulting diagram in a       **\n**               number of formats including Scalable Vector Graphics**\n**               (SVG) which is an excellent format for posting on   **\n**               your intranet. Other formats include png, pdf, jpg, **\n**               gif, html, bmp and wmf.                             **\n**            9. Try out a few other layout strategies if you want,  **\n**               but I think UML Style is best for JCL.              **\n**                                                                   **\n** SYNTAX   - JCL2XML infile outfile [(options...]                   **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = File containing JCL.                        **\n**            outfile  = Output xml and graphml path.                **\n**            options  = XML    - Output infile.xml                  **\n**                       GRAPHML- Output infile.graphml              **\n**                       JCL    - Output infile.jcl (reconstructed   **\n**                                from the XML).                     **\n**                       DUMP   - List the parse tree for debugging. **\n**                       SYSOUT - Include SYSOUT DDs in the graph.   **\n**                       DUMMY  - Include DUMMY  DDs in the graph.   **\n**                       INLINE - Include instream data in the graph.**\n**                       TRACE  - Trace parsing of the JCL.          **\n**                       ENCODING - Emit encoding=xxx in XML prolog. **\n**                       WRAP n - Wrap XML output so that each line  **\n**                                is no wider than 'n' characters.   **\n**                                This is not always possible - for  **\n**                                example, very long attribute values**\n**                                cannot be wrapped over multiple    **\n**                                lines. The default value for 'n'   **\n**                                is 255.                            **\n**                       LINE   - Output _line attributes containing **\n**                                the source JCL line number.        **\n**                       ID     - Output _id attributes (a unique    **\n**                                id per element). This attribute is **\n**                                nameed '_id' so that it does not   **\n**                                clash with the predefined 'id'     **\n**                                attribute in the XML specification.**\n**                                                                   **\n**                       You can negate any option by prefixing it   **\n**                       with NO. For example, NOXML.                **\n**                                                                   **\n**                                                                   **\n** LOGIC    - The general approach is to:                            **\n**            1. Scan the JCL and build an in-memory XML document.   **\n**            2. Walk through the in-memory XML document and create  **\n**               another in-memory XML document containing graphml   **\n**               markup.                                             **\n**            3. Write out the XML and graphml documents to files.   **\n**            4. If the JCL option is specified, write out a recon-  **\n**               struction of the JCL from the in-memory XML data.   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** CONTRIBUTORS -                                                    **\n**            Herbert.Frommwieser@partner.bmw.de                     **\n**            Anne.Feldmeier@partner.bmw.de                          **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20070323 AJA Used createDocumentFragment() API.        **\n**            20070220 AJA Added JCL option to output a file         **\n**                         containing JCL reconstructed from the     **\n**                         in-memory XML document. This effect-      **\n**                         ively reformats your JCL file.            **\n**            20070215 AJA Reworked string handling. Quotes are      **\n**                         no longer stripped from quoted            **\n**                         strings. This simplifies recreation       **\n**                         of the JCL from the XML.                  **\n**            20070208 AJA Allow numeric values to be specified      **\n**                         after command line options. This is       **\n**                         so that you can, for example, specify     **\n**                         WRAP 72 to wrap XML output lines at       **\n**                         column 72.                                **\n**            20070130 AJA Parsed comments on ELSE statement.        **\n**                         Added LINE and ID options.       .        **\n**            20070128 AJA Implemented output line wrapping if       **\n**                         line length exceeds the value in          **\n**                         g.!MAX_OUTPUT_LINE_LENGTH and the         **\n**                         WRAP option is specified. NOWRAP is       **\n**                         the default for all environments          **\n**                         other than TSO.                           **\n**            20070124 AJA Only append inline data once!             **\n**            20070119 AJA Rework inline data processing under       **\n**                         TSO such that the CDATA section is        **\n**                         split into lines at each linefeed         **\n**                         instead of being output as a single       **\n**                         possibly very long record.                **\n**            20070118 AJA Write CDATA as multiple records in a      **\n**                         TSO environment.                          **\n**            20070117 HF  Added support for JES3 statements &       **\n**                     AF  Tivoli Workload Scheduler (formerly       **\n**                         OPC) directives.                          **\n**            20070117 AF  Initialize g.!RC                          **\n**            20061017 AJA Added support for UNIX environment.       **\n**                         Tested on Ubuntu Linux 6.06 LTS.          **\n**            20061012 AJA Preserved spaces in JCL comments.         **\n**            20061006 AJA Added TRACE option (default NOTRACE).     **\n**                         Added ENCODING option to allow the        **\n**                         XML prolog \"encoding\" attribute to be     **\n**                         suppressed using NOENCODING.              **\n**                         Added src attribute to jcl element        **\n**                         identifying the source of the JCL.        **\n**                         Added _line attribute containing the      **\n**                         line number of the first card of each     **\n**                         statement parsed.                         **\n**            20060922 AJA Fix bug in getParmMap().                  **\n**            20060901 AJA Initial version.                          **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n\n  numeric digits 16\n  parse value sourceline(1) with . sVersion\n  say 'JCL000I JCL to XML Converter' sVersion\n  if sFileIn = ''\n  then do\n    say 'Syntax:'\n    say '   JCL2XML infile outfile [(options]'\n    say\n    say 'Where:'\n    say '   infile   = Input job control file'\n    say '   outfile  = Output xml and graphml path'\n    say '   options  = XML    - Output infile.xml'\n    say '              GRAPHML- Output infile.graphml'\n    say '              JCL    - Output infile.jcl (reconstructed'\n    say '                       from the XML)'\n    say '              DUMP   - List the parse tree for debugging'\n    say '              SYSOUT - Include SYSOUT DDs in the graph'\n    say '              DUMMY  - Include DUMMY  DDs in the graph'\n    say '              INLINE - Include instream data in the graph'\n    say '              TRACE  - Trace parsing of the JCL'\n    say '              ENCODING - Emit encoding=\"xxx\" in XML prolog'\n    say '              WRAP n - Wrap output, where possible, to be no'\n    say '                       wider than n characters'\n    say '              LINE   - Output _line attributes containing'\n    say '                       the source JCL line number'\n    say '              ID     - Output _id attributes'\n    say\n    say '              You can negate any option by prefixing it'\n    say '              with NO. For example, NOXML.'\n    exit\n  end\n  say 'JCL001I Scanning job control in' sFileIn\n\n  sOptions = 'NOBLANKS' toUpper(sOptions)\n  call initParser sOptions /* <-- This is in PARSEXML rexx */\n\n  g.!VERSION = sVersion\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call setFileNames sFileIn,sFileOut\n  call setOptions sOptions\n  call Prolog\n\n  gDoc = createDocument('graphml')\n\n  call scanJobControlFile\n\n  if g.!OPTION.GRAPHML\n  then do\n    call buildGraphML\n    g.!YED_FRIENDLY = 1\n    call prettyPrinter g.!FILEGML\n  end\n\n  if g.!OPTION.DUMP\n  then call _displayTree\n\n  if g.!OPTION.XML\n  then do\n    call setDocType /* we don't need a doctype declaration */\n    call setPreserveWhitespace 1 /* retain spaces in JCL comments */\n    if g.!OPTION.LINE = 0                                /* 20070130 */\n    then call removeAttributes '_line',g.!JCL\n    if g.!OPTION.ID = 0                                  /* 20070130 */\n    then call removeAttributes '_id',g.!JCL\n    call rearrangeComments\n    g.!YED_FRIENDLY = 0\n    call prettyPrinter g.!FILEXML,,g.!JCL\n  end\n\n  if g.!OPTION.JCL\n  then do\n    call prettyJCL g.!FILEJCL,g.!JCL\n  end\n\n  call Epilog\n  say 'JCL002I Done'\nexit\n\n\n/* The JobControl input filename is supplied by the user.\nThe names of the XML and GRAPHML output files are automatically\ngenerated from the input file filename. The generated file names also\ndepend on the operating system. Global variables are set as follows:\ng.!FILETXT = name of input text file  (e.g. JobControl.txt)\ng.!FILEGML = name of output GraphML file  (e.g. JobControl.graphml)\ng.!FILEXML = name of output XML file  (e.g. JobControl.xml)\ng.!FILEJCL = name of output JCL file  (e.g. JobControl.jcl)\n*/\nsetFileNames: procedure expose g.\n  parse arg sFileIn,sFileOut\n  if sFileOut = '' then sFileOut = sFileIn\n  if g.!ENV = 'TSO'\n  then do\n    g.!FILETXT = toUpper(sFileIn)\n    parse var sFileOut sDataset'('sMember')'\n    if pos('(',sFileOut) > 0 /* if member name notation used */\n    then do /* output to members in the specified PDS */\n      if sMember = '' then sMember = 'JCL'\n      sPrefix = strip(left(sMember,7)) /* room for a suffix char */\n      sPrefix = toUpper(sPrefix)\n      /* squeeze the file extension into the member name...*/\n      g.!FILEGML = sDataset'('strip(left(sPrefix'GML',8))')'\n      g.!FILEXML = sDataset'('strip(left(sPrefix'XML',8))')'\n      g.!FILEJCL = sDataset'('strip(left(sPrefix'JCL',8))')'\n    end\n    else do /* make output files separate datasets */\n      g.!FILEGML = sDataset'.GRAPHML'\n      g.!FILEXML = sDataset'.XML'\n      g.!FILEJCL = sDataset'.JCL'\n    end\n  end\n  else do\n    sFileName  = getFilenameWithoutExtension(sFileOut)\n    g.!FILETXT = sFileIn\n    g.!FILEGML = sFileName'.graphml'\n    g.!FILEXML = sFileName'.xml'\n    g.!FILEJCL = sFileName'.jcl'\n  end\nreturn\n\ngetFilenameWithoutExtension: procedure expose g.\n  parse arg sFile\n  nLastDot = lastpos('.',sFile)\n  if nLastDot > 1\n  then sFileName = substr(sFile,1,nLastDot-1)\n  else sFileName = sFile\nreturn sFileName\n\ninitStack: procedure expose g.\n  g.!T = 0              /* set top of stack index */\nreturn\n\npushStack: procedure expose g.\n  parse arg item\n  tos = g.!T + 1        /* get new top of stack index */\n  g.!E.tos = item       /* set new top of stack item */\n  g.!T = tos            /* set new top of stack index */\nreturn\n\npopStack: procedure expose g.\n  tos = g.!T            /* get top of stack index for */\n  item = g.!E.tos       /* get item at top of stack */\n  g.!T = max(tos-1,1)\nreturn item\n\npeekStack: procedure expose g.\n  tos = g.!T            /* get top of stack index */\n  item = g.!E.tos       /* get item at top of stack */\nreturn item\n\n/*\nThe syntax of a single statement is like:\n\n//name  command   positionals,key=value,...     comment\n\nEach statement can continue over several lines by appending a comma\nand starting the continuation between columns 4 and 16:\n\n//name   command key=value,           comment\n//             key=value,             comment\n//             key=value              comment\n\n*/\nscanJobControlFile: procedure expose g.\n  call initStack /* stack of conditional jcl blocks */\n  g.!JCL = createDocumentFragment('jcl')\n  call setAttribute g.!JCL,'src',g.!FILETXT\n  call appendAuthor g.!JCL\n  g.!STMTID = 0 /* unique statement id */\n  parent = g.!JCL\n  call pushStack parent\n  g.!FILEIN = openFile(g.!FILETXT)\n  g.!JCLLINE = 0   /* current line number in the JCL */\n  g.!DELIM = '/*'  /* current end-of-data delimiter */\n  g.!JCLDATA.0 = 0    /* current number of lines of inline data */\n  g.!PENDING_STMT = ''\n  call getStatement /* returns data in g.!JCLxxxx variables */\n  if g.!OPTION.TRACE                                     /* 20070130 */\n  then say ' Stmt  Line Type Name     Op       Operands'\n  do nStmt = 1 while g.!RC = 0 & g.!JCLTYPE <> g.!JCLTYPE_EOJ\n    if g.!OPTION.TRACE then call sayTrace nStmt\n    select\n      when g.!JCLTYPE = g.!JCLTYPE_STATEMENT then do\n        stmt = newStatementNode()\n        select\n          when g.!JCLOPER = 'IF' then do\n            parent = popUntil('step if then else proc job')\n            if getNodeName(parent) = 'step'\n            then do\n              parent = popStack() /* discard 'step' */\n              parent = peekStack()\n            end\n            call appendChild stmt,parent\n            call pushStack stmt\n            thenNode = newPseudoStatementNode('then')\n            call appendchild thenNode,stmt\n            call pushStack thenNode\n          end\n          when g.!JCLOPER = 'ELSE' then do\n            parent = popUntil('if')\n            call appendChild stmt,parent\n            call pushStack stmt\n          end\n          when g.!JCLOPER = 'ENDIF' then do\n            parent = popUntil('if')\n            if g.!JCLNAME <> ''                          /* 20070130 */\n            then call setAttribute parent,'_endname',g.!JCLNAME\n            if g.!JCLCOMM <> ''                          /* 20070130 */\n            then call setAttribute parent,'_endcomm',g.!JCLCOMM\n            parent = popStack() /* discard 'if' */\n          end\n          when g.!JCLOPER = 'JOB' then do\n            parent = popUntil('jcl')\n            call appendChild stmt,parent\n            call pushStack stmt\n          end\n          when g.!JCLOPER = 'JCLLIB' then do\n            parent = popUntil('job')\n            call appendChild stmt,parent\n            parse var g.!JCLPARM 'ORDER='sOrder .\n            if left(sOrder,1) = '('\n            then parse var sOrder '('sOrder')'\n            sOrder = translate(sOrder,'',',')\n            g.!ORDER.0 = 0\n            do j = 1 to words(sOrder)\n              g.!ORDER.j = word(sOrder,j)\n              g.!ORDER.0 = j\n            end\n            /* TODO: Append system libraries somehow */\n            /* The JES2 search order for INCLUDE groups is:\n               1. // JCLLIB ORDER=(dsn,dsn...)\n               2. /@JOBPARM PROCLIB=ddname\n                  ...where ddname is in JES2 started task JCL.\n               3. JES2 initialisation parameters:\n                  JOBCLASS(v) PROCLIB=nn\n                  ...where PROCnn DD is in JES2 started task JCL.\n               4. PROC00 DD in JES2 started task JCL.\n            */\n          end\n          when g.!JCLOPER = 'INCLUDE' then do\n            /* TODO: Replace this with the actual included text */\n            parent = popUntil('step proc job')\n            call appendChild stmt,parent\n            call pushStack stmt\n          end\n          when g.!JCLOPER = 'PROC' then do\n            parent = peekStack()\n            call appendChild stmt,parent\n            call pushStack stmt\n          end\n          when g.!JCLOPER = 'PEND' then do\n            parent = popUntil('proc')\n            parent = popStack() /* discard 'proc' */\n          end\n          when g.!JCLOPER = 'CNTL' then do\n            parent = popUntil('step proc job')\n            call appendChild stmt,parent\n            call pushStack stmt\n          end\n          when g.!JCLOPER = 'ENDCNTL' then do\n            parent = popUntil('cntl')\n            parent = popStack() /* discard 'cntl' */\n          end\n          when g.!JCLOPER = 'EXEC' then do\n            parent = popUntil('proc job then else')\n            call appendChild stmt,parent\n            call pushStack stmt\n          end\n          when g.!JCLOPER = 'DD' then do\n            dd = stmt  /* used to append instream data later...*/\n            if getAttribute(stmt,'_name') = '' /* concatenated dd? */\n            then do\n              parent = peekStack()\n              call appendChild stmt,parent /* append to owning dd */\n            end\n            else do /* this is a named dd (i.e. not concatenated) */\n              parent = popUntil('cntl step proc job')\n              call appendChild stmt,parent\n              call pushStack stmt\n            end\n          end\n          when g.!JCLOPER = 'SET' then do\n            /* coalesce multiple 'SET' statements into a single one */\n            /* TODO: consider coalescing SET stmts after XML is built */\n            if sLastOper <> 'SET'\n            then do\n              parent = peekStack()\n              call appendChild stmt,parent\n              set = stmt\n            end\n            else do /* move 'var' nodes in this 'set' to the first */\n              vars = getChildNodes(stmt)\n              do j = 1 to words(vars)\n                var = word(vars,j)\n                varCopy = cloneNode(var)                 /* 20070128 */\n                call appendChild varCopy,set\n                call removeChild var\n              end\n              call appendChild stmt,parent /* kludge... */\n              call removeChild stmt /* ...to allow infanticide! */\n            end\n          end\n          otherwise do /* all other statements cannot be parents */\n            parent = peekStack()\n            call appendChild stmt,parent\n          end\n        end\n        sLastOper = g.!JCLOPER\n      end\n      when g.!JCLTYPE = g.!JCLTYPE_DATA then do\n        call appendChild getInlineDataNode(),dd\n        g.!JCLDATA.0 = 0                                 /* 20070124 */\n      end\n      when g.!JCLTYPE = g.!JCLTYPE_COMMENT then do\n        if nLastStatementType <> g.!JCLTYPE_COMMENT\n        then do /* group multiple comment lines together */\n          comment = newElement('comment','_line',g.!JCLLINE)\n          parent = popUntil('step proc job dd')\n          call appendChild comment,parent\n        end\n        call appendChild createTextNode(g.!JCLCOMM),comment\n      end\n      when g.!JCLTYPE = g.!JCLTYPE_JES2CMD then do\n        stmt = newStatementNode()\n        parent = peekStack()\n        call appendChild stmt,parent\n      end\n      when g.!JCLTYPE = g.!JCLTYPE_JES2STMT then do\n        stmt = newStatementNode()\n        parent = peekStack()\n        call appendChild stmt,parent\n      end\n      when g.!JCLTYPE = g.!JCLTYPE_JES3STMT then do\n        stmt = newStatementNode()\n        parent = peekStack()\n        call appendChild stmt,parent\n      end\n      when g.!JCLTYPE = g.!JCLTYPE_OPCDIR  then do      /* HF 061218 */\n        stmt = newStatementNode()\n        parent = peekStack()\n        call appendChild stmt,parent\n      end                                               /* HF 061218 */\n      when g.!JCLTYPE = g.!JCLTYPE_EOJ then nop\n      otherwise do /* should not occur (famous last words) */\n        say 'JCL003E Unknown statement on line' g.!JCLLINE':',\n            '\"'g.!JCLOPER g.!JCLPARM'\"'\n      end\n    end\n    nLastStatementType = g.!JCLTYPE\n    call getStatement\n  end\n  if g.!JCLDATA.0 > 0 /* dump any pending sysin before eof reached */\n  then do\n    call appendChild getInlineDataNode(),dd\n  end\n  rc = closeFile(g.!FILEIN)\n  say 'JCL004I Processed' g.!K-1 'JCL statements'\nreturn\n\nsayTrace: procedure expose g.\n  parse arg nStmt\n  select\n    when g.!JCLTYPE = g.!JCLTYPE_COMMENT then do\n      call sayTraceLine nStmt,g.!JCLLINE,g.!JCLCOMM\n    end\n    when g.!JCLTYPE = g.!JCLTYPE_DATA then do\n      nLine = g.!JCLLINE - g.!JCLDATA.0\n      do i = 1 to g.!JCLDATA.0\n        call sayTraceLine nStmt,nLine,g.!JCLDATA.i\n        nLine = nLine + 1\n      end\n    end\n    otherwise do\n      call sayTraceLine nStmt,g.!JCLLINE,,\n           left(g.!JCLNAME,8) left(g.!JCLOPER,8) g.!JCLPARM\n    end\n  end\nreturn\n\nsayTraceLine: procedure expose g.\n  parse arg nStmt,nLine,sData\n  nType = g.!JCLTYPE\n  sType = g.!JCLTYPE.nType\n  say left(right(nStmt,5) right(nLine,5) left(sType,4) sData,79)\nreturn\n\nappendAuthor: procedure expose g.\n  parse arg node\n  comment = createComment('Created by JCL to XML Converter' g.!VERSION)\n  call appendChild comment,node\n  comment = createComment('by Andrew J. Armstrong',\n                          '(andrew_armstrong@unwired.com.au)')\n  call appendChild comment,node\nreturn\n\nremoveAttributes: procedure expose g.\n  parse arg sAttrName,node\n  if isElementNode(node)\n  then call removeAttribute node,sAttrName\n  children = getChildNodes(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call removeAttributes sAttrName,child\n  end\nreturn\n\n/*\nUsually, comments precede a step in JCL. However, the XML built by\nthis scanner will associate comments with the previous step. The\nintention of the following routine is to move step comments to their\nrightful position - under that step's node. It's not foolproof though.\n*/\nrearrangeComments: procedure expose g.\n  steps = getElementsByTagName(g.!JCL,'step')\n  do i = 1 to words(steps)\n    step = word(steps,i)\n    prev = getPreviousSibling(step)\n    if prev <> ''\n    then do\n      if getNodeName(prev) = 'comment'\n      then call moveNode prev,step\n      else do\n        node = getLastElementDescendant(prev)\n        if node <> ''\n        then do\n          if getNodeName(node) = 'comment'\n          then call moveNode node,step\n        end\n      end\n    end\n  end\nreturn\n\ngetLastElementDescendant: procedure expose g.\n  parse arg node\n  child = getLastChild(node)\n  if isElementNode(child)\n  then decendant = getLastElementDescendant(child)\n  else decendant = node\nreturn decendant\n\nmoveNode: procedure expose g.\n  parse arg original,newParent\n  node = removeChild(original)\n  firstChild = getFirstChild(newParent)\n  if firstChild <> ''\n  then call insertBefore node,firstChild\n  else call appendChild node,newParent\nreturn\n\npopUntil: procedure expose g.\n  parse arg sNodeNames\n  node = peekStack()\n  do while wordpos(getNodeName(node),sNodeNames 'jcl') = 0\n    node = popStack()\n    node = peekStack()\n  end\nreturn node\n\n/*\nThe function of this routine is to return the next statement (by\naccumulating continuations if necessary). The statement is returned in\na set of global variables as follows:\ng.!JCLLINE   = the line number of the first card of the statement\ng.!JCLTYPE   = the type of statement as follows:\n               g.!JCLTYPE_UNKNOWN    - An unknown statement\n               g.!JCLTYPE_STATEMENT  - A JCL statement\n               g.!JCLTYPE_DATA       - Instream data (see below)\n               g.!JCLTYPE_COMMENT    - A comment card\n               g.!JCLTYPE_EOJ        - An end-of-job card\n               g.!JCLTYPE_JES2CMD    - A JES2 command\n               g.!JCLTYPE_JES2STMT   - A JES2 statement\n               g.!JCLTYPE_JES3STMT   - A JES3 statement\n               g.!JCLTYPE_OPCDIR     - An OPC directive\ng.!JCLNAME   = the statement name field (e.g. a dd name)\ng.!JCLOPER   = the statement operation field (e.g. DD)\ng.!JCLPARM   = the statement parameters (e.g. DISP=SHR etc)\ng.!JCLCOMM   = any comment following the statement, or the entire\n               comment text if this is a comment card\nOne or more instream data cards are treated as a single pseudo-statement\nwith g.!JCLTYPE set to g.!JCLTYPE_DATA and the cards returned in an\narray as follows:\ng.!JCLDATA.0 = the number of instream data cards\ng.!JCLDATA.n = instream data card 'n' (n = 1 to g.!JCLDATA.0)\n*/\ngetStatement: procedure expose g.\n  g.!JCLTYPE = g.!JCLTYPE_UNKNOWN\n  g.!JCLNAME = ''  /* Statement label     */\n  g.!JCLOPER = ''  /* Statement operation */\n  g.!JCLCOMM = ''  /* Statement comment   */\n  g.!RC      = 0                                        /* AF 061018 */\n  /* The following kludge handles the case where a JCL author\n     omits the end-of-data delimiter from inline data (instead the\n     next statement terminates the inline data). When this happens we\n     have already read the next statement, so we need to remember it\n     and process it the next time 'getStatement' is called.\n  */\n  if g.!PENDING_STMT <> ''\n  then do\n    sLine = g.!PENDING_STMT\n    g.!PENDING_STMT = ''\n  end\n  else sLine = getNextLine()\n  parse var sLine 1 s2 +2 1 s3 +3\n  select\n    when s2 = '/*' & substr(sLine,3,1) <> ' ' then do\n      if substr(sLine,3,1) = '$'\n      then do\n        parse var sLine '/*$'sJesCmd','sJesParms\n        g.!JCLTYPE = g.!JCLTYPE_JES2CMD\n        g.!JCLOPER = sJesCmd\n        g.!JCLPARM = sJesParms\n      end\n      else do\n        parse var sLine '/*'sJesStmt sJesParms\n        g.!JCLTYPE = g.!JCLTYPE_JES2STMT\n        g.!JCLOPER = sJesStmt\n        g.!JCLPARM = sJesParms\n      end\n    end\n    when s3 = '//*' then do                             /* HF 061218 */\n      /* This statement may be a comment or a JES3 command or an OPC */\n      /* directive or ......                                         */\n      /* So let's make the distinction here...                       */\n      sWord = substr(word(sLine,1),4)\n      select\n        when sWord = '%OPC' then do       /* OPC directive           */\n          parse var sLine '//*%OPC' sOpcStmt sOpcParms\n          g.!JCLTYPE = g.!JCLTYPE_OPCDIR\n          g.!JCLOPER = sOpcStmt\n          g.!JCLPARM = sOpcParms\n        end\n        when isJes3Statement(sWord) then do /* JES3 statement        */\n          parse var sLine '//*'sJesStmt sJesParms\n          g.!JCLTYPE = g.!JCLTYPE_JES3STMT\n          g.!JCLOPER = sJesStmt\n          g.!JCLPARM = sJesParms\n        end\n        otherwise do                      /* Comment                 */\n          g.!JCLTYPE = g.!JCLTYPE_COMMENT\n          g.!JCLCOMM = substr(sLine,4)\n        end\n      end\n    end                                                 /* HF 061218 */\n    when sLine = '//' then do\n      g.!JCLTYPE = g.!JCLTYPE_EOJ\n    end\n    when s2 = '//' then do\n      sName = ''\n      if substr(sLine,3,1) = ' '\n      then parse var sLine '//'      sOper sParms\n      else parse var sLine '//'sName sOper sParms\n      g.!JCLTYPE = g.!JCLTYPE_STATEMENT\n      g.!JCLNAME = sName\n      g.!JCLOPER = sOper\n      select                                             /* 20070130 */\n        when sOper = 'IF' then do\n          /* IF has its own continuation rules */\n          do while g.!RC = 0 & pos('THEN',sParms) = 0\n             sLine = getNextLine()\n             parse var sLine '//' sThenContinued\n             sParms = sParms strip(sThenContinued)\n          end\n          parse var sParms sParms 'THEN' sComment\n          g.!JCLPARM = strip(sParms)\n          g.!JCLCOMM = sComment                          /* 20070128 */\n        end\n        when sOper = 'ELSE' | sOper = 'ENDIF' then do    /* 20070130 */\n          g.!JCLPARM = ''\n          g.!JCLCOMM = strip(sParms)\n        end\n        otherwise do /* Slurp up any continuation cards */\n          /* This gets really ugly...\n             Lines are considered to be continued when they end in a\n             comma, or a comma followed by a comment, or if a quoted\n             string has not been terminated by another quote.\n             For exmample:\n             //STEP1 EXEC PGM=IEFBR14,\n             //           PARM='HI THERE'\n             OR\n             //STEP1 EXEC PGM=IEFBR14,    A COMMENT\n             //           PARM='HI THERE'\n             OR\n             //STEP1 EXEC PGM=IEFBR14,PARM='HI\n             //           THERE'          A COMMENT\n             Comment statements in a continuation are ignored:\n             //STEP1 EXEC PGM=IEFBR14,\n             //.A comment (star is shown as a dot to keep Rexx happy)\n             //           PARM='HI THERE'\n          */\n          g.!INSTRING = 0 /* for detecting continued quoted strings */\n          sParms = getNormalized(sParms)\n          parse var sParms sParms sComment\n          g.!JCLPARM = sParms\n          do while g.!RC = 0 & pos(right(sParms,1),'ff'x',') > 0\n            sLine = getNextLine()\n            do while g.!RC = 0 & left(sLine,3) = '//*'\n              sLine = getNextLine()\n            end\n            if g.!RC = 0\n            then do\n              parse var sLine '//'       sParms\n              sParms = getNormalized(sParms)\n              parse var sParms sParms sComment\n              g.!JCLPARM = g.!JCLPARM || sParms\n            end\n          end\n          if sOper = 'DD' & pos('DLM=',g.!JCLPARM) > 0\n          then parse var g.!JCLPARM 'DLM=' +4 g.!DELIM +2\n          g.!JCLCOMM = sComment                          /* 20070128 */\n        end\n      end\n    end\n    otherwise do\n      g.!JCLTYPE = g.!JCLTYPE_DATA\n      g.!JCLPARM = ''\n      n = 0\n      do while g.!RC = 0 & \\isEndOfData(s2)\n        n = n + 1\n        g.!JCLDATA.n = strip(sLine,'TRAILING')\n        sLine = getNextLine()\n        parse var sLine 1 s2 +2\n      end\n      if g.!DELIM = '/*' & s2 = '//' /* end-of-data marker omitted */\n      then g.!PENDING_STMT = sLine\n      g.!JCLDATA.0 = n\n      g.!DELIM = '/*'  /* reset EOD delimiter to the default */\n    end\n  end\n  g.!K = g.!K + 1\n  g.!KDELTA = g.!KDELTA + 1\n  if g.!KDELTA >= 100\n  then do\n    say 'JCL005I Processed' g.!K 'statements'\n    g.!KDELTA = 0\n  end\nreturn\n\nisJes3Statement: procedure expose g.\n  arg sStmt\n  sJes3Stmts = 'DATASET ENDDATASET ENDPROCESS FORMAT MAIN NET NETACCT',\n               'OPERATOR *PAUSE PROCESS ROUTE'\nreturn wordpos(sStmt,sJes3Stmts) > 0\n\n/* Replace blanks in quoted strings with 'ff'x so it is easier\n   to parse later. For example:\n             <---parameters----><----comments------>\n       this: ABC,('D E F','GH'),    'QUOTED COMMENT'\n    becomes: ABC,('D~E~F','GH'),    'QUOTED COMMENT'\n    Where '~' is a 'hard' blank ('ff'x)\n*/\ngetNormalized: procedure expose g.\n  parse arg sLine\n  sLine = strip(sLine,'LEADING')\n  sNormalized = ''\n  do i = 1 to length(sLine) until c = ' ' & \\g.!INSTRING\n    c = substr(sLine,i,1)\n    select\n      when c = \"'\" & g.!INSTRING then g.!INSTRING = 0\n      when c = \"'\" then g.!INSTRING = 1\n      when c = ' ' & g.!INSTRING then c = 'ff'x\n      otherwise nop\n    end\n    sNormalized = sNormalized || c\n  end\n  if i <= length(sLine)\n  then do\n    if g.!INSTRING /* make trailing blanks 'hard' blanks */\n    then sNormalized = sNormalized ||,\n                       translate(substr(sLine,i),'ff'x,' ')\n    else sNormalized = sNormalized || substr(sLine,i)\n  end\nreturn strip(sNormalized)\n\nisEndOfData: procedure expose g.\n  parse arg s2\n  bEOD =  g.!DELIM = s2,\n       | (g.!DELIM = '/*' & s2 = '//')\nreturn bEOD\n\ngetInlineDataNode: procedure expose g.\n  sLines = ''\n  do n = 1 to g.!JCLDATA.0\n    sLines = sLines || g.!JCLDATA.n || g.!LF\n  end\nreturn createCDATASection(sLines)\n\nnewPseudoStatementNode: procedure expose g.\n  parse arg sName\n  g.!STMTID = g.!STMTID + 1\n  stmt = newElement(sName,'_id',g.!STMTID)\nreturn stmt\n\n/*\n  This is a helper routine that creates a named element and\n  optionally sets one or more attributes on it. Note Rexx only allows\n  up to 20 arguments to be passed.\n*/\nnewElement: procedure expose g.\n  parse arg sName /* attrname,attrvalue,attrname,attrvalue,... */\n  id = createElement(sName)\n  do i = 2 to arg() by 2\n    call setAttribute id,arg(i),arg(i+1)\n  end\nreturn id\n\nnewStatementNode: procedure expose g.\n  g.!STMTID = g.!STMTID + 1\n  select\n    when g.!JCLTYPE = g.!JCLTYPE_JES2CMD then do\n      stmt = newElement('jes2cmd',,\n                        '_id',g.!STMTID,,\n                        '_line',g.!JCLLINE,,\n                        'cmd',g.!JCLOPER,,\n                        'parm',strip(g.!JCLPARM))\n      return stmt\n    end\n    when g.!JCLTYPE = g.!JCLTYPE_JES2STMT then do\n      stmt = newElement('jes2stmt',,\n                       '_id',g.!STMTID,,\n                        '_line',g.!JCLLINE,,\n                       'stmt',g.!JCLOPER)\n      call getParmMap g.!JCLPARM\n      call setParms stmt\n      return stmt\n    end\n    when g.!JCLTYPE = g.!JCLTYPE_JES3STMT then do\n      stmt = newElement('jes3stmt',,\n                       '_id',g.!STMTID,,\n                        '_line',g.!JCLLINE,,\n                       'stmt',g.!JCLOPER)\n      call getParmMap g.!JCLPARM\n      call setParms stmt\n      return stmt\n    end\n    when g.!JCLTYPE = g.!JCLTYPE_OPCDIR  then do        /* HF 061218 */\n      stmt = newElement('opcdir',,\n                       '_id',g.!STMTID,,\n                        '_line',g.!JCLLINE,,             /* 20070214 */\n                        'cmd',g.!JCLOPER,,\n                        'parm',strip(g.!JCLPARM))\n      return stmt\n    end                                                 /* HF 061218 */\n    otherwise nop\n  end\n  if g.!JCLOPER = 'EXEC'\n  then stmt = newElement('step')\n  else stmt = newElement(toLower(g.!JCLOPER))\n  call setAttributes stmt,'_id',g.!STMTID,,\n                        '_line',g.!JCLLINE\n  if g.!JCLNAME <> ''\n  then call setAttribute stmt,'_name',g.!JCLNAME\n  if g.!JCLCOMM <> ''                                    /* 20070128 */\n  then call setAttribute stmt,'_comment',strip(g.!JCLCOMM)\n\n  call getParmMap g.!JCLPARM\n  sNodeName = getNodeName(stmt)\n  select\n    when sNodeName = 'if' then do\n      call setAttributes stmt,'cond',space(g.!JCLPARM)\n    end\n    when sNodeName = 'set' then do\n      /* //name  SET   var=value[,var=value]... comment */\n      do i = 1 to g.!PARM.0\n        sKey = translate(g.!PARM.i)\n        var = newElement('var','name',sKey,,\n                               'value',getParm(g.!PARM.i),,\n                               '_line',g.!JCLLINE)\n        call appendChild var,stmt\n      end\n      /* apply any comment to the last variable */\n      if g.!JCLCOMM <> ''\n      then call setAttribute var,'_comment',strip(g.!JCLCOMM)\n    end\n    when sNodeName = 'step' then do\n      bPgm     = 0\n      bProc    = 0\n      do i = 1 to g.!PARM.0\n        bPgm  = bPgm  | g.!PARM.i = 'pgm'\n        bProc = bProc | g.!PARM.i = 'proc'\n      end\n      if \\bPgm & \\bProc\n      then do\n        sKey = '_' /* the name for positional parameters */\n        sPositionals = g.!PARM.sKey\n        sKey = 'proc'\n        g.!PARM.1 = sKey\n        g.!PARM.sKey = sPositionals\n      end\n      do i = 1 to g.!PARM.0\n        sKey   = g.!PARM.i\n        call setAttribute stmt,sKey,getParm(sKey)\n      end\n    end\n    when sNodeName = 'job' then do\n      do i = 1 to g.!PARM.0\n        sKey   = g.!PARM.i\n        if sKey = '_'\n        then do /* [(acct,info)][,programmer] */\n                /* [acct][,programmer] */\n          sPositionals = g.!PARM.sKey\n          if left(sPositionals,1) = '('\n          then parse var sPositionals '('sAcctAndInfo'),'sProg\n          else parse var sPositionals sAcctAndInfo','sProg\n          parse var sAcctAndInfo sAcct','sInfo\n          call setAttributes stmt,'acct',deQuote(sAcct),,\n                                  'acctinfo',deQuote(sInfo),,\n                                  'pgmr',deQuote(sProg)\n        end\n        else do\n          call setAttribute stmt,sKey,getParm(sKey)\n        end\n      end\n    end\n    otherwise call setParms stmt\n  end\nreturn stmt\n\nsetParms: procedure expose g.\n  parse arg stmt\n  do i = 1 to g.!PARM.0\n    sKey = g.!PARM.i\n    call setAttribute stmt,sKey,getParm(sKey)\n  end\nreturn\n\ngetParm: procedure expose g.\n  parse arg sKey\nreturn deQuote(g.!PARM.sKey)\n\ndeQuote: procedure expose g.\n  parse arg sValue\nreturn translate(sValue,' ','ff'x)\n\n  /*\n  if left(sValue,1) = \"'\"  /- 'abc' --> abc -/\n  then sValue = substr(sValue,2,length(sValue)-2)\n  */\n  n = pos(\"''\",sValue)\n  do while n > 0\n    sValue = delstr(sValue,n,1)  /* '' --> ' */\n    n = pos(\"''\",sValue)\n  end\nreturn translate(sValue,' ','ff'x)\n\n/*\n  Parameters consist of positional keywords followed by key=value\n  pairs. Values can be bracketed or quoted. For example:\n    <---------------parms--------------->\n    A,(B,C),'D E,F',G=H,I=(J,K),L='M,N O'\n    <--positional--><------keywords----->\n  This routine parses parameters into stem variables as follows:\n  g.!PARM.0 = number of parameters\n  g.!PARM.n = key for parameter n\n  g.!PARM.key = value for parameter called 'key'\n  ...where n = 1 to the number of parameters.\n  A special parameter key called '_' is used for positionals.\n  Using the above example:\n  g.!PARM.0 = 4\n  g.!PARM.1 = '_'; g.!PARM._ = \"A,(B,C),'D E,F'\"\n  g.!PARM.2 = 'G'; g.!PARM.G = 'H'\n  g.!PARM.3 = 'I'; g.!PARM.I = '(J,K)'\n  g.!PARM.4 = 'L'; g.!PARM.L = \"'M,N O'\"\n*/\ngetParmMap: procedure expose g.\n  parse arg sParms\n  sParms = strip(sParms)\n  nParm = 0\n  nComma  = pos(',',sParms)\n  nEquals = pos('=',sParms)\n  /* Process the positional operands */\n  select\n    when nComma = 0 & nEquals = 0 & sParms <> '' then do\n      nParm = nParm + 1\n      sKey = '_'\n      g.!PARM.nParm = sKey\n      g.!PARM.sKey = sParms\n      sParms = ''\n    end\n    when nComma > 0 & nComma < nEquals then do\n      nPos = lastpos(',',sParms,nEquals)\n      sPositionals = left(sParms,nPos-1)\n      nParm = nParm + 1\n      sKey = '_'\n      g.!PARM.nParm = sKey\n      g.!PARM.sKey = sPositionals\n      sParms = substr(sParms,nPos+1)\n    end\n    otherwise nop\n  end\n  /* Process the keyword=value operands */\n  do while sParms <> ''\n    parse var sParms sKey'='sValue\n    sKey = toLower(sKey)\n    select\n      when left(sValue,1) = '(' then do /* K=(...) */\n        nValue = getInBracketsLength(sValue)\n        parse var sValue sValue +(nValue)','sParms\n      end\n      when left(sValue,1) = \"'\" then do /* K='...' */\n        nValue = getInQuotesLength(sValue)\n        if nValue = 2\n        then do    /* K='',... */\n          sParms = substr(sValue,4)\n          sValue = ''\n        end\n        else do    /* K='V',... */\n          parse var sValue sValue +(nValue)','sParms\n        end\n      end\n      otherwise do /* K=V         */\n                   /* K=S=(...)   */\n                   /* K=S='...'   */\n                   /* K=S=X       */\n        sSymbol = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$'\n        nSymbol = verify(sValue,sSymbol,'NOMATCH')\n        if nSymbol > 0\n        then do\n          c = substr(sValue,nSymbol,1)\n          if c = '='\n          then do /* K=S=...*/\n            parse var sValue sSubKey'='sParms\n            select\n              when left(sParms,1) = '(' then do /* S=(...) */\n                nSubValue = getInBracketsLength(sParms)\n                parse var sParms sSubValue +(nSubValue)','sParms\n              end\n              when left(sParms,1) = \"'\" then do /* S='...' */\n                nSubValue = getInQuotesLength(sParms)\n                if nSubValue = 2\n                then do  /* K=S='',... */\n                  sParms = substr(sParms,4)\n                  sSubValue = ''\n                end\n                else do  /* K=S='V',... */\n                  parse var sParms sSubValue +(nSubValue)','sParms\n                end\n              end\n              otherwise do                      /* S=... */\n                parse var sParms sSubValue','sParms\n              end\n            end\n            sValue = sSubKey'='sSubValue\n          end\n          else do /* K=V,... */\n            parse var sValue sValue','sParms\n          end\n        end\n        else parse var sValue sValue','sParms\n      end\n    end\n    nParm = nParm + 1\n    g.!PARM.nParm = sKey\n    g.!PARM.sKey = sValue\n  end\n  g.!PARM.0 = nParm\nreturn\n\n/* (abc) --> 5 */\ngetInBracketsLength: procedure expose g.\n  parse arg sValue\n  nLvl = 0\n  do i = 1 to length(sValue) until nLvl = 0\n    c = substr(sValue,i,1)\n    select\n      when c = '(' then nLvl = nLvl + 1\n      when c = ')' then nLvl = nLvl - 1\n      otherwise nop\n    end\n  end\nreturn i\n\n/* 'abc' --> 5 */\ngetInQuotesLength: procedure expose g.\n  parse arg sValue\n  bEndOfString = 0\n  do i = 2 to length(sValue) until bEndOfString\n    if substr(sValue,i,2) = \"''\"\n    then i = i + 1 /* Skip over '' */\n    else bEndOfString = substr(sValue,i,1) = \"'\"\n  end\nreturn i\n\ntoLower: procedure expose g.\n  parse arg sText\nreturn translate(sText,g.!LOWER,g.!UPPER)\n\ntoUpper: procedure expose g.\n  parse upper arg sText\nreturn sText\n\ngetNextLine: procedure expose g.\n  sLine = left(getLine(g.!FILEIN),71)\n  g.!JCLLINE = g.!JCLLINE + 1\nreturn sLine\n\n\n/*\nWe have two XML trees in memory, one for the XML representation of the\ninput JCL, and one for the GraphML representation.To distinguish them\neasily, a Rexx variable naming convention is used. A 'g' prefix, for\nexample 'gStep', indicates that the node belongs to the GraphML tree.\nNode names with no prefix, for example 'step', belong to the JCL tree.\n*/\nbuildGraphML: procedure expose g.\n  gDoc = getDocumentElement() /* created earlier by createDocument() */\n  call setAttributes gDoc,,\n       'xmlns','http://graphml.graphdrawing.org/xmlns/graphml',,\n       'xmlns:xsi','http://www.w3.org/2001/XMLSchema-instance',,\n       'xmlns:schemalocation',,\n          'http://graphml.graphdrawing.org/xmlns/1.0rc/graphml.xsd',\n          'http://www.yworks.com/xml/schema/graphml/1.0/ygraphml.xsd',,\n       'xmlns:y','http://www.yworks.com/xml/graphml'\n\n  call appendAuthor gDoc\n\n  gKey = newElement('key',,\n                   'id','d0',,\n                   'for','node',,\n                   'yfiles.type','nodegraphics')\n  call appendChild gKey,gDoc\n  gKey = newElement('key',,\n                   'id','d1',,\n                   'for','edge',,\n                   'yfiles.type','edgegraphics')\n  call appendChild gKey,gDoc\n\n  g.!GRAPH = newElement('graph',,\n                     'id','G',,\n                      'edgedefault','directed')\n\n  call appendChild g.!GRAPH,gDoc\n\n  call drawBlock g.!JCL\n\n  call removeEndIfNodes\nreturn\n\ndrawBlock: procedure expose g.\n  parse arg node\n  gFirstNode = ''\n  gLastNode= ''\n  children = getChildNodes(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    sChild = getNodeName(child)\n    select\n      when sChild = 'job' then do\n        gJob = newJobNode(child)\n        sNodes = drawBlock(child)\n        parse var sNodes gFirstChild','gLastChild\n        gEoj = newEndOfJobNode()\n        call newArrow gJob,gFirstChild,,newControlFlowLine()\n        call newArrow gLastChild,gEoj,,newControlFlowLine()\n      end\n      when sChild = 'proc' then do\n        gProc = newProcNode(child)\n        sNodes = drawBlock(child)\n        parse var sNodes gFirstChild','gLastChild\n        gPend = newEndOfProcNode()\n        call newArrow gProc,gFirstChild,,newControlFlowLine()\n        call newArrow gLastChild,gPend,,newControlFlowLine()\n      end\n      when sChild = 'step' then do\n        gStep = newStepNode(child)\n        if gFirstNode = ''\n        then gFirstNode = gStep\n        else do\n          sCond = getAttribute(child,'cond')\n          if sCond <> ''\n          then sLabel = 'COND='sCond\n          else sLabel = ''\n          call newArrow gLastNode,gStep,sLabel,newControlFlowLine()\n        end\n        gLastNode = gStep\n      end\n      when sChild = 'if' then do\n        gIf = newDecisionNode(child)\n        gEndIf = newEndIfNode() /* note: will be removed later */\n        if gFirstNode = ''\n        then gFirstNode = gIf\n        else call newArrow gLastNode,gIf,,newControlFlowLine()\n        thenNode = getChildrenByName(child,'then')\n        sNodes = drawBlock(thenNode)\n        parse var sNodes gFirstInThen','gLastInThen\n        call newArrow gIf,gFirstInThen,'TRUE',newControlFlowLine()\n        call newArrow gLastInThen,gEndIf,,newControlFlowLine()\n        elseNode = getChildrenByName(child,'else')\n        if elseNode <> ''\n        then do\n          sNodes = drawBlock(elseNode)\n          parse var sNodes gFirstInElse','gLastInElse\n          call newArrow gIf,gFirstInElse,'FALSE',newControlFlowLine()\n          call newArrow gLastInElse,gEndIf,,newControlFlowLine()\n        end\n        else call newArrow gIf,gEndIf,'FALSE',newControlFlowLine()\n        gLastNode = gEndIf\n      end\n      when sChild = 'set' then do\n        gSet = newSetNode(child)\n        if gFirstNode = ''\n        then gFirstNode = gSet\n        else call newArrow gLastNode,gSet,,newControlFlowLine()\n        gLastNode = gSet\n      end\n      when sChild = 'include' then do\n        gInclude = newIncludeNode(child)\n        if gFirstNode = ''\n        then gFirstNode = gInclude\n        else call newArrow gLastNode,gInclude,,newControlFlowLine()\n        gLastNode = gInclude\n      end\n      otherwise nop\n    end\n  end\nreturn gFirstNode','gLastNode\n\n/* Remove all the endif placeholder nodes. That is,\n             this:                      becomes:\n\n      .------[IF]------.          .------[IF]------.\n      |                |          |                |\n      | false          | true     | false          | true\n      |             [STEP]        |             [STEP]\n      |                |          |                |\n      |             [STEP]        |             [STEP]\n      |                |          |                |\n      '------. .-------'          '------. .-------'\n             | |                         | |\n             V V                         | |\n           [ENDIF]                       | |\n              |                          | |\n              V                          V V\n            [STEP]                      [STEP]\n*/\nremoveEndIfNodes: procedure expose g.\n  gDeadNodes = ''\n  gNodes = getElementsByTagName(g.!GRAPH,'node')\n  gEdges = getElementsByTagName(g.!GRAPH,'edge')\n  do i = 1 to words(gNodes)\n    gEndIf = word(gNodes,i)\n    if \\hasChildren(gEndIf)\n    then do /* This is an endif placeholder node */\n      /* Find the node that the endif node points to */\n      sEndIfId = getAttribute(gEndIf,'id')\n      do j = 1 to words(gEdges) until sArrowSourceId = sEndIfId\n        gArrowFromEndIf = word(gEdges,j)\n        sArrowSourceId = getAttribute(gArrowFromEndIf,'source')\n      end\n      sEndifTargetId = getAttribute(gArrowFromEndIf,'target')\n      /* Find all arrows pointing to the endif node and\n         change them to point to the node that the endif points to */\n      do j = 1 to words(gEdges)\n        gArrow = word(gEdges,j)\n        sArrowTargetId   = getAttribute(gArrow,'target')\n        if sArrowTargetId = sEndIfId\n        then call setAttribute gArrow,'target',sEndifTargetId\n      end\n      /* Schedule the endif node and its arrow for removal later */\n      gDeadNodes = gDeadNodes gEndIf gArrowFromEndIf\n    end\n  end\n  /* Finally, remove all the endif nodes and associated arrows */\n  do i = 1 to words(gDeadNodes)\n    gDeadNode = word(gDeadNodes,i)\n    call removeChild gDeadNode\n  end\nreturn\n\nnewEndIfNode: procedure expose g.\n  g.!STMTID = g.!STMTID + 1\n  gEndIf = newElement('node','id','n'g.!STMTID)\n  call appendChild gEndIf,g.!GRAPH\nreturn gEndIf\n\nnewControlFlowLine: procedure expose g.\n  gLineStyle = newElement('y:LineStyle',,\n                          'type','line',,\n                          'width',3,,\n                          'color',g.!COLOR_CONTROL_FLOW)\nreturn gLineStyle\n\nnewJobNode: procedure expose g.\n  parse arg job\n  sLabel = 'JOB' || g.!LF || getAttribute(job,'_name')\n  gGeometry = newElement('y:Geometry','width',70,'height',70)\n  gFill = newElement('y:Fill','color',g.!COLOR_JOB_NODE)\n  gNodeLabel = newElement('y:NodeLabel')\n  call appendChild createCDataSection(sLabel),gNodeLabel\n  gJob = newShapeNode(job,,'octagon',gFill,gGeometry,gNodeLabel)\n  dds = getChildrenByName(job,'dd')\n  do i = 1 to words(dds)\n    dd = word(dds,i)\n    sDDName = getAttribute(dd,'_name')\n    sDSN    = getAttribute(dd,'dsn')\n    if sDDName <> ''\n    then do\n      gDD = newFileNode(dd)\n      g.!DSN.sDSN = gDD\n      sDDName = getAttribute(dd,'_name')\n      call newArrow gDD,gJob,sDDName\n    end\n  end\n  jcllib = getChildrenByName(job,'jcllib')\n  if jcllib <> ''\n  then do\n    gJclLib = newJclLibNode(jcllib)\n    call newArrow gJclLib,gJob,'JCLLIB'\n  end\nreturn gJob\n\nnewEndOfJobNode: procedure expose g.\n  gGeometry = newElement('y:Geometry','width',70,'height',70)\n  gFill = newElement('y:Fill','color',g.!COLOR_EOJ_NODE)\n  gNodeLabel = newElement('y:NodeLabel',,\n                          'fontSize',14,,\n                          'textColor',g.!COLOR_WHITE)\n  call appendChild createTextNode('EOJ'),gNodeLabel\n  eoj = newPseudoStatementNode('eoj')\n  gEndOfJob = newShapeNode(eoj,,'octagon',gFill,gGeometry,gNodeLabel)\nreturn gEndOfJob\n\nnewProcNode: procedure expose g.\n  parse arg proc\n  sLabel = 'PROC' || g.!LF || getAttribute(proc,'_name')\n  gGeometry = newElement('y:Geometry','width',100,'height',34)\n  gFill = newElement('y:Fill','color',g.!COLOR_PROC_NODE)\n  gNodeLabel = newElement('y:NodeLabel')\n  call appendChild createCDataSection(sLabel),gNodeLabel\n  gProc = newShapeNode(proc,,'roundrectangle',,\n                             gFill,gGeometry,gNodeLabel)\n  gParms = newParmsNode(proc)\n  if gParms <> ''\n  then call newDottedArrow gParms,gProc\nreturn gProc\n\nnewParmsNode: procedure expose g.\n  parse arg step,sIgnoredParms\n  call getAttributeMap step\n  sLabel = ''\n  do i = 1 to g.!ATTRIBUTE.0\n    sKey = g.!ATTRIBUTE.i\n    if wordpos(sKey,'_id _name _line _comment' sIgnoredParms) = 0\n    then do\n      sVal = g.!ATTRIBUTE.sKey\n      sLabel = sLabel || g.!LF || toUpper(sKey)'='sVal\n    end\n  end\n  if sLabel = '' then return '' /* no parms worth mentioning */\n  sLabel = strip(sLabel,'LEADING',g.!LF)\n  parms = newPseudoStatementNode('parms')\n  gBorderStyle = newElement('y:BorderStyle','type','dashed')\n  gFill = newElement('y:Fill','color',g.!COLOR_PARMS_NODE)\n  gNode = newShapeNode(parms,sLabel,'roundrectangle',,\n                      gBorderStyle,gFill)\nreturn gNode\n\nnewEndOfProcNode: procedure expose g.\n  gGeometry = newElement('y:Geometry','width',100,'height',34)\n  gFill = newElement('y:Fill','color',g.!COLOR_PEND_NODE)\n  gNodeLabel = newElement('y:NodeLabel')\n  call appendChild createTextNode('PEND'),gNodeLabel\n  pend = newPseudoStatementNode('pend')\n  gPend = newShapeNode(pend,,'roundrectangle',,\n                             gFill,gGeometry,gNodeLabel)\nreturn gPend\n\nnewDecisionNode: procedure expose g.\n  parse arg id\n  sLabel = getAttribute(id,'cond')\n  gNodeLabel = newElement('y:NodeLabel')\n  call appendChild createTextNode(sLabel),gNodeLabel\n  gFill = newElement('y:Fill','color',g.!COLOR_IF_NODE)\n  gGeometry = newElement('y:Geometry','width',130,'height',80)\n  gDecision = newShapeNode(id,slabel,'diamond',,\n                          gFill,gGeometry,gNodeLabel)\nreturn gDecision\n\n/* Create a new STEP node linked to all its DD nodes */\nnewStepNode: procedure expose g.\n  parse arg step\n  sStepName = getAttribute(step,'_name')\n  sPgm = getAttribute(step,'pgm')\n  if sPgm <> ''\n  then sLabel = sStepName 'PGM='sPgm\n  else sLabel = sStepName 'PROC='getAttribute(step,'proc')\n  gFill = newElement('y:Fill','color',g.!COLOR_STEP_NODE)\n  gGeometry = newTextGeometry(22,2)\n  gNodeLabel = newElement('y:NodeLabel')\n  call appendChild createTextNode(sLabel),gNodeLabel\n  gStep = newShapeNode(step,,'roundrectangle',,\n                       gFill,gGeometry,gNodeLabel)\n  /* Draw any input parameters */\n  gParms = newParmsNode(step,'pgm proc cond')\n  if gParms <> '' then call newDottedArrow gParms,gStep\n  /* Draw any INCLUDE statements */\n  /* TODO: Replace this by actually including the member contents */\n  includes = getChildrenByName(step,'include')\n  do i = 1 to words(includes)\n    include = word(includes,i)\n    gInclude = newIncludeNode(include)\n    call newDottedArrow gInclude,gStep\n  end\n  /* Draw any DD statements */\n  dds = getChildrenByName(step,'dd')\n  do i = 1 to words(dds)\n    dd = word(dds,i)\n    sDDName = getAttribute(dd,'_name')\n    if sDDName <> ''\n    then do\n      select\n        when isPrintFile(dd) then do\n          if g.!OPTION.SYSOUT\n          then do\n            gDD = newPrinterNode(dd)\n            call newArrow gStep,gDD,sDDName\n          end\n        end\n        when isInternalReaderFile(dd) then do\n          gDD = newInternalReaderNode(dd)\n          call newArrow gStep,gDD,sDDName\n        end\n        when isInlineFile(dd) then do\n          if g.!OPTION.INLINE\n          then do\n            gDD = newInlineNode(dd)\n            call newArrow gDD,gStep,sDDName\n          end\n        end\n        when isDummyFile(dd) then do\n          if g.!OPTION.DUMMY\n          then do\n            gDD = newDummyNode(dd)\n            call newLine gDD,gStep,sDDName\n          end\n        end\n        when isConcatenatedFile(dd) then do\n          gDD = newFileNode(dd)\n          call newArrow gDD,gStep,sDDName\n        end\n        when getAttribute(dd,'dsn') = '' then nop\n        when isInputFile(dd) then do\n          gDD = getFileNode(dd)\n          call newArrow gDD,gStep,sDDName\n        end\n        when isOutputFile(dd) then do\n          gDD = getFileNode(dd)\n          call newArrow gStep,gDD,sDDName\n        end\n        otherwise do /* assume it is both input and output */\n          gDD = getFileNode(dd)\n          call newDoubleArrow gDD,gStep,sDDName\n        end\n      end\n    end\n  end\nreturn gStep\n\nnewShapeNode: procedure expose g.\n  parse arg node,sLabel,sShape\n  gShapeNode = newElement('y:ShapeNode')\n  if sShape <> '' /* if not the default rectangle...*/\n  then call appendChild newElement('y:Shape','type',sShape),gShapeNode\n  sPropertiesAlreadySet = ''\n  do i = 4 to arg()\n    sPropertiesAlreadySet = sPropertiesAlreadySet getNodeName(arg(i))\n    call appendChild arg(i),gShapeNode\n  end\n  sId = getAttribute(node,'_id')\n  gNode = newElement('node','id','n'sId)\n  gData = newElement('data','key','d0')\n  call appendChild gData,gNode\n  call appendChild gShapeNode,gData\n  if wordpos('y:Geometry',sPropertiesAlreadySet) = 0\n  then do\n    parse value getLabelDimension(sLabel) with nChars','nLines\n    call appendChild newTextGeometry(nChars,nLines),gShapeNode\n  end\n  if wordpos('y:NodeLabel',sPropertiesAlreadySet) = 0\n  then do\n    gNodeLabel = newElement('y:NodeLabel',,\n                       'alignment','left',,\n                       'modelPosition','l',,\n                       'fontFamily','Monospaced')\n    if pos(g.!LF,sLabel) > 0\n    then gText = createCDataSection(sLabel)\n    else gText = createTextNode(sLabel)\n    call appendChild gText,gNodeLabel\n    call appendChild gNodeLabel,gShapeNode\n  end\n  if wordpos('y:DropShadow',sPropertiesAlreadySet) = 0\n  then do\n    gDropShadow = newElement('y:DropShadow',,\n                             'offsetX',4,'offsetY',4,,\n                             'color',g.!COLOR_DROP_SHADOW)\n    call appendChild gDropShadow,gShapeNode\n  end\n  if wordpos('y:Fill',sPropertiesAlreadySet) = 0\n  then do\n    gFill = newElement('y:Fill','color',g.!COLOR_SHAPE_NODE)\n    call appendChild gFill,gShapeNode\n  end\n  call appendChild gNode,g.!GRAPH\nreturn gNode\n\ngetFileNode: procedure expose g.\n  parse arg dd\n  sDSN = getAttribute(dd,'dsn')\n  if g.!DSN.sDSN = '' /* if file is not already in graph */\n  then do /* create a new file node and add it to the graph */\n    gDD = newFileNode(dd)\n    g.!DSN.sDSN = gDD\n  end\n  else do /* use existing file node in graph */\n    gDD = g.!DSN.sDSN\n  end\nreturn gDD\n\nisTempFile: procedure expose g.\n  parse arg dd\n  sDSN = getAttribute(dd,'dsn')\nreturn left(sDSN,2) = '&&'\n\nisPrintFile: procedure expose g.\n  parse arg dd\n  sSysout = getAttribute(dd,'sysout')\nreturn sSysout <> '' & pos('INTRDR',sSysout) = 0\n\nisInternalReaderFile: procedure expose g.\n  parse arg dd\n  sSysout = getAttribute(dd,'sysout')\nreturn pos('INTRDR',sSysout) <> 0\n\nisInlineFile: procedure expose g.\n  parse arg dd\n  sPositionals = getAttribute(dd,'_')\nreturn sPositionals = '*' | sPositionals = 'DATA'\n\nisDummyFile: procedure expose g.\n  parse arg dd\n  sPositionals = getAttribute(dd,'_')\nreturn sPositionals = 'DUMMY'\n\nisConcatenatedFile: procedure expose g.\n  parse arg dd\n  dds = getChildrenByName(dd,'dd')\nreturn dds <> ''\n\nisInputFile: procedure expose g.\n  parse arg dd\n  sStatus = getDispStatus(getAttribute(dd,'disp'))\n  bSysout = hasAttribute(dd,'sysout')\nreturn \\bSysout & (wordpos(sStatus,'OLD SHR') > 0 | isInlineFile(dd))\n\nisOutputFile: procedure expose g.\n  parse arg dd\n  sStatus = getDispStatus(getAttribute(dd,'disp'))\n  bSysout = hasAttribute(dd,'sysout')\nreturn bSysout | wordpos(sStatus,'NEW MOD') > 0\n\ngetDispStatus: procedure expose g.\n  parse arg sDisp\n  if left(sDisp,1) = '('\n  then parse var sDisp '('sStatus','sNormal','sAbnormal')'\n  else sStatus = sDisp\n  if sStatus = '' then sStatus = 'NEW'\nreturn sStatus\n\nnewFileNode: procedure expose g.\n  parse arg dd\n  sLabel = getAttribute(dd,'dsn')\n  /* Get any concatenated dataset names too */\n  dds = getChildrenByName(dd,'dd')\n  if dds <> '' then sLabel = '+0' sLabel\n  do i = 1 to words(dds)\n    concatdd = word(dds,i)\n    sDataset = getAttribute(concatdd,'dsn')\n    if sDataset = '' then sDataset = '(in stream)'\n    sLabel = sLabel || g.!LF || '+'i sDataset\n  end\n  gNode = newShapeNode(dd,sLabel)\nreturn gNode\n\nnewPrinterNode: procedure expose g.\n  parse arg dd\n  sLabel = 'SYSOUT='getAttribute(dd,'sysout')\n  gNode = newImageNode(dd,sLabel,'paper.png')\nreturn gNode\n\nnewInternalReaderNode: procedure expose g.\n  parse arg dd\n  sLabel = 'SYSOUT='getAttribute(dd,'sysout')\n  gGeometry = newPixelGeometry(70,34)\n  gNode = newImageNode(dd,sLabel,'card.png',gGeometry)\nreturn gNode\n\n/*                                                             20070119\n The children of an inline dd node are zero or more CDATA nodes (one\n for each card of inline data) with an implied linefeed between each.\n*/\nnewInlineNode: procedure expose g.\n  parse arg dd\n  sLabel = ''\n  line = getFirstChild(dd)\n  do while line <> ''\n    sLabel = sLabel || g.!LF || getText(line) /* CDATA text */\n    line = getNextSibling(line)\n  end\n  sLabel = strip(sLabel,'LEADING',g.!LF)\n  parse value getLabelDimension(sLabel) with nChars','nLines\n  gGeometry = newTextGeometry(nChars,nLines)\n  gFill = newElement('y:Fill','color',g.!COLOR_INLINE_NODE)\n  gNode = newShapeNode(dd,sLabel,,gGeometry,gFill)\nreturn gNode\n\nnewDummyNode: procedure expose g.\n  parse arg dd\n  sLabel = 'DUMMY'\n  gNode = newShapeNode(dd,sLabel)\nreturn gNode\n\nnewJCLLibNode: procedure expose g.\n  parse arg jcllib\n  sOrder = getAttribute(jcllib,'order')\n  if left(sOrder,1) = '('\n  then parse var sOrder '('sOrder')'\n  sLabel = translate(sOrder,g.!LF,',')\n  gBorderStyle = newElement('y:BorderStyle','type','dashed')\n  gFill = newElement('y:Fill','color',g.!COLOR_JCLLIB_NODE)\n  gNode = newShapeNode(jcllib,sLabel,'roundrectangle',gBorderStyle,,\n                       gFill)\nreturn gNode\n\nnewSetNode: procedure expose g.\n  parse arg set\n  /* Get any var names too */\n  sLabel = ''\n  vars = getChildrenByName(set,'var')\n  do i = 1 to words(vars)\n    var = word(vars,i)\n    sName = getAttribute(var,'name')\n    sValue = getAttribute(var,'value')\n    sLabel = sLabel || g.!LF || 'SET' sName'='sValue\n  end\n  gFill = newElement('y:Fill','color',g.!COLOR_SET_NODE)\n  gNode = newShapeNode(set,substr(sLabel,2),,gFill)\nreturn gNode\n\n/*\nThis is a temporary solution until a way of including the actual\ntext is worked out.\n*/\nnewIncludeNode: procedure expose g.\n  parse arg include\n  /* Get any var names too */\n  sLabel = 'INCLUDE' getAttribute(include,'member')\n  gFill = newElement('y:Fill','color',g.!COLOR_INCLUDE_NODE)\n  gNode = newShapeNode(include,sLabel,,gFill)\nreturn gNode\n\ngetLabelDimension: procedure expose g.\n  parse arg sLabel\n  if pos(g.!LF,sLabel) > 0\n  then do /* compute dimensions of a multi-line label */\n    nChars = 10 /* minimum width */\n    do nLines = 1 by 1 until length(sLabel) = 0\n      parse var sLabel sLine (g.!LF) sLabel\n      nChars = max(nChars,length(sLine))\n    end\n  end\n  else do\n    nChars = max(length(sLabel),10)\n    nLines = 1\n  end\nreturn nChars','nLines\n\nnewTextGeometry: procedure expose g.\n  parse arg nChars,nLines\n  gGeometry = newElement('y:Geometry',,\n                        'width',format(nChars*9.7,,0),,\n                        'height',nLines * 17)\nreturn gGeometry\n\nnewPixelGeometry: procedure expose g.\n  parse arg nWidth,nHeight\n  gGeometry = newElement('y:Geometry','width',nWidth,'height',nHeight)\nreturn gGeometry\n\nnewImageNode: procedure expose g.\n  parse arg id,sLabel,sImage\n  sId = getAttribute(id,'_id')\n  gNode = newElement('node','id','n'sId)\n  gData = newElement('data','key','d0')\n  call appendChild gData,gNode\n  gImageNode = newElement('y:ImageNode')\n  call appendChild gImageNode,gData\n  do i = 4 to arg()\n    call appendChild arg(i),gImageNode\n  end\n  gNodeLabel = newElement('y:NodeLabel',,\n                          'modelName','sandwich',,\n                          'modelPosition','s')\n  call appendChild gNodeLabel,gImageNode\n  call appendChild createTextNode(sLabel),gNodeLabel\n  gImage = newElement('y:Image','href',sImage)\n  call appendChild gImage,gImageNode\n  call appendChild gNode,g.!GRAPH\nreturn gNode\n\nnewArrow: procedure expose g.\n  parse arg gFrom,gTo,sLabel,gLineStyle\nreturn newLine(gFrom,gTo,sLabel,gLineStyle,,'standard')\n\nnewDottedArrow: procedure expose g.\n  parse arg gFrom,gTo,sLabel\n  gLineStyle = newElement('y:LineStyle','type','dashed')\nreturn newLine(gFrom,gTo,sLabel,gLineStyle,,'standard')\n\nnewDoubleArrow: procedure expose g.\n  parse arg gFrom,gTo,sLabel\nreturn newLine(gFrom,gTo,sLabel,,'standard','standard')\n\nnewLine: procedure expose g.\n  parse arg gFrom,gTo,sLabel,gLineStyle,sBegArrow,sEndArrow\n  gEdge = newElement('edge',,\n                    'source',getAttribute(gFrom,'id'),,\n                    'target',getAttribute(gTo,'id'))\n  gData = newElement('data','key','d1')\n  call appendChild gData,gEdge\n  gPolyLineEdge = newElement('y:PolyLineEdge')\n  call appendChild gPolyLineEdge,gData\n  if sLabel <> ''\n  then do\n    gEdgeLabel = newElement('y:EdgeLabel')\n    call appendChild gEdgeLabel,gPolyLineEdge\n    call appendChild createTextNode(sLabel),gEdgeLabel\n  end\n  if gLineStyle <> ''\n  then call appendChild gLineStyle,gPolyLineEdge\n  if sBegArrow <> '' | sEndArrow <> ''\n  then do\n    if sBegArrow = '' then sBegArrow = 'none'\n    if sEndArrow = '' then sEndArrow = 'none'\n    gArrows = newElement('y:Arrows',,\n                         'source',sBegArrow,,\n                         'target',sEndArrow)\n    call appendChild gArrows,gPolyLineEdge\n  end\n  gBendStyle = newElement('y:BendStyle','smoothed','true')\n  call appendChild gBendStyle,gPolyLineEdge\n  call appendChild gEdge,g.!GRAPH\nreturn gEdge\n\nprettyJCL: procedure expose g.\n  parse arg sFileOut,node\n  g.!FILEOUT = ''\n  g.!INDENT = 0\n  if sFileOut <> ''\n  then do\n    g.!FILEOUT = openFile(sFileOut,'OUTPUT')\n    if g.!rc = 0\n    then say 'JCL011I Creating' sFileOut\n    else do\n      say 'JCL012E Could not create' sFileOut'. Writing to console...'\n      g.!FILEOUT = '' /* null handle means write to console */\n    end\n  end\n  call emitJCL node\n  if g.!FILEOUT <> ''\n  then do\n    say 'JCL013I Created' sFileOut\n    rc = closeFile(g.!FILEOUT)\n  end\nreturn\n\nemitJCL: procedure expose g.\n  parse arg node\n  if isCommentNode(node) then return /* ignore XML comments */\n  if isCDATA(node)\n  then do\n    call Say strip(getText(node),'TRAILING',g.!LF)\n    return\n  end\n  sElement = getNodeName(node)\n  select\n    when sElement = 'comment' then do\n      children = getChildNodes(node)\n      do i = 1 to words(children)\n        child = word(children,i)\n        call Say '//*'getText(child)\n      end\n    end\n    when sElement = 'job' then do\n      call emitJobStatement node\n      call emitChildrenOf node\n      call Say '//'\n    end\n    when sElement = 'proc' then do\n      call emitStatement node\n      call emitChildrenOf node\n      call Say '//         PEND'\n    end\n    when sElement = 'step' then do\n      call emitStatement node,'EXEC'\n      call emitChildrenOf node\n    end\n    when sElement = 'dd' then do\n      call emitStatement node  /* this DD...                  */\n      call emitChildrenOf node /* ...and any concatenated DDs */\n      if getAttribute(node,'_') = '*'\n      then do\n        sDelim = getAttribute(node,'dlm')\n        if sDelim = '' then sDelim = '/*'\n        call Say sDelim\n      end\n    end\n    when sElement = 'if' then do\n      call Say '//         IF' getAttribute(node,'cond') 'THEN',\n                          getAttribute(node,'_comment')\n      call emitChildrenOf node\n      call Say '//         ENDIF' getAttribute(node,'_endcomment')\n    end\n    when sElement = 'then' then do\n      call emitChildrenOf node\n    end\n    when sElement = 'else' then do\n      call Say '//         ELSE' getAttribute(node,'_comment')\n      call emitChildrenOf node\n    end\n    when sElement = 'set' then do\n      call emitChildrenOf node\n    end\n    when sElement = 'var' then do\n      call Say '//'getLabel(node) 'SET',\n               toUpper(getAttribute(node,'name'))||,\n               '='getAttribute(node,'value')\n    end\n    when sElement = 'cntl' then do\n      call emitStatement node\n      call emitChildrenOf node\n      call Say '//         ENDCNTL'\n    end\n    when sElement = 'jes2cmd' then do\n      call Say '/*$'getAttribute(node,'cmd')','getAttribute(node,'parm')\n    end\n    when sElement = 'jes2stmt' then do\n      call Say '/*'getAttribute(node,'stmt') getKeywords(node,'stmt')\n    end\n    when sElement = 'jes3stmt' then do\n      call Say '//*'getAttribute(node,'stmt') getKeywords(node,'stmt')\n    end\n    when sElement = 'opcdir' then do\n      call Say '//*%OPC' getAttribute(node,'cmd'),\n                         getAttribute(node,'parm')\n    end\n    when sElement = 'jcl' then do\n      call emitChildrenOf node\n    end\n    otherwise do\n      call emitStatement node\n      call emitChildrenOf node\n    end\n  end\nreturn\n\ngetLabel: procedure expose g.\n  parse arg node\nreturn left(getAttribute(node,'_name'),8)\n\nemitJobStatement: procedure expose g.\n  parse arg node\n  sName = getAttribute(node,'_name')\n  sAcct = getAttribute(node,'acct')\n  sAcctInfo = getAttribute(node,'acctinfo')\n  sProg = getAttribute(node,'pgmr')\n  sPositionals = '('sAcct','sAcctInfo'),'sProg\n  sOperands = sPositionals\n  call getAttributeMap node\n  do i = 1 to g.!ATTRIBUTE.0\n    sKey = g.!ATTRIBUTE.i\n    if left(sKey,1) <> '_' & wordpos(sKey,'acct acctinfo pgmr') = 0\n    then do\n      sValue = g.!ATTRIBUTE.sKey\n      sOperands = sOperands','toUpper(sKey)'='sValue\n    end\n  end\n  call Say '//'left(sName,8) 'JOB ' sOperands\nreturn\n\nemitStatement: procedure expose g.\n  parse arg node,sOper\n  sName = getAttribute(node,'_name')\n  if sOper = '' then sOper = toUpper(getNodeName(node))\n  if length(sOper) < 3 then sOper = left(sOper,3)\n  nKeywords = 0\n  k. = ''\n  sPositionals = getAttribute(node,'_')\n  if sPositionals <> ''\n  then do /* treat positionals as keyword 1 */\n   nKeywords = 1\n   k.1 = sPositionals\n  end\n  call getAttributeMap node\n  do i = 1 to g.!ATTRIBUTE.0\n    sKey = g.!ATTRIBUTE.i\n    if left(sKey,1) <> '_' & wordpos(sKey,sIgnored) = 0\n    then do\n      nKeywords = nKeywords + 1\n      sValue = g.!ATTRIBUTE.sKey\n      k.nKeywords = toUpper(sKey)'='sValue\n    end\n  end\n  if nKeywords <= 1\n  then call Say '//'left(sName,8) sOper k.1\n  else do\n    sLine = '//'left(sName,8) sOper k.1','\n    do i = 2 to nKeywords-1\n      if length(sLine || k.i',') < 72\n      then sLine = sLine || k.i','\n      else do\n        call Say sLine\n        sLine = '//             'k.i','\n      end\n    end\n    if length(sLine || k.nKeywords) < 72\n    then call Say sLine || k.nKeywords\n    else do\n      call Say sLine\n      call Say '//             'k.nKeywords\n    end\n  end\nreturn\n\n\ngetKeywords: procedure expose g.\n  parse arg node,sIgnored\n  sPositionals = getAttribute(node,'_')\n  sKeywords = ''\n  call getAttributeMap node\n  do i = 1 to g.!ATTRIBUTE.0\n    sKey = g.!ATTRIBUTE.i\n    if left(sKey,1) <> '_' & wordpos(sKey,sIgnored) = 0\n    then do\n      sValue = g.!ATTRIBUTE.sKey\n      sKeywords = sKeywords','toUpper(sKey)'='sValue\n    end\n  end\n  if sPositionals <> ''\n  then sParameters = sPositionals || sKeywords\n  else sParameters = strip(sKeywords,'LEADING',',')\nreturn sParameters\n\nemitChildrenOf: procedure expose g.\n  parse arg node\n  children = getChildNodes(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call emitJCL child\n  end\nreturn\n\nsetOptions: procedure expose g.\n  parse arg sOptions\n  /* set default options... */\n  g.!OPTION.WRAP.1 = 255 /* only when WRAP option is active    */\n  g.!OPTION.GRAPHML  = 1 /* Output GraphML file?               */\n  g.!OPTION.XML      = 1 /* Output XML file?                   */\n  g.!OPTION.JCL      = 0 /* Output JCL file?                   */\n  g.!OPTION.INLINE   = 1 /* Draw instream data?                */\n  g.!OPTION.SYSOUT   = 1 /* Draw DD SYSOUT=x nodes?            */\n  g.!OPTION.DUMMY    = 1 /* Draw DD DUMMY nodes?               */\n  g.!OPTION.TRACE    = 0 /* Trace parsing of JCL?              */\n  g.!OPTION.ENCODING = 1 /* Emit encoding=\"xxx\" in XML prolog? */\n  g.!OPTION.WRAP     = 0 /* Wrap output?                       */\n  if g.!ENV = 'TSO' then g.!OPTION.WRAP = 1 /* TSO is special  */\n  g.!OPTION.LINE     = 0 /* Output XML _line attributes?       */\n  g.!OPTION.ID       = 0 /* Output XML _id attributes?         */\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n    if left(sOption,2) = 'NO'\n    then do\n      sOption = substr(sOption,3)\n      g.!OPTION.sOption = 0\n    end\n    else do\n      g.!OPTION.sOption = 1\n      sNextWord = word(sOptions,i+1)                     /* 20070208 */\n      if datatype(sNextWord,'WHOLE')\n      then do\n        g.!OPTION.sOption.1 = sNextWord\n        i = i + 1\n      end                                                /* 20070208 */\n    end\n  end\nreturn\n\nProlog:\n  if g.!ENV = 'TSO'\n  then g.!LF = '15'x\n  else g.!LF = '0A'x\n\n  g.!UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  g.!LOWER = 'abcdefghijklmnopqrstuvwxyz'\n\n  g.!LONGEST_LINE             = 0   /* longest output line found     */\n\n  g.!K = 0\n  g.!KDELTA = 0\n\n  g.!JCLTYPE_UNKNOWN   = 0; g.!JCLTYPE.0 = '?'\n  g.!JCLTYPE_STATEMENT = 1; g.!JCLTYPE.1 = 'STMT'\n  g.!JCLTYPE_DATA      = 2; g.!JCLTYPE.2 = 'DATA'\n  g.!JCLTYPE_COMMENT   = 3; g.!JCLTYPE.3 = '//*'\n  g.!JCLTYPE_EOJ       = 4; g.!JCLTYPE.4 = '//'\n  g.!JCLTYPE_JES2CMD   = 5; g.!JCLTYPE.5 = '/*$'\n  g.!JCLTYPE_JES2STMT  = 6; g.!JCLTYPE.6 = 'JES2'\n  g.!JCLTYPE_JES3STMT  = 7; g.!JCLTYPE.7 = 'JES3'\n  g.!JCLTYPE_OPCDIR    = 8; g.!JCLTYPE.8 = 'OPC'        /* HF 061218 */\n\n  call setStandardColors\n\n  /* Set up your color scheme here...*/\n  g.!COLOR_WHITE        = g.!COLOR.white\n  g.!COLOR_PARMS_NODE   = g.!COLOR.white\n  g.!COLOR_INLINE_NODE  = g.!COLOR.white\n  g.!COLOR_SHAPE_NODE   = g.!COLOR.lavender /* default shape color */\n  g.!COLOR_SET_NODE     = g.!COLOR.aliceblue\n  g.!COLOR_INCLUDE_NODE = g.!COLOR.whitesmoke\n  g.!COLOR_IF_NODE      = g.!COLOR.gold\n  g.!COLOR_JCLLIB_NODE  = g.!COLOR.lavender\n  g.!COLOR_JOB_NODE     = '#ccffcc' /* light green */\n  g.!COLOR_PROC_NODE    = '#e3ffe3' /* lighter green */\n  g.!COLOR_EOJ_NODE     = '#ff5c5c' /* light red */\n  g.!COLOR_PEND_NODE    = g.!COLOR.mistyrose\n  g.!COLOR_STEP_NODE    = g.!COLOR.beige\n  g.!COLOR_CONTROL_FLOW = g.!COLOR.red\n  g.!COLOR_DATA_FLOW    = g.!COLOR.black\n  g.!COLOR_DROP_SHADOW  = '#e0e0e0' /* very light gray */\n  drop g.!COLOR.   /* we dont need these anymore */\nreturn\n\n\nsetStandardColors: procedure expose g.\n  /* These are the standard SVG color names in order of increasing\n     brightness. The brightness value is show as a comment...*/\n  g.!COLOR.black = '#000000'                    /*   0 */\n  g.!COLOR.maroon = '#800000'                   /*  14 */\n  g.!COLOR.darkred = '#8B0000'                  /*  15 */\n  g.!COLOR.red = '#FF0000'                      /*  28 */\n  g.!COLOR.navy = '#000080'                     /*  38 */\n  g.!COLOR.darkblue = '#00008B'                 /*  42 */\n  g.!COLOR.indigo = '#4B0082'                   /*  47 */\n  g.!COLOR.firebrick = '#B22222'                /*  50 */\n  g.!COLOR.midnightblue = '#191970'             /*  51 */\n  g.!COLOR.purple = '#800080'                   /*  52 */\n  g.!COLOR.crimson = '#DC143C'                  /*  54 */\n  g.!COLOR.brown = '#A52A2A'                    /*  56 */\n  g.!COLOR.darkmagenta = '#8B008B'              /*  57 */\n  g.!COLOR.darkgreen = '#006400'                /*  59 */\n  g.!COLOR.mediumblue = '#0000CD'               /*  62 */\n  g.!COLOR.saddlebrown = '#8B4513'              /*  62 */\n  g.!COLOR.orangered = '#FF4500'                /*  69 */\n  g.!COLOR.mediumvioletred = '#C71585'          /*  74 */\n  g.!COLOR.darkslategray = '#2F4F4F'            /*  75 */\n  g.!COLOR.darkslategrey = '#2F4F4F'            /*  75 */\n  g.!COLOR.green = '#008000'                    /*  76 */\n  g.!COLOR.blue = '#0000FF'                     /*  77 */\n  g.!COLOR.sienna = '#A0522D'                   /*  79 */\n  g.!COLOR.darkviolet = '#9400D3'               /*  80 */\n  g.!COLOR.deeppink = '#FF1493'                 /*  84 */\n  g.!COLOR.darkslateblue = '#483D8B'            /*  86 */\n  g.!COLOR.darkolivegreen = '#556B2F'           /*  87 */\n  g.!COLOR.olive = '#808000'                    /*  90 */\n  g.!COLOR.chocolate = '#D2691E'                /*  94 */\n  g.!COLOR.forestgreen = '#228B22'              /*  96 */\n  g.!COLOR.darkgoldenrod = '#B8860B'            /* 103 */\n  g.!COLOR.indianred = '#CD5C5C'                /* 104 */\n  g.!COLOR.fuchsia = '#FF00FF'                  /* 105 */\n  g.!COLOR.magenta = '#FF00FF'                  /* 105 */\n  g.!COLOR.dimgray = '#696969'                  /* 105 */\n  g.!COLOR.dimgrey = '#696969'                  /* 105 */\n  g.!COLOR.olivedrab = '#6B8E23'                /* 106 */\n  g.!COLOR.darkorchid = '#9932CC'               /* 108 */\n  g.!COLOR.tomato = '#FF6347'                   /* 108 */\n  g.!COLOR.blueviolet = '#8A2BE2'               /* 108 */\n  g.!COLOR.darkorange = '#FF8C00'               /* 111 */\n  g.!COLOR.seagreen = '#2E8B57'                 /* 113 */\n  g.!COLOR.teal = '#008080'                     /* 114 */\n  g.!COLOR.peru = '#CD853F'                     /* 120 */\n  g.!COLOR.darkcyan = '#008B8B'                 /* 124 */\n  g.!COLOR.orange = '#FFA500'                   /* 125 */\n  g.!COLOR.slateblue = '#6A5ACD'                /* 126 */\n  g.!COLOR.coral = '#FF7F50'                    /* 127 */\n  g.!COLOR.gray = '#808080'                     /* 128 */\n  g.!COLOR.grey = '#808080'                     /* 128 */\n  g.!COLOR.goldenrod = '#DAA520'                /* 131 */\n  g.!COLOR.slategray = '#708090'                /* 131 */\n  g.!COLOR.slategrey = '#708090'                /* 131 */\n  g.!COLOR.mediumorchid = '#BA55D3'             /* 134 */\n  g.!COLOR.palevioletred = '#DB7093'            /* 134 */\n  g.!COLOR.royalblue = '#4169E1'                /* 137 */\n  g.!COLOR.salmon = '#FA8072'                   /* 137 */\n  g.!COLOR.steelblue = '#4682B4'                /* 138 */\n  g.!COLOR.lightslategray = '#778899'           /* 139 */\n  g.!COLOR.lightslategrey = '#778899'           /* 139 */\n  g.!COLOR.lightcoral = '#F08080'               /* 140 */\n  g.!COLOR.limegreen = '#32CD32'                /* 141 */\n  g.!COLOR.hotpink = '#FF69B4'                  /* 144 */\n  g.!COLOR.mediumseagreen = '#3CB371'           /* 146 */\n  g.!COLOR.mediumslateblue = '#7B68EE'          /* 146 */\n  g.!COLOR.rosybrown = '#BC8F8F'                /* 148 */\n  g.!COLOR.mediumpurple = '#9370DB'             /* 148 */\n  g.!COLOR.lime = '#00FF00'                     /* 150 */\n  g.!COLOR.darksalmon = '#E9967A'               /* 151 */\n  g.!COLOR.cadetblue = '#5F9EA0'                /* 152 */\n  g.!COLOR.sandybrown = '#F4A460'               /* 152 */\n  g.!COLOR.yellowgreen = '#9ACD32'              /* 153 */\n  g.!COLOR.orchid = '#DA70D6'                   /* 154 */\n  g.!COLOR.gold = '#FFD700'                     /* 155 */\n  g.!COLOR.lightsalmon = '#FFA07A'              /* 159 */\n  g.!COLOR.lightseagreen = '#20B2AA'            /* 160 */\n  g.!COLOR.darkkhaki = '#BDB76B'                /* 161 */\n  g.!COLOR.lawngreen = '#7CFC00'                /* 162 */\n  g.!COLOR.chartreuse = '#7FFF00'               /* 164 */\n  g.!COLOR.dodgerblue = '#1E90FF'               /* 165 */\n  g.!COLOR.darkgray = '#A9A9A9'                 /* 169 */\n  g.!COLOR.darkgrey = '#A9A9A9'                 /* 169 */\n  g.!COLOR.darkseagreen = '#8FBC8F'             /* 170 */\n  g.!COLOR.cornflowerblue = '#6495ED'           /* 170 */\n  g.!COLOR.tan = '#D2B48C'                      /* 171 */\n  g.!COLOR.burlywood = '#DEB887'                /* 173 */\n  g.!COLOR.violet = '#EE82EE'                   /* 174 */\n  g.!COLOR.yellow = '#FFFF00'                   /* 179 */\n  g.!COLOR.mediumaquamarine = '#66CDAA'         /* 183 */\n  g.!COLOR.greenyellow = '#ADFF2F'              /* 184 */\n  g.!COLOR.darkturquoise = '#00CED1'            /* 184 */\n  g.!COLOR.plum = '#DDA0DD'                     /* 185 */\n  g.!COLOR.springgreen = '#00FF7F'              /* 189 */\n  g.!COLOR.deepskyblue = '#00BFFF'              /* 189 */\n  g.!COLOR.silver = '#C0C0C0'                   /* 192 */\n  g.!COLOR.mediumturquoise = '#48D1CC'          /* 192 */\n  g.!COLOR.lightpink = '#FFB6C1'                /* 193 */\n  g.!COLOR.mediumspringgreen = '#00FA9A'        /* 194 */\n  g.!COLOR.lightgreen = '#90EE90'               /* 199 */\n  g.!COLOR.thistle = '#D8BFD8'                  /* 201 */\n  g.!COLOR.turquoise = '#40E0D0'                /* 202 */\n  g.!COLOR.lightsteelblue = '#B0C4DE'           /* 202 */\n  g.!COLOR.pink = '#FFC0CB'                     /* 202 */\n  g.!COLOR.khaki = '#F0E68C'                    /* 204 */\n  g.!COLOR.skyblue = '#87CEEB'                  /* 207 */\n  g.!COLOR.palegreen = '#98FB98'                /* 210 */\n  g.!COLOR.navajowhite = '#FFDEAD'              /* 211 */\n  g.!COLOR.lightgray = '#D3D3D3'                /* 211 */\n  g.!COLOR.lightgrey = '#D3D3D3'                /* 211 */\n  g.!COLOR.lightskyblue = '#87CEFA'             /* 211 */\n  g.!COLOR.wheat = '#F5DEB3'                    /* 212 */\n  g.!COLOR.peachpuff = '#FFDAB9'                /* 212 */\n  g.!COLOR.palegoldenrod = '#EEE8AA'            /* 214 */\n  g.!COLOR.lightblue = '#ADD8E6'                /* 215 */\n  g.!COLOR.moccasin = '#FFE4B5'                 /* 217 */\n  g.!COLOR.gainsboro = '#DCDCDC'                /* 220 */\n  g.!COLOR.powderblue = '#B0E0E6'               /* 221 */\n  g.!COLOR.bisque = '#FFE4C4'                   /* 221 */\n  g.!COLOR.aqua = '#00FFFF'                     /* 227 */\n  g.!COLOR.cyan = '#00FFFF'                     /* 227 */\n  g.!COLOR.aquamarine = '#7FFFD4'               /* 228 */\n  g.!COLOR.blanchedalmond = '#FFEBCD'           /* 228 */\n  g.!COLOR.mistyrose = '#FFE4E1'                /* 230 */\n  g.!COLOR.antiquewhite = '#FAEBD7'             /* 231 */\n  g.!COLOR.paleturquoise = '#AFEEEE'            /* 231 */\n  g.!COLOR.papayawhip = '#FFEFD5'               /* 233 */\n  g.!COLOR.lavender = '#E6E6FA'                 /* 236 */\n  g.!COLOR.lemonchiffon = '#FFFACD'             /* 237 */\n  g.!COLOR.beige = '#F5F5DC'                    /* 238 */\n  g.!COLOR.lightgoldenrodyellow = '#FAFAD2'     /* 238 */\n  g.!COLOR.linen = '#FAF0E6'                    /* 238 */\n  g.!COLOR.cornsilk = '#FFF8DC'                 /* 240 */\n  g.!COLOR.oldlace = '#FDF5E6'                  /* 241 */\n  g.!COLOR.lavenderblush = '#FFF0F5'            /* 243 */\n  g.!COLOR.seashell = '#FFF5EE'                 /* 244 */\n  g.!COLOR.whitesmoke = '#F5F5F5'               /* 245 */\n  g.!COLOR.lightyellow = '#FFFFE0'              /* 246 */\n  g.!COLOR.floralwhite = '#FFFAF0'              /* 248 */\n  g.!COLOR.honeydew = '#F0FFF0'                 /* 249 */\n  g.!COLOR.aliceblue = '#F0F8FF'                /* 249 */\n  g.!COLOR.ghostwhite = '#F8F8FF'               /* 250 */\n  g.!COLOR.ivory = '#FFFFF0'                    /* 251 */\n  g.!COLOR.snow = '#FFFAFA'                     /* 251 */\n  g.!COLOR.lightcyan = '#E0FFFF'                /* 252 */\n  g.!COLOR.mintcream = '#F5FFFA'                /* 252 */\n  g.!COLOR.azure = '#F0FFFF'                    /* 253 */\n  g.!COLOR.white = '#FFFFFF'                    /* 255 */\nreturn\n\nEpilog: procedure expose g.\n  if g.!LONGEST_LINE > g.!OPTION.WRAP.1\n  then say 'JCL010W To avoid output line truncation, specify: (WRAP',\n           g.!LONGEST_LINE\nreturn\n\nprettyPrinter: procedure expose g.\n  parse arg sFileOut,g.!TAB,node\n  if g.!TAB = '' then g.!TAB = 2 /* indentation amount */\n  if node = '' then node = getRoot()\n  g.!INDENT = 0\n  g.!FILEOUT = ''\n  if sFileOut <> ''\n  then do\n    g.!FILEOUT = openFile(sFileOut,'OUTPUT')\n    if g.!rc = 0\n    then say 'JCL006I Creating' sFileOut\n    else do\n      say 'JCL007E Could not create' sFileOut'. Writing to console...'\n      g.!FILEOUT = '' /* null handle means write to console */\n    end\n  end\n  call _setDefaultEntities\n  call emitProlog\n  g.!INDENT = -g.!TAB\n  call showNode node\n  if g.!FILEOUT <> ''\n  then do\n    say 'JCL008I Created' sFileOut\n    rc = closeFile(g.!FILEOUT)\n  end\nreturn\n\nemitProlog: procedure expose g.\n  if g.?xml.version = ''\n  then sVersion = '1.0'\n  else sVersion = g.?xml.version\n  if g.?xml.encoding = ''\n  then sEncoding = 'UTF-8'\n  else sEncoding = g.?xml.encoding\n  if g.?xml.standalone = ''\n  then sStandalone = 'yes'\n  else sStandalone = g.?xml.standalone\n  g.!INDENT = 0\n  if g.!OPTION.ENCODING\n  then call Say '<?xml version=\"'sVersion'\"',\n                     'encoding=\"'sEncoding'\"',\n                   'standalone=\"'sStandalone'\"?>'\n  else call Say '<?xml version=\"'sVersion'\"',\n                   'standalone=\"'sStandalone'\"?>'\n  sDocType = getDocType()\n  if sDocType <> ''\n  then call Say '<!DOCTYPE' getName(getDocumentElement()) sDocType'>'\nreturn\n\nshowNode: procedure expose g.\n  parse arg node\n  g.!INDENT = g.!INDENT + g.!TAB\n  select\n    when isTextNode(node)    then call emitTextNode    node\n    when isCommentNode(node) then call emitCommentNode node\n    when isCDATA(node)       then call emitCDATA       node\n    otherwise                     call emitElementNode node\n  end\n  g.!INDENT = g.!INDENT - g.!TAB\nreturn\n\nsetPreserveWhitespace: procedure expose g.\n  parse arg bPreserve\n  g.!PRESERVEWS = bPreserve = 1\nreturn\n\nemitTextNode: procedure expose g.\n  parse arg node\n  if g.!PRESERVEWS = 1\n  then call Say escapeText(getText(node))\n  else call Say escapeText(removeWhitespace(getText(node)))\nreturn\n\nemitCommentNode: procedure expose g.\n  parse arg node\n  call Say '<!--'getText(node)' -->'\nreturn\n\nemitCDATA: procedure expose g.\n  parse arg node\n  sText = getText(node)\n  if g.!ENV = 'TSO'                                      /* 20070118 */\n  then do\n    do until length(sText) = 0\n      parse var sText sLine (g.!LF) sText\n      call Say '<![CDATA['sLine']]>'\n    end\n  end\n  else do                                                /* 20070118 */\n    call Say '<![CDATA['sText']]>'\n  end\nreturn\n\n/* Here we override emitElementNode in prettyPrinter.\nIt is done here to ensure that elements containing text nodes are\noutput as:\n\n<element>text</element>\n\ninstead of:\n\n<element>\n  text\n</element>\n\nThe yEd viewer considers whitespace in text nodes to be significant,\nso we need to avoid introducing whitespace before and after the text\ncontent of an element. Coding CDATA instead of text does not help.\n*/\nemitElementNode: procedure expose g.\n  parse arg node\n  sElement = getName(node)\n  children = getChildNodes(node)\n  nChildren = words(children)\n  select\n    when nChildren = 0 then do\n      call emitElementAndAttributes node,'/>'\n    end\n    when nChildren = 1 then do\n      child = children\n      bIsCDATA = isCDATA(child)\n      if g.!YED_FRIENDLY = 1 & (isTextNode(child) | bIsCDATA)\n      then do /* for yEd: <element attrs>text</element> */\n        sText = toString(child)\n        if g.!OPTION.WRAP & pos(g.!LF,sText) > 0\n        then do /* split lines into records */\n          parse var sText sLine (g.!LF) sText\n          call emitElementAndAttributes node,'>'sLine\n          do until length(sText) = 0\n            parse var sText sLine (g.!LF) sText\n            if bIsCDATA\n            then call Say sLine,0 /* suppress indentation */\n            else call Say sLine\n          end\n          call Say '</'sElement'>',0 /* suppress indentation */\n        end\n        else call emitElementAndAttributes node,,\n                  '>'sText'</'sElement'>'\n      end\n      else do\n        call emitElementAndAttributes node,'>'\n        call showNode child\n        call Say '</'sElement'>'\n      end\n    end\n    otherwise do\n      call emitElementAndAttributes node,'>'\n      child = getFirstChild(node)\n      do while child <> ''\n        call showNode child\n        child = getNextSibling(child)\n      end\n      call Say '</'sElement'>'\n    end\n  end\nreturn\n\n/*\nWrap attributes to the next line if the line is getting too long.\n*/\nemitElementAndAttributes: procedure expose g.\n  parse arg node,sTermination\n  sElement = getName(node)\n  nAttrs = getAttributeCount(node)\n  sPad = ''\n  sLine = '<'sElement\n  do i = 1 to nAttrs\n    sAttr = getAttributeName(node,i)'=\"' ||,\n            escapeText(getAttribute(node,i))'\"'\n    nLineLength = g.!INDENT + length(sPad || sLine sAttr),\n                            + length(sTermination)\n    if g.!OPTION.WRAP & nLineLength > g.!OPTION.WRAP.1   /* 20070208 */\n    then do\n      call Say sPad || sLine\n      sPad = copies(' ',length(sElement)+2)\n      sLine = sAttr\n    end\n    else sLine = sLine sAttr\n  end\n  call Say sPad || sLine || sTermination\nreturn\n\nSay: procedure expose g.\n  parse arg sText,nIndent\n  if nIndent <> ''\n  then sLine = copies(' ',nIndent)sText /* temporary override */\n  else sLine = copies(' ',g.!INDENT)sText\n  if g.!ENV = 'TSO' & length(sLine) > g.!OPTION.WRAP.1   /* 20070208 */\n  then do\n    say 'JCL009W Line truncated:' strip(left(sText,50),'TRAILING')'...'\n    g.!LONGEST_LINE = max(g.!LONGEST_LINE,length(sLine))\n  end\n  if g.!FILEOUT = ''\n  then say sLine\n  else call putLine g.!FILEOUT,sLine\nreturn\n\n/*INCLUDE io.rex */\n/*INCLUDE parsexml.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAPERPNG": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x07\\x12/\\x01\\x07\\x12/\\x12B\\x00=\\x00=\\x00\\x00\\xe5\\xf1K\\xf9K\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2007-05-02T12:42:50", "lines": 61, "newlines": 61, "modlines": 0, "user": "V1.9.3"}, "mimetype": "image/png", "datatype": "binary", "extension": ".png"}, "PARSEXML": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x06\\xfa\\x06\\xed\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 1786, "newlines": 1773, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: parsexml.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/**********************************************************************\n**                                                                   **\n** ALL CODE BELOW THIS POINT BELONGS TO THE XML PARSER. YOU MUST     **\n** APPEND IT TO ANY REXX SOURCE FILE THAT REQUIRES AN XML PARSING    **\n** CAPABILITY. SINCE REXX HAS NO 'LIBRARY' FUNCTIONALITY, A WAY TO   **\n** AVOID HAVING DIFFERENT VERSIONS OF THE PARSER IN EACH OF YOUR     **\n** REXX PROCS IS TO DYNAMICALLY APPEND A CENTRAL VERSION TO EACH OF  **\n** YOUR REXX PROCS BEFORE EXECUTION.                                 **\n**                                                                   **\n** THE EXACT PROCEDURE TO FOLLOW DEPENDS ON YOUR PLATFORM, BUT...    **\n** TO HELP YOU DO THIS, I HAVE INCLUDED A REXX PRE-PROCESSOR CALLED  **\n** REXXPP THAT CAN BE USED TO SEARCH FOR 'INCLUDE' DIRECTIVES AND    **\n** REPLACE THEM WITH THE SPECIFIED FILE CONTENTS. IT HAS BEEN TESTED **\n** ON TSO, AND ON WIN32 USING REGINA REXX VERSION 3.3.               **\n**                                                                   **\n**********************************************************************/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - PARSEXML                                               **\n**                                                                   **\n** FUNCTION - A Rexx XML parser. It is non-validating, so DTDs and   **\n**            XML schemas are ignored. Ok, DTD entities are processed**\n**            but that's all.                                        **\n**                                                                   **\n** USAGE    - 1. Initialize the parser by:                           **\n**                                                                   **\n**               call initParser [options...]                        **\n**                                                                   **\n**            2. Parse the XML file to build an in-memory model      **\n**                                                                   **\n**               returncode = parseFile('filename')                  **\n**                ...or...                                           **\n**               returncode = parseString('xml in a string')         **\n**                                                                   **\n**            3. Navigate the in-memory model with the DOM API. For  **\n**               example:                                            **\n**                                                                   **\n**               say 'The document element is called',               **\n**                                   getName(getDocumentElement())   **\n**               say 'Children of the document element are:'         **\n**               node = getFirstChild(getDocumentElement())          **\n**               do while node <> ''                                 **\n**                 if isElementNode(node)                            **\n**                 then say 'Element node:' getName(node)            **\n**                 else say '   Text node:' getText(node)            **\n**                 node = getNextSibling(node)                       **\n**               end                                                 **\n**                                                                   **\n**            4. Optionally, destroy the in-memory model:            **\n**                                                                   **\n**               call destroyParser                                  **\n**                                                                   **\n** INPUT    - An XML file containing:                                **\n**              1. An optional XML prolog:                           **\n**                 - 0 or 1 XML declaration:                         **\n**                     <?xml version=\"1.0\" encoding=\"...\" ...?>      **\n**                 - 0 or more comments, PIs, and whitespace:        **\n**                     <!-- a comment -->                            **\n**                     <?target string?>                             **\n**                 - 0 or 1 document type declaration. Formats:      **\n**                     <!DOCTYPE root SYSTEM \"sysid\">                **\n**                     <!DOCTYPE root PUBLIC \"pubid\" SYSTEM \"sysid\"> **\n**                     <!DOCTYPE root [internal dtd]>                **\n**              2. An XML body:                                      **\n**                 - 1 Document element containing 0 or more child   **\n**                     elements. For example:                        **\n**                     <doc attr1=\"value1\" attr2=\"value2\"...>        **\n**                       Text of doc element                         **\n**                       <child1 attr1=\"value1\">                     **\n**                         Text of child1 element                    **\n**                       </child1>                                   **\n**                       More text of doc element                    **\n**                       <!-- an empty child element follows -->     **\n**                       <child2/>                                   **\n**                       Even more text of doc element               **\n**                     </doc>                                        **\n**                 - Elements may contain:                           **\n**                   Unparsed character data:                        **\n**                     <![CDATA[...unparsed data...]]>               **\n**                   Entity references:                              **\n**                     &name;                                        **\n**                   Character references:                           **\n**                     &#nnnnn;                                      **\n**                     &#xXXXX;                                      **\n**              3. An XML epilog (which is ignored):                 **\n**                 - 0 or more comments, PIs, and whitespace.        **\n**                                                                   **\n** API      - The basic setup/teardown API calls are:                **\n**                                                                   **\n**            initParser [options]                                   **\n**                Initialises the parser's global variables and      **\n**                remembers any runtime options you specify. The     **\n**                options recognized are:                            **\n**                NOBLANKS - Suppress whitespace-only nodes          **\n**                DEBUG    - Display some debugging info             **\n**                DUMP     - Display the parse tree                  **\n**                                                                   **\n**            parseFile(filename)                                    **\n**                Parses the XML data in the specified filename and  **\n**                builds an in-memory model that can be accessed via **\n**                the DOM API (see below).                           **\n**                                                                   **\n**            parseString(text)                                      **\n**                Parses the XML data in the specified string.       **\n**                                                                   **\n**            destroyParser                                          **\n**                Destroys the in-memory model and miscellaneous     **\n**                global variables.                                  **\n**                                                                   **\n**          - In addition, the following utility API calls can be    **\n**            used:                                                  **\n**                                                                   **\n**            removeWhitespace(text)                                 **\n**                Returns the supplied text string but with all      **\n**                whitespace characters removed, multiple spaces     **\n**                replaced with single spaces, and leading and       **\n**                trailing spaces removed.                           **\n**                                                                   **\n**            removeQuotes(text)                                     **\n**                Returns the supplied text string but with any      **\n**                enclosing apostrophes or double-quotes removed.    **\n**                                                                   **\n**            escapeText(text)                                       **\n**                Returns the supplied text string but with special  **\n**                characters encoded (for example, '<' becomes &lt;) **\n**                                                                   **\n**            toString(node)                                         **\n**                Walks the document tree (beginning at the specified**\n**                node) and returns a string in XML format.          **\n**                                                                   **\n** DOM API  - The DOM (ok, DOM-like) calls that you can use are      **\n**            listed below:                                          **\n**                                                                   **\n**            Document query/navigation API calls                    **\n**            -----------------------------------                    **\n**                                                                   **\n**            getRoot()                                              **\n**                Returns the node number of the root node. This     **\n**                can be used in calls requiring a 'node' argument.  **\n**                In this implementation, getDocumentElement() and   **\n**                getRoot() are (incorrectly) synonymous - this may  **\n**                change, so you should use getDocumentElement()     **\n**                in preference to getRoot().                        **\n**                                                                   **\n**            getDocumentElement()                                   **\n**                Returns the node number of the document element.   **\n**                The document element is the topmost element node.  **\n**                You should use this in preference to getRoot()     **\n**                (see above).                                       **\n**                                                                   **\n**            getName(node)                                          **\n**                Returns the name of the specified node.            **\n**                                                                   **\n**            getNodeValue(node)                                     **\n**            getText(node)                                          **\n**                Returns the text content of an unnamed node. A     **\n**                node without a name can only contain text. It      **\n**                cannot have attributes or children.                **\n**                                                                   **\n**            getAttributeCount(node)                                **\n**                Returns the number of attributes present on the    **\n**                specified node.                                    **\n**                                                                   **\n**            getAttributeMap(node)                                  **\n**                Builds a map of the attributes of the specified    **\n**                node. The map can be accessed via the following    **\n**                variables:                                         **\n**                  g.!ATTRIBUTE.0 = The number of attributes mapped.**\n**                  g.!ATTRIBUTE.n = The name of attribute 'n' (in   **\n**                                   order of appearance). n > 0.    **\n**                  g.!ATTRIBUTE.name = The value of the attribute   **\n**                                   called 'name'.                  **\n**                                                                   **\n**            getAttributeName(node,n)                               **\n**                Returns the name of the nth attribute of the       **\n**                specified node (1 is first, 2 is second, etc).     **\n**                                                                   **\n**            getAttributeNames(node)                                **\n**                Returns a space-delimited list of the names of the **\n**                attributes of the specified node.                  **\n**                                                                   **\n**            getAttribute(node,name)                                **\n**                Returns the value of the attribute called 'name' of**\n**                the specified node.                                **\n**                                                                   **\n**            getAttribute(node,n)                                   **\n**                Returns the value of the nth attribute of the      **\n**                specified node (1 is first, 2 is second, etc).     **\n**                                                                   **\n**            setAttribute(node,name,value)                          **\n**                Updates the value of the attribute called 'name'   **\n**                of the specified node. If no attribute exists with **\n**                that name, then one is created.                    **\n**                                                                   **\n**            setAttributes(node,name1,value1,name2,value2,...)      **\n**                Updates the attributes of the specified node. Zero **\n**                or more name/value pairs are be specified as the   **\n**                arguments.                                         **\n**                                                                   **\n**            hasAttribute(node,name)                                **\n**                Returns 1 if the specified node has an attribute   **\n**                with the specified name, else 0.                   **\n**                                                                   **\n**            getParentNode(node)                                    **\n**            getParent(node)                                        **\n**                Returns the node number of the specified node's    **\n**                parent. If the node number returned is 0, then the **\n**                specified node is the root node.                   **\n**                All nodes have a parent (except the root node).    **\n**                                                                   **\n**            getFirstChild(node)                                    **\n**                Returns the node number of the specified node's    **\n**                first child node.                                  **\n**                                                                   **\n**            getLastChild(node)                                     **\n**                Returns the node number of the specified node's    **\n**                last child node.                                   **\n**                                                                   **\n**            getChildNodes(node)                                    **\n**            getChildren(node)                                      **\n**                Returns a space-delimited list of node numbers of  **\n**                the children of the specified node. You can use    **\n**                this list to step through the children as follows: **\n**                  children = getChildren(node)                     **\n**                  say 'Node' node 'has' words(children) 'children' **\n**                  do i = 1 to words(children)                      **\n**                     child = word(children,i)                      **\n**                     say 'Node' child 'is' getName(child)          **\n**                  end                                              **\n**                                                                   **\n**            getChildrenByName(node,name)                           **\n**                Returns a space-delimited list of node numbers of  **\n**                the immediate children of the specified node which **\n**                are called 'name'. Names are case-sensitive.       **\n**                                                                   **\n**            getElementsByTagName(node,name)                        **\n**                Returns a space-delimited list of node numbers of  **\n**                the descendants of the specified node which are    **\n**                called 'name'. Names are case-sensitive.           **\n**                                                                   **\n**            getNextSibling(node)                                   **\n**                Returns the node number of the specified node's    **\n**                next sibling node. That is, the next node sharing  **\n**                the same parent.                                   **\n**                                                                   **\n**            getPreviousSibling(node)                               **\n**                Returns the node number of the specified node's    **\n**                previous sibline node. That is, the previous node  **\n**                sharing the same parent.                           **\n**                                                                   **\n**            getProcessingInstruction(name)                         **\n**                Returns the value of the PI with the specified     **\n**                target name.                                       **\n**                                                                   **\n**            getProcessingInstructionList()                         **\n**                Returns a space-delimited list of the names of all **\n**                PI target names.                                   **\n**                                                                   **\n**            getNodeType(node)                                      **\n**                Returns a number representing the specified node's **\n**                type. The possible values can be compared to the   **\n**                following global variables:                        **\n**                g.!ELEMENT_NODE                = 1                 **\n**                g.!ATTRIBUTE_NODE              = 2                 **\n**                g.!TEXT_NODE                   = 3                 **\n**                g.!CDATA_SECTION_NODE          = 4                 **\n**                g.!ENTITY_REFERENCE_NODE       = 5                 **\n**                g.!ENTITY_NODE                 = 6                 **\n**                g.!PROCESSING_INSTRUCTION_NODE = 7                 **\n**                g.!COMMENT_NODE                = 8                 **\n**                g.!DOCUMENT_NODE               = 9                 **\n**                g.!DOCUMENT_TYPE_NODE          = 10                **\n**                g.!DOCUMENT_FRAGMENT_NODE      = 11                **\n**                g.!NOTATION_NODE               = 12                **\n**                Note: as this exposes internal implementation      **\n**                details, it is best not to use this routine.       **\n**                Consider using isTextNode() etc instead.           **\n**                                                                   **\n**            isCDATA(node)                                          **\n**                Returns 1 if the specified node is an unparsed     **\n**                character data (CDATA) node, else 0. CDATA nodes   **\n**                are used to contain content that you do not want   **\n**                to be treated as XML data. For example, HTML data. **\n**                                                                   **\n**            isElementNode(node)                                    **\n**                Returns 1 if the specified node is an element node,**\n**                else 0.                                            **\n**                                                                   **\n**            isTextNode(node)                                       **\n**                Returns 1 if the specified node is a text node,    **\n**                else 0.                                            **\n**                                                                   **\n**            isCommentNode(node)                                    **\n**                Returns 1 if the specified node is a comment node, **\n**                else 0. Note: when a document is parsed, comment   **\n**                nodes are ignored. This routine returns 1 iff a    **\n**                comment node has been inserted into the in-memory  **\n**                document tree by using createComment().            **\n**                                                                   **\n**            hasChildren(node)                                      **\n**                Returns 1 if the specified node has one or more    **\n**                child nodes, else 0.                               **\n**                                                                   **\n**            getDocType(doctype)                                    **\n**                Gets the text of the <!DOCTYPE> prolog node.       **\n**                                                                   **\n**            Document creation/mutation API calls                   **\n**            ------------------------------------                   **\n**                                                                   **\n**            createDocument(name)                                   **\n**                Returns the node number of a new document node     **\n**                with the specified name.                           **\n**                                                                   **\n**            createDocumentFragment(name)                           **\n**                Returns the node number of a new document fragment **\n**                node with the specified name.                      **\n**                                                                   **\n**            createElement(name)                                    **\n**                Returns the node number of a new empty element     **\n**                node with the specified name. An element node can  **\n**                have child nodes.                                  **\n**                                                                   **\n**            createTextNode(data)                                   **\n**                Returns the node number of a new text node. A text **\n**                node can *not* have child nodes.                   **\n**                                                                   **\n**            createCDATASection(data)                               **\n**                Returns the node number of a new Character Data    **\n**                (CDATA) node. A CDATA node can *not* have child    **\n**                nodes. CDATA nodes are used to contain content     **\n**                that you do not want to be treated as XML data.    **\n**                For example, HTML data.                            **\n**                                                                   **\n**            createComment(data)                                    **\n**                Returns the node number of a new commend node.     **\n**                A command node can *not* have child nodes.         **\n**                                                                   **\n**            appendChild(node,parent)                               **\n**                Appends the specified node to the end of the list  **\n**                of children of the specified parent node.          **\n**                                                                   **\n**            insertBefore(node,refnode)                             **\n**                Inserts node 'node' before the reference node      **\n**                'refnode'.                                         **\n**                                                                   **\n**            removeChild(node)                                      **\n**                Removes the specified node from its parent and     **\n**                returns its node number. The removed child is now  **\n**                an orphan.                                         **\n**                                                                   **\n**            replaceChild(newnode,oldnode)                          **\n**                Replaces the old child 'oldnode' with the new      **\n**                child 'newnode' and returns the old child's node   **\n**                number. The old child is now an orphan.            **\n**                                                                   **\n**            setAttribute(node,attrname,attrvalue)                  **\n**                Adds or replaces the attribute called 'attrname'   **\n**                on the specified node.                             **\n**                                                                   **\n**            removeAttribute(node,attrname)                         **\n**                Removes the attribute called 'attrname' from the   **\n**                specified node.                                    **\n**                                                                   **\n**            setDocType(doctype)                                    **\n**                Sets the text of the <!DOCTYPE> prolog node.       **\n**                                                                   **\n**            cloneNode(node,[deep])                                 **\n**                Creates a copy (a clone) of the specified node     **\n**                and returns its node number. If deep = 1 then      **\n**                all descendants of the specified node are also     **\n**                cloned, else only the specified node and its       **\n**                attributes are cloned.                             **\n**                                                                   **\n** NOTES    - 1. This parser creates global variables and so its     **\n**               operation may be severely jiggered if you update    **\n**               any of them accidentally (or on purpose). The       **\n**               variables you should avoid updating yourself are:   **\n**                                                                   **\n**               g.!ATTRIBUTE.n                                      **\n**               g.!ATTRIBUTE.name                                   **\n**               g.!ATTRSOK                                          **\n**               g.!DTD                                              **\n**               g.!ENDOFDOC                                         **\n**               g.!ENTITIES                                         **\n**               g.!ENTITY.name                                      **\n**               g.!FIRST.n                                          **\n**               g.!LAST.n                                           **\n**               g.!NAME.n                                           **\n**               g.!NEXT.n                                           **\n**               g.!NEXTID                                           **\n**               g.!OPTION.name                                      **\n**               g.!OPTIONS                                          **\n**               g.!PARENT.n                                         **\n**               g.!PI                                               **\n**               g.!PI.name                                          **\n**               g.!PREV.n                                           **\n**               g.!PUBLIC                                           **\n**               g.!ROOT                                             **\n**               g.!STACK                                            **\n**               g.!SYSTEM                                           **\n**               g.!TEXT.n                                           **\n**               g.!TYPE.n                                           **\n**               g.!WHITESPACE                                       **\n**               g.!XML                                              **\n**               g.?XML                                              **\n**               g.?XML.VERSION                                      **\n**               g.?XML.ENCODING                                     **\n**               g.?XML.STANDALONE                                   **\n**                                                                   **\n**            2. To reduce the incidence of name clashes, procedure  **\n**               names that are not meant to be part of the public   **\n**               API have been prefixed with '_'.                    **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** CONTRIBUTORS -                                                    **\n**            Alessandro Battilani                                   **\n**              <alessandro.battilani@bancaintesa.it>                **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top pls)       **\n**            -------- --------------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**                         Ignore whitespace to fix parse error.     **\n**            20070325 AJA Whitespace defaults to '090a0d'x.         **\n**            20070323 AJA Added createDocumentFragment().           **\n**                         Added isDocumentFragmentNode().           **\n**                         Added isDocumentNode().                   **\n**            20060915 AJA Added cloneNode().                        **\n**                         Added deepClone().                        **\n**                         Changed removeChild() to return the       **\n**                         node number of the child instead of       **\n**                         clearing it.                              **\n**                         Changed replaceChild() to return the      **\n**                         node number of the old child instead      **\n**                         of clearing it.                           **\n**            20060913 AJA Fixed bug in _resolveEntities().          **\n**            20060808 AB  Added support for reading from a DD       **\n**                         name when running IRXJCL on MVS.          **\n**                         This change was contributed by            **\n**                         Alessandro Battilani from Banca           **\n**                         Intesa, Italy.                            **\n**            20060803 AJA Fixed loop in getAttributeMap().          **\n**            20051025 AJA Now checks parentage before adding a      **\n**                         child node:                               **\n**                         Fixed appendChild(id,parent)              **\n**                         Fixed insertBefore(id,ref)                **\n**            20051014 AJA Added alias routine names to more         **\n**                         closely match the DOM specification.      **\n**                         Specifically:                             **\n**                         Added getNodeName()                       **\n**                         Added getNodeValue()                      **\n**                         Added getParentNode()                     **\n**                         Added getChildNodes()                     **\n**                         Added hasChildNodes()                     **\n**                         Added getElementsByTagName()      .       **\n**            20050919 AJA Added setAttributes helper routine.       **\n**            20050914 AJA Added createComment and isComment.        **\n**            20050913 AJA Added get/setDocType routines.            **\n**            20050907 AJA Added _setDefaultEntities routine.        **\n**            20050601 AJA Added '250d'x to whitespace for TSO.      **\n**            20050514 AJA Removed getAttributes API call and        **\n**                         reworked attribute processing.            **\n**                         Added toString API call.                  **\n**            20040706 AJA Added creation/modification support.      **\n**            20031216 AJA Bugfix: _parseElement with no attrs       **\n**                         causes crash.                             **\n**            20031031 AJA Correctly parse '/' in attributes.        **\n**                         Fixed entity resolution.                  **\n**            20030912 AJA Bugfix: Initialize sXmlData first.        **\n**                         Bugfix: Correctly parse a naked '>'       **\n**                         present in an attribute value.            **\n**                         Enhancement: DUMP option now displays     **\n**                         first part of each text node.             **\n**            20030901 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n  parse source . . sSourceFile .\n  parse value sourceline(1) with . sVersion\n  say 'Rexx XML Parser' sVersion\n  say 'You cannot invoke this rexx by itself!'\n  say\n  say 'This rexx is a collection of subroutines to be called'\n  say 'from your own rexx procedures. You should either:'\n  say '  - Append this procedure to your own rexx procedure,'\n  say '    or,'\n  say '  - Append the following line to your rexx:'\n  say '    /* INCLUDE' sSourceFile '*/'\n  say '    ...and run the rexx preprocessor:'\n  say '    rexxpp myrexx myrexxpp'\n  say '    This will create myrexxpp by appending this file to myrexx'\nexit\n\n/*-------------------------------------------------------------------*\n * Set up global variables for the parser\n *-------------------------------------------------------------------*/\n\ninitParser: procedure expose g.\n  parse arg sOptions\n  g. = '' /* Note: stuffs up caller who may have set g. variables */\n  g.!OPTIONS = translate(sOptions)\n  sOptions = 'DEBUG DUMP NOBLANKS'\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n    g.!OPTION.sOption = wordpos(sOption,g.!OPTIONS) > 0\n  end\n\n  parse source sSystem sInvocation sSourceFile\n  select\n    when sSystem = 'WIN32'  then g.!WHITESPACE = '090a0d'x\n    when sSystem = 'TSO'    then g.!WHITESPACE = '05250d'x\n    otherwise                    g.!WHITESPACE = '090a0d'x /*20070325*/\n  end\n\n  g.!LEADERS = '_:ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,\n                 'abcdefghijklmnopqrstuvwxyz'\n  g.!OTHERS  = g.!LEADERS'.-0123456789'\n\n  call _setDefaultEntities\n\n  /* Not all of the following node types are used... */\n  g.!ELEMENT_NODE            =  1; g.!NODETYPE.1 = 'Element'\n  g.!ATTRIBUTE_NODE          =  2; g.!NODETYPE.2 = 'Attribute'\n  g.!TEXT_NODE               =  3; g.!NODETYPE.3 = 'Text'\n  g.!CDATA_SECTION_NODE      =  4; g.!NODETYPE.4 = 'CDATA Section'\n  g.!ENTITY_REFERENCE_NODE   =  5     /* NOT USED */\n  g.!ENTITY_NODE             =  6     /* NOT USED */\n  g.!PROCESSING_INSTRUCTION_NODE = 7  /* NOT USED */\n  g.!COMMENT_NODE            =  8; g.!NODETYPE.8 = 'Comment'\n  g.!DOCUMENT_NODE           =  9; g.!NODETYPE.9 = 'Document'\n  g.!DOCUMENT_TYPE_NODE      = 10    /* NOT USED */\n  g.!DOCUMENT_FRAGMENT_NODE  = 11; g.!NODETYPE.11 = 'Document Fragment'\n  g.!NOTATION_NODE           = 12    /* NOT USED */\n\n\n\n\n  g.!ENDOFDOC = 0\nreturn\n\n/*-------------------------------------------------------------------*\n * Clean up parser\n *-------------------------------------------------------------------*/\n\ndestroyParser: procedure expose g.\n  /* Note: it would be easy to just \"drop g.\", but this could\n     possibly stuff up the caller who may be using other\n     \"g.\" variables...\n     todo: revisit this one (parser may have to 'own' g. names)\n  */\n  drop g.?XML g.!ROOT g.!SYSTEM g.!PUBLIC g.!DTD\n  do i = 1 to words(g.!PI)\n    sName = word(g.!PI,i)\n    drop g.!PI.sName\n  end\n  drop g.!PI\n  do i = 1 to words(g.!ENTITIES)\n    sName = word(g.!ENTITIES,i)\n    drop g.!ENTITY.sName\n  end\n  drop g.!ENTITIES\n  call _setDefaultEntities\n  if datatype(g.!NEXTID,'WHOLE')\n  then do\n    do i = 1 to g.!NEXTID\n      drop g.!PARENT.i g.!FIRST.i g.!LAST.i g.!PREV.i,\n           g.!NEXT.i g.!NAME.i g.!TEXT.i\n    end\n  end\n  drop g.!NEXTID g.!STACK g.!ENDOFDOC\nreturn\n\n\n/*-------------------------------------------------------------------*\n * Read a file into a string\n *-------------------------------------------------------------------*/\n\nparseFile: procedure expose g.\n  parse arg sFile\n  parse source sSystem sInvocation sSourceFile . . . sInitEnv .\n  sXmlData = ''\n  select\n    when sSystem = 'TSO' & sInitEnv = 'TSO' then do\n      /* sFile is a dataset name */\n      address TSO\n      junk = OUTTRAP('junk.') /* Trap and discard messages */\n      'ALLOCATE DD(INPUT) DSN('sFile')'\n      'EXECIO * DISKR INPUT (FINIS'\n      'FREE DD(INPUT)'\n      address\n      do queued()\n        parse pull sLine\n        sXmlData = sXmlData || sLine\n      end\n      junk = OUTTRAP('OFF')\n    end\n    when sSystem = 'TSO' & sInitEnv = 'MVS' then do\n      /* sFile is a DD name */\n      address MVS 'EXECIO * DISKR' sFile '(FINIS'\n      do queued()\n        parse pull sLine\n        sXmlData = sXmlData || sLine\n      end\n    end\n    otherwise do\n      sXmlData = charin(sFile,,chars(sFile))\n    end\n  end\nreturn parseString(sXmlData)\n\n/*-------------------------------------------------------------------*\n * Parse a string containing XML\n *-------------------------------------------------------------------*/\n\nparseString: procedure expose g.\n  parse arg g.!XML\n  call _parseXmlDecl\n  do while pos('<',g.!XML) > 0\n    parse var g.!XML sLeft'<'sData\n    select\n      when left(sData,1) = '?'         then call _parsePI      sData\n      when left(sData,9) = '!DOCTYPE ' then call _parseDocType sData\n      when left(sData,3) = '!--'       then call _parseComment sData\n      otherwise                             call _parseElement sData\n    end\n  end\nreturn 0\n\n/*-------------------------------------------------------------------*\n * <?xml version=\"1.0\" encoding=\"...\" ...?>\n *-------------------------------------------------------------------*/\n\n_parseXmlDecl: procedure expose g.\n  if left(g.!XML,6) = '<?xml '\n  then do\n    parse var g.!XML '<?xml 'sXMLDecl'?>'g.!XML\n    g.?xml = space(sXMLDecl)\n    sTemp = _getNormalizedAttributes(g.?xml)\n    parse var sTemp 'version='g.?xml.version'ff'x\n    parse var sTemp 'encoding='g.?xml.encoding'ff'x\n    parse var sTemp 'standalone='g.?xml.standalone'ff'x\n  end\nreturn\n\n/*-------------------------------------------------------------------*\n * <?target string?>\n *-------------------------------------------------------------------*/\n\n_parsePI: procedure expose g.\n  parse arg '?'sProcessingInstruction'?>'g.!XML\n  call _setProcessingInstruction sProcessingInstruction\nreturn\n\n/*-------------------------------------------------------------------*\n * <!DOCTYPE root SYSTEM \"sysid\">\n * <!DOCTYPE root SYSTEM \"sysid\" [internal dtd]>\n * <!DOCTYPE root PUBLIC \"pubid\" \"sysid\">\n * <!DOCTYPE root PUBLIC \"pubid\" \"sysid\" [internal dtd]>\n * <!DOCTYPE root [internal dtd]>\n *-------------------------------------------------------------------*/\n\n_parseDocType: procedure expose g.\n  parse arg '!DOCTYPE' sDocType'>'\n  if g.!ROOT <> ''\n  then call _abort 'XML002E Multiple \"<!DOCTYPE\" declarations'\n  if pos('[',sDocType) > 0\n  then do\n    parse arg '!DOCTYPE' sDocType'['g.!DTD']>'g.!XML\n    parse var sDocType g.!ROOT sExternalId\n    if sExternalId <> '' then call _parseExternalId sExternalId\n    g.!DTD = strip(g.!DTD)\n    call _parseDTD g.!DTD\n  end\n  else do\n    parse arg '!DOCTYPE' g.!ROOT sExternalId'>'g.!XML\n    if sExternalId <> '' then call _parseExternalId sExternalId\n  end\n  g.!ROOT = strip(g.!ROOT)\nreturn\n\n/*-------------------------------------------------------------------*\n * SYSTEM \"sysid\"\n * PUBLIC \"pubid\" \"sysid\"\n *-------------------------------------------------------------------*/\n\n_parseExternalId: procedure expose g.\n  parse arg sExternalIdType .\n  select\n    when sExternalIdType = 'SYSTEM' then do\n      parse arg . g.!SYSTEM\n      g.!SYSTEM = removeQuotes(g.!SYSTEM)\n    end\n    when sExternalIdType = 'PUBLIC' then do\n      parse arg . g.!PUBLIC g.!SYSTEM\n      g.!PUBLIC = removeQuotes(g.!PUBLIC)\n      g.!SYSTEM = removeQuotes(g.!SYSTEM)\n    end\n    otherwise do\n       parse arg sExternalEntityDecl\n       call _abort 'XML003E Invalid external entity declaration:',\n                   sExternalEntityDecl\n    end\n  end\nreturn\n\n\n/*-------------------------------------------------------------------*\n * <!ENTITY name \"value\">\n * <!ENTITY name SYSTEM \"sysid\">\n * <!ENTITY name PUBLIC \"pubid\" \"sysid\">\n * <!ENTITY % name pedef>\n * <!ELEMENT elementname contentspec>\n * <!ATTLIST elementname attrname attType DefaultDecl ...>\n * <!NOTATION name notationdef>\n *-------------------------------------------------------------------*/\n\n_parseDTD: procedure expose g.\n  parse arg sDTD\n  do while pos('<!',sDTD) > 0\n    parse var sDTD '<!'sDecl sName sValue'>'sDTD\n    select\n      when sDecl = 'ENTITY' then do\n        parse var sValue sWord1 .\n        select\n          when sName = '%'       then nop\n          when sWord1 = 'SYSTEM' then nop\n          when sWord1 = 'PUBLIC' then nop\n          otherwise do\n            sValue = _resolveEntities(removeQuotes(sValue))\n            call _setEntity sName,sValue\n          end\n        end\n      end\n      otherwise nop /* silently ignore other possibilities for now */\n    end\n  end\nreturn\n\n/*-------------------------------------------------------------------*\n * <!-- comment -->\n *-------------------------------------------------------------------*/\n\n_parseComment: procedure expose g.\n  parse arg sComment'-->'g.!XML\n  /* silently ignore comments */\nreturn\n\n/*-------------------------------------------------------------------*\n * <tag attr1=\"value1\" attr2=\"value2\" ...>...</tag>\n * <tag attr1=\"value1\" attr2=\"value2\" .../>\n *-------------------------------------------------------------------*/\n\n_parseElement: procedure expose g.\n  parse arg sXML\n\n  if g.!ENDOFDOC\n  then call _abort 'XML004E Only one top level element is allowed.',\n                  'Found:' subword(g.!XML,1,3)\n  call _startDocument\n\n  g.!XML = '<'sXML\n  do while pos('<',g.!XML) > 0 & \\g.!ENDOFDOC\n    parse var g.!XML sLeft'<'sBetween'>'g.!XML\n\n    if length(sLeft) > 0\n    then call _characters sLeft\n\n    if g.!OPTION.DEBUG\n    then say g.!STACK sBetween\n\n    if left(sBetween,8) = '![CDATA['\n    then do\n      g.!XML = sBetween'>'g.!XML            /* ..back it out! */\n      parse var g.!XML '![CDATA['sBetween']]>'g.!XML\n      call _characterData sBetween\n    end\n    else do\n      sBetween = removeWhiteSpace(sBetween)                /*20090822*/\n      select\n        when left(sBetween,3) = '!--' then do    /* <!-- comment --> */\n          if right(sBetween,2) <> '--'\n          then do  /* backup a bit and look for end-of-comment */\n            g.!XML = sBetween'>'g.!XML\n            if pos('-->',g.!XML) = 0\n            then call _abort 'XML005E End of comment missing after:',\n                            '<'g.!XML\n            parse var g.!XML sComment'-->'g.!XML\n          end\n        end\n        when left(sBetween,1) = '?' then do    /* <?target string?> */\n          parse var sBetween '?'sProcessingInstruction'?'\n          call _setProcessingInstruction sProcessingInstruction\n        end\n        when left(sBetween,1) = '/' then do    /* </tag> */\n          call _endElement substr(sBetween,2)   /* tag */\n        end\n        when  right(sBetween,1) = '/'  /* <tag ...attrs.../> */\n        then do\n          parse var sBetween sTagName sAttrs\n          if length(sAttrs) > 0                            /*20031216*/\n          then sAttrs = substr(sAttrs,1,length(sAttrs)-1)  /*20031216*/\n          else parse var sTagName sTagName'/'     /* <tag/>  20031216*/\n          sAttrs = _getNormalizedAttributes(sAttrs)\n          call _startElement sTagName sAttrs\n          call _endElement sTagName\n        end\n        otherwise do              /* <tag ...attrs ...> ... </tag>  */\n          parse var sBetween sTagName sAttrs\n          sAttrs = _getNormalizedAttributes(sAttrs)\n          if g.!ATTRSOK\n          then do\n            call _startElement sTagName sAttrs\n          end\n          else do /* back up a bit and look for the real end of tag */\n            g.!XML = '<'sBetween'&gt;'g.!XML\n            if pos('>',g.!XML) = 0\n            then call _abort 'XML006E Missing end tag for:' sTagName\n            /* reparse on next cycle avoiding premature '>'...*/\n          end\n        end\n      end\n    end\n  end\n\n  call _endDocument\nreturn\n\n_startDocument: procedure expose g.\n  g.!NEXTID = 0\n  g.!STACK = 0\nreturn\n\n_startElement:  procedure expose g.\n  parse arg sTagName sAttrs\n  id = _getNextId()\n  call _updateLinkage id\n  g.!NAME.id = sTagName\n  g.!TYPE.id = g.!ELEMENT_NODE\n  call _addAttributes id,sAttrs\n  cid = _pushElement(id)\nreturn\n\n_updateLinkage: procedure expose g.\n  parse arg id\n  parent = _peekElement()\n  g.!PARENT.id = parent\n  parentsLastChild = g.!LAST.parent\n  g.!NEXT.parentsLastChild = id\n  g.!PREV.id = parentsLastChild\n  g.!LAST.parent = id\n  if g.!FIRST.parent = ''\n  then g.!FIRST.parent = id\nreturn\n\n_characterData: procedure expose g.\n  parse arg sChars\n  id = _getNextId()\n  call _updateLinkage id\n  g.!TEXT.id = sChars\n  g.!TYPE.id = g.!CDATA_SECTION_NODE\nreturn\n\n_characters: procedure expose g.\n  parse arg sChars\n  sText = _resolveEntities(sChars)\n  if g.!OPTION.NOBLANKS & removeWhitespace(sText) = ''\n  then return\n  id = _getNextId()\n  call _updateLinkage id\n  g.!TEXT.id = sText\n  g.!TYPE.id = g.!TEXT_NODE\nreturn\n\n_endElement: procedure expose g.\n  parse arg sTagName\n  id = _popElement()\n  g.!ENDOFDOC = id = 1\n  if sTagName == g.!NAME.id\n  then nop\n  else call _abort,\n           'XML007E Expecting </'g.!NAME.id'> but found </'sTagName'>'\nreturn\n\n_endDocument: procedure expose g.\n  id = _peekElement()\n  if id <> 0\n  then call _abort 'XML008E End of document tag missing: 'id getName(id)\n  if g.!ROOT <> '' & g.!ROOT <> getName(getRoot())\n  then call _abort 'XML009E Root element name \"'getName(getRoot())'\"',\n                  'does not match DTD root \"'g.!ROOT'\"'\n\n  if g.!OPTION.DUMP\n  then call _displayTree\nreturn\n\n_displayTree: procedure expose g.\n  say   right('',4),\n        right('',4),\n        left('',12),\n        right('',6),\n        '--child--',\n        '-sibling-',\n        'attribute'\n  say   right('id',4),\n        right('type',4),\n        left('name',12),\n        right('parent',6),\n        right('1st',4),\n        right('last',4),\n        right('prev',4),\n        right('next',4),\n        right('1st',4),\n        right('last',4)\n  do id = 1 to g.!NEXTID\n    if g.!PARENT.id <> '' | id = 1 /* skip orphans */\n    then do\n      select\n        when g.!TYPE.id = g.!CDATA_SECTION_NODE then sName = '#CDATA'\n        when g.!TYPE.id = g.!TEXT_NODE          then sName = '#TEXT'\n        otherwise                                    sName = g.!NAME.id\n      end\n      say right(id,4),\n          right(g.!TYPE.id,4),\n          left(sName,12),\n          right(g.!PARENT.id,6),\n          right(g.!FIRST.id,4),\n          right(g.!LAST.id,4),\n          right(g.!PREV.id,4),\n          right(g.!NEXT.id,4),\n          right(g.!FIRSTATTR.id,4),\n          right(g.!LASTATTR.id,4),\n          left(removeWhitespace(g.!TEXT.id),19)\n    end\n  end\nreturn\n\n_pushElement: procedure expose g.\n  parse arg id\n  g.!STACK = g.!STACK + 1\n  nStackDepth = g.!STACK\n  g.!STACK.nStackDepth = id\nreturn id\n\n_popElement: procedure expose g.\n  n = g.!STACK\n  if n = 0\n  then id = 0\n  else do\n    id = g.!STACK.n\n    g.!STACK = g.!STACK - 1\n  end\nreturn id\n\n_peekElement: procedure expose g.\n  n = g.!STACK\n  if n = 0\n  then id = 0\n  else id = g.!STACK.n\nreturn id\n\n_getNextId: procedure expose g.\n  g.!NEXTID = g.!NEXTID + 1\nreturn g.!NEXTID\n\n_addAttributes: procedure expose g.\n  parse arg id,sAttrs\n  do while pos('ff'x,sAttrs) > 0\n    parse var sAttrs sAttrName'='sAttrValue 'ff'x sAttrs\n    sAttrName = removeWhitespace(sAttrName)\n    call _addAttribute id,sAttrName,sAttrValue\n  end\nreturn\n\n_addAttribute: procedure expose g.\n  parse arg id,sAttrName,sAttrValue\n  aid = _getNextId()\n  g.!TYPE.aid = g.!ATTRIBUTE_NODE\n  g.!NAME.aid = sAttrName\n  g.!TEXT.aid = _resolveEntities(sAttrValue)\n  g.!PARENT.aid = id\n  g.!NEXT.aid = ''\n  g.!PREV.aid = ''\n  if g.!FIRSTATTR.id = '' then g.!FIRSTATTR.id = aid\n  if g.!LASTATTR.id <> ''\n  then do\n    lastaid = g.!LASTATTR.id\n    g.!NEXT.lastaid = aid\n    g.!PREV.aid = lastaid\n  end\n  g.!LASTATTR.id = aid\nreturn\n\n/*-------------------------------------------------------------------*\n * Resolve attributes to an internal normalized form:\n *   name1=value1'ff'x name2=value2'ff'x ...\n * This makes subsequent parsing of attributes easier.\n * Note: this design may fail for certain UTF-8 content\n *-------------------------------------------------------------------*/\n\n_getNormalizedAttributes: procedure expose g.\n  parse arg sAttrs\n  g.!ATTRSOK = 0\n  sNormalAttrs = ''\n  parse var sAttrs sAttr'='sAttrs\n  do while sAttr <> ''\n    sAttr = removeWhitespace(sAttr)\n    select\n      when left(sAttrs,1) = '\"' then do\n        if pos('\"',sAttrs,2) = 0 /* if no closing \"   */\n        then return ''           /* then not ok       */\n        parse var sAttrs '\"'sAttrValue'\"'sAttrs\n      end\n      when left(sAttrs,1) = \"'\" then do\n        if pos(\"'\",sAttrs,2) = 0 /* if no closing '   */\n        then return ''           /* then not ok       */\n        parse var sAttrs \"'\"sAttrValue\"'\"sAttrs\n      end\n      otherwise return ''        /* no opening ' or \" */\n    end\n    sAttrValue = removeWhitespace(sAttrValue)\n    sNormalAttrs = sNormalAttrs sAttr'='sAttrValue'ff'x\n    parse var sAttrs sAttr'='sAttrs\n  end\n  g.!ATTRSOK = 1\n  /* Note: always returns a leading blank and is required by\n    this implementation */\nreturn _resolveEntities(sNormalAttrs)\n\n\n/*-------------------------------------------------------------------*\n *  entityref  := '&' entityname ';'\n *  entityname := ('_',':',letter) (letter,digit,'.','-','_',':')*\n *-------------------------------------------------------------------*/\n\n\n_resolveEntities: procedure expose g.\n  parse arg sText\n  if pos('&',sText) > 0\n  then do\n    sNewText = ''\n    do while pos('&',sText) > 0\n      parse var sText sLeft'&'sEntityRef\n      if pos(left(sEntityRef,1),'#'g.!LEADERS) > 0\n      then do\n        n = verify(sEntityRef,g.!OTHERS,'NOMATCH',2)\n        if n > 1\n        then do\n          if substr(sEntityRef,n,1) = ';'\n          then do\n            sEntityName = left(sEntityRef,n-1)\n            sEntity = _getEntity(sEntityName)\n            sNewText = sNewText || sLeft || sEntity\n            sText = substr(sEntityRef,n+1)\n          end\n          else do\n            sNewText = sNewText || sLeft'&'\n            sText = sEntityRef\n          end\n        end\n        else do\n          sNewText = sNewText || sLeft'&'\n          sText = sEntityRef\n        end\n      end\n      else do\n        sNewText = sNewText || sLeft'&'\n        sText = sEntityRef\n      end\n    end\n    sText = sNewText || sText\n  end\nreturn sText\n\n/*-------------------------------------------------------------------*\n * &entityname;\n * &#nnnnn;\n * &#xXXXX;\n *-------------------------------------------------------------------*/\n\n_getEntity: procedure expose g.\n  parse arg sEntityName\n  if left(sEntityName,1) = '#' /* #nnnnn  OR  #xXXXX */\n  then sEntity = _getCharacterEntity(sEntityName)\n  else sEntity = _getStringEntity(sEntityName)\nreturn sEntity\n\n/*-------------------------------------------------------------------*\n * &#nnnnn;\n * &#xXXXX;\n *-------------------------------------------------------------------*/\n\n_getCharacterEntity: procedure expose g.\n  parse arg sEntityName\n  if substr(sEntityName,2,1) = 'x'\n  then do\n    parse arg 3 xEntity\n    if datatype(xEntity,'XADECIMAL')\n    then sEntity = x2c(xEntity)\n    else call _abort,\n              'XML010E Invalid hexadecimal character reference: ',\n              '&'sEntityName';'\n  end\n  else do\n    parse arg 2 nEntity\n    if datatype(nEntity,'WHOLE')\n    then sEntity = d2c(nEntity)\n    else call _abort,\n              'XML011E Invalid decimal character reference:',\n              '&'sEntityName';'\n  end\nreturn sEntity\n\n/*-------------------------------------------------------------------*\n * &entityname;\n *-------------------------------------------------------------------*/\n\n_getStringEntity: procedure expose g.\n  parse arg sEntityName\n  if wordpos(sEntityName,g.!ENTITIES) = 0\n  then call _abort 'XML012E Unable to resolve entity &'sEntityName';'\n  sEntity = g.!ENTITY.sEntityName\nreturn sEntity\n\n_setDefaultEntities: procedure expose g.\n  g.!ENTITIES = ''\n  g.!ESCAPES = '<>&\"' || \"'\"\n  sEscapes = 'lt gt amp quot apos'\n  do i = 1 to length(g.!ESCAPES)\n    c = substr(g.!ESCAPES,i,1)\n    g.!ESCAPE.c = word(sEscapes,i)\n  end\n  call _setEntity 'amp','&'\n  call _setEntity 'lt','<'\n  call _setEntity 'gt','>'\n  call _setEntity 'apos',\"'\"\n  call _setEntity 'quot','\"'\nreturn\n\n_setEntity: procedure expose g.\n  parse arg sEntityName,sValue\n  if wordpos(sEntityName,g.!ENTITIES) = 0\n  then g.!ENTITIES = g.!ENTITIES sEntityName\n  g.!ENTITY.sEntityName = sValue\nreturn\n\n_setProcessingInstruction: procedure expose g.\n  parse arg sTarget sInstruction\n  if wordpos(sTarget,g.!PI) = 0\n  then g.!PI = g.!PI sTarget\n  g.!PI.sTarget = strip(sInstruction)\nreturn\n\n_abort: procedure expose g.\n  parse arg sMsg\n  say 'ABORT:' sMsg\n  call destroyParser\nexit 16\n\n_clearNode: procedure expose g.\n  parse arg id\n  g.!NAME.id       = '' /* The node's name */\n  g.!PARENT.id     = '' /* The node's parent */\n  g.!FIRST.id      = '' /* The node's first child */\n  g.!LAST.id       = '' /* The node's last child */\n  g.!NEXT.id       = '' /* The node's next sibling */\n  g.!PREV.id       = '' /* The node's previous sibling */\n  g.!TEXT.id       = '' /* The node's text content */\n  g.!TYPE.id       = '' /* The node's type */\n  g.!FIRSTATTR.id  = '' /* The node's first attribute */\n  g.!LASTATTR.id   = '' /* The node's last attribute */\nreturn\n\n/*-------------------------------------------------------------------*\n * Utility API\n *-------------------------------------------------------------------*/\n\nremoveWhitespace: procedure expose g.\n  parse arg sData\nreturn space(translate(sData,'',g.!WHITESPACE))\n\nremoveQuotes: procedure expose g.\n  parse arg sValue\n  c = left(sValue,1)\n  select\n    when c = '\"' then parse var sValue '\"'sValue'\"'\n    when c = \"'\" then parse var sValue \"'\"sValue\"'\"\n    otherwise nop\n  end\nreturn sValue\n\n/*-------------------------------------------------------------------*\n * Document Object Model ;-) API\n *-------------------------------------------------------------------*/\n\ngetRoot: procedure expose g. /* DEPRECATED */\nreturn 1\n\ngetDocumentElement: procedure expose g.\nreturn 1\n\ngetName: getNodeName: procedure expose g.\n  parse arg id\nreturn g.!NAME.id\n\ngetText: getNodeValue: procedure expose g.\n  parse arg id\nreturn g.!TEXT.id\n\ngetNodeType: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id\n\nisElementNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!ELEMENT_NODE\n\nisTextNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!TEXT_NODE\n\nisCommentNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!COMMENT_NODE\n\nisCDATA: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!CDATA_SECTION_NODE\n\nisDocumentNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!DOCUMENT_NODE\n\nisDocumentFragmentNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!DOCUMENT_FRAGMENT_NODE\n\n/**\n * This is similar to the DOM API's NamedNodeMap concept, except that\n * the returned structure is built in global variables (so calling\n * it a second time will destroy the structure built on the first\n * call). The other difference is that you can access the attributes\n * by name or ordinal number. For example, g.!ATTRIBUTE.2 is the value\n * of the second attribute. If the second attribute was called 'x',\n * then you could also access it by g.!ATTRIBUTE.x (as long as x='x')\n * Note, g.!ATTRIBUTE.0 will always contain a count of the number of\n * attributes in the map.\n */\ngetAttributeMap: procedure expose g.\n  parse arg id\n  if datatype(g.!ATTRIBUTE.0,'WHOLE')  /* clear any existing map */\n  then do\n    do i = 1 to g.!ATTRIBUTE.0\n      sName = g.!ATTRIBUTE.i\n      drop g.!ATTRIBUTE.sName g.!ATTRIBUTE.i\n    end\n  end\n  g.!ATTRIBUTE.0 = 0\n  if \\_canHaveAttributes(id) then return\n  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n  do i = 1 while aid <> ''\n    sName = g.!NAME.aid\n    sValue = g.!TEXT.aid\n    g.!ATTRIBUTE.0 = i\n    g.!ATTRIBUTE.i = sName\n    g.!ATTRIBUTE.sName = sValue\n    aid = g.!NEXT.aid /* id of next attribute */\n  end\nreturn\n\ngetAttributeCount: procedure expose g.\n  parse arg id\n  nAttributeCount = 0\n  if _canHaveAttributes(id)\n  then do\n    aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n    do while aid <> ''\n      nAttributeCount = nAttributeCount + 1\n      aid = g.!NEXT.aid /* id of next attribute */\n    end\n  end\nreturn nAttributeCount\n\ngetAttributeNames: procedure expose g.\n  parse arg id\n  sNames = ''\n  if _canHaveAttributes(id)\n  then do\n    aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n    do while aid <> ''\n      sNames = sNames g.!NAME.aid\n      aid = g.!NEXT.aid /* id of next attribute */\n    end\n  end\nreturn strip(sNames)\n\ngetAttribute: procedure expose g.\n  parse arg id,sAttrName\n  sValue = ''\n  if _canHaveAttributes(id)\n  then do\n    aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n    if aid <> ''\n    then do\n      n = 1\n      do while aid <> '' & (g.!NAME.aid <> sAttrName & n <> sAttrName)\n        aid = g.!NEXT.aid\n        n = n + 1\n      end\n      if g.!NAME.aid = sAttrName | n = sAttrName\n      then sValue = g.!TEXT.aid\n    end\n  end\nreturn sValue\n\ngetAttributeName: procedure expose g.\n  parse arg id,n\n  sName = ''\n  if _canHaveAttributes(id)\n  then do\n    aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n    if aid <> ''\n    then do\n      do i = 1 while aid <> '' & i < n\n        aid = g.!NEXT.aid\n      end\n      if i = n then sName = g.!NAME.aid\n    end\n  end\nreturn sName\n\nhasAttribute: procedure expose g.\n  parse arg id,sAttrName\n  bHasAttribute = 0\n  if _canHaveAttributes(id)\n  then do\n    aid = g.!FIRSTATTR.id\n    if aid <> ''\n    then do\n      do while aid <> '' & g.!NAME.aid <> sAttrName\n        aid = g.!NEXT.aid\n      end\n      bHasAttribute = g.!NAME.aid = sAttrName\n    end\n  end\nreturn bHasAttribute\n\n_canHaveAttributes: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!ELEMENT_NODE |,\n       g.!TYPE.id = g.!DOCUMENT_NODE |,\n       g.!TYPE.id = g.!DOCUMENT_FRAGMENT_NODE\n\n_canHaveChildren: procedure expose g.\n  parse arg id\nreturn g.!TYPE.parent <> g.!ELEMENT_NODE &,\n       g.!TYPE.parent <> g.!DOCUMENT_NODE &,\n       g.!TYPE.parent <> g.!DOCUMENT_FRAGMENT_NODE\n\ngetParent: getParentNode: procedure expose g.\n  parse arg id\nreturn g.!PARENT.id\n\ngetFirstChild: procedure expose g.\n  parse arg id\nreturn g.!FIRST.id\n\ngetLastChild: procedure expose g.\n  parse arg id\nreturn g.!LAST.id\n\ngetChildren: getChildNodes: procedure expose g.\n  parse arg id\n  ids = ''\n  id = getFirstChild(id)\n  do while id <> ''\n    ids = ids id\n    id = getNextSibling(id)\n  end\nreturn strip(ids)\n\ngetChildrenByName: procedure expose g.\n  parse arg id,sName\n  ids = ''\n  id = getFirstChild(id)\n  do while id <> ''\n    if getName(id) = sName\n    then ids = ids id\n    id = getNextSibling(id)\n  end\nreturn strip(ids)\n\ngetElementsByTagName: procedure expose g.\n  parse arg id,sName\n  ids = ''\n  id = getFirstChild(id)\n  do while id <> ''\n    if getName(id) = sName\n    then ids = ids id\n    ids = ids getElementsByTagName(id,sName)\n    id = getNextSibling(id)\n  end\nreturn space(ids)\n\ngetNextSibling: procedure expose g.\n  parse arg id\nreturn g.!NEXT.id\n\ngetPreviousSibling: procedure expose g.\n  parse arg id\nreturn g.!PREV.id\n\ngetProcessingInstruction: procedure expose g.\n  parse arg sTarget\nreturn g.!PI.sTarget\n\ngetProcessingInstructionList: procedure expose g.\nreturn g.!PI\n\nhasChildren: hasChildNodes: procedure expose g.\n  parse arg id\nreturn g.!FIRST.id <> ''\n\ncreateDocument: procedure expose g.\n  parse arg sName\n  if sName = ''\n  then call _abort,\n            'XML013E Tag name omitted:',\n            'createDocument('sName')'\n  call destroyParser\n  g.!NEXTID = 0\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!DOCUMENT_NODE /* 20070323 */\n  g.!NAME.id = sName\n  g.!PARENT.id = 0\nreturn id\n\ncreateDocumentFragment: procedure expose g. /* 20070323 */\n  parse arg sName\n  if sName = ''\n  then call _abort,\n            'XML014E Tag name omitted:',\n            'createDocumentFragment('sName')'\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!DOCUMENT_FRAGMENT_NODE\n  g.!NAME.id = sName\n  g.!PARENT.id = 0\nreturn id\n\ncreateElement: procedure expose g.\n  parse arg sName\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!ELEMENT_NODE\n  g.!NAME.id = sName\nreturn id\n\ncreateCDATASection: procedure expose g.\n  parse arg sCharacterData\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!CDATA_SECTION_NODE\n  g.!TEXT.id = sCharacterData\nreturn id\n\ncreateTextNode: procedure expose g.\n  parse arg sData\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!TEXT_NODE\n  g.!TEXT.id = sData\nreturn id\n\nappendChild: procedure expose g.\n  parse arg id, parent\n  if \\_canHaveChildren(parent)\n  then call _abort,\n            'XML015E' g.!NODETYPE.parent 'node cannot have children:',\n            'appendChild('id','parent')'\n  if g.!PARENT.id = ''\n  then g.!PARENT.id = parent\n  else call _abort,\n            'XML016E Node <'getNodeName(id)'> is already a child',\n            'of <'getNodeName(g.!PARENT.id)'>:',\n            'appendChild('id','parent')'\n  parentsLastChild = g.!LAST.parent\n  g.!NEXT.parentsLastChild = id\n  g.!PREV.id = parentsLastChild\n  g.!LAST.parent = id\n  if g.!FIRST.parent = ''\n  then g.!FIRST.parent = id\nreturn\n\ninsertBefore: procedure expose g.\n  parse arg id, ref\n  parent = g.!PARENT.ref\n  if \\_canHaveChildren(parent)\n  then call _abort,\n            'XML017E' g.!NODETYPE.parent 'node cannot have children:',\n            'insertBefore('id','ref')'\n  if g.!PARENT.id = ''\n  then g.!PARENT.id = parent\n  else call _abort,\n            'XML018E Node <'getNodeName(id)'> is already a child',\n            'of <'getNodeName(g.!PARENT.id)'>:',\n            'insertBefore('id','ref')'\n  g.!NEXT.id = ref\n  g.!PREV.ref = id\n  if g.!FIRST.parent = ref\n  then g.!FIRST.parent = id\nreturn\n\nremoveChild: procedure expose g.\n  parse arg id\n  parent = g.!PARENT.id\n  if \\_canHaveChildren(parent)\n  then call _abort,\n            'XML019E' g.!NODETYPE.parent 'node cannot have children:',\n            'removeChild('id')'\n  next = g.!NEXT.id\n  prev = g.!PREV.id\n  g.!NEXT.prev = next\n  g.!PREV.next = prev\n  if g.!FIRST.parent = id\n  then g.!FIRST.parent = next\n  if g.!LAST.parent = id\n  then g.!LAST.parent = prev\n  g.!PARENT.id = ''\n  g.!NEXT.id = ''\n  g.!PREV.id = ''\nreturn id\n\nreplaceChild: procedure expose g.\n  parse arg id, extant\n  parent = g.!PARENT.extant\n  if \\_canHaveChildren(parent)\n  then call _abort,\n            'XML020E' g.!NODETYPE.parent 'node cannot have children:',\n            'replaceChild('id','extant')'\n  g.!PARENT.id = parent\n  g.!NEXT.id = g.!NEXT.extant\n  g.!PREV.id = g.!PREV.extant\n  if g.!FIRST.parent = extant\n  then g.!FIRST.parent = id\n  if g.!LAST.parent = extant\n  then g.!LAST.parent = id\n  g.!PARENT.extant = ''\n  g.!NEXT.extant = ''\n  g.!PREV.extant = ''\nreturn extant\n\nsetAttribute: procedure expose g.\n  parse arg id,sAttrName,sValue\n  if \\_canHaveAttributes(id)\n  then call _abort,\n            'XML021E' g.!NODETYPE.id 'node cannot have attributes:',\n            'setAttribute('id','sAttrName','sValue')'\n  aid = g.!FIRSTATTR.id\n  do while aid <> '' & g.!NAME.aid <> sAttrName\n    aid = g.!NEXT.aid\n  end\n  if aid <> '' & g.!NAME.aid = sAttrName\n  then g.!TEXT.aid = sValue\n  else call _addAttribute id,sAttrName,sValue\nreturn\n\nsetAttributes: procedure expose g.\n  parse arg id /* ,name1,value1,name2,value2,...,namen,valuen */\n  do i = 2 to arg() by 2\n    sAttrName = arg(i)\n    sValue = arg(i+1)\n    call setAttribute id,sAttrName,sValue\n  end\nreturn\n\nremoveAttribute: procedure expose g.\n  parse arg id,sAttrName\n  if \\_canHaveAttributes(id)\n  then call _abort,\n            'XML022E' g.!NODETYPE.id 'node cannot have attributes:',\n            'removeAttribute('id','sAttrName')'\n  aid = g.!FIRSTATTR.id\n  do while aid <> '' & g.!NAME.aid <> sAttrName\n    aid = g.!NEXT.aid\n  end\n  if aid <> '' & g.!NAME.aid = sAttrName\n  then do\n    prevaid = g.!PREV.aid\n    nextaid = g.!NEXT.aid\n    if prevaid = ''  /* if we are deleting the first attribute */\n    then g.!FIRSTATTR.id = nextaid /* make next attr the first */\n    else g.!NEXT.prevaid = nextaid /* link prev attr to next attr */\n    if nextaid = '' /* if we are deleting the last attribute */\n    then g.!LASTATTR.id  = prevaid /* make prev attr the last */\n    else g.!PREV.nextaid = prevaid /* link next attr to prev attr */\n    call _clearNode aid\n  end\nreturn\n\ntoString: procedure expose g.\n  parse arg node\n  if node = '' then node = getRoot()\n  if node = getRoot()\n  then sXML = _getProlog()_getNode(node)\n  else sXML = _getNode(node)\nreturn sXML\n\n_getProlog: procedure expose g.\n  if g.?xml.version = ''\n  then sVersion = '1.0'\n  else sVersion = g.?xml.version\n  if g.?xml.encoding = ''\n  then sEncoding = 'UTF-8'\n  else sEncoding = g.?xml.encoding\n  if g.?xml.standalone = ''\n  then sStandalone = 'yes'\n  else sStandalone = g.?xml.standalone\n  sProlog = '<?xml version=\"'sVersion'\"',\n            'encoding=\"'sEncoding'\"',\n            'standalone=\"'sStandalone'\"?>'\nreturn sProlog\n\n_getNode: procedure expose g.\n  parse arg node\n  select\n    when g.!TYPE.node = g.!ELEMENT_NODE then,\n         sXML = _getElementNode(node)\n    when g.!TYPE.node = g.!TEXT_NODE then,\n         sXML = escapeText(removeWhitespace(getText(node)))\n    when g.!TYPE.node = g.!ATTRIBUTE_NODE then,\n         sXML = getName(node)'=\"'escapeText(getText(node))'\"'\n    when g.!TYPE.node = g.!CDATA_SECTION_NODE then,\n         sXML = '<![CDATA['getText(node)']]>'\n    otherwise sXML = '' /* TODO: throw an error here? */\n  end\nreturn sXML\n\n_getElementNode: procedure expose g.\n  parse arg node\n  sName = getName(node)\n  sAttrs = ''\n  attr = g.!FIRSTATTR.node\n  do while attr <> ''\n    sAttrs = sAttrs _getNode(attr)\n    attr = g.!NEXT.attr\n  end\n  if hasChildren(node)\n  then do\n    if sAttrs = ''\n    then sXML = '<'sName'>'\n    else sXML = '<'sName strip(sAttrs)'>'\n    child = getFirstChild(node)\n    do while child <> ''\n      sXML = sXML || _getNode(child)\n      child = getNextSibling(child)\n    end\n    sXML = sXML'</'sName'>'\n  end\n  else do\n    if sAttrs = ''\n    then sXML = '<'sName'/>'\n    else sXML = '<'sName strip(sAttrs)'/>'\n  end\nreturn sXML\n\nescapeText: procedure expose g.\n  parse arg sText\n  n = verify(sText,g.!ESCAPES,'MATCH')\n  if n > 0\n  then do\n    sNewText = ''\n    do while n > 0\n      sLeft = ''\n      n = n - 1\n      if n = 0\n      then parse var sText c +1 sText\n      else parse var sText sLeft +(n) c +1 sText\n      sNewText = sNewText || sLeft'&'g.!ESCAPE.c';'\n      n = verify(sText,g.!ESCAPES,'MATCH')\n    end\n    sText = sNewText || sText\n  end\nreturn sText\n\n/*-------------------------------------------------------------------*\n * SYSTEM \"sysid\"\n * PUBLIC \"pubid\" \"sysid\"\n *-------------------------------------------------------------------*/\nsetDocType: procedure expose g.\n  parse arg sDocType\n  g.!DOCTYPE = sDocType\nreturn\n\ngetDocType: procedure expose g.\nreturn g.!DOCTYPE\n\ncreateComment: procedure expose g.\n  parse arg sData\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!COMMENT_NODE\n  g.!TEXT.id = sData\nreturn id\n\ndeepClone: procedure expose g.\n  parse arg node\nreturn cloneNode(node,1)\n\ncloneNode: procedure expose g.\n  parse arg node,bDeep\n  clone = _getNextId()\n  call _clearNode clone\n  g.!TYPE.clone = g.!TYPE.node\n  g.!NAME.clone = g.!NAME.node\n  g.!TEXT.clone = g.!TEXT.node\n  /* clone any attributes...*/\n  aidin = g.!FIRSTATTR.node\n  do while aidin <> ''\n    aid = _getNextId()\n    g.!TYPE.aid = g.!TYPE.aidin\n    g.!NAME.aid = g.!NAME.aidin\n    g.!TEXT.aid = g.!TEXT.aidin\n    g.!PARENT.aid = clone\n    g.!NEXT.aid = ''\n    g.!PREV.aid = ''\n    if g.!FIRSTATTR.clone = '' then g.!FIRSTATTR.clone = aid\n    if g.!LASTATTR.clone <> ''\n    then do\n      lastaid = g.!LASTATTR.clone\n      g.!NEXT.lastaid = aid\n      g.!PREV.aid = lastaid\n    end\n    g.!LASTATTR.clone = aid\n    aidin = g.!NEXT.aidin\n  end\n  /* clone any children (if deep clone was requested)...*/\n  if bDeep = 1\n  then do\n    childin = g.!FIRST.node /* first child of node being cloned */\n    do while childin <> ''\n      child = cloneNode(childin,bDeep)\n      g.!PARENT.child = clone\n      parentsLastChild = g.!LAST.clone\n      g.!NEXT.parentsLastChild = child\n      g.!PREV.child = parentsLastChild\n      g.!LAST.clone = child\n      if g.!FIRST.clone = ''\n      then g.!FIRST.clone = child\n      childin = g.!NEXT.childin /* next child of node being cloned */\n    end\n  end\nreturn clone\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRETTY": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00\\xea\\x00\\xe1\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 234, "newlines": 225, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: pretty.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - PRETTY                                                 **\n**                                                                   **\n** FUNCTION - Pretty printer. This demonstrates the XML parser by    **\n**            reformatting an xml input file.                        **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - pretty infile [outfile] (options...)                   **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = Name of file to be parsed                   **\n**            outfile  = Name of file to store the pretty output in. **\n**                       The default is the console.                 **\n**            options  = NOBLANKS - Suppress whitespace-only nodes   **\n**                       DEBUG    - Display some debugging info      **\n**                       DUMP     - Display the parse tree           **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. You will have to either append the PARSEXML source  **\n**               manually to this demo source, or run this demo      **\n**               source through the REXXPP rexx pre-processor.       **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               rexxpp pretty prettypp                              **\n**                                                                   **\n**               ...and then run the resulting rexx procedure over   **\n**               an XML file of your choice:                         **\n**                                                                   **\n**               prettypp testxml [outxml]                           **\n**                ...or...                                           **\n**               prettypp testxml [outxml] (noblanks                 **\n**                ...or...                                           **\n**               prettypp testxml [outxml] (noblanks dump            **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com     **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --------------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20050920 AJA Allow root node to be specified.          **\n**            20050907 AJA Escape text of attribute values.          **\n**            20040706 AJA Assume default indentation amount.        **\n**                         Allow output to a file.                   **\n**            20031031 AJA Fix escaping text.                        **\n**            20030911 AJA Removed default filename value. You       **\n**                         must specify your own filename.           **\n**            20030905 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n  parse value sourceline(1) with . sVersion\n  say 'PRP000I Pretty Printer' sVersion\n\n  /* Initialise the parser */\n  call initParser sOptions /* <-- This is in PARSEXML rexx */\n\n  /* Open the specified file and parse it */\n  nParseRC = parseFile(sFileIn)\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call prettyPrinter sFileOut,2 /* 2 is the indentation amount */\n\nexit nParseRC\n\n/*-------------------------------------------------------------------*\n * An example of how to navigate the tree\n *-------------------------------------------------------------------*/\n\nprettyPrinter: procedure expose g.\n  parse arg sFileOut,g.!TAB,nRoot\n  if g.!TAB = '' then g.!TAB = 2 /* indentation amount */\n  if nRoot = '' then nRoot = getRoot()\n  g.!INDENT = 0\n  g.!FILEOUT = ''\n  if sFileOut <> ''\n  then do\n    g.!FILEOUT = openFile(sFileOut,'OUTPUT')\n    if g.!rc = 0\n    then say 'PRP001I Creating' sFileOut\n    else do\n      say 'PRP002E Could not create' sFileOut'. Writing to console...'\n      g.!FILEOUT = '' /* null handle means write to console */\n    end\n  end\n\n  call _setDefaultEntities\n\n  call emitProlog\n  g.!INDENT = -g.!TAB\n  call showNode nRoot\n\n  if g.!FILEOUT <> ''\n  then do\n    say 'PRP002I Created' sFileOut\n    rc = closeFile(g.!FILEOUT)\n  end\nreturn\n\n\nemitProlog: procedure expose g.\n  if g.?xml.version = ''\n  then sVersion = '1.0'\n  else sVersion = g.?xml.version\n  if g.?xml.encoding = ''\n  then sEncoding = 'UTF-8'\n  else sEncoding = g.?xml.encoding\n  if g.?xml.standalone = ''\n  then sStandalone = 'yes'\n  else sStandalone = g.?xml.standalone\n\n  g.!INDENT = 0\n  call Say '<?xml version=\"'sVersion'\"',\n                'encoding=\"'sEncoding'\"',\n              'standalone=\"'sStandalone'\"?>'\n\n  sDocType = getDocType()\n  if sDocType <> ''\n  then call Say '<!DOCTYPE' getName(getDocumentElement()) sDocType'>'\nreturn\n\nshowNode: procedure expose g.\n  parse arg node\n  g.!INDENT = g.!INDENT + g.!TAB\n  select\n    when isTextNode(node)    then call emitTextNode    node\n    when isCommentNode(node) then call emitCommentNode node\n    when isCDATA(node)       then call emitCDATA       node\n    otherwise                     call emitElementNode node\n  end\n  g.!INDENT = g.!INDENT - g.!TAB\nreturn\n\nsetPreserveWhitespace: procedure expose g.\n  parse arg bPreserve\n  g.!PRESERVEWS = bPreserve = 1\nreturn\n\nemitTextNode: procedure expose g.\n  parse arg node\n  if g.!PRESERVEWS = 1\n  then call Say escapeText(getText(node))\n  else call Say escapeText(removeWhitespace(getText(node)))\nreturn\n\nemitCommentNode: procedure expose g.\n  parse arg node\n  call Say '<!--'getText(node)' -->'\nreturn\n\nemitCDATA: procedure expose g.\n  parse arg node\n  call Say '<![CDATA['getText(node)']]>'\nreturn\n\nemitElementNode: procedure expose g.\n  parse arg node\n  sName = getName(node)\n  sAttrs = ''\n  do i = 1 to getAttributeCount(node)\n    sAttrs = sAttrs getAttributeName(node,i)'=\"' ||,\n                    escapeText(getAttribute(node,i))'\"'\n  end\n  sChildren = getChildren(node)\n  if sChildren = ''\n  then do\n    if sAttrs = ''\n    then call Say '<'sName'/>'\n    else call Say '<'sName strip(sAttrs)'/>'\n  end\n  else do\n    if sAttrs = ''\n    then call Say '<'sName'>'\n    else call Say '<'sName strip(sAttrs)'>'\n    child = getFirstChild(node)\n    do while child <> ''\n      call showNode child\n      child = getNextSibling(child)\n    end\n    call Say '</'sName'>'\n  end\nreturn\n\nSay: procedure expose g.\n  parse arg sMessage\n  sLine = copies(' ',g.!INDENT)sMessage\n  if g.!FILEOUT = ''\n  then say sLine\n  else call putLine g.!FILEOUT,sLine\nreturn\n\n/*INCLUDE io.rex */\n/*INCLUDE parsexml.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXPP": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x01\\xbc\\x01H\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 444, "newlines": 328, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: rexxpp.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - REXXPP                                                 **\n**                                                                   **\n** FUNCTION - Rexx INCLUDE pre-processor.  This rexx will read the   **\n**            specified filename looking for /*INCLUDE file */       **\n**            directives. For each INCLUDE found, it will append     **\n**            the content of the specified file to the output file.  **\n**                                                                   **\n**            The start and end of the included content is marked by **\n**            /*INCLUDED file */ and /*INCLUDEZ file */ lines. Remove**\n**            these markers at your peril, because they allow REXXPP **\n**            to intelligently handle a file that has already been   **\n**            pre-processed.                                         **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - REXXPP filein fileout                                  **\n**                                                                   **\n**            Where,                                                 **\n**            filein   = Name of the file to pre-process.            **\n**            fileout  = Name of the file to contain the resulting   **\n**                       output. On TSO, the default for fileout is  **\n**                       filein. On Windows there is no default.     **\n**                                                                   **\n** EXAMPLE  - 1. If file1 contains:                                  **\n**              say \"it's goodnight from me...\"                      **\n**            /*INCLUDE file2 */  /* <-- Note: starts in column 1 */ **\n**            exit                                                   **\n**                                                                   **\n**            2. And file2 contains:                                 **\n**              say \"...and it's goodnight from him\"                 **\n**                                                                   **\n**            3. And you run: rexxpp file1 file3                     **\n**                                                                   **\n**            4. Then file3 will contain:                            **\n**              say \"it's goodnight from me...\"                      **\n**            /*INCLUDED file2 */                                    **\n**              say \"...and it's goodnight from him\"                 **\n**            /*INCLUDEZ file2 */                                    **\n**            exit                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --------------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20060505 AJA Prompt user for missing file names.       **\n**            20050601 AJA Ensure each file included only once.      **\n**            20050518 AJA Default fileout is filein (TSO only).     **\n**            20031217 AJA Allow output to be re-processed.          **\n**            20030912 AJA Use stream() to close win32 file.         **\n**            20030904 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n  parse source g.!SYSTEM .\n  if g.!SYSTEM = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n    if sFileOut = ''\n    then sFileOut = sFileIn /* you can do this on TSO but not Windows*/\n  end\n  g.!LEVEL = 0\n  parse value sourceline(1) with . sVersion\n  call Say 'RPP000I Rexx INCLUDE Pre-processor' sVersion\n  call Say 'RPP001I Output file is:' sFileOut\n  sFileOut = getFile(sFileOut,'OUTPUT')\n  hFileOut = g.!hFile\n  if g.!rc = 0\n  then do\n    call Say 'RPP001I Input file is:' sFileIn\n    sFileIn = getFile(sFileIn)\n    hFileIn = g.!hFile\n    call includeFile sFileIn,hFileIn,hFileOut\n  end\n  else call Say 'RPP003E Could not create file:' sFileOut\n  call Say 'RRP004I Done.'\n  rc = closeFile(hFileOut)\nexit\n\n/*-------------------------------------------------------------------*\n * Display an indented message\n *-------------------------------------------------------------------*/\n\nSay: procedure expose g.\n  parse arg sMessage\n  say copies(' ',g.!LEVEL)sMessage\nreturn\n\n/*-------------------------------------------------------------------*\n * Open the file, or one nominated by the user\n *-------------------------------------------------------------------*/\n\ngetFile: procedure expose g.\n  parse arg sFile,sMode\n  if sFile <> ''\n  then do\n    sFile = strip(sFile)\n    g.!hFile = openFile(sFile,sMode)\n    do while g.!rc <> 0 & sFile <> ''\n      call Say 'RPP006E Could not open file:' sFile\n      call Say 'RPP007A Enter full path to file:' sFile\n      parse pull sFile\n      if sFile <> ''\n      then g.!hFile = openFile(sFile,sMode)\n    end\n  end\nreturn sFile\n\n/*-------------------------------------------------------------------*\n * Recursively include files specified by 'INCLUDE' tags\n *-------------------------------------------------------------------*/\n\nincludeFile: procedure expose g.\n  parse arg sFile,hFileIn,hFileOut\n  if sFile = '' then return\n  g.!LEVEL = g.!LEVEL + 2\n  if g.!INCLUDED.sFile = 1                               /* 20050601 */\n  then call Say 'RPP005I Already included file:' sFile   /* 20050601 */\n  else do                                                /* 20050601 */\n    g.!INCLUDED.sFile = 1                                /* 20050601 */\n    call Say 'RPP002I Including file:' sFile\n    sLine = getLine(hFileIn)\n    do while g.!rc = 0\n      select\n        when left(sLine,10) = '/*INCLUDE '\n        then do\n          parse var sLine '/*INCLUDE' sFile '*/'\n          call include sFile,hFileOut\n        end\n        when left(sLine,11) = '/*INCLUDED '\n        then do\n          parse var sLine '/*INCLUDED' sFile '*/'\n          call exclude sFile,hFileIn\n          call include sFile,hFileOut\n        end\n        otherwise g.!rc = putLine(hFileOut,sLine)\n      end\n      sLine = getLine(hFileIn)\n    end\n    rc = closeFile(hFileIn)\n    call Say 'RRP004I Done.'\n  end\n  g.!LEVEL = g.!LEVEL - 2\nreturn\n\n/*-------------------------------------------------------------------*\n * Append the specified file to the output file\n *-------------------------------------------------------------------*/\n\ninclude: procedure expose g.\n  parse arg sFile,hFileOut\n  sFile = strip(sFile)\n  sFile = getFile(sFile) /* open it, else ask user */\n  hFileIn = g.!hFile\n  if g.!rc = 0\n  then do\n    g.!rc = putLine(hFileOut,'/*INCLUDED' sFile '*/')\n    call includeFile sFile,hFileIn,hFileOut\n    g.!rc = putLine(hFileOut,'/*INCLUDEZ' sFile '*/')\n  end\nreturn\n\n/*-------------------------------------------------------------------*\n * Skip over the specified file in the input file\n *-------------------------------------------------------------------*/\n\nexclude: procedure expose g.\n  parse arg sFile,hFileIn\n  sFile = strip(sFile)\n  do until sFile = sFileIncluded | g.!rc <> 0\n    sLine = getLine(hFileIn)\n    if left(sLine,11) = '/*INCLUDEZ '\n    then parse var sLine '/*INCLUDEZ' sFileIncluded '*/'\n  end\nreturn\n\n/*REXX 2.0.0.1\n\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - IO                                                     **\n**                                                                   **\n** FUNCTION - Simple I/O routines.                                   **\n**                                                                   **\n** API      - The routines in this module are:                       **\n**                                                                   **\n**            openFile(filename,options,attrs)                       **\n**                Opens the specified file with the specified options**\n**                and returns a file handle to be used in other I/O  **\n**                operations. By default the file will be opened for **\n**                input. Specify 'OUTPUT' to open it for output.     **\n**                For TSO, you can specify any operand of the TSO    **\n**                ALLOCATE command in the third operand. For example:**\n**                rc = openFile('MY.FILE','OUTPUT','RECFM(F,B)'      **\n**                              'LRECL(80) BLKSIZE(27920)')          **\n**                                                                   **\n**            closeFile(handle)                                      **\n**                Closes the file specified by 'handle' (which was   **\n**                returned by the openFile() routine.                **\n**                                                                   **\n**            getLine(handle)                                        **\n**                Reads the next line from the file specified by     **\n**                'handle'.                                          **\n**                                                                   **\n**            putLine(handle,data)                                   **\n**                Appends the specified data to the file specified   **\n**                by 'handle'.                                       **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --------------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20061017 AJA Added support for UNIX environment.       **\n**                         Tested on Ubuntu Linux 6.06 LTS.          **\n**            20050930 AJA Initial version.                          **\n**                                                                   **\n**********************************************************************/\n\n  parse source . . sSourceFile .\n  parse value sourceline(1) with . sVersion .\n  say 'Simple Rexx I/O routines' sVersion\n  say 'You cannot invoke this rexx by itself!'\n  say\n  say 'This rexx is a collection of subroutines to be called'\n  say 'from your own rexx procedures. You should either:'\n  say '  - Append this procedure to your own rexx procedure,'\n  say '    or,'\n  say '  - Append the following line to your rexx:'\n  say '    /* INCLUDE' sSourceFile '*/'\n  say '    ...and run the rexx preprocessor:'\n  say '    rexxpp myrexx myrexxpp'\n  say '    This will create myrexxpp by appending this file to myrexx'\nexit\n\n/*-------------------------------------------------------------------*\n * Open a file\n *-------------------------------------------------------------------*/\n\nopenFile: procedure expose g.\n  parse arg sFile,sOptions,sAttrs\n  hFile = ''\n  select\n    when g.!ENV = 'TSO' then do\n      bOutput = wordpos('OUTPUT',sOptions) > 0\n      bQuoted = left(sFile,1) = \"'\"\n      if bQuoted then sFile = strip(sFile,,\"'\")\n      parse var sFile sDataset'('sMember')'\n      if sMember <> '' then sFile = sDataset\n      if bQuoted then sFile = \"'\"sFile\"'\"\n      if bOutput\n      then 'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n      else 'LMINIT  DATAID(hFile) DATASET(&sFile)'\n      if sMember <> ''\n      then do /* Open a member of a PDS */\n        'LMOPEN  DATAID(&hFile) OPTION(INPUT)' /* Input initially */\n        /* ... can't update ISPF stats when opened for output */\n        g.!MEMBER.hFile = sMember\n        'LMMFIND DATAID(&hFile) MEMBER('sMember') STATS(YES)'\n        if bOutput\n        then do\n          if rc = 0\n          then g.!STATS.hFile = zlvers','zlmod','zlc4date\n          else g.!STATS.hFile = '1,0,0000/00/00'\n          'LMCLOSE DATAID(&hFile)'\n          'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        end\n      end\n      else do /* Open a sequential dataset */\n        'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        if rc <> 0 /* If dataset does not already exist... */\n        then do /* Create sequential dataset then open it */\n          'LMCLOSE DATAID(&hFile)'\n          'LMFREE  DATAID(&hFile)'\n          address TSO 'ALLOCATE DATASET('sFile') NEW CATALOG',\n                      'SPACE(5,15) TRACKS RECFM(V,B)',\n                      'LRECL('g.!OPTION.WRAP.1 + 4')',\n                      'BLKSIZE(27990)' sAttrs\n          if bOutput\n          then do\n            'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n            'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n          end\n          else do\n            'LMINIT  DATAID(hFile) DATASET(&sFile)'\n            'LMOPEN  DATAID(&hFile) OPTION(INPUT)'\n          end\n        end\n      end\n      g.!OPTIONS.hFile = sOptions\n      g.!rc = rc /* Return code from LMOPEN */\n    end\n    otherwise do\n      if wordpos('OUTPUT',sOptions) > 0\n      then junk = stream(sFile,'COMMAND','OPEN WRITE REPLACE')\n      else junk = stream(sFile,'COMMAND','OPEN READ')\n      hFile = sFile\n      if stream(sFile,'STATUS') = 'READY'\n      then g.!rc = 0\n      else g.!rc = 4\n    end\n  end\nreturn hFile\n\n/*-------------------------------------------------------------------*\n * Read a line from the specified file\n *-------------------------------------------------------------------*/\n\ngetLine: procedure expose g.\n  parse arg hFile\n  sLine = ''\n  select\n    when g.!ENV = 'TSO' then do\n      'LMGET DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN(nLine) MAXLEN(32768)'\n      g.!rc = rc\n      sLine = strip(sLine,'TRAILING')\n      if sLine = '' then sLine = ' '\n    end\n    otherwise do\n      g.!rc = 0\n      if chars(hFile) > 0\n      then sLine = linein(hFile)\n      else g.!rc = 4\n    end\n  end\nreturn sLine\n\n/*-------------------------------------------------------------------*\n * Append a line to the specified file\n *-------------------------------------------------------------------*/\n\nputLine: procedure expose g.\n  parse arg hFile,sLine\n  select\n    when g.!ENV = 'TSO' then do\n      g.!LINES = g.!LINES + 1\n      'LMPUT DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN('length(sLine)')'\n    end\n    otherwise do\n      junk = lineout(hFile,sLine)\n      rc = 0\n    end\n  end\nreturn rc\n\n/*-------------------------------------------------------------------*\n * Close the specified file\n *-------------------------------------------------------------------*/\n\ncloseFile: procedure expose g.\n  parse arg hFile\n  rc = 0\n  select\n    when g.!ENV = 'TSO' then do\n      if g.!MEMBER.hFile <> '', /* if its a PDS */\n      & wordpos('OUTPUT',g.!OPTIONS.hFile) > 0 /* opened for output */\n      then do\n        parse value date('STANDARD') with yyyy +4 mm +2 dd +2\n        parse var g.!STATS.hFile zlvers','zlmod','zlc4date\n        zlcnorc  = min(g.!LINES,65535)   /* Number of lines   */\n        nVer = right(zlvers,2,'0')right(zlmod,2,'0')  /* vvmm */\n        nVer = right(nVer+1,4,'0')       /* vvmm + 1          */\n        parse var nVer zlvers +2 zlmod +2\n        if zlc4date = '0000/00/00'\n        then zlc4date = yyyy'/'mm'/'dd   /* Creation date     */\n        zlm4date = yyyy'/'mm'/'dd        /* Modification date */\n        zlmtime  = time()                /* Modification time */\n        zluser   = userid()              /* Modification user */\n        'LMMREP DATAID(&hFile) MEMBER('g.!MEMBER.hFile') STATS(YES)'\n      end\n      'LMCLOSE DATAID(&hFile)'\n      'LMFREE  DATAID(&hFile)'\n    end\n    otherwise do\n      if stream(hFile,'COMMAND','CLOSE') = 'UNKNOWN'\n      then rc = 0\n      else rc = 4\n    end\n  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SOAP": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x02\\x02\\x01\\xf5\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 514, "newlines": 501, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 6 $\n$Id: soap.rex 6 2009-09-05 02:56:11Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/* REXX ***************************************************************\n**                                                                   **\n** NAME     - SOAP                                                   **\n**                                                                   **\n** FUNCTION - This exec invokes a Web Service and displays the       **\n**            response. It assumes you are running the Apache Axis   **\n**            SOAP server on the specified host and port. Other SOAP **\n**            servers should also work but have not been tested.     **\n**                                                                   **\n**            Each time you invoke the client, you specify the SOAP  **\n**            server hostname and port, and the name of the service  **\n**            that you want to use. The client will then retrieve    **\n**            the Web Services Definition Language (WSDL) definitions**\n**            for that service from the SOAP server. If there is     **\n**            only one operation defined for that service then that  **\n**            operation is invoked automatically, else you will be   **\n**            prompted to select the operation to be invoked. If the **\n**            operation requires one or more parameters then you     **\n**            will be prompted for each parameter. No attempt is     **\n**            made to validate the input you supply. The operation   **\n**            is invoked and the response is displayed.              **\n**                                                                   **\n** NOTES    - 1. You will have to either append the PARSEXML and     **\n**               PRETTY source files manually to this file, or run   **\n**               this file through the REXX rexx pre-processor.      **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               tso rexxpp your.rexx.lib(soap)                      **\n**                                                                   **\n**            2. You can download Apache Axis from:                  **\n**               http://ws.apache.org/axis/                          **\n**                                                                   **\n**            3. Start the Apache Axis server by issuing the         **\n**               following command (all on one line with no line     **\n**               breaks):                                            **\n**                                                                   **\n**               java org.apache.axis.transport.http.SimpleAxisServer**\n**                    -p 8080                                        **\n**                                                                   **\n**               ...you will need to have the Axis jar files in your **\n**               classpath, of course.                               **\n**                                                                   **\n**            4. If you need to go through a proxy server, then      **\n**               specify the proxy server hostname and port number   **\n**               in the z.!PROXYHOST and z.!PROXYPORT variables      **\n**               (see below).                                        **\n**                                                                   **\n**            5. If you have access to the Internet, you can try the **\n**               SOAP client out by running:                         **\n**                                                                   **\n**               soap vizier.cfa.harvard.edu:8080 UCD                **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - SOAP url [service] [(options...]                       **\n**                                                                   **\n**            Where,                                                 **\n**            url       = The URL of the Axis SOAP server. Format is:**\n**                        hostname:port/path                         **\n**                        hostname - Axis SOAP server hostname       **\n**                        port - default is 80                       **\n**                        path - default is axis/services            **\n**            service   = Service name (default is Version). This    **\n**                        name is case-sensitive.                    **\n**            options   = One or more options:                       **\n**                        TRACE - Trace network I/O                  **\n**                        DEBUG - Dump message contents in hex       **\n**                        XML   - Display messages contents in XML   **\n**                        NOPROXY - Do not use proxy host.           **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20050602 AJA Retrieve WSDL from SOAP server and prompt **\n**                         user for the operation and parameters.    **\n**            20050601 AJA Added proxy host support.                 **\n**            20050531 AJA Original version.                         **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sURL sService . '('sOptions')'\n  sOptions = translate(sOptions) /* convert to upper case */\n\n  parse value sourceline(1) with . sVersion\n  say 'SOAP000I Rexx SOAP client' sVersion\n\n  z. = '' /* g. is used by the XML parser */\n\n  z.!PROXYHOST = 'proxy.example.org'\n  z.!PROXYPORT = '8080'\n\n  if pos('://',sURL) > 0\n  then parse var sURL sScheme'://'sURL    /* ignore protocol (scheme) */\n  parse var sURL sHost'/'sPath\n  parse var sHost sHost':'nPort\n  if sHost    = '' then sHost    = 'axisserver.example.org'\n  if \\datatype(nPort,'WHOLE') then nPort  = 80\n  if sPath    = '' then sPath    = 'axis/services'\n  if sService = '' then sService = 'Version'\n\n  say 'SOAP001I Host='sHost\n  say 'SOAP002I Port='nPort\n  say 'SOAP003I Path='sPath\n  say 'SOAP004I Service='sService\n\n  call initParser 'NOBLANKS' /* <-- This is in PARSEXML rexx */\n  z.!DEBUG   = wordpos('DEBUG',sOptions) <> 0\n  z.!TRACE   = wordpos('TRACE',sOptions) <> 0\n  z.!XML     = wordpos('XML',sOptions) <> 0\n  z.!NOPROXY = wordpos('NOPROXY',sOptions) <> 0\n\n  if z.!NOPROXY\n  then do\n    z.!PROXYHOST = ''\n    z.!PROXYPORT = ''\n  end\n\n  say 'SOAP005I Proxy Host='z.!PROXYHOST\n  say 'SOAP006I Proxy Port='z.!PROXYPORT\n  call Prolog\n\n/*\n *--------------------------------------------------------------------*\n * Contact the SOAP server and retrieve the WSDL for this service\n *--------------------------------------------------------------------*\n*/\n  nSocket = Connect(sHost,nPort)\n  say 'SOAP007I Retrieving WSDL for' sService 'service'\n  if z.!PROXYHOST <> ''\n  then sURL = 'http://'sHost':'nPort'/'sPath'/'sService'?wsdl'\n  else sURL = '/'sPath'/'sService'?wsdl'\n  say 'SOAP008I GET' sURL\n  sHeader =  'GET' sURL 'HTTP/1.1' || z.!CRLFCRLF\n\n  sMsg = sHeader\n  if z.!DEBUG then call Dump sMsg,'Sending'\n  sWrite = write(nSocket,sMsg)\n/*\n *--------------------------------------------------------------------*\n * Read the response from the SOAP server\n *--------------------------------------------------------------------*\n*/\n  say 'SOAP009I Reading WSDL response'\n  sReply = Slurp(nSocket)\n  sDisc = Disconnect(nSocket)\n  parse var sReply sHeader (z.!CRLFCRLF) sXML\n  if z.!DEBUG then call Dump sHeader,'Header'\n  if z.!DEBUG then call Dump sXML,'Payload'\n  parse var sHeader . nCode . 0 . sReason (z.!CRLF)\n  if nCode <> 200\n  then call Abort 'SOAP021E HTTP GET failed:' sReason\n/*\n *--------------------------------------------------------------------*\n * Parse the WSDL\n *--------------------------------------------------------------------*\n*/\n  rc = parseString(sXML)\n  doc = getDocumentElement()\n  if getName(doc) <> 'wsdl:definitions'\n  then do\n    say 'SOAP010E Could not retrieve WSDL for' sService,\n        'service on' sHost\n    say 'SOAP011I The reply received was:'\n    call showResponse doc\n    call Abort\n  end\n  porttype   = getChildrenByName(doc,'wsdl:portType')\n  operations = getChildrenByName(porttype,'wsdl:operation')\n  messages   = getChildrenByName(doc,'wsdl:message')\n  do i = 1 to words(messages)\n    message = word(messages,i)\n    sMsgName = getAttribute(message,'name')\n    z.!MSG.sMsgName = message\n    z.!MSG.message  = sMsgName\n  end\n  z.!OP.0  = words(operations)          /* number of operations */\n  if z.!OP.0 = 0\n  then call Abort 'Service' sService 'supports no operations'\n  do i = 1 to z.!OP.0  /* for each operation of this service...*/\n    operation = word(operations,i)\n    input  = getChildrenByName(operation,'wsdl:input')\n    output = getChildrenByName(operation,'wsdl:output')\n    sInputMsgName = getAttribute(input,'name')\n    sOutputMsgName = getAttribute(output,'name')\n    z.!OP.i  = operation                /* operation node */\n    z.!IN.i  = z.!MSG.sInputMsgName     /* input parms node */\n    z.!OUT.i = z.!MSG.sOutputMsgName    /* output parms node */\n  end\n\n  if z.!OP.0 > 1 /* More than one operation to choose from? */\n  then do\n    say 'SOAP012A Which' sService 'operation do you want to invoke?'\n    do i = 1 to z.!OP.0\n      say i'.' getAttribute(z.!OP.i,'name')\n    end\n    pull n\n    if n = '' then call Abort 'Operation cancelled'\n    if \\datatype(n,'WHOLE') | n < 1 | n > z.!OP.0 then n = 1\n  end\n  else n = 1\n\n  sOperation = getAttribute(z.!OP.n,'name')\n  sExpectedResponse = getAttribute(z.!OUT.n,'name')\n  say 'SOAP013I About to invoke operation:' sOperation\n  parameters = getChildrenByName(z.!IN.n,'wsdl:part')\n  z.!PARM.0  = words(parameters) /* number of defined parameters */\n  do i = 1 to z.!PARM.0\n    parameter = word(parameters,i)\n    sParmName = getAttribute(parameter,'name')\n    sParmType = getAttribute(parameter,'type')\n    say 'SOAP014A Enter value for' sParmName '(type is' sParmType'):'\n    parse pull reply\n    z.!PARM.i     = reply\n    z.!PARMNAME.i = sParmName\n  end\n\n/*\n *--------------------------------------------------------------------*\n * Create a SOAP request message roughly like:\n *  <soapenv:Envelope>\n *    <soapenv:Body>\n *      <getVersion/>\n *    </soapenv:Body>\n *  </soapenv:Envelope>\n *--------------------------------------------------------------------*\n*/\n  call initParser 'NOBLANKS'\n  doc = createDocument('soapenv:Envelope')\n  call setAttribute doc,'xmlns:soapenv',,\n                        'http://schemas.xmlsoap.org/soap/envelope/'\n  call setAttribute doc,'xmlns:xsd',,\n                        'http://www.w3.org/2001/XMLSchema'\n  call setAttribute doc,'xmlns:xsi',,\n                        'http://www.w3.org/2001/XMLSchema-instance'\n  body = createElement('soapenv:Body')\n  call appendChild body,doc\n  op   = createElement(sOperation)\n  call appendChild op,body\n  do i = 1 to z.!PARM.0\n    sParmName  = z.!PARMNAME.i\n    sParmValue = z.!PARM.i\n    parm = createElement(sParmName)\n    call appendChild createTextNode(sParmValue),parm\n    call appendChild parm,op\n  end\n  nSocket = Connect(sHost,nPort)\n  sContent = toString(getRoot())\n  say 'SOAP015I Sending' sOperation 'message to' sService 'service'\n  if z.!XML then say sContent\n/*\n *--------------------------------------------------------------------*\n * Build an HTTP header and send the message\n *--------------------------------------------------------------------*\n*/\n  if z.!PROXYHOST <> ''\n  then sURL = 'http://'sHost':'nPort'/'sPath'/'sService\n  else sURL = '/'sPath'/'sService\n  say 'SOAP020I POST' sURL\n  sHeader =  'POST' sURL 'HTTP/1.0' || z.!CRLF ||,\n    'Content-Type: text/xml; charset=utf-8' || z.!CRLF ||,\n    'Accept: application/soap+xml, application/dime,',\n            'multipart/related, text/*' || z.!CRLF ||,\n    'User-Agent: EpistAxis/1.2' || z.!CRLF ||,\n    'Host:' sHost':'nPort || z.!CRLF ||,\n    'Cache-Control: no-cache' || z.!CRLF ||,\n    'Pragma: no-cache' || z.!CRLF ||,\n    'SOAPAction: \"\"' || z.!CRLF ||,\n    'Content-Length:' length(sContent) || z.!CRLF || z.!CRLF\n\n  sMsg = sHeader || sContent\n  if z.!DEBUG then call Dump sMsg,'Sending'\n  sWrite = write(nSocket,sMsg)\n/*\n *--------------------------------------------------------------------*\n * Read the response from the SOAP server\n *--------------------------------------------------------------------*\n*/\n  sReply = Slurp(nSocket)\n  parse var sReply sHeader (z.!CRLFCRLF) sXML\n  if z.!DEBUG then call Dump sHeader,'Header'\n  if z.!DEBUG then call Dump sXML,'Payload'\n  parse var sHeader . nCode . 0 . sReason (z.!CRLF)\n  if nCode <> 200\n  then call Abort 'SOAP021E HTTP POST failed:' sReason\n\n/*\n *--------------------------------------------------------------------*\n * Now parse the response message.\n * If it worked, the response will look like:\n *\n * <soapenv:Envelope>\n *   <soapenv:Body>\n *     <getVersionResponse>\n *       <getVersionReturn>\n *         version information\n *       </getVersionReturn>\n *     </getVersionResponse>\n *   </soapenv:Body>\n * </soapenv:Envelope>\n *\n * If it failed, the response will look like:\n *\n * <soapenv:Envelope>\n *   <soapenv:Body>\n *     <soapenv:Fault>\n *       <faultcode>code</faultcode>\n *       <faultstring>string</faultstring>\n *       <detail>\n *         <stackTrace>stack trace information</stackTrace>\n *         <hostname>hostname of SOAP server</hostname>\n *       </detail>\n *     </soapenv:Fault>\n *   </soapenv:Body>\n * </soapenv:Envelope>\n *--------------------------------------------------------------------*\n*/\n  call initParser 'NOBLANKS'\n  rc = parseString(sXML)\n  if z.!XML then call prettyPrinter\n\n/*\n *--------------------------------------------------------------------*\n * Extract the payload from the response\n *--------------------------------------------------------------------*\n*/\n  doc  = getDocumentElement() /* SOAP envelope */\n  body = getFirstChild(doc)   /* SOAP body */\n  resp = getFirstChild(body)  /* SOAP server response */\n  select\n    when getName(resp) = sExpectedResponse then do\n      say 'SOAP016I Received \"'sExpectedResponse'\" response:'\n      call showResponse resp\n    end\n    when getName(resp) = 'soapenv:Fault'      then do\n      say 'SOAP017E Received \"'getName(resp)'\" response:'\n      call showResponse resp\n    end\n    otherwise do\n      say 'SOAP018W Received unexpected response:'\n      say toString(resp)\n    end\n  end\n\n  call Epilog\nexit\n\nshowResponse: procedure expose z. g.\n  parse arg node,sPad\n  if isElementNode(node)\n  then do\n    if hasAttribute(node,'xsi:type')\n    then do\n      say sPad || getName(node),\n                  getAttribute(node,'xsi:type') ||,\n                  '=\"'getText(getFirstChild(node))'\"'\n    end\n    else do\n      say sPad || getName(node)\n      if isTextNode(getFirstChild(node))\n      then say sPad'  'getText(getFirstChild(node))\n    end\n  end\n  children = getChildren(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call showResponse child,sPad'  '\n  end\nreturn\n\nshowParameters: procedure expose z. g.\n  parse arg sMsgName\n  message = z.!MSG.sMsgName\n  parts = getChildrenByName(message,'wsdl:part')\n  do k = 1 to words(parts)\n    part = word(parts,k)\n    say '    parameter:' getAttribute(part,'name'),\n                 'type:' getAttribute(part,'type')\n  end\nreturn\n\nConnect: procedure expose z.\n  parse arg sHost,nPort\n  say 'SOAP019I Connecting to' sHost 'port' nPort\n  if z.!PROXYHOST <> '' then sHost = z.!PROXYHOST\n  if z.!PROXYPORT <> '' then nPort = z.!PROXYPORT\n  sShutdown = Socket('Shutdown', z.!SOCKET)\n  sClose    = Socket('Close', z.!SOCKET)\n  nSocket   = Socket('Socket','AF_INET','SOCK_STREAM','TCP')\n  sSockOpt  = Socket('SetSockOpt',nSocket,'IPPROTO_TCP','SO_ASCII','ON')\n  sConnect  = Socket('Connect',nSocket,'AF_INET' nPort sHost)\n  if z.!RC <> 0 then call ABORT sConnect\nreturn nSocket\n\nSlurp: procedure expose z.\n  parse arg nSocket\n  sReply = ''\n  sRead  = read(nSocket)\n  do while length(sRead) > 0\n    sReply = sReply || sRead\n    sRead  = read(nSocket)\n  end\nreturn sReply\n\nDisconnect: procedure expose z.\n  parse arg nSocket\n  sShutdown= Socket('Shutdown', nSocket)\n  sResp = Socket('Close', nSocket)\nreturn sResp\n\nAbort: procedure expose z.\n  parse arg sMsg\n  say sMsg\n  call Epilog\n  exit\nreturn\n\nWrite: procedure expose z.\n  parse arg nSocket,sMsg\n  if z.!TRACE then call Dump sMsg,'-->'\n  sWrite    = Socket('Write',nSocket,sMsg)\nreturn sWrite\n\nRead: procedure expose z.\n  parse arg nSocket\n  sRead     = Socket('Read',nSocket)\n  parse var sRead nLen sData\n  if z.!TRACE then call Dump sData,'<--'\nreturn sData\n\nDump: procedure expose z.\n  parse arg sData,sPrefix,nPad\n  if \\datatype(nPad,'WHOLE') then nPad = 8\n  sPrefix = left(sPrefix,nPad)\n  lastline = length(sData)%16*16+1\n  do i = 1 to length(sData) by 16\n    if i = lastline\n    then sChunk = substr(sData,i)\n    else sChunk = substr(sData,i,16)\n    xChunk = left(c2x(sChunk),32)\n    say sPrefix,\n        substr(xChunk, 1,8),\n        substr(xChunk, 9,8),\n        substr(xChunk,17,8),\n        substr(xChunk,25,8),\n        '*'left(sChunk,16)'*'\n    sPrefix = right('+'d2x(i+15,6),nPad)\n  end\nreturn\n\nProlog:\n  z.!CR = '0D'x /* EBCDIC Carriage Return */\n  z.!LF = '25'x /* EBCDIC Line Feed */\n  z.!CRLF = '0D25'x\n  z.!CRLFCRLF = z.!CRLF || z.!CRLF\n  sResp = Socket('Terminate') /* Kill any previous socket set */\n  sResp = Socket('Initialize', 'MySet')\n  if z.!RC <> 0 then exit z.!RC\nreturn\n\nEpilog:\n  sDisc = Disconnect(nSocket)\n  sResp = Socket('Terminate')\nreturn sResp\n\nSocket: procedure expose z.\n  parse arg a,c,d,e,f,g,h,i,j,k\n  if z.!TRACE\n  then say 'Socket('strip(a','c','d','e','f','g','h','i','j','k,'T',\",\")')'\n\n  parse value 'SOCKET'(a,c,d,e,f,g,h,i,j,k) with nRC sResp\n  z.!RC = nRC\n\n  if z.!TRACE\n  then do\n    say '      Return code <'nRC'>'\n    say '      Response    <'sResp'>'\n  end\nreturn sResp\n\n/*INCLUDE pretty.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTMOD": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00\\x8c\\x00\\x81\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 140, "newlines": 129, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: testmod.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - TESTMOD                                                **\n**                                                                   **\n** FUNCTION - Tests modification of an existing XML file.            **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - testmod infile [outfile]                               **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = Name of XML file to be modified.            **\n**            outfile  = Name of file to store the output in.        **\n**                       The default is the console.                 **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. You will have to either append the PRETTY rexx code **\n**               manually to this demo source, or run this demo      **\n**               source through the REXXPP rexx pre-processor.       **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               rexxpp testmod testmodp                             **\n**                                                                   **\n**               ...and then run the resulting rexx procedure over   **\n**               an XML file of your choice:                         **\n**                                                                   **\n**               testmodp infile                                     **\n**                ...or...                                           **\n**               testmodp infile outfile                             **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top pls)       **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20040707 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n\n  parse value sourceline(1) with . sVersion\n  say 'Unit Test Suite 1 - ' sVersion\n\n  if sFileIn = ''\n  then do\n    parse source sSystem sInvocation sSourceFile .\n    say 'Syntax:' sSourceFile 'filein fileout (options...'\n    exit\n  end\n\n\n  sOptions = 'NOBLANKS' sOptions\n  call initParser sOptions /* <-- This is in PARSEXML rexx */\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  /* Open the specified file and parse it */\n  nParseRC = parseFile(sFileIn)\n  doc = getDocumentElement()\n\n  /* Create a new tag */\n  prologNode = createElement('prolog')\n  faqNode = createElement('faq')\n  call setAttribute faqNode,'question','What is your name?'\n  textNode = createTextNode('Sir Gawain of Camelot')\n  call appendChild textNode,faqNode\n  call appendChild faqNode,prologNode\n  /* We now have the following structure in memory:\n     <prolog>\n       <faq question=\"What is your name?\">\n         Sir Gawain of Camelot\n       </faq>\n     </prolog>\n  */\n\n  call Log 'Inserting a <prolog> tag at the start of the document'\n  firstChild = getFirstChild(doc)\n  if firstChild <> '' /* If document has a first child */\n  then call insertBefore prologNode,firstChild\n  else call appendChild prologNode,doc\n\n  /* Verify that the first child is now indeed the <prolog> node */\n  call assertEquals getFirstChild(doc),prologNode,,\n              'Failed to insert <prolog> as the first child'\n\n  call Log 'Appending an empty <epilog> at the end of the document'\n  call appendChild createElement('epilog'),doc\n\n  /* Save the document to a file (or display on console) */\n  call prettyPrinter sFileOut\nexit\n\nLog: procedure expose g.\n  parse arg sMessage\n  g.!TEST = g.!TEST + 1 /* increment test number */\n  say\n  say 'Test' right(g.!TEST,3,'0') left(sMessage,68,'-')\nreturn\n\n/*INCLUDE pretty.rex */\n/*INCLUDE assert.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTNEW": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00\\xba\\x00\\xb0\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 186, "newlines": 176, "modlines": 0, "user": "V2.0.1"}, "text": "/*REXX 2.0.0 $Rev: 5 $\n$Id: testnew.rex 5 2009-09-05 02:46:41Z simplicio $\nCopyright (c) 2009, Andrew J. Armstrong\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - TESTNEW                                                **\n**                                                                   **\n** FUNCTION - Tests creation and modification of XML.                **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - testnew outfile                                        **\n**                                                                   **\n**            Where,                                                 **\n**            outfile  = Name of file to store the output in.        **\n**                       The default is the console.                 **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. You will have to either append the PRETTY rexx code **\n**               manually to this demo source, or run this demo      **\n**               source through the REXXPP rexx pre-processor.       **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               rexxpp testnew testnewp                             **\n**                                                                   **\n**               ...and then run the resulting rexx procedure:       **\n**                                                                   **\n**               testnewp                                            **\n**                ...or...                                           **\n**               testnewp outfile                                    **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <androidarmstrong+sf@gmail.com>    **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20090822 AJA Changed from GPL to BSD license.          **\n**            20060803 AJA Added unit tests for getAttributeMap.     **\n**            20040707 AJA Intial version.                           **\n**                                                                   **\n**********************************************************************/\n\n\n  parse arg sFileOut' ('sOptions\n\n  parse value sourceline(1) with . sVersion\n  say 'Unit Test Suite 2 - ' sVersion\n\n  sOptions = 'NOBLANKS' sOptions\n  call initParser /* <-- This is in PARSEXML rexx */\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  g.!TEST = 0\n\n  call Log 'Create a new document'\n  doc = createDocument('bridgekeeper')\n  call prettyPrinter\n\n  call Log 'Create a faq tag and append it to the document'\n  q1 = createElement('faq')\n  call appendChild q1,doc\n  count = words(getChildren(doc))\n  call assertEquals 1,count,'001 <bridgekeeper> has wrong child count'\n  call setAttribute q1,'question','What is your name?'\n  count = getAttributeCount(q1)\n  call assertEquals 1,count,'002 <faq> element has wrong attr count'\n  textNode = createTextNode('Sir Gawain of Camelot')\n  call appendChild textNode,q1\n  count = words(getChildren(q1))\n  call assertEquals 1,count,'003 <faq> element has wrong child count'\n  call prettyPrinter\n\n  call Log 'Create another faq tag and append it to the document'\n  q2 = createElement('faq')\n  call setAttribute q2,'question','What is your quest?'\n  count = getAttributeCount(q2)\n  call assertEquals 1,count,'004 <faq> element has wrong attr count'\n  call setAttribute q2,'answer','To seek the Holy Grail'\n  count = getAttributeCount(q2)\n  call assertEquals 2,count,'005 <faq> element has wrong attr count'\n  call appendChild q2,doc\n  count = words(getChildren(doc))\n  call assertEquals 2,count,'006 <bridgekeeper> has wrong child count'\n  call prettyPrinter\n\n  call Log 'Create yet another faq tag and append it to the document'\n  q3 = createElement('faq')\n  call setAttribute q3,'question','What is your favourite color?'\n  call setAttribute q3,'answer','Blue'\n  call appendChild q3,doc\n  count = words(getChildren(doc))\n  call assertEquals 3,count,'007 <bridgekeeper> has wrong child count'\n  call prettyPrinter\n\n  call Log 'Modify the answer attribute on the third faq tag'\n  call setAttribute q3,'answer','No yelloooooww'\n  call assertEquals 'No yelloooooww',getAttribute(q3,'answer'),,\n          '008 \"answer\" attribute of <faq> is not correct'\n  call prettyPrinter\n\n  call Log 'Remove a text node and some attributes'\n  count = words(getChildren(q1))\n  call assertEquals 1,count,'009 <faq> has wrong child count'\n  call removeChild textNode /* give Sir Gawain the flick */\n  count = words(getChildren(q1))\n  call assertEquals 0,count,'010 <faq> has wrong child count'\n\n  count = getAttributeCount(q3)\n  call assertEquals 2,count,'011 <faq> element has wrong attr count'\n  call removeAttribute q3,'question'\n  count = getAttributeCount(q3)\n  call assertEquals 1,count,'012 <faq> element has wrong attr count'\n  call removeAttribute q3,'answer'\n  count = getAttributeCount(q3)\n  call assertEquals 0,count,'013 <faq> element has wrong attr count'\n  call prettyPrinter\n\n  call Log 'Insert a new text node in the first faq tag'\n  textNode = createTextNode('King of the Britons')\n  call appendChild textNode,q1\n  call insertBefore createTextNode('It is Arthur, '),textNode\n  call setAttribute q3,'question','What is the air-speed velocity',\n                                  'of an unladen swallow?'\n  call setAttribute q3,'answer','What do you mean?  An African or',\n                                  'European swallow?'\n  call prettyPrinter\n\n  call Log 'Exercise getAttributeMap'\n  call prettyPrinter ,,q3\n  call getAttributeMap q3\n  count = g.!ATTRIBUTE.0\n  call assertEquals 2,count,'014 <faq> element has wrong attr count'\n  s = g.!ATTRIBUTE.1\n  call assertEquals 'question',s,,\n                            '015 Attribute 1 of <faq> has wrong name'\n  s = g.!ATTRIBUTE.2\n  call assertEquals 'answer',s,,\n                            '016 Attribute 2 of <faq> has wrong name'\n\n  call Log 'Write the document to a file (or console)'\n  call prettyPrinter sFileOut\nexit\n\nLog: procedure expose g.\n  parse arg sMessage\n  g.!TEST = g.!TEST + 1 /* increment test number */\n  say\n  say 'Test' right(g.!TEST,3,'0') left(sMessage,68,'-')\nreturn\n\n/*INCLUDE pretty.rex */\n/*INCLUDE assert.rex */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTXML": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00P\\x01\\x07\\x12/\\x01\\x11\\x10\\x0f\\x06\\x07\\x00\"\\x00\"\\x00\\x00\\xe5\\xf2K\\xf0K\\xf1@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2007-05-02T00:00:00", "modifydate": "2011-04-10T06:07:50", "lines": 34, "newlines": 34, "modlines": 0, "user": "V2.0.1"}, "text": "<?xml version=\"1.0\"?>\n<!DOCTYPE signature[\n<!ENTITY copyright \"&#169;\">\n<!ENTITY tm \"&#xAE;\">\n]>\n<!--start of document-->\n<signature>\n<name id='one' xml:lang=\"en-AU\">\n<namepart order=\"1\">Andrew</namepart>\n<namepart order=\"2\" test='@order >= 2 &amp; @id > 0'>\nArmstrong</namepart>\n<alias>Scumbag&tm;</alias>\n<alias>Sturm &amp; Drang</alias>\n</name>\nSome unparsed character data:\n<![CDATA[<a href=\"mailto:geek@example.org\">\nAndrew Armstrong</a>]]>\n<inventory>\nTest text: and/or & &amp;&amp; &tm;includes\n<item name=\"$$$doc\" desc=\"Documentation/Installation\"/>\n<item name=\"assert\" desc=\"Unit test assertion plumbing\"/>\n<item name=\"devisio\" desc=\"Example of removing unwanted XML tags\"/>\n<item name=\"gpl\" desc=\"GNU General Public License\"/>\n<item name=\"io\" desc=\"Common Rexx I/O routines\"/>\n<item name=\"parsexml\" desc=\"A Rexx XML parser\" mode=\"> 1\"/>\n<item name=\"pretty\" desc=\"A Rexx XML pretty printer\"/>\n<item name=\"rexxpp\" desc=\"A Rexx INCLUDE pre-processor\"/>\n<item name=\"soap\" desc=\"A Rexx SOAP client\"/>\n<item name=\"testmod\" desc=\"Unit tests for XML modification\"/>\n<item name=\"testnew\" desc=\"Unit tests for XML creation\"/>\n<item name=\"testxml\" desc=\"A test XML file\"/>\n</inventory>\n</signature>\n<!--end of document-->\n", "mimetype": "text/xml", "datatype": "ebcdic", "extension": ".xml"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT647/FILE647.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT647", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}