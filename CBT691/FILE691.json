{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012615000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE691.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE691.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\t'", "DS1TRBAL": "b'@j'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xd3\\x00\\x01\\x04\\xd3\\x00\\x05\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x04$_\\x01\\x04$_\\x11\\x02\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-09-01T00:00:00", "modifydate": "2004-09-01T11:02:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-467"}, "text": "REGULAR CBT TAPE - VERSION 467    FILE:  691\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT467.FILE691\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   7 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,579 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/01/04    11:02:45    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x04$O\\x01\\x04$O\\t&\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xd2\\xd3\\xc9\\xd5\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-08-31T00:00:00", "modifydate": "2004-08-31T09:26:55", "lines": 19, "newlines": 19, "modlines": 0, "user": "MKLINE"}, "text": "This is the documentation for a source dataset containing several\nutilities from Martin Kline.\n\nAs of 08/24/2004, Martin is employed with American Century Investments\nin Kansas City, MO. He can be reached for information at\nmartin_kline@americancentury.com\n\nThe source originated in the mid 1980's, so it could possibley use\nsome updates. These utilities were written to address particular\nsituations, so may require some modification for various installations.\n\nEach of the source members has its own documentation at the beginning\nof the member.\n\nAMISPECL - Switches RACF SPECIAL authority for a user\nREADBC   - Reads all messages in SYS1.BRODCAST\nLBC      - Lists and deletes another user's SYS1.BRODCAST messages\nRANDSEQ  - Random access for a sorted sequential disk file\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE691": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x04$_\\x01\\x04$_\\x11\\x02\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-09-01T00:00:00", "modifydate": "2004-09-01T11:02:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT-467"}, "text": "//***FILE 691 is from Martin Kline and contains a program to        *   FILE 691\n//*           optimize reads of a few records from a large sorted   *   FILE 691\n//*           sequential file.  There are a few other tools here    *   FILE 691\n//*           too, relating to SYS1.BRODCAST.                       *   FILE 691\n//*                                                                 *   FILE 691\n//*           email:  martin_kline@americancentury.com              *   FILE 691\n//*                                                                 *   FILE 691\n//*     Description of RANDSEQ program:                             *   FILE 691\n//*                                                                 *   FILE 691\n//*     This subroutine can be called to perform random reads       *   FILE 691\n//*     against any sorted sequential disk file. Records can be     *   FILE 691\n//*     read by key, in sequence, or in skip-sequential order.      *   FILE 691\n//*                                                                 *   FILE 691\n//*     The best use of this routine is for improving the run       *   FILE 691\n//*     times of jobs which need to access only a few records       *   FILE 691\n//*     out of very large files. Since the program logically        *   FILE 691\n//*     finds records in the file, it is not as efficient at        *   FILE 691\n//*     reading lots of records in sequence as standard QSAM.       *   FILE 691\n//*                                                                 *   FILE 691\n//*     The program determines all of the multi-volume extents      *   FILE 691\n//*     for the file, then determines the key ranges for each       *   FILE 691\n//*     extent. It performs a binary search for the requested       *   FILE 691\n//*     key. It also keeps a tree structure of keys it has          *   FILE 691\n//*     already found, to improve the response as additional        *   FILE 691\n//*     records are read.                                           *   FILE 691\n//*                                                                 *   FILE 691\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AMISPECL": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x04$O\\x01\\x04$O\\t&\\x00R\\x00R\\x00\\x00\\xd4\\xd2\\xd3\\xc9\\xd5\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-08-31T00:00:00", "modifydate": "2004-08-31T09:26:55", "lines": 82, "newlines": 82, "modlines": 0, "user": "MKLINE"}, "text": "* This is one of those 'back-pocket' tools the systems programmer\n* can use under certain circumstances. It is particularly useful\n* in a disaster recovery test, but can also be useful when testing\n* timelines are shorter than the security team's response time.\n*\n* You probably won't want your auditor to see this one . . .\n*\n* AMISPECL flips the RACF SPECIAL authorization bit in the ACEE\n*          Call it again to flip it back.\n*\n* Original source by Martin Kline\n*\n* INSTRUCTIONS\n*\n* If you do not plan to add this program to the authorized command\n* list in IKJTSOxx then change the @AUTH macros to use whatever\n* local method you use to flip the JSCBAUTH bit so the program can\n* be authorized to use MODESET.\n*\n* Assemble and link the code. If it will be in the IKJTSOxx member,\n* then link it authorized and place it into an authorized linklist\n* dataset. Otherwise, it can be in any load library available from\n* TSO.\n*\n* The program can be called or run as a command processor, since\n* it does not use any parameters.\n*\n* If is displays \"No, you are just an ordinary user.\" then you did\n* have the RACF SPECIAL bit set, but do not any more. If it displays\n* \"Yes, you are very special.\" then the bit was not set, but is now.\n*\n* As far as I have been able to determine, the effect of this program\n* is temporary. The ACEE bits do not seem to be written back into the\n* RACF database. However, it would be wise to switch back to your\n* normal mode when you have completed whatever task you needed done.\n*\n* Note: Having the SPECIAL bit set does not necessarily mean that\n* your activities will not be logged. That's another bit. I assume\n* no liability for what you do with this code.\n*\nAMISPECL STM   14,12,12(13)            save regs\n         LR    12,15                   set up base\n         USING AMISPECL,12             establish addressability\n         L     4,548\n         L     4,108(,4)               Hi, code readers.\n         L     4,200(,4)\n*\n* The next instruction turns on the JSCBAUTH bit\n* If run under TSO as an authorized command, this is not needed\n*\n***      @AUTH 1                       user macro to become authorized\n*\n         MODESET MODE=SUP,KEY=ZERO     gotta run in key zero\n*\n         XI    38(4),X'80'             flip a bit\n         IC    5,38(4)                 pick up the bit\n*\n         MODESET MODE=PROB,KEY=NZERO   switch back to normal key\n*\n* The next instruction turns off the JSCBAUTH bit\n* If run under TSO as an authorized command, this is not needed\n*\n***      @AUTH 0                       become not authorized\n*\n         STC   5,NEWVAL                save the new value\n         TM    NEWVAL,X'80'            is bit on ?\n         BO    SAYYES                  yes - I am special\n*\n         TPUT  NO,L'NO                 no - I am not special\n*\n         B     EXIT                    go to exit\n*\nSAYYES   TPUT  YES,L'YES               display not special message\n*\nEXIT     LM    14,12,12(13)            restore regs\n         XR    15,15                   set return code\n         BR    14                      return\n*\nNEWVAL   DC    X'00'\nNO       DC    C' No, you are just an ordinary user.'\nYES      DC    C' Yes, you are very special.'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBC": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x04$O\\x01\\x04$O\\t&\\x00Y\\x00Y\\x00\\x00\\xd4\\xd2\\xd3\\xc9\\xd5\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-31T00:00:00", "modifydate": "2004-08-31T09:26:55", "lines": 89, "newlines": 89, "modlines": 0, "user": "MKLINE"}, "text": "* LBC - This module is used to read and delete another TSO user's\n* broadcast messages. This is especially useful when a user has been\n* receiving numerous message, but is away from the office. This\n* allows an authorized user to keep the broadcast dataset from filling\n* up.\n*\n* Written by Martin Kline\n*\n* INSTALLATION\n*\n* Add the LBC program to the authorized command table in IKJTSOxx.\n* Assemble the source and link it to produce an authorized module.\n* Put the module into an authorized linklist library.\n*\n* USAGE\n*\n* It is probably best to use this program in conjuncion with the\n* READBC program that reads the entire SYS1.BRODCAST dataset for all\n* users. Run READBC first to determine who has lots of messages. Then\n* run this program to delete messages for given userids.\n*\n* Enter the LBC command from anywhere in TSO\n*\n* The command responds with 'ENTER TSO USERID FOR LISTBC COMMAND'.\n*\n* Reply with a valid userid.\n*\n* The user's messages are displayed and deleted from SYS1.BRODCAST.\n*\n* The userid prompt is displayed again, and the process repeats\n* until the user enters 'END'.\n*\nLBC      STM   14,12,12(13)            Save registers\n         LR    12,15                   Set up base reg\n         USING LBC,12                  Establish addressability\n         LA    2,SAVEAREA              Point to save area\n         ST    2,8(,13)                Forward chain save areas\n         ST    13,4(,2)                Backward chain save areas\n         LR    13,2                    Set up save area pointer\n         ST    1,SAVER1                Save register 1\n*\nLOOP1    MVC   USER,BLANKS             Initialize field\n         TPUT  MSG1,L'MSG1,,NOWAIT     Prompt for userid\n*\n         TGET  USER,L'USER,,WAIT       Get userid\n*\n         STC   1,USERLEN               Save length\n         OC    USER,BLANKS             Make sure it is upper case\n         CLC   USER,BLANKS             Anything entered ?\n         BE    LOOP1                   No - try again\n*\n         CLC   USER(4),=C'END '        END command ?\n         BE    EXIT                    Yes - exit\n*\n         L     6,540                   Point to my TCB\n         L     6,180(,6)               Point to my JSCB\n         L     6,348(,6)               Point to active JSCB\n         L     6,264(,6)               Point to PSCB\n*\n         MODESET KEY=ZERO              Gotta be in key zero\n         MVC   SAVEUSER,0(6)           Save the old userid\n         MVC   0(8,6),USER             Set the new userid\n         MODESET KEY=NZERO             No longer key zero\n*\n         L     1,SAVER1                Get original parm register\n         LA    2,COMMAND               Point to pseudo command\n         LM    3,5,4(1)                Call the real LISTBC program\n         LINK  EP=LISTBC,PARAM=((2),(3),(4),(5))\n*\n         MODESET KEY=ZERO              Gotta be key zero\n         MVC   0(8,6),SAVEUSER         Restore userid field\n         MODESET KEY=NZERO             No longer key zero\n*\n         B     LOOP1                   Then do it all again\n*\nEXIT     L     13,4(,13)               Point to caller's save area\n         LM    14,12,12(13)            Restore caller's regs\n         XR    15,15                   Set zero return code\n         BR    14                      Return\n*\nSAVEAREA DC    18F'0'\nSAVER1   DC    F'0'\nSAVEUSER DC    CL8' '\nCOMMAND  DC    AL2(10,6),CL8'LISTBC'\nMSG1     DC    C'ENTER TSO USERID FOR LISTBC COMMAND'\nUSER     DC    CL7' '\nUSERLEN  DC    X'00'\nBLANKS   DC    CL7' '\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RANDSEQ": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00U\\x01\\x04$O\\x01\\x04$O\\t&\\x04L\\x04L\\x00\\x00\\xd4\\xd2\\xd3\\xc9\\xd5\\xc5@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-08-31T00:00:00", "modifydate": "2004-08-31T09:26:55", "lines": 1100, "newlines": 1100, "modlines": 0, "user": "MKLINE"}, "text": "* -------------------------------------------------------------------\n*\n*  This subroutine can be called to perform random reads against\n*  any sorted sequential disk file. Records can be read by key,\n*  in sequence, or in skip-sequential order.\n*\n*  The best use of this routine is for improving the run times of\n*  jobs which need to access only a few records out of very large\n*  files. Since the program logically finds records in the file, it\n*  is not as efficient at reading lots of records in sequence as\n*  standard QSAM.\n*\n*  The program determines all of the multi-volume extents for the\n*  file, then determines the key ranges for each extent. It performs\n*  a binary search for the requested key. It also keeps a tree\n*  structure of keys it has already found, to improve the response\n*  as additional records are read.\n*\n*  Author - Martin Kline\n* -------------------------------------------------------------------\n*\n*  CALLING ROUTINE PROVIDES:\n*\n*   0-3   work area pointer\n*   4-11  ddname\n*  12-13  call-type\n*         'CL' = close\n*         'GN' = get next\n*         'GU' = get unique\n*\n*  14-15  key length\n*  16-17  key position\n*  18-37  key\n*  38-41  record length field\n*  42-45  return code\n*         00 - ok                       04 - eof (sequential)\n*         08 - not found (direct)       12 - open failed\n*         16 - parm type invalid        20 - key length invalid\n*         24 - not dasd file            28 - parm change invalid\n*         32 - area too small for rec   36 - key not in record\n*         40 - key sequence error\n*\n*  46-49  area length\n*  50-?   record area\n*\n* -------------------------------------------------------------------\n*   REGISTER USAGE\n*\n*    R3  - frequently has dcb address\n*    R9  - file section work area pointer\n*    R10 - caller's parm list\n*    R11 - working storage\n*    R12 - base register\n*    R13 - save area address\n*    R14 - subroutine linkage\n*    R15 - return codes\n*\n* -------------------------------------------------------------------\n*  SPECIAL NOTES:\n*\n*  1)  Code allows for concatenated and multi-volume dasd files by\n*      determining extents of each section and maintaining open dcbs\n*      for each.\n*\n*  2)  No index file is maintained.  Records are found using binary\n*      search technique.  Known keys (1 per block) are kept in a tree\n*      structure to avoid unnecessary repeated i/o.\n*\n*  3)  Program assumes keys are defined correctly and data is in\n*      sequence.  Duplicate keys are acceptable.  The first record\n*      with duplicate keys is returned on get-unique call.  Get-next\n*      call(s) return following records (duplicate or not).\n*\n*  4)  Performance will improve as more records are processed, since\n*      index information is collected dynamically.  However, the\n*      overhead of reading records remains higher than normal QSAM.\n*      If the calling program will be requesting more than 10% of the\n*      records in the file, it may be more efficient to use QSAM to\n*      process the file, assuming request keys are in sequence.\n*\n*  5)  Variable length records are returned to the caller without\n*      the rdw.\n*\n*  6)  Program has been written to be reenterable to support multiple\n*      files simultaneously, and to remove any requirement for COBOL\n*      programs to be linked with it.\n*\n* -------------------------------------------------------------------\n*\n         MACRO\n&LAB     MODE24\n&LAB     LA    14,*+6                       point past bsm\n         BSM   0,14                         change to amode 24\n         MEND\n*\n         MACRO\n&LAB     MODE31\n&LAB     LA    14,*+10                      point past bsm\n         O     14,HIGHBIT                   set high order bit\n         BSM   0,14                         change to amode 31\n         MEND\n*\n         PRINT NOGEN\nRANDSEQ  CSECT\n         STM   14,12,12(13)                 save caller's regs\n         LR    12,15                        set up base reg\n         USING RANDSEQ,12                   establish my addressability\n         GETMAIN R,LV=72                    get save area\n*\n         ST    1,8(,13)                     chain\n         ST    13,4(,1)                           save\n         LR    13,1                                    areas\n         L     1,4(,13)                     pick up\n         L     1,24(,1)                             original parm\n*\n         LA    1,0(,1)                      fix reg 1\n         L     10,0(,1)                     copy parm reg\n*\n         MODE31 ,                           change to amode 31\n*\n         USING PARMLIST,10                  set up parm addressability\n         CLC   PMTYPE,=C'CL'                close request ?\n         BE    CLOSE                        yes - go do it\n*\n         CLC   PMTYPE,=C'GN'                get next ?\n         BE    PMTYPEOK                     yes - type ok\n*\n         CLC   PMTYPE,=C'GU'                get unique ?\n         BNE   PMTYPERR                     no - parm invalid\n*\nPMTYPEOK CLC   PMKEYLEN,=H'20'              key too long ?\n         BH    KEYLNERR                     yes - error\n*\n         CLC   PMKEYLEN,=H'1'               key too short ?\n         BL    KEYLNERR                     yes - error\n*\n         L     11,PMWKPTR                   get primary work address\n         LTR   11,11                        pointer zero ?\n         BNZ   BYFIRST                      no - go on\n*\n         GETMAIN RU,LV=BWSIZE,LOC=(BELOW,ANY)  get work space\n*\n         ST    1,PMWKPTR                    save ptr in parm list\n         LR    11,1                         point to work space\n         USING BWSPACE,11                   space addressability\n*\n         XC    BWSPACE(256),BWSPACE         clear space\n         XC    BWSPACE+256(BWSIZE-256),BWSPACE+256  clear space\n*\n         GETMAIN RU,LV=WORKSIZE,LOC=(BELOW,ANY)  get work space\n*\n         ST    1,WORKPTR                    save work area pointer\n         LR    9,1                          copy work area address\n         USING WORKAREA,9                   establish addressability\n*\n         LR    0,1                          copy work area address\n         LA    1,WORKSIZE                   get work length\n         XR    15,15                        clear reg 15\n         MVCL  0,14                         clear work area\n*\n         MVC   DDNAME,PMDDNAME              copy ddname to work area\n         MVC   KEYLEN,PMKEYLEN              copy key length\n         MVC   KEYPOS,PMKEYPOS              copy key position\n         MVC   WKDCB,MODELDCB               copy model dcb\n         LA    3,WKDCB                      point to dcb\n         USING IHADCB,3                     dcb addressability\n*\n         MVC   DCBDDNAM,DDNAME              put ddname into dcb\n*\n         MVC   OPENAREA,OPENLIST            copy open list\n         LA    1,OPENAREA                   point to open list\n*\n         OPEN  ((3),INPUT),MF=(E,(1))       open dcb\n*\n         LTR   15,15                        ok ?\n         BNZ   OPENFAIL                     no - fail\n*\n         CLI   DCBDEVT,X'21'                dasd file ?\n         BL    BADDEVT                      no - error\n*\n         CLI   DCBDEVT,X'2F'                dasd file ?\n         BH    BADDEVT                      no - error\n*\n         MVC   BLKSIZE,DCBBLKSI             save blksize\n         DROP  3                            lose addressability\n*\n         LA    4,1                          volume counter\n*\nCNTVOLS  MODE24 ,                           switch to amode 24\n*\n         FEOV  (3)                          force eov - next vol\n*\n         MODE31 ,                           switch to amode 31\n*\n         USING IHADCB,3                     dcb addressability\n         CLI   DCBDEVT,X'21'                dasd file ?\n         BL    BADDEVT                      no - error\n*\n         CLI   DCBDEVT,X'2F'                dasd file ?\n         BH    BADDEVT                      no - error\n*\n         CLC   BLKSIZE,DCBBLKSI             block size larger ?\n         BNL   BLKSIZOK                     no - go on\n*\n         MVC   BLKSIZE,DCBBLKSI             get largest block size\n         DROP  3                            lose addressability\n*\nBLKSIZOK LA    4,1(,4)                      count vols\n         B     CNTVOLS                      loop to count vols\n*\nEOF1     STH   4,NUMVOLS                    save volume counter\n         XR    2,2                          clear reg 2\n         ICM   2,3,BLKSIZE                  get largest blksize\n*\n         GETMAIN RU,LV=(2),LOC=(BELOW,ANY)   get i/o area\n*\n         ST    1,IOAREA                     save io area address\n         MVC   CLOSAREA(TCLOSLEN),TCLOSLST  set up close area\n         LA    1,CLOSAREA                   point to close parm list\n*\n         CLOSE ((3),LEAVE),TYPE=T,MF=(E,(1))   position to last block\n*\n         USING IHADCB,3                     dcb addressability\n         MVC   WKFDADHI,DCBFDAD             save hi disk address\n         DROP  3                            lose addressability\n*\n         LA    1,WKDCB                      point to dcb\n         BAL   14,CALLTTR                   go get high ttr\n*\n         ST    1,WKTTRHI                    save high ttr\n         MVC   WKTTRLO,=X'00000100'         set low ttr\n         CLC   WKTTRHI,WKTTRLO              hi ttr less than minimum ?\n         BL    SEMPTY1                      yes - empty extent\n*\n         LA    0,WKTTRLO                    point to low ttr\n         LR    1,3                          point to dcb\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0),TYPE=REL             prepare to read 1st block\n*\n         MODE31 ,                           switch to amode 31\n*\n         LA    1,WORKAREA                   point to work area\n         BAL   14,READ                      go read 1st block\n*\n         LH    15,KEYPOS                    get key position\n         AH    15,KEYLEN                    plus length\n         CR    15,0                         more than rec size ?\n         BH    FITERR                       yes - error\n*\n         AH    1,KEYPOS                     point to first key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         MVC   WKKEYLO(0),0(1)              executed move\n         EX    2,*-6                        move key\n         MVC   SAVEKEY(0),WKKEYLO           executed copy\n         EX    2,*-6                        save key\n*\nSEMPTY1  LH    4,NUMVOLS                    get number of volumes\n         BCT   4,SETUP                      continue if more than one\n*\n         B     ENDSETUP                     else skip remaining vols\n*\nSETUP    GETMAIN RU,LV=WORKSIZE,LOC=(BELOW,ANY)  get work space\n*\n         ST    1,WKCHAIN                    chain work area\n         LR    9,1                          copy work area address\n         USING WORKAREA,9                   establish addressability\n*\n         LR    0,1                          copy work area address\n         LA    1,WORKSIZE                   get work length\n         XR    15,15                        clear reg 15\n         MVCL  0,14                         clear work area\n*\n         MVC   WKDCB,MODELDCB               copy model dcb\n         LA    3,WKDCB                      point to dcb\n         USING IHADCB,3                     dcb addressability\n*\n         MVC   DCBDDNAM,DDNAME              put ddname into dcb\n*\n         MVC   OPENAREA,OPENLIST            copy open list\n         LA    1,OPENAREA                   point to open list\n*\n         OPEN  ((3),INPUT),MF=(E,(1))       open dcb\n*\n         LTR   15,15                        ok ?\n         BNZ   OPENFAIL                     no - fail\n*\n         DROP  3                            lose addressability\n*\n         LR    5,4                          copy volume counter\n         BCT   5,SKIPVOLS                   skip vols up to previous\n*\n         B     SKIPVOLX                     first - go on\n*\nSKIPVOLS MODE24 ,                           switch to amode 24\n         FEOV  (3)                          force eov - next vol\n*\n         BCT   5,SKIPVOLS                   loop to get right extent\n*\n         MODE31 ,                           switch to amode 31\n*\nSKIPVOLX MVC   CLOSAREA(TCLOSLEN),TCLOSLST  set up close area\n         LA    1,CLOSAREA                   point to close parm list\n*\n         CLOSE ((3),LEAVE),TYPE=T,MF=(E,(1))   position to last block\n*\n         USING IHADCB,3                     dcb addressability\n         MVC   WKFDADHI,DCBFDAD             save hi disk address\n         LA    1,WKDCB                      point to dcb\n         BAL   14,CALLTTR                   go get high ttr\n*\n         ST    1,WKTTRHI                    save high ttr\n         DROP  3                            lose addressability\n*\n         MVC   WKTTRLO,=X'00000100'         set low ttr\n         CLC   WKTTRHI,WKTTRLO              hi ttr less than minimum ?\n         BL    SEMPTY2                      yes - empty extent\n*\n         LA    0,WKTTRLO                    point to low ttr\n         LR    1,3                          point to dcb\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0),TYPE=REL             prepare to read 1st block\n*\n         MODE31 ,                           switch to amode 31\n*\n         LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read 1st block\n*\n         LH    15,KEYPOS                    get key position\n         AH    15,KEYLEN                    plus length\n         CR    15,0                         more than rec size ?\n         BH    FITERR                       yes - error\n*\n         AH    1,KEYPOS                     point to first key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         MVC   WKKEYLO(0),0(1)              executed move\n         EX    2,*-6                        move key\n         CLC   WKKEYLO(0),SAVEKEY           executed compare\n         EX    2,*-6                        compare keys\n         BH    SEQERR                       if higher, error\n*\n         MVC   SAVEKEY(0),WKKEYLO           executed copy\n         EX    2,*-6                        save key\n*\nSEMPTY2  MVI   POINTFLG,0                   clear point flag\n         BCT   4,SETUP                      loop for all extents\n*\nENDSETUP DS    0H\n*\nBYFIRST  CLC   KEYLEN,PMKEYLEN              same keylen as 1st call ?\n         BNE   PARMERR                      no - error\n*\n         CLC   KEYPOS,PMKEYPOS              same keypos as 1st call ?\n         BNE   PARMERR                      no - error\n*\n         CLC   DDNAME,PMDDNAME              same ddname as 1st call ?\n         BNE   PARMERR                      no - error\n*\n         CLC   PMTYPE,=C'GN'                get next ?\n         BE    PROCGN                       yes - get next record\n*\n         CLC   PMTYPE,=C'GU'                get unique ?\n         BE    PROCGU                       yes - perform random search\n*\n         B     PMTYPERR                     no - parm invalid\n*\n* -------------------------------------------------------------------\n*  PROCGN   -   process get-next request\n* -------------------------------------------------------------------\n*\nPROCGN   CLI   POINTFLG,0                   point done ?\n         BNE   GNNEXT                       yes - go on\n*\n         L     9,WORKPTR                    point to first wk area\n*\nGNLOOP1  OC    WKCHAIN,WKCHAIN              more areas chained ?\n         BZ    GNLOOP1X                     no - go on\n*\n         L     9,WKCHAIN                    point to next work area\n         B     GNLOOP1                      loop\n*\nGNLOOP1X CLC   WKTTRHI,WKTTRLO              hi ttr less than minimum ?\n         BNL   SEMPTY3                      no - not empty extent\n*\n         CL    9,WORKPTR                    last extent ?\n         BE    EODAD                        yes - end of file\n*\n         LR    0,9                          save work pointer\n         L     9,WORKPTR                    point to last extent\n*\nGNLOOP2  CL    0,WKCHAIN                    this extent next in chain ?\n         BE    GNLOOP1X                     yes - use it\n*\n         L     9,WKCHAIN                    point to previous extent\n         B     GNLOOP2                      loop\n*\nSEMPTY3  LA    1,WKDCB                      point to dcb\n         LA    0,=F'1'                      ttr of first record\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0)                      point to it\n*\n         MODE31 ,                           switch to amode 31\n*\n         MVI   POINTFLG,1                   indicate first point done\n         LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read block\n*\n         B     GNDONE                       go return rec to caller\n*\nGNNEXT   BAL   14,DEBLOCK                   go find next rec\n*\n         LTR   15,15                        end of file ?\n         BZ    GNDONE                       no - go pass rec to caller\n*\n         MVC   PMRCODE,=F'4'                set eof error code\n         LA    15,4                         set return code\n         B     EEXIT                        go to exit\n*\nGNDONE   CLM   0,15,PMBUFLEN                rec fit in user area ?\n         BH    SIZEERR                      no - error\n*\n         LR    14,1                         point to record\n         LR    15,0                         get actual record length\n         STCM  15,15,PMRECLEN               set length for return\n         LA    0,PMREC                      point to user area\n         ICM   1,15,PMBUFLEN                get area length\n         MVCL  0,14                         move record\n         MVC   PMRCODE,=F'0'                set error code\n         XR    15,15                        set return code\n         B     EEXIT                        go to exit\n*\n* -------------------------------------------------------------------\n*  PROCGU   -   process get-unique request\n* -------------------------------------------------------------------\n*\nPROCGU   L     9,WORKPTR                    point to work area\n         MVI   POINTFLG,0                   indicate point required\n         LH    1,KEYLEN                     get key length\n         BCTR  1,0                          minus 1 for execute\n*\nGUSECT   CLC   WKTTRHI,WKTTRLO              this extent empty ?\n         BL    GUSECT1                      yes - skip it\n*\n         CLC   PMKEY(0),WKKEYLO             is key higher than low key\n         EX    1,*-6                         in this section ?\n         BH    GUSECTOK                     yes - is in this section\n*\nGUSECT1  L     9,WKCHAIN                    get next work area\n         LTR   9,9                          any ?\n         BNZ   GUSECT                       yes - loop\n*\n         B     GUNOTFND                     no - not found (< low key)\n*\nGUSECTOK XR    7,7                          clear reg 7\n         ICM   7,3,WKTTRHI                  init max tt for range\n         XR    6,6                          init low tt for range\n         LA    8,WKTTRLO                    point to tree construct\n         USING TREE,8                       tree addressability\n*\nGUTREE   LH    1,PMKEYLEN                   get key length\n         BCTR  1,0                          minus 1 for compare\n         CLC   PMKEY(0),TRKEY               is key less than tree ?\n         EX    1,*-6                        well, is it ?\n         BNH   GULOW                        yes - go handle that\n*\n         ICM   6,3,TRTTR                    set new low tt\n         ICM   1,15,TRPTRHI                 get high branch pointer\n         BZ    GUHI1                        if zero, go on\n*\n         LR    8,1                          make that branch current\n         B     GUTREE                       go look again\n*\nGUHI1    LR    2,7                          copy high tt\n         SR    2,6                          minus low tt\n         SRL   2,1                          divide by 2\n         LTR   2,2                          result = 0 ?\n         BZ    GUHI2                        yes - found best tt\n*\n         MVC   SAVEKEY,TRKEY                save key\n*\n         GETMAIN RU,LV=TRSIZE,LOC=ANY       get space for new branch\n*\n         XC    0(TRSIZE,1),0(1)             clear it\n         ST    1,TRPTRHI                    add branch to tree\n         LR    8,1                          make branch current\n         AR    2,6                          add low tt of range\n         SLL   2,16                         shift for ttR0\n         ST    2,TRTTR                      set tt00 into branch\n         MVI   TRTTR+2,1                    make it into ttr0\n*\n         MVC   TTR0,TRTTR                   copy ttr below 16m line\n         LA    0,TTR0                       point to ttr\n         LA    1,WKDCB                      point to dcb\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0),TYPE=REL             prepare to read block\n*\n         MODE31 ,                           switch to amode 31\n*\n         LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read block\n*\n         LH    15,KEYPOS                    get key position\n         AH    15,KEYLEN                    plus length\n         CR    15,0                         more than rec size ?\n         BH    FITERR                       yes - error\n*\n         AH    1,KEYPOS                     point to first key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         MVC   TRKEY(0),0(1)                executed move\n         EX    2,*-6                        move key to tree\n         CLC   TRKEY(0),SAVEKEY             executed compare\n         EX    2,*-6                        is key lower ?\n         BL    SEQERR                       low - sequence error\n*\n         B     GUTREE                       now go look again\n*\nGUHI2    SLL   6,16                         change tt into tt00\n         ST    6,TTR0                       save tt00\n         MVI   TTR0+2,1                     change it into ttr0\n         LA    0,TTR0                       point to ttr0\n         LA    1,WKDCB                      point to dcb\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0),TYPE=REL             position to read block\n*\n         MODE31 ,                           switch to amode 31\n*\n         LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read block\n*\n         LH    15,KEYPOS                    get key position\n         AH    15,KEYLEN                    plus length\n         CR    15,0                         more than rec size ?\n         BH    FITERR                       yes - error\n*\n         B     GUSCANS                      go scan sequentially\n*\nGULOW    ICM   7,3,TRTTR                    set new high tt\n         ICM   1,15,TRPTRLO                 get low branch pointer\n         BZ    GULOW1                       if zero, go on\n*\n         LR    8,1                          make that branch current\n         B     GUTREE                       go look again\n*\nGULOW1   LR    2,7                          copy high tt\n         SR    2,6                          minus low tt\n         SRL   2,1                          divide by 2\n         LTR   2,2                          result = 0 ?\n         BZ    GULOW2                       yes - found best tt\n*\n         MVC   SAVEKEY,TRKEY                save the key\n*\n         GETMAIN RU,LV=TRSIZE,LOC=ANY       get space for new branch\n*\n         XC    0(TRSIZE,1),0(1)             clear it\n         ST    1,TRPTRLO                    add branch to tree\n         LR    8,1                          make branch current\n         AR    2,6                          add low tt of range\n         SLL   2,16                         shift for ttr0\n         ST    2,TRTTR                      set tt00 into branch\n         MVI   TRTTR+2,1                    make it into ttr0\n*\n         MVC   TTR0,TRTTR                   copy ttr below 16m line\n         LA    0,TTR0                       point to ttr\n         LA    1,WKDCB                      point to dcb\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0),TYPE=REL             prepare to read block\n*\n         MODE31 ,                           switch to amode 31\n*\n         LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read block\n*\n         LH    15,KEYPOS                    get key position\n         AH    15,KEYLEN                    plus length\n         CR    15,0                         more than rec size ?\n         BH    FITERR                       yes - error\n*\n         AH    1,KEYPOS                     point to first key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         MVC   TRKEY(0),0(1)                executed move\n         EX    2,*-6                        move key to tree\n         CLC   TRKEY(0),SAVEKEY             executed compare\n         EX    2,*-6                        key in sequence ?\n         BH    SEQERR                       no - error\n*\n         B     GUTREE                       now go look again\n*\nGULOW2   LTR   6,6                          first block (0) ?\n         BZ    GULOW3                       yes - do not back up 1\n*\n         BCTR  6,0                          back up one block\n*\nGULOW3   SLL   6,16                         change tt into tt00\n         ST    6,TTR0                       save tt00\n         MVI   TTR0+2,1                     change it into ttr0\n         LA    0,TTR0                       point to ttr0\n         LA    1,WKDCB                      point to dcb\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0),TYPE=REL             position to read block\n*\n         MODE31 ,                           switch to amode 31\n*\n         LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read block\n*\n         LH    15,KEYPOS                    get key position\n         AH    15,KEYLEN                    plus length\n         CR    15,0                         more than rec size ?\n         BH    FITERR                       yes - error\n*\n         B     GUSCANS                      go scan sequentially\n*\nGUSCANS  LH    3,PMKEYPOS                   get key offset\n         AR    3,1                          point to key\n         LH    2,PMKEYLEN                   get key length\n         BCTR  2,0                          minus 1 for compare\n         CLC   PMKEY(0),0(3)                key match ?\n         EX    2,*-6                        does key match ?\n         BE    GUFOUND                      yes - found record\n*\n         BL    GUNOTFND                     passed key - not found\n*\n         BAL   14,DEBLOCK                   get next record\n*\n         B     GUSCANS                      go check its key\n*\nGUFOUND  CLM   0,15,PMBUFLEN                rec fit in user area ?\n         BH    SIZEERR                      no - error\n*\n         LR    14,1                         point to record\n         LR    15,0                         get actual record length\n         STCM  15,15,PMRECLEN               set length for return\n         LA    0,PMREC                      point to user area\n         ICM   1,15,PMBUFLEN                get area length\n         MVCL  0,14                         move record\n         MVI   POINTFLG,1                   indicate first point done\n         MVC   PMRCODE,=F'0'                set error code\n         XR    15,15                        set return code\n         B     EEXIT                        go to exit\n*\n* -------------------------------------------------------------------\n*  CLOSE  -  process close request\n* -------------------------------------------------------------------\n*\nCLOSE    L     11,PMWKPTR                   get primary work address\n         LTR   11,11                        pointer zero ?\n         BZ    NOCLOSE                      yes - forget close\n         L     9,WORKPTR                    point to first work area\n*\nCLLOOP1  LTR   9,9                          valid ?\n         BZ    CLOSEX                       no - go on\n*\n         MODE24 ,                           switch to amode 24\n*\n         LA    3,WKDCB                      point to dcb\n         MVC   CLOSAREA(CLOSELEN),CLOSELST  set up close area\n         LA    1,CLOSAREA                   point to close parm list\n*\n         CLOSE ((3)),MF=(E,(1))             close file\n*\n         LA    1,WKDCB                      point to dcb\n*\n         FREEPOOL (1)                       free buffer pool\n*\n         MODE31 ,                           switch to amode 31\n*\n* -------------------------------------------------------------------\n*  How to free storage from a tree structure\n*\n*   Cannot free one element until all subordinate elements are gone.\n*   Reg 2 will point to current element (most of the time).  Go down\n*   the tree structure using the low then the high pointers of each\n*   element, saving the address of the element that points to the\n*   current element in the ttr field of the current element.  As\n*   each low or high pointer is picked up, it is zeroed.  When both\n*   pointers are zero, the previous pointer (from pointer) is picked\n*   up and the current element is freemained.  Then the previous\n*   element becomes current, and the pointers are checked again for\n*   the now current element.  The previous pointer of the first\n*   element is set to zero, and when recognized as the last remaining\n*   element, is not freemained, since it is actually part of the\n*   segment work area, and is freemained with that.\n* -------------------------------------------------------------------\n*\n         XR    3,3                          clear reg 3 (prev tree)\n         LA    2,WKTTRLO                    point to initial tree\n         PUSH  USING                        save addressability\n         DROP  8                            remove addressability\n         USING TREE,2                       set tree addressability\n*\nCLLOOP2  ST    3,TRTTR                      save from address in ttr\nCLLOOP2A LR    3,2                          copy tree address\n         L     1,TRPTRLO                    get low pointer\n         XC    TRPTRLO,TRPTRLO              clear pointer\n         LTR   2,1                          low pointer zero ?\n         BNZ   CLLOOP2                      no - do it again\n*\n         LR    2,3                          restore tree address\n         L     1,TRPTRHI                    get high pointer\n         XC    TRPTRHI,TRPTRHI              clear pointer\n         LTR   2,1                          high pointer zero ?\n         BNZ   CLLOOP2                      no - do it again\n*\n         LR    2,3                          restore tree address\n         L     4,TRTTR                      get from address from ttr\n         LR    1,2                          copy this tree address\n         LTR   2,4                          set new tree address\n         BZ    CLLOOP2X                     if zero, at top\n*\n         FREEMAIN RC,LV=TRSIZE,A=(1)        free tree storage\n         B     CLLOOP2A                     go do previous tree\n*\nCLLOOP2X LR    1,9                          copy wk address\n         L     9,WKCHAIN                    get next wk address\n         FREEMAIN RC,LV=WORKSIZE,A=(1)      free this work area\n         B     CLLOOP1                      do it again for next area\n*\nCLOSEX   LR    1,11                         point to main work area\n         FREEMAIN RC,LV=BWSIZE,A=(1)        free main work area\n*\n         XC    PMWKPTR,PMWKPTR              clear work pointer\n         MVC   PMRCODE,=F'0'                set error code\n*\nNOCLOSE  XR    15,15                        set return code\n         B     EEXIT                        go to exit\n         DROP  2\n         POP   USING\n*\n* -------------------------------------------------------------------\n*  ERROR ROUTINES\n* -------------------------------------------------------------------\n*\nEODAD    MVC   PMRCODE,=F'4'                set error code\n         LA    15,4                         set return code\n         B     EEXIT                        go to exit\n*\nGUNOTFND MVC   PMRCODE,=F'8'                set error code\n         LA    15,4                         set return code\n         B     EEXIT                        go to exit\n*\nSIZEERR  MVC   PMRCODE,=F'32'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nFITERR   MVC   PMRCODE,=F'36'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nSEQERR   MVC   PMRCODE,=F'40'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nPARMERR  MVC   PMRCODE,=F'28'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nOPENFAIL MVC   PMRCODE,=F'12'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nBADDEVT  MVC   PMRCODE,=F'24'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nKEYLNERR MVC   PMRCODE,=F'20'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nPMTYPERR MVC   PMRCODE,=F'16'               set error code\n         LA    15,8                         set return code\n         B     EEXIT                        go to exit\n*\nEEXIT    MODE24 ,                           switch to amode 24\n*\n         LR    1,13                         point to my save area\n         L     13,4(,13)                    point to caller's save area\n         ST    15,16(,13)                   save return code\n*\n         FREEMAIN R,LV=72,A=(1)             free the storage\n*\n         LM    14,12,12(13)                 restore caller's regs\n         BR    14                           return\n*\n* -------------------------------------------------------------------\n*  READ subroutine\n*    input r1 = dcb address\n*    output r1 = rec pointer, r0 = length\n*    read a block, determine record length (minus rdw if recfm=v),\n*    point to data (past rdw if recfm=v)\n*    saves block length, record pointer, and record length for\n*    deblock routine.\n* -------------------------------------------------------------------\n*\nREAD     STM   0,15,READSAVE                save regs\n         LR    5,1                          copy work area address\n*\n         PUSH  USING                        save current addressability\n         DROP  9\n         USING WORKAREA,5                   work area addressability\n*\n         L     4,IOAREA                     point to io area\n         LA    3,WKDCB                      get dcb address\n*\n         MODE24 ,                           switch to amode 24\n*\n         MVC   DECBLIST(READLEN),READLIST   build read decb\n*\n         READ  RDDECB,SF,(3),(4),'S',MF=E start read operation\n*\n         CHECK RDDECB                       complete read operation\n*\n         MODE31 ,                           switch to amode 31\n*\n         USING IHADCB,3                     dcb addressability\n         TM    DCBRECFM,DCBRECU             undefined records ?\n         BO    READU                        yes - handle them\n*\n         BZ    READU                        yes - handle them\n*\n         TM    DCBRECFM,DCBRECV             variable records ?\n         BO    READV                        yes - handle them\n*\n         TM    DCBRECFM,DCBRECBR            fixed-blocked records ?\n         BO    READFB                       yes - handle them\n*\nREADF    MVC   RDBLKSIZ,DCBBLKSI            use blksize for fixed recs\n         XR    0,0                          clear reg 0\n         ICM   0,3,DCBBLKSI                 pick up block size\n         L     1,IOAREA                     point to io area\n         B     READXIT                      go to read exit\n*\nREADV    L     1,IOAREA                     point to io area\n         MVC   RDBLKSIZ,0(1)                blksize is in 1st 2 bytes\n         LH    0,4(,1)                      get first rec length\n         SH    0,=H'4'                      minus 4\n         LA    1,8(,1)                      point to data part of rec\n         B     READXIT                      go to read exit\n*\nREADFB   L     1,RDDECB+16                  pick up iob address\n         LH    0,DCBBLKSI                   get dcb block size\n         SH    0,14(1)                      calculate read length\n         STH   0,RDBLKSIZ                   save block length\n         LH    0,DCBLRECL                   get lrecl from dcb\n         L     1,IOAREA                     point to record\n         B     READXIT                      go to read exit\n*\nREADU    L     1,RDDECB+16                  pick up iob address\n         LH    0,DCBBLKSI                   get dcb block size\n         SH    0,14(1)                      calculate read length\n         STH   0,RDBLKSIZ                   save block length\n         L     1,IOAREA                     point to record\n         B     READXIT                      go to read exit\n*\nREADXIT  STH   0,RDRECLEN                   save record length\n         ST    1,RDRECPTR                   save record pointer\n         ST    5,RDWKAREA                   save work area address\n         LM    2,15,READSAVE+8              restore regs 2 thru 15\n         BR    14                           go back\n*\n         DROP  5                            drop addressability\n         POP   USING                        restore addressability\n*\n* -------------------------------------------------------------------\n*    DEBLOCK\n*    output 1 = rec pointer, r0 = length\n*    returns address and length of next record in block,\n*    or reads next block if necessary.\n* -------------------------------------------------------------------\n*\nDEBLOCK  STM   0,15,DBLKSAVE                save regs\n         L     9,RDWKAREA                   point to current work area\n         USING WORKAREA,9                   work addressability\n         LA    3,WKDCB                      point to dcb\n         USING IHADCB,3                     dcb addressability\n*\n         L     1,RDRECPTR                   point to record\n         AH    1,KEYPOS                     point to first key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         MVC   SAVEKEY(0),0(1)              executed move\n         EX    2,*-6                        move key\n*\n         L     1,RDRECPTR                   point to record\n         AH    1,RDRECLEN                   point past end of record\n         L     2,IOAREA                     point to io area\n         AH    2,RDBLKSIZ                   point past end of block\n         CR    1,2                          end of block ?\n         BNL   DBREAD                       yes - go read another\n*\n         TM    DCBRECFM,DCBRECBR            blocked records ?\n         BZ    DBREAD                       no - read another (why?)\n*\n         TM    DCBRECFM,DCBRECF             fixed records ?\n         BO    DBFIXED                      yes - handle them\n*\n         LH    0,0(,1)                      get next rec len from rdw\n         SH    0,=H'4'                      minus 4\n         STH   0,RDRECLEN                   save next record length\n         LA    1,4(,1)                      point past rdw\n         ST    1,RDRECPTR                   save record pointer\n         AH    1,KEYPOS                     point to key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         CLC   SAVEKEY(0),0(1)              executed compare\n         EX    2,*-6                        compare keys\n         BH    SEQERR                       if high, sequence error\n*\n         L     1,RDRECPTR                   get record pointer\n         XR    15,15                        set return code\n         B     DEBLKXIT                     go to deblock exit\n*\nDBFIXED  LH    0,DCBLRECL                   get lrecl\n         STH   0,RDRECLEN                   set lrecl (again?)\n         XR    15,15                        set return code\n         B     DEBLKXIT                     go to deblock exit\n*\nDBREAD   CLC   DCBFDAD,WKFDADHI             last block in section ?\n         BNE   DBREAD1                      no - read next\n*\n         CL    9,WORKPTR                    last section ?\n         BE    DBEODAD                      yes - end of data\n*\n         LR    8,9                          save workarea pointer\n         LH    0,NUMVOLS                    get number of sections\n         L     9,WORKPTR                    get first work area ptr\n*\nDBCHAIN  CL    8,WKCHAIN                    current = next on chain ?\n         BE    DBEOV                        yes - use previous\n*\n         L     9,WKCHAIN                    get next work area pointer\n         LTR   9,9                          zero ?\n         BZ    DBEODAD                      yes - end of data (how?)\n*\n         BCT   0,DBCHAIN                    loop through volumes\n*\n         B     DBEODAD                      not found - eodad (how?)\n*\nDBEOV    LA    1,WKDCB                      point to dcb\n         LA    0,=F'1'                      set ttr for first block\n*\n         MODE24 ,                           switch to amode 24\n*\n         POINT (1),(0)                      set up to read first block\n*\n         MODE31 ,                           switch to amode 31\n*\nDBREAD1  LA    1,WORKAREA                   point to dcb\n         BAL   14,READ                      go read block\n*\n         L     1,RDRECPTR                   get record pointer\n         AH    1,KEYPOS                     point to key\n         LH    2,KEYLEN                     get key length\n         BCTR  2,0                          minus 1 for execute\n         CLC   SAVEKEY(0),0(1)              executed compare\n         EX    2,*-6                        compare keys\n         BH    SEQERR                       if high, sequence error\n*\n         L     1,RDRECPTR                   get record pointer\n         XR    15,15                        set return code\n         B     DEBLKXIT                     go to deblock exit\n*\nDBEODAD  XR    0,0                          clear reg 0 (length)\n         XR    1,1                          clear reg 1 (pointer)\n         LA    15,8                         set eodad return code\n         B     DEBLKXIT                     go to deblock exit\n*\nDEBLKXIT LM    2,14,DBLKSAVE+8              restore regs 2 thru 14\n         BR    14                           return from deblock\n*\n* -------------------------------------------------------------------\n*  CALLTTR - interface to documented ttr conversion routine\n*    converts mbbcchhr (from dcb + 5) into ttr0 in reg 1.\n*    see dfp system programming reference (sc26-4567)\n* -------------------------------------------------------------------\n*\nCALLTTR  STM   0,15,TTRSAVE                 save regs\n         LA    3,TTRSAVE                    point to save area\n         DROP  ,                            no addressability\n         USING IHADCB,1                     dcb addressability\n*\n         LA    2,DCBFDAD                    point to mbbcchhr\n         L     1,DCBDEBAD                   pick up deb address\n         LA    1,0(,1)                      fix deb address\n         L     15,16                        point to cvt\n         USING CVT,15                       cvt addressability\n*\n         L     15,CVTPRLTV                  point to converter routine\n         BALR  14,15                        call converter\n*\n         LR    1,0                          save returned ttr\n         L     0,0(,3)                      restore reg 0\n         LM    2,15,8(3)                    restore regs 2-15\n         BR    14                           go back\n*\n         DROP  15,1                         lose addressability\n*\nHIGHBIT  DC    0F'0',X'80000000'\nMODELDCB DCB   DDNAME=X,DSORG=PS,MACRF=(RCP),BUFNO=2,EODAD=EOF1\nMYDCBLEN EQU   *-MODELDCB\nOPENLIST OPEN  (0,INPUT),MF=L\nOPENLEN  EQU   *-OPENLIST\nTCLOSLST CLOSE (0,LEAVE),TYPE=T,MF=L\nTCLOSLEN EQU   *-TCLOSLST\nCLOSELST CLOSE (0),MF=L\nCLOSELEN EQU   *-CLOSELST\nREADLIST READ  LDECB,SF,MF=L\n*\nBWSPACE  DSECT ,\nTTRSAVE  DS    16F                     save area for ttr conversion\nDBLKSAVE DS    16F                     save area for deblock routine\nREADSAVE DS    16F                     save area for read routine\nRDRECPTR DC    A(0)                    record pointer for read\nWORKPTR  DC    A(0)                    last segment work pointer\nRDWKAREA DC    A(0)                    work area used by last read\nIOAREA   DC    A(0)                    io area address\nTTR0     DC    A(0)                    ttr work area\nOPENAREA DS    CL(OPENLEN)             space for open list\n         DS    0F\nCLOSAREA DS    CL(TCLOSLEN)            space for close list\n         DS    0F\nDECBLIST READ  RDDECB,SF,MF=L          space for read list\nREADLEN  EQU   *-DECBLIST\nBLKSIZE  DC    H'0'                    largest blocksize of all parts\nRDRECLEN DC    H'0'                    read record length\nRDBLKSIZ DC    H'0'                    read block size\nKEYLEN   DS    H                       original key length\nKEYPOS   DS    H                       original key position\nNUMVOLS  DS    H                       number of volumes (calculated)\nDDNAME   DS    CL8                     original dd name\nSAVEKEY  DS    CL(L'WKKEYLO)           save key area\nPOINTFLG DC    X'00'                   point indicator (0 = not done)\nBWSIZE   EQU   *-BWSPACE\n*\n* -------------------------------------------------------------------\n*  work area format\n*    there will be one work area for each volume.  areas will be\n*    chained with the last volume first.\n* -------------------------------------------------------------------\n*\nWORKAREA DSECT ,                       work area\nWKCHAIN  DS    F                       next work area address or zero\nWKTTRHI  DS    F                       hi used ttr of last volume\nWKTTRLO  DS    F     <--.              ttr of record with low key\nWKPTRLO  DS    F        |  TREE        pointer to lower key in tree\nWKPTRHI  DS    F        |  FORMAT      pointer to higher key in tree\nWKKEYLO  DS    CL20  <--'              first key in first block\nWKFDADHI DS    CL8                     hi used full disk address\nWKDCB    DS    CL(MYDCBLEN)            dcb for last or only volume\nWORKSIZE EQU   *-WORKAREA              length of work area dsect\n*\n* -------------------------------------------------------------------\n*  input parameter fields\n* -------------------------------------------------------------------\n*\nPARMLIST DSECT ,\nPMWKPTR  DS    F                       address of randseq wk area\nPMDDNAME DS    CL8                     requestor ddname\nPMTYPE   DS    CL2                     request type\nPMKEYLEN DS    H                       key length\nPMKEYPOS DS    H                       key position\nPMKEY    DS    CL20                    key\nPMRECLEN DS    AL4                     return record length\nPMRCODE  DS    AL4                     return code\nPMBUFLEN DS    AL4                     size of record area\nPMREC    DS    AL4                     return data area\n*\n* -------------------------------------------------------------------\n*  tree branch format\n* -------------------------------------------------------------------\n*\nTREE     DSECT ,\nTRTTR    DS    F                       ttr of rec with key\nTRPTRLO  DS    F                       pointer to lower key in tree\nTRPTRHI  DS    F                       pointer to higher key in tree\nTRKEY    DS    CL20                    first key in the block\nTRSIZE   EQU   *-TREE\n*\n* -------------------------------------------------------------------\n*\n         DCBD  DSORG=BS,DEVD=DA\n         IEZDEB\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "READBC": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x04$O\\x01\\x04$O\\t&\\x00\\xfb\\x00\\xfb\\x00\\x00\\xd4\\xd2\\xd3\\xc9\\xd5\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-08-31T00:00:00", "modifydate": "2004-08-31T09:26:55", "lines": 251, "newlines": 251, "modlines": 0, "user": "MKLINE"}, "text": "* READBC - This program reads all messages in the SYS1.BRODCAST\n* dataset, and displays them. Especially useful to identify users who\n* are wasting space in the broadcast dataset.\n*\n* Note: This program only works if you are still using SYS1.BRODCAST\n*       for all TSO SEND messages. If each user has their own\n*       dataset, then this will not work.\n*\n* Written by Martin Kline\n*\n* INSTALLATION\n*\n* Assemble the source and link it. Module does not require\n* authorization.\n*\n* USAGE\n*\n* Best if run in batch, so you can scroll through the messages,\n*\n* //READBC   EXEC PGM=READBC\n* //STEPLIB   DD  DISP=SSHR,DSN=your.load.library\n* //BRODCAST  DD  DSN=SYS1.BRODCAST,DISP=SHR\n* //SYSOUT    DD  SYSOUT=*\n*\nREADBC   CSECT\n         STM   14,12,12(13)            Save caller's regs\n         LR    12,15                   Set up base reg\n         USING READBC,12               Establish addressability\n         LA    2,SAVEAREA              Point to my save area\n         ST    2,8(,13)                Forward chain save areas\n         ST    13,4(,2)                Backward chain save areas\n         LR    13,2                    Set save area pointer\n*\n         L     2,0(,1)                 load parm address\n         SR    15,15                   clear register 15\n         ICM   15,3,0(2)               load parm length\n         BZ    START                   if zero, branch\n         CLC   2(5,2),=C'NOMSG'        no message text?\n         BNE   START                   no, branch\n         MVI   SWITCH,X'00'            set switch\n*\nSTART    OPEN  MF=(E,OPEN)             open files\n*\n         LA    1,0                     rba = 0\n         BAL   14,READ1                read 1st record of sys1.brodcast\n         ICM   1,15,R1BCPTRP           rba of 1st notices directory\n*\nLOOP0    BAL   14,READ2                read notices directory\n         LA    1,B2ENT                 point to 1st entry\n         LA    15,25                   set loop limit\nA        TM    0(1),X'80'              unused entry?\n         BO    C                       yes, branch\nB        AP    COUNT2U,=P'1'           increment counter\n         B     D                       branch\nC        AP    COUNT2AV,=P'1'          increment counter\n         B     D                       branch\nD        LA    1,5(,1)                 next entry\n         BCT   15,A                    loop\n         SR    1,1                     clear r1\n         ICM   1,7,B2NEXT              rba of next notice directory\n         BNZ   LOOP0                   read next one\n*\n         SR    1,1                     clear r1\n         ICM   1,7,BUFFER1+5           rba of 1st user mail directory\nLOOP1    BAL   14,READ3                read user mail directory record\n         LA    6,BUFFER3               point to 1st entry\n         LA    7,9                     max. entries\n*\nLOOP1A   DS    0H\n         USING USDENTRY,6              provide addressability\n         CLC   USERID,ZEROS            empty slot?\n         BE    NEXT                    yes, skip it\n         ZAP   COUNT,=P'0'             clear message count\n         SR    1,1                     clear register 1\n         ICM   1,7,RBA1ST              load rba of 1st message\n         BZ    ENDLOOP2                branch if zero\n*\nLOOP2    BAL   14,READ4                read user mail record\n         AP    COUNT,=P'1'             bump counter\n         TM    SWITCH,X'80'            print message text?\n         BZ    SKIP                    no, branch\n         MVC   OUTPUT,BLANKS           clear output line\n         MVC   OUTPUT(7),USERID        copy userid\n         SR    15,15                   clear register 15\n         IC    15,USMLNG               load message length\n         BCTR  15,0                    subtract 1\n         EX    15,MOVEMSG              move message to output\n         PUT   SYSPRINT,OUTPUT         print message text\n*\nSKIP     SR    1,1                     clear register 1\n         ICM   1,7,USMNEXT             load rba of next record\n         BNZ   LOOP2                   process next record\n*\nENDLOOP2 CP    COUNT,=P'0'             any messages?\n         BE    NEXT                    no, branch\n         MVC   TRAILER(7),USERID       copy userid\n         OI    COUNT+2,X'0F'           insure numeric sign\n         UNPK  TRAILER+8(4),COUNT      unpack message count\n         PUT   SYSPRINT,TRAILER        write total line\n*\nNEXT     LA    6,13(,6)                point to next entry\n         BCT   7,LOOP1A                loop\n         SR    1,1                     clear register 1\n         ICM   1,7,USDNEXT             rba of next directory record\n         BNZ   LOOP1                   zero, no more\n*\n         MVC   TRAILER1(10),=X'40206B2020206B202120'\n         ED    TRAILER1(10),COUNT1\n         PUT   SYSPRINT,TRAILER1\n         MVC   TRAILER2(10),=X'40206B2020206B202120'\n         ED    TRAILER2(10),COUNT2\n         PUT   SYSPRINT,TRAILER2\n         MVC   TRAILER3(10),=X'40206B2020206B202120'\n         ED    TRAILER3(10),COUNT2U\n         PUT   SYSPRINT,TRAILER3\n         MVC   TRAILER4(10),=X'40206B2020206B202120'\n         ED    TRAILER4(10),COUNT2AV\n         PUT   SYSPRINT,TRAILER4\n         MVC   TRAILER5(10),=X'40206B2020206B202120'\n         ED    TRAILER5(10),COUNT3\n         PUT   SYSPRINT,TRAILER5\n         MVC   TRAILER6(10),=X'40206B2020206B202120'\n         ED    TRAILER6(10),COUNT4\n         PUT   SYSPRINT,TRAILER6\n         ICM   1,15,R1RECNUM\n         CVD   1,DWORD\n         SP    DWORD,COUNT1\n         SP    DWORD,COUNT2\n         SP    DWORD,COUNT2U\n         SP    DWORD,COUNT2AV\n         SP    DWORD,COUNT3\n         SP    DWORD,COUNT4\n         MVC   TRAILER7(10),=X'40206B2020206B202120'\n         ED    TRAILER7(10),DWORD+4\n         PUT   SYSPRINT,TRAILER7\nEXIT     CLOSE MF=(E,CLOSE)            CLOSE FILES\n         L     13,4(,13)\n         LM    14,12,12(13)\n         XR    15,15\n         BR    14\n*\nREAD1    ST    14,SAVER14              SAVE RETURN ADDRESS\n         STCM  1,7,RBA                 SAVE RBA\n         READ  DECB1,DI,MF=E           READ CONTROL RECORD\n         CHECK DECB1                   WAIT FOR READ TO COMPLETE\n         AP    COUNT1,=P'1'            INCREMENT COUNTER\n         L     14,SAVER14              LOAD RETURN ADDRESS\n         BR    14                      RETURN\n*\nREAD2    ST    14,SAVER14              SAVE RETURN ADDRESS\n         STCM  1,7,RBA                 SAVE RBA\n         READ  DECB2,DI,MF=E           READ NOTICE DIRECTORY\n         CHECK DECB2                   WAIT FOR READ TO COMPLETE\n         AP    COUNT2,=P'1'            INCREMENT COUNTER\n         L     14,SAVER14              LOAD RETURN ADDRESS\n         BR    14                      RETURN\n*\nREAD3    ST    14,SAVER14              SAVE RETURN ADDRESS\n         STCM  1,7,RBA                 SAVE RBA\n         READ  DECB3,DI,MF=E           READ DIRECTORY RECORD\n         CHECK DECB3                   WAIT FOR READ TO COMPLETE\n         AP    COUNT3,=P'1'            INCREMENT COUNTER\n         L     14,SAVER14              LOAD RETURN ADDRESS\n         BR    14                      RETURN\n*\nREAD4    ST    14,SAVER14              SAVE RETURN ADDRESS\n         STCM  1,7,RBA                 SAVE RBA\n         READ  DECB4,DI,MF=E           READ MESSAGE RECORD\n         CHECK DECB4                   WAIT FOR READ TO COMPLETE\n         AP    COUNT4,=P'1'            INCREMENT COUNTER\n         L     14,SAVER14              LOAD RETURN ADDRESS\n         BR    14                      RETURN\n*\nMOVEMSG  MVC   OUTPUT+8(0),USMTEXT     DUMMY INSTRUCTION\n         EJECT\nBRODCAST DCB   DDNAME=BRODCAST,DSORG=DA,OPTCD=R,RECFM=F,MACRF=(RIC)\n         EJECT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=133\n         EJECT\nOPEN     OPEN  (BRODCAST,INPUT,SYSPRINT,OUTPUT),MF=L\nCLOSE    EQU   OPEN\n*\n         READ  DECB1,DI,BRODCAST,BUFFER1,'S',0,RBA,MF=L\n*\n         READ  DECB2,DI,BRODCAST,BUFFER2,'S',0,RBA,MF=L\n*\n         READ  DECB3,DI,BRODCAST,BUFFER3,'S',0,RBA,MF=L\n*\n         READ  DECB4,DI,BRODCAST,BUFFER4,'S',0,RBA,MF=L\n*\nSAVEAREA DC    18F'0'\nDWORD    DC    D'0'\nSAVER14  DC    F'0'\nRBA      DC    AL3(0),AL1(0)\nSWITCH   DC    XL1'80'\nCOUNT    DC    PL3'0'\nCOUNT1   DC    PL4'0'                  INDEX RECORDS READ\nCOUNT2   DC    PL4'0'                  TOTAL NOTICE DIRECTORY RECS.\nCOUNT2U  DC    PL4'0'                  NOTICE RECORDS USED\nCOUNT2AV DC    PL4'0'                  NOTICE RECORDS AVAIL.\nCOUNT3   DC    PL4'0'                  TOTAL MAIL DIRECTORY RECS.\nCOUNT4   DC    PL4'0'                  USED MAIL RECORDS\nCOUNT5   DC    PL4'0'                  UNUSED MAIL RECORDS\nZEROS    DC    XL7'00'\nBLANKS   DC    CL133' '\nOUTPUT   DC    CL133' '\nTRAILER  DC    CL133'XXXXXXX 0000 MESSAGES'\nTRAILER1 DC    CL133' 0,000,000 INDEX RECORD'\nTRAILER2 DC    CL133' 0,000,000 NOTICE DIRECTORY RECORDS'\nTRAILER3 DC    CL133' 0,000,000 USED NOTICE RECORDS'\nTRAILER4 DC    CL133' 0,000,000 UNUSED NOTICE RECORDS'\nTRAILER5 DC    CL133' 0,000,000 MAIL DIRECTORY RECORDS'\nTRAILER6 DC    CL133' 0,000,000 USED MAIL RECORDS'\nTRAILER7 DC    CL133' 0,000,000 UNUSED MAIL RECORDS'\n         EJECT\nBUFFER1  DS    0CL129\nR1BCPTRP DC    XL4'00'           RBA OF 1ST NOTICES DIRECTORY\nR1USPTRP DC    XL4'00'           RBA OF 1ST USER MAIL DIRECTORY\nR1RECNUM DC    XL4'00'           TOTAL RECORDS IN SYS1.BRODCAST\nR1BCMAX  DC    XL2'00'           MAX. BRODCAST MESSAGE NUMBER\nR1DSN    DC    CL24' SYS1.BRODCAST DATA SET '\nR1LEVEL  DC    CL7'LEVEL 2'\n         DC    XL1'00'\nR1FRESRH DC    XL3'00'           RBA TO FREE RECORD ???\nR1GENNUM DC    XL4'00'           GENERATION NUMBER FOR NOTICE TABLE\n         DC    XL76'00'\n*\nBUFFER2  DS    0CL129\nB2ENT    DS    25XL5\nB2END    DS    XL1\nB2NEXT   DS    XL3\n*\nBUFFER3  DS    0CL129\nENTRY    DS    9CL13\n         DS    XL8\nUSDREND  DS    XL1\nUSDNEXT  DS    XL3\n*\nBUFFER4  DS    0CL129\nUSMLNG   DS    XL1\nUSMTEXT  DS    CL125\nUSMNEXT  DS    XL3\n*\n         LTORG\n*\nUSDENTRY DSECT\nUSERID   DS    CL7\nRBA1ST   DS    XL3\nRBALAST  DS    XL3\n*\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT691/FILE691.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT691", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}