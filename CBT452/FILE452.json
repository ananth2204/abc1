{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012049000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 5349526, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 23, "INMDSNAM": "CBT.V500.FILE452.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 5349526, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 5349526, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE452.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00T\\x06'", "DS1TRBAL": "b'l>'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x037\\x00\\t\\x03=\\x00\\x03\\x00U'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00I\\x01\\x19 \\x9f\\x01\\x19 \\x9f\\x144\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-07-28T00:00:00", "modifydate": "2019-07-28T14:34:49", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  452\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE452\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 104 MEMBERS COUNTED; CUMULATIVE SIZE IS 50,085 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/28/19    14:34:49    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INTRO": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00@\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12$\\x00\\x19\\x00\\x19\\x00\\x00\\xc9\\xd5\\xc6\\xd6@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:24:40", "lines": 25, "newlines": 25, "modlines": 0, "user": "INFO"}, "text": "                         Dan's\n                    MVS/JES2 Software\n\n   -------------------------------------------------------------------\n\n   I have been developing system software in an MVS/JES2 environment\n   since 1975 and have written quite a few tools to make my life and\n   those who I work with easier.\n   I hope you find them useful too.\n\n   Email me if you require further information about these tools, or\n   just want to say hello. You can also email me to report bugs or\n   request enhancements.  I am not promising anything but I will get\n   to them as quickly as possible.\n\n   I have other tools that I will be making available as soon as they\n   are packaged, so if you're looking for something, just ask and I'll\n   see if I have something that will help you out.\n\n   -------------------------------------------------------------------\n\n    Happy coding.\n    Dan D.\n    zOS.JES2@Gmail.com\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$CHANGE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00T\\x01\\x18\\x12/\\x01\\x18\\x12/ \\x01\\x00\\xbe\\x00\\xbe\\x00\\x00\\xc9\\xd5\\xc6\\xd6@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2018-05-02T00:00:00", "modifydate": "2018-05-02T20:01:54", "lines": 190, "newlines": 190, "modlines": 0, "user": "INFO"}, "text": "  EMail address is zOS.JES2@Gmail.com\n\n *--------------------------------------------------------------------*\n\n  Updates   (May  2018)\n  =============================\n  ADDTO    - CREATE is now a default value.\n           - &ADDTO Variable is built to use elsewhere.\n           - Support \"FIRST\" and \"LAST\" keywords.\n           - Allow installation to decide which of the \"FIRST/LAST\" or\n             \"REMOVE\" options should be the default.\n             This requires an update each time a new version is released\n  SYSMSGS  - Add Assembled/Linked version in LOADLIB.\n  IEFUJV   - Added new self defined symbols.\n           - Correct large Math processing.\n           - Correct NEGATIVE Math overflow.\n  D2BLS    - Add Installation Exit routine (D2BUSERX) to allow the\n             installation to add/alter specific DSECT statements when\n             building an IPCS format model.\n\n *--------------------------------------------------------------------*\n\n  Additions (June 2016)\n  =============================\n  CATEXTR  - Test program to show SVC 26 (CATALOG) FIELD data.\n  FAMSEXTR - Test program to show FAMS (SMS) FIELD data.\n\n *--------------------------------------------------------------------*\n\n  Changes  (Jan 2015)\n  =============================\n  ULUTSCAN - New - Unauthorized UCB Scan routine (Macro included).\n\n *--------------------------------------------------------------------*\n\n  Changes  (May 2014)\n  =============================\n  D2BLS    - New - DSECT to IPCS Format Model tool.\n\n *--------------------------------------------------------------------*\n\n  Changes  (Mar 2012)\n  =============================\n  ADDTO    - Add EAV Support\n  CATL     - Add EAV Support\n  LDS      - Add EAV Support\n  LWATMGR  - Add EAV Support\n  PACKMAP  - Add EAV Support\n  PRU      - Add EAV Support\n  SAFECOPY - Add EAV Support\n  STEPLIB  - Add EAV Support\n\n *--------------------------------------------------------------------*\n\n  Changes  (Jul 2011)\n  =============================\n  CHECKVOL - Sample program to use READVOL1 (STARTIO)\n  READVOL1 - Old startio program from 1988 that still still works.\n  NOTE: These are simply \"SAMPLES\".\n    Please do not venture into STARTIO until you've educated yourself.\n\n *--------------------------------------------------------------------*\n\n  Changes  (Jun 2011)\n  =============================\n  LISTAST - \"LISTA ST\" command replacement.\n\n *--------------------------------------------------------------------*\n\n  Changes  (May 2011)\n  =============================\n  Various Catalog Management macros were updated to point to File 689.\n  I worked with Pete when he wrote this document.\n\n *--------------------------------------------------------------------*\n\n  Changes  (Dec 2010)\n  =============================\n  USERINFO - Correct System Symbol data.\n  EDITSUB  - Edit Macro Program to submit directly to INTRDR.\n\n *--------------------------------------------------------------------*\n\n  Changes  (June 2010)\n  =============================\n  STEPLIB  - \"STEPLIB SAVE\" command will now create a &STEPLIB CLIST\n             variable.  If you alter the STEPLIB various times within\n             your application you can simply do the following...\n                STEPLIB SAVE\n                ....\n                STEPLIB ALLOC DA(&STEPLIB)\n\n *--------------------------------------------------------------------*\n\n  Changes  (March 2010)\n  =============================\n  STEPLIB  - Add support for z/OS 1.12.  The system created STEPLIB now\n             consists of a DCB as well as a DCBE.\n\n *--------------------------------------------------------------------*\n\n  Changes  (July 2009)\n  =============================\n  IEFUJV   - Corrected &ZJOBID. as SSIB does not contain the JES JOBID\n             at this point of conversion.\n           - Added &ZMONTHCH. And &ZMOY. (month in character format).\n\n *--------------------------------------------------------------------*\n\n  Changes  (April 2009)\n  =============================\n  STEPLIB  - Use SCHEDIRB to circumvent z/OS R1.11 D78 ABEND.\n  IEFUJV   - More documentation & TSO HELP for \"// SET \" statement.\n             Added ZJOBID.\n\n *--------------------------------------------------------------------*\n\n  Changes\n  =============================\n  IEFUJV   - Additional Date symbols with +/- capability.\n  LWATEDIT - Add 5 blank slots in case Sam's TSUB is to be used to\n            add entries to the table.\n\n *--------------------------------------------------------------------*\n\n  Changes\n  =============================\n  STEPLIB - Allow STEPLIB to run in a Batch TMP without leaving the\n            DCB Storage around forever.\n            Added some debug code to display the TCB structure.\n  LWATMGR - New Command for managing the TSO Authorization tables.\n  LWATEDIT- New ISPF dialog (in progress) to invoke LWATMGR.\n\n *--------------------------------------------------------------------*\n\n  Changes since CBT version 474\n  =============================\n  STEPLIB - Version Command\n          - Prevent OPEN failures (ie. S913)\n  #PLIST  - REXX tool from Hartmut Beckmann\n\n *--------------------------------------------------------------------*\n\n  Changes since CBT version 471\n  =============================\n  EMail address change\n  Mixed case messages\n  PRU DCB error fix\n  Install JCL cleanup\n\n *--------------------------------------------------------------------*\n\n  Changes since CBT version 469\n  =============================\n  STEPLIB - Don't FREEMAIN Storage.  It causes ABENDs when a DIAG trap\n            was enabled that converts CONDITIONAL to UNCONDITIONAL\n            FREEMAINs.\n            Storage will automatically be free'd at task termination.\n  IEFUJV  - ADDED - Provide SYMBOL substitution on \"JCL SET\" statements.\n\n *--------------------------------------------------------------------*\n\n  Changes since CBT version 465\n  =============================\n  PRU     - Recover all members & recognize PDS/E'S\n  PRUREXX - Updated\n  WGREXX  - Added\n  General sample modules added.  See $$README\n\n *--------------------------------------------------------------------*\n\n  Changes since CBT version 464\n  =============================\n  STEPLIB - Add ESTAE around OPEN IRB in case of S913 (or other) ABENDs.\n\n *--------------------------------------------------------------------*\n\n  Changes since CBT version 426\n  =============================\n  PACKMAP - Cleanup assembly - PUSH without POP.\n  STEPLIB - Recognize duplicate dataset names.\n          - Provide \"STACK/DESTACK\" function.\n          - Provide \"APF AUTHORIZATION\" checking.\n          - Correct \"STACK\"/\"DESTACK\" errors.\n  CATL    - Recognize PDSE/HFS files.\n  WHOSGOT - Correct \"WHO302I\" message for 8 character jobnames.\n  MSG     - As the new HLASM recognizes this instruction I renamed\n            my macro to #MSG and updated all referencing members.\n  USERINFO- Correct \"DF/DSS\" level display.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$INDEX": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x16\\x16\\x7f\\x01\\x16\\x16\\x7f\\x123\\x00P\\x00P\\x00\\x00\\xc9\\xd5\\xc6\\xd6@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-06-15T00:00:00", "modifydate": "2016-06-15T12:33:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "INFO"}, "text": "$$$INTRO - Old  introduction data.\n$$CHANGE - Change history.  I'll try to keep this more up to date.\n$$INDEX  - This member\n$$README - Documentation\n$ADDTO   - JCL to ASSEMBLE/LINK\n$CATL    - JCL to ASSEMBLE/LINK\n$CATERUN - JCL to run CATEXTR\n$CATEXTR - JCL to ASSEMBLE/LINK\n$CATL    - JCL to ASSEMBLE/LINK\n$CHKPROC - PROCEDURE JCL to run CHECKVOL\n$CHKVOL  - JCL to ASSEMBLE/LINK\n$D2BLS   - JCL to ASSEMBLE/LINK\n$D2BLSJ  - JCL to run D2BLS (DSECT to IPCS Format Model)\n$EDITSUB - JCL to ASSEMBLE/LINK\n$FAMSEXT - JCL to ASSEMBLE/LINK\n$FAMSRUN - JCL to run FAMSEXTR\n$IEFUJV  - JCL to ASSEMBLE/LINK\n$LDS     - JCL to ASSEMBLE/LINK\n$LISTAST - JCL to ASSEMBLE/LINK\n$LWATEDI - JCL to ASSEMBLE/LINK\n$LWATMGR - JCL to ASSEMBLE/LINK\n$MPFEXIT - JCL to ASSEMBLE/LINK\n$PACKMAP - JCL to ASSEMBLE/LINK\n$PRU     - JCL to ASSEMBLE/LINK\n$RECEIVE - JCL to RECEIVE THE XMIT MEMBERS\n$RETCODE - JCL to ASSEMBLE/LINK\n$SAFECPY - JCL to ASSEMBLE/LINK\n$SJFSAMP - JCL to ASSEMBLE/LINK\n$STEPLIB - JCL to ASSEMBLE/LINK\n$TEPTERM - JCL to ASSEMBLE/LINK\n$ULUTSCN - JCL to ASSEMBLE/LINK\n$USERINF - JCL to ASSEMBLE/LINK\n$WHOSGOT - JCL to ASSEMBLE/LINK\n$XMIT    - JCL to XMIT \"TO\" HELP/LOADLIB/MACLIB members\n\n#PLIST   - REXX donated by Hartmut Beckmann\n\nADDTO    - Assembler source - Add files to allocations.\nCATEXTR  - Assembler source - Extract & dump catalog FIELD data\nCATL     - Assembler source - LISTCAT type program\nCHECKVOL - Assembler source - Calls READVOL1 to read OFFLINE DASD label\nD2BLS    - Assembler source - Build IPCS Format Model from DSECT\nEDITSUB  - Assembler source - Sample EDIT macro to write to internal rdr\nFAMSEXTR - Assembler source - Extract & dump SMS/PDSE FIELD data\nHELP     - XMIT File of HELP members\nHEXDUMP  - Assembler source - General HEX display/print routine\nIEFACTRT - System exit to release STEPLIB storage for batch jobs.\nIEFUJV   - System exit to provile \"// SET\" statement substitution.\nJCLSYMBL - Documentation for IEFUJV\nJCLSYMBS - Sample \"// SET\" statements for IEFUJV\nLDS      - Assembler source - List Data Set information.\nLISTAST  - Assembler source - \"LISTA ST\" replacement.\nLISTVOL$ - JCL to assemble LISTVOLS\nLISTVOLS - Assembler source - Sample of catalog management macros.\nLOADLIB  - XMIT File of LOAD members\nLWAEDIT1 - ISPF Panel for LWATEDIT\nLWATEDIT - Assembler source - ISPF interface to LWATMGR\nLWATMGR  - Assembler source - Logon Work Area Table Manager.\nMACLIB   - XMIT File of MACLIB members\nMPFCOLOR - Assembler source - MPF EXIT to alter message attributes.\nMPFEXITS - Assembler source - Display MPF exits\nPACKMAP  - Assembler source - DASD volume space map.\nPRU      - Assembler source - PDS rescue utility.\nPRUREXX  - REXX to invoke PRU\nPRUREXX2 - REXX to invoke PRU\nREADVOL1 - Assembler source - Read Offline Volume's Label using STARTIO\nRETCODE  - Assembler source - Generate return codes for testing.\nSAFECOPY - Assembler source - Link to IEBCOPY while holding enqueues.\nSASSXX02 - Assembler source - CA-7 reader exit.\nSTEPLIB  - Assembler source - TSO Dynamic STEPLIB\nSTEPLIBO - Assembler source - Previous version of STEPLIB\nSVC26DOC - Documentation for SVC 26\nSYSMSGS  - Assembler source - Sample SYSMSGS write routine.\nTSOPARSE - Assembler source - General IKJSCAN/IKJPARS routine\nUSERICLI - CLIST to display USERINFO created variables\nULUTSCAN - Assembler source - UCB Scan using ULUT table\nULUTTEST - Assembler source - Sample program using ULUTSCAN\nUSERINFO - Assembler source - Build CLIST variabls for TSO user.\nWGREXX   - REXX to invoke WHOSGOT\nWHOSGOT  - Assembler source - Display Enqueue information.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\t\\x02\\x9f\\x01\\t\\x02\\x9f\\x152\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-01-29T00:00:00", "modifydate": "2009-01-29T15:32:34", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$NOTE02": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x10\\x08/\\x01\\x10\\x08/\\x19A\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-03-23T00:00:00", "modifydate": "2010-03-23T19:41:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    FILE452\nFrom:       \"Dan Dalby\" <MVS-JES2@Sympatico.ca>\nDate:       Fri, 20 Mar 2009 13:40:19 -0400\nTo:         \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nAttached is an updated version of my file.\n\nAlong with the LWATEDIT and STEPLIB changes, I've been working on\na request from Dean Tesar with reguards to my IEFUJV exit\nroutine.  The exit now has the capability of performing MATH on\nthe date symbols that it manages.  It changes a bunch of built in\nvariables (&symbol) that can be specified on \"SET\" statements,\nwhich means they can later be used in the job's JCL.\n\nSample...\n// SET TODAY='&YYYYDDD.'     generates TODAY='2009079'\n// SET YESTERDY=&YYYYDDD-1.'  generates YESTERDY='2009078'\n// SET TOMORROW='&YYYYDDD+1.'  generates TOMORROW='2009080'\nIt can also be used for system symbols as defined in IEASYMxx.\n\nBTW, I'm still tracking an IBM problem with z/OS 1.11 that causes\nSTEPLIB to fail.  It appears to be a problem with the CIRB macro\nand the STAB=(DYN) option.  I'm sure that this will be corrected\nbefore z/OS 1.11 is shipped.\n\nDan\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE03": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x10\\x08/\\x01\\x10\\x08/\\x19A\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-03-23T00:00:00", "modifydate": "2010-03-23T19:41:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File CBT452\nFrom:     \"Dan Dalby\" <MVS-JES2@Sympatico.ca>\nDate:     Tue, 9 Mar 2010 13:02:42 -0500\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nJan Ott from BMC notified me of a problem with my dynamic STEPLIB\ncommand on z/OS 1.12.  We won't have it installed and running\ntill early next week so I haven't encountered the problem yet.\n\nJan was very helpful and got approval from IBM to discuss the\nchanges with me.  The STEPLIB storage now consists of a DCBE as\nwell as a DCB, so it's doubled the amount of storage that they\nFREEMAIN when the job/TSU terminates.\n\nThe attached version is an update of my file with the new version\nof STEPLIB that Jan has verified works with z/OS 1.12.  As I will\nbe able to access it next week, I'll be able to do further stress\ntesting but I'm fairly certain that the attached code will\nresolve the problem.  If I encounter any other situation, I'll\ncontact you next week.\n\nI hope you and yours are all doing well.\nThanks a lot.\n\nDan\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE04": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x10\\x08/\\x01\\x10\\x08/\\x19A\\x00!\\x00!\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-03-23T00:00:00", "modifydate": "2010-03-23T19:41:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Dynamic STEPLIB command\nFrom:     Dan Dalby <MVS-JES2@Sympatico.ca>\nDate:     Tue, 9 Mar 2010 20:29:42 -0500\n\nGreetings,\n\nFor all the users of my dynamic STEPLIB command from the CBT\nFile 452 please be aware of a couple of situations.\n\nOn z/OS 1.11 you may encounter a D78 abend.\nOn z/OS 1.12 you may encounter a D0A-04 abend.\n\nThe D78 fix has been available for a while (April '09).\nThe D0A-04 fix has just been released.\n\nThis command was originally designed for use on TSO.  Some users\nhave extended the use of this command to execute in a batch TMP\nenvironment.  Please be aware that in a batch environment STEPLIB\ncleanup is not automatic.  The original STEPLIB DCB/DCBE storage\nwill be released but any storage acquired by the STEPLIB command\nwill be orphaned.  I suggest the use of \"STEPLIB CLOSE\" when\nterminating a batch TMP step that uses STEPLIB.  Failure to do so\nwill cause a small amount of LSQA to be orphaned and eventually\nmay cause problems in the INIT.\n\nPlease contact me with any problems/suggestions.\n\nDanD\n----------------------------------------------------------------------\nFor IBM-MAIN subscribe / signoff / archive access instructions,\nsend email to listserv@bama.ua.edu with the message: GET IBM-MAIN INFO\nSearch the archives at http://bama.ua.edu/archives/ibm-main.html\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE05": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00B\\x01\\x10\\x11\\x7f\\x01\\x10\\x11\\x7f\\x12V\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-27T00:00:00", "modifydate": "2010-04-27T12:56:42", "lines": 30, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 452 updates\nFrom:     \"Dan Dalby\" <DDalby@MVSSol.com>\nDate:     Mon, 26 Apr 2010 13:10:27 -0400\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nRecently, a JES3 site installed the STEPLIB command.  I've never\ndone much with JES3 so I don't know the minor differences.  This\nsite's SSIBJBID in the SSID was \"J\" for TSO users.  He thought\nthat was normal saying that they were JOBS running under TSO.\nRather than argue the fact I put in some extra code to\naccommodate this situation.   Now it determines if it's a TSO\nuser based on the OUCB.  I suppose it could work like that for\nALL types of subsystems, but as it was working fine for JES2 why\nmess with it.\n\nOddly enough I had another site ask about STEPLIB on a JES3 LPAR.\nThey were slightly confused with my internal data set names\n(MVS-JES2) and thought that JES2 macros were required.  After\nthat was cleared up they are continuing to investigate if STEPLIB\nwill resolve their problems.\n\nHere's the latest version for you to upload to the CBT site at\nyour leisure.\n\nThanks for all your work.\nDan\nDDalby@MVSSol.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE06": {"ttr": 537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x11\\x14O\\x01\\x11\\x14O\\x01\\x18\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-05-24T00:00:00", "modifydate": "2011-05-24T01:18:23", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT File 452\nFrom:     \"Dan Dalby\" <DDalby@Sympatico.ca>\nDate:     Mon, 23 May 2011 12:45:41 -0400\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nI was contacted today to see if there were any updates to STEPLIB\nfor z/OS 1.13.\n\nI checked my code and the big change was for z/OS 1.12 which was\nSTEPLIB version 1.16.\n\nThere were a few minor changes since then with support for JES3\nsites and the addition of a &STEPLIB clist variable that can be\nused after STEPLIB has been invoked.\n\nI went to the CBT site to verify that the latest version was\nthere only to find that version 1.16 is on the CBT site, not the\nlatest 1.18.\n\nEven though the one on the CBT site will work with z/OS 1.13,\nit's best that the latest version is available to users.\n\nAttached is the latest version of my file.\n\nThanks,\nDan\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE07": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x11\\x19\\x8f\\x01\\x11\\x19\\x8f\\x016\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-07-17T00:00:00", "modifydate": "2011-07-17T01:36:45", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 452 updates\nFrom:     \"Dan Dalby\" <DDalby@Sympatico.ca>\nDate:     Fri, 15 Jul 2011 12:39:19 -0400\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nAttached is a new version of my file.  No rush to upload it as\nthere really aren't any changes but a few users that I've been\ntalking to from IBM-MAIN wanted a sample of STARTIO.  I've\nresurrected some old code (1988) that reads the VOL1 label of a\nDASD volume while it's OFFLINE.\n\nIn case you're interested in this tool, it is CHECKVOL which I\nre-wrote as the original used an obscure message routine for\ndisplaying the output.  This is a simple MLWTO and an optional\nWTOR.  This module does nothing, it's READVOL1 that issues the\nSTARTIO to the specified device.  For this module I didn't really\nchange a thing so it's running code written long long ago...and\nstill works.  When this was written, our DASD management group\nused this as a step before initializing a DASD volume.  They\nsimply ran a multi-step job with CHECKVOL as the 1st step (with\nthe WAIT option) and if that got a return code zero the INIT step\nproceeded.  All done with COND= as the IF statement wasn't\navailable at the time.\n\nThanks and have a great summer.\nDan\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE08": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x12\\x06O\\x01\\x12\\x06O\\x132\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-04T00:00:00", "modifydate": "2012-03-04T13:32:30", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 452 Updates\nFrom:     \"Dan Dalby\" <DDalby@Sympatico.ca>\nDate:     Fri, 2 Mar 2012 22:48:44 -0500\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nHope all is going well there.\n\nI recently had a STEPLIB user from Germany mention that it showed\nup in the TRACKING report when the operator commands \"SETCON\nTRACKING=ON\" and \"D OPDATA,TRACKING\" are issued.  As we don't\nhave any EAV devices I've never paid much attention to this\ninformation.  I recall working with it a long time ago when\ndebugging code that used 1 byte console ids for WTO's.  It looks\nlike they've updated it to track a few things now.\n\nAnyway, while I was at it I updated a few other of the tools so\nthat they don't show up on this list any more.\n\nI've attached the new version.  There's no rush in getting it\nuploaded as the user from Germany is running the new version and\nnobody else is complaining.\n\nBye for now.\nDan\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE09": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x12!O\\x01\\x12!O 4\\x00>\\x00>\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-08-01T00:00:00", "modifydate": "2012-08-01T20:34:34", "lines": 62, "newlines": 62, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: SYSSCMD\nFrom:     \"Dan Dalby\" <DDalby@MVSSol.com>\nDate:     8/1/2012 4:02 PM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nHere's the updated file.\n\nWhile testing the IEASYMnn list, I found a bug.  If the symbol\nname did not begin with SYS then it was changed to SYS...\n\nThere is a system symbol called UNIXVER and it was displaying as\nblanks.  I discovered it was changed to SYSXVER.\n\nThis is corrected now and system symbols from IEASYMnn have the\ncorrect name even when they don't begin with SYS.\n\nI suspect there are lots of sites with their own symbols that do\nNOT begin with SYS.  Now they're available via USERINFO.\n\nI've added a comment block to the HELP for USERINFO for the\n&SYSSCMD problem.  Let me know if you think it needs more.\n\nDan\nDDalby@MVSSol.com\n> -----Original Message----- From: Dan Dalby\n> Sent: Wednesday, August 01, 2012 12:29 PM\n> To: Sam Golob\n> Subject: SYSSCMD\n>\n> Hi Sam,\n>\n> I just looked at the code and I guess I need to update the HELP.\n>\n> If you specify an option like IPLD when invoking USERINFO it\n> will update SYSSCMD with the 1st 8 characters of the variable.\n> The reason for this restriction is that &SYSSCMD is an IBM\n> variable that contains the SUB-COMMAND name.  All USERINFO does\n> is update the contents of the ECT control block where the\n> subcommand name resides...\n>\n>    ECTSCMD  DS    CL8      SUBCOMMAND NAME\n>\n> I've never really found much use for it but someone wanted that\n> capability a long long time ago and they were probably using a\n> field that was 8 characters or less.  I've always used the full\n> variable names.\n>\n> I've attached the clist I use to test this tool.  If you\n> specify \"%USERINFO TEST\" you get the variable data followed by\n> the Length.  Of course this is only some of the variables.  You\n> probably have more in IEASYM00 (or you can see them with D\n> SYMBOLS).  Also, as these are constructed clist variables the\n> code will not detect them as an operand and not update SYSSCMD.\n>\n> It's starting to sound more like &SYSSCMD is even less useful\n> than we thought ;-)\n>\n> Dan\n> DDalby@MVSSol.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12%\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:25:11", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$NOTE10": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x14\\x12O\\x01\\x14\\x12O\\x009\\x00\\x1a\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-04T00:00:00", "modifydate": "2014-05-04T00:39:50", "lines": 26, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  New version of File452\nFrom:     \"Dan Dalby\" <DDalby@MVSSol.com>\nDate:     5/2/2014 6:03 PM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\nThis version of File 452 contains a little tool that will take an\nassembled DSECT and create the appropriate BLSQMDEF/BLSQMFLD\nstatements required for an IPCS format model.\n\nOne of the other vendors mentioned that he did this function by\nhand.  I had the beginnings of this tool but still had to do a\nlot of work by hand.  This one ALMOST does it all.  Hopefully\nwith the other vendor using it we may get it so it DOES do it all ;-)\n\nHope you're well.\nCheers,\nDan\nDDalby@MVSSol.com\n\nNote from Sam Golob:\n\nA few other fixes were added to members:\n$$CHANGE $$INDEX $D2BLS $D2BLSJ ADDTO D2BLS HELP\nLOADLIB MACLIB PACKMAP STEPLIB\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE11": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14\"/\\x01\\x14\"/#\\x12\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-08-10T00:00:00", "modifydate": "2014-08-10T23:12:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: File 423\nFrom:     \"Dan Dalby\" <DDalby@MVSSol.com>\nDate:     8/10/2014 8:09 PM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nI ran the re-assemble/link jobs for each of the tools and found\nanother minor glitch.  They now all run clean and the LOADLIB\nversion contains current executable versions.\n\nTalk to you soon.\n\nDan\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12%\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:25:11", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    FILE452\nFrom:       \"Dan Dalby\" <zOS.JES2@Gmail.com>\nDate:       Fri, 20 Mar 2009 13:40:19 -0400\nTo:         \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nAttached is an updated version of my file.\n\nAlong with the LWATEDIT and STEPLIB changes, I've been working on\na request from Dean Tesar with reguards to my IEFUJV exit\nroutine.  The exit now has the capability of performing MATH on\nthe date symbols that it manages.  It changes a bunch of built in\nvariables (&symbol) that can be specified on \"SET\" statements,\nwhich means they can later be used in the job's JCL.\n\nSample...\n// SET TODAY='&YYYYDDD.'     generates TODAY='2009079'\n// SET YESTERDY=&YYYYDDD-1.'  generates YESTERDY='2009078'\n// SET TOMORROW='&YYYYDDD+1.'  generates TOMORROW='2009080'\nIt can also be used for system symbols as defined in IEASYMxx.\n\nBTW, I'm still tracking an IBM problem with z/OS 1.11 that causes\nSTEPLIB to fail.  It appears to be a problem with the CIRB macro\nand the STAB=(DYN) option.  I'm sure that this will be corrected\nbefore z/OS 1.11 is shipped.\n\nDan\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE3": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12%\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:25:11", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File CBT452\nFrom:     \"Dan Dalby\" <zOS.JES2@Gmail.com>\nDate:     Tue, 9 Mar 2010 13:02:42 -0500\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nJan Ott from BMC notified me of a problem with my dynamic STEPLIB\ncommand on z/OS 1.12.  We won't have it installed and running\ntill early next week so I haven't encountered the problem yet.\n\nJan was very helpful and got approval from IBM to discuss the\nchanges with me.  The STEPLIB storage now consists of a DCBE as\nwell as a DCB, so it's doubled the amount of storage that they\nFREEMAIN when the job/TSU terminates.\n\nThe attached version is an update of my file with the new version\nof STEPLIB that Jan has verified works with z/OS 1.12.  As I will\nbe able to access it next week, I'll be able to do further stress\ntesting but I'm fairly certain that the attached code will\nresolve the problem.  If I encounter any other situation, I'll\ncontact you next week.\n\nI hope you and yours are all doing well.\nThanks a lot.\n\nDan\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE4": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12%\\x00!\\x00!\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:25:11", "lines": 33, "newlines": 33, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Dynamic STEPLIB command\nFrom:     Dan Dalby <zOS.JES2@Gmail.com>\nDate:     Tue, 9 Mar 2010 20:29:42 -0500\n\nGreetings,\n\nFor all the users of my dynamic STEPLIB command from the CBT\nFile 452 please be aware of a couple of situations.\n\nOn z/OS 1.11 you may encounter a D78 abend.\nOn z/OS 1.12 you may encounter a D0A-04 abend.\n\nThe D78 fix has been available for a while (April '09).\nThe D0A-04 fix has just been released.\n\nThis command was originally designed for use on TSO.  Some users\nhave extended the use of this command to execute in a batch TMP\nenvironment.  Please be aware that in a batch environment STEPLIB\ncleanup is not automatic.  The original STEPLIB DCB/DCBE storage\nwill be released but any storage acquired by the STEPLIB command\nwill be orphaned.  I suggest the use of \"STEPLIB CLOSE\" when\nterminating a batch TMP step that uses STEPLIB.  Failure to do so\nwill cause a small amount of LSQA to be orphaned and eventually\nmay cause problems in the INIT.\n\nPlease contact me with any problems/suggestions.\n\nDanD\n----------------------------------------------------------------------\nFor IBM-MAIN subscribe / signoff / archive access instructions,\nsend email to listserv@bama.ua.edu with the message: GET IBM-MAIN INFO\nSearch the archives at http://bama.ua.edu/archives/ibm-main.html\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12$\\x00i\\x00i\\x00\\x00\\xc9\\xd5\\xc6\\xd6@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:24:40", "lines": 105, "newlines": 105, "modlines": 0, "user": "INFO"}, "text": "******************************************************\n*                                                    *\n*    (C) COPYRIGHT 1999, 2016 zOS.JES2@Gmail.com     *\n*    All Rights Reserved.                            *\n*                                                    *\n******************************************************\n\nLicensed material-program, Property of zOS.JES2@Gmail.com\nAll Rights Reserved by zOS.JES2@Gmail.com\n\nAs with the CBT source rules, this code may be freely distributed.\nHowever I retain ownership of this code.  Thus it may not be used, fully\nor in part in a commercial product or sold in any way.\n\nThe files included are all in TSO TRANSMIT format (XMIT).\n\nThey must be transferred to your mainframe using BINARY FB80 format.\n\nAfter the files have been uploaded, they can be expanded back into their\noriginal PDS format using the following commands:\n\n     RECEIVE INDATASET(this.pds(HELP))\n     RECEIVE INDATASET(this.pds(LOADLIB))\n     RECEIVE INDATASET(this.pds(MACLIB))\n\nThe HELP file contains TSO help members for the various command\nprocessors.\n\nThe LOADLIB file contains executable formats of all of the tools.\n\nThe MACLIB file contains various macros required for assembly of the\ntools.\n\nThe SOURCE file contains the tool source as well as JCL to assemble and\nLINK.\n\nIf any updates are made at your installation, I would like to hear about\nthem.  If any modifications are required, and you do not feel\ncomfortable updating the source, send an email to me, and I'll be glad\nto see what I can do.\n\nLastly, if you need assistance with any of this code,feel free to email\nme.  I would like to hear of any installation or documentation problems\nyou encounter.  Please email the address below with any comments.\n\nThank you,\nDan D.\nzOS.JES2@Gmail.com\n\n\n\nInstallation Instructions:\n\nMost of these tools require no special installation instructions.\nSimply assemble and linkedit them into a library of your choice.  The\nLOAD.XMI file is provided to allow you to try them without even\nperforming this step.\n\nADDTO, CATL, LDS, USERINFO and WHOSGOT are all command processors that\nmust reside in either your STEPLIB, ISPLLIB or a LINKLISTED library.\nSTEPLIB must reside in an authorized LINKLISTED library and the IKJTSOxx\nmember of SYS1.PARMLIB must be updated to include STEPLIB in the\nAUTHCMD section.\n\nPACKMAP, RETCODE and PRU may be run from any library.  PACKMAP will\nenqueue on the volume's VTOC while it is being read if it is authorized.\nRETCODE will not issue appropriate error messages for invalid PARM= if\nit is not authorized.\n\n\nTSO HELP members are provided for the various command processors.\nA REXX to invoke PRU has also been provided by Oscar Omar Ortega Ortega.\nAnother REXX to invoke WhosGot (mainly for use with ISPF DSLIST) has\nbeen provided by Greg Shirey.  Greg also contributed modifications to\nthe PRU REXX.\nThanks to all for making these tools better for everyone.\n\nSample Batch JCL:\n\n//PACKMAP   JOB   ...jobcard...\n//PACKMAP   EXEC  PGM=PACKMAP,REGION=4096K,TIME=1440\n//STEPLIB    DD   DSN=userid.MVS.LOAD,DISP=SHR\n//DISK       DD   UNIT=SYSALLDA,VOL=SER=volser,DISP=SHR\n//SYSPRINT   DD   SYSOUT=*\n\n//PRU       JOB   ...jobcard...\n//PRU       EXEC  PGM=PRU,REGION=4096K,TIME=1440\n//*     PARM=ALL <--- COPY \"LIVE\" MEMBERS AS WELL\n//STEPLIB    DD   DSN=userid.MVS.LOAD,DISP=SHR\n//SYSPRINT   DD   SYSOUT=*\n//INPUT      DD   DSN=original.PDS.file,DISP=SHR\n//OUTPUT     DD   DSN=new.PDS.file,DISP=(,CATLG),\n//                UNIT=SYSDA,SPACE=(CYL,(30,10,90))\n\n//RETCODE   JOB   ...jobcard...\n//JOBLIB     DD   DSN=userid.MVS.LOAD,DISP=SHR\n//RC00      EXEC  PGM=RETCODE,PARM='RC(0)'\n//RC04      EXEC  PGM=RETCODE,PARM='RC(4)'\n//RC08      EXEC  PGM=RETCODE,PARM='RC(8)'\n//RC12      EXEC  PGM=RETCODE,PARM='RC(12)'\n//USER99    EXEC  PGM=RETCODE,PARM='USER(99)'\n//SYSTEM99  EXEC  PGM=RETCODE,PARM='SYSTEM(99)',COND=EVEN\n\nDan D.\nzOS.JES2@Gmail.com\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ADDTO": {"ttr": 790, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//ADDTO    JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(ADDTO),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(ADDTO),DISP=SHR\n//*\n//LINK     EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(ADDTO)\n  ENTRY    ADDTO\n  NAME     ADDTO(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CATERUN": {"ttr": 792, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x16\\x16\\x7f\\x01\\x16\\x16\\x7f\\x123\\x01\\x94\\x01\\x94\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-06-15T00:00:00", "modifydate": "2016-06-15T12:33:32", "lines": 404, "newlines": 404, "modlines": 0, "user": "JCL"}, "text": "//CATEXTR  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        UPDATE THE FOLLOWING \"SET\" STATEMENTS.                     *\n//*                                                                   *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//EXTRACT  EXEC  PGM=CATEXTR,REGION=0M,TIME=NOLIMIT\n//*        PARM=CATACB\n//*\n//* NOTE: TRY IT WITH \"PARM=CATACB\" TO SEE IF THERE IS ANY DIFFERENCE.\n//*\n//STEPLIB  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\nDSN=your.dataset.name\nACCESS     -\nACCOUNT    -\nACTOKEN    - 36 - ACTIVE COMPRESSION DICTIONARY TOKEN.\nALOCINIT   -\nAMDCIREC   -  8 - CONTROL INTERVAL SIZE FOR 4 BYTES AND MAXIMUM\n*                 RECORD SIZE FOR 4 BYTES.\nAMDKEY     -  4 - RELATIVE POSITION OF KSDS KEY FOR 2 BYTES AND KEY\n*                 LENGTH OF KSDS KEY FOR 2 BYTES.\nAMDSBCAT   -\nAMDSBSC    -\nAMDSB1     -\nAMDSB2     -\nAMDSB3     -\nAKEYPOS    -  2 - THE RELATIVE POSITION IN THE DATA RECORD OF THIS AIX\n*                 KEY. ONLY APPLICABLE FOR CATALOG ENTRY TYPES OF\n*                 AIX. NOTE THAT THE FIELD IS ONLY VALID IF THE\n*                 COMPONENT TYPE IS \"D\" AND THE RECORD TYPE IS FOR A\n*                 ALTERNATE INDEX.\nASSOCSC    -\nASSOCSYM   - 45 - A REPEATING LIST OF CATALOG RECORDS ASSOCIATED WITH\n*                 THIS ENTRY. CONSISTS OF A 1-BYTE VALUE SIMILAR TO\n*                 FIELD NAME ENTYPE, FOLLOWED BY THE 44-BYTE\n*                 NAME OF THE ASSOCIATION. IF THE NAME CONTAINS\n*                 SYSTEM SYMBOLICS, THEY ARE NOT RESOLVED.\nATIME      -\nATTRFLGS   -\nATTR1      -  1 - ATTRIBUTES:\n*                 1... .... - SPEED\n*                 .1.. .... - UNIQUE\n*                 ..1. .... - REUSABLE\n*                 ...1 .... - ERASE\n*                 .... 1... - ECSHARING - ICF CATALOGS ONLY\n*                 .... .1.. - INHIBIT UPDATE\n*                 .... ..1. - TEMPORARY EXPORT\n*                 .... ...1 - TRACK OVERFLOW\nATTR2      -  1 - SHARE ATTRIBUTES\n*                 11.. .... - REGION (00 = 1, 01 = 2, 10 = 3, 11 = 4)\n*                 ..11 .... - SYSTEM (00 = 1, 01 = 2, 10 = 3, 11 = 4)\n*                 .... 1111 - NOT DEFINED\nBITMAP     -\nBUFSIZE    -  4 - MAXIMUM BUFFER SIZE\nCATACB     -\nCATTR      -  1 - ATTRIBUTES FOR PAGESPACE AND SWAPSPACE\n*                 1111 11.. - NOT DEFINED\n*                 .... ..1. - SWAP=1, NOSWAP=0\n*                 .... ...1 - DATA SET IS A PAGESPACE\nCATVOL     -\nCATVOL2    -\nCCSID      -\nCHARSCNT   -\nCISIZE     -\nCOMPIND    -  1 - COMPRESSION INDICATOR.\n*                 1..1 1111 - NOT DEFINED.\n*                 .1.. .... - DATA SET IS EXTENDED FORMAT\n*                 ..1. .... - DATA SET IS COMPRESSIBLE\nCOMUDSIZ   -  8 - COMPRESSED USER DATA SIZE\nCRACRETS   -\nCRADEVT    -\nCRADIRCT   -\nCRADITS    -\nCRAIDNO    -\nCRAVOL     -\nCTIME      -\nDATACLAS   - VL - SMS DATA CLASS\nDATASPAC   -\nDEVTYP     -  4 - UCB DEVICE TYPE\nDEXTENTS   -\nDFMFLGS    -\nDIRECTRY   -\nDPASALL    -\nDSATRO     -\nDSATTR     -\nDSCBPTR    -\nDSCBTS     -\nDSCBTTR    -  3 - TTR OF FORMAT-1 DSCB FOR NON-VSAM DATA SET\nDSCRDT2    -  4 - CREATION DATE. PACKED DECIMAL YYDDDF FOR 3\n*                 BYTES APPENDED WITH ONE BYTE CENTURY INDICATOR. IF\n*                 THE CENTURY BYTE IS 00 THEN ADD 1900 TO GET THE\n*                 YEAR; IF 01, ADD 2000.\nDSCRETS    -\nDSDIRECT   -\nDSDIRFLG   -\nDSDIRSN    -\nDSETEXDT   -\nDSEXDT2    -  4 - EXPIRATION DATE. PACKED DECIMAL YYDDDF FOR 3\n*                 BYTES APPENDED WITH ONE BYTE CENTURY INDICATOR. IF\n*                 THE CENTURY BYTE IS 00 THEN ADD 1900 TO GET THE\n*                 YEAR; IF 01, ADD 2000.\nDSIDNO     -\nDSPDSCRP   -\nDSPSOPT    -\nDSPSSQ     -\nDSSPSN     -\nDSSUMTT    -\nDSTYPNAM   -\nEATTR      -  1 - DATA SET ATTRIBUTE FOR CONTROLLING ALLOCATION OF\n*                 VSAM DATA SETS (NOTE THAT EATTR FOR NON-VSAM\n*                 DATA SETS IS NOT CARRIED IN THE CATALOG INFORMATION\n*                 FOR SUCH DATA SETS). THE VALUE OF EATTR IS AS\n*                 FOLLOWS:\n*                 - X'00' - EATTR NOT SPECIFIED. DEFAULTS FOR EAS\n*                 ELIGIBILITY SHOULD APPLY.\n*                 - X'01' - EATTR=NO SPECIFIED. THE DATA SET\n*                 CANNOT HAVE EXTENDED ATTRIBUTES HAVE AND\n*                 CANNOT RESIDE IN EAS.\n*                 - X'02' - EATTR=OPT SPECIFIED. THE DATA SET CAN\n*                 HAVE EXTENDED ATTRIBUTES AND CAN OPTIONALLY\n*                 RESIDE IN AN EAS.\n*                 - X'03' - NOT USED. EATTR VALUE TREATED AS NOT\n*                 SPECIFIED.\nENTASSOC   -\nENTIDNO    -\nENTNAME    - 44 - THE NAME OF THE ENTRY\nENTUPGD    -\nENTVOL     -\nENTVOL2    -\nENTYPE     -  1 - ENTRY TYPE, EX., 'C' IS CLUSTER, 'A' IS NON-VSAM, ETC.\nEXCPEXIT   -  8 - EXCEPTION EXIT\nEXTENT     -\nEXTSTART   -\nEXTVOL     -\nFILCLSC    -\nFILEDATA   -\nFILESEQ    -  2 - FILE SEQUENCE NUMBER\nFILESIZE   -\nFRLOG      -\nFSDSFLAG   -  1 - FILE SYSTEM DATA SET FLAG\n*                 X'00' - NOT A ZFS DATA SET\n*                 X'80' - ZFS DATA SET\n*                 X'FF' - ATTRIBUTE NOT APPLICABLE TO ENTRY\nGDGALTDT   -  4 - LAST ALTERATION DATE. PACKED DECIMAL YYDDDF FOR\n*                 3 BYTES APPENDED WITH ONE BYTE CENTURY INDICATOR.\n*                 IF THE CENTURY BYTE IS 00 THEN ADD 1900 TO GET THE\n*                 YEAR; IF 01, ADD 2000.\nGDGATTR    -  1 - GENERATION DATA GROUP ATTRIBUTES\n*                 0... .... - DELETE OLDEST GDS WHEN GATLIMIT EXCEEDED\n*                 1... .... - DELETE ALL GDSS WHEN GATLIMIT EXCEEDED\n*                 .0.. .... - DO NOT SCRATCH DATA SET WHEN ROLLED OFF\n*                 .1.. .... - SCRATCH DATA SET WHEN ROLLED OFF IF VOLUME\n*                             MOUNTED\nGDGLIMIT   -  1 - MAXIMUM NUMBER OF GENERATION DATA SETS ALLOWED\n*                 IN THE GDG\nGDGLVLIM   -\nGDGNAME    -\nGENDSP     -\nGENLEVEL   -  4 - GDG GENERATION LEVEL   1 FOR EACH ACTIVE\n*                 GENERATION IN EBCDIC FORMAT C'0000'\nGENLVLS    -\nGID        -\nHARBA      -  4 - HIGH-ALLOCATED RBA\nHARBADS    -  4 - DATA SET HIGH-ALLOCATED RBA\nHIKEYV     - VL - HIGH KEY ON VOLUME\nHKRBA      -  4 - RBA OF DATA CONTROL INTERVAL WITH HIGH KEY\nHKURBA     -\nHURBA      -  4 - HIGH-USED RBA FOR THE VOLUME REQUESTED\nHURBADS    -  4 - DATA SET HIGH-USED RBA\nIRFLAG     -\nITYPEXT    -  1 - TYPE OF EXTENT\n*                 1... .... - SEQUENCE SET WITH DATA, IMBED\n*                 .1.. .... - EXTENTS NOT PREFORMATTED\n*                 ..1. .... - CONVERTED VSAM DATA SET VOLUME\n*                 ...1 1111 - NOT DEFINED\nKEYLNGTH   -\nKEYPOS     -\nLCBCONID   -\nLCBDESCR   -\nLCBDEVTP   -\nLCBEMPTY   -\nLCBLIBID   -\nLCBLOGIC   -\nLCBSCRTH   -\nLCBSLOTS   -\nLCBTHRES   -\nLOGPARMS   -  1 - VALUE OF LOG PARAMETER SET\n*                 BY IDCAMS DEFINE/ALTER\n*                 X'00' - NEVER SET\n*                 X'01' - LOG(NONE)\n*                 X'02' - LOG(UNDO)\n*                 X'03' - LOG(ALL)\nLOGSTRID   - 26 - VALUE OF LOGSTREAMID PARAMETER SET BY\n*                 IDCAMS DEFINE/ALTER\nLOKEYV     - VL - LOW KEY ON VOLUME\nLRECL      -  4 - AVERAGE LOGICAL RECORD SIZE\nLTBACKDT   -  8 - LAST BACKUP DATE IN TOD FORMAT\nMAPSPACE   -\nMAXARNB    -\nMGMTCLAS   - VL - SMS MANAGEMENT CLASS\nMTIME      -\nMULTITYP   -\nNAME       - 44 - THE NAME OF AN ASSOCIATED ENTRY\nNAMEDS     -\nNOBLKTRK   -  2 - NUMBER OF PHYSICAL BLOCKS PER TRACK. THIS IS THE\n*                 VALUE REPORTED BY IDCAMS LISTCAT AS\n*                 PHYRECS/TRK\nNOBYTAU    -  4 - NUMBER OF BYTES PER ALLOCATION UNIT\nNOBYTTRK   -  4 - NUMBER OF BYTES PER TRACK\nNODSDSP    -\nNODSET     -\nNODSEXT    -\nNODSPACE   -\nNODSPEXT   -\nNOEXTNT    -  1 - NUMBER OF EXTENTS. THIS IS THE VALUE REPORTED BY\n*                 IDCAMS LISTCAT AS EXTENTS.\nNONVOL     -\nNOTRKAU    -  2 - NUMBER OF TRACKS PER ALLOCATION UNIT. THIS IS THE\n*                 VALUE REPORTED BY IDCAMS LISTCAT AS\n*                 TRACKS/CA.\nNOTRKEXT   -\nNVSMATTR   -  1 - NON-VSAM ATTRIBUTE INFORMATION\n*                 H - ACTIVE GDS\n*                 N - DEFERRED GDS\n*                 M - ROLLED-OFF GDS\n*                 L - EXTENDED PARTITIONED DATA SET (PDSE)\n*                 P - POSIX DATA SET\n*             X'00' - SIMPLE NON-VSAM DATA SET\nOPENCNT    -\nOPENC2     -\nOPENIND    -  1 - OPEN INDICATOR\n*                 1... .... - OPEN =1, NOT OPEN=0, 1 MAY MEAN THAT THE\n*                             DATA SET WAS NOT CLOSED PROPERLY\nOPNCALL1   -\nOWNERID    -  8 - OWNER OF THE DATA SET\nPASSATMP   -  2 - NUMBER OF ATTEMPTS TO PROMPT FOR PASSWORD\nPASSPRMT   -  8 - PASSWORD PROMPT CODE NAME\nPASSWALL   -\nPASSWORD   - 32 - FOUR 8-BYTE PASSWORDS (VSAM DATA SETS ONLY)\nPHYBLKSZ   -  4 - PHYSICAL BLOCKSIZE. THIS IS THE VALUE REPORTED BY\n*                 IDCAMS LISTCAT AS PHYREC-SIZE.\nPRIMSPAC   -  3 - PRIMARY SPACE ALLOCATION\nRCDCOUNT   -\nRECVTIME   -  8 - RECOVERY TIME, TOD VALUE, LOCAL\nRECVTIMG   -  8 - RECOVERY TIME, TOD VALUE, GMT\nRELCRA     -\nRELIND     -\nREPNO      -\nREPTOKEN   -\nRGATTR     -  1 - ALTERNATE INDEX/PATH ATTRIBUTES\n*                 1... .... - UPGRADE=1, NOUPGRADE=0\n*                 .1.. .... - ENTRY IS AN ALTERNATE INDEX\n*                 ..11 1111 - NOT DEFINED\nRLSBWO     -  1 - VALUE OF BWO PARAMETER SET BY\n*                 IDCAMS DEFINE/ALTER\n*                 XXXX 0000 - UNDEFINED OR NOT SET\n*                 XXXX 0001 - BWO(TYPECICS)\n*                 XXXX 0010 - RESERVED\n*                 XXXX 0011 - BWO(TYPEIMS)\n*                 XXXX 0100 - RESERVED\nRLSFLAGS   -  1 - XXXX 0XXX - RECOVERY NOT REQUIRED\n*                 XXXX 1XXX - RECOVERY REQUIRED\nRLSRCRQN   -\nSCONSPAC   -  3 - SECONDARY SPACE ALLOCATION\nSECFLAGS   -  1 - SECURITY FLAG INFORMATION X'80' MEANS THE DATA SET\n*                 HAS A DISCRETE RACF PROFILE\nSLOCVOL    -\nSMSINFOM   -\nSMSSCMC    -\nSMSSFLAG   -  1 - SMS FLAGS\n*                 1... .... - VSAM EXTENDED FORMAT\n*                 .1.. .... - VSAM COMPRESSABLE INDICATOR\n*                 ..1. .... - RLS IN USE\n*                 ...1 .... - RLS VSAM QUIESCED\n*                 .... 1111 - NOT DEFINED\nSNSPHD     -\nSPACEHDR   -\nSPACEMAP   -\nSPACOPTN   -  1 - EQUALS '01' FOR RECORD ALLOCATION, '10' FOR TRACK\n*                 ALLOCATION, AND '11' FOR CYLINDER\nSPACPARM   -\nSPEXTENT   -\nSPHDFLG    -\nSTORCLAS   - VL - SMS STORAGE CLASS\nSTRIPCNT   -  2 - STRIPING COUNTS FOR STRIPED DATA SETS\nSYSEXTDS   -\nSZTME      -\nTEXTCHNG   -\nTOENTVOL   -\nTOVOLDEV   -\nTRBAEXT    -\nTRKSUSED   -\nTYPE       -  1 - THE TYPE OF AN ASSOCIATED ENTRY\nUDATASIZ   -  8 - USER DATA SIZE\n*                 RESTRICTION: THIS FIELD IS ONLY VALID FOR EXTENDED\n*                 FORMAT VSAM AND NON-VSAM DATA SETS.\nUID        -\nUPDVOL     -\nUPGRADE    -\nUSERAREC   - VL - USER AUTHORIZATION RECORD\nUSVRMDUL   -  8 - USER SECURITY VERIFICATION MODULE\nVCBCHKPT   -\nVCBCRDT    -\nVCBDEVTP   -\nVCBEDATE   -\nVCBERRST   -\nVCBEXPDT   -\nVCBLIBNM   -\nVCBLOC     -\nVCBMOUNT   -\nVCBOWNER   -\nVCBSGRP    -\nVCBSHELF   -\nVCBUATTR   -\nVCBWPROT   -\nVCBWRITE   -\nVOLDEV     -\nVOLDVCHR   -\nVOLEXT     -\nVOLFLG     -  1 - '100' IS THE PRIMARY VOLUME WITH SPACE ALLOCATED,\n*                 '010' IS THE CANDIDATE VOLUME WITH NO SPACE\n*                 ALLOCATED, '001' IS THE OVERFLOW VOLUME (KEYRANGE\n*                 DATA SET ONLY) WITH NO SPACE ALLOCATED\nVOLOAMDN   -\nVOLPHY     -\nVOLRFLG    -\nVOLSER     -  6 - VOLUME SERIAL NUMBER. A VOLSER OF ALL ASTERISKS\n*                 IS THE IPL VOLUME. FOR A SYMBOLIC VALUE (FOR\n*                 EXAMPLE, \"&XXXXX\"), USE THE ASASYMBM SERVICE\n*                 TO CONVERT THE SYMBOLIC VALUE TO A VALID CHARACTER\n*                 STRING.\nVOLTSTMP   -\nVSAMREUS   -  1 - VSAM DATA SET INFORMATION\n*                 1... .... - DATA SET HAS RACF DISCRETE PROFILE\n*                 .1.. .... - INDEX COMPONENT DATA SET\n*                 ..1. .... - REUSABLE DATA SET\n*                 ...1 .... - ERASE SPECIFIED (CLUSTER ONLY)\n*                 .... 11.. - NOT DEFINED\n*                 .... ..1. - SWAP SPACE (CLUSTER ONLY)\n*                 .... ...1 - PAGE SPACE (CLUSTER ONLY)\nVSAMSTAT   - 46 - STATISTICS INFOMATION FOR VSAM COMPONENTS.\n*                 1 - PERCENTAGE OF FREE CIS IN CA\n*                 1 - PERCENTAGE OF BYTES FREE IN CI\n*                 2 - NUMBER CIS/ CA\n*                 4 - FREE CIS/ CA\n*                 2 - FREE BYTES/CI\n*                 4 - NUMBER OF LOGICAL RECORDS\n*                 4 - NUMBER OF DELETED RECORDS\n*                 4 - NUMBER OF INSERTED RECORDS\n*                 4 - NUMBER OF UPDATED RECORDS\n*                 4 - NUMBER OF RETRIEVED RECORDS\n*                 4 - BYTES OF FREE SPACE IN COMPONENT. FOR\n*                     NON-EXTENDED ADDRESSABILITY DATA SETS, THIS FIELD\n*                     REPRESENTS THE ACTUAL AMOUNT OF FREE SPACE IN THE\n*                     COMPONENT. IF THE DATA SET IS EXTENDED\n*                     ADDRESSABLE, THE VALUE IN THE FIELD IS THE NUMBER\n*                     OF FREE CIS; THE BYTES OF FREESPACE CAN BE\n*                     OBTAINED BY MULTIPLYING THE FIELD VALUE BY THE CI\n*                     SIZE.\n*                 4 - NUMBER OF CI SPLITS\n*                 4 - NUMBER OF CA SPLITS\n*                 4 - NUMBER OF EXCPS\nVSAMTYPE   -  2 - VSAM DATA SET TYPE INFORMATION\n*       1ST BYTE  1... .... - KSDS=1, NOT KSDS=0\n*                 .1.. .... - WRITE CHECK\n*                 ..1. .... - IMBED\n*                 ...1 .... - REPLICATE\n*                 .... 1... - NOT DEFINED\n*                 .... .1.. - KEY-RANGE DATA SET\n*                 .... ..1. - RRDS\n*                 .... ...1 - SPANNED RECORDS ALLOWED\n*       2ND BYTE  1... .... - NON-UNIQUE OR UNIQUE KEYS ALLOWED\n*                 ...1 1.1. - NOT DEFINED\n*                 .1.. .... - 0=CA-RECLAIM(YES),\n*                             1=CA-RECLAIM(NO)\n*                 ..1. .... - THE DATA SET WAS NOT CLOSED PROPERLY AND\n*                             THE RECORDED STATISTICS ARE NOT ACCURATE.\n*                 .... .1.. - LDS\n*                 .... ...1 - VRRDS\nVVRNFLGS   -  2 - EXTENDED FORMAT FLAGS\n*       1ST BYTE  1... .... - COMUDSIZ AND UDATASIZ ARE INVALID\n*                 .111 1111 - BLOCK LEVEL COMPRESSION\n*                 ..11 1111 - NOT DEFINED\n*       2ND BYTE  1111 1111 - NOT DEFINED\nVVRRDATA   -\nVVRROWNR   -\nVVRSBWON   -\nVVRSHWRN   -\nVVRSMSFG   -\nXACIFLAG   -  1 - EXTENDED ATTRIBUTE FLAGS\n*                 X... .... - RESERVED, MAY BE ON\n*                 .X.. .... - DATA SET CAN BE GREATER THAN 4GB\n*                 ..XX .... - RESERVED, MAY BE ON\nXENTV2CI   -\nXHARBA     -  8 - HIGH-ALLOCATED RBA\nXHARBADS   -  8 - DATA-SET HIGH-ALLOCATED RBA\nXHKRBA     -  8 - RBA OF DATA CONTROL INTERVAL WITH HIGH KEY\nXHURBA     -  8 - HIGH-USED RBA FOR THE VOLUME REQUESTED\nXHURBADS   -  8 - DATA-SET HIGH-USED RBA\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CATEXTR": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//CATEXTR  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(CATEXTR),DISP=(,PASS),\n//         UNIT=SYSDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(CATEXTR),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(CATEXTR)\n  ENTRY    CATEXTR\n  NAME     CATEXTR(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CATL": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//CATL     JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(CATL),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(CATL),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(CATL)\n  ENTRY    CATL\n  NAME     CATL(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHKPROC": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x11\\x19o\\x01\\x11\\x19o\\x12$\\x00\\n\\x00\\n\\x00\\x00\\xd7\\xd9\\xd6\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-07-15T00:00:00", "modifydate": "2011-07-15T12:24:29", "lines": 10, "newlines": 10, "modlines": 0, "user": "PROC"}, "text": "//CHECKVOL PROC  U=JCL-ERROR,WAIT=\n//*------------------------------------------------------------------*\n//*                                                                  *\n//*   START SYNTAX:                                                  *\n//*      S CHECKVOL,U=2000                                           *\n//*      S CHECKVOL,U=2000,WAIT=Y                                    *\n//*                                                                  *\n//*------------------------------------------------------------------*\n//CHECKVOL EXEC  PGM=CHECKVOL,PARM='&U,WAIT=&WAIT'\n//STEPLIB  DD    DSN=YOUR.APF.LIBRARY,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CHKVOL": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x001\\x001\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 49, "newlines": 49, "modlines": 0, "user": "JCL"}, "text": "//CHECKVOL JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM1     EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(CHECKVOL),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(CHECKVOL),DISP=SHR\n//*\n//ASM2     EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(READVOL1),DISP=(OLD,PASS)\n//SYSIN    DD    DSN=&SOURCE(READVOL1),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(CHECKVOL)\n  INCLUDE  SYSPUNCH(READVOL1)\n  SETCODE  AC(1)\n  ENTRY    CHECKVOL\n  NAME     CHECKVOL(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$D2BLS": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//D2BLS    JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(D2BLS),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(D2BLS),DISP=SHR\n//*\n//LINK     EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(D2BLS)\n  ENTRY    D2BLS\n  NAME     D2BLS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$D2BLSJ": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00o\\x00o\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 111, "newlines": 111, "modlines": 0, "user": "JCL"}, "text": "//IPCSMOD  JOB   ...JOBCARD...                                          JOB07102\n//*-------------------------------------------------------------------*\n//*                                                                   *\n//*        Create IPCS Format Model from a DSECT                      *\n//*                                                                   *\n//*        Update the following \"SET\" statement.                      *\n//*                                                                   *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASSEMBLE EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//         PARM='TERM,DECK,NOOBJECT,NORLD,NOUSING,FLAG(PAGE0)'\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPRINT DD    DISP=(,CATLG),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1)),\n//         DCB=(DSORG=PS,RECFM=FBA,LRECL=133,BLKSIZE=27930)\n//SYSPUNCH DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSIN    DD    *\n*PROCESS NOUSING\nDSECT    CSECT ,\n         DC    X'00'\n         IEFZB502 ,              SWA Block Prefix\n         IEFASIOT ,              Step Input/Output Table\nDSECT    CSECT ,\n         END   ,\n//*-------------------------------------------------------------------*\n//*        Sample of using PARM=                                      *\n//*-------------------------------------------------------------------*\n//PARM     EXEC PGM=D2BLS,\n//  PARM=('NA=$SIOT,BA=ZB502,LA=SIO',\n//        'AL=SWPACRO,AN=SIOT',\n//        'DE=10,PR=NOGEN')\n//STEPLIB  DD   DSN=&LOADLIB,DISP=SHR\n//SYSUDUMP DD   SYSOUT=*\n//ASSEMBLY DD   DSN=*.ASSEMBLE.SYSPRINT,DISP=(OLD,PASS)\n//SYSPUNCH DD   SYSOUT=*\n//*-------------------------------------------------------------------*\n//*        Sample of using SYSIN                                      *\n//*-------------------------------------------------------------------*\n//SYSIN    EXEC PGM=D2BLS\n//STEPLIB  DD   DSN=&LOADLIB,DISP=SHR\n//SYSUDUMP DD   SYSOUT=*\n//ASSEMBLY DD   DSN=*.ASSEMBLE.SYSPRINT,DISP=(OLD,PASS)\n//SYSPUNCH DD   SYSOUT=*\n//SYSIN    DD   *\n* NAME= or NA= is the LABEL assigned to the IPCS Format model.\nNAME=$SIOT,\n\n* BASELBL= or BA= initial DSECT label\nBASELBL=ZB502,\n\n* CBLEN= or CB= is the user specified length of the control block.\n* If omitted the DSECT length will be used.\n\n* ACROLBL= or AL= is the LABEL that contains the control block acronym.\nACROLBL=SWPACRO,\n\n* ACRONYM= or AN= is the value of the ACROLBL field's contents.\nACRONYM=SIOT,\n\n* DECODE= or DE= indicates that True EQU values are to be identified\n* at the end of the mapping.  The operand indicates when the 1st EQU\n* may be found.  Others before this offset will be ignored.\nDECODE=10,\n\n* PRINT= or PR= is used to surround the mapping with \"PRINT GEN/NOGEN\".\nPRINT=NOGEN,\n\n* SHEADER= or SH= can be used to produce a header prior to the mapping\n* being expanded.\n\n* SFOOTER= or SF= can be used to produce a footer at the end of the\n* mapping expansion.\n\n* CSECT can be specified to generate the mapping as a CSECT.\n\n* END can be specified to terminate the mapping with an END statement.\n\n* MAINTLV= or ML= can be used to define a maintenance or change level\n* indicator.  The default will be the current date in CCYY.DDD format.\n\n* HEADER= or HE= defines the heading name to be displayed with the\n* control block virtual storage address.  If ACRONYM= is specified it\n* will be used if HEADER= is not specified.\n\n* LABEL= or LA= can be used to define a unique 3 character prefix for\n* the various labels that are used during the creation of this format\n* model.  It will use the first 3 bytes of ACRONYM or PREFIX if they\n* are specified.\nLABEL=SIO\n\n* LAST8 can be used to cause the NAME= to contain the last 8 bytes of\n* the DSECT label.  This is quite useful when long labels are used.\n* this is used in conjunction with PREFIX=.  First the matching prefix\n* is removed from the label then if the field is still more than\n* 8 bytes, the LAST\n\n* OFFSETS= or OF= indicates if the field offsets are to be printed or\n* not.  OFFSETS=NOPRINT indicates the offsets are NOT to be printed.\n* OFFSETS=PRINT is the default and will be ignored.\n\n* PREFIX= or PF= defines the prefix text that should be removed from\n* the beginning of the label.  Removal stops when the matching stops.\n* Example:  PREFIX=ABC will remove ABC from ABCDEF (NAME=DEF)\n*           but will only remove AB from ABXDEF (NAME=XDEF)\n\n//*------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EDITSUB": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//EDITSUB  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),RENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(EDITSUB),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(EDITSUB),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(EDITSUB)\n  ENTRY    EDITSUB\n  NAME     EDITSUB(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FAMSEXT": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//FAMSEXTR JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(FAMSEXTR),DISP=(,PASS),\n//         UNIT=SYSDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(FAMSEXTR),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(FAMSEXTR)\n  ENTRY    FAMSEXTR\n  NAME     FAMSEXTR(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FAMSRUN": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x16\\x16\\x7f\\x01\\x16\\x16\\x7f\\x123\\x00\\x95\\x00\\x95\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-06-15T00:00:00", "modifydate": "2016-06-15T12:33:32", "lines": 149, "newlines": 149, "modlines": 0, "user": "JCL"}, "text": "//FAMSEXTR JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        UPDATE THE FOLLOWING \"SET\" STATEMENTS.                     *\n//*                                                                   *\n// SET LOADLIB=USERID.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//* NOTE: EXTRACT FIELDS BELOW HAVE BEEN LIFTED FROM ...\n//*       SYS1.LINKLIB(IGWAMSP0) CSECT IGWAMAMT.\n//*\n//EXTRACT  EXEC  PGM=FAMSEXTR,REGION=0M,TIME=NOLIMIT\n//STEPLIB  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\nDSN=YOUR.DATASET.NAME\nACCESS\nACTOKEN\nADDVOL\nAKEYPOS\nAMDSBCAT\nATIME\nATTRFLGS\nATTR1\nATTR2\nBLKSIZE\nBUFSIZE\nCATACB\nCATNAME\nCATVOL\nCCSID\nCHARSCNT\nCHKPTTKN\nCISIZE\nCOMPIND\nCOMUDSIZ\nCTIME\nDATACLAS\nDDMATTR\nDEVTYP\nDFMATTR\nDFMFLGS\nDFMPREC\nDIRBLCKS\nDPASALL\nDSATTR\nDSCBTTR\nDSCRDT2\nDSEXDT2\nDSNVER\nDSORG\nENTNAME\nENTYPE\nEXCPEXIT\nEXTATTR\nFILBYTSZ\nFILCLS\nFILCLSC\nFILEDATA\nFILESEQ\nFILESIZE\nFILPRT\nFUZZYBK1\nFUZZYBK2\nFUZZYBK3\nGID\nHARPN\nHURBADS\nHURPN\nKEYLNGTH\nKEYPOS\nLIBSHROP\nLOGPARMS\nLOGSTRID\nLRECL\nLTBACKDT\nLTCHGDAT\nLTCHGTIM\nLTREFDAT\nLTUPDUSR\nMAXARNB\nMAXGENS\nMAXVOLS\nMEMCOUNT\nMEMMODLV\nMEMRECCT\nMEMVRSN\nMGMTCLAS\nMICKEY\nMINUNITS\nMTIME\nNAME\nNAMEDS\nNEWNAME\nOWNERID\nPAGSUSED\nPASSATMP\nPASSPRMT\nPASSWALL\nPASSWORD\nPDFREC\nPDSEFLAG\nPDSEXFLG\nPRIMSPAC\nRCDCOUNT\nRECFM\nRECVTIME\nRECVTIMG\nREMVOL\nRGATTR\nRLSBWO\nRLSFLAGS\nSCONSPAC\nSECFLAGS\nSMSINFOM\nSMSSCMC\nSMSSFLAG\nSPACOPTN\nSPACPARM\nSTORCLAS\nSTRIPCNT\nSZTME\nTEXTCHNG\nTITLE\nTOTGENCT\nTOTMEMCT\nTYPE\nUDATASIZ\nUID\nUSERAREC\nUSVRMDUL\nVOLCOUNT\nVOLFLG\nVOLFLG2\nVOLKRQF\nVOLLIST\nVOLSER\nVOLVRBA\nVSAMMRSZ\nVSAMNREC\nVSAMREUS\nVSAMTYPE\nVVRNFLGS\nVVRRDATA\nVVRROWNR\nVVRSHWRN\nVVRSHWRV\nVVRSMSFG\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$IEFUJV": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//IEFUJV   JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),RENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(IEFUJV),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(IEFUJV),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(IEFUJV)\n  ENTRY    IEFUJV\n  NAME     IEFUJV(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LDS": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00)\\x00)\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 41, "newlines": 41, "modlines": 0, "user": "JCL"}, "text": "//LDS      JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*    Note:                                                          *\n//*        IF YOU HAVE \"LIBRARIAN\" SIMPLY un-comment THE //LIBDSN DD  *\n//*        STATEMENT AND THE \"INCLUDE LIBDSN\" IN LINKEDIT STEP.       *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(LDS),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(LDS),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//*LIBDSN  DD    DSN=librarian.load/obj.dsname,DISP=SHR    <--- Note\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(LDS)\n* INCLUDE  LIBDSN(FAIROPN,FAIRCLS,FARIMOD)                 <--- Note\n  ENTRY    LDS\n  NAME     LDS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LISTAST": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//LISTAST  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(LISTAST),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(LISTAST),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(LISTAST)\n  ENTRY    LISTAST\n  NAME     LISTAST(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LISTVOL": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//LISTVOLS JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(LISTVOLS),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(LISTVOLS),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(LISTVOLS)\n  ENTRY    LISTVOLS\n  NAME     LISTVOLS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LWATEDI": {"ttr": 1299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//$LWATEDI JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),RENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(LWATEDIT),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(LWATEDIT),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(LWATEDIT)\n  ENTRY    LWATEDIT\n  NAME     LWATEDIT(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LWATMGR": {"ttr": 1301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00$\\x00$\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 36, "newlines": 36, "modlines": 0, "user": "JCL"}, "text": "//LWATMGR  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),RENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(LWATMGR),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(LWATMGR),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(LWATMGR)\n  SETCODE  AC(1)\n  ENTRY    LWATMGR\n  NAME     LWATMGR(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MPFEXIT": {"ttr": 1303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//MPFEXITS JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),NORENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(MPFEXITS),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(MPFEXITS),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(MPFEXITS)\n  ENTRY    MPFEXITS\n  NAME     MPFEXITS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PACKMAP": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x004\\x004\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 52, "newlines": 52, "modlines": 0, "user": "JCL"}, "text": "//PACKMAP  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*        If PACKMAP does not reside in an APF authorized library    *\n//*        It will still work.  It just will not ENQUEUE on the VTOC  *\n//*        during the read process.                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM1     EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(PACKMAP),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(PACKMAP),DISP=SHR\n//ASM2     EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(HEXDUMP),DISP=(OLD,PASS)\n//SYSIN    DD    DSN=&SOURCE(HEXDUMP),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(PACKMAP)\n  INCLUDE  SYSPUNCH(HEXDUMP)\n  SETCODE  AC(1)\n  ENTRY    PACKMAP\n  NAME     PACKMAP(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PRU": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//PRU      JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(PRU),DISP=(,PASS),\n//         UNIT=SYSDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(PRU),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(PRU)\n  ENTRY    PRU\n  NAME     PRU(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RECEIVE": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\t\\x02\\x9f\\x01\\t\\x02\\x9f\\x152\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-01-29T00:00:00", "modifydate": "2009-01-29T15:32:26", "lines": 15, "newlines": 15, "modlines": 0, "user": "JCL"}, "text": "//$RECEIVE JOB   ...\n//*------------------------------------------------------------------*\n//* JOB TO RECEIVE THE HELP/LOADLIB/MACLIB MEMBERS.                  *\n//*------------------------------------------------------------------*\n//*\n//BATCHTMP EXEC PGM=IKJEFT01\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n RECEIVE INDATASET ('CBT.CBT476.FILE452.PDS(HELP)')\n  DSN('SBGOLOB.FILE452.HELP)     VOL(WORKE3)\n RECEIVE INDATASET ('CBT.CBT476.FILE452.PDS(LOADLIB)')\n  DSN('SBGOLOB.FILE452.LOADLIB') VOL(WORKE3)\n RECEIVE INDATASET ('CBT.CBT476.FILE452.PDS(MACLIB)')\n  DSN('SBGOLOB.FILE452.MACLIB')  VOL(WORKE3)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RETCODE": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x004\\x004\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 52, "newlines": 52, "modlines": 0, "user": "JCL"}, "text": "//RETCODE  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*        If RETCODE does not reside in an APF authorized library    *\n//*        it will still work.  It just won't display \"PARSE\" error   *\n//*        messages when an invalid PARM= is specified.               *\n//*-------------------------------------------------------------------*\n//*\n//ASM1     EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(RETCODE),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(RETCODE),DISP=SHR\n//ASM2     EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(TSOPARSE),DISP=(OLD,PASS)\n//SYSIN    DD    DSN=&SOURCE(TSOPARSE),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(RETCODE)\n  INCLUDE  SYSPUNCH(TSOPARSE)\n  SETCODE  AC(1)\n  ENTRY    RETCODE\n  NAME     RETCODE(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RXLOCAT": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//RXLOCATE JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(RXLOCATE),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(RXLOCATE),DISP=SHR\n//*\n//LINK     EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(RXLOCATE)\n  ENTRY    RXLOCATE\n  NAME     RXLOCATE(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SAFECPY": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00\\'\\x00\\'\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 39, "newlines": 39, "modlines": 0, "user": "JCL"}, "text": "//$SAFECPY JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*    Note:                                                          *\n//*        SAFECOPY \"MUST\" reside in a linklisted library.            *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),NORENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(SAFECOPY),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(SAFECOPY),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(SAFECOPY)\n  SETCODE  AC(1)\n  ENTRY    SAFECOPY\n  NAME     SAFECOPY(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SJFSAMP": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00\\'\\x00\\'\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 39, "newlines": 39, "modlines": 0, "user": "JCL"}, "text": "//SJFSAMP  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*    Note:                                                          *\n//*        SJFSAMP \"MUST\" reside in an authorized library.            *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),RENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(SJFSAMP),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(SJFSAMP),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(SJFSAMP)\n  SETCODE  AC(1)\n  ENTRY    SJFSAMP\n  NAME     SJFSAMP(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$STEPLIB": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00(\\x00(\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 40, "newlines": 40, "modlines": 0, "user": "JCL"}, "text": "//STEPLIB  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*    Note:                                                          *\n//*        STEPLIB \"MUST\" reside in a linklisted library.             *\n//*        Follow the \"READ.ME\" instructions for further details.     *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),RENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(STEPLIB),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(STEPLIB),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(STEPLIB)\n  SETCODE  AC(1)\n  ENTRY    STEPLIB\n  NAME     STEPLIB(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SYSMSGS": {"ttr": 1553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00\\'\\x00\\'\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 39, "newlines": 39, "modlines": 0, "user": "JCL"}, "text": "//SYSMSGS  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*    Note:                                                          *\n//*        SYSMSGS \"MUST\" reside in an APF library.                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),RENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(SYSMSGS),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(SYSMSGS),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(SYSMSGS)\n  SETCODE  AC(1)\n  ENTRY    SYSMSGS\n  NAME     SYSMSGS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$TEPTERM": {"ttr": 1555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//IEFACTRT JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),RENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(IEFACTRT),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(IEFACTRT),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(IEFACTRT)\n  ENTRY    $TEPTERM\n  NAME     $TEPTERM(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ULUTSCN": {"ttr": 1557, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00F\\x00F\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 70, "newlines": 70, "modlines": 0, "user": "JCL"}, "text": "//ULUTSCAN JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//*-------------------------------------------------------------------*\n//*                                                                   *\n//*        Assemble \"ULUTSCAN\" - The UCB Scan Subroutine.             *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//ASMSCAN  EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),RENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&SCAN(ULUTSCAN),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(ULUTSCAN),DISP=SHR\n//*\n//LINKSCAN EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE,ASMSCAN),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&SCAN,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(ULUTSCAN)\n  ENTRY    ULUTSCAN\n  NAME     ULUTSCAN(R)\n//*\n//*-------------------------------------------------------------------*\n//*                                                                   *\n//*        Assemble \"ULUTTEST\" - The UCB Scan TEST TSO command.       *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//ASMTEST  EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'FLAG(PAGE0),OPTABLE(ZS3),RENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&TEST(ULUTTEST),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(ULUTTEST),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE,ASMTEST),\n//         PARM='NCAL,LET,LIST,XREF,RENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&TEST,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(ULUTTEST)\n  ENTRY    ULUTTEST\n  NAME     ULUTTEST(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$USERINF": {"ttr": 1559, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00$\\x00$\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 36, "newlines": 36, "modlines": 0, "user": "JCL"}, "text": "//USERINFO JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//         DD    DSN=SYS1.SHASMAC,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(USERINFO),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(USERINFO),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(USERINFO)\n  ENTRY    USERINFO\n  NAME     USERINFO(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$WHOSGOT": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x03\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:03:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//WHOSGOT  JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=userid.MVS-JES2.MACLIB                                  *\n// SET SOURCE=userid.MVS-JES2.SOURCE                                  *\n// SET LOADLIB=userid.MVS-JES2.LOADLIB                                *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(ZS3),NORENT,FLAG(PAGE0)')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(WHOSGOT),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(WHOSGOT),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(WHOSGOT)\n  ENTRY    WHOSGOT\n  NAME     WHOSGOT(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$XMIT": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x17\\x00O\\x01\\x17\\x00O\\x11A\\x00)\\x00)\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-04T00:00:00", "modifydate": "2017-01-04T11:41:39", "lines": 41, "newlines": 41, "modlines": 0, "user": "JCL"}, "text": "//$XMIT    JOB   ...JOBCARD...\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET PREFIX=userid                                                  *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//XMIT     PROC  IN=,OUT=\n//XMIT     EXEC  PGM=IKJEFT1A,REGION=4096K,TIME=1440,\n//         PARM='TRANSMIT N1.&PREFIX FILE(IN) OUTFILE(OUT)'\n//SYSTSPRT DD    SYSOUT=*\n//SYSPRINT DD    SYSOUT=*\n//SYSTSIN  DD    DUMMY\n//*\n//IN       DD    DSN=&IN,DISP=SHR\n//OUT      DD    DSN=&OUT,DISP=SHR\n//         PEND\n//*-------------------------------------------------------------------*\n//HELP     EXEC  XMIT,\n//         IN=&PREFIX..MVS-JES2.HELP,\n//         OUT=&PREFIX..MVS-JES2.SOURCE(HELP)\n//*-------------------------------------------------------------------*\n//LOADLIB  EXEC  XMIT,\n//         IN=&PREFIX..MVS-JES2.LOADLIB,\n//         OUT=&PREFIX..MVS-JES2.SOURCE(LOADLIB)\n//*-------------------------------------------------------------------*\n//MACLIB   EXEC  XMIT,\n//         IN=&PREFIX..MVS-JES2.MACLIB,\n//         OUT=&PREFIX..MVS-JES2.SOURCE(MACLIB)\n//*-------------------------------------------------------------------*\n//COMPRESS EXEC  PGM=SAFECOPY,REGION=4096K,TIME=1440\n//SYSPRINT DD    SYSOUT=*\n//SYSUT1   DD    DISP=SHR,DSN=&PREFIX..MVS-JES2.SOURCE\n//SYSIN    DD    DUMMY\n//*-------------------------------------------------------------------*\n//FILE452  EXEC  XMIT,COND=(0,NE),\n//         IN=&PREFIX..MVS-JES2.SOURCE,\n//         OUT=JCL-ERROR\n//XMIT.OUT DD    DSN=&PREFIX..FILE452.XMI,DISP=(,CATLG),\n//         UNIT=SYSALLDA,SPACE=(CYL,(10,1),RLSE)\n//*-------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#PLIST": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x08\\x10_\\x01\\x08\\x10_\\x08U\\x02<\\x02<\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-14T00:00:00", "modifydate": "2008-04-14T08:55:22", "lines": 572, "newlines": 572, "modlines": 0, "user": "REXX"}, "text": "/*****************************   REXX   ******************************/\n/*********************************************************************/\n/*                                                                   */\n/*  member name:    #plist                         (C) Atos Origin   */\n/*                                                                   */\n/*  member type:                                                     */\n/*                                                                   */\n/*  Author:         V100740  BECKMANN              DATE: 2008-03-11  */\n/*                                                                   */\n/*  Description:    add entries to the personal dataset list ______  */\n/*                  use XML like entries ____---___________________  */\n/*                  _______________________________________________  */\n/*                  _______________________________________________  */\n/*                                                                   */\n/*  History:                                                         */\n/* ___date___ ver who comment                                        */\n/* 2008-03-11 1.1 HB  _initial_                                      */\n/* 2008-04-14 1.2 HB  - additional vars DSAPEVnn and DSAPDSnn in XML */\n/*                      (DSAPETnn-DSAPEVnn-DSAPDSnn)                 */\n/*                    - IBM default entry REFLIST always last        */\n/*********************************************************************/\n  _x_ = TRACE(\"n\")\n  parse upper arg _all_parms_\n  signal on novalue name sub_novalue\n  _x_ = sub_init() ;\n  select ;\n    when ( abbrev(_all_parms_,\"V\") = 1 ) ,\n      then do ;\n              _x_ = sub_version() ;\n              exit\n           end;\n    when ( abbrev(_all_parms_,\"H\") = 1 ) ,\n      then do ;\n              _x_ = sub_help() ;\n              exit\n           end;\n    when ( abbrev(_all_parms_,\"?\"  ) = 1 ) ,\n      then do ;\n              _x_ = sub_help() ;\n              exit\n           end;\n    otherwise nop;\n  end\n  address ispexec\n  \"control errors return\"\n  _lib_ = \"LIBRARY(ISPPROF)\"\n  _lib_ = \"\"\n  tablenam = \"ISRPLIST\"\n  _x_ = sub_add_plists() ;\n  \"CONTROL ERRORS RETURN\"\n  if custname = \"\" ,\n  then do ;\n           _additional_plist_commands = \"\"\n       end;\n  else do ;\n           _additional_plist_commands = \"#PLISTC #PLISTU\"\n           _additional_plist_commands = \"#PLISTC\"\n       end;\n  do i = 1 to words(_additional_plist_commands)\n      _cmd_ = word(_additional_plist_commands,i)\n      \"select cmd(\"_cmd_\")\"\n  end\n  _sysnest_ = SYSVAR(\"SYSNEST\")\n  if _sysnest_ = \"NO\" ,\n  then do ;\n           zmsg000l = _msgid_\"\",\n                             \"todo:\"add.0\"\",\n                             \" - \",\n                             \"deleted:\"_del_count_\"\",\n                             \" - \",\n                             \"added:\"_add_count_\"\",\n                             \" - \",\n                             \"errors:\"_err_count_\"\",\n                             \" - \",\n                             \"skipped:\"_skp_count_\"\",\n                             \"\"\n           \"setmsg msg(ispz000) cond\"\n           com =\"DSLIST\"\n           \"DISPLAY PANEL(ISPBLANK) COMMAND(COM) RETBUFFR(RETBUFR)\"\n           retbufr = retbufr\n       end;\n exit\n\n sub_init:\n   parse value \"\" with _null_\n   parse source xenv xtype xmyname xddname xdsname .\n   _version_ = \"1.2 (2008-04-14)\"\n   _msgid_ = xmyname\": \"\n   _add_count_ = 0\n   _del_count_ = 0\n   _err_count_ = 0\n   _skp_count_ = 0\n   custchar = left(MVSVAR(\"SYMDEF\",\"CUSTCHAR\")\"I\",1)\n   custname = MVSVAR(\"SYMDEF\",\"CUSTname\")\n   gol.0 = 0\n   _x_ = sub_define_plist_entries() ;\n  return 0\n\n  /* -------------------------------------------------------------- */\n  /*                                                                */\n  /* XML format                                                     */\n  /* <entry name> <description>  up to 30 entries in the form       */\n  /*                             <dsname/level-VOLSER-?>            */\n  /*                             2nd parm (optional): VOLSER        */\n  /*                             3rd parm (optional): -unknown ??? -*/\n  /* sample:                                                        */\n  /* <PARMLIB>    <Parmlib act.> <SYS1.PARMLIB>                     */\n  /* <PARMLIBs>   <Parmlib all>  <SYS1.PARMLIB> ...                 */\n  /*                             <SYS1.PARMLIB-SYSR01> ...          */\n  /*                             <SYS1.PARMLIB-SYSR02> ...          */\n  /*                             <SYS1.PARMLIB-SYSR11> ...          */\n  /*                             <SYS1.PARMLIB-SYSR12>              */\n  /*                                                                */\n  /* -------------------------------------------------------------- */\n sub_define_plist_entries:\n   custname = \"ATOS\" /* here fix for general ATOS entries */\n   if custname = \"\",\n   then _t_ = \"\"\n   else _t_ = \"\"custname\": \"\n   add.0 = 5\n   add.1 = \"<ME>\",\n           \"<\"_t_\"my datasets>\",\n           \"<'\"userid()\".**'>\",\n           \"\"\n   add.2 = \"<WE>\",\n           \"<\"_t_\"MO datasets \"custchar\"ZA* \"custchar\"ZB*>\",\n           \"<'\"custchar\"ZAPM.**'>\",\n           \"<'\"custchar\"ZAPP.**'>\",\n           \"<'\"custchar\"ZAP.**'>\",\n           \"<'\"custchar\"ZBPM.**'>\",\n           \"<'\"custchar\"ZBPP.**'>\",\n           \"<'\"custchar\"ZBP.**'>\",\n           \"\"\n   add.3 = \"<WEZA>\",\n           \"<\"_T_\"MO datasets \"custchar\"ZA*>\",\n           \"<'\"custchar\"ZAPM.**'>\",\n           \"<'\"custchar\"ZAPP.**'>\",\n           \"<'\"custchar\"ZAP.**'>\",\n           \"\"\n   add.4 = \"<WEZB>\",\n           \"<\"_t_\"MO datasets \"custchar\"ZB*>\",\n           \"<'\"custchar\"ZBPM.**'>\",\n           \"<'\"custchar\"ZBPP.**'>\",\n           \"<'\"custchar\"ZBP.**'>\",\n           \"\"\n   add.5 = \"<CEE>\",\n           \"<\"_T_\"CEE (language env.)>\",\n           \"<'SYS9.CEE*.**'>\",\n           \"\"\n\n  return 0\n\n sub_version:\n  _t_ = \"\"\n  _t_ = \"\"_t_\"\"_msgid_\"Version \"_version_\"\"\n  zmsg000s = \"\"\n  zmsg000l = _t_\n  address ispexec \"SETMSG MSG(ispz000) COND\"\n  return 0\n\n sub_help:\n  x=sub_header()\n  x=gol(\"                                                            \")\n  x=gol(\"function:                                                   \")\n  x=gol(\" generate additional entries in personal dslist             \")\n  x=gol(\"                                                            \")\n  x=gol(\"                                                            \")\n  x=gol(\" These \"add.0\" entries are defined:                         \")\n  x=gol(\"                                                            \")\n  do i = 1 to add.0\n        parse var add.i \"<\" _entry_ \">\" \"<\"_desc_\">\"  _dsnames_\n        x=gol(\"  \"left(\"<\"_entry_\">\",10)\" <\"_desc_\">\")\n        do forever\n           parse var _dsnames_ \"<\" _dsname_ \">\" _dsnames_\n           _dsname_  = strip(_dsname_)\n           _dsnames_ = strip(_dsnames_)\n           if _dsname_ = \"\" ,\n           then leave\n           x=gol(copies(\" \",15)\"\"_dsname_\"\") ;\n           if _dsnames_ = \"\" ,\n           then do;\n                    x=gol(\" \") ;\n                    leave\n                end;\n        end\n  end\n  x=gol(\"                                                            \")\n  _x_ = sub_temp()\n   return 0\n\n sub_header:\n  x=gol(\"\"xmyname\" - \" _version_                                    \"\")\n  x=gol(\"                                                            \")\n    return 0\n\n gol:\n   /* generate output lines */\n   parse arg output_line\n   gol.0 = gol.0 + 1\n   gidx = gol.0\n   gol.gidx = output_line\n   return 0\n\n sub_temp:\n    parse arg stemvar\n    if stemvar = _null_ ,\n    then stemvar = \"gol.\"\n    finame = \"DD\"time(\"S\")\n    tmp.0 = gol.0\n    ADDRESS TSO\n    \"alloc fi(\"finame\") recfm(f,b) lrecl(80) \",\n           \"new delete cylinder\",\n           \"UNIT(VIO) \" ,\n           \"space(1,1) reuse dsorg(PS) \"\n    \"EXECIO * DISKW \"finame\" (STEM \"stemvar\" FINIS)\"\n    _x_ = sub_show(\"D=\"finame\" F=BROWSE \")\n    \"FREE FI(\"finame\")\"\n   return 0\n\n sub_show:\n   parse arg 1 . \"D=\" ddname . ,\n             1 . \"F=\" ddfunc . ,\n             1 . \"M=\" ddmem  . ,\n             1 .\n          idname = overlay(\"ID\",ddname,1,2)\n          select ;\n              when ( ddfunc = \"EDIT\"   ) then nop ;,\n              when ( ddfunc = \"VIEW\"   ) then nop ;,\n              when ( ddfunc = \"BROWSE\" ) then nop ;,\n              otherwise do;\n                     ddfunc = \"BROWSE\"\n                        end;\n          end;\n        ADDRESS ISPEXEC\n          \"LMINIT DATAID(idname)   DDNAME(\"finame\") enq(shr\"\n          ispf_service_parms = \"PANEL(ISREDDE) MEMBER(\"xmyname\")\"\n          if ddmem = _null_ ,\n          then ispf_service_parms = _null_\n          else ispf_service_parms = \"MEMBER(\"ddmem\")\"\n          if ddfunc = \"EDIT\" ,\n          then do\n                   \"CONTROL ERRORS CANCEL\"\n               end\n          ispf_service = ddfunc\n          \"\"ispf_service \" DATAID(\"idname\") \" ispf_service_parms\n          \"LMFREE DATAID(\"idname\")                 \"\n   return 0\n\n sub_prepare:\n  \"TBTOP  \"tablenam \"\"_lib_\n  return 0\n\n sub_add_plists:\n  _x_ = sub_prepare() ;\n   do i = add.0 to 1 by  -1\n      _x_ = sub_add_line(add.i) ;\n   end\n\n  /* -------------------------------------------------------------- */\n  /*                                                                */\n  /* What sorting order is preferred? Any good idea?                */\n  /*                                                                */\n  /* -------------------------------------------------------------- */\n  /*                                                                */\n  /* sortlist = \"DSADESCP,C,A ZCURTB,C,A\"                           */\n   sortlist = \"ZCURTB,C,A\"\n   \"TBSORT\" tablenam \"FIELDS(\"sortlist\")\"\n   rcode = rc\n   _x_ = sub_reorder_specials() ;\n\n  return 0\n\n  /* -------------------------------------------------------------- */\n  /* - get the first line of the table as a sample                  */\n  /* - parse the given string into the appropriate table variables  */\n  /*       and override the values of the sample line               */\n  /* - delete all lines with the same value in ZCURTB               */\n  /* - add the new line at the top                                  */\n  /* -------------------------------------------------------------- */\n sub_add_line:\n  _x_ = sub_table_vars(\"INIT\") ;\n  parse arg _parms_\n  \"TBSKIP \"tablenam \"NUMBER(1)\"\n  \"TBGET  \"tablenam \"\"_lib_\n  parse var _parms_ 1 . ,\n                      \"<\" ZCURTB    \">\" ,\n                      \"<\" DSADESCP  \">\" ,\n                      \"<\" XMLVAL01  \">\" ,\n                      \"<\" XMLVAL02  \">\" ,\n                      \"<\" XMLVAL03  \">\" ,\n                      \"<\" XMLVAL04  \">\" ,\n                      \"<\" XMLVAL05  \">\" ,\n                      \"<\" XMLVAL06  \">\" ,\n                      \"<\" XMLVAL07  \">\" ,\n                      \"<\" XMLVAL08  \">\" ,\n                      \"<\" XMLVAL09  \">\" ,\n                      \"<\" XMLVAL10  \">\" ,\n                      \"<\" XMLVAL11  \">\" ,\n                      \"<\" XMLVAL12  \">\" ,\n                      \"<\" XMLVAL13  \">\" ,\n                      \"<\" XMLVAL14  \">\" ,\n                      \"<\" XMLVAL15  \">\" ,\n                      \"<\" XMLVAL16  \">\" ,\n                      \"<\" XMLVAL17  \">\" ,\n                      \"<\" XMLVAL18  \">\" ,\n                      \"<\" XMLVAL19  \">\" ,\n                      \"<\" XMLVAL20  \">\" ,\n                      \"<\" XMLVAL21  \">\" ,\n                      \"<\" XMLVAL22  \">\" ,\n                      \"<\" XMLVAL23  \">\" ,\n                      \"<\" XMLVAL24  \">\" ,\n                      \"<\" XMLVAL25  \">\" ,\n                      \"<\" XMLVAL26  \">\" ,\n                      \"<\" XMLVAL27  \">\" ,\n                      \"<\" XMLVAL28  \">\" ,\n                      \"<\" XMLVAL29  \">\" ,\n                      \"<\" XMLVAL30  \">\" ,\n                      .\n  parse var XMLVAL01 1 DSAPET01 \"-\" DSAPEV01 \"-\" DSAPDS01\n  parse var XMLVAL02 1 DSAPET02 \"-\" DSAPEV02 \"-\" DSAPDS02\n  parse var XMLVAL03 1 DSAPET03 \"-\" DSAPEV03 \"-\" DSAPDS03\n  parse var XMLVAL04 1 DSAPET04 \"-\" DSAPEV04 \"-\" DSAPDS04\n  parse var XMLVAL05 1 DSAPET05 \"-\" DSAPEV05 \"-\" DSAPDS05\n  parse var XMLVAL06 1 DSAPET06 \"-\" DSAPEV06 \"-\" DSAPDS06\n  parse var XMLVAL07 1 DSAPET07 \"-\" DSAPEV07 \"-\" DSAPDS07\n  parse var XMLVAL08 1 DSAPET08 \"-\" DSAPEV08 \"-\" DSAPDS08\n  parse var XMLVAL09 1 DSAPET09 \"-\" DSAPEV09 \"-\" DSAPDS09\n  parse var XMLVAL10 1 DSAPET10 \"-\" DSAPEV10 \"-\" DSAPDS10\n  parse var XMLVAL11 1 DSAPET11 \"-\" DSAPEV11 \"-\" DSAPDS11\n  parse var XMLVAL12 1 DSAPET12 \"-\" DSAPEV12 \"-\" DSAPDS12\n  parse var XMLVAL13 1 DSAPET13 \"-\" DSAPEV13 \"-\" DSAPDS13\n  parse var XMLVAL14 1 DSAPET14 \"-\" DSAPEV14 \"-\" DSAPDS14\n  parse var XMLVAL15 1 DSAPET15 \"-\" DSAPEV15 \"-\" DSAPDS15\n  parse var XMLVAL16 1 DSAPET16 \"-\" DSAPEV16 \"-\" DSAPDS16\n  parse var XMLVAL17 1 DSAPET17 \"-\" DSAPEV17 \"-\" DSAPDS17\n  parse var XMLVAL18 1 DSAPET18 \"-\" DSAPEV18 \"-\" DSAPDS18\n  parse var XMLVAL19 1 DSAPET19 \"-\" DSAPEV19 \"-\" DSAPDS19\n  parse var XMLVAL20 1 DSAPET20 \"-\" DSAPEV20 \"-\" DSAPDS20\n  parse var XMLVAL21 1 DSAPET21 \"-\" DSAPEV21 \"-\" DSAPDS21\n  parse var XMLVAL22 1 DSAPET22 \"-\" DSAPEV22 \"-\" DSAPDS22\n  parse var XMLVAL23 1 DSAPET23 \"-\" DSAPEV23 \"-\" DSAPDS23\n  parse var XMLVAL24 1 DSAPET24 \"-\" DSAPEV24 \"-\" DSAPDS24\n  parse var XMLVAL25 1 DSAPET25 \"-\" DSAPEV25 \"-\" DSAPDS25\n  parse var XMLVAL26 1 DSAPET26 \"-\" DSAPEV26 \"-\" DSAPDS26\n  parse var XMLVAL27 1 DSAPET27 \"-\" DSAPEV27 \"-\" DSAPDS27\n  parse var XMLVAL28 1 DSAPET28 \"-\" DSAPEV28 \"-\" DSAPDS28\n  parse var XMLVAL29 1 DSAPET29 \"-\" DSAPEV29 \"-\" DSAPDS29\n  parse var XMLVAL30 1 DSAPET30 \"-\" DSAPEV30 \"-\" DSAPDS30\n  zcurtb = strip(zcurtb)\n  select;\n    when (abbrev(zcurtb,\"REFLIST\") = 1) then skp_count = skp_count + 1;\n    otherwise ,\n      do ;\n          _x_ = sub_clear_existing_plist_entries(zcurtb) ;\n          \"TBTOP  \"tablenam \"\"\n          \"CONTROL ERRORS CANCEL\"\n          \"VGET (zdate)\"\n          DSACTIME = ZDATE        /* create date */\n          \"TBADD  \"tablenam \"\"_lib_\n          rcode = rc\n          if rcode = 0 ,\n          then do ;\n                   _add_count_ = _add_count_ + 1\n               end;\n          else do ;\n                   _err_count_ = _err_count_ + 1\n               end;\n      end;\n  end;\n  return 0\n\n sub_clear_existing_plist_entries: ,\n    procedure expose tablenam _del_count_\n  parse arg zcurtb\n  zcurtb = strip(zcurtb)\n  if zcurtb = \"\" then return 0\n  namelist = \"ZCURTB\"\n  vallist  = \"EQ\"\n  do forever\n          \"TBTOP  \"tablenam \"\"\n          \"TBSCAN \"tablenam \"ARGLIST(\"namelist\") \",\n                            \"ROWID(rowid)\",\n                            \"CONDLIST(\"vallist\")\"\n          rcode = rc\n          if rcode = 0 ,\n          then do ;\n                   \"TBSKIP   \"tablenam \"row(\"rowid\")\"\n                   \"TBGET    \"tablenam \"\"\n                   \"TBDELETE \"tablenam\n                   rcode = rc\n                   if rcode = 0 ,\n                   then do ;\n                             _del_count_ = _del_count_ + 1\n                        end;\n               end;\n          else do ;\n                   leave ;\n               end;\n  end\n  return 0\n\n  /* -------------------------------------------------------------- */\n  /*                                                                */\n  /* entry REFLIST (IBM default) always last entry                  */\n  /*                                                                */\n  /* -------------------------------------------------------------- */\n sub_reorder_specials:\n   _x_ = sub_table_vars(\"INIT\") ;\n   namelist = \"ZCURTB\"\n   ZCURTB   = \"REFLIST\"\n   vallist  = \"EQ\"\n   \"control errors cancel\"\n   \"TBTOP  \"tablenam \"\"\n   \"TBSCAN \"tablenam \"ARGLIST(\"namelist\") \",\n                     \"ROWID(rowid)\",\n                     \"CONDLIST(\"vallist\")\"\n   rcode = rc\n   if rcode = 0 ,\n   then do ;\n             \"TBSKIP   \"tablenam \"row(\"rowid\")\"\n             \"TBGET    \"tablenam \"\"\n             _x_ = sub_table_vars(\"SAVE\") ;\n             \"TBDELETE \"tablenam\n             \"TBBOTTOM \"tablenam \"\"\n             _x_ = sub_table_vars(\"RESTORE\") ;\n             \"TBADD    \"tablenam\n             rcode = rc\n             if rcode = 0 ,\n             then do ;\n                  end;\n        end;\n  return 0\n\n sub_table_vars:\n   parse arg _all_parms_\n   select ;\n      when ( _all_parms_ = \"INIT\" ) ,\n        then do ;\n           parse value \"\" with ,\n            zcurtb     ,\n            dsadescp   ,\n            dsactime   ,\n            dsautime   ,\n            dsaactiv   ,\n            dsastck    ,\n            DSAPET01        DSAPEV01        DSAPDS01  ,\n            DSAPET02        DSAPEV02        DSAPDS02  ,\n            DSAPET03        DSAPEV03        DSAPDS03  ,\n            DSAPET04        DSAPEV04        DSAPDS04  ,\n            DSAPET05        DSAPEV05        DSAPDS05  ,\n            DSAPET06        DSAPEV06        DSAPDS06  ,\n            DSAPET07        DSAPEV07        DSAPDS07  ,\n            DSAPET08        DSAPEV08        DSAPDS08  ,\n            DSAPET09        DSAPEV09        DSAPDS09  ,\n            DSAPET10        DSAPEV10        DSAPDS10  ,\n            DSAPET11        DSAPEV11        DSAPDS11  ,\n            DSAPET12        DSAPEV12        DSAPDS12  ,\n            DSAPET13        DSAPEV13        DSAPDS13  ,\n            DSAPET14        DSAPEV14        DSAPDS14  ,\n            DSAPET15        DSAPEV15        DSAPDS15  ,\n            DSAPET16        DSAPEV16        DSAPDS16  ,\n            DSAPET17        DSAPEV17        DSAPDS17  ,\n            DSAPET18        DSAPEV18        DSAPDS18  ,\n            DSAPET19        DSAPEV19        DSAPDS19  ,\n            DSAPET20        DSAPEV20        DSAPDS20  ,\n            DSAPET21        DSAPEV21        DSAPDS21  ,\n            DSAPET22        DSAPEV22        DSAPDS22  ,\n            DSAPET23        DSAPEV23        DSAPDS23  ,\n            DSAPET24        DSAPEV24        DSAPDS24  ,\n            DSAPET25        DSAPEV25        DSAPDS25  ,\n            DSAPET26        DSAPEV26        DSAPDS26  ,\n            DSAPET27        DSAPEV27        DSAPDS27  ,\n            DSAPET28        DSAPEV28        DSAPDS28  ,\n            DSAPET29        DSAPEV29        DSAPDS29  ,\n            DSAPET30        DSAPEV30        DSAPDS30  ,\n            .\n             end;\n      when ( _all_parms_ = \"SAVE\" ) ,\n        then do ;\n                savcurtb=zcurtb\n                savdescp=dsadescp\n                savctime=dsactime\n                savutime=dsautime\n                savactiv=dsaactiv\n                savstck =dsastck\n                savpet01=dsapet01;savpev01=dsapev01;savpds01=dsapds01 ;\n                savpet02=dsapet02;savpev02=dsapev02;savpds02=dsapds02 ;\n                savpet03=dsapet03;savpev03=dsapev03;savpds03=dsapds03 ;\n                savpet04=dsapet04;savpev04=dsapev04;savpds04=dsapds04 ;\n                savpet05=dsapet05;savpev05=dsapev05;savpds05=dsapds05 ;\n                savpet06=dsapet06;savpev06=dsapev06;savpds06=dsapds06 ;\n                savpet07=dsapet07;savpev07=dsapev07;savpds07=dsapds07 ;\n                savpet08=dsapet08;savpev08=dsapev08;savpds08=dsapds08 ;\n                savpet09=dsapet09;savpev09=dsapev09;savpds09=dsapds09 ;\n                savpet10=dsapet10;savpev10=dsapev10;savpds10=dsapds10 ;\n                savpet11=dsapet11;savpev11=dsapev11;savpds11=dsapds11 ;\n                savpet12=dsapet12;savpev12=dsapev12;savpds12=dsapds12 ;\n                savpet13=dsapet13;savpev13=dsapev13;savpds13=dsapds13 ;\n                savpet14=dsapet14;savpev14=dsapev14;savpds14=dsapds14 ;\n                savpet15=dsapet15;savpev15=dsapev15;savpds15=dsapds15 ;\n                savpet16=dsapet16;savpev16=dsapev16;savpds16=dsapds16 ;\n                savpet17=dsapet17;savpev17=dsapev17;savpds17=dsapds17 ;\n                savpet18=dsapet18;savpev18=dsapev18;savpds18=dsapds18 ;\n                savpet19=dsapet19;savpev19=dsapev19;savpds19=dsapds19 ;\n                savpet20=dsapet20;savpev20=dsapev20;savpds20=dsapds20 ;\n                savpet21=dsapet21;savpev21=dsapev21;savpds21=dsapds21 ;\n                savpet22=dsapet22;savpev22=dsapev22;savpds22=dsapds22 ;\n                savpet23=dsapet23;savpev23=dsapev23;savpds23=dsapds23 ;\n                savpet24=dsapet24;savpev24=dsapev24;savpds24=dsapds24 ;\n                savpet25=dsapet25;savpev25=dsapev25;savpds25=dsapds25 ;\n                savpet26=dsapet26;savpev26=dsapev26;savpds26=dsapds26 ;\n                savpet27=dsapet27;savpev27=dsapev27;savpds27=dsapds27 ;\n                savpet28=dsapet28;savpev28=dsapev28;savpds28=dsapds28 ;\n                savpet29=dsapet29;savpev29=dsapev29;savpds29=dsapds29 ;\n                savpet30=dsapet30;savpev30=dsapev30;savpds30=dsapds30 ;\n             end;\n      when ( _all_parms_ = \"RESTORE\" ) ,\n        then do ;\n                zcurtb  =savcurtb\n                dsadescp=savdescp\n                dsactime=savctime\n                dsautime=savutime\n                dsaactiv=savactiv\n                dsastck =savstck\n                dsapet01=savpet01;dsapev01=savpev01;dsapds01=savpds01 ;\n                dsapet02=savpet02;dsapev02=savpev02;dsapds02=savpds02 ;\n                dsapet03=savpet03;dsapev03=savpev03;dsapds03=savpds03 ;\n                dsapet04=savpet04;dsapev04=savpev04;dsapds04=savpds04 ;\n                dsapet05=savpet05;dsapev05=savpev05;dsapds05=savpds05 ;\n                dsapet06=savpet06;dsapev06=savpev06;dsapds06=savpds06 ;\n                dsapet07=savpet07;dsapev07=savpev07;dsapds07=savpds07 ;\n                dsapet08=savpet08;dsapev08=savpev08;dsapds08=savpds08 ;\n                dsapet09=savpet09;dsapev09=savpev09;dsapds09=savpds09 ;\n                dsapet10=savpet10;dsapev10=savpev10;dsapds10=savpds10 ;\n                dsapet11=savpet11;dsapev11=savpev11;dsapds11=savpds11 ;\n                dsapet12=savpet12;dsapev12=savpev12;dsapds12=savpds12 ;\n                dsapet13=savpet13;dsapev13=savpev13;dsapds13=savpds13 ;\n                dsapet14=savpet14;dsapev14=savpev14;dsapds14=savpds14 ;\n                dsapet15=savpet15;dsapev15=savpev15;dsapds15=savpds15 ;\n                dsapet16=savpet16;dsapev16=savpev16;dsapds16=savpds16 ;\n                dsapet17=savpet17;dsapev17=savpev17;dsapds17=savpds17 ;\n                dsapet18=savpet18;dsapev18=savpev18;dsapds18=savpds18 ;\n                dsapet19=savpet19;dsapev19=savpev19;dsapds19=savpds19 ;\n                dsapet20=savpet20;dsapev20=savpev20;dsapds20=savpds20 ;\n                dsapet21=savpet21;dsapev21=savpev21;dsapds21=savpds21 ;\n                dsapet22=savpet22;dsapev22=savpev22;dsapds22=savpds22 ;\n                dsapet23=savpet23;dsapev23=savpev23;dsapds23=savpds23 ;\n                dsapet24=savpet24;dsapev24=savpev24;dsapds24=savpds24 ;\n                dsapet25=savpet25;dsapev25=savpev25;dsapds25=savpds25 ;\n                dsapet26=savpet26;dsapev26=savpev26;dsapds26=savpds26 ;\n                dsapet27=savpet27;dsapev27=savpev27;dsapds27=savpds27 ;\n                dsapet28=savpet28;dsapev28=savpev28;dsapds28=savpds28 ;\n                dsapet29=savpet29;dsapev29=savpev29;dsapds29=savpds29 ;\n                dsapet30=savpet30;dsapev30=savpev30;dsapds30=savpds30 ;\n             end;\n      otherwise nop ;\n   end\n  return 0\n\n       /**************************************************************\n        * Trap uninitialized variables                               *\n        **************************************************************/\n        sub_novalue:\n        Say \" \"\n        Say \"Variable\" ,\n           condition(\"Description\") \"undefined in line\" sigl\":\"\n        Say sourceline(sigl)\n        if sysenv           <> \"FORE\" then exit 8\n        say \"Report the error in this application along with the\",\n            \"syntax used.\"\n        exit 8\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE452": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00A\\x01\\x19 \\x9f\\x01\\x19 \\x9f\\x144\\x00\\x9a\\x00\\x9a\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-07-28T00:00:00", "modifydate": "2019-07-28T14:34:41", "lines": 154, "newlines": 154, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 452 is from Dan Dalby and contains a collection of his    *   FILE 452\n//*           programs and utilities, which he has been distribu-   *   FILE 452\n//*           ting over the Internet.  Dan retains ownership of     *   FILE 452\n//*           the programs, but has given permission for them to    *   FILE 452\n//*           be distributed on the CBT Tape.  Please see the       *   FILE 452\n//*           general disclaimer information on File 001 of the     *   FILE 452\n//*           CBT Tape, and what it says regarding \"owned files\".   *   FILE 452\n//*                                                                 *   FILE 452\n//*    Licensed material-program, Property of zOS.JES2@Gmail.com    *   FILE 452\n//*    All Rights Reserved by zOS.JES2@Gmail.com                    *   FILE 452\n//*                                                                 *   FILE 452\n//*    As with the CBT source rules, this code may be freely        *   FILE 452\n//*    distributed.  However I retain ownership of this code.       *   FILE 452\n//*    Thus it may not be used, fully or in part, in a              *   FILE 452\n//*    commercial product or sold in any way.                       *   FILE 452\n//*                                                                 *   FILE 452\n//*    Description of the programs included here:                   *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     Add to existing allocations (ADDTO)                         *   FILE 452\n//*     Updated July 1, 1999                                        *   FILE 452\n//*                                                                 *   FILE 452\n//*     Many users want their own personal libraries to be          *   FILE 452\n//*     allocated in front of the libraries that are allocated      *   FILE 452\n//*     within the LOGON procedure. Normally, this means that       *   FILE 452\n//*     the user has to re-allocate the DD, specifying all of       *   FILE 452\n//*     the libraries with their own as the first library. If       *   FILE 452\n//*     the libraries that are in the LOGON procedure get           *   FILE 452\n//*     renamed or deleted due to maintenance, the user's           *   FILE 452\n//*     allocation fails, leaving them without that specific DD     *   FILE 452\n//*     allocated at ALL.  With this command, you simply let        *   FILE 452\n//*     the LOGON procedure do it's thing, and in your initial      *   FILE 452\n//*     logon CLIST/REXX specify the libraries you want in          *   FILE 452\n//*     front. The re-allocation occurs, without the user           *   FILE 452\n//*     needing to know all the LOGON procedure's library           *   FILE 452\n//*     names.                                                      *   FILE 452\n//*                                                                 *   FILE 452\n//*     Note: ADDTO can NOT extend DDs that are OPEN. In other      *   FILE 452\n//*     words, ISPxLIB's can't be ADDTO'd once you are in ISPF.     *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     Fast Catalog List Command (CATL)                            *   FILE 452\n//*     Updated July 2, 1999                                        *   FILE 452\n//*                                                                 *   FILE 452\n//*     The TSO LISTCAT command seems to gather every smidgen       *   FILE 452\n//*     of information necessary about a dataset, even if it is     *   FILE 452\n//*     not going to display it on your screen. This command        *   FILE 452\n//*     only gets the required information, making it quite a       *   FILE 452\n//*     bit faster. There are additional keywords to change how     *   FILE 452\n//*     CATL displays the output. Try the \"SIDEWAYS\" keyword on     *   FILE 452\n//*     a GDG base.                                                 *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     List Dataset Information (LDS)                              *   FILE 452\n//*                                                                 *   FILE 452\n//*     This command lets you list information about your           *   FILE 452\n//*     libraries that you really can't get easily any other        *   FILE 452\n//*     way.  Actually, until TSO/E, some of this information       *   FILE 452\n//*     wasn't available at all.                                    *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     DASD Pack Map (PACKMAP)                                     *   FILE 452\n//*     Updated July 2, 1999                                        *   FILE 452\n//*                                                                 *   FILE 452\n//*     Occasionally, you need to know the physical layout of a     *   FILE 452\n//*     volume. This utility generates a MAP for you. The           *   FILE 452\n//*     output report gives you the relative track, extent          *   FILE 452\n//*     length, extent number, CCHH and DCB information for         *   FILE 452\n//*     every dataset on the volume. The freespace extents and      *   FILE 452\n//*     VTOC information are also displayed in this report.         *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     PDS Rescue (PRU)                                            *   FILE 452\n//*     Updated August 11, 2004                                     *   FILE 452\n//*                                                                 *   FILE 452\n//*     Have you ever hit SAVE in ISPF when you meant to enter      *   FILE 452\n//*     CANCEL? I have. This utility allows you to get the          *   FILE 452\n//*     original member back. The original library is left          *   FILE 452\n//*     untouched, and a new library is created with all the        *   FILE 452\n//*     OLD members.  Unfortunately, this does not work on PDSE     *   FILE 452\n//*     libraries, or after a PDS has been compressed.              *   FILE 452\n//*                                                                 *   FILE 452\n//*     A REXX exec has been provided by one of the users of        *   FILE 452\n//*     this utility. This makes it easier than ever to recover     *   FILE 452\n//*     member(s).                                                  *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     Return/Abend Code Generator (RETCODE)                       *   FILE 452\n//*     Updated July 14, 1999                                       *   FILE 452\n//*                                                                 *   FILE 452\n//*     Need to test the \"COND=\" or \"IF\" logic of your batch        *   FILE 452\n//*     jobs?  This tool lets you generate a step with any          *   FILE 452\n//*     return code or User/System ABEND code.                      *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     Dynamic Steplib (STEPLIB)                                   *   FILE 452\n//*     Updated ...ongoing...                                       *   FILE 452\n//*                                                                 *   FILE 452\n//*     With the deficiencies of ISPLLIB, and the other             *   FILE 452\n//*     \"tasklib\" capabilities provided by IBM, sometimes you       *   FILE 452\n//*     really need a STEPLIB. I've found it easier to simply       *   FILE 452\n//*     forget the other facilities, and use STEPLIB                *   FILE 452\n//*     exclusively. This tool allows you to create, alter or       *   FILE 452\n//*     remove your STEPLIB at any time during the life of your     *   FILE 452\n//*     TSO session.                                                *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     User/System Symbols (USERINFO)                              *   FILE 452\n//*     Updated April 2, 2000                                       *   FILE 452\n//*                                                                 *   FILE 452\n//*     Ever need to know your TSO terminal ID, the JES             *   FILE 452\n//*     subsystem you're running under or a raft of other system    *   FILE 452\n//*     or user related items within a CLIST or REXX? Of course,    *   FILE 452\n//*     in a REXX EXEC, you can bounce through control blocks,      *   FILE 452\n//*     but wouldn't it be easier to have it available in a         *   FILE 452\n//*     defined symbol. Actually, this tool was created way         *   FILE 452\n//*     back, before REXX was available, and CLIST was the way      *   FILE 452\n//*     to go. With USERINFO, the system and user information is    *   FILE 452\n//*     readily available in a &SYSxxxx variable. Simply invoke     *   FILE 452\n//*     the USERINFO program at the beginning of the CLIST, and     *   FILE 452\n//*     all these symbols magically appear. Recently, a user        *   FILE 452\n//*     needed to know what day of the week it was, so &SYSWDAY     *   FILE 452\n//*     was added.  The system symbols defined in IEASYMxx as       *   FILE 452\n//*     well as the current RACF USER and GROUP names are now       *   FILE 452\n//*     available.                                                  *   FILE 452\n//*                                                                 *   FILE 452\n//*     If you'd like additional variables, and know the            *   FILE 452\n//*     control block location, simply Email me and I'll add        *   FILE 452\n//*     it.                                                         *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     Who's Got my Dataset (WHOSGOT)                              *   FILE 452\n//*                                                                 *   FILE 452\n//*     When trying to edit or allocate a library, occasionally     *   FILE 452\n//*     you will get a \"dataset in use\" message.  This tool         *   FILE 452\n//*     lets you ask the question... \"WHO'S GOT MY FILE\"?           *   FILE 452\n//*                                                                 *   FILE 452\n//*       ----------------------------------------------------      *   FILE 452\n//*                                                                 *   FILE 452\n//*     IEFUJV System Exit Routine.                                 *   FILE 452\n//*                                                                 *   FILE 452\n//*     This routine will translate a variety of variables on       *   FILE 452\n//*     JCL SET statements.  This allows the use of date and        *   FILE 452\n//*     system symbols within batch JCL.                            *   FILE 452\n//*                                                                 *   FILE 452\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDTO": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x03o\\x03o\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 879, "newlines": 879, "modlines": 0, "user": "SOURCE"}, "text": "ADDTO    TITLE '- ADDTO - ADD DATASETS TO CONCATENATION'\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* A D D T O       |      Expand/Shrink A DD's Allocation.             *\n*                 |                                                   *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    FUNCTION: Expand the list of datasets that are allocated to a    *\n*              specific DD statement.                                 *\n*              You can also decrease the number of datasets that are  *\n*              allocated to a specific DD statement.                  *\n*                                                                     *\n*       PARMS: ADDTO ddname (dsname-list)                             *\n*                           [ NOCREATE ]                              *\n*                           [ REMOVE ] | [ FIRST ] | [ LAST ]         *\n*                           [ BLKSIZE(size) ]                         *\n*                           [ NOMSGS ] | [ VERBOSE ]                  *\n*                                                                     *\n*    Return Codes:                                                    *\n*               0 - Successful                                        *\n*               4 - Parse Error                                       *\n*               8 - DD Statement Not Found                            *\n*              12 - Allocation Error                                  *\n*              16 - Command Syntax Error                              *\n*              20 - Dsname Not Found (REMOVE)                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: V001R01  - Initial Version                             *\n*              V001R02  - EAV Support                                 *\n*              V001R03  - Add \"REMOVE\" keyword                        *\n*              V001R04  - Check for \"NOCREATE\"                        *\n*              V001R05  - Add \"FIRST\", \"LAST\" & \"VERBOSE\"             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 MACRO Format\n         SYSSTATE ARCHLVL=2        Assembly Requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly Requires z/OS 1.13 or More\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*        V001R03 - #DD13072 - Make CREATE Default, Add \"NOCREATE\"     *\n*        V001R04 - #DD17072 - Build &ADDTO VARIABLE                   *\n*        V001R05 - #DD17088 - Support \"FIRST\" & \"LAST\"                *\n*        V001R06 - #DD18120 - Allow for FIRST/LAST/REMOVE Default     *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDTO    #START ,                  Start Procedure                     *\n               AMODE=CAP31,        Execute In 31-Bit AMode             *\n               BASE=(R11,R12),     Use Relative Addressing             *\n               COPY=YES,           Generate Copyright Notice           *\n               LOC=BELOW,          Indicate 24-Bit WorkArea            *\n               REG1=R8,            Save Input Parameter Address        *\n               RMODE=ANY,          Execute In 24-Bit Rmode             *\n               USING=(CPPL,R8),    Address The Parameter List          *\n               WKDSECT=ADDTWRK,    Define WorkArea Name                *\n               LEVEL=#V001R06      Modification Level          #DD18120\n         USING PSA,0\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Initialize The WorkArea                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   WRKDDNL@(2),=AL2(DCCDDNAM)\n         MVC   WRKDDNL@+2(2),=AL2(2)\n         MVC   WRKDDN1,=AL2(8)     Set 1st DDName Length\n         MVC   WRKDDN1+2(8),BLANKS\n         MVC   WRKDDN2,=AL2(8)     Set 2nd DDName Length\n         MVC   WRKDDN2+2(8),BLANKS\n         LA    R0,WRKDDN\n         ST    R0,WRKDDN@          Save DDName Address\n         LA    R1,L'WRKDDN\n         STH   R1,WRKDDN@+4        Save DDName Length\n         LA    R0,WRKDSN\n         ST    R0,WRKDSN@          Save DSName Address\n         LA    R1,L'WRKDSN\n         STH   R1,WRKDSN@+4        Save DSName Length\n         LA    R0,WRKVOL\n         ST    R0,WRKVOL@          Save Volser Address\n         LA    R1,L'WRKVOL\n         STH   R1,WRKVOL@+4        Save Volser Length\n         MVC   WRKPERM(2),=AL2(DCCPERMC)  Permanent Allocations\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse The Input Command Buffer (DDName/DSName List)          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      Copy UPT Address\n         MVC   WRKUPT,CPPLUPT                                  #DD17088\n         MVC   PPLECT,CPPLECT      Copy ECT Address\n         MVC   WRKECT,CPPLECT                                  #DD17088\n         MVC   PPLCBUF,CPPLCBUF    Copy Command Buffer Address\n         LA    R0,WRKECB\n         ST    R0,PPLECB           Save ECB Address\n         MVC   PPLPCL,=A(ADDPCL)   Copy PCL Address\n         LA    R0,WRKANS\n         ST    R0,PPLANS           Save PDL Return Address\n         DROP  R1\n         CALLTSSR EP=IKJPARS       Invoke Parse Routine\n         LTR   R15,R15             Check Parse Return Code\n         JNZ   ADDTERR1            B. If Parse Failed\n\n         L     R7,WRKANS           A(PDL)\n         USING IKJPARMD,R7\n\n         CLI   KWCREATE+1,$CREATE  Check For \"CREATE\" Request  #DD99182\n         JNE   ADDT0100            B. If Not                   #DD99182\n         CLI   KWOPTS+1,$REMOVE    Check For \"REMOVE\" Request  #DD99182\n         JE    ADDTERR4            B. If Yes (MUT-EXCL)        #DD99182\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Obtain The Current DDName's DSName List                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDT0100 DS    0H                                              #DD99182\n         L     R1,DDNAME           A(Specified DDName)\n         LH    R2,DDNAME+4         L(Specified DDName)\n         MVC   WRKDDN,BLANKS\n         #EXEC -R2,MVC,WRKDDN(*-*),0(R1)\n         MVC   DCBDDNAM-IHADCB+SYSLIB,WRKDDN\n         MVC   WRKDDN1+2(8),WRKDDN\n\n         LA    R2,DCBDDNAM-IHADCB+SYSLIB\n         TIOTSCAN DDN=(R2),OK=ADDT0200                         #DD17088\n\n         OI    WRKFLAG1,WRK$CREA   Indicate \"CREATE\" New DD    #DD17088\n         CLI   KWOPTS+1,$REMOVE    Check For \"REMOVE\"          #DD17088\n         JE    ADDTERR2            B. If Yes (Error)           #DD17088\n         CLI   KWCREATE+1,$NOCREATE Check For \"NOCREATE\"       #DD17088\n         JE    ADDTERR2            B. If Yes (Error)           #DD17088\n         J     ADDT2000            Allocate New Datasets Only  #DD17088\n\nADDT0200 DS    0H                                              #DD17088\n         OI    ARLOPT1,ARLLANY     Return Info Can Be Above The Line\n         RDJFCB SYSLIB             Get Currently Allocated DSName List\n         LTR   R15,R15             Check If Information Returned\n         JNZ   ADDTERR2            B. If Not\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IF \"REMOVE\" CHECK THAT ALL DATASETS ARE WITHIN DD.           *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDT0300 DS    0H                                              #DD17088\n         CLI   KWOPTS+1,$REMOVE    Check For \"REMOVE\"          #DD17088\n         JNE   ADDT0700            B. If Not                   #DD17088\n         LA    R9,DSNAMES          A(DSName List)              #DD17088\n\nADDT0400 DS    0H                                              #DD17088\n         L     R1,0(,R9)           A(DSName)                   #DD17088\n         LH    R2,4(,R9)           L(DSName)                   #DD17088\n         MVC   WRKDSN2,BLANKS                                  #DD17088\n         #EXEC -R2,MVC,WRKDSN2(*-*),0(R1)                      #DD17088\n\n         L     R5,ARLAREA          A(1st Element)              #DD17088\n         LH    R6,ARLRTRVD         #(Returned Elements)        #DD17088\nADDT0500 DS    0H                                              #DD17088\n         LA    R15,4(,R5)          A(Element's JFCB)           #DD17088\n         USING JFCB,R15                                        #DD17088\n         MVC   WRKDSN,JFCBDSNM     Save Current Dataset Name   #DD17088\n         DROP  R15                                             #DD17088\n         CLC   WRKDSN,WRKDSN2      Check If DSNname Found      #DD17088\n         BE    ADDT0600            B. If Yes                   #DD17088\n\n         LH    R15,0(,R5)          L(Element)                  #DD17088\n         LA    R5,0(R15,R5)        A(Next Element)             #DD17088\n         BRCT  R6,ADDT0500         Process The Element List    #DD17088\n         B     ADDTERR5                                        #DD17088\n\nADDT0600 DS    0H                                              #DD17088\n         CLI   24(R9),X'FF'        Check For End Of List       #DD17088\n         JE    ADDT0700            B. If Yes                   #DD17088\n         ICM   R9,15,24(R9)        A(Next DSName)              #DD17088\n         JNZ   ADDT0400            B. If More Datasets         #DD17088\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CREATE &ADDTO VARIABLE                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDT0700 DS    0H                                              #DD17088\n         MVC   CVARCODE,=A(TSVEUPDT)  \"UPDATE\"                 #DD17072\n         LA    R0,CVARCODE                                     #DD17072\n         ST    R0,CVAREC@                                      #DD17072\n         MVC   CVARN,=CL8'ADDTO'   Set Variable Name           #DD17072\n         LA    R0,CVARN            A(Variable Name)            #DD17072\n         ST    R0,CVARN@                                       #DD17072\n         LA    R0,CVARN@                                       #DD17072\n         ST    R0,CVARNPT@                                     #DD17072\n         MVC   CVARL,=F'5'         Set Variable Name Length    #DD17072\n         LA    R0,CVARL            A(Variable Name Length)     #DD17072\n         ST    R0,CVARNLN@                                     #DD17072\n         LA    R0,CVARD@                                       #DD17072\n         ST    R0,CVARDPT@                                     #DD17072\n         LA    R0,CVARDL           A(Variable Data Length)     #DD17072\n         ST    R0,CVARDLN@                                     #DD17072\n         LA    R0,CVARTKN          A(Token)                    #DD17072\n         ST    R0,CVARTKN@                                     #DD17072\n         OI    CVARTKN@,X'80'      Set End Of List             #DD17072\n\n         L     R5,ARLAREA          A(1st Element)              #DD17072\n         LH    R6,ARLRTRVD         #(Returned Elements)        #DD17072\n         LR    R0,R6                                           #DD17072\n         AHI   R0,1                                            #DD17088\n         MHI   R0,47               Quoted & Separated          #DD17072\n         ST    R0,WRKBUFFL         L(Variable Data)            #DD17088\n         GETMAIN RU,LV=(0),LOC=BELOW                           #DD17072\n         ST    R1,CVARD@           A(Variable Data)            #DD17072\n         ST    R1,WRKBUFF@                                     #DD17072\n         LR    R0,R1               A(Variable Data)            #DD17072\n         L     R1,WRKBUFFL         L(Variable Data)            #DD17072\n         #BLANK (R0),LEN=(R1),PAD=C' '                         #DD17072\n\n         L     R4,CVARD@           A(Start Of Variable Area)   #DD17072\n         XC    CVARDL,CVARDL       Initialize Variable Length  #DD17088\n         LTR   R6,R6               Check If Any DSNames        #DD17088\n         JZ    ADDT0900            B. If Not                   #DD17088\nADDT0800 DS    0H                                              #DD17072\n         LA    R15,4(,R5)          A(Element's JFCB)           #DD17072\n         USING JFCB,R15                                        #DD17072\n         MVI   0(R4),C''''                                     #DD17072\n         MVC   1(44,R4),JFCBDSNM   Insert Dataset Name         #DD17072\n         DROP  R15                                             #DD17072\n         LA    R2,1(,R4)           A(1st Byte)                 #DD17072\n         LA    R1,46(,R4)          A(Last Byte)                #DD17072\n         SLR   R0,R0                                           #DD17072\n         IC    R0,=C' '                                        #DD17072\n         SRST  R1,R2               Search For A Blank          #DD17072\n         MVI   0(R1),C''''                                     #DD17072\n         MVI   1(R1),C','          Insert Separator            #DD17072\n         LA    R4,2(,R1)           A(Next Field)               #DD17072\n\n         LH    R15,0(,R5)          L(Element)                  #DD17072\n         LA    R5,0(R15,R5)        A(Next Element)             #DD17072\n         BRCT  R6,ADDT0800         Process The Element List    #DD17072\n\n         SHI   R4,1                A(Last Separator)           #DD17072\n         MVI   0(R4),C' '          Clear It                    #DD17072\n         L     R0,CVARD@           A(Start Of Buffer)          #DD17072\n         SR    R4,R0               Calculate Used Length       #DD17072\n         ST    R4,CVARDL           Save Used Length            #DD17072\n\nADDT0900 DS    0H                                              #DD17088\n         L     R15,FLCCVT          A(CVT)                      #DD17072\n         USING CVTMAP,R15                                      #DD17072\n         L     R15,CVTTVT          A(TVT)                      #DD17072\n         USING TSVT,R15                                        #DD17072\n         L     R15,TSVTVACC        A(IKJCT441)                 #DD17072\n         DROP  R15                                             #DD17072\n         LA    R1,CVARPARM         A(IKJCT441 Parameter List)  #DD17072\n         BASR  R14,R15             Call IKJCT441               #DD17072\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If \"LAST\" Specified Leave Existing Allocation Alone          *\n*        And Simply Concatenate The New DSNames To The End.           *\n*                                                                     *\n*        If \"REMOVE\" Specified                                        *\n*        Re-Allocate The Dsnames From The Original Allocation         *\n*        Removing Any That Match The User Specified DSName List.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         XC    WRKBLKSZ,WRKBLKSZ   Default BLKSIZE=0           #DD17088\n         CLI   KWBLKSIZ+1,$BLKSIZE Check For \"BLKSIZE(...)\"    #DD17088\n         JNE   ADDT1000            B. If Not                   #DD17088\n         ICM   R0,15,BLKSIZE       Load Specified Value        #DD17088\n         STCM  R0,3,WRKBLKSZ       Save Specified Value        #DD17088\nADDT1000 DS    0H                                              #DD17088\n         OI    WRKFLAG1,WRK$ALLO   Remember DD Started         #DD17088\n         CLI   KWOPTS+1,0          Check For \"DEFAULT\"         #DD18120\n         JNE   ADDT1050            B. If Not (Do As Specified) #DD18120\n         MVI   KWOPTS+1,$FIRST     Set Default to \"FIRST\"      #DD18120\nADDT1050 DS    0H                                              #DD18120\n         CLI   KWOPTS+1,$LAST      Check For \"LAST\"            #DD17088\n         JE    ADDT1600            B. If Yes (Add To End)      #DD17088\n\n         FREE  PERM,DDN=WRKDDN@    Free The Current Allocations\n         NI    WRKFLAG1,255-WRK$ALLO                           #DD17088\n\n*        Re-Allocate Original List Removing Specified Dataset Names\n         CLI   KWOPTS+1,$REMOVE    Check For \"REMOVE\"          #DD99182\n         JNE   ADDT2000            B. If Not                   #DD17088\n\nADDT1100 DS    0H                                              #DD17088\n         ICM   R5,15,ARLAREA       A(1st Element)              #DD17088\n         JZ    ADDT2700            B. If No Previous Datasets  #DD17088\n         SLR   R6,R6                                           #DD17088\n         ICM   R6,3,ARLRTRVD       #(Returned Elements)        #DD17088\n         JZ    ADDT2700                                        #DD17088\nADDT1200 DS    0H                                              #DD99182\n         LA    R15,4(,R5)          A(Element's JFCB)           #DD99182\n         USING JFCB,R15                                        #DD99182\n         MVC   WRKDSN,JFCBDSNM     Copy The Dataset Name       #DD99182\n         MVC   WRKVOL,JFCBVOLS                                 #DD99182\n         DROP  R15                                             #DD99182\n         BAS   R14,CHECKDSN        Process This DSName         #DD99182\n         LTR   R15,R15             Check If To Be \"REMOVED\"    #DD99182\n         JZ    ADDT1300            B. If Not (Allocate It)     #DD99182\n\n         LH    R15,0(,R5)          L(Element)                  #DD99182\n         LA    R5,0(R15,R5)        A(Next Element)             #DD99182\n         BRCT  R6,ADDT1200         Process The Element List    #DD99182\n         J     ADDT2700            B. If Done Original List    #DD17088\n\nADDT1300 DS    0H                                              #DD99182\n         ALLOC PERM,DDN=WRKDDN@,BLKSIZE=WRKBLKSZ,              #DD17088*\n               DSN=WRKDSN@,VOL=WRKVOL@,UNIT='SYSALLDA',DISP=SHR, D99182*\n               ERROR=ADDTERR3                                  #DD17088\n         OI    WRKFLAG1,WRK$ALLO   Remember DD Started         #DD17088\n\n         LH    R15,0(,R5)          L(Element)                  #DD99182\n         LA    R5,0(R15,R5)        A(Next Element)             #DD99182\n         CHI   R6,1                Check For Last Element      #DD17088\n         JE    ADDT2700            B. If List Exhausted        #DD17088\n         SHI   R6,1                Subtract 1 From Count       #DD17088\n\nADDT1400 DS    0H                                              #DD17088\n         LA    R15,4(,R5)          A(Element's JFCB)           #DD17088\n         USING JFCB,R15                                        #DD17088\n         MVC   WRKDSN,JFCBDSNM     Copy The Dataset Name       #DD17088\n         MVC   WRKVOL,JFCBVOLS     Copy The Volser             #DD17088\n         DROP  R15                                             #DD17088\n\n         BAS   R14,CHECKDSN        Process This DSName         #DD17088\n         LTR   R15,R15             Check If To Be \"REMOVED\"    #DD17088\n         JNZ   ADDT1500            B. If Yes (Don't CONCAT)    #DD17088\n\n         ALLOC PERM,DDNTO=WRKDDN2+2,                           #DD17088*\n               DSN=WRKDSN@,VOL=WRKVOL@,UNIT='SYSALLDA',DISP=SHR, D17088*\n               ERROR=ADDTERR3                                  #DD17088\n         ALLOC VERB=S99VRBCC,TU=(WRKDDNL@,WRKPERM),            #DD17088*\n               ERROR=ADDTERR3                                  #DD17088\n\nADDT1500 DS    0H                                              #DD17088\n         LH    R15,0(,R5)          L(Element)                  #DD17088\n         LA    R5,0(R15,R5)        A(Next Element)             #DD17088\n         BRCT  R6,ADDT1400         Process The Element List    #DD17088\n         J     ADDT2700                                        #DD17088\n\n*        Concatenate Specified Dataset Names To End Of Existing List.\nADDT1600 DS    0H                                              #DD17088\n         LA    R5,DSNAMES          A(New DSName List)          #DD17088\n         TM    WRKFLAG1,WRK$ALLO   Check If DDName Allocated   #DD17088\n         JO    ADDT1800            B. If Yes                   #DD17088\n         ALLOC PERM,DDN=WRKDDN@,BLKSIZE=WRKBLKSZ,              #DD17088*\n               DSN=(R5),DISP=SHR,                              #DD17088*\n               ERROR=ADDTERR3                                  #DD17088\n         OI    WRKFLAG1,WRK$ALLO   Remember DD Started         #DD17088\n\n         CLI   KWMSGS+1,$VERBOSE   Check For \"VERBOSE\"         #DD17088\n         JNE   ADDT1700            B. If Not                   #DD17088\n         MVC   WRKINS1(T002IDSL),T002IDS                       #DD17088\n         MVC   WRKINS1+4(44),BLANKS                            #DD17088\n         L     R1,0(,R5)           A(DSName)                   #DD17088\n         LH    R2,4(,R5)           L(DSName)                   #DD17088\n         #EXEC -R2,MVC,WRKINS1+4(*-*),0(R1)                    #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         MVC   WRKINS2(T002IDDL),T002IDD                       #DD17088\n         MVC   WRKINS2+4(8),WRKDDN                             #DD17088\n         LA    R1,WRKINS2                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT002I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #2)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT002I  added             #DD17088\n\nADDT1700 DS    0H                                              #DD17088\n         CLI   24(R5),X'FF'        Check For End Of List       #DD17088\n         JE    ADDT2700            B. If Yes                   #DD17088\n         ICM   R5,15,24(R5)        A(Next DSName)              #DD17088\n         JZ    ADDT2700            B. If Only The One          #DD17088\n\nADDT1800 DS    0H                                              #DD17088\n         ALLOC PERM,DDNTO=WRKDDN2+2,                           #DD17088*\n               DSN=(R5),DISP=SHR,                              #DD17088*\n               ERROR=ADDTERR3                                  #DD17088\n         ALLOC VERB=S99VRBCC,TU=(WRKDDNL@,WRKPERM),            #DD17088*\n               ERROR=ADDTERR3                                  #DD17088\n\n         CLI   KWMSGS+1,$VERBOSE   Check For \"VERBOSE\"         #DD17088\n         JNE   ADDT1900            B. If Not                   #DD17088\n         MVC   WRKINS1(T002IDSL),T002IDS                       #DD17088\n         MVC   WRKINS1+4(44),BLANKS                            #DD17088\n         L     R1,0(,R5)           A(DSName)                   #DD17088\n         LH    R2,4(,R5)           L(DSName)                   #DD17088\n         #EXEC -R2,MVC,WRKINS1+4(*-*),0(R1)                    #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         MVC   WRKINS2(T002IDDL),T002IDD                       #DD17088\n         MVC   WRKINS2+4(8),WRKDDN                             #DD17088\n         LA    R1,WRKINS2                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT002I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #2)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT002I  added             #DD17088\n\nADDT1900 DS    0H                                              #DD17088\n         CLI   24(R5),X'FF'        Check For End Of List       #DD17088\n         JE    ADDT2700            B. If Yes                   #DD17088\n         ICM   R5,15,24(R5)        A(Next DSName)              #DD17088\n         JNZ   ADDT1800            B. If Another DSName        #DD17088\n         J     ADDT2700                                        #DD17088\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If \"FIRST\" Specified                                         *\n*        Allocate The New DSNames                                     *\n*        And Concatenate The Old DSNames To The End.                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDT2000 DS    0H                                              #DD17088\n         LA    R5,DSNAMES          A(New DSName List)          #DD17088\n         ALLOC PERM,DDN=WRKDDN@,BLKSIZE=WRKBLKSZ,              #DD17088*\n               DSN=(R5),DISP=SHR,                              #DD17088*\n               ERROR=ADDTERR3                                  #DD17088\n         OI    WRKFLAG1,WRK$ALLO   Remember DD Started         #DD17088\n\n         CLI   KWMSGS+1,$VERBOSE   Check For \"VERBOSE\"         #DD17088\n         JNE   ADDT2100            B. If Not                   #DD17088\n         MVC   WRKINS1(T002IDSL),T002IDS                       #DD17088\n         MVC   WRKINS1+4(44),BLANKS                            #DD17088\n         L     R1,0(,R5)           A(DSName)                   #DD17088\n         LH    R2,4(,R5)           L(DSName)                   #DD17088\n         #EXEC -R2,MVC,WRKINS1+4(*-*),0(R1)                    #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         MVC   WRKINS2(T002IDDL),T002IDD                       #DD17088\n         MVC   WRKINS2+4(8),WRKDDN                             #DD17088\n         LA    R1,WRKINS2                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT002I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #2)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT002I  added             #DD17088\n\nADDT2100 DS    0H                                              #DD17088\n         CLI   DSNAMES+24,X'FF'    Check For End Of List\n         JE    ADDT2400            B. If Yes\n         ICM   R5,15,DSNAMES+24    A(Next DSName)\n         JZ    ADDT2400            B. If Only The One\n\nADDT2200 DS    0H\n         ALLOC PERM,DDNTO=WRKDDN2+2,                                   *\n               DSN=(R5),DISP=SHR,                                      *\n               ERROR=ADDTERR3\n         ALLOC VERB=S99VRBCC,TU=(WRKDDNL@,WRKPERM),                    *\n               ERROR=ADDTERR3\n\n         CLI   KWMSGS+1,$VERBOSE   Check For \"VERBOSE\"         #DD17088\n         JNE   ADDT2300            B. If Not                   #DD17088\n         MVC   WRKINS1(T002IDSL),T002IDS                       #DD17088\n         MVC   WRKINS1+4(44),BLANKS                            #DD17088\n         L     R1,0(,R5)           A(DSName)                   #DD17088\n         LH    R2,4(,R5)           L(DSName)                   #DD17088\n         #EXEC -R2,MVC,WRKINS1+4(*-*),0(R1)                    #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         MVC   WRKINS2(T002IDDL),T002IDD                       #DD17088\n         MVC   WRKINS2+4(8),WRKDDN                             #DD17088\n         LA    R1,WRKINS2                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT002I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #2)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT002I  added             #DD17088\n\nADDT2300 DS    0H                                              #DD17088\n         CLI   24(R5),X'FF'        Check For End Of List\n         JE    ADDT2400            B. If Yes\n         ICM   R5,15,24(R5)        A(Next DSName)\n         JNZ   ADDT2200            B. If Another DSName Specified\n\nADDT2400 DS    0H\n         ICM   R5,15,ARLAREA       A(1st Element)              #DD17088\n         JZ    ADDT2700                                        #DD17088\n         SLR   R6,R6                                           #DD17088\n         ICM   R6,3,ARLRTRVD       #(Returned Elements)        #DD17088\n         JZ    ADDT2700                                        #DD17088\nADDT2500 DS    0H\n         LA    R15,4(,R5)          A(Element's JFCB)\n         USING JFCB,R15\n         MVC   WRKDSN,JFCBDSNM     Copy The Dataset Name\n         MVC   WRKVOL,JFCBVOLS     Copy The Volser\n         DROP  R15\n\n         BAS   R14,CHECKDSN        Process This DSName         #DD99182\n         LTR   R15,R15             Check If To Be \"REMOVED\"    #DD99182\n         JNZ   ADDT2600            B. If Yes (Don't Concat)    #DD99182\n\n         ALLOC PERM,DDNTO=WRKDDN2+2,                                   *\n               DSN=WRKDSN@,VOL=WRKVOL@,UNIT='SYSALLDA',DISP=SHR,       *\n               ERROR=ADDTERR3\n         ALLOC VERB=S99VRBCC,TU=(WRKDDNL@,WRKPERM),                    *\n               ERROR=ADDTERR3\n\nADDT2600 DS    0H                                              #DD99182\n         LH    R15,0(,R5)          L(Element)\n         LA    R5,0(R15,R5)        A(Next Element)\n         BRCT  R6,ADDT2500         Process The Element List\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Free The Obtained JFCB List, Parse Storage and Exit.         *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDT2700 DS    0H                                              #DD17088\n         ICM   R3,15,ARLAREA       A(Element Buffer)           #DD17088\n         JZ    ADDT2800                                        #DD17088\n         SLR   R4,R4\n         IC    R4,ARLPOOL          ARL Subpool\n         SLR   R5,R5\n         ICM   R5,7,ARLRLEN        L(Element Buffer)\n         JZ    ADDT2800                                        #DD17088\n         FREEMAIN RC,A=(R3),SP=(R4),LV=(R5)\n\nADDT2800 DS    0H                                              #DD99182\n         IKJRLSA WRKANS            Release The PDL Buffer\n         J     ADDTEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate With Appropriate Return Code                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDTERR1 DS    0H\n         ST    R15,WRKRC           Save Return Code            #DD17088\n         ST    R0,WRKRS            Save Reason Code            #DD17088\n         MVC   WRKINS1(T006IRCL),T006IRC                       #DD17088\n         UNPK  WRKINS1+4(9),WRKRC(5)                           #DD17088\n         TR    WRKINS1+4(8),HEXTABLE-C'0'                      #DD17088\n         MVC   WRKINS2(T006IRSL),T006IRS                       #DD17088\n         UNPK  WRKINS2+4(9),WRKRS(5)                           #DD17088\n         TR    WRKINS2+4(8),HEXTABLE-C'0'                      #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT006I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #2)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT006I IKJPARS return     #DD17088\n         #SETRC 4                  Indicate \"Parse Error'\n         J     ADDTEXIT\n\nADDTERR2 DS    0H\n         MVC   WRKINS1(T003IDDL),T003IDD                       #DD17088\n         MVC   WRKINS1+4(8),WRKDDN Insert DDName               #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,2                Indicate 2 Segments         #DD17088\n         LA    R1,ADDT003I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         STM   R0,R2,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT003I unable to locate   #DD17088\n         #SETRC 8                  Indicate Error\n         J     ADDTEXIT\n\nADDTERR3 DS    0H\n         S99FAIL ,                 Display Allocation Error Message\n         #SETRC 12                 Indicate Error\n         J     ADDTEXIT\n\nADDTERR4 DS    0H                                              #DD99182\n         LA    R0,1                Indicate 2 Segments         #DD17088\n         LA    R1,ADDT004I         A(Message Text)             #DD17088\n         STM   R0,R1,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT004I \"CREATE\"/\"REMOVE\"  #DD17088\n         #SETRC 16                 Indicate Error              #DD99182\n         J     ADDTEXIT                                        #DD99182\n\nADDTERR5 DS    0H                                              #DD99182\n         MVC   WRKINS1(T005IDSL),T005IDS                       #DD17088\n         MVC   WRKINS1+4(44),WRKDSN2 Current Dataset Name      #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         MVC   WRKINS2(T005IDDL),T005IDD                       #DD17088\n         MVC   WRKINS2+4(8),WRKDDN Current DD Name             #DD17088\n         LA    R1,WRKINS2                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT005I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #1)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT005I dsname not found   #DD17088\n         #SETRC 20                 Indicate Error              #DD99182\n         J     ADDTEXIT                                        #DD99182\n\nADDTEXIT DS    0H                                              #DD17072\n         ICM   R1,15,WRKBUFF@      A(DSName Buffer)            #DD17072\n         JZ    ADDT9999                                        #DD17072\n         ICM   R0,15,WRKBUFFL      L(DSName Buffer)            #DD17072\n         JZ    ADDT9999                                        #DD17072\n         FREEMAIN RU,LV=(0),A=(1)                              #DD17072\n\nADDT9999 #STOP ,                   Return To Caller\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Check If Dataset Is To Be \"REMOVED\" From Concatenation.      *\n*                                                                     *\n*---------------------------------------------------------------------*\nCHECKDSN DS    0H                  Start Subroutine            #DD99182\n         STM   R0,R15,SUBSAVE1     Save All Registers          #DD99182\n         LHI   R9,0                Indicate \"Not Found\"        #DD99182\n\n         CLI   KWOPTS+1,$REMOVE    Check For \"REMOVE\"          #DD99182\n         JNE   CHECKXIT            B. If Not                   #DD99182\n\n         LA    R5,DSNAMES          A(DSName List)              #DD99182\nCHEC0100 DS    0H                                              #DD99182\n         L     R4,0(,R5)           A(DSName)                   #DD99182\n         LH    R3,4(,R5)           L(DSName)                   #DD99182\n         MVC   WRKDSN2,BLANKS                                  #DD99182\n         #EXEC -R3,MVC,WRKDSN2(*-*),0(R4)                      #DD99182\n         CLC   WRKDSN,WRKDSN2      Check If Dsnames Match      #DD99182\n         JNE   CHEC0300            B. If Not                   #DD99182\n\n         CLI   KWMSGS+1,$VERBOSE   Check For \"VERBOSE\"         #DD17088\n         JNE   CHEC0200            B. If Not                   #DD17088\n         MVC   WRKINS1(T001IDSL),T001IDS                       #DD17088\n         MVC   WRKINS1+4(44),WRKDSN2 Current Dataset Name      #DD17088\n         LA    R1,WRKINS1                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         MVC   WRKINS2(T001IDDL),T001IDD                       #DD17088\n         MVC   WRKINS2+4(8),WRKDDN Current DD Name             #DD17088\n         LA    R1,WRKINS2                                      #DD17088\n         BAS   R14,FIXLEN          Update Insert Length        #DD17088\n         LA    R0,3                Indicate 3 Segments         #DD17088\n         LA    R1,ADDT001I         A(Message Text)             #DD17088\n         LA    R2,WRKINS1          A(Message Insert #1)        #DD17088\n         LA    R3,WRKINS2          A(Message Insert #2)        #DD17088\n         STM   R0,R3,WRKOLD                                    #DD17088\n         BAS   R14,PUTLINE         ADDT001I ddname removed     #DD17088\n\nCHEC0200 DS    0H                                              #DD99182\n         LHI   R9,4                Indicate \"REMOVE\" DSName    #DD99182\n         J     CHECKXIT                                        #DD99182\n\nCHEC0300 DS    0H                                              #DD99182\n         CLI   24(R5),X'FF'        Check For End Of List       #DD99182\n         JE    CHECKXIT            B. If DSName Not Found      #DD17088\n         ICM   R5,15,24(R5)        A(Next DSName)              #DD99182\n         JNZ   CHEC0100            B. If Another Name Exists   #DD99182\n\nCHECKXIT DS    0H                  Return To Caller            #DD99182\n         LR    R15,R9                                          #DD15088\n         LM    R0,R14,SUBSAVE1     Restore All Registers       #DD99182\n         BR    R14                 Return To Caller            #DD99182\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Correct Insert Length.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nFIXLEN   DS    0H                  Start Subroutine            #DD17088\n         STM   R0,R15,SUBSAVE3     Save All Registers          #DD17088\n         LR    R5,R1               A(Start Of Insert)          #DD17088\n         SLR   R14,R14                                         #DD17088\n         ICM   R14,3,0(R5)         L(Insert Area)              #DD17088\n         JZ    FIX00300            B. If Length Is Zero        #DD17088\n         AR    R14,R5              A(End Of Insert Area)       #DD17088\n         SHI   R14,1               A(Last Byte Of Insert Area) #DD17088\nFIX00100 DS    0H                                              #DD17088\n         TM    0(R14),X'BF'        Check For Blanks Or Zeros   #DD17088\n         JNZ   FIX00200            B. If End Found             #DD17088\n         BRCT  R14,FIX00100        Back Up & Keep Looking      #DD17088\nFIX00200 DS    0H                                              #DD17088\n         AHI   R14,1               A(End Of Insert Text)       #DD17088\n         SR    R14,R5              Calculate Insert Length     #DD17088\n         STCM  R14,3,0(R5)         L(Used Insert Area)         #DD17088\nFIX00300 DS    0H                                              #DD17088\n         LM    R0,R14,SUBSAVE3     Restore All Registers       #DD17088\n         BR    R14                 Return To Caller            #DD17088\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Output Message To Terminal.                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nPUTLINE  DS    0H                                              #DD17088\n         CLI   KWMSGS+1,$QUIET     Check For \"NOMSGS\"          #DD17088\n         JE    PUTLEXIT                                        #DD17088\n\n         STM   R0,R15,SUBSAVE2     Save All Registers          #DD17088\n         L     R2,WRKUPT           A(UPT)                      #DD17088\n         L     R3,WRKECT           A(ECT)                      #DD17088\n         LA    R4,WRKECB           A(ECB)                      #DD17088\n         XC    WRKECB,WRKECB                                   #DD17088\n         MVC   PUTLINEL(MODPUTLL),MODPUTL                      #DD17088\n         PUTLINE PARM=PUTLINEL,UPT=(R2),ECT=(R3),ECB=(R4),     #DD17088*\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),              #DD17088*\n               MF=(E,WRKIOPL)                                  #DD17088\n         LM    R0,R15,SUBSAVE2     Restore All Registers       #DD17088\n\nPUTLEXIT DS    0H                                              #DD17088\n         BR    R14                 Return To Caller            #DD17088\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants And WorkArea.                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LTORG ,                   Literal Pool                #DD17088\n         #EXEC ,                   Executed Statements         #DD17088\n\nADDT001I #MSG  'ADDT001I  removed from  successfully.'         #DD17088\nT001IDS  #MSG  '_________+_________+_________+_________+____',OFFSET=9\nT001IDSL EQU   *-T001IDS                                       #DD17088\nT001IDD  #MSG  '________',OFFSET=23                            #DD17088\nT001IDDL EQU   *-T001IDD                                       #DD17088\n\nADDT002I #MSG  'ADDT002I  added to  successfully.'             #DD17088\nT002IDS  #MSG  '_________+_________+_________+_________+____',OFFSET=9\nT002IDSL EQU   *-T002IDS                                       #DD17088\nT002IDD  #MSG  '________',OFFSET=19                            #DD17088\nT002IDDL EQU   *-T002IDD                                       #DD17088\n\nADDT003I #MSG  'ADDT003I unable to locate DD .'                #DD17088\nT003IDD  #MSG  '________',OFFSET=29                            #DD17088\nT003IDDL EQU   *-T003IDD                                       #DD17088\n\nADDT004I #MSG  'ADDT004I \"CREATE\" and \"REMOVE\" are mutually exclusive.'\n\nADDT005I #MSG  'ADDT005I  not found in  DD statement.'         #DD17088\nT005IDS  #MSG  '_________+_________+_________+_________+____',OFFSET=9\nT005IDSL EQU   *-T005IDS                                       #DD17088\nT005IDD  #MSG  '________',OFFSET=23                            #DD17088\nT005IDDL EQU   *-T005IDD                                       #DD17088\n\nADDT006I #MSG  'ADDT006I IKJPARS return code X'''', reason code X''''.'\nT006IRC  #MSG  '________',OFFSET=31                            #DD17088\nT006IRCL EQU   *-T006IRC                                       #DD17088\nT006IRS  #MSG  '________',OFFSET=48                            #DD17088\nT006IRSL EQU   *-T006IRC                                       #DD17088\n\nMODPUTL  PUTLINE MF=L\nMODPUTLL EQU   *-MODPUTL\n\nBLANKS   DC    CL256' '            Lots Of Blanks\nSYSLIB   DCB   DSORG=PO,DDNAME=*-*,MACRF=R,EXLST=EXITLIST,             *\n               DCBE=SYSLDCBE                                   #DD12062\nSYSLDCBE DCBE  EADSCB=OK                                       #DD12062\nEXITLIST DS    0F\n         DC    X'93',AL3(DDARL)    \"LIST\" RDJFCB Exit (Obtain ARL)\nDDARL    DS    0F\n         IHAARL DSECT=NO           Allocation Retrieval List\n\nHEXTABLE DC    C'0123456789ABCDEF'                             #DD17088\n\n         #STARTWA PATCH=NO\nSUBSAVE1 DS    16F                 Subroutine Save Area        #DD99182\nSUBSAVE2 DS    16F                 Subroutine Save Area        #DD17088\nSUBSAVE3 DS    16F                 Subroutine Save Area        #DD17088\n\nPUTLINEL PUTLINE MF=L              Putline Parameter List      #DD17088\n\n         DYNSPACE ,                Dynamic Allocation Work Area\nWRKRC    DS    F                   Return Code                 #DD17088\nWRKRS    DS    F                   Reason Code                 #DD17088\nWRKFLAG1 DS    X                   General Flag Byte #1        #DD99182\nWRK$CREA EQU   X'80'   1... ....   - Create New File Only      #DD99182\nWRK$ALLO EQU   X'40'   .1.. ....   - DDName Allocation Started #DD17088\nWRKANS   DS    F                   Parse Answer Buffer\nWRKPERM  DS    AL2,AL2\nWRKDDNL@ DS    AL2,AL2             DDName List Address/Count\nWRKDDN1  DS    AL2,CL8             DDName Length / DDName\nWRKDDN2  DS    AL2,CL8             DDName Length / DDName\nWRKDDN@  DS    A,AL2               DDName Address/Length\nWRKDDN   DS    CL8                 DDName\nWRKDSN@  DS    A,AL2               DSName Address/Length\nWRKDSN   DS    CL44                DSName\nWRKDSN2  DS    CL44                Specified DSName            #DD99182\nWRKUPT   DS    A                   A(UPT)                      #DD17088\nWRKECT   DS    A                   A(ECT)                      #DD17088\nWRKECB   DS    F                   Parse ECB\nWRKIOPL  DS    7F                  IOPL                        #DD17088\nWRKOLD   DS    4F                  Output Line Descriptor      #DD17088\nWRKPPL   DS    7F                  Parse Parameter List\nWRKVOL@  DS    A,AL2               Volser Address/Length\nWRKVOL   DS    CL6                 Volser\n\nWRKBLKSZ DS    AL2                 Blksize                     #DD17088\n\nWRKBUFF@ DS    A                   A(Dsname Buffer)            #DD17072\nWRKBUFFL DS    F                   L(Dsname Buffer)            #DD17072\n\nCVARPARM DS    0D                  IKJCT441 Parameter List     #DD17072\nCVAREC@  DS    A                   A(Entry Code)               #DD17072\nCVARNPT@ DS    A                   A(Variable Name Pointer)    #DD17072\nCVARNLN@ DS    A                   A(Variable Name Length Pointer) 7072\nCVARDPT@ DS    A                   A(Variable Data)            #DD17072\nCVARDLN@ DS    A                   A(Variable Data Length)     #DD17072\nCVARTKN@ DS    A                   A(Token)                    #DD17072\nCVARCODE DS    F                   Entry Code                  #DD17072\nCVARN@   DS    A                   A(Variable Name)            #DD17072\nCVARN    DS    CL8                 Variable Name               #DD17072\nCVARL    DS    F                   Variable Name Length        #DD17072\nCVARD@   DS    A                   A(Variable Data)            #DD17072\nCVARDL   DS    F                   L(Variable Data)            #DD17072\nCVARTKN  DS    D                   Token                       #DD17072\n\nWRKINS1  DS    A,CL256             Message Insert Area         #DD17088\nWRKINS2  DS    A,CL256             Message Insert Area         #DD17088\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse Parameter List                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nADDPCL   IKJPARM ,\nDDNAME   IKJPOSIT DSNAME,DDNAM,                                        *\n               PROMPT='Current DDName',                                *\n               HELP='Name Of Currently Allocated DD'\n\nDSNAMES  IKJPOSIT DSNAME,USID,LIST,                                    *\n               PROMPT='New DSName(s)',                                 *\n               HELP='Name Of Dataset(s) To Be Added'\n\nKWCREATE IKJKEYWD ,                                            #DD99182\n         IKJNAME 'CREATE'                                      #DD99182\n         IKJNAME 'NOCREATE'                                    #DD13072\n$CREATE  EQU   1                                               #DD17088\n$NOCREATE EQU  2                                               #DD17088\n\nKWBLKSIZ IKJKEYWD ,\n         IKJNAME 'BLKSIZE',SUBFLD=SUBFLD1\n$BLKSIZE EQU   1                                               #DD17088\n\nKWOPTS   IKJKEYWD ,                                            #DD99182\n         IKJNAME 'REMOVE',ALIAS='DELETE'                       #DD99182\n         IKJNAME 'FIRST',ALIAS=('BEFORE','FRONT')              #DD17088\n         IKJNAME 'LAST',ALIAS=('AFTER','END')                  #DD17088\n$REMOVE  EQU   1                                               #DD17088\n$FIRST   EQU   2                                               #DD17088\n$LAST    EQU   3                                               #DD17088\n\nKWMSGS   IKJKEYWD ,                                            #DD17088\n         IKJNAME 'QUIET',ALIAS='NOMSGS'                        #DD17088\n         IKJNAME 'VERBOSE',ALIAS='MSGS'                        #DD17088\n$QUIET   EQU   1                                               #DD17088\n$VERBOSE EQU   2                                               #DD17088\n\nSUBFLD1  IKJSUBF ,\nBLKSIZE  IKJIDENT 'BLKSIZE',INTEG,                                     *\n               HELP='BLKSIZE Of The Largest Dataset (Or Greater)'\n         IKJENDP ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         #DSECTS ALLOC,CVT,DCB,JFCB,TSO,PSA\n*        IKJEFFDF DFDSECT=YES,DFDSEC2=YES                      #DD17088\n         IKJTSVT ,           TSO Vector Table                  #DD17072\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATEXTR": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x01\\x05\\x01\\x05\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:26", "lines": 261, "newlines": 261, "modlines": 0, "user": "SOURCE"}, "text": "CATEXTR  #START BASE=(R12),AMODE=31,RMODE=24,COPY=YES\n\n*---------------------------------------------------------------------*\n*        CHECK FOR PARM=CATACB                                        *\n*---------------------------------------------------------------------*\n         L     R1,0(,R1)           LOAD INPUT PARAMETER LIST ADDRESS\n         SLR   R2,R2\n         ICM   R2,3,0(R1)          LOAD INPUT PARAMETER TEXT LENGTH\n         BZ    CATE0100            B. IF NONE SPECIFIED\n         CH    R2,=H'06'           CHECK FOR MAXIMUM LENGTH\n         BH    CATE0100            B. IF TOO LONG\n         BCTR  R2,0                DECREMENT FOR EXECUTE\n         #EXEC R2,CLC,2(*-*,R1),=CL6'CATACB'\n         BNE   CATE0100            B. IF PARM IS NOT \"CATACB\"\n         OI    WRKFLAG,WRK$ACB@    ELSE. REMEMBER \"CATACB\" SPECIFIED\n\n*---------------------------------------------------------------------*\n*        SAVE INPUT DATASET NAME                                      *\n*---------------------------------------------------------------------*\nCATE0100 DS    0H\n         LOAD  EP=HEXDUMP          LOAD THE HEX DUMP FORMATTER\n         ST    R0,WRKDUMP@         SAVE \"HEXDUMP\" ROUTINE ADDRESS\n\n         L     R2,WRKAREAL         LOAD WORKAREA LENGTH\n         GETMAIN RU,LV=(R2)        ACQUIRE STORAGE FOR WORKAREA\n         ST    R1,WRKAREA          SAVE WORKAREA ADDRESS\n\n         LA    R0,WRKDUMPP+4       LOAD HEXDUMP PARAMETER LIST ADDRESS\n         ST    R0,WRKDUMPP\n         MVI   WRKDUMPP+16,X'40'   INDICATE RELATIVE ADDRESS\n         CLC   DCBLRECL-IHADCB+SYSPRINT,=AL2(133)\n         BL    CATE0150            B. IF OUTPUT RECORD LENGTH < 133\n         MVI   WRKDUMPP+16,X'20'   INDICATE 130 BYTE DUMP OUTPUT\n\nCATE0150 DS    0H\n         LA    R0,WRKPRINT+8       LOAD HEXDUMP OUTPUT AREA ADDRESS\n         STCM  R0,7,WRKDUMPP+17\n         MVC   WRKPRINT,BLANKS     INITIALIZE THE OUTPUT BUFFER\n\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n\n*---------------------------------------------------------------------*\n*        GET NEXT INPUT RECORD AND CHECK FOR NEW DATASET NAME         *\n*---------------------------------------------------------------------*\nCATE0200 DS    0H\n         GET   SYSIN               GET INPUT RECORD\n         LR    R10,R1              SAVE RECORD ADDRESS\n\n         CLI   0(R10),C'*'         CHECK FOR COMMENT RECORD\n         BE    CATE0200            B. IF YES\n         OC    0(80,R10),BLANKS    ENSURE UPPER CASE DATA\n\n         CLC   =C'DSN=',0(R10)     CHECK FOR \"DSN=\"\n         BNE   CATE0400            B. IF NOT\n         XC    WRKACB@,WRKACB@\n         MVC   WRKDSNAM,4(R10)     SAVE DATASET NAME\n\n         MVC   WRKPRINT+1(72),0(R10)\n         PUT   SYSPRINT,WRKPRINT   PRINT CURRENT INPUT RECORD\n         MVC   WRKPRINT,BLANKS\n\n         TM    WRKFLAG,WRK$ACB@    CHECK FOR PARM=CATACB\n         BNO   CATE0200            B. IF NOT\n\n         XC    WRKCTGFL,WRKCTGFL\n         #CTGFL CATACB,MF=(E,WRKCTGFL)\n         XC    WRKCTGPL,WRKCTGPL\n         L     R2,WRKAREA          LOAD WORKAREA ADDRESS\n         L     R3,WRKAREAL         LOAD WORKAREA LENGTH\n         #CTGPL LISTCAT,                                               *\n               OPTIONS=(NAME,BOTH,AM0),                                *\n               CRI=WRKDSNAM,                                           *\n               WORK=((R2),(R3),FORMAT2),                               *\n               FIELDS=(WRKCTGFL),                                      *\n               MF=(E,WRKCTGPL)\n\n         CATALOG WRKCTGPL\n         LTR   R15,R15\n         BZ    CATE0300\n         #SETRC (R15),FIELD=CATRC\n         MVC   WRKMSG01+1(8),=CL8'CATACB'\n         LA    R14,WRKCTGPL\n         USING CTGPL,R14\n         MVC   WRKMSG01+32(2),CTGMODID\n         STM   R15,R0,WRKDBL1      SAVE RETURN CODE / REASON CODE\n         MVI   WRKMSG01+42,C''''\n         UNPK  WRKMSG01+43(9),WRKDBL1(5)\n         TR    WRKMSG01+43(8),WRKTABLE-C'0'\n         MVI   WRKMSG01+51,C''''\n         MVI   WRKMSG01+61,C''''\n         UNPK  WRKMSG01+62(5),CTGREASN(3)\n         DROP  R14\n         TR    WRKMSG01+62(4),WRKTABLE-C'0'\n         MVI   WRKMSG01+66,C''''\n         PUT   SYSPRINT,WRKMSG01\n         B     CATE0200\nCATE0300 DS    0H\n         #GETFL WRKCTGFL,(R2),(R3),ZERO=CATE0200\n         MVC   WRKACB@,0(R2)\n         B     CATE0200\n\n*---------------------------------------------------------------------*\n*        FORMAT FIELD PARAMETER LIST                                  *\n*---------------------------------------------------------------------*\nCATE0400 DS    0H\n         XC    WRKCTGFL,WRKCTGFL\n         #CTGFL (R10),MF=(E,WRKCTGFL)\n\n*---------------------------------------------------------------------*\n*        FORMAT CATALOG PARAMETER LIST                                *\n*---------------------------------------------------------------------*\n         XC    WRKCTGPL,WRKCTGPL\n         L     R2,WRKAREA          LOAD WORKAREA ADDRESS\n         L     R3,WRKAREAL         LOAD WORKAREA LENGTH\n         ICM   R15,15,WRKACB@      CHECK IF A CATALOG'S ACB EXISTS\n         BZ    CATE0500            B. IF NOT\n         #CTGPL LISTCAT,                                               *\n               OPTIONS=(NAME,BOTH,AM0),                                *\n               CRI=WRKDSNAM,                                           *\n               CATALOG=WRKACB@,                                        *\n               WORK=((R2),(R3)),                                       *\n               FIELDS=(WRKCTGFL),                                      *\n               MF=(E,WRKCTGPL)\n         B     CATE0600\n\nCATE0500 DS    0H\n         #CTGPL LISTCAT,                                               *\n               OPTIONS=(NAME,BOTH,AM0),                                *\n               CRI=WRKDSNAM,                                           *\n               WORK=((R2),(R3)),                                       *\n               FIELDS=(WRKCTGFL),                                      *\n               MF=(E,WRKCTGPL)\n\nCATE0600 DS    0H\n         CATALOG WRKCTGPL\n         LTR   R15,R15\n         BZ    CATE0700\n         #SETRC (R15),FIELD=CATRC\n         MVC   WRKMSG01+1(8),0(R10)\n         LA    R14,WRKCTGPL\n         USING CTGPL,R14\n         MVC   WRKMSG01+32(2),CTGMODID\n         STM   R15,R0,WRKDBL1      SAVE RETURN CODE / REASON CODE\n         MVI   WRKMSG01+42,C''''\n         UNPK  WRKMSG01+43(9),WRKDBL1(5)\n         TR    WRKMSG01+43(8),WRKTABLE-C'0'\n         MVI   WRKMSG01+51,C''''\n         MVI   WRKMSG01+61,C''''\n         UNPK  WRKMSG01+62(5),CTGREASN(3)\n         DROP  R14\n         TR    WRKMSG01+62(4),WRKTABLE-C'0'\n         MVI   WRKMSG01+66,C''''\n         PUT   SYSPRINT,WRKMSG01\n         B     CATE0200\n\n*---------------------------------------------------------------------*\n*        REPORT ON EXTRACTED CATALOG FIELD'S INFORMATION              *\n*---------------------------------------------------------------------*\nCATE0700 DS    0H\n         #GETFL WRKCTGFL,(R2),(R3),ZERO=CATE0800\n         BAL   R14,DUMPIT          DUMP THE EXTRACTED FIELD INFORMATION\n         B     CATE0200\n\nCATE0800 DS    0H\n         MVC   WRKPRINT+1(8),0(R10)\n         PUT   SYSPRINT,WRKPRINT   PRINT CURRENT INPUT RECORD\n         MVC   WRKPRINT,BLANKS\n         B     CATE0200\n\n*---------------------------------------------------------------------*\n*        TERMINATE                                                    *\n*---------------------------------------------------------------------*\nCATE0900 DS    0H\n         ICM   R15,15,WRKDUMP@     LOAD HEXDUMP ROUTINE ADDRESS\n         BZ    CATEEXIT            B. IF ROUTINE NOT LOADED\n         DELETE EP=HEXDUMP         DELETE THE HEX DUMP FORMATTER\n\nCATEEXIT DS    0H\n         CLOSE (SYSIN,,SYSPRINT)\n         L     R15,CATRC\n         #STOP RC=(R15)            TERMINATE\n\n*---------------------------------------------------------------------*\n*        EXTRACTED FIELD DUMPPING ROUTINE                             *\n*---------------------------------------------------------------------*\nDUMPIT   DS    0H\n         STM   R0,R15,WRKSAVE      SAVE    ALL REGISTERS\n         ST    R2,WRKDUMPP+4       INSERT 1ST BYTE ADDRESS\n         BCTR  R3,0\n         AR    R3,R2\n         ST    R3,WRKDUMPP+8       INSERT LAST BYTE ADDRESS\n\n         XC    WRKDUMPP+12(4),WRKDUMPP+12\n         NI    WRKFLAG,255-WRK$NAME\n\nDUMP0100 DS    0H\n         LA    R1,WRKDUMPP         LOAD HEXDUMP ROUTINE PLIST ADDRESS\n         ICM   R15,15,WRKDUMP@     LOAD HEXDUMP ROUTINE ADDRESS\n         BZ    DUMPEXIT            B. IF ROUTINE NOT LOADED\n         BALR  R14,R15             FORMAT A LINE OF DATA INTO HEX\n\n         TM    WRKFLAG,WRK$NAME    CHECK IF 1ST LINE HAS BEEN DISPLAYED\n         BO    DUMP0110            B. IF YES\n         OI    WRKFLAG,WRK$NAME    REMEMBER 1ST LINE HAS BEEN DISPLAYED\n         MVC   WRKPRINT+1(8),0(R10)\n\nDUMP0110 DS    0H\n         PUT   SYSPRINT,WRKPRINT   PRINT CURRENT LINE\n         MVC   WRKPRINT,BLANKS\n         CLC   WRKDUMPP+4(4),WRKDUMPP+8\n         BNH   DUMP0100            B. IF MORE DATA TO BE DUMPED\n\nDUMPEXIT DS    0H\n         LM    R0,R15,WRKSAVE      RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*        WORK AREA AND CONSTANTS                                      *\n*---------------------------------------------------------------------*\n         #EXEC ,\n         LTORG ,\n\nCATRC    DC    F'0'\n\nBLANKS   DC    256C' '             LOTS OF BLANKS\nDCBEXIT  #DCBEXIT LRECL=133        DCB OPEN EXIT\nDCBEXIT@ DC    X'85',AL3(DCBEXIT)  DCB OPEN EXIT ADDRESS\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,                *\n               MACRF=GL,EODAD=CATE0900\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,                     *\n               MACRF=PM,EXLST=DCBEXIT@\n\nWRKACB@  DC    F'0'\nWRKAREA  DC    A(*-*)\nWRKAREAL DC    A(32767)\nWRKCTGFL DC    XL(CTGFLLEN)'00'\nWRKCTGPL DC    XL(CTGPLLEN+4*1)'00'\nWRKDBL1  DC    D'0'                DOUBLEWORD WORK AREA\nWRKDSNAM DC    CL44' '\nWRKDUMP@ DC    A(*-*)              HEXDUMP ROUTINE ADDRESS\nWRKDUMPP DC    A(*+4)              POINTER TO HEXDUMP PARAMETER LIST\n         DS    A               +4  STARTING ADDRESS OF DUMP STORAGE\n         DS    A               +8  LAST BYTE ADDRESS OF DUMP STORAGE\n         DS    A               +12 RELATIVE ADDRESS (OPTIONAL)\n         DS    X'40'           +16 DUMP OPTIONS (RELATIVE & 130 BYTES)\n*              X'80'               - PRINT ABSOLUTE STORAGE ADDRESS\n*              X'40'               - PRINT RELATIVE STORAGE ADDRESS\n*              X'20'               - PRINT 130 BYTES PER LINE (ON)\n*                                    PRINT  80 BYTES PER LINE (OFF)\n         DS    AL3             +17 OUTPUT BUFFER ADDRESS\nWRKFLAG  DC    X'00'              FLAG BYTE\nWRK$ACB@ EQU   BIT0               PARM=CATACB WAS SPECIFIED\nWRK$NAME EQU   BIT1               NAME HAS BEEN DISPLAYED\nWRKMSG01 DC    CL134'          - *** ERROR *** IGG0CLXX - R15=X\"#######*\n               #\" REASON=X\"####\"'\nWRKPRINT DS    CL256               OUTPUT BUFFER\nWRKSAVE  DC    18F'0'              SUBROUTINE SAVE AREA\nWRKTABLE DC    C'0123456789ABCDEF' TRANSLATION TABLE\n\n         #DSECTS CATLG,DCB\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATL": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x03\\x08\\x03\\x08\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:26", "lines": 776, "newlines": 776, "modlines": 0, "user": "SOURCE"}, "text": "CATL     TITLE 'CATL - CATALOG LIST UTILITY'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n***********************************************************************\n*                     *                                               *\n*   C A T L           *            CATALOG LIST UTILITY               *\n*                     *                                               *\n***********************                                               *\n*                                                                     *\n*   FUNCTION :        LIST CATALOGED DATASETS AND OPTIONALLY LIST     *\n*                     DCB | SPACE | VOLUME INFORMATION                *\n*                                                                     *\n*   SYNTAX:           CATL -                                          *\n*                         LEVEL(QUALIFIER) -                 (OPTIONAL)\n*                         DCB | SPACE | VOLUMES | HORIZONTAL (OPTIONAL)\n*                                                                     *\n*   REGISTER USAGE :   R0 - WORK REGISTER                             *\n*                      R1 - WORK REGISTER                             *\n*                      R2 - WORK REGISTER                             *\n*                      R3 - WORK REGISTER                             *\n*                      R4 - WORK REGISTER                             *\n*                      R5 - WORK REGISTER                             *\n*                      R6 - WORK REGISTER                             *\n*                      R7 - WORK REGISTER                             *\n*                      R8 - WORK REGISTER                             *\n*                      R9 - WORK REGISTER                             *\n*                     R10 - WORK REGISTER                             *\n*                     R11 - >>---> PDL                                *\n*                     R12 - BASE                                      *\n*                     R13 - >>---> WORK AREA                          *\n*                     R14 - RETURN ADDRESS                            *\n*                     R15 - RETURN CODE                               *\n*                                                                     *\n*   MACROS : #CTGPL   #DSECTS  #INSTACK #IOSRL   #MODE    #START      *\n*            #STARTWA #STOP    #STOPWA  CALLTSSR CAMLST   CATALOG     *\n*            #EXEC    FREEMAIN GETMAIN  IECSDSL1 IKJEFFMT IKJENDP     *\n*            IKJKEYWD          IKJNAME  IKJPARM  IKJPOSIT IKJSUBF     *\n*            IKJTSMSG LINK     LOCATE   #MSG     OBTAIN   PUTLINE     *\n*                                                                     *\n*   ROUTINES CALLED : IEFEB4UV IKJPARS  IKJEFF02 IKJEFF19             *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   HISTORY : #DD84123 - MAY  2,1984 - USE FORMAT2 CATALOG WORKAREA   *\n*             #DD99183 - JUL  2,1999 - CONVERT UNITNAME VIA IEFEB4UV  *\n*             #DD00033 - FEB  2,2000 - SUPPORT PDSE/HFS DATASETS      *\n*             #DD12062 - MAR  2,2012 - ADD EAV SUPPORT.               *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nCATL     #START BASE=R12,WKCSECT=CATLWORK,                             *\n               APARS=,COPY=YES,AMODE=24,                       #DD99183*\n               REG1=R2,USING=(PSA,0),                                  *\n               LEVEL=#V001R04                                  #DD12062\n\n         USING CPPL,R2\n         ST    R2,CATLCPPL         SAVE CPPL ADDRESS\n\n*--------------------------------------------------------------------*\n*        SET UP AN I/O SERVICE ROUTINE PARAMETER LIST                *\n*--------------------------------------------------------------------*\n\n         LA    R1,CATLIOPL         >>---> IOPL\n         USING IOPL,R1\n         MVC   IOPLUPT,CPPLUPT     INSERT ADDRESS OF UPT\n         MVC   IOPLECT,CPPLECT     INSERT ADDRESS OF ECT\n         MVC   IOPLECB,=A(CATLECB) INSERT ADDRESS OF ECB\n         DROP  R1\n\n         MVC   PUTLPARM(4),CPPLUPT   SAVE UPT ADDRESS\n         MVC   PUTLPARM+4(4),CPPLECT SAVE ECT ADDRESS\n         MVC   PUTLPARM+8(4),=A(CATLECB)\n\n*--------------------------------------------------------------------*\n*        SET UP IKJEFF02 (MESSAGE ROUTINE) PARAMETER LIST            *\n*--------------------------------------------------------------------*\n\n         LA    R0,MTCSECTP         >>---> MSG DESC SECTION\n         ST    R0,MTPLPTR\n         MVC   MTCPPLP,CATLCPPL    >>---> CPPL\n         MVC   MTECBP,=A(CATLECB)  >>---> COMMUNICATION ECB\n         OI    MTHIGH,B'10000000'  ON FOR STD LINKAGE\n         MVC   MTCSECTP,=A(MSGCSECT)\n         MVI   MTSW1,MTPUTLSW      PUTLINE MESSAGES\n         LA    R0,INSERT           >>---> INSERT AREA\n         STCM  R0,B'0111',MTADDR\n         MVI   MTLEN,44            SET INSERT LENGTH\n         MVC   INSERT,BLANKS\n\n*--------------------------------------------------------------------*\n*        SET UP A PARSE PARAMETER LIST (PPL)                         *\n*--------------------------------------------------------------------*\n\n         LA    R1,CATLPPL          >>---> PPL\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      INSERT ADDRESS OF UPT\n         MVC   PPLECT,CPPLECT      INSERT ADDRESS OF ECT\n         MVC   PPLCBUF,CPPLCBUF    INSERT ADDRESS OF CBUF\n         MVC   PPLECB,=A(CATLECB)  INSERT ADDRESS OF ECB\n         MVC   PPLANS,=A(CATLPDLP) INSERT ADDRESS OF ANSWER PLACE\n         MVC   PPLPCL,=A(PCL)      INSERT ADDRESS OF PCL\n         CALLTSSR EP=IKJPARS,MF=(E,(1))\n         DROP  R1\n         LTR   R15,R15             CHECK IF PARSE WAS SUCCESSFUL\n         BNZ   CATLERR1            IF NOT PROCESS ERROR\n         L     R11,CATLPDLP        >>---> PDL\n         USING IKJPARMD,R11\n\n*---------------------------------------------------------------------*\n*        SETUP THE LEVEL ACCORDINGLY     (PREFIX/LEVEL./'LEVEL')      *\n*---------------------------------------------------------------------*\n\n         MVC   DSNBUF,BLANKS       CLEAR THE DSNAME FIELD\n         CLI   LEVELKW+1,1         CHECK IF LEVEL(?) WAS SPECIFIED\n         BE    CATL0010\n         L     R1,CPPLUPT          >>---> UPT\n         USING UPT,R1\n         MVC   DSNBUF+1(7),UPTPREFX\n         SLR   R9,R9               CLEAR FOR INSERT\n         ICM   R9,B'0001',UPTPREFL INSERT PREFIX LENGTH\n         BZ    CATLERR2\n         B     CATL0020\n         DROP  R1\nCATL0010 DS    0H\n         L     R1,DSNPDE           >>---> DSNAME\n         LH    R9,DSNPDE+4         LOAD DSNAME LENGTH\n         #EXEC -R9,MVC,DSNBUF+1(*-*),0(R1)\n         LA    R9,1(,R9)           RESTORE LENGTH OF DSNAME\n         TM    DSNPDE+6,X'40'      CHECK IF LEVEL WAS ENTERED IN QUOTES\n         BO    CATL0030\nCATL0020 DS    0H\n         LA    R1,DSNBUF+1(R9)     >>---> END OF LEVEL\n         MVI   0(R1),C'.'          INSERT A PERIOD\n         LA    R9,1(,R9)           INCREMENT LENGTH OF DSNAME\nCATL0030 DS    0H\n         STC   R9,DSNBUF           SAVE LENGTH OF LEVEL\n\n*---------------------------------------------------------------------*\n*        LOCATE ALL CATALOG ENTRIES FOR THIS PREFIX                   *\n*---------------------------------------------------------------------*\n\n         GETMAIN VU,LA=WORKSIZE,A=WORKADDR\nCATL0040 DS    0H\n         LM    R2,R3,WORKADDR      LOAD WORKAREA ADDRESS & SIZE\n         XC    @CTGPL,@CTGPL\n         #CTGPL LISTCAT,           SETUP CATALOG PARAMETER LIST        *\n               CRI=DSNBUF,                                             *\n               WORK=((R2),(R3),FORMAT2),                       #DD84123*\n               OPTIONS=(NAME,GENLD,RCATN,SUPLT,AM0),                   *\n               MF=(E,@CTGPL)\n         CATALOG @CTGPL\n         LTR   R15,R15             CHECK CATALOG RETURN CODE\n         BNZ   CATLERR3            CHECK FOR RECOVERABLE ERROR\n\n*---------------------------------------------------------------------*\n*        CALCULATE THE NUMBER OF ENTRIES & PRINT THE TITLES           *\n*---------------------------------------------------------------------*\n\n         CLC   4(4,R2),=X'00000008'\n         BNE   CATL0050\n         XC    8(2,R2),8(R2)       CLEAR TOP HALF OF CVOL LENGTH\n         LA    R2,4(,R2)           >>---> CVOL WORK AREA\nCATL0050 DS    0H\n         L     R7,4(,R2)           LOAD AMOUNT USED IN WORKAREA\n         SLR   R6,R6               PREPARE FOR DIVIDE\n         LA    R5,8(,R2)           >>---> CATALOG NAME\n         MVC   INSERT,1(R5)        COPY CATALOG NAME TO INSERT AREA\n         D     R6,=F'45'           CALCULATE THE NUMBER OF DSNAMES\n         BCTR  R7,R0               SUBTRACT 1 FOR CATALOG NAME\n         ST    R7,ENTRIES          SAVE THE NUMBER OF ENTRIES\n         LTR   R7,R7               CHECK ENTRY COUNT\n         BNP   CATLER3C\n         CLI   KEYWORD1+1,4        CHECK FOR \"HORIZONTAL\"\n         BE    CATL0070\n         MVC   MTMSGID,=C'0004'    INSERT MESSAGE ID\n         CALLTSSR EP=IKJEFF02,     CALL MESSAGE ROUTER                 *\n               MF=(E,MTPARML)\n         MVC   PRINTLNE+4(44),MESSAGE1\n         MVC   PRINTLNE+49(31),MESSAGE2\n         CLI   KEYWORD1+1,1        CHECK FOR \"DCB\"\n         BE    CATL0060\n         MVC   PRINTLNE+49(31),MESSAGE3\n         CLI   KEYWORD1+1,2        CHECK FOR \"SPACE\"\n         BE    CATL0060\n         MVC   PRINTLNE+49(31),MESSAGE4\n         CLI   KEYWORD1+1,3        CHECK FOR \"VOLUMES\"\n         BNE   CATL0120\nCATL0060 DS    0H\n         LM    R2,R4,PUTLPARM      LOAD UPT/ECT/ECB ADDRESS\n         PUTLINE PARM=PUTLINEL,UPT=(R2),ECT=(R3),ECB=(R4),             *\n               OUTPUT=(PRINTLNE,TERM,SINGLE,DATA),                     *\n               MF=(E,IOPLADS)\n         B     CATL0120            SKIP SIDEWAYS PRINTING\n\n*---------------------------------------------------------------------*\n*        PRODUCE A \"HORIZONTAL\" CATALOG LIST                          *\n*---------------------------------------------------------------------*\n\nCATL0070 DS    0H\n         LA    R5,45(,R5)          >>---> PAST CATALOG NAME\nCATL0080 DS    0H\n         MVC   PRINTLNE+4(79),BLANKS\n         LA    R8,PRINTLNE+4       >>---> START OF MESSAGE AREA\n         LA    R10,PRINTLNE+4+79   >>---> END   OF MESSAGE AREA\nCATL0090 DS    0H\n         CLI   0(R5),C'0'          CHECK FOR CATALOG NAME ENTRY\n         BE    CATL0110            B. IF YES\n         LA    R1,45(R5)           >>---> END OF THE DSNAME\n         TRT   1(44,R5),TRTABLE    FIND THE END OF THE DSNAME\n         SLR   R2,R2               CLEAR FOR INSERT\n         IC    R2,DSNBUF           LOAD PREFIX LENGTH\n         LA    R3,1(R2,R5)         >>---> PAST DATASET NAME PREFIX\n         SR    R1,R3               CALCULATE LENGTH OF THE DSNAME\n         LA    R2,0(R1,R8)         >>---> WHERE DSNAME WILL END\n         CR    R2,R10              CHECK IF IT WILL OVERFLOW\n         BL    CATL0100\n         LM    R2,R4,PUTLPARM      LOAD UPT/ECT/ECB ADDRESS\n         PUTLINE PARM=PUTLINEL,UPT=(R2),ECT=(R3),ECB=(R4),             *\n               OUTPUT=(PRINTLNE,TERM,SINGLE,DATA),                     *\n               MF=(E,IOPLADS)\n         B     CATL0080            INSERT THE CURRENT DSNAME\nCATL0100 DS    0H\n         #EXEC -R1,MVC,0(*-*,R8),0(R3)\n         LA    R8,2(R1,R8)         >>---> NEXT DSN BUFFER\nCATL0110 DS    0H\n         LA    R5,45(,R5)          >>---> NEXT DATASET NAME\n         BCT   R7,CATL0090\n         LA    R1,PRINTLNE+4       >>---> START OF PRINT LINE\n         CR    R1,R8               CHECK IF ANYTHING IN THE LINE\n         BE    CATL0420\n         LM    R2,R4,PUTLPARM      LOAD UPT/ECT/ECB ADDRESS\n         PUTLINE PARM=PUTLINEL,UPT=(R2),ECT=(R3),ECB=(R4),             *\n               OUTPUT=(PRINTLNE,TERM,SINGLE,DATA),                     *\n               MF=(E,IOPLADS)\n         B     CATL0420\n\n*---------------------------------------------------------------------*\n*        FORMAT & PRINT THE INDIVIDUAL DATASET LINES                  *\n*---------------------------------------------------------------------*\n\nCATL0120 DS    0H\n         LA    R5,45(,R5)          >>---> NEXT DATASET NAME\n         MVC   PRINTLNE+4(44),1(R5)\n         MVC   PRINTLNE+49(31),BLANKS\n         MVC   DSNAME,1(R5)        SAVE THE DATASET NAME\n         CLI   0(R5),C'0'          CHECK FOR CATALOG NAME ENTRY\n         BNE   CATL0130            B. IF NOT\n         L     R1,ENTRIES\n         BCTR  R1,0                SUBTRACT 1 FROM ENTRY COUNT\n         ST    R1,ENTRIES\n         B     CATL0410\nCATL0130 DS    0H\n         CLI   KEYWORD2+1,1        CHECK FOR \"NOPREFIX\"\n         BNE   CATL0140\n         MVC   PRINTLNE+4(44),BLANKS\n         LA    R1,43               LOAD MAXIMUM DATASET LENGTH\n         SLR   R2,R2               CLEAR FOR INSERT\n         IC    R2,DSNBUF           LOAD PREFIX LENGTH\n         LA    R3,DSNAME           >>---> DATASET NAME\n         LA    R3,0(R2,R3)         >>---> PAST DATASET NAME PREFIX\n         SR    R1,R2               CALCULATE REMAINING LENGTH\n         #EXEC R1,MVC,PRINTLNE+4(*-*),0(R3)\n\n*---------------------------------------------------------------------*\n*        FORMAT THE \"DCB\" LINE                                        *\n*---------------------------------------------------------------------*\n\nCATL0140 DS    0H\n         CLI   KEYWORD1+1,1        CHECK FOR \"DCB\"\n         BNE   CATL0270\n         CLI   0(R5),CTGTGBS       CHECK FOR \"GDG BASE\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTCL        CHECK FOR \"CLUSTER\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTMCAT      CHECK FOR \"MASTER CATALOG\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTPGSP      CHECK FOR \"PAGE SPACE\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTUCAT      CHECK FOR \"USER CATALOG\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         LOCATE NAMEPL             GET CATALOG INFORMATION\n         LTR   R15,R15             CHECK LOCATE RETURN CODE\n         BNZ   CATL0400\n         MVC   VOLSER,WORKAREA+6   SAVE VOLSER\n         TM    WORKAREA+4,UCB3DACC CHECK FOR DIRECT ACCESS DEVICES\n         BO    CATL0150\n         MVC   MESSAGE9(6),VOLSER\n         MVC   PRINTLNE+49(31),MESSAGE9\n         B     CATL0400\nCATL0150 DS    0H\n         OBTAIN SEARCHPL,EADSCB=OK GET THE VTOC INFORMATION    #DD12062\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    CATL0160\n         BAL   R14,OBTAINFO        FORMAT OBTAIN ERROR MESSAGE\n         B     CATL0400\nCATL0160 DS    0H\n         MVC   PRINTLNE+50(3),=C'POE'                          #DD00033\n         TM    DS1SMSFG,DS1PDSE    CHECK IF DSN IS \"PDSE\"      #DD00033\n         BO    CATL0180                                        #DD00033\n         MVC   PRINTLNE+50(3),=C'HFS'                          #DD00033\n         TM    DS1SMSFG,DS1PDSEX   CHECK IF DSN IS \"HFS\"       #DD00033\n         BO    CATL0180                                        #DD00033\n         MVC   PRINTLNE+50(3),=C'PS '\n         TM    DS1DSORG,DS1DSGPS   CHECK IF DSN IS \"PS\"\n         BO    CATL0170\n         MVC   PRINTLNE+50(3),=C'PO '\n         TM    DS1DSORG,DS1DSGPO   CHECK IF DSN IS \"PO\"\n         BO    CATL0170\n         MVC   PRINTLNE+50(3),=C'DA '\n         TM    DS1DSORG,DS1DSGDA   CHECK IF DSN IS \"DA\"\n         BO    CATL0170\n         MVC   PRINTLNE+50(3),=C'IS '\n         TM    DS1DSORG,DS1DSGIS   CHECK IF DSN IS \"IS\"\n         BO    CATL0170\n         MVC   PRINTLNE+50(3),=C'VS '\n         TM    DS1DSORG+1,DS1ORGAM CHECK IF DSN IS \"AM\"\n         BO    CATL0170\n         MVC   PRINTLNE+50(3),=C'?? '\nCATL0170 DS    0H\n         TM    DS1DSORG,DS1DSGU    CHECK FOR UNMOVABLE DSORG\n         BNO   CATL0180\n         MVI   PRINTLNE+52,C'U'\nCATL0180 DS    0H\n         LA    R3,PRINTLNE+55      >>---> RECORD FORMAT SPACE\n         TM    DS1RECFM,X'C0'      CHECK FOR RECFM = U\n         BNO   CATL0190\n         MVI   0(R3),C'U'\n         LA    R3,1(,R3)           >>---> PAST \"U\"\n         B     CATL0220            CHECK FOR TRACK OVERFLOW\nCATL0190 DS    0H\n         TM    DS1RECFM,X'80'      CHECK FOR RECFM = F\n         BNO   CATL0200\n         MVI   0(R3),C'F'\n         LA    R3,1(,R3)           >>---> PAST \"F\"\n         B     CATL0210            CHECK FOR BLOCKING\nCATL0200 DS    0H\n         TM    DS1RECFM,X'40'      CHECK FOR RECFM = V\n         BNO   CATL0210\n         MVI   0(R3),C'V'\n         LA    R3,1(,R3)           >>---> PAST \"V\"\nCATL0210 DS    0H\n         TM    DS1RECFM,X'10'      CHECK IF DATASET IS BLOCKED\n         BNO   CATL0220\n         MVI   0(R3),C'B'\n         LA    R3,1(,R3)           >>---> PAST \"B\"\nCATL0220 DS    0H\n         TM    DS1RECFM,X'20'      CHECK FOR TRACK OVERFLOW\n         BNO   CATL0230\n         MVI   0(R3),C'T'\n         LA    R3,1(,R3)           >>---> PAST \"T\"\nCATL0230 DS    0H\n         TM    DS1RECFM,X'08'      CHECK FOR SPANNED OR STANDARD\n         BNO   CATL0240\n         MVI   0(R3),C'S'\n         LA    R3,1(,R3)           >>---> PAST \"S\"\nCATL0240 DS    0H\n         TM    DS1RECFM,X'04'      CHECK FOR ASA CNTL CHARS\n         BNO   CATL0250\n         MVI   0(R3),C'A'\n         LA    R3,1(,R3)           >>---> PAST \"A\"\nCATL0250 DS    0H\n         TM    DS1RECFM,X'02'      CHECK FOR MACHINE CNTL CHARS\n         BNO   CATL0260\n         MVI   0(R3),C'M'\nCATL0260 DS    0H\n         SLR   R0,R0\n         ICM   R0,B'0011',DS1LRECL LOAD RECORD LENGTH\n         CVD   R0,DBLWORD\n         MVC   PRINTLNE+60(6),=X'402020202120'\n         ED    PRINTLNE+60(6),DBLWORD+5\n         SLR   R0,R0\n         ICM   R0,B'0011',DS1BLKL  LOAD BLOCK SIZE\n         CVD   R0,DBLWORD\n         MVC   PRINTLNE+67(6),=X'402020202120'\n         ED    PRINTLNE+67(6),DBLWORD+5\n         MVC   FULLWORD(3),DS1EXPDT    SAVE THE EXPIRY DATE\n         L     R0,FULLWORD             LOAD THE EXPIRY DATE\n         SRL   R0,24                   SHIFT TO GET THE YEAR\n         CVD   R0,DBLWORD\n         UNPK  PRINTLNE+75(2),DBLWORD\n         OI    PRINTLNE+76,X'F0'   CONVERT SIGN BIT\n         L     R0,FULLWORD             LOAD THE EXPIRY DATE\n         SLL   R0,8                    SHIFT OFF THE YEAR\n         SRL   R0,16                   SHIFT BACK FOR DATE\n         CVD   R0,DBLWORD\n         UNPK  PRINTLNE+77(3),DBLWORD\n         OI    PRINTLNE+79,X'F0'   CONVERT SIGN BIT\n         B     CATL0400\n\n*---------------------------------------------------------------------*\n*        FORMAT THE \"SPACE\" LINE                                      *\n*---------------------------------------------------------------------*\n\nCATL0270 DS    0H\n         CLI   KEYWORD1+1,2        CHECK FOR \"SPACE\"\n         BNE   CATL0390\n         CLI   0(R5),CTGTGBS       CHECK FOR \"GDG BASE\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTCL        CHECK FOR \"CLUSTER\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTMCAT      CHECK FOR \"MASTER CATALOG\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTPGSP      CHECK FOR \"PAGE SPACE\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         CLI   0(R5),CTGTUCAT      CHECK FOR \"USER CATALOG\"\n         BE    CATL0400            - NO ACTUAL DATASET EXISTS\n         LOCATE NAMEPL             GET CATALOG INFORMATION\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   CATL0400\n         MVC   VOLSER,WORKAREA+6   SAVE VOLSER\n         TM    WORKAREA+4,UCB3DACC CHECK FOR DIRECT ACCESS DEVICES\n         BO    CATL0280\n         MVC   MESSAGE9(6),VOLSER\n         MVC   PRINTLNE+49(31),MESSAGE9\n         B     CATL0400\nCATL0280 DS    0H\n         OBTAIN VTOCPL,EADSCB=OK   GET VTOC INFORMATION        #DD12062\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    CATL0290\n         BAL   R14,OBTAINFO        FORMAT OBTAIN ERROR MESSAGE\n         B     CATL0400\nCATL0290 DS    0H\n         MVC   TRKCYL,DS4DEVSZ+2   SAVE # TRACKS PER CYL\n         OBTAIN SEARCHPL,EADSCB=OK GET FORMAT 1 DSCB           #DD12062\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    CATL0300\n         BAL   R14,OBTAINFO        FORMAT OBTAIN ERROR MESSAGE\n         B     CATL0400\nCATL0300 DS    0H\n         SLR   R3,R3\n         IC    R3,DS1NOEPV         LOAD THE NUMBER OF EXTENTS\n         CVD   R3,DBLWORD\n         MVC   PRINTLNE+62(4),=X'40202120'\n         ED    PRINTLNE+62(4),DBLWORD+6\n         MVC   PRINTLNE+74(4),=C'CYLS'\n         TM    DS1SCALO,X'C0'          CHECK FOR CYLINDER ALLOCATION\n         BO    CATL0310\n         MVC   PRINTLNE+74(4),=C'BLKS'\n         TM    DS1SCALO,X'40'          CHECK FOR BLOCK ALLOCATION\n         BO    CATL0310\n         MVC   PRINTLNE+74(4),=C'TRKS'\n         TM    DS1SCALO,X'80'          CHECK FOR TRACK ALLOCATION\n         BO    CATL0310\n         MVC   PRINTLNE+74(4),=C'ABST'\nCATL0310 DS    0H\n         SLR   R0,R0\n         ICM   R0,B'0111',DS1SCALO+1   LOAD SECONDARY ALLOCATION\n         CVD   R0,DBLWORD\n         MVC   PRINTLNE+67(6),=X'402020202120'\n         ED    PRINTLNE+67(6),DBLWORD+5\n         NI    DS1LSTAR,X'7F'      TURN OFF HIGH ORDER BIT\n         SLR   R3,R3\n         ICM   R3,B'0011',DS1LSTAR LOAD USED TRACKS\n         CLC   DS1LSTAR,=X'000000' CHECK IF ANY ARE USED\n         BE    CATL0320\n         LA    R3,1(,R3)\nCATL0320 DS    0H\n         CVD   R3,DBLWORD\n         MVC   PRINTLNE+54(6),=X'402020202120'\n         ED    PRINTLNE+54(6),DBLWORD+5\n         XC    FULLWORD,FULLWORD   CLEAR ALLOCATED TRK COUNTER\n         LA    R1,DS1EXT1          >>---> FIRST EXTENT\n         LA    R2,3                LOAD LOOP FACTOR\nCATL0330 DS    0H\n         BAL   R14,CONVCCHH        CONVERT + TOTAL TRACKS\n         LA    R1,10(,R1)          >>---> NEXT EXTENT\n         BCT   R2,CATL0330         LOOP 4 TIMES\n         CLC   DS1PTRDS,=X'0000000000' CHECK FOR A FMT2 OR FMT3 DSCB\n         BE    CATL0380\n         MVC   CCHHR,DS1PTRDS      SAVE DSCB POINTER\nCATL0340 DS    0H\n         OBTAIN SEEKPL,EADSCB=OK                               #DD12062\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    CATL0350\n         BAL   R14,OBTAINFO        FORMAT OBTAIN ERROR MESSAGE\n         B     CATL0400\nCATL0350 DS    0H\n         CLI   DS3FMTID,C'3'       CHECK FOR FORMAT 3 DSCB\n         BNE   CATL0340\n         LA    R1,DS3EXTNT         >>---> FOUR EXTENTS\n         LA    R2,4                LOAD LOOP FACTOR\nCATL0360 DS    0H\n         BAL   R14,CONVCCHH        CONVERT + TOTAL TRACKS\n         LA    R1,10(,R1)          >>---> NEXT EXTENT\n         BCT   R2,CATL0360         LOOP 4 TIMES\n         LA    R1,DS3ADEXT         >>---> NINE EXTENTS\n         LA    R2,9                LOAD LOOP FACTOR\nCATL0370 DS    0H\n         BAL   R14,CONVCCHH        CONVERT + TOTAL TRACKS\n         LA    R1,10(,R1)          >>---> NEXT EXTENT\n         BCT   R2,CATL0370         LOOP 9 TIMES\n         MVC   CCHHR,DS3PTRDS      SAVE DSCB POINTER\n         CLC   CCHHR,=X'0000000000' CHECK FOR MORE DSCBS\n         BNE   CATL0340\nCATL0380 DS    0H\n         L     R0,FULLWORD         LOAD ALLOCATED TRACK COUNT\n         CVD   R0,DBLWORD\n         MVC   PRINTLNE+48(6),=X'402020202120'\n         ED    PRINTLNE+48(6),DBLWORD+5\n         B     CATL0400\n\n*---------------------------------------------------------------------*\n*        FORMAT THE \"VOLUMES\" LINE                                    *\n*---------------------------------------------------------------------*\n\nCATL0390 DS    0H\n         CLI   KEYWORD1+1,3        CHECK FOR \"VOLUMES\"\n         BNE   CATL0400\n         LOCATE NAMEPL             GET THE CATALOG INFORMATION\n         LTR   R15,R15             CHECK LOCATE RETURN CODE\n         BNZ   CATL0400\n         MVC   PRINTLNE+49(6),WORKAREA+6\n         NI    WORKAREA+3,X'DF'    TURN OFF SHARED BIT IN THE DEVTYPE\n         MVC   UVDEVT,WORKAREA+2   COPY DEVICE TYPE            #DD99183\n         NI    UVDEVT+1,X'DF'      TURN OFF \"SHARED\" BIT       #DD99183\n         LA    R0,UVUNTAB                                      #DD99183\n         ST    R0,UVUNTAB@         SAVE UNIT TABLE ADDRESS     #DD99183\n         LA    R0,UVFLAGS                                      #DD99183\n         ST    R0,UVFLAGS@         SAVE FLAGS ADDRESS          #DD99183\n         OI    UVFLAGS@,X'80'      INDICATE END OF LIST        #DD99183\n         MVC   UVFLAGS,=X'2100'    INSERT REQUEST FLAGS        #DD99183\n         LA    R1,UVPLIST                                      #DD99183\n         LINK  EP=IEFEB4UV         CALL SERVICE ROUTINE        #DD99183\n         MVC   PRINTLNE+57(8),=CL8'????????'                   #DD99183\n         LTR   R15,R15             CHECK IF UNITNAME RETURNED  #DD99183\n         BNZ   CATL0400            B. IF NOT                   #DD99183\n         MVC   PRINTLNE+57(8),UVUNAME                          #DD99183\n\nCATL0400 DS    0H\n         LM    R2,R4,PUTLPARM      LOAD UPT/ECT/ECB ADDRESS\n         PUTLINE PARM=PUTLINEL,UPT=(R2),ECT=(R3),ECB=(R4),             *\n               OUTPUT=(PRINTLNE,TERM,SINGLE,DATA),                     *\n               MF=(E,IOPLADS)\nCATL0410 DS    0H\n         BCT   R7,CATL0120         PROCESS ALL ENTRIES IN THE BUFFER\n\n*---------------------------------------------------------------------*\n*        PRINT THE FOOTING TITLES                                     *\n*---------------------------------------------------------------------*\n\n         MVC   INSERT,BLANKS\n         MVC   INSERT(4),ENTRIES   COPY # OF DATASETS\n         OI    MTLEN,X'80'         SET HEX CONVERSION FLAG\n         MVC   MTMSGID,=C'0005'    INSERT MESSAGE ID\n         CALLTSSR EP=IKJEFF02,     CALL MESSAGE ROUTER                 *\n               MF=(E,MTPARML)\n\n*---------------------------------------------------------------------*\n*        FREE THE CATALOG WORK AREA IF ONE WAS OBTAINED               *\n*---------------------------------------------------------------------*\n\nCATL0420 DS    0H\n         LM    R3,R4,WORKADDR      LOAD WORKAREA ADDRESS & SIZE\n         LTR   R3,R3               CHECK IF A WORKAREA EXISTS\n         BZ    CATLEXIT\n         FREEMAIN RU,LV=(R4),A=(R3)\nCATLEXIT #STOP ,                   RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*        EXTENT SIZE CALCULATION SUBROUTINE                           *\n*---------------------------------------------------------------------*\n\nCONVCCHH DS    0H\n         CLC   2(4,R1),=F'0'       IS THERE A START CCHHR\n         BER   R14                 IF NOT RETURN TO CALLER\n         LH    R3,2(R1)            LOAD START CYL ADDRESS\n         MH    R3,TRKCYL           CONVERT TO TRKS\n         AH    R3,4(R1)            ADD ADDITIONAL TRKS\n         LH    R4,6(R1)            LOAD END CYL ADDRESS\n         MH    R4,TRKCYL           CONVERT TO TRKS\n         AH    R4,8(R1)            ADD ADDITIONAL TRKS\n         LA    R4,1(,R4)           ADD 1 FOR RELATIVE TRACK 0\n         SR    R4,R3               CALCULATE EXTENT SIZE\n         A     R4,FULLWORD         ADD ALREADY ACCUMULATED\n         ST    R4,FULLWORD         SAVE NEW TOTAL\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*        OBTAIN ERROR MESSAGE FORMATING SUBROUTINE                    *\n*---------------------------------------------------------------------*\n\nOBTAINFO DS    0F\n         MVC   MESSAGE5(6),VOLSER\n         MVC   MESSAGE6+23(6),VOLSER\n         MVC   MESSAGE7+18(6),VOLSER\n         MVC   PRINTLNE+49(31),BLANKS\n         LA    R1,OBTABLE          >>---> MESSAGE TABLE\n         LA    R1,0(R15,R1)        >>---> SPECIFIC MESSAGE POINTER\n         ICM   R1,B'1111',0(R1)    >>---> SPECIFIC MESSAGE\n         BZR   R14                 IF NO MESSAGE RETURN TO CALLER\n         MVC   PRINTLNE+49(31),0(R1)\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*        IKJPARSE ERROR PROCESSING                                    *\n*---------------------------------------------------------------------*\n\nCATLERR1 DS    0H\n         LA    R1,JEFF19PL         >>---> PARAMETER LIST\n         LA    R0,4(,R1)           >>---> PARAMETERS\n         ST    R0,0(R1)            SAVE IN PARAMETER LIST\n         XC    4(44,R1),4(R1)      CLEAR REMAINDER OF PARAMETER LIST\n         ST    R15,8(R1)           SAVE RETURN CODE\n         MVI   17(R1),21           SET CALLER ID (PARSE ERROR)\n         MVC   20(4,R1),CATLCPPL   INSERT CPPL ADDRESS\n         LA    R0,CATLECB          >>---> ECB\n         ST    R0,24(R1)           SAVE ECB ADDRESS\n         LINK  EP=IKJEFF19         ISSUE PARSE ERROR MESSAGE\n         B     CATL0420\n\n*---------------------------------------------------------------------*\n*        NULL PREFIX ERROR PROCESSING                                 *\n*---------------------------------------------------------------------*\n\nCATLERR2 DS    0H\n         MVC   MTMSGID,=C'0002'    INSERT MESSAGE ID\n         CALLTSSR EP=IKJEFF02,     CALL MESSAGE ROUTER                 *\n               MF=(E,MTPARML)\n         B     CATL0420\n\n*---------------------------------------------------------------------*\n*        CATALOG ERROR PROCESSING                                     *\n*---------------------------------------------------------------------*\n\nCATLERR3 DS    0H\n         C     R15,=A(RCVLSZ)      CHECK IF \"WORKAREA\" IS TOO SMALL\n         BNE   CATLER3B\n         LM    R3,R4,WORKADDR      LOAD WORKAREA ADDRESS & SIZE\n         L     R2,4(,R3)           LOAD REQUIRED WORK SIZE\n         FREEMAIN RU,LV=(R4),A=(R3)\n         GETMAIN  RU,LV=(R2)       OBTAIN REQUIRED \"WORKAREA\" STORAGE\n         STM   R1,R2,WORKADDR      SAVE NEW \"WORKAREA\" ADDRESS & SIZE\n         B     CATL0040            BRANCH BACK TO REISSUE LISTCAT\nCATLER3B DS    0H\n         C     R15,=A(RCENT)       CHECK IF NO ENTRIES FOUND\n         BNE   CATLER3D\nCATLER3C DS    0H\n         MVC   MTMSGID,=C'0006'    INSERT MESSAGE ID\n         CALLTSSR EP=IKJEFF02,     CALL MESSAGE ROUTER                 *\n               MF=(E,MTPARML)\n         B     CATL0420\nCATLER3D DS    0H\n         ST    R15,INSERT\n         OI    MTLEN,X'80'         SET HEX CONVERSION FLAG\n         MVC   MTMSGID,=C'0003'    INSERT MESSAGE ID\n         CALLTSSR EP=IKJEFF02,     CALL MESSAGE ROUTER                 *\n               MF=(E,MTPARML)\n         B     CATL0420\n\n*---------------------------------------------------------------------*\n*        WORK AREA                                                    *\n*---------------------------------------------------------------------*\n\n         #STARTWA ,\n         IKJEFFMT MTDSECT=NO,MTNINST=2\n@CTGPL   DS    CL(CTGPLLEN)\nBLANKS   DC    CL80' '\nCATLCPPL DS    F                   @ CMD PROCESSOR PARM LIST\nCATLECB  DS    F                   ECB\nCATLIOPL DS    4F                  I/O PARAM LIST\nCATLPDLP DC    F'0'                PDL POINTER\nCATLPPL  DS    7F                  PARSE PARAMETER LIST\nCCHHR    DS    XL5                     CCHHR\nDBLWORD  DS    D\nDSNBUF   DS    CL45                DSNAME SAVE AREA\nDSNAME   DS    CL44                DATASET NAME\nENTRIES  DS    F\nFMT4DSN  DC    44X'04'             FORMAT4.DSCB NAME\nFULLWORD DS    F\nINSERT   DS    CL44                MESSAGE INSERT # 1\nIOPLADS  DS    4F\nJEFF19PL DS    12F                 DAIRFAIL PARAMETER LIST\nMESSAGE1 DC    CL44'- DATASET NAME -'\nMESSAGE2 DC    CL31'DSORG-RECFM-LRECL-BLKSIZE-EXPDT'\nMESSAGE3 DC    CL31'ALLOC--USED-EXTENTS-SECONDARY'\nMESSAGE4 DC    CL31'VOLSER DEVTYPE'\nMESSAGE5 DC    CL31'XXXXXX NOT MOUNTED'\nMESSAGE6 DC    CL31'FMT1 DSCB NOT FOUND ON XXXXXX'\nMESSAGE7 DC    CL31'I/O ERROR READING XXXXXX VTOC'\nMESSAGE8 DC    CL31'INVALID DSCB CHAIN POINTER'\nMESSAGE9 DC    CL31'XXXXXX IS NOT A DASD VOLUME'\nNAMEPL   CAMLST NAME,DSNAME,,WORKAREA\n\nUVPLIST  DS    0F                                              #DD99183\nUVUNTAB@ DS    A                   A(UNIT TABLE)               #DD99183\nUVFLAGS@ DS    A                   A(FLAGS)                    #DD99183\nUVUNTAB  DS    0XL16               UNIT TABLE                  #DD99183\nUVUNAME  DS    CL8                 RETURNED UNIT NAME          #DD99183\nUVDEVT   DS    XL4                 DEVICE TYPE                 #DD99183\nUVATTR@  DS    A                   A(ATTRIBUTE AREA)           #DD99183\nUVFLAGS  DS    XL2                 FLAGS                       #DD99183\n\nOBTABLE  DC    A(0)\n         DC    A(MESSAGE5)\n         DC    A(MESSAGE6)\n         DC    A(MESSAGE7)\n         DC    A(0)\n         DC    A(MESSAGE8)\nPRINTLNE #MSG  '                                                       *\n                                       ' - 4 BYTE HEADER & 79 BYTE MSG\nPUTLINEL PUTLINE MF=L\nPUTLPARM DS    3F                  >>---> UPT/ECT/ECB\nSEARCHPL CAMLST SEARCH,DSNAME,VOLSER,WORKAREA,EADSCB=OK        #DD12062\nSEEKPL   CAMLST SEEK,CCHHR,VOLSER,WORKAREA,EADSCB=OK           #DD12062\nTRKCYL   DS    H                   TRACKS PER CYLINDER\nTRTABLE  DC    XL256'00'           TRANSLATE TABLE\n         ORG   TRTABLE+C' '\n         DC    X'FF'               FIND A BLANK\n         ORG   ,\nVOLSER   DS    CL6\nVTOCPL   CAMLST SEARCH,FMT4DSN,VOLSER,WORKAREA,EADSCB=OK       #DD12062\nWORKADDR DS    D                   RETURNED TABLE ADDRESS & SIZE\nWORKAREA DS    0F,265C             LOCATE/OBTAIN WORKAREA\n         PRINT NOGEN\n         ORG   WORKAREA-L'DS1DSNAM\n         IECSDSL1 1                FORMAT 1 DSCB\n         ORG   WORKAREA\n         IECSDSL1 3                FORMAT 3 DSCB\n         ORG   WORKAREA\n         IECSDSL1 4                FORMAT 4 DSCB\n         ORG   ,\n         PRINT GEN\nWORKSIZE DC    F'53'               MINIMUM TABLE SIZE (45*1+8)\n         DC    F'45008'            MAXIMUM TABLE SIZE (45*100+8)\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*        COMMAND PARAMETERS                                           *\n*---------------------------------------------------------------------*\n\n         PRINT NOGEN\n\nPCL      IKJPARM\nLEVELKW  IKJKEYWD\n         IKJNAME 'L',SUBFLD=LEVELSUB,ALIAS='LEVEL'\nKEYWORD1 IKJKEYWD\n         IKJNAME 'DCB',                                                *\n               ALIAS=('DSORG','RECFM','LRECL','BLKSIZE','EXPDT')\n         IKJNAME 'SPACE',ALIAS='TRACKS'\n         IKJNAME 'VOLUMES',ALIAS='UNIT'\n         IKJNAME 'HORIZONTAL',ALIAS='SIDEWAYS'\nKEYWORD2 IKJKEYWD\n         IKJNAME 'NOPREFIX'\nLEVELSUB IKJSUBF\nDSNPDE   IKJPOSIT DSNAME,PROMPT='DATA SET NAME HIGH LEVEL QUALIFIER'\n         IKJENDP\n\n*---------------------------------------------------------------------*\n*        MESSAGES                                                     *\n*---------------------------------------------------------------------*\n\nMSGCSECT CSECT ,\n         IKJTSMSG ('CATL001I Unable to list catalog+'),0001\n         IKJTSMSG ('CATL002I No prefix in User Profile Table'),0002,   *\n               0001\n         IKJTSMSG ('CATL003I Superlocate failed.  Return code=',,),0003\n         IKJTSMSG ('CATL004I Entries from catalog ',,),0004\n         IKJTSMSG ('CATL005I Number of entries listed = ',,),0005\n         IKJTSMSG ('CATL006I No entries found'),0006\n         IKJTSMSG\n\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n\n         #DSECTS CATLG,CVT,DCB,EDT,JESCT,JFCB,TCB,TIOT,TSO,UCB,PSA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHECKVOL": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x01y\\x01y\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:26", "lines": 377, "newlines": 377, "modlines": 0, "user": "SOURCE"}, "text": "CHECKVOL TITLE 'CHECKVOL - DISPLAY OFFLINE VOLUME SERIAL NUMBER'\n***********************************************************************\n*                     *                                               *\n*   C H E C K V O L   *     DISPLAY OFFLINE VOLUMES SERIAL NUMBER     *\n*                     *                                               *\n***********************                                               *\n*                                                                     *\n*   FUNCTION :        DISPLAY OFFLINE VOLUME'S VOLUME SERIAL NUMBER   *\n*                                                                     *\n*   PARMS:            \"DEVICE ADDRESS\" / OPTIONAL \",WAIT\"             *\n*                                              OR \",WAIT=Y\"           *\n*                                                                     *\n*   EXIT CODE:         0  -  UCB/VOLSER SUCCESSFULLY DISPLAYED        *\n*                      8  -  INVALID PARAMETER SPECIFIED              *\n*                     12  -  NO PARAMERTER SPECIFIED                  *\n*                     16  -  OPERATOR REPLIED \"NO\" OR \"N..\"           *\n*                     20  -  SPECIFIED UCB DOES NOT EXIST             *\n*                     24  -  UCB IS NOT OFFLINE OR A DASD DEVICE      *\n*                     28  -  UCB IS NOT ACCESSABLE (BOXED)            *\n*                     32  -  I/O ERROR OR TIMEOUT READING LABEL       *\n*                                                                     *\n*   REGISTER USAGE :   R0 - WORK REGISTER                             *\n*                      R1 - WORK REGISTER                             *\n*                      R2 - WORK REGISTER                             *\n*                      R3 - INPUT PARAMETER ADDRESS                   *\n*                      R4 - WORK REGISTER                             *\n*                      R5 - WORK REGISTER                             *\n*                      R6 - VOLUME LABEL ADDRESS                      *\n*                      R7 - NOT USED                                  *\n*                      R8 - NOT USED                                  *\n*                      R9 - NOT USED                                  *\n*                     R10 - NOT USED                                  *\n*                     R11 - NOT USED                                  *\n*                     R12 - BASE REGISTER                             *\n*                     R13 - SAVE AREA BASE REGISTER                   *\n*                     R14 - RETURN ADDRESS                            *\n*                     R15 - RETURN CODE                               *\n*                                                                     *\n*   MACROS : #DSECTS  #SETRC   #START   #STARTWA #STOP    #STOPWA     *\n*            DOM      IECDSECT LINK     STIMER   WAIT     WTO         *\n*            WTOR                                                     *\n*                                                                     *\n*   ROUTINES CALLED : READVOL1                                        *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nCHECKVOL #START ,                  Start Routine                       *\n               AMODE=31,           Indicate 31 Bit Addressing Mode     *\n               BASE=(R12),         Define Base Register(s)             *\n               COPY=YES,                                               *\n               LOC=BELOW,          Indicate 24 Bit work Area           *\n               REG1=(R3),          Copy Input Parameter Address        *\n               RMODE=24,           Indicate 24 Bit Residency Mode      *\n               WKDSECT=CHKVWORK,   Define WorkArea Name                *\n               LEVEL=**TOOL**      Maintenance Level\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse The Parameter List                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         L     R3,0(,R3)           A(Parameter List)\n         SLR   R4,R4\n         ICM   R4,3,0(R3)          L(Parameter Text)\n         BZ    CHKER001            B. If No Parameter Specified\n         LA    R3,2(,R3)           A(Parameter Text)\n         LA    R1,0(R4,R3)         A(End Of Parameter Text)\n         #EXEC -R4,TRT,0(*-*,R3),TRTAB1\n         AHI   R4,1                Restore Length\n         SR    R1,R3               Calculate Operand Length\n         BNP   CHKER001            B. If No Device Specified\n         CHI   R1,4                Check For Maximum Length\n         BH    CHKER002            B. If Too Long\n         MVC   DEVNAME,=C'0000'    Initialize Device Name Field\n         LA    R5,DEVNAME+4        A(End Of Device Name Field)\n         SR    R5,R1               Back Up To Right Justify\n         #EXEC -R1,MVC,0(*-*,R5),0(R3)\n         AHI   R1,1                Restore Device Number Length\n         LA    R3,0(R1,R3)         Advance Past Device Name\n         SR    R4,R1               Calculate Remaining Length\n\n         TRT   DEVNAME,HEXTAB      Verify Device Address Is Valid\n         BNZ   CHKER002            B. If Not\n\n         MVC   WRKDBL2(4),DEVNAME  Copy Device Address\n         TR    WRKDBL2(4),TRTAB2   Convert To Hex Values\n         OI    WRKDBL2+3,X'F0'     Ensure Positive Sign\n         PACK  WRKDBL1(4),WRKDBL2(4)\n         L     R1,WRKDBL1          Load Converted Hex Value\n         SRL   R1,4                Shift Off Sign\n         STCM  R1,3,UCBSDEVN       Save Converted Value\n\n         CHI   R4,5                Check If \",WAIT\" Possible\n         BL    CHK00100            B. If Not\n         OC    0(5,R3),BLANKS      Ensure Upper Case\n         CLC   0(5,R3),=C',WAIT'   Check If \"WAIT\" Requested\n         BNE   CHK00100            B. If Not\n         OI    FLAGBYTE,$WAIT      Remember \"Wait\" Specified\n\n         LA    R3,5(,R3)           Advance Past \",WAIT\"\n         SHI   R4,5                Subtract length of \",WAIT\"\n         CHI   R4,2                Check If Any PARM Data Remaining\n         BL    CHK00100            B. If Not\n         CLI   0(R3),C'='          Check For \",WAIT=\"\n         BNE   CHK00100            B. If Not (Ignore Invalid Extras)\n         CLI   1(R3),C'Y'          Check For \",WAIT=Y\"\n         BE    CHK00100            B. If Yes\n         NI    FLAGBYTE,255-$WAIT  Assume \",Wait=N\" Specified\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate UCB For Specified DASD Device                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nCHK00100 DS    0H\n         XC    UCBSWORK,UCBSWORK\n         MODESET KEY=ZERO,MODE=SUP\n         UCBSCAN ADDRESS,          Call \"ADDRESS\" Service              *\n               DEVN=UCBSDEVN,      . Device Number                     *\n               DEVCLASS=DASD,      . Device Class                      *\n               DYNAMIC=YES,        . Include Dynamic UCBs              *\n               RANGE=ALL,          . Include 4-Digit Device Numbers    *\n               LOC=ANY,            . Include Above 16 Meg UCBs         *\n               NOPIN,              . Do Not Pin The UCB                *\n               UCBPTR=UCBSPTR,     . Address Of UCB Common Segment     *\n               WORKAREA=UCBSWORK,  . Required WorkArea                 *\n               MF=(E,UCBSLIST)\n         STM   R15,R0,RETREAS      Save Return/Reason Codes\n         MODESET KEY=NZERO,MODE=PROB\n         LM    R15,R0,RETREAS      Restore Return/Reason Codes\n         LTR   R15,R15             Check If UCBSCAN Was Successful\n         BNZ   CHKER003            B. If Not\n\n         L     R4,UCBSPTR          A(UCB)\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Call \"READVOL1\" To Read The Offline Volume's Label           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ST    R4,RVOLPARM+4       Save UCB Address\n         LA    R0,RVOLBUFF\n         ST    R0,RVOLPARM+8       Save Buffer Address\n         OI    RVOLPARM+8,X'80'    Indicate End Of Parameter List\n         LA    R1,RVOLPARM         A(\"READVOL1\" Parameter List)\n         L     R15,=V(READVOL1)\n         BALR  R14,R15             Call \"READVOL1\" To Read Label\n         LHI   R0,X'99'            Identify \"After\" READVOL1\n         STM   R15,R0,RETREAS      Save Return/Reason Codes\n         CL    R15,=F'20'          Check For Valid Return Code\n         BH    CHKER004            B. If Not\n\n         B     *+4(R15)            Branch According To Return Code\n         B     CHK00200            - 00 Successful\n         B     CHKER003            - 04 UCB Not Valid\n         EX    0,*                 - 08\n         EX    0,*                 - 12\n         B     CHKER006            - 16 Device Not Accessible\n         B     CHKER007            - 20 Can't Read Device\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Process Returned Label Information                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nCHK00200 DS    0H\n         LA    R6,RVOLBUFF         A(DASD Label Information)\n         USING DXLBL,R6\n         MVC   MSG001I1,DEVNAME    Insert Device Address\n         MVC   MSG001I2,VOLSERNO   Insert Volume Serial\n         DROP  R6\n         WTO   MF=(E,MSG001)\n         ST    R1,DOMID1           Save WTO Message Identifier\n\n         TM    FLAGBYTE,$WAIT      Check If \"WAIT\" Requested\n         BNO   CHK00600            B. If Not\n\nCHK00300 DS    0H\n         MVC   RESPONSE,BLANKS     Initialize Response Area\n         XC    ECB,ECB             Initialize ECB\n         LA    R2,MSG001A\n         WTOR  MF=(E,(R2))         Issue Message With Reply\n\n         WAIT  ECB=ECB             Wait For Operator To Reply\n         ICM   R1,15,DOMID2        Load Previous Error Message Id\n         BZ    CHK00400            B. If None\n         DOM   MSG=(1)             Delete Operator Message\n         XC    DOMID2,DOMID2\n\nCHK00400 DS    0H\n         OC    RESPONSE,BLANKS     Convert Reply To Upper Case\n         CLI   RESPONSE,C'Y'       Check If Operator Replied \"Y..\"\n         BE    CHK00700            B. If Yes\n         CLI   RESPONSE,C'N'       Check If Operator Replied \"N..\"\n         BE    CHK00500            B. If Yes\n         MVC   MSG001B1,RESPONSE   Insert Response Into Message\n         LA    R2,MSG001B          A(Error Message)\n         WTO   MF=(E,(R2))         Issue Error Message\n         ST    R1,DOMID2           Save Message Identifier\n         B     CHK00300            Re-Prompt Operator\n\nCHK00500 DS    0H\n         #SETRC 16                 Set Return Code\n         B     CHK00700\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Wait For 30 Seconds Before Terminating                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nCHK00600 DS    0H\n         STIMER WAIT,DINTVL=SECONDS\n\nCHK00700 DS    0H\n         DOM   MSG=DOMID1          Delete Operator Message\n         B     TERMINAT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Process Error Conditions                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nCHKER001 DS    0H\n         WTO   TEXT=ERR001,ROUTCDE=(1)\n         #SETRC 12                 Set Return Code\n         B     TERMINAT\n\nCHKER002 DS    0H\n         WTO   TEXT=ERR002,ROUTCDE=(1)\n         #SETRC 8                  Set Return Code\n         B     TERMINAT\n\nCHKER003 DS    0H\n         MVC   ERR003I,DEVNAME     Insert Device Number\n         WTO   TEXT=ERR003,ROUTCDE=(1)\n         #SETRC 20                 Set Return Code\n         B     TERMINAT\n         UNPK  ERR004I1(5),RETREAS(3)\n         UNPK  ERR004I1+4(5),RETREAS+2(3)\n         MVI   ERR004I1+8,C' '\n         TR    ERR004I1,=C'0123456789ABCDEF'-C'0'\n         UNPK  ERR004I2(5),RETREAS+4(3)\n         UNPK  ERR004I2+4(5),RETREAS+6(3)\n         MVI   ERR004I2+8,C' '\n         TR    ERR004I2,=C'0123456789ABCDEF'-C'0'\n         WTO   TEXT=ERR004,ROUTCDE=(1)\n         B     TERMINAT\n\nCHKER004 DS    0H\n         EX    0,*                 Abend S0C3\n\nCHKER006 DS    0H\n         MVC   ERR006I,DEVNAME     Insert Device Number\n         WTO   TEXT=ERR006,ROUTCDE=(1)\n         #SETRC 28                 Set Return Code\n         B     TERMINAT\n\nCHKER007 DS    0H\n         MVC   ERR007I,DEVNAME     Insert Device Number\n         WTO   TEXT=ERR007,ROUTCDE=(1)\n         #SETRC 32                 Set Return Code\n         B     TERMINAT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nTERMINAT #STOP ,                   TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        MESSAGE AREA                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nMSG001   WTO   ('*-------------------------------------------*',D),    *\n               ('*    UNIT ____ HAS VOLUME SERIAL ______     *',D),    *\n               ('*-------------------------------------------*',DE),   *\n               ROUTCDE=1,DESC=(2),MF=L\nMSG001I1 EQU   MSG001+4+67,4       Insert Address/Length\nMSG001I2 EQU   MSG001+4+90,6       Insert Address/Length\nMSG001A  WTOR  'CKV001A REPLY \"YES\" TO CONTINUE, OR \"NO\" TO ABORT',    *\n               RESPONSE,3,ECB,DESC=(2),ROUTCDE=(1),MF=L\nMSG001B  WTO   'CKV001I REPLY ___ IS INVALID - REPLY \"YES\" OR \"NO\"',   *\n               DESC=(2),ROUTCDE=(1),MF=L\nMSG001B1 EQU   MSG001B+4+14,3      Insert Address/Length\n\nERR001   DC    AL2(L'ERR001T)\nERR001T  DC    C'CKV001E NO PARM= SPECIFIED'\n\nERR002   DC    AL2(L'ERR002T)\nERR002T  DC    C'CKV002E INVALID PARM= SPECIFIED'\n\nERR003   DC    AL2(L'ERR003T)\nERR003T  DC    C'CKV003E UNIT ____ IS NOT AN OFFLINE DASD DEVICE'\nERR003I  EQU   ERR003T+13,4        Insert Address/Length\n\nERR004   DC    AL2(L'ERR004T)\nERR004T  DC    C'        RETURN CODE:________ Reason Code:________ '\nERR004I1 EQU   ERR004T+20,8        Insert Address/Length\nERR004I2 EQU   ERR004T+41,8        Insert Address/Length\n\nERR006   DC    AL2(L'ERR006T)\nERR006T  DC    C'CKV006E UNIT ____ IS NOT ACCESSIBLE'\nERR006I  EQU   ERR006T+13,4        Insert Address/Length\n\nERR007   DC    AL2(L'ERR007T)\nERR007T  DC    C'CKV007E CAN NOT READ LABEL ON UNIT ____ '\nERR007I  EQU   ERR007T+35,4        Insert Address/Length\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS & WORK AREA                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nBLANKS   DC    256C' '             Lots Of Blanks\nECB      DC    F'0'                WTOR ECB\nRESPONSE DC    CL3' '              WTOR Reply Area\nSECONDS  DC    C'00003000'         \"WAIT\" For 30 Seconds\nTRTAB1   DC    256X'00'            Find Delimeter\n         ORG   TRTAB1+C','\n         DC    C','\n         ORG   ,\nTRTAB2   DC    256X'00'            Convert Bytes from Char to Hex\n         ORG   TRTAB2+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   TRTAB2+C'0'\n         DC    X'00010203040506070809'\n         ORG   ,\nHEXTAB   DC    256X'FF'            Find Invalid HEX Characters\n         ORG   HEXTAB+C'A'\n         DC    6X'00'              A-F\n         ORG   HEXTAB+C'0'\n         DC    10X'00'             0-9\n         ORG   ,\n\n         #STARTWA ,\n         UCBSCAN MF=(L,UCBSLIST)   UCBSCAN Parameter List\nWRKDBL1  DS    D\nWRKDBL2  DS    D\n\nRETREAS  DS    2F                  Return/Reason Codes\n\nDEVNAME  DS    CL4,C\nDOMID1   DS    F\nDOMID2   DS    F\nFLAGBYTE DS    X                   Flag Byte\n$WAIT    EQU   BIT0                \"WAIT\" Requested\nUCBSDEVN DS    XL2                 UCBSCAN Device Number\nUCBSWORK DS    XL100               UCBSCAN WorkArea\nUCBSPTR  DS    A                   UCBSCAN UCB Address\nUCBSPTKN DS    CL8                 UCBSCAN Pin Token\nRVOLBUFF DS    CL80                \"READVOL1\" Output Buffer\nRVOLPARM DS    0F                  \"READVOL1\" Parameter List\n         DS    A                   - Unused\n         DS    A                   - UCB Address\n         DS    A                   - 80 Byte Label Buffer Address\n         #STOPWA ,\n\n         IECDSECT ,                O/C/EOV WorkArea (Volume Label Map)\n\n         #DSECTS CVT,UCB\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "D2BLS": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\t\\xe9\\t\\xe9\\t\\xe9\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 2537, "newlines": 2537, "modlines": 2537, "user": "SOURCE"}, "text": "D2BLS    TITLE '- D2BLS - Build IPCS Format Model from DSECT listing'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT To BLS... statements (IPCS Format Model)               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Note: OA45131 adds > 8 character PREFIX= value and           *\n*                      also adds \"LAST8\" keyword.                     *\n*                      With this in mind, this tool will always       *\n*                      use \"LAST8\" if the remaining label length      *\n*                      is longer than 8 bytes.                        *\n*                      This APAR also adds \"LABEL=\" to specify a      *\n*                      totally different label for the field.         *\n*                      Code for this will come later.                 *\n*                                                                     *\n*                      Nicholas R. (Nick) Jones,                      *\n*                      z/OS MVS BCP Development - IPCS, Service Aids  *\n*                      Added the above and I appreciate his help      *\n*                      in understanding these concepts.               *\n*                      I also thank him for listening to my thoughts  *\n*                      and making them a reality which others can     *\n*                      use to make better format models.              *\n*                                                                     *\n*                                                                     *\n*        To Create a control block mapping for IPCS:                  *\n*                                                                     *\n*        EXEC PGM=D2BLS,PARM= ...                                     *\n*             ACROLBL=      - Control Block Acronym Label             *\n*             ACRONYM=      - Control Block Acronym                   *\n*             BASELBL=      - Control Block Base Label                *\n*             CBLEN=        - Control Block Length                    *\n*             CSECT         - Define Mapping As A CSECT               *\n*                           ... Implies \"END\"                         *\n*             DECODE=       - Decode EQU Labels                       *\n*             END           - Finish Mapping With an END              *\n*             NOEND         - Do Not Finish with \"END\"                *\n*             HEADER=       - Mapping Header Label                    *\n*             LABEL=        - Unique Sub-Label Prefix                 *\n*             LAST8         - NAME= last 8 bytes of label             *\n*             MAINTLV=      - Mapping Maintenance Level               *\n*             NAME=         - Mapping Name                            *\n*             OFFSETS=      - OFFSETS=PRINT | NOPRINT                 *\n*             PREFIX=       - Label Prefix String                     *\n*             PRINT=        - PRINT=GEN | NOGEN                       *\n*             SHEADER=      - Define Model Starting Text              *\n*             SFOOTER=      - Define Model Trailing Text              *\n*             START=        - Define Starting DSECT Label             *\n*             EXIT=         - Symbol Exit Routine.                    *\n*                             (See EXITPARM for Parameter List)       *\n*                                                                     *\n*        D2BUSERX is automatically called if it is LINKED with        *\n*        this module.  See EXITPARM for the parameters that are       *\n*        passed to the exit.                                          *\n*        A NON-Zero return code indicates that the DSECTMAP entry     *\n*        is to be ignored.                                            *\n*        Any field (execpt DSECTNXT) can be altered to influence the  *\n*        statement that will be produced.  DSECTFL2 is especially     *\n*        useful for adding options.                                   *\n*        EXITTRA@/EXITTRAR can be used to produce SYSTRACE output.    *\n*        EXITPUN@/EXITPUNR can be used to produce SYSPUNCH output.    *\n*        I've found EXITPUN@/EXITPUNR useful for adding new records   *\n*        to the PUNCH output file.                                    *\n*                                                                     *\n*        As the combination of these PARMS could exceed the current   *\n*        maximum length of a PARM= field, they may also be specified  *\n*        in a SYSIN data set.  The syntax of SYSIN is similar to      *\n*        the PARM field whereas it is a continuous string of keywords *\n*        separated by commas.  SHEADER & SFOOTER can be enclosed in   *\n*        quotes if they contain blanks.                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Below are the current BLSQMDEF/BLSQMFLD macro keywords.      *\n*        This program does not use them all.                          *\n*        As this tool grows it may use more options in the future.    *\n*                                                                     *\n*                                                                     *\n*        BLSQMDEF                                                     *\n*              BASELBL=                                               *\n*              CBLEN=                                                 *\n*              MAINTLV=      (Julian Date)                            *\n*              ACRONYM=                                               *\n*              ACROLEN=                                               *\n*              ACROLBL=                                               *\n*              ACROFF=                                                *\n*              PREFIX=       (Always specify PREFIX=0)                *\n*              OFFSETS=PRINT | NOPRINT                                *\n*              STRTCOL=      (Not Used)                               *\n*              LBLSPC=                                                *\n*              HEADER=                                                *\n*              VIEWMATCH=                                             *\n*                                                                     *\n*        BLSQMFLD                                                     *\n*              NAME=                                                  *\n*                 SHDR=                                               *\n*                 OFF=                                                *\n*                 LEN=          (If LEN=0 ignore this field)          *\n*                 VIEW=                                               *\n*                 ARRAY=                                              *\n*                 DTYPE=HEX | EBCDIC | ANY | QANY | ASCII             *\n*                 DECODE                                              *\n*                 INVERT                                              *\n*                 ATTACH                                              *\n*                 IMBED                                               *\n*                 STACK                                               *\n*                 CALLCBF                                             *\n*                 NEWLINE                                             *\n*                 NOLABEL                                             *\n*                 CALLRTN                                             *\n*                 LABEL=                                              *\n*                 LAST8                                               *\n*                 PREFIX=                                             *\n*                 NOSPLIT                                             *\n*                 NUMDEC                                              *\n*                 NOCOLNM                                             *\n*                 NOROWNM                                             *\n*                 STRTCOL=                                            *\n*                 COLNUM=                                             *\n*                 COLSEP=                                             *\n*                 ITEMSEP=                                            *\n*                 ORDER=                                              *\n*                 HEXONLY                                             *\n*                 MODELNAME                                           *\n*                 MSGID                                               *\n*                 SRCNDX=                                             *\n*                                                                     *\n*        BLSQMDEF END                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        History:                                                     *\n*              #DD14109 - Version 1 Release 1 - Creation Date         *\n*              #DD15243 - Add Installation User Exit Calls            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         DCLSW $ACROLBL,     PARM= ACROLBL=                            *\n               $ACRONYM,           ACRONYM=                            *\n               $BASELBL,           BASELBL=                            *\n               $CBLEN,             CBLEN=                              *\n               $CSECT,             CSECT                               *\n               $DECODE,            DECODE=                             *\n               $END,               END                                 *\n               $HEADER,            HEADER=                             *\n               $LAST8,             LAST8                               *\n               $LABEL,             LABEL=                              *\n               $MAINTLV,           MAINTLV=                            *\n               $NAME,              NAME=                               *\n               $OFFSETS,           OFFSETS=                            *\n               $PREFIX,            PREFIX=                             *\n               $PRINT,             PRINT=                              *\n               $SHEADER,           SHEADER=                            *\n               $SFOOTER,           SFOOTER=                            *\n               $START,             START=                              *\n               $NO_RSV,            NO_RSV                              *\n               $PTF,               PTF=                                *\n               $TRACE,       SYSTRACE DD statement exists              *\n               $PARM,        PARM= Simulated from SYSIN                *\n               MF=D\n\nD2BLS    #START ,                  Start Procedure                     *\n               AMODE=31,           Execute In 31-Bit AMode             *\n               RMODE=24,           Execute In 24-Bit RMode (GET/PUT)   *\n               BASE=RELATIVE,      Use Relative Addressing             *\n               CONSTANT=R12,       Constants Base Register(s)          *\n               WKDSECT=D2BWORK,    Define WorkArea Name                *\n               LOC=BELOW,          Indicate 24-Bit WorkArea            *\n               STORAGE=YES,        Obtain WorkArea With STORAGE Macro  *\n               #REGS=BOTH,         Define Standard & AR Registers      *\n               LEVEL=V01R002       Maintenance Level\n         USING PSA,0\n\n*---------------------------------------------------------------------*\n*        Read SYSIN If PARM= was not specified                        *\n*---------------------------------------------------------------------*\n         ST    R1,WRKPARM@         A(Input Paramters)\n         #ICALL CheckParm          Read SYSIN If PARM= Not Specified\n         #SETRC (R15)\n         LTR   R15,R15             Check If OPEN Was Successful\n         JNZ   BLSQEXIT            B. If Not\n\n*---------------------------------------------------------------------*\n*        Parse Input Parameter List                                   *\n*---------------------------------------------------------------------*\n         #ICALL ParseParm          Parse Input Parameter List\n         #SETRC (R15)\n         LTR   R15,R15             Check If Parse Was Successful\n         JNZ   BLSQEXIT            B. If Not\n\n*---------------------------------------------------------------------*\n*        Open the Input & Output Files & Inhale Assembler Output File *\n*---------------------------------------------------------------------*\n         #ICALL OpenFiles          Open Input & OUTPUT Files\n         #SETRC (R15)\n         LTR   R15,R15             Check If OPEN Was Successful\n         JNZ   BLSQEXIT            B. If Not\n\n         #ICALL LoadASM            Read Entire Assembler Output\n\n*---------------------------------------------------------------------*\n*        Find & Save All the DSECT Information                        *\n*---------------------------------------------------------------------*\n         #ICALL FindDsect          Find The Specified DSECT Label\n         #SETRC (R15)\n\n         #ICALL DumpDsect          Dump The DSECT Sequentially\n\n*---------------------------------------------------------------------*\n*        Generate BLSQMDEF/BLSQMFLD Statements                        *\n*---------------------------------------------------------------------*\n         #ICALL BuildBLS           Build & Print The IPCS Statements\n         #SETRC (R15)\n\n*---------------------------------------------------------------------*\n*        TERMINATE                                                    *\n*---------------------------------------------------------------------*\nBLSQEXIT DS    0H\n         #ICALL CloseFiles         Close Any Currently Open Files\n         #STOP ,                   Return To Caller\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build Simulated PARM= From SYSIN If No Real PARM=            *\n*                                                                     *\n*---------------------------------------------------------------------*\nCheckParm #IPROC ,\n         ICM   R1,15,WRKPARM@      A(Input Parameters)\n         JZ    Chec0100            B. If Called With No PARM\n         ICM   R1,15,0(R1)         A(Parameter List)\n         LA    R1,0(,R1)           Clear High Order Bit\n         LTR   R1,R1\n         JZ    Chec0100            B. If No PARM= Specified\n         SLR   R2,R2\n         ICM   R2,3,0(R1)          Check Length Of PARM=\n         JNZ   ChecRC00            B. If Specified\n\nChec0100 DS    0H\n         STORAGE OBTAIN,LENGTH=4096,LOC=ANY,SP=1,CHECKZERO=YES\n         ST    R1,WRKPARMS         Save Simulated PARM=\n         XC    0(2,R1),0(R1)       Zero PARM= Length\n         #BLANK 2(,R1),LEN=4094    Blank The PARM= Buffer\n         SET   $PARM               Indicate PARM= Is Simulated\n         LA    R0,WRKPARMS\n         ST    R0,WRKPARM@         Simulate PARM=\n\n         OPEN  (SYSIN,(INPUT))     Open Input\n         TM    DCBOFLGS-IHADCB+SYSIN,DCBOFOPN\n         JNO   ChecRC08            B. If \"SYSIN\" Did Not Open\n\n         L     R5,WRKPARMS         A(PARM= Buffer)\n         AHI   R5,2                A(Start Of PARM= Text Area)\n         ST    R5,WRKPARMT         Save PARM= Text Starting Address\n\n*        Read SYSIN And String Together Simulating PARM=\nChec0200 DS    0H\n         GET   SYSIN               Read A Record From SYSIN\n         CLI   0(R1),C'*'          Check For Comment Statement\n         JE    Chec0200            B. If Yes (Ignore)\n         CLC   0(72,R1),BLANKS     Check For Blank Line\n         JE    Chec0200            B. If Yes\n         MVC   0(72,R5),0(R1)      Save Input Record\n\n         AHI   R5,71               A(End Of New Record)\nChec0300 DS    0H\n         CL    R5,WRKPARMT         Back Up To The Beginning?\n         JE    Chec0200            B. If Yes (Keep Reading)\n         CLI   0(R5),C' '          Check For Last Non-Blank\n         JNE   Chec0400            B. If End Was Found\n         BRCT  R5,Chec0300         Back Up And Keep Looking\n\nChec0400 DS    0H\n         AHI   R5,1                Point Past Input Data\n         J     Chec0200            Keep Reading Till End-Of-File\n\nChec0500 DS    0H\n         L     R1,WRKPARMS         A(PARM= Buffer)\n         LR    R2,R1\n         AHI   R2,2                A(Start Of PARM= Text Area)\n         SR    R5,R2               Calculate Length\n         STH   R5,0(,R1)           Save PARM= Text Length\n\nChecRC00 DS    0H\n         LHI   R15,0               Set Return Code\n         J     CheckXit\n\nChecRC8E DS    0H\n         MVC   WrkTemp(ErrMsg07L),ErrMsg07\n         WTO   TEXT=WrkTemp\n\nChecRC08 DS    0H\n         LHI   R15,8               Set Return Code\n\nCheckXit #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build And Output BLSQMDEF/BLSQMFLD Statements                *\n*                                                                     *\n*---------------------------------------------------------------------*\n*  Syntax:\n*\n*        PUSH PRINT\n*        PRINT NOGEN\n*_______ DS    0H\n* or\n*_______ CSECT ,\n*        BLSQMDEF BASELBL=.........1.........2.........3.........4.....\n*              ....5.........6....,\n*              CBLEN=X'_____',PREFIX=0,\n*              HEADER=________,\n*              ACROFF=______,ACROLEN=_____,OFFSETS=NOPRINT,\n*              ACROLBL=.........1.........2.........3.........4........\n*              .5.........6....,ACRONYM=________,\n*              MAINTLV=________\n*        BLSQMFLD NAME=.........1.........2.........3.........4........\n*              .5.........6....,NEWLINE,LABEL=________,\n*              DTYPE=________,VIEW=________,\n*              OFF=X'______',LEN=_____\n*        BLSQMFLD NAME=________,OFF=X'______',LEN=_,VIEW=X'0280',DECODE\n*        BLSQMDEF END\n*_______ BLSQSHDR '.........1.........2.........3.........4.........5..\n*              .......6.........7'\n*        POP  PRINT\n*        END  ,\n*\n*---------------------------------------------------------------------*\nBuildBLS #IPROC ,\n         ICM   R4,15,WrkDSECT@     A(1st DSECT Entry)\n         JZ    BuildXit            B. If Not Built\n         ST    R4,WrkDSCUR@\n         USING DSECTMAP,R4\n         MVC   WRKPUNCH,BLANKS\n\n         GOIF  $PRINT,OFF=Buil0100 B. If PRINT= Not Specified\n         MVC   WRKPUNCH+9(11),=C'PUSH  PRINT'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         MVC   WRKPUNCH+9(5),=C'PRINT'\n         MVC   WRKPUNCH+15(8),WPRINT\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil0100 DS    0H\n         GOIF  $NAME,OFF=Buil0200\n         MVC   WRKPUNCH(8),WRKNAME\nBuil0200 DS    0H\n         MVC   WRKPUNCH+9(8),=C'DS    0D'\n         GOIF  $CSECT,OFF=Buil0300\n         MVC   WRKPUNCH+9(8),=C'CSECT , '\nBuil0300 DS    0H\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         MVC   WRKPUNCH+9(17),=C'BLSQMDEF BASELBL='\n         MVC   WRKPUNCH+26(45),DSECTLAB\n         CLI   DSECTLAB+44,C' '    Check For Really Long Label\n         JNE   Buil0400            B. If Yes\n         TRT   WRKPUNCH+26(80),BLANKTAB\n         MVI   0(R1),C','\nBuil0400 DS    0H\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         CLI   DSECTLAB+44,C' '    Check For Really Long Label\n         JE    Buil0500            B. If Not (No Second Stmt. Required)\n         MVC   WRKPUNCH+15(19),DSECTLAB+45\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         MVI   0(R1),C','\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil0500 DS    0H\n         MVC   WRKPUNCH+15(8),=C'CBLEN=X'''\n         MVC   WRKPUNCH+23(5),DSECTL\n         GOIF  $CBLEN,OFF=Buil0600\n         MVC   WRKPUNCH+23(5),WRKCBLEN+1\nBuil0600 DS    0H\n         MVC   WRKPUNCH+28(11),=C''',PREFIX=0,'\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         GOIF  $HEADER,OFF=Buil0700\n         MVC   WRKPUNCH+15(7),=C'HEADER='\n         MVC   WRKPUNCH+22(8),WHEADER\n         TRT   WRKPUNCH+22(80),BLANKTAB\n         MVI   0(R1),C','\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil0700 DS    0H\n         #ICALL FindACROLBL        Find Acronym Label\n         LTR   R15,R15             Check If Acronym Found\n         JNZ   Buil1100            B. If Not\n\n         MVC   WRKPUNCH+15(7),=C'ACROFF='\n         MVC   WRKPUNCH+22(6),WACROFF\n         MVC   WRKPUNCH+28(9),=C',ACROLEN='\n         MVC   WRKPUNCH+37(5),WACROLEN\n         MVI   WRKPUNCH+42,C','\n         GOIF  $OFFSETS,OFF=Buil0800\n         CLC   WRKOFFS,=CL7'PRINT'\n         JE    Buil0800            B. If Set To Default\n         MVC   WRKPUNCH+43(8),=C'OFFSETS='\n         MVC   WRKPUNCH+51(7),WRKOFFS\n         TRT   WRKPUNCH+51(80),BLANKTAB\n         MVI   0(R1),C','\nBuil0800 DS    0H\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         MVC   WRKPUNCH+15(8),=C'ACROLBL='\n         MVC   WRKPUNCH+23(48),WACROLBL\n         CLI   WACROLBL+47,C' '    Check For Really Long Label\n         JNE   Buil0900            B. If Yes\n         TRT   WRKPUNCH+23(80),BLANKTAB\n         MVI   0(R1),C','\n         AHI   R1,1                A(End Of ACROLBL=)\n         LA    R2,WRKPUNCH+70      A(End Of Current Line)\n         SR    R2,R1               Calculate Remaining Length\n         CHI   R2,17               Check If Room For ACRONYM=\n         JL    Buil0900            B. If Not\n         MVC   0(8,R1),=C'ACRONYM='\n         MVC   8(L'WACRONYM,R1),WACRONYM\n         TRT   8(L'WACRONYM+1,R1),BLANKTAB\n         MVI   0(R1),C','\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         J     Buil1100\n\nBuil0900 DS    0H\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         CLI   WACROLBL+47,C' '    Check For Really Long Label\n         JE    Buil1000            B. If Not (No Second Stmt. Required)\n         MVC   WRKPUNCH+15(16),WACROLBL+48\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         MVI   0(R1),C','\nBuil1000 DS    0H\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         MVC   0(8,R1),=C'ACRONYM='\n         MVC   8(L'WACRONYM,R1),WACRONYM\n         TRT   8(L'WACRONYM+1,R1),BLANKTAB\n         MVI   0(R1),C','\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil1100 DS    0H\n         MVC   WRKPUNCH+15(8),=C'MAINTLV='\n         MVC   WRKPUNCH+23(8),WRKMAINT\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         J     Buil3500\n\nBuil1200 DS    0H\n         ST    R4,WrkDSCUR@\n         #ICALL TRACE\n\n         CLC   =C'ORG ',DSECTOPC\n         JE    Buil3500\n         CLC   =C'USING ',DSECTOPC\n         JE    Buil3500\n         CLC   =C'CSECT ',DSECTOPC\n         JE    Buil3700            B. If End Of DSECT\n         CLC   =C'DSECT ',DSECTOPC\n         JE    Buil3700            B. If End Of DSECT\n         CLC   =C'RSECT ',DSECTOPC\n         JE    Buil3700            B. If End Of DSECT\n         CLC   DSECTL,=C'00000'\n         JE    Buil3500\n         CLC   DSECTVAL,BLANKS\n         JNE   Buil1300\n         CLC   DSECTL,BLANKS\n         JNE   Buil1300\n         J     Buil3500\n\nBuil1300 DS    0H\n         CLC   DSECTOFF,BLANKS     Check For Label With Offset\n         JE    Buil3400            B. If Not\n\n         GOIF  $CBLEN,OFF=Buil1400\n         MVC   NUMBER,DSECTOFF\n         #ICALL CONVHEX            Convert Offset To Hex\n         L     R2,WRKHEX           Load Current Entry's OFFSET\n         MVC   NUMBER,WRKCBLEN\n         #ICALL CONVHEX            Convert Offset To Hex\n         CL    R2,WRKHEX           Check If Entry Past End Of DSECT\n         JNL   Buil3700            B. If Yes\n\nBuil1400 DS    0H\n         LHI   R0,1                Load Exit Call Number\n         LA    R1,DSECTMAP         A(Current Record)\n         #ICALL USEREXIT           Call Exit Routine\n         LTR   R15,R15             Check If Line To Be Skipped\n         JNZ   Buil3500            B. If Yes\n\n         GOIF  $NO_RSV,OFF=Buil1500\n         CLI   DSECTLAB,C'*'\n         JNE   Buil1500            B. If Labelled Field\n         CLI   DSECTFL2,0          Check Flag Settings\n         JE    Buil3500            B. If No Flags\n         MVC   DSECTL,=C'00000'    Set Length To Zero\n         OI    DSECTFL2,DSECT$XL   Set \"NOLABEL\" Due To NO_RSV\n\nBuil1500 DS    0H\n         MVC   WRKPUNCH+9(14),=C'BLSQMFLD NAME='\n         MVC   WRKPUNCH+23(48),DSECTLAB\n         MVI   WRKPUNCH+71,C'*'\n\n         CLI   DSECTLAB+47,C' '    Check For Really Long Label\n         JE    Buil1600            B. If Not\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH              Output 1st Half Of NAME=\n         MVC   WRKPUNCH+15(16),DSECTLAB+48\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         J     Buil1800\n\nBuil1600 DS    0H\n         CLI   WRKPUNCH+41,C' '    Check If Room For Options\n         JE    Buil1700            B. If Yes\n         TRT   WRKPUNCH+19(80),BLANKTAB\n         MVI   0(R1),C','\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH              Output NAME= Keyword\n         LA    R6,WRKPUNCH+15      A(Start Of Next Line)\n         J     Buil1900            Continue\n\nBuil1700 DS    0H\n         TRT   WRKPUNCH+19(80),BLANKTAB\nBuil1800 DS    0H\n         MVI   0(R1),C','\n         LA    R6,1(,R1)\n\nBuil1900 DS    0H\n         TM    DSECTFL2,DSECT$AE   \"ARRAY=END\" From USEREXIT ?\n         JZ    Buil2000            B. If Not\n         MVC   0(10,R6),=C'ARRAY=END,'\n         AHI   R6,10\n\nBuil2000 DS    0H\n         TM    DSECTFL2,DSECT$DC   \"DECODE\" From USEREXIT ?\n         JZ    Buil2100            B. If Not\n         MVC   0(7,R6),=C'DECODE,'\n         AHI   R6,7\n\nBuil2100 DS    0H\n         TM    DSECTFL2,DSECT$NL   \"NEWLINE\" From USEREXIT ?\n         JO    Buil2200            B. If Yes\n         TM    WRKFLAG,W$NEWLINE   \"NEWLINE\" Needed ?\n         JZ    Buil2300            B. If Not\nBuil2200 DS    0H\n         MVC   0(8,R6),=C'NEWLINE,'\n         AHI   R6,8\n         NI    WRKFLAG,255-W$NEWLINE\n\nBuil2300 DS    0H\n         TM    DSECTFL2,DSECT$ST   \"STACK\" From USEREXIT ?\n         JZ    Buil2400            B. If Not\n         MVC   0(6,R6),=C'STACK,'\n         AHI   R6,6\n\nBuil2400 DS    0H\n         TM    DSECTFL2,DSECT$XL   \"NOLABEL\" Due To NO_RSV ?\n         JZ    Buil2500            B. If Not\n         MVC   0(8,R6),=C'NOLABEL,'\n         AHI   R6,8\n\nBuil2500 DS    0H\n         CLC   WRKPUNCH+15(56),BLANKS\n         JE    Buil2600            B. If Null Line\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil2600 DS    0H\n         CLI   DSECTLAB,C'*'\n         JE    Buil2700\n         CLI   DSECTLAB,C' '\n         JE    Buil2700\n         #ICALL NAME8              Create 8 Byte NAME= Field\n         CLC   WNAME8(8),DSECTLAB  LABEL= Same As NAME= ?\n         JE    Buil2700            B. If Yes\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         MVC   0(6,R1),=C'LABEL='\n         MVC   6(L'WNAME8,R1),WNAME8\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         MVI   0(R1),C','\nBuil2700 DS    0H\n         CLC   WRKPUNCH+15(50),BLANKS\n         JE    Buil2800\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil2800 DS    0H\n         CLI   DSECTLAB,C'*'\n         JE    Buil3000\n\n         TM    DSECTFL1,DSECT$EB\n         JZ    Buil2900\n         MVC   WRKPUNCH+15(12),=C'DTYPE=EBCDIC'\n         J     Buil3300\nBuil2900 DS    0H\n         TM    DSECTFL1,DSECT$HX\n         JZ    Buil3200\n         MVC   NUMBER,DSECTOFF\n         #ICALL CONVHEX            Convert Offset To Hex\n         L     R1,WRKHEX           Load Current Entry's OFFSET\n         CL    R1,WrkStOff         Compare Current Offset\n         JL    Buil3000            B. If Lower Than Starting Point\n         CLC   DSECTL,=C'00001'\n         JNE   Buil3100\n         ICM   R15,15,DSECTNXT     A(Next Entry)\n         JZ    Buil3100            B. If End Of DSECT\n         CLC   =C'EQU ',DSECTOPC-DSECTMAP(R15)\n         JNE   Buil3100\n         CLC   =C'000',DSECTVAL-DSECTMAP(R15)\n         JNE   Buil3100\n         MVC   WRKPUNCH+15(22),=C'DTYPE=HEX,VIEW=X''8200'''\n         OI    DSECTFL1,DSECT$DE   Add DECODE For This Label\n         J     Buil3300\nBuil3000 DS    0H\n         MVC   WRKPUNCH+15(18),=C'DTYPE=HEX,VIEW=(8)'\n         J     Buil3300\nBuil3100 DS    0H\n         MVC   WRKPUNCH+15(9),=C'DTYPE=HEX'\n         J     Buil3300\nBuil3200 DS    0H\n         TM    DSECTFL1,DSECT$AN\n         JZ    Buil3300\n         MVC   WRKPUNCH+15(9),=C'DTYPE=ANY'\nBuil3300 DS    0H\n         TRT   WRKPUNCH+15(80),BLANKTAB\n         MVI   0(R1),C','\n         MVI   WRKPUNCH+71,C'*'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         MVC   WRKPUNCH+15(6),=C'OFF=X'''\n         MVC   WRKPUNCH+21(6),DSECTOFF\n         MVC   WRKPUNCH+27(6),=C''',LEN='\n         MVC   WRKPUNCH+33(5),DSECTL\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         J     Buil3500\n\nBuil3400 DS    0H\n         CLC   =C'EQU ',DSECTOPC\n         JE    Buil3500\n         MVC   WRKPUNCH(7),=C'-Error-'\n         MVC   WRKPUNCH+8(4),=C'OFF='\n         MVC   WRKPUNCH+12(6),DSECTOFF\n         MVC   WRKPUNCH+19(4),=C'VAL='\n         MVC   WRKPUNCH+23(5),DSECTVAL\n         MVC   WRKPUNCH+29(2),=C'L='\n         MVC   WRKPUNCH+31(5),DSECTL\n         MVC   WRKPUNCH+37(4),=C'OPC='\n         MVC   WRKPUNCH+41(8),DSECTOPC\n         MVC   WRKPUNCH+50(4),=C'LAB='\n         MVC   WRKPUNCH+54(64),DSECTLAB\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         #SETRC 8                  Set Return Code\n\nBuil3500 DS    0H\n         ICM   R4,15,DSECTNXT      A(Next DSECT entry)\n         JZ    Buil3700            B. If End Of DSECT\n         GOIF  $START,OFF=Buil3600 Check For START= Keyword\n         CLC   DSECTLAB,WSTART     Check For Starting Label\n         JNE   Buil3500            B. If Not (Keep Searching)\n         SET   $START,OFF\nBuil3600 DS    0H\n         J     Buil1200            Process This Entry\n\nBuil3700 DS    0H\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         GOIF  $DECODE,OFF=Buil4000\n         ICM   R4,15,WrkDSECT@     A(1st DSECT Entry)\n         JZ    Buil4000\n         NI    WRKFLAG,255-W$DECODE\nBuil3800 DS    0H\n         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)\n         JZ    Buil3900            B. If End Of DSECT\n         TM    DSECTFL1,DSECT$DE   Check If DECODE Statement Required\n         JZ    Buil3800            B. If Not\n         OI    WRKFLAG,W$DECODE    Remember DECODE Statement Added\n         MVC   DSECTDCL(3),WSUBHDR Save ACRONYM/PREFIX Prefix\n         MVI   DSECTDCL+3,C'D'     Identify \"DECODE\" Label\n         L     R15,WDECODE#\n         AHI   R15,1               Increment \"DECODE\" Label Number\n         ST    R15,WDECODE#\n         CVD   R15,WRKDBL1\n         OI    WRKDBL1+7,X'0F'\n         UNPK  DSECTDCL+4(4),WRKDBL1+4(4)\n         MVC   WRKPUNCH+9(14),=C'BLSQMFLD NAME='\n         MVC   WRKPUNCH+23(8),DSECTDCL\n         MVC   WRKPUNCH+31(7),=C',OFF=X'''\n         MVC   WRKPUNCH+38(6),DSECTOFF\n         MVC   WRKPUNCH+44(27),=C''',LEN=1,VIEW=X''0280'',DECODE'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         J     Buil3800\n\nBuil3900 DS    0H\n         TM    WRKFLAG,W$DECODE    Check If Any DECODE Statements Added\n         JZ    Buil4000            B. If Not\n         GOIF  $SFOOTER,OFF=Buil4100\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n*        Add SHDR= Entry For Footer Information\nBuil4000 DS    0H\n         GOIF  $SFOOTER,OFF=Buil4100\n         MVC   WRKPUNCH+9(L'@SHEADER),@SHEADER\n         MVC   WRKPUNCH+24(3),WSUBHDR\n         MVC   WRKPUNCH+27(4),=C'SFTR'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil4100 DS    0H\n         LHI   R0,3                Load Exit Call Number\n         LA    R1,DSECTMAP         A(Current Record)\n         #ICALL USEREXIT           Call Exit Routine\n\n         MVC   WRKPUNCH+9(12),=C'BLSQMDEF END'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         LHI   R0,2                Load Exit Call Number\n         LA    R1,DSECTMAP         A(Current Record)\n         #ICALL USEREXIT           Call Exit Routine\n\n*        Add BLSQSHDR Statement For Headers & Footers\nBuil4200 DS    0H\n         GOIF  ($SHEADER,$SFOOTER),OFF=Buil4500\n\n         GOIF  $SHEADER,OFF=Buil4300\n         MVI   WRKPUNCH,C'$'\n         MVC   WRKPUNCH+1(3),WSUBHDR\n         MVC   WRKPUNCH+4(4),=C'SHDR'\n         MVC   WRKPUNCH+9(10),=C'BLSQSHDR '''\n         MVC   WRKPUNCH+19(50),WSHEADER\n         MVI   WRKPUNCH+69,C''''\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         OI    WRKFLAG,W$NEWLINE   \"NEWLINE\" Needed for next BLSQMFLD\n\nBuil4300 DS    0H\n         GOIF  $SFOOTER,OFF=Buil4400\n         MVI   WRKPUNCH,C'$'\n         MVC   WRKPUNCH+1(3),WSUBHDR\n         MVC   WRKPUNCH+4(4),=C'SFTR'\n         MVC   WRKPUNCH+9(10),=C'BLSQSHDR '''\n         MVC   WRKPUNCH+19(50),WSFOOTER\n         MVI   WRKPUNCH+69,C''''\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil4400 DS    0H\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil4500 DS    0H\n         GOIF  $DECODE,OFF=Buil5600\n         ICM   R4,15,WrkDSECT@     A(1st DSECT Entry)\n         JZ    Buil5600\n         NI    WRKFLAG,255-W$DECODE\nBuil4600 DS    0H\n         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)\n         JZ    Buil5600            B. If End Of DSECT\n\nBuil4700 DS    0H\n         TM    DSECTFL1,DSECT$DE   Check If DECODE Statement Required\n         JZ    Buil4600            B. If Not\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         OI    WRKFLAG,W$DECODE    Remember DECODE Statement Added\n         MVC   WRKPUNCH(8),DSECTDCL Insert DECODE Label\n         MVC   WRKPUNCH+9(L'BuilRec1),BuilRec1\n         TM    DSECTFL2,DSECT$VM   \"VIEWMATCH=VALUE\" From Exit ?\n         JZ    Buil4750            B. If Not\n         MVC   WRKPUNCH+0+L'BuilRec1(16),=C',VIEWMATCH=VALUE'\n\nBuil4750 DS    0H\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         MVC   WrkEQU@,DSECTNXT    Save 1st EQU Address\n         MVC   WrkEQUL,DSECTLAB    Save Flag Label\n         NI    WRKFLAG,255-W$LABEL Label Line Not Written Yet\nBuil4800 DS    0H\n         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)\n         JZ    Buil4900            B. If End Of DSECT\n         MVC   DSECTDCL(3),WSUBHDR Save ACRONYM/PREFIX Prefix\n         MVI   DSECTDCL+3,C'S'     Identify \"SHDR\" Label\n         L     R15,WSUBHDR#\n         AHI   R15,1               Increment \"SHDR\" Label Number\n         ST    R15,WSUBHDR#\n         CVD   R15,WRKDBL1\n         OI    WRKDBL1+7,X'0F'\n         UNPK  DSECTDCL+4(4),WRKDBL1+4(4)\n\n         TM    WRKFLAG,W$LABEL     Label Line Written Yet ?\n         BO    Buil4850            B. If Yes\n         MVC   WRKPUNCH+9(L'BuilRec2),BuilRec2\n         MVC   WRKPUNCH+23(8),DSECTDCL\n         MVI   WRKPUNCH+26,C'L'    Change \"...S....\" To \"...L....\"\n         MVC   BuilRec3(8),WRKPUNCH+23\n         MVC   BuilRec3+19(8),WrkEQUL\n         MVI   BuilRec3+27,C' '\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         OI    WRKFLAG,W$LABEL\n\nBuil4850 DS    0H\n         MVC   WRKPUNCH+9(14),=C'BLSQMFLD SHDR='\n         MVC   WRKPUNCH+23(8),DSECTDCL\n         MVC   WRKPUNCH+31(21),=C',VIEW=X''__08'',NEWLINE'\n         MVC   WRKPUNCH+39(2),DSECTVAL+3\n         NI    WRKFLAG,255-W$NEWLINE\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         ICM   R15,15,DSECTNXT     A(Next Entry)\n         JZ    Buil4900            B. If End Of DSECT\n         CLC   =C'EQU ',DSECTOPC-DSECTMAP(R15)\n         JE    Buil4800            B. If More EQU Statements\n\nBuil4900 DS    0H\n         TM    WRKFLAG,W$DECODE    Check If Any SHDR Statements Added\n         JZ    Buil5500            B. If Not\n         LHI   R0,3                Load Exit Call Number\n         LA    R1,DSECTMAP         A(Current Record)\n         #ICALL USEREXIT           Call Exit Routine\n\n         MVC   WRKPUNCH+9(12),=C'BLSQMDEF END'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\n         ICM   R4,15,WrkEQU@       A(1st EQU Statement)\n         JZ    Buil5500\n         MVC   WRKPUNCH(L'BuilRec3),BuilRec3\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\nBuil5000 DS    0H\n         MVC   WRKPUNCH(8),DSECTDCL Insert SHDR Label\n         MVC   WRKPUNCH+9(10),=C'BLSQSHDR '''\n         MVC   WRKPUNCH+19(L'DSECTLAB),DSECTLAB\n         TRT   WRKPUNCH+27(80),BLANKTAB\n         CLI   DSECTCOM,C'-'       Check If Comment Begins with \"-\"\n         JNE   Buil5100            B. If Not\n         SHI   R1,2                Back Up To Allow +3 Move\n         J     Buil5200            Continue\nBuil5100 DS    0H\n         MVI   1(R1),C'-'\nBuil5200 DS    0H\n         MVC   3(65,R1),DSECTCOM\n         LAY   R15,TRTABLE2\n         TR    3(70,R1),0(R15)     Convert Quotes Etc.\n         MVC   WRKPUNCH+70(20),BLANKS\n         LA    R2,WRKPUNCH+70      A(Last valid Byte)\nBuil5300 DS    0H\n         CLI   0(R2),C' '          Check For Final Blank\n         JNE   Buil5400            B. If Last Character Found\n         BRCT  R2,Buil5300         Back Up Till Non-Blank Found\nBuil5400 DS    0H\n         MVI   1(R2),C''''\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         ICM   R4,15,DSECTNXT      A(Next Entry)\n         JZ    Buil5600            B. If End Of DSECT\n         CLC   =C'EQU ',DSECTOPC\n         JE    Buil5000            B. If More EQU Statements\nBuil5500 DS    0H\n         LTR   R4,R4               Check If We Hit The End\n         JNZ   Buil4700            B. If Not\n\nBuil5600 DS    0H\n         GOIF  $PRINT,OFF=Buil5800 B. If PRINT= Not Specified\n         GOIF  $PTF,OFF=Buil5700   B. If PTF= Not Specified\n         MVC   WRKPUNCH,BLANKS\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n         MVC   WRKPUNCH+9(12),=C'#TMMOD# PTF='\n         MVC   WRKPUNCH+21(8),WRKPTFID\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\nBuil5700 DS    0H\n         MVC   WRKPUNCH+9(11),=C'POP   PRINT'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil5800 DS    0H\n         GOIF  $END,OFF=Buil5900   B. If END Not Specified\n         MVC   WRKPUNCH+9(7),=C'END   ,'\n         LA    R1,WRKPUNCH\n         #ICALL PUNCH\n\nBuil5900 DS    0H\n         LHI   R15,0\n\nBuildXit #IPEND ,\n\n         #CON  RESUME\nBuilRec1 DC    C'BLSQMDEF CBLEN=1,OFFSETS=NOPRINT,PREFIX=0'\nBuilRec2 DC    C'BLSQMFLD SHDR=___Lnnnn,VIEW=X''FF00'',NEWLINE'\nBuilRec3 DC    C'___Lnnnn BLSQSHDR ''________ -------------------------*\n               -----------------'''\n         #CON  REVERT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse Input Parameter List                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\nParseParm #IPROC ,\n\n         MVC   WrkStOff,=F'0'      Set Default DECODE=\n         #ICALL GetDate            Get Current MAINTLV=\n         MVC   WRKOFFS,=CL7'PRINT' Set Default OFFSETS=\n         MVC   WPRINT,=CL8'GEN'    Set Default PRINT=\n\n         L     R1,WRKPARM@         A(Input Paramters)\n         ICM   R3,15,0(R1)         A(Parameter List)\n         JZ    ParsErr1\n         LA    R3,0(,R3)           Clear High Order Bit\n         SLR   R2,R2\n         ICM   R2,3,0(R3)          L(Parameter Text)\n         JZ    ParsErr1\n         AHI   R3,2                A(Parameter Text)\n         ST    R2,WRKPARML         Save Parameter List Length\n         CHI   R2,255              Check For Maximum Length\n         JNH   Pars0100            B. If Acceptable Length\n         LHI   R2,255              Set To Maximum (for Print Data)\nPars0100 DS    0H\n         MVC   WRKPARM,BLANKS      Clear Macro Name Field\n         #EXEC -R2,MVC,WRKPARM(*-*),0(R3)\n         L     R2,WRKPARML         Restore Original Parm Length\n         J     Pars0300\n\nPars0200 DS    0H\n         SHI   R2,1                Subtract 1 From Remaining Length\n         AHI   R3,1                Advance To Next Character\n\nPars0300 DS    0H\n         LTR   R2,R2               Check If Parsing Complete\n         JNP   Pars0800            B. If Yes\n         CLI   0(R3),C' '          Check For Blank\n         JE    Pars0200            B. If Yes (Skip It)\n         CLI   0(R3),C','          Check For Comma\n         JE    Pars0200            B. If Yes (Skip It)\n\n         LAY   R4,ParmTbl          A(Valid PARM= Keywords)\nPars0400 DS    0H\n         CLI   0(R4),X'FF'         Check For End Of Table\n         JE    ParsErr2            B. If Operand Not Found\n\n         CH    R2,0(,R4)           Check If Keyword Fits\n         JL    Pars0700            B. If Not\n         LH    R5,0(,R4)           Load Keyword Length\n         #EXEC -R5,CLC,0(*-*,R3),6(R4)\n         JNE   Pars0700            B. If No Match For Keyword\n\n         SH    R2,0(,R4)           Subtract Keyword Length\n         AH    R3,0(,R4)           Advance Past Keyword\n         LR    R5,R2               Save Remaining Length\n\n         LTR   R2,R2               Check For End Of Parameter List\n         JZ    Pars0600            B. If Yes\n\n         CLI   0(R3),C''''         Check If Operand within Quotes\n         JE    Pars0500            B. If Yes\n         LA    R1,0(R2,R3)         A(End Of Parameter List)\n         LAY   R15,TRTABLE1\n         #EXEC -R2,TRT,0(*-*,R3),0(R15)\n         SR    R1,R3               Calculate Length Of Operand\n         LR    R2,R1               Pass Length To Subroutine\n         J     Pars0600\n\nPars0500 DS    0H\n         LA    R1,0(R2,R3)         A(End Of Parameter List)\n         SHI   R2,1                Subtract 1 For Leading Quote\n         LAY   R15,TRTABLE3\n         #EXEC -R2,TRT,1(*-*,R3),0(R15)\n         AHI   R1,1                Point Past Trailing Quote\n         SR    R1,R3               Calculate Length Of Operand\n         LR    R2,R1               Pass Length To Subroutine\n\nPars0600 DS    0H\n         ICM   R10,15,2(R4)        A(Keyword Subroutine)\n         BASR  R10,R10             Process Operand\n\n         SR    R5,R2               Calculate Remaining Length\n         AR    R3,R2               Advance Past Operand\n         LR    R2,R5               Restore Length Register\n\n         J     Pars0300            Continue Processing Parmameters\n\nPars0700 DS    0H\n         AHI   R4,ParmTblL         A(Next PARM= Table Entry)\n         J     Pars0400            Continue Processing Table\n\n*        Ensure \"BASELBL\" Was Specified\nPars0800 DS    0H\n         GOIF  $BASELBL,OFF=ParsErr1 Ensure DSECT= Specified\n\n*        Ensure \"ACRONYM\" Or \"PREFIX\" coded to generate a unique label\n         GOIF  $LABEL,ON=Pars0900    Use LABEL= when Specified\n         GOIF  ($ACRONYM,$PREFIX),NONE=ParsErr6\n         MVC   WSUBHDR,WACRONYM\n         GOIF  $ACRONYM,ON=Pars0900  Use ACRONYM= Prefix\n         MVC   WSUBHDR,WPREFIX\nPars0900 DS    0H\n         CLI   WSUBHDR+1,C' '        Check For Single Character Prefix\n         JNE   Pars1000              B. If Not\n         MVI   WSUBHDR+1,C'$'        Insert Prefix Filler\nPars1000 DS    0H\n         CLI   WSUBHDR+2,C' '        Check For Double Character Prefix\n         JNE   ParseRC0              B. If Not\n         MVI   WSUBHDR+2,C'$'        Insert Prefix Filler\n         J     ParseRC0\n\nParsErr1 DS    0H\n         MVC   WrkTemp(ErrMsg01L),ErrMsg01\n         WTO   TEXT=WrkTemp\n         J     ParseRC8\nParsErr2 DS    0H\n         MVC   WrkTemp(ErrMsg02L),ErrMsg02\n         MVC   ErrMsg02A+WrkTemp,BLANKS\n         CHI   R2,8\n         JNH   ParsEr2A\n         LHI   R2,8\nParsEr2A DS    0H\n         #EXEC -R2,MVC,ErrMsg02A+WrkTemp(*-*),0(R3)\n         WTO   TEXT=WrkTemp\n         J     ParseRC8\nParsErr3 DS    0H\n         MVC   WrkTemp(ErrMsg03L),ErrMsg03\n         MVC   ErrMsg03A+WrkTemp,6(R4)\n         WTO   TEXT=WrkTemp\n         J     ParseRC8\nParsErr4 DS    0H\n         MVC   WrkTemp(ErrMsg04L),ErrMsg04\n         MVC   ErrMsg04A+WrkTemp,6(R4)\n         WTO   TEXT=WrkTemp\n         J     ParseRC8\nParsErr5 DS    0H\n         MVC   WrkTemp(ErrMsg05L),ErrMsg05\n         MVC   ErrMsg05A+WrkTemp,6(R4)\n         WTO   TEXT=WrkTemp\n         J     ParseRC8\nParsErr6 DS    0H\n         MVC   WrkTemp(ErrMsg06L),ErrMsg06\n         WTO   TEXT=WrkTemp\n         J     ParseRC8\n\nParseRC0 DS    0H\n         LHI   R15,0               Set Return Code\n         J     ParsExit\n\nParseRC8 DS    0H\n         LHI   R15,8               Set Return Code\n         J     ParsExit\n\nParmTbl  DS    0H\n         DC    AL2(03),AL4(Prtn01),CL10'AL='\nParmTblL EQU   *-ParmTbl\n         DC    AL2(08),AL4(Prtn01),CL10'ACROLBL='\n         DC    AL2(03),AL4(Prtn02),CL10'AN='\n         DC    AL2(08),AL4(Prtn02),CL10'ACRONYM='\n         DC    AL2(03),AL4(Prtn03),CL10'BA='\n         DC    AL2(08),AL4(Prtn03),CL10'BASELBL='\n         DC    AL2(03),AL4(Prtn04),CL10'CB='\n         DC    AL2(06),AL4(Prtn04),CL10'CBLEN='\n         DC    AL2(05),AL4(Prtn05),CL10'CSECT'\n         DC    AL2(03),AL4(Prtn06),CL10'DE='\n         DC    AL2(07),AL4(Prtn06),CL10'DECODE='\n         DC    AL2(03),AL4(Prtn07),CL10'END'\n         DC    AL2(05),AL4(Prtn08),CL10'NOEND'\n         DC    AL2(03),AL4(Prtn09),CL10'HE='\n         DC    AL2(07),AL4(Prtn09),CL10'HEADER='\n         DC    AL2(05),AL4(Prtn10),CL10'LAST8'\n         DC    AL2(03),AL4(Prtn11),CL10'LA='\n         DC    AL2(06),AL4(Prtn11),CL10'LABEL='\n         DC    AL2(03),AL4(Prtn12),CL10'ML='\n         DC    AL2(08),AL4(Prtn12),CL10'MAINTLV='\n         DC    AL2(03),AL4(Prtn13),CL10'NA='\n         DC    AL2(05),AL4(Prtn13),CL10'NAME='\n         DC    AL2(03),AL4(Prtn14),CL10'OF='\n         DC    AL2(08),AL4(Prtn14),CL10'OFFSETS='\n         DC    AL2(03),AL4(Prtn15),CL10'PF='\n         DC    AL2(07),AL4(Prtn15),CL10'PREFIX='\n         DC    AL2(03),AL4(Prtn16),CL10'PR='\n         DC    AL2(06),AL4(Prtn16),CL10'PRINT='\n         DC    AL2(03),AL4(Prtn17),CL10'SH='\n         DC    AL2(08),AL4(Prtn17),CL10'SHEADER='\n         DC    AL2(03),AL4(Prtn18),CL10'SF='\n         DC    AL2(08),AL4(Prtn18),CL10'SFOOTER='\n         DC    AL2(03),AL4(Prtn19),CL10'ST='\n         DC    AL2(06),AL4(Prtn19),CL10'START='\n         DC    AL2(06),AL4(Prtn20),CL10'NO_RSV'\n         DC    AL2(04),AL4(Prtn21),CL10'PTF='\n         DC    AL2(-1)             End Of Table\n\n*        ACROLBL=\nPrtn01   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $ACROLBL,ON=ParsErr3 Check If Already Specified\n         SET   $ACROLBL            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,L'WACROLBL       Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WACROLBL,BLANKS\n         #EXEC -R2,MVC,WACROLBL(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        ACRONYM=\nPrtn02   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $ACRONYM,ON=ParsErr3 Check If Already Specified\n         SET   $ACRONYM            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WACRONYM,BLANKS\n         #EXEC -R2,MVC,WACRONYM(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        BASELBL=\nPrtn03   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $BASELBL,ON=ParsErr3 Check If Already Specified\n         SET   $BASELBL            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,50               Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         STC   R2,WrkDSECTL\n         MVC   WrkDSECT,BLANKS\n         #EXEC -R2,MVC,WrkDSECT(*-*),0(R3)\n\n         GOIF  $PREFIX,ON=Prtn0310 B. If PREFIX= Already Coded\n         MVC   WPREFIX,WrkDSECT    Default PREFIX= to BASELBL= Value\n\nPrtn0310 DS    0H\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        CBLEN=\nPrtn04   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $CBLEN,ON=ParsErr3  Check If Already Specified\n         SET   $CBLEN              Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,5                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         LHI   R1,6                L(Output Field)\n         SLR   R1,R2               Calculate Residual Offset\n         LA    R1,WRKCBLEN(R1)     Offset To Starting Position\n         MVC   WRKCBLEN,=C'000000'\n         #EXEC -R2,MVC,0(*-*,R1),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        CSECT\nPrtn05   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $CSECT,ON=ParsErr3  Check If Already Specified\n         SET   $CSECT              Remember Keyword Specified\n         SET   $END                Imply \"END\" Keyword\n\n         LTR   R2,R2               Check Operand Length\n         JNZ   ParsErr5            B. If Data Exists\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        DECODE=#\nPrtn06   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $DECODE,ON=ParsErr3 Check If Already Specified\n         SET   $DECODE             Remember Keyword Specified\n\n         LTR   R5,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n\n         #EXEC -R2,TRT,0(*-*,R3),NUMBERS\n         JNZ   ParsErr5            B. If Not Numeric\n         #EXEC -R5,PACK,WRKDBL1,0(*-*,R3)\n         OI    WRKDBL1+7,X'0F'\n         CVB   R1,WRKDBL1          Convert Number To Binary\n         ST    R1,WrkStOff         Save Decoding Starting Point\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        END\nPrtn07   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $CSECT,ON=Prtn0710  Check If CSECT= Specified\n         GOIF  $END,ON=ParsErr3    Check If Already Specified\nPrtn0710 DS    0H\n         SET   $END                Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JNZ   ParsErr5            B. If Data Exists\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        NOEND\nPrtn08   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         SET   $END,OFF            Turn OFF \"END\" Keyword\n\n         LTR   R2,R2               Check Operand Length\n         JNZ   ParsErr5            B. If Data Exists\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        HEADER=\nPrtn09   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $HEADER,ON=ParsErr3 Check If Already Specified\n         SET   $HEADER             Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WHEADER,BLANKS\n         #EXEC -R2,MVC,WHEADER(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        LAST8\nPrtn10   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $LAST8,ON=ParsErr3  Check If Already Specified\n         SET   $LAST8              Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JNZ   ParsErr5            B. If Data Exists\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        LABEL=\nPrtn11   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $LABEL,ON=ParsErr3 Check If Already Specified\n         SET   $LABEL              Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,3                Check For Exact Length\n         JNE   ParsErr5            B. If Not Correct\n         MVC   WSUBHDR,BLANKS\n         #EXEC -R2,MVC,WSUBHDR(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        MAINTLV=\nPrtn12   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $MAINTLV,ON=ParsErr3 Check If Already Specified\n         SET   $MAINTLV            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,5                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WRKMAINT,BLANKS\n         #EXEC -R2,MVC,WRKMAINT(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        NAME=\nPrtn13   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $NAME,ON=ParsErr3   Check If Already Specified\n         SET   $NAME               Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WRKNAME,BLANKS\n         #EXEC -R2,MVC,WRKNAME(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        OFFSETS=\nPrtn14   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $OFFSETS,ON=ParsErr3 Check If Already Specified\n         SET   $OFFSETS            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,5                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WRKOFFS,BLANKS\n         #EXEC -R2,MVC,WRKOFFS(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        PREFIX=\nPrtn15   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $PREFIX,ON=ParsErr3 Check If Already Specified\n         SET   $PREFIX             Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         STC   R2,WPREFIXL         Save PREFIX= Length\n         MVC   WPREFIX,BLANKS\n         #EXEC -R2,MVC,WPREFIX(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        PRINT=\nPrtn16   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $PRINT,ON=ParsErr3 Check If Already Specified\n         SET   $PRINT              Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WPRINT,BLANKS\n         #EXEC -R2,MVC,WPRINT(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        SHEADER=\nPrtn17   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $SHEADER,ON=ParsErr3 Check If Already Specified\n         SET   $SHEADER            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CLI   0(R3),C''''         Check If Enclosed Within Quotes\n         JNE   Prtn1710            B. If Not\n         AHI   R3,1                Point Past Leading Quote\n         SHI   R2,2                Remove Quotes From Length\nPrtn1710 DS    0H\n         CHI   R2,50               Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WSHEADER,BLANKS\n         #EXEC -R2,MVC,WSHEADER(*-*),0(R3)\n         LAY   R15,TRTABLE2\n         TR    WSHEADER,0(R15)     Convert Quotes Etc.\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        SFOOTER=\nPrtn18   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $SFOOTER,ON=ParsErr3 Check If Already Specified\n         SET   $SFOOTER            Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CLI   0(R3),C''''         Check If Enclosed Within Quotes\n         JNE   Prtn1810            B. If Not\n         AHI   R3,1                Point Past Leading Quote\n         SHI   R2,2                Remove Quotes From Length\nPrtn1810 DS    0H\n         CHI   R2,50               Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WSFOOTER,BLANKS\n         #EXEC -R2,MVC,WSFOOTER(*-*),0(R3)\n         LAY   R15,TRTABLE2\n         TR    WSFOOTER,0(R15)     Convert Quotes Etc.\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        START=\nPrtn19   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $START,ON=ParsErr3  Check If Already Specified\n         SET   $START              Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,50               Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WSTART,BLANKS\n         #EXEC -R2,MVC,WSTART(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        NO_RSV\nPrtn20   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $NO_RSV,ON=ParsErr3 Check If Already Specified\n         SET   $NO_RSV             Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JNZ   ParsErr5            B. If Data Exists\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\n*        PTF=\nPrtn21   DS    0H\n         STM   R0,R15,ParseSA      Save All Registers\n         GOIF  $PTF,ON=ParsErr3    Check If Already Specified\n         SET   $PTF                Remember Keyword Specified\n\n         LTR   R2,R2               Check Operand Length\n         JZ    ParsErr4            B. If Missing\n         CHI   R2,8                Check For Maximum Length\n         JH    ParsErr5            B. If Too Long\n         MVC   WRKPTFID,BLANKS\n         #EXEC -R2,MVC,WRKPTFID(*-*),0(R3)\n\n         LM    R0,R15,PARSESA      Restore All Registers\n         BR    R10                 Return To Parser\n\nParsExit #IPEND ,\n\n*---------------------------------------------------------------------*\n*        Close Any File That Is Currently Open                        *\n*---------------------------------------------------------------------*\nCloseFiles #IPROC ,\n\n         TM    DCBOFLGS-IHADCB+ASSEMBLY,DCBOFOPN\n         JNO   Close100            B. If \"ASSEMBLY\" Is Not Open\n         CLOSE (ASSEMBLY)\n\nClose100 DS    0H\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN\n         JNO   Close200            B. If \"SYSPUNCH\" Is Not Open\n         CLOSE (SYSPUNCH)\n\nClose200 DS    0H\n         TM    DCBOFLGS-IHADCB+SYSTRACE,DCBOFOPN\n         JNO   ClosExit            B. If \"SYSTRACE\" Is Not Open\n         CLOSE (SYSTRACE)\n\nClosExit #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Open Required Files                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\nOpenFiles #IPROC ,\n\n         OPEN  (ASSEMBLY,(INPUT),SYSPUNCH,(OUTPUT))\n\n         TM    DCBOFLGS-IHADCB+ASSEMBLY,DCBOFOPN\n         JNO   OpenRC08\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN\n         JNO   OpenRC08\n\n         LA    R2,DCBDDNAM-IHADCB+SYSTRACE\n         TIOTSCAN DDN=(R2),NOK=Open0100\n         OPEN  (SYSTRACE,(OUTPUT))\n         TM    DCBOFLGS-IHADCB+SYSTRACE,DCBOFOPN\n         JNO   OpenRC08\n         SET   $TRACE              Write Trace Information To SYSTRACE\n\nOpen0100 DS    0H\n         LHI   R15,0               Set Return Code\n         J     OpenExit\n\nOpenRC08 DS    0H\n         LHI   R15,8               Set Return Code\n\nOpenExit #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Find The ACROLBL Label Within The DSECT                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nFindACROLBL #IPROC ,\n         GOIF  $ACROLBL,OFF=FindARC8\n\n         LA    R4,WrkDSECT@        A(1st DSECT Entry)\n         USING DSECTMAP,R4\nFindA100 DS    0H\n         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)\n         JZ    FindARC8            B. If Entry Not Found\n         CLC   DSECTLAB,WACROLBL\n         JNE   FindA100            B. If Label Not Found\n\n         MVC   WACROFF,DSECTOFF    Save Field Offset\n         MVC   WACROLEN,DSECTL     Save Field Length\n\n         LHI   R15,0               Set Return Code\n         J     FindAxit\n\nFindARC8 DS    0H\n         LHI   R15,8               Set Return Code\n\nFindAxit #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Find The Label specified in the PARM                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nFindDsect #IPROC ,\n         L     R5,WRKASM@          A(Assembler Output Buffer)\n         ICM   R6,15,WRKASM#       #(Assembler Output Statements)\n         JZ    Find0300\n         LH    R2,WRKASMEL         L(Assembler Output Record)\n*        Find The \"DSECT\" Statement\nFind0100 DS    0H\n         USING ASMLIST,R5\n         CLC   ASMLOC,CZEROS       Check If Offset Is Zeros\n         JNE   Find0200            B. If Not\n         LA    R3,ASMLINE          A(Start Of Assembler Text)\n         TRT   0(L'ASMLINE,R3),BLANKTAB\n         JZ    Find0200            B. If No Blanks Found\n         SR    R1,R3               Calculate Length Of Label\n         JNP   Find0200            B. If No Label Exists\n         STC   R1,WrkLabelL        Save Length Of Current Label\n         MVC   WRKLABEL,BLANKS\n         #EXEC -R1,MVC,WrkLabel(*-*),0(R3)\n\n         LA    R3,1(R1,R3)         A(End Of Label)\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB\n         JZ    Find0200            B. If Non-Blank Not Found\n         CLC   =C'DSECT ',0(R1)    Check For DSECT Line\n         JNE   Find0200            B. If Not\n\n         CLC   WrkDSECTL,WrkLabelL\n         JNE   Find0200            B. If Not The Requested DSECT\n         CLC   WrkDSECT,WrkLabel\n         JNE   Find0200            B. If Not The Requested DSECT\n\n         STORAGE OBTAIN,LENGTH=DSECTLEN,LOC=ANY,SP=1,CHECKZERO=YES\n         ST    R1,WrkDSECT@        Save 1st Entry Address\n         LR    R4,R1\n         USING DSECTMAP,R4\n         XC    DSECTPRE,DSECTPRE   Clear Previous Entry Pointer\n         XC    DSECTNXT,DSECTNXT   Clear Next Entry Pointer\n         MVC   DSECTPRL,BLANKS     Clear Previous DSECTLAB\n         MVC   DSECTPRO,BLANKS     Clear Previous DSECTOFF\n         MVC   DSECT,WRKNAME\n         MVC   DSECTLAB,WrkLabel   Save DSECT Label\n         MVC   DSECTOFF,ASMLOC     Save DSECT Offset (Zeros)\n         MVC   DSECTVAL,ASMADDR1   Save DSECT Value  (Zeros)\n         MVC   DSECTL,ASMADDR2     Save DSECT Length\n         MVC   WrkDSELen,ASMADDR2  Save Dsect Length\n         MVC   DSECTOPC,BLANKS\n         MVC   DSECTOPC(5),=C'DSECT'\n         MVC   DSECTOP,BLANKS\n         MVC   DSECTCOM,BLANKS\n         MVC   DSECTDCL,BLANKS\n         J     Find1000\n\nFind0200 DS    0H\n         AH    R5,WRKASMEL         A(Next Assembler Statement)\n         BRCT  R6,Find0100         B. If More Records\n\nFind0300 DS    0H\n         LHI   R15,8               Set Return Code\n         J     FINDEXIT\n\n*        Process statements within this DSECT\nFind0400 DS    0H\n         CLI   ASMLINE,C'*'        Check For Comment Statement\n         JE    Find1000            B. If Yes (Ignore)\n         CLC   =C'Symbol',ASMLOC   Check For Symbol Cross Reference\n         JE    Find1200            B. If End Of Listing\n         CLC   ASMSTMT,BLANKS      Check For Blank Statement Number\n         JE    Find1000            B. If Yes\n         TRT   ASMSTMT,NUMBERS     Check For Valid Statement Number\n         JNZ   Find1000            B. If Not\n         ST    R4,WRKPREV@         Save Previous DSECT Entry Address\n\n         STORAGE OBTAIN,LENGTH=DSECTLEN,LOC=ANY,SP=1,CHECKZERO=YES\n         ST    R1,DSECTNXT         Chain This Entry To Previous\n         LR    R4,R1\n         MVC   DSECTPRE,WRKPREV@   Set Previous Entry Pointer\n         XC    DSECTNXT,DSECTNXT   Clear Next Entry Pointer\n         MVC   DSECTPRL,BLANKS     Clear Previous DSECTLAB\n         MVC   DSECTPRO,BLANKS     Clear Previous DSECTOFF\n         MVC   DSECT,WRKNAME\n         MVC   DSECTLAB,BLANKS\n         MVI   DSECTLAB,C'*'\n         MVC   DSECTOFF,ASMLOC     Save DSECT Offset\n         MVC   DSECTVAL,ASMADDR1   Save DSECT Value\n         MVC   DSECTL,ASMADDR2     Save DSECT Length\n         MVC   DSECTOPC,BLANKS\n         MVC   DSECTOP,BLANKS\n         MVC   DSECTCOM,BLANKS\n         MVC   DSECTDCL,BLANKS\n\n         LA    R3,ASMLINE          A(Start Of Label)\n         CLI   0(R3),C' '          Check If A Label Exists\n         JE    Find0500            B. If Not\n         TRT   0(L'ASMLINE,R3),BLANKTAB\n         JZ    Find1000            B. If No Blanks Found\n         SR    R1,R3               Calculate Length Of Label\n         MVC   WrkTemp,Blanks\n         #EXEC -R1,MVC,WrkTemp(*-*),0(R3)\n         MVC   DSECTLAB,WrkTemp\n         LA    R3,1(R1,R3)         A(End Of Label)\n\nFind0500 DS    0H\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB\n         JZ    Find1000            B. If Non-Blank Not Found\n         LR    R3,R1               A(DC/DS/EQU etc.)\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),BLANKTAB\n         SR    R1,R3               Calculate Length Of Label\n         MVC   WrkTemp,Blanks\n         #EXEC -R1,MVC,WrkTemp(*-*),0(R3)\n         MVC   DSECTOPC,WrkTemp\n         OC    DSECTOPC,BLANKS     Ensure Upper Case\n         LA    R3,1(R1,R3)         A(End Of OptCode)\n\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB\n         JZ    Find1000            B. If Non-Blank Not Found\n         LR    R3,R1               A(CLx ALx X'nn' etc.)\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),BLANKTAB\n         SR    R1,R3               Calculate Length Of Label\n         MVC   WrkTemp,Blanks\n         #EXEC -R1,MVC,WrkTemp(*-*),0(R3)\n         MVC   DSECTOP,WrkTemp\n         OC    DSECTOP,BLANKS      Ensure Upper Case\n         LA    R3,1(R1,R3)         A(End Of Operand)\n\n         CLC   =C'DC ',DSECTOPC    Check For Define Constant\n         JNE   Find0600            B. If Not (No Need To Blank Value)\n         MVC   DSECTVAL,BLANKS\n\nFind0600 DS    0H\n         CLC   =C'EQU ',DSECTOPC   Check For Equate Statement\n         JNE   Find0900            B. If Not (No Need For Comments)\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB\n         JZ    Find1000            B. If Non-Blank Not Found\n         LR    R3,R1               Comments\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         CLI   0(R1),C'-'          Check For Lead \"-\"\n         JE    Find0700            B. If Yes (Skip It)\n         CLC   0(2,R1),=C'. '      Check For Lead \".\"\n         JE    Find0700            B. If Yes (Skip It)\n         J     Find0800\nFind0700 DS    0H\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\n         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB\n         JZ    Find1000            B. If Non-Blank Not Found\n         LR    R3,R1               Comments\n         LA    R2,ASMLINE+L'ASMLINE-1\n         SR    R2,R3               Calculate Remaining Output Length\nFind0800 DS    0H\n         MVC   WrkTemp,Blanks\n         #EXEC -R2,MVC,WrkTemp(*-*),0(R3)\n         MVC   DSECTCOM,WrkTemp\n         J     Find1000\n\nFind0900 DS    0H\n         CLC   ASMLOC,WrkDSELen    Check If Last Statement Processed\n         JE    Find1200\n         CLC   =C'CSECT ',DSECTOPC Check For End Of DSECT\n         JE    Find1100\n         CLC   =C'DSECT ',DSECTOPC Check For End Of DSECT\n         JE    Find1100\n         CLC   =C'RSECT ',DSECTOPC Check For End Of DSECT\n         JE    Find1100\n\nFind1000 DS    0H\n         AH    R5,WRKASMEL         A(Next Assembler Statement)\n         BRCT  R6,Find0400         B. If More Records\n         J     Find1200\n\nFind1100 DS    0H\n         L     R1,WRKPREV@         A(Previous DSECT) Entry\n         XC    0(4,R1),0(R1)       Clear Last \"DSECTNXT\" Pointer\n         STORAGE RELEASE,ADDR=(R4),LENGTH=DSECTLEN,SP=1\n\nFind1200 DS    0H\n         L     R4,WrkDSECT@        A(DSECT Entry)\n         USING DSECTMAP,R4\nFind1300 DS    0H\n         ICM   R4,15,DSECTNXT      A(Next Entry)\n         JZ    Find1900            B. If End Of DSECT\n         CLC   DSECTOFF,BLANKS     Check If OFFSET Exists\n         JE    Find1300            B. If Not\n         CLI   DSECTLAB,C'*'       Check For Null Label\n         JE    Find1500\n\n         TRT   DSECTOP,NONNUMS     Find 1st Non-Numeric\n         JZ    Find1600            B. If All Numerics\n\n         CLI   0(R1),C'A'          Check For ALx\n         JE    Find1500\n         CLI   0(R1),C'B'          Check For BLx\n         JE    Find1500\n         CLI   0(R1),C'C'          Check For CLx\n         JE    Find1400\n         CLI   0(R1),C'D'          Check For DLx\n         JE    Find1500\n         CLI   0(R1),C'F'          Check For FLx\n         JE    Find1500\n         CLI   0(R1),C'H'          Check For HLx\n         JE    Find1500\n         CLI   0(R1),C'P'          Check For PLx\n         JE    Find1500\n         CLI   0(R1),C'X'          Check For XLx\n         JE    Find1500\n\n         OI    DSECTFL1,DSECT$AN   DTYPE=ANY\n         J     Find1600\n\nFind1400 DS    0H\n         OI    DSECTFL1,DSECT$EB   DTYPE=EBCDIC\n         J     Find1600\n\nFind1500 DS    0H\n         OI    DSECTFL1,DSECT$HX   DTYPE=HEX\n\nFind1600 DS    0H\n         MVC   NUMBER,DSECTOFF\n         #ICALL CONVHEX            Convert Offset To Hex\n         L     R5,WRKHEX           Load Current Entry's OFFSET\n         ICM   R15,15,DSECTNXT     A(Next Entry)\n         JZ    Find1900            B. If End Of DSECT\nFind1700 DS    0H\n         CLC   =C'CSECT ',DSECTOPC-DSECTMAP(R15)\n         JE    Find1900            B. If End Of DSECT\n         CLC   =C'DSECT ',DSECTOPC-DSECTMAP(R15)\n         JE    Find1900            B. If End Of DSECT\n         CLC   =C'RSECT ',DSECTOPC-DSECTMAP(R15)\n         JE    Find1900            B. If End Of DSECT\n         CLC   DSECTOFF-DSECTMAP(,R15),BLANKS\n         JNE   Find1800            B. If Next Entry Offset Available\n         ICM   R15,15,DSECTNXT-DSECTMAP(R15)\n         JNZ   Find1700            B. If Next Entry Exists\n         J     Find1900            Else. End Of DSECT\nFind1800 DS    0H\n         MVC   NUMBER,DSECTOFF-DSECTMAP(R15)\n         #ICALL CONVHEX            Convert Offset To Hex\n         L     R6,WRKHEX           Load Next Entry's OFFSET\n         SR    R6,R5               Calculate Length Of 1st Entry\n         CVD   R6,WRKDBL1\n         OI    WRKDBL1+7,X'0F'\n         UNPK  DSECTL,WRKDBL1      Save Length Of Field\n\n         CLC   DSECTL,=C'00001'    Check If Length Is 1 Byte\n         JNE   Find1300            B. If Not\n         TM    DSECTFL1,DSECT$EB   Check For CL1 Byte\n         JZ    Find1300            B. If Not\n         ICM   R15,15,DSECTNXT\n         JZ    Find1300            B. If No Following Entry\n         CLC   =C'EQU ',DSECTOPC-DSECTMAP(R15)\n         JNE   Find1300            B. If Not Followed By An EQU\n         MVI   DSECTFL1,DSECT$HX   DTYPE=HEX\n         J     Find1300\n\nFind1900 DS    0H\n         LHI   R15,0               Set Return Code\n         J     FindExit\n\nFindExit #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Load Entire ASSEMBLY Output Into Storage                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nLoadASM  #IPROC ,\n\n         LHI   R4,0                Initialize Statement Counter\nLoad0100 DS    0H\n         GET   ASSEMBLY\n         AHI   R4,1                Increment Statement Counter\n         J     Load0100            B. Till End Of File\n\nLoad0200 DS    0H\n         ST    R4,WRKASM#          Save Assembler Statement Count\n\n         LH    R1,DCBLRECL-IHADCB+ASSEMBLY\n         STH   R1,WRKASMEL         Save Assembler Output LRECL\n         MH    R4,WRKASMEL         Calculate Required Buffer Length\n         STORAGE OBTAIN,LENGTH=(R4),LOC=ANY,SP=1\n         ST    R1,WRKASM@          Save Assembler Output Buffer Address\n         ST    R4,WRKASML          Save Assembler Output Buffer Length\n\n         CLOSE (ASSEMBLY)          Close The Assembler Output File\n         LARL  R0,LoadExit         A(EODAD Address)\n         ST    R0,DCBEEODA-DCBE+ASMDCBE\n         OPEN  (ASSEMBLY,(INPUT))  Re-Open The Assembler Output File\n\n         L     R5,WRKASM@          A(Assembler Output Buffer)\nLoad0300 DS    0H\n         GET   ASSEMBLY            Get Assembler Output Record\n         LH    R2,WRKASMEL         L(Assembler Output Record)\n         #EXEC -R2,MVC,0(*-*,R5),0(R1)\n         LA    R5,1(R2,R5)         A(End Of Current Assembler Record)\n         J     Load0300            B. Till End Of File\n\nLoadExit #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Get Current Date                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nGetDate  #IPROC ,\n\n         MVC   WRKMAINT,=C'CCYY.DDD'\n         L     R1,FLCCVT           A(CVT)\n         USING CVT,R1\n         L     R0,CVTDATE          Load 0CYYDDDF\n         DROP  R1\n         XC    WRKDBL1,WRKDBL1\n         STCM  R0,8,WRKDBL1+3      Save Centuries Past 1900\n         LHI   R15,19              Load Starting Point\n         A     R15,WRKDBL1         Add Number Of Centuries Past 1900\n         CVD   R15,WRKDBL1         Convert To Decimal\n         OI    WRKDBL1+7,X'0F'\n         UNPK  WRKMAINT(2),WRKDBL1+6(2)    Insert CC\n         LR    R15,R0              Re-Load 0CYYDDDF\n         STCM  R15,4,WRKMAINT+3    Save  Y\n         SRL   R15,4\n         STCM  R15,4,WRKMAINT+2    Save Y\n         OC    WRKMAINT+2(2),=C'00'\n         XC    WRKDBL1,WRKDBL1\n         STH   R0,WRKDBL1+6        Save DDDF\n         OI    WRKDBL1+7,X'0F'\n         UNPK  WRKMAINT+5(3),WRKDBL1+6(2)  Insert DDD\n\n         #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Convert EBCDIC Hex Value To Hex                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nCONVHEX  #IPROC ,\n\n         LAY   R15,HEXTAB2\n         TR    NUMBER,0(R15)       Convert Character To Hex\n         PACK  WRKDBL1,NUMBER(7)   Remove Top Nibbles\n         MVC   WRKHEX,WRKDBL1+3    Save Converted Hex Value\n\n         #IPEND ,                  Return To Caller\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Create an 8 byte LABEL= name from the current DSECT label.   *\n*                                                                     *\n*---------------------------------------------------------------------*\nNAME8    #IPROC ,\n         USING DSECTMAP,R4\n\n         MVC   WNAME8,BLANKS       Clear Name Field\n         MVI   WNAME8+8,C' '\n         MVI   WNAME8,C'*'         Indicate \"RSV\" Area\n         CLI   DSECTLAB,C'*'       Check If Field Has A Label\n         JE    Name8Xit            B. If Not\n\n         MVC   WrkTemp,BLANKS\n         MVC   WrkTemp(L'DSECTLAB),DSECTLAB\n         MVC   WNAME8,DSECTLAB     Copy To 8 Byte Name Field\n\n*        Remove Matching PREFIX= Characters\n         LA    R1,DSECTLAB         A(Start Of DSECT Label)\n         GOIF  $PREFIX,OFF=Name8300\n         LA    R2,WPREFIX          A(PREFIX= Value)\n         SLR   R3,R3\n         ICM   R3,1,WPREFIXL       L(PREFIX= Field)\nName8100 DS    0H\n         CLI   0(R2),C' '          Check For End Of PREFIX=\n         JE    Name8200            B. If Yes\n         CLC   0(1,R2),0(R1)       Check For Matching Prefix Value\n         JNE   Name8200            B. If Not (Done Stripping Prefix)\n         LA    R1,1(,R1)           A(Next Byte In DSECT Label)\n         LA    R2,1(,R2)           A(Next Byte In PREFIX= Value)\n         BRCT  R3,Name8100         Loop Through PREFIX= Value\nName8200 DS    0H\n         MVC   WrkTemp,BLANKS\n         LA    R3,DSECTLAB+L'DSECTLAB\n         SR    R3,R1               Calculate Suffix Length\n         MVC   WrkTemp,BLANKS\n         #EXEC -R3,MVC,WrkTemp(*-*),0(R1)\n         MVC   WNAME8,WrkTemp      Copy To 8 Byte Name Field\n\n*        Copy Last 8 Characters If \"LAST8\" Specified\nName8300 DS    0H\n         GOIF  $LAST8,OFF=Name8Xit\n         TRT   WrkTemp,BLANKTAB    Find End Of Label\n         LA    R3,WrkTemp          A(Start Of Label)\n         LR    R2,R1               A(End Of Label)\n         SR    R2,R3               Calculate Length Of Label\n         CHI   R2,8                Check For A Large Label\n         JNH   Name8Xit            B. If NAME= Is Already Acceptable\n         SHI   R1,8                Back Up To Last 8 Bytes Of Label\n         MVC   WNAME8,0(R1)        Copy Last 8 Bytes\n\nName8Xit #IPEND ,                  Return To Caller\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Write record to SYSPUNCH (Called From UserExit)              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\nPUNCH    DS    0H\n         BAKR  R14,0               SAVE GPRs & ARs\n         LARL  R12,$CNLS           Set Constants Base Register\n         LAM   AR2,AR10,ZEROS      Clear The Access Registers\n         LR    R5,R1               A(Punch Record)\n\n         CLC   0(256,R5),BLANKS    Check If Punching a BLANK Line\n         JNE   PUNC0100            B. If Not\n         TM    WRKFLAG,W$BLANKS    Check If We Just Punched A BLANK\n         JO    PUNCEXIT            B. If Yes (No Need For Another)\n         OI    WRKFLAG,W$BLANKS    Remember We Punched A BLANK Line\n         J     PUNC0200\n\nPUNC0100 DS    0H\n         NI    WRKFLAG,255-W$BLANKS Remember We Punched A Non-BLANK\n\nPUNC0200 DS    0H\n         PUT   SYSPUNCH,0(R5)      Punch The Current Record\n         MVC   0(256,R5),BLANKS    Clear The Record Area\n\nPUNCEXIT DS    0H                  Return To Caller\n         PR    ,                   Restore GPR/AR 2-14 And Return\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Write record to SYSTRACE (Called From UserExit)              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\nPRINT    DS    0H\n         BAKR  R14,0               SAVE GPRs & ARs\n         LARL  R12,$CNLS           Set Constants Base Register\n         LAM   AR2,AR10,ZEROS      Clear The Access Registers\n         LR    R5,R1               A(Print Record)\n\n         PUT   SYSTRACE,0(R5)\n         MVC   0(256,R5),BLANKS\n\n         PR    ,                   Restore GPR/AR 2-14 And Return\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Write All The DSECTMAP Data                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nDumpDsect #IPROC ,\n         GOIF  $TRACE,OFF=DumpExit\n\n         ICM   R4,15,WrkDSECT@     A(1st DSECTMAP Entry)\n         JZ    DumpExit\n         USING DSECTMAP,R4\n         MVC   WRKTRACE,BLANKS\n         MVC   WRKTRACE(L'Dumphdr1),Dumphdr1\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n         MVC   WRKTRACE(L'Dumphdr2),Dumphdr2\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n\nDump0100 DS    0H\n         UNPK  DMPNXT(9),DSECTNXT(5)\n         LAY   R15,HEXTAB1\n         TR    DMPNXT(8),0(R15)\n         MVI   DMPNXT+8,C' '\n         UNPK  DMPPRE(9),DSECTPRE(5)\n         LAY   R15,HEXTAB1\n         TR    DMPPRE(8),0(R15)\n         MVI   DMPPRE+8,C' '\n         MVC   DMPDSE,DSECT\n         MVC   DMPPRL,DSECTPRL\n         MVC   DMPPRO,DSECTPRO\n         MVC   DMPLAB,DSECTLAB\n         UNPK  DMPF1(3),DSECTFL1(2)\n         LAY   R15,HEXTAB1\n         TR    DMPF1(2),0(R15)\n         MVI   DMPF1+2,C' '\n         UNPK  DMPF2(3),DSECTFL2(2)\n         LAY   R15,HEXTAB1\n         TR    DMPF2(2),0(R15)\n         MVI   DMPF2+2,C' '\n         MVC   DMPOFF,DSECTOFF\n         MVC   DMPVAL,DSECTVAL\n         MVC   DMPL,DSECTL\n         MVC   DMPOPC,DSECTOPC\n         MVC   DMPOP,DSECTOP\n         MVC   DMPCOM,DSECTCOM\n         MVC   DMPDCL,DSECTDCL\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n\n         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)\n         JNZ   Dump0100\n         #ICALL PRINT\n\nDumpExit #IPEND ,                  Return To Caller\n\n         #CON  RESUME\nDumphdr1 DC    C'NEXT     PREV     DSECT    PREV-LABEL           P-OFF *\n                LABEL                F1 F2 OFF    VAL   LEN   OPCODE   *\n               OPERAND  COMMENTS             DEC-LABEL'\nDumphdr2 DC    C'________ ________ ________ ____________________ ______*\n                ____________________ __ __ ______ _____ _____ ________ *\n               ________ ____________________ _________'\n         #CON  REVERT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Write record to SYSTRACE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nTRACE    #IPROC ,\n         L     R4,WrkDSCUR@        A(Current DSECTMAP Entry)\n         USING DSECTMAP,R4\n\n         GOIF  $TRACE,OFF=TracExit\n         TM    WRKFLAG,W$HEADER    Check If Already Written\n         JO    TRACE100            B. If Yes\n         OI    WRKFLAG,W$HEADER\n         MVC   WRKTRACE,BLANKS\n         MVC   WRKTRACE(L'TraceHd1),TraceHd1\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n         MVC   WRKTRACE(L'TraceHd2),TraceHd2\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n\nTRACE100 DS    0H\n         TM    WRKFLAG,W$EXIT      Check If After USEREXIT\n         JZ    TRACE300            B. If Not\n         LA    R5,WRKUPARM         A(Exit Parameter List)\n         USING EXITPARM,R5\n         MVC   WRKTRACE(8),=C'D2BUSERX'\n         MVC   WRKTRACE+9(3),=C'RS='\n         UNPK  WRKTRACE+12(9),EXITRSCD(5)\n         LAY   R15,HEXTAB1\n         TR    WRKTRACE+12(8),0(R15)\n         MVC   WRKTRACE+20(4),=C' RC='\n         UNPK  WRKTRACE+24(9),EXITRSCD(5)\n         LAY   R15,HEXTAB1\n         TR    WRKTRACE+24(8),0(R15)\n         MVI   WRKTRACE+32,C' '\n         LTR   R4,R4               Check For DSECTMAP\n         JZ    TRACE200            B. If Not Available\n         MVC   WRKTRACE+33(9),=C'DSECTOFF='\n         MVC   WRKTRACE+42(6),DSECTOFF\n         MVC   WRKTRACE+49(9),=C'DSECTPRO='\n         MVC   WRKTRACE+58(6),DSECTPRO\n         MVC   WRKTRACE+65(9),=C'DSECTLAB='\n         MVC   WRKTRACE+74(10),DSECTLAB\n         MVC   WRKTRACE+85(9),=C'DSECTPRL='\n         MVC   WRKTRACE+94(10),DSECTPRL\nTRACE200 DS    0H\n         DROP  R5\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n\nTRACE300 DS    0H\n         LTR   R4,R4               Check For DSECTMAP\n         JZ    TracExit            B. If Not Available\n         MVC   WTDSECT,DSECT\n         MVC   WTDSOFF,DSECTOFF\n         MVC   WTDSVAL,DSECTVAL\n         MVC   WTDSL,DSECTL\n         MVC   WTDSOPC,DSECTOPC\n         MVC   WTDSOP,DSECTOP\n         MVC   WTDSDCL,DSECTDCL\n         UNPK  WTDSF1(3),DSECTFL1(2)\n         LAY   R15,HEXTAB1\n         TR    WTDSF1(2),0(R15)\n         MVI   WTDSF1+2,C' '\n         UNPK  WTDSF2(3),DSECTFL2(2)\n         LAY   R15,HEXTAB1\n         TR    WTDSF2(2),0(R15)\n         MVI   WTDSF2+2,C' '\n         MVC   WTDSLAB,DSECTLAB\n         MVC   WTDSCOM,DSECTCOM\n         LA    R1,WRKTRACE\n         #ICALL PRINT\n\nTracExit #IPEND ,                  Return To Caller\n\n         #CON  RESUME\nTraceHd1 DC    C'DSECT    DSECTOFF DSECTVAL DSECTL DSECTOPC DSECTOP  DS*\n               ECTDCL DSECTFL1 DSECTFL2 DSECTLAB'\nTraceHd2 DC    C'_____    ________ ________ ______ ________ _______  __*\n               ______ ________ ________ ________'\n         #CON  REVERT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Call Installation Processing Routine                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nUSEREXIT #IPROC ,\n         ST    R1,WrkDSCUR@        A(Current DSECTMAP)\n         LA    R5,WRKUPARM         A(Exit Parameter List)\n         USING EXITPARM,R5\n         LTR   R6,R1               A(DSECTMAP)\n         JZ    USEREX30            B. If Not Provided\n         USING DSECTMAP,R6\n         MVC   DSECTPRL,BLANKS     Clear Previous DSECTLAB\n         MVC   DSECTPRO,BLANKS     Clear Previous DSECTOFF\n\n         ICM   R2,15,DSECTPRE      A(Previous DSECTMAP Entry)\n         JZ    USEREX30            B. If At The Beginning\nPREV     USING DSECTMAP,R2\nUSEREX10 DS    0H\n         TM    PREV.DSECTOFF,X'F0' Check For Previous Offset\n         JNO   USEREX20            B. If Not\n         MVC   DSECTPRO,PREV.DSECTOFF Set Previous Offset\n         MVC   DSECTPRL,PREV.DSECTLAB Set Previous Label\n         J     USEREX30\nUSEREX20 DS    0H\n         ICM   R2,15,PREV.DSECTPRE A(Previous DSECTMAP Entry)\n         JNZ   USEREX10            B. If At The Beginning\n         DROP  PREV\n\nUSEREX30 DS    0H\n         XC    EXITRSCD,EXITRSCD   Clear Reason Code\n         XC    EXITRECD,EXITRECD   Clear Return Code\n\n         WXTRN D2BUSERX\n         ICM   R15,15,=V(D2BUSERX) A(Installation Exit Routine)\n         JZ    USEREX99            B. If No Exit Provided\n\n         MVC   EXITNAME,WRKNAME    Current Macro Name\n         ST    R0,EXITNUM          Save Exit Number\n         ST    R6,EXITIREC         A(Current DSECTMAP Record)\n         L     R0,=A(PRINT)        A(Print Output Routine)\n         ST    R0,EXITTRA@\n         LA    R0,WRKTRACE         A(Print Output Record)\n         ST    R0,EXITTRAR\n         L     R0,=A(PUNCH)        A(Punch Output Routine)\n         ST    R0,EXITPUN@\n         LA    R0,WRKPUNCH         A(Punch Output Record)\n         ST    R0,EXITPUNR\n\n         L     R0,EXITNUM          #(Exit Invocation)\n         LR    R1,R5               A(Exit Parameter List)\n         BASR  R14,R15             Invoke Installation Exit\n\n         OI    WRKFLAG,W$EXIT      Indicate After USEREXIT\n         #ICALL TRACE\n         NI    WRKFLAG,255-W$EXIT\n\n         L     R0,EXITRSCD         Load Reason Code\n         L     R15,EXITRECD        Load Return Code\n\n         LTR   R15,R15             Check Return Code\n         JZ    USEREX99            B. If Zero\n         LHI   R15,8               Set Return Code To 8\n\nUSEREX99 #IPEND ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS AND WORK AREA                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #CON  START\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n\n@SHEADER DC    C'BLSQMFLD SHDR=$_______,NEWLINE'\n\nErrMsg01  DC   AL2(29),C'D2BLS01I Missing DSECT= label'\nErrMsg01L EQU  *-ErrMsg01\nErrMsg02  DC   AL2(38),C'D2BLS02I Invalid PARM= Value: ________'\nErrMsg02L EQU  *-ErrMsg02\nErrMsg02A EQU  2+30,8              Insert Offset/Length\nErrMsg03  DC   AL2(46),C'D2BLS03I Duplicate Keyword: ________'\nErrMsg03L EQU  *-ErrMsg03\nErrMsg03A EQU  2+28,8              Insert Offset/Length\nErrMsg04  DC   AL2(34),C'D2BLS04I Missing Operand: ________'\nErrMsg04L EQU  *-ErrMsg04\nErrMsg04A EQU  2+26,8              Insert Offset/Length\nErrMsg05  DC   AL2(34),C'D2BLS05I Invalid Operand: ________'\nErrMsg05L EQU  *-ErrMsg05\nErrMsg05A EQU  2+26,8              Insert Offset/Length\nErrMsg06  DC   AL2(37),C'D2BLS06I ACRONYM=, LABEL= or PREFIX= Required'\nErrMsg06L EQU  *-ErrMsg06\nErrMsg07  DC   AL2(37),C'D2BLS07I SYSIN Contains No Data'\nErrMsg07L EQU  *-ErrMsg07\nErrMsg08  DC   AL2(27),C'D2BLS08I Missing PTF= label'\nErrMsg08L EQU  *-ErrMsg08\n\nASSEMBLY DCB   DDNAME=ASSEMBLY,DSORG=PS,MACRF=GL,DCBE=ASMDCBE\nASMDCBE  DCBE  EODAD=Load0200\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,                      X\n               RECFM=FB,EXLST=OPENLST\nSYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PS,MACRF=PM,                      X\n               RECFM=FB,EXLST=OPENLST\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,DCBE=SYSINE,    X\n               RECFM=FB,EXLST=OPENLST\nSYSINE   DCBE  EODAD=Chec0500\n\nOPENLST  DC    X'85',AL3(DCBEXIT)\nDCBEXIT  #DCBEXIT LRECL=80\n\nCZEROS   DC    72C'0'              Lots Of Zeros\nBLANKS   DC    256C' '             Lots Of Blanks\nZEROS    DC    16F'0'              Lots Of Zeros\n\nBLANKTAB DC    256X'00'            Find Blanks\n         ORG   BLANKTAB+C' '\n         DC    C' '\n         ORG   ,\n\nNBLANKTAB DC    256X'FF'           Find Non-Blanks\n         ORG   NBLANKTAB+C' '\n         DC    X'00'\n         ORG   ,\n\nNUMBERS  DC    256X'FF'            Find Numerics (or Blanks)\n         ORG   NUMBERS+C' '\n         DC    X'00'               Blanks\n         ORG   NUMBERS+C'0'\n         DC    10X'00'             0123456789\n         ORG   ,\n\nNONNUMS  DC    256X'FF'            Find Non-Numerics\n         ORG   NONNUMS+C'0'\n         DC    10X'00'             0123456789\n         ORG   ,\n\nTRTABLE1 DC    256X'00'\n         ORG   TRTABLE1+C' '       Find Blanks\n         DC    C' '\n         ORG   TRTABLE1+C','       Or Commas\n         DC    C','\n         ORG   ,\n\nTRTABLE2 DC    256AL1(*-TRTABLE2)  All-Characters Defined\n         ORG   TRTABLE2+X'50'\n         DC    C'+'                Convert And To Plus\n         ORG   TRTABLE2+C''''\n         DC    C'\"'                Convert Quote To Double-Quote\n         ORG   ,\n\nTRTABLE3 DC    256X'00'\n         ORG   TRTABLE3+C''''      Find Trailing Quote\n         DC    C''''\n         ORG   ,\n\nHEXTAB1  DC    256X'00'\n         ORG   HEXTAB1+C'0'\n         DC    C'0123456789ABCDEF'\n         ORG   ,\n\nHEXTAB2  DC    256X'00'\n         ORG   HEXTAB2+C'0'\n         DC    X'00010203040506070809'\n         ORG   HEXTAB2+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   ,\n\n         #CON  END,PATCH=NO\n\n         #STARTWA PATCH=NO\n         DCLSW MF=L                Define Switches\n         #IPROC MODE=DEFINE\nWRKPARM@ DS    A                   A(Input Parameters)\nWRKPARMT DS    A                   A(Input Parameter Text)\nWRKPARMS DS    A                   A(Simulated PARM=)\nWRKPARML DS    F                   L(Input Parameters)\nWRKPARM  DS    CL256               Input Parameter String\nWRKPTFID DS    CL8                 PTF=\nWRKNAME  DS    CL8                 NAME=    (Default=________)\nWRKMAINT DS    CL8'CCYY.DDD'       MAINTLV= (Default=Julian Date)\nWRKCBLEN DS    CL6                 CBLEN=   (Default defined by DSECT)\nWRKOFFS  DS    CL7                 OFFSETS=PRINT/NOPRINT\nWRKASM#  DS    F                   Assembler Statement Count\nWRKASM@  DS    A                   Assembler Output Address\nWRKASML  DS    F                   Assembler Output Length\nWRKASMEL DS    H                   Assembler Output Entry Length\n\nWRKPREV@ DS    A                   A(Previous DSECT Entry)\n\nParseSA  DS    16F                 Parse SubRoutine Save Area\n\nWrkTemp  DS    CL256               Temporary Area\n\nWrkDSECTL DS   AL1                 L(DSECT Label)\nWrkDSECT DS    CL65                DSECT Label\nWrkDSECT@ DS   A                   A(DSECT Information - DSECTMAP)\nWrkDSCUR@ DS   A                   A(Current DSECTMAP Entry)\nWrkDSELen DS   CL5                 Defined DSECT Length\nWrkEQUL  DS    CL8                 EQU Flag Label\nWrkEQU@  DS    A                   A(1st EQU Label)\n\nWRKDBL1  DS    D                   Conversion Work Area\nWRKDBL2  DS    D                   Conversion Work Area\n\nNUMBER   DS    CL6                 Input EBCDIC HEX Number\nWRKHEX   DS    F                   Converted Hex Value\n\nWrkLabelL DS   AL1                 Length Of Macro Name\nWrkLabel DS    CL65                Macro Name (Plus Trailing Blank)\n\nWRKFLAG  DS    XL1                 Flag Byte\nW$DECODE EQU   B'10000000'         - DECODE Statement Added\nW$NEWLINE EQU  B'01000000'         - NEWLINE Needed for next FLD\nW$BLANKS  EQU  B'00100000'         - Previous PUNCH record was BLANKS\nW$HEADER EQU   B'00010000'         - Trace Header Written\nW$EXIT   EQU   B'00001000'         - Trace After USEREXIT\nW$LABEL  EQU   B'00000100'         - Label Line Written\nWrkStOff DS    F                   Decode Starting Offset\n\nWRKCHAIN DS    A                   DSECT Chain Beginning\nWRKLAST  DS    A                   Last DSECT Entry Address\n\nWRKFULL1 DS    F\nWRKFULL2 DS    F\n\nLABEL    DS    CL80                Current Statement's Label\nOPCODE   DS    CL80                Current Statement's Opcode\nOPERAND  DS    CL80                Current Statement's Operand\n\nLENGTH   DS    CL6                 Current DSECT Length\nOFFSET   DS    CL6                 Current Statement DSECT Offset\n\n         DS    0F\nWRKPUNCH DS    CL256               Output Record Buffer\n         DS    0F\nWRKTRACE DS    CL256               Output Record Buffer\n\n         ORG   WRKTRACE            Record Trace Data\nWTDSECT  DS    CL8\n         DS    CL1\nWTDSOFF  DS    CL6\n         DS    CL3\nWTDSVAL  DS    CL5\n         DS    CL4\nWTDSL    DS    CL5\n         DS    CL2\nWTDSOPC  DS    CL8\n         DS    CL1\nWTDSOP   DS    CL8\n         DS    CL1\nWTDSDCL  DS    CL8\n         DS    CL1\nWTDSF1   DS    CL2\n         DS    CL7\nWTDSF2   DS    CL2\n         DS    CL7\nWTDSLAB  DS    CL64\n         DS    CL1\nWTDSCOM  DS    CL65\n         ORG   ,\n\n         ORG   WRKTRACE            DSECT Dump Data\nDMPNXT   DS    CL8                 Next DSECTMAP Address\n         DS    CL1\nDMPPRE   DS    CL8                 Previous DSECTMAP Address\n         DS    CL1\nDMPDSE   DS    CL8                 DSECT Name\n         DS    CL1\nDMPPRL   DS    CL20                Previous Label\n         DS    CL1\nDMPPRO   DS    CL6                 Previous Offset\n         DS    CL1\nDMPLAB   DS    CL20                Current Label\n         DS    CL1\nDMPF1    DS    CL2                 Flag 1\n         DS    CL1\nDMPF2    DS    CL2                 Flag 2\n         DS    CL1\nDMPOFF   DS    CL6                 Offset\n         DS    CL1\nDMPVAL   DS    CL5                 Value\n         DS    CL1\nDMPL     DS    CL5                 Length\n         DS    CL1\nDMPOPC   DS    CL8                 Opcode\n         DS    CL1\nDMPOP    DS    CL8                 Operand\n         DS    CL1\nDMPCOM   DS    CL20                Comments\n         DS    CL1\nDMPDCL   DS    CL8                 DECODE Label\n         ORG   ,\n\nWACROFF  DS    CL6                 ACROFF=   (Determined from DSECT)\nWACROLEN DS    CL5                 ACROLEN=  (Determined from DSECT)\nWACRONYM DS    CL8                 ACRONYM=  (Specified In PARM)\nWACROLBL DS    CL64                ACROLBL=  (Specified In PARM)\nWHEADER  DS    CL8                 HEADER=   (Specified In PARM)\nWPREFIXL DS    AL1                 PREFIX= Length\nWPREFIX  DS    CL8                 PREFIX=   (Specified In PARM)\nWSUBHDR  DS    CL3                 Subheader\nWDECODE# DS    F                   DECODE Statement Counter\nWSUBHDR# DS    F                   SHDR   Statement Counter\nWPRINT   DS    CL8                 GEN/NOGEN Print Option\nWNAME8   DS    CL8,C               NAME=\nWSHEADER DS    CL50                Heading Text\nWSFOOTER DS    CL50                Footing Text\nWSTART   DS    CL64                START= Label\n\nWRKUPARM DS    0F,XL(EXITPLEN)     Exit Routine Parameter List\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nASMLIST  DSECT ,\nASMCC    DS    C                   ASA/Machine Control Character\nASMLOC   DS    CL6                 Location\n         DS    CL16\nASMADDR1 DS    CL5                 Value\n         DS    CL1\nASMADDR2 DS    CL5                 Length\n         DS    CL1\nASMSTMT  DS    CL5                 Statement Number\nASMPLUS  DS    CL1                 \"+\" For Macro Statement\nASMLINE  DS    CL72                Expanded Text Line\nASMCONT  DS    CL1                 Non-Blank For Continuation\n\nDSECTMAP DSECT ,\nDSECTNXT DS    A                   A(Next Entry In Chain)\nDSECTPRE DS    A                   A(Previous Entry In Chain)\nDSECT    DS    CL8                 Name\nDSECTPRL DS    CL64                Previous Label\nDSECTPRO DS    CL6                 Previous Offset\nDSECTLAB DS    CL64                Label\nDSECTFL1 DS    X                   Flag Byte\nDSECT$HX EQU   B'10000000'         DTYPE=HEX\nDSECT$EB EQU   B'01000000'         DTYPE=EBCDIC\nDSECT$AN EQU   B'00100000'         DTYPE=ANY\nDSECT$AQ EQU   B'00100000'         DTYPE=QANY  (Not Used)\nDSECT$AS EQU   B'00100000'         DTYPE=ASCII (Not Used)\nDSECT$DE EQU   B'00010000'         DECODE This Byte\nDSECTFL2 DS    X                   Flab Byte #2\nDSECT$AE EQU   B'10000000'         - Add \"ARRAY=END\"\nDSECT$DC EQU   B'01000000'         - Add \"DECODE\"\nDSECT$NL EQU   B'00100000'         - Add \"NEWLINE\"\nDSECT$ST EQU   B'00010000'         - Add \"STACK\"\nDSECT$XL EQU   B'00001000'         - Add \"NOLABEL\"\nDSECT$VM EQU   B'00000100'         - Add \"VIEWMATCH=VALUE\"\nDSECTOFF DS    CL6                 Offset\nDSECTVAL DS    CL5                 Value\nDSECTL   DS    CL5                 Length\nDSECTOPC DS    CL8                 Opcode\nDSECTOP  DS    CL8                 Operand\nDSECTCOM DS    CL65                Comments\nDSECTDCL DS    CL8                 DECODE Label\nDSECTLEN EQU   *-DSECTMAP\n\nEXITPARM DSECT ,\nEXITNAME DS    CL8                 Macro Name\nEXITNUM  DS    F                   Exit Call Number\nEXITIREC DS    A                   A(Current DSECT Record (\"DSECTMAP\"))\nEXITTRA@ DS    A                   A(SYSTRACE Routine (\"PRINT\"))\nEXITTRAR DS    A                   A(SYSTRACE Record  (\"WRKTRACE\"))\nEXITPUN@ DS    A                   A(SYSPUNCH Routine (\"PUNCH\"))\nEXITPUNR DS    A                   A(SYSPUNCH Record  (\"WRKOUT\"))\nEXITRSCD DS    F                   Exit Reason Code (R0)\nEXITRECD DS    F                   Exit Return Code (R15)\nEXITPLEN EQU   *-EXITPARM\n\n         #DSECTS CVT,DCB,DCBE,PSA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITSUB": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x01\\x1c\\x01\\x1c\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:26", "lines": 284, "newlines": 284, "modlines": 0, "user": "SOURCE"}, "text": "EDITSUB  TITLE '- Submit Currently Edited Data Set Without Saving'\n*------------------------------------------------------------------*\n*                                                                  *\n*        This EDIT MACRO will submit the data that is currently    *\n*        being edited, without saving the data first.              *\n*                                                                  *\n*        It also does not require a SPFTEMPn file as it writes     *\n*        the data directly to the internal reader.                 *\n*                                                                  *\n*        As this is an initial initial version there may be        *\n*        problems so please let me know if you encounter any.      *\n*                                                                  *\n*        To Execute:   !EDITSUB                                    *\n*                                                                  *\n*        To elimintate the \"!\", in an IMACRO define this macro:    *\n*            DEFINE EDITSUB MACRO PGM                              *\n*                                                                  *\n*        Note:                                                     *\n*        - The SUBMIT Exits Are NOT Called (ie. IKJEFF10).         *\n*        - No \"IKJ56250I JOB jobname(jobid) SUBMITTED\" Message     *\n*        - A single ISPF message indicating the \"LAST\" job number  *\n*          that was submitted is displayed.                        *\n*        - Probably more issues that I haven't encountered.        *\n*                                                                  *\n*        Please send all suggestions/updates to:                   *\n*            zOS.JES2@Gmail.com                                    *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nEDITSUB  #START ,                  Start Procedure                     *\n               AMODE=31,           Execute In 31-Bit Addressing Mode   *\n               BASE=R12,           Define Base Register(s)             *\n               COPY=YES,                                               *\n               RMODE=ANY,          Execute In Any Residency Mode       *\n               WKDSECT=SUBWRK,     Define WorkArea Name                *\n               LOC=BELOW,          WorkArea Acquired Below The Line    *\n               LEVEL=#V01R001      Maintenance Level           #V01R001\n\n*-------\n*        Check If Called From Within ISPF\n*-------\n         LINK  EP=ISPQRY\n         LTR   R15,R15             Check If Within ISPF\n         JZ    EDIT0100            B. If Yes\n         MVC   WRKREC(L'NOTISPF),NOTISPF\n         TPUT  WRKREC,L'NOTISPF    SAY: ISPF IS REQUIRED\n         #SETRC 8                  Set Return Code\n         J     EDITEXIT\n\n*-------\n*        Define ISPF Variables To Be Used\n*-------\nEDIT0100 DS    0H\n         MVC   WRKFUNC,=CL8'LOAD'\n         ISPLINK LOAD,SAVE=WRKLINK@,LIST=WRKPARMS,ERROR=ISPFERR\n\n         MVC   WRKFUNC,=CL8'VDEFINE'\n         ISPLINK VDEFINE,'WRKLAST ',WRKLAST,'FIXED ',L'WRKLAST,        *\n               ERROR=ISPFERR\n         ISPLINK VDEFINE,'WRKLRECL',WRKLRECL,'FIXED',L'WRKLRECL,       *\n               ERROR=ISPFERR\n         ISPLINK VDEFINE,'WRKREC  ',WRKREC,'CHAR ',L'WRKREC,           *\n               ERROR=ISPFERR\n         ISPLINK VDEFINE,'ZEDSMSG ',ZEDSMSG,'CHAR ',L'ZEDSMSG,         *\n               ERROR=ISPFERR\n         ISPLINK VDEFINE,'ZEDLMSG ',ZEDLMSG,'CHAR ',L'ZEDLMSG,         *\n               ERROR=ISPFERR\n\n*-------\n*        Start EDIT MACRO & Obtain Data Set Information\n*-------\n         MVC   WRKFUNC,=CL8'ISREDIT'\n         OI    WRKFLAG,WRK$MAC     Indicate \"EDIT MACRO\" Statement\n         ISPLINK ISREDIT,0,MACRO,ERROR=ISPFERR                         *\n                                   Start \"EDIT MACRO\" Processing\n         NI    WRKFLAG,255-WRK$MAC\n         ISPLINK ISREDIT,0,MACLREC,ERROR=ISPFERR                       *\n                                   Save Logical Record Length\n         ISPLINK ISREDIT,0,MACLAST,ERROR=ISPFERR                       *\n                                   Save Last Line Number\n\n*-------\n*        Allocate & Open The Internal Reader\n*-------\n         ALLOC DDNTO=WRKDDN,SYSOUT=('A','INTRDR'),ERROR=S99FAIL\n\n         MVC   WRKACB(MODACBL),MODACB\n         MVC   WRKRPL(MODRPLL),MODRPL\n         USING IFGACB,WRKACB\n         USING IFGRPL,WRKRPL\n\n         MVC   ACBDDNM,WRKDDN\n         LA    R0,WRKACB\n         ST    R0,RPLDACB\n         LA    R0,WRKREC\n         ST    R0,RPLAREA\n         L     R0,WRKLRECL\n         ST    R0,RPLRLEN\n\n         MVC   WRKOPEN(MODOPENL),MODOPEN\n         OPEN  (WRKACB,(OUTPUT)),MF=(E,WRKOPEN)\n         LTR   R15,R15\n         JZ    *+8\n         EX    0,*                 ABEND S0C3 (Should Never Happen)\n\n*-------\n*        Read A Record At A Time & Submit To The Internal Reader\n*-------\n         XC    WRKLINE,WRKLINE     Initialize Line Counter\nEDIT0200 DS    0H\n         L     R1,WRKLINE\n         AHI   R1,1                Increment Line Number\n         ST    R1,WRKLINE\n         CL    R1,WRKLAST          Check If Last Row Processed\n         JH    EDIT0300            B. If Yes\n         BAL   R14,ISRREAD         Read Next Row Of Data\n         LTR   R15,R15             Check For An Error\n         JNZ   EDITEXIT            B. If Yes\n\n         PUT   RPL=WRKRPL          Output Current Record\n         J     EDIT0200\n\n*-------\n*        Obtain the JES Job Id From The RPL & Close The Internal Reader\n*-------\nEDIT0300 DS    0H\n         ENDREQ RPL=WRKRPL         Get JobNumber\n         MVI   ZEDSMSG,C' '\n         MVC   ZEDSMSG+1(L'ZEDSMSG-1),ZEDSMSG\n         MVI   ZEDLMSG,C' '\n         MVC   ZEDLMSG+1(L'ZEDLMSG-1),ZEDLMSG\n\n         MVC   ZEDSMSG,=CL24'Job ________ Submitted'\n         MVC   ZEDSMSG+4(8),RPLRBAR\n         MVC   ZEDLMSG(8),RPLRBAR\n         MVC   ZEDLMSG+9(47),=C'submitted 000000 records to the interna*\n               l reader'\n         MVC   ZEDLMSG+19(6),WRKCMD+17\n         MVC   WRKFUNC,=CL8'SETMSG'\n         ISPLINK SETMSG,'ISRZ001 ' Set ISPF Error Message\n\n         MVC   WRKCLOSE(MODCLOSEL),MODCLOSE\n         CLOSE (WRKACB),MF=(E,WRKCLOSE)\n\n         MVC   WRKFUNC,=CL8'VDELETE'\n         ISPLINK VDELETE,'*'       Delete Previously Defined Variables\n         LA    R0,WRKDDN\n         ST    R0,WRKDDN@          A(DDName)\n         LHI   R0,L'WRKDDN\n         STH   R0,WRKDDN@+4        L(DDName)\n         FREE  DDN=WRKDDN@         Free The Internal Reader\n\n*-------\n*        Terminate\n*-------\nEDITEXIT #STOP ,                   Terminate\n\n*-------\n*        Obtain A Line From The EDIT Buffer\n*-------\nISRREAD  DS    0H\n         STM   R0,R14,WRKSAVE\n         MVC   WRKCMD,MACREC       Copy \"(WRKREC) = LINE\"\n         L     R1,WRKLINE\n         CVD   R1,WRKDBL1          Convert Line Number To Decimal\n         OI    WRKDBL1+7,X'0F'\n         UNPK  WRKCMD+17(6),WRKDBL1\n\n         MVI   WRKREC,C' '\n         MVC   WRKREC+1(L'WRKREC-1),WRKREC\n\n         MVC   WRKFUNC,=CL8'ISREDIT'\n         ISPLINK ISREDIT,0,WRKCMD,ERROR=ISPFERR\n*                                  Read Next Row\n         LM    R0,R14,WRKSAVE\n         BR    R14                 Return To Caller\n\n*-------\n*        Display Any Dynamic Allocation Error Messages\n*-------\nS99FAIL  DS    0H\n         #SETRC (R15)              Set Return Code\n         S99FAIL MF=(E,WRKFAIL)\n         J     EDITEXIT\n\n*-------\n*        Display An ISPF Error\n*-------\nISPFERR  DS    0H\n         #SETRC (R15)              Set Return Code\n\n         MVI   ZEDSMSG,C' '\n         MVC   ZEDSMSG+1(L'ZEDSMSG-1),ZEDSMSG\n         MVI   ZEDLMSG,C' '\n         MVC   ZEDLMSG+1(L'ZEDLMSG-1),ZEDLMSG\n\n         MVC   ZEDSMSG(8),WRKFUNC\n         MVC   ZEDSMSG+9(6),=CL6'Failed'\n\n         CLC   WRKFUNC,=CL8'ISREDIT'\n         JNE   ISPFE100            B. If Not ISREDIT Request\n         TM    WRKFLAG,WRK$MAC     Check For \"EDIT MACRO\" Statement\n         JZ    ISPFE100            B. If Not\n         MVC   ZEDSMSG(19),=C'''EDIT MACRO'' Failed'\n         MVC   ZEDLMSG(28),=C'Improper Environment or Call'\n         NI    WRKFLAG,255-WRK$MAC\n         J     ISPFE200\n\nISPFE100 DS    0H\n         MVC   ZEDLMSG(34),=C'Function Failed With A Return Code'\n         CVD   R15,WRKDBL1         Convert Return Code To Decimal\n         OI    WRKDBL1+7,X'0F'\n         UNPK  ZEDLMSG+35(4),WRKDBL1\n\nISPFE200 DS    0H\n         MVC   WRKFUNC,=CL8'SETMSG'\n         ISPLINK SETMSG,'ISRZ001 '\n         J     EDITEXIT\n\n*-------\n*        Edit MACRO Model Statements\n*-------\nMACRO    DC    C'\u00a2MACRO\u00a2                         '\nMACLREC  DC    C'\u00a2(WRKLRECL) = DATA_WIDTH\u00a2       '\nMACREC   DC    C'\u00a2(WRKREC) = LINE 000000\u00a2        '\nMACLAST  DC    C'\u00a2(WRKLAST) = LINENUM .ZLAST\u00a2    '\n\n*-------\n*        Constants\n*-------\n         ISPLINK ,                 ISPLINK Keywords/Constants\n\nNOTISPF  DC    C'This Program Requires An ISPF Environment'\n\nMODACB   ACB   DDNAME=X,MACRF=(ADR,SEQ,OUT)\nMODACBL  EQU   *-MODACB\nMODRPL   RPL   ACB=*-*,OPTCD=(ADR,SEQ,SYN,NUP),                        *\n               AREA=*-*,RECLEN=*-*,AREALEN=L'WRKREC\nMODRPLL  EQU   *-MODRPL\nMODOPEN  OPEN  (*-*,(OUTPUT)),MF=L\nMODOPENL EQU   *-MODOPEN\nMODCLOSE CLOSE (*-*),MF=L\nMODCLOSEL EQU  *-MODCLOSE\n\n*-------\n*        Dynamic Work Area\n*-------\n         #STARTWA ,\n         DYNSPACE ,                Dynamic Allocation Area\nWRKACB   DS    0F,XL(MODACBL)      Internal Reader ACB\nWRKCLOSE DS    0F,XL(MODCLOSEL)    Close Parameter List\nWRKCMD   DS    CL32                Edit Macro Command Line Area\nWRKDBL1  DS    D                   DoubleWord Work Area\nWRKDDN   DS    CL8                 SYSOUT DDName\nWRKDDN@  DS    A,AL2               DDName Address & Length\nWRKFAIL  DS    8F                  S99FAIL Parameter List\nWRKFLAG  DS    XL1                 Flag Byte\nWRK$MAC  EQU   BIT0                - \"ISREDIT MACRO\" Statement\n         DS    XL3                 Spare\nWRKFUNC  DS    CL8                 Current ISPF Function\nWRKLAST  DS    F                   Last Line Number\nWRKLINE  DS    F                   Current Line Number\nWRKLINK@ DS    A                   A(ISPLINK/ISREDIT)\nWRKLRECL DS    F                   Current Data Set LRECL\nWRKOPEN  DS    0F,XL(MODOPENL)     Open Parameter List\nWRKPARMS DS    16F                 ISPLINK Parameter List\nWRKREC   DS    CL256               Current ISPF EDIT Record\nWRKRPL   DS    0F,XL(MODRPLL)      Internal Reader RPL\nWRKSAVE  DS    16F                 Register Save Area\n\nZEDSMSG  DS    CL24                ISPF Short Message\nZEDLMSG  DS    CL80                ISPF Long Message\n         #STOPWA ,\n\n*-------\n*        Required DSECTs\n*-------\n         #DSECTS ACB,ALLOC,RPL\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FAMSEXTR": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x00\\xf1\\x00\\xf1\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 241, "newlines": 241, "modlines": 0, "user": "SOURCE"}, "text": "FAMSEXTR #START BASE=(R12),AMODE=31,RMODE=24,COPY=YES\n         USING PSA,0\n\n*---------------------------------------------------------------------*\n*        Initialize HEXDUMP parameters                                *\n*---------------------------------------------------------------------*\n         LOAD  EP=HEXDUMP,         Load the HEX dump formatter         *\n               ERRET=FAMS0700\n         ST    R0,WRKDUMP@         A(\"HEXDUMP\" routine)\n\n         LA    R0,WRKDUMPP+4       A(\"HEXDUMP\" parameters)\n         ST    R0,WRKDUMPP         A(Parameters pointer)\n         MVI   WRKDUMPP+16,X'40'   Request relative Addresses\n         CLC   DCBLRECL-IHADCB+SYSPRINT,=AL2(133)\n         BL    FAMS0200            B. If output Record length < 133\n         MVI   WRKDUMPP+16,X'20'   Indicate 130 byte DUMP output\n\nFAMS0200 DS    0H\n         LA    R0,WRKPRINT+8       A(\"HEXDUMP\" output area)\n         STCM  R0,7,WRKDUMPP+17\n         MVC   WRKPRINT,BLANKS     Clear print area\n\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n\n*---------------------------------------------------------------------*\n*        Locate the FAMS interface routine                            *\n*---------------------------------------------------------------------*\n         L     R15,FLCCVT          A(CVT)\n         L     R15,CVTDFA-CVT(,R15) A(Data Facilities Area)\n         CLC   2(2,R15),=X'3200'   Check for ancient OS\n         BL    FAMS0700            B. If so\n         L     R15,DFADFVAD-DFA(,R15)  DFP Vector table\n         ICM   R15,15,DFVTFMS-DFVT(R15) FAMS Main Entry Point\n         BZ    FAMS0700\n         ST    R15,WRKFAMS@        Save IGWFAMS Routine Address\n\n*---------------------------------------------------------------------*\n*        Read next input record and ignore comments                   *\n*---------------------------------------------------------------------*\nFAMS0300 DS    0H\n         GET   SYSIN               Get input record\n         LR    R10,R1              A(Input record)\n\n         CLI   0(R10),C'*'         Check for comment statement\n         BE    FAMS0300            B. If yes\n         OC    0(80,R10),BLANKS    Ensure Upper Case Data\n\n         CLC   0(4,R10),=C'DSN='\n         BNE   FAMS0390            B. If not a new DSN= statement\n         MVC   WRKDSNAM,4(R10)     Copy new DSN=\n\n         MVC   WRKPRINT+1(80),0(R10)\n         PUT   SYSPRINT,WRKPRINT   Print current line\n         B     FAMS0300            Get Next Record\n\n*---------------------------------------------------------------------*\n*        Format Parameter Lists and call IGWFAMS                      *\n*---------------------------------------------------------------------*\nFAMS0390 DS    0H\n         TM    WRKDSNAM,X'BF'      Check for blanks/nulls\n         BZ    FAMS0300            B. If so (loop till DSN=)\n\n*        Re-initialize parameter list areas\n         XC    FAMSPARM(FAMSPARML),FAMSPARM\n         XC    FAMSFMH(FAMSFMHL),FAMSFMH\n         #BLANK FAMSFMO,LEN=FAMSFMOL,PAD=X'00'\n         XC    FAMSLIST,FAMSLIST\n         XC    FAMPTRL(FAMPTRLL),FAMPTRL\n\n*        Call  IGWFAMS    (IGWAMSP0)\n         MVC   FAMSFMH(8),=CL8'IGWFMH'\n         MVC   FAMSFMH+8(4),=A(FAMSFMHL)\n         MVC   FAMSFMH+12(4),=X'01000000'  Version\n         MVC   FAMSFMH+16(4),=X'00010068'  Getattr\n         MVC   FAMSFMH+20(4),=X'00000400'\n         LA    R0,WRKDSNL\n         ST    R0,FAMSFMH+24\n         MVC   FAMSFMH+60(4),=X'80000000'\n\n         MVC   FAMSFMH+116(4),=A(1)\n         LA    R0,FAMSLIST\n         ST    R0,FAMSFMH+120\n\n         ST    R10,FAMPTRL+8\n         LA    R0,FAMPTRL\n         ST    R0,FAMSLIST+0\n\n         MVC   FAMSFMO(8),=CL8'IGWFMO'\n         MVC   FAMSFMO+8(4),=A(FAMSFMOL)\n         MVC   FAMSFMO+12(4),=X'01000000'  Version\n\n*        CALL IGWFAMS\n         LA    R1,FAMSPARM         A(Parameter list)\n         LA    R0,FAMSFMH\n         ST    R0,0(,R1)\n         LA    R0,FAMSFMO\n         ST    R0,4(,R1)\n         L     R15,WRKFAMS@        A(IGWFAMS)\n         BASSM R14,R15\n         #SETRC (R15),FIELD=FAMSRC Save highest return code\n         LTR   R15,R15             Check if call was successful\n         BZ    FAMS0400            B. If so\n\n*        Issue Error Message\n         MVC   WRKMSG01+1(8),0(R10)\n         L     R14,WRKFAMS@\n         MVC   WRKMSG01+26(8),5(R14)\n         STM   R15,R0,WRKDBL1      Save return & reason codes\n         MVI   WRKMSG01+42,C''''\n         UNPK  WRKMSG01+43(9),WRKDBL1(5)\n         TR    WRKMSG01+43(8),WRKTABLE-C'0'\n         MVI   WRKMSG01+51,C''''\n         MVI   WRKMSG01+61,C''''\n         UNPK  WRKMSG01+62(9),WRKDBL1+4(5)\n         TR    WRKMSG01+62(8),WRKTABLE-C'0'\n         MVI   WRKMSG01+70,C''''\n         PUT   SYSPRINT,WRKMSG01\n         B     FAMS0300\n\n*---------------------------------------------------------------------*\n*        Print the extracted information                              *\n*---------------------------------------------------------------------*\nFAMS0400 DS    0H\n         ICM   R2,15,FAMPTRL+20    A(Returned data)\n         BZ    FAMS0500\n         ICM   R3,15,FAMPTRL+16    L(Returned data)\n         BZ    FAMS0500\n         BAL   R14,DUMPIT          Dump the returned data\n         B     FAMS0300\n\n*        No Data Returned\nFAMS0500 DS    0H\n         MVC   WRKPRINT+1(8),0(R10)  Insert extract field name\n         PUT   SYSPRINT,WRKPRINT   Print current line\n         MVC   WRKPRINT,BLANKS     Clear print area\n         B     FAMS0300\n\n*---------------------------------------------------------------------*\n*        TERMINATE                                                    *\n*---------------------------------------------------------------------*\nFAMS0600 DS    0H\n         ICM   R15,15,WRKDUMP@     A(\"HEXDUMP\" routine)\n         BZ    FAMSEXIT            B. If routine was not loaded\n         DELETE EP=HEXDUMP         Delete the HEX dump formatter\n         B     FAMSEXIT\n\nFAMS0700 DS    0H\n         #SETRC 99,FIELD=FAMSRC    Set \"FATAL\" error code\n\nFAMSEXIT DS    0H\n         CLOSE (SYSIN,,SYSPRINT)\n         L     R15,FAMSRC          Load Return Code\n         #STOP RC=(R15)            Terminate\n\n*---------------------------------------------------------------------*\n*        Print the field data in HEX                                  *\n*---------------------------------------------------------------------*\nDUMPIT   DS    0H\n         STM   R0,R15,WRKSAVE      Save all registers\n         ST    R2,WRKDUMPP+4       A(1ST byte to print)\n         SHI   R3,1                Back up 1 byte\n         AR    R3,R2               A(last byte to print)\n         ST    R3,WRKDUMPP+8\n\n         XC    WRKDUMPP+12(4),WRKDUMPP+12\n         NI    WRKFLAG,255-WRK$NAME\n\nDUMP0100 DS    0H\n         LA    R1,WRKDUMPP         A(HEXDUMP parameter list pointer)\n         ICM   R15,15,WRKDUMP@     A(HEXDUMP routine)\n         BZ    DUMPEXIT            B. If routine was not loaded\n         BALR  R14,R15             Format a line of data\n\n         TM    WRKFLAG,WRK$NAME    Check if 1ST line has been printed\n         BO    DUMP0200            B. If yes\n         OI    WRKFLAG,WRK$NAME    Remember 1ST line has been printed\n         MVC   WRKPRINT+1(8),0(R10)\n\nDUMP0200 DS    0H\n         PUT   SYSPRINT,WRKPRINT   Print current line\n         MVC   WRKPRINT,BLANKS     Clear print area\n         CLC   WRKDUMPP+4(4),WRKDUMPP+8\n         BNH   DUMP0100            B. If more data to be printed\n\nDUMPEXIT DS    0H\n         LM    R0,R15,WRKSAVE      Restore all registers\n         BR    R14                 Return to caller\n\n*---------------------------------------------------------------------*\n*        Work areas and constants                                     *\n*---------------------------------------------------------------------*\n         #EXEC ,                   Executed statements\n         LTORG ,                   Literal pool\n\nBLANKS   DC    256C' '             Lots of blanks\nDCBEXIT  #DCBEXIT LRECL=133        DCB Open exit\nDCBEXIT@ DC    X'85',AL3(DCBEXIT)  DCB Open exit address\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,                *\n               MACRF=GL,EODAD=FAMS0600\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,                     *\n               MACRF=PM,EXLST=DCBEXIT@\n\nFAMSRC   DC    F'0'                Return code\n\nFAMSPARM DS    3F\nFAMSPARML EQU  *-FAMSPARM\nFAMSFMH  DS    0F,XL136\nFAMSFMHL EQU   *-FAMSFMH\nFAMSFMO  DS    0F,XL1104\nFAMSFMOL EQU   *-FAMSFMO\nFAMSLIST DS    F\nFAMPTRL  DS    6F\nFAMPTRLL EQU   *-FAMPTRL\n\nWRKFAMS@ DS    A\nWRKDBL1  DC    D'0'                Doubleword work area\nWRKDSNL  DC    AL2(L'WRKDSNAM)\nWRKDSNAM DC    CL44' '\nWRKDUMP@ DC    A(*-*)              HEXDUMP ROUTINE ADDRESS\nWRKDUMPP DC    A(*+4)              POINTER TO HEXDUMP PARAMETER LIST\n         DS    A               +4  STARTING ADDRESS OF DUMP STORAGE\n         DS    A               +8  LAST BYTE ADDRESS OF DUMP STORAGE\n         DS    A               +12 RELATIVE ADDRESS (OPTIONAL)\n         DS    X'40'           +16 DUMP OPTIONS (RELATIVE & 130 BYTES)\n*              X'80'               - PRINT ABSOLUTE STORAGE ADDRESS\n*              X'40'               - PRINT RELATIVE STORAGE ADDRESS\n*              X'20'               - PRINT 130 BYTES PER LINE (ON)\n*                                    PRINT  80 BYTES PER LINE (OFF)\n         DS    AL3             +17 OUTPUT BUFFER ADDRESS\nWRKFLAG  DC    X'00'              FLAG BYTE\nWRK$ACB  EQU   BIT0               - PARM=CATACB WAS SPECIFIED\nWRK$NAME EQU   BIT1               - NAME HAS BEEN DISPLAYED\nWRKMSG01 DC    CL134' ________ - *** ERROR *** ________ - R15=X\"_______*\n               _\" REASON=X\"________\"'\nWRKPRINT DS    CL256               Print area\nWRKSAVE  DC    18F'0'              Subroutine save area\nWRKTABLE DC    C'0123456789ABCDEF' HEX Translate table\n         #DSECTS CATLG,CVT,DCB,PSA\n         IHADFA ,\n         IHADFVT ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HELP": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x19 \\x9f\\x01\\x19 \\x9f\\x142\\x01\\xf1\\x01\\xf1\\x00\\x00\\xe7\\xd4\\xc9\\xe3\\xc6\\xd4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-28T00:00:00", "modifydate": "2019-07-28T14:32:02", "lines": 497, "newlines": 497, "modlines": 0, "user": "XMITFMT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "HEXDUMP": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12'\\x01\\x91\\x01\\x91\\x00\\x01\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:27:00", "lines": 401, "newlines": 401, "modlines": 1, "user": "SOURCE"}, "text": "HEXDUMP  TITLE 'H E X D U M P  - STORAGE DUMP FORMAT ROUTINE'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n***********************************************************************\n*                *                                                    *\n*  H E X D U M P *                                                    *\n*                *                                                    *\n***********************************************************************\n*                                                                     *\n*   FUNCTION - THIS SUBROUTINE PROVIDES A FORMATTED DUMP OF STORAGE,  *\n*              WITH BOTH A HEX AND CHARACTER DISPLAY IN THE AMASPZAP  *\n*              FORMAT. THE PRINT LINE CAN BE FORMATED FOR AN 80 BYTE  *\n*              LINE FOR TERMINALS, OR A 130 BYTE LINE FOR PRINTED     *\n*              MATTER.  THIS IS CONTROLLED BY A SWITCH.  ALSO, THE    *\n*              PROVISION FOR PRINTING THE ABSOLUTE STORAGE ADDRESS    *\n*              AND/OR A RELATIVE ADDRESS, WHOSE STARTING VALUE IS     *\n*              SUPPLIED IN THE PARAMETER LIST.  THIS SUBROUTINE       *\n*              PASSES THE FORMATED LINE IN THE BUFFER SUPPLIED BY     *\n*              THE CALLER.  THE ROUTINE SHOULD BE REINVOLKED UNTIL    *\n*              THE STARTING ADDRESS IN THE PARAMETER LIST EQUALS OR   *\n*              EXCEEDS THE END ADDRESS.                               *\n*                                                                     *\n*   ENTRY -   STANDARD SUBROUTINE LINKAGE                             *\n*                                                                     *\n*                       +0 4 BYTE START ADDRESS FOR DUMP              *\n*                       +4 4 BYTE ADDRESS OF LAST BYTE FOR DUMP       *\n*                       +8 4 BYTE RELATIVE ADDRESS (OPTIONAL)         *\n*                      +12 1 BYTE OF SWITCHES                         *\n*                          X'80' PRINT ABSOLUTE STORAGE ADDRESS ON    *\n*                                EACH LINE OF DUMP                    *\n*                          X'40' PRINT RELATIVE STORAGE ADDRESS ON    *\n*                                EACH LINE OF DUMP                    *\n*                          X'20' PRINT LINE IS 130 BYTES WIDE (ON)    *\n*                                OTHERWISE IT IS 80 BYTES WIDE        *\n*                     +13 3 BYTE ADDRESS OF BUFFER                    *\n*                                                                     *\n*   EXIT PARAMETERS NORMAL -  PARAMETER LIST START AND RELATIVE ADDRE *\n*                             INCREMENTED BY NO OF BYTES PROCESSED.   *\n*                             ALL REGISTERS RESTORED.                 *\n*                                                                     *\n*   EXIT PARAMETERS ABNORMAL - NONE                                   *\n*                                                                     *\n*   REGISTER USAGE - R0  -  USED                                      *\n*                    R1  -  PARM LIST POINTER                         *\n*                    R2  -  CURRENT DATA ADDRESS                      *\n*                    R3  -  LENGTH OF LINE LEFT TO FORMAT             *\n*                    R4  -  RELATIVE ADDRESS                          *\n*                    R5  -  BUFFER ADDRESS                            *\n*                    R6  -  CURRENT BUFFER SLOT ADDRESS               *\n*                    R7  -  WORK REGISTER                             *\n*                    R8  -  WORK REGISTER                             *\n*                    R9  -  USED FOR SAVING CALLERS MODE              *\n*                    R10 -  FREE                                      *\n*                    R11 -  FREE                                      *\n*                    R12 -  FREE                                      *\n*                    R13 -  CALLER'S SAVE AREA ADDRESS                *\n*                    R14 -  RETURN ADDRESS                            *\n*                    R15 -  ENTRY POINT ADDRESS AND BASE              *\n*                                                                     *\n*   ATTRIBUTES -   REENTRANT                                          *\n*                                                                     *\n*   CONTROL BLOCK DEPENDENCIES - NONE                                 *\n*                                                                     *\n*   ROUTINES CALLED - NONE                                            *\n*                                                                     *\n*   ABEND CODES -  NONE                                               *\n*                                                                     *\n*   MESSAGES ISSUED - NONE                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        HISTORY:                                                     *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nHEXDUMP  #START REG1=R3,AMODE=CAP31,WKDSECT=HEXWORK\n\n         L     R1,0(0,R3)               >>---> PARAMETER LIST\n         NI    0(R1),FF-BIT0            ENSURE HIGH ORDER BIT\n         NI    4(R1),FF-BIT0            ENSURE HIGH ORDER BIT\n         LM    R2,R4,0(R1)         LOAD START/LAST/RELATIVE ADDRESSES\n         SLR   R5,R5                    CLEAR BEFORE INSERT\n         ICM   R5,B'0111',13(R1)        LOAD BUFFER ADDRESS\n         LA    R3,1(0,R3)               >>---> PAST LAST BYTE\n         LR    R6,R5                    >>---> BUFFER\n         MVI   0(R5),C' '               INSERT PAD CHARACTER\n         TM    12(R1),BIT2              CHECK IF 130 BYTE BUFFER\n         BO    DUMPL130\n         MVC   1(79,R5),0(R5)           CLEAR FIRST 80 BYTES\n         B     DUMP10\n\nDUMPL130 MVC   1(129,R5),0(R5)          CLEAR FIRST 130 BYTES\n\n***********************************************************************\n* CHECK THE PARAMETERS IF RELATIVE ADDRESS OPTION WAS SPECIFIED, THEN *\n* BRANCH ACCORDINGLY.                                                 *\n***********************************************************************\n\nDUMP10   DS    0H\n         TM    12(R1),BIT1         CHECK FOR RELATIVE ADDRESS REQUEST\n         BZ    DUMP20\n         LTR   R4,R4               CHECK FOR NEGATIVE RELATIVE ADDRESS\n         BNM   DUMP11\n         LCR   R4,R4                    LOAD COMPLEMENT OF ADDRESS\n         ST    R4,8(0,R1)               SAVE COMPLIMENT FOR UNPACK\n         LCR   R4,R4                    RESTORE REGISTER 4\n\n***********************************************************************\n* UNPACK THE HEX DIGITS AND SURPRESS 5 LEADING ZEROS.                 *\n***********************************************************************\n\nDUMP11   DS    0H\n         UNPK  2(7,R6),9(4,R1)          SPREAD HEX DIGITS\n         MVI   8(R6),C' '               BLANK EXTRA DIGIT\n         TR    2(6,R6),HEXTAB2          MAKE HEX DIGITS PRINTABLE\n         LA    R8,5                     SUPPRESS 5 LEADING ZEROES\n         LA    R7,2(0,R6)               POINT TO FIRST DIGIT\n\n***********************************************************************\n* IF MORE LEADING ZEROS ARE PRESENT, THEN SURPRESS THEM AND SET       *\n* RELATIVE SWITCH ON.                                                 *\n***********************************************************************\n\nDUMP12   DS    0H\n         CLI   0(R7),C'0'               HAVE WE A LEADING ZERO?\n         BNE   DUMP14                   NO, HAVE A SIG DIGIT\n         MVI   0(R7),C' '               BLANK OUT THE LEADING ZERO\n         LA    R7,1(0,R7)               POINT TO NEXT CHARACTER\n         BCT   R8,DUMP12                REPEAT 4 MORE TIMES\nDUMP14   BCTR  R7,0                     BACK UP BY 1\n         MVI   0(R7),C'+'               INDICATE A RELATIVE ADDRESS\n         LTR   R4,R4                    TEST RELATIVE ADDRESS\n         BNM   DUMP16                   BRANCH IF POSITIVE\n         MVI   0(R7),C'-'               ELSE INDICATE REL ADDR NEG\nDUMP16   DS    0H\n         LA    R6,8(0,R6)               BUMP UP BUFFER POINTER\n\n***********************************************************************\n* CHECK IF THE ABSOLUTE ADDRESS OPTION WAS SPECIFIED, AND BRANCH      *\n* ACCORDINGLY.                                                        *\n***********************************************************************\n\nDUMP20   DS    0H\n         TM    12(R1),BIT0              ABSOLUTE ADDRESS REQUIRED?\n         BZ    DUMP30                   NO, SKIP\n         UNPK  1(9,R6),0(5,R1)          SPREAD HEX DIGITS OF ABS ADDR\n         TR    1(8,R6),HEXTAB2          MAKE HEX DIGITS PRINTABLE\n         MVI   9(R6),C' '               PAD\n         LA    R6,9(0,R6)               UPDATE BUFFER POINTER\n\n***********************************************************************\n* TEST OUTPUT LENGTH SPECIFIED AND BRANCH ACCORDINGLY TO FORMAT       *\n* OUTPUT.                                                             *\n***********************************************************************\n\nDUMP30   DS    0H\n         LA    R6,2(0,R6)               ADD PADDING CHARACTERS\n         USING BUFDSECT,R6              MAP BUFFER\n         SR    R3,R2                    GET LENGTH OF DATA LEFT\n         TM    12(R1),BIT2              WAS 130 BYTE BUFFER WANTED?\n         BO    DUMP50                   YES, BRANCH\n\n***********************************************************************\n* IF OUTPUT LENGTH IS 80 CHARACTERS THEN SET SWITCH AND MOVE DATA     *\n* INTO BUFFER CONVERTING THE HEX DIGITS INTO PRINTABLE FORM IF        *\n* POSSIBLE AND TO DOTS IF UNPRINTABLE.                                *\n***********************************************************************\n\n         LA    R8,4                     INDICATE 80 BYTE BUFFER\n         MVI   BL80HEX,C'*'             FORMAT CHARACTER DISPLAY\n         MVI   BL80HEX+17,C'*'\n         CL    R3,=A(16)                TEST LENGTH LEFT TO DO\n         BNL   DUMP40                   BRANCH IF >= 16\n         AR    R4,R3                    UPDATE RELATIVE ADDR\n         #EXEC -R3,MVC,BL80HEX+1(*-*),0(R2)\n         #EXEC R3,TR,BL80HEX+1(*-*),HEXTAB1\n         LA    R3,1(0,R3)               RESTORE LENGTH\n         B     DUMP60\n\nDUMP40   MVC   BL80HEX+1(16),0(R2)      MOVE DATA TO LINE\n         TR    BL80HEX+1(16),HEXTAB1    CONVERT UNPRINTABLES TO DOTS\n         A     R4,=A(16)                UPDATE REL ADDR (CAN'T USE LA)\n         B     DUMP60\n\n***********************************************************************\n* IF OUTPUT LENGTH IS 130 CHARACTERS THEN SET SWITCH AND MOVE DATA    *\n* INTO BUFFER CONVERTING HEX DIGITS INTO PRINTABLE FORM IF POSSIBLE   *\n* AND INTO DOTS IF NOT POSSIBLE.                                      *\n***********************************************************************\n\nDUMP50   DS    0H                       130 BYTE BUFFER\n         LA    R8,8                     INDICATE 80 BYTE BUFFER\n         MVI   BL130HEX,C'*'            FORMAT CHARACTER DISPLAY\n         MVI   BL130HEX+33,C'*'\n         CL    R3,=A(32)                TEST LENGTH LEFT TO DO\n         BNL   DUMP55                   BRANCH IF >= 32\n         AR    R4,R3                    UPDATE RELATIVE ADDR\n         #EXEC -R3,MVC,BL130HEX+1(*-*),0(R2)\n         #EXEC R3,TR,BL130HEX+1(*-*),HEXTAB1\n         LA    R3,1(0,R3)               RESTORE LENGTH\n         B     DUMP60\n\nDUMP55   MVC   BL130HEX+1(32),0(R2)     MOVE DATA TO LINE\n         TR    BL130HEX+1(32),HEXTAB1   CONVERT UNPRINTABLES TO DOTS\n         A     R4,=A(32)                UPDATE REL ADDR (CAN'T USE LA)\n\n***********************************************************************\n* CHECK IF 5 OR MORE BYTES LEFT IN BUFFER AND BRANCH ACCORDINGLY TO   *\n* FILL BUFFER COMPLETELY.                                             *\n***********************************************************************\n\nDUMP60   DS    0H\n         CL    R3,=A(5)                 AT LEAST 5 BYTES LEFT?\n         BL    DUMP80                   NO\n\n***********************************************************************\n* FIVE OR MORE BYTES LEFT IN BUFFER, THEN FILL 4 AT A TIME UNTIL LESS *\n* THEN 5 BYTES ARE LEFT, THEN BRANCH ACCORDINGLY TO FILL BUFFER.      *\n***********************************************************************\n\n         UNPK  0(9,R6),0(5,R2)          UNPACK 4 BYTES\n         TR    0(8,R6),HEXTAB2          CONVERT TO PRINTABLE HEX\n         LA    R2,4(0,R2)               BUMP UP DATA POINTER\n         MVI   8(R6),C' '               ALLOW ONE PADDING BLANK\n         LA    R6,9(0,R6)               BUMP UP BUFFER POINTER\n         SL    R3,=A(4)                 DECREMENT LENGTH LEFT TO DO\n         CL    R8,=A(5)                 FIRST FOUR WORDS OUT ?\n         BNE   *+8                      NO, SKIP\n         LA    R6,1(0,R6)               YES, EXTRA SPACE\n         BCT   R8,DUMP60                CONVERT IF SPACE LEFT ON LINE\n         B     DUMPEXIT                 ELSE HAVE DONE OUR JOB\n\n***********************************************************************\n* CHECK THE NUMBER OF BYTES LEFT TO FILL AND BRANCH ACCORDINGLY TO    *\n* FILL BUFFER COMPLETELY. IF FULL THEN BRANCH TO END PROGRAM.         *\n***********************************************************************\n\nDUMP80   DS    0H\n         SLL   R3,2                     GET A BRANCH INDEX\n         B     *+4(R3)                  USE A BRANCH TABLE\n         B     DUMPEXIT                 NO MORE BYTES LEFT\n         B     DUMPL1                   ONE BYTE LEFT\n         B     DUMPL2                   TWO BYTES LEFT\n         B     DUMPL3                   3 BYTES LEFT\n\n***********************************************************************\n* FOUR BYTES LEFT TO FILL, FILL IT AND BRANCH TO END PROGRAM.         *\n***********************************************************************\n\nDUMPL4   DS    0H\n         MVC   12(4,R13),0(R2)          MOVE IN LAST 4 BYTES\n         UNPK  0(9,R6),12(5,R13)        SPREAD OUT HEX DIGITS\n         TR    0(8,R6),HEXTAB2          CONVERT TO PRINTABLE HEX\n         LA    R2,4(0,R2)               BUMP UP DATA PTR\n         MVI   8(R6),C' '               PAD\n         B     DUMPEXIT                 DUMP COMPLETE\n\n***********************************************************************\n* THREE BYTES LEFT TO FILL, FILL IT AND BRANCH TO END PROGRAM.        *\n***********************************************************************\n\nDUMPL3   DS    0H\n         MVC   12(3,R13),0(R2)          MOVE IN LAST 3 BYTES\n         UNPK  0(7,R6),12(4,R13)        SPREAD OUT HEX DIGITS\n         TR    0(6,R6),HEXTAB2          CONVERT TO PRINTABLE HEX\n         LA    R2,3(0,R2)               BUMP UP DATA PTR\n         MVI   6(R6),C' '               PAD\n         B     DUMPEXIT                 DUMP COMPLETE\n\n***********************************************************************\n* TWO BYTES LEFT TO FILL, FILL IT AND BRANCH TO END PROGRAM.          *\n***********************************************************************\n\nDUMPL2   DS    0H\n         MVC   12(2,R13),0(R2)          MOVE IN LAST 2 BYTES\n         UNPK  0(5,R6),12(3,R13)        SPREAD OUT HEX DIGITS\n         TR    0(4,R6),HEXTAB2          CONVERT TO PRINTABLE HEX\n         LA    R2,2(0,R2)               BUMP UP DATA PTR\n         MVI   4(R6),C' '               PAD\n         B     DUMPEXIT                 DUMP COMPLETE\n\n***********************************************************************\n* ONE BYTE LEFT TO FILL, FILL IT AND BRANCH TO END PROGRAM.           *\n***********************************************************************\n\nDUMPL1   DS    0H\n         MVC   12(1,R13),0(R2)          MOVE IN LAST 1 BYTE\n         UNPK  0(3,R6),12(2,R13)        SPREAD OUT HEX DIGITS\n         TR    0(2,R6),HEXTAB2          CONVERT TO PRINTABLE HEX\n         LA    R2,1(0,R2)               BUMP UP DATA PTR\n         MVI   2(R6),C' '               PAD\n\n***********************************************************************\n* PROGRAM IS FINISHED, RESTORE REGISTERS, AND PASS OUTPUT BUFFER BACK *\n* TO CALLER.                                                          *\n***********************************************************************\n\nDUMPEXIT DS    0H\n         ST    R2,0(0,R1)               SAVE NEW DATA POINTER\n         ST    R4,8(0,R1)               SAVE NEW RELATIVE ADDRESS\n\n         #STOP ,                        RETURN\n\n         CNOP  0,8\nHEXTAB1  DC    256C'.'\n         ORG   HEXTAB1+X'81'                                   #DD99292\n         DC    9AL1(*-HEXTAB1)      LOWER CASE A-I             #DD99292\n         ORG   HEXTAB1+X'91'                   J-R             #DD99292\n         DC    9AL1(*-HEXTAB1)                 S-Z             #DD99292\n         ORG   HEXTAB1+X'A2'                                   #DD99292\n         DC    9AL1(*-HEXTAB1)                                 #DD99292\n         ORG   HEXTAB1+C' '\n         DC    C' '\n         ORG   HEXTAB1+C'<'\n         DC    C'<'\n         ORG   HEXTAB1+C'('\n         DC    C'('\n         ORG   HEXTAB1+C'+'\n         DC    C'+'\n         ORG   HEXTAB1+C'|'\n         DC    C'|'\n         ORG   HEXTAB1+C'&&'\n         DC    C'&&'\n         ORG   HEXTAB1+C'!'\n         DC    C'!'\n         ORG   HEXTAB1+C'$'\n         DC    C'$'\n         ORG   HEXTAB1+C'*'\n         DC    C'*'\n         ORG   HEXTAB1+C')'\n         DC    C')'\n         ORG   HEXTAB1+C';'\n         DC    C';'\n         ORG   HEXTAB1+C'\u00ac'\n         DC    C'\u00ac'\n         ORG   HEXTAB1+C'-'\n         DC    C'-'\n         ORG   HEXTAB1+C'/'\n         DC    C'/'\n         ORG   HEXTAB1+C','\n         DC    C','\n         ORG   HEXTAB1+C'%'\n         DC    C'%'\n         ORG   HEXTAB1+C'_'\n         DC    C'_'\n         ORG   HEXTAB1+C'>'\n         DC    C'>'\n         ORG   HEXTAB1+C'?'\n         DC    C'?'\n         ORG   HEXTAB1+C':'\n         DC    C':'\n         ORG   HEXTAB1+C'#'\n         DC    C'#'\n         ORG   HEXTAB1+C'@'\n         DC    C'@'\n         ORG   HEXTAB1+C''''\n         DC    C''''\n         ORG   HEXTAB1+C'='\n         DC    C'='\n         ORG   HEXTAB1+C'\"'\n         DC    C'\"'\n         ORG   HEXTAB1+C'{'\n         DC    C'{'\n         ORG   HEXTAB1+C'A'\n         DC    9AL1(*-HEXTAB1)\n         ORG   HEXTAB1+C'}'\n         DC    C'}'\n         ORG   HEXTAB1+C'J'\n         DC    9AL1(*-HEXTAB1)\n         ORG   HEXTAB1+C'S'\n         DC    8AL1(*-HEXTAB1)\n         ORG   HEXTAB1+C'0'\n         DC    10AL1(*-HEXTAB1)\n         ORG   ,\n\n         ORG   *-C'0'\nHEXTAB2  DS    0H\n         ORG   *+C'0'\n         DC    C'0123456789ABCDEF'\n\n         #STARTWA ,\n         #STOPWA ,\n\nBUFDSECT DSECT ,R6\n         ORG   BUFDSECT+(4*9)+2\nBL80HEX  DS    0C\n         ORG   BUFDSECT+(8*9)+2\nBL130HEX DS    0C\n\n         #DSECTS CVT\n         IEZBITS ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFACTRT": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x00\\xc0\\x00\\xc0\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 192, "newlines": 192, "modlines": 0, "user": "SOURCE"}, "text": "*-------\n*\n*        Check if a STEPLIB was created by the TSO STEPLIB command\n*\n*-------\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\n$TEPTERM #START AMODE=31,RMODE=ANY,                                    *\n               BASE=RELATIVE,                                          *\n               CONSTANT=R12,                                           *\n               COPY=YES,                                               *\n               WKDSECT=$TEPWRK,SP=230,LOC=BELOW,STORAGE=YES,           *\n               REG1=R8,                                                *\n               USING=(PSA,0,PLIST,R8),                                 *\n               #REGS=BOTH,         Define Standard & AR Registers      *\n               LEVEL=#V001R00      Mainteinence Level          #DD16124\n\n*-------\n*        Check For \"Step Total\" (Step Term) IEFACTRT Call\n*-------\n         CHI   R0,X'14'            Check For \"Job/Step Term\"\n         JNE   TRT00400            B. If Not\n         ICM   R10,15,P1SMF        A(SMF 30 Record)\n         JZ    TRT00400            B. If Not Available\n         USING SMFRCD30,R10\n\n         CLC   SMF30STP,=AL2(4)    \"Step Total\" Call ?\n         JNE   TRT00400            B. If Not\n         DROP  R10\n\n*-------\n*        Check If This Is A BATCH Job\n*-------\n         ICM   R15,15,PSATOLD      A(TCB)\n         JZ    TRT00400            B. If Not Available\n         USING TCB,R15\n         ICM   R14,15,TCBJSCB      A(JSCB)\n         JZ    TRT00400            B. If Not Available\n         USING IEZJSCB,R14\n         ICM   R14,15,JSCBACT      A(Active JSCB)\n         JZ    TRT00400            B. If Not Available\n         ICM   R14,15,JSCBSSIB     A(SSIB)\n         JZ    TRT00400            B. If Not Available\n         USING SSIB,R14\n\n         CLI   SSIBJBID,C'J'       Check For Batch Job\n         JNE   TRT00400            B. If Not\n\n         DROP  R14,R15\n\n*-------\n*        Check Level Of Operating System\n*-------\n         L     R15,FLCCVT          A(CVT)\n         USING CVTMAP,R15\n         TM    CVTOSLV5,CVTZOS_V1R12\n         JZ    TRT00100            B. If Not z/OS R1.12 or >\n         OI    WRKFLAG1,WRK$R112   Set z/OS R1.12 flag\n         DROP  R15\n\n*-------\n*        Check If There Is Currently A Dynamic STEPLIB Allocated\n*-------\nTRT00100 DS    0H\n         ICM   R4,15,PSATOLD       A(TCB)\n         JZ    TRT00400            B. If Not Available\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         JZ    TRT00400            B. If One Does Not Exist\n         USING DCB,R2\n\n         TM    DCBOFLGS,DCBOFOPN   Check If STEPLIB is OPEN\n         JZ    TRT00200            B. If Not\n         MVC   WRKCLOSE,MODLCLOS   Format Close Parameter List\n         CLOSE ((R2)),MF=(E,WRKCLOSE)\n\nTRT00200 DS    0H\n         CLC   =C'$TEP',DCBDDNAM   Check For $TEPnnnn DDName\n         JNE   TRT00400            B. If Not\n         MVC   WRKDDNM,DCBDDNAM    Save STEPLIB DDName\n         DROP  R2\n\n*-------\n*        Release The STEPLIB Storage\n*-------\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >\n         JNO   TRT00300            B. If Not\n         AHI   R3,MODDCBEL         Add DCBE Length\n\nTRT00300 DS    0H\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),                 *\n               CALLRKY=YES,TCBADDR=TCBJSTCB\n         DROP  R4\n\n         MVC   MSGBUFF(MSG0001L),MSG0001\n         MVC   MSG0001A+MSGBUFF,WRKDDNM\n         #ICALL QMESSAGE           Write Message To SYSMSGS\n\n*-------\n*        Terminate\n*-------\nTRT00400 DS    0H\n         ICM   R0,15,@TB723\n         JZ    TRTEXIT\n         DELETE EP=IEFTB723\n         XC    @TB723,@TB723\n\nTRTEXIT  #STOP RC=0                Terminate Exit Routine\n         TITLE 'QMESSAGE - CALL IEFTB723'\n*-------\n*        CALL IEFTB723 TO QUEUE MESSAGE TO SYSMSGS.\n*-------\nQMESSAGE #IPROC ,\n         ICM   R0,15,@TB723        IEFTB723 AVAILABLE?\n         JNZ   QMSG0100            B. IF NOT\n         LOAD  EP=IEFTB723,ERRET=QMSGEXIT\n         ST    R0,@TB723           Save IEFTB723 Address\n\nQMSG0100 DS    0H\n         L     R14,PSATOLD         A(TCB)\n         USING TCB,R14\n         L     R14,TCBTCT          A(TCT)\n         USING SMFTCT,R14\n         L     R14,TCTLCTAD        A(LCT)\n         USING LCT,R14\n         LA    R1,MSGBUFF+2        Set Address Of Message\n         ST    R1,LCTPARM1\n         LH    R15,MSGBUFF         Set Length Of Message\n         STH   R15,LCTPARM2+2\n\n         LR    R5,R12              Save R12\n         LR    R12,R14             A(LCT)\n         L     R15,@TB723          Call IEFTB723 To Queue\n         BASSM R14,R15             . Message To JESYSMSG\n         LR    R12,R5              Restore R12\n\nQMSGEXIT #IPEND ,\n\n         #CON  START\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n\nMODLDCB  DCB   DDNAME=*,DSORG=PO,RECFM=U,MACRF=E\n         DS    F                   DCB Exit List (ALA IEFSD164)\nMODLDCBL EQU   *-MODLDCB           DCB Length\n\nMODDCBE  DCBE  EADSCB=OK\nMODDCBEL EQU   *-MODDCBE           DCBE Length\n\nMODLCLOS CLOSE (*-*),MF=L          Close Parameter List\nMODLCLOL EQU   *-MODLCLOS\n\nMSG0001  DC    AL2(L'MSG0001T)\nMSG0001T DC    C'$TEP001I ________ closed and storage released.'\nMSG0001A EQU   2+9,8               Insert Offset & Length\nMSG0001L EQU   *-MSG0001\n\n         #CON  END,PATCH=NO\n\n         #STARTWA ,\n         #IPROC MODE=DEFINE\n\nWRKFLAG1 DS    XL1                 Flag Byte #1\nWRK$R112 EQU   BIT0   1... ....    - System is z/OS R1.12 or >\n         DS    XL3\n\n@TB723   DS    A                   A(IEFTB723 Routine)\nWRKDDNM  DS    CL8                 STEPLIB DDName\nWRKCLOSE DS    XL(MODLCLOL)        Close Paramter List\nMSGBUFF  DS    H,XL133             Formatted Message Buffer\n         #STOPWA ,\n\nPLIST    DSECT ,\nP1JMR    DS    A   1    +0         Address Of JMR\nP1STEPNM DS    A   2    +4         Address Of Step Name, Or Zero\nP1PGMRNM DS    A   3    +8         Address Of Programmer Name\nP1JCPU   DS    A   4   +12         Address Of Job CPU/Acct Data\nP1JACCT  DS    A   5   +16         Address Of Job Acct Fields\nP1SCPU   DS    A   6   +20         Address Of Step CPU/Acct Data\nP1SACCT  DS    A   7   +24         Address Of Step Acct Fields\nP1FLAGS  DS    A   8   +28         Address Of 2 Flag/Status Bytes\nP1CMPC   DS    A   9   +32         Address Of Completion Code\nP1SMF    DS    A  10   +36         Address Of SMF Record\n\n         #DSECTS CVT,DCB,JMR,JSCB,LCT,PSA,SSIB,TCB,TCT\n         IFASMFR 30\n         PRINT NOGEN\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFUJV": {"ttr": 4868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x04\\xaa\\x04\\xaa\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 1194, "newlines": 1194, "modlines": 0, "user": "SOURCE"}, "text": "IEFUJV   TITLE '- IEFUJV - JCL Symbolic Substitution'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n*  I E F U J V    |      Replace \"SET\" Statement Variables            *\n*                 |                                                   *\n*-----------------+                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Function: Replace Symbols On \"SET\" Statements With Their         *\n*              Appropriate Values.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    JCL \"SET\" Statements Will Be Scanned.                            *\n*    Any Variable (&Name) Will Be Substituted With It's Appropriate   *\n*    Value If The Symbol Is Found To Be Valid.                        *\n*                                                                     *\n*    Please Terminate Your Symbols With A Period.                     *\n*    They Will Work If They Are Terminated By A Blank But It Is       *\n*    Best To Use Symbols As They Are Documented By IBM.               *\n*                                                                     *\n*    Internal Symbols:                                                *\n*      &ZDAY.        - DD                                             *\n*      &ZDOW.        - WED                                            *\n*      &ZJDATE.      - DDD                                            *\n*      &ZJOBNAME.    - JOBNAME                                        *\n*      &ZJOBID.      - JOB12345 or J1234567                           *\n*      &ZMONTH.      - MM                                             *\n*      &ZMONTHCH.    - JANUARY                                        *\n*      &ZMOY.        - JAN                                            *\n*      &ZSMFID.      - SMFI                                           *\n*      &ZSTDYEAR.    - CCYY                                           *\n*      &ZTIME.       - HHMM                                           *\n*      &ZTIMEL.      - HHMMSS                                         *\n*      &ZTIMET.      - HHMMSST                                        *\n*      &ZWD.         - # - Day Of The Week 1:Monday / 7:Sunday        *\n*      &ZWEEKDAY.    - Wednesday                                      *\n*      &ZYEAR.       - YY                                             *\n*      &ZHH.         - HH                                             *\n*      &ZMM.         - MM                                             *\n*      &ZSS.         - SS                                             *\n*                                                                     *\n*      &DDMMYY.      -                                                *\n*      &DDMMYYYY.    -                                                *\n*      &MMDDYY.      -                                                *\n*      &MMDDYYYY.    -                                                *\n*      &YYDDD.       - Various Date Formats                           *\n*      &YYDDMM.      -                                                *\n*      &YYMMDD.      -                                                *\n*      &YYYYDDD.     -                                                *\n*      &YYYYDDMM.    -                                                *\n*      &YYYYMMDD.    -                                                *\n*                                                                     *\n*      &YYYY/DDD.    - YYYY/DDD                                       *\n*      &YYYY*DDD.    - YYYY.DDD                                       *\n*                                                                     *\n*    System Symbols:                                                  *\n*      All Symbols Defined In IEASYMxx                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Addition & Subtraction Are Allowed On Numeric Internal Symbols.  *\n*    You Can Code:                                                    *\n*         // SET LASTWEEK=&ZJDATE-7.                                  *\n*    This Will Give You The Julian Date For One Week Ago From Today.  *\n*                                                                     *\n*    The Symbol Name Must Be Terminated With A \"+\" or \"-\" And The     *\n*    Numeric Portion Should Be Terminated With A Period.              *\n*    (ie. &YYDDD+1. or &YYDDD-07.)                                    *\n*                                                                     *\n*    The General Rule For The \"Math\" Portion Is That The Number Will  *\n*    Be In Units Of The Symbol.                                       *\n*                                                                     *\n*    For Example:                                                     *\n*    &DDMMYY.,   &DDMMYYYY., &MMDDYY.,   &MMDDYYYY., &YYDDD.,         *\n*    &YYDDMM.,   &YYMMDD.,   &YYYYDDD.,  &YYYYDDMM., &YYYYMMDD.       *\n*    &ZDAY.,     &ZDOW.,     &ZJDATE.,   &ZWD.,      &ZWEEKDAY.,      *\n*    &YYYY/DDD.  &YYYY*DDD.                                           *\n*    Are \"Day\" Symbols.  The \"+\" Or \"-\" Value Will Adjust             *\n*    The Symbol By The Specified Number Of Days.                      *\n*                                                                     *\n*    &STDYEAR.,  &ZYEAR.,                                             *\n*    Are \"Year\" Symbols.  The \"+\" Or \"-\" Value Will Adjust            *\n*    The Symbol By The Specified Number Of Years.                     *\n*                                                                     *\n*    &ZMONTH.,   &ZMONTHCH., &ZMOY.,                                  *\n*    Are \"Month\" Symbol. The \"+\" Or \"-\" Value Will Adjust             *\n*    The Symbol By The Specified Number Of Months.                    *\n*                                                                     *\n*    &HH., Is An \"Hour\" Symbol.  The \"+\" Or \"-\" Value Will Adjust     *\n*    The Symbol By The Specified Number Of Hours.                     *\n*                                                                     *\n*    &MM., Is A \"Minutes\" Symbol.  The \"+\" Or \"-\" Value Will Adjust   *\n*    The Symbol By The Specified Number Of Minutes.                   *\n*                                                                     *\n*    &SS., Is A \"Seconds\" Symbol.  The \"+\" Or \"-\" Value Will Adjust   *\n*    The Symbol By The Specified Number Of Seconds.                   *\n*                                                                     *\n*    The &ZTIME., &ZTIMEL., &ZTIMET., &ZJOBID., &ZJOBNAME., &ZSMFID.,\n*    And IEASYMxx Symbols Will Ignore Any \"+\" Or \"-\" Adjustment.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     History: #DD05336 - Dec 2005 - Modeled After CBT File #573      *\n*                                    Thanks To Shane Ginnane          *\n*              #DD09049 - Feb 2009 - Added &ZWD. & &ZDOW.             *\n*              #DD09071 - Mar 2009 - Added &SYM+nnn. And &SYM-nnn.    *\n*              #DD09079 - Mar 2009 - Added &YYYY/DDD. symbol          *\n*              #DD09118 - Apr 2009 - Added &ZJOBID. symbol            *\n*              #DD09183 - Jul 2009 - Added &ZMONTHCH. And &ZMOY.      *\n*              #DD14280 - Oct 2014 - Added &YYYY*DDD. symbol          *\n*              #DD15062 - Mar 2015 - Corrected Large +/- Processing.  *\n*              #DD18023 - Jan 2018 - Corrected Negative Math Value.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INTERNAL MACROS                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MACRO ,\n&NAME    IPROC &MODE=,&BASEREG=R10,&LINKREG=R14,&DEPTH=\n         AIF   ('&MODE' EQ '').IPRO050\n         AIF   ('&MODE' EQ 'INIT').IPRO010\n         AIF   ('&MODE' EQ 'DEFINE').IPRO030\n         MNOTE 12,'INVALID VALUE SPECIFIED FOR MODE - \"&MODE\"'\n         MEXIT ,\n.IPRO010 ANOP  ,\n         AIF   ('&DEPTH' EQ '').IPRO020 \"DEPTH\" SPECIFIED\n         MNOTE 4,'DEPTH IGNORED WHEN MODE IS NOT DEFINE'\n.IPRO020 ANOP  ,\n         LA    R14,IPROCSTK        Initialize Next\n         ST    R14,IPROCNXT        . Stack Entry\n         LA    R14,IPROCTSL(,R14)  Initialize Last\n         ST    R14,IPROCEND        . Stack Entry\n         B     I&SYSNDX\nIPROCERR EX    0,*                 Abend S0C3 When Stack Overflows\nI&SYSNDX DS    0H\n         MEXIT ,\n.IPRO030 ANOP  ,\n         LCLC  &DP                 Stack Depth\n&DP      SETC  '16'                Default Stack Depth\n         AIF   ('&DEPTH' EQ '').IPRO040 \"DEPTH\" SPECIFIED?\n&DP      SETC  '&DEPTH'            Use specified Stack Depth\n.IPRO040 ANOP  ,\nIPROCTMP DS    F                   Temporary Register Save Area\nIPROCNXT DS    A                   A(Next Stack Entry)\nIPROCEND DS    A                   A(Last Stack Entry)\nIPROCESL EQU   10*4                Length Of Each Stack Entry\nIPROCSTK DS    &DP.XL(IPROCESL)    SaveArea Stack\nIPROCTSL EQU   *-IPROCSTK          Total Length Of Stack\n         MEXIT ,\n.IPRO050 ANOP  ,\n         AIF   ('&DEPTH' EQ '').IPRO060 \"DEPTH\" SPECIFIED\n         MNOTE 4,'DEPTH IGNORED WHEN MODE IS NOT DEFINE'\n.IPRO060 ANOP  ,\n         GBLC  &STPREF             Module Prefix\n         LCLC  &SUBRNAM            Subroutine Label\n         LCLC  &BR                 Base Register\n         LCLC  &LR                 Linkage Register\n&BR      SETC  '&BASEREG'          Set Base Register\n&LR      SETC  '&LINKREG'          Set Linkage Register\n&SUBRNAM SETC  '&STPREF.SUBRT'\n&SUBRNAM LOCTR ,\n&NAME    ST    &LINKREG,IPROCTMP   Save Linkage Register\n         PUSH  USING               Save USING Status\n         L     &LINKREG,IPROCNXT   Get Next Stack Entry\n         C     &LINKREG,IPROCEND   Check For Stack Overflow\n         BNL   IPROCERR            B. If Yes\n         MVC   0(4,&LR),IPROCTMP   Copy Linkage Register\n         STM   R2,R10,4(&LR)       Save Registers\n         LA    &LR,IPROCESL(,&LR)  Update Next\n         ST    &LR,IPROCNXT        . Stack Entry Address\n         BALR  &BR,0               Obtain Local\n         USING *,&BR               Addressability\n         LA    &BR,0(,&BR)         Ensure Clean Base\n         MEND  ,\n\n         MACRO\n&NAME    IPEND &BASEREG=R10,&LINKREG=R14\n         GBLC  &STNAME             Main CSECT Name\n         LCLC  &BR                 Base Register\n         LCLC  &LR                 Linkage Register\n&BR      SETC  '&BASEREG'          Set Base Register\n&LR      SETC  '&LINKREG'          Set Linkage Register\n&NAME    ST    R15,IPROCTMP        Save Return Code\n         L     &LR,IPROCNXT        Derive Address\n         LA    R15,IPROCESL        . Of Our\n         SR    &LR,R15             . Stack Entry\n         ST    &LR,IPROCNXT        Update Next Stack Entry\n         L     R15,IPROCTMP        Load Return Code\n         LM    R2,R10,4(&LR)       Restore Registers\n         L     &LR,0(,&LR)         Restore Linkage Register\n         BR    &LR                 Return To Caller\n         #EXEC ,                   Generate #EXEC Statements\n         LTORG ,                   Generate Literal Pool\n         DC    32S(*)              Patch Area\n         POP   USING               Restore Using Status\n&STNAME  LOCTR ,                   Restore Main CSECT\n         MEND  ,\n\n         MACRO\n&NAME    ICALL &RTN,&LINKREG=R14\n         LCLC  &REG\n         AIF   ('&RTN'(1,1) EQ '(').REGFORM\n         L     &LINKREG,=A(&RTN)\n         BALR  &LINKREG,&LINKREG   Call Subroutine\n         MEXIT\n.REGFORM ANOP\n&REG     SETC  '&RTN'(2,K'&RTN-2)\n         BALR  &LINKREG,&REG       Call Subroutine\n         MEND  ,\n\nIEFUJV   #START BASE=(R12),AMODE=31,RMODE=ANY,                         *\n               EXTKEY=ZERO,COPY=YES,                                   *\n               WKDSECT=UJVWRK,SP=230,LOC=ANY,PREFIX=WRK,               *\n               REG1=R8,                                                *\n               USING=(PSA,0,PLIST,R8),                                 *\n               LEVEL=#V001R09      Mainteinence Level          #DD18023\n\n         IPROC MODE=INIT           Initialize Stack            #DD09143\n\n*-------\n*        Only Process \"Batch\" SET JCL Statements Containing An \"&\"\n*-------\n         L     R15,P1SUBSYS        A(Subsystem Name)\n         CLC   =C'JES',0(R15)      Check For JES2/JES3 Subsystem\n         BNE   SCNEXIT             B. If Not\n\n         L     R15,P1TYPE          A(Statement Type)\n         CLI   0(R15),128          Check For Extended JCL Statement\n         BNE   SCNEXIT             B. If Not\n\n         L     R4,P1JCL            A(JCL Statement)\n         LA    R2,2(,R4)           A(1St Byte After //)\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n\n         SLR   R0,R0\n         IC    R0,=C'&&'           Load Search Character\n         SRST  R1,R2               Search For String\n         BC    2,SCNEXIT           B. If Not Found\n\n         LA    R1,2(,R4)           A(1St Byte Of JCL Statement)\n         LHI   R2,65               Load No. Of Bytes In Statement\nUJV00100 DS    0H\n         CLC   =C' SET ',0(R1)     Check For \"SET\" Statement\n         BE    UJV00200            B. If Yes\n         LA    R1,1(,R1)           A(Next Byet In JCL Statement)\n         BCT   R2,UJV00100         Look At Entire Statement\n\n         B     SCNEXIT             B. If Not A \"SET\" Statement\n\n*-------\n*        Save Symbol Name And It's Length\n*-------\nUJV00200 DS    0H\n         LA    R2,5(,R1)           A(1St Byte After \" SET \")\n\nUJV00300 DS    0H\n         LA    R1,72(,R4)          A(Last Byet Of JCL Statement)\n         SLR   R0,R0\n         IC    R0,=C'&&'           Load Search Character\n         SRST  R1,R2               Search For String\n         BC    2,SCNEXIT           B. If Not Found\n\n         LR    R3,R1\n         ST    R3,WRKSYM@          Save Symbol Starting Address\n         LA    R2,72(,R4)          A(Last Byte Of JCL Statement)\n         SR    R2,R3               Calculate Remaining Length\n         BNP   SCNEXIT\n\n         XC    WRKTRTAB,WRKTRTAB   Prime\n         MVI   WRKTRTAB+C' ',C' '     With\n         MVI   WRKTRTAB+C'.',C'.'        Symbol\n         MVI   WRKTRTAB+C',',C','           Terminator\n         MVI   WRKTRTAB+C'''',C''''            Values\n         MVI   WRKTRTAB+C'+',C'+'                              #DD09071\n         MVI   WRKTRTAB+C'-',C'-'                              #DD09071\n\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n         #EXEC -R2,TRT,0(*-*,R3),WRKTRTAB\n         SR    R1,R3               Calculate Symbol Name Length\n         SHI   R1,1                Subtract 1 For \"&\"          #DD09071\n         STC   R1,WRKSYML          Save Symbol Length\n\n         MVC   WRKSYM,BLANKS\n         #EXEC -R1,MVC,WRKSYM(*-*),1(R3)\n         LA    R3,2(R1,R3)         A(Past End Of Symbol Name)\n\n*-------\n*        Process Plus/Minus Suffix\n*-------\n         MVI   WRKSYMFL,0          Initialize Symbol Flag\n         MVI   WRKNUMF,C'N'        Initialize Numeric Flag     #DD09071\n\n         XC    WRKSUFFL,WRKSUFFL   Clear Suffix Length         #DD09071\n         XC    WRKNUM,WRKNUM       Clear Numeric Suffix Value  #DD09071\n\n         CLI   0(R3),C'+'          Check For \"Addition\"        #DD09071\n         BNE   UJV00500            B. If Not                   #DD09071\n         OI    WRKSYMFL,WRK$PLUS                               #DD09071\n         B     UJV00600                                        #DD09071\nUJV00500 DS    0H                                              #DD09071\n         CLI   0(R3),C'-'          Check For \"Subtraction\"     #DD09071\n         BNE   UJV00800            B. If Not                   #DD09071\n         OI    WRKSYMFL,WRK$MINUS                              #DD09071\nUJV00600 DS    0H                                              #DD09071\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n         LA    R3,1(,R3)           Advance Past \"+\" Or \"-\"     #DD09071\n         LR    R2,R1                                           #DD09071\n         SR    R2,R3               Calculate Remaining Length  #DD09071\n         BNP   SCNEXIT                                         #DD09071\n         MVI   WRKTRTAB+C'+',0     Remove \"+\" From Table       #DD09071\n         MVI   WRKTRTAB+C'-',0     Remove \"-\" From Table       #DD09071\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n         #EXEC -R2,TRT,0(*-*,R3),WRKTRTAB                      #DD09071\n         SR    R1,R3               Calculate Numeric Length    #DD09071\n         BNP   SCNEXIT             B. If No Number             #DD09071\n         CLM   R2,1,=C'.'          Check For Trailing Period   #DD09071\n         BNE   UJV00700            B. If Not                   #DD09071\n         OI    WRKSYMFL,WRK$DOT                                #DD09071\nUJV00700 DS    0H                                              #DD09071\n         STH   R1,WRKSUFFL         Save Suffix Length          #DD09071\n         LTR   R5,R1               Check For Positive Length   #DD09071\n         BNP   SCNEXIT             B. If Not                   #DD09071\n         L     R15,=A(NUMERTAB)    A(Translate Table)          #DD09071\n         #EXEC -R5,TRT,0(*-*,R3),0(R15)                        #DD09071\n         BNZ   SCNEXIT             B. If Not Numeric           #DD09071\n         #EXEC R5,PACK,WRKDBL1,0(*-*,R3)                       #DD09071\n         CVB   R1,WRKDBL1          Convert Number To Binary    #DD09071\n         C     R1,=A(32767)        Check For Maximum Value     #DD15062\n         BH    UJV02200            Ignore This Symbol          #DD15062\n         STH   R1,WRKNUM           Save Numeric Value          #DD09071\n\n*-------\n*        Check Symbol Termination Character\n*-------\nUJV00800 DS    0H                                              #DD09071\n         CLI   0(R3),C'.'          Check If Symbol Ends With A Period\n         BNE   UJV01200            B. If Not\n         OI    WRKSYMFL,WRK$DOT\n         LA    R3,1(,R3)           A(Past Period)\n\n*-------\n*        Scan For Internal Symbol Name\n*-------\nUJV01200 DS    0H\n         CLI   WRKSYML,8           Check For Maximum Internal Length\n         BH    UJV01600            B. If Too Long\n\n         SLR   R1,R1\n         ICM   R1,1,WRKSYML        L(Current Symbol)\n         BZ    UJV02200            B. If Null Symbol Name\n         SHI   R1,1                Convert To Machine Length   #DD09071\n         L     R2,=A(INTERNAL)     A(Internal Symbol Table)    #DD09079\nUJV01300 DS    0H\n         CLI   0(R2),255           Check For End Of Internal Symbols\n         BE    UJV01600            B. If Yes\n\n         CLM   R1,1,0(R2)          Check If Lengths Match\n         BNE   UJV01400            B. If Not\n         #EXEC R1,CLC,2(*-*,R2),WRKSYM\n         BE    UJV01500            B. If Symbol Found\nUJV01400 DS    0H\n         LA    R2,1+1+8+4(,R2)\n         B     UJV01300            Continue Scanning Internal Symbols\n\nUJV01500 DS    0H\n         ICM   R15,15,1+1+8(R2)\n         ICALL (R15)               Get Symbol Address & Length #DD09183\n\n         B     UJV02000            Insert Value Into JCL Statement\n\n*-------\n*        Scan For System Symbol Names\n*-------\nUJV01600 DS    0H\n         L     R15,FLCCVT          A(CVT)\n         USING CVT,R15\n         ICM   R15,15,CVTECVT      A(ECVT)\n         BZ    UJV02200            B. If Not Available\n         USING ECVT,R15\n         ICM   R15,15,ECVTSYMT     A(Symbol Table)\n         BZ    UJV02200            B. If None Defined\n         USING SYMBT,R15\n\n         SLR   R7,R7\n         ICM   R7,3,SYMBTNUMBEROFSYMBOLS  Number Of Symbols\n         BZ    UJV02200            B. If None Defined\n         LA    R6,SYMBTTABLEENTRIES A(Start Of Symbol Table Entries)\n         ST    R6,WRKSYMB@         Save Start Of Symbol Table Address\n         USING SYMBTE,R6\n\nUJV01700 DS    0H\n         LM    R1,R2,SYMBTESYMBOLOFFSET O(Name) & L(Name)\n         A     R1,WRKSYMB@         A(Symbol Name)\n         LA    R1,1(,R1)           Advance Past \"&\"\n         SH    R2,=AL2(2)          Reduce Length For \"&\" And \".\"\n         BNP   UJV01800            B. If Null Symbol\n\n         CLM   R2,1,WRKSYML        Check If Lengths Match\n         BNE   UJV01800            B. If Not\n         #EXEC -R2,CLC,WRKSYM(*-*),0(R1)\n         BE    UJV01900            B. If Symbol Found\n\nUJV01800 DS    0H\n         LA    R6,SYMBTE_LEN(,R6)  A(Next Symbol Table Entry)\n         BCT   R7,UJV01700         Loop Through Symbol Table\n         B     UJV02200\n\nUJV01900 DS    0H\n         L     R1,SYMBTESUBTEXTOFFSET   O(Symbol Value)\n         A     R1,WRKSYMB@              A(Symbol Value)\n         L     R15,SYMBTESUBTEXTLENGTH  L(Symbol Value)\n\n*-------\n*        Insert Symbol's Value Into JCL Statement\n*-------\nUJV02000 DS    0H\n         L     R5,WRKSYM@          A(&Symbol)\n         SLR   R14,R14\n         IC    R14,WRKSYML         L(Current Symbol)\n         LA    R14,1(,R14)         Add 1 For \"&&\"\n         AH    R14,WRKSUFFL        Add Suffix Length           #DD09071\n         TM    WRKSYMFL,WRK$DOT    Check If Symbol Ends With A Period\n         BZ    UJV02100            B. If Not\n         LA    R14,1(,R14)         Add 1 For \".\"\nUJV02100 DS    0H\n         TM    WRKSYMFL,WRK$PLUS+WRK$MINUS\n         BZ    UJV02150            B. If No Math Performed\n         LA    R14,1(,R14)         Add 1 For \"+\" Or \"-\"\nUJV02150 DS    0H\n         #EXEC -R14,MVC,0(*-*,R5),BLANKS\n         #EXEC -R15,MVC,0(*-*,R5),0(R1)\n         LA    R5,1(R15,R5)        A(End Of Inserted Value)\n\n*-------\n*        Shift Remainder Of Statement Forward\n*-------\n         MVI   WRKTRTAB,X'FF'\n         MVC   WRKTRTAB+1(L'WRKTRTAB-1),WRKTRTAB\n         MVI   WRKTRTAB+C' ',X'00' Find Next Non-Blank\n\n         LA    R2,72(,R4)          A(Last Byte Of JCL Statement)\n         SR    R2,R5               Calculate Remaining Length\n         BNP   UJV02300            B. If No More Data\n\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n         #EXEC -R2,TRT,0(*-*,R5),WRKTRTAB\n         BZ    UJV02300            B. If Remainder Is Blanks\n\n         LR    R2,R1               A(1St Non-Blank)\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n         SR    R1,R2               Calculate Bytes To Move\n         BNP   UJV02300\n         #EXEC -R1,MVC,0(*-*,R5),0(R2)\n         LR    R3,R5               A(End Of Inserted Value)\n\n         LA    R2,1(R1,R2)         A(Last Byte Of Shifted Data)\n         LA    R1,72(,R4)          A(Last Byte Of JCL Statement)\n         SR    R1,R2               Calculate Bytes To Blank\n         BNP   UJV02300\n         #EXEC -R1,MVC,0(*-*,R2),BLANKS\n\n         B     UJV02300\n\n*-------\n*        Unknown Symbol\n*-------\nUJV02200 DS    0H\n         SLR   R1,R1\n         ICM   R1,1,WRKSYML        L(Current Symbol)\n         AH    R1,WRKSUFFL         Add Suffix Length           #DD09071\n         LA    R3,1(R1,R3)         A(End Of Current Symbol)\n\n*-------\n*        Continue Scanning Till All Symbols Have Been Processed\n*-------\nUJV02300 DS    0H\n         LR    R2,R3               A(End Of Processed Section)\n         B     UJV00300            Scan Rest Of Statement\n\n*-------\n*        Terminate\n*-------\nSCNEXIT  #STOP RC=0                Terminate Exit Routine\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        Internal Symbol Value Subroutines                         *\n*                                                                  *\n*------------------------------------------------------------------*\n\nZDAY     IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WDD,FORMAT='DD',FROM=WRKDATE                    #DD09071\n\n         LA    R1,WDD              A(Symbol Value)\n         LHI   R15,L'WDD           L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZDOW     IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WDOW,FORMAT='DAYOFWEEK',FROM=WRKDATE            #DD09071\n         OC    WDOW,BLANKS         Convert To Upper Case       #DD09049\n\n         LA    R1,WDOW             A(Symbol Value)             #DD09049\n         LHI   R15,3               L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZJDATE   IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WDDD,FORMAT='DDD',FROM=WRKDATE                  #DD09071\n\n         LA    R1,WDDD             A(Symbol Value)\n         LHI   R15,L'WDDD          L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZJOBNAME IPROC ,                   Start SubRoutine            #DD09183\n         L     R15,P1JMR           A(JMR)\n         USING JMR,R15\n         MVC   WJOBNAME,JMRJOB     Save Job Name\n         DROP  R15\n\n         LA    R1,WJOBNAME         A(Symbol Value)\n         LA    R15,WJOBNAME+L'WJOBNAME-1\nZJOBN010 DS    0H\n         CLI   0(R15),C' '         Check For End Of Value\n         BNE   ZJOBN020            B. If End Found\n         BCT   R15,ZJOBN010        Back Up Till End Found\nZJOBN020 DS    0H\n         LA    R15,1(,R15)         A(Past Last Non-Blank)\n         SR    R15,R1              Calculate Length Of Value\n         IPEND ,                   Return To Caller            #DD09183\n\nZJOBID   IPROC ,                   Start SubRoutine            #DD09183\n         IAZXJSAB READ,            Get Info From JSAB          #DD09183*\n               JOBID=WJOBID                                    #DD09183\n         LTR   R15,R15             Check If Successful         #DD09183\n         BZ    ZJOBIXIT            B. If Yes                   #DD09183\n\n         MVC   WJOBID,=CL8'NOTAVAIL'                           #DD09183\n\nZJOBIXIT DS    0H                                              #DD09183\n         LA    R1,WJOBID           A(Symbol Value)             #DD09118\n         LHI   R15,L'WJOBID        L(Symbol Value)             #DD09118\n         IPEND ,                   Return To Caller            #DD09183\n\nZMONTH   IPROC ,                   Start SubRoutine            #DD09183\n         #DATE WMONTH,FORMAT='MM',FROM=WRKDATE                 #DD09071\n\n         LA    R1,WMONTH           A(Symbol Value)             #DD09071\n         LHI   R15,L'WMONTH        L(Symbol Value)             #DD09071\n\n         MVC   WRKMAX,=AL2(12)     Set Maximum Value           #DD09071\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZMONTHCH IPROC ,                   Start SubRoutine            #DD09183\n         #DATE WMONTH,FORMAT='MM',FROM=WRKDATE                 #DD09183\n\n         LA    R1,WMONTH           A(Symbol Value)             #DD09183\n         LHI   R15,L'WMONTH        L(Symbol Value)             #DD09183\n         MVC   WRKMAX,=AL2(12)     Set Maximum Value           #DD09183\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n\n         LA    R3,MONTHS           A(1st Month Entry)          #DD09183\nZMON0100 DS    0H                                              #DD09183\n         CLC   0(2,R3),WMONTH      Check For Current Month     #DD09183\n         BE    ZMON0200            B. If Month Found           #DD09183\n         LA    R3,MONTHSL(,R3)     A(Next Month Entry)         #DD09183\n         B     ZMON0100            Loop Till Month Is Found    #DD09183\n\nZMON0200 DS    0H                                              #DD09183\n         LA    R1,4(,R3)           A(Current Month)            #DD09183\n         LH    R15,2(,R3)          L(Current Month)            #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZMOY     IPROC ,                   Start SubRoutine            #DD09183\n         #DATE WMONTH,FORMAT='MM',FROM=WRKDATE                 #DD09183\n\n         LA    R1,WMONTH           A(Symbol Value)             #DD09183\n         LHI   R15,L'WMONTH        L(Symbol Value)             #DD09183\n         MVC   WRKMAX,=AL2(12)     Set Maximum Value           #DD09183\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n\n         LA    R3,MONTHS           A(1st Month Entry)          #DD09183\nZMOY0100 DS    0H                                              #DD09183\n         CLC   0(2,R3),WMONTH      Check For Current Month     #DD09183\n         BE    ZMOY0200            B. If Month Found           #DD09183\n         LA    R3,MONTHSL(,R3)     A(Next Month Entry)         #DD09183\n         B     ZMOY0100            Loop Till Month Is Found    #DD09183\n\nZMOY0200 DS    0H                                              #DD09183\n         LA    R1,4(,R3)           A(Current Month)            #DD09183\n         LHI   R15,3               L(Current Month)            #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZSMFID   IPROC ,                   Start SubRoutine            #DD09183\n         MVC   WSMFID,BLANKS\n         L     R15,FLCCVT          A(CVT)\n         USING CVTMAP,R15\n         MVC   WSMFID,BLANKS\n         ICM   R15,15,CVTSMCA      A(SMCA)\n         BZ    ZSMFI010            B. If Nit Found\n         USING SMCABASE,R15\n         MVC   WSMFID,SMCASID      Insert SMF System Identifier\n         DROP  R15\n\nZSMFI010 DS    0H\n         LA    R1,WSMFID           A(Symbol Value)\n         LHI   R15,L'WSMFID        L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZSTDYEAR IPROC ,                   Start SubRoutine            #DD09183\n         #DATE WCCYY,FORMAT='CCYY',FROM=WRKDATE                #DD09071\n\n         LA    R1,WCCYY            A(Symbol Value)\n         LHI   R15,L'WCCYY         L(Symbol Value)             #DD09071\n\n         XC    WRKMAX,WRKMAX       Indicate No Max Value       #DD09071\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZTIME    IPROC ,                   Start SubRoutine            #DD09183\n         #TIME WHHMM,FORMAT='HHMM'\n\n         LA    R1,WHHMM            A(Symbol Value)\n         LHI   R15,L'WHHMM         L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZTIMEL   IPROC ,                   Start SubRoutine            #DD09183\n         #TIME WHHMMSS,FORMAT='HHMMSS'\n\n         LA    R1,WHHMMSS          A(Symbol Value)\n         LHI   R15,L'WHHMMSS       L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZTIMET   IPROC ,                   Start SubRoutine            #DD09183\n         #TIME WHHMMSST,FORMAT='HHMMSSTH'                      #DD09121\n\n         LA    R1,WHHMMSST         A(Symbol Value)             #DD09121\n         LHI   R15,L'WHHMMSST      L(Symbol Value)             #DD09121\n         IPEND ,                   Return To Caller            #DD09183\n\nZHH      IPROC ,                   Start SubRoutine            #DD09183\n         #TIME WHH,FORMAT='HH'                                 #DD09071\n\n         LA    R1,WHH              A(Symbol Value)             #DD09071\n         LHI   R15,L'WHH           L(Symbol Value)             #DD09071\n\n         OI    WRKSYMFL,WRK$ZERO   Indicate Zeros Are Allowed  #DD09071\n         MVC   WRKMAX,=AL2(24)     Set Maximum Value           #DD09071\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZMM      IPROC ,                   Start SubRoutine            #DD09183\n         #TIME WMM,FORMAT='MM'                                 #DD09071\n\n         LA    R1,WMM              A(Symbol Value)             #DD09071\n         LHI   R15,L'WMM           L(Symbol Value)             #DD09071\n\n         OI    WRKSYMFL,WRK$ZERO   Indicate Zeros Are Allowed  #DD09071\n         MVC   WRKMAX,=AL2(60)     Set Maximum Value           #DD09071\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZSS      IPROC ,                   Start SubRoutine            #DD09183\n         #TIME WSS,FORMAT='SS'                                 #DD09071\n\n         LA    R1,WSS              A(Symbol Value)             #DD09071\n         LHI   R15,L'WSS           L(Symbol Value)             #DD09071\n\n         OI    WRKSYMFL,WRK$ZERO   Indicate Zeros Are Allowed  #DD09071\n         MVC   WRKMAX,=AL2(60)     Set Maximum Value           #DD09071\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nZWD      IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WD,FORMAT='WD',FROM=WRKDATE                     #DD09071\n\n         LA    R1,WD+1             A(Symbol Value)             #DD09071\n         LHI   R15,1               L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nZWEEKDAY IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WDOW,FORMAT='DAYOFWEEK',FROM=WRKDATE            #DD09071\n\n         LA    R1,WDOW             A(Symbol Value)\n         LA    R15,WDOW+L'WDOW-1\nZWEEK010 DS    0H\n         CLI   0(R15),C' '         Check For End Of Value\n         BNE   ZWEEK020            B. If End Found\n         BCT   R15,ZWEEK010        Back Up Till End Found\nZWEEK020 DS    0H\n         LA    R15,1(,R15)         A(Past Last Non-Blank)\n         SR    R15,R1              Calculate Length Of Value\n         IPEND ,                   Return To Caller            #DD09183\n\nZYEAR    IPROC ,                   Start SubRoutine            #DD09183\n         #DATE WYY,FORMAT='YY',FROM=WRKDATE                    #DD09071\n\n         LA    R1,WYY              A(Symbol Value)\n         LHI   R15,L'WYY           L(Symbol Value)             #DD09071\n\n         XC    WRKMAX,WRKMAX       Indicate No Max Value       #DD09071\n         ICALL MATH                Process \"+\" Or \"-\" Suffix   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\nDDMMYY   IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WDDMMYY,FORMAT='DDMMYY',FROM=WRKDATE            #DD09071\n\n         LA    R1,WDDMMYY          A(Symbol Value)             #DD09071\n         LHI   R15,L'WDDMMYY       L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nDDMMYYYY IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WDDMMYYYY,FORMAT='DDMMCCYY',FROM=WRKDATE        #DD09071\n\n         LA    R1,WDDMMYYYY        A(Symbol Value)             #DD09071\n         LHI   R15,L'WDDMMYYYY     L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nMMDDYY   IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WMMDDYY,FORMAT='MMDDYY',FROM=WRKDATE            #DD09071\n\n         LA    R1,WMMDDYY          A(Symbol Value)             #DD09071\n         LHI   R15,L'WMMDDYY       L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nMMDDYYYY IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WMMDDYYYY,FORMAT='MMDDCCYY',FROM=WRKDATE        #DD09071\n\n         LA    R1,WMMDDYYYY        A(Symbol Value)             #DD09071\n         LHI   R15,L'WMMDDYYYY     L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYDDD    IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYDDD,FORMAT='YYDDD',FROM=WRKDATE              #DD09071\n\n         LA    R1,WYYDDD           A(Symbol Value)             #DD09071\n         LHI   R15,L'WYYDDD        L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYDDMM   IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYDDMM,FORMAT='YYDDMM',FROM=WRKDATE            #DD09071\n\n         LA    R1,WYYDDMM          A(Symbol Value)             #DD09071\n         LHI   R15,L'WYYDDMM       L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYMMDD   IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYMMDD,FORMAT='YYMMDD',FROM=WRKDATE            #DD09071\n\n         LA    R1,WYYMMDD          A(Symbol Value)             #DD09071\n         LHI   R15,L'WYYMMDD       L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYYYDDD  IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYYYDDD,FORMAT='CCYYDDD',FROM=WRKDATE          #DD09071\n\n         LA    R1,WYYYYDDD         A(Symbol Value)             #DD09071\n         LHI   R15,L'WYYYYDDD      L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYYYDDMM IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYYYDDMM,FORMAT='CCYYDDMM',FROM=WRKDATE        #DD09071\n\n         LA    R1,WYYYYDDMM        A(Symbol Value)             #DD09071\n         LHI   R15,L'WYYYYDDMM     L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYYYMMDD IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYYYMMDD,FORMAT='CCYYMMDD',FROM=WRKDATE        #DD09071\n\n         LA    R1,WYYYYMMDD        A(Symbol Value)             #DD09071\n         LHI   R15,L'WYYYYMMDD     L(Symbol Value)             #DD09071\n         IPEND ,                   Return To Caller            #DD09183\n\nYYYYDDD2 IPROC ,                   Start SubRoutine            #DD09183\n         ICALL GETDATE             Get Updated Date            #DD09183\n\n         #DATE WYYYYDDD2,FORMAT='CCYY/DDD',FROM=WRKDATE        #DD09079\n\n         LA    R1,WYYYYDDD2        A(Symbol Value)             #DD09079\n         LHI   R15,L'WYYYYDDD2     L(Symbol Value)             #DD09079\n         IPEND ,                   Return To Caller            #DD09183\n\nYYYYDDD3 IPROC ,                   Start SubRoutine            #DD14280\n         ICALL GETDATE             Get Updated Date            #DD14280\n\n         #DATE WYYYYDDD3,FORMAT='CCYY.DDD',FROM=WRKDATE        #DD14280\n\n         LA    R1,WYYYYDDD3        A(Symbol Value)             #DD14280\n         LHI   R15,L'WYYYYDDD3     L(Symbol Value)             #DD14280\n         IPEND ,                   Return To Caller            #DD14280\n\n*-------\n*        Add Or Subtract The Number Of Days From The Current Date\n*-------\nGETDATE  IPROC ,                   Start SubRoutine            #DD09183\n         TM    WRKSYMFL,WRK$PLUS+WRK$MINUS                     #DD09071\n         BZ    GETDEXIT            B. If No Changes Requested  #DD09071\n\n         TIME  DEC                 Obtain Current Time/Date    #DD09071\n         STM   R0,R1,TIMEDATE      Save Current Time/Date      #DD09071\n\n         #DATE WRKCCYYC,FORMAT='CCYY',FROM=WRKDATE             #DD09071\n         PACK  WRKDBL1,WRKCCYYC                                #DD09071\n         OI    WRKDBL1+7,X'0F'                                 #DD09071\n         CVB   R1,WRKDBL1          Convert CCYY To Binary      #DD09071\n         STH   R1,WRKCCYYB                                     #DD09071\n\n         XC    WRKDBL1,WRKDBL1                                 #DD09071\n         MVC   WRKDBL1+6(2),WRKDATE+2                          #DD09071\n         OI    WRKDBL1+7,X'0F'                                 #DD09071\n         CVB   R1,WRKDBL1          Convert DDD To Binary       #DD09071\n         STH   R1,WRKDDDB                                      #DD09071\n         MVC   WRKTODAY,WRKDDDB    Save Today's Julian Date    #DD09071\n\nGETD0100 DS    0H                                              #DD09071\n         MVC   WRKDPY,=AL2(365)    Set Non-Leap Year Days/Year #DD09071\n         TM    WRKCCYYB+1,3        Check If Divisible By 4     #DD09071\n         BNZ   GETD0200            B. If Not                   #DD09071\n         MVC   WRKDPY,=AL2(366)    Set Leap Year Days/Year     #DD09071\n\nGETD0200 DS    0H                                              #DD09071\n         MVC   WRKCVAL,WRKNUM      Initialize +/- Value        #DD15062\n         CLC   WRKCVAL,WRKDPY      Check If > Days In 1 Year   #DD15062\n         BL    GETD0300            B. If Not                   #DD15062\n         MVC   WRKCVAL,WRKDPY      Set Value To 1 Year         #DD15062\n\nGETD0300 DS    0H                                              #DD15062\n         TM    WRKSYMFL,WRK$PLUS                               #DD09071\n         BZ    GETD0400            B. If No \"+\" Calculation    #DD09071\n         LH    R1,WRKDDDB          Load Today's Date           #DD09071\n         AH    R1,WRKCVAL          Add \"+\" Value               #DD15062\n         STH   R1,WRKDDDB          Save Calculated Date        #DD09071\n         CH    R1,WRKDPY           Check If Into Next Year     #DD09071\n         BNH   GETD0700            B. If Not                   #DD09071\n         SH    R1,WRKDPY           Calculate Next Year's Date  #DD15062\n         STH   R1,WRKDDDB                                      #DD16062\n         LH    R1,WRKCCYYB                                     #DD09071\n         AHI   R1,1                Set To Next Year            #DD09071\n         STH   R1,WRKCCYYB                                     #DD09071\n         B     GETD0700            Return Date Value           #DD09071\n\nGETD0400 DS    0H                                              #DD09071\n         TM    WRKSYMFL,WRK$MINUS                              #DD09071\n         BZ    GETDEXIT            B. If No \"-\" Calculation    #DD09071\n         LH    R1,WRKDDDB          Load Today's Date           #DD09071\n         SH    R1,WRKCVAL          Subtract \"-\" Value          #DD15062\n         LTR   R1,R1               Check If Still In This Year #DD09071\n         BNP   GETD0500            B. If Not                   #DD15062\n         STH   R1,WRKDDDB          Save Calculated Date        #DD15062\n         B     GETD0700                                        #DD15062\nGETD0500 DS    0H                                              #DD15062\n         LH    R1,WRKCCYYB                                     #DD09071\n         SHI   R1,1                Set To Last Year            #DD09071\n         STH   R1,WRKCCYYB                                     #DD09071\n         MVC   WRKDPY,=AL2(365)    Set Non-Leap Year Days/Year #DD09071\n         TM    WRKCCYYB+1,3        Check If Divisible By 4     #DD09071\n         BNZ   GETD0600            B. If Not                   #DD09071\n         MVC   WRKDPY,=AL2(366)    Set Leap Year Days/Year     #DD09071\nGETD0600 DS    0H                                              #DD09071\n         LH    R1,WRKDDDB          Load Today's Date           #DD15062\n         AH    R1,WRKDPY           Add Previous Years Days     #DD15062\n         SH    R1,WRKCVAL          Calc. Day Of Previous Year  #DD15062\n         STH   R1,WRKDDDB          Save Calculated Date        #DD15062\n\nGETD0700 DS    0H                                              #DD09071\n         LH    R1,WRKNUM           Load Remaining +/- Value    #DD15062\n         SH    R1,WRKCVAL          Subtract Current Value      #DD15062\n         STH   R1,WRKNUM           Save Remaining +/- Value    #DD15062\n         LTR   R1,R1               Check If More Days          #DD15062\n         BP    GETD0100            B. If Yes                   #DD15062\n\n         CLC   WRKDDDB,=AL2(0)     Check For Start Of New Year #DD15062\n         BNE   GETD0800            B. If Not                   #DD15062\n         MVC   WRKDDDB,=AL2(1)     Set Date To 1St Day Of Year #DD15062\n\nGETD0800 DS    0H                                              #DD15062\n         LH    R1,WRKCCYYB         Load Year Value             #DD09071\n         SH    R1,=AL2(1900)                                   #DD09071\n         CVD   R1,WRKDBL1                                      #DD09071\n         LH    R1,WRKDBL1+6        Load CCYYF                  #DD09071\n         SRL   R1,4                Convert To CCYY             #DD09071\n         STH   R1,WRKDATE          Save CCYY                   #DD09071\n\n         LH    R1,WRKDDDB          Load Julian Date Value      #DD09071\n         CVD   R1,WRKDBL1                                      #DD09071\n         LH    R1,WRKDBL1+6        Load CCYYF                  #DD09071\n         STH   R1,WRKDATE+2        Save DDDF                   #DD09071\n\nGETDEXIT IPEND ,                                               #DD09183\n\n*-------\n*        Add Or Subtract Plain Numbers\n*-------\nMATH     IPROC ,                   Start SubRoutine            #DD09183\n         STM   R15,R1,WRKMATH      Save Variable Addr/Len      #DD62142\n\n         TM    WRKSYMFL,WRK$PLUS+WRK$MINUS                     #DD09071\n         BZ    MATHEXIT            B. If No Math Required      #DD09071\n\n         LR    R5,R1               Save Variable Address       #DD09071\n         LR    R6,R15              Save Variable Length        #DD09071\n         #EXEC -R6,PACK,WRKDBL1(8),0(*-*,R5)                   #DD09071\n         CVB   R1,WRKDBL1          Convert Number To Binary    #DD09071\n\n         TM    WRKSYMFL,WRK$PLUS   Check For \"+\" Suffix        #DD09071\n         BZ    MATH0100            B. If Not                   #DD09071\n         AH    R1,WRKNUM           Add Numeric Suffix          #DD09071\n         B     MATH0200                                        #DD09071\n\nMATH0100 DS    0H                                              #DD09071\n         TM    WRKSYMFL,WRK$MINUS  Check For \"-\" Suffix        #DD09071\n         BZ    MATH0600            B. If Not                   #DD09183\n         SH    R1,WRKNUM           Subtract Numeric Suffix     #DD09071\n\nMATH0200 DS    0H                                              #DD09071\n         CLC   WRKMAX,=AL2(0)      Check For A Max Value       #DD09071\n         BE    MATH0500            B. If Not                   #DD09071\n         TM    WRKSYMFL,WRK$ZERO   Check If Zeros Are Allowed  #DD09071\n         BO    MATH0300            B. If Yes                   #DD09071\n         LTR   R1,R1               Check For Positive Value    #DD18023\n         BNP   MATH0450            B. If Zero or Negative      #DD18023\n         CH    R1,WRKMAX           Check Against Maximum Value #DD09071\n         BNH   MATH0400            B. If Not Over Max          #DD09071\n         SH    R1,WRKMAX           Subtract Range Value        #DD09071\n         B     MATH0200            Loop Till Within Range      #DD09071\n\nMATH0300 DS    0H                                              #DD09071\n         CH    R1,WRKMAX           Check Against Maximum Value #DD09071\n         BL    MATH0400            B. If Not Over Max          #DD09071\n         SH    R1,WRKMAX           Subtract Range Value        #DD09071\n         B     MATH0200            Loop Till Within Range      #DD09071\n\nMATH0400 DS    0H                                              #DD09071\n         TM    WRKSYMFL,WRK$ZERO   Check If Zeros Are Allowed  #DD09071\n         BO    MATH0500            B. If Yes                   #DD09071\n         LTR   R1,R1               Check For Minimum Value     #DD09071\n         BNZ   MATH0500            B. If Not Too Low           #DD09071\n         LHI   R1,1                Set To Minimum Value        #DD09071\n         B     MATH0500                                        #DD18023\n\nMATH0450 DS    0H                                              #DD18023\n         LR    R2,R1                                           #DD18023\n         LH    R1,WRKMAX           Load Maximum Value          #DD18023\n         AR    R1,R2               Add Zero or Negative Value  #DD18023\n         LTR   R1,R1               Check If Still Negative     #DD18023\n         BNP   MATH0450            B. If Not                   #DD18023\n\nMATH0500 DS    0H                                              #DD09071\n         CVD   R1,WRKDBL1          Convert Changed Number      #DD09071\n         OI    WRKDBL1+7,X'0F'     Ensure Correct Sign         #DD09071\n         UNPK  WRKCHAR(8),WRKDBL1(8)                           #DD09071\n\n         LA    R1,WRKCHAR+7        A(Last Byte Of Number)      #DD09071\n         SR    R1,R6               A(Start Of Converted Number)#DD09071\n         #EXEC R6,MVC,0(*-*,R5),0(R1)                          #DD09071\n\nMATH0600 DS    0H                                              #DD09183\n         NI    WRKSYMFL,255-WRK$ZERO                           #DD09071\n\nMATHEXIT DS    0H                                              #DD09183\n         LM    R15,R1,WRKMATH      Re-Load Variable Addr/Len   #DD09183\n         IPEND ,                   Return To Caller            #DD09183\n\n         #STARTWA PATCH=NO\n         IPROC MODE=DEFINE         Define Save Area Stack      #DD09143\n\nTIMEDATE DS    0D                  Time & Date Values          #DD09071\nWRKTIME  DS    F                   - Time                      #DD09071\nWRKDATE  DS    F                   - Date                      #DD09071\n\nWRKYEAR  DS    H                   Current Year CCYY           #DD09071\nWRKDPY   DS    H                   Days In The Current Year    #DD09071\n\nWRKCCYYC DS    CL4                 \"CCYY\" Character Format     #DD09071\nWRKCCYYB DS    H                   \"CCYY\" Binary Format        #DD09071\nWRKDDDB  DS    H                   \"DDD\" Binary Format         #DD09071\nWRKTODAY DS    H                   Today's \"DDD\" Binary Value  #DD09071\n\nWRKCHAR  DS    CL8                 Numeric Output Field        #DD09071\n\nWRKSYMFL DS    X\nWRK$DOT  EQU   B'10000000'         Symbol Ends With A Period\nWRK$PLUS EQU   B'01000000'         Addition Requested          #DD09071\nWRK$MINUS EQU  B'00100000'         Subtraction Requested       #DD09071\nWRK$ZERO  EQU  B'00010000'         Math Can Return Zero        #DD09071\n\nWRKNUMF  DS    C                   Internal Table Flag (Y / N) #DD09071\nWRKSUFFL DS    H                   Numeric Suffix Length       #DD09071\nWRKNUM   DS    H                   Numeric Suffix Value        #DD09071\nWRKCVAL  DS    H                   Current +/- Value           #DD15062\n\nWRKMAX   DS    H                   Maximum \"Math\" Value        #DD09071\n\nWRKSYMB@ DS    A                   System Symbol Table Starting Address\n\nWRKSYM@  DS    A\nWRKSYML  DS    XL1\nWRKSYM   DS    CL65\n\nWRKMATH  DS    16F                 Math Routine Save Area      #DD09183\n\nWRKTRTAB DS    XL256\n\n*        Temporary Symbol Output Area\nWCCYY    DS    C'CCYY'\nWD       DS    C'00'                                           #DD09049\nWDD      DS    C'DD'\nWDDD     DS    C'DDD'\nWDDMMYY  DS    C'DDMMYY'                                       #DD09071\nWDDMMYYYY DS   C'DDMMCCYY'                                     #DD09071\nWDOW     DS    C'DAYOFWEEK'\nWHH      DS    C'HH'                                           #DD09071\nWHHMM    DS    C'HHMM'\nWHHMMSS  DS    C'HHMMSS'\nWHHMMSST DS    C'HHMMSST',C'H'                                 #DD09121\nWJOBNAME DS    C'ABCDEFGH'\nWJOBID   DS    C'JOB12345'                                     #DD09118\nWMM      DS    C'MM'                                           #DD09071\nWMMDDYY  DS    C'MMDDYY'                                       #DD09071\nWMMDDYYYY DS   C'MMDDCCYY'                                     #DD09071\nWMONTH   DS    C'MM'\nWSMFID   DS    C'SYS1'\nWSS      DS    C'SS'                                           #DD09071\nWYY      DS    C'YY'\nWYYDDD   DS    C'YYDDD'                                        #DD09071\nWYYDDMM  DS    C'YYDDMM'                                       #DD09071\nWYYMMDD  DS    C'YYMMDD'                                       #DD09071\nWYYYYDDD DS    C'CCYYDDD'                                      #DD09071\nWYYYYDDMM DS   C'CCYYDDMM'                                     #DD09071\nWYYYYMMDD DS   C'CCYYMMDD'                                     #DD09071\nWYYYYDDD2 DS   C'YYYY/DDD'                                     #DD09079\nWYYYYDDD3 DS   C'YYYY.DDD'                                     #DD14280\n         #STOPWA ,\n\nBLANKS   DC    CL256' '\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        Internal Symbols                                          *\n*                                                                  *\n*        NOTE: Symbol String Must Be At Least As Long As           *\n*              It's Substituted Value (Including &)                *\n*              This Is An IBM Symbol Restriction.                  *\n*                                                                  *\n*------------------------------------------------------------------*\n\n*      Machine Length, Spare Flag, Symbol Name, Processing Routine\nINTERNAL DS    0F\n         DC    AL1(3,0),CL8'ZDAY    ',AL4(ZDAY)     DD         #DD09071\n         DC    AL1(3,0),CL8'ZDOW    ',AL4(ZDOW)     Mon        #DD09049\n         DC    AL1(5,0),CL8'ZJDATE  ',AL4(ZJDATE)   DDD        #DD09071\n         DC    AL1(7,0),CL8'ZJOBNAME',AL4(ZJOBNAME) JName      #DD09071\n         DC    AL1(5,0),CL8'ZJOBID  ',AL4(ZJOBID)   JOB12345   #DD09118\n         DC    AL1(5,0),CL8'ZMONTH  ',AL4(ZMONTH)   MM         #DD09071\n         DC    AL1(7,0),CL8'ZMONTHCH',AL4(ZMONTHCH) JANUARY    #DD09183\n         DC    AL1(3,0),CL8'ZMOY    ',AL4(ZMOY)     JAN        #DD09183\n         DC    AL1(5,0),CL8'ZSMFID  ',AL4(ZSMFID)   SMFId      #DD09071\n         DC    AL1(7,0),CL8'ZSTDYEAR',AL4(ZSTDYEAR) CCYY       #DD09071\n         DC    AL1(4,0),CL8'ZTIME   ',AL4(ZTIME)    HHMM       #DD09071\n         DC    AL1(5,0),CL8'ZTIMEL  ',AL4(ZTIMEL)   HHMMSS     #DD09071\n         DC    AL1(5,0),CL8'ZTIMET  ',AL4(ZTIMET)   HHMMSST    #DD09121\n         DC    AL1(2,0),CL8'ZHH     ',AL4(ZHH)      HH         #DD09071\n         DC    AL1(2,0),CL8'ZMM     ',AL4(ZMM)      MM         #DD09071\n         DC    AL1(2,0),CL8'ZSS     ',AL4(ZSS)      SS         #DD09071\n         DC    AL1(2,0),CL8'ZWD     ',AL4(ZWD)      #          #DD09071\n         DC    AL1(7,0),CL8'ZWEEKDAY',AL4(ZWEEKDAY) Monday     #DD09071\n         DC    AL1(4,0),CL8'ZYEAR   ',AL4(ZYEAR)    YY         #DD09071\n\n         DC    AL1(5,0),CL8'DDMMYY  ',AL4(DDMMYY)   DDMMYY     #DD09071\n         DC    AL1(7,0),CL8'DDMMYYYY',AL4(DDMMYYYY) DDMMYYYY   #DD09071\n         DC    AL1(5,0),CL8'MMDDYY  ',AL4(MMDDYY)   MMDDYY     #DD09071\n         DC    AL1(7,0),CL8'MMDDYYYY',AL4(MMDDYYYY) MMDDYYYY   #DD09071\n         DC    AL1(4,0),CL8'YYDDD   ',AL4(YYDDD)    YYDDD      #DD09071\n         DC    AL1(5,0),CL8'YYDDMM  ',AL4(YYDDMM)   YYDDMM     #DD09071\n         DC    AL1(5,0),CL8'YYMMDD  ',AL4(YYMMDD)   YYMMDD     #DD09071\n         DC    AL1(6,0),CL8'YYYYDDD ',AL4(YYYYDDD)  YYYYDDD    #DD09071\n         DC    AL1(7,0),CL8'YYYYDDMM',AL4(YYYYDDMM) YYYYDDMM   #DD09071\n         DC    AL1(7,0),CL8'YYYYMMDD',AL4(YYYYMMDD) YYYYMMDD   #DD09071\n         DC    AL1(7,0),CL8'YYYY/DDD',AL4(YYYYDDD2) YYYY/DDD   #DD09079\n         DC    AL1(7,0),CL8'YYYY*DDD',AL4(YYYYDDD3) YYYY.DDD   #DD14280\n\n         DC    AL1(255)            End Of Internal Symbol List\n\n\nNUMERTAB DC    256X'FF'            Find Non-Numerics           #DD09071\n         ORG   NUMERTAB+C'0'                                   #DD09071\n         DC    10X'00'             0-9                         #DD09071\n         ORG   ,                                               #DD09071\n\nMONTHS   DC    C'01',AL2(07),CL10'JANUARY   '                  #DD09183\nMONTHSL  EQU   *-MONTHS                                        #DD09183\n         DC    C'02',AL2(08),CL10'FEBRUARY  '                  #DD09183\n         DC    C'03',AL2(05),CL10'MARCH     '                  #DD09183\n         DC    C'04',AL2(05),CL10'APRIL     '                  #DD09183\n         DC    C'05',AL2(03),CL10'MAY       '                  #DD09183\n         DC    C'06',AL2(04),CL10'JUNE      '                  #DD09183\n         DC    C'07',AL2(04),CL10'JULY      '                  #DD09183\n         DC    C'08',AL2(06),CL10'AUGUST    '                  #DD09183\n         DC    C'09',AL2(09),CL10'SEPTEMBER '                  #DD09183\n         DC    C'10',AL2(07),CL10'OCTOBER   '                  #DD09183\n         DC    C'11',AL2(08),CL10'NOVEMBER  '                  #DD09183\n         DC    C'12',AL2(08),CL10'DECEMBER  '                  #DD09183\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        DSECTs                                                    *\n*                                                                  *\n*------------------------------------------------------------------*\n\n*\n*        This Is The Parameter List Passed To IEFUJV Via R1\n*\nPLIST    DSECT ,     Word Offset\nP1JMR    DS    A      1     +0         Address Of JMR\nP1JCL    DS    A      2     +4         Address Of JCL Statement\nP1TYPE   DS    A      3     +8         Address Of Statement Type\n*        0 - Null Statement Card Image.\n*        1 - JOB Statement Card Image.\n*        2 - EXEC Statement Card Image.\n*        4 - DD Statement Card Image.\n*        8 - PROC Statement Card Image From Cataloged Procedure.\n*       16 - All JCL Has Been Converted.\n*       32 - All JCL Has Been Interpreted.\n*       64 - JCL Definition Table Defined (JDT) Statement Card Image.\n*      128 - Extended JCL Statement Type Card Image.\nP1CNVPRM DS    A      4    +12         Address Of Converter Parm\n* .......1 - Programmer Name Required.\n* ......1. - Account Number Required.\n* .....1.. - Enabled To Run With The SWA Located In Virtual Storage\n*            Above 16 Megabytes.\nP1SUBSYS DS    A      5    +16         Address Of ASCH, JES2, Or JES3\nP1ENVIR  DS    A      6    +20         Address Of Environment Indicator\n*        1 - APPC Scheduler Utility TP Add Call\n*        2 - APPC Scheduler Utility TP Retrieve Call\n*        3 - APPC Scheduler Utility TP Reconvert Call\n\n         #DSECTS CVT,PSA,JMR,TCT,TCB,ASCB,ASXB,SCT,LCT,JCT,JSCB,SSIB,  *\n               SMCA\n\n         PRINT NOGEN\n         ASASYMBP DSECT=YES,LIST=YES,SYMBP=YES,SYMBT=YES,SYMBTE=YES\n         IHAASSB ,                                             #DD09183\n         IAZJSAB ,                                             #DD09183\n         IHASTCB ,                                             #DD09183\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCLSYMBL": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\t\\x18\\x7f\\x01\\t\\x18\\x7f\\x106\\x00v\\x00v\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-07-06T00:00:00", "modifydate": "2009-07-06T10:36:46", "lines": 118, "newlines": 118, "modlines": 0, "user": "DOC"}, "text": " ----------------------------------------------------------------------\n\n   Function:\n             Replace symbols on \"SET\" JCL statements with their\n             current values.\n\n ----------------------------------------------------------------------\n\n   All \"SET\" JCL statements will be scanned.\n\n   All supported symbols will be substituted at submission time\n   with the symbol's value at that time.\n   As the substitution is performed by an IEFUJV exit routine it\n   will perform the substition at that time on the processing\n   system.  In other words, if a job is submitted on SYSTEM A and\n   executes on SYSTEM B, the symbols would have been translated\n   by SYSTEM A.  If you are using system dependent symbols (ie.\n   &SYSNAME.) then the job must execute on the submitting lpar.\n   This also goes for other variables.  The current TIME may not\n   be the same on each system.  Although &ZJOBNAME. is one that\n   will never change, &ZJOBID. could change if the job is passed\n   to another node.\n\n   Due to these caviots it is unlikely that IBM will ever provide\n   addtional support for system symbols in batch.\n\n ----------------------------------------------------------------------\n\n   Please terminate your symbols with a period.  A \"blank\" is\n   also accepted as a terminator but it is best to use symbols\n   as they are defined by IBM documentation.\n\n   Internal Symbols:\n     &ZDAY.        - DD\n     &ZDOW.        - WED\n     &ZJDATE.      - DDD\n     &ZJOBNAME.    - JOBNAME\n     &ZMONTH.      - MM\n     &ZMONTHCH.    - JANUARY\n     &ZMOY.        - JAN\n     &ZSMFID.      - SMFI\n     &ZSTDYEAR.    - CCYY\n     &ZTIME.       - HHMM\n     &ZTIMEL.      - HHMMSS\n     &ZTIMET.      - HHMMSST\n     &ZWD.         - # - Day of the week 1:Monday / 7:Sunday\n     &ZWEEKDAY.    - Wednesday\n     &ZYEAR.       - YY\n     &ZHH.         - HH\n     &ZMM.         - MM\n     &ZSS.         - SS\n\n     &DDMMYY.      -\n     &DDMMYYYY.    -\n     &MMDDYY.      -\n     &MMDDYYYY.    -\n     &YYDDD.       - Various date formats\n     &YYDDMM.      -\n     &YYMMDD.      -\n     &YYYYDDD.     -\n     &YYYYDDMM.    -\n     &YYYYMMDD.    -\n\n     &YYYY/DDD.    - YYYY/DDD\n\n   System Symbols:\n     All symbols defined in IEASYMxx\n\n     z/OS Defined:\n     &SYSCLONE. &SYSNAME. &SYSPLEX. &SYSR1. &SYSR2. etc.\n\n ----------------------------------------------------------------------\n\n   Addition & Subtraction Are Allowed On Numeric Internal Symbols.\n\n   You can code:\n        // SET LASTWEEK=&ZJDATE-7.\n   This will give you the julian date for one week prior to today.\n\n   The symbol name must be terminated with a \"+\" or \"-\" and the\n   numeric portion should be terminated with a period.\n   (ie. &YYDDD+1. or &YYDDD-07.)\n\n   The general rule for the \"Math\" process is that the number will\n   be in units of the symbol.\n\n   For Example:\n   &DDMMYY.,   &DDMMYYYY., &MMDDYY.,   &MMDDYYYY., &YYDDD.,\n   &YYDDMM.,   &YYMMDD.,   &YYYYDDD.,  &YYYYDDMM., &YYYYMMDD.\n   &ZDAY.,     &ZDOW.,     &ZJDATE.,   &ZWD.,      &ZWEEKDAY.,\n   &YYYY/DDD.\n   Are \"Day\" symbols.  The \"+\" or \"-\" value will adjust the symbol\n   by the specified number of days.\n\n   &STDYEAR.,  &ZYEAR.,\n   Are \"Year\" symbols.  The \"+\" or \"-\" value will adjust the symbol\n   by the specified number of years.\n\n   &ZMONTH., &ZMONTHCH., And &ZMOY.\n   Is a \"Month\" symbol.  The \"+\" or \"-\" value will adjust the symbol\n   by the specified number of months.\n\n   &HH.,\n   Is an \"Hour\" symbol.  The \"+\" or \"-\" value will adjust the symbol\n   by the specified number of hours.\n\n   &MM.,\n   Is a \"Minutes\" symbol.  The \"+\" or \"-\" value will adjust the symbol\n   by the specified number of minutes.\n\n   &SS.,\n   Is a \"Seconds\" symbol.  The \"+\" or \"-\" value will adjust the symbol\n   by the specified number of seconds.\n\n   The &ZTIME., &ZTIMEL., &ZJOBNAME., &ZSMFID. And IEASYMxx\n   symbols will ignore any \"+\" or \"-\" adjustment.\n\n ----------------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCLSYMBS": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\t\\x18\\x7f\\x01\\t\\x18\\x7f\\x106\\x00/\\x00/\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-07-06T00:00:00", "modifydate": "2009-07-06T10:36:54", "lines": 47, "newlines": 47, "modlines": 0, "user": "JCL"}, "text": "//*\n//*    IF YOU \"INCLUDE\" THIS MEMBER IN YOUR JCL YOU'LL BE ABLE TO USE\n//*    ALL OF THESE VARIABLES.\n//*\n//* INTERNALLY DEFINED VARIABLES:\n//     SET ZDAY='&ZDAY.'\n//     SET ZJDATE='&ZJDATE.'\n//     SET ZJOBID='&ZJOBID.'\n//     SET ZJOBNAME='&ZJOBNAME.'\n//     SET ZMONTH='&ZMONTH.'\n//     SET ZMONTHCH='&ZMONTHCH.'\n//     SET ZMOY='&ZMOY.'\n//     SET ZSMFID='&ZSMFID.'\n//     SET ZSTDYEAR='&ZSTDYEAR.'\n//     SET ZTIME='&ZTIME.'\n//     SET ZTIMEL='&ZTIMEL.'\n//     SET ZTIMET='&ZTIMET.'\n//     SET ZWEEKDAY='&ZWEEKDAY.'\n//     SET ZYEAR='&ZYEAR.'\n//*\n//* DATE VARIABLES:\n//     SET DDMMYY='&DDMMYY.'\n//     SET DDMMYYYY='&DDMMYYYY.'\n//     SET MMDDYY='&MMDDYY.'\n//     SET MMDDYYYY='&MMDDYYYY.'\n//     SET YYDDD='&YYDDD.'\n//     SET YYDDMM='&YYDDMM.'\n//     SET YYMMDD='&YYMMDD.'\n//     SET YYYYDDD='&YYYYDDD.'\n//     SET YYYYDDMM='&YYYYDDMM.'\n//     SET YYYYMMDD='&YYYYMMDD.'\n//     SET LOGDATE='&YYYY/DDD.'\n//*\n//     SET YESTERDY='&YYYYDDD-1.'\n//     SET TOMORROW='&YYYYDDD+1.'\n//*\n//* SYSTEM SYMBOLS  (ADD WHATEVER SYMBOLS YOU HAVE DEFINED IN IEASYMXX)\n//     SET SYSALVL='&SYSALVL.'\n//     SET SYSCLONE='&SYSCLONE.'\n//     SET SYSNAME='&SYSNAME.'\n//     SET SYSPLEX='&SYSPLEX.'\n//     SET SYSR1='&SYSR1.',SYSR2='&SYSR2.'\n//     SET UNIXVER='&UNIXVER.'\n//*\n//* COMBINED SYMBOLS\n//     SET DSNDATE='D&ZYEAR.&ZMONTH.&ZDAY.'\n//     SET DSNTIME='T&ZTIMEL.'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LDS": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x07\\xf1\\x07\\xf1\\x00\\x04\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 2033, "newlines": 2033, "modlines": 4, "user": "SOURCE"}, "text": "LDS      TITLE   'LDS - TSO \"LISTDS\" + \"LSPACE\" REPLACEMENT COMMAND'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n***********************************************************************\n**                                                                    *\n**   FUNCTION-                                                        *\n**      THE LDS COMMAND DISPLAYS BASIC ATTRIBUTES OF USER SPECIFIED   *\n**     DATASETS, EITHER CATALOGUED OR UNCATALOGUED.                   *\n**                                                                    *\n**   SYNTAX-                                                          *\n**      LDS 'DSLIST' SPACE DCB MEMBERS FROM(MEMBER) TO(MEMBER) LOCATE *\n**                   VOL(VOLSER LIST)                                 *\n**                                                                    *\n**      REQUIRED- 'DSLIST'                                            *\n**      DEFAULTS- NONE                                                *\n**                                                                    *\n**   OPERANDS                                                         *\n**      'DSLIST'  - A LIST OF ONE OR MORE DSNAMES CONFORMING          *\n**                  TO TSO DATASET NAMING CONVENTIONS, FOR            *\n**                  WHICH THE INFORMATION IS REQUESTED. IF A          *\n**                  DATASET IS NOT CATALOGUED, THE USER IS            *\n**                  PROMPTED FOR A VOLUME/SERIAL NUMBER.              *\n**                                                                    *\n**      DCB       - THE FOLLOWING DCB ATTRIBUTES ARE LISTED.          *\n**                    .DSORG                                          *\n**                    .RECFM                                          *\n**                    .LRECL                                          *\n**                    .BLKSIZE                                        *\n**                    .OPTCD                                          *\n**                    .KEYLEN                                         *\n**                    .RKP                                            *\n**                    .CREATE DATE                                    *\n**                    .EXPIRY DATE                                    *\n**                    .DATE LAST REFERENCED                           *\n**                                                                    *\n**      SPACE     - THE FOLLOWING SPACE PARAMETERS ARE LISTED.        *\n**                    .TRACKS ALLOCATED                               *\n**                    .TRACKS USED                                    *\n**                    .NUMBER OF EXTENTS                              *\n**                    .SECONDARY ALLOCATION                           *\n**                                                                    *\n**      MEMBERS   - MEMBER AND ALIAS NAMES OF PARTITIONED             *\n**                  DATASETS ARE DISPLAY. ALIASES ARE FLAGGED         *\n**                  WITH AN ASTERISK(*). THE NUMBER OF                *\n**                  DIRECTORY BLOCKS USED AND NOT USED ARE            *\n**                  ALSO DISPLAYED.                                   *\n**                                                                    *\n**                - A MASK MAY BE ENTERED WITH THE MEMBERS PARAMETER  *\n**                  TO CONTROL WHICH MEMBER NAMES WILL BE DISPLAYED.  *\n**                - A ? FOLLOWED BY 1 OR MORE CHARACTERS, INDICATES   *\n**                  THAT THE MEMBER NAME MUST END WITH THE CHARACTERS *\n**                  FOLLOWING THE ?.                                  *\n**                - AN * IS A PLACE HOLDER IN THE MASK. THE CORRES-   *\n**                  PONDING POSITION IN THE MEMBER NAME MAY CONTAIN   *\n**                  ANY NON-BLANK CHARACTER.                          *\n**                                                                    *\n**      ALL       - THIS IS EQUIVALENT TO SPECIFYING 'DCB', 'SPACE',  *\n**                  AND 'MEMBERS' PARAMETERS. I.E. ALL OPTIONS ARE    *\n**                  TO BE USED.                                       *\n**                                                                    *\n**      FROM      - THE BEGINNING MEMBER NAME OF A RANGE OF NAMES     *\n**                  TO BE LISTED BY THE 'MEMBERS' OPERAND. IF THIS    *\n**                  OPERAND IS OMITTED, THE MEMBER NAMES ARE LISTED   *\n**                  STARTING AT THE BEGINNING MEMBER NAME THROUGH TO  *\n**                  THE MEMBER NAME SPECIFIED BY THE 'TO' OPERAND.    *\n**                  IF 'FROM' IS SPECIFIED, 'MEMBERS' IS ASSUMED.     *\n**                                                                    *\n**      TO        - THE LAST MEMBER NAME OF A RANGE OF NAMES TO BE    *\n**                  LISTED BY THE 'MEMBERS' OPERAND. IF THIS OPERAND  *\n**                  IS NOT SPECIFIED THE NAMES STARTING AT THE        *\n**                  'FROM' NAME TO THE LAST MEMBER NAME ARE LISTED.   *\n**                  IF 'TO' IS SPECIFIED, 'MEMBERS' IS ASSUMED.       *\n**                                                                    *\n**      LOCATE    - ALL OCCURRENCES OF THE DATASET(S) ARE LISTED.     *\n**                  THE ONLINE PACKS (DEFAULT) ARE SCANNED            *\n**                  FOR ANY OCCURRENCES OF THE DATASET.               *\n**                                                                    *\n**      VOL       - A LIST OF VOLSERS WHICH ARE TO BE SCANNED         *\n**                  FOR THE DATASETS.                                 *\n**                                                                    *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TO DO:                                                       *\n*        - IF MULTI-VOLUME DATASET & VOL(...) IS NOT SPECIFIED        *\n*          DISPLAY SPACE INFORMATION FOR ALL VOLUMES.                 *\n*          SAMPLE OUTPUT:                                             *\n*           SPACE: UNITS--ALLOC---USED--EXTENTS--2NDARY QTY--VOLUME   *\n*                  TRKS   48593  48593     12    1000 TRKS   VOL001   *\n*                  TRKS   20957  20957      2    1000 TRKS   VOL002   *\n*                                                                     *\n*---------------------------------------------------------------------*\n**                                                                    *\n**       HISTORY: #DD03312 - USE DSCB MAPPING & FLAGS.                *\n**                           DISPLAY LARGE SECONDARY (> 999)          *\n**                #DD05150 - USE UCBCHAN RATHER THAN UCBNAME.         *\n**                #DD11328 - CORRECT /DEVICE NAME FOR DYNALLOC.       *\n**                #DD12062 - Add EAV Support.                         *\n**                #DD16151 - Add PDS/E Percent Used.                  *\n**                                                                    *\n***********************************************************************\n\nLDS      CSECT ,\n         USING *,R15\n***********************************************************************\n***  SET UP OUR SAVE AREA AND CHAINING PTRS.\n***********************************************************************\n\n         SAVE  (14,12),,*         SAVE CALLER'S REGISTERS\n         #COPY GEN,BR=YES,YEAR=1999\n         LR    R2,R1              GET ADDRESS OF CPPL FROM TMP.\n         USING CPPL,R2            SET UP ADDRESSABILITY TO IT.\n         USING PSA,0\n\n***********************************************************************\n*  REGISTER 13 IS USED AS A BASE REGISTER IN THIS PROGRAM. BECAUSE OF *\n*  THIS, EXTREME CARE SHOULD BE TAKEN IF CHANGING THE FOLLOWING CODE. *\n***********************************************************************\n\n         BALR  R15,0              SET UP TEMPORARY BASE\n         USING *,R15              SET UP ADDRESSABILITY TO BASE\n         LA    R1,SAVEAREA        LOAD ADDRESS OF THIS SAVEAREA\n         ST    R1,8(R13)          STORE ADDRESS OF THIS SAVEAREA IN\n*                                 CALLERS SAVEAREA\n         ST    R13,SAVEAREA+4     STORE ADDRESS OF CALLERS SAVEAREA\n*                                 IN THIS SAVEAREA\n         LR    R13,R1             LOAD ADDRESS OF THIS SAVEAREA\n*                                 INTO R13\n         B     LDSCONT            BRANCH AROUND ADDRESSES\n         DROP  R15                DROP TEMPORARY BASE\n         DS    0F                 FULLWORD BOUNDARY FOR BASE\n         USING *,R13,R11,R12      ESTABLISH NEW BASE REGISTERS\nSAVEAREA DC    18F'-1'\nBASE2    DC    A(SAVEAREA+4096)\nBASE3    DC    A(SAVEAREA+8192)\nLDSCONT  DS    0H\n         LM    R11,R12,BASE2      LOAD SECOND AND THIRD BASE REGS.\n\n***********************************************************************\n\n         EXTRACT EXTOUT,'S',FIELDS=(TIOT,TSO)\n         L     R10,TSOFLAG        LOAD ADDRESS OF T.S. FLAG\n         TM    0(R10),X'80'       IS TSO FLAG ON???\n         BO    TSO                YES...\n         OI    NOPSKIP+1,X'F0'\nTSO      DS    0H\n\n***********************************************************************\n*** EXTRACT THE DATASET NAME PREFIX FROM THE USER'S PROFILE TABLE\n***********************************************************************\n\n         L     R5,CPPLPSCB        GET ADDRESS OF PSCB\n         USING PSCB,R5            SET UP ADDRESSABILITY TO IT.\n         L     R6,PSCBUPT         GET ADDRESS OF UPT\n         SR    R7,R7              ZERO OUT REG. 7\n         IC    R7,23(R6)          PLACE PREFIX LENGTH INTO REG. 7\n         ST    R7,DSNPREFL        STORE THE PREFIX LENGTH FOR LATER\n         MVC   DSNPREF(7),16(R6) STORE THE PREFIX FOR LATER\n\n***********************************************************************\n***  BUILD THE PARSE PARAMETER LIST (PDL) AND\n***  THE DAIR PARAMETER LIST (DAPL).\n***********************************************************************\n\n         L     R3,CPPLUPT         ADDRESS OF UPT\n         L     R4,CPPLECT         ADDRESS OF ECT\n         LA    R5,ECB             EVENT CONTROL BLOCK\n         LA    R7,IOPLADS\n         STM   R3,R5,0(R7)\n         L     R6,=A(PCL)         ADDRESS OF PARSE CONTROL LIST\n         LA    R7,PARSEPDL        ADDRESS OF PARSE DESCRIPTOR LIST\n         L     R8,CPPLCBUF        ADDRESS OF COMMAND BUFFER\n         SR    R9,R9              ANSWER WORD AREA\n         STM   R3,R9,WRKPPL       STORE INTO PARSE PARAMETER LIST\n         L     R6,CPPLPSCB        ADDRESS OF PSCB\n         STM   R3,R6,DAPL         STORE INTO DAIR PARAMETER LIST\n         ST    R6,DFPBPSCB        STORE PSCB ADDRESS IN DFPB\n         L     R6,=A(DFPB)        ADDRESS OF DFPB\n         STM   R3,R6,DFPL         STORE INTO DEFAULT PARAMETER LIST\n         LA    R3,DSNLEN          ADDRESS OF DSNLEN, DSN\n         ST    R3,DFPBDSN         STORE IN DFPB\n         MVI   DFPBCODE,X'04'     SET DFPB CODE FOR DEFAULT\n         DROP  R2                 FREE REGISTER 2\n\n***********************************************************************\n***  LINK TO THE PARSING ROUTINE TO PARSE THE INPUT COMMAND.\n***********************************************************************\n\n         LA    R1,WRKPPL          LOAD ADDRESS OF WRKPPL\n         LINK  EP=IKJPARS         LINK TO PARSE ROUTINE\n         LTR   R15,R15            CHECK FOR ZERO RETURN CODE\n         BNZ   BADRET             NOPE -> TROUBLE WITH PARSE.\n         CLC   PARSEPDL,=XL4'FF000000' CHECK FOR VALID ADDRESS.\n         BNE   CHKCMD\nBADRET   DS    0H\n         LA    R9,BADMSG\n         BAL   R10,ONEMESSG\n         B     CMDEND\n\n***********************************************************************\n***  CHECK OUT THE COMMAND PARAMETERS.\n***********************************************************************\n\nCHKCMD   DS    0H\n         L     R10,PARSEPDL       GET ADDRESS OF OUR PDE LIST\n         USING IKJPARMD,R10       SET UP ADDRESSABILITY TO IT\n         MVC   REQFLAGS(5),=CL5'NNNYN' SET REQUEST FLAGS\n* CHECK THE 'ALL' PARAMETER.\n         LH    R8,ALLWD           GET ALL VALUE FROM PDE\n         CH    R8,=H'2'           WAS 'ALL' SPECIFIED?\n         BNE   CHKDCB             NO...\n         MVC   DCB(3),=C'YYY'     YES...TURN ON DCB, SPACE AND MEMBERS\n         B     CHKLOCA            SKIP CHECKING OF NEXT 3 PARMS\n* CHECK THE 'DCB' PARAMETER.\nCHKDCB   DS    0H\n         LH    R8,DCBWD           GET DCB VALUE FROM PDE\n         CH    R8,=H'2'           WAS 'DCB' SPECIFIED\n         BNE   CHKSPACE           NO...LEAVE 'N'\n         MVI   DCB,C'Y'           YES...TURN ON 'Y'\n* CHECK THE 'SPACE' PARAMETER.\nCHKSPACE DS    0H\n         LH    R8,SPACEWD         GET SPACE VALUE FROM PDE\n         CH    R8,=H'2'           WAS 'SPACE' SPECIFIED\n         BNE   CHKMEM             NO...LEAVE 'N'\n         MVI   SPACE,C'Y'         YES...TURN ON 'Y'\n* CHECK THE 'MEMBERS' PARAMETER.\nCHKMEM   DS    0H\n         LH    R8,MEMBWD          GET MEMBERS VALUE FROM PDE\n         CH    R8,=H'2'           WAS 'MEMBERS' SPECIFIED\n         BNE   CHKLOCA            NO..CONTINUE\n         MVI   MEMB,C'Y'          MEMBER LIST WANTED\n         L     R2,MASK            GET ADDRESS OF MASK\n         LTR   R2,R2              IS IT ZERO?\n         BZ    CHKLOCA            YES, CONTINUE THERE IS NO MASK\n         MVI   MASKFLG,C'Y'       TURN ON MASK INDICATOR\n         LH    R3,MASK+4          GET LENGTH OF MASK\n         BCTR  R3,0               DECREASE LENGTH BY 1 FOR MOVE\n         LA    R5,MEMBMASK        STORE ADDRESS OF STORAGE AREA\n*                                 FOR MASK\n         #EXEC R3,MVC,0(*-*,R5),0(R2)\n* CHECK THE 'LOCATE' PARAMETER.\nCHKLOCA  DS    0H\n         LH    R8,LOCWD           GET LOCATE VALUE FROM PDE\n         CH    R8,=H'2'           WAS 'LOCATE' SPECIFIED\n         BE    CHKVOL             YES...SKIP NEXT INSTRUCTION\n         MVI   LOCATE,C'N'        NO LOCATE SCAN WANTED\n* CHECK THE 'VOL' PARAMETER\nCHKVOL   DS    0H\n         LA    R4,VOLTABLE        STORAGE TABLE\n         USING VOLPDE,R2          R2 ADDRESSABILITY TO VOL PDE\n         SR    R2,R2              CLEAR\n         L     R2,VOLSER          GET VOLSER VALUE FROM PDE\n         LTR   R2,R2              WAS 'VOL' SPECIFIED???\n         BZ    DEFAULT            NO...SET DEFAULT LIST\n         MVI   LOCATE,C'Y'\n         LA    R2,VOLSER          YES...ADDRESS OF FIRST VOLSER PDE\n         L     R6,ADDRVOL         ADDRESS OF VOLSER\n         CLC   0(3,R6),=CL3'ALL'  DOES HE WANT ALL VOLUMES???\n         BNE   LOADADDR+4         NO...CONTINUE PROCESSING...FILL TABLE\n         B     DEFAULTT           YES...SET DEFAULT LIST\nLOADADDR DS    0H\n         L     R6,ADDRVOL         ADDRESS OF VOLSER\n         LH    R3,LENVOL          LENGTH OF VOLSER ENTRY\n         CH    R3,=H'2'           MINIMUM OF 2             PT/MAY86\n         BL    NEXTONE\n         CH    R3,=H'6'           MAX. OF 6 CHARACTERS\n         BNH   *+8\n         LA    R3,6\n         BCTR  R3,R0              DECREMENT FOR MOVE AND COMPARISON\n         STH   R3,0(0,R4)         STORE FOR COMPARES\n         #EXEC R3,MVC,2(*-*,R4),0(R6)\nNEXTONE  DS    0H\n         LA    R4,8(,R4)          NEXT ENTRY IN TABLE\n         L     R2,NEXTVOL         ADDRESS OF NEXT VOL PWE\n         C     R2,=XL4'FF000000' ARE THERE ANY MORE???\n         BNE   LOADADDR           YES...CONTINUE\n         MVC   0(4,R4),0(R2)      MOVE 'FF000000' TO EOT\n         B     CHKFROM            CHECK NEXT PARM\nDEFAULT  DS    0H\n         CLI   LOCATE,C'N'        WAS 'LOCATE' SPECIFIED???\n         BE    CHKFROM            NO...\nDEFAULTT DS    0H\n         MVC   VOLTABLE(20),DEFAULTV YES...MOVE IN DEFAULT VOLSER LIST\n         B     CHKFROM\nDEFAULTV DC    H'2',CL6'RES   ',H'2',CL6'SYS   ',X'FF000000'\n* CHECK THE 'FROM' PARAMETER.\nCHKFROM  DS    0H\n         L     R2,FROM            GET ADDRESS OF 'FROM' STRING\n         LTR   R2,R2              IS IT ZERO?\n         BZ    CHKTO              YES- USE THE DEFAULT\n         MVI   MEMB,C'Y'          SET 'MEMBERS' INDICATOR TO 'YES'\n         LH    R3,FROM+4          GET LENGTH OF 'FROM' STRING\n         BCTR  R3,0               DECRMENT LENGTH BY 1 FOR MOVE\n         LA    R5,FRMEMB          GET ADDRESS OF 'FROM' NAME\n         #EXEC R3,MVC,0(*-*,R5),0(R2)\n* CHECK THE 'TO' PARAMETER.\nCHKTO    DS    0H\n         L     R2,TO              GET ADDRESS OF 'TO' STRING\n         LTR   R2,R2              IS IT ZERO?\n         BZ    CHKDCBSP           YES- USE THE DEFAULT\n         MVI   MEMB,C'Y'          SET 'MEMBERS' INDICATOR TO 'YES'\n         LH    R3,TO+4            GET LENGTH OF 'TO' STRING\n         BCTR  R3,0               DECRMENT LENGTH BY 1 FOR MOVE\n         LA    R5,TOMEMB          GET ADDRESS OF 'TO' NAME\n         #EXEC R3,MVC,0(*-*,R5),0(R2)\n* DID HE ASK FOR ANY OF DCB, SPACE OR MEMBER INFORMATION???\nCHKDCBSP DS    0H\n         CLC   DCB(3),=C'NNN'     DID HE ASK FOR DCB,SPACE,MEMBER???\n         BNE   SKIPTO             ONE OF THEM...SO LEAVE HIM ALONE\n         MVC   DCB(2),=C'YY'      NO..SO TURN ON DEFAULTS FOR DCB,SPACE\nSKIPTO   DS    0H\n\n***********************************************************************\n***  LOOP THROUGH THE PARSE DESCRIPTOR ENTRIES (PDE'S) AND\n***  PROCESS EACH DSNAME FOUND.\n***********************************************************************\n\n         LA    R8,DSNLIST         GET ADDRESS OF THE FIRST DSN PDE\n         USING DSNPDE,R8          SET UP ADDRESSABILITY TO IT\n         DROP  R10                FREE REGISTER 10\nNEXTDSN  DS    0H\n         BAL   R10,BLDDSN         BRANCH TO BUILD FULL DSNAME.\n         XC    FLGS,FLGS\n         CLI   LOCATE,C'Y'        WAS 'LOCATE' SPECIFIED?\n         BE    PACKSCAN           IF SO, DO PACK SCANING\n         BAL   R10,FINDONE        OTHERWISE, USE THE CATALOGUE\n         B     GETPDE             GET THE NEXT DATASET NAME\nPACKSCAN DS    0H\n         BAL   R10,FINDALL        BRANCH TO PACK SCANNING RTN\nGETPDE   DS    0H\n         L     R6,NEXTPDE         GET ADDRESS OF THE NEXT PDE\n         C     R6,=XL4'FF000000' ARE THERE ANY MORE???\n         BE    CMDEND\n         LR    R8,R6\n         B     NEXTDSN\n\n***********************************************************************\n***  RETURN TO THE TSO TERMINAL MONITOR PROGRAM.\n***********************************************************************\n\nCMDEND   DS    0H\n         L     R13,4(,R13)        RESET REGISTER 13\n         RETURN (14,12),T,RC=0    RETURN TO THE TMP.\n         LTORG ,\n\n***********************************************************************\n***  THIS ROUTINE SEARCHES THE CATALOGUE FOR THE SPECIFIED DATASET.\n***  IF AN ENTRY IS FOUND FOR THE DATASET, THE REQUESTED INFORMATION\n***  IS DISPLAYED. IF THE DATASET IS NOT CATALOGUED, THE USER IS\n***  PROMPTED FOR A VOLUME SERIAL NUMBER.\n***********************************************************************\n\nFINDONE  DS    0H\n         ST    R10,SAVE10         STORE THE RETURN ADDRESS\n         BAL   R10,DETVOL         GET THE VOL/SER NUMBER\n         LTR   R9,R9              IS EVERYTHING OKAY?\n         BZ    CONTIN0            YES...\n         CH    R9,=H'2'           WAS RETURN = 2 ?\n         BE    FORETRN            YES..DATASET NOT CATALOGUED AND\n*                                 VOLSER NOT SPECIFIED\n         MVI   ERRMSG,C' '\n         MVC   ERRMSG+1(79),ERRMSG\n         LA    R5,ERRMSG\n         AH    R5,DSNLEN\n         MVC   ERRMSG(44),DSN\n         MVC   1(35,R5),ALLONACC\n         LA    R9,ERRMSGP\n         BAL   R10,ONEMESSG\n         B     FORETRN\nCONTIN0  DS    0H\n         LA    R5,VOL             ADDRESS OF VOLSER\n         BAL   R10,ALLODSET       ATTEMPT TO ALLOCATE THIS DATASET\n         LTR   R9,R9              WAS IT SUCCESSFUL?\n         BNZ   FORETRN            IF NOT- RETURN TO MAINLINE\n         BAL   R10,GETDSCB        BRANCH TO READ DSCB'S\n         LTR   R9,R9              WAS THE DSCB READ SUCCESSFUL?\n         BNZ   FREEDS             IF NOT- TRY NEXT PDE.\n         CLI   DCB,C'Y'           DOES HE WANT DCB INFO?\n         BNE   *+8                NO, SKIP NEXT INSTRUCTION\n         BAL   R10,LISTDCB        BRANCH TO LIST DCB INFO.\n         CLI   SPACE,C'Y'         DOES HE WANT SPACE INFO?\n         BNE   *+8                NO, SKIP NEXT INSTRUCTION\n         BAL   R10,LISTSPC        BRANCH TO LIST SPACE INFO.\n         CLI   MEMB,C'Y'          DOES HE WANT MEMBER NAMES?\n         BNE   *+8                NO, SKIP NEXT INSTRUCTION.\n         BAL   R10,LISTMEM        BRANCH TO LIST MEMBER NAMES.\nFREEDS   DS    0H\n         BAL   R10,FREEDSET       FREE UP THE CURR. DATASET ALLOC.\nFORETRN  DS    0H\n         L     R10,SAVE10         RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n\n***********************************************************************\n***  THIS ROUTINE USES THE UCB ADDRESS TABLE TO GET THE VOLUME SERIAL\n***  NUMBER OF EACH ONLINE PACK WHICH IS MOUNTED. EACH SUCH PACK\n***  IS SCANNED FOR THE EXISTENCE OF THE SPECIFIED DATASET. IF THE\n***  DATASET EXISTS ON A PACK, THE REQUESTED INFORMATION IS THEN\n***  DISPLAYED AND THE NEXT PACK IS THEN SCANNED.\n***********************************************************************\n\nFINDALL  DS    0H\n         ST    R10,SAVE10         STORE THE RETURN ADDRESS\n         LOCATE CATBLK            CHECK IF DATASET IS CATALOGUED?\n         BAL   R10,CHKALIAS       GO SEE IF IT'S DATASET NAME WAS\n*                                 AN ALIAS\n         MVC   DSNLINE+5(75),DSNLINE+4 BUILD DISPLAY LINE\n         MVC   DSNLINE+7(44),DSN  MOVE IN THE DATASET NAME\n         LA    R4,DSNLINE         GET DSN LINE ADDRESS\n         AH    R4,DSNLEN          POSITION FOR OUR MESSAGE\n         CH    R15,=H'0'          WAS DATASET CATALOGUED?\n         BE    CATLGD             YES..\n         CH    R15,=H'8'          IS IT UNAUTHORIZED???\n         BNE   NOTCATLG           NO...SOME OTHER PROBLEM\n         CH    R0,=H'56'          IS IT UNAUTHORIZED???\n         BE    FARETRN            YES...SO BYPASS AND GET OUT OF HERE\n         B     NOTCATLG\nCATLGD   DS    0H\n         MVC   10(17,R4),=CL17'IS CATALOGUED ON '\n         MVC   27(6,R4),WKAREA+6 MOVE IN THE VOLUME SERIAL NUMBER\n         B     TPUTDSNL           BRANCH TO TPUT CODE\nNOTCATLG DS    0H\n         MVC   10(18,R4),=CL18'IS NOT CATALOGUED.'\nTPUTDSNL DS    0H\n         LA    R9,DSNLINEP\n         BAL   R10,ONEMESSG\n         XC    FLGS,FLGS          INDICATE DATASET NOT FOUND YET\n\n*   THIS CODE REPLACES THE OLD UCB SEARCH ROUTINE AND IS BOTH\n*   MVS/370 AND MVS/XA COMPATABLE.               ***        MAY83   ***\n*   AGAIN...REPLACED CVTUCBSC WITH UCBSCAN       ***   DSD  MAY98   ***\n\n         XC    UCBSWORK,UCBSWORK  INITIALIZE WORK AREA         #DD98129\nNEXTUCB1 DS    0H\n         UCBSCAN COPY,            REQUEST A COPY OF A UCB      #DD98129*\n               DEVNCHAR=UCBDEV#,                               #DD98129*\n               DEVCLASS=DASD,                                  #DD98129*\n               DYNAMIC=YES,                                    #DD98129*\n               RANGE=ALL,                                      #DD98129*\n               UCBAREA=UCBSAREA,                               #DD98129*\n               WORKAREA=UCBSWORK,                              #DD98129*\n               MF=(E,UCBSLST)                                  #DD98129\n         LTR   R15,R15            ARE YOUR HANDS DIRTY ? NO MORE UCBS ?\n         BNZ   UCBEND             IF SO, GO WASH THEM.  WE ARE DONE.\n         LA    R3,UCBSAREA        A(RETURNED UCB)              #DD98129\n         USING UCBOB,R3\n         TM    UCBSTAT,UCBONLI    CHECK FOR ONLINE STATUS ???\n         BNO   NEXTUCB1           IF NOT TRY TRY AGAIN\n***   ***   ***   ***   ***   ***   ***   ***   ***        MAY83   ***\n\n         LA    R4,VOLTABLE\n         SR    R5,R5\nDOWANT   DS    0H\n         LH    R5,VOLTABLE\n         EX    R5,COMPVOL\n         BE    GOCHECK\n         LA    R4,8(,R4)\n         CLI   0(R4),X'FF'\n         BE    NEXTUCB1\n         B     DOWANT\nCOMPVOL  CLC   2(0,R4),UCBVOLI     EXECUTED\nGOCHECK  DS    0H\n         MVC   VOL,UCBVOLI        LOAD IN PACK VOLUME SERIAL NUMBER\n         UNPK  DYNAMUCB+1(5),UCBCHAN(3)                        #DD11328\n         TR    DYNAMUCB+1(4),HEXTAB-C'0'                       #DD11328\n         MVI   DYNAMUCB+5,C' '                                 #DD11328\n         MVC   UCBTYPE,UCBUNTYP   STORE UCB DEVICE TYPE CODE\n         STM   R2,R3,SAVE28\n         BAL   R10,ALLODSET       ATTEMPT DATASET ALLOCATION\n         LTR   R9,R9              DID IT WORK?\n         BNZ   DONEPACK           IF NOT, SKIP THIS PACK\n         BAL   R10,GETDSCB        ATTEMPT TO READ THE DSCB'S\n         LTR   R9,R9              DID WE GET THEM?\n         BNZ   FREEUP             IF NOT, SKIP THIS PACK\n         OI    FLGS,FOUND         INDICATE DATASET HAS BEEN FOUND\n         CLI   DCB,C'Y'           DOES HE WANT DCB INFO?\n         BNE   *+8                NO, SKIP NEXT INSTRUCTION\n         BAL   R10,LISTDCB        BRANCH TO LIST DCB INFO.\n         CLI   SPACE,C'Y'         DOES HE WANT SPACE INFO?\n         BNE   *+8                NO, SKIP NEXT INSTRUCTION\n         BAL   R10,LISTSPC        BRANCH TO LIST SPACE INFO.\n         CLI   MEMB,C'Y'          DOES HE WANT MEMBER NAMES?\n         BNE   *+8                NO, SKIP NEXT INSTRUCTION.\n         BAL   R10,LISTMEM        BRANCH TO LIST MEMBER NAMES.\nFREEUP   DS    0H\n         BAL   R10,FREEDSET       FREE UP THE CURR. DATASET ALLOC.\nDONEPACK DS    0H\n         LM    R2,R3,SAVE28       RESTORE REGISTERS 2 AND 3\n         B     NEXTUCB1           UCB\nUCBEND   DS    0H\n         TM    FLGS,FOUND+ALLOERR DATASET FOUND /ALLOC ERROR?\n         BNZ   FARETRN            IF SO, RETURN TO MAINLINE\n         LA    R4,DSNLINE         GET DSNLINE ADDRESS\n         AH    R4,DSNLEN\n         MVC   10(23,R4),=CL23'WAS NOT FOUND.    '\n         LA    R9,DSNLINEP\n         BAL   R10,ONEMESSG\nFARETRN  DS    0H\n         L     R10,SAVE10         RESTORE RETURN REGISTER\n         BR    R10                RETURN TO MAINLINE\nSAVREG03 DC    F'0'\nH3       DC    H'3'\nH13      DC    H'13'\nDS3PTRDS DC    CL5' '\n\n***********************************************************************\n***  THIS ROUTINE PROCESSES ONE DSNAME FROM THE PDE LIST.\n***  IT TAKES THE CURRENT DSNAME AND IF IT WAS NOT ENTERED\n***  IN QUOTES, THE DATASET NAME PREFIX IS ADDED TO THE\n***  BEGINNING OF IT. THE FULL DATASET NAME IS THEN STORED\n***  IN THE FIELD CALLED 'DSN'.\n***********************************************************************\n\nBLDDSN   DS    0H\n         SR    R9,R9\n         MVI   DSN,C' '           SET DSNAME FIELD TO BLANKS\n         MVC   DSN+1(43),DSN\n         L     R6,ADDRDSN         GET THE ADDRESS OF THE CURRENT DSN\n         LH    R5,LENDSN          GET THE DSNAME LENGTH\n         TM    FLGSDSN,X'C0'      WAS IT SPECIFIED WITHIN QUOTES?\n         BNO   NOQUOTES           IF NO, THEN BUILD FULL DSN.\nDECREM5  DS    0H\n         STH   R5,DSNLEN          STORE THE DSN LENGTH\n         BCTR  R5,0               DECREMENT LENGTH BY 1 FOR EX\n         #EXEC R5,MVC,DSN(*-*),0(R6)\n         BR    R10                RETURN TO MAINLINE\nNOQUOTES DS    0H\n         LA    R4,DSN             GET ADDRESS OF OUR DSN FIELD\n         L     R3,DSNPREFL        GET THE DSN PREFIX LENGTH\n         LTR   R3,R3              DID HE SPECIFY 'NOPREFIX' IN PROFILE?\n         BZ    DECREM5            YES...USE DSN AS IS\n         BCTR  R3,0               DECREMENT IT BY 1 FOR EX\n         #EXEC R3,MVC,DSN(*-*),DSNPREF\n         AR    R4,R3              ADD LENGTH TO ADDRESS\n         MVI   1(R4),C'.'         STICK IN THE DOT AFTER THE PREFIX\n         LA    R4,2(,R4)          GET ADDRESS OF NEXT BLANK BYTE\n         SR    R3,R3              CLEAR REG. 3\n         LH    R3,LENDSN          GET THE LENGTH OF THE DSN\n         BCTR  R3,0               DECREMENT IT BY 1 FOR EX\n         #EXEC R3,MVC,0(*-*,R4),0(R6)\n         L     R3,DSNPREFL        GET DSN PREFIX LENGTH\n         AH    R3,LENDSN          ADD LENGTH OF SUPPLIED DSN\n         LA    R3,1(,R3)          INCREMENT LENGTH BY 1 FOR DOT\n         STH   R3,DSNLEN          STORE THE DSN LENGTH\n         LA    R1,DFPL            CHECK FOR A FULLY QUALIFIED DSN\n         LINK  EP=IKJEHDEF        LINK TO DEFAULT SERVICE RTN\n         MVC   STDSN,DSN          STORE DSN IN CASE ITS AN ALIAS\n         BR    R10                RETURN TO MAINLINE.\n\n***********************************************************************\n***  THIS ROUTINE DETERMINES THE VOLUME/SERIAL NUMBER FOR THE\n***  CURRENT DATASET. IF THE DATASET IS CATALOGUED, IT OBTAINS\n***  THE VOLUME/SERIAL NUMBER FROM THE CATALOGUE. OTHERWISE IT\n***  PROMPTS THE USER FOR THE VOLUME/SERIAL NUMBER.\n***  ONCE THIS IS DONE, IT THEN GOES AND OBTAINS THE DSCB'S\n***  FOR THE CURRENT DATASET AND RETURNS.\n***********************************************************************\n\nDETVOL   DS    0H\n         MVC   VOL(6),=CL6' '\n         ST    R10,DETSTORE\n         LOCATE CATBLK            READ THE CATALOGUE FOR THE DSN\n         BAL   R10,CHKALIAS       GO SEE IF DSNAME WAS AN ALIAS\n         LTR   R9,R15             DID WE GET A VALID ENTRY?\n         BZ    GOTCAT             IF YES, MOVE VOLSER NUMBER\n         MVI   ERRMSG,C' '\n         MVC   ERRMSG+1(79),ERRMSG  SET MESSAGE BUFFER TO BLANKS\n         MVC   ERRMSG(44),DSN\n         LA    R4,ERRMSG\n         AH    R4,DSNLEN\n         MVC   1(18,R4),=CL18'IS NOT CATALOGUED.'\n         LA    R9,ERRMSGP\n         BAL   R10,ONEMESSG\n\nNOPSKIP  NOP   SKIPDS              SELF MODIFYING CODE (BARF)\n         TPUT  GETVOLM,L'GETVOLM,ASIS PROMPT THE USER FOR\n         TGET  TGETVOL,10         THE VOLUME SERIAL NUMBER.\n         LTR   R15,R15            DID WE GET IT FROM HIM?\n         BNZ   SKIPDS             IF NO, SKIP THIS DATASET\n         LTR   R1,R1              IS THE LENGTH ZERO?\n         BZ    SKIPDS             YES, SKIP THIS DATASET.\n         MVC   VOL(6),TGETVOL     MOVE VOL/SER FROM MESSAGE BUFFER\n         OC    VOL(6),BLK8        CONVERT TO UPPERCASE\n         SR    R9,R9              INDICATE NO ERRORS SO FAR\n         B     GOTCAT1\nSKIPDS   DS    0H\n         LA    R9,2               SET RETURN CODE REGISTER\n         L     R10,DETSTORE       RESTORE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\nGOTCAT   DS    0H\n         MVC   VOL,WKAREA+6       MOVE VOL/SER FROM WORK AREA\nGOTCAT1  DS    0H\n         SR    R9,R9\n\n*   THIS CODE REPLACES THE OLD UCB SEARCH ROUTINE AND IS BOTH\n*   MVS/370 AND MVS/XA COMPATABLE.   ***   ***   ***        MAY83   ***\n*   AGAIN...REPLACED CVTUCBSC WITH UCBSCAN       ***   DSD  MAY98   ***\n\n         XC    UCBSWORK,UCBSWORK  INITIALIZE WORK AREA         #DD98129\nNEXTUCB2 DS    0H\n         UCBSCAN COPY,            REQUEST A COPY OF A UCB      #DD98129*\n               DEVNCHAR=UCBDEV#,                               #DD98129*\n               DEVCLASS=DASD,                                  #DD98129*\n               DYNAMIC=YES,                                    #DD98129*\n               RANGE=ALL,                                      #DD98129*\n               UCBAREA=UCBSAREA,                               #DD98129*\n               WORKAREA=UCBSWORK,                              #DD98129*\n               MF=(E,UCBSLST)                                  #DD98129\n         LTR   R15,R15            ARE YOUR HANDS DIRTY ? NO MORE UCBS ?\n         BNZ   UCBEND2            IF SO, GO WASH THEM.  WE ARE DONE.\n         LA    R3,UCBSAREA        A(RETURNED UCB)              #DD98129\n         USING UCBOB,R3\n         TM    UCBSTAT,UCBONLI    CHECK FOR ONLINE STATUS ???\n         BNO   NEXTUCB2           IF NOT TRY TRY AGAIN\n***   ***   ***   ***   ***   ***   ***   ***   ***        MAY83   ***\n\n         CLC   VOL,UCBVOLI        IS THIS THE ONE WE'RE LOOKING FOR\n         BNE   NEXTUCB2           NO....TRY NEXT UCB\n         SR    R9,R9\n         UNPK  DYNAMUCB+1(5),UCBCHAN(3)                        #DD11328\n         TR    DYNAMUCB+1(4),HEXTAB-C'0'                       #DD11328\n         MVI   DYNAMUCB+5,C' '                                 #DD11328\n         MVC   UCBTYPE,UCBUNTYP   STORE UCB DEVICE TYPE CODE\n         L     R10,DETSTORE\n         BR    R10\nUCBEND2  DS    0H\n         LA    R9,1\n         L     R10,DETSTORE\n         BR    R10\n         LTORG ,\n\n***********************************************************************\n*** THIS ROUTINE DETERMINES IF THE DATASET NAME SPECIFIED IN THE LDS **\n*** COMMAND IS AN ALIAS, AND IF IT IS CALCULATES THE CORRECT DATASET **\n*** NAME LENGTH.                                                     **\n***********************************************************************\nCHKALIAS DS    0H\n         CLC   DSN,STDSN           IS DSNAME FROM LOCATE = DSNAME\n*                                  ENTERED WITH LDS COMMAND?\n         BE    CHKRET              YES..DSNAME NOT AN ALIAS\n         LA    R2,DSN              START OF DSN FIELD\n         LA    R3,DSN+43           END OF DSN FIELD\nCHK010   DS    0H\n         CLI   0(R3),C' '          IS THIS THE END OF THE DSNAME?\n         BNE   CHK020              YES..\n         BCT   R3,CHK010           NO..KEEP LOOKING\nCHK020   DS    0H\n         SR    R3,R2\n         LA    R3,1(,R3)           LENGTH OF DSNAME\n         STH   R3,DSNLEN           STORE LENGTH\nCHKRET   DS    0H\n         BR    R10                 RETURN\n\n***********************************************************************\n***  THIS ROUTINE ATTEMPTS TO ALLOCATE THE CURRENT DATASET.          **\n***  UPON RETURN, REGISTER 9 CONTAINS THE RESULT OF THE ALLOCATION   **\n***********************************************************************\nALLODSET DS    0H\n         ST    R10,RETADDR\n         MVC   DYNAMVOL(6),VOL     PUT VOLUME SERIAL IN CTL LIST\n         MVC   DYNAMDSN(44),DSN\n         MVC   DYNAMDDN(2),=C'$$'\n         MVC   DYNAMDDN+2(6),VOL\n         OBTAIN DSCBLK,EADSCB=OK  ATTEMPT TO GET FMT 1 DSCB    #DD12062\n         LTR   R9,R15             CHECK FOR SUCCESS\n         BZ    LINKALLO\n         CLI   LOCATE,C'Y'        CHECK FOR PACK SCANNING\n         BE    ALLOERET\n         B     DSCBERR            NO...SKIP THIS PACK TO AVOID\n*               ENQ ERROR WITH IBM ALLOCATION ERROR\nLINKALLO DS    0H\n         CLI   MEMB,C'Y'              MEMBER LIST WANTED?\n         BNE   SUCCESS                IF NOT, RETURN\n         LA    R1,DYNRBADD\n         DYNALLOC ,\n         LTR   R15,R15\n         BZ    SUCCESS\n         OI    FLGS,ALLOERR           SET FLAG TO ALLOC ERROR\n         CLI   LOCATE,C'Y'            FOR LOCATE, BYPASS THE MESSAGES\n         BE    ALLOERET\n\n         LA    R14,DYNAMRB\n         S99FAIL\n\n         B     ALLOERET\n\n*\n*  SUCCESSFUL COMPLETION\n*\nSUCCESS  DS    0H\n         MVC   SYSLIB+40(8),DYNAMDDN\n         MVC   FAIRDDDN,DYNAMDDN          SAVE DDNAME FOR LIBRARIAN\n         BR    R10\n\n*\n*  R15 = 4\n*  AN ERROR RESULTED FROM THE CURRENT ENVIRONMENT, THE UNAVAILABILITY\n*  OF A SYSTEM RESOURCE, OR A SYSTEM ROUTINE FAILURE.\n*\n\n*\n*  R15 = 8\n*  THE INSTALLATION VALIDATION ROUTINE DENIED THE REQUEST.\n*\n*\n*  R15 = 12\n*  THE ERROR IS DUE TO AN INVALID PARAMETER LIST.\n*\n\n*\n*  SUCCESSFUL COMPLETION\n*\nALLOERET DS    0H\n         LA    R9,1               RAISE THE ERROR FLAG\n         L     R10,RETADDR        RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n         LTORG ,\n\n***********************************************************************\n***  THIS ROUTINE FREES UP THE CURRENT DATASET ALLOCATION.\n***********************************************************************\nFREEDSET DS    0H\n         FREE  DDN=DDNPTR,ERROR=FREEERR\nFREEERR  DS    0H\n         BR    R10                RETURN TO MAINLINE\n\n***********************************************************************\n***  THIS ROUTINE FIRST DISPLAYS THE FULL DATASET NAME, AND THEN\n***  THE VOLUME SERIAL NUMBER. IT THEN ATTEMPTS TO READ INTO CORE\n***  THE DATASET CONTROL BLOCKS FOR THE CURRENT DATASET.\n***********************************************************************\nGETDSCB  DS    0H\n         ST    R10,RETADDR        STORE THE RETURN ADDRESS\n         MVC   DSNLINE+5(75),DSNLINE+4 CLEAR DSNAME PRINT LINE\n         MVC   DSNLINE+7(44),DSN  MOVE IN THE DSNAME\n         LA    R4,DSNLINE         GET ADDRESS OF THE DSN LINE\n         AH    R4,DSNLEN          ADD LENGTH OF DSN\n         MVC   10(8,R4),=CL8'VOLUME: ' MOVE IN THE VOLUME\n         MVC   18(6,R4),VOL       SERIAL NUMBER\n         LA    R9,DSNLINEP\n         BAL   R10,ONEMESSG\n         SR    R9,R9\n\n         OBTAIN DSCBLK,EADSCB=OK  ATTEMPT TO GET FMT 1 DSCB    #DD12062\n         LTR   R15,R15            CHECK FOR SUCCESS\n         BNZ   DSCBERR            IF NOT, INFORM USER\n\n         SR    R9,R9\n         CLI   WKAREA,C'8'        IS IT A FORMAT 8 DSCB?       #DD13118\n         BE    PROCDSCB                                        #DD13118\n         CLI   WKAREA,C'1'        IS IT A FORMAT 1 DSCB?\n         BNE   DSCBERR            IF NOT, INFORM USER\nPROCDSCB DS    0H                                              #DD13118\n         MVC   DS1FMTID(DS1END-DS1FMTID),WKAREA                #DD03312\n         CLC   DS1PTRDS(5),HEX00  SEE IF A FMT 2 OR 3 EXISTS.\n         BE    DSCBRET            IF NOT, BRANCH TO RETURNING CODE\nOBNEXT   DS    0H\n         OBTAIN NEXTBLK,EADSCB=OK  GET FMT 2 OR FMT 3 DSCB     #DD12062\n         LTR   R15,R15            CHECK FOR SUCCESS\n         BNZ   DSCBERR            IF NOT, INFORM USER.\n         SR    R9,R9\n         CLI   WKAREA+44,C'9'     IS IT A FORMAT 9 DSCB?       #DD13118\n         BE    SKIPFMT9           If Yes, Skip to next DSCB    #DD13118\n         CLI   WKAREA+44,C'3'     IS IT A FMT 3\n         BE    DSCBRET            OKAY. BRANCH TO RETURNING CODE\n         CLI   WKAREA+44,C'2'     IS IT A FMT 2?\n         BNE   DSCBERR        NO...\nSKIPFMT9 DS    0H                                              #DD13118\n         CLC   WKAREA+135(5),HEX00  SEE IF A FORMAT 3 EXISTS\n         BE    DSCBRET        IF NOT, BRANCH TO RETURNING CODE\n         MVC   DS1PTRDS(5),WKAREA+135\n         B     OBNEXT\nDSCBERR  DS    0H\n         LR    R9,R15             DSCB ERROR OCCURRED.\n         C     R9,=F'16'          IS IT GREATER THAN 16\n         BNH   *+8                IF NOT, SKIP NEXT INSTRUCTION\n         LA    R9,20              SET VALUE TO 20 (MAX).\n         LA    R4,DSCBTBL         GET ADDRESS OF DSCB ERROR TABLE\n         AR    R4,R9              ADD REG. 09 TO ADDRESS OF TABLE\n         L     R10,0(,R4)         R10->ERROR MESSAGE\n         C     R15,=F'8'          ERROR CODE = 8???\n         BNE   PUTR10             NO...VOLSER NOT NEEDED IN MESSAGE\n         MVC   27(6,R10),VOL      YES...STORE VOLSER IN CORRECT SPOT\nPUTR10   DS    0H\n         LR    R9,R10\n         BAL   R10,ONEMESSG\n         LA    R9,1               RAISE THE ERROR FLAG.\nDSCBRET  DS    0H\n         L     R10,RETADDR        RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n         LTORG ,\n\n***********************************************************************\n***  THIS ROUTINE DECODES AND FORMATS THE DCB INFORMATION.\n***********************************************************************\n\nLISTDCB  DS    0H\n         ST    R10,RETADDR        STORE THE RETURN ADDRESS\n         MVC   DSORG(3),BLK8      BLANK OUT THE DSORG FIELD\n         MVC   RECFM(5),BLK8      BLANK OUT THE RECFM FIELD\n\n***********************************************************************\n**  DECODE THE DATASET ORGANIZATION.\n***********************************************************************\n\n         LA    R3,DSORGTBL        GET ADDRESS OF THE DSORG TABLE\n         LA    R4,5               GET LENGTH OF A TABLE ENTRY\n         LA    R5,DSORGTBX        ADDRESS OF LAST TABLE ENTRY\nLIDSORG  DS    0H\n         CLC   DS1DSORG(1),4(R3) CHECK FOR DSORG EQUAL\n         BNE   LIDSORGB           IF NO TRY NEXT ENTRY FROM TABLE\nLIDSORGA DS    0H\n         MVC   DSORG(3),1(R3)     MOVE IN THE CHAR. EQUIVALENT\n         B     CHCKVSAM           BRANCH TO DECODE RECFM           |\nLIDSORGB DS    0H\n         BXLE  R3,R4,LIDSORG      GET ADDRESS OF NEXT TABLE ENTRY  |\n         LA    R3,DSORGUN         DSORG IS UNKNOWN                 |\n         B     LIDSORGA           BRANCH TO PUT IT INTO PRT LINE   |\n\n***********************************************************************\n**  CHECK IF THIS HERE MIGHT BE VSAM     82/10/19  ...\n***********************************************************************\n\nCHCKVSAM DS    0H\n         TM    DS1SMSFG,DS1PDSE   Check For PDS/E Dataset      #DD13046\n         BNO   NOTPOE             B. If Not                    #DD13046\n         MVC   DSORG(4),=C'PDSE'                               #DD13046\nNOTPOE   DS    0H\n         CLI   DS1DSORG+1,DS1ORGAM VSAM ?                      #DD03312\n         BNE   DORECFM            NO ........\n         MVC   DSORG(3),=C'VSM'   YES ... THEN SAY SO YOU DUMMY\n\n***********************************************************************\n**  DECODE THE RECORD FORMAT.\n***********************************************************************\n\nDORECFM  DS    0H\n         LA    R4,RECFM           GET ADDRESS OF RECFM IN PRT LINE\n         TM    DS1RECFM,DS1RECFU  TEST FOR UNDEFINED LENGTH    #DD03312\n         BNO   LIRECFA\n         MVI   0(R4),C'U'\n         LA    R4,1(,R4)          INCRMENT NEXT AVAIL CHAR. POSITION\n         B     LIRECFE\nLIRECFA  DS    0H\n         TM    DS1RECFM,DS1RECFF  TEST FOR FIXED LENGTH        #DD03312\n         BNO   LIRECFB\n         MVI   0(R4),C'F'\n         LA    R4,1(,R4)          SET NEXT AVAIL. CHAR. POSITION\n         B     LIRECFC\nLIRECFB  DS    0H\n         TM    DS1RECFM,DS1RECFV  TEST FOR VARYING LENGTH      #DD03312\n         BNO   LIRECFC\n         MVI   0(R4),C'V'\n         LA    R4,1(,R4)          SET NEXT AVAIL. CHAR. POSITION\nLIRECFC  DS    0H\n         TM    DS1RECFM,DS1RECFB  TEST FOR BLOCKED             #DD03312\n         BNO   LIRECFD\n         MVI   0(R4),C'B'\n         LA    R4,1(,R4)          SET NEXT AVAIL. CHAR. POSITION\nLIRECFD  DS    0H\n         TM    DS1RECFM,DS1RECFS  TEST FOR STANDARD            #DD03312\n         BNO   LIRECFE\n         MVI   0(R4),C'S'\n         LA    R4,1(,R4)          SET NEXT AVAIL. CHAR. POSITION\nLIRECFE  DS    0H\n         TM    DS1RECFM,DS1RECMC  TEST FOR MACHINE CTL CHAR.   #DD03312\n         BNO   LIRECFF\n         MVI   0(R4),C'M'\n         LA    R4,1(,R4)          SET NEXT. AVAIL. CHAR. POSITION\n         B     LIRECFG\nLIRECFF  DS    0H\n         TM    DS1RECFM,DS1RECFA  TEST FOR ASA CTL CHAR.       #DD03312\n         BNO   LIRECFG\n         MVI   0(R4),C'A'\n         LA    R4,1(,R4)          SET NEXT AVAIL. CHAR. POSITION\nLIRECFG  DS    0H\n         TM    DS1RECFM,DS1RECFT  TEST FOR TRACK OVERFLOW      #DD03312\n         BNO   DOLRECL\n         MVI   0(R4),C'T'\n\n***********************************************************************\n*** DECODE THE LOGICAL RECORD LENGTH.\n***********************************************************************\n\nDOLRECL  DS    0H\n         LH    R4,DS1LRECL        GET THE LRECL (BINARY FORMAT)\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   LRECL,DWD2+11      STORE VALUE IN PRINT LINE\n\n**********************************************************************\n***  DECODE THE BLOCK SIZE\n**********************************************************************\n\n         LH    R4,DS1BLKL         GET THE BLK LENGTH (BINARY)\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   BLKSIZE,DWD2+11    STORE VALUE IN PRINT LINE\n\n**********************************************************************\n*** DETERMINE HEX REPRESENTATION OF THE OPTCD FIELD\n**********************************************************************\n\n         SR    R4,R4              CLEAR REG. 4\n         IC    R4,DS1OPTCD        GET THE OPTCD CHARACTER\n         SRL   R4,4               CHOP OFF LAST 4 BITS\n         STC   R4,OPTCD           STORE LAST CHAR.\n         TR    OPTCD(1),HEXTAB    CONVERT TO DISPLAY CHAR.\n         IC    R4,DS1OPTCD        GET THE OPTCD CHARACTER\n         N     R4,=XL4'FFFFFF0F' WIPE OUT ALL BUT LAST 4 BITS\n         STC   R4,OPTCD+1         STORE CHAR.\n         TR    OPTCD+1(1),HEXTAB  CONVERT TO DISPLAY CHAR.\n\n**********************************************************************\n*** DECODE THE KEY LENGTH.\n**********************************************************************\n\n         SR    R4,R4              CLEAR REG. 4\n         IC    R4,DS1KEYL         MOVE IN THE KEY LENGTH\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   KEYLEN,DWD2+12     STORE VALUE IN PRINT LINE\n\n**********************************************************************\n*** DECODE THE RELATIVE KEY POSITION.\n**********************************************************************\n\n         MVC   DWD1+2(2),DS1RKP   GET THE RKP FIELD\n         LH    R4,DWD1+2          LOAD IT INTO REG 4\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   RKP,DWD2+13        STORE VALUE IN PRINT LINE\n\n**********************************************************************\n*** DECODE THE CREATE DATE.\n**********************************************************************\n\n         MVC   FWORD(4),HEX00     ZERO OUT A FULLWORD AREA\n         MVC   FWORD(3),DS1CREDT  MOVE IN 3-BYTE CREATE DATE\n         L     R4,FWORD           LOAD IT INTO REG. 4\n         SRL   R4,24              SHIFT TO GET THE YEAR\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   CRTDT,DWD2+14      STORE VALUE IN PRINT LINE\n         L     R4,FWORD           LOAD CRTDT BACK INTO REG. 4\n         SLL   R4,8               SHIFT TO LOSE THE YEAR\n         SRL   R4,16              SHIFT BACK TO GET THE DAY\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   CRTDT+2(3),DWD2+13 STORE VALUE IN PRINT LINE\n         MVZ   CRTDT(5),=C'00000' SET THE ZONE FIELDS\n\n**********************************************************************\n*** DECODE THE EXPIRY DATE\n**********************************************************************\n\n         MVC   FWORD(4),HEX00     ZERO OUT A FULLWORD AREA\n         MVC   FWORD(3),DS1EXPDT  MOVE IN 3-BYTE EXPIRY DATE\n         L     R4,FWORD           LOAD IT INTO REG. 4\n         SRL   R4,24              SHIFT TO GET THE YEAR\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   EXPDT,DWD2+14      STORE VALUE IN PRINT LINE\n         L     R4,FWORD           LOAD EXPDT BACK INTO REG. 4\n         SLL   R4,8               SHIFT TO LOSE THE YEAR\n         SRL   R4,16              SHIFT BACK TO GET THE DAY\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   EXPDT+2(3),DWD2+13 STORE VALUE IN PRINT LINE\n         MVZ   EXPDT(5),=C'00000' SET THE ZONE FIELDS\n\n**********************************************************************\n*** DECODE THE DATE LAST REFERENCED\n**********************************************************************\n\n         MVC   FWORD(4),HEX00     ZERO OUT A FULLWORD AREA\n         MVC   FWORD(3),DS1REFD   MOVE IN 3-BYTE DATE LAST REF'D\n         L     R4,FWORD           LOAD IT INTO REG. 4\n         SRL   R4,24              SHIFT TO GET THE YEAR\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   REFDT,DWD2+14      STORE VALUE IN PRINT LINE\n         L     R4,FWORD           LOAD REFDT BACK INTO REG. 4\n         SLL   R4,8               SHIFT TO LOSE THE YEAR\n         SRL   R4,16              SHIFT BACK TO GET THE DAY\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   REFDT+2(3),DWD2+13 STORE VALUE IN PRINT LINE\n         MVZ   REFDT(5),=C'00000' SET THE ZONE FIELDS\n         LA    R9,DCBTITLE\n         BAL   R10,TWOMESSG\n         L     R10,RETADDR        RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n         LTORG ,\n\n***********************************************************************\n***  THIS ROUTINE DECODES AND FORMATS THE SPACE INFORMATION.\n***********************************************************************\n\nLISTSPC  DS    0H\n         ST    R10,RETADDR        STORE THE RETURN ADDRESS\n         CLI   UCBTYPE,X'0B'      IS IT 3350 ?\n         BNE   D3380\n         MVC   TRKCYL,=H'030'     3350 HAS 30 TRKS/CYL\n         B     LISTALC\nD3380    DS    0H\n         CLI   UCBTYPE,X'0E'      IS IT 3380 ?\n         BNE   D3390                                           #DD98056\n         MVC   TRKCYL,=H'015'     3380 HAS 15 TRKS/CYL\n         B     LISTALC\nD3390    DS    0H\n         CLI   UCBTYPE,X'0F'      IS IT 3390 ?                 #DD98056\n         BNE   D3330              NO - MUST BE 3330 THEN       #DD98056\n         MVC   TRKCYL,=H'015'     3390 HAS 15 TRKS/CYL         #DD98056\n         B     LISTALC                                         #DD98056\nD3330    DS    0H\n         MVC   TRKCYL,=H'019'     3330 HAS 19 TRKS/CYL\n\n***********************************************************************\n**  DETERMINE THE SECONDARY ALLOCATION UNITS (TRKS, CYLS, BLKS)\n***********************************************************************\n\nLISTALC  DS    0H\n         MVC   SECU,=C' TRKS'     ASSUME DEFAULT OF TRACKS\n         TM    DS1SCAL1,DS1CYL    TEST FOR CYLINDERS           #DD03312\n         BNO   LI2NDAA            IF NO, TRY NEXT TEST\n         MVC   SECU,=C' CYLS'     SET TO CYLINDERS\n         B     DO2NDALL           BRANCH TO DECODE THE NUMBER\nLI2NDAA  DS    0H\n         TM    DS1SCAL1,DS1AVR    TEST FOR BLOCKS              #DD03312\n         BNO   DO2NDALL           IF NO, MUST BE TRACKS\n         MVC   SECU,=C' BLKS'     SET TO BLOCKS\n\n***********************************************************************\n**  DETERMINE THE NUMBER OF SECONDARY ALLOCATION UNITS\n***********************************************************************\n\nDO2NDALL DS    0H\n         MVI   FWORD,X'00'        ZERO FIRST BYTE OF FULLWORD\n         MVC   FWORD+1(3),DS1SCAL3 GET THE SECONDARY QTY.      #DD03312\n         L     R4,FWORD           LOAD REG 4\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   SECA,DWD2+11       STORE VALUE INTO PRINT LINE  #DD03312\n\n***********************************************************************\n**  DECODE THE NUMBER OF EXTENTS\n***********************************************************************\n\n         SR    R4,R4              CLEAR REG 4\n         IC    R4,DS1NOEPV        GET NO. OF EXTENTS (BINARY)\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   EXTS,DWD2+14       STORE VALUE IN PRINT LINE\n\n***********************************************************************\n**  DETERMINE AND DECODE THE TOTAL TRACKS ALLOCATED.\n***********************************************************************\n\n         LA    R2,EXTTBL          GET ADDRESS OF EXTENTS TABLE\n         SLR   R4,R4              CLEAR REG 4                  #DD03312\n         ST    R4,TOTRK           INITIALIZE TOTAL TRKS TO 0   #DD03312\n         IC    R4,DS1NOEPV        GET THE NO. OF EXTENTS\n         ST    R3,SAVREG03        SAVE REGISTER 3\n         XR    R3,R3              CLEAR REGISTER 3\n         LH    R3,H3              REG 3, COUNTER FOR 1ST 3 EXT.\nEXT03LP  DS    0H\n         L     R5,0(,R2)          GET NEXT EXTENT ADDRESS\n         USING EXTENT,R5          SET UP ADDRESSABILITY TO IT\n         CLI   ID,X'00'           SEE IF THIS IS THE LAST\n         BE    NOMORE             IF YES, BRANCH\n         SLR   R6,R6                                           #DD03312\n         ICM   R6,3,CCA           GET CYL LOWER LIMIT          #DD03312\n         MH    R6,TRKCYL          CONVERT TO TRACKS\n         SLR   R15,R15                                         #DD03312\n         ICM   R15,3,TTA                                       #DD03312\n         AR    R6,R15             ADD TRKS LOWER LIMIT         #DD03312\n\n         SLR   R7,R7                                           #DD03312\n         ICM   R7,3,CCB           GET CYL UPPER LIMIT          #DD03312\n         MH    R7,TRKCYL          CONVERT TO TRACKS\n         SLR   R15,R15                                         #DD03312\n         ICM   R15,3,TTB                                       #DD03312\n         AR    R7,R15             ADD TRKS UPPER LIMIT         #DD03312\n         LA    R7,1(,R7)          ADD 1 (RELATIVE TRACK ZERO)  #DD03312\n\n         SR    R7,R6              SUBTRACT TO GET NO. TRACKS\n         A     R7,TOTRK           ADD TO TOTAL TRACKS          #DD03312\n         ST    R7,TOTRK           STORE BACK INTO TOTAL TRKS   #DD03312\n         LA    R2,4(,R2)          GET ADDRESS OF NEXT TABLE ENTRY\n         BCTR  R4,0               DECREMENT # OF EXTENTS\n         LTR   R4,R4              ANYMORE EXTENTS?\n         BZ    NOMORE             NO, THEN GET OUT OF LOOP\n         BCT   R3,EXT03LP         STILL WORKING ON FIRST 3 EXT.\n         XR    R3,R3              CLEAR REGISTER 03\n         LH    R3,H13             REG 3,COUNTER FOR NEXT 13 EXT.\nEXT13LP1 DS    0H\n         LA    R2,WKTBL           GET ADDRESS OF WORK TABLE\nEXT13LP2 DS    0H\n         L     R5,0(,R2)          GET NEXT EXTENT ADDRESS\n         USING EXTENT,R5          SET UP ADDRESSABILITY TO IT\n         CLI   ID,X'00'           SEE IF THIS IS THE LAST\n         BE    NOMORE             IF YES, BRANCH\n         SLR   R6,R6                                           #DD03312\n         ICM   R6,3,CCA           GET CYL LOWER LIMIT          #DD03312\n         MH    R6,TRKCYL          CONVERT TO TRACKS\n         SLR   R15,R15                                         #DD03312\n         ICM   R15,3,TTA                                       #DD03312\n         AR    R6,R15             ADD TRKS LOWER LIMIT         #DD03312\n\n         SLR   R7,R7                                           #DD03312\n         ICM   R7,3,CCB           GET CYL UPPER LIMIT          #DD03312\n         MH    R7,TRKCYL          CONVERT TO TRACKS\n         SLR   R15,R15                                         #DD03312\n         ICM   R15,3,TTB                                       #DD03312\n         AR    R7,R15             ADD TRKS UPPER LIMIT         #DD03312\n         LA    R7,1(,R7)          ADD 1 (RELATIVE TRACK ZERO)  #DD03312\n\n         SR    R7,R6              SUBTRACT TO GET NO. TRACKS\n         A     R7,TOTRK           ADD TO TOTAL TRACKS          #DD03312\n         ST    R7,TOTRK           STORE BACK INTO TOTAL TRKS   #DD03312\n         LA    R2,4(,R2)          GET ADDRESS OF NEXT TABLE ENTRY\n         BCTR  R4,0               DECREMENT # OF EXTENTS\n         LTR   R4,R4              ANYMORE EXTENTS?\n         BZ    NOMORE             NO, GET OUT\n         BCT   R3,EXT13LP2        STILL WORKING ON FMT3 DSCB?\n         LA    R3,WKAREA          NO, PREPARE NEXT FMT3 DSCB\n         MVC   DS3PTRDS,135(R3)   GET PTR TO NEXT FMT3 DSCB\n         XR    R3,R3              CLEAR REGISTER 03\n         LH    R3,H13             PREPARE R3 FOR NEXT 13 EXT.\n         OBTAIN NEXT13,EADSCB=OK  GET FMT3 DSCB                #DD12062\n         LTR   R15,R15            IS EVERYTHING OKAY?\n         BNZ   DSCBERR            NO, THEN SAY SO WITH MSG\n         B     EXT13LP1           ELSE KEEP GOING\nNOMORE   DS    0H\n         L     R3,SAVREG03        RESTORE REGISTER 3\n         SR    R4,R4              CLEAR REG 4\n         L     R4,TOTRK           LOAD TOTAL TRACKS INTO REG 4 #DD03312\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   TRKA,DWD2+11       STORE VALUE IN PRINT LINE\n         DROP  R5                 FREE REG 5\n\n***********************************************************************\n**  DETERMINE AND DECODE THE TOTAL TRACKS USED.\n***********************************************************************\n\n         TM    DS1SMSFG,DS1PDSE   Check For PDS/E Dataset      #DD13071\n         BO    FULLDSN                                         #DD13071\n         TM    DS1DSORG,DS1DSGPS+DS1DSGDA+DS1DSGPO             #DD03312\n         BNZ   SPACUSED           YES...ONE OF THEM...USE CALCULATIONS\nFULLDSN  DS    0H                                              #DD13071\n         MVC   TRKU,DWD2+11       DEFAULT TO SPACE ALLOCATED\n         B     SPACUS30                                        #DD16151\nSPACUSED DS    0H\n         XC    DWD1,DWD1           INITIALZE TRACK COUNT       #DD13071\n         MVC   DWD1+2(2),DS1LSTAR                              #DD13071\n         TM    DS1SMSFG,DS1STRP    CHECK FOR EXTENDED FORMAT   #DD13071\n         BZ    SPACUS10            B. IF NOT                   #DD13071\n         MVC   DWD1(2),DS1TRBAL                                #DD13071\n         B     SPACUS20                                        #DD13071\nSPACUS10 DS    0H                                              #DD13071\n         TM    DS1FLAG1,DS1LARGE   CHECK FOR DSNTYPE=LARGE     #DD13071\n         BZ    SPACUS20            B. IF NOT                   #DD13071\n         MVC   DWD1+1(1),DS1TTTHI                              #DD13071\nSPACUS20 DS    0H                                              #DD13071\n         L     R4,DWD1             LOAD USED TRACKS            #DD13071\n         CLI   DS1LSTAR+2,0       CHECK IF NO RECORDS          #DD03312\n         BE    *+8                YES, SKIP NEXT INSTRUCTION\n         LA    R4,1(,R4)          INCREMENT LAST BLOCK PTR BY 1\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   TRKU,DWD2+11       STORE VALUE IN PRINT LINE\n\nSPACUS30 DS    0H                                              #DD16151\n         TM    DS1SMSFG,DS1PDSE   Check For PDS/E Dataset      #DD16151\n         BZ    PRTSPACE           B. If Not                    #DD16151\n*        Call  IGWFAMS    (IGWAMSP0)\n         MVC   FAMSFMH(8),=CL8'IGWFMH'                         #DD16151\n         MVC   FAMSFMH+8(4),=A(FAMSFMHL)                       #DD16151\n         MVC   FAMSFMH+12(4),=X'01000000'  VERSION             #DD16151\n         MVC   FAMSFMH+16(4),=X'00010068'  GETATTR             #DD16151\n         MVC   FAMSFMH+20(4),=X'00000400'                      #DD16151\n         LA    R0,DSNLEN          A(LENGTH,DSNAME)             #DD16151\n         ST    R0,FAMSFMH+24                                   #DD16151\n         MVC   FAMSFMH+60(4),=X'80000000'                      #DD16151\n         MVC   FAMSFMH+116(4),=A(2)                            #DD16151\n         LA    R0,FAMSLIST                                     #DD16151\n         ST    R0,FAMSFMH+120                                  #DD16151\n\n         LA    R0,=CL8'HARPN'                                  #DD16151\n         ST    R0,FAMPTRL1+8                                   #DD16151\n         LA    R0,=CL8'PAGSUSED'                               #DD16151\n         ST    R0,FAMPTRL2+8                                   #DD16151\n         LA    R0,=CL8'MEMCOUNT'                               #DD16151\n         ST    R0,FAMPTRL3+8                                   #DD16151\n         LA    R0,FAMPTRL1                                     #DD16151\n         ST    R0,FAMSLIST+0                                   #DD16151\n         LA    R0,FAMPTRL2                                     #DD16151\n         ST    R0,FAMSLIST+4                                   #DD16151\n         LA    R0,FAMPTRL3                                     #DD16151\n         ST    R0,FAMSLIST+8                                   #DD16151\n\n         MVC   FAMSFMO(8),=CL8'IGWFMO'                         #DD16151\n         MVC   FAMSFMO+8(4),=A(FAMSFMOL)                       #DD16151\n         MVC   FAMSFMO+12(4),=X'01000000'  VERSION             #DD16151\n\n         L     R15,FLCCVT             LOAD CVT POINTER         #DD16151\n         L     R15,CVTDFA-CVT(,R15)   DATA FACILITIES AREA     #DD16151\n         CLC   2(2,R15),=X'3200'                               #DD16151\n         BL    PRTSPACE                                        #DD16151\n         L     R15,DFADFVAD-DFA(,R15)  DFP VECTOR TABLE        #DD16151\n         L     R15,DFVTFMS-DFVT(,R15)  FMS MAIN ENTRY PT       #DD16151\n         LTR   R15,R15                                         #DD16151\n         BZ    PRTSPACE                                        #DD16151\n\n         LA    R1,FAMSPARM        A(Parameter List)            #DD16151\n         LA    R0,FAMSFMH                                      #DD16151\n         ST    R0,0(,R1)                                       #DD16151\n         LA    R0,FAMSFMO                                      #DD16151\n         ST    R0,4(,R1)                                       #DD16151\n         BASSM R14,R15                                         #DD16151\n         LTR   R15,R15                FAMS SUCCESSFUL?         #DD16151\n         BNZ   PRTSPACE               NO                       #DD16151\n\n         L     R2,FAMSFMO+X'60'       HARPN                    #DD16151\n         L     R1,FAMSFMO+X'64'       PAGSUSED                 #DD16151\n\n         MH    R1,=H'100'                                      #DD16151\n         SR    R0,R0                                           #DD16151\n         DR    R0,R2              Calculate Percent Used       #DD16151\n\n         LR    R4,R1              Percent Used                 #DD16151\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE      #DD16151\n         MVC   TRKU,DWD2+11       Insert Used Percentage       #DD16151\n         MVI   TRKU+5,C'%'                                     #DD16151\n\n***********************************************************************\n**  PRINT THE SPACE LINES\n***********************************************************************\n\nPRTSPACE DS    0H\n         LA    R9,SPATITLE\n         BAL   R10,TWOMESSG\n         L     R10,RETADDR        RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n         LTORG ,\n\n***********************************************************************\n***  ROUTINE PDSDSET WILL DISPLAY THE MEMBER NAMES OF THE CURRENT\n***  PARTITIONED DATASET.  ROUTINE DADSET WILL DISPLAY THE MODULES\n***  OF THE CURRENT LIBRARIAN DATASET.\n***********************************************************************\n\nLISTMEM  DS    0H\n         ST    R10,RETADDR        STORE THE RETURN ADDRESS\n         TM    DS1DSORG,DS1DSGPO  CHECK FOR A PDS (PO OR POU)  #DD03312\n         BO    PDSDSET            PROCESS MEMBER LIST\n         TM    DS1DSORG,DS1DSGDA  CHECK FOR A 'DA'(DA OR DAU)  #DD03312\n         BNO   MEMRET             IF NOT, SKIP MEMBER LIST\n         B     DADSET\n\n***********************************************************************\n***  OPEN THIS PARTITIONED DATASET.\n***********************************************************************\n\nPDSDSET  DS    0H\n         MVI   NOM,X'00'          INITIALIZE COUNTERS TO ZERO\n         MVC   NOM+1(15),NOM\n         OPEN  (SYSLIB)           OPEN THE PDS DIRECTORY\n         TM    SYSLIB+48,X'10'    CHECK FOR SUCCESS\n         BNO   CANTOPEN           IF NOT, INFORM USER\n         MVI   MBRLINE,C' '       CLEAR OUT THE MEMBER LIST\n         MVC   MBRLINE+1(75),MBRLINE\n         MVC   MBRLINE(5),=CL5'MBRS:'\n\n***********************************************************************\n***  LOOP THROUGH THE DIRECTORY BLOCKS.\n***********************************************************************\n\n         MVI   LASTDIR,C'N'       LAST DIR. ENTRY NOT FOUND YET.\n         SR    R7,R7              SET LIST COUNTER TO ZERO\n         LA    R5,MBRS            GET ADDRESS OF MEMBER NAME LIST\nGETBLK   DS    0H\n         GET   SYSLIB             READ A DIRECTORY BLOCK\n         L     R3,DIRALL          GET THE CURRENT DIR. CTR\n         LA    R3,1(,R3)          ADD 1 TO IT\n         ST    R3,DIRALL          STORE IT BACK\n         CLI   LASTDIR,C'Y'       CHECK FOR END REACHED.\n         BE    GETBLK             IF SO, READ NEXT BLOCK.\n         LR    R6,R1              GET ADDRESS OF DIR BLK.\n         LH    R2,0(,R1)          GET LENGTH OF DIR. BLK\n         LA    R4,2(,R1)          GET REAL ADDRESS OF DIR. BLK\n         AR    R6,R2              POINT TO LAST BYTE\n         CLC   0(4,R4),HEXFF      SEE IF VALID NAME\n         BNE   VALIDNM            IF NOT, A VALID NAME.\n         MVI   LASTDIR,C'Y'       INDICATE END REACHED.\n         B     GETBLK             BUT KEEP READING DIR. BLOCKS\nVALIDNM  DS    0H\n         L     R3,DIRU            GET THE CURR. DIR. USED CTR\n         LA    R3,1(,R3)          ADD 1 TO IT\n         ST    R3,DIRU            STORE IT BACK\nCHKEND   DS    0H\n         CR    R6,R4             SEE IF THAT WAS LAST ENTRY IN BLOCK\n         BE    GETBLK            YES...\n         CLC   0(4,R4),HEXFF     WAS IT LAST VALID ENTRY???\n         BNE   GOING             NO...\n         MVI   LASTDIR,C'Y'      YES...INDICATE END OF DATA\n         B     GETBLK            BUT KEEP READING DIRECTORY BLOCKS\nGOING    DS    0H\n         L     R3,NOM             GET THE NO. MEMBERS CTR\n         LA    R3,1(,R3)          ADD 1 TO IT\n         ST    R3,NOM             STORE IT BACK\n         TM    11(R4),X'80'       TEST FOR AN ALIAS\n         BNO   CHKRANGE           IF NO, SKIP CTR INCREMENTING\n         L     R3,NOA             GET NO. ALIASES CTR\n         LA    R3,1(,R3)          ADD 1 TO IT\n         ST    R3,NOA             STORE IT BACK\nCHKRANGE DS    0H\n         CLC   0(8,R4),FRMEMB     CHECK TO SEE IF NAME IN RANGE\n         BL    NEXTENT            LESS THEN 'FROM' NAME- FORGET\n         CLC   0(8,R4),TOMEMB     CHECK AGAINST LAST NAME IN RANGE\n         BH    NEXTENT            GREATER THAN 'TO' NAME- FORGET\n         CLI   MASKFLG,C'Y'       IS THERE A MASK?\n         BNE   ACCMEMB            NO..ACCEPT THIS MEMBER\n         MVC   MEMBDATA,0(R4)     YES..\n         MASK  MEMBMASK,MEMBDATA,MAXLEN,MAXLEN  CHECK OUT MEMBER\n         LTR   R15,15             DOES MEMBER NAME FIT MASK?\n         BNZ   NEXTENT            NO..GET NEXT MEMBER\nACCMEMB  DS    0H\n         MVC   2(8,R5),0(R4)      YES PUT NAME IN MEMBER NAME LIST\n         TM    11(R4),X'80'       TEST FOR AN ALIAS\n         BNO   NOTALIAS           IF NO, SKIP NEXT INSTRUCTION\n         MVI   1(R5),C'*'         INDICATE AN ALIAS\nNOTALIAS DS    0H\n         LA    R5,10(,R5)         GET NEXT AVAILABLE NAME POS.\n         LA    R7,1(,R7)          ADD 1 TO NO. IN LIST CTR\n         CH    R7,=H'7'           SEE IF CURRENT LIST FULL\n         BNE   NEXTENT            IF NOT, PROCESS NEXT ENTRY\n         LA    R9,MBRLINEP\n         BAL   R10,ONEMESSG\n         LA    R5,MBRS            RESET ADDRESS OF NEXT SLOT\n         MVI   MBRLINE,C' '       CLEAR OUT THE MBR NAME LINE\n         MVC   MBRLINE+1(75),MBRLINE\n         SR    R7,R7              SET LIST COUNTER TO ZERO\nNEXTENT  DS    0H\n         SR    R2,R2              CLEAR REG. 2\n         IC    R2,11(R4)          GET ENTRY LENGTH\n         SLL   R2,27              DETERMINE ADDRESS OF THE\n         SRL   R2,26              NEXT PDS ENTRY\n         LA    R4,12(R2,R4)       STORE ADDRESS BACK IN REG. 4\n         B     CHKEND             CHECK FOR END\n\n***********************************************************************\n***  CLOSE THE PARTITIONED DATASET AND PRINT LAST LINES.\n***********************************************************************\n\nEOFDIR   DS    0H\n         CLOSE (SYSLIB)           DONE. CLOSE PDS\n         LTR   R7,R7              ANY NAMES IN CURRENT LIST?\n         BZ    PRTENT             IF NOT, DONT PRINT\n         LA    R9,MBRLINEP\n         BAL   R10,ONEMESSG\nPRTENT   DS    0H\n         L     R4,NOM             GET THE NO. OF MEMBERS\n         S     R4,NOA             SUBTRACT THE NO. ALIASES\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   NOMEM,DWD2+12      STORE VALUE IN PRINT LINE\n         L     R4,NOA             GET NO. OF ALIASES\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   NOALIAS,DWD2+12    STORE VALUE IN PRINT LINE\n         L     R4,DIRU            GET NO. OF DIR. BLKS USED\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   DIRUSE,DWD2+13     STORE VALUE IN PRINT LINE\n         L     R4,DIRALL          GET NO. OF DIR. BLKS\n         S     R4,DIRU            SUBTRACT NO. USED -> UNUSED\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   DIRUNUSE,DWD2+13   STORE VALUE IN PRINT LINE\n         PUTLINE PARM=PUTBLOCK,                                        *\n               OUTPUT=(ENTLINE,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         B     MEMRET             BRANCH TO RETURNING CODE\nCANTOPEN DS    0H\n         LA    R9,OPENERR\n         BAL   R10,ONEMESSG\n         LA    R9,1               SET ERROR FLAG.\nMEMRET   DS    0H\n         L     R10,RETADDR        RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n         LTORG ,\n\n***********************************************************************\n***  OPEN THIS LIBRARIAN DATASET.\n***********************************************************************\n\nDADSET   DS    0H\n         LA    R1,FAIROPL         POINT AT OPEN PARM LIST\n         WXTRN FAIROPN\n         ICM   R15,15,=V(FAIROPN) LOAD LIBRARIAN \"OPEN\" ROUTINE\n         BZ    FAIRERR1           B. IF NOT AVAILABLE\n         CALL  (15)\n         LTR   R15,R15            PARM LIST O.K. ?\n         BNZ   FAIRERR1\n         CLI   FAIRORES,C'0'      WERE WE SUCCESSFUL???\n         BE    DACONTIN           YES...\n         LA    R1,FAIRCPL         POINT AT CLOSE PARM LIST\n         WXTRN FAIRCLS\n         ICM   R15,15,=V(FAIRCLS) LOAD LIBRARIAN \"CLOSE\" ROUTINE\n         BZ    FAIRER1B           B. IF NOT AVAILABLE\n         CALL  (15)               FAIR OPENED THE DA DATASET\n         MVC   OPENDA+42(1),FAIRORES NO...SO TELL HIM\nFAIRERR1 DS    0H\n         LA    R9,OPENDA\n         BAL   R10,ONEMESSG\nFAIRER1B DS    0H\n         LA    R9,1               SET ERROR FLAG\n         L     R10,RETADDR        RESTORE THE RETURN ADDRESS\n         BR    R10                RETURN TO MAINLINE\n\n***********************************************************************\n***  LOOP THROUGH THE INDEX\n***********************************************************************\n\nDACONTIN DS    0H\n         XC    NOM(16),NOM\n         MVC   MBRLINE(5),=CL5'MBRS:'\nNEXTLINE DS    0H\n         MVI   MBRLINE+5,C' '     CLEAR OUT THE MEMBER LIST\n         MVC   MBRLINE+6(70),MBRLINE+5\n         SR    R7,R7              SET LIST COUNTER TO ZERO\n         LA    R5,MBRS            GET ADDRESS OF MEMBER NAME LIST\nGETDAMOD DS    0H\n         MVC   MODNAME(8),BLANKS  CLEAR PARAMETER\n         LA    R1,FAIRMPL         POINT AT MOD PARM LIST\n         WXTRN FAIRMOD\n         ICM   R15,15,=V(FAIRMOD) LOAD LIBRARIAN \"MODULE\" ROUTINE\n         BZ    FAIRERR2           B. IF NOT AVAILABLE\n         CALL  (15)\n         LTR   R15,R15            CHECK IF ENVIRONMENT O.K.\n         BNZ   FAIRERR2\n         CLI   FAIRMRES,C'0'      RETURNED WITH A MODULE???\n         BE    SETUP              YES...\n         CLI   FAIRMRES,C'1'      AT END OF INDEX???\n         BE    EOFDA              YES...\n         MVC   LOADERR+39(1),FAIRMRES STORE ERROR CODE\nFAIRERR2 DS    0H\n         LA    R9,LOADERR\n         BAL   R10,ONEMESSG\n         LA    R9,1               SET ERROR FLAG\n         L     R10,RETADDR\n         BR    R10                RETURN TO MAINLINE\nSETUP    DS    0H\n         L     R3,NOM\n         LA    R3,1(,R3)          INCREMENT COUNTER\n         ST    R3,NOM\n         MVC   FAIRMMDN(8),MODNAME\n         CLC   MODNAME(8),FRMEMB  CHECK TO SEE IF NAME IN RANGE\n         BL    GETDAMOD           LESS THAN 'FROM' NAME...FORGET\n         CLC   MODNAME(8),TOMEMB CHECK AGAINST LAST NAME IN RANGE\n         BH    GETDAMOD           GREATER THAN 'TO' NAME...FILE END\n         CLI   MASKFLG,C'Y'       IS THERE A MASK?\n         BNE   ACCMOD             NO..ACCEPT THIS MEMBER\n         MASK  MEMBMASK,MODNAME,8,8   CHECK OUT MEMBER\n         LTR   R15,15             DOES MEMBER NAME FIT MASK?\n         BNZ   GETDAMOD           NO..GET NEXT MEMBER\nACCMOD   DS    0H\n         MVC   2(8,R5),MODNAME\n         LA    R5,10(,R5)         GET NEXT AVAILABLE NAME POSITION\n         LA    R7,1(,R7)          ADD 1 TO NUMBER IN LIST CTR.\n         CH    R7,=H'7'           SEE IF CURRENT LIST FULL\n         BNE   GETDAMOD           IF NOT,PROCESS NEXT ENTRY\n         LA    R9,MBRLINEP\n         BAL   R10,ONEMESSG\n         MVC   MBRLINE(5),BLANKS  CLEAR OUT 'MBRS:'\n         B     NEXTLINE\n\n***********************************************************************\n***  CLOSE THE DIRECT ACCESS DATASET AND PRINT THE LAST LINE\n***********************************************************************\n\nEOFDA    DS    0H\n         LA    R1,FAIRCPL         POINT AT CLOSE PARM LIST\n         ICM   R15,15,=V(FAIRCLS) LOAD LIBRARIAN \"CLOSE\" ROUTINE\n         BZ    DAMEMS             B. IF NOT AVAILABLE\n         CALL  (15)\n         LTR   R7,R7              ANY NAMES IN CURRENT LIST???\n         BZ    DAMEMS\n         LA    R9,MBRLINEP\n         BAL   R10,ONEMESSG\nDAMEMS   DS    0H\n         L     R4,NOM             LOAD NUMBER OF MODULES\n         BAL   R10,CONVERT        CONVERT TO DISPLAY MODE\n         MVC   DAMEM,DWD2+12      STORE IN PRINT LINE\n         LA    R9,DENTLINE\n         BAL   R10,ONEMESSG\n         L     R10,RETADDR\n         BR    R10\n\n***********************************************************************\n***  THIS ROUTINE CONVERTS THE CONTENTS OF REGISTER 4 TO DISPLAY\n***  FORMAT AND STORES THE RESULT INTO DOUBLEWORD 'DWD2'.\n***********************************************************************\n\nCONVERT  DS    0H\n         CVD   R4,DWD1\n         MVC   DWD2(16),PATTERN\n         ED    DWD2(16),DWD1\n         BR    R10\n\n***********************************************************************\n*\n*** ALL TSO PUTLINES EXECUTED FROM THIS ROUTINE.\n*\n***********************************************************************\n\nONEMESSG DS    0H\n         PUTLINE PARM=PUTBLOCK,                                        *\n               OUTPUT=((R9),TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         BR    R10\n\nTWOMESSG DS    0H\n         PUTLINE PARM=PUTBLOCK,                                        *\n               OUTPUT=((R9),TERM,MULTLIN,DATA),MF=(E,IOPLADS)\n         BR    R10\n\n***********************************************************************\n***    THIS ROUTINE VALIDATES THE MASK IF THERE IS ONE ENTERED      ***\n***********************************************************************\n\nCHKMASK  DS    0H\n         SAVE  (14,12),,*         HOUSEKEEPING\n         LR    R12,R15\n         USING CHKMASK,R12\n         ST    R13,CHKSAVE+4\n         LA    R2,CHKSAVE\n         ST    R2,8(R13)\n         LR    R13,R2\n         XR    R15,R15\n         L     R2,0(,R1)          LOAD ADDRESS OF PDE\n         LH    R3,4(,R2)          STORE LENGTH OF MASK\n         L     R4,0(0,R2)         LOAD POINTER TO MASK\n         NI    QUESFLG,X'00'      INITIALIZE FLAG\nCHK001   DS    0H\n         CLI   0(R4),C' '         IS MASK CHAR BLANK?\n         BE    CHKERR             YES..MASK IS INVALID\n         CLI   0(R4),C'?'         IS MASK CHAR A ? MARK ?\n         BNE   CHK002             NO..CONTINUE\n         TM    QUESFLG,X'FF'      YES..IS IT THE FIRST ? TO BE FOUND?\n         BO    CHKERR             NO..INVALID MASK, MORE THAN 1 ?\n         OI    QUESFLG,X'FF'      SET FLAG TO INDICATE ? FOUND\nCHK002   DS    0H\n         BCT   R3,*+8             IF NOT END OF MASK, GO AROUND EXIT\n         B     CHKEXIT            YES..END\n         LA    R4,1(,R4)          ADJUST PTR TO NEXT CHAR IN MASK\n         B     CHK001             CONTINUE\nCHKERR   DS    0H\n         L     R15,=F'4'          SET ERROR RETURN CODE\nCHKEXIT  DS    0H\n         L     R13,4(R13)         RESTORE POINTER TO CALLERS SAVEAREA\n         DROP  R12\n         RETURN (14,12),RC=(15)   RESTORE REGISTERS\n         LTORG ,\n\n***********************************************************************\n*** FORMAT 1 DSCB AREA\n***********************************************************************\n\nDS1      DS    0D\n         IECSDSL1 1                                            #DD03312\n\n***********************************************************************\n*** PRINT LINES\n***********************************************************************\n\nDSNLINEP DC    H'84'\n         DC    H'0'\nDSNLINE  DC    CL80'Dsn: '\n\nDCBTITLE DC    A(DCBLINE)\n         DC    H'78'\n         DC    H'0'\n         DC    C'Dcb:   Dsorg-Recfm-Lrecl-Blksize-Optcd-'\n         DC    C'Keylen-RKP--Created-Expires-LastRef'\nDCBLINE  DC    A(0)\n         DC    H'78'\n         DC    H'0'\n         DC    C'        '\nDSORG    DS    CL3\n         DC    C'  '\nRECFM    DS    CL5\n         DC    C' '\nLRECL    DS    CL5\n         DC    C'  '\nBLKSIZE  DS    CL5\n         DC    C'    '\nOPTCD    DS    CL2\n         DC    C'   '\nKEYLEN   DS    CL4\n         DC    C'  '\nRKP      DS    CL3\n         DC    C'   '\nCRTDT    DS    CL5\n         DC    C'   '\nEXPDT    DS    CL5\n         DC    C'   '\nREFDT    DS    CL5\n         DC    C' '\n\nSPATITLE DC    A(SPALINE)\n         DC    H'51'\n         DC    H'0'\n         DC    C'Space: Units--Alloc---Used--Extents--'\n         DC    C'2ndary Qty.'\nSPALINE  DC    A(0)\n         DC    H'51'\n         DC    H'0'\n         DC    C'        Trks  '\nTRKA     DS    CL5\n         DC    C'  '\nTRKU     DS    CL5\n         DC    C'     '\nEXTS     DS    CL2\n         DC    C'   '                                          #DD03312\nSECA     DS    CL5                                             #DD03312\nSECU     DS    CL5\n         DC    C' '\n\nMBRLINEP DC    H'80'\n         DC    H'0'\nMBRLINE  DS    0CL76\nMBR1     DS    CL6\nMBRS     DS    CL70\n\nENTLINE  DC    H'70'\n         DC    H'0'\n         DS    0CL66\n         DC    C'       '\nNOMEM    DS    CL4\n         DC    C' Members  '\nNOALIAS  DS    CL4\n         DC    C' Aliases   Dir. Blks: '\nDIRUSE   DS    CL3\n         DC    C' Used '\nDIRUNUSE DS    CL3\n         DC    C' Unused'\n\nDENTLINE DC    H'24'\n         DC    H'0'\n         DS    0CL20\n         DC    CL7' '\nDAMEM    DS    CL4\n         DC    C' Members '\n\nERRMSGP  DC    H'84'\n         DC    H'0'\nERRMSG   DS    CL80\n\nBADMSG   DC    H'27'\n         DC    H'0'\n         DC    C' Error in parse routine.'\n\nOPENERR  DC    H'23'\n         DC    H'0'\n         DC    C' Unable to open dataset.'\n\nOPENDA   DC    H'44'\n         DC    H'0'\n         DC    C' Unable to open LIBRARIAN dataset (RC=0)'\n\nLOADERR  DC    H'41'\n         DC    H'0'\n         DC    C' Error reading LIBRARIAN index (RC=0)'\n\n***********************************************************************\n*** WORK AREAS, TABLES AND CAMLSTS.\n***********************************************************************\n\nVERSION  DC    C'V1.8...Compile Date= &SYSTIME &SYSDATE'\n\nVOLADDR  DS    F\n\nVOLTABLE DS    CL100\n*\nCHKSAVE  DS    18F\nSAVE10   DS    F\nDETSTORE DS    F\nSAVE28   DS    8F\nRETADDR  DS    F\nQUESFLG  DC    X'00'\nREQFLAGS DS    0CL5\nDCB      DS    C\nSPACE    DS    C\nMEMB     DS    C\nLOCATE   DS    C\nMASKFLG  DS    C\nDSNLEN   DS    H\nDSN      DS    CL44\nSTDSN    DS    CL44\nDSNPREF  DC    CL7' '\nDSNPREFL DS    F\nVOL      DS    CL6\nTGETVOL  DS    CL10\nFLGS     DS    X\nALLOERR  EQU   X'08'\nFOUND    EQU   X'80'\nINTERNAL DC    C'N'\nFRMEMB   DC    XL8'0000000000000000'\nTOMEMB   DC    XL8'FFFFFFFFFFFFFFFF'\nMEMBMASK DC    XL8'4040404040404040'\nMEMBDATA DC    XL8'4040404040404040'\nMAXLEN   DC    F'8'\nDWD1     DS    D\nDWD2     DS    2D\nPATTERN  DC    X'40',13X'20',X'2120'\nFWORD    DS    XL4\nBLK8     DC    CL8' '\nHEX00    DC    XL8'0000000000000000'\nHEXFF    DC    XL8'FFFFFFFFFFFFFFFF'\nHEXTAB   DC    CL16'0123456789ABCDEF'\n\n********************************************************************\n*                                                                  *\n*  CONSTANTS FOR LIBRARIAN INTERFACE ROUTINES                      *\n*                                                                  *\n********************************************************************\nFAIRWKAR DC    CL20' '\nFAIROMCD DC    CL4' '\nFAIROOPS DC    CL20'2011  '\nFAIRDDDN DC    CL8' '\nFAIRMMDN DC    CL8' '\nFAIRMOPS DC    CL20'11000000 '\nFAIRORES DC    CL120' '          FAIROPN RESULT AREA\nFAIRMRES DS    0CL800            FAIRMOD RESULT AREA\n         DC    CL12' '\nMODNAME  DC    CL8' '\n         DC    CL140' '\n         DC    CL200' '\n         DC    CL200' '\n         DC    CL200' '\nFAIRCRES DC    CL8' '            FAIRCLS RESULT AREA\n********************************************************************\n*                                                                  *\n*  PARAMETER LISTS FOR LIBRARIAN INTERFACE ROUTINES                *\n*                                                                  *\n********************************************************************\nFAIROPL  DS    0F                OPN PARM LIST\n         DC    A(FAIRWKAR)\n         DC    A(FAIRORES)\n         DC    A(FAIROMCD)\n         DC    A(FAIROOPS)\n         DC    A(FAIRDDDN)\n         DC    A(0)              FAIRCDDN\n         DC    A(0)              FAIRTDDN\n         DC    A(0)              FAIRBA1\n         DC    X'80'\n         DC    AL3(0)            FAIRBA2\nFAIRMPL  DS    0F                MOD PARM LIST\n         DC    A(FAIRWKAR)\n         DC    A(FAIRMRES)\n         DC    A(FAIRMMDN)\n         DC    A(FAIRMOPS)\n         DC    A(0)              FAIRMARL\n         DC    X'80'\n         DC    AL3(0)            FAIRMDAL\nFAIRCPL  DS    0F                CLS PARM LIST\n         DC    A(FAIRWKAR)\n         DC    X'80'\n         DC    AL3(FAIRCRES)\n\nBLANKS   DC    CL8' '\nMODINFO  DS    CL100\n\nDSORGTBL DC    X'03',CL3'ISU',X'81'\n         DC    X'03',CL3'PSU',X'41'\n         DC    X'03',CL3'DAU',X'21'\n         DC    X'03',CL3'POU',X'03'\n         DC    X'02',CL3'IS ',X'80'\n         DC    X'02',CL3'PS ',X'40'\n         DC    X'02',CL3'DA ',X'20'\n         DC    X'02',CL3'PO ',X'02'\nDSORGUN  DC    X'02',CL3'?? ',X'00'\nDSORGTBX DC    X'01',CL3'U  ',X'01'\n\nEXTTBL   DC    AL4(DS1EXT1)                                    #DD03312\n         DC    AL4(DS1EXT2)                                    #DD03312\n         DC    AL4(DS1EXT3)                                    #DD03312\nWKTBL    DC    AL4(WKAREA+4)\n         DC    AL4(WKAREA+14)\n         DC    AL4(WKAREA+24)\n         DC    AL4(WKAREA+34)\n         DC    AL4(WKAREA+45)\n         DC    AL4(WKAREA+55)\n         DC    AL4(WKAREA+65)\n         DC    AL4(WKAREA+75)\n         DC    AL4(WKAREA+85)\n         DC    AL4(WKAREA+95)\n         DC    AL4(WKAREA+105)\n         DC    AL4(WKAREA+115)\n         DC    AL4(WKAREA+125)\nWKAREA   DS    0D\n         DS    265C\nUCBTYPE  DS    C\nTRKCYL   DC    H'0'\nTOTRK    DS    F                                               #DD03312\nNOM      DS    F\nNOA      DS    F\nDIRALL   DS    F\nDIRU     DS    F\nLASTDIR  DS    C\nGETVOLM  DC    CL27'Enter Volume/Serial Number-'\nWRKPPL   DS    7F\nPARSEPDL DS    F\nDAPL     DS    4F\nDAPLAPB  DS    F\nIOPLADS  DC    4F'0'\n\nPARMLIST DS    0F               PARMLIST FOR UCB LOOK-UP WITH\nPARMWA   DS    F                IOSVSUCB SERVICE ROUTINE.\nPARMDEVT DS    F\nPARMUCB  DS    F\nADDRUCB  DS    F\n\n         DS    0D\n         UCBSCAN MF=(L,UCBSLST)    UCBSCAN PARAMETER LIST      #DD98129\nUCBDEV#  DS    F                   UCBSCAN RETURNED DEVICE NO. #DD98129\nUCBSWORK DS    CL100               UCBSCAN WORK AREA           #DD98129\nUCBSAREA DS    XL48                UCBSCAN UCB AREA            #DD98129\n\nECB      DC    F'0'\nDSCBTBL  DC    F'0'\n         DC    AL4(DSCBM04)\n         DC    AL4(DSCBM08)\n         DC    AL4(DSCBM12)\n         DC    AL4(DSCBM16)\n         DC    AL4(DSCBM20)\nDSCBM04  DC    H'38',H'0',C' - required catalog not accessible'\nDSCBM08  DC    H'38',H'0',C' - not found on volume XXXXXX.    '\nDSCBM12  DC    H'38',H'0',C' - permanent I/O error on volume. '\nDSCBM16  DC    H'38',H'0',C' - invalid work area pointer.     '\nDSCBM20  DC    H'38',H'0',C' - unknown VTOC error.            '\n\nALLONACC DC    C'- required volume not accessible.  '\nALLOSECM DC    C'- not authorized to access dataset.'\n\nDEVCLASS DS    CL1\n\n         #EXEC ,\n\nEXTOUT   DS    0F\nATIOT    DC    F'0'\nTSOFLAG  DC    F'0'\n\n         DC    C' '\nPRTLINE  DS    CL133\n\nCATBLK   CAMLST NAME,DSN,,WKAREA\n\nDSCBLK   CAMLST SEARCH,DSN,VOL,WKAREA,EADSCB=OK                #DD12062\n\nNEXTBLK  CAMLST SEEK,DS1PTRDS,VOL,WKAREA,EADSCB=OK             #DD12062\n\nNEXT13   CAMLST SEEK,DS3PTRDS,VOL,WKAREA,EADSCB=OK             #DD12062\n\nFMT4DSCB CAMLST SEARCH,DSCB4KEY,VOL,DSCBWORK,EADSCB=OK         #DD12062\n\n         DS    0F\nDSCBWORK DS    XL148\nDSCB4KEY DS    0XL44\n         DC    44XL1'04'\n\nPUTBLOCK PUTLINE MF=L\n\n***********************************************************************\nDYNRBADD DC    0F'0',X'80',AL3(DYNAMRB)\nDYNAMRB  EQU   *\nDYNAMLTH DC    AL1(20)        LENGTH\nDYNAMVRB DC    XL1'01'        VERB\nDYNAMFL1 DC    XL2'0000'      FLAGS\nDYNAMERR DC    XL2'0000'      ERROR CODE\nDYNAMINF DC    XL2'0000'      INFORMATION CODE\nDYNAMTXA DC    A(DYNAMTXT)    DYNAMIC TEXT ADDRESS POINTERS\n         DC    F'0'\nDYNAMFL2 DC    F'0'           FLAGS 2\n*\nDYNAMTXT DC    A(DYNAMXXA)\n         DC    A(DYNAMXXB)\n         DC    A(DYNAMXXC)\n         DC    A(DYNAMXXD)\n         DC    A(DYNAMXXE)\n         DC    X'80',AL3(DYNAMXXF)\n*\nDYNAMTBL EQU   *\nDYNAMXXA DC    XL2'0001',XL2'0001',AL2(8)\nDYNAMDDN DS    CL8            DDNAME\nDYNAMXXB DC    XL2'0002',XL2'0001'\nDYNAMDSL DC    H'44'\nDYNAMDSN DS    CL44           DSNAME\nDYNAMXXC DC    XL2'0004',XL2'0001',AL2(1),XL1'08'\nDYNAMXXD DC    XL2'0010',XL2'0001',AL2(6)\nDYNAMVOL DS    CL6            VOLSER\nDYNAMXXE DC    XL2'0015',XL2'0001',AL2(8)                      #DD11328\nDYNAMUCB DC    CL8'/???? '    UCB NAME                         #DD11328\nDYNAMXXF DC    XL2'001C',XL2'0000'\nDDNPTR   DC    A(DYNAMDDN),Y(8)\n*\n***********************************************************************\n*** DEFAULT SERVICE ROUTINE (IKJEHDEF) CONTROL BLOCKS\n***********************************************************************\n\nDFPL     DS    0F      DEFAULT PARAMETER LIST\nDFPLUPT  DS    A            PTR TO UPT\nDFPLECT  DS    A            PTR TO ECT\nDFPLECB  DS    A            PTR TO CP'S ECB\nDFPLDFPB DS    A            PTR TO DEFAULT PARAMETER BLOCK\nDFPB     DS    0F      DEFAULT PARAMETER BLOCK\nDFPBCODE DS    0AL1         DEFAULT ENTRY CODE\nDFPBDSN  DS    A            PTR TO DSNLEN AND DSN\nDFPBCNTL DS    0AL1         DEFAULT CONTROL CODE\nDFPBPSCB DS    A            PTR TO PSCB\nDFPBLORC DS    0AL1         LOCATE RETURN CODE\nDFPBQUAL DC    AL4(0)       PTR TO DEFAULT QUALIFIER\nDFPBCAT  DC    AL4(0)       PTR TO USER CATALOG\nDFPBPSWD DC    AL4(0)       PTR TO PASSWORD\n\n***********************************************************************\n*** IGWFAMS Parameters\n***********************************************************************\nFAMSPARM DS    3F                                              #DD16151\nFAMSFMH  DS    0F,XL136                                        #DD16151\nFAMSFMHL EQU   *-FAMSFMH                                       #DD16151\nFAMSFMO  DS    0F,XL1104                                       #DD16151\nFAMSFMOL EQU   *-FAMSFMO                                       #DD16151\nFAMSLIST DS    3F                                              #DD16151\nFAMPTRL1 DS    6F                                              #DD16151\nFAMPTRL2 DS    6F                                              #DD16151\nFAMPTRL3 DS    6F                                              #DD16151\n         DS    A(*-*)                                          #DD16151\n         DS    A(*-*)                                          #DD16151\n\n***********************************************************************\n*** DCB FOR PDS'S WHOSE MEMBERS ARE BEING LISTED\n***********************************************************************\n\nSYSLIB   DCB   DSORG=PS,RECFM=F,LRECL=256,BLKSIZE=256,                 X\n               MACRF=GL,EODAD=EOFDIR,                                  X\n               DCBE=SYSLDCBE                                   #DD12062\nSYSLDCBE DCBE  EADSCB=OK                                       #DD12062\n\n         PRINT NOGEN\nPCL      IKJPARM\n\nDSNLIST  IKJPOSIT DSNAME,LIST,UPPERCASE,                               C\n               PROMPT='ONE OR MORE DATASET NAMES'\n\nALLWD    IKJKEYWD DEFAULT='NOALL'\n         IKJNAME  'NOALL'\n         IKJNAME  'ALL'\n\nDCBWD    IKJKEYWD DEFAULT='NODCB'\n         IKJNAME  'NODCB'\n         IKJNAME  'DCB'\n\nSPACEWD  IKJKEYWD DEFAULT='NOSPACE'\n         IKJNAME  'NOSPACE'\n         IKJNAME  'SPACE'\n\nMEMBWD   IKJKEYWD DEFAULT='NOMEMB'\n         IKJNAME  'NOMEMB'\n         IKJNAME  'MEMBERS',SUBFLD=MEMSUB\n\nLOCWD    IKJKEYWD DEFAULT='NOLOC'\n         IKJNAME  'NOLOC'\n         IKJNAME  'LOCATE'\n\nFROMWD   IKJKEYWD ,\n         IKJNAME  'FROM',SUBFLD=FROMSUB\n\nTOWD     IKJKEYWD ,\n         IKJNAME  'TO',SUBFLD=TOSUB\n\nVOLWD    IKJKEYWD ,\n         IKJNAME 'VOL',SUBFLD=VOLSUB\n\nMEMSUB   IKJSUBF ,\nMASK     IKJIDENT 'MASK',UPPERCASE,MAXLNTH=8,                          X\n               CHAR,VALIDCK=CHKMASK\n\nFROMSUB  IKJSUBF ,\nFROM     IKJIDENT 'FROM',MAXLNTH=8,OTHER=ALPHANUM,                     X\n               PROMPT='THE ''FROM'' MEMBER NAME',                      X\n               HELP=('FIRST MEMBER NAME IN A RANGE OF MEMBER NAMES')\n\nTOSUB    IKJSUBF ,\nTO       IKJIDENT 'TO',MAXLNTH=8,OTHER=ALPHANUM,                       X\n               PROMPT='THE ''TO'' MEMBER NAME',                        X\n               HELP=('LAST MEMBER NAME IN A RANGE OF MEMBER NAMES')\n\nVOLSUB   IKJSUBF ,\nVOLSER   IKJIDENT 'VOL',LIST,OTHER=ALPHANUM,                           X\n               PROMPT='THE ''VOLSER'' LIST',                           X\n               HELP=('VOLUMES TO BE SCANNED')\n\n         IKJENDP ,\n         PRINT GEN\n\n         DYNSPACE ,\n         ORG   DYNSP1+4+4         4 = START OF RB  + 4 = ERROR CODE\nDYNAMERA DS    XL2                ERROR CODE\n         ORG   ,\n\n***********************************************************************\n***  PARSE DESCRIPTOR ENTRY FORMAT.\n***********************************************************************\n\nDSNPDE   DSECT ,\nADDRDSN  DS    A\nLENDSN   DS    H\nFLGSDSN  DS    H\n         DS    4F\nNEXTPDE  DS    A\n\nVOLPDE   DSECT ,\nADDRVOL  DS    F\nLENVOL   DS    H\nFLAGVOL  DS    H\nNEXTVOL  DS    F\n\n***********************************************************************\n***  DSCB EXTENT FORMAT\n***********************************************************************\n\nEXTENT   DSECT\nID       DS    C\nSEQ      DS    C\nCCA      DS    H\nTTA      DS    H\nCCB      DS    H\nTTB      DS    H\n\n         #DSECTS ALLOC,CVT,TSO,UCB,PSA\n\n         IHADFA ,                                              #DD16151\n         IHADFVT ,                                             #DD16151\n\n         #REGS ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTAST": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x01\\x96\\x01\\x96\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:26", "lines": 406, "newlines": 406, "modlines": 0, "user": "SOURCE"}, "text": "LISTAST  TITLE 'List Allocation Status'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support EMail Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                |                                                    *\n* L I S T A S T  |       TSO LISTA Status Command Processor           *\n*                |                                                    *\n*-----------------                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        This Program Generates Data Similar To The LISTA Command     *\n*                                                                     *\n*        Syntax:                                                      *\n*                                                                     *\n*              LISTAST                                                *\n*           or LISTAST DDNAME                                         *\n*           or LISTAST PREFIX* [ NOMSGS ]                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* OUTPUT:                                                             *\n*   DDNAME__  VOLSER   New  *DSNAME                                   *\n*             Sysout   Shr   CLASS=X                                  *\n*             Terminal Mod                                            *\n*                      Old                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     History: #DD14219 - Aug 07,2014 -  Add Volser To Display        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nLISTAST  #START ,                  Start Procedure                     *\n               AMODE=31,           Execute In 31-Bit Addressing Mode   *\n               APARS=,             No Need For APAR \"Zap\" Slots        *\n               RMODE=ANY,          Execute In Any Residency Mode       *\n               BASE=(R12),         Define Base Register(s)             *\n               COPY=YES,           Insert CopyRight Notice             *\n               WKDSECT=LISTWORK,LOC=BELOW,  WorkArea                   *\n               REG1=R10,USING=(CPPL,R10),   Input Parameter List       *\n               LEVEL=#V001R01                                  #DD14219\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Format Required Control Blocks                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R1,WRKIOPL          Load IOPL Address\n         USING IOPL,R1\n         MVC   IOPLUPT,CPPLUPT     Insert UPT Address\n         MVC   IOPLECT,CPPLECT     Insert ECT Address\n         LA    R0,WRKECB           Load ECB Address\n         ST    R0,IOPLECB\n\n         LA    R1,WRKPPL           Load PPL Address\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      Insert UPT Address\n         MVC   PPLECT,CPPLECT      Insert ECT Address\n         LA    R0,WRKECB           Load ECB Address\n         ST    R0,PPLECB\n         MVC   PPLPCL,=A(PCL)      Insert PCL Address\n         MVC   PPLCBUF,CPPLCBUF    Insert CBUF Address\n         LA    R0,PDLADDR          Load PDL Answer Address\n         ST    R0,PPLANS\n         DROP  R1\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pares The Command Buffer                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         XC    WRKECB,WRKECB\n         CALLTSSR EP=IKJPARS,                                          *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Pares Return Code\n         BZ    LSTA0100            B. If Successful\n\n         #SETRC (R15)              Set Return Code\n\n         ST    R15,GFRCODE         Insert Return Code\n         MVC   GFCALLID,=AL2(GFPARSE)\n         ST    R10,GFCPPLP         Insert CPPL Address\n         LA    R0,WRKECB\n         ST    R0,GFECBP           Insert ECB Address\n         XC    WRKECB,WRKECB\n         LA    R0,GFPARMS          Load IKJEFF19 PList Address\n         ST    R0,PARMADDR\n         LA    R1,PARMADDR         Load PList Pointer Address\n         LINK  EP=IKJEFF19         Call General Fail Routine\n         B     LSTA1500            Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Check If User Specified A DDName/DDName Prefix               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLSTA0100 DS    0H\n         L     R1,PDLADDR          Load PDL Buffer Address\n         USING IKJPARMD,R1\n         SLR   R2,R2\n         ICM   R2,3,PDDNAME+4      Load DDName Length\n         BZ    LSTA0200            B. If Length Is Zero\n         ICM   R3,15,PDDNAME       Load DDName Address\n         BZ    LSTA0200            B. If Not Specified\n         TM    PDDNAME+6,1         Check For \"Generic\" DDName\n         BO    *+6                 B. If Yes\n         BCTR  R2,0                Decrement Non-Generic Length\n         MVC   DDNAME,BLANKS\n         #EXEC R2,MVC,DDNAME(*-*),0(R3)\n         OI    FLAGBYTE,$DDNAME    Indicate DDName Specified\n         MVC   DDNAMEL,=AL2(8)     Set Default Length\n         TM    PDDNAME+6,1         Check If DDName Is Generic\n         BNO   LSTA0200            B. If Not\n         OI    FLAGBYTE,$GENERIC   Indicate Generic DDName\n         STH   R2,DDNAMEL          Save DDName Length\nLSTA0200 DS    0H\n         CLI   PNOMSG+1,1          Check For \"NOMSG\" Option\n         BNE   LSTA0300            B. If Not\n         OI    FLAGBYTE,$NOMSGS    Indicate No Messages To Be Issued\n         DROP  R1\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Find The Start Of The DSAB Chain                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLSTA0300 DS    0H\n         USING PSA,0\n         L     R8,PSATOLD          Load TCB Address\n         USING TCB,R8\n         L     R8,TCBJSCB          Load JSCB Address\n         USING IEZJSCB,R8\n         L     R8,JSCBACT          Load Active JSCB Address\n         L     R8,JSCDSABQ         Load QDB Address\n         USING QDB,R8\n         ICM   R8,15,QDBFELMP      Load DSAB Address\n         BZ    LSTA1500            B. If None Exists\n         USING DSABID,R8\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display Information On Each Allocated Dataset                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLSTA0400 DS    0H\n         MVC   MSG1+4(MSG1LEN),BLANKS\n\n         L     R7,DSABSIOT         Load SIOT Address\n         USING INDMSIOT,R7\n\n         TM    FLAGBYTE,$DDNAME    Check If User Specified A DDName\n         BNO   LSTA0600            B. If Not\n         TM    FLAGBYTE,$FOUND2    Check If Current DDName Matches\n         BNO   LSTA0500            B. If Not\n         CLC   SCTDDNAM,BLANKS     Check For Concatenation\n         BE    LSTA0600            B. If Yes\n\nLSTA0500 DS    0H\n         LH    R1,DDNAMEL          Load Length Of DDName/Prefix\n         #EXEC -R1,CLC,SCTDDNAM(*-*),DDNAME\n         BNE   LSTA1300            B. If Not\n         OI    FLAGBYTE,$FOUND1    Indicate DDName Has Been Found\n         OI    FLAGBYTE,$FOUND2\n\nLSTA0600 DS    0H\n         MVC   MSG1I1,SCTDDNAM\n\n         L     R2,DSABTIOT         Load TIOT Address\n         USING TIOENTRY,R2\n         MVC   MSG1I2(8),=CL8'Terminal'\n         TM    TIOELINK,TIOTTERM   Check For \"Terminal\"\n         BO    LSTA1100            B. If Yes\n         MVC   MSG1I2(8),BLANKS\n         MVC   MSG1I2,=CL6'Sysin'\n         TM    TIOELINK,TIOESSDS   Check For \"SubSystem Dataset\"\n         BZ    LSTA0700            B. If Not\n         TM    TIOELINK,TIOESYOT   Check For SYSOUT Dataset\n         BZ    LSTA1100            B. IF Not\n         MVC   MSG1I2,=CL6'Sysout'\n         MVC   MSG1I5,BLANKS\n         MVC   MSG1I5(6),=C'Class='\n         MVC   MSG1I5+6(1),SCTOUTPN\n         B     LSTA1100            B. If SYSOUT DataSet\nLSTA0700 DS    0H\n         MVC   MSG1I2,=CL6'Dummy'\n         TM    SCTSBYT1,SCTDUMMY   Check For \"Dummy\" File\n         BO    LSTA1100            B. If Yes\n\n         TM    TIOELINK,TIOTREM    Entry For A Remote Device (TCAM) ?\n         BZ    LSTA0800            B. If Not\n         L     R3,SJFCBPTR         Load JFCB Address\n         USING INFMJFCB,R3\n         MVC   MSG1I2,=CL6'Queue'\n         MVC   MSG1I5,BLANKS\n         MVC   MSG1I5(11),=C'TCAM Queue:'\n         MVC   MSG1I5+12(8),JFCBDSNM\n         B     LSTA1200\n\nLSTA0800 DS    0H\n         L     R3,SJFCBPTR         Load JFCB Address\n         USING INFMJFCB,R3\n         MVC   MSG1I5,BLANKS\n         MVC   MSG1I5(44),JFCBDSNM Insert Dataset Name\n         TM    JFCBELNM,X'BF'      Check If Member Name Exists\n         BZ    LSTA0900            B. If Not\n         TRT   MSG1I5(45),TRTABLE1 Find End Of DataSet Name\n         MVI   0(R1),C'('          Insert Leading Bracket\n         MVC   1(8,R1),JFCBELNM    Insert Member Name\n         TRT   MSG1I5(55),TRTABLE1 Find End Of DataSet Name & Member\n         MVI   0(R1),C')'          Insert Closing Bracket\nLSTA0900 DS    0H\n         MVC   MSG1I2,=CL6'VIO'\n         TM    JFCFLGS1,JFCVRDS    Check For \"VIO\" Dataset\n         BO    LSTA1000            B. If Yes\n         MVC   MSG1I2,JFCBVOLS     Copy 1st Volume Serial\n\nLSTA1000 DS    0H\n         MVC   MSG1I3,=CL3'New'\n         TM    JFCBFLG2,JFCMODNW   Check For \"New/Mod\" File\n         BO    LSTA1100            B. If Yes\n         MVC   MSG1I3,=CL3'Shr'\n         TM    JFCBIND2,JFCSHARE   Check For \"Shr\" File\n         BO    LSTA1100            B. If Yes\n         MVC   MSG1I3,=CL3'New'\n         TM    JFCBIND2,JFCNEW     Check For \"New\" File\n         BO    LSTA1100            B. If Yes\n         MVC   MSG1I3,=CL3'Mod'\n         TM    JFCBIND2,JFCMOD     Check For \"Mod\" File\n         BO    LSTA1100            B. If Yes\n         MVC   MSG1I3,=CL3'Old'\n         TM    JFCBIND2,JFCOLD     Check For \"Old\" File\n         BO    LSTA1100            B. If Yes\n         MVC   MSG1I3,BLANKS\n\nLSTA1100 DS    0H\n         MVI   MSG1I4,C' '\n         TM    DSABFLG1,DSABPALC   Check For Permanent Allocation\n         BO    LSTA1200            B. If Yes\n         MVI   MSG1I4,C'*'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Issue Message To Terminal                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLSTA1200 DS    0H\n         TM    FLAGBYTE,$NOMSGS    Check For \"NOMSG\" Option\n         BO    LSTA1400            B. If Yes\n         SAM24 ,                   Enter 24 Bit Addressing Mode\n         XC    WRKECB,WRKECB\n         PUTLINE PARM=PUTLINEL,                                        *\n               OUTPUT=(MSG1,TERM,SINGLE,DATA),                         *\n               MF=(E,WRKIOPL)\n         SAM31 ,                   Return To 31 Bit Addressing Mode\n         B     LSTA1400            Continue\nLSTA1300 DS    0H\n         NI    FLAGBYTE,255-$FOUND2\nLSTA1400 DS    0H\n         ICM   R8,15,DSABFCHN      Load Next DSAB Address\n         BNZ   LSTA0400            B. If Another Exists\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLSTA1500 DS    0H\n         TM    FLAGBYTE,$DDNAME    Check If User Specified A DDName\n         BNO   LISTAXIT            B. If Not\n         TM    FLAGBYTE,$FOUND1    Check If DDName Was Found\n         BO    LISTAXIT            B. If Yes\n         XC    WRKECB,WRKECB\n         MVC   MSG2I1,DDNAME       Insert DDName Into Message\n         TM    FLAGBYTE,$NOMSGS    Check For \"NOMSG\" Option\n         BO    LSTA1600            B. If Yes\n         SAM24 ,                   Enter 24 Bit Addressing Mode\n         PUTLINE PARM=PUTLINEL,                                        *\n               OUTPUT=(MSG2,TERM,SINGLE,DATA),                         *\n               MF=(E,WRKIOPL)\n         SAM31 ,                   Return To 31 Bit Addressing Mode\n\nLSTA1600 DS    0H\n         #SETRC 8                  Set Return Code\n\nLISTAXIT #STOP ,                   Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DDName Validity Check - Check For \"DDN*\"                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nVALDDNAM DS    0H\n         STM   R14,R12,12(R13)     Save Caller's Registers\n         XC    16(4,R13),16(R13)   Set Return Code To Zero\n         LR    R12,R15             Setup Exit's Base Register\n         USING VALDDNAM,R12\n         L     R5,0(,R1)           Load PDE Address\n\n         NI    6(R5),255-1         Turn Off \"Asterisk\" Flag\n         L     R4,0(,R5)           Load DDName Address\n         LH    R3,4(,R5)           Load DDName Length\n         LA    R1,VALDDTAB         Load Translate Table Address\n         #EXEC -R3,TRT,0(*-*,R4),0(R1)\n         BZ    VALDEXIT            B. If No Asterisk Was Found\n         OI    6(R5),1             Turn On \"Asterisk\" Flag\n         SR    R1,R4               Re-Calculate Length Without Asterisk\n         STH   R1,4(,R5)           Save New Length In PDE\nVALDEXIT DS    0H                  R1 -> Storage Obtained\n         LM    R14,R12,12(R13)     Restore Caller's Registers\n         BR    R14                 Return To Caller\n\nVALDDTAB DC    256X'00'\n         ORG   VALDDTAB+C'*'\n         DC    C'*'                Find The First Asterisk\n         ORG   ,\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nBLANKS   DC    256C' '             Lots Of Blanks\n\nMSG1     #MSG  '________   ______   ___  *_________+_________+_________*\n               +_________+____(________) '\nMSG1LEN  EQU   *-MSG1-4            Length Of Message Text Area\nMSG1I1   EQU   MSG1+4+00,8         DDName Address & Length\nMSG1I2   EQU   MSG1+4+11,6         Volser Address & Length\nMSG1I3   EQU   MSG1+4+20,3         Disposition Address & Length\nMSG1I4   EQU   MSG1+4+25,1         Temporary Allocation Flag\nMSG1I5   EQU   MSG1+4+26,54        DataSet Name Address & Length\n\nMSG2     #MSG  'IEC130I ________ DD STATEMENT MISSING'\nMSG2I1   EQU   MSG2+4+08,8         Insert 1 Address & Offset\n\nTRTABLE1 DC    256X'00'\n         ORG   TRTABLE1+C' '\n         DC    C' '                Find The 1st Blank\n         ORG   ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic Work Area                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #STARTWA ,\n         IKJEFFGF GFDSECT=NO       IKJEFF19 Parameter List\nDDNAME   DS    CL8                 Specified DDName\nDDNAMEL  DS    H                   Specified DDName Length\nFLAGBYTE DS    X                   General Purpose Flag Byte\n$DDNAME  EQU   BIT0                DDName Has Been Specified\n$FOUND1  EQU   BIT1                DDName Has Been Found\n$FOUND2  EQU   BIT2                At Least 1 Line Has Been Printed\n$GENERIC EQU   BIT3                DDName Is A Generic Prefix\n$NOMSGS  EQU   BIT4                Don't Issue Messages\nPARMADDR DS    F                   Register 1 Save Area\nPDLADDR  DS    F                   PDL Pointer\nPUTLINEL PUTLINE MF=L              PUTLINE Parameter List\nWRKECB   DS    F                   ECB\nWRKIOPL  DS    XL(IOPLLEN)         IOPL\nWRKPPL   DS    XL(PPLLEN)          Parse Parameter List\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse Parameter List                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PRINT NOGEN\nPCL      IKJPARM ,\n\nPDDNAME  IKJIDENT 'DDNAME',VALIDCK=VALDDNAM,                           *\n               FIRST=ANY,OTHER=ANY,MAXLNTH=8,                          *\n               HELP='Name Of Currently Allocated DDName'\n\nPNOMSG   IKJKEYWD ,\n         IKJNAME 'NOMSGS'\n\n         IKJENDP ,\n         PRINT GEN\n\n         #DSECTS CVT,DSAB,JFCB,JSCB,PSA,PSCB,QDB,SIOT,TCB,TIOT,TSO\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTAST$": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x11\\x18\\x7f\\x01\\x14!\\x9f#X\\x00&\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-07-06T00:00:00", "modifydate": "2014-08-07T23:58:57", "lines": 38, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*-------------------------------------------------------------------*\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=SBGOLOB.FILE452.MACLIB                                  *\n// SET SOURCE=SBGOLOB.CBT489.FILE452                                  *\n// SET LOADLIB=SYS1.W$$.LINKLIB                                       *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//*\n//ASM      EXEC  PGM=ASMA90,REGION=4M,TIME=NOLIMIT,\n//   PARM=('TERM,DECK,NOOBJECT,NORLD,NOUSING,XREF(SHORT)',\n//         'OPTABLE(YOP),NORENT')\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10))\n//SYSLIB   DD    DSN=&MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ(LISTAST),DISP=(,PASS),\n//         UNIT=SYSALLDA,SPACE=(CYL,(1,1,45)),\n//         DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD    DSN=&SOURCE(LISTAST),DISP=SHR\n//*\n//LINKEDIT EXEC  PGM=IEWL,REGION=4M,TIME=NOLIMIT,COND=(0,NE),\n//         PARM='NCAL,LET,LIST,XREF,NORENT'\n//SYSPRINT DD    SYSOUT=*\n//SYSLMOD  DD    DSN=&LOADLIB,DISP=SHR\n//SYSPUNCH DD    DSN=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSLIN   DD    *\n  INCLUDE  SYSPUNCH(LISTAST)\n  SETSSI   CB489452\n  ENTRY    LISTAST\n  NAME     LISTAST(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTASTO": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x11\\x18\\x7f\\x01\\x11\\x18\\x7f 4\\x01)\\x01)\\x00\\x00\\xd6\\xd3\\xc4\\xe2\\xd9\\xc3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-07-06T00:00:00", "modifydate": "2011-07-06T20:34:34", "lines": 297, "newlines": 297, "modlines": 0, "user": "OLDSRCE"}, "text": "LISTAST  TITLE 'LIST ALLOCATION STATUS'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        THIS PROGRAM GENERATES DATA SIMILAR TO THE LISTA COMMAND     *\n*                                                                     *\n*        SYNTAX:                                                      *\n*                                                                     *\n*              LISTAST                                                *\n*           OR LISTAST DDNAME                                         *\n*           OR LISTAST PREFIX*                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTAST  #START BASE=(R12),SPLEVEL=2,AMODE=CAP31,RMODE=ANY,            *\n               WKDSECT=LISTWORK,LOC=BELOW,                             *\n               APARS=,COPY=YES,COPYYR=1999,                    #DD99183*\n               REG1=R10,USING=(CPPL,R10)\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FORMAT REQUIRED CONTROL BLOCKS                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R1,WRKIOPL          LOAD IOPL ADDRESS\n         USING IOPL,R1\n         MVC   IOPLUPT,CPPLUPT     INSERT UPT  ADDRESS\n         MVC   IOPLECT,CPPLECT     INSERT ECT  ADDRESS\n         LA    R0,WRKECB           LOAD ECB  ADDRESS\n         ST    R0,IOPLECB\n\n         LA    R1,WRKPPL           LOAD PPL ADDRESS\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      INSERT UPT  ADDRESS\n         MVC   PPLECT,CPPLECT      INSERT ECT  ADDRESS\n         LA    R0,WRKECB           LOAD ECB ADDRESS\n         ST    R0,PPLECB\n         MVC   PPLPCL,=A(PCL)      INSERT PCL  ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    INSERT CBUF ADDRESS\n         LA    R0,PDLADDR          LOAD PDL ANSWER ADDRESS\n         ST    R0,PPLANS\n         DROP  R1\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARSE THE COMMAND BUFFER                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         XC    WRKECB,WRKECB\n         CALLTSSR EP=IKJPARS,                                          *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             CHECK PARSE RETURN CODE\n         BZ    LISTA100            B. IF SUCCESSFUL\n\n         #SETRC (R15)              SET RETURN CODE\n\n         ST    R15,GFRCODE         INSERT RETURN CODE\n         MVC   GFCALLID,=AL2(GFPARSE)\n         ST    R10,GFCPPLP         INSERT CPPL ADDRESS\n         LA    R0,WRKECB\n         ST    R0,GFECBP           INSERT ECB  ADDRESS\n         XC    WRKECB,WRKECB\n         LA    R0,GFPARMS          LOAD IKJEFF19 PLIST ADDRESS\n         ST    R0,PARMADDR\n         LA    R1,PARMADDR         LOAD PLIST POINTER ADDRESS\n         LINK  EP=IKJEFF19         CALL GENERAL FAIL ROUTINE\n         B     LISTA900            TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CHECK IF USER SPECIFIED A DDNAME/DDNAME PREFIX               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTA100 DS    0H\n         L     R1,PDLADDR          LOAD PDL  BUFFER ADDRESS\n         USING IKJPARMD,R1\n         SLR   R2,R2\n         ICM   R2,3,PDDNAME+4      LOAD DDNAME LENGTH\n         BZ    LISTA200            B. IF LENGTH ZERO\n         ICM   R3,15,PDDNAME       LOAD DDNAME ADDRESS\n         BZ    LISTA200            B. IF NOT SPECIFIED\n         TM    PDDNAME+6,1         CHECK FOR \"GENERIC\" DDNAME\n         BO    *+6                 B. IF YES\n         BCTR  R2,0                DECREMENT NON-GENERIC LENGTH\n         MVC   DDNAME,BLANKS\n         #EXEC R2,MVC,DDNAME(*-*),0(R3)\n         OI    FLAGBYTE,$DDNAME    INDICATE DDNAME SPECIFIED\n         MVC   DDNAMEL,=AL2(8)     SET DEFAULT LENGTH\n         TM    PDDNAME+6,1         CHECK IF DDNAME IS GENERIC\n         BNO   LISTA200            B. IF NOT\n         OI    FLAGBYTE,$GENERIC   INDICATE GENERIC DDNAME\n         STH   R2,DDNAMEL          SAVE DDNAME LENGTH\n         DROP  R1\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND THE START OF THE DSAB CHAIN                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTA200 DS    0H\n         USING PSA,0\n         L     R8,PSATOLD          LOAD TCB  ADDRESS\n         USING TCB,R8\n         L     R8,TCBJSCB          LOAD JSCB ADDRESS\n         USING IEZJSCB,R8\n         L     R8,JSCBACT          LOAD ACTIVE JSCB ADDRESS\n         L     R8,JSCDSABQ         LOAD QDB  ADDRESS\n         USING QDB,R8\n         ICM   R8,15,QDBFELMP      LOAD DSAB ADDRESS\n         BZ    LISTA900            B. IF NONE EXISTS\n         USING DSABID,R8\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DISPLAY INFORMATION ON EACH ALLOCATED DATASET                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTA300 DS    0H\n         MVC   MSG1+4(MSG1LEN),BLANKS\n\n         L     R7,DSABSIOT         LOAD SIOT ADDRESS\n         USING INDMSIOT,R7\n\n         TM    FLAGBYTE,$DDNAME    CHECK IF USER SPECIFIED A DDNAME\n         BNO   LISTA500            B. IF NOT\n         TM    FLAGBYTE,$FOUND2    CHECK IF CURRENT DDNAME MATCHES\n         BNO   LISTA400\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION\n         BE    LISTA500            B. IF YES\n\nLISTA400 DS    0H\n         LH    R1,DDNAMEL          LOAD LENGTH OF DDNAME/PREFIX\n         #EXEC -R1,CLC,SCTDDNAM(*-*),DDNAME\n         BNE   LISTA700            B. IF NOT\n         OI    FLAGBYTE,$FOUND1    INDICATE DDNAME HAS BEEN FOUND\n         OI    FLAGBYTE,$FOUND2\n\nLISTA500 DS    0H\n         MVC   MSG1I1,SCTDDNAM\n\n         L     R2,DSABTIOT         LOAD TIOT ADDRESS\n         USING TIOENTRY,R2\n         MVC   MSG1I2,=CL3'TRM'\n         TM    TIOELINK,TIOTTERM   CHECK FOR \"TERMINAL\"\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'SSD'\n         TM    TIOELINK,TIOESSDS   CHECK FOR \"SUBSYSTEM DATASET\"\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'DMY'\n         TM    SCTSBYT1,SCTDUMMY   CHECK FOR \"DUMMY\" FILE\n         BO    LISTA600            B. IF YES\n\n         L     R2,SJFCBPTR         LOAD JFCB ADDRESS\n         USING INFMJFCB,R2\n         MVC   MSG1I4,JFCBDSNM     INSERT DATASET NAME\n         MVC   MSG1I2,=CL3'VIO'\n         TM    JFCFLGS1,JFCVRDS    CHECK FOR \"VIO DATASET\"\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'NEW'\n         TM    JFCBFLG2,JFCMODNW   CHECK FOR \"NEW/MOD\" FILE\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'SHR'\n         TM    JFCBIND2,JFCSHARE   CHECK FOR \"SHR\" FILE\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'NEW'\n         TM    JFCBIND2,JFCNEW     CHECK FOR \"NEW\" FILE\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'MOD'\n         TM    JFCBIND2,JFCMOD     CHECK FOR \"MOD\" FILE\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'OLD'\n         TM    JFCBIND2,JFCOLD     CHECK FOR \"OLD\" FILE\n         BO    LISTA600            B. IF YES\n         MVC   MSG1I2,=CL3'???'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISSUE MESSAGE TO TERMINAL                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTA600 DS    0H\n         #MODE 24                  ENTER 24 BIT ADDRESSING MODE\n         XC    WRKECB,WRKECB\n         PUTLINE PARM=PUTLINEL,                                        *\n               OUTPUT=(MSG1,TERM,SINGLE,DATA),                         *\n               MF=(E,WRKIOPL)\n         #MODE 31                  RETURN TO 31 BIT ADDRESSING MODE\n         B     LISTA800            CONTINUE\nLISTA700 DS    0H\n         NI    FLAGBYTE,255-$FOUND2\nLISTA800 DS    0H\n         ICM   R8,15,DSABFCHN      LOAD NEXT DSAB ADDRESS\n         BNZ   LISTA300            B. IF ANOTHER EXISTS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTA900 DS    0H\n         TM    FLAGBYTE,$DDNAME    CHECK IF USER SPECIFIED A DDNAME\n         BNO   LISTAXIT            B. IF NOT\n         TM    FLAGBYTE,$FOUND1    CHECK IF DDNAME WAS FOUND\n         BO    LISTAXIT            B. IF YES\n         XC    WRKECB,WRKECB\n         MVC   MSG2I1,DDNAME       INSERT DDNAME INTO MESSAGE\n         #MODE 24                  ENTER 24 BIT ADDRESSING MODE\n         PUTLINE PARM=PUTLINEL,                                        *\n               OUTPUT=(MSG2,TERM,SINGLE,DATA),                         *\n               MF=(E,WRKIOPL)\n         #MODE 31                  RETURN TO 31 BIT ADDRESSING MODE\n\nLISTAXIT #STOP ,                   TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DDNAME VALIDITY CHECK - CHECK FOR \"DDN*\"                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nVALDDNAM DS    0H\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         XC    16(4,R13),16(R13)   SET RETURN CODE TO ZERO\n         LR    R12,R15             SETUP EXIT'S BASE REGISTER\n         USING VALDDNAM,R12\n         L     R5,0(,R1)           LOAD PDE ADDRESS\n\n         NI    6(R5),255-1         TURN OFF \"ASTERISK\" FLAG\n         L     R4,0(,R5)           LOAD DDNAME ADDRESS\n         LH    R3,4(,R5)           LOAD DDNAME LENGTH\n         LA    R1,VALDDTAB         LOAD TRANSLATE TABLE ADDRESS\n         #EXEC -R3,TRT,0(*-*,R4),0(R1)\n         BZ    VALDEXIT            B. IF NO ASTERISKS FOUND\n         OI    6(R5),1             TURN ON \"ASTERISK\" FLAG\n         SR    R1,R4               RE-CALCULATE LENGTH WITHOUT ASTERISK\n         STH   R1,4(,R5)           SAVE NEW LENGTH IN PDE\nVALDEXIT DS    0H                  R1 -> STORAGE OBTAINED\n         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS\n         BR    R14                 RETURN TO CALLER\n\nVALDDTAB DC    256X'00'\n         ORG   VALDDTAB+C'*'\n         DC    C'*'                FIND THE FIRST ASTERISK\n         ORG   ,\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WORK AREA & DSECTS                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nBLANKS   DC    256C' '             LOTS OF BLANKS\nMSG1     #MSG  'DDDDDDDD ??? *XXXXXXXXX+XXXXXXXXX+XXXXXXXXX+XXXXXXXXX+X*\n               XXX'\nMSG1LEN  EQU   *-MSG1-4            LENGTH OF MESSAGE TEXT AREA\nMSG1I1   EQU   MSG1+4+00,8         INSERT 1 ADDRESS & OFFSET\nMSG1I2   EQU   MSG1+4+09,3         INSERT 2 ADDRESS & OFFSET\nMSG1I3   EQU   MSG1+4+13,1         INSERT 3 ADDRESS & OFFSET\nMSG1I4   EQU   MSG1+4+14,44        INSERT 4 ADDRESS & OFFSET\nMSG2     #MSG  'FILE XXXXXXXX NOT FOUND'\nMSG2I1   EQU   MSG2+4+05,8         INSERT 1 ADDRESS & OFFSET\n         #STARTWA ,\n         IKJEFFGF GFDSECT=NO       IKJEFF19 PARAMETER LIST\nDDNAME   DS    CL8                 SPECIFIED DDNAME\nDDNAMEL  DS    H                   SPECIFIED DDNAME LENGTH\nFLAGBYTE DS    X                   GENERAL PURPOSE FLAG BYTE\n$DDNAME  EQU   BIT0                DDNAME HAS BEEN SPECIFIED\n$FOUND1  EQU   BIT1                DDNAME HAS BEEN FOUND\n$FOUND2  EQU   BIT2                AT LEAST 1 LINE HAS BEEN PRINTED\n$GENERIC EQU   BIT3                DDNAME IS A GENERIC PREFIX\nPARMADDR DS    F                   REGISTER 1 SAVE AREA\nPDLADDR  DS    F                   PDL POINTER\nPUTLINEL PUTLINE MF=L              PUTLINE PARAMETER LIST\nWRKECB   DS    F                   ECB\nWRKIOPL  DS    XL(IOPLLEN)         IOPL\nWRKPPL   DS    XL(PPLLEN)          PARSE PARAMETER LIST\n         #STOPWA ,\n\n         PRINT NOGEN\nPCL      IKJPARM ,\nPDDNAME  IKJIDENT 'DDNAME',VALIDCK=VALDDNAM,                           *\n               FIRST=ANY,OTHER=ANY,MAXLNTH=8,                          *\n               HELP='NAME OF CURRENTLY ALLOCATED DDNAME'\n         IKJENDP ,\n         PRINT GEN\n\n         #DSECTS CVT,DSAB,JFCB,JSCB,PSA,PSCB,QDB,SIOT,TCB,TIOT,TSO\n         IHAQDB ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTVOL$": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x008\\x01\\x082\\x1f\\x01\\x082O \\x15\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2008-11-16T00:00:00", "modifydate": "2008-11-19T20:15:38", "lines": 30, "newlines": 30, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,RENT)\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.FILE452.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.S19.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.S19.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT477.FILE452(LISTVOLS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   LISTVOLS\n SETSSI  CB477452\n SETCODE AC(0)\n NAME    LISTVOLS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTVOLS": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x02E\\x02E\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 581, "newlines": 581, "modlines": 0, "user": "SOURCE"}, "text": "LISTVOLS TITLE 'LISTVOLS - Display All Volume Entries for a Cataloged D-\n               ataset'\n***********************************************************************\n*                                                                     *\n*   Program Name:   LISTVOLS                                          *\n*                                                                     *\n*  Documentation:   This TSO command tells you what volumes a         *\n*                   dataset is cataloged to.  It is especially        *\n*                   useful for displaying information about datasets  *\n*                   which are cataloged to multiple volumes, even a   *\n*                   very large number (much bigger than 20).          *\n*                                                                     *\n*                   A direct SVC 26 LISTCAT interface is used,        *\n*                   courtesy of Dan Dalby.  Prettified by Sam Golob   *\n*                   and fixed again by Dan Dalby.                     *\n*                                                                     *\n*                   The first dataset prompt and input are via TPUT   *\n*                   and TGET.  But the other terminal outputs are     *\n*                   via PUTLINE, so they can be sysouttrap'ed.        *\n*                                                                     *\n*         Syntax:   LISTVOLS                                          *\n*                                                                     *\n*                   Then answer the prompt:                           *\n*                                                                     *\n*              Enter Dataset Name whose Volumes are to be Listed:     *\n*                                                                     *\n*              Give the unquoted, full dataset name.                  *\n*                                                                     *\n*     Sample Captured Output:                                         *\n*                                                                     *\n*        LISTVOLS - Display Volumes of a Cataloged Dataset            *\n*        -------- - ------- ------- -- - --------- -------            *\n*        Dataset Name:  IBMUSER.B.CBTEX05.XMI                         *\n*        Volume # :     1  WORK01                                     *\n*        Volume # :     2  WORK02                                     *\n*                                                                     *\n*     This program is REENTRANT.                                      *\n*                                                                     *\n*     Required Externals:  Macros from CBT Tape File 452 MACLIB       *\n*                          member:                                    *\n*                                                                     *\n*          #CATRC   #COPY    #CTGFL   #CTGPL   #DSECTS                *\n*          #GETFL   #PATCH   #REGS    #START   #STARTWA               *\n*          #STOP    #STOPWA  CICB     IDAAMDSB IEZCAML                *\n*          IEZCTGFL IEZCTGFV IEZCTGPL IEZCTGVL IEZCTGWA               *\n*          IGGCAXWA IGGCCA   IGGCCX   SHI                             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLISTVOLS #START ,                  Start Procedure                     *\n               AMODE=31,           Execute In 31-Bit AMode             *\n               BASE=(R12),         Define Base Register(S)             *\n               COPY=YES,                                               *\n               LOC=BELOW,          Indicate 24-Bit WorkArea            *\n               RMODE=ANY,          Execute In Any RMode                *\n               WKDSECT=WRKAREA,    Define WorkArea Name                *\n               LEVEL=**TEST**      Maintenance Level\n\n*-------\n*        Prompt For Dataset Name To Be Listed\n*-------\n         APUT  TITLE1,L'TITLE1\n         APUT  TITLE2,L'TITLE2\n         MVC   WRKTPUT,PROMPT1     Copy Message To Below The Line\n         TPUT  WRKTPUT,L'PROMPT1,ASIS\n         TGET  DSNAME,L'DSNAME     Get User Specified Dsname\n         OC    DSNAME,BLANKS       Ensure It Is In Upper Case\n         MVC   WKTITLE(15),=CL15'Dataset Name:  '\n         APUT  WKTITLE,WKLENTH     PUT Dsname into command output\n         OC    DSNAME,BLANKS       OC here, is just to get Cond Code\n         BZ    LISTEXIT            B. If No Name Specified\n\n*-------\n*        Build And Issue The Catalog Request\n*-------\n         L     R2,=A(32*1024)      Start With A 32K Buffer\nLIST0100 DS    0H\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKBUFF@         Save Catalog Work Buffer ADDRESS\n         ST    R2,WRKBUFFL         Save Catalog Work Buffer LENGTH\n\n         XC    WRKCTGFL,WRKCTGFL\n         #CTGFL VOLSER,            Request Volume Serial               *\n               MF=(E,WRKCTGFL)\n         L     R2,WRKBUFF@         A(Work Buffer)\n         L     R3,WRKBUFFL         L(Work Buffer)\n*        Check The Catalog Parameter List (IEZCTGPL) To Understand\n         #CTGPL LISTCAT,                                               *\n               OPTIONS=(NAME,AM0),                                     *\n               CRI=DSNAME,                                             *\n               FIELDS=(WRKCTGFL),                                      *\n               WORK=((R2),(R3),FORMAT2),                               *\n               MF=(E,WRKCTGPL)\n         CATALOG WRKCTGPL          Issue LISTCAT Request\n\n         C     R15,=A(40)          Check For \"Work Area Too Small\"\n         BNE   LIST0200            B. If Not\n         L     R1,WRKBUFF@         A(Work Area)\n         L     R2,4(,R1)           Load \"Required\" Work Area Length\n         L     R3,WRKBUFFL         L(Work Area)\n         FREEMAIN RU,A=(R1),LV=(R3)\n         B     LIST0100            Retry LISTCAT With The Larger Buffer\n\nLIST0200 DS    0H\n         LTR   R15,R15             Check If \"LISTCAT\" Worked\n         BZ    LISTWKED            B. If Yes\n         LA    R5,WRKCTGPL\n         USING CTGPL,R5\n         ST    R15,WRKST15\n         MVC   WORKAG1(MESSAG1L),MESSAG1\n         HEX   WORKAG1H,4,WRKST15\n         MVC   WORKAG1M,CTGMODID\n         HEX   WORKAG1R,2,CTGREASN\n         DROP  R5\n         APUT  WORKAG1,WORKAG1L    Else. Put out error message.\n         B     LISTEXIT\nLISTWKED DS    0H\n*-------\n*        Display The Volumes Returned From The Catalog\n*-------\n         #GETFL WRKCTGFL,(R2),(R3),ZERO=LISTEXIT\nLIST0300 DS    0H\n         MVC   WRKLIT1(L'VOLLIT1),VOLLIT1\n         LA    R5,1\n         ST    R5,VOLSBIN\nLIST03LP DS    0H\n         CVD   R5,CVDAREA          Convert count to printable\n         MVC   WRKNUMSP(10),MASK10     Move in the mask\n         ED    WRKNUMSP(10),CVDAREA+3  Make it pretty\n         MVC   WRKMASK(8),BLANKS\n         MVC   WRKMASK(6),WRKNUMSP+4\n         MVC   WRKVOL,0(R2)        Copy The Current Volume Serial\n         APUT  WRKVOLMS,WRKLLEN\n         L     R5,VOLSBIN          Increment\n         LA    R5,1(,R5)              Volser\n         ST    R5,VOLSBIN                Count\n         AHI   R2,6                A(Next Volume Serial)\n         SHI   R3,6                Subtract Length Of Volume\n         LTR   R3,R3               Check For More Data\n         BP    LIST03LP            B. If Yes\n\n         B     LISTEXIT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         ST    R9,SAVR9HEX\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVR9HEX\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLISTEXIT #STOP ,                   Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants And Work Area                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nBLANKS   DC    256C' '\nPROMPT1  DC    C'Enter Dataset Name whose Volumes are to be Listed: '\nTITLE1   DC    C'LISTVOLS - Display Volumes of a Cataloged Dataset'\nTITLE2   DC    C'-------- - ------- ------- -- - --------- -------'\nMESSAG1  DC    C'LISTCAT Failed. Catalog Error in IGG0CL'\nMESSAG1M DC    C'  '\n         DC    C'. RC='\nMESSAG1H DC    C'         '\n         DC    C' RS='\nMESSAG1R DC    C'    '\nMESSAG1L EQU   *-MESSAG1\nVOLLIT1  DC    C'Volume # :'\nMASK10   DC    XL10'40202020202020202120'\n         #STARTWA ,\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVR9HEX DS    F\nCVDAREA  DS    D                   For CVD instruction\nWRKTPUT  DS    CL(L'PROMPT1)       TPUT Buffer Must Be Below The Line\n         CNOP  0,4\nWRKCTGPL DS    XL(CTGPLLEN+1*4)\nWRKCTGFL DS    XL(CTGFLLEN)\n\nWORKAG1  DC    C'LISTCAT Failed. Catalog Error in IGG0CL'\nWORKAG1M DC    C'  '\n         DC    C'. RC='\nWORKAG1H DC    C'         '\n         DC    C' RS='\nWORKAG1R DC    C'    '\nWORKAG1L EQU   *-WORKAG1\nWRKBUFF@ DS    A                   Catalog Buffer Address\nWRKBUFFL DS    A                   Catalog Buffer Length\nWRKST15  DS    F\nVOLSBIN  DS    F\nWKTITLE  DC    CL15'Dataset Name:  '\nDSNAME   DS    CL44                Full Data Set Name\nWKLENTH  EQU   *-WKTITLE\nWRKVOLMS DS    0CL26\nWRKLIT1  DC    C'          '\nWRKMASK  DC    CL8' '\nWRKVOL   DS    CL6                 Volume Serial\nWRKLLEN  EQU   *-WRKLIT1\nWRKNUMSP DC    CL12' '\n         #STOPWA ,\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #DSECTS ALLOC,CATLG\n         END   ,\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n         IKJCPPL\n\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n\n         IHAPSA   LIST=YES                                     HD APR88\n\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n\n         USING PSA,0\n         L     R2,PSATOLD               @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n\n         LTORG ,\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADLIB": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x19 \\x9f\\x01\\x19 \\x9f\\x141\\x07t\\x07t\\x00\\x00\\xe7\\xd4\\xc9\\xe3\\xc6\\xd4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-28T00:00:00", "modifydate": "2019-07-28T14:31:29", "lines": 1908, "newlines": 1908, "modlines": 0, "user": "XMITFMT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LWAEDIT1": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x04\\x01\\x082\\x9f\\x01\\x082\\x9f\\x19X\\x009\\x009\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2008-11-24T00:00:00", "modifydate": "2008-11-24T19:58:04", "lines": 57, "newlines": 57, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n  % TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(LEFT)            SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  CAPS(OFF) JUST(LEFT)            SKIP(ON)\n  _ TYPE(NEF)    CAPS(ON) PAD(NULLS)\n  \u00ac TYPE(NEF)    CAPS(ON) PAD('.')\n  $ TYPE(NT)\n  ! TYPE(ET)\n  ~ TYPE(LID)\n  \u00a2 TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(LEFT)            SKIP(OFF)\n)BODY\n%---------------------------------- LWATMgr ------------------------------------\n+Command ===>_ZCMD                                 +Date:%&ZDATE   +Time:%&ZTIME\n+                                                                              +\n      *------------------------------------------------------------------*\n      *                                                                  *\n      *               TSO Authorized Command Table Manager               *\n      *                                                                  *\n      *                                                                  *\n      *------------------------------------------------------------------*\n+                                                                              +\n+                                                                              +\n$Enter!\"/\"$to select table or!\"EXIT\"$/!\"CANCEL\"$to terminate.                  +\n+                                                                              +\n+  \u00acZ~AUTHTSF+  -  Authorized when called through the TSO Service Facility.    +\n+  \u00acZ~AUTHCMD+  -  Authorized Commands.                                        +\n+  \u00acZ~AUTHPGM+  -  Authorized Programs.                                        +\n+  \u00acZ~NOTBKGND+ -  Commands Which May Not Be Issued In The Background.         +\n)INIT\n  &AUTHTSF = 'AUTHTSF'\n  &AUTHCMD = 'AUTHCMD'\n  &AUTHPGM = 'AUTHPGM'\n  &NOTBKGND = 'NOTBKGND'\n\n  .ZVARS='(SEL1 SEL2 SEL3 SEL4)'\n  &SEL1 = &Z\n  &SEL2 = &Z\n  &SEL3 = &Z\n  &SEL4 = &Z\n)PROC\n  &ZCURSOR = .CURSOR\n\n  VER (&SEL1,LIST,'/')\n  VER (&SEL2,LIST,'/')\n  VER (&SEL3,LIST,'/')\n  VER (&SEL4,LIST,'/')\n\n  &ALL = '&SEL1 &SEL2 &SEL3 &SEL4'\n  IF (&ALL = ' ')\n     IF (&ZCURSOR = 'SEL1')\n        &SEL1 = '/'\n     IF (&ZCURSOR = 'SEL2')\n        &SEL2 = '/'\n     IF (&ZCURSOR = 'SEL3')\n        &SEL3 = '/'\n     IF (&ZCURSOR = 'SEL4')\n        &SEL4 = '/'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATEDI$": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00@\\x01\\x081?\\x01\\t\\x03\\x7f\\x084\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-11-08T00:00:00", "modifydate": "2009-02-06T08:34:40", "lines": 30, "newlines": 30, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.S19.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.S19.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.FILE452.MACLIB\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(LWATEDIT)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   LWATEDIT\n SETSSI  CB478452\n SETCODE AC(0)\n NAME    LWATEDIT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LWATEDI@": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\t\\x04\\x1f\\x01\\t\\x04\\x1f\\x008\\x00!\\x00!\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-02-10T00:00:00", "modifydate": "2009-02-10T00:38:26", "lines": 33, "newlines": 33, "modlines": 0, "user": "HELP"}, "text": "                 NOTES ON HOW TO USE LWATEDIT\n\n\nThe LWATEDIT program was written by Dan Dalby, to make it easier to\nmanipulate your TSO authorization tables, just by editing them.\n\nIngredients:\n\n1.  Copy the LWAEDIT1 panel to one of your ISPPLIB libraries.\n\n2.  Assemble the LWATEDIT program.  It should NOT be APF-authorized.\n\n3.  Assemble the LWATMGR program.  This program has to have its name\n    in the AUTHCMD table (when it is used standalone) and also in the\n    AUTHTSF table (so it can be called by IKJEFTSR from the LWATEDIT\n    program).\n\n4.  Issue the TSO command LWATEDIT from within ISPF.\n\n5.  You will get the LWAEDIT1 panel, which will ask you to pick which\n    table you want to edit.  Place a slash / next to the table you\n    want to edit.  Press ENTER.  You will get a list of 8-character\n    program names that are in the table.  Do what you want with this\n    table, sort it, etc.  When you have finished, if you want to make\n    the new names into a new table, enter SAVE.  Otherwise just END.\n\n6.  If you SAVEd the table and then exit, LWATEDIT will call LWATMGR\n    using IKJEFTSR (that's why LWATMGR has to be in AUTHTSF), and\n    LWATMGR will update the table with your new SAVEd entries.\n\n7.  Making a new table is easy, just edit the old one with LWATEDIT,\n    change it, SAVE it, and exit.  Easy as pie.  Thanks, Dan Dalby!\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LWATEDIT": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x03\\xcc\\x03\\xcc\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 972, "newlines": 972, "modlines": 0, "user": "SOURCE"}, "text": "LWATEDIT TITLE '- LWATEDIT - LWA Auth Table Editor'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* L W A T E D I T |                                                   *\n*                 |          Logon WorkArea Table Editor              *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    FUNCTION:     Use ISPF Services to EDIT the TSO user's           *\n*                  authorization tables.                              *\n*                                                                     *\n*                  The update of these tables is performed by the     *\n*                  \"LWATMGR BUILD\" command function.                  *\n*                  This means that LWATMGR must be accessable to      *\n*                  you either via STEPLIB or LNKLST.                  *\n*                                                                     *\n* Special Note: LWATMGR must be added to the AUTHTSF (IKJEFTAP) table.*\n*               Otherwise the call to LWATMGR (using the IKJEFTSR     *\n*               interface) will fail.                                 *\n*                                                                     *\n*                                                                     *\n*       PARMS:  This program must be selected as a command in ISPF.   *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE:   R0 - PSA                                          *\n*                   R1 - Work Register                                *\n*                   R2 - Work Register                                *\n*                   R3 - Work Register                                *\n*                   R4 - Work Register                                *\n*                   R5 - Work Register                                *\n*                   R6 - Work Register                                *\n*                   R7 - Work Register                                *\n*                   R8 - CPPL                                         *\n*                   R9 - Work Register                                *\n*                  R10 - PCL                                          *\n*                  R11 - Not Used                                     *\n*                  R12 - Base Register #1                             *\n*                  R13 - Work Area Base Register (24-Bit Storage)     *\n*                  R14 - Return Address                               *\n*                  R15 - Return Code                                  *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: #V01R001 - NOV 07,2008 -  In The Beginning...          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Instream Macros                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MACRO ,\n&NAME    #SAVE ,\nSUBRTNS  LOCTR ,\n&NAME    ST    R15,STACK15         Save Work Register\n         L     R15,STACKNX@        A(Next Save Area)\n         C     R15,STACKEND        Check If Stack Has Overflowed\n         JL    #&SYSNDX            B. If Not\n         ABEND 1                   User Abend\n#&SYSNDX STM   R0,R14,0(R15)       Save Registers 0 Through 14\n         MVC   15*4(4,R15),STACK15 Save R15 As Well\n         AHI   R15,16*4            A(Next Save Area)\n         ST    R15,STACKNX@        Save Next Save Area Address\n         BALR  R11,0               Initialize Subroutine Base\n         USING *,R11\n         MEND  ,\n\n         MACRO ,\n&NAME    #RESTORE &R15=\n&NAME    DS    0H\n         AIF   ('&R15' EQ '').REST030\n         AIF   ('&R15'(1,1) EQ '(').REST010\n         LA    R15,&R15            Set Return Code\n         AGO   .REST020\n.REST010 ANOP  ,\n         AIF   ('&R15' EQ '(R15)').REST020\n         LR    R15,&R15(1)         Set Return Code\n.REST020 ANOP  ,\n         ST    R15,WRKR15          Save Return Code Value\n.REST030 ANOP  ,\n         L     R15,STACKNX@        A(Next Save Area)\n         SHI   R15,16*4            A(Current Save Area)\n         ST    R15,STACKNX@        Restore Next Save Area Address\n         LM    R0,R15,0(R15)       Restore All Registers\n         J     #&SYSNDX\n         #EXEC ,                   Executed Statements\n         LTORG ,                   Literal Pool\n#&SYSNDX DS    0H\n         AIF   ('&R15' EQ '').REST040\n         L     R15,WRKR15          Restore Return Code Value\n.REST040 ANOP  ,\n         MEND  ,\n\n         MACRO ,\n&NAME    #CALL &RTN\n&NAME    L     R15,=A(&RTN)        A(Processing Routine)\n         BALR  R14,R15             Call Subroutine\n         MEND  ,\n\nLWATEDIT #START ,                  Start Mainline                      *\n               BASE=(R12),         Define Base Register(s)             *\n               COPY=YES,                                               *\n               WKDSECT=WRKLWAED,   Define Work Area Name               *\n               LOC=BELOW,          Acquire Work Area Below The Line    *\n               REG1=R8,            Command Parameter List              *\n               AMODE=31,RMODE=ANY, Execute In AMODE 31, RMODE Any      *\n               USING=(PSA,0,CPPL,R8),                                  *\n               LEVEL=#V01R001      Version Identifier\n\n*-------\n*        Initialize Save Area Stack Pointers\n*-------\n         LA    R1,STACK            A(Start Of Save Area Stack)\n         ST    R1,STACKNX@         Save \"Next\" Address\n         AH    R1,=AL2(STACKLEN)   A(End Of Save Area Stack)\n         ST    R1,STACKEND         Save \"End\" Address\n\n         MVI   BLANKS,C' '         Initialize BLANKS Area\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate and Validate The LWA                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R14,PSAAOLD         A(ASCB)\n         USING ASCB,R14\n         L     R14,ASCBASXB        A(ASXB)\n         USING ASXB,R14\n         L     R14,ASXBLWA         A(LWA)\n         ST    R14,WRKLWA@         Save LWA Address\n         USING LWA,R14\n\n         C     R14,LWAPPTR         Check If LWA Points To Itself\n         BNE   LWA00400            B. If Not\n         CLC   LWALWA,=C'   LWA  ' Check LWA Identifier\n         BNE   LWA00400            B. If Valid\n\n\n*-------\n*        Save The Authorization Table Pointer Addresses\n*-------\n         LA    R0,LWATAP           A(IKJEFTAP Pointer)\n         ST    R0,WRKTAPP@\n         LA    R0,LWATAPLN         A(IKJEFTAP Length)\n         ST    R0,WRKTAPL@\n         MVC   WRKTAPL,LWATAPLN    Save IKJEFTAP Length\n         TM    LWAPRMLB,LWATAPST   Did IKJEFTAP Come From //STEPLIB\n         BZ    LWA00100            B. If Not\n         OI    WRKTAPF,WRK$STEP\nLWA00100 DS    0H\n         LA    R0,LWATE2           A(IKJEFTE2 Pointer)\n         ST    R0,WRKTE2P@\n         LA    R0,LWATE2LN         A(IKJEFTE2 Length)\n         ST    R0,WRKTE2L@\n         MVC   WRKTE2L,LWATE2LN    Save IKJEFTE2 Length\n         TM    LWAPRMLB,LWATE2ST   Did IKJEFTE2 Come From //STEPLIB\n         BZ    LWA00200            B. If Not\n         OI    WRKTE2F,WRK$STEP\nLWA00200 DS    0H\n         LA    R0,LWATE8           A(IKJEFTE8 Pointer)\n         ST    R0,WRKTE8P@\n         LA    R0,LWATE8LN         A(IKJEFTE8 Length)\n         ST    R0,WRKTE8L@\n         MVC   WRKTE8L,LWATE8LN    Save IKJEFTE8 Length\n         TM    LWAPRMLB,LWATE8ST   Did IKJEFTE8 Come From //STEPLIB\n         BZ    LWA00300            B. If Not\n         OI    WRKTE8F,WRK$STEP\nLWA00300 DS    0H\n         LA    R0,LWATNS           A(IKJEFTNS Pointer)\n         ST    R0,WRKTNSP@\n         LA    R0,LWATNSLN         A(IKJEFTNS Length)\n         ST    R0,WRKTNSL@\n         MVC   WRKTNSL,LWATNSLN    Save IKJEFTNS Length\n         TM    LWAPRMLB,LWATNSST   Did IKJEFTNS Come From //STEPLIB\n         BZ    LWA00500            B. If Not\n         OI    WRKTNSF,WRK$STEP\n         B     LWA00500\n         DROP  R14\n\nLWA00400 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG001)      A(Error Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Save the TSO control block addresses                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA00500 DS    0H\n         L     R0,CPPLUPT          A(UPT)\n         ST    R0,WRKUPT@\n         L     R0,CPPLECT          A(ECT)\n         ST    R0,WRKECT@\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Process The Tables Via ISPF EDIT                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*-------\n*        Check For ISPF Environment\n*-------\n         LINK  EP=ISPQRY           Check For An ISPF Enfironment\n         LTR   R15,R15             Check Return Code\n         BZ    LWA00600            B. If ISPF Is Available\n         ST    R15,WRKR15          Save Return Code\n\n         LHI   R0,2                Message Contains 2 Segment\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0021)\n         UNPK  WRKINS1+4(9),WRKR15(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS1+4(8),0(R15)\n         MVI   WRKINS1+4+8,C' '\n         L     R1,=A(#MSG002)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*-------\n*        Define ISPF Variables\n*-------\nLWA00600 DS    0H\n         ISPLINK LOAD,SAVE=WRKLINK@,LIST=WRKCALL\n\n         ISPLINK 'VDEFINE ','DATAID  ',DATAID,'CHAR ',8\n         ISPLINK 'VDEFINE ','SEL1    ',WRKSEL1,'CHAR ',1\n         ISPLINK 'VDEFINE ','SEL2    ',WRKSEL2,'CHAR ',1\n         ISPLINK 'VDEFINE ','SEL3    ',WRKSEL3,'CHAR ',1\n         ISPLINK 'VDEFINE ','SEL4    ',WRKSEL4,'CHAR ',1\n         ISPLINK 'VDEFINE ','TEMPMSG ',TEMPMSG,'CHAR ',8\n         ISPLINK 'VDEFINE ','TEMPREC ',TEMPREC,'CHAR ',80\n         ISPLINK 'VDEFINE ','ZDSN    ',WRKZDSN,'CHAR ',44\n         ISPLINK 'VDEFINE ','ZMEMB   ',WRKCMDNM,'CHAR ',8\n         ISPLINK 'VDEFINE ','ZTEMPF  ',ZTEMPF,'CHAR ',44\n         ISPLINK 'VDEFINE ','ZTEMPN  ',ZTEMPN,'CHAR ',8\n\nLWA00700 DS    0H\n         MVI   WRKSEL1,C' '        Initialize\n         MVI   WRKSEL2,C' '        .  Panel\n         MVI   WRKSEL3,C' '        .     Selection\n         MVI   WRKSEL4,C' '        .        Options\n\n         ISPLINK 'DISPLAY ','LWAEDIT1',ERROR=LWA01500\n\n*-------\n*        Edit \"AUTHTSF\" Table\n*-------\n         CLI   WRKSEL1,C'/'        Check If \"AUTHTSF\"  Selected\n         BNE   LWA00900            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNM,=C'---AP---'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n\n         L     R15,WRKTAPP@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTAPL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA00800            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA00800 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n*-------\n*        Edit \"AUTHCMD\" Table\n*-------\nLWA00900 DS    0H\n         CLI   WRKSEL2,C'/'        Check If \"AUTHCMD\"  Selected\n         BNE   LWA01100            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNM,=C'---E2---'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n\n         L     R15,WRKTE2P@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTE2L@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA01000            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA01000 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n*-------\n*        Edit \"AUTHPGM\" Table\n*-------\nLWA01100 DS    0H\n         CLI   WRKSEL3,C'/'        Check If \"AUTHPGM\"  Selected\n         BNE   LWA01300            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNM,=C'---E8---'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n\n         L     R15,WRKTE8P@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTE8L@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA01200            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA01200 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n*-------\n*        Edit \"NOTBKGND\" Table\n*-------\nLWA01300 DS    0H\n         CLI   WRKSEL4,C'/'        Check If \"NOTBKGND\" Selected\n         BNE   LWA00700            B. If Not\n\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNM,=C'---NS---'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n\n         L     R15,WRKTNSP@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         L     R15,WRKTAB@\n         AHI   R15,16              A(1st Table Entry)\n         ST    R15,WRKTABE@\n         L     R15,WRKTNSL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         ICM   R0,3,WRKTABL        Check If Table Has A Length\n         BNZ   LWA01400            B. If Yes\n         #CALL SETTABL             Else. Calculate Table Length\n\nLWA01400 DS    0H\n         #CALL EDIT                Edit The Table Entries\n\n         B     LWA00700\n\n*-------\n*        Delete ISPF Variables and Terminate\n*-------\nLWA01500 DS    0H\n         ISPLINK 'VDELETE ','* '   Delete All Defined Variables\n         ISPLINK UNLOAD            Delete ISPLINK Routine\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWAEXIT  DS    0H\n         #CALL CLEANUP             Free All Acquired Storage\n\n         #STOP ,                   Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n\n#MSG001  #MSG  'LWAE01I LWA control block is not valid'\n\n#MSG002  #MSG  'LWAE02I This Program Requires An ISPF Environment.  ISP*\n               QRY Return Code  '\n#MSG0021 EQU   71,8                Insert Offset & Length\n\n#MSG003  #MSG  'LWAE03I R15=, IKJEFTSR RC= RS= ABEND= '\n#MSG0031 EQU   12,8                Insert Offset & Length\n#MSG0032 EQU   26,8                Insert Offset & Length\n#MSG0033 EQU   30,8                Insert Offset & Length\n#MSG0034 EQU   37,8                Insert Offset & Length\n\nHEXTABLE DC    C'0123456789ABCDEF'\n\nCONVDASH DC    256AL1(*-CONVDASH)\n         ORG   CONVDASH+C' '\n         DC    C'-'                Convert Blanks To Dashes\n         ORG   ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Subroutines                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Perform Program Termination Cleanup                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCLEANUP  #SAVE ,                   Save All Registers\n\n         ICM   R1,15,WRKBUFF@      A(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         ICM   R0,15,WRKBUFFL      L(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         XC    WRKBUFF@,WRKBUFF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0200 DS    0H\n         ICM   R1,15,WRKMSGB@      A(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         ICM   R0,15,WRKMSGBL      L(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         XC    WRKMSGB@,WRKMSGB@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0300 DS    0H\n         ICM   R1,15,WRKCBUF@      A(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         ICM   R0,15,WRKCBUFL      L(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         XC    WRKCBUF@,WRKCBUF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEANXIT #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Use ISPF EDIT To Process The Authorization Table Entries     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nEDIT     #SAVE ,                   Save All Registers\n\n         L     R15,WRKTAB@         A(Current Table)\n         AH    R15,WRKTABL         A(End Of Current Table)\n         ST    R15,WRKTABX@        Save End Of Table Address\n         SH    R15,WRKTABEL        A(Last Entry In Table)\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Entry\n         BE    EDIT0100            B. If Yes\n         ICM   R0,3,0(R15)         Check If Entry Length Is Zero\n         BZ    EDIT0200            B. If Yes (End Of Table)\n         CLC   0(2,R15),=X'FFFF'   Check For Terminating Entry\n         BE    EDIT0200            B. If Yes (End Of Table)\n         TM    2(R15),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    EDIT0200            B. If Yes (End Of Table)\n         B     EDIT0300            Else. Last Entry Is Used\n\nEDIT0100 DS    0H\n         TM    0(R15),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    EDIT0200            B. If Yes (End Of Table)\n         B     EDIT0300            Else. Last Entry Is Used\n\nEDIT0200 DS    0H\n         ST    R15,WRKTABX@        Save End Of Table Address\n\nEDIT0300 DS    0H\n         MVC   WRKDSN,BLANKS\n         MVC   WRKDSN(8),WRKCMDNM  Put Table Name in EDIT Heading\n         ICM   R15,15,WRKTAB@      A(Current Table)\n         BZ    EDITEXIT            B. If No Table\n         MVC   WRKDSN+9(16),0(R15) Copy Table Header To Edit Heading\n         UNPK  WRKDSN+26(9),WRKTAB@(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKDSN+26(8),0(R15) Insert Table Address\n         MVI   WRKDSN+26+8,C' '\n         L     R15,=A(CONVDASH)\n         TR    WRKDSN(34),0(R15)   Convert Blanks To Dashes\n\n         MVC   WRKZDSN,BLANKS\n         MVC   WRKZDSN(18),=C'LWA.IKJEFTxx.TABLE'\n         MVC   WRKZDSN+10(2),WRKTABNM+3\n\n         ISPLINK 'FTOPEN ','TEMP ' Allocate An SPFTEMP.CNTL Data Set\n         ISPLINK 'VGET ','(ZTEMPF ZTEMPN)','ASIS '\n         ISPLINK 'FTCLOSE ',,ZTEMPF\n\n         ISPLINK 'LMINIT ','DATAID ',,,,,,,,ZTEMPN,,'EXCLU '\n         ISPLINK 'LMOPEN ',DATAID,'OUTPUT '\n         MVC   TEMPREC,BLANKS\n         MVC   TEMPREC(8),WRKTABNM\n         ISPLINK 'LMPUT',DATAID,'INVAR ','TEMPREC ',80\n\n         MVI   WRKUPDTE,C'N'       Initialize \"Update\" Flag\n\n         ST    R13,WRKR13          Save WorkArea Address\n         ISPLINK 'EDIF ',WRKDSN,'LWAPROF ','F ',8,                     *\n               A(EDIFREAD),A(EDIFWRITE),0,WRKR13\n\n         MVC   TEMPREC,BLANKS\n         LHI   R3,5                Add 5 Blank Slots For Use By TSUB\nEDIT0400 DS    0H\n         ISPLINK 'LMPUT',DATAID,'INVAR ','TEMPREC ',80\n         BCT   R3,EDIT0400\n\n         ISPLINK 'LMCLOSE ',DATAID Close The ISPTEMP File\n         ISPLINK 'LMFREE ',DATAID  Free The ISPTEMP File\n\n         CLI   WRKUPDTE,C'N'       Check If An Update Has Occurred\n         BE    EDITEXIT            B. If Not\n\n         MVC   WRKTSRFL,=AL1(0,0,1,1) Set IKJEFTSR Flags\n         MVC   WRKTSRC,BLANKS      Clear Command Buffer\n         MVC   WRKTSRC(19),=C'LWATMGR BUILD LIST('\n         MVI   WRKTSRC+19,C''''    Insert Leading Quote\n         MVC   WRKTSRC+20(44),ZTEMPF\n         L     R15,=A(FINDBLANK)\n         TRT   WRKTSRC+20(45),0(R15)\n         MVI   0(R1),C''''         Insert Trailing Quote\n         MVI   1(R1),C')'          Close the \"LIST\" Operand\n         LA    R15,2(,R1)          A(End Of DSName)\n         MVC   0(6,R15),=C' NOMSG' Don't Issue Messages\n         LA    R15,6(,R15)         A(End Of Command)\n         LA    R14,WRKTSRC         A(Start Of Command)\n         SR    R15,R14\n         ST    R15,WRKTSRCL        Save Command Length\n         XC    WRKRETCD,WRKRETCD\n         XC    WRKRSNCD,WRKRSNCD\n         XC    WRKABNCD,WRKABNCD\n\n         L     R15,FLCCVT             A(CVT)\n         L     R15,CVTTVT-CVT(,R15)   A(TSVT)\n         L     R15,TSVTASF-TSVT(,R15) A(Interface Routine)\n         CALL  (15),(WRKTSRFL,     Invoke IKJEFTSR Service Routine     *\n               WRKTSRC,            - Command                           *\n               WRKTSRCL,           - Command Length                    *\n               WRKRETCD,           - Return Code                       *\n               WRKRSNCD,           - Reason Code                       *\n               WRKABNCD),          - Abend  Code                       *\n               VL,MF=(E,WRKTSRPL)\n\n         LTR   R15,R15             Check Return Code\n         BZ    EDIT0500            B. If Successful\n\n         ST    R15,WRKR15          Save Return Code\n\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0031)\n         UNPK  WRKINS1+4(9),WRKR15(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS1+4(8),0(R15)\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0032)\n         UNPK  WRKINS2+4(9),WRKRETCD(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVC   WRKINS3(4),=AL2(4+8,#MSG0033)\n         UNPK  WRKINS3+4(9),WRKRSNCD(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS3+4(8),0(R15)\n         MVC   WRKINS4(4),=AL2(4+8,#MSG0034)\n         UNPK  WRKINS4+4(9),WRKABNCD(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS4+4(8),0(R15)\n\n         LHI   R0,5                Message Contains 5 Segments\n         L     R1,=A(#MSG003)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         B     EDITEXIT\n\nEDIT0500 DS    0H\n         ISPLINK 'SETMSG ','ISRE016 '\n\nEDITEXIT #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISPF EDIF \"READ\" Routine                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSUBRTNS  LOCTR ,\n\n         PUSH  USING\nEDIFREAD STM   R14,R12,12(R13)     Save Caller's Registers\n         BASR  R11,0               Set Subroutine Base\n         USING *,R11\n\n         LR    R10,R13             Save Caller's Save Area Address\n         L     R13,12(,R1)         A(Save Area Passed By ISPF)\n         L     R13,0(,R13)         A(Mainline Work Area)\n\n         L     R5,8(,R1)\n         L     R5,0(,R5)           Request Code (1-1st 0-Next)\n         L     R4,0(,R1)           A(Recored Area)\n\n         L     R6,WRKTABE@         Calculate Record Offset\n         C     R6,WRKTABX@         Check If Past End Of Table\n         BNL   EDIFR200            B. If Yes\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Entry\n         BE    EDIFR100            B. If Yes\n         AHI   R6,2                Skip Record Prefix\n\nEDIFR100 DS    0H\n         CLI   0(R6),C' '          Check For Blank Entry\n         BE    EDIFR200            B. If Yes (Logical End)\n         ST    R6,0(,R4)           Pass Entry Address To ISPF\n\n         AHI   R6,8                A(Next Entry Address)\n         ST    R6,WRKTABE@\n\n         LHI   R15,0               Set Return Code\n         B     EDIFRXIT\n\nEDIFR200 DS    0H\n         LHI   R15,8               Set Return Code\n         B     EDIFRXIT\n\nEDIFRXIT DS    0H\n         ST    R15,16(,R10)        Save Return Code\n         LR    R13,R10             A(Caller's Save Area)\n         LM    R14,R12,12(R13)     Restore Caller's Registers\n         BR    R14                 Return To Caller\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISPF EDIF \"WRITE\" Routine                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSUBRTNS  LOCTR ,\n\n         PUSH  USING\n         DROP  ,\nEDIFWRITE STM  R14,R12,12(R13)     Save Caller's Registers\n         BASR  R11,0               Set Subroutine Base\n         USING *,R11\n\n         L     R9,16(,R1)          A(Save Area Passed By ISPF)\n         L     R9,0(,R9)           A(Mainline Work Area)\n         USING WRKLWAED,R9\n\n         LR    R10,R13             Save Caller's Save Area Address\n         LA    R13,WRKSAVE         Point To A New Save Area\n\n         L     R4,0(,R1)           A(Record Data Pointer)\n         L     R4,0(,R4)           A(Record Data)\n\n         MVI   WRKUPDTE,C'Y'       Indicate An Update Has Occurred\n\n         L     R6,12(,R1)          A(Request Code)\n         CLC   0(4,R6),=A(4)       Check For \"No Data Records\"\n         BE    EDIFWXIT            B. If Yes\n\n         MVC   TEMPREC(8),0(R4)\n\n         ISPLINK 'LMPUT',DATAID,'INVAR ','TEMPREC ',80\n\nEDIFWXIT DS    0H\n         LHI   R15,0               Set Return Code\n\n         ST    R15,16(,R10)        Save Return Code\n         LR    R13,R10             A(Caller's Save Area)\n         LM    R14,R12,12(R13)     Restore Caller's Registers\n         BR    R14                 Return To Caller\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PUTLINE Subroutine                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nPUTLINE  #SAVE ,                   Save All Registers\n\n         STM   R0,R7,WRKOLD        Save Output Line Descriptors\n\n         L     R3,WRKUPT@          A(UPT)\n         L     R4,WRKECT@          A(ECT)\n\n         XC    WRKECB,WRKECB       Clear ECB\n         PUTLINE PARM=PUTLINEL,UPT=(R3),ECT=(R4),ECB=WRKECB,           *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)      Write The Message\n\nPUTLEXIT DS    0H\n         NI    WRKFLAG,255-$ERROR\n\n         #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Table Length Calculator Routine                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nSETTABL  #SAVE ,                   Save All Registers\n         L     R14,WRKTABE@        A(1st Table Entry)\n\nSETT0100 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Entry\n         BE    SETT0200            B. If Yes\n\n*-------\n*        Check \"NOTBKGND\" Table Entries\n*-------\n         ICM   R0,3,0(R14)         Check If Entry Length Is Zero\n         BZ    SETT0900            B. If Yes (End Of Table)\n         CLC   0(2,R14),=X'FFFF'   Check For Terminating Entry\n         BE    SETT0900            B. If Yes (End Of Table)\n         TM    2(R14),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    SETT0900            B. If Yes (End Of Table)\n         B     SETT0300            Else. Advance To Next Entry\n\n*-------\n*        Check normal Table Entries\n*-------\nSETT0200 DS    0H\n         TM    0(R14),X'BF'        Check If Entry Is Blank Or Zeros\n         BZ    SETT0900            B. If Yes (End Of Table)\n\nSETT0300 DS    0H\n         AH    R14,WRKTABEL        A(Next Table Entry)\n         B     SETT0100            Loop Till End Of Table\n\nSETT0900 DS    0H\n         AH    R14,WRKTABEL        A(End Of Last Slot)\n         L     R15,WRKTAB@         A(Start Of Table)\n         SR    R14,R15             Calculate Table Length\n         STH   R14,WRKTABL         Save Calculated Table Length\n\n         #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATEDIT LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic Work Area                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nFINDBLANK DC   256X'00'\n         ORG   FINDBLANK+C' '\n         DC    C' '                Find First Blank\n         ORG   ,\n\n         #STARTWA PATCH=NO\n\nPUTLINEL PUTLINE MF=L              PUTLINE Parameter List\n\nWRKCALL  CALL  ,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),VL,MF=L\nWRKLINK@ DS    A                   ISPLINK ROUTINE ADDRESS\n\nBLANKS   DS    CL80                Initialized Blanks\n\nWRKDBL   DS    D\nWRKECB   DS    F                   ECB\nWRKECT@  DS    A                   ECT Address\nWRKUPT@  DS    A                   UPT Address\n\nWRKFLAG  DS    X                   General Flag Byte\n$MSG_NF  EQU   X'08'               - Issue \"Not Found\" Message\n$MSG_F   EQU   X'04'               - Issue \"Found\" Message\n$ERROR   EQU   X'02'               - This Is An Error Message\n\nWRKSAVE  DS    20F                 Register Save Area\n\n         CNOP  0,4\nWRKINS1  DS    AL2,AL2,CL80        PUTLINE Message Insert #1\nWRKINS2  DS    AL2,AL2,CL80        PUTLINE Message Insert #2\nWRKINS3  DS    AL2,AL2,CL80        PUTLINE Message Insert #3\nWRKINS4  DS    AL2,AL2,CL80        PUTLINE Message Insert #4\nWRKINS5  DS    AL2,AL2,CL80        PUTLINE Message Insert #5\nWRKINS6  DS    AL2,AL2,CL80        PUTLINE Message Insert #6\n\nWRKIOPL  DS    4F                  IOPL\nWRKLWA@  DS    A                   LWA Address\nWRKOLD   DS    F                   Number Of Message Segments\n         DS    A                   A(Message Text)\n         DS    A                   A(Message Insert 1)\n         DS    A                   A(Message Insert 2)\n         DS    A                   A(Message Insert 3)\n         DS    A                   A(Message Insert 4)\n         DS    A                   A(Message Insert 5)\n         DS    A                   A(Message Insert 6)\n\nWRKPPL   DS    7F                  PPL\nWRKPDL1  DS    A                   PDL\nWRKPDL2  DS    A                   PDL (IKJTSOxx Section Parse)\n\nWRKKW@   DS    A                   Keyword Matching Found Table\n\nWRKDDPDE DS    A,AL2,CL8           DD Name PDE\nWRKDDN   EQU   WRKDDPDE+6,8        DD Name\nWRKDSPDE DS    A,AL2,CL46          Data Set Name PDE\nWRKDSN   EQU   WRKDSPDE+6,46       Data Set Name\nWRKMNPDE DS    A,AL2,CL8           Member Name PDE\nWRKMEMNM EQU   WRKMNPDE+6,8        Member Name\n\nWRKZDSN  DS    CL44                ISPF Message DSName\nWRKUPDTE DS    C                   Edit Performed Update (Y/N)\nWRKSEL1  DS    C                   ISPF Selection Option\nWRKSEL2  DS    C                   ISPF Selection Option\nWRKSEL3  DS    C                   ISPF Selection Option\nWRKSEL4  DS    C                   ISPF Selection Option\n\n         CNOP  0,4\nWRKCMDNL DS    AL2                 IKJTSOxx Section Command Length\nWRKCMDNM DS    CL8                 IKJTSOxx Section Command\n\nWRKCMD@  DS    A                   IKJTSOxx Buffer Section Start\nWRKCMDE@ DS    A                   IKJTSOxx Buffer Section End\n\nWRKCBUF@ DS    A                   Command Buffer Address\nWRKCBUFL DS    F                   Command Buffer Length\n\nWRKTSRFL DS    0F                  TSO Service Routine Flags\n         DC    X'00'               Reserved\n         DC    X'00'               Internal Processing Options\n         DC    X'01'               Dump If Command Abends\n         DC    X'01'               Command Is Being Invoked\n\n         DS    0F\nWRKTSRC  DS    C'LWATMGR BUILD LIST(''123456789.123456789.123456789.123*\n               456789.1234'')'     Authorized Command\nWRKTSRCL DS    A(L'WRKTSRC)        Authorized Command Length\nWRKRETCD DS    F                   Command Return Code\nWRKRSNCD DS    F                   Command Reason Code\nWRKABNCD DS    F                   Command Abend Code\nWRKTSRPL DS    8F                  TSO Service Routine Parameters\n\nWRKR13   DS    F                   Register 13 Save Area\nWRKR14   DS    F                   Register 14 Save Area\nWRKR15   DS    F                   Register 15 Save Area\n\nWRKREASN DS    F                   IEFPRMLB Reason Code\nWRKRCODE DS    F                   IEFPRMLB Return Code\nWRKBUFF@ DS    A                   IEFPRMLB Return Buffer Address\nWRKBUFFL DS    F                   IEFPRMLB Return Buffer Length\nWRKMSGB@ DS    A                   IEFPRMLB Returned Message Buffer\nWRKMSGBL DS    F                   IEFPRMLB Returned Message Buffer Len\nWRKMSGBE DS    A                   End Of Buffer\n\nWRKDATAL DS    AL2                 Current Keyword's Operand Length\nWRKDATA  DS    CL80                Current Keyword's Operand\nWRKNAMEL DS    AL2                 Current Command/Program Name Length\nWRKNAME  DS    CL8                 Current Command/Program Name\nWRKNAMEO DS    A                   Current Entry's Offset In Table\nWRKNEWNL DS    AL2                 New Command/Program Name Length\nWRKNEWN  DS    CL8                 New Command/Program Name\nWRKTMPNL DS    AL2                 Save Area For NAME Length\nWRKTMPN  DS    CL8                 Save Area For NAME\n\nDATAID   DS    CL8                 LM Data Id\nTEMPMSG  DS    CL8                 Temporary ISPF MsgId\nTEMPREC  DS    CL80                Temporary Output Record\nZTEMPF   DS    CL44                ISPTEMP Dsname\nZTEMPN   DS    CL8                 ISPTEMP DDName\n\nWRKTABNM DS    CL8                 Current Table Name\nWRKTAB@  DS    A                   Current Table Address\nWRKTABE@ DS    A                   Current Table End Address\nWRKTABPK DS    X                   Current Table PSW Key\nWRKTABF  DS    X                   Current Table Flags\nWRK$STEP EQU   X'80'   1... ....   Table Was Loaded From //STEPLIB\nWRKTABEL DS    AL2                 Current Table Entry Length\nWRKTABX@ DS    A                   Current Table End Address\nWRKTABL  DS    AL2                 Current Table LWA Length\n\nWRKTAPP@ DS    A                   IKJEFTAP Table Pointer Address\nWRKTAPL@ DS    A                   IKJEFTAP Table Length Address\nWRKTAPL  DS    AL2                 IKJEFTAP Table Length In LWA\nWRKTAPF  DS    C                   IKJEFTAP Flags\n         DS    X\n\nWRKTE2P@ DS    A                   IKJEFTE2 Table Pointer Address\nWRKTE2L@ DS    A                   IKJEFTE2 Table Length Address\nWRKTE2L  DS    AL2                 IKJEFTE2 Table Length In LWA\nWRKTE2F  DS    C                   IKJEFTE2 Flags\n         DS    X\n\nWRKTE8P@ DS    A                   IKJEFTE8 Table Pointer Address\nWRKTE8L@ DS    A                   IKJEFTE8 Table Length Address\nWRKTE8L  DS    AL2                 IKJEFTE8 Table Length In LWA\nWRKTE8F  DS    C                   IKJEFTE8 Flags\n         DS    X\n\nWRKTNSP@ DS    A                   IKJEFTNS Table Pointer Address\nWRKTNSL@ DS    A                   IKJEFTNS Table Length Address\nWRKTNSL  DS    AL2                 IKJEFTNS Table Length In LWA\nWRKTNSF  DS    C                   IKJEFTNS Flags\n         DS    X\n\nSTACK15  DS    F                   Stack Save Area\nSTACKNX@ DS    A                   Next Save Area On The Stack\nSTACKEND DS    A                   End Of Stack Address\nSTACK    DS    (10*16)F            Register Save Area Stack\nSTACKLEN EQU   *-STACK             Length Of Save Area Stack\n         #STOPWA ,\n\n         IKJEFLWA ,                LOGON Work Area\n\n         IKJEFFDF DFDSECT=YES,DFDSEC2=YES\n         IKJTSVT ,                 TSO Service Vector Table\n\n         #DSECTS ASCB,ASXB,CVT,PSA,TSO\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATMGR": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x17\\x00O\\x01\\x17\\x00O\\x11\"\\x0e\\x11\\x0e\\x11\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-04T00:00:00", "modifydate": "2017-01-04T11:22:25", "lines": 3601, "newlines": 3601, "modlines": 0, "user": "SOURCE"}, "text": "LWATMGR  TITLE '- LWATMGR - LWA Table Manager'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* L W A T M G R   |                                                   *\n*                 |          Logon WorkArea Table Manager             *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    FUNCTION:     Dynamically Manage the TSO user's copy of the      *\n*                  authorization tables.                              *\n*                                                                     *\n*                  These tables are typically created from the        *\n*                  IKJTSOxx parmlib member but can be loaded from     *\n*                  an authorized STEPLIB or from LPA when the user    *\n*                  logs on to TSO.                                    *\n*                                                                     *\n*                  This program can replace the tables entirely,      *\n*                  just selected table(s) or it can add or remove     *\n*                  entries from the existing table.                   *\n*                                                                     *\n*                  The updates to this table affect the current TSO   *\n*                  user only.  The other TSO users are unchanged.     *\n*                  This makes this command ideal for testing a new    *\n*                  IKJTSOxx member.                                   *\n*                                                                     *\n*                  Note: If the initial table was loaded from either  *\n*                        STEPLIB or it resides in LPA, this program   *\n*                        will replace the table with one simulating   *\n*                        the PARMLIB version of the table.            *\n*                        Once the table is in this format additions   *\n*                        and deletions can easily be performed.       *\n*                        When this \"LOAD MODULE\" verion of the table  *\n*                        is replaced, it's storage is not released    *\n*                        as the actual size is unknown.               *\n*                        As this is only done one time it should not  *\n*                        cause a storage shortage problem.            *\n*                                                                     *\n*                                                                     *\n*       PARMS:  See comment block above \"PCL\".                        *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE:   R0 - PSA                                          *\n*                   R1 - Work Register                                *\n*                   R2 - Work Register                                *\n*                   R3 - Work Register                                *\n*                   R4 - Work Register                                *\n*                   R5 - Work Register                                *\n*                   R6 - Work Register                                *\n*                   R7 - Work Register                                *\n*                   R8 - CPPL                                         *\n*                   R9 - Work Register                                *\n*                  R10 - PCL                                          *\n*                  R11 - Base Register #2                             *\n*                  R12 - Base Register #1                             *\n*                  R13 - Work Area Base Register (24-Bit Storage)     *\n*                  R14 - Return Address                               *\n*                  R15 - Return Code                                  *\n*                                                                     *\n*                                                                     *\n* EXTERNALS:                                                          *\n*            DYNALLOC - Under the guise of the \"ALLOC\" and \"FREE\"     *\n*                       macro, to perform dynamic allocation.         *\n*            IEFPRMLB - Read the specified PARMLIB member into        *\n*                       storage as one large string.                  *\n*            IKJPARS  - Parse the main command & also parse the       *\n*                       IKJTSOxx statements.                          *\n*            ISPLINK  - Invoke ISPF Services.                         *\n*            PUTLINE  - Write messages to the user.                   *\n*                                                                     *\n*                                                                     *\n* Attributes:  Authorized, Key 8, Problem State, Reentrant, Amode 31. *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: #V01R001 - NOV 07,2008 -  In The Beginning...          *\n*              #V01R002 - MAR 02,2012 -  Add EAV Support.      #DD12062\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Instream Macros                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MACRO ,\n&NAME    #SAVE ,\nSUBRTNS  LOCTR ,\n&NAME    ST    R15,STACK15         Save Work Register\n         L     R15,STACKNX@        A(Next Save Area)\n         C     R15,STACKEND        Check If Stack Has Overflowed\n         JL    #&SYSNDX            B. If Not\n         ABEND 1                   User Abend\n#&SYSNDX STM   R0,R14,0(R15)       Save Registers 0 Through 14\n         MVC   15*4(4,R15),STACK15 Save R15 As Well\n         AHI   R15,16*4            A(Next Save Area)\n         ST    R15,STACKNX@        Save Next Save Area Address\n         BALR  R11,0               Initialize Subroutine Base\n         USING *,R11\n         MEND  ,\n\n         MACRO ,\n&NAME    #RESTORE &R15=\n&NAME    DS    0H\n         AIF   ('&R15' EQ '').REST030\n         AIF   ('&R15'(1,1) EQ '(').REST010\n         LA    R15,&R15            Set Return Code\n         AGO   .REST020\n.REST010 ANOP  ,\n         AIF   ('&R15' EQ '(R15)').REST020\n         LR    R15,&R15(1)         Set Return Code\n.REST020 ANOP  ,\n         ST    R15,WRKR15          Save Return Code Value\n.REST030 ANOP  ,\n         L     R15,STACKNX@        A(Next Save Area)\n         SHI   R15,16*4            A(Current Save Area)\n         ST    R15,STACKNX@        Restore Next Save Area Address\n         LM    R0,R15,0(R15)       Restore All Registers\n         J     #&SYSNDX\n         #EXEC ,                   Executed Statements\n         LTORG ,                   Literal Pool\n#&SYSNDX DS    0H\n         AIF   ('&R15' EQ '').REST040\n         L     R15,WRKR15          Restore Return Code Value\n.REST040 ANOP  ,\n         MEND  ,\n\n         MACRO ,\n&NAME    #CALL &RTN\n&NAME    L     R15,=A(&RTN)        A(Processing Routine)\n         BALR  R14,R15             Call Subroutine\n         MEND  ,\n\n\nLWATMGR  #START ,                  Start Mainline                      *\n               BASE=(R12,R11),     Define Base Register(s)             *\n               COPY=YES,                                               *\n               WKDSECT=WRKLWATM,   Define Work Area Name               *\n               LOC=BELOW,          Acquire Work Area Below The Line    *\n               REG1=R8,            Command Parameter List              *\n               AMODE=31,RMODE=ANY, Execute In AMODE 31, RMODE Any      *\n               USING=(PSA,0,CPPL,R8),                                  *\n               LEVEL=#V01R002      Version Identifier          #DD12062\n\n*-------\n*        Initialize Save Area Stack Pointers\n*-------\n         LA    R1,STACK            A(Start Of Save Area Stack)\n         ST    R1,STACKNX@         Save \"Next\" Address\n         AH    R1,=AL2(STACKLEN)   A(End Of Save Area Stack)\n         ST    R1,STACKEND         Save \"End\" Address\n\n         MVI   BLANKS,C' '         Initialize BLANKS Area\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate and Validate The LWA                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R14,PSAAOLD         A(ASCB)\n         USING ASCB,R14\n         L     R14,ASCBASXB        A(ASXB)\n         USING ASXB,R14\n         L     R14,ASXBLWA         A(LWA)\n         ST    R14,WRKLWA@         Save LWA Address\n         USING LWA,R14\n\n         C     R14,LWAPPTR         Check If LWA Points To Itself\n         BNE   LWA00400            B. If Not\n         CLC   LWALWA,=C'   LWA  ' Check LWA Identifier\n         BNE   LWA00400            B. If Valid\n\n         MVC   WRKPRMLB,LWAPRMLB   Save Original LWA Flag Value\n\n*-------\n*        Save The Authorization Table Pointer Addresses\n*-------\n         LA    R0,LWATAP           A(IKJEFTAP Pointer)\n         ST    R0,WRKTAPP@\n         LA    R0,LWATAPLN         A(IKJEFTAP Length)\n         ST    R0,WRKTAPL@\n         MVC   WRKTAPL,LWATAPLN    Save IKJEFTAP Length\n         TM    LWAPRMLB,LWATAPST   Did IKJEFTAP Come From //STEPLIB\n         BZ    LWA00100            B. If Not\n         OI    WRKTAPF,WRK$STEP\nLWA00100 DS    0H\n         LA    R0,LWATE2           A(IKJEFTE2 Pointer)\n         ST    R0,WRKTE2P@\n         LA    R0,LWATE2LN         A(IKJEFTE2 Length)\n         ST    R0,WRKTE2L@\n         MVC   WRKTE2L,LWATE2LN    Save IKJEFTE2 Length\n         TM    LWAPRMLB,LWATE2ST   Did IKJEFTE2 Come From //STEPLIB\n         BZ    LWA00200            B. If Not\n         OI    WRKTE2F,WRK$STEP\nLWA00200 DS    0H\n         LA    R0,LWATE8           A(IKJEFTE8 Pointer)\n         ST    R0,WRKTE8P@\n         LA    R0,LWATE8LN         A(IKJEFTE8 Length)\n         ST    R0,WRKTE8L@\n         MVC   WRKTE8L,LWATE8LN    Save IKJEFTE8 Length\n         TM    LWAPRMLB,LWATE8ST   Did IKJEFTE8 Come From //STEPLIB\n         BZ    LWA00300            B. If Not\n         OI    WRKTE8F,WRK$STEP\nLWA00300 DS    0H\n         LA    R0,LWATNS           A(IKJEFTNS Pointer)\n         ST    R0,WRKTNSP@\n         LA    R0,LWATNSLN         A(IKJEFTNS Length)\n         ST    R0,WRKTNSL@\n         MVC   WRKTNSL,LWATNSLN    Save IKJEFTNS Length\n         TM    LWAPRMLB,LWATNSST   Did IKJEFTNS Come From //STEPLIB\n         BZ    LWA00500            B. If Not\n         OI    WRKTNSF,WRK$STEP\n         B     LWA00500\n         DROP  R14\n\nLWA00400 DS    0H\n         MVC   WRKDATA(#MSG001L),#MSG001\n         TPUT  WRKDATA,#MSG001L    Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Check Current Authorization Level                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA00500 DS    0H\n         TESTAUTH STATE=YES,       Check If Already In                 *\n               RBLEVEL=1           Supervisor State\n         LTR   R15,R15\n         BNZ   LWA00600            B. If Not (Modeset Required)\n\n         OI    WRKFLAG,$SUPER      Remember \"Supervisor State\"\n\nLWA00600 DS    0H\n         TESTAUTH FCTN=1           Check If APF Authorized\n         LTR   R15,R15\n         BNZ   LWA00700            B. If Not\n\n         OI    WRKFLAG,$APF        Remember \"APF Authorized\"\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Parse The Input Command Buffer                               *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA00700 DS    0H\n         L     R0,CPPLUPT          A(UPT)\n         ST    R0,WRKUPT@\n         L     R0,CPPLECT          A(ECT)\n         ST    R0,WRKECT@\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         MVC   PPLUPT,WRKUPT@      Set UPT  Address\n         MVC   PPLECT,WRKECT@      Set ECT  Address\n         LA    R0,WRKECB\n         ST    R0,PPLECB           Save ECB Address\n         XC    WRKECB,WRKECB\n         L     R0,=A(PCL)          A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,CPPLCBUF    Copy Command Buffer Address\n         LA    R0,WRKPDL1\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         L     R10,WRKPDL1         A(PDL)\n         USING MAINPCL,R10\n         LA    R1,PARMLIB\n\n         L     R2,=A(X'FFFF')      L(IEFPRMLB Message Buffer)\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKMSGB@         Save IEFPRMLB Message Buffer Address\n         ST    R2,WRKMSGBL         Save IEFPRMLB Message Buffer Length\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Add A New Command/Program To The Specified Table             *\n*        - A new entry will be added to the end of a table.           *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR ADD                                                  *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }          *\n*                NAME(command/program)                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         CLI   FUNCKW+1,$ADD       Check For 'ADD' Keyword\n         BNE   LWA01500            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         MVC   WRKINS1(4),=AL2(4+4,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NAME    '\n         LA    R1,NAME             A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNAMEL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNAME,WRKDATA     Save \"NAME\" Value\n\n         OI    WRKFLAG,$MSG_F      Issue \"Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BNZ   LWAEXIT             B. If Entry Already Exists\n\n         #CALL COPYTAB             Ensure Table Is In Our Address Space\n         BZ    LWAEXIT             B. If Table Does Not Exist\n\n*-------\n*        Increase The Size Of The Current Table\n*-------\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n\n         LH    R3,WRKTABL          Load Calculated Table Length\n         AH    R3,WRKTABEL         Add Length Of One Entry\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         STH   R3,WRKAUTHL         Save Authorized Table Length\n\n         L     R4,WRKTAB@          A(Current Table)\n         #MVCL (R1),(R4),LEN=(R3)  Copy Table To Authorized Storage\n\n         L     R15,WRKAUTH@        A(Authorized Storage Table)\n         AH    R15,WRKAUTHL        A(End Of Authorized Storage Table)\n         SH    R15,WRKTABEL        A(Last Entry In Authorized Table)\n\n         LH    R14,WRKTABEL        L(Table Entry)\n         #EXEC -R14,MVC,0(*-*,R15),BLANKS\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   LWA00800            B. If Not\n         MVC   0(2,R15),=X'FFFF'   Change Last Entry To A Terminator\n\nLWA00800 DS    0H\n         L     R1,WRKTAB@@         A(Table Address In LWA)\n         MVC   WRKTAB@,0(R1)       Save Old Table Address\n         MVC   0(4,R1),WRKAUTH@    Point To New Table\n         L     R1,WRKTABL@         A(Table Length In LWA)\n         MVC   WRKTABL,0(R1)       Save Old Table Length\n         MVC   0(2,R1),WRKAUTHL    Set To New Table Length\n\n         ICM   R1,15,WRKTAB@       A(Previous Table)\n         BZ    LWA00900            B. If No Previous Table\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        A(Previous Table Length)\n         BZ    LWA00900            B. If No Previous Table\n         FREEMAIN RU,A=(1),LV=(0),SP=252\n\n*-------\n*        Scan Current Table For The 1st Empty Slot & Insert New Entry\n*-------\nLWA00900 DS    0H\n         MVC   WRKTAB@,WRKAUTH@    Set New Table Address\n         MVC   WRKTABL,WRKAUTHL    Set New Table Length\n\n         L     R3,WRKTAB@          A(Start Of New Table)\n         LR    R15,R3\n         AH    R15,WRKTABL         A(End Of Table)\n         ST    R15,WRKTABE@\n         AHI   R3,16               A(1st Entry)\n\nLWA01000 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BNE   LWA01100            B. If Not\n         CLC   0(8,R3),BLANKS      Check For Empty Slot\n         BNE   LWA01300            B. If Not\n         MVC   0(8,R3),WRKNAME     Insert New Name\n         B     LWA01400\n\nLWA01100 DS    0H\n         CLC   0(2,R3),=X'0000'    Check For Null Slot\n         BE    LWA01200            B. If Yes\n         CLC   0(2,R3),=X'FFFF'    Check For Terminator Slot\n         BNE   LWA01300            B. If Not\nLWA01200 DS    0H\n         MVC   0(2,R3),WRKNAMEL    Insert New Name Length\n         MVC   2(8,R3),WRKNAME     Insert New Name\n         B     LWA01400\n\nLWA01300 DS    0H\n         AH    R3,WRKTABEL         A(Next Entry In Table)\n         C     R3,WRKTABE@         Check For End Of Table\n         BL    LWA01000            B. If Not\n\n         #CALL DEAUTH              Return To Original State & Key\n         B     LWAEXIT             This Branch Should Never Be Taken\n\nLWA01400 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0021)\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS1+4(8),WRKNAME\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0022)\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         MVC   WRKINS2+4(8),WRKCMDNM\n\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG002)      A(Added Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Delete An Entry From The Specified Table                     *\n*        - Remove an existing entry from within a table.              *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR DELETE                                               *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }          *\n*                NAME(command/program)                                *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA01500 DS    0H\n         CLI   FUNCKW+1,$DELETE    Check For 'DELETE' Keyword\n         BNE   LWA01700            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         MVC   WRKINS1(4),=AL2(4+4,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NAME    '\n         LA    R1,NAME             A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNAMEL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNAME,WRKDATA     Save \"NAME\" Value\n\n         OI    WRKFLAG,$MSG_NF     Issue \"Not_Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BZ    LWAEXIT             B. If Entry Not Found\n\n         #CALL COPYTAB             Ensure Table Is In Our Address Space\n         BZ    LWAEXIT             B. If Table Does Not Exist\n\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n\n         L     R5,WRKTAB@\n         A     R5,WRKNAMEO         A(Current Table Entry)\n         L     R4,WRKTAB@\n         AH    R4,WRKTABL          A(End Of Current Table)\n         ST    R4,WRKTABE@\n         LR    R3,R5\n         AH    R3,WRKTABEL         A(Next Entry In Table)\n         SR    R4,R3               Calculate Remaining Length\n         #MVCL (R5),(R3),LEN=(R4)  Shift Out Entry To Be Deleted\n\n         L     R4,WRKTABE@         A(End Of Table)\n         SH    R4,WRKTABEL         A(Last Entry In Table)\n         LH    R14,WRKTABEL\n         #EXEC -R14,MVC,0(*-*,R4),BLANKS\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   LWA01600            B. If Not\n         MVC   0(2,R4),=X'FFFF'    Change Entry To Terminator\n\nLWA01600 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0031)\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS1+4(8),WRKNAME\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0032)\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         MVC   WRKINS2+4(8),WRKCMDNM\n\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG003)      A(Removed Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display Information About The Specified Table(s)             *\n*        - Report on the table location, attributes and contents.     *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR DISPLAY                                              *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }    *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA01700 DS    0H\n         CLI   FUNCKW+1,$DISPLAY   Check For 'DISPLAY' Keyword\n         BNE   LWA02200            B. If Not\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    LWA01800            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    LWA01800            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    LWA01800            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    LWA01800            B. If Yes\n         MVI   APKW+1,$AUTHTSF\n         MVI   E2KW+1,$AUTHCMD\n         MVI   E8KW+1,$AUTHPGM     Default to \"LWATMGR DISPLAY ALL\"\n         MVI   NSKW+1,$NOTBKGND\n\nLWA01800 DS    0H\n         CLI   APKW+1,$AUTHTSF     Check For 'IKJEFTAP' Keyword\n         BNE   LWA01900            B. If Not\n         L     R5,WRKTAPP@\n         ICM   R5,15,0(R5)         A(IKJEFTAP Table)\n         BZ    LWA01900            B. If Not Available\n         MVC   WRKTABNM,=C'AUTHTSF '\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTABL,WRKTAPL     Save Length Found in LWA\n         MVC   WRKTABF,WRKTAPF     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n\nLWA01900 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For 'IKJEFTE2' Keyword\n         BNE   LWA02000            B. If Not\n         L     R5,WRKTE2P@\n         ICM   R5,15,0(R5)         A(IKJEFTE2 Table)\n         BZ    LWA01900            B. If Not Available\n         MVC   WRKTABNM,=C'AUTHCMD '\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTABL,WRKTE2L     Save Length Found in LWA\n         MVC   WRKTABF,WRKTE2F     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n\nLWA02000 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For 'IKJEFTE8' Keyword\n         BNE   LWA02100            B. If Not\n         L     R5,WRKTE8P@\n         ICM   R5,15,0(R5)         A(IKJEFTE2 Table)\n         BZ    LWA02100            B. If Not Available\n         MVC   WRKTABNM,=C'AUTHPGM '\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTABL,WRKTE8L     Save Length Found in LWA\n         MVC   WRKTABF,WRKTE8F     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n\nLWA02100 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For 'IKJEFTNS' Keyword\n         BNE   LWAEXIT             B. If Not\n         L     R5,WRKTNSP@\n         ICM   R5,15,0(R5)         A(IKJEFTNS Table)\n         BZ    LWAEXIT             B. If Not Available\n         MVC   WRKTABNM,=C'NOTBKGND'\n         ST    R5,WRKTAB@          Save Table Address\n         IVSK  R15,R5              Get Storage Key\n         STC   R15,WRKTABPK        Save Table Key\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVC   WRKTABL,WRKTNSL     Save Length Found in LWA\n         MVC   WRKTABF,WRKTNSF     Save Table Flag\n         #CALL DISPTAB             Display Table Information\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Reload The Tables From A Load Module                         *\n*        - Load an assembled version of the IKJTABLS alias entry.     *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR RELOAD                                               *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }    *\n*                LOADLIB(dataset)                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA02200 DS    0H\n         CLI   FUNCKW+1,$RELOAD    Check For 'RELOAD' Keyword\n         BNE   LWA03200            B. If Not\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    LWA02300            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    LWA02300            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    LWA02300            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    LWA02300            B. If Yes\n         MVI   APKW+1,$AUTHTSF\n         MVI   E2KW+1,$AUTHCMD\n         MVI   E8KW+1,$AUTHPGM     Default to \"LWATMGR RELOAD ALL\"\n         MVI   NSKW+1,$NOTBKGND\n\n*-------\n*        Allocate & Open The Specified \"LOADLIB\" Library\n*-------\nLWA02300 DS    0H\n         ICM   R1,15,LOADLIB       A(Fully Qualified Data Set Name)\n         BZ    LWA02800            B. If Not Available\n         LH    R2,LOADLIB+4        L(Fully Qualified Data Set Name)\n\n         LA    R0,WRKDDN           A(DDName Buffer)\n         ST    R0,WRKDDPDE\n         LHI   R0,8                L(DDName Buffer)\n         STH   R0,WRKDDPDE+4\n         MVC   WRKDDN,BLANKS       Initialize DDName\n\n         LA    R0,WRKDSN           A(Quoted Data Set Name Area)\n         ST    R0,WRKDSPDE\n         MVC   WRKDSN,BLANKS\n         MVI   WRKDSN,C''''        Insert Leading Quote\n         #EXEC -R2,MVC,WRKDSN+1(*-*),0(R1)\n         LA    R1,WRKDSN+1+1(R2)   A(End Of Data Set Name)\n         MVI   0(R1),C''''         Insert Ending Quote\n         AHI   R1,1                A(End Of Data Set Name)\n         LA    R2,WRKDSN           A(Start Of Data Set Name)\n         SR    R1,R2               Calculate Length Of Data Set Name\n         STH   R1,WRKDSPDE+4       Save Quoted Data Set Name Length\n\n         ICM   R1,15,LOADLIB+8     A(Member Name)\n         BNZ   LWA02900            B. If Member Specified (Not Allowed)\n\n         ALLOC DSN=WRKDSPDE,DISP=SHR,                                  *\n               DDNTO=WRKDDN,                                           *\n               ERROR=LWA03000\n\n*-------\n*        Acquire An Initial Buffer To Contain The Loaded Module\n*-------\n         LHI   R2,4*1024           L(Directed Load Buffer)\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKLOAD@         Save Directed Load Buffer Address\n         ST    R2,WRKLOADL         Save Directed Load Buffer Length\n\n*-------\n*        Load The \"AUTHTSF\" Module & Anchor It Off Of The LWA\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BNE   LWA02400            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVI   WRKVFLGS,LWATAPLD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTAPP@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTAPL@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Load The \"AUTHCMD\" Module & Anchor It Off Of The LWA\n*-------\nLWA02400 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BNE   LWA02500            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVI   WRKVFLGS,LWATE2LD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTE2P@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTE2L@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Load The \"AUTHPGM\" Module & Anchor It Off Of The LWA\n*-------\nLWA02500 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BNE   LWA02600            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVI   WRKVFLGS,LWATE8LD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTE8P@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTE8L@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Load The \"NOTBKGND\" Module & Anchor It Off Of The LWA\n*-------\nLWA02600 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BNE   LWA02700            B. If Not\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVI   WRKVFLGS,LWATNSLD   Set \"Loaded\" Flag\n\n         MVC   WRKTAB@@,WRKTNSP@   Set Table Pointer Address\n         L     R15,WRKTAB@@\n         MVC   WRKTAB@,0(R15)      Set Table Address\n         MVC   WRKTABL@,WRKTNSL@   Set Table Length Address\n         L     R15,WRKTABL@\n         MVC   WRKTABL,0(R15)      Set Table Length\n\n         #CALL LOADIT              Load The Table\n\n*-------\n*        Free The \"LOADLIB\" Library\n*-------\nLWA02700 DS    0H\n         FREE  DDN=WRKDDPDE        Free Any Allocated Data Set\n         B     LWAEXIT\n\n*-------\n*        Issue Error Messages\n*-------\nLWA02800 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG015)      A(Required Keyword Missing)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\nLWA02900 DS    0H\n         LHI   R0,1                Message Contains 1 Segments\n         L     R1,=A(#MSG016)      A(Member Not Allowed)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\nLWA03000 DS    0H\n         S99FAIL ,                 Issue Dynamic Allocation Error\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\nLWA03100 DS    0H\n         LHI   R0,1                Message Contains 1 Segments\n         L     R1,=A(#MSG017)      A(OPEN Failed)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace An Entry In The Specified Table                      *\n*        - Change an entry in one of the authorization tables.        *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR REPLACE                                              *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }          *\n*                NAME(command/program)                                *\n*                NEWNAME(command/program)                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA03200 DS    0H\n         CLI   FUNCKW+1,$REPLACE   Check For 'REPLACE' Keyword\n         BNE   LWA03500            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         MVC   WRKINS1(4),=AL2(4+4,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NAME    '\n         LA    R1,NAME             A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNAMEL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNAME,WRKDATA     Save \"NAME\" Value\n\n         OI    WRKFLAG,$MSG_NF     Issue \"Not Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BZ    LWAEXIT             B. If Entry Not Found\n\n         MVC   WRKINS1(4),=AL2(4+7,#MSG0061)\n         MVC   WRKINS1+4(8),=C'NEWNAME '\n         LA    R1,NEWNAME          A(Keyword)\n         #CALL SAVEKW              Check For \"NAME\" Keyword\n         BZ    LWAEXIT             B. If Not Specified\n         MVC   WRKNEWNL,WRKDATAL   Save \"NAME\" Value Length\n         MVC   WRKNEWN,WRKDATA     Save \"NAME\" Value\n\n         MVC   WRKTMPNL,WRKNAMEL   Save Name Length\n         MVC   WRKTMPN,WRKNAME     Save Name\n\n         MVI   APKW+1,0            Reset\n         MVI   E2KW+1,0             Table Keywords\n         MVI   E8KW+1,0              To Only\n         MVI   NSKW+1,0               The One\n         L     R15,WRKKW@              Where \"NAME\" Entry\n         MVI   1(R15),1                 Was Found\n\n         MVC   WRKNAMEL,WRKNEWNL   Change To \"NEWNAME\" Value Length\n         MVC   WRKNAME,WRKNEWN     Change To \"NEWNAME\" Value\n         OI    WRKFLAG,$MSG_F      Issue \"Found\" Message\n         #CALL FINDNAME            Find The Table Entry's Address\n         BNZ   LWAEXIT             B. If Entry Not Found\n\n         MVC   WRKNAMEL,WRKTMPNL   Restore Name Length\n         MVC   WRKNAME,WRKTMPN     Restore Name\n\n         #CALL COPYTAB             Ensure Table Is In Our Address Space\n         BZ    LWAEXIT             B. If Table Does Not Exist\n\n         L     R5,WRKTAB@          A(Current Table)\n         A     R5,WRKNAMEO         A(Current Table Entry)\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BNE   LWA03300            B. If Not\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n         MVC   0(8,R5),WRKNEWN     Overlay With New Entry Name\n         #CALL DEAUTH              Return To Original State & Key\n         B     LWA03400\n\nLWA03300 DS    0H\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   LWAEXIT             B. If Not Authorized\n         MVC   0(2,R5),WRKNEWNL    Overlay With New Entry Name Length\n         MVC   2(8,R5),WRKNEWN     Overlay With New Entry Name\n         #CALL DEAUTH              Return To Original State & Key\n\nLWA03400 DS    0H\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0041)\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS1+4(8),WRKNAME\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0042)\n         LH    R0,WRKNEWNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         MVC   WRKINS2+4(8),WRKNEWN\n         MVC   WRKINS3(4),=AL2(4+*-*,#MSG0043)\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS3\n         MVC   WRKINS3+4(8),WRKCMDNM\n\n         LHI   R0,4                Message Contains 4 Segments\n         L     R1,=A(#MSG004)      A(Replacement Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace The Tables With IKJTSOxx Input Data                  *\n*        - Validate an IKJTSOxx member and load any/all tables.       *\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR UPDATE                                               *\n*              { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }    *\n*                PARMLIB(dataset(member))                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA03500 DS    0H\n         CLI   FUNCKW+1,$UPDATE    Check For 'UPDATE' Keyword\n         BNE   LWA03900            B. If Not\n\n         #CALL CHECKTAB            Check If A Table Was Specified\n         BNZ   LWAEXIT             B. If Not\n\n         #CALL READPARM            Read The Specified Parmlib Member\n\n*-------\n*        Update 'IKJEFTAP' Table If Requested\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For 'AUTHTSF' Keyword\n         BNE   LWA03600            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWA03600            B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTAPP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTAPL@   Set Table Length Address\n         MVC   WRKTABL,WRKTAPL     Set Length Found in LWA\n         MVC   WRKTABF,WRKTAPF     Set Table Flag\n         OI    WRKPRMLB,LWATAPST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATAPLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Update 'IKJEFTE2' Table If Requested\n*-------\nLWA03600 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For 'AUTHCMD' Keyword\n         BNE   LWA03700            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWA03700            B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTE2P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE2L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE2L     Set Length Found in LWA\n         MVC   WRKTABF,WRKTE2F     Set Table Flag\n         OI    WRKPRMLB,LWATE2ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE2LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Update 'IKJEFTE8' Table If Requested\n*-------\nLWA03700 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For 'AUTHPGM' Keyword\n         BNE   LWA03800            B. If Not\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWA03800            B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTE8P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE8L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE8L     Set Length Found in LWA\n         MVC   WRKTABF,WRKTE8F     Set Table Flag\n         OI    WRKPRMLB,LWATE8ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE8LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Update 'IKJEFTNS' Table If Requested\n*-------\nLWA03800 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For 'NOTBKGND' Keyword\n         BNE   LWAEXIT             B. If Not\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         #CALL BUILDCMD            Build CBUF From PARMLIB Section\n         BNZ   LWAEXIT             B. If Section Not Found\n\n         LA    R1,WRKPPL           A(Parse Parameter List)\n         USING PPL,R1\n         XC    WRKECB,WRKECB\n         L     R0,=A(PARMPCL)      A(Parse Command List)\n         ST    R0,PPLPCL           Save PCL Address\n         MVC   PPLCBUF,WRKCBUF@    Copy Command Buffer Address\n         LA    R0,WRKPDL2\n         ST    R0,PPLANS           Save PDL Address\n         DROP  R1\n\n         CALLTSSR EP=IKJPARS,      Invoke Parse Routine                *\n               MF=(E,WRKPPL)\n         LTR   R15,R15             Check Parse Return Code\n         BNZ   LWAEXIT             B. If Command Syntax Error\n\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         #CALL BUILDTAB            Build Replacement Table\n         BNZ   LWAEXIT             B. If Table Construction Failed\n\n         MVC   WRKTAB@@,WRKTNSP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTNSL@   Set Table Length Address\n         MVC   WRKTABL,WRKTNSL     Set Length Found in LWA\n         MVC   WRKTABF,WRKTNSF     Set Table Flag\n         OI    WRKPRMLB,LWATNSST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATNSLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         IKJRLSA WRKPDL2           Release The Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0141)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG014)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace The Tables With 8 Character List Data                *\n*        - Rebuild tables With 8 Byte Name List structure.            *\n*        - Note: The List contains \"--name--\" to identify which table.*\n*                                                                     *\n*     Syntax:                                                         *\n*        LWATMGR BUILD                                                *\n*                LIST(dataset\u00dd(member)\u00a8)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWA03900 DS    0H\n         CLI   FUNCKW+1,$BUILD     Check For 'BUILD' Keyword\n         BNE   LWAEXIT             B. If Not\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    LWA04000            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    LWA04000            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    LWA04000            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    LWA04000            B. If Yes\n         MVI   APKW+1,$AUTHTSF\n         MVI   E2KW+1,$AUTHCMD\n         MVI   E8KW+1,$AUTHPGM     Default to \"LWATMGR BUILD ALL\"\n         MVI   NSKW+1,$NOTBKGND\n\nLWA04000 DS    0H\n         ICM   R1,15,REC8          A(Fully Qualified Data Set Name)\n         BZ    LWA02800            B. If Not Available\n         LH    R2,REC8+4           L(Fully Qualified Data Set Name)\n\n*-------\n*        Allocate The Input Library\n*        - As we only use the 1st 8 bytes, the LRECL of the input file\n*          can be anything as low as 8.\n*          Anything after the 1st 8 bytes is disreguarded.\n*-------\n         LA    R0,WRKDDN           A(DDName Buffer)\n         ST    R0,WRKDDPDE\n         LHI   R0,8                L(DDName Buffer)\n         STH   R0,WRKDDPDE+4\n         MVC   WRKDDN,BLANKS       Initialize DDName\n\n         LA    R0,WRKDSN           A(Quoted Data Set Name Area)\n         ST    R0,WRKDSPDE\n         MVC   WRKDSN,BLANKS\n         MVI   WRKDSN,C''''        Insert Leading Quote\n         #EXEC -R2,MVC,WRKDSN+1(*-*),0(R1)\n         LA    R1,WRKDSN+1+1(R2)   A(End Of Data Set Name)\n         MVI   0(R1),C''''         Insert Ending Quote\n         AHI   R1,1                A(End Of Data Set Name)\n         LA    R2,WRKDSN           A(Start Of Data Set Name)\n         SR    R1,R2               Calculate Length Of Data Set Name\n         STH   R1,WRKDSPDE+4       Save Quoted Data Set Name Length\n\n         XC    WRKMNPDE(6),WRKMNPDE\n         MVC   WRKMEMNM,BLANKS\n         ICM   R1,15,REC8+8        A(Member Name)\n         BZ    LWA04100            B. If Not Available\n         LA    R0,WRKMEMNM         A(Member Name)\n         ST    R0,WRKMNPDE\n         LHI   R0,8                L(Member Name)\n         STH   R0,WRKMNPDE+4\n         LH    R2,REC8+12          L(Member Name)\n         #EXEC -R2,MVC,WRKMEMNM(*-*),0(R1)\n\nLWA04100 DS    0H\n         ALLOC DSN=WRKDSPDE,DISP=SHR,                                  *\n               MEMBER=WRKMNPDE,                                        *\n               DDNTO=WRKDDN,                                           *\n               ERROR=LWA03000\n\n         L     R14,=A(OPENSTUB)    A(24-Bit Exit Routine)\n         MVC   WDCBEXIT,0(R14)     Initialize Exit Stub\n         L     R14,=A(DCBEXIT)     A(31-Bit Exit Routine)\n         BSM   R14,0               Set Current AMode\n         STCM  R14,15,REAL@-OPENSTUB+WDCBEXIT\n         LA    R0,WDCBEXIT         A(24-Bit Exit Stub)\n         ST    R0,DCBEXIT@         Store In Exlst Plist\n         MVI   DCBEXIT@,X'85'      Open Exit Is Last In List\n\n         L     R15,=A(MODCBF)\n         MVC   WRKDCB,0(R15)       Copy DCB To Work Area\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN\n         L     R15,=A(MODCBEF)\n         MVC   WRKDCBE,0(R15)      Copy DCBE To Work Area\n         LA    R15,WRKDCBE         A(DCBE)\n         ST    R15,DCBDCBE-IHADCB+WRKDCB\n\n         L     R15,=A(MODOPEN)\n         MVC   WRKOPEN,0(R15)\n         OPEN  (WRKDCB),           Open The \"LIST\" Data Set            *\n               MF=(E,WRKOPEN)\n         TM    DCBOFLGS-IHADCB+WRKDCB,DCBOFOPN\n         BZ    LWA03100            B. If OPEN Failed\n\n*-------\n*        Read The \"List\" Into Storage.\n*-------\n         L     R4,WRKMSGB@         A(Start Of Data Buffer)\n         LR    R1,R4\n         A     R1,WRKMSGBL         A(End Of Data Buffer)\n         ST    R1,WRKMSGBE         Save End Address\nLWA04200 DS    0H\n         GET   WRKDCB              Get Next Record From LIST Data Set\n\n         C     R4,WRKMSGBE         Check For End Of Buffer\n         BNE   LWA04300            B. If Not\n\n         LR    R5,R1               Save Current Record Address\n         LR    R6,R4               A(Logical End Of Current Buffer)\n\n         L     R4,WRKMSGB@         A(Start Of Data Buffer)\n         L     R3,WRKMSGBL         L(Current Data Buffer)\n         SR    R6,R4               Calculate Used Data Buffer Length\n\n         L     R2,WRKMSGBL         L(Current Data Buffer)\n         SLL   R2,1                Double The Length\n         GETMAIN RU,LV=(R2),LOC=ANY\n         ST    R1,WRKMSGB@         Save New Buffer Address\n         ST    R2,WRKMSGBL         Save New Buffer Length\n\n         #MVCL (R1),(R4),LEN=(R6)  Copy The Previous Used Portion\n\n         FREEMAIN RU,A=(R4),LV=(R3)  Free The Old Data Buffer\n\n         L     R4,WRKMSGB@\n         LR    R1,R4\n         A     R1,WRKMSGBL         A(End Of Data Buffer)\n         ST    R1,WRKMSGBE         Save End Address\n         AR    R4,R6               A(End Of Used Portion Of Buffer)\n\n         LR    R1,R5               Restore Current Record Address\n\nLWA04300 DS    0H\n         MVC   0(8,R4),0(R1)       Copy The Current Record's Entry\n         LA    R4,8(,R4)           A(Next Slot In Data Buffer)\n         B     LWA04200            Read Until End Of File\n\nLWA04400 DS    0H\n         ST    R4,WRKMSGBE         Save Logical End Of Buffer Address\n\n         L     R15,=A(MODCLOSE)\n         MVC   WRKCLOSE,0(R15)\n         CLOSE (WRKDCB),           Close The \"LIST\" Data Set           *\n               MF=(E,WRKCLOSE)\n\n         FREE  DDN=WRKDDPDE        Free Any Allocated Data Set\n\n*-------\n*        Process 'IKJEFTAP' List If Requested\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BNE   LWA04500            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKNAME,=C'---AP---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWA04500            B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTAPP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTAPL@   Set Table Length Address\n         MVC   WRKTABL,WRKTAPL     Set Length Found in LWA\n         OI    WRKPRMLB,LWATAPST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATAPLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Process 'IKJEFE2P' List If Requested\n*-------\nLWA04500 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BNE   LWA04600            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKNAME,=C'---E2---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWA04600            B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTE2P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE2L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE2L     Set Length Found in LWA\n         OI    WRKPRMLB,LWATE2ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE2LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Process 'IKJEFE8P' List If Requested\n*-------\nLWA04600 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BNE   LWA04700            B. If Not\n\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKNAME,=C'---E8---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWA04700            B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTE8P@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTE8L@   Set Table Length Address\n         MVC   WRKTABL,WRKTE8L     Set Length Found in LWA\n         OI    WRKPRMLB,LWATE8ST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATE8LD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n\n*-------\n*        Process 'IKJEFNSP' List If Requested\n*-------\nLWA04700 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BNE   LWAEXIT             B. If Not\n\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVC   WRKNAME,=C'---NS---'\n         #CALL LISTTAB             Create Table From LIST\n         BNZ   LWAEXIT             B. If LIST Not Created\n\n         MVC   WRKTAB@@,WRKTNSP@   Set Table Pointer Address\n         MVC   WRKTABL@,WRKTNSL@   Set Table Length Address\n         MVC   WRKTABL,WRKTNSL     Set Length Found in LWA\n         OI    WRKPRMLB,LWATNSST   Set \"Came From //STEPLIB\" Flag\n         MVI   WRKVFLGS,LWATNSLD   Set \"Loaded\" Flag\n         #CALL REPTABLE            Replace The Table With A New One\n         BNZ   LWAEXIT             B. If Replace Failed\n\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0211)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG021)      A(Section Updated From Parmlib)\n         LA    R2,WRKINS1          A(Insert #1)\n         #CALL PUTLINE             Write Message\n         B     LWAEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nLWAEXIT  DS    0H\n         #CALL CLEANUP             Free All Acquired Storage\n\n         #STOP ,                   Terminate\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LTORG ,                   Literal Pool\n         #EXEC ,                   Executed Statements\n\nMODCBU   DCB   DDNAME=*,DSORG=PO,RECFM=U,MACRF=R,BUFNO=1,              *\n               DCBE=*-*\nMODCBUL  EQU   *-MODCBU            DCB Parameter List Length\nMODCBEU  DCBE  EODAD=LOAD0900,SYNAD=LOADSYN,EADSCB=OK          #DD12062\nMODCBEUL EQU   *-MODCBEU           DCBE Parameter List Length\n\nMODCBF   DCB   DDNAME=*,DSORG=PS,RECFM=FB,MACRF=GL,                    *\n               DCBE=*-*\nMODCBFL  EQU   *-MODCBF            DCB Parameter List Length\nMODCBEF  DCBE  EODAD=LWA04400,EADSCB=OK                        #DD12062\nMODCBEFL EQU   *-MODCBEF           DCBE Parameter List Length\n\nMODOPEN  OPEN  *-*,MF=L\nMODOPENL EQU   *-MODOPEN           OPEN Parameter List Length\n\nMODCLOSE CLOSE *-*,MF=L\nMODCLOSEL EQU  *-MODCLOSE          CLOSE Parameter List Length\n\nMODLOAD  LOAD  SF=L\nMODLOADL EQU   *-MODLOAD           LOAD Parameter List Length\n\n#MSG001  DC    C'LWA001I LWA control block is not valid'\n#MSG001L EQU   *-#MSG001\n\n#MSG002  #MSG  'LWA002I '''' added to '''' table'\n#MSG0021 EQU   9,8                 Insert Offset & Length\n#MSG0022 EQU   21,8                Insert Offset & Length\n\n#MSG003  #MSG  'LWA003I '''' removed from '''' table'\n#MSG0031 EQU   9,8                 Insert Offset & Length\n#MSG0032 EQU   25,8                Insert Offset & Length\n\n#MSG004  #MSG  'LWA004I '''' replaced with '''' in '''' table'\n#MSG0041 EQU   9,8                 Insert Offset & Length\n#MSG0042 EQU   26,8                Insert Offset & Length\n#MSG0043 EQU   32,8                Insert Offset & Length\n\n#MSG005  #MSG  'LWA005I Command Is Not Authorized'\n\n#MSG006  #MSG  'LWA006I '''' Keyword Is Missing'\n#MSG0061 EQU   9,8                 Insert Offset & Length\n\n#MSG007  #MSG  'LWA007I Required Table Keyword Not Specified'\n\n#MSG008  #MSG  'LWA008I  At  Key   '\n#MSG0081 EQU   8,26                Insert Offset & Length\n#MSG0082 EQU   12,8                Insert Offset & Length\n#MSG0083 EQU   17,2                Insert Offset & Length\n#MSG0084 EQU   18,17               Insert Offset & Length\n#MSG0085 EQU   19,7                Insert Offset & Length\n\n#MSG009  #MSG  'LWA009I      '\n#MSG0091 EQU   8,8                 Insert Offset & Length\n#MSG0092 EQU   9,8                 Insert Offset & Length\n#MSG0093 EQU   10,8                Insert Offset & Length\n#MSG0094 EQU   11,8                Insert Offset & Length\n#MSG0095 EQU   12,8                Insert Offset & Length\n#MSG0096 EQU   13,8                Insert Offset & Length\n\n#MSG010  #MSG  'LWA010I '''' already exists in '''' table'\n#MSG0101 EQU   9,8                 Insert Offset & Length\n#MSG0102 EQU   30,8                Insert Offset & Length\n\n#MSG011  #MSG  'LWA011I '''' Not Found'\n#MSG0111 EQU   9,8                 Insert Offset & Length\n\n#MSG012  #MSG  'LWA012I PARMLIB Must Be Specified with a member name'\n\n#MSG013  #MSG  'LWA013I PARMLIB READ failed, RC=X''''  RS=X'''' '\n#MSG0131 EQU   34,8                Insert Offset & Length\n#MSG0132 EQU   42,8                Insert Offset & Length\n\n#MSG014  #MSG  'LWA014I '''' table updated from PARMLIB'\n#MSG0141 EQU   9,8                 Insert Offset & Length\n\n#MSG015  #MSG  'LWA015I LOADLIB Keyword Is Missing'\n\n#MSG016  #MSG  'LWA016I MEMBER name can not be specified'\n\n#MSG017  #MSG  'LWA017I OPEN Failed for '''' '\n#MSG0171 EQU   25,44               Insert Offset & Length\n\n#MSG018  #MSG  'LWA018I '''' LOAD failed, RC=X''''  RS=X'''' '\n#MSG0181 EQU   9,8                 Insert Offset & Length\n#MSG0182 EQU   29,8                Insert Offset & Length\n#MSG0183 EQU   37,8                Insert Offset & Length\n\n#MSG019  #MSG  'LWA019I '''' Table loaded from '\n#MSG0191 EQU   9,8                 Insert Offset & Length\n#MSG0192 EQU   29,8                Insert Offset & Length\n\n#MSG020  #MSG  'LWA020I '''' is not a valid ALIAS in '\n#MSG0201 EQU   9,8                 Insert Offset & Length\n#MSG0202 EQU   35,8                Insert Offset & Length\n\n#MSG021  #MSG  'LWA021I '''' table updated from LIST'\n#MSG0211 EQU   9,8                 Insert Offset & Length\n\n#MSG022  #MSG  'LWA022I This Program Requires An ISPF Environment.  ISP*\n               QRY Return Code  '\n#MSG0221 EQU   71,8                Insert Offset & Length\n\nBLANKLNE #MSG  '          '\nBLANKINS EQU   2,80                Insert Offset & Length\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DCB Open Exit Stub - Copied to Work Area (below the line).   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  ,\n         USING *,R15\nOPENSTUB DS    0H\n         N     R1,CLEAR1ST         CLEAR HIGH ORDER BYTE\n         ICM   R15,15,REAL@        A(31-BIT EXIT ROUTINE)\n         BSM   0,R15               B. TO 31 BIT CODE\n         DS    0F                  ALIGNMENT\nREAL@    DS    AL4                 A(31-BIT EXIT ROUTINE)\nCLEAR1ST DC    X'00FFFFFF'         CLEAR MASK\nSTUBLEN  EQU   *-OPENSTUB\n         POP   USING\n\nDCBEXIT  #DCBEXIT ,                Real (Amode 31) Exit Routine\n\nFINDBLANK DC   256X'00'\n         ORG   FINDBLANK+C' '\n         DC    C' '                Find First Blank\n         ORG   ,\n\nFINDCHAR DC    AL1(*-FINDCHAR)\n         ORG   FINDCHAR+C' '\n         DC    X'00'               Skip Over Any Blanks\n         ORG   ,\n\nCONVCONT DC    256AL1(*-CONVCONT)\n         ORG   CONVCONT+C'+'\n         DC    C' '                Convert \"+\" To Blanks\n         ORG   CONVCONT+C'-'\n         DC    C' '                Convert \"-\" To Blanks\n         ORG   ,\n\nCONVDASH DC    256AL1(*-CONVDASH)\n         ORG   CONVDASH+C' '\n         DC    C'-'                Convert Blanks To Dashes\n         ORG   ,\n\nHEXTABLE DC    C'0123456789ABCDEF'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Subroutines                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Get Into Supervisor State Key Zero                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nAUTH     #SAVE ,                   Save All Registers\n\n         TM    WRKFLAG,$SUPER      Check If Already In Supervisor State\n         BO    AUTH0100            B. If Yes\n         TM    WRKFLAG,$APF        Check If Module Is APF Authorized\n         BZ    AUTH0200            B. If Not (Error)\n\n         MODESET MODE=SUP          Get Into Supervisor State\n         OI    WRKFLAG,$SETSUP     Remember Superviosr State Was Set\n\nAUTH0100 DS    0H\n         IPK   ,\n         STC   R2,WRKOPSWK         Save Original Protect Key\n\n         SPKA  0                   Get Into Key Zero\n         OI    WRKFLAG,$SETKEY0    Remember KEY0 Was Set\n\n         LHI   R15,0               Set Return Code\n         B     AUTHEXIT\n\nAUTH0200 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG005)      A(Error Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n\nAUTHEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build Command Buffer From IKJTSOxx Section                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nBUILDCMD #SAVE ,                   Save All Registers\n\n         L     R5,WRKBUFF@         A(Start Of Parmlib Buffer)\n         USING PRM_READ_BUFFER,R5\n         L     R6,PRM_BUFF_SIZE_NEEDED\n         LA    R6,PRM_RECORDS(R6)  A(End Of Parmlib Buffer)\n         LA    R5,PRM_RECORDS      A(1st Parmlib Record)\n         DROP  R5\n\n*-------\n*        Find The Start Of The Requested IKJTSOxx Section\n*-------\nBUIC0100 DS    0H\n         CR    R5,R6               Check For End Of Buffer\n         BNL   BUIC0900            B. If Yes\n\n         L     R15,=A(FINDCHAR)\n         TRT   0(72,R5),0(R15)     Find The 1st Non-Blank\n         BZ    BUIC0700            B. If All Blanks\n\n         CLC   WRKCMDNM,0(R1)      Check For Current Command\n         BE    BUIC0800            B. If Match Found\n\nBUIC0200 DS    0H\n         CLC   0(72,R5),BLANKS     Check For Blank Line\n         BE    BUIC0500            B. If Yes (End Of Command)\n\n         LA    R1,71(,R5)          A(End Of Current Record)\nBUIC0300 DS    0H\n         CLI   0(R1),C' '          Check For Non-Blank\n         BNE   BUIC0400            B. If Found\n         BCT   R1,BUIC0300         Back Up And Loop To Last Non-Blank\n\nBUIC0400 DS    0H\n         CLI   0(R1),C'+'          Check for Continuation Character\n         BE    BUIC0600            B. If Yes\n         CLI   0(R1),C'-'          Check for Continuation Character\n         BE    BUIC0600            B. If Yes\n\nBUIC0500 DS    0H\n         AHI   R5,80               A(Next Record)\n         B     BUIC0100            Keep Searching For Section\n\nBUIC0600 DS    0H\n         AHI   R5,80               A(Next Record)\n         CR    R5,R6               Check For End Of Buffer\n         BL    BUIC0200            B. If Not\n         B     BUIC0100            Keep Searching For Section\n\nBUIC0700 DS    0H\n         AHI   R4,80               A(Next Record)\n         B     BUIC0100            Keep Searching For Section\n\n*-------\n*        Find The End Of The Requested IKJTSOxx Section\n*-------\nBUIC0800 DS    0H\n         ST    R1,WRKCMD@          Save Command Section Start Address\n\nBUIC0900 DS    0H\n         LR    R1,R5               A(Start Of Current Record)\n         CLC   0(72,R5),BLANKS     Check For Blank Line\n         BE    BUIC1300            B. If Yes (End Of Command)\n\n         LA    R1,71(,R5)          A(End Of Current Record)\nBUIC1000 DS    0H\n         CLI   0(R1),C' '          Check For Non-Blank\n         BNE   BUIC1100            B. If Found\n         BCT   R1,BUIC1000         Back Up And Loop To Last Non-Blank\n\nBUIC1100 DS    0H\n         CLI   0(R1),C'+'          Check for Continuation Character\n         BE    BUIC1200            B. If Yes\n         CLI   0(R1),C'-'          Check for Continuation Character\n         BE    BUIC1200            B. If Yes\n\n         LA    R1,1(,R1)           A(End Of Current Section)\n         B     BUIC1300\n\nBUIC1200 DS    0H\n         AHI   R5,80               A(Next Record)\n         CR    R5,R6               Check For End Of Buffer\n         BL    BUIC0900            B. If Not\n         LR    R1,R6               A(End Of Buffer)\n\n*-------\n*        Build A Command Buffer From This Section's Data\n*-------\nBUIC1300 DS    0H\n         ST    R1,WRKCMDE@         Save Command Section End Address\n         SL    R1,WRKCMD@          Calculate Section Length\n         AHI   R1,4                Add CBUF Header Length\n\n         LR    R3,R1\n         C     R3,WRKCBUFL         Check If Buffer Is Large Enough\n         BNH   BUIC1500            B. If Yes\n\n         ICM   R1,15,WRKCBUF@      A(Old Command Buffer)\n         BZ    BUIC1400            B. If No Previous Buffer\n         L     R0,WRKCBUFL         L(Old Command Buffer)\n         FREEMAIN RU,A=(1),LV=(0)\n\nBUIC1400 DS    0H\n         GETMAIN RU,LV=(R3),LOC=ANY\n         ST    R1,WRKCBUF@         Save New Command Buffer Address\n         ST    R3,WRKCBUFL         Save New Command Buffer Length\n\nBUIC1500 DS    0H\n         L     R5,WRKCBUF@         A(Start Of Command Buffer)\n\n         L     R1,WRKCMDE@         A(End Of Current Section)\n         SL    R1,WRKCMD@          Calculate Section Length\n         L     R14,WRKCMD@         A(Start Of Current Section)\n         STH   R1,0(,R5)           Save Command Length In Header\n         LA    R0,4(,R5)           A(Start Of Command Area)\n         #MVCL (R0),(R14),LEN=(R1) Move Section To Command Buffer\n\n         LH    R1,WRKCMDNL         L(Current Section Command)\n         LA    R1,5(R1,R5)         Point Past Command Name\n         L     R2,WRKCBUFL         L(Current Command Buffer Length)\n         SH    R2,=AL2(4)          Subtract CBUF Header Length\n         SH    R2,WRKCMDNL         Subtract Length Of Command Name\n         L     R15,=A(FINDCHAR)\n         #EXEC -R2,TRT,0(*-*,R1),0(R15)                                *\n\n         LA    R2,4(,R5)           A(Start Of Command)\n         SR    R1,R2               Calculate Offset To 1st Operand\n         STH   R1,2(,R5)           Save Offset In Header\n\n         LH    R4,0(,R5)           L(Command)\n         LA    R5,4(,R5)           A(Command)\nBUIC1600 DS    0H\n         LR    R3,R4               Copy Remaining Length\n         CHI   R3,255              Check If Length Is Too Large\n         BNH   BUIC1700            B. If Not\n         LHI   R3,255              Else. Set Length To Maximum\n\nBUIC1700 DS    0H\n         L     R15,=A(CONVCONT)\n         #EXEC -R3,TR,0(*-*,R5),0(R15)                                 *\n                                   Remove Continuation Chars from CBUF\n         AHI   R3,1\n         LA    R5,0(R3,R5)         A(Past Translated Portion)\n         SR    R4,R3               Calculate Remaining Length\n         BP    BUIC1600            B. If There Is More Command Data\n\n         LHI   R15,0               Set Return Code\n         B     BUICEXIT\n\nBUIC1800 DS    0H\n         MVC   WRKINS1(4),=AL2(*-*,#MSG0061)\n         MVC   WRKINS1+4(8),WRKCMDNM\n         LH    R1,WRKCMDNL         L(Current Section Command)\n         AHI   R1,4                Add Msg Prefix Length\n         STH   R1,WRKINS1          Save Message Length\n\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG006)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n\nBUICEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build Table From Parsed Names List                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nBUILDTAB #SAVE ,                   Save All Registers\n\n         MVC   WRKR15,=A(8)        Set Default Return Code\n\n         L     R10,WRKPDL2         A(PDL)\n         USING TSOXXPCL,R10\n\n*-------\n*        Calculate The Number Of Specified Names\n*-------\n         LA    R5,LIST             A(Start Of 'NAMES')\n         SLR   R6,R6               Initialize Entry Counter\nBUIT0100 DS    0H\n         AHI   R6,1                Increment Entry Count\n         CLC   8(4,R5),=X'FF000000'\n         BE    BUIT0200            B. If End Of List\n         L     R5,8(,R5)           A(Next NAME In List)\n         B     BUIT0100            Else. Keep Counting\n\n*-------\n*        Add 1 To The Table Entry Count And Create a KEY8 Table\n*-------\nBUIT0200 DS    0H\n         AHI   R6,1                Add 1 To Entry Count\n         ST    R6,WRKTABCT         Save Entry Count\n\n         MH    R6,WRKTABEL         Calculate Required Table Size\n         AHI   R6,16               Add Table Header Length\n\n         GETMAIN RU,LV=(R6),LOC=ANY\n         ST    R1,WRKTEMP@         Save Table Address\n         STH   R6,WRKTEMPL         Save Table Length\n\nBUIT0300 DS    0H\n         L     R0,WRKTEMP@         A(Key8 Table Storage)\n         LH    R1,WRKTEMPL         L(Key8 Table Storage)\n         #BLANK (R0),LEN=(R1),PAD=C' '\n\n         L     R3,WRKTEMP@         A(Key8 Table Storage)\n         MVC   0(8,R3),WRKTABNM    Insert Table Name\n         MVC   8(8,R3),=C' PARMLIB'\n         AHI   R3,16               A(Start Of Table Entries)\n\n         LA    R5,LIST             A(Start Of 'NAMES')\nBUIT0400 DS    0H\n         L     R1,0(,R5)           A(Current NAME)\n         LH    R2,4(,R5)           L(Current NAME)\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    BUIT0500            B. If Yes\n         STH   R2,0(,R3)           Save NAME Length\n         AHI   R3,2                Advance Past Length\nBUIT0500 DS    0H\n         #EXEC -R2,MVC,0(*-*,R3),0(R1)\n         AHI   R3,8                Advance To Next Entry\n\n         CLC   8(4,R5),=X'FF000000'\n         BE    BUIT0600            B. If End Of List\n         L     R5,8(,R5)           A(Next NAME In List)\n         B     BUIT0400\n\nBUIT0600 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    BUIT0700            B. If Yes\n         MVC   0(2,R3),=X'FFFF'    Set End Of List\n\nBUIT0700 DS    0H\n         MVC   WRKR15,=A(0)        Set Return Code\n\nBUITEXIT DS    0H                  Restore All Registers\n         L     R15,WRKR15          Load Return Code\n         #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Ensure At Least One Table Name Was Specified                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCHECKTAB #SAVE ,                   Save All Registers\n         SLR   R15,R15             Initialize Return Code\n\n         CLI   APKW+1,$AUTHTSF     Check For \"AUTHTSF\" Keyword\n         BE    CHECEXIT            B. If Yes\n         CLI   E2KW+1,$AUTHCMD     Check For \"AUTHCMD\" Keyword\n         BE    CHECEXIT            B. If Yes\n         CLI   E8KW+1,$AUTHPGM     Check For \"AUTHPGM\" Keyword\n         BE    CHECEXIT            B. If Yes\n         CLI   NSKW+1,$NOTBKGND    Check For \"NOTBKGND\" Keyword\n         BE    CHECEXIT            B. If Yes\n\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG007)      A(No Table Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n\nCHECEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Perform Program Termination Cleanup                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCLEANUP  #SAVE ,                   Save All Registers\n\n         IKJRLSA WRKPDL1           Release The Main Parse Storage\n         XC    WRKPDL1,WRKPDL1\n\n         IKJRLSA WRKPDL2           Release The SubCommand Parse Storage\n         XC    WRKPDL2,WRKPDL2\n\nCLEA0100 DS    0H\n         ICM   R1,15,WRKBUFF@      A(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         ICM   R0,15,WRKBUFFL      L(Parmlib Read Buffer)\n         BZ    CLEA0200            B. If Not Available\n         XC    WRKBUFF@,WRKBUFF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0200 DS    0H\n         ICM   R1,15,WRKMSGB@      A(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         ICM   R0,15,WRKMSGBL      L(Buffer)\n         BZ    CLEA0300            B. If Not Available\n         XC    WRKMSGB@,WRKMSGB@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0300 DS    0H\n         ICM   R1,15,WRKCBUF@      A(Buffer)\n         BZ    CLEA0400            B. If Not Available\n         ICM   R0,15,WRKCBUFL      L(Buffer)\n         BZ    CLEA0400            B. If Not Available\n         XC    WRKCBUF@,WRKCBUF@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0400 DS    0H\n         ICM   R1,15,WRKTEMP@      A(Buffer)\n         BZ    CLEA0500            B. If Not Available\n         SLR   R0,R0\n         ICM   R0,3,WRKTEMPL       L(Buffer)\n         BZ    CLEA0500            B. If Not Available\n         XC    WRKTEMP@,WRKTEMP@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEA0500 DS    0H\n         ICM   R1,15,WRKLOAD@      A(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         ICM   R0,15,WRKLOADL      L(Buffer)\n         BZ    CLEANXIT            B. If Not Available\n         XC    WRKLOAD@,WRKLOAD@\n         FREEMAIN RU,A=(1),LV=(0)\n\nCLEANXIT #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Insert The Current Loaded Module                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCOPYLOAD #SAVE ,                   Save All Registers\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   COPLEXIT            B. If Not Authorized\n\n         LH    R3,WRKMODL          Load Module Length\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         STH   R3,WRKAUTHL         Save Authorized Table Size\n\n         L     R4,WRKMOD@          A(Loaded Module)\n         #MVCL (R1),(R4),LEN=(R3)  Copy Module To Authorized Storage\n\n         L     R1,WRKTAB@@         A(Table Address In LWA)\n         MVC   WRKTAB@,0(R1)       Save Old Table Address\n         MVC   0(4,R1),WRKAUTH@    Point To New Table\n         MVC   WRKTABL,0(R1)       Save Old Table Address\n         L     R1,WRKTABL@         A(Table Length In LWA)\n         MVC   0(2,R1),WRKAUTHL    Set To New Table Length\n\n         L     R14,WRKLWA@         A(LWA)\n         USING LWA,R14\n\n         OC    LWAVFLGS,WRKVFLGS   Ensure \"LOADED\" Flag Is On\n\n         DROP  R14\n\n         ICM   R1,15,WRKTAB@       A(Previous Table)\n         BZ    COPYL100            B. If No Previous Table\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        A(Previous Table Length)\n         BZ    COPYL100            B. If No Previous Table\n         XC    WRKTAB@,WRKTAB@\n         XC    WRKTABL,WRKTABL\n         FREEMAIN RU,A=(1),LV=(0),SP=252\n\nCOPYL100 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n         LHI   R15,0               Set Return Code\n\nCOPLEXIT #RESTORE R15=(R15)        Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Copy The Current Table To One With A Known Length            *\n*                                                                     *\n*        If The Table Length Is Not Known, The User May Be Using      *\n*        A Version That is Loaded From LPA (Un-Alterable).            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nCOPYTAB  #SAVE ,                   Save All Registers\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        Check If Length Is Already Known\n         BNZ   COPYEXIT            B. If Yes (No Need To Copy)\n\n         #CALL GETLEN              Determine Length Of Current Table\n         BZ    COPYEXIT            B. If No Current Table\n         STH   R15,WRKTABL         Set Current Table Length\n\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   COPYEXIT            B. If Not Authorized\n\n         LH    R3,WRKTABL          Load Calculated Table Length\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         LR    R2,R1\n         STH   R3,WRKAUTHL         Save Authorized Table Length\n\n         L     R4,WRKTAB@          A(Current Table)\n         #MVCL (R1),(R4),LEN=(R3)  Copy Table To Authorized Storage\n\n         L     R1,WRKTAB@@         A(Table Address In LWA)\n         MVC   0(4,R1),WRKAUTH@    Point To New Table\n         MVC   WRKTAB@,WRKAUTH@\n         L     R1,WRKTABL@         A(Table Length In LWA)\n         MVC   0(2,R1),WRKAUTHL    Set To New Table Length\n\n         #CALL DEAUTH              Return To Original State & Key\n\nCOPYEXIT #RESTORE ,                Restore All Registers\n\n         SLR   R15,R15\n         ICM   R15,3,WRKTABL       Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Return To Original State And Key                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nDEAUTH   #SAVE ,                   Save All Registers\n\n         TM    WRKFLAG,$SETKEY0    Check If Changed To Key Zero\n         BZ    DEAU0100            B. If Not\n\n         IC    R2,WRKOPSWK         Load Original Protect Key\n         SPKA  0(R2)               Return To Original Key\n         NI    WRKFLAG,255-$SETKEY0\n\nDEAU0100 DS    0H\n         TM    WRKFLAG,$SETSUP     Check If Changed To Superviosr State\n         BZ    DEAUEXIT            B. If Not\n\n         MODESET MODE=PROB         Return To Problem State\n         NI    WRKFLAG,255-$SETSUP\n\nDEAUEXIT #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display A Table's Information And Contents                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nDISPTAB  #SAVE ,                   Save All Registers\n\n*-------\n*     LWA008I ________(________________) AT ________ KEY __ LEN=_____\n*-------\n\n         MVC   WRKINS1(4),=AL2(4+26,#MSG0081)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVI   WRKINS1+4+8,C'('\n         MVC   WRKINS1+4+8+1(16),BLANKS\n         ICM   R5,15,WRKTAB@       A(Current Table)\n         BZ    DISP0100            B. If No Table\n         MVC   WRKINS1+4+8+1(16),0(R5)\nDISP0100 DS    0H\n         MVI   WRKINS1+4+8+1+16,C')'\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0082)\n         UNPK  WRKINS2+4(9),WRKTAB@(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVI   WRKINS2+4+8,C' '\n         MVC   WRKINS3(4),=AL2(4+2,#MSG0083)\n         UNPK  WRKINS3+4(3),WRKTABPK(2)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS3+4(2),0(R15)\n         MVI   WRKINS3+4+2,C' '\n         MVC   WRKINS4(4),=AL2(4+9+8,#MSG0084)\n         MVC   WRKINS4+4(28),BLANKS\n         SLR   R1,R1\n         ICM   R1,3,WRKTABL\n         BZ    DISP0200\n         MVC   WRKINS4+4(4),=C'LEN='\n         CVD   R1,WRKDBL\n         OI    WRKDBL+7,X'0F'\n         UNPK  WRKINS4+8(5),WRKDBL\n         MVC   WRKINS4+8+5(8),=C' Decimal'\n\nDISP0200 DS    0H\n         MVC   WRKINS5(4),=AL2(4+L'#MSG0085,#MSG0085)\n         MVC   WRKINS5+4(28),BLANKS\n         TM    WRKTABF,WRK$STEP    Check If Table Came From //STEPLIB\n         BZ    DISP0300            B. If Not\n         MVC   WRKINS5+4(7),=C'STEPLIB'\n         B     DISP0400\nDISP0300 DS    0H\n         ICM   R0,3,WRKTABL        Check If A Length Exists In The LWA\n         BNZ   DISP0400            B. If Yes (Parmlib Or //STEPLIB)\n         MVC   WRKINS5+4(28),BLANKS\n         MVC   WRKINS5+4(3),=C'LPA'\n\nDISP0400 DS    0H\n         LHI   R0,6                Message Contains 6 Segments\n         L     R1,=A(#MSG008)      A(Informational Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         LA    R6,WRKINS5          A(Insert #5)\n         #CALL PUTLINE             Write Message\n\n*-------\n*     LWA002I ________ ________ ________ ________ ________ ________\n*-------\n         ICM   R9,15,WRKTAB@       A(Current Table)\n         BZ    DISPEXIT            B. If No Table\n         LR    R2,R9               Save Starting Address\n         XC    WRKTABE@,WRKTABE@   Reset End Of Table Address\n         AHI   R9,16               Advance Past Table Header\n\n         SLR   R1,R1\n         ICM   R1,3,WRKTABL        L(Current Table)\n         BZ    DISP0500            B. If Table Has Blank Terminator\n         AR    R2,R1               A(End Of Table)\n         ST    R2,WRKTABE@         Save End Of Table Address\n\nDISP0500 DS    0H\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0091)\n         MVC   WRKINS1+4(28),BLANKS\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0092)\n         MVC   WRKINS2+4(28),BLANKS\n         MVC   WRKINS3(4),=AL2(4+8,#MSG0093)\n         MVC   WRKINS3+4(28),BLANKS\n         MVC   WRKINS4(4),=AL2(4+8,#MSG0094)\n         MVC   WRKINS4+4(28),BLANKS\n         MVC   WRKINS5(4),=AL2(4+8,#MSG0095)\n         MVC   WRKINS5+4(28),BLANKS\n         MVC   WRKINS6(4),=AL2(4+8,#MSG0096)\n         MVC   WRKINS6+4(28),BLANKS\n\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISPEXIT            B. If Terminator Slot Found\n         MVC   WRKINS1+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0600            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0600 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS2+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0700            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0700 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS3+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0800            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0800 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS4+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0900            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP0900 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS5+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP1000            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP1000 DS    0H\n         #CALL GETNAME             Get Current Program/Command Name\n         BZ    DISP1200            B. If Terminator Slot Found\n         MVC   WRKINS6+4(8),WRKNAME\n         AH    R9,WRKTABEL         A(Next Slot In Table)\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP1100            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BNL   DISP1200            B. If End Encountered\n\nDISP1100 DS    0H\n         LHI   R0,7                Message Contains 7 Segments\n         L     R1,=A(#MSG009)      A(Program/Command Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         LA    R6,WRKINS5          A(Insert #5)\n         LA    R7,WRKINS6          A(Insert #6)\n         #CALL PUTLINE             Write Message\n\n         ICM   R0,3,WRKTABL        L(Current Table)\n         BZ    DISP0500            B. If Table Must Have A Terminator\n         C     R9,WRKTABE@         Check For End Of Table\n         BL    DISP0500            B. If More Entries Exist\n         B     DISPEXIT            Else. Terminate\n\n*-------\n*        Display The Last Entry\n*-------\nDISP1200 DS    0H\n         LHI   R0,7                Message Contains 7 Segments\n         L     R1,=A(#MSG009)      A(Program/Command Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         LA    R5,WRKINS4          A(Insert #4)\n         LA    R6,WRKINS5          A(Insert #5)\n         LA    R7,WRKINS6          A(Insert #6)\n         #CALL PUTLINE             Write Message\n\nDISPEXIT DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(BLANKLNE)     A(Blank Line Message)\n         #CALL PUTLINE             Write Message\n\n         #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\n*-------\n*        Save The Contents Of The Current Table Entry\n*-------\n         PUSH  USING\nGETNAME  #SAVE ,                   Save All Registers\n         MVC   WRKNAME,BLANKS      Initialize Output Area\n         LR    R1,R9               Set Start Of Entry Name\n         LHI   R2,8                Set Length For MVC\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   GETN0100            B. If Not\n         ICM   R2,3,0(R9)          Load Command Length\n         BZ    GETNEXIT            B. If Null Entry\n         CLC   0(2,R9),=X'FFFF'    Check For Terminating Entry\n         BE    GETNEXIT            B. If Yes\n         LA    R1,2(,R1)           Advance Past Length Field\n\nGETN0100 DS    0H\n         #EXEC -R2,MVC,WRKNAME(*-*),0(R1)\n\nGETNEXIT #RESTORE ,                Restore All Registers\n\n         TM    WRKNAME,X'BF'       Check If Entry Name Is Null\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Locate The Currently Specified \"NAME\"                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nFINDNAME #SAVE ,                   Save All Registers\n         SLR   R6,R6               Initialize \"FOUND\" Keyword Address\n\n*-------\n*        Search The AUTHTSF Table\n*-------\n         CLI   APKW+1,$AUTHTSF     Check For 'IKJEFTAP' Keyword\n         BNE   FIND0200            B. If Not\n         LA    R6,APKW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHTSF '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTAP'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTAB@@,WRKTAPP@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTAPL@   Save Table Length Address\n         L     R3,WRKTAPP@\n         ICM   R3,15,0(R3)         A(IKJEFTAP Table)\n         BZ    FIND0200            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTAPL     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0100            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0100 DS    0H\n         CLI   0(R4),C' '          Check For End Of Table\n         BE    FIND0200            B. If Table Ends\n         CLC   0(8,R4),WRKNAME     Check If \"NAME\" Was Found\n         BE    FIND0900            B. If Yes\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0100            B. If Terminator Must Exist\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0100            B. If More Entries\n\n*-------\n*        Search The AUTHCMD Table\n*-------\nFIND0200 DS    0H\n         CLI   E2KW+1,$AUTHCMD     Check For 'IKJEFTE2' Keyword\n         BNE   FIND0400            B. If Not\n         LA    R6,E2KW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHCMD '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE2'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTAB@@,WRKTE2P@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTE2L@   Save Table Length Address\n         L     R3,WRKTE2P@\n         ICM   R3,15,0(R3)         A(IKJEFTE2 Table)\n         BZ    FIND0400            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTE2L     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTE2L        L(Table In LWA)\n         BZ    FIND0300            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0300 DS    0H\n         CLI   0(R4),C' '          Check For End Of Table\n         BE    FIND0400            B. If Table Ends\n         CLC   0(8,R4),WRKNAME     Check If \"NAME\" Was Found\n         BE    FIND0900            B. If Yes\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0300            B. If Terminator Must Exist\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0300            B. If More Entries\n\n*-------\n*        Search The AUTHPGM Table\n*-------\nFIND0400 DS    0H\n         CLI   E8KW+1,$AUTHPGM     Check For 'IKJEFTE8' Keyword\n         BNE   FIND0600            B. If Not\n         LA    R6,E8KW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(7)\n         MVC   WRKCMDNM,=C'AUTHPGM '\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTE8'\n         MVC   WRKTABEL,=AL2(8)    Set Table Entry Length\n         MVC   WRKTAB@@,WRKTE8P@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTE8L@   Save Table Length Address\n         L     R3,WRKTE8P@\n         ICM   R3,15,0(R3)         A(IKJEFTE8 Table)\n         BZ    FIND0600            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTE8L     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTE8L        L(Table In LWA)\n         BZ    FIND0500            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0500 DS    0H\n         CLI   0(R4),C' '          Check For End Of Table\n         BE    FIND0600            B. If Table Ends\n         CLC   0(8,R4),WRKNAME     Check If \"NAME\" Was Found\n         BE    FIND0900            B. If Yes\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0500            B. If Terminator Must Exist\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0500            B. If More Entries\n\n*-------\n*        Search The NOTBKGND Table\n*-------\nFIND0600 DS    0H\n         CLI   NSKW+1,$NOTBKGND    Check For 'IKJEFTNS' Keyword\n         BNE   FIND1000            B. If Not\n         LA    R6,NSKW             A(Current Keyword)\n         MVC   WRKCMDNL,=AL2(8)\n         MVC   WRKCMDNM,=C'NOTBKGND'\n         MVC   WRKTABNL,=AL2(8)\n         MVC   WRKTABNM,=C'IKJEFTNS'\n         MVC   WRKTABEL,=AL2(10)   Set Table Entry Length\n         MVC   WRKTAB@@,WRKTNSP@   Save Table Pointer Address\n         MVC   WRKTABL@,WRKTNSL@   Save Table Length Address\n         L     R3,WRKTNSP@\n         ICM   R3,15,0(R3)         A(IKJEFTNS Table)\n         BZ    FIND1000            B. If Not Available\n         ST    R3,WRKTAB@          Save Table Address\n         MVC   WRKTABL,WRKTNSL     Save Table Length\n         LA    R4,16(,R3)          A(1st Entry)\n         SLR   R1,R1\n         ICM   R1,3,WRKTNSL        L(Table In LWA)\n         BZ    FIND0700            B. If Length Is Zero\n         AR    R1,R3               A(End Of Table)\n         ST    R1,WRKTABE@\nFIND0700 DS    0H\n         ICM   R0,3,0(R4)          Load Command Length\n         BZ    FIND1000            B. If Null Entry\n         CLC   0(2,R4),=X'FFFF'    Check For Terminating Entry\n         BE    FIND1000            B. If Yes\n         CLC   0(2,R4),WRKNAMEL    Check If Lengths Match\n         BNE   FIND0800            B. If Not\n         LH    R1,WRKNAMEL         L(NAME)\n         #EXEC -R1,CLC,2(*-*,R4),WRKNAME\n         BE    FIND0900            B. If NAME Found\nFIND0800 DS    0H\n         AH    R4,WRKTABEL         A(Next Table Entry)\n         ICM   R0,3,WRKTAPL        L(Table In LWA)\n         BZ    FIND0700            B. If No Length In LWA\n         C     R4,WRKTABE@         Check For End Of Table\n         BL    FIND0700            B. If More Entries\n         B     FIND1000            B. If Not Found\n\n*-------\n*        \"NAME\" Found.  Return It's Address To Caller\n*-------\nFIND0900 DS    0H\n         ST    R6,WRKKW@           Save \"FOUND\" Keyword Address\n\n         LR    R5,R4               A(Current Table Entry)\n\n         LR    R15,R5\n         SL    R15,WRKTAB@         Calculate Entry Offset\n         ST    R15,WRKNAMEO\n\n         TM    WRKFLAG,$MSG_F      Check If Message Requested\n         BZ    FINDEXIT            B. If Not\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0101)\n         MVC   WRKINS1+4(8),WRKNAME\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0102)\n         MVC   WRKINS2+4(8),WRKCMDNM\n         LH    R0,WRKCMDNL\n         AHI   R0,4\n         STH   R0,WRKINS2\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG010)      A(Not Found Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         B     FINDEXIT\n\n*-------\n*        \"NAME\" Not Found.  Issue Messaged If Requested\n*-------\nFIND1000 DS    0H\n         SLR   R5,R5               Indicate Entry Not Found\n\n         TM    WRKFLAG,$MSG_NF     Check If Message Requested\n         BZ    FINDEXIT            B. If Not\n         MVC   WRKINS1(4),=AL2(4+*-*,#MSG0111)\n         MVC   WRKINS1+4(8),WRKNAME\n         LH    R0,WRKNAMEL\n         AHI   R0,4\n         STH   R0,WRKINS1\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG011)      A(Not Found Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\nFINDEXIT DS    0H\n         NI    WRKFLAG,255-($MSG_NF+$MSG_F)\n\n         #RESTORE R15=(R5)         Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Determine Length Of Table                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nGETLEN   #SAVE ,                   Save All Registers\n\n         SLR   R15,R15\n         ICM   R15,3,WRKTABL       Load Table Length From LWA\n         BNZ   GETLEXIT            B. If Length Exists\n\nGETL0100 DS    0H\n         L     R15,WRKTAB@@        A(Current Table Pointer)\n         ICM   R15,15,0(R15)       A(Current Table)\n         BZ    GETLEXIT            B. If No Table Exists\n         ST    R15,WRKTAB@         Save Current Table Address\n         AHI   R15,16              A(1st Table Entry)\n\nGETL0200 DS    0H\n         CLC   WRKTABEL,=AL2(10)   Check For IKJEFTNS Table\n         BNE   GETL0300            B. If Not\n         ICM   R0,3,0(R15)         Check For Null Entry (Terminator)\n         BZ    GETL0500            B. If Yes\n         CLC   0(2,R15),=X'FFFF'   Check For Terminating Entry\n         BE    GETL0500            B. If Yes\n         B     GETL0400\n\nGETL0300 DS    0H\n         TM    0(R15),X'BF'        Check For Blank/Zero Entry\n         BZ    GETL0500            B. If Yes (Terminator)\n\nGETL0400 DS    0H\n         AH    R15,WRKTABEL        A(Next Entry In Table)\n         B     GETL0100            B. Check Next Entry\n\nGETL0500 DS    0H\n         AH    R15,WRKTABEL        A(End Of Terminating Entry)\n\nGETLEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Build A Table From The 8 Byte LIST File                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nLISTTAB  #SAVE ,                   Save All Registers\n\n*-------\n*        Find The Table Id And Count It's Entries\n*-------\n         L     R4,WRKMSGB@         A(Start Of Data Buffer)\nLIST0100 DS    0H\n         C     R4,WRKMSGBE         Check For End Of Buffer\n         BNL   LIST0800            B. If Id Not Found\n         CLC   WRKNAME,0(R4)       Check For Current Table Id\n         BE    LIST0200            B. If Yes\n         AHI   R4,8                A(Next LIST Entry)\n         B     LIST0100            Keep Searching\n\nLIST0200 DS    0H\n         AHI   R4,8                A(Start Of Table Names)\n         ST    R4,WRKPARM@         Save 1st Entry Address\n         SLR   R5,R5               Initialize Entry Counter\n\nLIST0300 DS    0H\n         C     R4,WRKMSGBE         Check For End Of Buffer\n         BNL   LIST0400            B. If End Reached\n         CLI   0(R4),C'-'          Check For \"Id\" Entry\n         BE    LIST0400            B. If Next Id Found\n         AHI   R4,8                A(Next LIST Entry)\n         AHI   R5,1                Add 1 To Entry Count\n         B     LIST0300            Keep Counting Entries\n\nLIST0400 DS    0H\n         ST    R5,WRKPARM#         Save Entry Count\n\n         LTR   R5,R5               Check Entry Count\n         BZ    LIST0800            B. If No Entries In Table\n\n*-------\n*        Add 1 To The Table Entry Count And Create a KEY8 Table\n*-------\n         AHI   R5,1                Add 1 To Entry Count\n         ST    R5,WRKTABCT         Save Entry Count\n\n         MH    R5,WRKTABEL         Calculate Required Table Size\n         AHI   R5,16               Add Table Header Length\n\n         GETMAIN RU,LV=(R5),LOC=ANY\n         ST    R1,WRKTEMP@         Save Table Address\n         STH   R5,WRKTEMPL         Save Table Length\n\n         L     R0,WRKTEMP@         A(Key8 Table Storage)\n         LH    R1,WRKTEMPL         L(Key8 Table Storage)\n         #BLANK (R0),LEN=(R1),PAD=C' '\n\n         L     R3,WRKTEMP@         A(Key8 Table Storage)\n         MVC   0(8,R3),WRKTABNM    Insert Table Name\n         MVC   8(8,R3),=C' PARMLIB'\n         AHI   R3,16               A(Start Of Table Entries)\n\n*-------\n*        Insert All The LIST Entries Into The KEY8 Table\n*-------\n         L     R5,WRKPARM@         A(1st Entry Name)\n         L     R6,WRKPARM#         Load Entry Count\nLIST0500 DS    0H\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    LIST0600            B. If Yes\n         LA    R1,8(,R5)           A(End Of Current Entry)\n         L     R15,=A(FINDBLANK)\n         TRT   0(8,R5),0(R15)      Find The First Blank\n         SR    R1,R5               Calculate Entry's Value Length\n         STH   R1,0(,R3)           Save NAME Length\n         AHI   R3,2                Advance Past Length\nLIST0600 DS    0H\n         MVC   0(8,R3),0(R5)       Insert LIST Entry\n         AHI   R3,8                Advance To Next Entry\n         AHI   R5,8                Advance To Next LIST Entry\n         BCT   R6,LIST0500         Process All LIST Entries\n\n         CLC   WRKTABEL,=AL2(8)    Check For Normal Table Entry\n         BE    LIST0700            B. If Yes\n         MVC   0(2,R3),=X'FFFF'    Set End Of List\n\nLIST0700 DS    0H\n         LHI   R15,0               Set Return Code\n         B     LISTEXIT\n\nLIST0800 DS    0H\n         LHI   R15,8               Set Return Code\n\nLISTEXIT #RESTORE R15=(R15)        Restore All Registers\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Load A Table From An IKJTABLS Alias Load Module              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nLOADIT   #SAVE ,                   Save All Registers\n\n         L     R15,=A(MODCBU)\n         MVC   WRKDCB,0(R15)       Copy DCB To Work Area\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN\n         L     R15,=A(MODCBEU)\n         MVC   WRKDCBE,0(R15)      Copy DCBE To Work Area\n         LA    R15,WRKDCBE         A(DCBE)\n         ST    R15,DCBDCBE-IHADCB+WRKDCB\n\n         LA    R14,LOAD0900        A(Return From SYNAD Routine)\n         ST    R14,WRKR14          And From End-Of-Data\n         ST    R14,DCBEEODA-DCBE+WRKDCBE\n\n         L     R15,=A(MODOPEN)\n         MVC   WRKOPEN,0(R15)\n         OPEN  (WRKDCB),           Open The \"LOADLIB\" Data Set         *\n               MF=(E,WRKOPEN)\n         TM    DCBOFLGS-IHADCB+WRKDCB,DCBOFOPN\n         BZ    LOAD0700            B. If OPEN Failed\n\n*-------\n*        Issue BLDL To Allow Subsequent Load From Unauthorzed Library\n*-------\n         XC    WRKBLDL(WRKBLDLL),WRKBLDL\n         MVC   WRKBLDE#,=AL2(1)    Set Entry Length\n         MVC   WRKBLDEL,=AL2(L'WRKBLDLI) Set Directory Entry Length\n\n         LA    R2,WRKBLDLI         A(Directory Information)\n         USING PDS2,R2\n         MVC   PDS2NAME,WRKTABNM   Set Module Name\n\n         BLDL  WRKDCB,WRKBLDL      Search For Module Information\n         LTR   R15,R15             Check If Module Found\n         BNZ   LOAD0900            B. If Not\n\n         TM    PDS2INDC,PDS2ALIS   Check If Module Is An Alias\n         BZ    LOAD0900            B. If Not\n\n         SLR   R3,R3\n         ICM   R3,7,PDS2STOR       L(Module)\n         BZ    LOAD0900            B. If No Module\n         DROP  R2\n\n         C     R3,WRKLOADL         Check If Buffer Is Large Enough\n         BNH   LOAD0200            B. If Entire Module Will Fit\n         ICM   R1,15,WRKLOAD@      A(Buffer)\n         BZ    LOAD0100            B. If Not Available\n         ICM   R0,15,WRKLOADL      L(Buffer)\n         BZ    LOAD0100            B. If Not Available\n         FREEMAIN RU,A=(1),LV=(0)\nLOAD0100 DS    0H\n         GETMAIN RU,LV=(R3),LOC=BELOW\n         ST    R1,WRKLOAD@         Save Buffer Address\n         ST    R3,WRKLOADL         Save Buffer Length\n\n*-------\n*        Load The Requested Module Into Temporary Storage\n*-------\nLOAD0200 DS    0H\n         L     R15,=A(MODLOAD)\n         MVC   WRKLOAD,0(R15)\n         L     R2,WRKLOAD@         A(Directed Load Storage)\n\n         LOAD  EPLOC=WRKTABNM,                                         *\n               DCB=WRKDCB,LSEARCH=YES,ADRNAPF=(R2),                    *\n               ERRET=LOAD0800,SF=(E,WRKLOAD)\n\n         ST    R0,WRKMOD@          Save Module Entry Point\n         MVC   8(8,R2),=C' PARMLIB'  Simulate Data From IKJTSOxx\n\n         DELETE EPLOC=WRKTABNM     Remove The Module\n\n*-------\n*        Read The LOAD Module To Determine The CSECT Length\n*-------\n         FIND  WRKDCB,WRKTABNM,D   Point To Start Of Member\n\nLOAD0300 DS    0H\n         GETBUF WRKDCB,R6\n         ST    R6,WRKDCBBU         Save DCB Buffer Address\n\n         READ  DECB,SF,WRKDCB,(R6),'S',MF=E\n         CHECK DECB                Wait For I/O To Complete\n\n         USING CESD,R6\n         USING ESDDATA,CESDATA\n         CLI   CESDIDEN,CESDRCD    Check For CESD Record\n         BNE   LOAD0300            B. If Not\n\n         #BLKLEN DECB,R2           Get Length Of Current Block\n         AR    R2,R6               A(End Of Buffer)\n         ST    R2,WRKDCBBE         Save DCB Buffer End Address\n\nLOAD0400 DS    0H\n         C     R6,WRKDCBBE         Check For End Of Buffer\n         BNL   LOAD0300            B. If Buffer Complete\n         CLC   ESDNAME,WRKTABNM    Check For CESD For Our Module\n         BNE   LOAD0500            B. If Not\n         SLR   R3,R3\n         ICM   R3,7,ESDCLEN        Get CSECT Length\n         B     LOAD0600\n\nLOAD0500 DS    0H\n         LA    R6,16(,R6)          A(Next ESD Entry)\n         B     LOAD0400            Loop Through Buffer\n         DROP  R6\n\nLOAD0600 DS    0H\n         STH   R3,WRKMODL          Save CSECT Length\n\n         #CALL COPYLOAD            Copy And Save Address/Length In LWA\n\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0191)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0192)\n         MVC   WRKINS2+4(46),WRKDSN\n         LH    R1,WRKDSPDE+4       L(Quoted Data Set Name)\n         AHI   R1,4\n         STH   R1,WRKINS2\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG019)      A(Table Loaded Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,0               Set Return Code\n         B     LOAD1000\n\nLOAD0700 DS    0H\n         LHI   R0,2                Message Contains 1 Segments\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0171)\n         MVC   WRKINS1+4(8),WRKDDN\n         L     R1,=A(#MSG017)      A(OPEN Failed)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LOAD1000\n\nLOAD0800 DS    0H\n         ST    R15,WRKRCODE        Save Return Code\n         ST    R1,WRKREASN         Save Reason Code\n\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0181)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0182)\n         UNPK  WRKINS2+4(9),WRKRCODE(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVI   WRKINS2+4+8,C' '\n         MVC   WRKINS3(4),=AL2(4+8,#MSG0183)\n         UNPK  WRKINS3+4(9),WRKREASN(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS3+4(8),0(R15)\n         MVI   WRKINS3+4+8,C' '\n         LHI   R0,4                Message Contains 4 Segments\n         L     R1,=A(#MSG018)      A(Load Failed Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         LA    R4,WRKINS3          A(Insert #3)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LOAD1000\n\nLOAD0900 DS    0H\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0201)\n         MVC   WRKINS1+4(8),WRKTABNM\n         MVC   WRKINS2(4),=AL2(4+*-*,#MSG0202)\n         MVC   WRKINS2+4(46),WRKDSN\n         LH    R1,WRKDSPDE+4       L(Quoted Data Set Name)\n         AHI   R1,4\n         STH   R1,WRKINS2\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG020)      A(Table Loaded Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         #CALL PUTLINE             Write Message\n\n         LHI   R15,8               Set Return Code\n         B     LOAD1000\n\nLOAD1000 DS    0H\n         TM    DCBOFLGS-IHADCB+WRKDCB,DCBOFOPN\n         BZ    LOADEXIT            B. If OPEN Failed\n         L     R15,=A(MODCLOSE)\n         MVC   WRKCLOSE,0(R15)\n         CLOSE (WRKDCB),           Close The \"LOADLIB\" Data Set        *\n               MF=(E,WRKCLOSE)\n\nLOADEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\n         PUSH  USING\nLOADSYN  #SAVE ,                   Save All Registers\n         LR    R4,R13              Save Work Area Address\n         DROP  R13\n         USING WRKLWATM,R4\n\n         SYNADAF ACSMETH=BPAM,PARM1=(1)\n         MVC   WRKINS1(4),=AL2(4+82,BLANKINS)\n         MVC   WRKINS1+4(78),50(R1)\n\n         SYNADRLS ,                Release Synad Message Buffer\n\n         LR    R13,R4              Restore Dynamic Work Area\n         DROP  R4\n         USING WRKLWATM,R13\n\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(BLANKLNE)     A(Blank Line)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\n         #RESTORE ,                Restore All Registers\n\n         L     R14,WRKR14          A(Synad Return Address)\n         BR    R14\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PUTLINE Subroutine                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nPUTLINE  #SAVE ,                   Save All Registers\n         TM    WRKFLAG,$ERROR      Check For Error Message\n         BO    PUTL0100            B. If Yes\n         CLI   NOMSGSKW+1,$NOMSGS  Check For 'NOMSG' Keyword\n         BE    PUTLEXIT            B. If Yes\n\nPUTL0100 DS    0H\n         STM   R0,R7,WRKOLD        Save Output Line Descriptors\n\n         L     R3,WRKUPT@          A(UPT)\n         L     R4,WRKECT@          A(ECT)\n\n         XC    WRKECB,WRKECB       Clear ECB\n         PUTLINE PARM=PUTLINEL,UPT=(R3),ECT=(R4),ECB=WRKECB,           *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)      Write The Message\n\nPUTLEXIT DS    0H\n         NI    WRKFLAG,255-$ERROR\n\n         #RESTORE ,                Restore All Registers\n\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARMLIB Data Set Read Subroutine                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nREADPARM #SAVE ,                   Save All Registers\n\n         XC    WRKPARM@,WRKPARM@   Clear 1st Parmlib Record Address\n         XC    WRKPARM#,WRKPARM#   Clear Parmlib Record Count\n\n         LA    R0,WRKDDN           A(DDName Buffer)\n         ST    R0,WRKDDPDE\n         LHI   R0,8                L(DDName Buffer)\n         STH   R0,WRKDDPDE+4\n         MVC   WRKDDN,BLANKS\n\n*-------\n*        Validate And Allocate The PARMLIB Data Set\n*-------\n         CLI   PARMLKW+1,$PARMLIB  Check For 'PARMLIB' Keyword\n         BNE   READ0400            B. If Not\n         ICM   R1,15,PARMLIB       A(Fully Qualified Data Set Name)\n         BZ    READ0400            B. If Not Available\n         LH    R2,PARMLIB+4        L(Fully Qualified Data Set Name)\n\n         LA    R0,WRKDSN           A(Quoted Data Set Name Area)\n         ST    R0,WRKDSPDE\n         MVC   WRKDSN,BLANKS\n         MVI   WRKDSN,C''''        Insert Leading Quote\n         #EXEC -R2,MVC,WRKDSN+1(*-*),0(R1)\n         LA    R1,WRKDSN+1+1(R2)   A(End Of Data Set Name)\n         MVI   0(R1),C''''         Insert Ending Quote\n         AHI   R1,1                A(End Of Data Set Name)\n         LA    R2,WRKDSN           A(Start Of Data Set Name)\n         SR    R1,R2               Calculate Length Of Data Set Name\n         STH   R1,WRKDSPDE+4       Save Quoted Data Set Name Length\n\n         MVC   WRKMEMNM,BLANKS\n         ICM   R1,15,PARMLIB+8     A(Member Name)\n         BZ    READ0400            B. If Not Available\n         LH    R2,PARMLIB+12       L(Member Name)\n         #EXEC -R2,MVC,WRKMEMNM(*-*),0(R1)\n\n         ALLOC DSN=WRKDSPDE,DISP=SHR,                                  *\n               DDNTO=WRKDDN,                                           *\n               ERROR=READ0500\n\n*-------\n*        Use Parmlib Services To Read The Entire IKJTSOxx Member\n*-------\n         L     R1,WRKBUFF@         A(Previous Storage Buffer)\n         ICM   R0,15,WRKBUFFL      Check If A Buffer Already Exists\n         BNZ   READ0200            B. If Yes\n         MVC   WRKBUFFL,=A(PRM_READ_BUFFER_LEN+(1024*80))\nREAD0100 DS    0H\n         L     R0,WRKBUFFL\n         GETMAIN RU,LV=(R0),LOC=ANY\nREAD0200 DS    0H\n         XC    0(PRM_READ_BUFFER_LEN,R1),0(R1)\n         ST    R1,WRKBUFF@\n         LR    R3,R1\n         USING PRM_READ_BUFFER,R3\n         MVC   PRM_READ_BUFF_SIZE,WRKBUFFL\n\n         L     R2,WRKMSGBL         L(IEFPRMLB Messages Buffer)\n         L     R4,WRKMSGB@         A(IEFPRMLB Messages Buffer)\n         USING PRM_Message_Buffer,R4\n         XC    PRM_MESSAGE_HEADER,PRM_MESSAGE_HEADER\n         ST    R2,PRM_MSG_BUFFER_SIZE\n         DROP  R4\n\n         IEFPRMLB REQUEST=READMEMBER,                                  *\n               DDNAME=WRKDDN,                                          *\n               MEMNAME=WRKMEMNM,                                       *\n               READBUF=(R3),                                           *\n               BLANK72=NO,                                             *\n               MSG=NO,                                                 *\n               CALLERNAME=LWAMODID,                                    *\n               RSNCODE=WRKREASN,                                       *\n               RETCODE=WRKRCODE,                                       *\n               MF=(E,WRKPRMPL,COMPLETE)\n\n         LTR   R15,R15\n         BZ    READ0300\n         CLC   WRKRCODE,=A(PRMLB_REQUEST_FAILED)\n         BNE   READ0600            B. If Not Request Failed\n         CLC   WRKREASN,=A(PRMLB_READ_BUFFER_FULL)\n         BNE   READ0600            B. If Not Buffer Full\n\n         L     R5,PRM_BUFF_SIZE_NEEDED\n         A     R5,=A(100*80)       Allow For 100 More Records\n         MVC   WRKBUFFL,PRM_BUFF_SIZE_NEEDED\n         L     R0,PRM_READ_BUFF_SIZE\n\n         FREEMAIN RU,A=(R3),LV=(0)\n         XC    WRKBUFF@,WRKBUFF@\n         B     READ0100\n\n*-------\n*        Return 1st Record Address And Number Of Records\n*-------\nREAD0300 DS    0H\n         ICM   R5,15,PRM_TOTAL_RECORDS\n         BZ    READEXIT            B. If No Records In Member\n         LA    R4,PRM_RECORDS      A(1st Record)\n\n         ST    R5,WRKPARM#         #(Returned Records)\n         ST    R4,WRKPARM@         A(1st Record)\n         B     READEXIT\n\n*-------\n*        PARMLIB Not Specified Or DSN/Member Not Specified\n*-------\nREAD0400 DS    0H\n         LHI   R0,1                Message Contains 1 Segment\n         L     R1,=A(#MSG012)      A(Error Message)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     READEXIT\n\n*-------\n*        PARMLIB Could Not Be Allocated\n*-------\nREAD0500 DS    0H\n         S99FAIL ,\n         B     READEXIT\n\n*-------\n*        PARMLIB Read Failed\n*-------\nREAD0600 DS    0H\n         MVC   WRKINS1(4),=AL2(4+8,#MSG0131)\n         UNPK  WRKINS1+4(9),WRKRCODE(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS1+4(8),0(R15)\n         MVI   WRKINS1+4+8,C' '\n         MVC   WRKINS2(4),=AL2(4+8,#MSG0132)\n         UNPK  WRKINS2+4(9),WRKREASN(5)\n         L     R15,=A(HEXTABLE-C'0')\n         TR    WRKINS2+4(8),0(R15)\n         MVI   WRKINS2+4+8,C' '\n         LHI   R0,3                Message Contains 3 Segments\n         L     R1,=A(#MSG013)      A(Informational Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         LA    R3,WRKINS2          A(Insert #2)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n         B     READEXIT\n\n*-------\n*        TERMINATE                                                    *\n*-------\nREADEXIT DS    0H\n         FREE  DDN=WRKDDPDE        Free Any Allocated Data Set\n\n         #RESTORE ,                Restore All Registers\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Replace The Entire Table                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nREPTABLE #SAVE ,                   Save All Registers\n         LHI   R15,0               Set Return Code\n\n         XC    WRKTAB@,WRKTAB@     Clear Previous Table Address\n         L     R5,WRKTAB@@         A(Current Table Address Address)\n         L     R6,WRKTABL@         A(Current Table Length Address)\n         ICM   R14,15,0(R5)        A(Current Table)\n         BZ    REPT0100            B. If No Previous Table\n         ST    R14,WRKTAB@         Save Old Table Address\n\n*-------\n*        Acquire A New Table And Anchor It In The LWA\n*-------\nREPT0100 DS    0H\n         #CALL AUTH                Get Into Supervisor State, Key Zero\n         BNZ   REPTEXIT            B. If Not Authorized\n\n         SLR   R2,R2               Clear New Table Address\n         SLR   R3,R3\n         ICM   R3,3,WRKTEMPL       L(Replacement Table)\n         BZ    REPT0200            B. If No New Table\n\n         GETMAIN RU,LV=(R3),SP=252,LOC=BELOW\n         ST    R1,WRKAUTH@         Save Authorized Table Address\n         LR    R2,R1\n         STH   R3,WRKAUTHL         Save Authorized Table Length\n\n         L     R4,WRKTEMP@         A(New Table Address)\n         #MVCL (R1),(R4),LEN=(R3)  Copy New Table To Authorized Storage\n\n         ST    R2,0(,R5)           Save New Table Address\n         STH   R3,0(,R6)           Save New Table Length\n\n         L     R14,WRKLWA@         A(LWA)\n         USING LWA,R14\n\n         MVC   LWAPRMLB,WRKPRMLB   Reset //STEPLIB Flags In LWA\n         OC    LWAVFLGS,WRKVFLGS   Ensure \"LOADED\" Flag Is On\n\n         DROP  R14\n\n*-------\n*        Release The Old Table's Storage If A Length Was Available\n*-------\nREPT0200 DS    0H\n         ICM   R1,15,WRKTAB@       A(Previous Table)\n         BZ    REPT0300            B. If No Previous Table\n         SLR   R0,R0\n         ICM   R0,3,WRKTABL        A(Previous Table Length)\n         BZ    REPT0300            B. If No Previous Table\n         FREEMAIN RU,A=(1),LV=(0),SP=252\n\nREPT0300 DS    0H\n         #CALL DEAUTH              Return To Original State & Key\n\n         LHI   R15,0               Set Return Code\n\nREPTEXIT #RESTORE R15=(R15)        Restore All Registers\n\n         LTR   R15,R15             Set Condition Code\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Save Current Keyword's Operand                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\nSAVEKW   #SAVE ,                   Save All Registers\n         XC    WRKDATAL,WRKDATAL   Initialize Operand Length\n         MVC   WRKDATA,BLANKS      Initialize Operand Value\n\n         ICM   R2,15,0(R1)         A(NAME)\n         BZ    SAVE0900            B. If Not Available\n         ICM   R3,3,4(R1)          L(NAME)\n         BZ    SAVE0900            B. If Not Available\n         STH   R3,WRKDATAL         Save Operand Length\n         #EXEC -R3,MVC,WRKDATA(*-*),0(R2)\n         B     SAVEEXIT\n\nSAVE0900 DS    0H\n         LHI   R0,2                Message Contains 2 Segments\n         L     R1,=A(#MSG006)      A(Error Message)\n         LA    R2,WRKINS1          A(Insert #1)\n         OI    WRKFLAG,$ERROR      Force Message To Be Written\n         #CALL PUTLINE             Write Message\n\nSAVEEXIT #RESTORE ,                Restore All Registers\n\n         TM    WRKDATA,X'BF'       Check If A Name Exists\n         BR    R14                 Return To Caller\n         POP   USING\n\nLWATMGR  LOCTR ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic Work Area                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #STARTWA PATCH=NO\n\n         DYNSPACE ,                Dynamic Allocation Area\n         DS    XL256               In Case Of Overflow\n\n         IEFPRMLB MF=(L,WRKPRMPL)\nPUTLINEL PUTLINE MF=L              PUTLINE Parameter List\n         READ  DECB,SF,*-*,*-*,'S',MF=L\n\nWRKCALL  CALL  ,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),VL,MF=L\nWRKLINK@ DS    A                   ISPLINK ROUTINE ADDRESS\n\nBLANKS   DS    CL80                Initialized Blanks\n\nWRKDBL   DS    D\nWRKECB   DS    F                   ECB\nWRKECT@  DS    A                   ECT Address\nWRKUPT@  DS    A                   UPT Address\n\nWRKVFLGS DS    X                   LWAVFLGS\nWRKFLAG  DS    X                   General Flag Byte\n$SUPER   EQU   X'80'               - Entered In Supervisor State\n$APF     EQU   X'40'               - Module Is APF Authorized\n$SETSUP  EQU   X'20'               - Changed To Supervisor State\n$SETKEY0 EQU   X'10'               - Changed To Key Zero\n$MSG_NF  EQU   X'08'               - Issue \"Not Found\" Message\n$MSG_F   EQU   X'04'               - Issue \"Found\" Message\n$ERROR   EQU   X'02'               - This Is An Error Message\n$EDITTAB EQU   X'01'               - Table Specified For EDIT\n\nWRKOPSWK DS    X                   Original PSW Key\n\n         CNOP  0,4\nWRKINS1  DS    AL2,AL2,CL80        PUTLINE Message Insert #1\nWRKINS2  DS    AL2,AL2,CL80        PUTLINE Message Insert #2\nWRKINS3  DS    AL2,AL2,CL80        PUTLINE Message Insert #3\nWRKINS4  DS    AL2,AL2,CL80        PUTLINE Message Insert #4\nWRKINS5  DS    AL2,AL2,CL80        PUTLINE Message Insert #5\nWRKINS6  DS    AL2,AL2,CL80        PUTLINE Message Insert #6\n\nWRKIOPL  DS    4F                  IOPL\nWRKLWA@  DS    A                   LWA Address\nWRKOLD   DS    F                   Number Of Message Segments\n         DS    A                   A(Message Text)\n         DS    A                   A(Message Insert 1)\n         DS    A                   A(Message Insert 2)\n         DS    A                   A(Message Insert 3)\n         DS    A                   A(Message Insert 4)\n         DS    A                   A(Message Insert 5)\n         DS    A                   A(Message Insert 6)\n\nWRKPPL   DS    7F                  PPL\nWRKPDL1  DS    A                   PDL\nWRKPDL2  DS    A                   PDL (IKJTSOxx Section Parse)\n\nWRKKW@   DS    A                   Keyword Matching Found Table\n\nWRKDDPDE DS    A,AL2,CL8           DD Name PDE\nWRKDDN   EQU   WRKDDPDE+6,8        DD Name\nWRKDSPDE DS    A,AL2,CL46          Data Set Name PDE\nWRKDSN   EQU   WRKDSPDE+6,46       Data Set Name\nWRKMNPDE DS    A,AL2,CL8           Member Name PDE\nWRKMEMNM EQU   WRKMNPDE+6,8        Member Name\n\nWRKZDSN  DS    CL44                ISPF Message DSName\nWRKUPDTE DS    C                   Edit Performed Update (Y/N)\nWRKSEL1  DS    C                   ISPF Selection Option\nWRKSEL2  DS    C                   ISPF Selection Option\nWRKSEL3  DS    C                   ISPF Selection Option\nWRKSEL4  DS    C                   ISPF Selection Option\n\n         CNOP  0,4\nWRKCMDNL DS    AL2                 IKJTSOxx Section Command Length\nWRKCMDNM DS    CL8                 IKJTSOxx Section Command\n\nWRKCMD@  DS    A                   IKJTSOxx Buffer Section Start\nWRKCMDE@ DS    A                   IKJTSOxx Buffer Section End\n\nWRKCBUF@ DS    A                   Command Buffer Address\nWRKCBUFL DS    F                   Command Buffer Length\n\nWRKR13   DS    F                   Register 13 Save Area\nWRKR14   DS    F                   Register 14 Save Area\nWRKR15   DS    F                   Register 15 Save Area\n\nWRKREASN DS    F                   IEFPRMLB Reason Code\nWRKRCODE DS    F                   IEFPRMLB Return Code\nWRKBUFF@ DS    A                   IEFPRMLB Return Buffer Address\nWRKBUFFL DS    F                   IEFPRMLB Return Buffer Length\nWRKMSGB@ DS    A                   IEFPRMLB Returned Message Buffer\nWRKMSGBL DS    F                   IEFPRMLB Returned Message Buffer Len\nWRKMSGBE DS    A                   End Of Buffer\n\nWRKCURB@ DS    A                   Current Buffer Address\nWRKCURBL DS    F                   Remaining Buffer Length\n\nWRKPARM@ DS    A                   First Parmlib Record Address\nWRKPARM# DS    F                   Number Of Parmlib Records Returned\n\nWRKDATAL DS    AL2                 Current Keyword's Operand Length\nWRKDATA  DS    CL80                Current Keyword's Operand\nWRKNAMEL DS    AL2                 Current Command/Program Name Length\nWRKNAME  DS    CL8                 Current Command/Program Name\nWRKNAMEO DS    A                   Current Entry's Offset In Table\nWRKNEWNL DS    AL2                 New Command/Program Name Length\nWRKNEWN  DS    CL8                 New Command/Program Name\nWRKTMPNL DS    AL2                 Save Area For NAME Length\nWRKTMPN  DS    CL8                 Save Area For NAME\n\nWRKTABNL DS    AL2                 Current Table Name Length\nWRKTABNM DS    CL8                 Current Table Name\nWRKTAB@@ DS    A                   Current Table Address Pointer\nWRKTAB@  DS    A                   Current Table Address\nWRKTABCT DS    F                   Current Command List Count\nWRKTABE@ DS    A                   Current Table End Address\nWRKTABPK DS    X                   Current Table PSW Key\nWRKTABF  DS    X                   Current Table Flags\nWRK$STEP EQU   X'80'   1... ....   Table Was Loaded From //STEPLIB\nWRKTABEL DS    AL2                 Current Table Entry Length\nWRKTABX@ DS    A                   Current Table End Address\nWRKTABL@ DS    A                   Current Table LWA Length Address\nWRKTABL  DS    AL2                 Current Table LWA Length\n\nWRKTEMP@ DS    A                   Temporary KEY8 Table Address\nWRKTEMPL DS    H                   Temporary KEY8 Table Length\n\nWRKAUTH@ DS    A                   New KEY0 Table Address\nWRKAUTHL DS    H                   New KEY0 Table Length\n\nWRKPRMLB DS    X                   Original LWAPRMLB Value\n\n         CNOP  0,4\nWRKDCB   DS    CL(MODCBUL)         DCB\n         CNOP  0,4\nWRKDCBE  DS    CL(MODCBEUL)        DCBE\n         CNOP  0,4\nWRKOPEN  DS    CL(MODOPENL)        OPEN Parameter List\n         CNOP  0,4\nWRKCLOSE DS    CL(MODCLOSEL)       CLOSE Parameter List\n         CNOP  0,4\nWRKLOAD  DS    XL(MODLOADL)        LOAD Parameter List\n\nWRKDCBBU DS    A                   DCB Buffer Address\nWRKDCBBE DS    A                   DCB Buffer End Address\n\nWRKLOAD@ DS    A                   Directed Load Buffer Address\nWRKLOADL DS    F                   Directed Load Buffer Length\n\nWRKBLDL  DS    0H\nWRKBLDE# DS    H                   Number Of Entries In List\nWRKBLDEL DS    H                   Length Of Entries In List\nWRKBLDLI DS    XL58                Returned Directory Information\nWRKBLDLL EQU   *-WRKBLDL           BLDL Parameter List Length\n\nWRKMOD@  DS    A                   Loaded Module Address\nWRKMODL  DS    H                   Loaded Module Length\n\nWRKTAPP@ DS    A                   IKJEFTAP Table Pointer Address\nWRKTAPL@ DS    A                   IKJEFTAP Table Length Address\nWRKTAPL  DS    AL2                 IKJEFTAP Table Length In LWA\nWRKTAPF  DS    C                   IKJEFTAP Flags\n         DS    X\n\nWRKTE2P@ DS    A                   IKJEFTE2 Table Pointer Address\nWRKTE2L@ DS    A                   IKJEFTE2 Table Length Address\nWRKTE2L  DS    AL2                 IKJEFTE2 Table Length In LWA\nWRKTE2F  DS    C                   IKJEFTE2 Flags\n         DS    X\n\nWRKTE8P@ DS    A                   IKJEFTE8 Table Pointer Address\nWRKTE8L@ DS    A                   IKJEFTE8 Table Length Address\nWRKTE8L  DS    AL2                 IKJEFTE8 Table Length In LWA\nWRKTE8F  DS    C                   IKJEFTE8 Flags\n         DS    X\n\nWRKTNSP@ DS    A                   IKJEFTNS Table Pointer Address\nWRKTNSL@ DS    A                   IKJEFTNS Table Length Address\nWRKTNSL  DS    AL2                 IKJEFTNS Table Length In LWA\nWRKTNSF  DS    C                   IKJEFTNS Flags\n         DS    X\n\nDCBEXIT@ DS    F                   DCB Open Exit Pointer\nWDCBEXIT DS    CL(STUBLEN)         24-Bit DCB Open Exit Stub\n\nSTACK15  DS    F                   Stack Save Area\nSTACKNX@ DS    A                   Next Save Area On The Stack\nSTACKEND DS    A                   End Of Stack Address\nSTACK    DS    (10*16)F            Register Save Area Stack\nSTACKLEN EQU   *-STACK             Length Of Save Area Stack\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Command Parameters                                           *\n*                                                                     *\n*     Syntax:                                                         *\n*                                                                     *\n*        LWATMGR ADD                                                  *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }           *\n*               NAME(command/program)                                 *\n*                                                                     *\n*        LWATMGR BUILD                                                *\n*               LIST(dataset(member))                                 *\n*                                                                     *\n*        LWATMGR DELETE                                               *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }           *\n*               NAME(command/program)                                 *\n*                                                                     *\n*        LWATMGR DISPLAY                                              *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }     *\n*                                                                     *\n*        LWATMGR RELOAD                                               *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }     *\n*               LOADLIB(dataset)                                      *\n*                                                                     *\n*        LWATMGR REPLACE                                              *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND }           *\n*               NAME(command/program)                                 *\n*               NEWNAME(command/program)                              *\n*                                                                     *\n*        LWATMGR UPDATE                                               *\n*             { AUTHTSF  | AUTHCMD  | AUTHPGM  | NOTBKGND | ALL }     *\n*               PARMLIB(dataset(member))                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PRINT NOGEN\n\nPCL      IKJPARM DSECT=MAINPCL\n\nFUNCKW   IKJKEYWD DEFAULT='DISPLAY'\n         IKJNAME 'ADD',ALIAS='ANY'\n$ADD     EQU   1\n         IKJNAME 'BUILD'\n$BUILD   EQU   2\n         IKJNAME 'DELETE'\n$DELETE  EQU   3\n         IKJNAME 'DISPLAY'\n$DISPLAY EQU   4\n         IKJNAME 'RELOAD'\n$RELOAD  EQU   5\n         IKJNAME 'REPLACE'\n$REPLACE EQU   6\n         IKJNAME 'UPDATE'\n$UPDATE  EQU   7\n\nALLKW    IKJKEYWD ,\n         IKJNAME 'ALL',INSERT='IKJEFTAP IKJEFTE2 IKJEFTE8 IKJEFTNS'\nAPKW     IKJKEYWD ,\n         IKJNAME 'IKJEFTAP',ALIAS=('TAP','AUTHTSF')\n$AUTHTSF EQU   1\nE2KW     IKJKEYWD ,\n         IKJNAME 'IKJEFTE2',ALIAS=('TE2','AUTHCMD')\n$AUTHCMD EQU   1\nE8KW     IKJKEYWD ,\n         IKJNAME 'IKJEFTE8',ALIAS=('TE8','AUTHPGM')\n$AUTHPGM EQU   1\nNSKW     IKJKEYWD ,\n         IKJNAME 'IKJEFTNS',ALIAS=('TNS','NOTBKGND')\n$NOTBKGND EQU  1\n\nNAMEKW   IKJKEYWD ,\n         IKJNAME 'NAME',SUBFLD=NAMESUBF\n\nNEWCMDKW IKJKEYWD ,\n         IKJNAME 'NEWNAME',SUBFLD=NEWSUBF\n\nPARMLKW  IKJKEYWD ,\n         IKJNAME 'PARMLIB',                                            *\n               SUBFLD=PARMSUBF\n$PARMLIB EQU   1\n\nLOADKW   IKJKEYWD ,\n         IKJNAME 'LOADLIB',                                            *\n               SUBFLD=LOADSUBF\n\nREC8KW   IKJKEYWD ,\n         IKJNAME 'LIST',                                               *\n               SUBFLD=REC8SUBF\n\nNOMSGSKW IKJKEYWD ,\n         IKJNAME 'NOMESSAGES',ALIAS='NOMSG'\n$NOMSGS  EQU   1\n\nNAMESUBF IKJSUBF  ,\nNAME     IKJIDENT 'NAME',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,         *\n               PROMPT='Command Or Program Name'\n\nNEWSUBF  IKJSUBF  ,\nNEWNAME  IKJIDENT 'NEWNAME',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,      *\n               PROMPT='New Command Or Program Name'\n\nPARMSUBF IKJSUBF  ,\nPARMLIB  IKJPOSIT DSNAME,USID,UPPERCASE,                               *\n               PROMPT='IKJTSOXX Input Data Set'\n\nLOADSUBF IKJSUBF  ,\nLOADLIB  IKJPOSIT DSNAME,USID,UPPERCASE,                               *\n               PROMPT='IKJTABLS Load Library'\n\nREC8SUBF IKJSUBF  ,\nREC8     IKJPOSIT DSNAME,USID,UPPERCASE,                               *\n               PROMPT='Table List Data Set'\n\n         IKJENDP ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IKJTSOXX Statements                                          *\n*                                                                     *\n*        Syntax:                                                      *\n*                                                                     *\n*        AUTHCMD  NAMES(...LIST...)                                   *\n*        AUTHPGM  NAMES(...LIST...)                                   *\n*        NOTBKGND NAMES(...LIST...)                                   *\n*        AUTHTSF  NAMES(...LIST...)                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nPARMPCL  IKJPARM DSECT=TSOXXPCL\n\nNAMESKW  IKJKEYWD ,\n         IKJNAME 'NAMES',SUBFLD=LISTSUBF\n\nLISTSUBF IKJSUBF  ,\nLIST     IKJIDENT 'NAME',LIST,                                         *\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,                   *\n               PROMPT='Command Or Program Name'\n\n         IKJENDP ,\n\n         PRINT GEN\n\n         IKJEFLWA ,                LOGON Work Area\n\n         IEFZPMAP ,                IEFPRMLB Parameter List\n         IEFZPRC ,                 IEFPRMLB Return Codes\n\n         IHAPDS ,                  PDS / PDSE Directory Entry\n         IHARLD ,                  Linkage Editor Records\n         IHADCBE ,                 Data Control Block Extension\n\n         #DSECTS ALLOC,ASCB,ASXB,CVT,DCB,PSA,TSO\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACLIB": {"ttr": 9480, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x19 \\x9f\\x01\\x19 \\x9f\\x141>)>)\\x00\\x00\\xe7\\xd4\\xc9\\xe3\\xc6\\xd4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-28T00:00:00", "modifydate": "2019-07-28T14:31:43", "lines": 15913, "newlines": 15913, "modlines": 0, "user": "XMITFMT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MPFCOLOR": {"ttr": 16129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12'\\x00\\x98\\x00\\x98\\x00\\x01\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:27:00", "lines": 152, "newlines": 152, "modlines": 1, "user": "SOURCE"}, "text": "MPFCOLOR TITLE '- CHANGE MESSAGE COLOR'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    SIMPLE MPF EXIT TO CHANGE THE COLOR (COLOUR FOR CANADIANS)    *\n*    OF AN INDIVIDUAL MESSAGE.  SYS1.PARMLIB(MPFLST00) SYNTAX:     *\n*                                                                  *\n*        IEF404I,SUP(NO),USEREXIT(MPFCOLOR),AUTO(RED)              *\n*                                                                  *\n*------------------------------------------------------------------*\n*        #DD03310 - ADD DELETABLE/NON-DELETABLE OPTION             *\n*------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nMPFCOLOR #START ,                  START PROCEDURE                     *\n               AMODE=CAP31,        EXECUTE IN 31-BIT ADDRESSING MODE   *\n               RMODE=ANY,          EXECUTE IN ANY RESIDENCY MODE       *\n               BASE=(R12),         DEFINE BASE REGISTER(S)             *\n               REG1=(R1),          DEFINE PARAMETER REGISTER           *\n               LEVEL=#V001R02      MAINTENANCE LEVEL\n\n         L     R5,0(0,R1)          LOAD PARAMETER LIST ADDRESS\n         USING CTXT,R5\n         LA    R6,CTXTAUTT         A(AUTO TOKEN)\n\n*---------------------------------------------------------------------*\n*        CHECK \"AUTO\" TOKEN DELTABLE/NON-DELETABLE REQUEST.           *\n*        - DELETABLE WILL BE DESCRIPTOR CODE 0.                       *\n*        - NON-DELETALE WILL BE DESCRIPTOR CODE 2.                    *\n*---------------------------------------------------------------------*\n         CLI   CTXTAUTT,C'+'       MAKE NON-DELETABLE ?        #DD03310\n         BNE   MPF00100            B. IF NOT                   #DD03310\n         LA    R6,1(,R6)           SKIP OVER \"+\"               #DD03310\n         OI    CTXTRFB1,CTXTRCDC   REQUEST DESC. CODE CHANGE   #DD03310\n         L     R15,CTXTDCP         POINT TO DESCRIPTOR CODES   #DD03310\n         USING CTXTDESC,R15                                    #DD03310\n         MVI   CTXTDC1,CTXTDC02    CHANGE TO DESC=02           #DD03310\n         MVI   CTXTDC2,0                                       #DD03310\n         DROP  R15                                             #DD03310\n         B     MPF00200            CONTINUE                    #DD03310\n\nMPF00100 DS    0H                                              #DD03310\n         CLI   CTXTAUTT,C'-'       MAKE DELETABLE ?            #DD03310\n         BNE   MPF00200            B. IF NOT                   #DD03310\n         LA    R6,1(,R6)           SKIP OVER \"-\"               #DD03310\n         OI    CTXTRFB1,CTXTRCDC   REQUEST DESC. CODE CHANGE   #DD03310\n         L     R15,CTXTDCP         POINT TO DESCRIPTOR CODES   #DD03310\n         USING CTXTDESC,R15                                    #DD03310\n         MVI   CTXTDC1,0           CHANGE TO DESC=00           #DD03310\n         MVI   CTXTDC2,0                                       #DD03310\n         DROP  R15                                             #DD03310\n         B     MPF00200            CONTINUE                    #DD03310\n\n*---------------------------------------------------------------------*\n*        CHECK \"AUTO\" TOKEN FIELD FOR COLOR CHANGE REQUEST            *\n*---------------------------------------------------------------------*\nMPF00200 DS    0H\n         LA    R3,COLORTAB         A(START OF COLOR TABLE)\nMPF00300 DS    0H\n         CLI   0(R3),255           CHECK FOR END OF TABLE\n         BE    MPF00500            B. IF YES\n         CLC   0(7,R6),0(R3)       CHECK FOR MATCHING TOKEN    #DD03010\n         BE    MPF00400            B. IF SAME\n         LA    R3,9(,R3)           A(NEXT ENTRY IN TABLE)\n         B     MPF00300            KEEP SEARCHING\n\nMPF00400 DS    0H\n         OI    CTXTERF1,CTXTEMCO   REQUEST COLOR CHANGE\n         MVC   CTXTCOLR,8(R3)      COPY REQUESTED OPTION\n         B     MPFCEXIT\n\n*---------------------------------------------------------------------*\n*        CHECK \"AUTO\" TOKEN FIELD FOR HIGHLIGHTING CHANGE REQUEST     *\n*---------------------------------------------------------------------*\nMPF00500 DS    0H\n         LA    R3,HILITTAB         A(START OF HILIGHT TABLE)\nMPF00600 DS    0H\n         CLI   0(R3),255           CHECK FOR END OF TABLE\n         BE    MPF00800            B. IF YES\n         CLC   0(7,R6),0(R3)       CHECK FOR MATCHING TOKEN    #DD03010\n         BE    MPF00700            B. IF SAME\n         LA    R3,9(,R3)           A(NEXT ENTRY IN TABLE)\n         B     MPF00600            KEEP SEARCHING\n\nMPF00700 DS    0H\n         OI    CTXTERF1,CTXTEMHI   REQUEST HILIGHT CHANGE\n         MVC   CTXTHILI,8(R3)      COPY REQUESTED OPTION\n         B     MPFCEXIT\n\n*---------------------------------------------------------------------*\n*        CHECK \"AUTO\" TOKEN FIELD FOR INTENSITY CHANGE REQUEST        *\n*---------------------------------------------------------------------*\nMPF00800 DS    0H\n         LA    R3,INTENTAB         A(START OF INTENSITY TABLE)\nMPF00900 DS    0H\n         CLI   0(R3),255           CHECK FOR END OF TABLE\n         BE    MPFCEXIT            B. IF YES\n         CLC   0(7,R6),0(R3)       CHECK FOR MATCHING TOKEN    #DD03010\n         BE    MPF01000            B. IF SAME\n         LA    R3,9(,R3)           A(NEXT ENTRY IN TABLE)\n         B     MPF00900            KEEP SEARCHING\n\nMPF01000 DS    0H\n         OI    CTXTERF1,CTXTEMIN   REQUEST INTENSITY CHANGE\n         MVC   CTXTINTN,8(R3)      COPY REQUESTED OPTION\n\n*---------------------------------------------------------------------*\n*        TERMINATE                                                    *\n*---------------------------------------------------------------------*\nMPFCEXIT #STOP RC=0                TERMINATE (ALWAYS RETURN CODE 0)\n\n*---------------------------------------------------------------------*\n*        OPTION TABLES                                                *\n*---------------------------------------------------------------------*\n\nCOLORTAB DS    0H\n         DC    CL8'BLUE    ',AL1(CTXTBLUE)\n         DC    CL8'RED     ',AL1(CTXTRED)\n         DC    CL8'PINK    ',AL1(CTXTPINK)\n         DC    CL8'GREEN   ',AL1(CTXTGREE)\n         DC    CL8'TURQ    ',AL1(CTXTTURQ)\n         DC    CL8'YELLOW  ',AL1(CTXTYELO)\n         DC    CL8'WHITE   ',AL1(CTXTWHIT)\n         DC    9X'FF'\n\nHILITTAB DS    0H\n         DC    CL8'NONE    ',AL1(CTXTNOHI)\n         DC    CL8'BLINK   ',AL1(CTXTBLNK)\n         DC    CL8'REVERSE ',AL1(CTXTREVD)\n         DC    CL8'UNDERLI ',AL1(CTXTUNDR)\n         DC    9X'FF'\n\nINTENTAB DS    0H\n         DC    CL8'NORMAL  ',AL1(CTXTINOR)\n         DC    CL8'HIGH    ',AL1(CTXTIHIG)\n         DC    9X'FF'\n\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n\n         IEZVX100 ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MPFEXITS": {"ttr": 16133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x00F\\x00F\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 70, "newlines": 70, "modlines": 0, "user": "SOURCE"}, "text": "MPFEXITS TITLE '- MPFEXITS - Display Loaded MPF Exits'\nMPFEXITS #START ,                  Start Procedure                     *\n               AMODE=31,           Execute In 31-Bit AMode             *\n               RMODE=24,           Execute In 24-Bit RMode             *\n               BASE=RELATIVE,      Generate Baseless Code              *\n               CONSTANT=R12,       Base For Constants                  *\n               COPY=YES,                                               *\n               WKDSECT=WRKAREA,    Set WorkArea Name                   *\n               LOC=BELOW,          Indicate 24-Bit Workarea Storage    *\n               LEVEL=**TOOL**      Maintenance Level           #DD13234\n         USING PSA,0\n\n         L     R5,FLCCVT           A(CVT)\n         USING CVT,R5\n         ICM   R5,15,CVTCUCB       A(UCM)\n         BZ    MPFLEXIT\n         USING UCM,R5\n         ICM   R5,15,UCMBFEXT\n         BZ    MPFLEXIT\n         USING UCMFEXTA,R5\n         ICM   R5,15,UCMFMPFP      A(MPF Table)\n         BZ    MPFLEXIT\n         USING MPFT,R5\n         SLR   R6,R6\n         ICM   R6,3,MPFTNENM       #(Elements In MPF Exit Table)\n         BZ    MPFLEXIT            B. If None\n         ICM   R5,15,MPFTMENP      A(1st Element Of Exit Table)\n         BZ    MPFLEXIT\n         USING MPFMENTY,R5\nLOOP     DS    0H\n         MVC   INSERT1,MPFMNAME\n         UNPK  INSERT2(9),MPFMADDR(5)\n         TR    INSERT2(8),HEXTABLE\n         MVI   INSERT2+8,C')'\n         UNPK  INSERT3(9),MPFMLEN(5)\n         TR    INSERT3(8),HEXTABLE\n         MVI   INSERT3+8,C')'\n         UNPK  INSERT4(9),MPFMEPA(5)\n         TR    INSERT4(8),HEXTABLE\n         MVI   INSERT4+8,C')'\n\n         LA    R2,MESSAGE\n         LHI   R3,L'MESSAGE\n         TPUT  (R2),(R3)\n\n         AHI   R5,MPFTENTY_LEN     A(Next Element In Exit Table)\n         BRCT  R6,LOOP             Process All Table Entries\n\nMPFLEXIT #STOP ,                   Return To Caller\n\n         #CON  START               Beginning Of Constants\n         #EXEC ,\n         LTORG ,\nMESSAGE  DC    C'________ ADDR(________) LEN(________) EPA(________) '\nINSERT1  EQU   MESSAGE+00,8        INSERT ADDRESS/LENGTH\nINSERT2  EQU   MESSAGE+14,8        INSERT ADDRESS/LENGTH\nINSERT3  EQU   MESSAGE+28,8        INSERT ADDRESS/LENGTH\nINSERT4  EQU   MESSAGE+42,8        INSERT ADDRESS/LENGTH\nHEXTABLE DC    256X'00'\n         ORG   HEXTABLE+C'0'\n         DC    C'0123456789ABCDEF'\n         ORG   ,\n         #CON  END                 End Of Constants\n\n         #STARTWA ,                Beginning Of WorkArea\n         #STOPWA ,                 End Of WorkArea\n\n         IEEZB809 ,\n         #DSECTS CVT,UCM,PSA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PACKMAP": {"ttr": 16135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x08\\x1f\\x08\\x1f\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 2079, "newlines": 2079, "modlines": 0, "user": "SOURCE"}, "text": "PACKMAP  TITLE '- PACKMAP -  DASD VOLUME MAPPING UTILITY'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n***********************************************************************\n*                     *                                               *\n*   P A C K M A P     *                                               *\n*                     *                                               *\n***********************                                               *\n*                                                                     *\n*   FUNCTION :        PRODUCE DATASET/FREESPACE EXTENT LIST FOR       *\n*                     ANY DASD VOLUME                                 *\n*                                                                     *\n*   REGISTER USAGE :   R0 - WORK REGISTER                             *\n*                      R1 - WORK REGISTER                             *\n*                      R2 - WORK REGISTER                             *\n*                      R3 - WORK REGISTER                             *\n*                      R4 - WORK REGISTER                             *\n*                      R5 - WORK REGISTER                             *\n*                      R6 - WORK REGISTER                             *\n*                      R7 - WORK REGISTER                             *\n*                      R8 - WORK REGISTER                             *\n*                      R9 - WORK REGISTER                             *\n*                     R10 - WORK REGISTER                             *\n*                     R11 - BASE                                      *\n*                     R12 - BASE                                      *\n*                     R13 - SAVE AREA                                 *\n*                     R14 - RETURN ADDRESS                            *\n*                     R15 - RETURN CODE                               *\n*                                                                     *\n*   MACROS USED :     MANY                                            *\n*                                                                     *\n*   CONTROL BLOCK :   IECSDSL1 - DSCB DESCRIPTIONS                    *\n*   DEPENDENCIES      DCBD     - DCB MAP                              *\n*                     ICVAFBFL - CVAF BUFFER MAP                      *\n*                     ICVAFPL  - CVAF PARAMETER LIST                  *\n*                     IEZDEB   - DEB MAP                              *\n*                     IEFJFCBN - JFCB MAP                             *\n*                     IHAPSA   - PSA MAP                              *\n*                     IEFTIOT1 - TIOT MAP                             *\n*                     IEFUCBOB - UCB MAP                              *\n*                                                                     *\n*   ABEND CODES :     U100 - DISK DD STATEMENT NOT SUPPLIED           *\n*                     U200 - INSUFFICIENT STORAGE TO CONTINUE         *\n*                                                                     *\n*   ATTRIBUTES :      AUTHORIZED                                      *\n*                                                                     *\n*   ROUTINES CALLED : MSGRTN - MESSAGE FORMATING SUBROUTINE           *\n*                     HEXDUMP  - FORMAT HEX DUMP OUTPUT               *\n*                     GETFMT5  - FORMAT5.DSCB TABLE SUBROUTINE        *\n*                     SORTRTN  - TABLE SORT SUBROUTINE                *\n*                                                                     *\n*   MESSAGES ISSUED :  PAK0001I *** VTOC ERRORS EXIST ON VOLSER ***   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   HISTORY :         MAY/82 - #DD82130 - INITIAL INSTALL             *\n*                     APR/88 - #DD88103 - 3380K SUPPORT               *\n*                   APR/2001 - #DD01097 - CLEANUP ASSEMBLY ERRORS.    *\n*                   MAR/2012 - #DD12062 - ADD EAV SUPPORT.            *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\n         MACRO ,\n&NAME    FMTMSG\n.**********************************************************************\n.*                             FMTMSG                                 *\n.*                             --------                               *\n.* FUNCTION:                                                          *\n.*       CREATE A VARIABLE LENGTH CHARACTER STRING FOR INPUT TO       *\n.*       MSGRTN.                                                      *\n.*                                                                    *\n.* OUTPUT FORMAT:                                                     *\n.*                                                                    *\n.* NAME   DS   0CLXXX                                                 *\n.*        DC   AL1(LENGTH)                                            *\n.* LABEL  DC   CLN'TEXT'                                              *\n.* LABEL  DC   NNC' '                                                 *\n.*        DC   C'TEXT'                                                *\n.*        DC   NNNC' '                                                *\n.*                                                                    *\n.*                                                                    *\n.* THE OPERANDS ARE IN FORMAT 'TEXT' OR (LABEL,'TEXT') OR             *\n.* (LABEL,'C',M) WHERE 'C' IS ONE CHAR AND M IS THE MULTPLCATN FACTOR *\n.* (LABEL,'TEXT',L) WHERE 'TEXT' IS GT 1 CHAR AND L IS THE LENGTH     *\n.* DESIRED FOR THE FIELD (TO BE PADDED OR TRUNCATED IN DC CL_'TEXT' ) *\n.*   ANY NUMBER OF SEPARATE OPERANDS MAY BE SPECIFIED ON THE          *\n.* MACRO CALL PROTOTYPE STMT. SOME EXAMPLES FOLLOW                    *\n.* LABEL FMTMSG 'IEA001',(ID,' ',1),(,' ',20),'***',(MSG,'****',80)   *\n.* WILL GENERATE FOLLOWING PARAMETER LISTS AND CONSTANTS              *\n.* LABEL DS    0CL111                                                 *\n.*       DC    AL1(110)       LENGTH OF TOTAL    MSG                  *\n.*       DC    C'IEA001'      FIRST OPERAND                           *\n.* ID    DC    1C' '          SECOND OPERAND                          *\n.*       DC    20C' '         THIRD OPERAND                           *\n.*       DC    C'***'          FOURTH OPERAND                         *\n.* MSG   DC    CL80'***'       FIFTH OPERAND                          *\n.**********************************************************************\n         LCLC  &LBL   LABEL VARIABLE\n         LCLA  &N1,&CNT,&LEN\n         LCLC  &TEMP1\n&CNT     SETA  1              . COUNT IS ONE\n&LEN     SETA  0              . TOTAL LEN IS 0\n&N1      SETA  N'&SYSLIST          . NUMBER OPERANDS\n.LOOP1   ANOP\n.* THIS LOOP ADDS UP ALL THE STRING LENGTHS\n         AIF   (N'&SYSLIST(&CNT) NE 1).SUBS1\n.* IF SUBSCRIPTED IE 'TEXT' AS OPPOSED (LABL,'TEXT') SKIP\n&LEN     SETA  &LEN+K'&SYSLIST(&CNT)-2 .    ADD LENGTH\n         AGO   .COUNT\n.SUBS1   ANOP\n         AIF   (T'&SYSLIST(&CNT,3) EQ 'O').SUBS3\n.* IF THIRD SUBSET IS OMITTED USE LENGTH OF SECOND OPERAND\n&LEN     SETA  &LEN+&SYSLIST(&CNT,3)  . ADD GIVEN LENGTH\n         AGO   .COUNT\n.SUBS3   ANOP\n&LEN     SETA  &LEN+K'&SYSLIST(&CNT,2)-2 . ELSE USE LENGTH STRING 2\n.COUNT   ANOP\n&CNT     SETA  &CNT+1   . ADD ONE TO COUNT OF OPERANDS\n         AIF   ('&CNT' LE '&N1').LOOP1\n&LEN     SETA  &LEN+1     .   ADD 1 FOR LENGTH BYTE\n&NAME    DS    0CL&LEN\n&LEN     SETA  &LEN-1      .  SUBTRACT 1 FOR LENGTH BYTE\n         DC    AL1(&LEN)                LENGTH OF MESSAGE\n&CNT     SETA  0              . START AT BEGINNING\n.LOOP2   ANOP\n.* THIS LOOP GENERATES DEFINE CONSTANTS FOR FIELDS GIVEN\n&CNT     SETA  &CNT+1         . ADD ONE\n&LBL     SETC  ' '     . SET LABEL BLANK\n.NOSETL  AIF   (N'&SYSLIST(&CNT) GT 1).SUBS4\n.* IF MORE THAN 1 FIELD PROCESS AS SUCH\n&LEN     SETA  K'&SYSLIST(&CNT)-2    . GET LENGTH OF STRING\n&TEMP1   SETC  '&SYSLIST(&CNT)'         .  AND SET TEXT\n         AGO   .GENLINE\n.SUBS4   ANOP\n&LBL     SETC  '&SYSLIST(&CNT,1)' . GENERATE LABEL\n&LEN     SETA  K'&SYSLIST(&CNT,2)-2   . SET LENGTH OF STRING\n&TEMP1   SETC  '&SYSLIST(&CNT,2)'   . GET CHAR STRING\n         AIF   (T'&SYSLIST(&CNT,3) EQ 'O').SUBS5\n&LEN     SETA  &SYSLIST(&CNT,3)   . GET LENGTH/MULT FACTOR\n.* IF NO LENGTH OR MULT FACTOR GIVEN PROCESS\n.SUBS5   AIF   (K'&SYSLIST(&CNT,2) NE 3).GENLINE\n.* IF MORE THAN 1 CHAR LOG PROCESS AS LENGTH\n&LBL     DC    &LEN.C&TEMP1\n         AGO   .INCR2\n.SUBS6   ANOP\n.* NO LENGTH OR MULT FACTOR GIVEN SET LENGTH OF TEXT\n&LEN     SETA  K'&SYSLIST(&CNT,2)-2   . SET LENGTH OF STRING\n.GENLINE ANOP\n.* GENERATE ASSEMBLER DEFINE FOR TEXT\n&LBL     DC    CL&LEN.&TEMP1\n.INCR2   ANOP\n         AIF   ('&CNT' LT '&N1').LOOP2\n         AGO   .MEND\n.MEND    ANOP\n         MEND\n\nPACKMAP  #START ,                                                      *\n               AMODE=CAP24,                                            *\n               APARS=,                                                 *\n               BASE=(R12,R11),                                         *\n               WKDSECT=MAP,                                            *\n               COPY=YES,                                               *\n               LEVEL=#V001R03                                  #DD12062\n         USING PSA,0\n         TITLE '- PACKMAP -  INITIALIZATION'\n*---------------------------------------------------------------------*\n*        INITIALIZE ALL LIST FORM MACROS AND LOAD HEX FORMAT RTN      *\n*---------------------------------------------------------------------*\n         MVC   RDJFCB(1),=AL1(128)          OPTION BYTE\n         MVC   ENQL(1),=AL1(192)            OPTION BYTE\n         MVC   OPENLIST(1),=AL1(128)        OPTION BYTE\n         WXTRN HEXDUMP\n         ICM   R0,15,=V(HEXDUMP)            CHECK IF HEXDUMP AVAILABLE\n         BNZ   START                        B. IF YES\n         LOAD  EP=HEXDUMP,ERRET=VTOC0000    LOAD HEXDUMP RTN\nSTART    DS    0H\n         ST    R0,HEXRTN                    SAVE HEXDUMP ADDR\n         LA    R1,HEXPARM+4                 POINT TO HEX PARMS\n         ST    R1,HEXPARM                   SAVE PARM ADDRESS\n         TITLE '- PACKMAP -  TIOT AND JFCB CHECKS'\n*---------------------------------------------------------------------*\n*        CHECK THE TIOT AND SETUP THE JFCB TO READ THE FORMAT4        *\n*---------------------------------------------------------------------*\nVTOC0000 DS    0H\n         L     R1,PSATOLD                   >>--> TCB\n         L     R1,TCBTIO-TCB(R1)            >>--> TIOT\n         LA    R1,TIOENTRY-TIOT1(R1)        SKIP TIOT HEADER\nVTOC0100 DS    0H\n         CLC   VTOCDCB+DCBDDNAM-IHADCB(8),TIOEDDNM-TIOENTRY(R1)\n         BE    VTOC0200\n         SLR   R0,R0                        CLEAR REGISTER\n         IC    R0,TIOELNGH-TIOENTRY(R1)     INSERT ENTRY LENGTH\n         ALR   R1,R0                        POINT TO NEXT ENTRY\n         CLI   TIOELNGH-TIOENTRY(R1),0      CHECK FOR TIOT END\n         BNE   VTOC0100                     IF NOT CHECK ENTRY\n         B     ERROR001                     IF NOT FOUND ERROR\nVTOC0200 DS    0H\n         MVC   DDNAME(8),VTOCDCB+DCBDDNAM-IHADCB\n         MVC   WRKDEVT,MODDEVT                                 #DD12062\n         LA    R2,DDNAME                                       #DD12062\n         DEVTYPE (R2),                  GET DEVICE TYPE.       #DD12062*\n               (DVAREA,DVAREAL),                               #DD12062*\n               INFOLIST=INFOLIST,                              #DD12062*\n               MF=(E,WRKDEVT)                                  #DD12062\n         SLR   R0,R0                                           #DD88103\n         SLR   R1,R1                                           #DD88103\n         ICM   R1,3,DVACYL         LOAD # OF CYLS ON VOLUME    #DD12062\n         SLR   R2,R2                                           #DD88103\n         ICM   R2,3,DVATRK         LOAD # OF TRKS ON CYLINDER  #DD12062\n         MR    R0,R2               CALC # OF TRKS ON VOLUME    #DD88103\n         BCTR  R1,0                SUBTRACT 1 FOR TRACK ZERO   #DD88103\n         ST    R1,LASTTRK                   SAVE LAST TRK ADDR\n         MVC   TRKCYL(2),DVATRK             COPY TRKS PER CYL  #DD12062\n         RDJFCB (VTOCDCB),MF=(E,RDJFCB)     READ THE JFCB\n         MVC   VTOCJFCB+JFCBDSNM-INFMJFCB(44),FMT4DSNM\n         MVC   VOLSER1(6),VTOCJFCB+JFCBVOLS-INFMJFCB\n         MVC   VOLSER2(6),VTOCJFCB+JFCBVOLS-INFMJFCB\n         MVC   VOLSER3(6),VTOCJFCB+JFCBVOLS-INFMJFCB\n         TITLE '- PACKMAP -  OPEN ROUTINE'\n*---------------------------------------------------------------------*\n*        OPEN THE VTOC AND SAVE THE DEB AND UCB ADDRESSES             *\n*---------------------------------------------------------------------*\n         OPEN  (VTOCDCB,INPUT),TYPE=J,MF=(E,OPENLIST)\n         TM    VTOCDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BNO   ERROR001                     IF NOT OPEN ERROR\n         L     R1,VTOCDCB+DCBDEBAD-IHADCB   LOAD DEB ADDRESS\n         L     R1,DEBSUCBA-DEBBASIC(R1)     LOAD UCB ADDRESS\n         ST    R1,@UCB             SAVE UCB ADDRESS\n         UNPK  UCB1(5),UCBCHAN-UCBOB(3,R1)                     #DD99204\n         TR    UCB1(4),TRTABLE1-C'0'                           #DD99204\n         MVI   UCB1+4,C' '                                     #DD99204\n         MVC   UCB2,UCB1              COPY DEVICE NUMBER       #DD99183\n         TITLE '- PACKMAP -  HEADING INITIALIZATION'\n*---------------------------------------------------------------------*\n*        SET UP THE REPORT HEADING                                    *\n*---------------------------------------------------------------------*\n         #DATE DATE1,FORMAT='MMM DD,CCYY'   PUT DATE IN TITLE\n         MVC   DATE2,DATE1                  COPY THE DATE\n         TIME  DEC                          GET SYSTEM TIME\n         ST    R0,DBL                       SAVE THE TIME\n         MVC   TIME1(9),=X'4021207A20207A2020'\n         ED    TIME1(9),DBL                 INSERT INTO TITLE\n         MVC   TIME2(9),TIME1               COPY TIME\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#TITLE,MSGWORD,TITLE,HEADING1),VL,MF=(E,CALLL)\n         TITLE '- PACKMAP -  FORMAT 5 DSCB ROUTINE'\n*---------------------------------------------------------------------*\n*        GET FREESPACE TABLE                                          *\n*---------------------------------------------------------------------*\n         L     R15,=A(GETFMT5)     A(FORMAT 5 EXTRACT RTN)     #DD99183\n         CALL  (15),(VTOCDCB),VL,MF=(E,CALLL)\n         LTR   R15,R15                      CHECK RETURN CODE\n         BNZ   ERROR003                     IF ERROR REPORT IT\n         ST    R1,FREESPCE                  SAVE FREESPACE ADDR\n         TITLE '- PACKMAP -  GET VTOC TABLE'\n*---------------------------------------------------------------------*\n*        GET STORAGE SPACE TO HOLD VTOC INFO                          *\n*---------------------------------------------------------------------*\nVTOC0600 DS    0H\n         GETMAIN VU,LA=TAB1SIZE,A=TAB1ADDR,MF=(E,GETMAINL)\n         L     R2,TAB1ADDR                  LOAD START ADDR\n         L     R5,TAB1ADDR+4                LOAD STORAGE LENGTH\n         #BLANK 0(R2),LEN=(R5),PAD=X'00'    CLEAR THE STORAGE\n         L     R4,TAB1SIZE                  LOAD RECORD LENGTH\n         LA    R5,0(R5,R2)                  LOAD END   ADDR\n         ST    R5,TAB1ADDR+4                SAVE END ADDRESS\n         TITLE '- PACKMAP -  VOLUME RESERVATION'\n*---------------------------------------------------------------------*\n*        GET EXCLUSIVE CONTROL OF THE VTOC IF RUNNING BATCH           *\n*---------------------------------------------------------------------*\n         TESTAUTH FCTN=1,STATE=YES,RBLEVEL=1                   #DD88103\n         LTR   R15,R15             CHECK IF AUTHORIZED         #DD88103\n         BNZ   VTOC0700            B. IF NOT                   #DD88103\n         MVC   RNAME(6),VOLSER1             ENQ ON THIS VOLSER\n         RESERVE (QNAME,RNAME,E,6,SYSTEMS),RET=HAVE,UCB=@UCB,          X\n               MF=(E,ENQL)\n         TITLE '- PACKMAP -  READ THE VTOC'\n*---------------------------------------------------------------------*\n*        READ THE VTOC AND SAVE ALL THE RELEVENT INFORMATION          *\n*---------------------------------------------------------------------*\nVTOC0700 DS    0H\n         SLR   R3,R3                        CLEAR COUNTER\n         USING DSCBTAB,R2\nVTOC0800 DS    0H\n         LR    R1,R2                        COPY TABLE ADDRESS\n         LA    R1,144(,R1)                  POINT PAST ENTRY\n         C     R1,TAB1ADDR+4                CHECK FOR END\n         BNL   ERROR002                     IF NO ROOM ERROR\n         LR    R6,R2                        COPY TABLE ADDRESS\n         LA    R6,4(,R6)                    MAKE ROOM FOR TTR0\n         MVI   IOERROR,0                    CLEAR IO ERROR FLAG\n         READ  READECB,SF,VTOCDCB,(R6),MF=(E,READL)\n         CHECK READECB                      WAIT FOR THE I/O\n         CLI   IOERROR,0                    CHECK FOR I/O ERROR\n         BE    VTOC0900                     IF OK CONTINUE\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR6MSG,ERR7MSG,BLANKLNE),         X\n               VL,MF=(E,CALLL)\n         #SETRC 8                           SET RETURN CODE\n         B     VTOC0800                     KEEP ON READING\nVTOC0900 DS    0H\n         CLI   DS1FMTID,X'00'               CHECK FOR FORMAT0\n         BNE   VTOC1000                     IF NOT SKIP\n         LA    R3,1(,R3)                    ADD 1 TO FREE COUNT\n         B     VTOC0800                     CONTINUE READING\nVTOC1000 DS    0H\n         CLI   DS1FMTID,C'1'                CHECK FOR FORMAT1\n         BNE   VTOC1100                     IF NOT KEEP CHECKIN\n         CLI   DS1NOEPV,X'00'               CHECK EXTENT COUNT\n         BNE   VTOC1400                     IF SOME PROCESS\n         MVC   ERR5DSN,DS1DSNAM\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR5MSG,BLANKLNE),                 X\n               VL,MF=(E,CALLL)\n         B     VTOC0800                     SKIP THIS DSCB\nVTOC1100 DS    0H\n         CLI   DS2FMTID,C'2'                CHECK FOR FORMAT2\n         BE    VTOC1400                     IF MATCH KEEP\n         CLI   DS3FMTID,C'3'                CHECK FOR FORMAT3\n         BE    VTOC1400                     IF MATCH KEEP\n         CLI   DS4IDFMT,C'4'                CHECK FOR FORMAT4\n         BNE   VTOC1200                     IF NOT CHECK NEXT\n         MVC   CCHH(4),DS4VTOCE+2           POINT TO START CCHH\n         BAL   R10,CCHHTOTT                 CONVERT TO TT\n         MVC   VTOCTT(4),TT                 SAVE START TT\n         ST    R6,HEXPARM+4                 SAVE START ADDRESS\n         LA    R1,139(,R6)                  POINT TO END\n         ST    R1,HEXPARM+8                 SAVE END ADDRESS\n         NOTE  VTOCDCB                      GET RELATIVE TTR0\n         MVC   HEXIN(4),DS4VTOCE+2          COPY CCHH\n         STCM  R1,B'0010',HEXIN+4           SAVE RECORD NUMBER\n         LA    R1,5                         LOAD FIELD LENGTH\n         BAL   R10,HEXFORM                  CONVERT TO CHAR\n         MVC   HEXKEYWD(31),=C'FORMAT4.DSCB AT   CCCCHHHHRR = '\n         MVC   HEXKEYWD+18(10),HEXOUT       COPY CONVERTED CCHHR\n         LA    R1,HEXPARM                   POINT TO PARM FIELD\n         BAL   R10,HEXDUMPR                 PRINT RECORD IN HEX\n         B     VTOC1400                     SAVE FORMAT4 INFO\nVTOC1200 DS    0H\n         CLI   DS5FMTID,C'5'                CHECK FOR FORMAT5\n         BE    VTOC0800                     IF SO SKIP IT\n         CLI   DS6FMTID,C'6'                CHECK FOR FORMAT6\n         BNE   VTOC1300                     IF NOT SKIP\n         ST    R6,HEXPARM+4                 SAVE START ADDRESS\n         LA    R1,139(,R6)                  POINT TO END\n         ST    R1,HEXPARM+8                 SAVE END ADDRESS\n         NOTE  VTOCDCB                      GET RELATIVE TTR0\n         XC    TT,TT                        CLEAR TT\n         STCM  R1,B'1100',TT+2              SAVE TT\n         STCM  R1,B'0010',HEXIN+4           SAVE RECORD NUMBER\n         L     R1,TT                        LOAD RELATIVE TT\n         A     R1,VTOCTT                    ADD VTOC CCHH\n         ST    R1,TT                        SAVE REAL TT\n         BAL   R10,TTTOCCHH                 CONVERT TO CCHH\n         MVC   HEXIN(4),CCHH                COPY CCHH\n         LA    R1,5                         LOAD FIELD LENGTH\n         BAL   R10,HEXFORM                  CONVERT TO CHAR\n         MVC   HEXKEYWD(31),=C'FORMAT6.DSCB AT   CCCCHHHHRR = '\n         MVC   HEXKEYWD+18(10),HEXOUT       COPY CONVERTED CCHHR\n         LA    R1,HEXPARM                   POINT TO PARM FIELD\n         BAL   R10,HEXDUMPR                 PRINT RECORD IN HEX\n         #SETRC 4                           SET RETURN CODE\n         B     VTOC0800                     CONTINUE READING\nVTOC1300 DS    0H\n         ST    R6,HEXPARM+4                 SAVE START ADDRESS\n         LA    R1,139(,R6)                  POINT TO END\n         ST    R1,HEXPARM+8                 SAVE END ADDRESS\n         NOTE  VTOCDCB                      GET RELATIVE TTR0\n         XC    TT,TT                        CLEAR TT\n         STCM  R1,B'1100',TT+2              SAVE TT\n         STCM  R1,B'0010',HEXIN+4           SAVE RECORD NUMBER\n         L     R1,TT                        LOAD RELATIVE TT\n         A     R1,VTOCTT                    ADD VTOC CCHH\n         ST    R1,TT                        SAVE REAL TT\n         BAL   R10,TTTOCCHH                 CONVERT TO CCHH\n         MVC   HEXIN(4),CCHH                COPY CCHH\n         LA    R1,5                         LOAD FIELD LENGTH\n         BAL   R10,HEXFORM                  CONVERT TO CHAR\n         MVC   HEXKEYWD(31),=C'UNKNOWN DSCB AT   CCCCHHHHRR = '\n         MVC   HEXKEYWD+18(10),HEXOUT       COPY CONVERTED CCHHR\n         LA    R1,HEXPARM                   POINT TO PARM FIELD\n         BAL   R10,HEXDUMPR                 PRINT RECORD IN HEX\n         #SETRC 4                           SET RETURN CODE\n         B     VTOC0800                     CONTINUE READING\nVTOC1400 DS    0H\n         NOTE  VTOCDCB                      GET RELATIVE TTR0\n         ST    R1,DSCBTAB                   SAVE TTR0\n         BXLE  R2,R4,VTOC0800               LOOP TILL END\n         B     ERROR002                     TERMINATE\n         TITLE '- PACKMAP -  VOLUME RELEASING'\n*---------------------------------------------------------------------*\n*        RELEASE CONTROL OF VTOC IF RUNNING BATCH                     *\n*---------------------------------------------------------------------*\nVTOC1500 DS    0H\n         TESTAUTH FCTN=1,STATE=YES,RBLEVEL=1                   #DD88103\n         LTR   R15,R15             CHECK IF AUTHORIZED         #DD88103\n         BNZ   VTOC1600            B. IF NOT                   #DD88103\n         DEQ   (QNAME,RNAME,6,SYSTEMS),RET=HAVE,MF=(E,ENQL)\n         TITLE '- PACKMAP -  FREE UNUSED VTOC TABLE'\n*---------------------------------------------------------------------*\n*        FREE THE UNUSED STORAGE SPACE                                *\n*---------------------------------------------------------------------*\nVTOC1600 DS    0H\n         ST    R2,TAB1ADDR+4                SAVE LAST ADDRESS\n         SR    R5,R2                        CALC UNUSED SPACE\n         FREEMAIN R,A=(R2),LV=(R5)          FREE UNUSED STORAGE\n         TITLE '- PACKMAP -  GET EXTENT TABLE'\n*---------------------------------------------------------------------*\n*        CREATE EXTENT TABLE                                          *\n*---------------------------------------------------------------------*\nVTOC1700 DS    0H\n         GETMAIN VU,LA=TAB2SIZE,A=TAB2ADDR,MF=(E,GETMAINL)\n         L     R2,TAB2ADDR                  LOAD START ADDR\n         L     R5,TAB2ADDR+4                LOAD STORAGE LENGTH\n         #BLANK 0(R2),LEN=(R5),PAD=X'00'    CLEAR THE STORAGE\n         LA    R5,0(R5,R2)                  LOAD END   ADDR\n         ST    R5,TAB2ADDR+4                SAVE END ADDRESS\n         L     R2,TAB1ADDR                  LOAD START ADDRESS\n         SLR   R3,R3                        CLEAR COUNTER\n         L     R4,TAB1SIZE                  LOAD RECORD LENGTH\n         L     R5,TAB1ADDR+4                LOAD END ADDRESS\n         SR    R5,R4                        BACKUP 1 RECORD\n         L     R6,TAB2ADDR                  LOAD START ADDR\n         USING EXTABLE,R6\n         TITLE '- PACKMAP -  FILL THE EXTENT TABLE'\n*---------------------------------------------------------------------*\n*        FILL THE EXTENT TABLE                                        *\n*---------------------------------------------------------------------*\nVTOC1800 DS    0H\n         CLI   DS1FMTID,C'1'                CHECK FOR FORMAT1\n         BNE   VTOC3800                     IF NOT TRY NEXT\n         MVC   TEMPDSN,DS1DSNAM             SAVE THE DSNAME\n         MVC   EXTENTS(1),DS1NOEPV          SAVE TOTAL EXTENTS\n         XC    EXTENTNO,EXTENTNO            CLEAR THE COUNTER\n         TM    DS1DSORG,DS1DSGPS            CHECK FOR \"PS\"\n         BNO   VTOC1900                     IF NOT CONTINUE\n         MVC   EXDSORG(2),=C'PS'            INSERT DSORG\n         B     VTOC2400                     CHECK FOR \"XXU\"\nVTOC1900 DS    0H\n         TM    DS1DSORG,DS1DSGPO            CHECK FOR \"PO\"\n         BNO   VTOC2000                     IF NOT CONTINUE\n         MVC   EXDSORG(2),=C'PO'            INSERT DSORG\n         B     VTOC2400                     CHECK FOR \"XXU\"\nVTOC2000 DS    0H\n         TM    DS1DSORG,DS1DSGDA            CHECK FOR \"DA\"\n         BNO   VTOC2100                     IF NOT CONTINUE\n         MVC   EXDSORG(2),=C'DA'            INSERT DSORG\n         B     VTOC2400                     CHECK FOR \"XXU\"\nVTOC2100 DS    0H\n         TM    DS1DSORG,DS1DSGIS            CHECK FOR \"IS\"\n         BNO   VTOC2200                     IF NOT CONTINUE\n         MVC   EXDSORG(2),=C'IS'            INSERT DSORG\n         B     VTOC2400                     CHECK FOR \"XXU\"\nVTOC2200 DS    0H\n         TM    DS1DSORG+1,DS1ORGAM          CHECK FOR \"AM\"\n         BNO   VTOC2300                     IF NOT CONTINUE\n         MVC   EXDSORG(2),=C'AM'            INSERT DSORG\n         B     VTOC2400                     CHECK FOR \"XXU\"\nVTOC2300 DS    0H\n         MVC   EXDSORG(2),=C'??'            INSERT DSORG\nVTOC2400 DS    0H\n         TM    DS1DSORG,DS1DSGU             CHECK FOR \"XXU\"\n         BNO   VTOC2500                     IF NOT CONTINUE\n         MVI   EXDSORG+2,C'U'               FLAG AS UNMOVABLE\nVTOC2500 DS    0H\n         LA    R1,EXRECFM                   POINT TO RECFM\n         TM    DS1RECFM,X'C0'               CHECK FOR RECFM = U\n         BNO   VTOC2600                     IF NOT CONTINUE\n         MVI   0(R1),C'U'                   INSERT RECFM\n         LA    R1,1(,R1)                    ADVANCE POINTER\n         B     VTOC2900                     CONTINUE\nVTOC2600 DS    0H\n         TM    DS1RECFM,X'80'               CHECK FOR RECFM = F\n         BNO   VTOC2700                     IF NOT CONTINUE\n         MVI   0(R1),C'F'                   INSERT RECFM\n         LA    R1,1(,R1)                    ADVANCE POINTER\n         B     VTOC2800                     CONTINUE\nVTOC2700 DS    0H\n         TM    DS1RECFM,X'40'               CHECK FOR RECFM = V\n         BNO   VTOC2800                     IF NOT CONTINUE\n         MVI   0(R1),C'V'                   INSERT RECFM\n         LA    R1,1(,R1)                    ADVANCE POINTER\nVTOC2800 DS    0H\n         TM    DS1RECFM,X'10'               CHECK IF BLOCKED\n         BNO   VTOC2900                     IF NOT CONTINUE\n         MVI   0(R1),C'B'                   INSERT BLOCKED FLAG\n         LA    R1,1(,R1)                    ADVANCE POINTER\nVTOC2900 DS    0H\n         TM    DS1RECFM,X'20'               CHECK FOR TRK OVFLO\n         BNO   VTOC3000                     IF NOT CONTINUE\n         MVI   0(R1),C'T'                   INSERT TRK OVF FLAG\n         LA    R1,1(,R1)                    ADVANCE POINTER\nVTOC3000 DS    0H\n         TM    DS1RECFM,X'08'               CHECK FOR SPAN/STD\n         BNO   VTOC3100                     IF NOT CONTINUE\n         MVI   0(R1),C'S'                   INSERT FLAG\n         LA    R1,1(,R1)                    ADVANCE POINTER\nVTOC3100 DS    0H\n         TM    DS1RECFM,X'04'               CHECK FOR ASA CNTL\n         BNO   VTOC3200                     IF NOT CONTINUE\n         MVI   0(R1),C'A'                   INSERT FLAG\n         LA    R1,1(,R1)                    ADVANCE POINTER\nVTOC3200 DS    0H\n         TM    DS1RECFM,X'02'               CHECK FOR MACHINE C\n         BNO   VTOC3300                     IF NOT CONTINUE\n         MVI   0(R1),C'M'                   INSERT FLAG\n         LA    R1,1(,R1)                    ADVANCE POINTER\nVTOC3300 DS    0H\n         SLR   R0,R0                                           #DD88103\n         ICM   R0,3,DS1LRECL                LOAD RECORD LEN    #DD88103\n         CVD   R0,DBL                       CONVERT\n         MVC   EXLRECL(6),=X'402020202120'  MOVE EDIT MASK\n         ED    EXLRECL(6),DBL+5             INSERT INTO OUTPUT\n         SLR   R0,R0                                           #DD88103\n         ICM   R0,3,DS1BLKL                 LOAD BLOCK LEN     #DD88103\n         CVD   R0,DBL                       CONVERT\n         MVC   EXBLKSIZ(6),=X'402020202120' MOVE EDIT MASK\n         ED    EXBLKSIZ(6),DBL+5            INSERT INTO OUTPUT\n         LA    R1,DS1EXT1                   POINT TO 1ST EXTENT\n         LA    R9,3                         SETUP FOR 3 EXTENTS\nVTOC3400 DS    0H\n         BAL   R10,EXTUPDAT                 PROCESS THIS EXTENT\n         LA    R1,10(,R1)                   POINT TO NEXT FIELD\n         BCT   R9,VTOC3400                  LOOP FOR FORMAT1\n         LR    R7,R2                        SAVE FORMAT1 ADDR\n         TM    DS1DSORG,DS1DSGIS            CHECK FOR ISAM DSN\n         BNO   VTOC3500                     IF NOT PROCEED\n         CLC   DS1VOLSQ(2),=X'0001'         CHECK FOR 1ST VOL\n         BNE   VTOC3500                     IF NOT PROCEED\n         MVC   DSCBTAB,=C'DONE'             FLAG AS PROCESSED\n         MVI   FORMATID,C'2'                PROCESS FORMAT2\n         CLC   DS1PTRDS(5),=X'0000000000'   CHECK FOR ZEROS\n         BE    ERROR004                     IF SO ERROR\n         MVC   CCHH(4),DS1PTRDS             COPY FORWARD PTR\n         BAL   R10,CCHHTOTT                 CONVERT TO TT\n         L     R8,TT                        LOAD THIS TT\n         S     R8,VTOCTT                    FIND RELATIVE TT\n         STCM  R8,3,CCHH                    SAVE RELATIVE TT   #DD88103\n         MVC   CCHH+2(1),DS1PTRDS+4         COPY R\n         MVI   CCHH+3,X'00'                 ASSURE ZEROS\n         L     R1,CCHH                      LOAD RECORD NUMBER\n         BAL   R10,FINDDSCB                 FIND THE FORMAT2\n         LTR   R15,R15                      CHECK RETURN CODE\n         BNZ   ERROR004                     IF NOT FOUND ERROR\n         CLI   DS2FMTID-DSCBTAB(R1),C'2'    CHECK FOR FORMAT2\n         BNE   ERROR005                     IF NOT ERROR\n         LR    R2,R1                        POINT TO FORMAT2\nVTOC3500 DS    0H\n         MVC   DSCBTAB,=C'DONE'             FLAG AS PROCESSED\n         CLC   DS1PTRDS(5),=X'0000000000'   CHECK FOR ZEROS\n         BE    VTOC3900                     IF SO QUIT PROCESS\n         MVI   FORMATID,C'3'                PROCESS FORMAT3\n         MVC   CCHH(4),DS1PTRDS             COPY FORWARD PTR\n         BAL   R10,CCHHTOTT                 CONVERT TO TT\n         L     R8,TT                        LOAD THIS TT\n         S     R8,VTOCTT                    FIND RELATIVE TT\n         STCM  R8,3,CCHH                    SAVE RELATIVE TT   #DD88103\n         MVC   CCHH+2(1),DS1PTRDS+4         COPY R\n         MVI   CCHH+3,X'00'                 ASSURE ZEROS\n         L     R1,CCHH                      LOAD RECORD NUMBER\n         BAL   R10,FINDDSCB                 FIND THE FORMAT3\n         LTR   R15,R15                      CHECK RETURN CODE\n         BNZ   ERROR004                     IF NOT FOUND ERROR\n         CLI   DS3FMTID-DSCBTAB(R1),C'3'    CHECK FOR FORMAT3\n         BNE   ERROR004                     IF NOT ERROR\n         LR    R2,R1                        POINT TO FORMAT3\n         LA    R1,DS3EXTNT                  POINT TO EXTENT\n         LA    R9,4                         SETUP FOR 4 EXTENTS\nVTOC3600 DS    0H\n         BAL   R10,EXTUPDAT                 PROCESS THIS EXTENT\n         LA    R1,10(,R1)                   POINT TO NEXT FIELD\n         BCT   R9,VTOC3600                  LOOP FOR FORMAT3\n         LA    R1,DS3ADEXT                  POINT TO EXTENT\n         LA    R9,9                         SETUP FOR 9 EXTENTS\nVTOC3700 DS    0H\n         BAL   R10,EXTUPDAT                 PROCESS THIS EXTENT\n         LA    R1,10(,R1)                   POINT TO NEXT FIELD\n         BCT   R9,VTOC3700                  LOOP FOR FORMAT3\n         B     VTOC3500\nVTOC3800 DS    0H\n         CLI   DS4IDFMT,C'4'                CHECK FOR FORMAT4\n         BNE   VTOC4000                     IF NOT TRY NEXT\n         MVC   EXTENTS(1),=X'01'            SET EXTENTS TO 1\n         XC    EXTENTNO,EXTENTNO            ZERO EXTENT NUMBER\n         MVC   TEMPDSN,=CL44'*** VTOC ***'  INSERT VTOC NAME\n         LA    R1,DS4VTOCE                  POINT TO EXTENT\n         BAL   R10,EXTUPDAT                 PROCESS THIS EXTENT\n         MVC   DSCBTAB,=C'DONE'             FLAG ENTRY AS DONE\n         B     VTOC4000                     SKIP EXTENT CHECK\nVTOC3900 DS    0H\n         LR    R2,R7                        RESTORE FMT1 ADDR\n         CLC   EXTENTS(1),EXTENTNO+3        COMPARE EXTENTS\n         BNE   ERROR006                     IF NOT ERROR\nVTOC4000 DS    0H\n         BXLE  R2,R4,VTOC1800               LOOP TILL END\n         TITLE '- PACKMAP -  CHECK FOR UNCHAINED DSCBS'\n*---------------------------------------------------------------------*\n*        CHECK FOR UNCHAINED DSCBS                                    *\n*---------------------------------------------------------------------*\n         L     R2,TAB1ADDR                  LOAD START ADDRESS\n         SLR   R3,R3                        CLEAR REGISTER\n         L     R4,TAB1SIZE                  LOAD ENTRY SIZE\n         L     R5,TAB1ADDR+4                LOAD END   ADDRESS\n         SR    R5,R4                        BACKUP TO LAST REC\nVTOC4100 DS    0H\n         CLC   DSCBTAB,=C'DONE'             WAS DSCB CHAINED\n         BE    VTOC4200                     IF SO CHECK NEXT\n         XC    TT,TT                        CLEAR TRACK AREA\n         MVC   TT+2(2),DSCBTAB              MOVE RELATIVE TRK\n         L     R1,TT                        LOAD RELATIVE TT\n         A     R1,VTOCTT                    ADD VTOC CCHH\n         ST    R1,TT                        SAVE REAL TT\n         BAL   R10,TTTOCCHH                 CONVERT TO CCHH\n         MVC   HEXIN(4),CCHH                MOVE TO HEX AREA\n         MVC   HEXIN+4(1),DSCBTAB+2         MOVE RELATIVE REC\n         LA    R1,5                         LOAD INPUT LENGTH\n         BAL   R10,HEXFORM                  CONVERT TO HEX\n         MVC   HEXKEYWD(31),=C'UNCHAINED DSCB AT CCCCHHHHRR = '\n         MVC   HEXKEYWD+18(10),HEXOUT       COPY CONVERTED CCHHR\n         LA    R1,4(,R2)                    POINT TO DSCB START\n         ST    R1,HEXPARM+4                 SAVE START ADDRESS\n         LA    R1,139(,R1)                  POINT TO DSCB END\n         ST    R1,HEXPARM+8                 SAVE END ADDRESS\n         LA    R1,HEXPARM                   POINT TO PARM FIELD\n         BAL   R10,HEXDUMPR                 PRINT RECORD IN HEX\n         #SETRC 4                           SET RETURN CODE\nVTOC4200 DS    0H\n         BXLE  R2,R4,VTOC4100               LOOP THROUGH TABLE\n         TITLE '- PACKMAP -  PROCESS FREESPACE EXTENTS'\n*---------------------------------------------------------------------*\n*        FILL IN THE FREESPACE EXTENTS                                *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',FREESPCE          LOAD FREESPACE TBL\n         BZ    VTOC4400                     IF NONE SKIP IT\n         SLR   R9,R9                        CLEAR REGISTER\n         ICM   R9,B'1111',0(R1)             LOAD EXTENT COUNT\n         BZ    VTOC4400                     IF NONE SKIP IT\n         STCM  R9,3,EXTENTS                 SAVE TOTAL EXTENTS #DD88103\n         XC    EXTENTNO,EXTENTNO            CLEAR EXTENT COUNT\n         LA    R3,4(,R1)                    POINT PAST COUNT\nVTOC4300 DS    0H\n         MVC   STRTRACK+2(2),0(R3)          INSERT START TRK\n         SLR   R0,R0                                           #DD88103\n         SLR   R1,R1                                           #DD88103\n         ICM   R1,3,2(R3)                   LOAD # OF CYLS     #DD88103\n         SLR   R2,R2                                           #DD88103\n         ICM   R2,3,TRKCYL                  LOAD # OF TRKS/CYL #DD88103\n         MR    R0,R2                        CALCULATE TO TRKS  #DD88103\n         SLR   R2,R2                        CLEAR REGISTER\n         IC    R2,4(R3)                     LOAD # OF TRKS\n         AR    R2,R1                        CALC LENGTH\n         ST    R2,EXTNTLEN                  INSERT EXTENT LEN\n         BCTR  R2,R0                        DECREMENT FOR TRK 0\n         SLR   R0,R0                                           #DD88103\n         ICM   R0,3,0(R3)                   LOAD START TRACK   #DD88103\n         AR    R2,R0                        ADD START TRACK    #DD88103\n         ST    R2,ENDTRACK                  INSERT END TRK\n         MVC   TT,STRTRACK                  COPY START TRK\n         BAL   R10,TTTOCCHH                 CONVERT TO CCHH\n         MVC   STRTCCHH,CCHH                INSERT START CCHH\n         MVC   TT,ENDTRACK                  COPY END TRACK\n         BAL   R10,TTTOCCHH                 CONVERT TO CCHH\n         MVC   ENDCCHH,CCHH                 INSERT END   CCHH\n         L     R1,EXTENTNO                  LOAD OLD COUNT\n         LA    R1,1(,R1)                    ADD 1 TO COUNTER\n         ST    R1,EXTENTNO                  STORE NEW COUNT\n         ST    R1,EXTNTNO                   INSERT EXTENT NO.\n         MVC   TOTEXTNT+2(2),EXTENTS        INSERT TOTAL EXTENTS\n         MVC   EXDSNAME,=CL44'*** FREE SPACE ***'\n         LA    R3,5(,R3)                    ADVANCE TABLE\n         LA    R6,EXTNTEND                  ADVANCE TABLE\n         SLR   R1,R1                                           #DD88103\n         ICM   R1,3,TAB2CNT                 LOAD TOTAL COUNT   #DD88103\n         LA    R1,1(,R1)                    ADD 1 TO COUNT\n         STCM  R1,3,TAB2CNT                 SAVE TOTAL COUNT   #DD88103\n         BCT   R9,VTOC4300                  LOOP FOR EACH EXTNT\n         TITLE '- PACKMAP -  SORT THE TABLE'\n*---------------------------------------------------------------------*\n*        SORT THE EXTENT TABLE                                        *\n*---------------------------------------------------------------------*\nVTOC4400 DS    0H\n         ST    R6,TAB2ADDR+4                SAVE END ADDRESS\n         L     R2,TAB2ADDR                  LOAD START ADDRESS\n         L     R15,=A(SORTRTN)     A(SORT ROUTINE)             #DD99183\n         CALL  (15),(TAB2CNT,TAB2SIZE+2,SKEY,STYPE,(R2)),              X\n               VL,MF=(E,CALLL)\n         TITLE '- PACKMAP -  PRINT THE TABLE'\n*---------------------------------------------------------------------*\n*        PRINT THE EXTENT TABLE                                       *\n*---------------------------------------------------------------------*\n         L     R2,TAB2ADDR                  LOAD START ADDRESS\n         DROP  R6\n         USING EXTABLE,R2\n         SLR   R3,R3                        CLEAR COUNTER\n         L     R4,TAB2SIZE                  LOAD RECORD LENGTH\n         L     R5,TAB2ADDR+4                LOAD END ADDRESS\n         SR    R5,R4                        BACKUP 1 RECORD\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#TITLE,MSGWORD,TITLE,HEADING2,BLANKLNE,HEADING3,HEX\n               ADING4),VL,MF=(E,CALLL)\nVTOC4500 DS    0H\n         L     R1,PREVEND                   LOAD END OF PREVIOUS\n         LA    R1,1(,R1)                    ADD 1 TO END\n         C     R1,STRTRACK                  COMPARE WITH THIS DSN\n         BE    VTOC4700                     IF OK CONTINUE\n         BL    VTOC4600                     IF LOWER..MISSING\n         MVC   TRKERROR(30),=C'*** SHARED TRACKS ***         '\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR8MSG),VL,MF=(E,CALLL)\n         OI    FLAG,EXTNTERR                SET EXTENT ERROR FLAG\n         B     VTOC4700                     CONTINUE\nVTOC4600 DS    0H\n         MVC   TRKERROR(30),=C'*** MISSING TRACKS ***        '\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR8MSG),VL,MF=(E,CALLL)\n         OI    FLAG,EXTNTERR                SET EXTENT ERROR FLAG\nVTOC4700 DS    0H\n         L     R0,STRTRACK                  LOAD START TRACK\n         CVD   R0,DBL                       CONVERT\n         OI    DBL+7,X'0F'                  CHANGE SIGN\n         UNPK  RSTRT(5),DBL                 INSERT INTO OUTPUT\n         L     R0,ENDTRACK                  LOAD END   TRACK\n         CVD   R0,DBL                       CONVERT\n         OI    DBL+7,X'0F'                  CHANGE SIGN\n         UNPK  REND(5),DBL                  INSERT INTO OUTPUT\n         L     R0,EXTNTLEN                  LOAD EXTENT LENGTH\n         CVD   R0,DBL                       CONVERT\n         MVC   LEN+1(6),=X'402020202120'    MOVE EDIT MASK\n         ED    LEN+1(6),DBL+5               INSERT INTO OUTPUT\n         L     R0,EXTNTNO                   LOAD EXTENT NUMBER\n         CVD   R0,DBL                       CONVERT\n         MVC   EXNO(4),=X'40202120'         MOVE EDIT MASK\n         ED    EXNO(4),DBL+6                INSERT INTO OUTPUT\n         L     R0,TOTEXTNT                  LOAD TOTAL EXTENTS\n         CVD   R0,DBL                       CONVERT\n         MVC   HEXIN(6),=X'402021204040'    MOVE EDIT MASK\n         ED    HEXIN(4),DBL+6               EDIT TOTAL EXTENTS\n         CLI   HEXIN+1,C' '                 CHECK FOR BLANK\n         BE    VTOC4800                     IF SO TRY NEXT\n         MVC   EXTOT(3),HEXIN+1             INSERT INTO OUTPUT\n         B     VTOC5000                     PROCEED\nVTOC4800 DS    0H\n         CLI   HEXIN+2,C' '                 CHECK FOR BLANK\n         BE    VTOC4900                     IF NOT TRY NEXT\n         MVC   EXTOT(3),HEXIN+2             INSERT INTO OUTPUT\n         B     VTOC5000                     PROCEED\nVTOC4900 DS    0H\n         MVC   EXTOT(3),HEXIN+3             INSERT INTO OUTPUT\nVTOC5000 DS    0H\n         MVC   DSN(44),EXDSNAME\n         MVC   HEXIN(4),STRTCCHH            MOVE START CCHH\n         LA    R1,4                         LOAD FIELD LENGTH\n         BAL   R10,HEXFORM                  CONVERT TO CHAR\n         MVC   STCCCHH+1(3),HEXOUT+1        INSERT CCC\n         MVC   STCCCHH+5(2),HEXOUT+6        INSERT HH\n         MVC   HEXIN(4),ENDCCHH             MOVE START CCHH\n         LA    R1,4                         LOAD FIELD LENGTH\n         BAL   R10,HEXFORM                  CONVERT TO CHAR\n         MVC   ENDCCCHH+1(3),HEXOUT+1       INSERT CCC\n         MVC   ENDCCCHH+5(2),HEXOUT+6       INSERT HH\n         OC    EXDSORG(20),=20C' '          ASSURE UPPER CASE\n         MVC   PRDSORG(3),EXDSORG           INSERT DSORG\n         MVC   PRRECFM(5),EXRECFM           INSERT RECFM\n         MVC   PRLRECL(6),EXLRECL           INSERT LRECL\n         MVC   PRBLKSIZ(6),EXBLKSIZ         INSERT BLOCKSIZE\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,PRINTLNE),VL,MF=(E,CALLL)\n         CLC   LASTTRK,ENDTRACK             CHECK FOR EOV\n         BNL   VTOC5100                     IF NOT OVER SKIP\n         TM    FLAG,SIZEERR                 CHECK FOR PREVIOUS\n         BO    VTOC5100                     PROCEED\n         MVC   TRKERROR(30),=C'*** EXTENDS PAST EOV ***      '\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR8MSG),VL,MF=(E,CALLL)\n         OI    FLAG,SIZEERR                 SET EOV FLAG\nVTOC5100 DS    0H\n         CLC   ENDTRACK,PREVEND             COMPARE ENDS\n         BNH   VTOC5200                     IF NOT HIGHER SKIP\n         MVC   PREVEND,ENDTRACK             COPY NEW END\nVTOC5200 DS    0H\n         BXLE  R2,R4,VTOC4500               LOOP TILL END\n         CLC   LASTTRK,ENDTRACK             CHECK FOR EOV\n         BNL   VTOC5300                     IF SO PROCEED\n         MVC   TRKERROR(30),=C'*** MISSING TRACKS ***        '\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR8MSG),VL,MF=(E,CALLL)\n         OI    FLAG,EXTNTERR                SET EXTENT ERROR FLAG\nVTOC5300 DS    0H\n         TM    FLAG,VTOCERRS                CHECK FOR ANY ERRORS\n         BNO   VTOC5400                     IF NONE TERMINATE\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#WTO,MSGWORD,WTOL2,ERR9MSG),VL,MF=(E,CALLL)\n         #SETRC 8                           SET RETURN CODE\nVTOC5400 DS    0H\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,BLANKLNE,ENDLINE),                 X\n               VL,MF=(E,CALLL)\n         #STOP ,\n         TITLE '- PACKMAP -  PROCESS ERRORS'\n*---------------------------------------------------------------------*\n*        PROCESS ANY ERRORS THAT MAY OCCUR                            *\n*---------------------------------------------------------------------*\nERROR001 DS    0H\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#WTO,MSGWORD,WTOL1,ERR1MSG),VL,MF=(E,CALLL)\n         LA    R2,100                       SET ABEND CODE\n         B     ABEND                        ABNORMALLY TERMINATE\nERROR002 DS    0H\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR10MSG),VL,MF=(E,CALLL)\n         LA    R2,200                       SET ABEND CODE\n         B     ABEND                        TERMINATE ABNORMALLY\nERROR003 DS    0H\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR3MSG,BLANKLNE),                 X\n               VL,MF=(E,CALLL)\n         OI    FLAG,SPACEERR                SET FREESPACE FLAG\n         B     VTOC0600                     CONTINUE PROCESS\nERROR004 DS    0H\n         MVC   ERR2DSN,TEMPDSN              COPY DATASET NAME\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR2MSG,BLANKLNE),                 X\n               VL,MF=(E,CALLL)\n         #SETRC 4                           SET CONDITION CODE\n         B     VTOC3900                     CONTINUE PROCESS\nERROR005 DS    0H\n         MVC   ERR2DSN,TEMPDSN              COPY DATASET NAME\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR2MSG,BLANKLNE),                 X\n               VL,MF=(E,CALLL)\n         #SETRC 4                           SET CONDITION CODE\n         B     VTOC3500                     CONTINUE PROCESS\nERROR006 DS    0H\n         MVC   ERR4DSN,TEMPDSN              COPY DATASET NAME\n         SLR   R0,R0                        CLEAR REGISTER\n         IC    R0,EXTENTS                   LOAD TOTAL EXTENTS\n         CVD   R0,DBL                       CONVERT\n         OI    DBL+7,X'0F'                  CHANGE SIGN\n         UNPK  ERR4EX1(3),DBL               INSERT INTO OUTPUT\n         SLR   R0,R0                        CLEAR REGISTER\n         L     R0,EXTENTNO                  LOAD FOUND EXTENTS\n         CVD   R0,DBL                       CONVERT\n         OI    DBL+7,X'0F'                  CHANGE SIGN\n         UNPK  ERR4EX2(3),DBL               INSERT INTO OUTPUT\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,ERR4MSG,BLANKLNE),                 X\n               VL,MF=(E,CALLL)\n         #SETRC 4                           SET CONDITION CODE\n         B     VTOC4000                     CONTINUE PROCESS\nABEND    ABEND (R2)\n         TITLE '- PACKMAP -  SUBRTN - CCHH >>--->> TTR'\n*---------------------------------------------------------------------*\n*        CONVERT CCHH TO RELATIVE TRACK ADDRESS                       *\n*---------------------------------------------------------------------*\nCCHHTOTT DS    0H\n         STM   R0,R15,SAVEREG2              SAVE ALL REGS      #DD88103\n         SLR   R0,R0                                           #DD88103\n         SLR   R1,R1                                           #DD88103\n         ICM   R1,3,CCHH                    LOAD CC            #DD88103\n         SLR   R2,R2                                           #DD88103\n         ICM   R2,3,TRKCYL                  LOAD TRKS/CYL      #DD88103\n         MR    R0,R2                        CONVERT TO TRACKS  #DD88103\n         SLR   R0,R0                                           #DD88103\n         ICM   R0,3,CCHH+2                  LOAD TT            #DD88103\n         AR    R1,R0                        CALC TOTAL TRKS    #DD88103\n         ST    R1,TT                        SAVE RELATIVE TT\n         LM    R0,R15,SAVEREG2              RESTORE ALL REGS   #DD88103\n         BR    R10                          RETURN TO CALLER\n         TITLE '- PACKMAP -  SUBRTN - TTR >>--->> CCHH'\n*---------------------------------------------------------------------*\n*        CONVERT RELATIVE TRACK ADDRESS TO CCHH                       *\n*---------------------------------------------------------------------*\nTTTOCCHH DS    0H\n         STM   R0,R15,SAVEREGS              SAVE ALL REGS\n         SLR   R2,R2                        CLEAR REGISTER\n         L     R3,TT                        LOAD RELATIVE TRK\n         SLR   R4,R4                                           #DD88103\n         ICM   R4,3,TRKCYL                  LOAD TRKS / CYL    #DD88103\n         DR    R2,R4                        CALCULATE CCHH\n         STCM  R3,3,CCHH                    SAVE CC            #DD88103\n         STCM  R2,3,CCHH+2                  SAVE HH            #DD88103\n         LM    R0,R15,SAVEREGS              RESTORE ALL REGS\n         BR    R10                          RETURN TO CALLER\n         TITLE '- PACKMAP -  SUBRTN - PROCESS A SINGLE EXTENT'\n*---------------------------------------------------------------------*\n*        UPDATE THE EXTENT TABLE FOR ONE EXTENT                       *\n*---------------------------------------------------------------------*\nEXTUPDAT DS    0H\n         DROP  R2\n         USING EXTABLE,R6\n         STM   R0,R15,SAVEREGS              SAVE ALL REGS\n         CLC   0(10,R1),=10X'00'            CHECK IF NO EXTENT\n         BER   R10                          IF NONE RETURN\n         LR    R2,R6                        COPY TABLE ADDRESS\n         LA    R2,144(,R2)                  POINT PAST ENTRY\n         C     R2,TAB2ADDR+4                CHECK FOR END\n         BNL   ERROR002                     IF NO ROOM ERROR\n         MVC   STRTCCHH,2(R1)               SAVE START CCHH\n         MVC   ENDCCHH,6(R1)                SAVE END   CCHH\n         MVC   CCHH,STRTCCHH                COPY   START CCHH\n         BAL   R10,CCHHTOTT                 CONVERT TO TT\n         MVC   STRTRACK,TT                  INSERT START TT\n         MVC   CCHH,ENDCCHH                 COPY   END   CCHH\n         BAL   R10,CCHHTOTT                 CONVERT TO TT\n         MVC   ENDTRACK,TT                  INSERT END   TT\n         L     R7,STRTRACK                  LOAD START TT\n         L     R8,ENDTRACK                  LOAD END   TT\n         LA    R8,1(,R8)                    ADD 1 FOR TRK 0\n         SR    R8,R7                        CALCULATE LENGTH\n         ST    R8,EXTNTLEN                  INSERT EXTENT LEN\n         L     R1,EXTENTNO                  LOAD OLD EXTENT CNT\n         LA    R1,1(,R1)                    ADD 1 TO EXTENT CNT\n         ST    R1,EXTENTNO                  SAVE NEW EXTENT CNT\n         ST    R1,EXTNTNO                   INSERT EXTENT NO\n         MVC   TOTEXTNT+3(1),EXTENTS        INSERT TOT EXTENTS\n         MVC   EXDSNAME,TEMPDSN             INSERT DATASET NAME\n         SLR   R1,R1                                           #DD88103\n         ICM   R1,3,TAB2CNT                 LOAD TABLE 2 COUNT #DD88103\n         LA    R1,1(,R1)                    ADD 1 TO COUNTER\n         STCM  R1,3,TAB2CNT                 SAVE NEW TABLE CNT #DD88103\n         LM    R0,R15,SAVEREGS              RESTORE ALL REGS\n         LA    R6,EXTNTEND                  ADVANCE TABLE\n         BR    R10                          RETURN TO CALLER\n         TITLE '- PACKMAP -  SUBRTN - FIND A DSCB IN THE TABLE'\n*---------------------------------------------------------------------*\n*        FIND THE CHAINED FORMAT2 OR FORMAT3 DSCB                     *\n*---------------------------------------------------------------------*\nFINDDSCB DS    0H\n         STM   R2,R14,SAVEREGS              SAVE ALL REGISTERS\n         SLR   R15,R15                      ASSUME IT IS THERE\n         L     R2,TAB1ADDR                  LOAD START ADDRESS\n         SLR   R3,R3                        CLEAR COUNTER\n         L     R4,TAB1SIZE                  LOAD RECORD LENGTH\n         L     R5,TAB1ADDR+4                LOAD END ADDRESS\nFIND0100 DS    0H\n         C     R1,0(R2)                     IS THIS OUR DSCB\n         BE    FIND0200                     IF MATCH GET OUT\n         BXLE  R2,R4,FIND0100               LOOP TILL END\n         LA    R15,8                        SET RETURN CODE\n         B     FIND0999                     TERMINATE\nFIND0200 DS    0H\n         LA    R1,0(,R2)                    POINT TO DSCB\nFIND0999 DS    0H\n         LM    R2,R14,SAVEREGS              RESTORE ALL REGS\n         BR    R10                          RETURN TO CALLER\n         TITLE '- PACKMAP -  SUBRTN - CONVERT A TO C1'\n*---------------------------------------------------------------------*\n*        CONVERT A STRING TO HEX FORMAT                               *\n*---------------------------------------------------------------------*\nHEXFORM  DS    0H\n         STM   R0,R15,SAVEREGS              SAVE ALL REGS\n         LA    R6,HEXIN                     POINT TO INPUT\n         LA    R7,HEXOUT                    POINT TO OUTPUT\nHEX00000 DS    0H\n         MVC   0(1,R7),0(R6)                MOVE ONE CHARACTER\n         MVC   1(1,R7),0(R6)                REPEAT IT\n         LA    R6,1(,R6)                    POINT TO NEXT ONE\n         LA    R7,2(,R7)                    SKIP DOUBLE CHARS\n         BCT   R1,HEX00000                  LOOP TILL DONE\n         NC    HEXOUT(20),ANDTABLE          FLIP THE BITS\n         TR    HEXOUT(20),TRTABLE2          TRANSLATE TO PRINT\n         LM    R0,R15,SAVEREGS              RESTORE ALL REGS\n         BR    R10                          RETURN TO CALLER\n         TITLE '- PACKMAP -  SUBRTN - FORMAT STORAGE DUMP'\n*---------------------------------------------------------------------*\n*        PRINT STORAGE IN DUMP FORMAT                                 *\n*---------------------------------------------------------------------*\nHEXDUMPR DS    0H\n         STM   R0,R15,SAVEREGS              SAVE ALL REGS\n         XC    HEXPARM+12(4),HEXPARM+12     CLEAR 3RD PARM\n         LA    R1,PRNTHEX                   POINT TO AREA\n         ST    R1,HEXPARM+16                SAVE IN PARM\n         MVI   HEXPARM+16,X'40'             80 CHARACTER DUMP\nHEXDUMP0 DS    0H\n         ICM   R15,B'1111',HEXRTN           LOAD HEX ROUTINE\n         BNZ   HEXDUMP1                     IF NOT LOADED END\n         MVC   HEXPARM+8(4),HEXPARM+4       ASSURE ONLY 1 LINE\n         B     HEXDUMP2                     SKIP HEXDUMP RTN\nHEXDUMP1 DS    0H\n         LA    R1,HEXPARM                   LOAD HEX PARM\n         BALR  R14,R15                      LINK TO ROUTINE\nHEXDUMP2 DS    0H\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,HEXLINE),VL,MF=(E,CALLL)\n         #BLANK HEXKEYWD,LEN=31             CLEAR DESCRIPTOR\n         CLC   HEXPARM+8(4),HEXPARM+4       CHECK FOR MORE\n         BH    HEXDUMP0                     IF MORE LOOP BACK\n         L     R15,=A(MSGRTN)      A(MESSAGE PROCESSING RTN)   #DD99183\n         CALL  (15),(#PRINT,MSGWORD,BLANKLNE),VL,MF=(E,CALLL)\n         LM    R0,R15,SAVEREGS              RESTORE ALL REGS\n         BR    R10\n         TITLE '- PACKMAP -  SUBRTN - PROCESS READ I/O ERRORS'\n*---------------------------------------------------------------------*\n*        PROCESS ANY I/O ERRORS WHILE READING THE VTOC                *\n*---------------------------------------------------------------------*\nVTOCERR  DS    0H\n         SYNADAF ACSMETH=BSAM\n         MVC   SYNADBUF,0(R1)\n         MVI   IOERROR,255\n         SYNADRLS\n         BR    R14\n         TITLE '- PACKMAP -  CONSTANTS AND DSECTS'\n*---------------------------------------------------------------------*\n*                     CONSTANTS + DSECTS                              *\n*---------------------------------------------------------------------*\nVTOCDCB  DCB   DDNAME=DISK,LRECL=96,KEYLEN=44,BLKSIZE=96,DEVD=DA,      X\n               MACRF=RP,RECFM=F,DSORG=PS,EODAD=VTOC1500,EXLST=EXTLIST, X\n               SYNAD=VTOCERR,DCBE=VTOCDCBE                     #DD12062\nVTOCDCBE DCBE  EADSCB=OK                                       #DD12062\nEXTLIST  DS    0F                           *\n         DC    X'87',AL3(VTOCJFCB)          *  DCB EXTENT LIST\nVTOCJFCB DS    CL176                        *  DCB JFCB AREA\nFMT4DSNM DC    44X'04'                      *  FORMAT4.DSCB\nTAB1SIZE DC    F'144'                       *  ALLOW FOR\n         DC    F'1440000'                   *    1 TO 10,000\nTAB2SIZE DC    F'92'                        *  ALLOW FOR\n         DC    F'920000'                    *    1 TO 10,000\nSKEY     DC    H'04'                        *  SORT START OFFSET\nSTYPE    DC    C'A'                         *  ASCENDING SORT\nQNAME    DC    CL8'SYSVTOC'                 *  QNAME FOR ENQ\nINFOLIST DEVTYPE INFO=(DEVTYPE,DASD,SUFFIX)                    #DD12062\nMODDEVT  DEVTYPE *-*,INFOLIST=INFOLIST,MF=L                    #DD12062\nMODDEVTL EQU   *-MODDEVT                                       #DD12062\nBLANKLNE FMTMSG ' '\nTITLE    FMTMSG 'Disk Pack Mapping Utility'\nHEADING1 FMTMSG 'Date = ',(DATE1,'MMM DD,CCYY'),(,' ',28),             X\n               'Information For ',(VOLSER1,'  ',6),' On ',             X\n               (UCB1,'  ',4),(,' ',41),'Time =',(TIME1,' HH:MM:SS')\nHEADING2 FMTMSG 'Date = ',(DATE2,'MMM DD,CCYY'),(,' ',28),             X\n               'Volume Map For ',(VOLSER2,'  ',6),' On ',(UCB2,'  ',4),X\n               (,' ',42),'Time =',(TIME2,' HH:MM:SS')\nHEADING3 FMTMSG 'Relative Trk   Extent  Extent ',(,'  ',44),           X\n               'Hex Cyl/Trk (CCC/HH)'\nHEADING4 FMTMSG 'Start /  End   Length  No./Of  Dataset Name',         X\n               (,'  ',30),'    Start -  End',                          X\n               '         Dsorg    Recfm    Lrecl    Blksize'\nPRINTLNE FMTMSG (RSTRT,'-----'),' - ',(REND,'-----'),(LEN,'  -----'),  X\n               ' ',(EXNO,' ---'),'/',(EXTOT,'---'),'  ',               X\n               (DSN,'  ',44),(STCCCHH,' CCC/HH -'),                    X\n               (ENDCCCHH,' CCC/HH '),(,' ',7),(PRDSORG,'   '),(,' ',6),X\n               (PRRECFM,'     '),(,' ',2),(PRLRECL,'      '),(,' ',4), X\n               (PRBLKSIZ,'      ')\nERR1MSG  FMTMSG 'IEC130I DISK     DD Statement Missing.'\nERR2MSG  FMTMSG 'Unable To Locate Format',(FORMATID,' '),              X\n               '. DSCB On Volume For ',(ERR2DSN,'  ',44)\nERR3MSG  FMTMSG 'Error Occurred Building Freespace Table'\nERR4MSG  FMTMSG 'Extent Count Error For ',(ERR4DSN,'  ',44),           X\n               ' Should Be ',(ERR4EX1,'   '),' Extents, But Found ',   X\n               (ERR4EX2,'   ')\nERR5MSG  FMTMSG (ERR5DSN,'  ',44),' Has Zero Extents'\nERR6MSG  FMTMSG 'I/O Error Occurred While Reading VTOC...Synad :'\nERR7MSG  FMTMSG '   ',(SYNADBUF,'  ',128)\nERR8MSG  FMTMSG '*** Error ***',(,' ',18),(TRKERROR,'  ',30)\nERR9MSG  FMTMSG 'PAK0001I *** VTOC Errors Exist On ',                  X\n               (VOLSER3,'      '),' ***'\nERR10MSG FMTMSG 'Insufficient Region Size To Map Volume'\nHEXLINE  FMTMSG (HEXKEYWD,'  ',31),(PRNTHEX,'  ',80)\nENDLINE  FMTMSG (,'  ',48),'*** End Of Volume Map ***'\n\n#PRINT   EQU   1    BATCH - ISSUE TO SYSPRINT\n*                   TSO   - ISSUED TO SYSPRINT OR TERMINAL\n*\n#WTO     EQU   2    BATCH - WRITE TO OPERATOR (AUTO DOM AFTER 15 MSGS)\n*                   TSO   - TPUT MESSAGE TO TSO TERMINAL\n*                   NOTE: SECOND PARAMETER MUST BE LIST FORM WTO\n*\n#TITLE   EQU   3    INITIALIZE TITLE TEXT AREA (AUTOMATICALLY CENTRED)\n*                   NOTE: THIRD...NTH PARAMETERS ARE USED AS HEADINGS\n*\n#HEADING EQU   4    RE-INITIALIZE HEADING AREA\n*\n#WTOR    EQU   5    BATCH - ISSUE WRITE TO OPERATOR WITH REPLY\n*                   TSO   - ISSUE TPUT/TGET FROM TSO TERMINAL\n*                   NOTE: SECOND PARAMETER MUST BE LIST FOR WTOR\n*\n#DOM     EQU   6    ISSUE DOM FOR OUTSTANDING WTO MESSAGES\n*                   NOTE : SECOND...NTH PARAMETER MAY BE THE ADDRESS\n*                          OF A PARTICUALR WTO TO BE DOMMED\n*\n#TPUT    EQU   7    ISSUE TPUT TO TSO TERMINAL\n*                   NOTE : IGNORED WHEN RUNNING BATCH\n\nWTOL1    WTO   ' ',ROUTCDE=(1,2,11),MF=L    *  LIST FORM WTO\nWTOL2    WTO   ' ',ROUTCDE=(1,2,11),MF=L,DESC=(2)\nANDTABLE DC    50X'F00F'                    *  AND TABLE\nTRTABLE1 DC    C'0123456789ABCDEF'                             #DD99204\nTRTABLE2 DC    256X'00'                     *  TRANSLATE TABLE\n         ORG   TRTABLE2                     *\n         DC    C'0123456789ABCDEF'          *\n         ORG   TRTABLE2+X'10'               *\n         DC    C'1'                         *\n         ORG   TRTABLE2+X'20'               *\n         DC    C'2'                         *\n         ORG   TRTABLE2+X'30'               *\n         DC    C'3'                         *\n         ORG   TRTABLE2+X'40'               *\n         DC    C'4'                         *\n         ORG   TRTABLE2+X'50'               *\n         DC    C'5'                         *\n         ORG   TRTABLE2+X'60'               *\n         DC    C'6'                         *\n         ORG   TRTABLE2+X'70'               *\n         DC    C'7'                         *\n         ORG   TRTABLE2+X'80'               *\n         DC    C'8'                         *\n         ORG   TRTABLE2+X'90'               *\n         DC    C'9'                         *\n         ORG   TRTABLE2+X'A0'               *\n         DC    C'A'                         *\n         ORG   TRTABLE2+X'B0'               *\n         DC    C'B'                         *\n         ORG   TRTABLE2+X'C0'               *\n         DC    C'C'                         *\n         ORG   TRTABLE2+X'D0'               *\n         DC    C'D'                         *\n         ORG   TRTABLE2+X'E0'               *\n         DC    C'E'                         *\n         ORG   TRTABLE2+X'F0'               *\n         DC    C'F'                         *\n         ORG   ,                            *\n         #STARTWA ,                         *\n         IHADVA DSECT=NO                DEVTYPE OUTPUT AREA    #DD12062\nDVAREAL  EQU   *-DVAREA                 OUTPUT AREA LENGTH     #DD12062\nWRKDEVT  DS    XL(MODDEVTL)             DEVTYPE PARAMETER LIST #DD12062\nRDJFCB   RDJFCB (0),MF=L                    *  LIST FORM RDJFCB\nOPENLIST OPEN  (0,INPUT),TYPE=J,MF=L        *  LIST FORM OPEN\nENQL     RESERVE (0,0,E,6,SYSTEMS),RET=HAVE,UCB=0,MF=L         #DD99183\n@UCB     DS    F\nGETMAINL GETMAIN VU,LA=0,A=0,MF=L           *  LIST FORM GETMAIN\nREADL    READ  READECB,SF,VTOCDCB,0,MF=L    *  LIST FORM READ\nCALLL    CALL  ,(0,0,0,0,0,0,0,0,0,0,0,0),VL,MF=L\nTEMPDSN  DS    CL44                         *  FORMAT1 DSNAME\nDDNAME   DS    CL8                          *  DDNAME FROM DCB\nSAVEREGS DS    16F                          *  REGS SAVE AREA\nSAVEREG2 DS    16F                          *  REGS SAVE AREA2 #DD88103\nIOERROR  DS    X                            *  SYNAD ERROR FLAG\nHEXRTN   DS    F                            *  HEX ROUTINE ADDR\nFREESPCE DS    F                            *  FREE SPACE TABLE\nLASTTRK  DS    F                            *  LAST TRK ON VOL\nTRKCYL   DS    H                            *  NO OF TRKS/CYL\nVTOCTT   DS    F                            *  VTOC START TT\nCCHH     DS    F                            *  CONVERSION CCHH\nTT       DS    F                            *  CONVERSION TT\nEXTENTS  DS    H                            *  TOTAL EXTENTS\nEXTENTNO DS    F                            *  EXTENT NUMBER\nRNAME    DS    CL6                          *  RNAME FOR ENQ\nTAB1ADDR DS    D                            *  DSCB START + END\nTAB2ADDR DS    D                            *  EXTENT STRT + END\nTAB2CNT  DS    H                            *  EXTENT COUNTER\nDBL      DS    D                            *  DBLEWORD WRK AREA\nMSGWORD  DS    F                            *  MSGRTN WRK ADDR\nPREVEND  DS    F                            *  PREV EXTENT END\nHEXIN    DS    CL10                         *  CONVERSION INPUT\nHEXOUT   DS    CL20                         *  CONVERSION OUTPUT\nHEXPARM  DS    0F                           *\n         DC    A(*-*)                       *  POINTER TO PARMS\n         DC    A(*-*)                       *  HEX START ADDRESS\n         DC    A(*-*)                       *  HEX END   ADDRESS\n         DC    A(0)                         *  RELATIVE ADDRESS\n         DC    X'40'                        *  FLAG BYTE\n         DC    AL3(*-*)                     *  BUFFER ADDRESS\nFLAG     DS    X                            *  ERROR FLAG\nVTOCERRS EQU   X'01'                        *  ANY VTOC ERROR\nEXTNTERR EQU   X'03'                        *  EXTENT ERROR\nSIZEERR  EQU   X'05'                        *  EOV EXTENT ERROR\nSPACEERR EQU   X'09'                        *  FREESPACE ERROR\n         #STOPWA ,                          *\n         DSECT ,                            *\nDSCBTAB  DS    CL4                          *\n         IECSDSL1 1                         *  FORMAT1 DSCB\n         ORG   IECSDSL1                     *\n         IECSDSL1 2                         *  FORMAT2 DSCB\n         ORG   IECSDSL1                     *\n         IECSDSL1 3                         *  FORMAT3 DSCB\n         ORG   IECSDSL1+L'DS1DSNAM          *\n         IECSDSL1 4                         *  FORMAT4 DSCB\n         ORG   IECSDSL1                     *\n         IECSDSL1 5                         *  FORMAT5 DSCB\n         ORG   IECSDSL1                     *\n         IECSDSL1 6                         *  FORMAT6 DSCB\nDSCBEND  EQU   *                            *  END OF DSCB\n         DCBD  DEVD=DA,DSORG=PS             *  DCB MAP\nCVAFBUFF ICVAFBFL DSECT=YES                 *  CVAF BUFFER MAP\nCVPL     ICVAFPL  DSECT=YES                 *  CVAF PARM LIST\n         DSECT ,                            *\n         IEZDEB   LIST=YES                  *  DEB MAP\n         DSECT ,                            *\n         IEFJFCBN LIST=YES                  *  JFCB MAP\n         DSECT ,                            *\n         IKJTCB ,                           *  TCB MAP\n         DSECT ,                            *\n         IEFTIOT1 ,                         *  TIOT MAP\n         DSECT ,                            *\n         IEFUCBOB LIST=NO                   *  UCB MAP\n         DSECT ,                            *\nEXTABLE  DS    0F                           *  ENTENT TABLE\nSTRTRACK DS    XL4                          *  - START REL TRK\nENDTRACK DS    XL4                          *  - END   REL TRK\nSTRTCCHH DS    XL4                          *  - START CCHH\nENDCCHH  DS    XL4                          *  - END   CCHH\nEXTNTLEN DS    XL4                          *  - EXTENT LENGTH\nEXTNTNO  DS    XL4                          *  - EXTENT NUMBER\nTOTEXTNT DS    XL4                          *  - TOTAL EXTENTS\nEXDSNAME DS    CL44                         *  - DATASET NAME\nEXDSORG  DS    CL3                          *  - DSORG\nEXRECFM  DS    CL5                          *  - RECFM\nEXLRECL  DS    CL6                          *  - LRECL\nEXBLKSIZ DS    CL6                          *  - BLKSIZE\nEXTNTEND EQU   *                            *  - END OF TABLE\n         PUSH  USING,PRINT\n         PRINT ON,GEN\n         DROP  ,\n         TITLE '- MSGRTN -  MESSAGE FORMATING SUBROUTINE'\nMSGRTN   #START REG1=R10,USING=(MSGWRK,R11),BASE=R12\n         USING PSA,0\n         TITLE '- MSGRTN -  WORK AREA INITIALIZATION ROUTINE.'\n*---------------------------------------------------------------------*\n*        INITIALIZE WORK AREA FIRST TIME AROUND                       *\n*---------------------------------------------------------------------*\nINITIAL0 DS    0H\n         L     R2,4(R10)                    LOAD WORK AREA PTR\n         ICM   R11,B'1111',0(R2)            LOAD WORK AREA\n         BNZ   BRANCH00                     SKIP IF ALREADY DONE\n         L     R3,=A(MSGWKLEN)              LOAD WORK AREA LENGTH\n         GETMAIN R,LV=(R3)                  GET WORK SPACE\n         ST    R1,0(R2)                     SAVE WORK AREA PTR\n         LR    R11,R1                       COPY WORK AREA PTR\n         LR    R2,R1                        POINT TO START\n         LR    R4,R1                        POINT TO START\n         SLR   R5,R5                        CLEAR REGISTER\n         MVCL  R2,R4                        CLEAR WORK AREA\n         LA    R1,DOMLIST                   POINT TO DOM LIST\n         ST    R1,DOMPTR                    INITIALIZE POINTER\n         MVI   TITLES,C' '                  INSERT A BLANK\n         MVC   TITLES+1(255),TITLES         PROPAGATE BLANKS\n         MVI   LINE,C' '                    MOVE IN A BLANK\n         MVC   LINE+1(255),LINE             PROPAGATE BLANKS\n         MVC   LINENO,=F'99'                FORCE FIRST TITLE\n         MVC   MSGDCB(DMYDCBL),DMYDCB       INITIALIZE DCB\n         LA    R1,EXITLIST                  POINT TO EXITLIST\n         STCM  R1,B'0111',MSGDCB+DCBEXLSA-IHADCB\n         LA    R1,PRNTJFCB                  POINT TO JFCB AREA\n         ST    R1,EXITLIST                  SAVE JFCB ADDRESS\n         MVI   EXITLIST,X'87'               SETUP EXITLIST\n         MVC   OPENL(1),=AL1(143)           SETUP FOR OPEN\n         MVC   RDJFCBL(1),=AL1(128)         SERUP FOR RDJFCB\n         L     R1,PSATOLD                   LOAD TCB ADDRESS\n         L     R1,TCBTIO-TCB(R1)            LOAD TIOT ADDRESS\n         LA    R1,TIOENTRY-TIOT1(R1)        SKIP OVER HEADER\n*---------------------------------------------------------------------*\n*        SCAN FOR THE SYSPRINT FILE                                   *\n*---------------------------------------------------------------------*\nINITIAL1 DS    0H\n         CLC   MSGDCB+DCBDDNAM-IHADCB(8),TIOEDDNM-TIOENTRY(R1)\n         BE    INITIAL2                     IF SO OPEN IT\n         SLR   R0,R0                        CLEAR REGISTER\n         IC    R0,TIOELNGH-TIOENTRY(R1)     INSERT ENTRY LEN\n         ALR   R1,R0                        POINT TO NEXT ONE\n         CLI   TIOELNGH-TIOENTRY(R1),0      ENTRY LENGTH = 0\n         BNE   INITIAL1                     IF NOT KEEP TRYING\n         OI    MSGFLAG,NOPRINT              SET DDNAME FLAG\n*---------------------------------------------------------------------*\n*        SETUP SYSPRINT DCB TO SPECIFIED LRECL OR DEFAULT TO 133      *\n*---------------------------------------------------------------------*\nINITIAL2 DS    0H\n         LA    R2,MSGDCB                    POINT TO DCB\n         RDJFCB ((R2)),MF=(E,RDJFCBL)       READ THE JFCB\n         CLI   PRNTJFCB+JFCRECFM-INFMJFCB,X'00'\n         BNE   INITIAL3                     IF RECFM THERE SKIP\n         OI    PRNTJFCB+JFCRECFM-INFMJFCB,JFCFIX+JFCRFB+JFCASA\nINITIAL3 DS    0H\n         CLC   PRNTJFCB+JFCLRECL-INFMJFCB(2),=H'00'\n         BNE   INITIAL4                     IF LRECL THERE SKIP\n         MVC   PRNTJFCB+JFCLRECL-INFMJFCB(2),=H'133'\nINITIAL4 DS    0H\n         CLC   PRNTJFCB+JFCBLKSI-INFMJFCB(2),=H'00'\n         BNE   INITIAL5                     IF BLKSI THERE SKIP\n         MVC   PRNTJFCB+JFCBLKSI-INFMJFCB(2),PRNTJFCB+JFCLRECL-INFMJFCB\nINITIAL5 DS    0H\n         CLC   PRNTJFCB+JFCBDSNM-INFMJFCB(44),=CL44'TERMFILE '\n         BNE   INITIAL6                     IF NOT CONTINUE\n         OI    MSGFLAG,NOPRINT              SET DDNAME FLAG\nINITIAL6 DS    0H\n         TM    MSGDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BO    INITIAL7                     SKIP IF NOW OPEN\n         TM    MSGFLAG,NOPRINT              CHECK FOR NO PRINT\n         BO    INITIAL7                     SKIP IF NO PRINT\n         OPEN  ((R2),(OUTPUT)),TYPE=J,MF=(E,OPENL)\n         TM    MSGDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BO    INITIAL7                     CONTINUE IF OPEN\n         OI    MSGFLAG,NOPRINT              SET NOPRINT FLAG\n*---------------------------------------------------------------------*\n*        SAVE LRECL AND SETUP THE TITLE AREAS                         *\n*---------------------------------------------------------------------*\nINITIAL7 DS    0H\n         LH    R3,PRNTJFCB+JFCLRECL-INFMJFCB\n         CH    R3,=F'12'                    CHECK FOR MINIMUM\n         BL    ERROR030                     IF LOWER ERROR\n         BCTR  R3,R0                        DECREMENT LENGTH\n         STH   R3,MSGLRECL                  SAVE MAXIMUM LENGTH\n         SH    R3,=H'10'                    SUB PAGE NO. LENGTH\n         STH   R3,TITLEN                    SAVE TITLE LENGTH\n         LA    R5,TITLES                    POINT TO TITLE\n         LA    R3,1(R3,R5)                  POINT TO PAGE AREA\n         MVC   0(6,R3),=C' PAGE '           MOVE PAGE CONSTANT\n         LA    R3,6(,R3)                    PNT PAST CONSTANT\n         ST    R3,PAGEADDR                  SAVE PAGE NO. PTR\n         L     R15,PSAAOLD                  LOAD ASCB ADDRESS\n         CLC   ASCBJBNI-ASCB(4,R15),=F'0'   CHECK FOR JOBNM PTR\n         BNE   BRANCH00                     IF NONE...TSO USER\n         OI    MSGFLAG,TSOUSER              SET TSOUSER FLAG\n         TITLE '- MSGRTN -  BRANCH TO PROPER MESSAGE ROUTINE.'\n*---------------------------------------------------------------------*\n*        BRANCH TO PROPER ROUTINE                                     *\n*---------------------------------------------------------------------*\nBRANCH00 DS    0H\n         L     R3,0(R10)                    LOAD MESSAGE TYPE\n         MH    R3,=H'04'                    CALC BRANCH OFFSET\n         CH    R3,=H'28'                    IS TYPE VALID\n         BH    ERROR020                     IF NOT TERMINATE\n         B     BRANCH10(R3)                 BRANCH TO ROUTINE\nBRANCH10 DS    0H\n         B     ERROR020      (R3=00)        BRANCH FOR UNKNOWN\n         B     PRINT000      (R3=04)        BRANCH FOR #PRINT\n         B     WTO00000      (R3=08)        BRANCH FOR #WTO\n         B     TITLE000      (R3=12)        BRANCH FOR #TITLE\n         B     HEAD0000      (R3=16)        BRANCH FOR #HEADING\n         B     WTOR0000      (R3=20)        BRANCH FOR #WTOR\n         B     DOM00000      (R3=24)        BRANCH FOR #DOM\n         B     TPUT0000      (R3=28)        BRANCH FOR #TPUT\n         TITLE '- MSGRTN -  PROCESS #PRINT PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #PRINT PARAMETERS                                *\n*---------------------------------------------------------------------*\nPRINT000 DS    0H\n         TM    MSGFLAG,NOPRINT              CHECK FOR DD CARD\n         BO    ERROR010                     IF MISSING ERROR\n         LA    R10,8(,R10)                  SKIP USED PARMS\nPRINT010 DS    0H\n         CLC   LINENO,=F'60'                PAGE LIMIT EXCEEDED\n         BL    PRINT030                     IF NOT PRINT LINE\n         L     R2,PAGENO                    LOAD OLD PAGE COUNT\n         LA    R2,1(,R2)                    ADD 1 TO COUNT\n         ST    R2,PAGENO                    SAVE NEW PAGE COUNT\n         CVD   R2,DOUBLE                    CONVERT TO DECIMAL\n         L     R2,PAGEADDR                  POINT TO TITLE AREA\n         MVC   0(4,R2),PAGEMASK             MOVE EDIT MASK\n         ED    0(4,R2),DOUBLE+6             EDIT PAGE NUMBER\n         MVI   TITLES,C'1'                  SET PAGE EJECT\n         MVI   HEADINGS,C'0'                SET LINE SKIP\n         MVI   LINE,C'0'                    SET LINE SKIP\n         PUT   MSGDCB,TITLES                PRINT TITLE\n         LA    R5,HEADINGS                  POINT TO HEADING\n         LA    R2,2                         SET LINECOUNT TO 2\n         ST    R2,LINENO                    SAVE LINE COUNT\n         ICM   R6,B'1111',HEADNOS           LOAD HEADING COUNT\n         BZ    PRINT030                     IF NO HEADING SKIP\n         LA    R2,1(,R2)                    ADD 1 FOR LINE SKIP\nPRINT020 DS    0H\n         PUT   MSGDCB,0(R5)                 PRINT HEADING\n         LA    R5,256(,R5)                  POINT TO NEXT ONE\n         LA    R2,1(,R2)                    ADD 1 TO LINE COUNT\n         BCT   R6,PRINT020                  LOOP TILL ALL DONE\n         ST    R2,LINENO                    SAVE LINE COUNT\nPRINT030 DS    0H\n         L     R2,0(R10)                    LOAD TEXT ADDRESS\n         SLR   R5,R5                        CLEAR REGISTER\n         ICM   R5,B'0001',0(R2)             LOAD TEXT LENGTH\n         BZ    PRINT040                     CHECK FOR ZERO\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         EX    R5,EXECMVC1                  MVC LINE+1(?),1(R2)\nPRINT040 DS    0H\n         PUT   MSGDCB,LINE                  PRINT TEXT LINE\n         MVI   LINE,C' '                    MOVE IN A BLANK\n         MVC   LINE+1(254),LINE             PROPAGATE BLANKS\n         L     R2,LINENO                    LOAD OLD LINECOUNT\n         LA    R2,1(R2)                     ADD 1 TO LINECOUNT\n         ST    R2,LINENO                    SAVE NEW LINECOUNT\n         TM    0(R10),X'80'                 CHECK FOR PARM END\n         BO    EXIT                         IF ALL DONE QUIT\n         LA    R10,4(,R10)                  SKIP TO NEXT PARM\n         B     PRINT010                     KEEP PRINTING\n         TITLE '- MSGRTN -  PROCESS #WTO PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #WTO PARAMETERS                                  *\n*---------------------------------------------------------------------*\nWTO00000 DS    0H\n         L     R4,8(R10)                    LOAD WTO LIST ADDR\n         LA    R10,12(,R10)                 SKIP USED PARMS\n         TM    MSGFLAG,TSOUSER              CHECK FOR TSO USER\n         BO    WTOTPUT0                     IF SO ISSUE TPUT\n         MVC   MCSFLAGS(2),2(R4)            SAVE MCS FLAGS\n         LH    R5,0(R4)                     LOAD TEXT LENGTH\n         LA    R4,0(R5,R4)                  POINT PAST TEXT\n         MVC   DESCODES(4),0(R4)            DESC + ROUTE CODES\nWTO00010 DS    0H\n         L     R2,0(R10)                    LOAD MESSAGE TEXT\n         SLR   R5,R5                        CLEAR REGISTER\n         ICM   R5,B'0001',0(R2)             LOAD TEXT LENGTH\n         BZ    WTO00050                     CHECK FOR ZERO\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         CH    R5,=H'123'                   CHECK FOR MAX - 124\n         BNH   WTO00020                     IF OK CONTINUE\n         LH    R5,=H'123'                   IF OVER 124 TRUNCATE\nWTO00020 DS    0H\n         EX    R5,EXECMVC2                  MVC WTOTEXT(?),1(R2)\n         LA    R5,5(,R5)                    ALLOW FOR LEN + MCS\n         STH   R5,WTOL                      SAVE IN PARM LIST\n         LA    R4,WTOL                      POINT TO LIST FORM\n         LA    R4,0(R5,R4)                  POINT PAST TEXT\n         MVC   0(4,R4),DESCODES             DESC + ROUTE CODES\n         LA    R1,WTOL                      POINT TO LIST FORM\n         WTO   MF=(E,(R1))                  ISSUE WTO\n         TM    DESCODES,B'11000000'         DESC CODE = 1 OR 2\n         BO    WTO00030                     IF SO SAVE MSGID\n         TM    DESCODES+1,B'00100000'       DESC CODE = 11\n         BNO   WTO00050                     IF NOT DONT SAVE MSGID\nWTO00030 DS    0H\n         LR    R3,R1                        COPY MSGID\n         L     R4,DOMPTR                    LOAD AVAILABLE PTR\n         LA    R5,DOMEND                    POINT TO END OF LIST\n         CR    R4,R5                        CHECK IF AT END\n         BNE   WTO00040                     IF NOT JUST SAVE ID\n         SH    R4,=H'04'                    BACK UP TO PREVIOUS\n         OI    0(R4),X'80'                  SET END OF DOM LIST\n         LA    R4,DOMLIST                   POINT TO DOM LIST\n         DOM   MSGLIST=(R4)                 DOM ALL MESSAGES\n         XC    DOMLIST(60),DOMLIST          CLEAR THE LIST\nWTO00040 DS    0H\n         ST    R3,0(R4)                     SAVE THIS MSGID\n         LA    R4,4(,R4)                    POINT TO NEXT ONE\n         ST    R4,DOMPTR                    SAVE NEW POINTER\nWTO00050 DS    0H\n         TM    0(R10),X'80'                 CHECK FOR PARM END\n         BO    EXIT                         IF ALL DONE QUIT\n         LA    R10,4(,R10)                  SKIP USED PARM\n         B     WTO00010                     ISSUE NEXT WTO\nWTOTPUT0 DS    0H\n         L     R2,0(R10)                    LOAD TEXT ADDRESS\n         SLR   R5,R5                        CLEAR REGISTER\n         ICM   R5,B'0001',0(R2)             LOAD TEXT LENGTH\n         BZ    WTOTPUT1                     CHECK FOR ZERO\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         EX    R5,EXECMVC1                  MVC LINE+1(?),1(R2)\nWTOTPUT1 DS    0H\n         LA    R5,1(,R5)                    RESTORE LENGTH\n         TPUT  LINE+1,(R5)                  TPUT TEXT LINE\n         MVI   LINE,C' '                    MOVE IN A BLANK\n         MVC   LINE+1(255),LINE             PROPAGATE BLANKS\n         TM    0(R10),X'80'                 CHECK FOR PARM END\n         BO    EXIT                         IF ALL DONE QUIT\n         LA    R10,4(,R10)                  SKIP TO NEXT PARM\n         B     WTOTPUT0                     KEEP TPUTING\n         TITLE '- MSGRTN -  PROCESS #TITLE PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #TITLE PARAMETERS                                *\n*---------------------------------------------------------------------*\nTITLE000 DS    0H\n         LA    R10,8(,R10)                  SKIP USED PARMS\n         L     R2,0(R10)                    LOAD TITLE ADDR\n         LH    R6,TITLEN                    LOAD TITLE LENGTH\n         BCTR  R6,R0                        DECREMENT FOR EXEC\n         MVI   TITLES+1,C' '                MOVE IN A BLANK\n         EX    R6,EXECMVC3                  MVC TITLES+2(?),TITLES+1\n         LA    R6,1(,R6)                    RESET LENGTH\n         SLR   R5,R5                        CLEAR REGISTER\n         ICM   R5,B'0001',0(R2)             INSERT TEXT LENGTH\n         CR    R5,R6                        CHECK FOR MAXIMUM\n         BNH   TITLE010                     IF OK PROCEED\n         LR    R5,R6                        TRUNCATE TO MAX LEN\nTITLE010 DS    0H\n         LH    R8,TITLEN                    LOAD TITLE LENGTH\n         SR    R8,R5                        CALC DIFFERENCE\n         BZ    TITLE020                     IF ZERO PROCEED\n         SRL   R8,1                         DIV TO FIND OFFSET\nTITLE020 DS    0H\n         LA    R7,TITLES+1                  POINT TO TITLE LINE\n         LA    R7,0(R8,R7)                  CENTER THE TITLE\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         EX    R5,EXECMVC4                  MVC 0(?,R7),1(R2)\n         TM    0(R10),X'80'                 ANY MORE PARMS\n         BO    EXIT                         IF NOT TERMINATE\n         LA    R10,4(,R10)                  ADVANCE POINTER\n         MVC   LINENO,=F'99'                SET LINECT TO MAX\n         B     HEAD0010                     PROCESS ANY HEADINGS\n         TITLE '- MSGRTN -  PROCESS #HEADING PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #HEADING PARAMETERS                              *\n*---------------------------------------------------------------------*\nHEAD0000 DS    0H\n         LA    R10,8(,R10)                  SKIP USED PARMS\nHEAD0010 DS    0H\n         LA    R7,HEADINGS+1                POINT TO HEADINGS\n         SLR   R6,R6                        CLEAR HEADING COUNTER\n         ST    R6,HEADNOS                   SET COUNT TO ZERO\nHEAD0020 DS    0H\n         CH    R6,=H'06'                    CHECK FOR MAXIMUM\n         BE    EXIT                         IF MAX TERMINATE\n         L     R2,0(R10)                    LOAD HEADING TEXT\n         MVI   0(R7),C' '                   MOVE IN A BLANK\n         MVC   1(255,R7),0(R7)              PROPAGATE BLANKS\n         SLR   R4,R4                        CLEAR REGISTER\n         ICM   R4,B'0001',0(R2)             INSERT TEXT LENGTH\n         BZ    HEAD0030                     IF ZERO TRY NEXT\n         BCTR  R4,0                         DECREMENT FOR EXEC\n         EX    R4,EXECMVC4                  MVC 0(?,R7),1(R2)\nHEAD0030 DS    0H\n         LA    R7,256(,R7)                  ADVANCE POINTER\n         LA    R6,1(,R6)                    ADD 1 TO COUNTER\n         ST    R6,HEADNOS                   SAVE HEADINGS COUNT\n         TM    0(R10),X'80'                 ANY MORE PARMS\n         BO    EXIT                         IF NOT TERMINATE\n         LA    R10,4(,R10)                  POINT TO NEXT PARM\n         B     HEAD0020                     PROCESS NEXT HEADING\n         TITLE '- MSGRTN -  PROCESS #WTOR PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #WTOR PARAMETERS                                 *\n*---------------------------------------------------------------------*\nWTOR0000 DS    0H\n         TM    MSGFLAG,TSOUSER              CHECK FOR TSO USER\n         BO    PUTGET00                     IF SO ISSUE TPUT/TGET\n         L     R4,8(R10)                    LOAD WTOR LIST ADDR\n         LA    R10,12(,R10)                 SKIP USED PARMS\n         MVC   WTORL(8),0(R4)               SAVE LEN/REPLY/ECB\n         MVC   MCSFLAGS(2),10(R4)           SAVE MCS FLAGS\n         LH    R5,8(R4)                     LOAD TEXT LENGTH\n         LA    R4,8(R5,R4)                  POINT PAST TEXT\n         MVC   DESCODES(4),0(R4)            DESC + ROUTE CODES\nWTOR0010 DS    0H\n         L     R2,0(R10)                    LOAD MESSAGE TEXT\n         SLR   R5,R5                        CLEAR REGISTER\n         ICM   R5,B'0001',0(R2)             LOAD TEXT LENGTH\n         BZ    WTOR0030                     CHECK FOR ZERO\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         CH    R5,=H'123'                   CHECK FOR MAX - 124\n         BNH   WTOR0020                     IF OK CONTINUE\n         LH    R5,=H'123'                   IF OVER 124 TRUNCATE\nWTOR0020 DS    0H\n         EX    R5,EXECMVC2                  MVC WTOTEXT(?),1(R2)\n         LA    R5,5(,R5)                    ALLOW FOR LEN + MCS\n         STH   R5,WTOL                      SAVE IN PARM LIST\n         LA    R4,WTOL                      POINT TO LIST FORM\n         LA    R4,0(R5,R4)                  POINT PAST TEXT\n         MVC   0(4,R4),DESCODES             DESC + ROUTE CODES\n         LA    R1,WTORL                     POINT TO LIST FORM\n         WTOR  MF=(E,(R1))                  ISSUE WTO\nWTOR0030 DS    0H\n         LR    R3,R1                        COPY MSGID\n         L     R4,DOMPTR                    LOAD AVAILABLE PTR\n         LA    R5,DOMEND                    POINT TO END OF LIST\n         CR    R4,R5                        CHECK IF AT END\n         BNE   WTOR0040                     IF NOT JUST SAVE ID\n         SH    R4,=H'04'                    BACK UP TO PREVIOUS\n         OI    0(R4),X'80'                  SET END OF DOM LIST\n         LA    R4,DOMLIST                   POINT TO DOM LIST\n         DOM   MSGLIST=(R4)                 DOM ALL MESSAGES\n         XC    DOMLIST(60),DOMLIST          CLEAR THE LIST\nWTOR0040 DS    0H\n         ST    R3,0(,R4)                    SAVE THIS MSGID\n         LA    R4,4(,R4)                    POINT TO NEXT ONE\n         ST    R4,DOMPTR                    SAVE NEW POINTER\n         B     EXIT                         ONLY 1 WTOR ALLOWED\n         TITLE '- MSGRTN -  PROCESS #DOM PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #DOM PARAMETERS                                  *\n*---------------------------------------------------------------------*\nDOM00000 DS    0H\n         TM    MSGFLAG,TSOUSER              CHECK FOR TSO USER\n         BO    EXIT                         IF SO NO NEED TO DOM\n         TM    0(R10),X'80'                 ANY SPECIFIC MSG\n         BO    DOM00020                     IF NOT CONTINUE\nDOM00010 DS    0H\n         LA    R10,4(,R10)                  POINT TO NEXT PARM\n         L     R2,0(R10)                    POINT TO MSG TO DOM\n         DOM   MSG=(R2),REPLY=YES           DOM THIS MSGS\n         TM    0(R10),X'80'                 ANY MORE MSGS TO DOM\n         BNO   DOM00010                     IF SO LOOP TILL DONE\n         B     EXIT                         IF NOT TERMINATE\nDOM00020 DS    0H\n         L     R2,DOMPTR                    LOAD LAST ADDRESS\n         LA    R3,DOMLIST                   LOAD START ADDRESS\n         CR    R2,R3                        ANY MSGS TO DOM\n         BE    EXIT                         IF NOT TERMINATE\n         SH    R2,=H'04'                    POINT TO LAST MSGID\n         OI    0(R2),X'80'                  SET END OF DOMLIST\n         LA    R3,DOMLIST                   POINT TO DOM LIST\n         DOM   MSGLIST=(R3)                 DOM MESSAGE LIST\n         XC    DOMLIST(60),DOMLIST          CLEAR THE LIST\n         ST    R3,DOMPTR                    SAVE MSGID POINTER\n         B     EXIT                         TERMINATE\n         TITLE '- MSGRTN -  PROCESS #TPUT PARAMETERS.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #TPUT PARAMETERS                                 *\n*---------------------------------------------------------------------*\nTPUT0000 DS    0H\n         TM    MSGFLAG,TSOUSER              CHECK FOR TSO USER\n         BNO   EXIT                         IF NOT TERMINATE\n         LA    R10,8(,R10)                  SKIP USED PARMS\n         LH    R7,MSGDCB+DCBLRECL-IHADCB    LOAD LRECL\n         BCTR  R7,R0                        SUB CARRAGE CONTROL\nTPUT0010 DS    0H\n         CLC   LINENO,=F'24'                IS LINECOUNT <= 24\n         BNH   TPUT0030                     IF SO PROCEED\n         L     R2,PAGENO                    LOAD OLD PAGE COUNT\n         LA    R2,1(,R2)                    ADD 1 TO COUNT\n         ST    R2,PAGENO                    SAVE NEW PAGE COUNT\n         CVD   R2,DOUBLE                    CONVERT TO DECIMAL\n         L     R2,PAGEADDR                  POINT TO PAGE#\n         MVC   0(4,R2),PAGEMASK             MOVE EDIT MASK\n         ED    0(4,R2),DOUBLE+6             EDIT PAGE NUMBER\n         TPUT  TITLES+1,(R7)                TITLE TO TERMINAL\n         LA    R5,HEADINGS+1                POINT TO HEADING\n         LA    R2,1                         SET LINECOUNT TO 1\n         ST    R2,LINENO                    SAVE LINE COUNT\n         ICM   R6,B'1111',HEADNOS           LOAD HEADING COUNT\n         BZ    TPUT0030                     IF NO HEADING PROCEED\nTPUT0020 DS    0H\n         TPUT  (R5),(R7)                    TPUT HEADING\n         LA    R5,256(,R5)                  POINT TO NEXT ONE\n         LA    R2,1(R2)                     ADD 1 TO LINE COUNT\n         BCT   R6,TPUT0020                  LOOP TILL ALL DONE\n         ST    R2,LINENO                    SAVE LINE COUNT\nTPUT0030 DS    0H\n         L     R2,0(R10)                    LOAD TEXT ADDRESS\n         SLR   R5,R5                        CLEAR REGISTER\n         ICM   R5,B'0001',0(R2)             LOAD TEXT LENGTH\n         BZ    TPUT0040                     CHECK FOR ZERO\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         EX    R5,EXECMVC1                  MVC LINE+1(?),1(R2)\nTPUT0040 DS    0H\n         TPUT  LINE+1,(R7)                  TPUT TEXT LINE\n         MVI   LINE,C' '                    MOVE IN A BLANK\n         MVC   LINE+1(255),LINE             PROPAGATE BLANKS\n         L     R2,LINENO                    LOAD OLD LINECOUNT\n         LA    R2,1(,R2)                    ADD 1 TO LINECOUNT\n         ST    R2,LINENO                    SAVE NEW LINECOUNT\n         TM    0(R10),X'80'                 CHECK FOR PARM END\n         BO    EXIT                         IF ALL DONE QUIT\n         LA    R10,4(,R10)                  SKIP TO NEXT PARM\n         B     TPUT0010                     KEEP TPUTING\n         TITLE '- MSGRTN -  PROCESS #WTOR PARAMETERS FOR TSO.'\n*---------------------------------------------------------------------*\n*        PROCESS THE #WTOR PARAMETERS FOR A TSO USER                  *\n*---------------------------------------------------------------------*\nPUTGET00 DS    0H\n         L     R2,8(R10)                    LOAD WTOR LIST FORM\n         SLR   R5,R5                        CLEAR REGISTER\n         IC    R5,0(R2)                     LOAD REPLY LENGTH\n         SLR   R6,R6                        CLEAR REGISTER\n         ICM   R6,B'0111',1(R2)             LOAD REPLY ADDRESS\n         L     R7,4(R2)                     GET ECB ADDR\n         L     R2,12(R10)                   LOAD TEXT ADDRESS\n         SLR   R3,R3                        CLEAR REGISTER\n         ICM   R3,B'0001',0(R2)             INSERT TEXT LENGTH\n         BZ    PUTGET40                     IF ZERO POST ECB\n         BCTR  R3,R0                        DECREMENT FOR EXEC\n         MVC   LINE(4),=C'*00 '             SIMULATE WTOR MESSAGE\n         EX    R3,EXECMVC5                  MVC LINE+4(?),1(R2)\n         LA    R3,5(,R3)                    RESTORE TEXT LENGTH#DD88103\n         TPUT  LINE,(R3)                    TPUT MSG\nPUTGET10 DS    0H\n         MVI   LINE,C' '                    MOVE IN A BLANK\n         MVC   LINE+1(255),LINE             PROPAGATE BLANKS\n         TGET  LINE,256,EDIT,WAIT           GET RESPONSE FROM TERMINAL\n         CR    R1,R5                        CHECK RESPONSE LENGTH\n         BNH   PUTGET30                     IF ACCEPTABLE CONTINUE\n         TPUT  TGETERR,L'TGETERR            TPUT ERROR MESSAGE\n         B     PUTGET10                     RETRY TGET\nPUTGET30 DS    0H\n         OC    LINE(256),=256X'40'          CONVERT TO UPPER CASE\n         BCTR  R5,R0                        DECREMENT FOR EXEC\n         EX    R5,EXECMVC6                  MVC 0(?,R6),LINE\nPUTGET40 DS    0H\n         POST  (R7)                         STOP WAITING\n         B     EXIT                         TERMINATE\n         TITLE '- MSGRTN -  ERROR ROUTINES.'\n*---------------------------------------------------------------------*\n*        PROCESS ANY ERRORS                                           *\n*---------------------------------------------------------------------*\nERROR010 DS    0H\n         TM    MSGFLAG,TSOUSER              CHECK FOR TSO USER\n         BO    TPUT0000                     IF SO ISSUE TPUT\n         TM    MSGFLAG,PRERR10              CHECK FOR PREVIOUS ERROR\n         BO    ERROR011                     IF SO NO ERROR MSG\n         WTO   'IEC130I SYSPRINT DD STATEMENT MISSING.',ROUTCDE=11\nERROR011 DS    0H\n         LA    R15,4                        SET RC = 4\n         B     TERMINAT                     TERMINATE IMMEDIATELY\nERROR020 DS    0H\n         LA    R15,8                        SET RC = 8\n         B     TERMINAT                     TERMINATE IMMEDIATELY\nERROR030 DS    0H\n         LA    R15,12                       SET RC = 12\n         B     TERMINAT                     TERMINATE IMMEDIATELY\n         TITLE '- MSGRTN -  TERMINATE MESSAGE ROUTINE.'\n*---------------------------------------------------------------------*\n*        TERMINATION ROUTINE                                          *\n*---------------------------------------------------------------------*\nEXIT     DS    0H\n         LA    R15,0                        SET RC = 0\nTERMINAT DS    0H\n         #STOP RC=(R15)                     RETURN TO CALLER\n         TITLE '- MSGRTN -  CONSTANTS AND STORAGE AREA.'\n*---------------------------------------------------------------------*\n*        CONSTANTS AND DSECTS                                         *\n*---------------------------------------------------------------------*\nTGETERR  DC  C'IEE700I REPLY 00 IGNORED; REPLY TOO LONG FOR REQUESTOR.'\n*\nPAGEMASK DC    XL4'40202021'                PAGE NUMBER EDIT MASK\n*\nEXECMVC1 MVC   LINE+1(*-*),1(R2)            **** EXECUTED ****\nEXECMVC2 MVC   WTOTEXT(*-*),1(R2)           **** EXECUTED ****\nEXECMVC3 MVC   TITLES+2(*-*),TITLES+1       **** EXECUTED ****\nEXECMVC4 MVC   0(*-*,R7),1(R2)              **** EXECUTED ****\nEXECMVC5 MVC   LINE+4(*-*),1(R2)            **** EXECUTED ****\nEXECMVC6 MVC   0(*-*,R6),LINE               **** EXECUTED ****\n*\nDMYDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,EXLST=DMYDCB\nDMYDCBL  EQU   *-DMYDCB                     DCB LENGTH\nEXITLIST DS    0F\n         DC    X'87',AL3(PRNTJFCB)          JFCB EXIT\nPRNTJFCB DS    CL176                        JFCB AREA\n         LTORG\n*\n         TITLE '- MSGRTN -  MESSAGE ROUTINE WORK AREA'\nMSGWRK   DSECT\n*\nHEADNOS  DS    F                            HEADING COUNTER\nDOUBLE   DS    D                            DOUBLEWORD WORK AREA\n*\nDOMPTR   DS    F                            FIRST AVAILABLE SLOT\nDOMLIST  DS    15F                          15 MSGID SLOTS\nDOMEND   EQU   DOMLIST+60                   END OF MSGID LIST\n*\nWTORL    DS    0F\n         DC    AL1(*-*)                     REPLY LENGTH\n         DC    AL3(*-*)                     REPLY ADDRESS\n         DC    A(*-*)                       ECB ADDRESS\nWTOL     DS    0F\n         DC    AL2(*-*)                     REXT LENGTH\nMCSFLAGS DC    B'0000000000000000'          MCS FLAGS\nWTOTEXT  DC    CL124' '                     TEXT\nDESCODES DC    B'0000000000000000'          DESCRIPTOR CODES\n         DC    B'0000000000000000'          ROUTING CODES\n*\nTITLES   DS    CL256                        TITLE BUFFER\nHEADINGS DS    6CL256                       6 HEADING SLOTS\nLINE     DS    CL256                        PRINT LINE BUFFER\n*\nTITLEN   DS    H                            TITLE DATA LENGTH\nPAGEADDR DS    F                            PAGE NUMBER ADDRESS\n*\nPAGENO   DS    F                            CURRENT PAGE NUMBER\nLINENO   DS    F                            CURRENT LINE NUMBER\n*\nMSGLRECL DS    H                            USABLE RECORD LENGTH\n*\nMSGFLAG  DS    X                            FLAG\nNOPRINT  EQU   B'00000001'                  NO OUTPUT DD CARD\nTSOUSER  EQU   B'00000010'                  TSO USER\nPRERR10  EQU   B'00000100'                  PREVIOUS PRINT ERROR\n*\nMSGDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,EXLST=MSGDCB\n*\nOPENL    OPEN  (MSGDCB,(OUTPUT)),MF=L\n*\nRDJFCBL  RDJFCB (MSGDCB),MF=L\n*\nMSGWKLEN EQU   *-MSGWRK\n         POP   USING,PRINT                                     #DD01097\n         TITLE '- MSGRTN -  ADDRESS SPACE CONTROL BLOCK'\n         DSECT\n         IHAASCB\n         PUSH  USING,PRINT\n         PRINT ON,GEN\n         DROP  ,\n         TITLE '- GETFMT5  -  FORMAT5.DSCB FORMATING SUBROUTINE'\nGETFMT5  #START ,\n         TITLE '- GETFMT5  -  INITIALIZATION'\n*---------------------------------------------------------------------*\n*        FIND THE DCB / DEB / UCB ADDRESSES                           *\n*---------------------------------------------------------------------*\n         L     R5,0(R1)                     >>---> DCB\n         LA    R5,0(,R5)                    TURN OFF HIGH ORDER\n         L     R1,DCBDEBAD-IHADCB(R5)       >>---> DEB\n         ST    R1,DEBADDR                   SAVE DEB ADDRESS\n         SLR   R2,R2               CLEAR BEFORE INSERT\n         ICM   R2,B'0111',DEBSUCBA+1-DEBBASIC(R1)     >>---> UCB\n         ST    R2,UCBADDR                   SAVE UCB ADDRESS\n         TITLE '- GETFMT5  -  CALCULATE AND AQUIRE STORAGE SPACE'\n*---------------------------------------------------------------------*\n*        FIND THE NUMBER OF EXTENTS AND GET ENOUGH SPACE              *\n*---------------------------------------------------------------------*\n         LR    R0,R2                        >>---> UCB\n         LA    R1,LSPACE                    >>---> RETURN BUFFER\n         SVC   78                           ISSUE LSPACE SVC\n         CLI   LSPEXTS+4,C'/'               MAKE SURE IT WORKED\n         BNE   EXITRC8                      IF NOT TERMINATE\n         PACK  DBLWORD,LSPEXTS(4)           PACK EXTENTS NUMBER\n         CVB   R2,DBLWORD                   GET IN BINARY\n         LR    R9,R2                        SAVE EXTENT COUNT\n         MH    R2,=H'5'                     CALCULATE SPACE REQ\n         LA    R2,4(,R2)                    ALLOW FOR COUNT FLD\n         GETMAIN R,LV=(R2)                  GET FMT5 SPACE\n         ST    R1,TABADDR                   SAVE START ADDRESS\n         LR    R3,R1                        SAVE START ADDRESS\n         LA    R2,0(R2,R1)                  POINT TO END ADDRESS\n         ST    R2,ENDADDR                   SAVE END   ADDRESS\n         ST    R9,0(R1)                     SAVE EXTENT COUNT\n         TITLE '- GETFMT5  -  VTOC TYPE DETERMINATION'\n*---------------------------------------------------------------------*\n*        DETERMINE IF THE VOLUME IS INDEXED OR NOT                    *\n*---------------------------------------------------------------------*\n         L     R6,UCBADDR                   LOAD UCB ADDRESS\n         PUSH  ACONTROL\n         ACONTROL FLAG(NOPAGE0)\n         CVAFTST UCB=(R6)                   CHECK IF INDEXED\n         POP   ACONTROL\n         B     *+4(R15)                     BRANCH ACCORDINGLY\n         B     SPACE040                     DF/DS NOT ON SYSTEM\n         B     SPACE040                     VTOC IS NOT INDEXED\n         B     SPACE020                     VTOC IS INDEXED\n         B     EXITRC8                      VOLUME NOT MOUNTED\n         B     EXITRC8                      UCB NOT DASD DEVT\n         TITLE '- GETFMT5  -  BUILD INDEXED VTOC FREESPACE TABLE'\n*---------------------------------------------------------------------*\n*        PROCESS ANY VOLUMES WITH INDEXED VTOCS                       *\n*---------------------------------------------------------------------*\nSPACE020 DS    0H\n         LTR   R9,R9                        CHECK EXTENT COUNT\n         BZ    EXITRC0                      IF NONE TERMINATE\n         LA    R3,4(,R3)                    SKIP LENGTH\n         MVI   F5EXTNT,X'01'                ONLY 1 AT A TIME\n         LA    R4,F5EXTNT                   >>---> F5 BUFFER\n         L     R6,DEBADDR                   >>---> DEB\nSPACE030 DS    0H\n         CVAFDSM ACCESS=MAPDATA,            GET ALL POSSIBLE           X\n               MAP=VOLUME,                      FMT5'S                 X\n               EXTENTS=(R4),                                           X\n               DEB=(R6),                                               X\n               COUNT=NO,                                               X\n               BRANCH=NO\n         MVC   0(5,R3),F5EXTNT+1            SAVE THIS EXTENT\n         LA    R3,5(,R3)                    ADVANCE POINTER\n         BCT   R9,SPACE030                  FILL THE ENTIRE TBL\n         B     EXITRC0                      WHEN ALL DONE QUIT\n         TITLE '- GETFMT5  -  BUILD NON-INDEXED VTOC FREESPACE TABLE'\n*---------------------------------------------------------------------*\n*        PROCESS ANY VOLUMES WITH NON-INDEXED VTOCS                   *\n*---------------------------------------------------------------------*\nSPACE040 DS    0H\n         XC    READF5,READF5                CLEAR THE ECB\n         READ  READF5,SF,(R5),FORMAT4,MF=(E,READFMT5)\n         CHECK READF5                       WAIT FOR I/O TO END\n         NOTE  (R5)                         GET FMT4 TTR0\n         ST    R1,VTOCTTR                   SAVE FOR LATER\n         MVC   FULLWORD,=X'00000200'        START AT FIRST FMT5\n         LA    R7,FORMAT5                   POINT TO BUFFER\n         LA    R3,4(,R3)                    SKIP COUNT\nSPACE050 DS    0H\n         C     R3,ENDADDR                   CHECK FOR END\n         BE    SPACE080                     IF SO QUIT\n         POINT (R5),FULLWORD                POINT TO FMT5 BLOCK\n         XC    READF5,READF5                CLEAR ECB\n         READ  READF5,SF,(R5),FORMAT5,MF=(E,READFMT5)\n         CHECK READF5                       WAIT FOR I/O TO END\n         MVC   0(5,R3),FORMAT5+DS5AVEXT-IECSDSL5\n         LA    R3,5(,R3)                    ADVANCE POINTER\n         LA    R9,FORMAT5+DS5EXTAV-IECSDSL5 POINT TO FORMAT5\n         LA    R10,7                        LOAD LOOP COUNT\nSPACE060 DS    0H\n         C     R3,ENDADDR                   CHECK FOR END\n         BE    SPACE080                     IF SO QUIT\n         MVC   0(5,R3),0(R9)                MOVE AN EXTENT\n         LA    R3,5(,R3)                    ADVANCE POINTER\n         LA    R9,5(,R9)                    ADVANCE POINTER\n         BCT   R10,SPACE060\n         LA    R9,FORMAT5+DS5MAVET-IECSDSL5 POINT TO FORMAT5\n         LA    R10,18                       LOAD LOOP COUNT\nSPACE070 DS    0H\n         C     R3,ENDADDR                   CHECK FOR END\n         BE    SPACE080                     IF SO QUIT\n         MVC   0(5,R3),0(R9)                MOVE AN EXTENT\n         LA    R3,5(,R3)                    ADVANCE POINTER\n         LA    R9,5(,R9)                    ADVANCE POINTER\n         BCT   R10,SPACE070                 MOVE ALL EXTENTS\n         SLR   R1,R1                        CLEAR REGISTER\n         ICM   R1,B'0011',FORMAT4+44+DS4VTOCE+2-IECSDSL4\n         MH    R1,FORMAT4+44+DS4DEVSZ+2-IECSDSL4\n         SLR   R0,R0                        CLEAR REGISTER\n         ICM   R0,B'0011',FORMAT4+44+DS4VTOCE+4-IECSDSL4\n         AR    R1,R0                        CALC VTOC TT\n         SLR   R2,R2                        CLEAR REGISTER\n         ICM   R2,B'0011',FORMAT5+DS5PTRDS-IECSDSL5\n         MH    R2,FORMAT4+44+DS4DEVSZ+2-IECSDSL4\n         SLR   R0,R0                        CLEAR REGISTER\n         ICM   R0,B'0011',FORMAT5+DS5PTRDS+2-IECSDSL5\n         AR    R2,R0                        CALC FMT4 TT\n         SR    R2,R1                        CALC DIFFERENCE\n         STH   R2,FULLWORD                  SAVE RELATIVE TT\n         MVC   FULLWORD+2(1),FORMAT5+DS5PTRDS+4-IECSDSL5\n         MVI   FULLWORD+3,X'00'             MAKE SURE ZEROS\n         CLC   FULLWORD,=F'00'              CHECK FOR ZEROS\n         BNE   SPACE050                     IF NOT KEEP LOOPING\nSPACE080 DS    0H\n         POINT (R5),VTOCTTR                 POINT AT THE FMT4\n         B     EXITRC0                      TERMINATE NORMALLY\n         TITLE '- GETFMT5  -  TERMINATION ROUTINES'\n*---------------------------------------------------------------------*\n*        TERMINATE GIVING THE APPROPRIATE RETURN CODE                 *\n*---------------------------------------------------------------------*\nEXITRC8  DS    0H\n         LA    R15,8                        SET RC = 8\n         B     SPACEND                      TERMINATE\nEXITRC4  DS    0H\n         LA    R15,4                        SET RC = 4\n         B     SPACEND                      TERMINATE\nEXITRC0  DS    0H\n         L     R1,TABADDR                   LOAD TABLE ADDRESS\n         LA    R15,0                        SET RC = 0\nSPACEND  DS    0H\n         #STOP RC=(R15),R1=R1\n\n*---------------------------------------------------------------------*\n*                         CONSTANTS                                   *\n*---------------------------------------------------------------------*\nREADFMT5 READ  READF5,SF,0,0,MF=L\nF5EXTNT  DS    XL1,CL5                      LENGTH + F5INFO\nDBLWORD  DS    D\nFULLWORD DS    F\nVTOCTTR  DS    F\nDEBADDR  DS    F\nUCBADDR  DS    F\nTABADDR  DS    F\nENDADDR  DS    F\nLSPACE   DS    0CL30\n         DC    CL6'SPACE='\nLSPTCYL  DC    CL4' ',CL1' '\nLSPTTRK  DC    CL4' ',CL1' '\nLSPEXTS  DC    CL4' ',CL1' '\nLSPLCYL  DC    CL4' ',CL1' '\nLSPLTRK  DC    CL4' '\nFORMAT4  DS    CL140\nFORMAT5  DS    CL140\n         LTORG\n         POP   PRINT,USING                                     #DD01097\n\n         PUSH  USING,PRINT\n         PRINT ON,GEN\n         DROP  ,\n         TITLE '- SORTRTN  -  TABLE SORT SUBROUTINE'\nSORTRTN  #START WKDSECT=SORTWORK\n*---------------------------------------------------------------------*\n*        PROCESS THE SORT PARAMETERS                                  *\n*---------------------------------------------------------------------*\n         LM    R2,R7,0(R1)                  LOAD PARAMETERS\n         LH    R2,0(R2)                     LOAD ENTRY COUNT\n         STH   R2,ENTRYCNT                  SAVE ENTRY COUNT\n         LH    R3,0(R3)                     LOAD ENTRY LENGTH\n         STH   R3,ENTRYLEN                  SAVE ENTRY LENGTH\n         LH    R4,0(R4)                     LOAD KEY LENGTH\n         STH   R4,KEYLEN                    SAVE KEY LENGTH\n         MVC   SEQUENCE(1),0(R5)            SAVE SORT SEQUENCE\n         ST    R6,STRTADDR                  SAVE START ADDRESS\n         NI    STRTADDR,X'7F'               TURN OFF HIGH BIT\n         ST    R7,SAVER7                    SAVE OFFSET\n         SLR   R7,R7                        CLEAR REGISTER\n         TM    16(R1),X'80'                 CHECK FOR OFFSET PARM\n         BO    SORT000                      IF NONE SKIP LOAD\n         L     R7,SAVER7                    RESTORE OFFSET\n         LH    R7,0(R7)                     LOAD KEY OFFSET\nSORT000  DS    0H\n         STH   R7,OFFSET                    SAVE OFFSET\n         LR    R0,R3                        LOAD ENTRY LENGTH\n         GETMAIN R,LV=(0)                   GET TEMPORARY STORAGE\n         ST    R1,SAVEAREA                  SAVE WORKAREA ADDRESS\n         NI    SAVEAREA,X'7F'               TURN OFF HIGH BIT\n         CLC   ENTRYCNT(2),=H'2'            CHECK ENTRY COUNT\n         BL    SORTRC0                      IF 0 OR 1 FORGET SORT\n         CLC   ENTRYLEN(2),=H'00'           CHECK ELEMENT LENGTH\n         BE    SORTRC4                      IF 0 ERROR\n         CLC   KEYLEN(2),=H'00'             CHECK KEY LENGTH\n         BE    SORTRC8                      IF 0 ERROR\n         CLC   KEYLEN(2),ENTRYLEN           COMPARE KEYLEN / ENTRYLEN\n         BH    SORTRC12                     IF HIGHER ERROR\n         CLC   OFFSET(2),ENTRYLEN           COMPARE OFFSET / ENTRYLEN\n         BH    SORTRC16                     IF GREATER ERROR\n         LH    R0,OFFSET                    LOAD OFFSET\n         AH    R0,KEYLEN                    ADD KEYLENGTH TO OFFSET\n         CH    R0,ENTRYLEN                  COMPARE TOTAL / ENTRYLEN\n         BH    SORTRC20                     IF GREATER ERROR\n         CLI   SEQUENCE,C'D'                CHECK FOR DESCENDING\n         BNE   SORT010                      IF NOT DEFAULT TO ASCENDING\n         LA    R5,13                        SETUP FOR CONDITIONAL BRNCH\n         B     SORT020                      SKIP ASCENDING SETUP\nSORT010  LA    R5,11                        MUST BE ASCENDING\nSORT020  SLL   R5,4                         SHIFT TO BITS 28-31\n         ST    R5,BRSWITCH                  SAVE BRANCHING SWITCH\n         NI    BRSWITCH,X'7F'               TURN OFF HIGH BIT\n         MVI   SWITCH,0                     SEQUENCE SWITCH OFF\n         LH    R8,ENTRYLEN                  LOAD ENTRY LENGTH\n         LH    R9,ENTRYCNT                  LOAD RECORD COUNT\n         BCTR  R9,R0                        SUBTRACT 1 FROM COUNT\n         MH    R9,ENTRYLEN                  CALCULATE LENGTH OF TABLE\n         LA    R9,0(R9,R6)                  POINT TO LAST ENTRY\nSORT030  L     R7,STRTADDR                  POINT TO FIRST ENTRY\nSORT040  BXH   R7,R8,SORT060                LOOP TILL END OF TABLE\n         LR    R2,R7                        LOAD THIS ENTRY ADDRESS\n         SR    R2,R8                        BACKUP TO PREVIOUS ENTRY\n         AH    R2,OFFSET                    ADD OFFSET\n         LH    R3,KEYLEN                    LOAD KEY LENGTH\n         LR    R4,R7                        LOAD THIS ENTRY ADDRESS\n         AH    R4,OFFSET                    ADD OFFSET\n         LH    R5,KEYLEN                    LOAD KEY LENGTH\n         CLCL  R4,R2                        COMPARE CURRENT TO PREVIOUS\n         L     R5,BRSWITCH                  LOAD BRANCHING SWITCH\n         EX    R5,SORT050                   BR ACCORDING TO SEQUENCE\n         MVI   SWITCH,1                     SEQUENCE SWITCH ON\n         LR    R2,R7                        LOAD THIS ENTRY ADDRESS\n         LH    R3,ENTRYLEN                  LOAD ENTRY LENGTH\n         L     R4,SAVEAREA                  LOAD SAVE AREA ADDRESS\n         LH    R5,ENTRYLEN                  LOAD ENTRY LENGTH\n         MVCL  R4,R2                        MOVE ENTRY TO SAVE AREA\n         LR    R2,R7                        LOAD THIS ENTRY ADDRESS\n         SH    R2,ENTRYLEN                  BACKUP TO PREVIOUS\n         LH    R3,ENTRYLEN                  LOAD ENTRY LENGTH\n         LR    R4,R7                        LOAD THIS ENTRY ADDRESS\n         LH    R5,ENTRYLEN                  LOAD ENTRY LENGTH\n         MVCL  R4,R2                        MOVE PREVIOUS TO ENTRY\n         L     R2,SAVEAREA                  LOAD SAVE AREA ADDRESS\n         LH    R3,ENTRYLEN                  LOAD ENTRY LENGTH\n         LR    R4,R7                        LOAD THIS ENTRY ADDRESS\n         SH    R4,ENTRYLEN                  BACKUP TO PREVIOUS\n         LH    R5,ENTRYLEN                  LOAD ENTRY LENGTH\n         MVCL  R4,R2                        MOVE SAVE AREA TO PREVIOUS\n         B     SORT040                      PROCEED WITH LOOP\n*\nSORT050  NOP   SORT040                      **** EXECUTED ****\n*\nSORT060  CLI   SWITCH,0                     TEST SEQUENCE SWITCH\n         BE    SORTRC0                      IF ZERO SORT COMPLETE\n         MVI   SWITCH,0                     SEQUENCE SWITCH OFF\n         B     SORT030                      START OVER AGAIN\nSORTRC0  LA    R15,0                        SET RC = 0\n         B     SORTEND                      TERMINATE\nSORTRC4  LA    R15,4                        SET RC = 4\n         B     SORTEND                      TERMINATE\nSORTRC8  LA    R15,8                        SET RC = 8\n         B     SORTEND                      TERMINATE\nSORTRC12 LA    R15,12                       SET RC = 12\n         B     SORTEND                      TERMINATE\nSORTRC16 LA    R15,16                       SET RC = 16\n         B     SORTEND                      TERMINATE\nSORTRC20 LA    R15,20                       SET RC = 20\nSORTEND  #STOP RC=(R15)                     TERMINATE\n         #STARTWA ,\nENTRYCNT DS    H                            NUMBER OF ENTRIES\nENTRYLEN DS    H                            LENGTH OF EACH ENTRY\nKEYLEN   DS    H                            LENGTH OF SORT KEY\nSEQUENCE DS    C                            SEQUENCE (A/D)\nSTRTADDR DS    F                            TABLE START ADDRESS\nOFFSET   DS    H                            KEY OFFSET INTO TABLE\nBRSWITCH DS    F                            BRANCHING SWITCH FOR A/D\nSAVEAREA DS    F                            TEMPORARY ENTRY ADDRESS\nSWITCH   DS    C                            SORT SWITCH\nSAVER7   DS    F                            SEQUENCE SAVE AREA\n         #STOPWA ,\n         #DSECTS PSA\n         POP   PRINT,USING                                     #DD01097\n         END   ,                            *\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRU": {"ttr": 16905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x02M\\x02M\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 589, "newlines": 589, "modlines": 0, "user": "SOURCE"}, "text": "PRU      TITLE 'PDS RESCUE UTILITY'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*=====================================================================*\n*                                                                     *\n*PURPOSE:IF YOU HAVE EVER ACCIDENTLY DONE A SAVE AT THE WRONG TIME    *\n*        UNDER SPF, PROBABLY LIKE MOST PEOPLE -- YOU REALIZE          *\n*        10 MILLISECS AFTER HITTING THE ENTER KEY.                    *\n*                                                                     *\n*        THIS PROGRAM SHOULD HELP YOU RECOVER THE ORIGINAL MEMBER     *\n*        PROVIDING THAT YOU RUN THIS PROGRAM BEFORE DOING ANY         *\n*        COMPRESSES. IT LOCATES ALL DEAD MEMBERS IN THE PDS AND       *\n*        COPIES THEM TO AN OUTPUT PDS GIVING THEM MEMBER NAMES OF     *\n*        MEM001 TO MEMNNN WHERE MEMNNN WILL BE THE MOST RECENTLY      *\n*        SAVED MEMBER. (DELETED MEMBERS ARE ALSO COPIED BUT THEIR     *\n*        MEM NUMBER IS NOT PREDICATABLE).                             *\n*                                                                     *\n*        SPF BROWSE, EDIT OR ANY EQUIVALENT MEANS MAY THEN BE USED TO *\n*        LOCATE THE DESIRED ONE. IF THIS IS DONE IMMEDIATLY AFTER THE *\n*        10 MILLISECS MENTIONED ABOVE IT SHOULD BE MEMNNN.            *\n*                                                                     *\n*                                                                     *\n*METHOD: (1) READS PDS DIRECTORY AND STORES ALL ACTIVE MEMBER TTRS.   *\n*                                                                     *\n*        (2) READS ENTIRE INPUT PDS DATA. IF A BLOCK BEGINS AFTER     *\n*            AN END-OF-FILE IT IS DEEMED TO BE THE BEGINNING OF THE   *\n*            MEMBER.  IF NOT A TTR FOUND ABOVE THEN THIS IS A DEAD    *\n*            MEMBER AND WRITTEN TO THE OUTPUT PDS. A SUMMARY OF EACH  *\n*            MEMBER THUS WRITTEN IS LOGGED ON  THE PRT FILE.          *\n*                                                                     *\n*        (3) AT THE END OF PDS (HIGHEST TTR ON FILE IS REACHED) THE   *\n*            OUTPUT PDS IS FIXED TO GIVE PROPER DCB ATTRUIBUTES.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SAMPLE JCL:                                                  *\n*        //PRU      EXEC  PGM=PRU,REGION=4M,                          *\n*        //*        PARM=ALL   <--- COPY \"LIVE\" MEMBERS AS WELL       *\n*        //STEPLIB  DD    DSN=PRU.LOADLIB,DISP=SHR                    *\n*        //SYSPRINT DD    SYSOUT=*                                    *\n*        //SYSUDUMP DD    SYSOUT=*                                    *\n*        //INPUT    DD    DISP=SHR,DSN=UNCOMPRESSED.PDS               *\n*        //OUTPUT   DD    DSN=PRU.OUTPUT.FILE,DISP=(,CATLG),          *\n*        //         UNIT=SYSDA,SPACE=(CYL,(1,1,90))                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        #DD99253 - ADD RETURN CODE 4 FOR \"NO OUTPUT MEMBERS\"         *\n*        #DD04223 - READ TILL END OF \"USED\" PORTION OF DATASET.       *\n*                 - RECOGNIZE PDS/E INPUT DATASET.                    *\n*        #DD06229 - CORRECT DCB PROCESSING ERROR.                     *\n*        #DD12062 - ADD EAV SUPPORT.                                  *\n*                                                                     *\n*=====================================================================*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 macro format\n         SYSSTATE ARCHLVL=2        Assembly requires z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly requires z/OS 1.13 & higher\n\nPRU      #START BASE=(R12),WKCSECT=WRKCSECT,                           *\n               APARS=,COPY=YES,                                        *\n               LEVEL=V001R04                                   #DD06229\n         USING PSA,0\n\n*-------\n*\n*        VALIDATE PARAMETER LIST\n*\n*-------\n\n         L     R1,0(R1)            >>---> PARAMETER LIST\n         LH    R2,0(R1)            LOAD PARAMETER LENGTH\n         LA    R1,2(,R1)           >>---> PARAMETER DATA\n         CH    R2,=AL2(3)          CHECK FOR VALID LENGTH\n         BNE   PRU00100\n         CLC   0(3,R1),=C'ALL'     CHECK FOR PARM='ALL'\n         BNE   PRU00100\n         OI    FLAGBYTE,FLAGALL    REMEMBER TO COPY ALL MEMBERS\n\n*-------\n*\n*        OPEN OUTPUT MESSAGE FILE\n*\n*-------\n\nPRU00100 DS    0H\n         LA    R2,DCBDDNAM-IHADCB+SYSPRINT\n         MVC   ERROR1+17(8),0(R2)\n         TIOTSCAN DDN=(R2),NOK=ERROR1\n         OPEN  (SYSPRINT,OUTPUT)   OPEN THE MESSAGE FILE\n         TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN\n         BNO   ERROR1\n\n*-------\n*\n*        BUILD A MEMBER NAME/TTR TABLE\n*\n*-------\n\n         LA    R2,DCBDDNAM-IHADCB+DIRDCB\n         MVC   ERROR1+17(8),0(R2)\n         TIOTSCAN DDN=(R2),NOK=ERROR1\n\n         RDJFCB BSAMDCB            GET INPUT JFCB              #DD04223\n\n         LA    R14,INJFCB                                      #DD06229\n         USING INFMJFCB,R14                                    #DD06229\n         MVC   DSNAME,JFCBDSNM     DSN=                        #DD06229\n         MVC   LRECL,JFCLRECL      LRECL=                      #DD06229\n         MVC   VOLSER,JFCBVOLS     VOL=                        #DD06229\n         DROP  R14                                             #DD06229\n\n         OBTAIN SEARCHPL,EADSCB=OK GET FORMAT1 DSCB            #DD12062\n         TM    DS1SMSFG,DS1PDSE    CHECK FOR PDS/E             #DD04223\n         BO    ERROR4                                          #DD04223\n         MVC   MAXTTR,DS1LSTAR     SAVE LAST TTR ADDRESS       #DD04223\n\n         OPEN  (DIRDCB,INPUT)      OPEN THE DIRECTORY\n         TM    DIRDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BNO   ERROR1\n         LA    R3,MEMTAB@          >>---> 1ST ENTRY POINTER\n\n         B     PRU00300            READ THE FIRST DIRECTORY BLOCK\nPRU00200 DS    0H\n         IC    R1,11(0,R2)         LOAD LENGTH OF NEXT ENTRY\n         SLL   R1,27\n         SRL   R1,26\n         LA    R2,12(R1,R2)        >>---> NEXT DIRECTORY ENTRY\n         CLR   R2,R4               CHECK FOR END OF DIRECTORY BLOCK\n         BL    PRU00400\nPRU00300 DS    0H\n         GET   DIRDCB              READ IN A DIRECTORY BLOCK\n         LH    R4,0(0,R1)          LOAD LENGTH OF CURRENT BLOCK\n         LA    R4,0(R1,R4)         >>---> LAST USED BYTE IN DIRECTORY\n         LA    R2,2(0,R1)          >>---> FIRST ENTRY IN DIRECTORY\nPRU00400 DS    0H\n         CLI   0(R2),255           CHECK FOR END OF DIRECTORY\n         BE    PRU00500\n\n         GETMAIN RU,LV=MEMTABLN    GET STORAGE FOR NEW ENTRY\n         ST    R1,0(R3)            CHAIN TO PREVIOUS ENTRY\n         LR    R3,R1               >>---> NEW MEMBER ENTRY\n         USING MEMTABD,R3\n         XC    0(MEMTABLN,R3),0(R3)\n         MVC   MEMNAME,0(R2)       INSERT MEMBER NAME\n         MVC   MEMTTR,8(R2)        INSERT RELATIVE TTR OF DATA\n         DROP  R3\n         B     PRU00200            LOOP TILL END OF DIRECTORY\n\nPRU00500 DS    0H\n         CLOSE DIRDCB              CLOSE THE DIRECTORY\n\n*-------\n*\n*        COPY ALL MEMBERS TO OUTPUT DATASET\n*\n*-------\n\n         LA    R2,DCBDDNAM-IHADCB+BSAMDCB\n         MVC   ERROR1+17(8),0(R2)\n         TIOTSCAN DDN=(R2),NOK=ERROR1\n         OPEN  (BSAMDCB,INPUT)\n         TM    BSAMDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BNO   ERROR1\n\n         LA    R2,DCBDDNAM-IHADCB+BPAMDCB\n         MVC   ERROR1+17(8),0(R2)\n         TIOTSCAN DDN=(R2),NOK=ERROR1\n         OPEN  (BPAMDCB,OUTPUT)\n         TM    BPAMDCB+DCBOFLGS-IHADCB,DCBOFOPN\n         BNO   ERROR1\n\n         ESTAE TRAPABND,PARAM=(R12) SET ESTAE EXIT\n\n*-------\n*\n*        READ EACH MEMBER WHETHER IT IS IN THE DIRECTORY OR NOT\n*\n*-------\n\nPRU00600 DS    0H\n         MVI   CURRTTR+3,1         SETUP TO READ NEXT BLOCK\n         POINT BSAMDCB,CURRTTR     POINT TO NEXT TTR\n         READ  RDECB,SF,BSAMDCB,BUFF,'S'\n         CHECK RDECB               WAIT FOR COMPLETION OF READ\n\n         TM    FLAGBYTE,FLAGSYNA   CHECK FOR SYNAD ERROR\n         BO    ERROR2M             ISSUE ERROR MESSAGE\n\n         NOTE  BSAMDCB             GET CURRENT TTR\n         ST    R1,CURRTTR          SAVE CURRENT TTR\n         MVI   CURRTTR+3,0\n\n         TM    FLAGBYTE,FLAGDIR    CHECK IF DIRECTORY HAS BEEN READ\n         BNO   PRU00600            IF NOT READ TILL END OF DIRECTORY\n\n*-------\n*\n*        CHECK IF THE CURRENT MEMBER IS IN THE DIRECTORY\n*\n*-------\n\n         L     R1,BLKCNT           LOAD EXISTING BLOCK COUNT\n         LA    R1,1(,R1)           ADD 1 TO BLOCK COUNT\n         ST    R1,BLKCNT           SAVE NEW BLOCK COUNT\n         C     R1,=F'1'            CHECK FOR FIRST BLOCK\n         BNE   PRU01000\n\n         NOTE  BSAMDCB             GET CURRENT TTR\n         ST    R1,STARTTTR         SAVE STARTING TTR ADDRESS\n\n         L     R14,=A(BUFF)                                    #DD12062\n         MVC   PR1STLNE,0(R14)     COPY FIRST LINE             #DD12062\n         NI    FLAGBYTE,255-FLAGDEAD\n         LA    R3,MEMTAB@          >>---> START OF MEMBER TABLE\nPRU00800 DS    0H\n         USING MEMTABD,R3\n         CLC   MEMTTR,CURRTTR      CHECK FOR MATCHING TTR\n         BE    PRU00900            IF SO DO REMEMBER MEMBER NAME\n         ICM   R3,B'1111',MEMNEXT@ >>---> NEXT MEMBER IN DIRECTORY\n         BNZ   PRU00800\n         OI    FLAGBYTE,FLAGDEAD   COPY THIS MEMBER\n         B     PRU01000\n\nPRU00900 DS    0H\n         MVC   STOWNAME(8),MEMNAME\n         DROP  R3\n\nPRU01000 DS    0H\n         TM    FLAGBYTE,FLAGDEAD   CHECK IF THIS IS A DEAD MEMBER\n         BO    PRU01100            IF SO ALWAYS COPY IT\n         TM    FLAGBYTE,FLAGALL    CHECK IF COPYING ALL MEMBERS\n         BNO   PRU00600            IF NOT READ NEXT THROUGH THIS MEMBER\n\nPRU01100 DS    0H\n         LH    R1,DCBBLKSI-IHADCB+BSAMDCB\n         L     R14,RDECB+16        >>---> IOB\n         SH    R1,14(R14)          SUBTRACT RESIDUAL\n         STH   R1,DCBBLKSI-IHADCB+BPAMDCB\n         A     R1,BLKBYTES\n         ST    R1,BLKBYTES         ACCUMULATE TOTAL BYTES WRITTEN\n         WRITE WDECB,SF,BPAMDCB,BUFF,'S'\n         CHECK WDECB\n         B     PRU00600            LOOP TILL END OF CURRENT MEMBER\n\n*-------\n*\n*        PROCESS AFTER END OF MEMBER\n*\n*-------\n\nPRU01200 DS    0H\n         NOTE  BSAMDCB             GET CURRENT TTR\n         ST    R1,CURRTTR          SAVE CURRENT TTR\n         ST    R1,ENDTTR           SAVE LAST TTR\n\n         MVI   CURRTTR+3,0\n         TM    FLAGBYTE,FLAGDIR    CHECK IF DIRECTORY WAS READ\n         BO    PRU01300\n         OI    FLAGBYTE,FLAGDIR    REMEMBER THE DIRECTORY WAS PROCESSED\n         B     PRU01900            PROCEED WITH NEXT ENTRY\nPRU01300 DS    0H\n         TM    FLAGBYTE,FLAGDEAD   WAS THIS MEMBER IN THE DIRECTORY\n         BNO   PRU01500            IF NOT PROCEED WITH NEXT ENTRY\n         MVC   STOWNAME(3),=C'MEM' INSERT MEMBER NAME PREFIX\n         ICM   R1,15,BLKCNT        CHECK IF ANY BLOCKS WRITTEN #DD04223\n         BZ    PRU01900            B. IF NOT                   #DD04223\nPRU01400 DS    0H\n         AP    MEMNUM,=PL3'1'      ADD 1 TO MEMBER NUMBER\n         UNPK  STOWNAME+3(5),MEMNUM\n         OI    STOWNAME+7,X'F0'\n\nPRU01500 DS    0H\n         TM    FLAGBYTE,FLAGALL    CHECK IF COPYING ALL MEMBERS\n         BO    PRU01600            IF SO PROCEED AS NORMAL\n         TM    FLAGBYTE,FLAGDEAD   WAS THIS A DEAD MEMBER\n         BNO   PRU01900            IF NOT DO NOT UPDATE DIRECTORY\nPRU01600 DS    0H\n         STOW  BPAMDCB,STOWNAME    STORE MEMBER NAME IN THE DIRECTORY\n         LTR   R15,R15             CHECK FOR STOW ERROR\n         BZ    PRU01700            IF NOT PROCEED\n         TM    FLAGBYTE,FLAGDEAD   WAS THIS MEMBER IN THE DIRECTORY\n         BNO   ERROR3              ERROR3 IF SO PROCESS ERROR\n         CH    R15,=H'04'          CHECK FOR DUPLICATE MEMBER NAME\n         BE    PRU01400            IF SO TRY A NEW MEMBER NAME\n         B     ERROR3\nPRU01700 DS    0H\n         L     R1,STOW#                                        #DD99253\n         LA    R1,1(,R1)           INCREMENT NUMBER OF MEMBERS #DD99253\n         ST    R1,STOW#                                        #DD99253\n         MVI   PRDEADFL,C' '\n         TM    FLAGBYTE,FLAGDEAD   WAS THIS MEMBER IN THE DIRECTORY\n         BNO   PRU01800\n         MVI   PRDEADFL,C'*'\nPRU01800 DS    0H\n         MVC   PRMEMBER,STOWNAME   COPY MEMBER NAME TO OUTPUT\n\n         SLR   R0,R0\n         ICM   R0,B'1110',STARTTTR GET STARTING TTR\n         L     R1,DCBDEBAD-IHADCB+BPAMDCB\n         LA    R2,DBLWORD          >>---> OUTPUT AREA\n         L     R14,FLCCVT          >>---> CVT\n         L     R15,CVTPCNVT-CVTMAP(R14)\n         STM   R3,R13,SAVEREGS     SAVE DESTROYED REGISTERS\n         LA    R3,SAVEREGS         SAVE SAVE AREA ADDRESS\n         BALR  R14,R15             LINK TO RESIDENT CONVERT RTN\n         LM    R3,R13,0(R3)        RESTORE DESTROYED REGISTERS\n         UNPK  PRTTRSTA(11),DBLWORD+3(6) UNPACK CCHHR\n         TR    PRTTRSTA(11),TRTBL  XLATE TO EBCDIC\n\n         ICM   R0,B'1110',ENDTTR   GET ENDING TTR\n         L     R1,DCBDEBAD-IHADCB+BPAMDCB\n         LA    R2,DBLWORD          >>---> OUTPUT AREA\n         L     R14,FLCCVT          >>---> CVT\n         L     R15,CVTPCNVT-CVTMAP(R14)\n         STM   R3,R13,SAVEREGS     SAVE DESTROYED REGISTERS\n         LA    R3,SAVEREGS         SAVE SAVE AREA ADDRESS\n         BALR  R14,R15             LINK TO RESIDENT CONVERT RTN\n         LM    R3,R13,0(R3)        RESTORE DESTROYED REGISTERS\n         UNPK  PRTTREND(11),DBLWORD+3(6) UNPACK CCHHR\n         TR    PRTTREND(11),TRTBL  XLATE TO EBCDIC\n\n         L     R1,BLKCNT           LOAD BLOCK COUNT\n         CVD   R1,DBLWORD\n         MVC   PRBLKCNT,=X'402020202021'\n         ED    PRBLKCNT,DBLWORD+5\n         LA    R1,PRINTLNE         >>---> LINE TO BE PRINTED\n         BAL   R14,PRINTRTN        PRINT THE LINE\n\nPRU01900 DS    0H\n         XC    BLKCNT,BLKCNT\n         CLC   MAXTTR,ENDTTR       CHECK IF DONE READING       #DD04223\n         BH    PRU00600            B. IF MORE TO READ          #DD04223\n\n*-------\n*\n*        RE-CONSTRUCT THE DCB'S TO SIMULATE THE INPUT DATASET\n*\n*-------\n\nPRU02000 DS    0H\n         CLOSE (BSAMDCB,,BPAMDCB,,SYSPRINT)\n         MVC   EXITLST2+1(3),=AL3(SETDCBO2) CHANGE EXIT\n         OPEN  (BPAMDCB,OUTPUT)    OPEN FOR OUTPUT TO COPY INPUT DCB'S\n         CLOSE (BPAMDCB)\n\n         ICM   R0,15,STOW#         CHECK FOR OUTPUT MEMBERS    #DD99253\n         BNZ   PRUEXIT             B. IF SOME WRITTEN          #DD99253\n         #SETRC 4                  SET RETURN CODE             #DD99253\n\n*-------\n*\n*        RETURN TO CALLER WITH APPROPRIATE RETURN CODE\n*\n*-------\n\nPRUEXIT  #STOP ,                   RETURN TO CALLER\n\nERROR1   WTO   'PRU0001I XXXXXXXX DD STATEMENT MISSING',ROUTCDE=11\n         #SETRC 8                  SET RETURN CODE\n         B     PRUEXIT\n\nERROR2   DS    0H\n         SYNADAF ACSMETH=BSAM\n         MVC   ERROR2M+17(78),50(R1)\n         OI    FLAGBYTE,FLAGSYNA\n         SYNADRLS\n         BR    R14\n\nERROR2M  WTO   'PRU0002I XXXXXXXXX+XXXXXXXXX+XXXXXXXXX+XXXXXXXXX+XXXXXX*\n               XXX+XXXXXXXXX+XXXXXXXXX+XXXXXXXX',ROUTCDE=11\n         #SETRC 12                 SET RETURN CODE\n         B     PRU02000\n\nERROR3   DS    0H\n         MVC   ERROR3M+40(8),STOWNAME INSERT MEMBER NAME\n         CVD   R15,DBLWORD\n         OI    DBLWORD+7,X'0F'\n         UNPK  ERROR3M+53(4),DBLWORD\nERROR3M  WTO   'PRU0003I STOW FAILED FOR MEMBER XXXXXXXX R15=XXXX ',   *\n               ROUTCDE=11\n         #SETRC 16                 SET RETURN CODE\n         B     PRU01900\n\nERROR4   DS    0H                                              #DD04223\n         WTO   'PRU0004I INPUT DD IS A PDS/E',                 #DD04223*\n               ROUTCDE=11                                      #DD04223\n         #SETRC 20                 SET RETURN CODE             #DD04223\n         B     PRUEXIT                                         #DD04223\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ESTAE EXIT                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n\nTRAPABND DS    0H\n         USING *,R15\n         CH    R0,=F'12'           CHECK IF RTM PROVIDED AN SDWA\n         BNE   TRAP0010\n         SLR   R15,R15             IF NOT: PERCOLATE\n         BR    R14                 RETURN TO CALLER\n\n         DROP  R15\n\nTRAP0010 DS    0H\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R4,R1               >>---> SDWA\n         USING SDWA,R4\n         L     R12,SDWAPARM        RE-LOAD BASE REGISTER\n\n         LR    R5,R13              >>---> CALLERS SAVE AREA\n         LA    R13,TRAPSAVE        >>---> ESTAE SAVE AREA\n         ST    R5,TRAPSAVE+4       SAVE CALLERS SAVE AREA ADDRESS\n         ST    R13,8(0,R5)         SAVE OUR SAVE AREA ADDRESS\n\n         CLOSE (BPAMDCB)\n         MVC   EXITLST2+1(3),=AL3(SETDCBO2) CHANGE EXIT\n         OPEN  (BPAMDCB,OUTPUT)    OPEN FOR OUTPUT TO COPY INPUT DCB'S\n         CLOSE (BPAMDCB)\n\n         L     R13,4(,R13)         RESTORE CALLERS SAVE AREA ADDRESS\n         SETRP RC=0,                                                   *\n               WKAREA=(4),                                             *\n               REGS=(14,12),                                           *\n               DUMP=YES\n\n         POP   USING\n\nSTOWNAME DS    0H\n         DC    CL8'MEM-----',XL4'0'\nMEMNUM   DC    PL3'0'\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,RECFM=FBA,                     *\n               DSORG=PS,EXLST=EXITLST3,                                *\n               DCBE=DCBE1                                      #DD12062\nDCBE1    DCBE  EADSCB=OK                                       #DD12062\nDIRDCB   DCB   DDNAME=INPUT,MACRF=GL,                                  *\n               DSORG=PS,RECFM=F,LRECL=256,BLKSIZE=256,                 *\n               DCBE=DCBE2                                      #DD12062\nDCBE2    DCBE  EADSCB=OK                                       #DD12062\nBSAMDCB  DCB   DDNAME=INPUT,MACRF=RP,                                  *\n               EODAD=PRU01200,SYNAD=ERROR2,                            *\n               DSORG=PS,EXLST=EXITLIST,                                *\n               DCBE=DCBE3                                      #DD12062\nDCBE3    DCBE  EADSCB=OK                                       #DD12062\nBPAMDCB  DCB   DDNAME=OUTPUT,MACRF=W,                                  *\n               DSORG=PO,EXLST=EXITLST2,                                *\n               DCBE=DCBE4                                      #DD12062\nDCBE4    DCBE  EADSCB=OK                                       #DD12062\nEXITLIST DC    0F'0',AL1(000+5),AL3(SAVEDCBI)                  #DD04223\n         DC    0F'0',AL1(128+7),AL3(INJFCB)                    #DD04223\nEXITLST2 DC    0F'0',AL1(128+5),AL3(SETDCBO)\nEXITLST3 DC    0F'0',AL1(128+5),AL3(DCBEXIT)\nINJFCB   DC    0F'0',XL176'00'     INPUT FILE'S JFCB           #DD04223\nSEARCHPL CAMLST SEARCH,DSNAME,VOLSER,WORKAREA,EADSCB=OK        #DD12062\n*=================================================================*\n* SAVE ORIGINAL DCB FORMAT AND MAKE RECFM UNDEFINED.              *\n*=================================================================*\nSAVEDCBI DC    0H'0'\n         USING IHADCB,R1                                       #DD06229\n         USING SAVEDCBI,R15                                    #DD06229\n         MVC   RECFM,DCBRECFM                                  #DD06229\n         MVI   DCBRECFM-IHADCB+BSAMDCB,DCBRECU                 #DD06229\n         MVC   LRECL,DCBLRECL                                  #DD06229\n         MVC   BLKSIZE,DCBBLKSI                                #DD06229\n         BR    R14\n         DROP  R15                                             #DD06229\n*=================================================================*\n* MAKE OUTPUT DCB LIKE INPUT                                      *\n*=================================================================*\nSETDCBO  DC    0H'0'\n         MVC   DCBRECFM-IHADCB+BPAMDCB,DCBRECFM-IHADCB+BSAMDCB\n         MVC   DCBLRECL-IHADCB+BPAMDCB,=H'00'\n         MVC   DCBBLKSI-IHADCB+BPAMDCB,DCBBLKSI-IHADCB+BSAMDCB\n         BR    R14\nSETDCBO2 DC    0H'0'\n         MVC   DCBBLKSI-IHADCB+BPAMDCB,BLKSIZE\n         MVC   DCBLRECL-IHADCB+BPAMDCB,LRECL\n         MVC   DCBRECFM-IHADCB+BPAMDCB,RECFM\n         BR    R14\nDCBEXIT  DS    0H\n         #DCBEXIT LRECL=133\nPRINTRTN DS    0H\n         STM   R0,R15,SAVEREGS     SAVE ALL REGISTERS\n         LR    R10,R1              >>>---> RECORD TO BE PRINTED\n         AP    LINE#,=PL3'1'       ADD 1 TO LINE NUMBER\n         CP    LINE#,=PL3'60'      CHECK IF TITLES ARE REQUIRED\n         BNE   PRINT010\n         L     R1,PAGE#            LOAD OLD PAGE NUMBER\n         LA    R1,1(,R1)           ADD 1 TO PAGE NUMBER\n         ST    R1,PAGE#            SAVE CURRENT PAGE NUMBER\n         CVD   R1,DBLWORD\n         MVC   PRTPAGE#,=X'402020202021'\n         ED    PRTPAGE#,DBLWORD+5\n         PUT   SYSPRINT,TITLE1\n         PUT   SYSPRINT,TITLE2\n         PUT   SYSPRINT,TITLE3\n         PUT   SYSPRINT,TITLE4\n         PUT   SYSPRINT,TITLE5\n         MVC   LINE#,=PL3'6'\nPRINT010 DS    0H\n         PUT   SYSPRINT,0(R10)     PRINT RECORD\n         LM    R0,R15,SAVEREGS     RESTORE ALL REGISTERS\n         BR    R14\n\n         LTORG ,\nLINE#    DC    PL3'+59'            LINE NUMBER\nPAGE#    DC    F'0'                PAGE NUMBER\nTITLE1   DC    CL133'1 '\n         ORG   TITLE1+57\n         DC    C'PDS Rescue Utility'\n         ORG   TITLE1+123\n         DC    C'Page'\nPRTPAGE# DS    CL6\n         ORG   ,\nTITLE2   DC    CL133'0 '\n         ORG   TITLE2+2\n         DC    C' Member   Input Dataset CCHHR    Block'\n         ORG   ,\nTITLE3   DC    CL133'  '\n         ORG   TITLE3+2\n         DC    C'  Name   Starting       Ending   Count First Record'\n         ORG   ,\nTITLE4   DC    CL133'+ '\n         ORG   TITLE4+2\n         DC    C'  ____   _____________________   _____ ____________'\n         ORG   ,\nTITLE5   DC    CL133'  '\nABENDCDE DC    XL3'00'\nPRINTLNE DC    CL133' '\n         ORG   PRINTLNE+1\nPRDEADFL DC    CL1' '\nPRMEMBER DC    CL8' '\n         DC    CL1' '\nPRTTRSTA DC    CL11' '\nPRTTREND DC    CL11' '\n         DC    CL1' '\nPRBLKCNT DC    CL6' '\n         DC    CL1' '\nPR1STLNE DC    CL80' '\n         ORG   ,\nTRAPSAVE DS    18F                 ESTAE SAVE AREA\nBLKSIZE  DS    H                   INPUT BLOCKSIZE\nLRECL    DS    H                     \"   LRECL\nRECFM    DS    X                     \"   RECFM\nTRTBL    DS    0CL256\n         DC    CL240' '\n         DC    C'0123456789ABCDEF'\n\nBUFF     DS    0D,CL(32*1024)      READ/WRITE BUFFER\n\n         #STARTWA ,\nBLKBYTES DS    F\nBLKCNT   DS    F\nCURRTTR  DS    F\nDBLWORD  DS    D\nENDTTR   DS    F\nFLAGBYTE DS    X\nFLAGDEAD EQU   X'80'               CURRENT MEMBER IS NOT IN DIRECTORY\nFLAGDIR  EQU   X'40'               DIRECTORY HAS BEEN READ\nFLAGSYNA EQU   X'10'               BSAM SYNAD ERROR OCCURRED\nFLAGALL  EQU   X'08'               ALL MEMBERS ARE TO BE COPIED\nMAXTTR   DS    XL3\nMEMTAB@  DS    F                   >>---> MEMBER NAME TABLE\nSAVEREGS DS    16F\nSTARTTTR DS    F\nSTOW#    DS    F                   NUMBER OF OUTPUT MEMBERS    #DD99253\nDSNAME   DC    CL44' '             DATASET NAME                #DD04223\nVOLSER   DC    CL6' '              VOLUME SERIAL               #DD04223\nWORKAREA DC    0F'0',265X'00'      OBTAIN WORK AREA            #DD04223\n         ORG   WORKAREA-L'DS1DSNAM                             #DD04223\n         IECSDSL1 1                FORMAT 1 DSCB               #DD04223\n         ORG   ,                                               #DD04223\n         #STOPWA ,\n\nMEMTABD  DSECT ,\nMEMNEXT@ DS    F                   >>---> NEXT ENTRY IN TABLE\nMEMNAME  DS    CL8                 MEMBER NAME\nMEMTTR   DS    CL3                 TTR\nMEMTABLN EQU   *-MEMTABD\n         #DSECTS CVT,DCB,JFCB,SDWA,PSA                         #DD04223\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRUREXX": {"ttr": 17161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00V\\x01\\x00\\x06?\\x01\\x00\\x06?\\x16\\x13\\x00g\\x00g\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-03-03T00:00:00", "modifydate": "2000-03-03T16:13:56", "lines": 103, "newlines": 103, "modlines": 0, "user": "REXX"}, "text": "/*-REXX/PRUREXX ------------------------------\n   SYNTAX:   PRUREXX dsn {anychar}\n   AUTHOR:   Oscar Omar Ortega Ortega\n   OUTPUT:   dsn.NEW{.NEW{...}}\n   NOTE:  change \"userid.MVS-JES2.LOADLIB\"\n\n   This EXEC will create various datasets under the user's prefix.\n   You may need to review this REXX if your installation has any\n   file name or other restrictions.\n\n  ---------------------------------------------*/\nTrace O\naddress TSO\nparse upper arg bib param\nif bib = \"\" then do\n   Say 'You must provide PDS name to process'\n   exit\nend\nif param <> '' then param = \"'ALL'\"\n\nupre1 = sysvar(SYSPREF)\nupref = upre1                          /* to avoid second call later */\nif upref = \"\" then upref = Userid()    /* either prefix or userid    */\n\napos1 = pos(\"'\",bib)\nif apos1 = 0 then do                       /* if it has no quotes    */\n   if upre1 <> \"\" then bib = upref\".\"bib   /* append prefix or uid   */\n   bib = \"'\"bib\"'\"\nend\n\nExist = SYSDSN(bib)                    /* check dsn existance        */\nIf Exist <> 'OK'                       /* if not exists, say so      */\nthen do\n   Say 'PDS 'bib' NOT found or not catalogued'\n   exit\nend\n\ndsprin = \"'\"upref\".PRUPGM.SYSPRINT'\"           /* pru pgm sysprint   */\n\nbib2 = bib\ndo forever\n   totlng = length(bib2)                   /* check current length   */\n   bib2 = left(bib2,totlng-1)              /* delete last quote      */\n   bib2 = bib2\".NEW'\"                      /* append .NEW to dsn     */\n   if totlng > 41 then call Change_Name    /* check if dsn > 44 char */\n   Exist = sysdsn(bib2)\n   If Exist <> 'OK'                        /* check dsn existance    */\n   then leave                              /* if so, iterate         */\nend\n\nmsgst =  MSG('OFF')\nif sysdsn(dsprin) = 'OK' then \"DELETE \"dsprin /* if exists, delete it*/\n\nx = LISTDSI(bib directory)                 /* to check if its a PDS  */\nmsgst =  MSG(msgst)\n\nif sysdsorg <> 'PO' & sysdsorg <> 'POU' then do  /* if dsn not a PDS */\n   Say 'Dataset 'bib' is NOT a PDS, it is 'sysdsorg\n   exit\nend\n\nmsgst =  MSG('OFF')\n\"FREE FI(SYSPRINT,INPUT,OUTPUT)\"   /* include SYSUDUMP as optional   */\nmsgst =  MSG(msgst)\n\n/*  allocate all work files       */\n\n\"ALLOC FI(SYSPRINT) DA(\"dsprin\") REUSE UNIT(SYSDA) \",\n       \"SPACE(5 1) TRACKS RECFM(F,B,A) LRECL(133) BLK(27930)\"\n\"ALLOC FI(INPUT)    DA(\"bib\") SHR REUSE\"\n\"ALLOC FI(OUTPUT)   DA(\"bib2\") NEW UNIT(SYSDA) LIKE(\"bib\") RELEASE\"\n\n\"CALL 'userid.MVS-JES2.LOADLIB(PRU)' \"param   /* call PRU program    */\nRcPRU = rc                             /* save return code    */\n\n\"FREE FI(SYSPRINT,INPUT,OUTPUT)\"   /* include SYSUDUMP as optional   */\n\"ALLOC FI(SYSPRINT) DA(*)\"         /* reallocate SYSPRINT to terminal*/\n\nselect\n   when RcPRU = 0 then do\n      if sysvar(\"SYSISPF\") = \"ACTIVE\"\n      then address ISPEXEC \"VIEW DATASET(\"dsprin\")\"\n      else Say 'PDS 'bib' procesed with name 'bib2' successfully'\n   end\n   when RcPRU = 4 then do\n      Say 'PDS 'bib' processed and no members were recovered'\n      msgst =  MSG('OFF')\n      \"DELETE \"dsprin\n      \"DELETE \"bib2\n      msgst =  MSG(msgst)\n   end\n   otherwise Say 'PDS 'bib' procesed with errors RC='RcPRU\nend\nexit\n\nChange_Name:\n fecS = date('S')\n timN = time()\n timN = left(timN,2)substr(timN,4,2)right(timN,2)\n Say 'Output PDS 'bib2\n bib2 = \"'\"upref\".PRUPGM.RECOVERD.D\"right(fecS,6)\".T\"timN\"'\"\n Say 'changed to 'bib2' due to dsn length'\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRUREXX2": {"ttr": 17409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x04\"_\\x01\\x04\"_\\x01\\x10\\x00y\\x00y\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-08-12T00:00:00", "modifydate": "2004-08-12T01:10:06", "lines": 121, "newlines": 121, "modlines": 0, "user": "REXX"}, "text": "/*-REXX/PRUREXX ------------------------------\n   AUTHOR:   Oscar Omar Ortega Ortega (modified by Greg Shirey for BEK)\n      (original source from CBT File452)\n   OUTPUT:   SST.USERID.library.name.RESCUE\n      (unless name is too long, then see bottom of this routine)\n   This EXEC will also create various datasets under the user's prefix.\n\n  ---------------------------------------------*/\nTrace O\naddress TSO\nSay \"                  Ben E. Keith Company \"\nSay \"This utility will 'rescue' deleted or modified members of a PDS.\"\nSay \"A new partitioned data set will be created, prefixed by 'SST' and\"\nSay \"your User ID, and appended by 'RESCUE'.  If the source PDS has not\"\nSay \"been compressed, the 'dead members' will be copied to the new PDS\"\nSay \"and assigned member names of MEM001 to MEMNNN where NNN will be\"\nSay \"the most recently saved member.  The MEM number assigned to \"\nSay \"the deleted members will not be predictable.\"\nSay \"This utility cannot be used on a PDSE library.\"\n\n/*  param = \"'ALL'\"   */\nparam = \"'DEAD'\"\nDo Forever\n  Say \" \"\n  Say \"Enter the PDS to be rescued, or Q to quit\"\n  Pull bib\n  bib = Strip(bib)\n  If bib = \"Q\" Then Exit\n  if bib = \"\" then do\n     Say 'You must provide PDS name to process'\n     Iterate\n  end\n  apos1 = pos(\"'\",bib)\n  if apos1 = 0 then bib = \"'\"bib\"'\"    /* Add tics if needed         */\n  Exist = SYSDSN(bib)                  /* check dsn existance        */\n  If Exist = 'OK' Then NOP             /* if no, say it and iterate  */\n    Else do\n      Say 'PDS 'bib' NOT found or not catalogued'\n      Iterate\n  end\n  msgst =  MSG('OFF')\n  x = LISTDSI(bib directory)           /* to check if its a PDS     */\n                                       /* If no, say it & iterate   */\n  if sysdsorg <> 'PO' & sysdsorg <> 'POU' then do\n     Say 'Dataset 'bib' is NOT a PDS, it is 'sysdsorg\n     Iterate\n  end\n  if SYSUDIRBLK = 'N/A' Then Do          /* Check if it is a PDSE  */\n     Say 'Dataset 'bib' is a PDSE - rescue not possible'\n     Exit\n  end\n  Leave                               /* Break loop                */\nEnd                                   /* End Do Forever            */\n\nupref = Userid()\ndsprin = \"'\"upref\".PRUPGM.SYSPRINT'\"          /* pru pgm sysprint   */\n\nbibnoq = Strip(TRANSLATE(bib,\" \",\"'\"))     /*  Remove tics          */\n\nbib2 = \"'SST.\"upref\".\"bibnoq\"'\"            /* DSN for rescue PDS    */\ndo forever\n   totlng = length(bib2)                   /* check current length   */\n   bib2 = left(bib2,totlng-1)              /* delete last quote      */\n   bib2 = bib2\".RESCUE'\"                   /* append RESCUE to dsn   */\n   if totlng > 38 then call Change_Name    /* check if dsn > 44 char */\n   Exist = sysdsn(bib2)\n   If Exist <> 'OK'                        /* check dsn existance    */\n   then leave                              /* if so, iterate         */\nend\n\nmsgst =  MSG('OFF')\nif sysdsn(dsprin) = 'OK' then \"DELETE \"dsprin /* if exists, delete it*/\n\nmsgst =  MSG('OFF')\n\"FREE FI(SYSPRINT,INPUT,OUTPUT)\"   /* include SYSUDUMP as optional   */\nmsgst =  MSG(msgst)\n\n/*  allocate all work files       */\n\nSay \"Allocating work files....\"\n\n\"ALLOC FI(SYSPRINT) DA(\"dsprin\") REUSE UNIT(SYSDA) \",\n       \"SPACE(5 1) TRACKS RECFM(F,B,A) LRECL(133) BLK(27930)\"\n\"ALLOC FI(INPUT)    DA(\"bib\") SHR REUSE\"\n\"ALLOC FI(OUTPUT)   DA(\"bib2\") NEW UNIT(SYSDA) LIKE(\"bib\") RELEASE\"\n\nSay \"Calling PRU program.....\"\n\n\"CALL 'SYS2.SYSTEMS.ZOSR13.LOADLIB(PRU)' \"param   /* call PRU pgm */\nRcPRU = rc                                 /* save return code    */\n\n\"FREE FI(SYSPRINT,INPUT,OUTPUT)\"   /* include SYSUDUMP as optional   */\n\"ALLOC FI(SYSPRINT) DA(*)\"         /* reallocate SYSPRINT to terminal*/\nselect\n   when RcPRU = 0 then do\n      if sysvar(\"SYSISPF\") = \"ACTIVE\"\n      then Do\n         Say bib2 'created - press ENTER to view report'\n         address ISPEXEC \"VIEW DATASET(\"dsprin\")\"\n      End\n      else Say 'PDS 'bib' processed with name 'bib2' successfully'\n   end\n   when RcPRU = 4 then do\n      Say 'PDS 'bib' processed and no members were recoverable'\n      msgst =  MSG('OFF')\n      \"DELETE \"dsprin\n      \"DELETE \"bib2\n      msgst =  MSG(msgst)\n   end\n   otherwise Say 'PDS 'bib' processed with errors RC='RcPRU\nend\nexit\n\nChange_Name:\n fecS = date('S')\n timN = time()\n timN = left(timN,2)substr(timN,4,2)right(timN,2)\n Say 'Output PDS 'bib2\n bib2 = \"'SST.\"upref\".PDS.D\"right(fecS,6)\".T\"timN\".RESCUE'\"\n Say 'changed to 'bib2' due to dsn length'\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "READVOL1": {"ttr": 17412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x01\\x9a\\x01\\x9a\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:27", "lines": 410, "newlines": 410, "modlines": 0, "user": "SOURCE"}, "text": "***********************************************************************\n*                                                                     *\n*     WARNING:                                                        *\n*      1) THIS CODE WAS WRITTEN IN 1988..AND AMAZINGLY STILL WORKS.   *\n*      2) DO NOT \"PLAY\" WITH STARTIO UNLESS YOU KNOW ARE AWARE OF     *\n*         ALL THE CONSEQUENCES...                                     *\n*         SYSTEM OUTAGES AND POSSIBLE DATA LOSS.                      *\n*                                                                     *\n*       - READ THE MANUALS BEFORE CONTINUING.                         *\n*                                                                     *\n***********************************************************************\n\nREADVOL1 TITLE ' - READ VOLUME LABEL RECORD'\n***********************************************************************\n*                     *                                               *\n*   R E A D V O L 1   *                                               *\n*                     *                                               *\n***********************                                               *\n*                                                                     *\n*   FUNCTION :        READ VOLUME LABEL OF AN OFFLINE DASD DEVICE     *\n*                                                                     *\n*   PARMS:            R1 >>---> +0 RESERVED WORD                      *\n*                               +4 UCB ADDRESS                        *\n*                               +8 LABEL OUTPUT BUFFER                *\n*                                                                     *\n*   EXIT CODE:         4  -  SPECIFIED UCB INVALID (ONLINE OR NON-DA) *\n*                     16  -  DEVICE NOT ACCESSIBLE                    *\n*                     20  -  I/O ERROR OR I/O TIMEOUT                 *\n*                                                                     *\n*   REGISTER USAGE :   R0 - WORK REGISTER                             *\n*                      R1 - WORK REGISTER                             *\n*                      R2 - WORK REGISTER                             *\n*                      R3 - WORK REGISTER                             *\n*                      R4 - SRB ADDRESS                               *\n*                      R5 - IOSB ADDRESS                              *\n*                      R6 - IOS POST STATUS TERMINATION BASE REGISTER *\n*                      R7 - ASCB ADDRESS                              *\n*                      R8 - UCB ADDRESS                               *\n*                      R9 - LABEL OUTPUT BUFFER ADDRESS               *\n*                     R10 - WORK REGISTER                             *\n*                     R11 - WORK REGISTER                             *\n*                     R12 - BASE REGISTER                             *\n*                     R13 - WORKAREA BASE REGISTER                    *\n*                     R14 - RETURN ADDRESS                            *\n*                     R15 - RETURN CODE                               *\n*                                                                     *\n*   MACROS : #CCW     #DSECTS  #SETRC   #START   #STARTWA #STOP       *\n*            #STOPWA  CCW      FREEMAIN GETMAIN  LINK     MODESET     *\n*            POST     PURGE    SETLOCK  STARTIO  STIMER   TTIMER      *\n*            WAIT                                                     *\n*                                                                     *\n*   ROUTINES CALLED : IEEVDEV                                         *\n*                                                                     *\n*   HISTORY :  APR  5,1988 - INITIAL INSTALL                          *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nREADVOL1 #START BASE=(R12),WKDSECT=WORKAREA,COPY=YES,                  *\n               AMODE=31,RMODE=24,SP=230\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        LOAD USER SPECIFIED PARAMETERS                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING PSA,0\n         L     R3,CVTPTR           LOAD CVT ADDRESS\n         USING CVT,R3\n         LM    R8,R9,4(R1)         LOAD UCB ADDRESS & BUFFER ADDRESS\n         USING UCBOB,R8\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        VALIDATE SPECIFIED UCB                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    UCBSTAT,UCBONLI+UCBALOC\n         BNZ   BADUCB              B. IF DEVICE IS ONLINE OR ALLOCATED\n         TM    UCBDMCT,UCBDMC      CHECK IF DEVICE IS IN USE\n         BNZ   BADUCB              B. IF YES\n         CLI   UCBTBYT3,UCB3DACC   CHECK IF DEVICE IS DIRECT ACCESS\n         BNE   BADUCB              B. IF NOT\n         TM    UCBJBNR,UCBVRDEV    CHECK IF DEVICE IS VIRTUAL\n         BO    BADUCB              B. IF YES\n\n         TM    CVTDCB,CVTMVSE      CHECK FOR MVS/XA SYSTEM\n         BO    RV1XABOX            B. IF YES\n\n         TM    UCBJBNR,16          CHECK FOR MVS/370 BOX FLAG\n         BO    NOTOPER             B. IF YES\n         B     RV1PATH             ELSE. CONTINUE\n\nRV1XABOX TM    UCBFLA,UCBBOX       CHECK FOR MVS/XA BOX FLAG\n         BO    NOTOPER             B. IF YES\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        VALIDATE PATH TO SPECIFIED DEVICE                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nRV1PATH  DS    0H\n         MODESET KEY=ZERO,MODE=SUP GET INTO KEY ZERO & SUPERVISOR STATE\n\n         LA    R0,IEEPARMS         LOAD PARAMETER LIST ADDRESS\n         ST    R0,RV1PLIST         SAVE PARAMETERS ADDRESS\n         ST    R8,PARMUCB          SAVE UCB ADDRESS\n         LA    R1,RV1PLIST         LOAD IEEVDEV PARAMETER LIST\n         LINK  EP=IEEVDEV          CALL IEEVDEV\n         LTR   R15,R15             CHECK IF PATH IS OPERATIONAL\n         BNZ   NOTOPER             B. IF NOT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OBTAIN STORAGE & INITIALIZE                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   PROLOG(12),MPROLOG  BUILD STIMER EXIT PROLOG\n         LA    R0,ROUTINE          LOAD ROUTINE ADDRESS\n         ST    R0,TIMEPARM         SAVE ROUTINE ADDRESS IN WORK AREA\n         ST    R13,TIMEPARM+4      SAVE WORKAREA ADDRESS\n\n         LA    R2,245              LOAD MVS/XA  STORAGE SUBPOOL\n         TM    CVTDCB,CVTMVSE      CHECK FOR MVS/XA SYSTEM\n         BNO   *+8                 B. IF NOT\n         LA    R2,226              LOAD MVS/370 STORAGE SUBPOOL\n\n         LA    R0,SRBSIZE+IOSBSIZE+CCWSIZE\n         GETMAIN RU,LV=(0),SP=(R2) OBTAIN STORAGE FOR SRB/IOSB/CCWS\n         XC    0(SRBSIZE+IOSBSIZE,R1),0(R1)\n         LR    R4,R1               LOAD ADDRESS OF SRB STORAGE\n         USING SRB,R4\n         LA    R5,SRB+SRBSIZE      LOAD ADDRESS OF IOSB STORAGE\n         USING IOSB,R5\n         LA    R10,IOSB+IOSBSIZE   LOAD ADDRESS OF CCWS STORAGE\n         USING CCWAREA,R10\n         L     R7,PSAAOLD          LOAD ADDRESS OF ASCB\n         USING ASCB,R7\n         MVC   SRBID,=CL4'SRB'     INITIALIZE SRB ID\n         MVC   SRBPTCB,PSATOLD     INSERT TCB ADDRESS\n         MVC   SRBPASID,ASCBASID   INSERT ASID\n         ST    R7,SRBASCB          INSERT ASCB ADDRESS\n         ST    R5,SRBPARM          INSERT IOSB ADDRESS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INITIALIZE THE IOSB.  MOST OF THE FIELDS ARE SELF            *\n*        EXPLANATORY.  AN EXCEPTION IS THE FIELD IOSDVRID WHICH IS    *\n*        USED AS AN INDEX INTO THE VECTOR OF IOS DRIVERS (VOID)       *\n*        TABLE.  THIS IS WHERE IOS DIRECT ACCESS ERROR RECOVERY       *\n*        COMPONENT FINDS THE ADDRESS OF THE EXTENT CHECKING           *\n*        SUBROUTINE.  A RETURN +0 FROM THIS SUBROUTINE INDICATES      *\n*        CONTINUE (THE ROUTINE MAY HAVE ALSO UPDATED THE DYNAMIC      *\n*        SEEK ADDRESS IN THE IOSB).  A RETURN +4 FROM THIS            *\n*        SUBROUTINE INDICATES THE UPDATED SEEK ADDRESS VIOLATES       *\n*        EXTENTS.  THIS IS ALSO WHERE IOS PURGE AND RESTORE           *\n*        COMPONENTS FIND THE ADDESSES OF THE PURGE AND RESTORE        *\n*        SUBROUTINES.  IT'S VOID ENTRY CONTAIN THE ADDRESS OF         *\n*        DUMMY (NOOP) SUBROUTINES.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVI   IOSFLA,IOSCCHN      INDICATE COMMAND CHAINING\n         MVI   IOSDVRID,IOSMISID   INSERT DRIVER ID\n         MVI   IOSOPT,IOSNERP      INDICATE NO ERROR RECOVERY\n         MVC   IOSASID,ASCBASID    INSERT ASID\n         LA    R1,STIOPSTR\n         ST    R1,IOSPGAD          INSERT THE TERMINATION RTN ADDRESS\n         ST    R8,IOSUCB           INSERT THE UCB ADDRESS\n         ST    R8,IOSDSID          - SAVE AS THE PURGE ID\n         ST    R13,IOSUSE          INSERT WORKAREA ADDRESS\n         ST    R4,IOSSRB           INSERT THE SRB ADDRESS\n         LA    R1,STIONRMR\n         ST    R1,IOSNRM           SAVE POST STATUS NORMAL EXIT ADDR\n         LA    R1,STIOABNR\n         ST    R1,IOSABN           SAVE POST STATUS ABNORMAL EXIT ADDR\n         MVI   IOSFMSK,X'40'       INSERT FILE MASK\n         MVI   IOSEEK+7,3          INSERT SEEK ADDRESS (0,00,00,00,3)\n         MVC   IOSEEKA,IOSEEK      INSERT DYNAMIC SEEK ADDR\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE CHANNEL PROGRAM:                                   *\n*        -  SEARCH ID EQUAL  -  TIC  -  READ                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         XC    LABEL,LABEL         CLEAR THE OUTPUT BUFFER\n         MVC   CCW1(24),MCCW1      INSERT CHANNEL PROGRAM CHAIN\n         LRA   R0,IOSEEK+3\n         STCM  R0,7,CCW1+1         SAVE REAL ADDRESS OF CCHHR\n         LRA   R0,CCW1\n         STCM  R0,7,CCW2+1         SAVE REAL ADDRESS OF CCW CHAIN\n         LRA   R0,LABEL\n         STCM  R0,7,CCW3+1         SAVE REAL ADDRESS OF OUTPUT BUFFER\n         LRA   R0,CCW1\n         ST    R0,IOSRST           SAVE REAL ADDRESS OF CHANEL PGM\n         LA    R0,CCW1\n         ST    R0,IOSVST           SAVE VIRTUAL ADDRESS OF CHANEL PGM\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INVOKE CHANNEL SCHEDULER (IOS)                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    CVTDCB,CVTMVSE      CHECK FOR MVS/XA SYSTEM\n         BNO   *+8                 B. IF NOT\n         NI    UCBFLB,255-UCBNOPTH INDICATE DEVICE HAS PATH(S)\n         NI    UCBFLA,255-UCBNRY   INDICATE DEVICE IS READY\n         MVI   RV1ECB,0            CLEAR ECB\n\n         STM   R14,R12,12(R13)     SAVE REGISTERS AS IOS DESTROYS THEM\n         LR    R1,R4               LOAD SRB ADDRESS\n         STARTIO SRB=(1),TCB=SRB   INVOKE THE CHANNEL SCHEDULER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n\n         STIMER REAL,PROLOG,BINTVL=TIMEXPY\n         WAIT  ECB=RV1ECB          WAIT FOR I/O COMPLETION\n         OI    UCBFLA,UCBNRY       INDICATE DEVICE IS NOT READY\n         TTIMER CANCEL             CANCEL TIMER ROUTINE\n\n         MVC   RV1ECB+1(1),IOSCOD  SAVE I/O COMPLETION CODE\n         MVC   0(80,R9),LABEL      RETURN VOL1 LABEL\n\n         LR    R1,R4               LOAD ADDR OF SRB/IOSB/CCWS STORAGE\n         LA    R0,SRBSIZE+IOSBSIZE+CCWSIZE\n         FREEMAIN RU,LV=(0),A=(1),SP=(R2)\n\n         CLI   RV1ECB,X'33'        CHECK IF I/O TIMED OUT\n         BE    NOTOPER             B. IF YES\n\n         CLI   RV1ECB+1,X'7F'      CHECK IF I/O WAS SUCCESSFUL\n         BNE   ERROR20             B. IF NOT\n         CLC   =C'VOL1',0(R9)      CHECK IF VOLUME LABEL IS VALID\n         BNE   ERROR20             B. IF NOT\n         B     EXIT                B. IF YES\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE WITH APPROPRIATE RETURN CODE                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nERROR20  DS    0H\n         #SETRC 20                 SET RETURN CODE - I/O ERROR\n         B     EXIT                TERMINATE\n\nBADUCB   DS    0H\n         #SETRC 4                  SET RETURN CODE - INVALID UCB\n         B     EXIT                TERMINATE\n\nNOTOPER  DS    0H\n         #SETRC 16                 SET RETURN CODE - NOT ACCESSIBLE\n         B     EXIT                TERMINATE\n\nEXIT     DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         #STOP ,                   RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IOS POST STATUS NORMAL EXIT.                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTIONRMR DS    0H\n         SR    R15,R15\n         B     PSARET\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IOS POST STATUS ABNORMAL EXIT.                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTIOABNR DS    0H\n         SR    R15,R15\n         B     PSARET\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IOS POST STATUS TERMINATION ROUTINE.  THIS ROUTINE IS        *\n*        EXECUTED UNDER THE SRB PASSED AS A PARAMETER TO IOS.  THE    *\n*        LOCAL LOCK IS HELD.  AT LEAST TWO THINGS MUST BE DONE IN A   *\n*        TERMINATION ROUTINE: 1) THE COMPLETION ECB MUST BE POSTED    *\n*        USING BRANCH ENTRY POST, 2) THE PURGE ROUTINE MUST BE        *\n*        CALLED IF AN IPIB EXISTS.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTIOPSTR DS    0H\n*        SETLOCK OBTAIN,TYPE=LOCAL,RELATED=(POST,RELEASE),\n*              MODE=UNCOND,REGS=USE\n         L     R3,CVTPTR           LOAD THE CVT ADDRESS\n         LR    R5,R1               LOAD THE IOSB ADDRESS\n         BALR  R6,0                LOAD THE BASE REGISTER\n         USING *,R6\n\n         L     R13,IOSUSE          LOAD WORKAREA ADDRESS\n         IC    R10,IOSCOD          LOAD THE COMPLETION CODE\n         SLL   R10,24              SHIFT TO HIGH ORDER NIBBLE\n         LA    R11,RV1ECB          LOAD ECB ADDRESS\n         L     R15,CVT0PT01        LOAD BRANCH ENTRY POST ADDRESS\n         BALR  R14,R15             CALL BRANCH ENTRY POST\n\n         ICM   R1,15,IOSIPIB       LOAD Q/IPIB ADDRES\n         BZ    RELEASE             B. IF NOT PRESENT\n         SR    R0,R0               INDICATE LOCAL LOCK HELD\n         L     R15,CVTIXAVL\n         L     R15,IOCQCNT-IOCOM(,R15)\n         BALR  R14,R15             UPDATE QUIESCE COUNT\n\nRELEASE  DS    0H\n         SETLOCK RELEASE,TYPE=LOCAL,RELATED=(POST,OBTAIN)\n         L     R14,CVTSRBRT        LOAD RETURN ADDRESS\n         BR    R14                 RETURN TO DISPATCHER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TIMER ROUTINE                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  ,\n\nMPROLOG  STM   R14,R12,12(R13)     SAVE REGISTERS\n         LM    R2,R3,12(R15)       LOAD REGISTERS\n         USING ROUTINE,R2\n         USING WORKAREA,R3\n         B     0(0,R2)             GO TO EXIT ROUTINE\n\nROUTINE  MVI   PURGOPTS,B'10100100'\n         PURGE PURGLIST\n         LA    R0,X'33'\n         SLL   R0,24\n         POST  RV1ECB,(0)\n         LM    R14,R12,12(R13)\n         BR    R14\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WORK AREA                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         DS    0D\nMCCW1    CCW   SIDEQ,*-*,CC,5           CHANNEL PROGRAM TO READ\nMCCW2    CCW   TIC,*-*,0,0              DATA FROM RECORD 3\nMCCW3    CCW   RDT,*-*,0,80\n\nTIMEXPY  DC    F'50'                    INTERVAL IS .50 SEC\n\n         #STARTWA ,\n\n         DS    0F                       MUST BE ON WORD BOUNDARY\nPROLOG   STM   R14,R12,12(R13)          SAVE REGS\n         LM    R2,R3,12(R15)            LOAD REGS\n         B     0(0,R2)                  GO TO EXIT\nTIMEPARM DS    2F                       PARMS\n\nPURGLIST DS    0F             ***  I/O PURGE PARAMETER LIST\nPURGOPTS DC    B'10100100'         1... .... SINGLE DATASET PURGE\n*                                  .1.. .... POST ASSOCIATED ECB X'48'\n*                                  ..1. .... HALT I/O (NOT QUIESCE)\n*                                  ...1 .... RELATED REQUESTS ONLY\n*                                  .... .1.. DONT PURGE IRB'S\n*                                  .... ..1. PURGE BY TCB\nUCBADDR  DC    AL3(0)                   DATASET ID (UCB ADDRESS)\n         DC    A(0)                     TCB ADDRESS (NOT REQUIRED)\n         DC    A(0)                     UNUSED (RESTORE POINTER)\n\nRV1ECB   DC    F'0'                     EVENT CONTROL BLOCK\n\nRV1PLIST DC    A(IEEPARMS)              ************************\nIEEPARMS DS    0D                       * THIS IS THE REQUIRED *\nPARMUCB  DS    A                        * PARAMETER POINTING   *\nPARMFC   DC    X'00'                    * SCHEME REQUIRED      *\nPARMRES1 DS    CL1                      *  BY IEEVDEV          *\nPARMCHP  DS    CL1                      *                      *\nPARMRES2 DS    CL1                      ************************\n\n         #STOPWA ,\n\nCCWAREA  DSECT ,\n\nCCW1     CCW   SIDEQ,*-*,CC,5           CHANNEL PROGRAM TO READ\nCCW2     CCW   TIC,*-*,0,0              DATA FROM RECORD 3\nCCW3     CCW   RDT,*-*,0,80\n\nLABEL    DS    CL80                     LABEL IS READ IN HERE\n\nCCWSIZE  EQU   *-CCWAREA\n\n         PRINT NOGEN\n         #DSECTS CVT,IOSB,SRB,UCB,PSA,ASCB,IOCOM\nIOSBSIZE EQU   IOSEND-IOSB\n         #CCW  ,\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RETCODE": {"ttr": 17419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x00\\xc7\\x00\\xc7\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:27", "lines": 199, "newlines": 199, "modlines": 0, "user": "SOURCE"}, "text": "RETCODE  TITLE '- GENERATE RETURN CODE/ABEND BASED ON PARM='\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nRETCODE  #START WKDSECT=WORKAREA,APARS=,AMODE=CAP24,                   *\n               COPY=YES,                                               *\n               LEVEL=#V001R01\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTRUCT COMMAND BUFFER FROM THE PARAMETER LIST             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         L     R1,0(,R1)           >>---> PARM FIELD\n         SR    R2,R2\n         ICM   R2,3,0(R1)          LOAD PARAMETER LENGTH\n         BZ    RETC0100            B. IF NO PARAMETER SPECIFIED\n\n         #EXEC -R2,MVC,COMMAND+8(*-*),2(R1)\n         LA    R2,9(,R2)           CALCULATE LENGTH OF COMMAND BUFFER\n         STH   R2,COMMAND          RESET LENGTH OF COMMAND BUFFER\n\nRETC0100 DS    0H\n         MVC   PPLPCL-PPL+WRKPPL,=A(PARSEPCL)\n         LA    R0,PDLADDR          >>---> IKJPARS ANSWER PLACE\n         ST    R0,PPLANS-PPL+WRKPPL\n         LA    R0,COMMAND          >>---> INPUT COMMAND BUFFER\n         ST    R0,PPLCBUF-PPL+WRKPPL\n         ST    R0,CSPLCBUF-CSPL+WRKCSPL\n         ST    R13,PPLUWA-PPL+WRKPPL\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SCAN & PARSE THE COMMAND BUFFER                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R1,WRKCSPL          >>---> SCAN PARAMETER LIST\n         LA    R0,4                INDICATE \"IKJSCAN\" FUNCTION\n         L     R15,=V(TSOPARSE)\n         #BALR R14,R15\n\n         LA    R1,WRKPPL           >>---> PARSE PARAMETER LIST\n         LA    R0,0                INDICATE \"IKJPARS\" FUNCTION\n         L     R15,=V(TSOPARSE)\n         #BALR R14,R15\n         #SETRC (R15)              SET RETURN CODE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISSUE MESSAGES TRAPPED BY PARSE SVC                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LTR   R3,R1               CHECK IF ANY MESSAGES RETURNED\n         BZ    RETC0400            B. IF NO\n\nRETC0200 DS    0H\n         MVC   WTOBUFFR+4(80),BLANKS\n         LH    R2,4(,R3)           LOAD MESSAGE TEXT LENGTH\n         CH    R2,=H'80'           CHECK FOR MAXIMUM LENGTH\n         BNH   RETC0300            B. IF NOT HIGHER THAN 80\n         LH    R2,=H'80'           SET TO MAXIMUM LENGTH\nRETC0300 DS    0H\n         #EXEC -R2,MVC,WTOBUFFR+4(*-*),8(R3)\n\n         WTO   MF=(E,WTOBUFFR)     ISSUE ERROR MESSAGE\n\n         ICM   R3,15,0(R3)         >>---> NEXT MESSAGE\n         BNZ   RETC0200            B. IF MORE MESSAGES\n\nRETC0400 DS    0H\n         ICM   R15,15,RETRCODE     CHECK IKJPARS RETURN CODE\n         BZ    RETC0450            B. IF SUCCESSFUL PARSE\n         WTO   'RETC001I INVALID PARAMETER LIST',ROUTCDE=11\n         B     RETCEXIT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SET RETURN CODE TO REQUESTED VALUE                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nRETC0450 DS    0H\n         L     R10,PDLADDR         LOAD PDL ADDRESS\n         USING IKJPARMD,R10\n\n         CLI   TYPEKW+1,1          CHECK FOR \"RC(...)\"\n         BNE   RETC0500            B. IF NOT\n         L     R1,RC               LOAD REQUESTED RETURN CODE ADDRESS\n         L     R15,0(,R1)          LOAD REQUESTED RETURN CODE\n         #SETRC (R15),FORCE=Y      SET RETURN CODE\n         B     RETCEXIT\n\nRETC0500 DS    0H\n         CLI   TYPEKW+1,2          CHECK FOR \"USER(...)\"\n         BNE   RETC0600            B. IF NOT\n         L     R1,USER             LOAD REQUESTED USER CODE ADDRESS\n         L     R15,0(,R1)          LOAD REQUESTED USER CODE\n         ABEND (15)\nRETC0600 DS    0H\n         CLI   TYPEKW+1,3          CHECK FOR \"SYSTEM(...)\"\n         BNE   RETCEXIT            B. IF NOT\n         L     R1,SYSTEM           LOAD REQUESTED SYSTEM CODE ADDRESS\n         SLR   R15,R15\n         ICM   R15,1,0(R1)         LOAD 1 BYTE SYSTEM CODE\n         CLC   =X'0001',SYSTEM+4   CHECK FOR 1 BYTE CODE\n         BE    RETC0700            B. IF YES\n         ICM   R15,3,0(R1)         LOAD 2 BYTE SYSTEM CODE\n         CLC   =X'0002',SYSTEM+4   CHECK FOR 2 BYTE CODE\n         BE    RETC0700            B. IF YES\n         ICM   R15,7,0(R1)         LOAD 3 BYTE SYSTEM CODE\n         CLC   =X'0003',SYSTEM+4   CHECK FOR 3 BYTE CODE\n         BE    RETC0700            B. IF YES\n         ICM   R15,15,0(R1)        LOAD 4 BYTE SYSTEM CODE\nRETC0700 DS    0H\n         ABEND (15),,,SYSTEM\n         DROP  R10\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nRETCEXIT DS    0H\n         IKJRLSA PDLADDR           RELEASE THE IKJPARS BUFFERS\n         #STOP ,                   RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WORK AREA                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nBLANKS   DC    CL256' '            LOTS OF BLANKS\nCOMMAND  DS    0F\n         DC    AL2(7,0),CL104'XXX '\nWTOBUFFR WTO   '---------+---------+---------+---------+---------+-----*\n               ----+---------+---------+',ROUTCDE=11,MF=L\n\n         #STARTWA ,\nPDLADDR  DS    F                   IKJPARS ANSWER PLACE\nWRKCSPL  DS    CL(CSPLLEN)         SCAN PARAMETER LIST\nWRKPPL   DS    CL(PPLLEN)          PARSE PARAMETER LIST\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        COMMAND OPERANDS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PRINT NOGEN\nPARSEPCL IKJPARM ,\n\nTYPEKW   IKJKEYWD DEFAULT='RC(0)'\n         IKJNAME 'RC',SUBFLD=RCSUB\n         IKJNAME 'USER',SUBFLD=USERSUB\n         IKJNAME 'SYSTEM',SUBFLD=SYSSUB\n\nRCSUB    IKJSUBF\nRC       IKJIDENT 'RC',                                                *\n               INTEG,                                                  *\n               MAXLNTH=4,                                              *\n               PROMPT='RETURN CODE'\n\nUSERSUB  IKJSUBF\nUSER     IKJIDENT 'USER',                                              *\n               INTEG,                                                  *\n               MAXLNTH=3,                                              *\n               PROMPT='USER ABEND CODE'\n\nSYSSUB   IKJSUBF\nSYSTEM   IKJIDENT 'SYSTEM',                                            *\n               HEX,                                                    *\n               MAXLNTH=3,                                              *\n               PROMPT='SYSTEM ABEND CODE'\n\n         IKJENDP\n         PRINT GEN\n\n         PRINT NOGEN\n*              'PARSE PARAMETER LIST'\n         IKJPPL ,\nPPLLEN   EQU   *-PPL               LENGTH OF PPL\n*              'SCAN PARAMETER LIST'\n         IKJCSPL ,\nCSPLLEN  EQU   *-CSPL              LENGTH OF CSPL\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXLOCATE": {"ttr": 17668, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 129, "newlines": 129, "modlines": 0, "user": "SOURCE"}, "text": "RXLOCATE TITLE 'Return Absolute or True name'\n*------------------------------------------------------------------*\n*                                                                  *\n*        To Call:                                                  *\n*                                                                  *\n*        /*rexx*/                                                  *\n*        LOCDSN = 'prefix.gdg.name(-1)' or 'prefix.alias.name'     *\n*        address LINK \"RXLOCATE\"                                   *\n*        say LOCDSN   <- absolute or true name                     *\n*        exit                                                      *\n*                                                                  *\n*------------------------------------------------------------------*\n\nRXLOCATE CSECT ,\nRXLOCATE AMODE 31\nRXLOCATE RMODE ANY\n         BAKR  14,0\n         LARL  R12,RXLOCATE\n         USING RXLOCATE,R12\n\n         STORAGE OBTAIN,LENGTH=WRKLEN,LOC=ANY,SP=1,CALLRKY=YES\n         LR    R13,R1\n         USING WRKAREA,R13\n         USING SHVBLOCK,WRKSHV\n\n         MVI   WRKDSNAM,C' '\n         MVC   WRKDSNAM+1(L'WRKDSNAM-1),WRKDSNAM\n\n*        Fetch \"LOCDSN\" Variable\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVFETCH\n         LA    R0,VARNAME          A(Variable Name)\n         ST    R0,SHVNAMA\n         LHI   R0,L'VARNAME        L(Variable Name)\n         ST    R0,SHVNAML\n         LA    R0,WRKDSNAM         A(DSName Area)\n         ST    R0,SHVVALA\n         LHI   R0,L'WRKDSNAM       L(DSName Area)\n         ST    R0,SHVBUFL\n         LA    R2,IRXEXCOM\n         LA    R4,SHVBLOCK\n         LINK  EP=IRXEXCOM,PARAM=((R2),0,0,(R4)),VL=1\n         LTR   R15,R15\n         JNZ   EXIT\n\n*        Locate The Catalog Entry\n         MVC   WRKLOC(NAMEPLL),NAMEPL\n         LA    R0,WRKDSNAM\n         ST    R0,WRKLOC+4\n         LA    R0,BUFFER\n         ST    R0,WRKLOC+12\n         LOCATE WRKLOC             Locate Catalog Entry\n         LR    R5,R15\n\n*        Store \"LOCDSN\" Variable\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVSTORE\n         LA    R0,VARNAME          A(Variable Name)\n         ST    R0,SHVNAMA\n         LHI   R0,L'VARNAME        L(Variable Name)\n         ST    R0,SHVNAML\n         LA    R0,WRKDSNAM         A(DSName Area)\n         ST    R0,SHVVALA\n         LHI   R0,L'WRKDSNAM       L(DSName Area)\n         ST    R0,SHVBUFL\n         ST    R0,SHVVALL\n         LA    R2,IRXEXCOM\n         LA    R4,SHVBLOCK\n         LINK  EP=IRXEXCOM,PARAM=((R2),0,0,(R4)),VL=1\n         LR    R15,R5\n\nEXIT     DS    0H\n         LR    R5,R15\n         STORAGE RELEASE,LENGTH=WRKLEN,ADDR=(R13),SP=1,CALLRKY=YES\n         LR    R15,R5\n         PR    ,\n\nERROR1   DS    0H\n         EX    0,*                 Abend S0C3\n\nVARNAME  DC    C'LOCDSN'\nIRXEXCOM DC    CL8'IRXEXCOM'\n\nNAMEPL   CAMLST NAME,*-*,,*-*\nNAMEPLL  EQU   *-NAMEPL\n\nWRKAREA  DSECT ,\n         DS    18F\n\nWRKLOC   DS    XL(NAMEPLL)\nWRKDSNAM DS    CL44\nBUFFER   DS    CL265\nWRKSHV   DS    0F,XL(SHVBLEN)\n\n         DS    0D\nWRKLEN   EQU   *-WRKAREA\n\n         YREGS ,\n\n* SHVBLOCK:  Shared-Variable Parameter List\nSHVBLOCK DSECT\nSHVNEXT  DS    A     CHAIN POINTER (0 IF LAST BLOCK)\nSHVUSER  DS    F     AVAILABLE FOR PRIVATE USE, EXCEPT DURING\n*                      \"FETCH NEXT\" WHEN IT IDENTIFIES THE\n*                      LENGTH OF THE BUFFER POINTED TO BY SHVNAMA.\nSHVCODE  DS    CL1   INDIVIDUAL FUNCTION CODE INDICATING\n*                      THE TYPE OF VARIABLE ACCESS REQUEST\n*                      (S,F,D,s,f,d,N, OR P)\nSHVRET   DS    XL1   INDIVIDUAL RETURN CODE FLAGS\n         DS    H'0'  RESERVED, SHOULD BE ZERO\nSHVBUFL  DS    F     LENGTH OF 'FETCH' VALUE BUFFER\nSHVNAMA  DS    A     ADDRESS OF VARIABLE NAME\nSHVNAML  DS    F     LENGTH OF VARIABLE NAME\nSHVVALA  DS    A     ADDRESS OF VALUE BUFFER\nSHVVALL  DS    F     LENGTH OF VALUE\nSHVBLEN  EQU   *-SHVBLOCK  (LENGTH OF THIS BLOCK = 32)\n         SPACE\n*\n*     FUNCTION CODES (PLACED IN SHVCODE):\n*\nSHVFETCH EQU   C'F'  COPY VALUE OF VARIABLE TO BUFFER\nSHVSTORE EQU   C'S'  SET VARIABLE FROM GIVEN VALUE\nSHVDROPV EQU   C'D'  DROP VARIABLE\nSHVSYSET EQU   C's'  SYMBOLIC NAME SET VARIABLE\nSHVSYFET EQU   C'f'  SYMBOLIC NAME FETCH VARIABLE\nSHVSYDRO EQU   C'd'  SYMBOLIC NAME DROP VARIABLE\nSHVNEXTV EQU   C'N'  FETCH \"NEXT\" VARIABLE\nSHVPRIV  EQU   C'P'  FETCH PRIVATE INFORMATION\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAFECOPY": {"ttr": 17671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x01\\t\\x01\\t\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 265, "newlines": 265, "modlines": 0, "user": "SOURCE"}, "text": "SAFECOPY TITLE '- PROTECT AGAINST ISPF AND IEWL WHILE COMPRESSING'\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* S A F E C O P Y |           PROTECT COMPRESS AGAINST                *\n*                 |       ISPF USERS AND THE LINKAGE EDITOR           *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    FUNCTION:  ISSUE ISPF/EDIT AND IEWL ENQ/RESERVES WHILE INVOKING  *\n*               IEBCOPY TO COMPRESS A SYSUT1 FILE.                    *\n*                                                                     *\n*       PARMS:  NONE                                                  *\n*                                                                     *\n*  EXIT CODES:  SAME AS FOR IEBCOPY                                   *\n*                                                                     *\n*   REGISTERS:  R0 - WORK REGISTER                                    *\n*               R1 - WORK REGISTER                                    *\n*               R2 - WORK REGISTER                                    *\n*               R3 - NOT USED                                         *\n*               R4 - NOT USED                                         *\n*               R5 - NOT USED                                         *\n*               R6 - NOT USED                                         *\n*               R7 - NOT USED                                         *\n*               R8 - NOT USED                                         *\n*               R9 - NOT USED                                         *\n*              R10 - NOT USED                                         *\n*              R11 - NOT USED                                         *\n*              R12 - BASE REGISTER                                    *\n*              R13 - SAVE AREA ADDRESS                                *\n*              R14 - RETURN ADDRESS                                   *\n*              R15 - RETURN CODE                                      *\n*                                                                     *\n*      MACROS: #DSECTS  #ENVIRON #SETRC   #START   #STARTWA #STOP     *\n*              #STOPWA  DCB      DEQ      ENQ      LINK     RDJFCB    *\n*              RESERVE  TIOTSCAN WTO                                  *\n*                                                                     *\n*  ATTRIBUTES: AUTHORIZED (SYSIEWLP QNAME REQUIRES AUTHORIZATION)     *\n*                                                                     *\n*        NOTE: SYSIEWLP ENQUEUE WILL BE BYPASSED IF ON TSO            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: #V001000 - JUN 15,1993 -  CREATION DATE                *\n*              #V001002 - MAR  2,2012 -  ADD EAV SUPPORT      #DD12062*\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nSAFECOPY #START ,                  *** HOUSEKEEPING ***                *\n               AMODE=CAP24,        EXECUTE IN 24-BIT ADDRESSING MODE   *\n               APARS=,             DON'T GENERATE APAR SLOTS           *\n               BASE=(R12),         DEFINE BASE REGISTER(S)             *\n               COPY=YES,                                               *\n               LOC=BELOW,          INDICATE 24-BIT WORKAREA            *\n               PREFIX=SAF,         DEFINE MACRO LABEL PREFIX           *\n               REG0=R0,            SAVE INPUT PARAMETER ADDRESS        *\n               REG1=R1,            SAVE INPUT PARAMETER ADDRESS        *\n               RMODE=24,           EXECUTE IN 24-BIT RESIDENCY MODE    *\n               SP=0,               DEFINE WORKAREA SUBPOOL             *\n               WKDSECT=SAFEWRK,    DEFINE WORKAREA NAME                *\n               LEVEL=#V001R02      DEFINE SOFTWARE VERSION     #DD12062\n         USING PSA,0\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DETERMINE EXECUTION ENVIRONMENT (BATCH OR TSO)               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #ENVIRON BATCH=SAFE0010   B. IF BATCH JOB\n         OI    WRK$FLAG,WRK$TSO    INCICATE \"TSO\" ENVIRONMENT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND THE TIOT ENTRY AND SAVE THE UCB ADDRESS                 *\n*        EXTRACT THE DSNAME FOR THE DD STATEMENT                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSAFE0010 DS    0H\n         LA    R2,DCBDDNAM-IHADCB+WRKDCB\n         TIOTSCAN DDN=(R2),NOK=ERROR1\n         USING TIOENTRY,R1         ADDRESS TIOT ENTRY\n         SLR   R15,R15\n         ICM   R15,7,TIOEFSRT      LOAD UCB ADDRESS\n         ST    R15,WRKUCB@         SAVE UCB ADDRESS FOR \"RESERVE\"\n\n         RDJFCB WRKDCB             COPY THE JFCB\n         LTR   R15,R15             CHECK IF THE DD STATEMENT EXISTS\n         BNZ   ERROR2              B. IF NOT\n\n         MVC   WRKDSNAM,JFCBDSNM-INFMJFCB+WRKJFCB\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISSUE A RESERVE TO LOCK OUT ISPF USERS & THE LINKAGE EDITOR  *\n*              A ENQUEUE TO LOCK OUT THE LINKAGE EDITOR               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        NOTE: THE LINKAGE EDITOR ISSUES AN ENQUEUE AND A RESERVE     *\n*              TO PROTECT AGAINST MULTIPLE MACHINES, THAT MAY NOT     *\n*              BE PROTECTED BY GRS OR A REPLACEMENT PRODUCT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         RESERVE ,MF=(E,WRKRISPF)  LOCK OUT ISPF USERS\n         TM    WRK$FLAG,WRK$TSO    CHECK FOR \"TSO\" ENVIRONMENT\n         BO    SAFE0020            B. IF YES (BYPASS SYSIEWL ENQUEUE)\n         RESERVE ,MF=(E,WRKRLINK)  LOCK OUT THE LINKAGE EDITOR\n         ENQ   ,MF=(E,WRKELINK)    LOCK OUT THE LINKAGE EDITOR\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INVOKE IEBCOPY TO COMPRESS THE LIBRARY                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSAFE0020 DS    0H\n         TM    WRK$FLAG,WRK$TSO    CHECK FOR \"TSO\" ENVIRONMENT\n         BO    SAFE0030            B. IF YES\n\n         LINK  EP=IEBCOPY,PARAM=(WRKPARM1,WRKPARM2),VL=1\n         #SETRC (R15)              SET RETURN CODE\n         B     SAFE0050            TERMINATE\n\nSAFE0030 DS    0H\n         LA    R0,WRKPARM1         LOAD OPTIONAL PARAMETERS ADDRESS\n         LA    R1,WRKPARM2         LOAD DDNAME TABLE ADDRESS\n         STM   R0,R1,WRKPLIST      SAVE PARAMETER ADDRESSES\n         OI    WRKPLIST+4,X'80'    INDICATE END OF PARAMETER LIST\n\n         L     R15,FLCCVT          LOAD CVT  ADDRESS\n         L     R15,CVTTVT-CVT(,R15)     TSVT ADDRESS\n         L     R15,TSVTASF-TSVT(,R15)   INTERFACE ROUTINE ADDRESS\n         CALL  (15),(WRKTSRFL,     INVOKE SERVICE ROUTINE              *\n               IEBCOPY,            - NAME OF PROGRAM                   *\n               WRKPROGL,           - LENGTH OF PROGRAM NAME            *\n               WRKRETCD,           - RETURN CODE AREA                  *\n               WRKRSNCD,           - REASON CODE AREA                  *\n               WRKABNCD,           - ABEND  CODE AREA                  *\n               WRKPLIST),          - PROGRAM PARAMETERS ADDRESS        *\n               VL,MF=(E,WRKTSRPL)\n         LTR   R15,R15             CHECK FOR ANY ERRORS\n         BZ    SAFE0040            B. IF NOT\n         ICM   R15,15,WRKRETCD     LOAD IEBCOPY RETURN CODE\n         BNZ   SAFE0040            B. IF RETURN CODE FOUND\n         L     R15,WRKABNCD        ELSE. LOAD IEBCOPY ABEND CODE\nSAFE0040 DS    0H\n         #SETRC (R15)              SET RETURN CODE\n         B     SAFE0050            TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RELEASE PREVIOUS ENQUEUES AND RESERVES                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSAFE0050 DS    0H\n         DEQ   MF=(E,WRKDISPF)     RELEASE ISPF LOCKOUT\n         TM    WRK$FLAG,WRK$TSO    CHECK FOR \"TSO\" ENVIRONMENT\n         BO    SAFEEXIT            B. IF YES (BYPASS SYSIEWL ENQUEUE)\n         DEQ   MF=(E,WRKDLINK)     RELEASE ISPF LOCKOUT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSAFEEXIT #STOP ,                   RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ERROR ROUTINES & MESSAGES                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nERROR1   DS    0H\n         MVC   MESSAGE1+4(8),DCBDDNAM-IHADCB+WRKDCB\n         WTO   MF=(E,MESSAGE1)\n         EX    0,*\nERROR2   DS    0H\n         WTO   MF=(E,MESSAGE2)\n         EX    0,*\nERROR3   DS    0H\n         WTO   MF=(E,MESSAGE3)\n         EX    0,*\n\nMESSAGE1 WTO   'XXXXXXXX DD STATEMENT NOT FOUND',ROUTCDE=11,MF=L\nMESSAGE2 WTO   'INTERNAL ERROR - JFCB EXTRACT FAILED',ROUTCDE=11,MF=L\nMESSAGE3 WTO   'INTERNAL ERROR - IEBCOPY ATTACH FAILED',ROUTCDE=11,MF=L\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS AND WORK AREA                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nIEBCOPY  DC    CL8'IEBCOPY'\nSPFEDIT  DC    CL8'SPFEDIT'\nSYSIEWLP DC    CL8'SYSIEWLP'\nWRK$FLAG DC    X'00'                 FLAG BYTE\nWRK$TSO  EQU   X'80'      1... ....  - EXECUTING IN \"TSO\" ENVIRONMENT\nWRKDCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(R),EXLST=WRKEXLST,        *\n               DCBE=WRKDCBE                                    #DD12062\nWRKDCBE  DCBE  EADSCB=OK                                       #DD12062\nWRKDISPF DEQ   (SPFEDIT,WRKDSNAM,44,SYSTEMS),                          *\n               RET=HAVE,MF=L\nWRKDLINK DEQ   (SYSIEWLP,WRKDSNAM,44,SYSTEM,                           *\n               SYSIEWLP,WRKDSNAM,44,SYSTEMS),                          *\n               RET=HAVE,MF=L\nWRKDSNAM DS    CL44\nWRKELINK ENQ   (SYSIEWLP,WRKDSNAM,E,44,SYSTEM),MF=L\nWRKEXLST DC    X'87',AL3(WRKJFCB)\nWRKJFCB  DS    0F,CL265\nWRKPARM1 DS    0D                    NULL PARAMETER LIST\n         DC    H'00',F'0'\nWRKPARM2 DS    0D                    DDNAME OVERIDE TABLE\n         DC    AL2(11*8)             LENGTH OF ALL ENTRIES\n         DC    XL8'00'               DUMMY ENTRY\n         DC    XL8'00'               DUMMY ENTRY\n         DC    XL8'00'               DUMMY ENTRY\n         DC    XL8'00'               DUMMY ENTRY\n         DC    CL8'SYSIN'            SYSIN\n         DC    CL8'SYSPRINT'         SYSPRINT\n         DC    XL8'00'               DUMMY ENTRY\n         DC    CL8'SYSUT1'           SYSUT1\n         DC    CL8'SYSUT1'           SYSUT2 (CHANGED TO SYSUT1)\n         DC    CL8'SYSUT3'           SYSUT3\n         DC    CL8'SYSUT4'           SYSUT4\nWRKRISPF RESERVE (SPFEDIT,WRKDSNAM,E,44,SYSTEMS),UCB=WRKUCB@,MF=L\nWRKRLINK RESERVE (SYSIEWLP,WRKDSNAM,E,44,SYSTEMS),UCB=WRKUCB@,MF=L\nWRKUCB@  DS    F\nWRKTSRFL DS    0F                  TSO SERVICE ROUTINE FLAGS\n         DC    H'0'                UNUSED\n         DC    X'01'               DUMP IF PROGRAM ABENDS\n         DC    X'02'               PROGRAM IS BEING INVOKED\nWRKPROGL DC    A(L'IEBCOPY)        LENGTH OF PROGRAM NAME\nWRKRETCD DC    F'0'                IEBCOPY RETURN CODE\nWRKRSNCD DC    F'0'                TSO SERVICE ROUTINE REASON CODE\nWRKABNCD DC    F'0'                IEBCOPY ABEND  CODE\nWRKTSRCD DC    F'0'                TSO SERVICE ROUTINE RETURN CODE\nWRKPLIST DS    2F                  IEBCOPY PARAMETER LIST\nWRKTSRPL DS    7F                  TSO SERVICE ROUTINE PARAMETERS\n\n         #STARTWA ,\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #DSECTS CVT,DCB,JFCB,TIOT,PSA\n         IKJTSVT ,                 TSO SERVICE VECTOR TABLE\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SASSXX02": {"ttr": 17676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x01\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12'\\x02\\x0c\\x02\\x0c\\x00\\x01\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:27:01", "lines": 524, "newlines": 524, "modlines": 1, "user": "SOURCE"}, "text": "SASSXX02 TITLE ' -- CA-7 -- JCL SUBMISSION EXIT'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* S A S S X X 0 2 |            JCL SUBMISSION EXIT                    *\n*                 |                                                   *\n*------------------                                                   *\n*                                                                     *\n*    FUNCTION: USED TO ADD, DELETE OR CHANGE JCL STATMENTS OR CONTROL *\n*              CARDS IMMEDIATELY PRECEDING JOB SUBMISSION.  MUST BE   *\n*              CODED AS REUASABLE, BUT NOT NECESSARILY REENTRANT.     *\n*              CHANGES MADE TO THE JCL BY THIS EXIT ARE NOT REFLECTED *\n*              IN THE QUEUE JCL.                                      *\n*                                                                     *\n*       INPUT: R02 = ADDRESS OF PARAMETER LIST                        *\n*               +0 = ADDRESS OF 80-BYTE AREA CONTAINING THE JCL       *\n*                    STATEMENT.                                       *\n*               +4 = ADDRESS OF THE JOB'S QUEUE RECORD (MAPPED BY     *\n*                    JQREC IN THE CA-7 MACRO LIBRARY).                *\n*                                                                     *\n*      OUTPUT: R15 = RETURN CODE                                      *\n*                0 = WRITE THIS STATEMENT AND CONTINUE PROCESSING     *\n*                    (THE JCL STATEMENT MAY HAVE BEEN MODIFIED).      *\n*                1 = DELETE THIS STATEMENT FROM THE JCL.              *\n*                2 = WRITE THE STATEMENT AND RETURN TO THE EXIT       *\n*                    (USED TO ADD STATEMENTS).                        *\n*                                                                     *\n*         THE JOB NAME AND COLUMNS 69 THROUGH 71 IN THE JOB CARD      *\n*         MUST NOT BE CHANGED.  ADDRESSES IN THE PARAMETER LIST       *\n*         MUST NOT BE CHANGED.                                        *\n*                                                                     *\n*        THIS EXIT IS CALLED BY SASSSSM0.                             *\n*                                                                     *\n*   REGISTERS:  R0 - DESTROYED                                        *\n*               R1 - DESTORYED                                        *\n*               R2 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*                    USED FOR PARAMETER LIST ADDRESS                  *\n*               R3 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*                    USED FOR JCL STATEMENT ADDRESS                   *\n*               R4 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*                    USED FOR JOB QUEUE RECORD ADDRESS                *\n*               R5 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*               R6 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*               R7 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*               R8 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*               R9 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*                    (SECONDARY BASE REGISTER)                        *\n*              R10 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*                    (PRIMARY BASE REGISTER)                          *\n*              R11 - POINTS TO THE SCT - MUST NOT BE MODIFIED         *\n*                    MAPPED BY MACRO SCTENTRY                         *\n*              R12 - POINTS TO THE SVT - MUST NOT BE MODIFIED         *\n*                    MAPPED BY MACRO UCC7SVT                          *\n*              R13 - DESTROYED - DOES NOT POINT TO A SAVE AREA UNLESS *\n*                    OTHERWISE NOTED                                  *\n*              R14 - SAVED ACROSS CA-7 SYSTEM REQUESTS                *\n*              R15 - DESTORYED - BUT UPON ENTRY CONTAINS THE ENTRY    *\n*                    ADDRESS                                          *\n*                                                                     *\n*  ATTRIBUTES: RE-ENTRANT, REUSABLE, AC(1) APF-AUTHORIZED             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   INSTALLATION USEAGE:                                              *\n*        SCAN ALL RECORDS BEING SUBMITTED FOR A \"&\".  IF FOUND,       *\n*        A SEARCH FOR A DELIMITER IS MADE.  NOW WE HAVE THE ADDRESS   *\n*        AND LENGTH OF THE VARIABLE, AND CAN CHECK TO SEE IF IT IS    *\n*        ONE OF THE SUPPORTED VARIABLES.  IF IT IS, THE VARIABLE IS   *\n*        REPLACED BY IT'S REAL VALUE.  FOR NUMERIC VARIABLES, CHECK   *\n*        IF THE USER REQUESTED AN EVALUATION TO BE PERFORMED.  THIS   *\n*        IS DENOTED BY A +## OR -## PRECEEDING THE TRAILING PERIOD.   *\n*        IN THESE CASES, THE VALUE IS CALCULATED PRIOR TO ITS         *\n*        INSERTION INTO THE RECORD.                                   *\n*                                                                     *\n*   VARIABLES:                                                        *\n*        &Y.                                                          *\n*        &MM.                                                         *\n*        &DD.                                                         *\n*        &YY.                                                         *\n*        &DDD.                                                        *\n*        &DAY.                                                        *\n*        &DOW.                                                        *\n*        &CCYY.                                                       *\n*        &YYDDMM.                                                     *\n*        &YYMMDD.                                                     *\n*        &DDMMYY.                                                     *\n*        &MMDDYY.                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY: MAR 15,1991 - INSTALL R2L9 (9010)                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSASSXX02 START 0\n         PRINT NOGEN\n         SASSEQU ,\n         SASSTBLK ,\n         SCTENTRY ,\n         UCC7SVT ,\n         JQREC ,\n         PRINT GEN\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ESTABLISH BASE REGISTER AND ACQUIRE WORK AREA                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSASSXX02 CSECT ,\n         SASSVRSN VRSN=000,REGS=R10\n\nXX020010 DS    0H\n         LA    R0,WRKAREAL             LOAD WORKAREA LENGTH\n         SGETM SIZE=(R0),BUSY=XX020020,RETURN=XX020030\n\nXX020020 DS    0H\n         SWAIT ECFADD=(R0),ECFMASK=(R0),RETURN=XX020010\n\nXX020030 DS    0H\n         LR    R13,R1                  LOAD WORKAREA ADDRESS\n         USING WRKAREA,R13\n\n         LR    R0,R13                  LOAD WORKAREA ADDRESS\n         LA    R1,WRKAREAL             LOAD WORKAREA LENGTH\n         LR    R14,R0\n         SLR   R15,R15\n         MVCL  R0,R14                  ZERO WORKAREA\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        LOAD JCL STATEMENT AND JOB QUEUE RECORD ADDRESSES            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LM    R7,R8,0(R2)             LOAD INPUT PARAMETER ADDRESSES\n         USING JQREC,R8\n\n         MVI   WRKREC1,C' '            CLEAR STATEMENT WORK AREA\n         MVC   WRKREC1+1(L'WRKREC1-1),WRKREC1\n         MVC   WRKREC1(80),0(R7)       COPY INPUT STATEMENT TO WORKAREA\n\n         LA    R3,WRKREC1              LOAD STATEMENT STARTING ADDRESS\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CHECK IF CURRENT STATEMENT CONTAINS ONE OF OUR VARIABLES     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nXX020040 DS    0H\n         L     R15,CVTPTR              LOAD CVT ADDRESS\n         USING CVT,R15\n         MVC   WRKCVTDD,CVTDATE+2      SAVE CVT JULIAN DATE \"DDDF\"\n         ICM   R14,3,CVTDATE           LOAD CURRENT JULIAN YEAR\n         DROP  R15\n         SLL   R14,4                   MAKE ROOM FOR SIGN\n         STCM  R14,3,WRKCVTYY          SAVE CVT JULIAN YEAR \"0YY?'\n         OI    WRKCVTYY+1,X'0F'        INSERT SIGN\n\n         LA    R14,WRKREC1+80          LOAD STATEMENT ENDING ADDRESS\n         SR    R14,R3                  CALCULATE REMAINING LENGTH\n         BNP   XX020240                B. IF RECORD PROCESSING COMPLETE\n         XC    WRKTRTAB,WRKTRTAB\n         MVI   WRKTRTAB+C'&&',C'&&'    INSERT VARIABLE PREFIX BYTE\n         BCTR  R14,0                   DECREMENT FOR EXECUTE\n         #EXEC R14,TRT,0(*-*,R3),WRKTRTAB\n         BZ    XX020240                B. IF NO VARIABLE PREFIX FOUND\n         LR    R3,R1                   LOAD ADDRESS OF AMPERSAND\n\n         LA    R14,WRKREC1+80          LOAD STATEMENT ENDING ADDRESS\n         SR    R14,R3                  CALCULATE REMAINING LENGTH\n         BNP   XX020240                B. IF RECORD PROCESSING COMPLETE\n         XC    WRKTRTAB,WRKTRTAB\n         MVI   WRKTRTAB+C'.',C'.'      INSERT VARIABLE SUFFIX BYTE\n         MVI   WRKTRTAB+C'+',C'+'      INSERT VARIABLE SUFFIX BYTE\n         MVI   WRKTRTAB+C'-',C'-'      INSERT VARIABLE SUFFIX BYTE\n         BCTR  R14,0                   DECREMENT FOR EXECUTE\n         #EXEC R14,TRT,0(*-*,R3),WRKTRTAB\n         BZ    XX020240                B. IF NO VARIABLE SUFFIX FOUND\n         ST    R1,WRKEND@              SAVE SUFFIX END ADDRESS\n         STC   R2,WRKENDC              SAVE SUFFIX END CHARACTER\n         MVC   WRKREC2,1(R1)           SAVE DATA AFTER \".\"\n\n         LR    R14,R1                  LOAD TERMINATOR ADDRESS\n         SR    R14,R3                  CALCULATE VARIABLE NAME LENGTH\n         BCTR  R14,0                   SUBTRACT 1 FOR &\n         CH    R14,=H'08'              CHECK FOR MAXIMUM NAME LENGTH\n         BH    XX020230                B. IF TOO LONG\n\n         BCTR  R14,0                   DECREMENT FOR EXECUTE\n         LA    R6,XX02TAB1             LOAD VARIABLE NAME TABLE ADDRESS\nXX020050 DS    0H\n         CLI   0(R6),X'FF'             CHECK FOR END OF TABLE\n         BE    XX020230                B. IF END\n         CLM   R14,3,0(R6)             CHECK LENGTH OF VARIABLE NAME\n         BNE   XX020060                B. IF NOT THE SAME\n         #EXEC R14,CLC,1(*-*,R3),2(R6)\n         BE    XX020070                B. IF FOUND\nXX020060 DS    0H\n         LA    R6,14(,R6)              POINT TO NEXT VARIABLE NAME\n         B     XX020050                CONTINUE SEARCH\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RE-CALCULATE DATE IF XXXX+01. OR XXXX-01. FOUND              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nXX020070 DS    0H\n         ZAP   WRKVAR#,=P'+0'          FORMAT THE NUMERIC VARIABLE\n         CLI   WRKENDC,C'.'            CHECK IF CALCULATION IS REQUIRED\n         BE    XX020080                B. IF NOT\n         L     R4,WRKEND@              LOAD \"+\" OR \"-\" ADDRESS\n         LA    R4,1(,R4)               POINT PAST \"+\" OR \"-\"\n         LA    R14,WRKREC1+80          LOAD STATEMENT ENDING ADDRESS\n         SR    R14,R4                  CALCULATE REMAINING LENGTH\n         BNP   XX020240                B. IF RECORD PROCESSING COMPLETE\n         XC    WRKTRTAB,WRKTRTAB\n         MVI   WRKTRTAB+C'.',C'.'      INSERT VARIABLE SUFFIX BYTE\n         BCTR  R14,0                   DECREMENT FOR EXECUTE\n         #EXEC R14,TRT,0(*-*,R4),WRKTRTAB\n         BZ    XX020240                B. IF NO VARIABLE SUFFIX FOUND\n         ST    R1,WRKEND@              SAVE ADDRESS OF \".\"\n         MVC   WRKREC2,1(R1)           SAVE DATA AFTER \".\"\n         SR    R1,R4                   CALCULATE LENGTH OF NUMERICS\n         BNP   XX020080                B. IF NULL VALUE\n         LR    R14,R1                  LOAD LENGTH OF NUMERICS\n         MVI   WRKTRTAB,X'FF'\n         MVC   WRKTRTAB+1(L'WRKTRTAB-1),WRKTRTAB\n         MVC   WRKTRTAB+C'0'(10),=10X'00'\n         BCTR  R14,0                   DECREMENT FOR EXECUTE\n         #EXEC R14,TRT,0(*-*,R4),WRKTRTAB\n         BNZ   XX020230                B. IF NON-NUMERICS FOUND\n         #EXEC R14,PACK,WRKVAR#,0(*-*,R4)\n\nXX020080 DS    0H\n         ICM   R14,15,10(R6)           LOAD INSERT PROCESSING ADDRESS\n         BR    R14                     OVERLAY INPUT VARIABLE TEXT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        INSERT DATE INTO WORKING RECORD AND ADVANCE POINTER          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nXX020090 DS    0H\n         BAL   R14,CONVYEAR            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(1,R3),YY+1            INSERT \"Y\"\n         B     XX020220                CONTINUE\n\nXX020100 DS    0H\n         BAL   R14,CONVMNTH            CONVERT AND FORMAT DATE FIELDS\n         MVC   0(2,R3),MM              INSERT \"MM\"\n         B     XX020220                CONTINUE\n\nXX020110 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(2,R3),DD              INSERT \"DD\"\n         B     XX020220                CONTINUE\n\nXX020120 DS    0H\n         BAL   R14,CONVYEAR            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(2,R3),YY              INSERT \"YY\"\n         B     XX020220                CONTINUE\n\nXX020130 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(3,R3),DDD             INSERT \"DDD\"\n         B     XX020220                CONTINUE\n\nXX020140 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(3,R3),DAY             INSERT \"DAY\"\n         B     XX020220                CONTINUE\n\nXX020150 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(3,R3),DAY             INSERT \"DOW\"\n         B     XX020220                CONTINUE\n\nXX020170 DS    0H\n         BAL   R14,CONVYEAR            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(4,R3),CCYY            INSERT \"CCYY\"\n         B     XX020220                CONTINUE\n\nXX020180 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(2,R3),YY              INSERT \"YY\"\n         MVC   2(2,R3),DD              INSERT \"DD\"\n         MVC   4(2,R3),MM              INSERT \"MM\"\n         B     XX020220                CONTINUE\n\nXX020190 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(2,R3),YY              INSERT \"YY\"\n         MVC   2(2,R3),MM              INSERT \"MM\"\n         MVC   4(2,R3),DD              INSERT \"DD\"\n         B     XX020220                CONTINUE\n\nXX020200 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(2,R3),DD              INSERT \"DD\"\n         MVC   2(2,R3),MM              INSERT \"MM\"\n         MVC   4(2,R3),YY              INSERT \"YY\"\n         B     XX020220                CONTINUE\n\nXX020210 DS    0H\n         BAL   R14,CONVDATE            CALCULATE REQUESTED DATE\n         BAL   R14,FORMAT              FORMAT THE DATE FIELDS\n         MVC   0(2,R3),MM              INSERT \"MM\"\n         MVC   2(2,R3),DD              INSERT \"DD\"\n         MVC   4(2,R3),YY              INSERT \"YY\"\n         B     XX020220                CONTINUE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RESTORE SUFFIX, ADVANCE TO NEXT BYTE AND CONTINUE SEARCH     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nXX020220 DS    0H\n         LH    R1,0(,R6)               LOAD MACHINE LENGTH OF INSERT\n         AR    R3,R1                   POINT TO END OF INSERT\n         MVC   1(80,R3),WRKREC2        RESTORE DATA TRAILING VARIABLE\n         OI    WRKFLAG,WRK$MOD         REMEMBER RECORD WAS MODIFIED\n\nXX020230 DS    0H\n         LA    R3,1(,R3)               POINT TO NEXT BYTE IN RECORD\n         B     XX020040                CONTINUE TILL END OF STATEMENT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FREE THE WORKAREA AND EXIT WITH APPROPRIATE RETURN CODE      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nXX020240 DS    0H\n         TM    WRKFLAG,WRK$MOD         CHECK IF RECORD WAS MODIFIED\n         BNO   XX02EXIT                B. IF NOT\n         MVC   0(80,R7),WRKREC1        OVERLAY ORIGINAL STATEMENT\n\nXX02EXIT DS    0H\n         L     R9,WRKRCODE             SAVE RETURN CODE\n         LA    R0,WRKAREAL             SET WORKAREA LENGTH\n         SPUTM SIZE=(R0),AREA=(R13)\n         LR    R15,R9                  LOAD RETURN CODE\n         SEXIT ,                       TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FORMAT THE DATE FROM THE CONVERTED DATE & TIME               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nFORMAT   DS    0H\n         ST    R14,WRKREG14            SAVE RETURN ADDRESS\n\n         ICM   R0,12,WRKCVTYY          LOAD 0YYF....\n         SRL   R0,4                    CONVERT TO 00YYF...\n         OI    WRKCVTDD+1,X'0F'        ENSURE DATE IS DDDF\n         ICM   R0,3,WRKCVTDD           LOAD DDDF (R0 = 00YYDDDF)\n         #DATE WRKDATE,FORMAT='DDD CCYY MM DD DAYOFWEEK',FROM=(0)\n\n         L     R14,WRKREG14            RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CALCULATE CURRENT DATE BASED ON NUMERIC SUFFIX               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nCONVDATE DS    0H\n         ST    R14,WRKREG14            SAVE RETURN ADDRESS\n\n         CLI   WRKENDC,C'+'            CHECK FOR VARIABLE+##.\n         BNE   CONVD010                B. IF NOT\n         AP    WRKCVTDD,WRKVAR#        ADD VARIABLE NUMERIC\n         CP    WRKCVTDD,=P'+366'       CHECK FOR \"NEXT\" YEAR\n         BL    CONVDXIT                B. IF NOT\n         AP    WRKCVTYY,=P'+1'         ADD TO YEAR\n         SP    WRKCVTDD,=P'+365'       SUBTRACT FROM DATE\n         B     CONVDXIT\n\nCONVD010 DS    0H\n         CLI   WRKENDC,C'-'            CHECK FOR VARIABLE-##.\n         BNE   CONVDXIT                B. IF NOT\n         SP    WRKCVTDD,WRKVAR#        SUBTRACT VARIABLE NUMERIC\n         CP    WRKCVTDD,=P'+0'         CHECK FOR \"LAST\" YEAR\n         BH    CONVDXIT                B. IF NOT\n         SP    WRKCVTYY,=P'+1'         SUBTRACT FROM YEAR\n         AP    WRKCVTDD,=P'+365'       ADD TO DATE\n\nCONVDXIT DS    0H\n         L     R14,WRKREG14            RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n\nCONVMNTH DS    0H\n         LR    R4,R14                  SAVE RETURN ADDRESS\n         BAL   R14,FORMAT              FORMAT THE CURRENT DATE\n\n         ST    R4,WRKREG14             SAVE RETURN ADDRESS\n         PACK  DBL1,MM                 INSERT \"MM\"\n\n         CLI   WRKENDC,C'+'            CHECK FOR VARIABLE+##.\n         BNE   CONVM020                B. IF NOT\n         AP    DBL1,WRKVAR#            ADD VARIABLE NUMERIC\nCONVM010 DS    0H\n         CP    DBL1,=P'+12'            CHECK IF PAST DECEMBER\n         BNH   CONVM040                B. IF NOT\n         SP    DBL1,=P'+12'            SUBTRACT 1 YEAR\n         B     CONVM010\n\nCONVM020 DS    0H\n         CLI   WRKENDC,C'-'            CHECK FOR VARIABLE-##.\n         BNE   CONVMXIT                B. IF NOT\n         SP    DBL1,WRKVAR#            SUBTRACT VARIABLE NUMERIC\nCONVM030 DS    0H\n         CP    DBL1,=P'+1'             CHECK IF PAST JANUARY\n         BNL   CONVM040                B. IF NOT\n         AP    DBL1,=P'+12'            ADD 1 YEAR\n         B     CONVM030\n\nCONVM040 DS    0H\n         OI    DBL1+7,X'0F'            ENSURE POSITIVE SIGN\n         UNPK  MM,DBL1                 INSERT CONVERTED MONTH\n\nCONVMXIT DS    0H\n         L     R14,WRKREG14            RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n\nCONVYEAR DS    0H\n         ST    R14,WRKREG14            SAVE RETURN ADDRESS\n\n         CLI   WRKENDC,C'+'            CHECK FOR VARIABLE+##.\n         BNE   CONVY010                B. IF NOT\n         AP    WRKCVTYY,WRKVAR#        ADD VARIABLE NUMERIC\n         B     CONVYXIT\n\nCONVY010 DS    0H\n         CLI   WRKENDC,C'-'            CHECK FOR VARIABLE-##.\n         BNE   CONVYXIT                B. IF NOT\n         SP    WRKCVTYY,WRKVAR#        SUBTRACT VARIABLE NUMERIC\n\nCONVYXIT DS    0H\n         L     R14,WRKREG14            RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS & DYNAMIC WORKAREA                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #EXEC ,                       EXECUTED STATEMENTS\n         LTORG ,                       LITERAL POOL\nXX02TAB1 DS    0F\n         DC    AL2(0),CL8'Y       ',AL4(XX020090)\n         DC    AL2(1),CL8'MM      ',AL4(XX020100)\n         DC    AL2(1),CL8'DD      ',AL4(XX020110)\n         DC    AL2(1),CL8'YY      ',AL4(XX020120)\n         DC    AL2(2),CL8'DDD     ',AL4(XX020130)\n         DC    AL2(2),CL8'DAY     ',AL4(XX020140)\n         DC    AL2(2),CL8'DOW     ',AL4(XX020150)\n         DC    AL2(3),CL8'CCYY    ',AL4(XX020170)\n         DC    AL2(5),CL8'YYDDMM  ',AL4(XX020180)\n         DC    AL2(5),CL8'YYMMDD  ',AL4(XX020190)\n         DC    AL2(5),CL8'DDMMYY  ',AL4(XX020200)\n         DC    AL2(5),CL8'MMDDYY  ',AL4(XX020210)\n         DC    AL1(255)\n\nWRKAREA  DSECT ,                       DYNAMIC WORKAREA\n         DS    18F                     STANDARD SAVE AREA\nDBL1     DS    D                       #DATE WORK AREA #1\nDBL2     DS    D                       #DATE WORK AREA #2\nWRKCVTYY DS    PL2                     CVT YEAR\nWRKCVTDD DS    PL2                     CVT DAY\nWRKDATE  DC    C'DDD CCYY MM DD DAYOFWEEK'\nDDD      EQU   WRKDATE+00,3            - JULIAN DATE\nCCYY     EQU   WRKDATE+04,4            - CENTURY & YEAR\nYY       EQU   WRKDATE+06,2            - YEAR\nMM       EQU   WRKDATE+09,2            - NUMERIC MONTH OF YEAR\nDD       EQU   WRKDATE+12,2            - DAY OF MONTH\nDAY      EQU   WRKDATE+15,3            - DAY OF THE WEEK\nWRKEND@  DS    F                       VARIABLE NAME ENDING ADDRESS\nWRKENDC  DS    C                       VARIABLE NAME ENDING CHARACTER\nWRKFLAG  DS    X                       FLAG BYTE\nWRK$MOD  EQU   B'10000000'             - RECORD HAS BEEN MODIFIED\nWRKRCODE DS    F                       RETURN CODE\nWRKREC1  DS    CL160                   RECORD WORK AREA #1\nWRKREC2  DS    CL80                    RECORD WORK AREA #2\nWRKREG14 DS    F                       SUBROUTINE RETURN ADDRESS\nWRKTRTAB DS    XL256                   DYNAMIC TRANSLATE TABLE\nWRKVAR#  DS    PL2                     VARIABLE NUMERIC SUFFIX (PACKED)\n         DS    0D\nWRKAREAL EQU   *-WRKAREA               LENGTH OF WORK AREA\n\n         #DSECTS CVT\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SJFSAMP": {"ttr": 17929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x01\\xe9\\x01\\xe9\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 489, "newlines": 489, "modlines": 0, "user": "SOURCE"}, "text": "SJF      TITLE '- SJFSAMP - Sample SJF Extract'\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* S J F S A M P   |          Example Of SJF Retrieval                 *\n*                 |                                                   *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        This program is an example of what information can be        *\n*        retrieved about the OUTPUT JCL statements and the OUTPUT=    *\n*        keyword on the DD statement.                                 *\n*        The keywords to be extracted (placed in SJREKEYW) can be     *\n*        whatever is documented in the JCL manual for the OUTPUT      *\n*        statement (or the right side of the IEFDOKEY macro).         *\n*        If you are obtaining newer OUTPUT keywords such as PRTATTRS  *\n*        or AFPPARMS which were added with z/OS 1.8 then they should  *\n*        be placed at the end of the list if it is possible that      *\n*        the retrieve may be performed on a level of z/OS less than   *\n*        1.8.  If it is you will receive a REASON code of '201' (C9). *\n*        All other keywords will be retrieved.                        *\n*        SJF Reason codes are in the IEFSJRC macro.                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Attributes: Authorized / Rent                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nSJFSAMP  #START ,                  Start Procedure                     *\n               AMODE=CAP31,        Execute In 31-Bit Addressing Mode   *\n               RMODE=ANY,          Execute In ANY Residency Mode       *\n               BASE=(R12),         Define Base Register(s)             *\n               COPY=YES,                                               *\n               WKDSECT=SJFTWRK,    Define WorkArea Name                *\n               LOC=BELOW,          Acquire Workarea Below The Line     *\n               USING=(PSA,0,SJEXP,WRKSJFPL,SJREP,WRKSJFPL,SJRELIST,WRKL*\n               IST),                                                   *\n               LEVEL=*SAMPLE*      Maintenance Level\n\n         MODESET MODE=SUP,KEY=ZERO   *** Authorize ***\n\n         L     R3,=A(4096)         L(SJF Reply Area)\n         GETMAIN RU,LV=(R3),SP=0,LOC=ANY\n         ST    R1,WRKSJRE@         Save Reply Area Address\n         STH   R3,WRKSJREL         Save Reply Area Length\n\n         MVC   WTOPL(MODWTOL),MODWTO\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Obtain The JCL Definition Vector Table Name (JDVT)           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         XC    WRKSJFPL,WRKSJFPL\n         MVC   SJEXID,=CL4'SJJD'   - Identifier\n         MVI   SJEXVERS,SJEXCVER   - Version Number\n         MVC   SJEXLEN,=AL2(SJEXLGTH) - Length\n         MVC   SJEXVERB,=CL8'OUTPUT'  - Verb\n         MVC   SJEXKEYW,=CL8'DEFAULT' - Keyword\n         MVI   SJEXPARM,1             - Number Of SubParameters\n\n         SJFREQ REQUEST=FINDJDVT,PARM=WRKSJFPL\n\n         MVC   WRKJDVT,SJEXJDVT    Save JDVT Name (or Zeros)\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Check If A \"Job Level\" SWB Chain Exists                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R14,PSATOLD         A(TCB)\n         USING TCB,R14\n         L     R14,TCBTCT          A(TCT)\n         USING SMFTCT,R14\n         L     R10,TCTLCTAD        A(LCT)\n         USING LCT,R10\n         LA    R1,LCTJCTVA         A(JCT SVA)\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LR    R8,R2               A(JCT)\n         USING JCT,R8\n         LA    R1,JCTJCTX          A(JCT Extention SVA)\n         BAL   R14,SWAREQ          Convert SVA To Address\n         USING JCTX,R2\n         LA    R1,JCTXSWB+1        A(SWB Chain SVA)\n         DROP  R2\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R2,R2               Check If A SWB Chain Exists\n         BZ    MAIN0200            B. If Not\n         XC    WRKTOKN,WRKTOKN\n         SH    R2,=AL2(16)         Back Up To Control Block Prefix\n         ST    R2,WRKSWB@          Save JCT SWB Address\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display The \"Job\" Output Statement Information               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(35),=C'*** Job Level OUTPUT Statements ***'\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n\nMAIN0100 DS    0H\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(27),=C'//________ OUTPUT Statement'\n         L     R2,WRKSWB@          A(Current SWB)\n         USING SWB-16,R2\n         MVC   WTOTEXT+4(8),SWBVRBL\n         DROP  R2\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n\n         XC    WRKSJFPL,WRKSJFPL\n         MVC   SJREID,=CL4'SJRE'   - Identifier\n         MVI   SJREVERS,SJRECVER   - Version Number\n         MVC   SJRELEN,=AL2(SJRELGTH)\n         MVC   SJREJDVT,WRKJDVT    - Name Of JDVT\n         MVC   SJRETOKN,WRKTOKN    - Token (JCTSWB Address)\n         MVC   SJREAREA,WRKSJRE@   - Storage Area Address\n         MVC   SJRESIZE,WRKSJREL   - Size Of Storage Area\n         MVC   SJRENKWD,=AL2(4)    - Number Of Keywords Passed\n         LA    R0,WRKLIST\n         ST    R0,SJREKWDL         - Keyword List Address\n\n         MVC   SJREKEYW+00*SJREKLEN,=CL8'BUILDING'\n         MVC   SJREKEYW+01*SJREKLEN,=CL8'DEPT'\n         MVC   SJREKEYW+02*SJREKLEN,=CL8'TITLE'\n         MVC   SJREKEYW+03*SJREKLEN,=CL8'DEFAULT'\n\n         SJFREQ REQUEST=RETRIEVE,PARM=WRKSJFPL\n\n         L     R0,SJREREAS         Load Reason Code\n         LTR   R15,R15             Check Return Code\n         BZ    *+8                 B. If Successful\n         EX    0,*                 Else. Abend S0C3\n\n         BAL   R14,DISPTU          Display Returned Text Units\n\n*-------\n*        Check If Another SWB Exists In The Chain\n*-------\n         L     R2,WRKSWB@          A(Current SWB)\n         USING SWB-16,R2\n         LA    R1,SWBCHNXT+1       A(Next SWB In Chain)\n         DROP  R2\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R2,R2               Check If Another SWB Exists\n         BZ    MAIN0200            B. If Not\n         XC    WRKTOKN,WRKTOKN\n         SH    R2,=AL2(16)         Back Up To Control Block Prefix\n         ST    R2,WRKSWB@          Save SWB Address\n         B     MAIN0100            Process Next SWB\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display The \"Step\" OUTPUT Statement Information              *\n*                                                                     *\n*---------------------------------------------------------------------*\nMAIN0200 DS    0H\n         LA    R1,JCTSSTR          A(1st SCT SVA)\n\nMAIN0300 DS    0H\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R7,R2               Check If SCT Exists\n         BZ    RETURN              B. If End Of Job\n         USING SCT,R7\n\n         LA    R1,SCTSWB+1         A(Step's SWB Chain SVA)\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R2,R2               Check If SWB Chain Exists\n         BZ    MAIN0500            B. If Not\n         XC    WRKTOKN,WRKTOKN\n         SH    R2,=AL2(16)         Back Up To Control Block Prefix\n         ST    R2,WRKSWB@          Save SWB Address\n\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(34),=C'*** STEP ___ OUTPUT Statements ***'\n         SLR   R0,R0\n         IC    R0,SCTSNUMB         Load Step Number\n         CVD   R0,WRKDBL\n         OI    WRKDBL+7,X'0F'\n         UNPK  WTOTEXT+11(3),WRKDBL\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n\nMAIN0400 DS    0H\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(27),=C'//________ OUTPUT Statement'\n         L     R2,WRKSWB@          A(Current SWB)\n         USING SWB-16,R2\n         MVC   WTOTEXT+4(8),SWBVRBL\n         DROP  R2\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n\n         XC    WRKSJFPL,WRKSJFPL\n         MVC   SJREID,=CL4'SJRE'   - Identifier\n         MVI   SJREVERS,SJRECVER   - Version Number\n         MVC   SJRELEN,=AL2(SJRELGTH)\n         MVC   SJREJDVT,WRKJDVT    - Name Of JDVT\n         MVC   SJRETOKN,WRKTOKN    - Token (SCTSWB)\n         MVC   SJREAREA,WRKSJRE@   - Storage Area Address\n         MVC   SJRESIZE,WRKSJREL   - Size Of Storage Area\n         MVC   SJRENKWD,=AL2(4)    - Number Of Keywords Passed\n         LA    R0,WRKLIST\n         ST    R0,SJREKWDL         - Keyword List Address\n\n         MVC   SJREKEYW+00*SJREKLEN,=CL8'BUILDING'\n         MVC   SJREKEYW+01*SJREKLEN,=CL8'DEPT'\n         MVC   SJREKEYW+02*SJREKLEN,=CL8'TITLE'\n         MVC   SJREKEYW+03*SJREKLEN,=CL8'DEFAULT'\n\n         SJFREQ REQUEST=RETRIEVE,PARM=WRKSJFPL\n\n         L     R0,SJREREAS         Load Reason Code\n         LTR   R15,R15             Check Return Code\n         BZ    *+8                 B. If Successful\n         EX    0,*                 Else. Abend S0C3\n\n         BAL   R14,DISPTU          Display Returned Text Units\n\n*-------\n*        Check If Another SWB Exists In The Chain\n*-------\n         L     R2,WRKSWB@          A(Current SWB)\n         USING SWB-16,R2\n         LA    R1,SWBCHNXT+1       A(Next SWB In Chain)\n         DROP  R2\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R2,R2               Check If Another SWB Exists\n         BZ    MAIN0500            B. If Not\n         XC    WRKTOKN,WRKTOKN\n         SH    R2,=AL2(16)         Back Up To Control Block Prefix\n         ST    R2,WRKSWB@          Save SWB Address\n         B     MAIN0400            Process Next SWB\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Display The \"DD\" OUTPUT= Keyword Information                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nMAIN0500 DS    0H\n         LA    R1,SCTFSIOT         A(1st SIOT SVA)\n\nMAIN0600 DS    0H\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R6,R2               Check If SIOT Exists\n         BZ    MAIN0900            B. If Not\n\n         USING SIOT,R6\n         TM    SCTSBYT3,SCTSYSOU   Is This A SYSOUT= Statement\n         BNO   MAIN0800            B. If Not\n\n         LA    R1,SIOTSWB+1        A(DD's SWB Chain SVA)\n         BAL   R14,SWAREQ          Convert SVA To Address\n         LTR   R2,R2               Check If SWB Chain Exists\n         BZ    MAIN0800            B. If Not\n         XC    WRKTOKN,WRKTOKN\n         SH    R2,=AL2(16)         Back Up To Control Block Prefix\n         ST    R2,WRKSWB@          Save SWB Address\n\n         XC    WRKSJFPL,WRKSJFPL\n         MVC   SJREID,=CL4'SJRE'   - Identifier\n         MVI   SJREVERS,SJRECVER   - Version Number\n         MVC   SJRELEN,=AL2(SJRELGTH)\n         MVC   SJREJDVT,WRKJDVT    - Name Of JDVT\n         MVC   SJRETOKN,WRKTOKN    - Token (SIOTSWB)\n         MVC   SJREAREA,WRKSJRE@   - Storage Area Address\n         MVC   SJRESIZE,WRKSJREL   - Size Of Storage Area\n         MVC   SJRENKWD,=AL2(1)    - Number Of Keywords Passed\n         LA    R0,WRKLIST\n         ST    R0,SJREKWDL         - Keyword List Address\n\n         MVC   SJREKEYW+00*SJREKLEN,=CL8'OUTPUT'\n\n         SJFREQ REQUEST=RETRIEVE,PARM=WRKSJFPL\n\n         L     R0,SJREREAS         Load Reason Code\n         LTR   R15,R15             Check Return Code\n         BZ    *+8                 B. If Successful\n         EX    0,*                 Else. Abend S0C3\n\n         ICM   R1,15,SJRETPAD+00*SJREKLEN   A(OUTPUT= Pointer)\n         BZ    MAIN0800\n         L     R5,0(,R1)           A(OUTPUT= Text Unit)\n         USING S99TUNIT,R5\n         LH    R3,S99TUNUM         #(OUTPUT= Operands)\nMAIN0700 DS    0H\n         LH    R2,S99TULNG         L(OUTPUT= Operand)\n         LA    R1,S99TUPAR         A(OUTPUT= Operand)\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(37),=C'Statement ___ DD SYSOUT=(,),OUTPUT=*.'\n         #EXEC -R2,MVC,WTOTEXT+39(*-*),0(R1)\n         AHI   R2,1                Increment Operand Length\n         ICM   R0,15,SIOTSTMT      Load DD Statement Number\n         CVD   R0,WRKDBL\n         OI    WRKDBL+7,X'0F'\n         UNPK  WTOTEXT+12(3),WRKDBL\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n\n         LA    R5,2(R2,R5)         A(Next OUTPUT= Operand)\n         BCT   R3,MAIN0700\n         DROP  R5\n\nMAIN0800 DS    0H\n         LA    R1,SCTPSIOT         A(Next SIOT SVA)\n         B     MAIN0600\n\nMAIN0900 DS    0H\n         LA    R1,SCTANSCT         A(Next SCT SVA)\n         B     MAIN0300\n\nRETURN   DS    0H\n         MODESET MODE=PROB,KEY=NZERO *** De-Authorize ***\n\n         #STOP ,                   Terminate\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        SVA To Address Conversion Routine                         *\n*                                                                  *\n*        Input:                                                    *\n*            R1 => 3 Byte SVA                                      *\n*                                                                  *\n*        Output:                                                   *\n*            R2 = Converted Address                                *\n*           R15 = SWAREQ Return Code                               *\n*                                                                  *\n*------------------------------------------------------------------*\nSWAREQ   DS    0H\n         STM   R0,R14,WRKSWASV     Save All Registers\n         SLR   R2,R2\n         ICM   R2,7,0(R1)          Load SVA\n         BZ    SWAREXIT            B. If Zeros\n\n         XC    WRKEPA@(L'SWAEPA+4),WRKEPA@\n         LA    R0,WRKEPA@+4\n         ST    R0,WRKEPA@\n         STCM  R2,7,SWVA-ZB505+WRKEPA@+4\n         SWAREQ FCODE=RL,EPA=WRKEPA@,                                  *\n               MF=(E,WRKSWAPL)\n         ICM   R2,15,SWBLKPTR-ZB505+WRKEPA@+4\nSWAREXIT DS    0H\n         ST    R2,WRKSWASV+8       Return Control Block Address (R2)\n         LM    R0,R14,WRKSWASV     Restore All Registers\n         BR    R14                 Return To Caller\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        Display Extracted Text Unit Information                   *\n*                                                                  *\n*        This Subroutine Can Be Expanded To Display Additional     *\n*        OUTPUT Statement Keywords/Operands.                       *\n*                                                                  *\n*------------------------------------------------------------------*\n\nDISPTU   ds    0h\n         STM   R0,R15,WRKDISPS     Save All Registers\n\n*-------\n*        Process The \"BUILDING=\" Keyword\n*-------\n         ICM   R1,15,SJRETPAD+00*SJREKLEN   A(BUILDING= Pointer)\n         BNZ   DISP0100\n         WTO   'NO BUILDING= FOUND',ROUTCDE=11\n         B     DISP0200\nDISP0100 DS    0H\n         L     R5,0(,R1)           A(BUILDING= Text Unit)\n         USING S99TUNIT,R5\n         LH    R2,S99TULNG         L(BUILDING= Operand)\n         LA    R1,S99TUPAR         A(BUILDING= Operand)\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(9),=C'BUILDING='\n         #EXEC -R2,MVC,WTOTEXT+11(*-*),0(R1)\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n         DROP  R5\n\n*-------\n*        Process The \"DEPT=\" Keyword\n*-------\nDISP0200 DS    0H\n         ICM   R1,15,SJRETPAD+01*SJREKLEN   A(DEPT= Pointer)\n         BNZ   DISP0300\n         WTO   'NO DEPT= FOUND',ROUTCDE=11\n         B     DISP0400\nDISP0300 DS    0H\n         L     R5,0(,R1)           A(DEPT= Text Unit)\n         USING S99TUNIT,R5\n         LH    R2,S99TULNG         L(DEPT= Operand)\n         LA    R1,S99TUPAR         A(DEPT= Operand)\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(5),=C'DEPT='\n         #EXEC -R2,MVC,WTOTEXT+7(*-*),0(R1)\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n         DROP  R5\n\n*-------\n*        Process The \"TITLE=\" Keyword\n*-------\nDISP0400 DS    0H\n         ICM   R1,15,SJRETPAD+02*SJREKLEN   A(TITLE= Pointer)\n         BNZ   DISP0500\n         WTO   'NO TITLE= FOUND',ROUTCDE=11\n         B     DISP0600\nDISP0500 DS    0H\n         L     R5,0(,R1)           A(TITLE= Text Unit)\n         USING S99TUNIT,R5\n         LH    R2,S99TULNG         L(TITLE= Operand)\n         LA    R1,S99TUPAR         A(TITLE= Operand)\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(6),=C'TITLE='\n         #EXEC -R2,MVC,WTOTEXT+8(*-*),0(R1)\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n         DROP  R5\n\n*-------\n*        Process The \"DEFAULT=\" Keyword\n*-------\nDISP0600 DS    0H\n         MVC   WTOTEXT,BLANKS\n         MVC   WTOTEXT(2),=AL2(80)\n         MVC   WTOTEXT+2(10),=C'DEFAULT=NO'\n\n         ICM   R1,15,SJRETPAD+03*SJREKLEN   A(DEFAULT= Pointer)\n         BZ    DISP0700\n         L     R5,0(,R1)           A(DEFAULT= Text Unit)\n         USING S99TUNIT,R5\n         CLI   S99TUPAR,X'40'      DEFAULT=YES (X'40'=Yes X'80'=No)\n         BNE   DISP0700            B. If Not\n         DROP  R5\n         MVC   WTOTEXT+10(3),=C'YES'\nDISP0700 DS    0H\n         WTO   TEXT=WTOTEXT,ROUTCDE=11,MF=(E,WTOPL)\n\n         LM    R0,R15,WRKDISPS     Restore All Registers\n         BR    R14                 Return To Caller\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        CONSTANTS AND WORK AREA                                   *\n*                                                                  *\n*------------------------------------------------------------------*\n\nBLANKS   DC    82C' '\nMODWTO   WTO   TEXT=*-*,ROUTCDE=11,MF=L\nMODWTOL  EQU   *-MODWTO\n\n         #STARTWA ,\nWRKDBL   DS    D                   Decimal Conversion Area\nSJFPTR   DS    F                   A(WRKSJFPL)\nWRKSWAPL SWAREQ MF=L               SWAREQ Parameter List\nWRKJDVT  DS    CL8                 JCL Definition Vector Table Name\n         DS    0D\nWRKSJFPL DS    XL256               SJF Request Parameter List\nWRKTOKN  DS    D                   SJF Request Token\n         ORG   WRKTOKN\nWRKSWB@  DS    F                   Current SWB Address\n         ORG   ,\nWRKEPA@  DS    A,XL(L'SWAEPA)      SWAREQ Work Area\nWRKSWASV DS    16F                 SWAREQ SubRoutine Save Area\nWRKDISPS DS    16F                 DISPTU SubRoutine Save Area\nWRKSJRE@ DS    A                   Reply Buffer Address\nWRKSJREL DS    H                   Reply Buffer Length\nWRKLIST  DS    0D,XL(10*SJREKLEN)  Request Keyword List\nWTOPL    DS    0F,CL(MODWTOL)      WTO Parameter List\nWTOTEXT  DS    CL82                WTO Text\n         #STOPWA ,\n\n*------------------------------------------------------------------*\n*                                                                  *\n*        DSECTS                                                    *\n*                                                                  *\n*------------------------------------------------------------------*\n         #DSECTS CVT,JESCT,PSA,TCB,TCT,LCT,JCT,JCTX,SWB,SCT,SIOT,ALLOC,*\n               ZB505\n\n         IEFSJEXP ,                SJF Extract Parameter List\n         IEFSJREP ,                SJF Retrieve Parameter List\n         IEFSJRC ,                 SJF Reason Codes\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEPLIB": {"ttr": 18183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x08\\x17\\x08\\x17\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 2071, "newlines": 2071, "modlines": 0, "user": "SOURCE"}, "text": "STEPLIB  TITLE '- STEPLIB - COMMAND PROCESSOR'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n*  S T E P L I B  |       TSO STEPLIB COMMAND PROCESSOR               *\n*                 |                                                   *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* COMMNAD SYNTAX:                                                     *\n*                                                                     *\n*        STEPLIB ADD DATASETS(DSNAME LIST) FIRST|LAST NOMSGS          *\n*        - ADDS THE DSNAME LIST TO THE EXISTING STEPLIB.              *\n*                                                                     *\n*        STEPLIB ALLOCATE DATASETS(DSNAME LIST) SHR REUSE NOMSGS      *\n*        - ALLOCATES A NEW STEPLIB & CLOSES/FREES THE OLD.            *\n*                                                                     *\n*        STEPLIB FREE NOMSGS                                          *\n*        - CLOSES/FREES THE OLD STEPLIB.                              *\n*                                                                     *\n*        STEPLIB LIST                                                 *\n*        - DISPLAYS THE STEPLIB DDNAME AND DATASETS.                  *\n*                                                                     *\n*        STEPLIB REMOVE DATASETS(DSNAME LIST) NOMSGS                  *\n*        - REMOVES THE DSNAME LIST FROM THE EXISTING STEPLIB.         *\n*                                                                     *\n*        STEPLIB SAVE                                                 *\n*        - CREATES A CLIST VARIABLE (&STEPLIB) TO BE USED TO SAVE     *\n*          THE CURRENT STEPLIB'S DATASET NAME LIST.                   *\n*                                                                     *\n*        STEPLIB STACK DATASETS(DSNAME LIST) FIRST|LAST NOMSGS        *\n*        - ADDS THE DSNAME TO THE STEPLIB, EVEN IF IT IS ALREADY      *\n*          PART OF THE CONCATENATION.                                 *\n*                                                                     *\n*        STEPLIB DESTACK DATASETS(DSNAME LIST) NOMSGS                 *\n*        - REMOVES THE 1ST OCCUANCE OF A DSNAME FROM THE STEPLIB.     *\n*                                                                     *\n*        STEPLIB ... APFCHK                                           *\n*        - AFTER THE FUNCTION IS PERFORMED, CHECK IF THE LIBRARIES    *\n*          WITHIN THE STEPLIB ARE IN THE APF LIST.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY:          - JAN 13,1996 -  RE-WRITTEN FROM OLD \"MODS\"   *\n*              #DD99244 - SEP 01,1999 -  VARIOUS BUG FIXES:           *\n*              - IF OLD STEPLIB DDNAME IS \"STEPLIB\" BYPASS \"UNALLOC\". *\n*              - GET \"REAL\" NAME FROM CATALOG IN CASE AN ALIAS WAS    *\n*                SPECIFIED ON THE \"STEPLIB REMOVE\".                   *\n*              - FIX REMOVAL OF \"LAST\" DATASET FROM LIST.             *\n*              #DD99245 - SEP 02,1999 -  IF THE ORIGINAL DDNAME       *\n*                FOR A STEPLIB IS NOT A \"$TEP\" PREFIX, IT IS FREE'D   *\n*                AND RE-ALLOCATED WITH THE $TEP000# DDNAME.           *\n*              #DD01068 - MAR 09,2001 -  RECOGNIZE LIBRARIES THAT     *\n*                ARE ALREADY IN THE CURRENT STEPLIB WHEN PERFORMING   *\n*                AN \"ADD\" FUNCTION.                                   *\n*              #DD01072 - MAR 13,2001 -  ADD \"STACK\"/\"DESTACK\".       *\n*              #DD01073 - MAR 14,2001 -  ADD \"APFCHK\".                *\n*              #DD01095 - APR  5,2001 -  CORRECTIVE FIXES.            *\n*              #DD01250 - SEP  7,2001 -  FIX \"DESTACK\" PROCESSING.    *\n*              #DD04108 - APR 17,2004 -  ADD ESTAE AROUND OPEN        *\n*                                        TO PROTECT AGAINST ABENDS,   *\n*                                        ESPECIALLY S913'S.           *\n*              #DD05026 - JAN 26,2005 -  CHECK FOR A REAL \"JOBLIB\".   *\n*              #DD05031 - JAN 31,2005 -  CORRECT NULL STEPLIB DDNAME. *\n*              #DD08098 - APR  7,2008 -  STEPLIB \"VERSION\" FUNCTION.  *\n*              #DD08099 - APR  8,2008 -  ISSUE OPEN FAILED MSG FOR    *\n*                                        EACH FAILED DSN.             *\n*              #DD08112 - APR 21,2008 -  CORRECT APF/SMS CHECK.       *\n*              #DD08268 - SEP 24,2008 -  ALLOW FOR BATCH TMP.         *\n*                                     -  ADD DEBUG CODE.              *\n*              #DD08350 - DEC 15,2008 -  NO TRACE WHEN PARSE ERROR    *\n*              #DD09027 - JAN 27,2009 -  PAUSE BEFORE BATCH EXIT.     *\n*              #DD09101 - APR 11,2009 -  USE BRANCH ENTRY CIRB.       *\n*                                        FIX FOR Z11 PMR 49446,756    *\n*                                        (D78 abend).                 *\n*              #DD09103   APR 13,2009 -  CHANGE TO USE SCHEDIRB.      *\n*              #DD09199   JUL 18,2009 -  LEAVE NON-ZERO TCBJLIB ALONE.*\n*   1.16 -     #DD10050   Feb 19,2010 -  Build DCB/DCBE for >= r1.12  *\n*                       (Thanks to Jan Ott for heads up & assistance).*\n*   1.17 -     #DD10106   Apr 16,2010 -  JES3 Support.                *\n*   1.18 -     #DD10177   Jun 10,2010 -  Create &STEPLIB Variable.    *\n*   1.19 -     #DD12060   Feb 29,2012 -  Correction for EAV support.  *\n*   1.20 -     #JR14048   Feb 17,2014 -  Use 24-bit address for RBCDE.*\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nSTEPLIB  #START ,                  START PROCEDURE                     *\n               AMODE=CAP31,        EXECUTE IN 31-BIT ADDRESSING MODE   *\n               APARS=,             NO NEED FOR APAR \"ZAP\" SLOTS        *\n               RMODE=24,           EXECUTE IN 24-BIT RESIDENCY MODE    *\n               BASE=(R12,R11),     DEFINE BASE REGISTER(S)             *\n               COPY=YES,           INSERT COPYRIGHT NOTICE             *\n               WKDSECT=STEPWRK,    DEFINE WORKAREA NAME                *\n               LEVEL=#V001R20                                  #DD14048\n\n         USING PSA,0\n\n         ST    R1,WRKCPPL@         Save CPPL Address           #DD10106\n         LR    R8,R1               A(CPPL)\n         USING CPPL,R8\n\n         MVC   WRKUPT@,CPPLUPT     SAVE A(UPT)\n         MVC   WRKECT@,CPPLECT     SAVE A(ECT)\n\n         L     R15,PSATOLD         LOAD TCB  ADDRESS           #DD08268\n         USING TCB,R15                                         #DD08268\n         MVC   WRKJSTCB,TCBJSTCB   SAVE JOBSTEP TCB ADDRESS    #DD08268\n         L     R14,TCBJSCB         LOAD JSCB ADDRESS           #DD08268\n         USING IEZJSCB,R14                                     #DD08268\n         L     R14,JSCBACT         LOAD ACTIVE JSCB ADDRESS    #DD08268\n         L     R14,JSCBSSIB        LOAD SSIB ADDRESS           #DD08268\n         USING SSIB,R14                                        #DD08268\n         MVC   WRKTYPE,SSIBJBID    \"J\", \"T\" OR \"S\"             #DD08268\n         MVC   WRKSSID,SSIBSSID    Save Subsystem Identifier   #DD10106\n         DROP  R14,R15                                         #DD08268\n\n*        SSIBJBID is unreliable when running under JES3.       #DD10106\n         CLI   WRKSSID,SSIBJES2    Check For JES2 Subsystem    #DD10106\n         BE    STEP0100            B. If Yes (JBID Is Reliable)#DD10106\n         L     R14,PSAAOLD         A(ASCB)                     #DD10106\n         USING ASCB,R14                                        #DD10106\n         ICM   R14,15,ASCBOUCB     A(OUCB)                     #DD10106\n         USING OUCB,R14                                        #DD10106\n         MVI   WRKTYPE,C'S'                                    #DD10106\n         TM    OUCBYFL,OUCBSTT+OUCBMNT Started Task Or Mount?  #DD10106\n         BNZ   STEP0100            B. If Yes                   #DD10106\n         MVI   WRKTYPE,C'T'                                    #DD10106\n         TM    OUCBYFL,OUCBLOG     Check For Logon             #DD10106\n         BO    STEP0100            B. If Yes                   #DD10106\n         MVI   WRKTYPE,C'J'        Treat All Others As Jobs    #DD10106\n         DROP  R14                                             #DD10106\n\nSTEP0100 DS    0H                                              #DD10106\n         L     R2,FLCCVT           A(CVT)                      #DD10050\n         USING CVTMAP,R2                                       #DD10050\n         TM    CVTOSLV5,CVTZOS_V1R12                           #DD10050\n         BZ    STEP0200            B. If Not z/OS R1.12 or >   #DD10050\n         OI    WRKFLAG1,WRK$R112   Set z/OS R1.12 flag         #DD10050\n         DROP  R2                                              #DD10050\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND THE NEXT \"$TEP####\" TO USE AS THE NEW STEPLIB DDNAME    *\n*        NOTE: THIS DDNAME IS USED TO ALLOCATE THE DATASETS WITHIN    *\n*              THE IKJPARS VALIDATION SUBROUTINE.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0200 DS    0H                                              #DD10050\n         MVC   WRKDDNEW,=CL8'$TEP0001'\nSTEP0300 DS    0H                                              #DD99245\n         LA    R2,WRKDDNEW         A(\"NEW\" FAKE STEPLIB DDNAME)#DD99245\n         TIOTSCAN DDN=(R2),NOK=STEP0400  SCAN THE TIOT         #DD99245\n         PACK  WRKDBL1,WRKDDNEW+4(4)                           #DD99245\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB DD NUMBER #DD99245\n         OI    WRKDBL1+7,X'0F'                                 #DD99245\n         UNPK  WRKDDNEW+4(4),WRKDBL1                           #DD99245\n         B     STEP0300                                        #DD99245\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLOSE & RE-OPEN THE STEPLIB TO RETRIEVE THE DDNAME           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0400 DS    0H                                              #DD99245\n         L     R4,PSATOLD          A(TCB)                      #DD99245\n         USING TCB,R4                                          #DD99245\n         L     R5,TCBTCT           A(TCT)                      #DD99245\n         USING SMFTCT,R5                                       #DD99245\n         L     R6,TCTLCTAD         A(LCT)                      #DD99245\n         ST    R6,WRKLCT@          SAVE LCT ADDRESS            #DD99245\n\n         L     R5,TCBJSCB          A(JSCB)                     #DD01068\n         USING IEZJSCB,R5                                      #DD01068\n         L     R5,JSCBACT          A(ACTIVE JSCB)              #DD01068\n         L     R5,JSCDSABQ         A(QDB)                      #DD01068\n         USING QDB,R5                                          #DD01068\n         MVC   WRKDSAB@,QDBFELMP   SAVE DSAB ADDRESS           #DD01068\n         DROP  R4,R5                                           #DD01068\n\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD01068\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD01068\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01068\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD01068\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)       #DD01068\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01068\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARSE THE STEPLIB COMMAND BUFFER                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R1,WRKPPL           LOAD PPL ADDRESS\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      SET UPT ADDRESS\n         MVC   PPLECT,CPPLECT      SET ECT ADDRESS\n         LA    R15,WRKECB\n         ST    R15,PPLECB          SET ECB ADDRESS\n         XC    WRKECB,WRKECB\n         MVC   PPLPCL,=A(STEPPCL)  SET PCL ADDRESS\n         LA    R15,WRKANS@\n         ST    R15,PPLANS          SET PDL ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    SET COMMAND BUFFER ADDRESS\n         ST    R13,PPLUWA          PASS WRKDSECT TO VALIDATION EXIT\n         DROP  R1,R8                                           #DD10106\n\n         CALLTSSR EP=IKJPARS,MF=(E,WRKPPL)\n         L     R8,WRKANS@          LOAD PDL ADDRESS\n         USING IKJPARMD,R8\n         #SETRC (R15)              SET RETURN CODE\n         LTR   R15,R15             CHECK PARSE RETURN CODE\n         BZ    STEP0500            B. IF SUCCESSFUL            #DD99245\n\n*-------\n*        FREE ANY ALLOCATED DATASETS IF THE PARSE ROUTINE FAILED\n*-------\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BZ    STEPEXIT            B. IF NOT                   #DD08350\n         LA    R0,WRKDDNEW         A(STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDNEW       L(STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         FREE  PERM,DDN=WRKDDN@    FREE THE \"NEW\" STEPLIB DATASETS\n         B     STEPEXIT                                        #DD08350\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RE-ALLOCATE THE CURRENT STEPLIB IF THE OLD STEPLIB WAS       *\n*        A \"REAL\" STEPLIB. (IE. //STEPLIB WITHIN THE LOGON PROC)      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0500 DS    0H                                              #DD99245\n         TM    WRKFLAG1,WRK$ABND   CHECK FOR \"OPEN\" ABEND      #DD08099\n         BO    STEP6000            B. IF YES                   #DD08268\n\n         CLI   $TEPFUNC+1,$VERSION CHECK FOR \"VERSION\" FUNC.   #DD08098\n         BE    STEP5900            B. IF YES                   #DD08098\n\n         CLI   $TEPFUNC+1,$FREE    CHECK FOR \"FREE\" FUNCTION   #DD99245\n         BE    STEP1500            B. IF YES                   #DD99245\n         CLI   $TEPFUNC+1,$LIST    CHECK FOR \"LIST\" FUNCTION   #DD99245\n         BE    STEP2500            B. IF YES                   #DD05031\n\n         MVC   WRKDDTMP,=CL8'$TEP0001'                         #DD99245\nSTEP0600 DS    0H                                              #DD99245\n         LA    R2,WRKDDTMP         A(\"NEW\" FAKE STEPLIB DDNAME)#DD99245\n         TIOTSCAN DDN=(R2),NOK=STEP0700  SCAN THE TIOT         #DD99245\n         PACK  WRKDBL1,WRKDDTMP+4(4)                           #DD99245\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB NUMBER    #DD99245\n         OI    WRKDBL1+7,X'0F'                                 #DD99245\n         UNPK  WRKDDTMP+4(4),WRKDBL1                           #DD99245\n         B     STEP0600                                        #DD99245\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED \"REAL\" STEPLIB\n*-------\nSTEP0700 DS    0H                                              #DD99245\n         CLC   =C'JOBLIB ',WRKDDOLD CHECK FOR \"REAL\" JOBLIB DD #DD05026\n         BE    STEP0800            B. IF YES                   #DD05026\n         CLC   =C'STEP',WRKDDOLD   CHECK FOR \"REAL\" STEPLIB DD #DD01068\n         BNE   STEP1500            B. IF NOT                   #DD01068\nSTEP0800 DS    0H                                              #DD05026\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD99245\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD99245\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD99245\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE OLD STEPLIB DDNAME\n*-------\n         NI    WRKFLAG1,255-WRK$1STD                           #DD99245\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP1500            B. IF CHAIN DOES NOT EXIST  #DD99245\n         USING DSABID,R5                                       #DD99245\n\nSTEP0900 DS    0H                                              #DD99245\n         L     R4,DSABSIOT         A(SIOT)                     #DD99245\n         USING INDMSIOT,R4                                     #DD99245\n         CLC   SCTDDNAM,WRKDDOLD   CHECK PREV. STEPLIB DDNAME  #DD99245\n         BE    STEP1000            B. IF FOUND                 #DD99245\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD99245\n         BNZ   STEP0900            B. IF ANOTHER DSAB EXISTS   #DD99245\n         B     STEP1500            ELSE. UNABLE TO FIND DDNAME #DD99245\n\n*-------\n*        ALLOCATE THE 1ST DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP1000 DS    0H                                              #DD99245\n         L     R1,SJFCBPTR         A(JFCB)                     #DD99245\n         USING INFMJFCB,R1                                     #DD99245\n         MVC   WRKDSN1,JFCBDSNM    SAVE THE CURRENT DSN        #DD99245\n         DROP  R1                                              #DD99245\n         LA    R0,WRKDSN1                                      #DD99245\n         ST    R0,WRKDSN@          A(CURRENT STEPLIB DSNAME)   #DD99245\n         LA    R0,L'WRKDSN1                                    #DD99245\n         STH   R0,WRKDSN@+4        L(CURRENT STEPLIB DSNAME)   #DD99245\n\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DSN ALLOCATED  #DD99245\n         BO    STEP1100            B. IF YES                   #DD99245\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DSN ALLOCATED  #DD99245\n         LA    R0,WRKDDTMP                                     #DD99245\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD99245\n         LA    R0,L'WRKDDTMP                                   #DD99245\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD99245\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                      #DD99245*\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT             #DD99245\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE#DD99245\n         BZ    STEP1300            B. IF SUCCESSFUL            #DD99245\n         B     STEP1200            ELSE. ISSUE ALLOC ERROR MSG #DD99245\n\n*-------\n*        CONCATENATE THE REMAINING DSNAMES TO THE NEW STEPLIB DDNAME\n*-------\nSTEP1100 DS    0H                                              #DD99245\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                      #DD99245*\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT          #DD99245\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE#DD99245\n         BNZ   STEP1200            B. IF ALLOCATION FAILED     #DD99245\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)                    #DD99245\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME        #DD99245\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME        #DD99245\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)                    #DD99245\n         MVC   WRKCCDD1+2(8),WRKDDTMP                          #DD99245\n         MVC   WRKCCDD2+2(8),WRKDDRET                          #DD99245\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)            #DD99245\n         LTR   R15,R15             CHECK CONCAT RETURN CODE    #DD99245\n         BZ    STEP1300            B. IF CONCAT SUCCEEDED      #DD99245\n\n*-------\n*        PROCESS ALLOCATION/CONCATENATION ERRORS\n*-------\nSTEP1200 DS    0H                                              #DD99245\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP6000                                        #DD08268\n\n*-------\n*        CHECK IF NEXT DSAB IS A CONCATENATION OF THE STEPLIB\n*-------\nSTEP1300 DS    0H                                              #DD99245\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD99245\n         BZ    STEP1400            B. IF END OF DSAB CHAIN     #DD99245\n         L     R4,DSABSIOT         A(SIOT)                     #DD99245\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION     #DD99245\n         BE    STEP1000            B. IF YES                   #DD99245\n         DROP  R4,R5                                           #DD99245\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP1400 DS    0H                                              #DD99245\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD99245\n         LA    R1,WRKDDTMP         A(NEW STEPLIB DDNAME)       #DD99245\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD99245\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB ADD\" FUNCTION                           *\n*             OR THE \"STEPLIB STACK\" FUNCTION                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP1500 DS    0H                                              #DD01073\n         L     R15,=A(MSG008I6)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$STACK   CHECK FOR \"STACK\" FUNCTION  #DD01072\n         BE    STEP1600            B. IF YES                   #DD01072\n         CLI   $TEPFUNC+1,$ADD     CHECK FOR \"ADD\" FUNCTION\n         BNE   STEP2100            B. IF NOT\n         L     R15,=A(MSG008I1)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\nSTEP1600 DS    0H                                              #DD01072\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n         TM    WRKFLAG1,WRK$1STD   CHECK IF ANY DSNS TO ADD    #DD01095\n         BO    STEP1700            B. IF YES                   #DD01095\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01095\n         BE    STEP5200            B. IF YES (DO \"APFCHK\")     #DD01095\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD01095\n         L     R1,=A(MSG010I)      'DATASET ALREADY IN STEPLIB'#DD10106\n         SLR   R2,R2                                           #DD01095\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01095\n         B     STEP5200                                        #DD01095\nSTEP1700 DS    0H                                              #DD01095\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEP2200            B. IF ONE DOES NOT EXIST (ALLOCATE)\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEP2200            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n\n*-------\n*        CONCATENATE THE NEW DATASET(S) WITH THE OLD STEPLIB DATASETS\n*-------\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDOLD\n         CLI   $TEPOPTS+1,$FIRST   CHECK FOR \"FIRST\" OPTION\n         BE    STEP1800            B. IF YES\n         MVC   WRKCCDD1+2(8),WRKDDOLD\n         MVC   WRKCCDD2+2(8),WRKDDNEW\nSTEP1800 DS    0H\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    STEP1900            B. IF CONCATENATION SUCCEEDED\n\n*-------\n*        IF CONCATENATION FAILS, ISSUE MESSAGE & REINSTATE OLD STEPLIB\n*-------\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BZ    STEP6000            B. IF NOT                   #DD08268\n         LA    R0,WRKDDNEW         A(STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDNEW       L(STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DDNAME\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP6000                                        #DD08268\n\n*-------\n*        RE-OPEN THE CONCATENATED STEPLIB\n*-------\nSTEP1900 DS    0H\n         CLI   $TEPOPTS+1,$FIRST   CHECK FOR \"FIRST\" OPTION\n         BE    STEP2000            B. IF YES\n         MVC   WRKDDNEW,WRKDDOLD   NEW STEPLIB DDNAME TO SAME AS BEFORE\n\nSTEP2000 DS    0H\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG001I)      'STEPLIB EXTENDED'          #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB ALLOCATE\" FUNCTION                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2100 DS    0H\n         L     R15,=A(MSG008I2)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$ALLOC   CHECK FOR \"ALLOCATE\" FUNCTION\n         BNE   STEP2300            B. IF NOT\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEP2200            B. IF ONE DOES NOT EXIST\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEP2200            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE & FREE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP2200            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP2200 DS    0H\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG002I)      'STEPLIB ALLOCATED'         #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB FREE\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2300 DS    0H\n         L     R15,=A(MSG008I3)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$FREE    CHECK FOR \"FREE\" FUNCTION\n         BNE   STEP2500            B. IF NOT\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE & FREE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP2400            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\nSTEP2400 DS    0H\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG003I)      'STEPLIB FREED'             #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB LIST\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2500 DS    0H\n         L     R15,=A(MSG008I4)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$LIST    CHECK FOR \"LIST\" FUNCTION\n         BNE   STEP2900            B. IF NOT                   #DD10177\n\n*-------\n*        CHECK IF THERE IS CURRENTLY A STEPLIB\n*-------\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE START OF THE STEPLIB DD\n*-------\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP6000            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5\n\nSTEP2600 DS    0H\n         L     R4,DSABSIOT         A(SIOT)\n         USING INDMSIOT,R4\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB DDNAME\n         BE    STEP2700            B. IF FOUND\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BNZ   STEP2600            B. IF ANOTHER DSAB EXISTS\n         B     STEP6000            ELSE. UNABLE TO FIND OLD DDN#DD08268\n\n*-------\n*        ONCE 1ST DSAB ENTRY FOUND DISPLAY ASSOCIATED DSNAMES\n*-------\nSTEP2700 DS    0H\n         MVC   WRKINSRT(4),=AL2(12,39)   LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(8),WRKDDOLD\n         LA    R0,2                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG006I)      '$TEPNNNN LIST:'            #DD10106\n         LA    R2,WRKINSRT\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n\nSTEP2800 DS    0H\n         L     R1,SJFCBPTR         A(JFCB)\n         USING INFMJFCB,R1\n         MVC   WRKINSRT(4),=AL2(48,11)   LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(44),JFCBDSNM\n         DROP  R1\n         LA    R0,2                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG007I)      '- DSNAME'                  #DD10106\n         LA    R2,WRKINSRT\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n\n*-------\n*        CONTINUE PROCESSING DSAB'S TILL NON STEPLIB DD FOUND\n*-------\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BZ    STEP5200            B. IF END OF DSAB CHAIN     #DD01073\n         L     R4,DSABSIOT         A(SIOT)\n         CLC   SCTDDNAM,BLANKS     CHECK IF NEXT IS A CONCATENATION\n         BE    STEP2800            B. IF YES\n         DROP  R4,R5\n         B     STEP5200            ELSE. END OF LIST           #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB SAVE\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2900 DS    0H                                              #DD10177\n         CLI   $TEPFUNC+1,$SAVE    CHECK FOR \"SAVE\" FUNCTION   #DD10177\n         BNE   STEP3800            B. IF NOT                   #DD10177\n\n*-------\n*        Create Blank &STEPLIB Variable\n*-------\n         MVC   CVARCODE,=A(TSVEUPDT)  \"Update\"                 #DD10177\n         LA    R0,CVARCODE                                     #DD10177\n         ST    R0,CVAREC@                                      #DD10177\n         MVC   CVARN,=CL8'STEPLIB' Set Variable Name           #DD10177\n         LA    R0,CVARN            A(Variable Name)            #DD10177\n         ST    R0,CVARN@                                       #DD10177\n         LA    R0,CVARN@                                       #DD10177\n         ST    R0,CVARNPT@                                     #DD10177\n         MVC   CVARL,=F'7'         Set Variable Name Length    #DD10177\n         LA    R0,CVARL            A(Variable Name Length)     #DD10177\n         ST    R0,CVARNLN@                                     #DD10177\n         LA    R0,BLANKS           A(Variable Data)            #DD10177\n         ST    R0,CVARD@                                       #DD10177\n         LA    R0,CVARD@                                       #DD10177\n         ST    R0,CVARDPT@                                     #DD10177\n         XC    CVARDL,CVARDL                                   #DD10177\n         LA    R0,CVARDL           A(Variable Data Length)     #DD10177\n         ST    R0,CVARDLN@                                     #DD10177\n         LA    R0,CVARTKN          A(Token)                    #DD10177\n         ST    R0,CVARTKN@                                     #DD10177\n         OI    CVARTKN@,X'80'      Set End Of List             #DD10177\n         l     R15,FLCCVT          A(CVT)                      #DD10177\n         USING CVTMAP,R15                                      #DD10177\n         L     R15,CVTTVT          A(TVT)                      #DD10177\n         USING TSVT,R15                                        #DD10177\n         L     R15,TSVTVACC        A(IKJCT441)                 #DD10177\n         DROP  R15                                             #DD10177\n         LA    R1,CVARPARM         A(IKJCT441 Parameter List)  #DD10177\n         BALR  R14,R15             Call IKJCT441               #DD10177\n\n*-------\n*        Count The Number Of STEPLIB Data Sets\n*-------\n         L     R4,PSATOLD          A(TCB)                      #DD10177\n         USING TCB,R4                                          #DD10177\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)              #DD10177\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD10177\n         DROP  R4                                              #DD10177\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD10177\n         BZ    STEPERR2            B. IF NOT                   #DD10177\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD10177\n         BZ    STEPERR2            B. IF CHAIN DOES NOT EXIST  #DD10177\n         USING DSABID,R5                                       #DD10177\n\n         SLR   R6,R6               Initialize STEPLIB Counter  #DD10177\nSTEP3000 DS    0H                                              #DD10177\n         L     R4,DSABSIOT         A(SIOT)                     #DD10177\n         USING INDMSIOT,R4                                     #DD10177\n         ST    R4,WRKSTEP@         Save SIOT Address           #DD10177\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB       #DD10177\n         BE    STEP3100            B. IF FOUND                 #DD10177\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD10177\n         BNZ   STEP3000            B. IF ANOTHER DSAB EXISTS   #DD10177\n         B     STEPERR2            ELSE. UNABLE TO FIND STEPLIB#DD10177\n\nSTEP3100 DS    0H                                              #DD10177\n         AHI   R6,1                Increment DataSet Counter   #DD10177\n\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD10177\n         BZ    STEP3200            B. IF END OF DSAB CHAIN     #DD10177\n         L     R4,DSABSIOT         A(SIOT)                     #DD10177\n         CLC   SCTDDNAM,BLANKS     CHECK IF NEXT IS A CONCATENATION 177\n         BE    STEP3100            B. IF YES                   #DD10177\n         DROP  R4,R5                                           #DD10177\n\n*-------\n*        Allocate Storage For &STEPLIB Variable\n*-------\nSTEP3200 DS    0H                                              #DD10177\n         MHI   R6,47               Calculate Space Required    #DD10177\n         ST    R6,WRKVARL          Save Length Of Buffer       #DD10177\n         GETMAIN RU,LV=(R6),LOC=BELOW                          #DD10177\n         ST    R1,WRKVAR@          Save Buffer Address         #DD10177\n         ST    R1,WRKVARC@                                     #DD10177\n         #BLANK (R1),LEN=(R6)      Blank The Entire Buffer     #DD10177\n\n*-------\n*        Save The STEPLIB DataSet Names\n*-------\n         L     R5,WRKVAR@          A(Beginning Of Buffer)      #DD10177\n\n         L     R4,WRKSTEP@         A(1st STEPLIB SIOT)         #DD10177\n         USING INDMSIOT,R4                                     #DD10177\nSTEP3300 DS    0H                                              #DD10177\n         L     R1,SJFCBPTR         A(JFCB)                     #DD10177\n         USING INFMJFCB,R1                                     #DD10177\n         MVI   WRKINSRT,C''''      Insert Leading Quote        #DD10177\n         MVC   WRKINSRT+1(44),JFCBDSNM                         #DD10177\n         DROP  R1                                              #DD10177\n         MVC   0(45,R5),WRKINSRT   Save Current DataSet Name   #DD10177\n         AHI   R5,44               A(Last Possible Position)   #DD10177\nSTEP3400 DS    0H                                              #DD10177\n         CLI   0(R5),C' '          Check For End Of Dsname     #DD10177\n         BNE   STEP3500            B. If End Found             #DD10177\n         BCT   R5,STEP3400         Back Up & Keep Checking     #DD10177\n\nSTEP3500 DS    0H                                              #DD10177\n         MVI   1(R5),C''''         Insert Trailing Quote       #DD10177\n         AHI   R5,3                Point Past Inserted Dsname  #DD10177\n\nSTEP3600 DS    0H                                              #DD10177\n         ICM   R4,15,SIOTNPTR      A(Next SIOT)                #DD10177\n         BZ    STEP3700            B. If No More SIOTs         #DD10177\n         CLC   SCTDDNAM,BLANKS     Check If Another STEPLIB    #DD10177\n         BE    STEP3300            B. If Yes                   #DD10177\n         DROP  R4                                              #DD10177\n\nSTEP3700 DS    0H                                              #DD10177\n         SL    R5,WRKVAR@          Calculate Total Length      #DD10177\n\n         MVC   CVARD@,WRKVAR@      A(Variable Data)            #DD10177\n         ST    R5,CVARDL           Save Variable Length        #DD10177\n\n         l     R15,FLCCVT          A(CVT)                      #DD10177\n         USING CVTMAP,R15                                      #DD10177\n         L     R15,CVTTVT          A(TVT)                      #DD10177\n         USING TSVT,R15                                        #DD10177\n         L     R15,TSVTVACC        A(IKJCT441)                 #DD10177\n         DROP  R15                                             #DD10177\n         LA    R1,CVARPARM         A(IKJCT441 Parameter List)  #DD10177\n         BALR  R14,R15             Call IKJCT441               #DD10177\n\n*-------\n*        Release Storage Used For &STEPLIB Variable\n*-------\n         L     R5,WRKVAR@                                      #DD10177\n         L     R6,WRKVARL                                      #DD10177\n         FREEMAIN RU,A=(R5),LV=(R6)                            #DD10177\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB REMOVE\" FUNCTION                        *\n*             OR THE \"STEPLIB DESTACK\" FUNCTION                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP3800 DS    0H\n         L     R15,=A(MSG008I7)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNCTION#DD01072\n         BE    STEP3900            B. IF YES                   #DD01072\n         CLI   $TEPFUNC+1,$REMOVE  CHECK FOR \"REMOVE\" FUNCTION\n         BNE   STEP5200            B. IF NOT                   #DD01073\n         L     R15,=A(MSG008I5)                                #DD10177\n         MVC   WRKFUNC,0(R15)                                  #DD10177\nSTEP3900 DS    0H                                              #DD01072\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n\n*-------\n*        CHECK IF THERE IS CURRENTLY A STEPLIB\n*-------\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP6000            B. IF NOT                   #DD08268\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE OLD STEPLIB DDNAME\n*-------\n         NI    WRKFLAG1,255-WRK$1STD\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP6000            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5\n\nSTEP4000 DS    0H\n         L     R4,DSABSIOT         A(SIOT)\n         USING INDMSIOT,R4\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR PREVIOUS STEPLIB DDNAME\n         BE    STEP4100            B. IF FOUND\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BNZ   STEP4000            B. IF ANOTHER DSAB EXISTS\n         B     STEP5200            ELSE. CAN'T FIND STEPLIB    #DD01073\n\n*-------\n*        SCAN THE USER SPECIFIED LIST FOR A MATCHING STEPLIB DSNAME\n*-------\nSTEP4100 DS    0H\n         L     R1,SJFCBPTR         A(JFCB)\n         USING INFMJFCB,R1\n         MVC   WRKDSN1,JFCBDSNM    SAVE THE CURRENT DATASET NAME\n         DROP  R1\n\n         LA    R3,$TEPLIST         A(1ST USER SPECIFIED DSNAME)\nSTEP4200 DS    0H\n         L     R2,0(,R3)           A(SPECIFIED DSNAME)\n         LH    R1,4(,R3)           L(SPECIFIED DSNAME)\n         MVC   WRKDSN2,BLANKS      CLEAR DSNAME AREA           #DD99244\n         #EXEC -R1,MVC,WRKDSN2(*-*),0(R2)                      #DD99244\nSTEP4300 DS    0H                                              #DD01072\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD99244\n         LA    R0,WRKDSN2                                      #DD99244\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD99244\n         LA    R0,WRKAREA                                      #DD99244\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD99244\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD99244\n         CLC   WRKDSN1,WRKDSN2     COMPARE DSNAMES             #DD99244\n         BNE   STEP4400            B. IF MATCH NOT FOUND       #DD01250\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNCTION#DD01250\n         BNE   STEP4800            B. IF NOT                   #DD01250\n         MVI   0(R2),X'FF'         DESTROY DSNAME SO THAT ONLY #DD01250\n*                                  1ST OCCURANCE IS REMOVED.   #DD01250\n         B     STEP4800                                        #DD01250\nSTEP4400 DS    0H                                              #DD01250\n         CLI   24(R3),X'FF'        CHECK FOR END OF LIST\n         BE    STEP4500            B. IF YES\n         L     R3,24(,R3)          A(NEXT DSNAME PDE)\n         B     STEP4200            SCAN TILL END OF LIST\n\n*-------\n*        ALLOCATE THE DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP4500 DS    0H\n         LA    R0,WRKDSN1\n         ST    R0,WRKDSN@          A(CURRENT STEPLIB DSNAME)\n         LA    R0,L'WRKDSN1\n         STH   R0,WRKDSN@+4        L(CURRENT STEPLIB DSNAME)\n\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BO    STEP4600            B. IF YES\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DATASET WAS ALLOCATED\n         LA    R0,WRKDDNEW\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)\n         LA    R0,L'WRKDDNEW\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                              *\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BZ    STEP4800            B. IF SUCCESSFUL\n         B     STEP4700            ELSE. ISSUE ALLOCATION ERROR MSG\n\n*-------\n*        CONCATENATE THE DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP4600 DS    0H\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                              *\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   STEP4700            B. IF ALLOCATION FAILED\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDRET\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    STEP4800            B. IF CONCATENATION SUCCEEDED\n\n*-------\n*        PROCESS ALLOCATION/CONCATENATION ERRORS\n*-------\nSTEP4700 DS    0H\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP6000                                        #DD08268\n\n*-------\n*        CHECK IF NEXT DSAB IS A CONCATENATION OF THE STEPLIB\n*-------\nSTEP4800 DS    0H\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BZ    STEP4900            B. IF END OF DSAB CHAIN     #DD99244\n         L     R4,DSABSIOT         A(SIOT)\n         CLC   SCTDDNAM,BLANKS     CHECK IF NEXT IS A CONCATENATION\n         BE    STEP4100            B. IF YES\n         DROP  R4,R5\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP4900 DS    0H                                              #DD99244\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP5000            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\nSTEP5000 DS    0H                                              #DD99244\n         TM    WRKFLAG1,WRK$1STD   CHECK IF ALL DATASETS REMOVED\n         BZ    STEP5100            B. IF YES\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG004I)      'STEPLIB SHRUNK'            #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP5200                                        #DD01073\n\n*-------\n*        INDICATE THAT ALL DATASETS WERE REMOVED FROM THE STEPLIB\n*-------\nSTEP5100 DS    0H\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG003I)      'STEPLIB DEACTIVATED'       #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP6000                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"APFCHK\" KEYWORD                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP5200 DS    0H                                              #DD01073\n         CLI   $TEPAPF+1,$APFCHK   CHECK FOR \"APFCHK\" KEYWORD  #DD01073\n         BNE   STEP6000            B. IF NOT                   #DD08268\n\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD01073\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD01073\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01073\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD01073\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)       #DD01073\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01073\n\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD01073\n         BZ    STEP6000            B. IF NOT                   #DD08268\n         L     R4,PSATOLD          A(TCB)                      #DD01073\n         USING TCB,R4                                          #DD01073\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)              #DD01073\n         BZ    STEP6000            B. IF ONE DOES NOT EXIST    #DD08268\n         DROP  R4                                              #DD01073\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01073\n         BZ    STEP6000            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5                                       #DD01073\n\nSTEP5300 DS    0H                                              #DD01073\n         L     R4,DSABSIOT         A(SIOT)                     #DD01073\n         USING INDMSIOT,R4                                     #DD01073\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB DDNAME#DD01073\n         BE    STEP5400            B. IF FOUND                 #DD01073\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD01073\n         BNZ   STEP5300            B. IF ANOTHER DSAB EXISTS   #DD01073\n         B     STEP6000            ELSE. CAN'T FIND STEPLIB    #DD08268\nSTEP5400 DS    0H                                              #DD01073\n         L     R1,SJFCBPTR         A(JFCB)                     #DD01073\n         USING INFMJFCB,R1                                     #DD01073\n         MVC   WRKDSN2,JFCBDSNM                                #DD01073\n         DROP  R1                                              #DD01073\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD01073\n         LA    R0,WRKDSN2                                      #DD01073\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD01073\n         LA    R0,WRKAREA                                      #DD01073\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD01073\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD01073\n         MVC   WRKVOL,WRKAREA+6    SAVE VOLUME SERIAL          #DD01073\n\n         CSVAPF REQUEST=QUERY,     CHECK IF IN APF LIST        #DD01073*\n               DSNAME=WRKDSN2,                                 #DD01073*\n               VOLTYPE=ANY,VOLUME=WRKVOL,                      #DD01073*\n               RETCODE=WRKCSVRC,RSNCODE=WRKCSVRS,              #DD01073*\n               MF=(E,WRKCSVPL)                                 #DD01073\n         ICM   R1,15,WRKCSVRC      CHECK IF \"IN APFLIST\"       #DD01073\n         BZ    STEP5800            B. IF YES                   #DD01073\n         CHI   R1,4                CHECK FOR RETURN CODE 4     #DD08112\n         BNE   STEP5500            B. IF NOT                   #DD08112\n         CLC   =X'0401',WRKCSVRS+2 CHECK FOR SMS APF LIBRARY   #DD08112\n         BE    STEP5800            B. IF YES                   #DD08112\n\nSTEP5500 DS    0H                                              #DD08112\n         #SETRC 12                 INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP5800            B. IF YES                   #DD01073\n         MVC   WRKINSRT(4),=AL2(48,9)    LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(L'WRKDSN2),WRKDSN2                   #DD01073\n         LA    R1,WRKINSRT+4+L'WRKDSN2-1                       #DD01073\nSTEP5600 DS    0H                                              #DD01073\n         TM    0(R1),X'BF'         CHECK FOR END OF DSNAME     #DD01073\n         BNZ   STEP5700            B. IF FOUND                 #DD01073\n         BCT   R1,STEP5600         KEEP LOOPING BACKWARDS      #DD01073\nSTEP5700 DS    0H                                              #DD01073\n         LA    R1,1(,R1)           A(END OF INSERT BUFFER)     #DD01073\n         LA    R2,WRKINSRT         A(START OF INSERT BUFFER)   #DD01073\n         SR    R1,R2               CALCULATE INSERT LENGTH     #DD01073\n         STCM  R1,3,WRKINSRT       SET INSERT LENGTH           #DD01073\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD01073\n         L     R1,=A(MSG009I)      'DSNAME IS NOT IN APF LIST' #DD10106\n         LA    R2,WRKINSRT                                     #DD01073\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01073\n\nSTEP5800 DS    0H                                              #DD01073\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD01073\n         BZ    STEP6000            B. IF END OF DSAB CHAIN     #DD08268\n         L     R4,DSABSIOT         A(SIOT)                     #DD01073\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION     #DD01073\n         BE    STEP5400            B. IF YES                   #DD01073\n         B     STEP6000            ELSE. ALL DONE CHECKING     #DD08268\n         DROP  R5                                              #DD09103\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"VERSION\" KEYWORD                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP5900 DS    0H                                              #DD08098\n         L     R15,=A(MSG011I)                                 #DD10106\n         MVC   WRKMSG(MSG011IL),0(R15)                         #DD10106\n         MVC   MSG011I1+WRKMSG,STEPLIB+32                      #DD08098\n         MVC   MSG011I2+WRKMSG,STEPLIB+36                      #DD08098\n         MVC   WRKINSRT(4),=AL2(14,46)   LENGTH+4/OFFSET       #DD08098\n         MVC   WRKINSRT+4(10),=C'CCYY/MM/DD'                   #DD08098\n         MVC   WRKINSRT+4(4),STEPLIB+21                        #DD08098\n         MVC   WRKINSRT+9(2),STEPLIB+25                        #DD08098\n         MVC   WRKINSRT+12(2),STEPLIB+27                       #DD08098\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD08098\n         LA    R1,WRKMSG           '$TEP011I VERSION:'         #DD08098\n         LA    R2,WRKINSRT         ASSEMBLY DATE & TIME        #DD08098\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08098\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PRODUCE A TCB/RB STRUCTURE LIST FOR DEBUGGING                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP6000 DS    0H                                              #DD08268\n         CLI   $TEPMSGS+1,$DEBUG   CHECK FOR \"DEBUG\" OPTION    #DD08268\n         BNE   STEPEXIT            B. IF NOT                   #DD08268\n\n         L     R4,PSATOLD          A(CURRENT TCB)              #DD08268\n         USING TCB,R4                                          #DD08268\n         MVC   WRKJSTCB,TCBJSTCB   SAVE JOBSTEP TCB ADDRESS    #DD08268\n\n         L     R4,PSAAOLD          A(ASCB)                     #DD08268\n         USING ASCB,R4                                         #DD08268\n         L     R4,ASCBASXB         A(ASXB)                     #DD08268\n         USING ASXB,R4                                         #DD08268\n         L     R4,ASXBFTCB         A(REGION CONTROL TASK TCB)  #DD08268\n         USING TCB,R4                                          #DD08268\n\n         L     R15,=A(TRC001I)                                 #DD10050\n         MVC   WRKMSG(TRC001IL),0(R15)                         #DD10050\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I TCB DATA'         #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\nSTEP6100 DS    0H                                              #DD08268\n         L     R15,=A(TRC001B)                                 #DD10050\n         MVC   WRKMSG(TRC001BL),0(R15)                         #DD10050\n         CL    R4,WRKJSTCB         IS THIS THE JOBSTEP TCB ?   #DD08268\n         BNE   STEP6200            B. IF NOT                   #DD08268\n         MVC   TRC001B1+WRKMSG,=C'(JSTCB)'                     #DD08268\n\nSTEP6200 DS    0H                                              #DD08268\n         ST    R4,WRKHEXIN         INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC001B2+WRKMSG,WRKHEXOU                        #DD08268\n         CL    R4,PSATOLD          CHECK FOR CURRENT TCB       #DD08268\n         BNE   STEP6300            B. IF NOT                   #DD08268\n         MVI   TRC001B3+WRKMSG,C'*'                            #DD08268\n\nSTEP6300 DS    0H                                              #DD08268\n         MVC   TRC001B4+WRKMSG,=C'UNKNOWN'                     #DD08268\n         ICM   R6,15,TCBRBP        A(TOP RB)                   #DD08268\n         BZ    STEP6700            B. IF NONE                  #DD08268\n         USING RBSECT,R6                                       #DD08268\nSTEP6400 DS    0H                                              #DD08268\n         CLI   RBSTAB1,RBFTPRB     CHECK FOR PRB               #DD08268\n         BE    STEP6500            B. IF YES                   #DD08268\n         ICM   R6,7,RBLINKB        A(NEXT RB)                  #DD08268\n         BNZ   STEP6400            B. IF ANOTHER EXISTS        #DD08268\n         B     STEP6700            ELSE. SKIP IT               #DD08268\n\nSTEP6500 DS    0H                                              #DD08268\n         SLR   R1,R1                                           #JR14048\n         ICM   R1,7,RBCDE1         A(CDE/LPDE)                 #JR14048\n         BZ    STEP6600            B. IF NONE                  #DD08268\n         USING CDENTRY,R1                                      #DD08268\n         MVC   TRC001B4+WRKMSG,CDNAME                          #DD08268\n         DROP  R1                                              #DD08268\n\nSTEP6600 DS    0H                                              #DD08268\n         MVC   TRC001B5+WRKMSG,BLANKS                          #DD08268\n         ICM   R1,15,TCBJLB        A(JOBLIB/STEPLIB)           #DD08268\n         BZ    STEP6700            B. IF NONE                  #DD08268\n         MVC   TRC001B5+WRKMSG,=C'-LNKLST-'                    #DD08268\n         L     R2,FLCCVT           A(CVT)                      #DD08268\n         USING CVTMAP,R2                                       #DD08268\n         CL    R1,CVTLINK          CHECK FOR LINKLIST          #DD08268\n         BE    STEP6700            B. IF NOT                   #DD08268\n         DROP  R2                                              #DD08268\n         LH    R1,DCBTIOT-IHADCB(,R1)                          #DD08268\n         A     R1,TCBTIO           A(TIOT ENTRY)               #DD08268\n         MVC   TRC001B5+WRKMSG,4(R1)                           #DD08268\n\nSTEP6700 DS    0H                                              #DD08268\n         MVC   WRKHEXIN,TCBJLB     INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC001B6+WRKMSG,WRKHEXOU                        #DD08268\n\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I TCB DATA'         #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\n         LR    R1,R4               A(CURRENT TCB)              #DD08268\n         ICM   R4,15,TCBLTC        A(DAUGHTER TCB)             #DD08268\n         BNZ   STEP6100                                        #DD08268\n         ICM   R4,15,TCBNTC-TCB(R1)                            #DD08268\n         BNZ   STEP6100            A(SISTER TCB)               #DD08268\n         DROP  R4,R6                                           #DD08268\n\n         B     STEPEXIT                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ANY ERRORS                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEPERR1 DS    0H\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG005I)      'MISSING STEPLIB DSNAMES'   #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP6000                                        #DD08268\n\nSTEPERR2 DS    0H                                              #DD01072\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD01072\n         L     R1,=A(MSG008I)      'STEPLIB NOT ALLOCATED'     #DD10106\n         LA    R2,WRKFUNC                                      #DD01072\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01072\n         B     STEP6000                                        #DD08268\n\nSTEPERR3 DS    0H                                              #DD08099\n         #SETRC 20                 INDICATE AN ERROR OCCURRED  #DD08099\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD08099\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08100\n         L     R1,=A(MSG012I)      'STEPLIB OPEN FAILED'       #DD10106\n         SLR   R2,R2                                           #DD08099\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08099\n         B     STEP6000                                        #DD08268\n\nSTEPERR4 DS    0H                                              #DD08268\n         #SETRC 28                 INDICATE AN ERROR OCCURRED  #DD08268\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD08268\n         BE    STEP6000            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         L     R1,=A(MSG014I)      'STEPLIB NOT AUTHORIZED'    #DD10106\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n         B     STEP6000                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEPEXIT DS    0H\n         CLI   WRKTYPE,C'J'        CHECK FOR BATCH JOB         #DD09027\n         BNE   STEPEX99            B. IF NOT (DON'T PAUSE)     #DD09027\n\n         CLI   WRKANS@,X'FF'       Check If PDL returned       #DD10106\n         BE    STEPEX99            B. If Not                   #DD10106\n         ICM   R8,15,WRKANS@       Load PDL Address            #DD10106\n         BNP   STEPEX99            B. If No PDL                #DD10106\n         USING IKJPARMD,R8                                     #DD10106\n\n         L     R1,PAUSEPDE         A(PDE)                      #DD09027\n         ICM   R1,15,0(R1)         LOAD TIME TO WAIT           #DD09027\n         BZ    STEPEX99            B. IF NO WAITING            #DD09027\n         M     R0,=F'100'          CONVERT TO HUNDREDTHS       #DD09027\n         ST    R1,WRKTIME          SAVE HUNDREDTHS OF SECONDS  #DD09027\n         STIMER WAIT,BINTVL=WRKTIME WAIT FOR ANY HUNG IRB RTN  #DD09027\n\nSTEPEX99 DS    0H                                              #DD09027\n         IKJRLSA WRKANS@           RELEASE ANSWER BUFFER STORAGE\n         #STOP ,                   TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CREATE IRB TO PERFORM FUNCTION UNDER MAIN TASK'S TCB.        *\n*                                                                     *\n*        OPEN & CLOSE ARE DONE IN AN IRB SO THAT THE DCB BUFFERS      *\n*        ARE ASSOCIATED WITH THE TCB.                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nSENDIRB  DS    0H\n         STM   R0,R15,WRKSEND      SAVE ALL REGISTERS          #DD09101\n         ST    R1,WRKREGS          PASS ROUTINE PARAMETER LIST\n         XC    WRKREGS+4(4),WRKREGS+4                          #DD09103\n         ST    R13,WRKREGS+8       PASS WORK AREA ADDRESS      #DD08268\n\n         MODESET MODE=SUP,KEY=ZERO\n\n         L     R6,WRKLCT@          A(LCT)                      #DD09101\n         L     R4,LCTTCBAD-LCT(R6) A(TCB)                      #DD09101\n         ST    R4,WRKTCB@                                      #DD09103\n\n         LA    R0,WRKREGS                                      #DD09103\n         ST    R0,WRKPARM@         A(PARAMETERS)               #DD09103\n\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE        #DD09103\n\n         SCHEDIRB EPPTR=WRKSEND,   ADDRESS OF IRB ENTRY POINT  #DD09103X\n               TCBPTR=WRKTCB@,     ADDRESS OF TCB,             #DD09103X\n               MODE=SUPR,          RUN IN SUPERVISOR STATE     #DD09103X\n               KEY=SUPR,           RUN IN KEY ZERO             #DD09103X\n               PARAMPTR=WRKPARM@,  PASS ADDRESS OF PARAMETERS  #DD09103X\n               MF=(E,WRKSCH,COMPLETE)                          #DD09103\n\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE                   #DD09103\n\n         MODESET MODE=PROB,KEY=NZERO\n\n         WAIT  ECB=WRKREGS+4       WAIT FOR THE EXIT TO END\n\n         CLI   $TEPMSGS+1,$DEBUG   CHECK FOR \"DEBUG\" OPTION    #DD08268\n         BNE   SEND0400            B. IF NOT                   #DD08268\n         ICM   R0,15,WRKDCB@       CHECK IF DCB ADDRESS EXISTS #DD08268\n         BZ    SEND0400            B. IF NOT                   #DD08268\n\n         L     R15,=A(TRC002I)                                 #DD10050\n         MVC   WRKMSG(TRC002IL),0(R15)                         #DD10050\n         MVC   TRC002I1+WRKMSG,WRKIRB                          #DD08268\n         MVC   WRKHEXIN,WRKDCB@    INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC002I2+WRKMSG,WRKHEXOU                        #DD08268\n         MVC   TRC002I3+WRKMSG,=C'Obtained'                    #DD08268\n         CLI   WRKIRB,C'O'         CHECK FOR \"OPEN\"            #DD08268\n         BE    SEND0300            B. IF YES                   #DD08268\n         MVC   TRC002I3+WRKMSG,=C'Released'                    #DD08268\nSEND0300 DS    0H                                              #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I DCB ADDRESS:\"     #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\nSEND0400 DS    0H                                              #DD08268\n         LH    R15,WRKREGS+6       RETURN EXIT RETURN CODE\n         LM    R0,R14,WRKSEND      RESTORE RETURN ADDRESS      #DD09101\n         BR    R14                 RETURN TO CALLER\n         DROP  R8\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ASYNCRONOUS EXIT TO CLOSE THE STEPLIB DD STATEMENT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\n         DROP  ,\nCLOSEIRB DS    0H\n         LR    R12,R15             A(EXIT ENTRY POINT)\n         USING CLOSEIRB,R12\n         USING PSA,0\n\n         LR    R9,R1               A(INPUT PARAMETER)\n         L     R7,0(,R9)           A(STEPLIB DDNAME SAVE AREA)\n         L     R13,8(,R9)          RE-ESTABLIST WORK AREA      #DD08268\n         USING STEPWRK,R13                                     #DD08268\n         MVC   WRKIRB,=C'CLOSE'    TRACE CURRENT REQUEST       #DD08268\n\n         MVC   0(8,R7),BLANKS      CLEAR RETURN DDNAME AREA    #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         L     R5,TCBTCT           A(TCT)\n         USING SMFTCT,R5\n         L     R6,TCTLCTAD         A(LCT)\n         USING LCT,R6\n         L     R2,LCTJOBLB         A(JOBLIB DCB)\n         SLR   R0,R0\n         ST    R0,LCTJOBLB         ZERO LCT'S STEPLIB POINTER\n\nCLOSE100 DS    0H\n         ICM   R4,15,TCBTCB        A(NEXT LOWER TCB)\n         BZ    CLOSE200            B. IF AT END\n         C     R2,TCBJLB           CHECK FOR MATCHING DCB POINTER\n         BNE   CLOSE100            B. IF NOT LEAVE ALONE\n         ST    R0,TCBJLB           ZERO CURRENT TCB'S STEPLIB POINTER\n         B     CLOSE100            CONTINUE TILL END OF TCBS\n\nCLOSE200 DS    0H\n         LTR   R2,R2               CHECK IF A STEPLIB EXISTED  #DD99245\n         BZ    CLOSE400            B. IF NOT                   #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         L     R3,TCBTIO           A(TIOT)                     #DD10106\n         L     R1,TCBLTC           A(LAST TASK TCB)\n         MVC   TCBTIO,TCBTIO-TCB(R1)\n         MVI   0(R9),128           SET CLOSE OPTION\n         CLOSE ((R2)),MF=(E,(R9))\n         ST    R3,TCBTIO           RESTORE A(TIOT)             #DD10106\n         MVC   0(8,R7),DCBDDNAM-IHADCB(R2)\n\n         CLI   WRKTYPE,C'J'        CHECK FOR BATCH JOB         #DD08268\n         BE    CLOSE300            B. IF YES (FREE STEPLIB)    #DD08268\n         CLI   0(R7),C'$'          CHECK FOR \"$TEP...\"         #DD09050\n         BNE   CLOSE400            B. IF NOT                   #DD99245\n\nCLOSE300 DS    0H                                              #DD08268\n         ST    R2,WRKDCB@          SAVE FOR DEBUG MESSAGE      #DD08268\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),         #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n\nCLOSE400 DS    0H                                              #DD99245\n         SLR   R0,R0               SET SUCCESSFUL RETURN CODE\n         POST  4(,R9),(0)          POST WITH RETURN CODE\n         SVC   3                   RETURN TO CALLER\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN ABEND RECOVERY ROUTINE                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD04108\n         DROP  ,                                               #DD04108\n\nESTAERTN DS    0H                                              #DD04108\n         USING *,R15                                           #DD04108\n         CH    R0,=H'12'           RTM PROVIDE AN SDWA?        #DD04108\n         BNE   ESTAE100            B. IF YES                   #DD04108\n         SR    R15,R15             ELSE.                       #DD04108\n         BR    R14                 PERCOLATE                   #DD04108\n\nESTAE100 DS    0H                                              #DD04108\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS     #DD04108\n\n         SETRP RC=4,                                           #DD04108*\n               RETADDR=OPEN0100,   SET RETRY ADDRESS           #DD04108*\n               FRESDWA=YES,        FREE THE SDWA WHEN DONE     #DD04108*\n               REGS=(14,12),       RESTORE CALLER'S REGISTERS  #DD04108*\n               RETREGS=YES,                                    #DD04108*\n               DUMP=NO             DON'T CUT A DUMP            #DD04108\n\n         LTORG ,                   LITERAL POOL                #DD04108\n\n         POP   USING                                           #DD04108\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ASYNCRONOUS EXIT TO OPEN  THE STEPLIB DD STATEMENT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\n         DROP  ,\nOPENIRB  DS    0H\n         LR    R12,R15             A(EXIT ENTRY POINT)\n         USING OPENIRB,R12\n         USING PSA,0\n\n         LR    R9,R1               A(INPUT PARAMETER)\n         L     R7,0(,R9)           A(STEPLIB DDNAME)\n         L     R13,8(,R9)          RE-ESTABLIST WORK AREA      #DD08268\n         USING STEPWRK,R13                                     #DD08268\n         MVC   WRKIRB,=C'OPEN '    TRACE CURRENT REQUEST       #DD08268\n\n         LA    R0,8                SET FAILURE CODE            #DD99245\n         TM    0(R7),X'BF'         CHECK FOR VALID DDNAME      #DD99245\n         BZ    OPENEXIT            B. IF NOT                   #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         L     R5,TCBTCT           A(TCT)\n         USING SMFTCT,R5\n         L     R6,TCTLCTAD         A(LCT)\n         USING LCT,R6\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE OBTAIN,LOC=BELOW,SP=253,LENGTH=(R3),          #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n         ST    R1,WRKDCB@          SAVE FOR DEBUG MESSAGE      #DD08268\n         LR    R2,R1               A(DCB)\n         MVC   0(MODLDCBL,R2),MODLDCB\n         MVC   DCBDDNAM-IHADCB(,R2),0(R7)\n\n*        Add DCBE As Added by z/OS R1.12 and Higher            #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   OPEN0050            B. If Not                   #DD10050\n         LA    R1,MODLDCBL(,R2)    A(DCBE)                     #DD10050\n         MVC   0(MODDCBEL,R1),MODDCBE                          #DD10050\n         OI    DCBBFALN-IHADCB(R2),DCBH1+DCBH0  DCBE Exists    #DD10050\n         ST    R1,DCBDCBE-IHADCB(,R2) Save DCBE Address in DCB #DD10050\n\nOPEN0050 DS    0H                                              #DD10050\n         L     R3,TCBTIO           A(TIOT)                     #DD10106\n         L     R1,TCBLTC           A(LAST TASK TCB)\n         MVC   TCBTIO,TCBTIO-TCB(R1)\n\n         ESTAE ESTAERTN            ESTABLISH ABEND RECOVERY    #DD04108\n\n         MVI   0(R9),128           SET OPEN OPTION\n         OPEN  ((R2)),MF=(E,(R9))\nOPEN0100 DS    0H                                              #DD04108\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD04108\n\n         ST    R3,TCBTIO           RESTORE A(TIOT)             #DD10106\n\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN\n         BO    OPEN0200            B. IF OPEN WAS SUCCESSFUL\n         XC    WRKDCB@,WRKDCB@     RESET FOR DEBUG MESSAGE     #DD08268\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),         #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n         LA    R0,12               SET FAILURE CODE\n         B     OPENEXIT\n\nOPEN0200 DS    0H\n         ST    R2,LCTJOBLB-LCT(,R6) SAVE STEPLIB DCB IN LCT\n\nOPEN0300 DS    0H\n         ICM   R4,15,TCBTCB        A(NEXT LOWER TCB)\n         BZ    OPEN0400            B. IF AT END\n\n         CLC   TCBJLB,=F'0'        CHECK FOR IN-USE JOBLIB     #DD09199\n         BNE   OPEN0300            B. IF YES (LEAVE ALONE)     #DD09199\n\n         ST    R2,TCBJLB           SET NEW STEPLIB POINTER\n         B     OPEN0300            CONTINUE TILL END OF TCBS\n\nOPEN0400 DS    0H\n         SLR   R0,R0               SET SUCCESSFUL RETURN CODE\n\nOPENEXIT DS    0H\n         POST  4(,R9),(0)          POST WITH RETURN CODE\n         SVC   3                   RETURN TO CALLER\n         POP   USING\n\n         #EXEC ,                   EXECUTED STATEMENTS         #DD01068\n         LTORG ,                   LITERAL POOL                #DD01068\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONVERT FULLWORD TO 8 BYTES PRINTABLE HEX                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD08268\nFULLCHAR DS    0H                                              #DD08268\n         STM   R0,R15,WRKREGS3     SAVE ALL REGISTERS          #DD08268\n         UNPK  WRKHEXOU(9),WRKHEXIN(5)                         #DD08268\n         TR    WRKHEXOU,HEXTABLE-C'0'                          #DD08268\n         MVI   WRKHEXOU+8,C' '                                 #DD08268\n         LM    R0,R15,WRKREGS3     RESTORE ALL REGISTERS       #DD08268\n         BR    R14                 RETURN TO CALLER            #DD08268\n         POP   USING                                           #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISSUE MESSAGE VIA PUTLINE                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nISSUEMSG DS    0H\n         STM   R0,R14,WRKREGS1     SAVE ALL REGISTERS\n         STM   R0,R2,WRKOLD        #SEGMENTS, SEGMENT1 SEGMENT2\n         L     R4,WRKUPT@          A(UPT)\n         L     R5,WRKECT@          A(ECT)\n         XC    WRKECB,WRKECB\n         PUTLINE PARM=WRKPUTL,UPT=(R4),ECT=(R5),ECB=WRKECB,            *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)\n         LM    R0,R15,WRKREGS1     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN ABEND RECOVERY ROUTINE (FOR VALIDATION ROUTINE)         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD08099\n         DROP  ,                                               #DD08099\n\nDDALEST  DS    0H                                              #DD08099\n         USING *,R15                                           #DD08099\n         CH    R0,=H'12'           RTM PROVIDE AN SDWA?        #DD08099\n         BNE   DDALEST1            B. IF YES                   #DD08099\n         SR    R15,R15             ELSE.                       #DD08099\n         BR    R14                 PERCOLATE                   #DD08099\n\nDDALEST1 DS    0H                                              #DD08099\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS     #DD08099\n\n         SETRP RC=4,                                           #DD08099*\n               RETADDR=DDALOP10,   SET RETRY ADDRESS           #DD08099*\n               FRESDWA=YES,        FREE THE SDWA WHEN DONE     #DD08099*\n               REGS=(14,12),       RESTORE CALLER'S REGISTERS  #DD08099*\n               RETREGS=YES,                                    #DD08099*\n               DUMP=NO             DON'T CUT A DUMP            #DD08099\n\n         LTORG ,                   LITERAL POOL                #DD08099\n\n         POP   USING                                           #DD08099\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DATASET NAME VALIDITY CHECKING ROUTINE (CONCATENATION)       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  ,\nDDALLOC  DS    0H\n         USING DDALLOC,R15\n         STM   R14,R12,12(R13)     SAVE ALL REGISTERS\n         LR    R12,R15             SET SUBROUTINE BASE REGISTER\n         DROP  R15\n         USING DDALLOC,R12\n         L     R5,0(,R1)           A(DSNAME PDE)\n         LR    R10,R13             A(ORIGINAL SAVEAREA)\n         L     R9,4(,R1)           A(USER WORKAREA)\n         USING STEPWRK,R9\n         LA    R13,WRKREGS         A(SUBROUTINE SAVE AREA)\n\n*-------                                                       #DD01068\n*        IF THE \"ADD\" FUNCTION IS REQUESTED, DONT CONTINUALLY  #DD01068\n*        ALLOCATE DSNAMES THAT ARE ALREADY ALLOCATED TO THE    #DD01068\n*        STEPLIB.  INDICATE VIA A RETURN CODE OF 4 THAT        #DD01068\n*        \"AT LEAST 1\" OF THE DATASETS TO BE ADDED WERE NOT.    #DD01068\n*-------                                                       #DD01068\n         L     R8,WRKANS@          LOAD PDL ADDRESS            #DD01068\n         USING IKJPARMD,R8                                     #DD01068\n         L     R2,0(,R5)           A(SPECIFIED DSNAME)         #DD01068\n         LH    R1,4(,R5)           L(SPECIFIED DSNAME)         #DD01068\n         MVC   WRKDSN2,BLANKS      CLEAR DSNAME AREA           #DD01068\n         #EXEC -R1,MVC,WRKDSN2(*-*),0(R2)                      #DD01068\n         CLI   $TEPFUNC+1,$ADD     CHECK FOR \"ADD\" FUNCTION    #DD08101\n         BNE   DDAL0400            B. IF NOT                   #DD08101\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD08101\n         BNE   DDAL0400            B. IF NOT                   #DD08101\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD01068\n         LA    R0,WRKDSN2                                      #DD01068\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD01068\n         LA    R0,WRKAREA                                      #DD01068\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD01068\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD01068\n         ICM   R6,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    DDAL0400            B. IF CHAIN DOES NOT EXIST  #DD01068\n         USING DSABID,R6                                       #DD01068\nDDAL0100 DS    0H                                              #DD01068\n         L     R4,DSABSIOT         A(SIOT)                     #DD01068\n         USING INDMSIOT,R4                                     #DD01068\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR START OF STEPLIB  #DD01068\n         BE    DDAL0200            B. IF FOUND                 #DD01068\n         ICM   R6,15,DSABFCHN      A(NEXT DSAB)                #DD01068\n         BNZ   DDAL0100            B. IF ANOTHER DSAB EXISTS   #DD01068\n         B     DDAL0400            ELSE. NO $TEP#### DDNAME    #DD01068\nDDAL0200 DS    0H                                              #DD01068\n         L     R1,SJFCBPTR         A(JFCB)                     #DD01068\n         USING INFMJFCB,R1                                     #DD01068\n         CLC   JFCBDSNM,WRKDSN2    CHECK FOR MATCHING DSNAME   #DD01068\n         BE    DDAL0300            B. IF ALREADY ALLOCATED     #DD01068\n         DROP  R1                                              #DD01068\n         ICM   R6,15,DSABFCHN      A(NEXT DSAB)                #DD01068\n         BZ    DDAL0400            B. IF END OF CHAIN          #DD01068\n         L     R4,DSABSIOT         A(SIOT)                     #DD01068\n         CLC   SCTDDNAM,BLANKS     CHECK FOR CONCATENATION     #DD01068\n         BNE   DDAL0400            B. IF END OF $TEP###'S      #DD01068\n         B     DDAL0200            ELSE. CONTINUE SEARCHING    #DD01068\n         DROP  R6                                              #DD09103\nDDAL0300 DS    0H                                              #DD01068\n         #SETRC 4                  SET MAINLINE RETURN CODE    #DD01068\n         LA    R15,0               SET VALIDCK RETURN CODE     #DD01068\n         B     DDALEXIT            CONTINUE PARSING            #DD01068\n\nDDAL0400 DS    0H                                              #DD01068\n         LA    R15,0               SET VALIDCK RETURN CODE     #DD01072\n         CLI   $TEPFUNC+1,$REMOVE  CHECK FOR \"REMOVE\" FUNC.    #DD01072\n         BE    DDALEXIT            B. IF YES (DON'T ALLOCATE)  #DD01072\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNC.   #DD01072\n         BE    DDALEXIT            B. IF YES (DON'T ALLOCATE)  #DD01072\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET WAS ALLOCATED\n         BO    DDAL0600            B. IF YES\n         LA    R0,WRKDDNEW\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)\n         LA    R0,L'WRKDDNEW\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)\nDDAL0500 DS    0H\n         ALLOC PERM,DSN=((R5)),DISP=SHR,                               *\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT\n         MVC   WRKDDN,WRKDDNEW     SAVE CURRENT DDNAME         #DD08099\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DATASET WAS ALLOCATED\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   DDAL0550            B. IF ALLOCATION FAILED     #DD08099\n         BAL   R14,DDALOPEN        CATCH OPEN FAILURES         #DD08099\n         B     DDALEXIT                                        #DD08099\n\nDDAL0550 DS    0H                                              #DD08099\n         USING S99RB,R14\n         CLC   S99ERROR,=X'0410'   CHECK FOR \"DDNAME IN USE\" ERROR\n         BNE   DDAL0700            B. IF NOT\n         PACK  WRKDBL1,WRKDDNEW+4(4)\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB NUMBER\n         OI    WRKDBL1+7,X'0F'\n         UNPK  WRKDDNEW+4(4),WRKDBL1\n         DROP  R14\n         B     DDAL0500            RETRY ALLOCATION\n\nDDAL0600 DS    0H\n         ALLOC PERM,DSN=((R5)),DISP=SHR,                               *\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT\n         MVC   WRKDDN,WRKDDRET     SAVE CURRENT DDNAME         #DD08099\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   DDAL0700            B. IF ALLOCATION FAILED\n         BAL   R14,DDALOPEN        CATCH OPEN FAILURES         #DD08099\n         TM    WRKFLAG1,WRK$ABND   CHECK IF AN ABEND OCCURED   #DD08101\n         BO    DDALEXIT            B. IF YES                   #DD08101\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDRET\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    DDALEXIT            B. IF CONCATENATION SUCCEEDED\n\nDDAL0700 DS    0H\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         LA    R15,12              SET ERROR CODE\n\nDDALEXIT DS    0H\n         LR    R13,R10             A(ORIGINAL SAVE AREA)\n         ST    R15,16(,R13)        OVERLAY R15 IN SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO IKJPARS\n\n*-------\n*        CATCH OPEN ABENDS (IE. S913)\n*-------\nDDALOPEN DS    0H                                              #DD08099\n         STM   R0,R15,WRKREGS2     SAVE ALL REGISTERS          #DD08099\n\n         MVC   WRKDCB,MODLDCB      FORMAT TEMPORARY DCB        #DD08099\n         MVC   WRKDCBE,MODDCBE     FORMAT TEMPORARY DCBE       #DD12060\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN                   #DD08100\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD12060\n         BNO   DDALOP05            B. If Not                   #DD12060\n         OI    DCBBFALN-IHADCB+WRKDCB,DCBH1+DCBH0 DCBE Exists  #DD12060\n         LA    R1,WRKDCBE          A(DCBE)                     #DD12060\n         ST    R1,DCBDCBE-IHADCB+WRKDCB Save DCBE Address      #DD12060\nDDALOP05 DS    0H                                              #DD12060\n         MVC   WRKOPEN(MODLOPEL),MODLOPEN                      #DD08099\n         MVC   WRKCLOSE(MODLCLOL),MODLCLOS                     #DD08099\n\n         ESTAE DDALEST             ESTABLISH ABEND RECOVERY    #DD08099\n\n         OPEN  WRKDCB,MF=(E,WRKOPEN)                           #DD08099\n         CLOSE WRKDCB,MF=(E,WRKCLOSE)                          #DD08099\n         B     DDALOP20                                        #DD08099\n\nDDALOP10 DS    0H                                              #DD08099\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD08100\n         OI    WRKFLAG1,WRK$ABND   INDICATE \"OPEN\" ABEND       #DD08099\n         #SETRC 24                                             #DD08099\n\n         MVC   WRKINSRT(4),=AL2(48,33)   LENGTH+4/OFFSET       #DD08099\n         MVC   WRKINSRT+4(44),WRKDSN2                          #DD08099\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD08099\n         L     R1,=A(MSG013I)      '$TEP013I OPEN FAILED FOR'  #DD10106\n         LA    R2,WRKINSRT         DSNAME                      #DD08099\n         STM   R0,R2,WRKOLD        COUNT, A(PART1), A(PART2)   #DD08101\n         L     R4,WRKUPT@          A(UPT)                      #DD08101\n         L     R5,WRKECT@          A(ECT)                      #DD08101\n         XC    WRKECB,WRKECB                                   #DD08101\n         PUTLINE PARM=WRKPUTL,UPT=(R4),ECT=(R5),ECB=WRKECB,    #DD08101*\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),              #DD08101*\n               MF=(E,WRKIOPL)                                  #DD08101\n\n         LA    R0,WRKDDN                                       #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDN                                     #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n         CLC   WRKDDN,WRKDDNEW     CHECK IF 1ST DATASET        #DD08101\n         BE    DDALOP30            B. IF YES                   #DD08101\n         LA    R0,WRKDDNEW                                     #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDNEW                                   #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n         B     DDALOP30                                        #DD08100\n\nDDALOP20 DS    0H                                              #DD08099\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD08099\n         TM    WRKFLAG1,WRK$ABND   CHECK IF AN ABEND OCCURED   #DD08101\n         BZ    DDALOP30            B. IF NOT                   #DD08101\n         LA    R0,WRKDDN                                       #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDN                                     #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n\nDDALOP30 DS    0H                                              #DD08100\n         LM    R0,R15,WRKREGS2     RESTORE ALL REGISTERS       #DD08099\n         BR    R14                 RETURN TO CALLER            #DD08099\n\n         LTORG ,                   LITERAL POOL                #DD01068\n         #EXEC ,                   EXECUTED STATEMENTS         #DD01068\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS & DYNAMIC WORKAREA                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nHEXTABLE DC    C'0123456789ABCDEF' HEX CONVERSION TABLE        #DD08268\n\nMODLDCB  DCB   DDNAME=*,DSORG=PO,RECFM=U,MACRF=E\n         DS    F                   DCB EXIT LIST (ALA IEFSD164)#DD08268\nMODLDCBL EQU   *-MODLDCB           DCB LENGTH\n\nMODDCBE  DCBE  EADSCB=OK                                       #DD10050\nMODDCBEL EQU   *-MODDCBE           DCBE LENGTH                 #DD10050\n\nMODLOPEN OPEN  (*-*),MF=L          OPEN PARAMETER LIST         #DD08099\nMODLOPEL EQU   *-MODLOPEN                                      #DD08099\nMODLCLOS CLOSE (*-*),MF=L          OPEN PARAMETER LIST         #DD08099\nMODLCLOL EQU   *-MODLCLOS                                      #DD12060\n\nMODLLOC  CAMLST NAME,*-*,,*-*      CATALOG PARAMETER LIST      #DD99244\nMODLLOCL EQU   *-MODLLOC           CATALOG PARAMETER LIST LEN  #DD99244\n\nBLANKS   DC    80C' '              LOTS OF BLANKS              #DD99244\n\nMSG001I  #MSG  '$TEP001I STEPLIB Expanded'\nMSG002I  #MSG  '$TEP002I STEPLIB Activated'\nMSG003I  #MSG  '$TEP003I STEPLIB Deactivated'\nMSG004I  #MSG  '$TEP004I STEPLIB Shrunk'\nMSG005I  #MSG  '$TEP005I Missing STEPLIB Dataset Name(s)'\nMSG006I  #MSG  '$TEP006I STEPLIB Dataset List - DDName():'     #DD01095\nMSG007I  #MSG  '$TEP007I - '\nMSG008I  #MSG  '$TEP008I STEPLIB Not ed, is not allocated'     #DD01072\nMSG008I1 #MSG  'add',OFFSET=21                                 #DD01072\nMSG008I2 #MSG  'allocat',OFFSET=21                             #DD01072\nMSG008I3 #MSG  'fre',OFFSET=21                                 #DD01072\nMSG008I4 #MSG  'list',OFFSET=21                                #DD01072\nMSG008I5 #MSG  'remov',OFFSET=21                               #DD01072\nMSG008I6 #MSG  'stack',OFFSET=21                               #DD01072\nMSG008I7 #MSG  'destack',OFFSET=21                             #DD01072\nMSG009I  #MSG  '$TEP009I  is not an APF authorized library'    #DD01073\nMSG010I  #MSG  '$TEP010I dataset(s) already found in STEPLIB'  #DD01095\nMSG011I  #MSG  '$TEP011I Version:___ Release:__ Assembly Date:' DD08098\nMSG011I1 EQU   4+17,3              INSERT OFFSET & LENGTH      #DD08098\nMSG011I2 EQU   4+29,2              INSERT OFFSET & LENGTH      #DD08098\nMSG011IL EQU   *-MSG011I                                       #DD08098\nMSG012I  #MSG  '$TEP012I STEPLIB OPEN Failed'                  #DD08099\nMSG013I  #MSG  '$TEP013I STEPLIB OPEN Failed for '             #DD08099\nMSG014I  #MSG  '$TEP014I STEPLIB Command is not APF Authorized' DD08268\n\nTRC001I  #MSG  '$TEP901I TCB Address  Program   Tasklib   TCBJLB' 08268\nTRC001IL EQU   *-TRC001I                                       #DD08268\nTRC001B  #MSG  '.         ________    ________  ________  ________' 268\nTRC001BA EQU   4+1,57              INSERT OFFSET & LENGTH      #DD08268\nTRC001B1 EQU   4+1,7               INSERT OFFSET & LENGTH      #DD08268\nTRC001B2 EQU   4+10,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B3 EQU   4+21,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B4 EQU   4+22,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B5 EQU   4+32,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B6 EQU   4+42,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001BL EQU   *-TRC001B                                       #DD08268\nTRC002I  #MSG  '$TEP902I _____ - DCB Storage at ________ ________'\nTRC002I1 EQU   4+9,5               INSERT OFFSET & LENGTH      #DD08268\nTRC002I2 EQU   4+32,8              INSERT OFFSET & LENGTH      #DD08268\nTRC002I3 EQU   4+41,8              INSERT OFFSET & LENGTH      #DD08268\nTRC002IL EQU   *-TRC002I                                       #DD08268\n\n         #STARTWA PATCH=NO\n         CSVAPF MF=(L,WRKCSVPL)                                #DD01073\n         DYNSPACE ,                DYNAMIC ALLOCATION PARAMETER LIST\n         SCHEDIRB MF=(L,WRKSCH)                                #DD09103\nWRKCLOSE DS    0F,CL(MODLCLOL)     CLOSE PARAMETER LIST        #DD08099\nWRKCSVRC DS    F                   CSVAPF RETURN CODE          #DD01073\nWRKCSVRS DS    F                   CSVAPF REASON CODE          #DD01073\nWRKANS@  DS    A                   RETURNED PDL BUFFER ADDRESS\nWRKAREA  DS    0F,XL265            CATALOG LOCATE WORK AREA    #DD99244\n* THE FOLLOWING \"WRKCC...\" STATEMENTS MUST REMAIN IN ORDER\nWRKCCTU1 DS    AL2,AL2             CONCATENATION DDNAMES TEXT UNIT\nWRKCCDD1 DS    AL2,CL8             PRIMARY DDNAME\nWRKCCDD2 DS    AL2,CL8             SECONDARY DDNAME\nWRKCCTU2 DS    AL2,AL2             CONCATENATION \"PERMANENT\" TEXT UNIT\nWRKDBL1  DS    D                   DOUBLEWORD WORK AREA\nWRKDCB   DS    CL(MODLDCBL)        VALIDATION DCB              #DD08099\nWRKDCBE  DS    CL(MODDCBEL)        VALIDATION DCBE             #DD12060\nWRKDCB@  DS    A                   ACQUIRED/FREE'D DCB ADDRESS #DD08268\nWRKDDN@  DS    A,AL2               CURRENT DATASET'S DDNAME PDE\nWRKDDN   DS    CL8                 VALIDATION DDNAME           #DD08099\nWRKDDNEW DS    CL8                 CURRENT STEPLIB DDNAME\nWRKDDOLD DS    CL8                 ORIGINAL STEPLIB DDNAME\nWRKDDRET DS    CL8                 CURRENT DATASET'S RETURNED DDNAME\nWRKDDTMP DS    CL8                 //STEPLIB REPLACEMENT NAME  #DD99245\nWRKDSAB@ DS    A                   DSAB ADDRESS                #DD01068\nWRKDSN@  DS    A,AL2               CURRENT DATASET NAME PDE\nWRKDSN1  DS    CL44                CURRENT STEPLIB DATASET NAME\nWRKDSN2  DS    CL44                CURRENT \"INPUT\" DATASET NAME\nWRKECB   DS    A                   COMMAND PROCESSOR ECB\nWRKECT@  DS    A                   ECT ADDRESS\nWRKFAIL  DS    6F                  S99FAIL PARAMETER LIST\nWRKFLAG1 DS    X                   FLAG BYTE #1\nWRK$1STD EQU   BIT1   .1.. ....    - 1ST DSNAME ALLOCATED\nWRK$ABND EQU   BIT2   ..1. ....    - ABEND DURING DSN OPEN     #DD08099\nWRK$R112 EQU   BIT3   ...1 ....    - System is z/OS R1.12 or > #DD10050\nWRKFUNC  DS    CL12                REQUESTED FUNCTION INSERT   #DD01072\nWRKINSRT DS    AL2,AL2,CL80        PUTLINE MESSAGE INSERT\nWRKIOPL  DS    4F                  IOPL\nWRKIRB   DS    CL5                 \"OPEN\" OR \"CLOSE\"           #DD08268\nWRKLCT@  DS    A                   LCT ADDRESS                 #DD99245\nWRKTCB@  DS    A                   TCB ADDRESS                 #DD09103\nWRKLOCAT DS    5F                  CATALOG LOCATE PLIST        #DD99244\nWRKMSG   DS    AL2,AL2,CL256       PUTLINE MESSAGE AREA        #DD08098\nWRKOLD   DS    F                   NUMBER OF MESSAGE SEGMENTS\n         DS    A                   A(MESSAGE SEGMENT)\n         DS    A                   A(MESSAGE INSERT SEGMENT)\nWRKOPEN  DS    0F,CL(MODLOPEL)     CLOSE PARAMETER LIST        #DD08099\nWRKPPL   DS    7F                  PARSE PARAMETER LIST\nWRKPSWK  DS    F                   ORIGINAL PSW KEY            #DD08268\nWRKPUTL  PUTLINE MF=L              PUTLINE PARAMETER LIST\nWRKSEND  DS    18F                 REGISTER SAVE AREA          #DD09101\nWRKPARM@ DS    A                   SCHEDIRB PARAMETER POINTER  #DD09103\nWRKREGS  DS    18F                 REGISTER SAVE AREA\nWRKREGS1 DS    18F                 REGISTER SAVE AREA          #DD08268\nWRKREGS2 DS    18F                 REGISTER SAVE AREA          #DD08099\nWRKREGS3 DS    18F                 REGISTER SAVE AREA          #DD08268\nWRKTIME  DS    F                   PAUSE TIME                  #DD09027\nWRKCPPL@ DS    A                   CPPL Address                #DD10106\nWRKUPT@  DS    A                   UPT ADDRESS\nWRKVOL   DS    CL6                 VOLUME OF CURRENT DATASET   #DD01073\n\nWRKHEXIN DS    F                   BINARY TO CHARACTER INPUT   #DD08268\nWRKHEXOU DS    XL8,CL1             BINARY TO CHARACTER OUTPUT  #DD08268\nWRKJLB   DS    CL8                 TASKLIB DDNAME              #DD08268\nWRKJSTCB DS    A                   JOBSTEP TCB ADDRESS         #DD08268\nWRKTYPE  DS    C                   ADDRESS TYPE (T, J, S)      #DD08268\nWRKSSID  DS    X                   Subsystem Identifier        #DD10106\nWRKSTEP@ DS    A                   1st STEPLIB SIOT Address    #DD10177\nWRKVAR@  DS    A                   &STEPLIB Data Address       #DD10177\nWRKVARC@ DS    A                   Current Dsname Address      #DD10177\nWRKVARL  DS    F                   &STEPLIB Data Length        #DD10177\n\nCVARPARM DS    0D                  IKJCT441 Parameter List     #DD10177\nCVAREC@  DS    A                   A(Entry Code)               #DD10177\nCVARNPT@ DS    A                   A(Variable Name Pointer)    #DD10177\nCVARNLN@ DS    A                   A(Variable Name Length Pointer) 0177\nCVARDPT@ DS    A                   A(Variable Data)            #DD10177\nCVARDLN@ DS    A                   A(Variable Data Length)     #DD10177\nCVARTKN@ DS    A                   A(Token)                    #DD10177\n\nCVARCODE DS    F                   Entry Code                  #DD10177\nCVARN@   DS    A                   A(Variable Name)            #DD10177\nCVARN    DS    CL8                 Variable Name               #DD10177\nCVARL    DS    F                   Variable Name Length        #DD10177\nCVARD@   DS    A                   A(Variable Data)            #DD10177\nCVARDL   DS    F                   L(Variable Data)            #DD10177\nCVARTKN  DS    D                   Token                       #DD10177\n         #STOPWA ,\n\n         PRINT NOGEN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        \"STEPLIB\" COMMAND KEYWORDS:                                  *\n*                                                                     *\n*        NOTE: SOME KEYWORDS (SHR & REUSE) ARE THERE SIMPLY TO MAKE   *\n*              THE COMMAND LINE LOOK MORE LIKE AN \"ALLOC\" COMMAND.    *\n*              A PREVIOUS VERSION HOOKED INTO THE \"ALLOC\" COMMAND,    *\n*              AND REMOVED THE \"STEPLIB\" DDNAME RESTRICTION.          *\n*              THIS VERSION WAS CREATED WHEN \"USERMODS\" WERE BEING    *\n*              ELIMINATED FROM THE SYSTEM.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nSTEPLIB  CSECT ,\n\nSTEPPCL  IKJPARM\n\n$TEPFUNC IKJKEYWD DEFAULT='ALLOCATE'\n         IKJNAME 'ADD'\n         IKJNAME 'ALLOCATE',ALIAS=('OVERRIDE','REPLACE')\n         IKJNAME 'DESTACK',ALIAS='UNSTACK'                     #DD01072\n         IKJNAME 'FREE',ALIAS='CLOSE'\n         IKJNAME 'LIST'\n         IKJNAME 'REMOVE',ALIAS='DELETE'\n         IKJNAME 'SAVE',INSERT='NOMSGS'                        #DD10177\n         IKJNAME 'STACK'                                       #DD01072\n         IKJNAME 'VERSION'                                     #DD08098\n$ADD     EQU     1                                             #DD01072\n$ALLOC   EQU     2                                             #DD01072\n$DESTACK EQU     3                                             #DD01072\n$FREE    EQU     4                                             #DD01072\n$LIST    EQU     5                                             #DD01072\n$REMOVE  EQU     6                                             #DD01072\n$SAVE    EQU     7                                             #DD10177\n$STACK   EQU     8                                             #DD01072\n$VERSION EQU     9                                             #DD08098\n\n$TEPDSNS IKJKEYWD ,\n         IKJNAME 'DATASETS',ALIAS='DSNAMES',SUBFLD=$TEPSUBF\n$DSNS    EQU   1                                               #DD01072\n\n$TEPDISP IKJKEYWD ,\n         IKJNAME 'OLD'                                         #DD01072\n         IKJNAME 'SHR'\n$OLD     EQU   1                                               #DD01072\n$SHR     EQU   2                                               #DD01072\n\n$TEPREUS IKJKEYWD ,\n         IKJNAME 'REUSE'\n\n$TEPOPTS IKJKEYWD DEFAULT='FIRST'\n         IKJNAME 'FIRST',ALIAS=('BEFORE','FRONT')\n         IKJNAME 'LAST',ALIAS=('AFTER','END')\n$FIRST   EQU   1                                               #DD01072\n$LAST    EQU   2                                               #DD01072\n\n$TEPMSGS IKJKEYWD DEFAULT='MSGS'\n         IKJNAME 'MSGS',ALIAS=('LOUD','VERBOSE')\n         IKJNAME 'NOMSGS',ALIAS=('QUIET','TERSE')\n         IKJNAME 'DEBUG'                                       #DD08268\n$MSGS    EQU   1                                               #DD01072\n$NOMSGS  EQU   2                                               #DD01072\n$DEBUG   EQU   3                                               #DD08268\n\n$TEPAPF  IKJKEYWD DEFAULT='NOAPFCHK'                           #DD01073\n         IKJNAME 'APFCHK'                                      #DD01073\n         IKJNAME 'NOAPFCHK'                                    #DD01073\n$APFCHK  EQU   1                                               #DD01073\n$NOAPFCH EQU   2                                               #DD01073\n\n$STEPAUS IKJKEYWD DEFAULT='PAUSE(1)'                           #DD09027\n         IKJNAME 'PAUSE',SUBFLD=$PAUSESF                       #DD09027\n\n$TEPSUBF IKJSUBF\n$TEPLIST IKJPOSIT DSNAME,LIST,USID,UPPERCASE,                          *\n               PROMPT='STEPLIB DATASET NAME(S)',VALIDCK=DDALLOC\n\n$PAUSESF IKJSUBF ,                                             #DD09027\nPAUSEPDE IKJIDENT 'PAUSE',MAXLNTH=1,FIRST=NUMERIC,INTEG        #DD09027\n\n         IKJENDP\n\n         PRINT GEN\n\n*-------\n*        DSECTS\n*-------\n         #DSECTS ALLOC,CVT,DCB,DEB,DSAB,ECT,IQE,LCT,PSA,RB,TCB,TCT,TSO,*\n               ASCB,ASXB,JSCB,QDB,SDWA,SIOT,JFCB,SSIB,RB,CDE,  #DD08268*\n               OUCB                                            #DD10106\n         PRINT NOGEN\n         IHADCBE ,                                             #DD10050\n         IKJTSVT ,           TSO Vector Table                  #DD10177\n         PRINT GEN\n\n         AIF   (D'CVTZOS_V1R12).NOZR112                        #DD10050\nCVTZOS_V1R12  EQU X'02'      z/OS V1R12                        #DD10050\n.NOZR112 ANOP  ,                                               #DD10050\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEPLIBH": {"ttr": 18954, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00(\\x01\\x11\\x14?\\x01\\x11\\x14?\\t@\\x00_\\x00_\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2011-05-23T00:00:00", "modifydate": "2011-05-23T09:40:28", "lines": 95, "newlines": 95, "modlines": 0, "user": "HELP"}, "text": "/* *----------------------------------------------------------------* */\n/* *                                                                * */\n/* * To install this command, it must be placed into the LINKLIST,  * */\n/* * and an \"F LLA,REFRESH\" operator command must be issued.        * */\n/* *                                                                * */\n/* * Also, your SYS1.PARMLIB(IKJTSOxx) member must be updated so    * */\n/* * that \"STEPLIB\" is in the AUTHCMD NAMES list.                   * */\n/* * After this member has been updated, a \"PARMLIB UPDATE(xx)\" TSO * */\n/* * command must be issued to reflect the parmlib change.          * */\n/* *                                                                * */\n/* * Note: If a \"REAL\" STEPLIB DD exists within your LOGON PROC,    * */\n/* *       it will NOT be freed, but it will no longer be used.     * */\n/* *                                                                * */\n/* * *************************************                          * */\n/* * *** Special note for BATCH users: ***                          * */\n/* * *************************************                          * */\n/* *       If you use STEPLIB in a BATCH job, please ensure that    * */\n/* *       you \"STEPLIB REMOVE\" prior to terminating.  Otherwise    * */\n/* *       a small amount of LSQA storage will be orphaned under    * */\n/* *       the INIT's TCB.  This could eventually cause storage     * */\n/* *       fragmentation problems.  A $PI will resolve the problem  * */\n/* *       but it would be best to prevent it in the first place.   * */\n/* *                                                                * */\n/* *----------------------------------------------------------------* */\n)F FUNCTION -\n     Dynamically manage the STEPLIB.\n\n     Your STEPLIB can be changed at any time, whether you are in ISPF\n     or not.  This command handles all situations.\n\n)X SYN\n     STEPLIB ADD      DATASETS(DSNAME LIST) FIRST|LAST\n     STEPLIB ALLOCATE DATASETS(DSNAME LIST)\n     STEPLIB DESTACK  DATASETS(DSNAME LIST)\n     STEPLIB FREE\n     STEPLIB LIST\n     STEPLIB REMOVE   DATASETS(DSNAME LIST)\n     STEPLIB SAVE\n     STEPLIB STACK    DATASETS(DSNAME LIST)\n     STEPLIB VERSION\n     STEPLIB ...      APFCHK NOMSGS|MSGS\n\nREQUIRED - <function>\nDEFAULTS - ALLOCATE FIRST MSGS\nALIAS    - ALLOCATE / OVERRIDE or REPLACE\n         - DESTACK  / UNSTACK\n         - FREE     / CLOSE\n         - REMOVE   / DELETE\n         - DATASETS / DSNAMES\n         - FIRST    / BEFORE or FRONT\n         - LAST     / AFTER or END\n         - MSGS     / LOUD or VERBOSE\n         - NOMSGS   / QUIET or TERSE\n\nNOTE: The \"SHR\" and \"REUSE\" keywords have been added so that this\n      command looks like an ALLOCATE command, although these keywords\n      are not used.\n      I.E. (STEPLIB DA(MY.LOAD) SHR REUSE)\n\nEXAMPLE:\n     STEPLIB DA(MY.LOAD 'XYZ.YOUR.LOAD')\n\nReturn Codes:\n     If the PARSE process fails this will be the IKJPARS return code.\n\n      4 - Specified Data Set is already in STEPLIB.\n      8 - Data Set allocation failed.\n     12 - APF Check failed.\n     20 - STEPLIB OPEN failed.\n     24 - STEPLIB Data Set OPEN failed.\n\n)O OPERANDS -\n     ADD      - Add a library(s) to the current STEPLIB concatenation.\n                If the library already exists within the STEPLIB, the\n                command will terminate with a return code of 4.\n     ALLOCATE - Build a new STEPLIB allocation list.\n     DESTACK  - Eliminate a single occurance of the library(s) from\n                the STEPLIB concatenation.\n     FREE     - Remove any existing STEPLIB.\n     LIST     - Display the current STEPLIB DDNAME & Dataset names.\n     REMOVE   - Eliminate library(s) from the current STEPLIB.\n     SAVE     - Create a CLIST variable (&STEPLIB) that contains a\n                list of the current STEPLIB data set names.\n     STACK    - Add a new instance of the library(s) to the current\n                STEPLIB concatenation even if it is already part of the\n                current STEPLIB.  This will allow DESTACK to remove a\n                single instance without affecting other applications.\n     VERSION  - Display the Version and Release of the code as well as\n                the assembly date.\n\n     APFCHK   - After performing the specified function, all libraries\n                in the STEPLIB concatenation are checked to see if they\n                are APF authorized.\n     NOMSGS   - Do not issue any messages during STEPLIB allocation\n                deallocation or APF checking.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEPLIBO": {"ttr": 19203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x07]\\x07]\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:27", "lines": 1885, "newlines": 1885, "modlines": 0, "user": "SOURCE"}, "text": "STEPLIB  TITLE '- STEPLIB - COMMAND PROCESSOR'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                 |                                                   *\n*  S T E P L I B  |       TSO STEPLIB COMMAND PROCESSOR               *\n*                 |                                                   *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* COMMNAD SYNTAX:                                                     *\n*                                                                     *\n*        STEPLIB ADD DATASETS(DSNAME LIST) FIRST|LAST NOMSGS          *\n*        - ADDS THE DSNAME LIST TO THE EXISTING STEPLIB.              *\n*                                                                     *\n*        STEPLIB ALLOCATE DATASETS(DSNAME LIST) SHR REUSE NOMSGS      *\n*        - ALLOCATES A NEW STEPLIB & CLOSES/FREES THE OLD.            *\n*                                                                     *\n*        STEPLIB FREE NOMSGS                                          *\n*        - CLOSES/FREES THE OLD STEPLIB.                              *\n*                                                                     *\n*        STEPLIB LIST                                                 *\n*        - DISPLAYS THE STEPLIB DDNAME AND DATASETS.                  *\n*                                                                     *\n*        STEPLIB REMOVE DATASETS(DSNAME LIST) NOMSGS                  *\n*        - REMOVES THE DSNAME LIST FROM THE EXISTING STEPLIB.         *\n*                                                                     *\n*        STEPLIB STACK DATASETS(DSNAME LIST) FIRST|LAST NOMSGS        *\n*        - ADDS THE DSNAME TO THE STEPLIB, EVEN IF IT IS ALREADY      *\n*          PART OF THE CONCATENATION.                                 *\n*                                                                     *\n*        STEPLIB DESTACK DATASETS(DSNAME LIST) NOMSGS                 *\n*        - REMOVES THE 1ST OCCUANCE OF A DSNAME FROM THE STEPLIB.     *\n*                                                                     *\n*        STEPLIB ... APFCHK                                           *\n*        - AFTER THE FUNCTION IS PERFORMED, CHECK IF THE LIBRARIES    *\n*          WITHIN THE STEPLIB ARE IN THE APF LIST.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     HISTORY:          - JAN 13,1996 -  RE-WRITTEN FROM OLD \"MODS\"   *\n*              #DD99244 - SEP 01,1999 -  VARIOUS BUG FIXES:           *\n*              - IF OLD STEPLIB DDNAME IS \"STEPLIB\" BYPASS \"UNALLOC\". *\n*              - GET \"REAL\" NAME FROM CATALOG IN CASE AN ALIAS WAS    *\n*                SPECIFIED ON THE \"STEPLIB REMOVE\".                   *\n*              - FIX REMOVAL OF \"LAST\" DATASET FROM LIST.             *\n*              #DD99245 - SEP 02,1999 -  IF THE ORIGINAL DDNAME       *\n*                FOR A STEPLIB IS NOT A \"$TEP\" PREFIX, IT IS FREE'D   *\n*                AND RE-ALLOCATED WITH THE $TEP000# DDNAME.           *\n*              #DD01068 - MAR 09,2001 -  RECOGNIZE LIBRARIES THAT     *\n*                ARE ALREADY IN THE CURRENT STEPLIB WHEN PERFORMING   *\n*                AN \"ADD\" FUNCTION.                                   *\n*              #DD01072 - MAR 13,2001 -  ADD \"STACK\"/\"DESTACK\".       *\n*              #DD01073 - MAR 14,2001 -  ADD \"APFCHK\".                *\n*              #DD01095 - APR  5,2001 -  CORRECTIVE FIXES.            *\n*              #DD01250 - SEP  7,2001 -  FIX \"DESTACK\" PROCESSING.    *\n*              #DD04108 - APR 17,2004 -  ADD ESTAE AROUND OPEN        *\n*                                        TO PROTECT AGAINST ABENDS,   *\n*                                        ESPECIALLY S913'S.           *\n*              #DD05026 - JAN 26,2005 -  CHECK FOR A REAL \"JOBLIB\".   *\n*              #DD05031 - JAN 31,2005 -  CORRECT NULL STEPLIB DDNAME. *\n*              #DD08098 - APR  7,2008 -  STEPLIB \"VERSION\" FUNCTION.  *\n*              #DD08099 - APR  8,2008 -  ISSUE OPEN FAILED MSG FOR    *\n*                                        EACH FAILED DSN.             *\n*              #DD08112 - APR 21,2008 -  CORRECT APF/SMS CHECK.       *\n*              #DD08268 - SEP 24,2008 -  ALLOW FOR BATCH TMP.         *\n*                                     -  ADD DEBUG CODE.              *\n*              #DD08350 - DEC 15,2008 -  NO TRACE WHEN PARSE ERROR    *\n*              #DD09027 - JAN 27,2009 -  PAUSE BEFORE BATCH EXIT.     *\n*              #DD09101 - APR 11,2009 -  USE BRANCH ENTRY CIRB.       *\n*                                        FIX FOR Z11 PMR 49446,756    *\n*                                        (D78 abend).                 *\n*              #DD09103   APR 13,2009 -  CHANGE TO USE SCHEDIRB.      *\n*              #DD09199   JUL 18,2009 -  LEAVE NON-ZERO TCBJLIB ALONE.*\n*   1.16 -     #DD10050   Feb 19,2010 -  Build DCB/DCBE for >= r1.12  *\n*                       (Thanks to Jan Ott for heads up & assistance).*\n*   1.17 -     #DD10106   Apr 16,2010 -  JES3 Support.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nSTEPLIB  #START ,                  START PROCEDURE                     *\n               AMODE=CAP31,        EXECUTE IN 31-BIT ADDRESSING MODE   *\n               APARS=,             NO NEED FOR APAR \"ZAP\" SLOTS        *\n               RMODE=24,           EXECUTE IN 24-BIT RESIDENCY MODE    *\n               BASE=(R11,R12),     DEFINE BASE REGISTER(S)             *\n               COPY=YES,           INSERT COPYRIGHT NOTICE             *\n               SPLEVEL=2,          XA/ESA MACRO LEVEL SUPPORT          *\n               WKDSECT=STEPWRK,    DEFINE WORKAREA NAME                *\n               LEVEL=#V001R17                                  #DD10106\n\n         USING PSA,0\n\n         ST    R1,WRKCPPL@         Save CPPL Address           #DD10106\n         LR    R8,R1               A(CPPL)\n         USING CPPL,R8\n\n         MVC   WRKUPT@,CPPLUPT     SAVE A(UPT)\n         MVC   WRKECT@,CPPLECT     SAVE A(ECT)\n\n         L     R15,PSATOLD         LOAD TCB  ADDRESS           #DD08268\n         USING TCB,R15                                         #DD08268\n         MVC   WRKJSTCB,TCBJSTCB   SAVE JOBSTEP TCB ADDRESS    #DD08268\n         L     R14,TCBJSCB         LOAD JSCB ADDRESS           #DD08268\n         USING IEZJSCB,R14                                     #DD08268\n         L     R14,JSCBACT         LOAD ACTIVE JSCB ADDRESS    #DD08268\n         L     R14,JSCBSSIB        LOAD SSIB ADDRESS           #DD08268\n         USING SSIB,R14                                        #DD08268\n         MVC   WRKTYPE,SSIBJBID    \"J\", \"T\" OR \"S\"             #DD08268\n         MVC   WRKSSID,SSIBSSID    Save Subsystem Identifier   #DD10106\n         DROP  R14,R15                                         #DD08268\n\n*        SSIBJBID is unreliable when running under JES3.       #DD10106\n         CLI   WRKSSID,SSIBJES2    Check For JES2 Subsystem    #DD10106\n         BE    STEP0080            B. If Yes (JBID Is Reliable)#DD10106\n         L     R14,PSAAOLD         A(ASCB)                     #DD10106\n         USING ASCB,R14                                        #DD10106\n         ICM   R14,15,ASCBOUCB     A(OUCB)                     #DD10106\n         USING OUCB,R14                                        #DD10106\n         MVI   WRKTYPE,C'S'                                    #DD10106\n         TM    OUCBYFL,OUCBSTT+OUCBMNT Started Task Or Mount?  #DD10106\n         BNZ   STEP0080            B. If Yes                   #DD10106\n         MVI   WRKTYPE,C'T'                                    #DD10106\n         TM    OUCBYFL,OUCBLOG     Check For Logon             #DD10106\n         BO    STEP0080            B. If Yes                   #DD10106\n         MVI   WRKTYPE,C'J'        Treat All Others As Jobs    #DD10106\n         DROP  R14                                             #DD10106\n\nSTEP0080 DS    0H                                              #DD10106\n         L     R2,CVTPTR           A(CVT)                      #DD10050\n         USING CVTMAP,R2                                       #DD10050\n         TM    CVTOSLV5,CVTZOS_V1R12                           #DD10050\n         BZ    STEP0090            B. If Not z/OS R1.12 or >   #DD10050\n         OI    WRKFLAG1,WRK$R112   Set z/OS R1.12 flag         #DD10050\n         DROP  R2                                              #DD10050\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND THE NEXT \"$TEP####\" TO USE AS THE NEW STEPLIB DDNAME    *\n*        NOTE: THIS DDNAME IS USED TO ALLOCATE THE DATASETS WITHIN    *\n*              THE IKJPARS VALIDATION SUBROUTINE.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0090 DS    0H                                              #DD10050\n         MVC   WRKDDNEW,=CL8'$TEP0001'\nSTEP0100 DS    0H                                              #DD99245\n         LA    R2,WRKDDNEW         A(\"NEW\" FAKE STEPLIB DDNAME)#DD99245\n         TIOTSCAN DDN=(R2),NOK=STEP0200  SCAN THE TIOT         #DD99245\n         PACK  WRKDBL1,WRKDDNEW+4(4)                           #DD99245\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB DD NUMBER #DD99245\n         OI    WRKDBL1+7,X'0F'                                 #DD99245\n         UNPK  WRKDDNEW+4(4),WRKDBL1                           #DD99245\n         B     STEP0100                                        #DD99245\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLOSE & RE-OPEN THE STEPLIB TO RETRIEVE THE DDNAME           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0200 DS    0H                                              #DD99245\n         L     R4,PSATOLD          A(TCB)                      #DD99245\n         USING TCB,R4                                          #DD99245\n         L     R5,TCBTCT           A(TCT)                      #DD99245\n         USING SMFTCT,R5                                       #DD99245\n         L     R6,TCTLCTAD         A(LCT)                      #DD99245\n         ST    R6,WRKLCT@          SAVE LCT ADDRESS            #DD99245\n\n         L     R5,TCBJSCB          A(JSCB)                     #DD01068\n         USING IEZJSCB,R5                                      #DD01068\n         L     R5,JSCBACT          A(ACTIVE JSCB)              #DD01068\n         L     R5,JSCDSABQ         A(QDB)                      #DD01068\n         USING QDB,R5                                          #DD01068\n         MVC   WRKDSAB@,QDBFELMP   SAVE DSAB ADDRESS           #DD01068\n         DROP  R4,R5                                           #DD01068\n\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD01068\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD01068\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01068\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD01068\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)       #DD01068\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01068\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARSE THE STEPLIB COMMAND BUFFER                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R1,WRKPPL           LOAD PPL ADDRESS\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      SET UPT ADDRESS\n         MVC   PPLECT,CPPLECT      SET ECT ADDRESS\n         LA    R15,WRKECB\n         ST    R15,PPLECB          SET ECB ADDRESS\n         XC    WRKECB,WRKECB\n         MVC   PPLPCL,=A(STEPPCL)  SET PCL ADDRESS\n         LA    R15,WRKANS@\n         ST    R15,PPLANS          SET PDL ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    SET COMMAND BUFFER ADDRESS\n         ST    R13,PPLUWA          PASS WRKDSECT TO VALIDATION EXIT\n         DROP  R1,R8                                           #DD10106\n\n         CALLTSSR EP=IKJPARS,MF=(E,WRKPPL)\n         L     R8,WRKANS@          LOAD PDL ADDRESS\n         USING IKJPARMD,R8\n         #SETRC (R15)              SET RETURN CODE\n         LTR   R15,R15             CHECK PARSE RETURN CODE\n         BZ    STEP0300            B. IF SUCCESSFUL            #DD99245\n\n*-------\n*        FREE ANY ALLOCATED DATASETS IF THE PARSE ROUTINE FAILED\n*-------\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BZ    STEPEXIT            B. IF NOT                   #DD08350\n         LA    R0,WRKDDNEW         A(STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDNEW       L(STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         FREE  PERM,DDN=WRKDDN@    FREE THE \"NEW\" STEPLIB DATASETS\n         B     STEPEXIT                                        #DD08350\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RE-ALLOCATE THE CURRENT STEPLIB IF THE OLD STEPLIB WAS       *\n*        A \"REAL\" STEPLIB. (IE. //STEPLIB WITHIN THE LOGON PROC)      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP0300 DS    0H                                              #DD99245\n         TM    WRKFLAG1,WRK$ABND   CHECK FOR \"OPEN\" ABEND      #DD08099\n         BO    STEP4500            B. IF YES                   #DD08268\n\n         CLI   $TEPFUNC+1,$VERSION CHECK FOR \"VERSION\" FUNC.   #DD08098\n         BE    STEP4400            B. IF YES                   #DD08098\n\n         CLI   $TEPFUNC+1,$FREE    CHECK FOR \"FREE\" FUNCTION   #DD99245\n         BE    STEP1200            B. IF YES                   #DD99245\n         CLI   $TEPFUNC+1,$LIST    CHECK FOR \"LIST\" FUNCTION   #DD99245\n         BE    STEP2100            B. IF YES                   #DD05031\n\n         MVC   WRKDDTMP,=CL8'$TEP0001'                         #DD99245\nSTEP0400 DS    0H                                              #DD99245\n         LA    R2,WRKDDTMP         A(\"NEW\" FAKE STEPLIB DDNAME)#DD99245\n         TIOTSCAN DDN=(R2),NOK=STEP0500  SCAN THE TIOT         #DD99245\n         PACK  WRKDBL1,WRKDDTMP+4(4)                           #DD99245\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB NUMBER    #DD99245\n         OI    WRKDBL1+7,X'0F'                                 #DD99245\n         UNPK  WRKDDTMP+4(4),WRKDBL1                           #DD99245\n         B     STEP0400                                        #DD99245\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED \"REAL\" STEPLIB\n*-------\nSTEP0500 DS    0H                                              #DD99245\n         CLC   =C'JOBLIB ',WRKDDOLD CHECK FOR \"REAL\" JOBLIB DD #DD05026\n         BE    STEP0550            B. IF YES                   #DD05026\n         CLC   =C'STEP',WRKDDOLD   CHECK FOR \"REAL\" STEPLIB DD #DD01068\n         BNE   STEP1200            B. IF NOT                   #DD01068\nSTEP0550 DS    0H                                              #DD05026\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD99245\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD99245\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD99245\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE OLD STEPLIB DDNAME\n*-------\n         NI    WRKFLAG1,255-WRK$1STD                           #DD99245\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP1200            B. IF CHAIN DOES NOT EXIST  #DD99245\n         USING DSABID,R5                                       #DD99245\n\nSTEP0600 DS    0H                                              #DD99245\n         L     R4,DSABSIOT         A(SIOT)                     #DD99245\n         USING INDMSIOT,R4                                     #DD99245\n         CLC   SCTDDNAM,WRKDDOLD   CHECK PREV. STEPLIB DDNAME  #DD99245\n         BE    STEP0700            B. IF FOUND                 #DD99245\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD99245\n         BNZ   STEP0600            B. IF ANOTHER DSAB EXISTS   #DD99245\n         B     STEP1200            ELSE. UNABLE TO FIND DDNAME #DD99245\n\n*-------\n*        ALLOCATE THE 1ST DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP0700 DS    0H                                              #DD99245\n         L     R1,SJFCBPTR         A(JFCB)                     #DD99245\n         USING INFMJFCB,R1                                     #DD99245\n         MVC   WRKDSN1,JFCBDSNM    SAVE THE CURRENT DSN        #DD99245\n         DROP  R1                                              #DD99245\n         LA    R0,WRKDSN1                                      #DD99245\n         ST    R0,WRKDSN@          A(CURRENT STEPLIB DSNAME)   #DD99245\n         LA    R0,L'WRKDSN1                                    #DD99245\n         STH   R0,WRKDSN@+4        L(CURRENT STEPLIB DSNAME)   #DD99245\n\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DSN ALLOCATED  #DD99245\n         BO    STEP0800            B. IF YES                   #DD99245\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DSN ALLOCATED  #DD99245\n         LA    R0,WRKDDTMP                                     #DD99245\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD99245\n         LA    R0,L'WRKDDTMP                                   #DD99245\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD99245\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                      #DD99245*\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT             #DD99245\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE#DD99245\n         BZ    STEP1000            B. IF SUCCESSFUL            #DD99245\n         B     STEP0900            ELSE. ISSUE ALLOC ERROR MSG #DD99245\n\n*-------\n*        CONCATENATE THE REMAINING DSNAMES TO THE NEW STEPLIB DDNAME\n*-------\nSTEP0800 DS    0H                                              #DD99245\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                      #DD99245*\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT          #DD99245\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE#DD99245\n         BNZ   STEP0900            B. IF ALLOCATION FAILED     #DD99245\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)                    #DD99245\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME        #DD99245\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME        #DD99245\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)                    #DD99245\n         MVC   WRKCCDD1+2(8),WRKDDTMP                          #DD99245\n         MVC   WRKCCDD2+2(8),WRKDDRET                          #DD99245\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)            #DD99245\n         LTR   R15,R15             CHECK CONCAT RETURN CODE    #DD99245\n         BZ    STEP1000            B. IF CONCAT SUCCEEDED      #DD99245\n\n*-------\n*        PROCESS ALLOCATION/CONCATENATION ERRORS\n*-------\nSTEP0900 DS    0H                                              #DD99245\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP4500                                        #DD08268\n\n*-------\n*        CHECK IF NEXT DSAB IS A CONCATENATION OF THE STEPLIB\n*-------\nSTEP1000 DS    0H                                              #DD99245\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD99245\n         BZ    STEP1100            B. IF END OF DSAB CHAIN     #DD99245\n         L     R4,DSABSIOT         A(SIOT)                     #DD99245\n         CLC   SCTDDNAM,=CL8' '    CHECK FOR CONCATENATION     #DD99245\n         BE    STEP0700            B. IF YES                   #DD99245\n         DROP  R4,R5                                           #DD99245\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP1100 DS    0H                                              #DD99245\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD99245\n         LA    R1,WRKDDTMP         A(NEW STEPLIB DDNAME)       #DD99245\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD99245\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB ADD\" FUNCTION                           *\n*             OR THE \"STEPLIB STACK\" FUNCTION                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP1200 DS    0H                                              #DD01073\n         MVC   WRKFUNC,MSG008I6                                #DD01072\n         CLI   $TEPFUNC+1,$STACK   CHECK FOR \"STACK\" FUNCTION  #DD01072\n         BE    STEP1300            B. IF YES                   #DD01072\n         CLI   $TEPFUNC+1,$ADD     CHECK FOR \"ADD\" FUNCTION\n         BNE   STEP1700            B. IF NOT\n         MVC   WRKFUNC,MSG008I1                                #DD01072\nSTEP1300 DS    0H                                              #DD01072\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n         TM    WRKFLAG1,WRK$1STD   CHECK IF ANY DSNS TO ADD    #DD01095\n         BO    STEP1350            B. IF YES                   #DD01095\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01095\n         BE    STEP3800            B. IF YES (DO \"APFCHK\")     #DD01095\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD01095\n         L     R1,=A(MSG010I)      'DATASET ALREADY IN STEPLIB'#DD10106\n         SLR   R2,R2                                           #DD01095\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01095\n         B     STEP3800                                        #DD01095\nSTEP1350 DS    0H                                              #DD01095\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEP1800            B. IF ONE DOES NOT EXIST (ALLOCATE)\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEP1800            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP4500            B. IF NOT                   #DD08268\n\n*-------\n*        CONCATENATE THE NEW DATASET(S) WITH THE OLD STEPLIB DATASETS\n*-------\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDOLD\n         CLI   $TEPOPTS+1,$FIRST   CHECK FOR \"FIRST\" OPTION\n         BE    STEP1400            B. IF YES\n         MVC   WRKCCDD1+2(8),WRKDDOLD\n         MVC   WRKCCDD2+2(8),WRKDDNEW\nSTEP1400 DS    0H\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    STEP1500            B. IF CONCATENATION SUCCEEDED\n\n*-------\n*        IF CONCATENATION FAILS, ISSUE MESSAGE & REINSTATE OLD STEPLIB\n*-------\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BZ    STEP4500            B. IF NOT                   #DD08268\n         LA    R0,WRKDDNEW         A(STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDNEW       L(STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DDNAME\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP4500                                        #DD08268\n\n*-------\n*        RE-OPEN THE CONCATENATED STEPLIB\n*-------\nSTEP1500 DS    0H\n         CLI   $TEPOPTS+1,$FIRST   CHECK FOR \"FIRST\" OPTION\n         BE    STEP1600            B. IF YES\n         MVC   WRKDDNEW,WRKDDOLD   NEW STEPLIB DDNAME TO SAME AS BEFORE\n\nSTEP1600 DS    0H\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG001I)      'STEPLIB EXTENDED'          #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP3800                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB ALLOCATE\" FUNCTION                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP1700 DS    0H\n         MVC   WRKFUNC,MSG008I2                                #DD01072\n         CLI   $TEPFUNC+1,$ALLOC   CHECK FOR \"ALLOCATE\" FUNCTION\n         BNE   STEP1900            B. IF NOT\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEP1800            B. IF ONE DOES NOT EXIST\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEP1800            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE & FREE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP4500            B. IF NOT                   #DD08268\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP1800            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP1800 DS    0H\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG002I)      'STEPLIB ALLOCATED'         #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP3800                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB FREE\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP1900 DS    0H\n         MVC   WRKFUNC,MSG008I3                                #DD01072\n         CLI   $TEPFUNC+1,$FREE    CHECK FOR \"FREE\" FUNCTION\n         BNE   STEP2100            B. IF NOT\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE & FREE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP4500            B. IF NOT                   #DD08268\n\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP2000            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\nSTEP2000 DS    0H\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG003I)      'STEPLIB FREED'             #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP3800                                        #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB LIST\" FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2100 DS    0H\n         MVC   WRKFUNC,MSG008I4                                #DD01072\n         CLI   $TEPFUNC+1,$LIST    CHECK FOR \"LIST\" FUNCTION\n         BNE   STEP2500            B. IF NOT\n\n*-------\n*        CHECK IF THERE IS CURRENTLY A STEPLIB\n*-------\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE START OF THE STEPLIB DD\n*-------\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP4500            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5\n\nSTEP2200 DS    0H\n         L     R4,DSABSIOT         A(SIOT)\n         USING INDMSIOT,R4\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB DDNAME\n         BE    STEP2300            B. IF FOUND\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BNZ   STEP2200            B. IF ANOTHER DSAB EXISTS\n         B     STEP4500            ELSE. UNABLE TO FIND OLD DDN#DD08268\n\n*-------\n*        ONCE 1ST DSAB ENTRY FOUND DISPLAY ASSOCIATED DSNAMES\n*-------\nSTEP2300 DS    0H\n         MVC   WRKINSRT(4),=AL2(12,39)   LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(8),WRKDDOLD\n         LA    R0,2                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG006I)      '$TEPNNNN LIST:'            #DD10106\n         LA    R2,WRKINSRT\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n\nSTEP2400 DS    0H\n         L     R1,SJFCBPTR         A(JFCB)\n         USING INFMJFCB,R1\n         MVC   WRKINSRT(4),=AL2(48,11)   LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(44),JFCBDSNM\n         DROP  R1\n         LA    R0,2                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG007I)      '- DSNAME'                  #DD10106\n         LA    R2,WRKINSRT\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n\n*-------\n*        CONTINUE PROCESSING DSAB'S TILL NON STEPLIB DD FOUND\n*-------\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BZ    STEP3800            B. IF END OF DSAB CHAIN     #DD01073\n         L     R4,DSABSIOT         A(SIOT)\n         CLC   SCTDDNAM,=CL8' '    CHECK IF NEXT IS A CONCATENATION\n         BE    STEP2400            B. IF YES\n         DROP  R4,R5\n         B     STEP3800            ELSE. END OF LIST           #DD01073\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"STEPLIB REMOVE\" FUNCTION                        *\n*             OR THE \"STEPLIB DESTACK\" FUNCTION                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP2500 DS    0H\n         MVC   WRKFUNC,MSG008I7                                #DD01072\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNCTION#DD01072\n         BE    STEP2600            B. IF YES                   #DD01072\n         CLI   $TEPFUNC+1,$REMOVE  CHECK FOR \"REMOVE\" FUNCTION\n         BNE   STEP3800            B. IF NOT                   #DD01073\n         MVC   WRKFUNC,MSG008I5                                #DD01072\nSTEP2600 DS    0H                                              #DD01072\n         CLI   $TEPDSNS+1,$DSNS    CHECK IF DATASET NAMES SPECIFIED\n         BNE   STEPERR1            B. IF NOT\n\n*-------\n*        CHECK IF THERE IS CURRENTLY A STEPLIB\n*-------\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)\n         BZ    STEPERR2            B. IF ONE DOES NOT EXIST    #DD01072\n         DROP  R4\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD05031\n         BZ    STEPERR2            B. IF NOT                   #DD05031\n\n*-------\n*        CLOSE THE PREVIOUSLY ALLOCATED STEPLIB\n*-------\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF CLOSE WAS SUCCESSFUL\n         BNZ   STEP4500            B. IF NOT                   #DD08268\n\n*-------\n*        SCAN THE DSAB CHAIN FOR THE OLD STEPLIB DDNAME\n*-------\n         NI    WRKFLAG1,255-WRK$1STD\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    STEP4500            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5\n\nSTEP2700 DS    0H\n         L     R4,DSABSIOT         A(SIOT)\n         USING INDMSIOT,R4\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR PREVIOUS STEPLIB DDNAME\n         BE    STEP2800            B. IF FOUND\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BNZ   STEP2700            B. IF ANOTHER DSAB EXISTS\n         B     STEP3800            ELSE. CAN'T FIND STEPLIB    #DD01073\n\n*-------\n*        SCAN THE USER SPECIFIED LIST FOR A MATCHING STEPLIB DSNAME\n*-------\nSTEP2800 DS    0H\n         L     R1,SJFCBPTR         A(JFCB)\n         USING INFMJFCB,R1\n         MVC   WRKDSN1,JFCBDSNM    SAVE THE CURRENT DATASET NAME\n         DROP  R1\n\n         LA    R3,$TEPLIST         A(1ST USER SPECIFIED DSNAME)\nSTEP2900 DS    0H\n         L     R2,0(,R3)           A(SPECIFIED DSNAME)\n         LH    R1,4(,R3)           L(SPECIFIED DSNAME)\n         MVC   WRKDSN2,BLANKS      CLEAR DSNAME AREA           #DD99244\n         #EXEC -R1,MVC,WRKDSN2(*-*),0(R2)                      #DD99244\nSTEP3000 DS    0H                                              #DD01072\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD99244\n         LA    R0,WRKDSN2                                      #DD99244\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD99244\n         LA    R0,WRKAREA                                      #DD99244\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD99244\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD99244\n         CLC   WRKDSN1,WRKDSN2     COMPARE DSNAMES             #DD99244\n         BNE   STEP3050            B. IF MATCH NOT FOUND       #DD01250\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNCTION#DD01250\n         BNE   STEP3400            B. IF NOT                   #DD01250\n         MVI   0(R2),X'FF'         DESTROY DSNAME SO THAT ONLY #DD01250\n*                                  1ST OCCURANCE IS REMOVED.   #DD01250\n         B     STEP3400                                        #DD01250\nSTEP3050 DS    0H                                              #DD01250\n         CLI   24(R3),X'FF'        CHECK FOR END OF LIST\n         BE    STEP3100            B. IF YES\n         L     R3,24(,R3)          A(NEXT DSNAME PDE)\n         B     STEP2900            SCAN TILL END OF LIST\n\n*-------\n*        ALLOCATE THE DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP3100 DS    0H\n         LA    R0,WRKDSN1\n         ST    R0,WRKDSN@          A(CURRENT STEPLIB DSNAME)\n         LA    R0,L'WRKDSN1\n         STH   R0,WRKDSN@+4        L(CURRENT STEPLIB DSNAME)\n\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET ALLOCATED\n         BO    STEP3200            B. IF YES\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DATASET WAS ALLOCATED\n         LA    R0,WRKDDNEW\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)\n         LA    R0,L'WRKDDNEW\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                              *\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BZ    STEP3400            B. IF SUCCESSFUL\n         B     STEP3300            ELSE. ISSUE ALLOCATION ERROR MSG\n\n*-------\n*        CONCATENATE THE DSNAME TO THE NEW STEPLIB DDNAME\n*-------\nSTEP3200 DS    0H\n         ALLOC PERM,DSN=WRKDSN@,DISP=SHR,                              *\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   STEP3300            B. IF ALLOCATION FAILED\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDRET\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    STEP3400            B. IF CONCATENATION SUCCEEDED\n\n*-------\n*        PROCESS ALLOCATION/CONCATENATION ERRORS\n*-------\nSTEP3300 DS    0H\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         B     STEP4500                                        #DD08268\n\n*-------\n*        CHECK IF NEXT DSAB IS A CONCATENATION OF THE STEPLIB\n*-------\nSTEP3400 DS    0H\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)\n         BZ    STEP3500            B. IF END OF DSAB CHAIN     #DD99244\n         L     R4,DSABSIOT         A(SIOT)\n         CLC   SCTDDNAM,=CL8' '    CHECK IF NEXT IS A CONCATENATION\n         BE    STEP2800            B. IF YES\n         DROP  R4,R5\n\n*-------\n*        OPEN THE NEWLY ALLOCATED STEPLIB\n*-------\nSTEP3500 DS    0H                                              #DD99244\n         LA    R0,WRKDDOLD         A(OLD STEPLIB DDNAME)\n         ST    R0,WRKDDN@\n         LA    R0,L'WRKDDOLD       L(OLD STEPLIB DDNAME)\n         STH   R0,WRKDDN@+4\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD99244\n         BNE   STEP3600            B. IF NOT                   #DD99244\n         FREE  PERM,DDN=WRKDDN@    FREE THE OLD STEPLIB DDNAME\n\nSTEP3600 DS    0H                                              #DD99244\n         TM    WRKFLAG1,WRK$1STD   CHECK IF ALL DATASETS REMOVED\n         BZ    STEP3700            B. IF YES\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)\n         LA    R1,WRKDDNEW         A(NEW STEPLIB DDNAME)\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY\n         LTR   R15,R15             CHECK IF OPEN SUCCEEDED\n         BNZ   STEPERR3            B. IF NOT                   #DD08099\n\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG004I)      'STEPLIB SHRUNK'            #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP3800                                        #DD01073\n\n*-------\n*        INDICATE THAT ALL DATASETS WERE REMOVED FROM THE STEPLIB\n*-------\nSTEP3700 DS    0H\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG003I)      'STEPLIB DEACTIVATED'       #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP4500                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"APFCHK\" KEYWORD                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP3800 DS    0H                                              #DD01073\n         CLI   $TEPAPF+1,$APFCHK   CHECK FOR \"APFCHK\" KEYWORD  #DD01073\n         BNE   STEP4500            B. IF NOT                   #DD08268\n\n         LA    R0,CLOSEIRB         A(STEPLIB CLOSE ROUTINE)    #DD01073\n         LA    R1,WRKDDOLD         A(OLD DDNAME RETURN ADDRESS)#DD01073\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01073\n\n         LA    R0,OPENIRB          A(STEPLIB OPEN ROUTINE)     #DD01073\n         LA    R1,WRKDDOLD         A(OLD STEPLIB DDNAME)       #DD01073\n         BAL   R14,SENDIRB         PERFORM ASYNCHRONOUSLY      #DD01073\n\n         TM    WRKDDOLD,X'BF'      CHECK IF A STEPLIB EXISTS   #DD01073\n         BZ    STEP4500            B. IF NOT                   #DD08268\n         L     R4,PSATOLD          A(TCB)                      #DD01073\n         USING TCB,R4                                          #DD01073\n         ICM   R2,15,TCBJLB        A(STEPLIB DCB)              #DD01073\n         BZ    STEP4500            B. IF ONE DOES NOT EXIST    #DD08268\n         DROP  R4                                              #DD01073\n\n         ICM   R5,15,WRKDSAB@      A(DSAB)                     #DD01073\n         BZ    STEP4500            B. IF CHAIN DOES NOT EXIST  #DD08268\n         USING DSABID,R5                                       #DD01073\n\nSTEP3900 DS    0H                                              #DD01073\n         L     R4,DSABSIOT         A(SIOT)                     #DD01073\n         USING INDMSIOT,R4                                     #DD01073\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR THE STEPLIB DDNAME#DD01073\n         BE    STEP4000            B. IF FOUND                 #DD01073\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD01073\n         BNZ   STEP3900            B. IF ANOTHER DSAB EXISTS   #DD01073\n         B     STEP4500            ELSE. CAN'T FIND STEPLIB    #DD08268\nSTEP4000 DS    0H                                              #DD01073\n         L     R1,SJFCBPTR         A(JFCB)                     #DD01073\n         USING INFMJFCB,R1                                     #DD01073\n         MVC   WRKDSN2,JFCBDSNM                                #DD01073\n         DROP  R1                                              #DD01073\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD01073\n         LA    R0,WRKDSN2                                      #DD01073\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD01073\n         LA    R0,WRKAREA                                      #DD01073\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD01073\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD01073\n         MVC   WRKVOL,WRKAREA+6    SAVE VOLUME SERIAL          #DD01073\n\n         CSVAPF REQUEST=QUERY,     CHECK IF IN APF LIST        #DD01073*\n               DSNAME=WRKDSN2,                                 #DD01073*\n               VOLTYPE=ANY,VOLUME=WRKVOL,                      #DD01073*\n               RETCODE=WRKCSVRC,RSNCODE=WRKCSVRS,              #DD01073*\n               MF=(E,WRKCSVPL)                                 #DD01073\n         ICM   R1,15,WRKCSVRC      CHECK IF \"IN APFLIST\"       #DD01073\n         BZ    STEP4300            B. IF YES                   #DD01073\n         CHI   R1,4                CHECK FOR RETURN CODE 4     #DD08112\n         BNE   STEP4050            B. IF NOT                   #DD08112\n         CLC   =X'0401',WRKCSVRS+2 CHECK FOR SMS APF LIBRARY   #DD08112\n         BE    STEP4300            B. IF YES                   #DD08112\n\nSTEP4050 DS    0H                                              #DD08112\n         #SETRC 12                 INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP4300            B. IF YES                   #DD01073\n         MVC   WRKINSRT(4),=AL2(48,9)    LENGTH+4/OFFSET       #DD01095\n         MVC   WRKINSRT+4(L'WRKDSN2),WRKDSN2                   #DD01073\n         LA    R1,WRKINSRT+4+L'WRKDSN2-1                       #DD01073\nSTEP4100 DS    0H                                              #DD01073\n         TM    0(R1),X'BF'         CHECK FOR END OF DSNAME     #DD01073\n         BNZ   STEP4200            B. IF FOUND                 #DD01073\n         BCT   R1,STEP4100         KEEP LOOPING BACKWARDS      #DD01073\nSTEP4200 DS    0H                                              #DD01073\n         LA    R1,1(,R1)           A(END OF INSERT BUFFER)     #DD01073\n         LA    R2,WRKINSRT         A(START OF INSERT BUFFER)   #DD01073\n         SR    R1,R2               CALCULATE INSERT LENGTH     #DD01073\n         STCM  R1,3,WRKINSRT       SET INSERT LENGTH           #DD01073\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD01073\n         L     R1,=A(MSG009I)      'DSNAME IS NOT IN APF LIST' #DD10106\n         LA    R2,WRKINSRT                                     #DD01073\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01073\n\nSTEP4300 DS    0H                                              #DD01073\n         ICM   R5,15,DSABFCHN      A(NEXT DSAB)                #DD01073\n         BZ    STEP4500            B. IF END OF DSAB CHAIN     #DD08268\n         L     R4,DSABSIOT         A(SIOT)                     #DD01073\n         CLC   SCTDDNAM,=CL8' '    CHECK FOR CONCATENATION     #DD01073\n         BE    STEP4000            B. IF YES                   #DD01073\n         B     STEP4500            ELSE. ALL DONE CHECKING     #DD08268\n         DROP  R5                                              #DD09103\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE \"VERSION\" KEYWORD                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP4400 DS    0H                                              #DD08098\n         L     R15,=A(MSG011I)                                 #DD10106\n         MVC   WRKMSG(MSG011IL),0(R15)                         #DD10106\n         MVC   MSG011I1+WRKMSG,STEPLIB+32                      #DD08098\n         MVC   MSG011I2+WRKMSG,STEPLIB+36                      #DD08098\n         MVC   WRKINSRT(4),=AL2(14,46)   LENGTH+4/OFFSET       #DD08098\n         MVC   WRKINSRT+4(10),=C'CCYY/MM/DD'                   #DD08098\n         MVC   WRKINSRT+4(4),STEPLIB+21                        #DD08098\n         MVC   WRKINSRT+9(2),STEPLIB+25                        #DD08098\n         MVC   WRKINSRT+12(2),STEPLIB+27                       #DD08098\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD08098\n         LA    R1,WRKMSG           '$TEP011I VERSION:'         #DD08098\n         LA    R2,WRKINSRT         ASSEMBLY DATE & TIME        #DD08098\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08098\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PRODUCE A TCB/RB STRUCTURE LIST FOR DEBUGGING                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEP4500 DS    0H                                              #DD08268\n         CLI   $TEPMSGS+1,$DEBUG   CHECK FOR \"DEBUG\" OPTION    #DD08268\n         BNE   STEPEXIT            B. IF NOT                   #DD08268\n\n         L     R4,PSATOLD          A(CURRENT TCB)              #DD08268\n         USING TCB,R4                                          #DD08268\n         MVC   WRKJSTCB,TCBJSTCB   SAVE JOBSTEP TCB ADDRESS    #DD08268\n\n         L     R4,PSAAOLD          A(ASCB)                     #DD08268\n         USING ASCB,R4                                         #DD08268\n         L     R4,ASCBASXB         A(ASXB)                     #DD08268\n         USING ASXB,R4                                         #DD08268\n         L     R4,ASXBFTCB         A(REGION CONTROL TASK TCB)  #DD08268\n         USING TCB,R4                                          #DD08268\n\n         L     R15,=A(TRC001I)                                 #DD10050\n         MVC   WRKMSG(TRC001IL),0(R15)                         #DD10050\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I TCB DATA'         #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\nSTEP4600 DS    0H                                              #DD08268\n         L     R15,=A(TRC001B)                                 #DD10050\n         MVC   WRKMSG(TRC001BL),0(R15)                         #DD10050\n         CL    R4,WRKJSTCB         IS THIS THE JOBSTEP TCB ?   #DD08268\n         BNE   STEP4700            B. IF NOT                   #DD08268\n         MVC   TRC001B1+WRKMSG,=C'(JSTCB)'                     #DD08268\n\nSTEP4700 DS    0H                                              #DD08268\n         ST    R4,WRKHEXIN         INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC001B2+WRKMSG,WRKHEXOU                        #DD08268\n         CL    R4,PSATOLD          CHECK FOR CURRENT TCB       #DD08268\n         BNE   STEP4750            B. IF NOT                   #DD08268\n         MVI   TRC001B3+WRKMSG,C'*'                            #DD08268\n\nSTEP4750 DS    0H                                              #DD08268\n         MVC   TRC001B4+WRKMSG,=C'UNKNOWN'                     #DD08268\n         ICM   R6,15,TCBRBP        A(TOP RB)                   #DD08268\n         BZ    STEP5100            B. IF NONE                  #DD08268\n         USING RBSECT,R6                                       #DD08268\nSTEP4800 DS    0H                                              #DD08268\n         CLI   RBSTAB1,RBFTPRB     CHECK FOR PRB               #DD08268\n         BE    STEP4900            B. IF YES                   #DD08268\n         ICM   R6,7,RBLINKB        A(NEXT RB)                  #DD08268\n         BNZ   STEP4800            B. IF ANOTHER EXISTS        #DD08268\n         B     STEP5100            ELSE. SKIP IT               #DD08268\n\nSTEP4900 DS    0H                                              #DD08268\n         ICM   R1,15,RBCDE         A(CDE/LPDE)                 #DD08268\n         BZ    STEP5000            B. IF NONE                  #DD08268\n         USING CDENTRY,R1                                      #DD08268\n         MVC   TRC001B4+WRKMSG,CDNAME                          #DD08268\n         DROP  R1                                              #DD08268\n\nSTEP5000 DS    0H                                              #DD08268\n         MVC   TRC001B5+WRKMSG,BLANKS                          #DD08268\n         ICM   R1,15,TCBJLB        A(JOBLIB/STEPLIB)           #DD08268\n         BZ    STEP5100            B. IF NONE                  #DD08268\n         MVC   TRC001B5+WRKMSG,=C'-LNKLST-'                    #DD08268\n         L     R2,CVTPTR           A(CVT)                      #DD08268\n         USING CVTMAP,R2                                       #DD08268\n         CL    R1,CVTLINK          CHECK FOR LINKLIST          #DD08268\n         BE    STEP5100            B. IF NOT                   #DD08268\n         DROP  R2                                              #DD08268\n         LH    R1,DCBTIOT-IHADCB(,R1)                          #DD08268\n         A     R1,TCBTIO           A(TIOT ENTRY)               #DD08268\n         MVC   TRC001B5+WRKMSG,4(R1)                           #DD08268\n\nSTEP5100 DS    0H                                              #DD08268\n         MVC   WRKHEXIN,TCBJLB     INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC001B6+WRKMSG,WRKHEXOU                        #DD08268\n\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I TCB DATA'         #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\n         LR    R1,R4               A(CURRENT TCB)              #DD08268\n         ICM   R4,15,TCBLTC        A(DAUGHTER TCB)             #DD08268\n         BNZ   STEP4600                                        #DD08268\n         ICM   R4,15,TCBNTC-TCB(R1)                            #DD08268\n         BNZ   STEP4600            A(SISTER TCB)               #DD08268\n         DROP  R4,R6                                           #DD08268\n\n         B     STEPEXIT                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ANY ERRORS                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEPERR1 DS    0H\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS\n         L     R1,=A(MSG005I)      'MISSING STEPLIB DSNAMES'   #DD10106\n         SLR   R2,R2\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE\n         B     STEP4500                                        #DD08268\n\nSTEPERR2 DS    0H                                              #DD01072\n         #SETRC 8                  INDICATE AN ERROR OCCURRED  #DD01073\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD01073\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD01072\n         L     R1,=A(MSG008I)      'STEPLIB NOT ALLOCATED'     #DD10106\n         LA    R2,WRKFUNC                                      #DD01072\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD01072\n         B     STEP4500                                        #DD08268\n\nSTEPERR3 DS    0H                                              #DD08099\n         #SETRC 20                 INDICATE AN ERROR OCCURRED  #DD08099\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD08099\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08100\n         L     R1,=A(MSG012I)      'STEPLIB OPEN FAILED'       #DD10106\n         SLR   R2,R2                                           #DD08099\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08099\n         B     STEP4500                                        #DD08268\n\nSTEPERR4 DS    0H                                              #DD08268\n         #SETRC 28                 INDICATE AN ERROR OCCURRED  #DD08268\n         CLI   $TEPMSGS+1,$NOMSGS  CHECK FOR \"NOMSGS\" OPTION   #DD08268\n         BE    STEP4500            B. IF YES                   #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         L     R1,=A(MSG014I)      'STEPLIB NOT AUTHORIZED'    #DD10106\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n         B     STEP4500                                        #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nSTEPEXIT DS    0H\n         CLI   WRKTYPE,C'J'        CHECK FOR BATCH JOB         #DD09027\n         BNE   STEPEX99            B. IF NOT (DON'T PAUSE)     #DD09027\n\n         CLI   WRKANS@,X'FF'       Check If PDL returned       #DD10106\n         BE    STEPEX99            B. If Not                   #DD10106\n         ICM   R8,15,WRKANS@       Load PDL Address            #DD10106\n         BNP   STEPEX99            B. If No PDL                #DD10106\n         USING IKJPARMD,R8                                     #DD10106\n\n         L     R1,PAUSEPDE         A(PDE)                      #DD09027\n         ICM   R1,15,0(R1)         LOAD TIME TO WAIT           #DD09027\n         BZ    STEPEX99            B. IF NO WAITING            #DD09027\n         M     R0,=F'100'          CONVERT TO HUNDREDTHS       #DD09027\n         ST    R1,WRKTIME          SAVE HUNDREDTHS OF SECONDS  #DD09027\n         STIMER WAIT,BINTVL=WRKTIME WAIT FOR ANY HUNG IRB RTN  #DD09027\n\nSTEPEX99 DS    0H                                              #DD09027\n         IKJRLSA WRKANS@           RELEASE ANSWER BUFFER STORAGE\n         #STOP ,                   TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CREATE IRB TO PERFORM FUNCTION UNDER MAIN TASK'S TCB.        *\n*                                                                     *\n*        OPEN & CLOSE ARE DONE IN AN IRB SO THAT THE DCB BUFFERS      *\n*        ARE ASSOCIATED WITH THE TCB.                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nSENDIRB  DS    0H\n         STM   R0,R15,WRKSEND      SAVE ALL REGISTERS          #DD09101\n         ST    R1,WRKREGS          PASS ROUTINE PARAMETER LIST\n         XC    WRKREGS+4(4),WRKREGS+4                          #DD09103\n         ST    R13,WRKREGS+8       PASS WORK AREA ADDRESS      #DD08268\n\n         MODESET MODE=SUP,KEY=ZERO\n\n         L     R6,WRKLCT@          A(LCT)                      #DD09101\n         L     R4,LCTTCBAD-LCT(R6) A(TCB)                      #DD09101\n         ST    R4,WRKTCB@                                      #DD09103\n\n         LA    R0,WRKREGS                                      #DD09103\n         ST    R0,WRKPARM@         A(PARAMETERS)               #DD09103\n\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE        #DD09103\n\n         SCHEDIRB EPPTR=WRKSEND,   ADDRESS OF IRB ENTRY POINT  #DD09103X\n               TCBPTR=WRKTCB@,     ADDRESS OF TCB,             #DD09103X\n               MODE=SUPR,          RUN IN SUPERVISOR STATE     #DD09103X\n               KEY=SUPR,           RUN IN KEY ZERO             #DD09103X\n               PARAMPTR=WRKPARM@,  PASS ADDRESS OF PARAMETERS  #DD09103X\n               MF=(E,WRKSCH,COMPLETE)                          #DD09103\n\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE                   #DD09103\n\n         MODESET MODE=PROB,KEY=NZERO\n\n         WAIT  ECB=WRKREGS+4       WAIT FOR THE EXIT TO END\n\n         CLI   $TEPMSGS+1,$DEBUG   CHECK FOR \"DEBUG\" OPTION    #DD08268\n         BNE   SEND0400            B. IF NOT                   #DD08268\n         ICM   R0,15,WRKDCB@       CHECK IF DCB ADDRESS EXISTS #DD08268\n         BZ    SEND0400            B. IF NOT                   #DD08268\n\n         L     R15,=A(TRC002I)                                 #DD10050\n         MVC   WRKMSG(TRC002IL),0(R15)                         #DD10050\n         MVC   TRC002I1+WRKMSG,WRKIRB                          #DD08268\n         MVC   WRKHEXIN,WRKDCB@    INPUT WORD                  #DD08268\n         BAL   R14,FULLCHAR        CONVERT TO CHARACTER        #DD08268\n         MVC   TRC002I2+WRKMSG,WRKHEXOU                        #DD08268\n         MVC   TRC002I3+WRKMSG,=C'Obtained'                    #DD08268\n         CLI   WRKIRB,C'O'         CHECK FOR \"OPEN\"            #DD08268\n         BE    SEND0300            B. IF YES                   #DD08268\n         MVC   TRC002I3+WRKMSG,=C'Released'                    #DD08268\nSEND0300 DS    0H                                              #DD08268\n         LA    R0,1                SET NUMBER OF SEGMENTS      #DD08268\n         LA    R1,WRKMSG           '$TEP009I DCB ADDRESS:\"     #DD08268\n         SLR   R2,R2                                           #DD08268\n         BAL   R14,ISSUEMSG        ISSUE MESSAGE               #DD08268\n\nSEND0400 DS    0H                                              #DD08268\n         LH    R15,WRKREGS+6       RETURN EXIT RETURN CODE\n         LM    R0,R14,WRKSEND      RESTORE RETURN ADDRESS      #DD09101\n         BR    R14                 RETURN TO CALLER\n         DROP  R8\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ASYNCRONOUS EXIT TO CLOSE THE STEPLIB DD STATEMENT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\n         DROP  ,\nCLOSEIRB DS    0H\n         LR    R12,R15             A(EXIT ENTRY POINT)\n         USING CLOSEIRB,R12\n         USING PSA,0\n\n         LR    R9,R1               A(INPUT PARAMETER)\n         L     R7,0(,R9)           A(STEPLIB DDNAME SAVE AREA)\n         L     R13,8(,R9)          RE-ESTABLIST WORK AREA      #DD08268\n         USING STEPWRK,R13                                     #DD08268\n         MVC   WRKIRB,=C'CLOSE'    TRACE CURRENT REQUEST       #DD08268\n\n         MVC   0(8,R7),BLANKS      CLEAR RETURN DDNAME AREA    #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         L     R5,TCBTCT           A(TCT)\n         USING SMFTCT,R5\n         L     R6,TCTLCTAD         A(LCT)\n         USING LCT,R6\n         L     R2,LCTJOBLB         A(JOBLIB DCB)\n         SLR   R0,R0\n         ST    R0,LCTJOBLB         ZERO LCT'S STEPLIB POINTER\n\nCLOSE100 DS    0H\n         ICM   R4,15,TCBTCB        A(NEXT LOWER TCB)\n         BZ    CLOSE200            B. IF AT END\n         C     R2,TCBJLB           CHECK FOR MATCHING DCB POINTER\n         BNE   CLOSE100            B. IF NOT LEAVE ALONE\n         ST    R0,TCBJLB           ZERO CURRENT TCB'S STEPLIB POINTER\n         B     CLOSE100            CONTINUE TILL END OF TCBS\n\nCLOSE200 DS    0H\n         LTR   R2,R2               CHECK IF A STEPLIB EXISTED  #DD99245\n         BZ    CLOSE400            B. IF NOT                   #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         L     R3,TCBTIO           A(TIOT)                     #DD10106\n         L     R1,TCBLTC           A(LAST TASK TCB)\n         MVC   TCBTIO,TCBTIO-TCB(R1)\n         MVI   0(R9),128           SET CLOSE OPTION\n         CLOSE ((R2)),MF=(E,(R9))\n         ST    R3,TCBTIO           RESTORE A(TIOT)             #DD10106\n         MVC   0(8,R7),DCBDDNAM-IHADCB(R2)\n\n         CLI   WRKTYPE,C'J'        CHECK FOR BATCH JOB         #DD08268\n         BE    CLOSE300            B. IF YES (FREE STEPLIB)    #DD08268\n         CLI   0(R7),C'$'          CHECK FOR \"$TEP...\"         #DD09050\n         BNE   CLOSE400            B. IF NOT                   #DD99245\n\nCLOSE300 DS    0H                                              #DD08268\n         ST    R2,WRKDCB@          SAVE FOR DEBUG MESSAGE      #DD08268\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),         #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n\nCLOSE400 DS    0H                                              #DD99245\n         SLR   R0,R0               SET SUCCESSFUL RETURN CODE\n         POST  4(,R9),(0)          POST WITH RETURN CODE\n         SVC   3                   RETURN TO CALLER\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN ABEND RECOVERY ROUTINE                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD04108\n         DROP  ,                                               #DD04108\n\nESTAERTN DS    0H                                              #DD04108\n         USING *,R15                                           #DD04108\n         CH    R0,=H'12'           RTM PROVIDE AN SDWA?        #DD04108\n         BNE   ESTAE100            B. IF YES                   #DD04108\n         SR    R15,R15             ELSE.                       #DD04108\n         BR    R14                 PERCOLATE                   #DD04108\n\nESTAE100 DS    0H                                              #DD04108\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS     #DD04108\n\n         SETRP RC=4,                                           #DD04108*\n               RETADDR=OPEN0100,   SET RETRY ADDRESS           #DD04108*\n               FRESDWA=YES,        FREE THE SDWA WHEN DONE     #DD04108*\n               REGS=(14,12),       RESTORE CALLER'S REGISTERS  #DD04108*\n               RETREGS=YES,                                    #DD04108*\n               DUMP=NO             DON'T CUT A DUMP            #DD04108\n\n         LTORG ,                   LITERAL POOL                #DD04108\n\n         POP   USING                                           #DD04108\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ASYNCRONOUS EXIT TO OPEN  THE STEPLIB DD STATEMENT.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PUSH  USING\n         DROP  ,\nOPENIRB  DS    0H\n         LR    R12,R15             A(EXIT ENTRY POINT)\n         USING OPENIRB,R12\n         USING PSA,0\n\n         LR    R9,R1               A(INPUT PARAMETER)\n         L     R7,0(,R9)           A(STEPLIB DDNAME)\n         L     R13,8(,R9)          RE-ESTABLIST WORK AREA      #DD08268\n         USING STEPWRK,R13                                     #DD08268\n         MVC   WRKIRB,=C'OPEN '    TRACE CURRENT REQUEST       #DD08268\n\n         LA    R0,8                SET FAILURE CODE            #DD99245\n         TM    0(R7),X'BF'         CHECK FOR VALID DDNAME      #DD99245\n         BZ    OPENEXIT            B. IF NOT                   #DD99245\n\n         L     R4,PSATOLD          A(TCB)\n         USING TCB,R4\n         L     R5,TCBTCT           A(TCT)\n         USING SMFTCT,R5\n         L     R6,TCTLCTAD         A(LCT)\n         USING LCT,R6\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE OBTAIN,LOC=BELOW,SP=253,LENGTH=(R3),          #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n         ST    R1,WRKDCB@          SAVE FOR DEBUG MESSAGE      #DD08268\n         LR    R2,R1               A(DCB)\n         MVC   0(MODLDCBL,R2),MODLDCB\n         MVC   DCBDDNAM-IHADCB(,R2),0(R7)\n\n*        Add DCBE As Added by z/OS R1.12 and Higher            #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   OPEN0050            B. If Not                   #DD10050\n         LA    R1,MODLDCBL(,R2)    A(DCBE)                     #DD10050\n         MVC   0(MODDCBEL,R1),MODDCBE                          #DD10050\n         OI    DCBBFALN-IHADCB(R2),DCBH1+DCBH0  DCBE Exists    #DD10050\n         ST    R1,DCBDCBE-IHADCB(,R2) Save DCBE Address in DCB #DD10050\n\nOPEN0050 DS    0H                                              #DD10050\n         L     R3,TCBTIO           A(TIOT)                     #DD10106\n         L     R1,TCBLTC           A(LAST TASK TCB)\n         MVC   TCBTIO,TCBTIO-TCB(R1)\n\n         ESTAE ESTAERTN            ESTABLISH ABEND RECOVERY    #DD04108\n\n         MVI   0(R9),128           SET OPEN OPTION\n         OPEN  ((R2)),MF=(E,(R9))\nOPEN0100 DS    0H                                              #DD04108\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD04108\n\n         ST    R3,TCBTIO           RESTORE A(TIOT)             #DD10106\n\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN\n         BO    OPEN0200            B. IF OPEN WAS SUCCESSFUL\n         XC    WRKDCB@,WRKDCB@     RESET FOR DEBUG MESSAGE     #DD08268\n         LHI   R3,MODLDCBL         Pre r1.12 DCB Length        #DD10050\n         TM    WRKFLAG1,WRK$R112   Check if z/OS R1.12 or >    #DD10050\n         BNO   *+8                 B. If Not                   #DD10050\n         AHI   R3,MODDCBEL         Add DCBE Length             #DD10050\n         STORAGE RELEASE,ADDR=(R2),SP=253,LENGTH=(R3),         #DD10050*\n               CALLRKY=YES,TCBADDR=TCBJSTCB                    #DD08268\n         LA    R0,12               SET FAILURE CODE\n         B     OPENEXIT\n\nOPEN0200 DS    0H\n         ST    R2,LCTJOBLB-LCT(,R6) SAVE STEPLIB DCB IN LCT\n\nOPEN0300 DS    0H\n         ICM   R4,15,TCBTCB        A(NEXT LOWER TCB)\n         BZ    OPEN0400            B. IF AT END\n\n         CLC   TCBJLB,=F'0'        CHECK FOR IN-USE JOBLIB     #DD09199\n         BNE   OPEN0300            B. IF YES (LEAVE ALONE)     #DD09199\n\n         ST    R2,TCBJLB           SET NEW STEPLIB POINTER\n         B     OPEN0300            CONTINUE TILL END OF TCBS\n\nOPEN0400 DS    0H\n         SLR   R0,R0               SET SUCCESSFUL RETURN CODE\n\nOPENEXIT DS    0H\n         POST  4(,R9),(0)          POST WITH RETURN CODE\n         SVC   3                   RETURN TO CALLER\n         POP   USING\n\n         #EXEC ,                   EXECUTED STATEMENTS         #DD01068\n         LTORG ,                   LITERAL POOL                #DD01068\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONVERT FULLWORD TO 8 BYTES PRINTABLE HEX                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD08268\nFULLCHAR DS    0H                                              #DD08268\n         STM   R0,R15,WRKREGS3     SAVE ALL REGISTERS          #DD08268\n         UNPK  WRKHEXOU(9),WRKHEXIN(5)                         #DD08268\n         TR    WRKHEXOU,HEXTABLE-C'0'                          #DD08268\n         MVI   WRKHEXOU+8,C' '                                 #DD08268\n         LM    R0,R15,WRKREGS3     RESTORE ALL REGISTERS       #DD08268\n         BR    R14                 RETURN TO CALLER            #DD08268\n         POP   USING                                           #DD08268\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ISSUE MESSAGE VIA PUTLINE                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nISSUEMSG DS    0H\n         STM   R0,R14,WRKREGS1     SAVE ALL REGISTERS\n         STM   R0,R2,WRKOLD        #SEGMENTS, SEGMENT1 SEGMENT2\n         L     R4,WRKUPT@          A(UPT)\n         L     R5,WRKECT@          A(ECT)\n         XC    WRKECB,WRKECB\n         PUTLINE PARM=WRKPUTL,UPT=(R4),ECT=(R5),ECB=WRKECB,            *\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),                      *\n               MF=(E,WRKIOPL)\n         LM    R0,R15,WRKREGS1     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        OPEN ABEND RECOVERY ROUTINE (FOR VALIDATION ROUTINE)         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD08099\n         DROP  ,                                               #DD08099\n\nDDALEST  DS    0H                                              #DD08099\n         USING *,R15                                           #DD08099\n         CH    R0,=H'12'           RTM PROVIDE AN SDWA?        #DD08099\n         BNE   DDALEST1            B. IF YES                   #DD08099\n         SR    R15,R15             ELSE.                       #DD08099\n         BR    R14                 PERCOLATE                   #DD08099\n\nDDALEST1 DS    0H                                              #DD08099\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS     #DD08099\n\n         SETRP RC=4,                                           #DD08099*\n               RETADDR=DDALOP10,   SET RETRY ADDRESS           #DD08099*\n               FRESDWA=YES,        FREE THE SDWA WHEN DONE     #DD08099*\n               REGS=(14,12),       RESTORE CALLER'S REGISTERS  #DD08099*\n               RETREGS=YES,                                    #DD08099*\n               DUMP=NO             DON'T CUT A DUMP            #DD08099\n\n         LTORG ,                   LITERAL POOL                #DD08099\n\n         POP   USING                                           #DD08099\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DATASET NAME VALIDITY CHECKING ROUTINE (CONCATENATION)       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  ,\nDDALLOC  DS    0H\n         USING DDALLOC,R15\n         STM   R14,R12,12(R13)     SAVE ALL REGISTERS\n         LR    R12,R15             SET SUBROUTINE BASE REGISTER\n         DROP  R15\n         USING DDALLOC,R12\n         L     R5,0(,R1)           A(DSNAME PDE)\n         LR    R10,R13             A(ORIGINAL SAVEAREA)\n         L     R9,4(,R1)           A(USER WORKAREA)\n         USING STEPWRK,R9\n         LA    R13,WRKREGS         A(SUBROUTINE SAVE AREA)\n\n*-------                                                       #DD01068\n*        IF THE \"ADD\" FUNCTION IS REQUESTED, DONT CONTINUALLY  #DD01068\n*        ALLOCATE DSNAMES THAT ARE ALREADY ALLOCATED TO THE    #DD01068\n*        STEPLIB.  INDICATE VIA A RETURN CODE OF 4 THAT        #DD01068\n*        \"AT LEAST 1\" OF THE DATASETS TO BE ADDED WERE NOT.    #DD01068\n*-------                                                       #DD01068\n         L     R8,WRKANS@          LOAD PDL ADDRESS            #DD01068\n         USING IKJPARMD,R8                                     #DD01068\n         L     R2,0(,R5)           A(SPECIFIED DSNAME)         #DD01068\n         LH    R1,4(,R5)           L(SPECIFIED DSNAME)         #DD01068\n         MVC   WRKDSN2,BLANKS      CLEAR DSNAME AREA           #DD01068\n         #EXEC -R1,MVC,WRKDSN2(*-*),0(R2)                      #DD01068\n         CLI   $TEPFUNC+1,$ADD     CHECK FOR \"ADD\" FUNCTION    #DD08101\n         BNE   DDAL0400            B. IF NOT                   #DD08101\n         CLC   =C'$TEP',WRKDDOLD   CHECK FOR \"FAKE\" STEPLIB DD #DD08101\n         BNE   DDAL0400            B. IF NOT                   #DD08101\n         MVC   WRKLOCAT(MODLLOCL),MODLLOC                      #DD01068\n         LA    R0,WRKDSN2                                      #DD01068\n         ST    R0,WRKLOCAT+4       SAVE DSNAME ADDRESS         #DD01068\n         LA    R0,WRKAREA                                      #DD01068\n         ST    R0,WRKLOCAT+12      SAVE WORK AREA ADDRESS      #DD01068\n         LOCATE WRKLOCAT           CONVERT ALIAS TO REAL NAME  #DD01068\n         ICM   R6,15,WRKDSAB@      A(DSAB)                     #DD01068\n         BZ    DDAL0400            B. IF CHAIN DOES NOT EXIST  #DD01068\n         USING DSABID,R6                                       #DD01068\nDDAL0100 DS    0H                                              #DD01068\n         L     R4,DSABSIOT         A(SIOT)                     #DD01068\n         USING INDMSIOT,R4                                     #DD01068\n         CLC   SCTDDNAM,WRKDDOLD   CHECK FOR START OF STEPLIB  #DD01068\n         BE    DDAL0200            B. IF FOUND                 #DD01068\n         ICM   R6,15,DSABFCHN      A(NEXT DSAB)                #DD01068\n         BNZ   DDAL0100            B. IF ANOTHER DSAB EXISTS   #DD01068\n         B     DDAL0400            ELSE. NO $TEP#### DDNAME    #DD01068\nDDAL0200 DS    0H                                              #DD01068\n         L     R1,SJFCBPTR         A(JFCB)                     #DD01068\n         USING INFMJFCB,R1                                     #DD01068\n         CLC   JFCBDSNM,WRKDSN2    CHECK FOR MATCHING DSNAME   #DD01068\n         BE    DDAL0300            B. IF ALREADY ALLOCATED     #DD01068\n         DROP  R1                                              #DD01068\n         ICM   R6,15,DSABFCHN      A(NEXT DSAB)                #DD01068\n         BZ    DDAL0400            B. IF END OF CHAIN          #DD01068\n         L     R4,DSABSIOT         A(SIOT)                     #DD01068\n         CLC   SCTDDNAM,=CL8' '    CHECK FOR CONCATENATION     #DD01068\n         BNE   DDAL0400            B. IF END OF $TEP###'S      #DD01068\n         B     DDAL0200            ELSE. CONTINUE SEARCHING    #DD01068\n         DROP  R6                                              #DD09103\nDDAL0300 DS    0H                                              #DD01068\n         #SETRC 4                  SET MAINLINE RETURN CODE    #DD01068\n         LA    R15,0               SET VALIDCK RETURN CODE     #DD01068\n         B     DDALEXIT            CONTINUE PARSING            #DD01068\n\nDDAL0400 DS    0H                                              #DD01068\n         LA    R15,0               SET VALIDCK RETURN CODE     #DD01072\n         CLI   $TEPFUNC+1,$REMOVE  CHECK FOR \"REMOVE\" FUNC.    #DD01072\n         BE    DDALEXIT            B. IF YES (DON'T ALLOCATE)  #DD01072\n         CLI   $TEPFUNC+1,$DESTACK CHECK FOR \"DESTACK\" FUNC.   #DD01072\n         BE    DDALEXIT            B. IF YES (DON'T ALLOCATE)  #DD01072\n         TM    WRKFLAG1,WRK$1STD   CHECK IF 1ST DATASET WAS ALLOCATED\n         BO    DDAL0600            B. IF YES\n         LA    R0,WRKDDNEW\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)\n         LA    R0,L'WRKDDNEW\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)\nDDAL0500 DS    0H\n         ALLOC PERM,DSN=((R5)),DISP=SHR,                               *\n               DDN=WRKDDN@,FLAG1=S99NOCNV+S99NOMNT\n         MVC   WRKDDN,WRKDDNEW     SAVE CURRENT DDNAME         #DD08099\n         OI    WRKFLAG1,WRK$1STD   REMEMBER 1ST DATASET WAS ALLOCATED\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   DDAL0550            B. IF ALLOCATION FAILED     #DD08099\n         BAL   R14,DDALOPEN        CATCH OPEN FAILURES         #DD08099\n         B     DDALEXIT                                        #DD08099\n\nDDAL0550 DS    0H                                              #DD08099\n         USING S99RB,R14\n         CLC   S99ERROR,=X'0410'   CHECK FOR \"DDNAME IN USE\" ERROR\n         BNE   DDAL0700            B. IF NOT\n         PACK  WRKDBL1,WRKDDNEW+4(4)\n         AP    WRKDBL1,=P'+1'      INCREMENT STEPLIB NUMBER\n         OI    WRKDBL1+7,X'0F'\n         UNPK  WRKDDNEW+4(4),WRKDBL1\n         DROP  R14\n         B     DDAL0500            RETRY ALLOCATION\n\nDDAL0600 DS    0H\n         ALLOC PERM,DSN=((R5)),DISP=SHR,                               *\n               DDNTO=WRKDDRET,FLAG1=S99NOCNV+S99NOMNT\n         MVC   WRKDDN,WRKDDRET     SAVE CURRENT DDNAME         #DD08099\n         LTR   R15,R15             CHECK ALLOCATION RETURN CODE\n         BNZ   DDAL0700            B. IF ALLOCATION FAILED\n         BAL   R14,DDALOPEN        CATCH OPEN FAILURES         #DD08099\n         TM    WRKFLAG1,WRK$ABND   CHECK IF AN ABEND OCCURED   #DD08101\n         BO    DDALEXIT            B. IF YES                   #DD08101\n\n         MVC   WRKCCTU1(4),=AL2(DCCDDNAM,2)\n         MVC   WRKCCDD1(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCDD2(2),=AL2(8) SET LENGTH OF DDNAME\n         MVC   WRKCCTU2(4),=AL2(DCCPERMC,0)\n         MVC   WRKCCDD1+2(8),WRKDDNEW\n         MVC   WRKCCDD2+2(8),WRKDDRET\n         ALLOC VERB=S99VRBCC,TU=(WRKCCTU1,WRKCCTU2)\n         LTR   R15,R15             CHECK CONCATENATION RETURN CODE\n         BZ    DDALEXIT            B. IF CONCATENATION SUCCEEDED\n\nDDAL0700 DS    0H\n         L     R2,WRKCPPL@         A(CPPL)                     #DD10106\n         S99FAIL CP=YES,CPPL=(R2), ISSUE ALLOC FAILURE MESSAGE #DD10106*\n               MF=(E,WRKFAIL)                                  #DD10106\n         LA    R15,12              SET ERROR CODE\n\nDDALEXIT DS    0H\n         LR    R13,R10             A(ORIGINAL SAVE AREA)\n         ST    R15,16(,R13)        OVERLAY R15 IN SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO IKJPARS\n\n*-------\n*        CATCH OPEN ABENDS (IE. S913)\n*-------\nDDALOPEN DS    0H                                              #DD08099\n         STM   R0,R15,WRKREGS2     SAVE ALL REGISTERS          #DD08099\n\n         MVC   WRKDCB,MODLDCB      FORMAT TEMPORARY DCB        #DD08099\n         MVC   DCBDDNAM-IHADCB+WRKDCB,WRKDDN                   #DD08100\n         MVC   WRKOPEN(MODLOPEL),MODLOPEN                      #DD08099\n         MVC   WRKCLOSE(MODLCLOL),MODLCLOS                     #DD08099\n\n         ESTAE DDALEST             ESTABLISH ABEND RECOVERY    #DD08099\n\n         OPEN  WRKDCB,MF=(E,WRKOPEN)                           #DD08099\n         CLOSE WRKDCB,MF=(E,WRKCLOSE)                          #DD08099\n         B     DDALOP20                                        #DD08099\n\nDDALOP10 DS    0H                                              #DD08099\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD08100\n         OI    WRKFLAG1,WRK$ABND   INDICATE \"OPEN\" ABEND       #DD08099\n         #SETRC 24                                             #DD08099\n\n         MVC   WRKINSRT(4),=AL2(48,33)   LENGTH+4/OFFSET       #DD08099\n         MVC   WRKINSRT+4(44),WRKDSN2                          #DD08099\n\n         LA    R0,2                SET NUMBER OF SEGMENTS      #DD08099\n         L     R1,=A(MSG013I)      '$TEP013I OPEN FAILED FOR'  #DD10106\n         LA    R2,WRKINSRT         DSNAME                      #DD08099\n         STM   R0,R2,WRKOLD        COUNT, A(PART1), A(PART2)   #DD08101\n         L     R4,WRKUPT@          A(UPT)                      #DD08101\n         L     R5,WRKECT@          A(ECT)                      #DD08101\n         XC    WRKECB,WRKECB                                   #DD08101\n         PUTLINE PARM=WRKPUTL,UPT=(R4),ECT=(R5),ECB=WRKECB,    #DD08101*\n               OUTPUT=(WRKOLD,TERM,SINGLE,INFOR),              #DD08101*\n               MF=(E,WRKIOPL)                                  #DD08101\n\n         LA    R0,WRKDDN                                       #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDN                                     #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n         CLC   WRKDDN,WRKDDNEW     CHECK IF 1ST DATASET        #DD08101\n         BE    DDALOP30            B. IF YES                   #DD08101\n         LA    R0,WRKDDNEW                                     #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDNEW                                   #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n         B     DDALOP30                                        #DD08100\n\nDDALOP20 DS    0H                                              #DD08099\n         ESTAE 0                   REMOVE RECOVERY ROUTINE     #DD08099\n         TM    WRKFLAG1,WRK$ABND   CHECK IF AN ABEND OCCURED   #DD08101\n         BZ    DDALOP30            B. IF NOT                   #DD08101\n         LA    R0,WRKDDN                                       #DD08101\n         ST    R0,WRKDDN@          A(CURRENT STEPLIB DDNAME)   #DD08101\n         LA    R0,L'WRKDDN                                     #DD08101\n         STH   R0,WRKDDN@+4        L(CURRENT STEPLIB DDNAME)   #DD08101\n         FREE  PERM,DDN=WRKDDN@    FREE THE STEPLIB DATASET    #DD08101\n\nDDALOP30 DS    0H                                              #DD08100\n         LM    R0,R15,WRKREGS2     RESTORE ALL REGISTERS       #DD08099\n         BR    R14                 RETURN TO CALLER            #DD08099\n\n         LTORG ,                   LITERAL POOL                #DD01068\n         #EXEC ,                   EXECUTED STATEMENTS         #DD01068\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS & DYNAMIC WORKAREA                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nBLANKS   DC    80C' '              LOTS OF BLANKS              #DD99244\n\nHEXTABLE DC    C'0123456789ABCDEF' HEX CONVERSION TABLE        #DD08268\n\nMODLDCB  DCB   DDNAME=*,DSORG=PO,RECFM=U,MACRF=E\n         DS    F                   DCB EXIT LIST (ALA IEFSD164)#DD08268\nMODLDCBL EQU   *-MODLDCB           DCB LENGTH\n\nMODDCBE  DCBE  EADSCB=OK                                       #DD10050\nMODDCBEL EQU   *-MODDCBE           DCBE LENGTH                 #DD10050\n\nMODLOPEN OPEN  (*-*),MF=L          OPEN PARAMETER LIST         #DD08099\nMODLOPEL EQU   *-MODLOPEN                                      #DD08099\nMODLCLOS CLOSE (*-*),MF=L          OPEN PARAMETER LIST         #DD08099\nMODLCLOL EQU   *-MODLOPEN                                      #DD08099\n\nMODLLOC  CAMLST NAME,*-*,,*-*      CATALOG PARAMETER LIST      #DD99244\nMODLLOCL EQU   *-MODLLOC           CATALOG PARAMETER LIST LEN  #DD99244\n\nMSG001I  #MSG  '$TEP001I STEPLIB Expanded'\nMSG002I  #MSG  '$TEP002I STEPLIB Activated'\nMSG003I  #MSG  '$TEP003I STEPLIB Deactivated'\nMSG004I  #MSG  '$TEP004I STEPLIB Shrunk'\nMSG005I  #MSG  '$TEP005I Missing STEPLIB Dataset Name(s)'\nMSG006I  #MSG  '$TEP006I STEPLIB Dataset List - DDName():'     #DD01095\nMSG007I  #MSG  '$TEP007I - '\nMSG008I  #MSG  '$TEP008I STEPLIB Not ed, is not allocated'     #DD01072\nMSG008I1 #MSG  'add',OFFSET=21                                 #DD01072\nMSG008I2 #MSG  'allocat',OFFSET=21                             #DD01072\nMSG008I3 #MSG  'fre',OFFSET=21                                 #DD01072\nMSG008I4 #MSG  'list',OFFSET=21                                #DD01072\nMSG008I5 #MSG  'remov',OFFSET=21                               #DD01072\nMSG008I6 #MSG  'stack',OFFSET=21                               #DD01072\nMSG008I7 #MSG  'destack',OFFSET=21                             #DD01072\nMSG009I  #MSG  '$TEP009I  is not an APF authorized library'    #DD01073\nMSG010I  #MSG  '$TEP010I dataset(s) already found in STEPLIB'  #DD01095\nMSG011I  #MSG  '$TEP011I Version:___ Release:__ Assembly Date:' DD08098\nMSG011I1 EQU   4+17,3              INSERT OFFSET & LENGTH      #DD08098\nMSG011I2 EQU   4+29,2              INSERT OFFSET & LENGTH      #DD08098\nMSG011IL EQU   *-MSG011I                                       #DD08098\nMSG012I  #MSG  '$TEP012I STEPLIB OPEN Failed'                  #DD08099\nMSG013I  #MSG  '$TEP013I STEPLIB OPEN Failed for '             #DD08099\nMSG014I  #MSG  '$TEP014I STEPLIB Command is not APF Authorized' DD08268\n\nTRC001I  #MSG  '$TEP901I TCB Address  Program   Tasklib   TCBJLB' 08268\nTRC001IL EQU   *-TRC001I                                       #DD08268\nTRC001B  #MSG  '.         ________    ________  ________  ________' 268\nTRC001BA EQU   4+1,57              INSERT OFFSET & LENGTH      #DD08268\nTRC001B1 EQU   4+1,7               INSERT OFFSET & LENGTH      #DD08268\nTRC001B2 EQU   4+10,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B3 EQU   4+21,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B4 EQU   4+22,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B5 EQU   4+32,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001B6 EQU   4+42,8              INSERT OFFSET & LENGTH      #DD08268\nTRC001BL EQU   *-TRC001B                                       #DD08268\nTRC002I  #MSG  '$TEP902I _____ - DCB Storage at ________ ________'\nTRC002I1 EQU   4+9,5               INSERT OFFSET & LENGTH      #DD08268\nTRC002I2 EQU   4+32,8              INSERT OFFSET & LENGTH      #DD08268\nTRC002I3 EQU   4+41,8              INSERT OFFSET & LENGTH      #DD08268\nTRC002IL EQU   *-TRC002I                                       #DD08268\n\n         #STARTWA PATCH=NO\n         CSVAPF MF=(L,WRKCSVPL)                                #DD01073\n         DYNSPACE ,                DYNAMIC ALLOCATION PARAMETER LIST\n         SCHEDIRB MF=(L,WRKSCH)                                #DD09103\nWRKCLOSE DS    0F,CL(MODLCLOL)     CLOSE PARAMETER LIST        #DD08099\nWRKCSVRC DS    F                   CSVAPF RETURN CODE          #DD01073\nWRKCSVRS DS    F                   CSVAPF REASON CODE          #DD01073\nWRKANS@  DS    A                   RETURNED PDL BUFFER ADDRESS\nWRKAREA  DS    0F,XL265            CATALOG LOCATE WORK AREA    #DD99244\n* THE FOLLOWING \"WRKCC...\" STATEMENTS MUST REMAIN IN ORDER\nWRKCCTU1 DS    AL2,AL2             CONCATENATION DDNAMES TEXT UNIT\nWRKCCDD1 DS    AL2,CL8             PRIMARY DDNAME\nWRKCCDD2 DS    AL2,CL8             SECONDARY DDNAME\nWRKCCTU2 DS    AL2,AL2             CONCATENATION \"PERMANENT\" TEXT UNIT\nWRKDBL1  DS    D                   DOUBLEWORD WORK AREA\nWRKDCB   DS    CL(MODLDCBL)        VALIDATION DCB              #DD08099\nWRKDCB@  DS    A                   ACQUIRED/FREE'D DCB ADDRESS #DD08268\nWRKDDN@  DS    A,AL2               CURRENT DATASET'S DDNAME PDE\nWRKDDN   DS    CL8                 VALIDATION DDNAME           #DD08099\nWRKDDNEW DS    CL8                 CURRENT STEPLIB DDNAME\nWRKDDOLD DS    CL8                 ORIGINAL STEPLIB DDNAME\nWRKDDRET DS    CL8                 CURRENT DATASET'S RETURNED DDNAME\nWRKDDTMP DS    CL8                 //STEPLIB REPLACEMENT NAME  #DD99245\nWRKDSAB@ DS    A                   DSAB ADDRESS                #DD01068\nWRKDSN@  DS    A,AL2               CURRENT DATASET NAME PDE\nWRKDSN1  DS    CL44                CURRENT STEPLIB DATASET NAME\nWRKDSN2  DS    CL44                CURRENT \"INPUT\" DATASET NAME\nWRKECB   DS    A                   COMMAND PROCESSOR ECB\nWRKECT@  DS    A                   ECT ADDRESS\nWRKFAIL  DS    6F                  S99FAIL PARAMETER LIST\nWRKFLAG1 DS    X                   FLAG BYTE #1\nWRK$1STD EQU   BIT1   .1.. ....    - 1ST DSNAME ALLOCATED\nWRK$ABND EQU   BIT2   ..1. ....    - ABEND DURING DSN OPEN     #DD08099\nWRK$R112 EQU   BIT3   ...1 ....    - System is z/OS R1.12 or > #DD10050\nWRKFUNC  DS    CL12                REQUESTED FUNCTION INSERT   #DD01072\nWRKINSRT DS    AL2,AL2,CL80        PUTLINE MESSAGE INSERT\nWRKIOPL  DS    4F                  IOPL\nWRKIRB   DS    CL5                 \"OPEN\" OR \"CLOSE\"           #DD08268\nWRKLCT@  DS    A                   LCT ADDRESS                 #DD99245\nWRKTCB@  DS    A                   TCB ADDRESS                 #DD09103\nWRKLOCAT DS    5F                  CATALOG LOCATE PLIST        #DD99244\nWRKMSG   DS    AL2,AL2,CL256       PUTLINE MESSAGE AREA        #DD08098\nWRKOLD   DS    F                   NUMBER OF MESSAGE SEGMENTS\n         DS    A                   A(MESSAGE SEGMENT)\n         DS    A                   A(MESSAGE INSERT SEGMENT)\nWRKOPEN  DS    0F,CL(MODLOPEL)     CLOSE PARAMETER LIST        #DD08099\nWRKPPL   DS    7F                  PARSE PARAMETER LIST\nWRKPSWK  DS    F                   ORIGINAL PSW KEY            #DD08268\nWRKPUTL  PUTLINE MF=L              PUTLINE PARAMETER LIST\nWRKSEND  DS    18F                 REGISTER SAVE AREA          #DD09101\nWRKPARM@ DS    A                   SCHEDIRB PARAMETER POINTER  #DD09103\nWRKREGS  DS    18F                 REGISTER SAVE AREA\nWRKREGS1 DS    18F                 REGISTER SAVE AREA          #DD08268\nWRKREGS2 DS    18F                 REGISTER SAVE AREA          #DD08099\nWRKREGS3 DS    18F                 REGISTER SAVE AREA          #DD08268\nWRKTIME  DS    F                   PAUSE TIME                  #DD09027\nWRKCPPL@ DS    A                   CPPL Address                #DD10106\nWRKUPT@  DS    A                   UPT ADDRESS\nWRKVOL   DS    CL6                 VOLUME OF CURRENT DATASET   #DD01073\n\nWRKHEXIN DS    F                   BINARY TO CHARACTER INPUT   #DD08268\nWRKHEXOU DS    XL8,CL1             BINARY TO CHARACTER OUTPUT  #DD08268\nWRKJLB   DS    CL8                 TASKLIB DDNAME              #DD08268\nWRKJSTCB DS    A                   JOBSTEP TCB ADDRESS         #DD08268\nWRKTYPE  DS    C                   ADDRESS TYPE (T, J, S)      #DD08268\nWRKSSID  DS    X                   Subsystem Identifier        #DD10106\n         #STOPWA ,\n\n         PRINT NOGEN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        \"STEPLIB\" COMMAND KEYWORDS:                                  *\n*                                                                     *\n*        NOTE: SOME KEYWORDS (SHR & REUSE) ARE THERE SIMPLY TO MAKE   *\n*              THE COMMAND LINE LOOK MORE LIKE AN \"ALLOC\" COMMAND.    *\n*              A PREVIOUS VERSION HOOKED INTO THE \"ALLOC\" COMMAND,    *\n*              AND REMOVED THE \"STEPLIB\" DDNAME RESTRICTION.          *\n*              THIS VERSION WAS CREATED WHEN \"USERMODS\" WERE BEING    *\n*              ELIMINATED FROM THE SYSTEM.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nSTEPLIB  CSECT ,\n\nSTEPPCL  IKJPARM\n\n$TEPFUNC IKJKEYWD DEFAULT='ALLOCATE'\n         IKJNAME 'ADD'\n         IKJNAME 'ALLOCATE',ALIAS=('OVERRIDE','REPLACE')\n         IKJNAME 'DESTACK',ALIAS='UNSTACK'                     #DD01072\n         IKJNAME 'FREE',ALIAS='CLOSE'\n         IKJNAME 'LIST'\n         IKJNAME 'REMOVE',ALIAS='DELETE'\n         IKJNAME 'STACK'                                       #DD01072\n         IKJNAME 'VERSION'                                     #DD08098\n$ADD     EQU     1                                             #DD01072\n$ALLOC   EQU     2                                             #DD01072\n$DESTACK EQU     3                                             #DD01072\n$FREE    EQU     4                                             #DD01072\n$LIST    EQU     5                                             #DD01072\n$REMOVE  EQU     6                                             #DD01072\n$STACK   EQU     7                                             #DD01072\n$VERSION EQU     8                                             #DD08098\n\n$TEPDSNS IKJKEYWD ,\n         IKJNAME 'DATASETS',ALIAS='DSNAMES',SUBFLD=$TEPSUBF\n$DSNS    EQU   1                                               #DD01072\n\n$TEPDISP IKJKEYWD ,\n         IKJNAME 'OLD'                                         #DD01072\n         IKJNAME 'SHR'\n$OLD     EQU   1                                               #DD01072\n$SHR     EQU   2                                               #DD01072\n\n$TEPREUS IKJKEYWD ,\n         IKJNAME 'REUSE'\n\n$TEPOPTS IKJKEYWD DEFAULT='FIRST'\n         IKJNAME 'FIRST',ALIAS=('BEFORE','FRONT')\n         IKJNAME 'LAST',ALIAS=('AFTER','END')\n$FIRST   EQU   1                                               #DD01072\n$LAST    EQU   2                                               #DD01072\n\n$TEPMSGS IKJKEYWD DEFAULT='MSGS'\n         IKJNAME 'MSGS',ALIAS=('LOUD','VERBOSE')\n         IKJNAME 'NOMSGS',ALIAS=('QUIET','TERSE')\n         IKJNAME 'DEBUG'                                       #DD08268\n$MSGS    EQU   1                                               #DD01072\n$NOMSGS  EQU   2                                               #DD01072\n$DEBUG   EQU   3                                               #DD08268\n\n$TEPAPF  IKJKEYWD DEFAULT='NOAPFCHK'                           #DD01073\n         IKJNAME 'APFCHK'                                      #DD01073\n         IKJNAME 'NOAPFCHK'                                    #DD01073\n$APFCHK  EQU   1                                               #DD01073\n$NOAPFCH EQU   2                                               #DD01073\n\n$STEPAUS IKJKEYWD DEFAULT='PAUSE(1)'                           #DD09027\n         IKJNAME 'PAUSE',SUBFLD=$PAUSESF                       #DD09027\n\n$TEPSUBF IKJSUBF\n$TEPLIST IKJPOSIT DSNAME,LIST,USID,UPPERCASE,                          *\n               PROMPT='STEPLIB DATASET NAME(S)',VALIDCK=DDALLOC\n\n$PAUSESF IKJSUBF ,                                             #DD09027\nPAUSEPDE IKJIDENT 'PAUSE',MAXLNTH=1,FIRST=NUMERIC,INTEG        #DD09027\n\n         IKJENDP\n\n         PRINT GEN\n\n*-------\n*        DSECTS\n*-------\n         #DSECTS ALLOC,CVT,DCB,DEB,DSAB,ECT,IQE,LCT,PSA,RB,TCB,TCT,TSO,*\n               ASCB,ASXB,JSCB,QDB,SDWA,SIOT,JFCB,SSIB,RB,CDE,  #DD08268*\n               OUCB                                            #DD10106\n         PRINT NOGEN\n         IHADCBE ,                                             #DD10050\n\n         IHAQDB ,\n         PRINT GEN\n\n         AIF   (D'CVTZOS_V1R12).NOZR112                        #DD10050\nCVTZOS_V1R12  EQU X'02'      z/OS V1R12                        #DD10050\n.NOZR112 ANOP  ,                                               #DD10050\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVC26DOC": {"ttr": 19971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x16\\x16\\x7f\\x01\\x16\\x16\\x7f\\x124\\x04X\\x04X\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-06-15T00:00:00", "modifydate": "2016-06-15T12:34:16", "lines": 1112, "newlines": 1112, "modlines": 0, "user": "DOC"}, "text": "                              SVC 26\n\n                                and\n\n                          What It Can Do\n\n                          MVS SCP Project\n\n                           Session O327\n                           March 3, 1989\n\n                         Table of Contents\n\n Overview and Disclaimer. . . . . . . . . . . . . . . . . . . .  1\n\n Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2\n      The OS/360 Catalog. . . . . . . . . . . . . . . . . . . .  3\n      CAMLST functions. . . . . . . . . . . . . . . . . . . . .  4\n      OS Catalogs in MVS (with SU8) . . . . . . . . . . . . . .  5\n      VSAM Catalogs (including ICF) . . . . . . . . . . . . . .  5\n\n The Catalog Parameter List (CTGPL) . . . . . . . . . . . . . .  6\n\n The Catalog Field Vector Table (CTGFV) . . . . . . . . . . . .  8\n\n The Catalog Field List (CTGFL) . . . . . . . . . . . . . . . . 10\n      CTGFL Dictionary of Names for Define. . . . . . . . . . . 11\n\n The DELETE Function. . . . . . . . . . . . . . . . . . . . . . 12\n      EXPORT DISCONNECT . . . . . . . . . . . . . . . . . . . . 12\n\n Information Retrieval - VSAM LOCATE. . . . . . . . . . . . . . 13\n\n SUPERLOCATE. . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n GENERIC LOCATE . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n LSPACE - Available Space Report. . . . . . . . . . . . . . . . 16\n\n Creating Catalog Entries - The DEFINE Function . . . . . . . . 17\n      DEFINE NONVSAM. . . . . . . . . . . . . . . . . . . . . . 17\n           IMPORT CONNECT . . . . . . . . . . . . . . . . . . . 17\n      DEFINE GENERATIONDATAGROUP. . . . . . . . . . . . . . . . 18\n      DEFINE CLUSTER/ALTERNATEINDEX . . . . . . . . . . . . . . 18\n      DEFINE PATH . . . . . . . . . . . . . . . . . . . . . . . 20\n      DEFINE ALIAS. . . . . . . . . . . . . . . . . . . . . . . 20\n      DEFINE SPACE. . . . . . . . . . . . . . . . . . . . . . . 21\n\n Modifying Catalog Information - ALTER. . . . . . . . . . . . . 22\n\n DIAGNOSTIC TIPS & HOW TO LEARN MORE. . . . . . . . . . . . . . 23\n      Testing AMS Under TSO . . . . . . . . . . . . . . . . . . 23\n      Testing AMS In The Background . . . . . . . . . . . . . . 23\n\n Data Area Descriptions . . . . . . . . . . . . . . . . . . . . 25\n      CTGPL . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n      CTGFV . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n      CTGFL . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n      CTGWA . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n      CTGVL . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n      CTGCV . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n      AMDSB . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n\n\n                      Overview and Disclaimer\n\n This is a discussion of the SVC 26 interface in MVS.  It includes\n support for ICF catalogs where appropriate, as well as a\n description of the CVOL processor support.  Except as noted, all\n references to VSAM catalogs include ICF catalogs as well.\n\n The intended audience is an experienced system programmer, with a\n working knowledge of Catalog Management externals, including Access\n Method Services.  This is not a tutorial on catalog management, but\n a detailed exploration of the internals.\n\n The information is based upon personal observation, test cases,\n tracing, fiche reading, etcetera.  It is not exhaustive, and has\n not been subjected to any formal testing by the author.\n Nonetheless, the author believes it to be correct and useful.  In\n no circumstances will the author be liable for any damages arising\n from its use.\n\n                           Introduction\n\n The catalog function, like much of MVS, has its origins in the\n original design of OS/360.  It has been enhanced several times\n since.  The first version was limited to associating a list of\n volumes with a dataset name.  This was adequate for the needs of\n OS.  The information was stored in a DASD dataset named SYSCTLG on\n the system residence volume, in a tree structure based on index\n levels in the dataset name.  One of the first improvements was the\n ability to have more than one SYSCTLG, and to chain them together.\n The search would still begin on sysres, but the first level could\n be a pointer to another volume, known as a Control Volume Pointer\n Entry (CVPE).  The CVPE had the serial number of the volume to be\n searched.  Alternatively, the caller could provide the serial\n number of the Control Volume in the CAMLST. It is interesting to\n note that the OS/360 term \"Control Volume\" (CVOL for short) refers\n to the volume containing the SYSCTLG dataset, and not the dataset\n itself.  Hereafter, we will use the vernacular CVOL to refer to a\n SYSCTLG dataset.  Other changes were made to improve the OS catalog\n over time.  The CAMLST functions were documented externally in a\n manual, the last version of which was titled \"Data Management for\n System Programmers.\"\n\n The first major change was the introduction of VSAM as part of\n OS/VS1 and OS/VS2 SVS.  Both of these systems retained the OS\n catalog structure intact, but added a parallel structure for VSAM.\n A new format of request was defined for SVC 26, used for VSAM\n requests.  IBM did not document this new interface, claiming that\n to do so would impair their ability to make changes to it.  The\n author believes that perhaps the real reason is that the new\n interface is so clumsy and awkward they sought to avoid public\n ridicule by concealing the mess.  One day, history will judge this.\n At any rate, the need for documentation does not diminish, hence\n this work.\n\n With the introduction of MVS, the two parallel catalog structures\n were combined in what was, at best, a shotgun marriage.  All\n searches would begin with the VSAM master catalog.  From there, the\n high level qualifier could redirect the activity to either a VSAM\n usercatalog, or to an OS catalog.  The use of an alternate\n usercatalog was possible either by specifying the catalog as a\n parameter to SVC 26, or through the use of STEPCAT.  There was no\n way to select a CVOL other than the one connected via the master\n catalog.  Neither was there support for generation data groups\n (GDGs) in CVOL catalogs.  There was a new layer of software\n introduced, known as the catalog controller.  The controller became\n the first load of SVC 26, and translated CAMLST format requests\n into VSAM Catalog Parameter Lists (CTGPLs).  If later processing\n determined that the target catalog was indeed a CVOL catalog, then\n the CTGPL was translated to a CAMLST, and the CVOL processor\n called.  After CVOL processing, the CAMLST was again translated to\n CTGPL format if required.\n\n The VSAM catalog (prior to ICF) was less than perfect, and users\n demanded full OS catalog support in MVS.  They got it in MVS 3.7\n with SU8.  SU8 reinstated all the code for CVOL functions that had\n been in SVS.  Now, the catalog controller had to recognize CAMLST\n requests which specified a CVOL, and pass them directly to the CVOL\n processor untranslated. The possibility still existed for all of\n the translations described above as well.\n\n The latest major change was the introduction of ICF catalogs in the\n ill fated Data Facility/Extended Function product. DF/EF had severe\n reliability problems in its early life.  It has since been\n superseded by the Data Facility Product (DFP).  There now were\n three catalog types:  OS CVOL, VSAM catalog, and ICF catalog.\n Fortunately the parameter lists for VSAM and ICF catalogs are\n compatible with minor exceptions, so the mapping functions of the\n catalog controller are not changed.\n\n Our purpose here is to understand the CTGPL format of request, and\n how it applies to the various catalog types.  First, however, a\n brief chat about CVOL functions.\n\n                        The OS/360 Catalog\n\n The original catalog was a BSAM type dataset with 256 byte records\n having 8 byte hardware keys.  This is the same format as the\n directory for a partitioned data set, and in OS some of the code\n was shared.  BLDL was branch entered to search catalogs, and\n catalog management was entered (via SVC 28) to format PDS\n directories.  Enough esoteric trivia.\n\n For a seemingly simple function, the internal complexity is\n surprising.  If you think this is bad, just wait until I get to\n VSAM.\n\n There were 10 types of entries in the catalog:\n     AE        Alias entry, provides a substitute high qualifier\n     CVPE      CVOL pointer entry, points to another OS catalog\n     DSPE      Dataset pointer entry (five or less volumes)\n     GIPE      Generation index pointer entry (GDG base)\n     ICE       Index control entry, an intermediate tree node\n     ILE       Index link entry, to chain to another ICE\n     IPE       Index pointer entry, points to the ICE at the next\n               lower level\n     VCB       Volume Control Block, holds up to 20 volumes\n     VCBPE     Volume Control Block pointer entry (more than 5\n               volumes)\n     VICE      Volume index control entry, first block of SYSCTLG\n\n All requests were made with the CAMLST format.  On entry to SVC 26,\n register 1 contains the address of the CAMLST, which is 3 to 5\n words in length.  The first word of the CAMLST is a group of flags\n and control fields to identify the request.  Bit 23 of this word is\n always zero to identify CAMLST format.  The next two to four words\n are pointers to data.  In general, word two points to the dataset\n or index name, and word three is zero or the address of the CVOL\n specification.  Word four points to a second name, volume\n information, or a work area for LOCATE.  Word five is used only\n when a DSCB pointer is passed for a single volume dataset.\n\n There were 14 CAMLST functions available:\n     BLDA      Build an alias for a high level index\n     BLDG      Build a generation index\n     BLDX      Build index (other than a GDG index)\n     BLOCK     LOCATE by TTR\n     CAT       Catalog a dataset when index levels exist\n     CATBX     Catalog a dataset creating required index levels\n     DLTA      Delete an alias for a high level index\n     DLTX      Delete an index (index must be empty)\n     DRPX      Disconnect control volumes\n     LNKX      Connect two control volumes\n     NAME      LOCATE by name\n     RECAT     Recatalog a dataset\n     UCATDX    Uncatalog and remove empty index levels\n     UNCAT     Uncatalog and retain index levels\n\n Word one of the CAMLST indicated the function as follows:\n\n     BLDA    ..00 0.0.   .001 0000   0... ...0   .... ....   0010\n 0000\n     BLDG    ..00 0.0.   .010 0000   0... ...0   .... ....   0020\n 0000\n     BLDX    ..00 0.0.   .100 0000   0... ...0   .... ....   0040\n 0000\n     BLOCK   ..00 0.1.   .000 0000   0... ...0   .... ....   0200\n 0000\n     CAT     ..10 0.0.   .000 0000   0... ...0   .... ....   2000\n 0000\n     CATBX   ..10 0.0.   .100 0000   0... ...0   .... ....   2040\n 0000\n     DLTA    ..00 0.0.   .000 0001   0... ...0   .... ....   0001\n 0000\n     DLTX    ..00 0.0.   .000 0100   0... ...0   .... ....   0004\n 0000\n     DRPX    ..00 0.0.   .000 0000   1... ...0   .... ....   0000\n 8000\n     LNKX    ..00 0.0.   .000 1000   0... ...0   .... ....   0008\n 0000\n     NAME    ..00 0.0.   .000 0000   0... ...0   .... ....   0000\n 0000\n     RECAT   ..01 0.0.   .000 0000   0... ...0   .... ....   1000\n 0000\n     UCATDX  ..00 1.0.   .000 0100   0... ...0   .... ....   0804\n 0000\n     UNCAT   ..00 1.0.   .000 0000   0... ...0   .... ....   0800\n 0000\n\n Bit 0 is set on if the user has specified a CVOL.  Naturally, BLOCK\n is not meaningful without a CVOL specification.  In this case word\n three is the address of the CVOL serial number.  Bits 1 and 5 are\n not used by SVC 26, but the CAMLST macro always generates them as\n one.  This makes locate by name appear as 44000000, for example.\n\n                    OS Catalogs in MVS (with SU8)\n\n MVS changes the rules for OS catalogs slightly.  Index levels are\n always handled automatically in MVS, so that CAT and UNCAT are\n treated as CATBX and UCATDX respectively.  BLDX is supported, but\n is redundant, and DLTX is needed only for a GDG.  Requests which\n are meaningful only in a CVOL are accepted only if the required\n CVOL is specified.  This affects BLDA, BLOCK, DLTA, DRPX and LNKX.\n Any request requiring a specific OS catalog is passed to the CVOL\n processor (IGG0CLCA) unchanged.  Others are mapped to equivalent\n VSAM requests, and passed to the VSAM catalog processor (IGG0CLA1).\n\n If later processing determines that a CTGPL request is directed to\n an OS catalog, then most requests are rejected as not supported.\n The ones that can be handled are VSAM LOCATE, SUPERLOCATE, Generic\n LOCATE, and DELETE.\n\n It is a peculiarity that a CAMLST CATBX can be handled by any\n catalog, but the analogous DEFINE NONVSAM is rejected by the CVOL\n processor.  Furthermore, when working with GDGs, the request must\n match the catalog type.  There is no remapping for BLDG/DLTX, or\n for DEFINE/DELETE GDG.\n\n                   VSAM Catalogs (including ICF)\n\n The primary support for these catalogs is via the VSAM catalog\n parameter list (CTGPL).  This is the undocumented interface, used\n primarily between Access Method Services (AMS) and the catalog\n management component.  All requests are issued in the form of an\n SVC 26.  This interface is much more complex than the CAMLST\n interface.\n\n There are basically only four functions from the user's point of\n view.  DEFINE is used to create catalog entries, DELETE to remove\n them, ALTER to change them, and LOCATE to read them.\n\n There are several flavors of retrieval requests.  The obvious one\n is SUPERLOCATE, which is used by the scheduler to retrieve catalog\n information about a specific entity.  For some unknown reason,\n SUPERLOCATE is restricted to authorized programs only.  VSAM LOCATE\n extracts selected fields from a catalog entry.  LSPACE returns\n space information.  Generic LOCATE returns a list of dataset names,\n but if you want to know what volumes they are on, you must do\n individual calls for that.  Authorized callers would use\n SUPERLOCATE, but mere mortals must use the more clumsy VSAM LOCATE.\n LISTCAT can also be used to read sequentially through a catalog.\n\n Other functions, which are beyond the scope of this document,\n include UPDATE, used by VSAM to maintain descriptive information,\n and CONVERTV, used only with MSS.  With MVS/XATM DFP Version 2,\n there are additional functions for communication with the catalog\n address space, and there is something new in XA DFP 2.3 called GFL\n about which nothing is yet known.\n\n                The Catalog Parameter List (CTGPL)\n\n For all VSAM requests, register 1 at entry to SVC 26 holds the\n address of the CTGPL.  At present, the CTGPL and all data areas\n pointed to it are required to reside below the 16Mb line, however\n all the pointers are fullwords, and the high order bytes must\n always be zero.  IEZCTGPL is the mapping for the CTGPL.\n\n The CTGPL is distinguished from a CAMLST by bit 23 of the first\n word (CTGAM0) being on.  The CTGPL has a base portion 28 bytes\n long, and may have additional 4-byte pointers at the end for\n certain functions.  The basic function is identified in the high-\n order three bits of byte 2 of the parameter list (this is the same\n byte (CTGOPTN3) that contains CTGAM0).  A value of B'100' means\n catalog management services (CMS) request.  For a CMS request, the\n high order five bits of CTGDSORG indicate the specific request.\n\n To clear some of the fog, consider this table:\n\n     Function       CTGOPTN3        CTGDSORG\n      SUPERLOCATE     000              n/a    with CTGSUPLT set on\n      GENERIC LOCATE  000              n/a    with CTGSUPLT &\n CTGGENLD on\n      LOCATE          001              n/a\n      LSPACE          010              n/a\n      UPDATE          011              n/a\n      DEFINE          100             00001\n      ALTER           100             00010\n      DELETE          100             00011\n      LISTCAT         100             00100\n      CONVERTV        100             00110\n      GFL             101              n/a\n\n Most functions require a work area to be provided by the caller.\n Even if none is required, it does no harm to provide one.  The word\n CTGWKA in the CTGPL points to the work area.  Except for\n SUPERLOCATE, the first halfword is the length of the workarea,\n including the halfword itself.  The second halfword contains the\n number of bytes of the workarea actually in use, and should\n normally be initialized to zero.  On return, the content is the\n number of bytes used, including the header.  The workarea itself\n should also be cleared to zeros, although it is not clear what the\n effect of not doing so would be.  Catalog management uses the work\n area to return information to the caller.  For DEFINE, generated\n fields such as component names are built here.  For SUPERLOCATE,\n the workarea is special, and is described later.\n\n DFP levels of catalog management will also accept a \"Format-2\"\n workarea, in which the two fields at the beginning are fullwords\n rather than halfwords, permitting a work area of more than 32K.\n Such a work area is used only for a generic locate.  In a format-2\n workarea, the second header field includes the length of the\n header, so it must be initialized to 8.  Use of a Format-2 work\n area is indicated by setting bit CTGF2WKA on in CTGDSORG.\n\n In the event that the workarea is too small, catalog management\n will return the required size in the second header field, and give\n return code 40.  This enables the caller to obtain a sufficient\n work area, and retry.  If the return code is 44-8 then the caller\n supplied a format-1 workarea, but more than 64K is required (this\n can only happen on a generic locate).\n\n The CTGPL contains an optional pointer to specify which catalog to\n use.  This word (CTGCAT) can be the address of a pointer to the\n catalog's ACB if CTGCNAME=0, or the 44-byte catalog name if\n CTGCNAME=1.\n\n There are several useful flags which modify processing.  They\n include:\n     CTGBYPSS  Bypass security checking (key 0 or supervisor state\n               only)\n     CTGDOCAT  Do not open or allocate the needed catalog\n     CTGSRH    Search only the master catalog\n     CTGTIOT   Caller owns SYSZTIOT exclusive (authorized callers)\n\n If catalog management finds fault with the request, a return code\n is given in register 15.  Note that a branch table cannot be used,\n as the return code may not be divisible by four.  There will be a\n reason code stored in the halfword CTGFDBK, and the last 2\n characters of the detecting catalog management module will be\n stored at CTGMODID.  For a list of return and reason codes, refer\n to the description of message IDC3009I in the System Messages\n manual for MVS.\n\n If the request was processed in an ICF catalog, the bit CTGICFC\n will be turned on by the system to indicate this to the caller.\n\n              The Catalog Field Vector Table (CTGFV)\n\n This data area is used only with the DEFINE and ALTER functions.\n If you are reading this for the first time, skip this until you\n understand the simpler stuff, and then come back.\n\n The CTGFV is the basic unit for describing to catalog management\n the form of an entity to be created in a VSAM or ICF catalog.  It\n is mapped by IEZCTGFV.  The CTGFV for the principal entity (eg.\n cluster) is pointed to by the CTGPL field CTGFVT.  Additional\n CTGFVs (if required) are chained from the first one.\n\n The Field Vector Table is always 100 (X'64') bytes long.  Byte zero\n is the type code for the entity being described (eg.  \"B\" for a GDG\n base).  Bytes one and three are option flags.  Byte two is not\n understood by the author.  The following 24 fullwords are pointers.\n Not all of these pointers will be used at one time.  Indeed, it is\n valid to have a CTGFV with a type code of \"V\" followed by 99 bytes\n of zeros!\n\n Most of the pointers contain addresses of Catalog Field Lists\n (CTGFLs).  Don't panic yet, we'll describe them shortly. Others\n point directly to the data itself.  At this time, we will look at\n a few key pointers only.\n\n CTGFVENT contains the address of the 44-byte component name, or\n zero.  If zeros are passed when defining a Data, Index, or Space\n component, then catalog management will generate a name, place the\n name in the catalog workarea, and place the address in CTGFVENT.\n Generated names in the workarea are actually 45 bytes, with the\n first byte being the type code, and the address in CTGFVENT being\n that of the second byte.  Other types (cluster, nonvsam, etc),\n always require that a name be provided.\n\n Data and index components are always associated with a cluster (or\n alternateindex) record.  The CTGFV for these components are pointed\n to by the fields CTGFVDCH and CTGFVICH of the primary entity during\n define.\n\n Space (type \"V\") is meaningful only for old style VSAM catalogs.\n ICF catalogs do not use this entity type.  Space may be requested\n alone, as in DEFINE SPACE, in which case the primary CTGFV is type\n V and is the only one.  Space may also be requested as part of\n another request, such as DEFINE UCAT or DEFINE CLUSTER UNIQUE, in\n which case the type \"V\" CTGFV is chained from the primary CTGFV via\n field CTGFVVCH.  When the SPACE CTGFV is secondary, it is provided\n as a feedback area only, and should be binary zeros except for the\n type code.  CTGFVVCH is ignored when processing in an ICF catalog.\n\n When creating any entity except space (V), optional ownerid,\n creation date and expiry date CTGFLs may be provided via CTGFVOWN,\n CTGFVCRE, and CTGFVEXP, respectively.  AMS always provides a create\n date, but it is not required.  Curiously, on TSO AMS provides the\n users dataset prefix (not his userid) as the default ownerid.\n\n As a graphic illustration of the worst case CTGFV structure\n (defining a unique KSDS), observe:\n\n        CTGPL\n      +----------+\n      |          |\n      |          |         CTGFV\n      +----------+       +---------------+\n +-------------+\n      |  CTGFVT  |------>|  C3 00 00 00  |        +-------->|  \"D\"\n CTGFV  |\n      +----------+       +---------------+        |         |\n       |\n      |          |       |   CTGFVDCH    |--------+         |\n       |\n      |   . . .  |       +---------------+\n +-------------+  |\n      |          |       |   CTGFVICH    |-------------->|  \"I\"\n CTGFV  |  |\n      +----------+       +---------------+               |\n    |  |\n                         |   CTGFVVCH    |-----+         |\n    |  |\n                         +---------------+     |     +-------------+\n  |--+\n                         |               |     +---->|  \"V\" CTGFV\n |   |\n                         |     . . .     |           |\n |   |\n                         |               |           |\n |---+\n                         +---------------+           |    . . .\n |\n                                                     |\n |\n                                                     |\n |\n                                                     +-------------+\n\n Remember that the \"C\", \"D\" and \"I\" field vectors also point to\n other data, including catalog field lists.\n\n                  The Catalog Field List (CTGFL)\n\n The Catalog Field List (CTGFL) consists of a 16-byte fixed portion,\n and zero or more 8-byte variable fields.  The CTGFL is mapped by\n IEZCTGFL.  This data area is used with retrieval functions, update,\n and with DEFINE and ALTER.  The format is similar, but differs.\n\n When used with DEFINE or ALTER, the CTGFL is pointed to by one of\n the fields in a CTGFV.  The type of data must be consistent with\n the pointer used.  For this usage, CTGFLDNO will be one (or zero,\n to explicitly omit a field). CTGFLDNM will point to an 8-byte\n EBCDIC field name (see dictionary below).  Other header fields will\n be zero.  The data pointer pair (CTGFLDAT) describes the data\n pointed to.  CTGFLNG has the length, which must match the defined\n length for the field (eg.  7 bytes for space), and CTGFLPT has the\n address of the actual data.\n\n When used for UPDATE or information retrieval, the CTGPL points to\n the CTGFL, which describes the field to be retrieved.  CTGNOFLD\n (when nonzero) indicates the number of fullword CTGFL pointers\n which are found beginning at CTGFIELD (CTGPL offset X'1C').  When\n used in this manner, the field name is the only indication of the\n type of data being referred to.\n\n For selective retrieval, the CTGFLCHN field in the retrieval CTGFL\n points to another CTGFL (a \"TEST\" CTGFL) which describes the test.\n It is through the use of this type of CTGFL that selective LISTCAT\n by entity type is implemented. In this case, there may be more than\n one length/address pair describing alternative values.  In\n addition, CTGFLDCD will contain a code indicating what type of\n result is required (eg.  equal, less than, etc.) The CTGFLCHN field\n may chain a series of TEST CTGFLs together, in which case retrieval\n proceeds if any test is successful.\n\n The length and address pair point to the data retrieved for LISTCAT\n or LOCATE, to the new data for ALTER, DEFINE or UPDATE, and to\n comparison data in a test CTGFL.\n\n For example, this diagram illustrates the CTGFL used by DEFINE for\n a space request of CYLINDERS(5,3):\n\n         +----------------+\n   +0    |  01 00 00 00   |     +--->  C'SPACPARM'\n         +----------------+     |\n         |       0        |     |\n         +----------------+     |\n         |    CTGFLDNM    |-----+\n         +----------------+              =--->  X'000005,000003,C0'\n         |       0        |              |\n         +----------------+              |\n  +10    |  00 00 00 07   |              |\n         +----------------+              |\n         |    CTGFLPT     |--------------+\n         +----------------+\n\n               CTGFL Dictionary of Names for Define\n\n                                                       Anchor\n   Name     Length        Description                 CTGFV---\n Types\n\n PASSWALL     52+   Security fields                      STY\n CDGIR\n OWNERID       8    Owner identification                 OWN\n ABCDGIR\n DSETEXDT      3    Expiration date                      EXP\n ABCDGIR\n DSETCRDT      3    Creation date                        CRE\n ABCDGIR\n DEVTYP       12    Device Type (left justified EBCDIC)  DVT\n A\n SPACPARM      7    Space quantity and format            SPC\n CDGIV\n AMDSBCAT     96    Copy of the AMDSB control block      AMD\n DI\n FILESEQ       2    File Sequence                        FSN\n A\n DSATTR        2    Cluster attributes                   ATR\n DI\n BUFSIZE       4    Buffer size                          BUF\n D\n LRECL         4    Average record length                LRS\n D\n RGATTR        1    Path/Alternate Index attribute       UPG\n GR\n\n                        The DELETE Function\n\n We will examine the DELETE function first.  This is because it is\n relatively simple, and provides a good way to get our feet wet.\n\n DELETE requires a 28-byte CTGPL, with the function codes in\n CTGOPTN3 and CTGDSORG being 100 and 00011 respectively. CTGENT must\n point to the 44-byte name of the entity to be deleted, and CTGNAME\n in CTGOPTN1 must be on to indicate use of a name rather than an\n RBA.  To restrict the operation to s specific entity type, insert\n the type code (eg.  \"P\" for pagespace) in CTGTYPE, otherwise leave\n CTGTYPE binary zero.  Set CTGSCR on unless you want NOSCRATCH.\n\n Despite the name, EXPORT DISCONNECT is a form of DELETE.  CTGDISC\n should be turned on to signal export disconnect (as opposed to\n delete usercatalog), and the type in CTGTYP should be \"U\" for\n usercat.\n\n That's it for a basic DELETE.  Options which may be specified\n include:\n     CTGPURG   To ignore the expiry date of the entity\n     CTGERASE  To overwrite the object with zeros on deletion\n     CTGDELRC  Specifies the RECOVERY option for deleting a BCS\n     CTGOVRID  To override the ERASE attribute in the catalog\n     CTGSCR    Set OFF (0) for NOSCRATCH\n\n DELETE SPACE is funny.  For a delete space, the catalog owning the\n volume must be specified via CTGCAT (unless it is the master\n catalog), and CTGENT points to the six character volume serial\n followed by 38 bytes of binary zeros.\n\n                Information Retrieval - VSAM LOCATE\n\n We now examine the VSAM LOCATE request.  Unlike the CAMLST LOCATE,\n which returns a complete record, VSAM LOCATE retrieves fields from\n within the record.  This isolates the caller from the actual record\n format, but he must still be aware of the format of individual\n fields and groups of fields.\n\n VSAM LOCATE requires a work area large enough to hold the record\n being read.  AMS seems happy with 1024 bytes.  The CTGPL will have\n function code 001, and should have CTGBOTH set on.  CTGENT points\n to the 44-byte name, and CTGNAME is on to so indicate.  The list of\n CTGFL pointers begins at CTGFIELD, and the number of them is stored\n in CTGNOFLD.\n\n For each field wanted, a CTGFL must be built, with one\n length/address pair.  The name pointed to by CTGFLDNM indicates\n what data is wanted.  Catalog management will place the data in the\n workarea, and insert the length and address into the CTGFL.\n\n The dictionary of fields is voluminous, and is not included here.\n See Catalog Management Logic manual for a list, or refer to the\n microfiche for IGG0CLAY.  Some of the \"fields\" are in fact derived\n information not residing in the catalog, for example, the catalog\n ACB address.\n\n Most information can be had without any problems, but to receive\n security information you must either (1) be authorized and not turn\n on a \"check password\" bit, or (2) supply the master password by\n pointing CTGPSWD to it.\n\n Actually, the whole record will likely be put in the workarea\n (minus passwords in most cases), but it would be unwise to depend\n on that.\n\n                            SUPERLOCATE\n\n SUPERLOCATE was designed for use by device allocation (the\n scheduler subcomponent), and is restricted to authorized callers.\n You must provide a 28-byte CTGPL, with the function code in\n CTGOPTN3 being 000.  CTGNAME and CTGSUPLT must be turned on.\n\n A special form of workarea is required for SUPERLOCATE.  CTGWKA\n points to the 16-byte area, called the Catalog Work Area (CTGWA),\n and mapped by IEZCTGWA.  The CTGWA in turn points to the variable\n length work area where volume information is returned.\n\n The CTGWA should be zero, except for two fields.  CTGWAVL points to\n the area for the volume list, and CTGWALV holds the length.  The\n system will return the actual number of volumes in CTGWAVCT.\n\n Returned information is scattered across three places.  In the\n CTGPL, there are flags returned in CTGFDBK, and organization\n information is in CTGDSORG (it is only meaningful in terms of VSAM\n versus nonVSAM).  Bit CTGGDGB will be on if a GDG base was located.\n\n In the CTGWA, the number of volumes will be returned in CTGWAVCT,\n and the minimum number of concurrent volumes required will be\n returned in CTGWAUCT.  If CTGGDGB is on, then CTGWAGCT contains the\n number of generations catalogued.  A generation number is returned\n in CTGWAGB, if CTGGDGL was on the original CTGPL.\n\n Volume information is returned in the area pointed to by CTGWAVL.\n Each volume occupies 12 bytes.  Warning to CAMLST users:  The\n format is different for superlocate.  The order of the data\n returned from superlocate is Volume Serial, Device Type code, and\n File Sequence (IEZCTGVL maps the volume list).  For a single volume\n dasd dataset, the TTR of the format-1 DSCB is returned in bytes\n 12-15, otherwise zeros appear in those bytes.  For a multivolume\n dataset, the three fields are repeated as many times as indicated\n in CTGWAVCT.\n\n An insufficient size of volume area will result in a return code 40\n with the required size returned in CTGFDBK.\n\n                          GENERIC LOCATE\n\n GENERIC LOCATE is a form of SUPERLOCATE, but does not require\n authorization.  It requires a 28-byte CTGPL, with the function code\n in CTGOPTN3 being 000.  You must turn on CTGNAME, CTGSUPLT, and\n CTGGENLD to further define the function. CTGENT points to the 44-\n byte name of the entity to be located.\n\n A large work area is typically required.  Catalog information is\n returned here, and 45 bytes are required for each entry.\n\n Input to the function is provided by CTGENT.  This field points to\n a 1-byte length, followed by a variable length character string\n (maximum 43 characters).  Generic locate will find all catalog\n entries matching the partial name.  A period at the end of the\n string is your responsibility, if needed.  If the string has no\n periods at all, then the master catalog is implied, otherwise the\n first qualifier implies the catalog in the usual way.  For example,\n to find all datasets whose first qualifier is DEPT27, you would\n provide AL1(7),C'DEPT27.' (if you omit the period, you get entries\n from the mastercat, including the alias DEPT27.)\n\n Information is returned in the workarea, beginning at the first\n available byte after the header.  If there is already data in the\n workarea, then the new data is added to the existing data.  The\n second header field contains the number of bytes returned, which is\n 45 times the number of names (plus the length of the header, either\n 4 or 8).  Each name consists of a 1-byte type code followed by a\n 44-byte component name.  If more information is required, then you\n must make another call, using VSAM LOCATE, SUPERLOCATE, or OS\n LOCATE to get it.\n\n Optionally, flag bit CTGRCATN may be turned on to have the name of\n the catalog returned as well.  If this is done, then the first name\n in the workarea will be the name of the catalog from which the\n other information was retrieved.  The type code byte for the\n catalog name will be '0' (X'F0').\n\n An catalog may be specified by pointing CTGCAT at its name, and\n turning on CTGCNAME, in which case only that catalog will be\n searched.\n\n                  LSPACE - Available Space Report\n\n The LSPACE function is used only with old style VSAM catalogs.  It\n is not applicable to ICF (you get a rude return code).  LSPACE\n searches the data spaces on a volume, and reports on the free space\n within them, in a manner similar to the DADSM LSPACE function\n provided by SVC 78.\n\n When LSPACE is invoked, the catalog owning the volume must be\n specified via CTGCAT (unless it is the master catalog), and CTGENT\n points to the six character volume serial followed by 38 bytes of\n binary zeros.\n\n LSPACE will return a 30 byte character string of the form\n \"SPACE=CCCC,TTTT,AAAA/cccc,tttt\" in the caller's work area,\n describing free VSAM suballocate space on the volume.  If the\n CTGSMF bit is on, an SMF 69 record is also written\n\n          Creating Catalog Entries - The DEFINE Function\n\n Now, let us look at DEFINE.  This is quite complex, and requires\n that we use the Catalog Field Vector (CTGFV) and Catalog Field List\n (CTGFL).  If you have not already read the descriptions of those\n data areas, do so now before continuing.\n\n DEFINE is used to create one or more entities in the catalog.  Even\n if the type is nonVSAM, the request can be processed only in a VSAM\n catalog.\n\n DEFINE requires a 28-byte CTGPL, with the function codes in\n CTGOPTN3 and CTGDSORG being 100 and 00001 respectively. CTGNAME in\n CTGOPTN1 must be on to indicate use of a name rather than an RBA.\n A work area is mandatory, and a size of 512 bytes is sufficient for\n all known requests.  The address of the primary CTGFV must be\n placed in CTGFVT.\n\n The primary CTGFV will contain the type of entity being defined in\n CTGFVTYP, which will be one of:\n     A         nonVSAM entity\n     B         generation data group (GDG) base\n     C         cluster, pagespace, usercatalog, or mastercatalog\n     G         alternate index\n     R         path\n     V         space (ie, DEFINE SPACE for VSAM suballocation)\n     X         alias (either nonVSAM or catalog)\n\n In addition, the field CTGFVENT will have the address of the name\n for all types except space (V).  If the entity being created is a\n pagespace or catalog, then CTGTYPE in the CTGPL is set to \"P\" or\n \"U\", while CTGFVTYP is \"C\".  Otherwise, CTGTYPE is binary zeros.\n For compatibility, SVC26 will accept a value of \"M\" in CTGTYPE and\n will treat it as \"U\".\n\n Cluster, alternate index, catalog and pagespace requests are quite\n similar.  We will examine the various types in turn.\n\n                          DEFINE NONVSAM\n\n The creation of an \"alien\" (A) record requires a single CTGFV.\n CTGFVENT points to the name of the data set.  The device type is\n passed in EBCDIC using a CTGFL anchored at CTGFVDVT.  The volume\n list is pointed to directly by CTGFVVLT.  It consists of a halfword\n length, followed by a series of 8-byte entries.  Each entry\n consists of two bytes of binary zeros, followed by the six\n character volume serial number.  The length field does not include\n itself, eg. for one volume:  H'8',XL2'0',CL6'VOL001'.  Optionally\n a file sequence number CTGFL may be provided via CTGFVFSN.  Also\n optionally, CTGFVTTR may point to a 3-byte TTR of the format-1\n DSCB.\n\n Believe it or not, the connection of a usercatalog, known as IMPORT\n CONNECT, is a form of DEFINE NONVSAM.  The parameters are set up as\n described, with a type \"A\" CTGFV.  CTGFVENT, CTGFVVLT and CTGFVDVT\n are the only fields used, and CTGTYP (in the CTGPL) must be \"U\" to\n indicate a catalog.  No workarea is needed.  Nothing in the catalog\n connector record indicates whether the catalog is an ICF catalog.\n\n                    DEFINE GENERATIONDATAGROUP\n\n Like nonVSAM, creation of a GDG base (B) requires a single CTGFV.\n CTGFVENT points to the name of the object.  A work area of 256\n bytes is adequate.  GTFFVLMT points to the one byte binary limit\n value.  CTGFVGAT points to an attribute byte, where bit 0 means\n EMPTY and bit 1 means SCRATCH.\n\n                   DEFINE CLUSTER/ALTERNATEINDEX\n\n The creation of clusters (C), alternate indices (G), pagespaces\n (P), and catalogs (U/M) is very similar.  We shall use \"cluster\"\n loosely to mean all of these, except as noted.  These requests\n require multiple CTGFVs to complete.  The primary CTGFV is pointed\n to from the CTGPL.  In the primary CTGFV, CTGFVDCH points to the\n CTGFV for the data (D) component.  CTGFVICH points to the CTGFV for\n the index (I) component, if one exists.  CTGFVVCH points to the\n CTGFV for space (V), if any.  If a space CTGFV exists, it is empty\n except for the type code of V.  Such a CTGFV is always present for\n a catalog, but is optional for other types, and denotes \"UNIQUE\".\n ICF catalogs ignore the space CTGFV.\n\n The following table illustrates the general relationships among the\n various data ares for defining each specific type of object:\n\n   Entity      CTGFVTYP  CTGTYPE   Data   Index   Space       Other\n    KSDS          C       X'00'     Yes    Yes     Opt\n    ESDS          C       X'00'     Yes    No      Opt\n    RRDS          C       X'00'     Yes    No      Opt\n    LDS           C       X'00'     Yes    No      ??\n ?Linear?\n    AIX           G       X'00'     Yes    Yes     Opt\n    ICF Cat       C        U/M      Yes    Yes     Yes\n CTGICFOR=1\n    VSAM Cat      C        U/M      Yes    Yes     Yes\n CTGICFOR=0\n    PAGESPACE     C         P       Yes    No      Opt\n CTGSWAP=0\n    SWAPSPACE     C         P       Yes    No      Opt\n CTGSWAP=1\n\n The data and index components (if present) will always each have an\n AMDSB.  Flags in the data AMDSB distinguish between ESDS, RRDS, and\n linear objects.  The AMDSB is mapped by IDAAMDSB, and is described\n by a CTGFL anchored from the related CTGFVAMD field.  The AMDSB is\n updated by catalog management to fill in additional information.\n Also in the AMDSB are found:  CI size, maximum record size, key\n position and length, numbers of buffers, IMBED, REPLICATE, spanned\n record indicator, writecheck flag, and MSS staging information.\n Not all information is applicable to all component types.\n\n As a minimum, you must fill in AMDSBID and AMDLEN in every AMDSB.\n If the entity is not an ESDS, then one of AMDRRDS, AMDDST, or\n AMDLDS must be set.  In the AMDSB for the data component, you must\n provide maximum record length in AMDLRECL (the average length is\n passed separately).\n\n The caller can specify names for all components when defining a\n pagespace, cluster, or alternate index.  Names for catalog\n components are always constructed by catalog management.  The\n effect of giving the data component of a VVDS a user-provided name\n has not been studied.  When names are generated, they are placed in\n the workarea as described in the CTGFV section above.\n\n Data and index components require allocation information.  A DD\n statement must exist for the volume, and CTGFVIND must point to the\n DDNAME.  Field lists for volumes and space are required.  This\n information may be provided at the component level, or the cluster\n level.  If both are specified, then the component level information\n overrides the cluster level.\n\n The space field list anchored at CTGFVSPC is named SPACPARM, and\n points to a 7-byte field.  The first three bytes contain the\n primary quantity in binary.  The next three bytes contain the\n secondary quantity, or zero if there is no secondary space desired.\n The seventh byte is a space format indicator, where X'C0' denotes\n cylinders, X'80' means tracks, and X'40' requests records.  If\n records are requested, then the LRECL CTGFL must be present via\n CTGFVLRS to provide a fullword average record length.  AMS provides\n a default of 4089 for unspanned records, and 4086 for spanned.\n\n When defining a non-ICF catalog, if space is specified at both the\n cluster level and data component level, then a dataspace is created\n based on the cluster space request, and the data suballocated with\n the data space request.  The leftover space is available for\n allocation of other clusters.\n\n To create an ICF catalog, turn on CTGICFOR in the CTGPL, and\n CTGFVICF in the CTGFV.  For creation of a VSAM catalog, these bits\n must be off.\n\n When a pagespace is created, the setting of CTGSWAP determines a\n swap dataset versus a normal page dataset.  The space request for\n a pagespace must be at the data component level, and must have zero\n as the secondary quantity.  Contiguous space will be allocated.\n Defining the pagespace does not format it, and it cannot be used\n until formatted.  AMS formats the new pagespace by dynamically\n allocating it, opening it, and closing it.  Apparently VSAM is\n clever enough to format it during open.\n\n When creating an alternate index, the name of the related cluster\n must be supplied by pointing CTGFVNAM of the \"G\" CTGFV to it.\n\n The volume list is pointed to directly by CTGFVVLT.  It consists of\n a halfword length, followed by a series of 8-byte entries.  Each\n entry consists of two bytes of binary zeros, followed by the six\n character volume serial number.  The length field does not include\n itself, eg.  for one volume:  H'8',XL2'0',CL6'VOL001'.  All of the\n volumes in the list must be of the same type, but different\n components may use different lists.\n\n The optional security information CTGFL is pointed to by CTGFVSTY.\n The list is named PASSWALL.  The data addressed is at least 52\n bytes long, as follows:\n         +0    8-byte master password\n         +8    8-byte control interval password\n        +10    8-byte update password\n        +18    8-byte read password\n        +20    8-byte code word\n        +28    2-byte binary attempts count\n        +2A    8-byte user security verification module name\n        +32    2-byte user data length (min 0, max 256)\n        +34    optional user data string (up to 256 bytes)\n Unused fields are set to binary ones (X'FF').\n\n CTGFVATR points to the attributes field list named DSATTR.  The\n data is two bytes long:\n         1... ....  .... ....    Speed\n         .1.. ....  .... ....    Unique\n         ..1. ....  .... ....    Reusable\n         ...1 ....  .... ....    Erase\n         .... 1...  .... ....    This catalog is recoverable (non\n                                 ICF only)\n         .... .1..  .... ....    Inhibit update\n         .... ...1  .... ....    Track overflow (pagespaces only)\n         .... ....  XX.. ....    Cross-Region share options 00=1,\n                                 01=2, etc\n         .... ....  ..XX ....    Cross-System share options 10=3,\n                                 11=4\n         .... ..x.  .... xxxx    Reserved, must be zero\n\n For an alternate index only, CTGFVUPG points to the RGATTR field\n list, which addresses a flag byte, bit 0 of which is on for\n upgrade.\n\n For a define with recatalog, turn on CTGFVRCT.  You must be\n authorized for this function.\n\n                            DEFINE PATH\n\n A path (R) is like an alias for VSAM of sorts.  In the single\n CTGFV, CTGFVENT points to the 44-byte path name. CTGFVNAM points\n directly to the 44-byte path entry name, (\"true name\").  CTGFVUPG\n points to the RGATTR field list, which addresses a flag byte, bit\n 0 of which is on for upgrade.  CTGFVSTY may point to a CTGFL with\n password information if desired (see define cluster for format).\n\n                           DEFINE ALIAS\n\n An alias (X) requires a single CTGFV.  CTGFVENT points to the alias\n name being defined, and CTGFVNAM points directly to the 44-byte\n true name.  The referenced true name must be of type (A) or (U).\n\n                           DEFINE SPACE\n\n Space, when requested alone, applies only to non-ICF catalogs.  It\n is the only entity for which no name need be provided.  An\n allocation must exist to the volume, and CTGFVIND must point to the\n DDNAME.  Volume and space information are required in the same\n format as described under DEFINE CLUSTER.  A name will be\n generated, and returned in the workarea.\n\n               Modifying Catalog Information - ALTER\n\n Alter shares a lot with define, so you should be familiar with the\n description of define before continuing.\n\n The setup for alter is always a single CTGFV which refers to the\n component being altered.  To alter the share options for an entire\n cluster, you would alter the cluster, data, and index components in\n separate requests.  Also, alter replaces whole fields in the\n catalog.  To change STRNO, for example, you must provide a complete\n AMDSB replacement. This means you must first use VSAM LOCATE to\n obtain a copy of the existing AMDSB.\n\n The CTGFV will only require pointers to the fields being changed.\n All other pointers (except CTGFVENT) will be zero. CTGFVENT, of\n course, points to the 44-byte name of the object being altered.\n CTGFVTYP should contain the type code of the entity, but I don't\n know if this is required.\n\n ALTER NEWNAME is a special case, in that the new name is pointed to\n by CTGNEWNM in the CTGPL, and the CTGFV is all zeros (even\n CTGFVTYP) except for CTGFVENT.  Attempting ALTER NEWNAME on a\n catalog or one of its components will fail with return code 48,\n reason 8.  If the entity being renamed is type A, D or I, then\n CTGFVIND should provide a DD as the VTOC will require updating.\n\n ALTER REMOVEVOLUMES, for the volume cleanup function, requires that\n CTGFVENT point to the name of the master catalog, CTGFVIND must\n point to the DDNAME to be used, and CTGFVRVL must be on.\n\n                DIAGNOSTIC TIPS & HOW TO LEARN MORE\n\n Much information about the parameter lists was found through the\n examination of the parameters created by AMS.  Two techniques are\n useful, one for TSO and the other for background testing.\n\n Processing for both TSO and background mode involves the mainline\n load module IDCAMS identifying the command. Depending on the\n request, one of several functional modules will be entered from the\n mainline, but control always passes back to a common \"System\n Adapter\" to perform the actual catalog management call.  The\n adapter we are interested in is named IDCSACA, and entry point in\n module IDCSA02, load module IDCAMS.  On entry to IDCSA02, register\n 1 points to a two word parameter list.  The second word is the\n address of the pointer to the CTGPL.  In TEST-ese, the CTGPL is\n located at 1R%+4%%.  Other data may be found chained from the\n CTGPL.\n\n                       Testing AMS Under TSO\n\n All TSO requests begin at module IDCAM01, which resides in CMDLIB\n and has an alias for each AMS command.  Most levels of AMS also\n have module IDCAM02, which is identical to IDCAM01, and is used to\n avoid the limit of 16 aliases per load module.  (Note, PARM and\n CNVTCAT are not available under TSO).  IDCAM01 passes control via\n LINK to the AMS mainline IDCSATO (an alias of IDCAMS).\n\n By running AMS under test, and setting a breakpoint at the entry to\n IDCSACA, we can examine (and modify!) the parameters to study them\n and their effect.\n\n The following MVS/XATM CLIST has been useful to the author (it\n requires slight modification for use with MVS/370):\n\n   10 PROC 1 VERB\n   20 WRITE ENTER OPERANDS FOR &VERB COMMAND\n   30 READ\n   40 TEST 'SYS1.CMDLIB(&VERB)' CP\n   50 &VERB &SYSDVAL\n   60 AT IDCSATO.IDCSACA +\n   70 (EQ CTGPL 1R%+4%% L(28);L CTGPL;EQ CTGFV CTGPL+4% L(100);L\n      CTGFV; +\n   80 EQ AFTER 14R%;AT AFTER (OFF AFTER)) DEFER\n   90 GO\n\n In MVS/370, you must find the offset of label IDCSACA in module\n IDCSA02 (with AMBLIST, for example), and change line 60 to AT\n IDCSATO.IDCSA02.+xx, since TEST in 370 mode will not accept an\n external symbol which is not a CSECT name.\n\n                   Testing AMS In The Background\n\n Testing in the background is accomplished through the use of AMS\n own built in debugging facility.  AMS provides a generous number of\n dump points within the logic flow.  The most useful one is called\n ZZCA, which is located in IDCSACA and is hit before and after each\n call (ie.  twice per request).  The trap is activated by the AMS\n command \" PARM TEST(FULL(ZZCA,n,m)\", where n (default 1) indicates\n when dumping is to begin, and m (default 1) indicates how many\n dumps are to be taken.\n\n ALTER usually requires a locate, followed by an alter call.  To\n trace the before and after status of an ALTER, without tracing the\n locate call, you might use:\n\n         PARM TEST(FULL(ZZCA,3,2))     /* ACTIVATE TRAP */\n         ALTER entity-name STRNO(8)\n         PARM TEST(OFF)                /* DEACTIVATE TRAP */\n\n The dumps are taken to the AMSDUMP DD statement.  Each dump is\n assigned an ID number, and messages in SYSPRINT relate the dumps to\n the logic flow.  Each pass through the active trap point will be\n traced on SYSPRINT, even if no dump is produced.\n\n                      Data Area Descriptions\n\n The following pages contain descriptions of the major data areas\n discussed in this paper.  They are based upon assembler language\n mapping macros which are not generally available.  Some of the\n mappings are available on the optional materials tape for the Data\n Facility Product (DFP), as component AAPVT, however (except for\n the CTGPL), they are PL/S mappings only.  In order to produce these\n mappings, the PL/S descriptions have been manually translated into\n assembler language.\n\n Offsets are shown in hex, and for equated bit settings, the\n assembled values are shown in hex.\n\n\n --------------------------------\n Author's note, September 4, 2004\n --------------------------------\n\n The original paper distributed through SHARE had mappings of several\n control blocks included at this point.  A small font was used in the\n paper, but the lines are too wide to fit in 80-character lines.  They\n are not included here in order to fit the record size in the CBT file.\n\n The mappings are included in file 689 in a member named PRINT, which\n is in TSO XMIT format.  To expand on an MVS system, execute the TSO\n command:\n\n   RECEIVE INDS(xxxx.FILE689.PDS(PRINT))\n\n and you'll get an FB-133 file which contains the correctly formatted\n data.\n\n Alternatively, the macros to map these data areas are in file 689.\n You can just run an assembly to expand them. Member CATMAP in this\n data set is a source module which can be assembled to do just that.\n\n Peter Sawyer\n With assistance of Dan Dalby\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSMSGS": {"ttr": 20234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x18\\x12/\\x01\\x18\\x12/ \\x00\\x00V\\x00V\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-02T00:00:00", "modifydate": "2018-05-02T20:00:57", "lines": 86, "newlines": 86, "modlines": 0, "user": "SOURCE"}, "text": "SYSMSGS  TITLE '- SYSMSGS  - Sample Code To Write To SYSMSGS'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     Assembly OPTCDE Table\n         SPLEVEL  SET=6            Specify OS/390 R2 MACRO Format\n         SYSSTATE ARCHLVL=2        Assembly Requires Z/Architecture\n         SYSSTATE OSREL=ZOSV1R13   Assembly Requires Z/OS 1.13 & Higher\n\n*\n* NOTE: The BASE Must NOT Be R12 As It's Used By IEFTB723\n*\n\nSYSMSGS  #START ,                  Start Procedure                     *\n               AMODE=CAP31,        Execute In 31-Bit AMode             *\n               RMODE=ANY,          Execute In Any RMode                *\n               BASE=(R11),         Define Base Register(s)             *\n               REG0=R0,            Save Input Parameter Address        *\n               REG1=R1,            Save Input Parameter Address        *\n               WKDSECT=SAMPWRK,    Define WorkArea Name                *\n               LOC=BELOW,          Indicate 24-Bit WorkArea            *\n               LEVEL=**TEST**      Maintenance Level\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Call IEFTB723 To Write To SYSMSGS                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MODESET KEY=ZERO,MODE=SUP\n\n         LOAD  EP=IEFTB723         Load Write-To-Programmer Routine\n         ST    R0,@TB723\n\n         USING PSA,0\n         L     R1,PSATOLD          A(TCB)\n         USING TCB,R1\n         ICM   R1,7,TCBTCT+1       A(TCT)\n         USING SMFTCT,R1\n         SLR   R2,R2\n         ICM   R2,7,TCTLCTAD+1     A(LCT)\n         LA    R12,0(,R2)\n         USING LCT,R12\n         LA    R1,TESTMSG+2        A(Message Text)\n         ST    R1,LCTPARM1         Set Address In LCT\n         LH    R15,TESTMSG         L(Message Text)\n         STH   R15,LCTPARM2+2      Set Length In LCT\n\n         L     R15,@TB723          Call IEFTB723 To\n         BASSM R14,R15             . Queue Message To SYSMSGS\n\n         DELETE EP=IEFTB723        Remove Write-To-Programmer Routine\n\n         MODESET KEY=NZERO,MODE=PROB\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Terminate                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #STOP ,                   Return To Caller\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Constants And Work Area                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nTESTMSG  DC    AL2(16),CL16'Test SYSMSG Text'\n\n         #STARTWA ,\n@TB723   DS    A\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTs                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #DSECTS PSA,TCB,TCT,LCT\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSOPARSE": {"ttr": 20483, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x01\\x01\\x160\\x7f\\x01\\x160\\x7f\\x12'\\x01\\xbc\\x01\\xbc\\x00\\x01\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-02T00:00:00", "modifydate": "2016-11-02T12:27:01", "lines": 444, "newlines": 444, "modlines": 1, "user": "SOURCE"}, "text": "TSOPARSE TITLE ' - \"IKJPARS\" / \"IKJSCAN\" SERVICE ROUTINE'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        \"IKJPARS\" / \"IKJSCAN\" SERVICE ROUTINE                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nTSOPARSE #START ,                  *** HOUSEKEEPING ***                *\n               AMODE=CAP24,        EXECUTE IN 24-BIT ADDRESSING MODE   *\n               BASE=(R12),         DEFINE BASE REGISTER(S)             *\n               LOC=BELOW,          INDICATE 24-BIT WORKAREA            *\n               PREFIX=PAR,         DEFINE MACRO LABEL PREFIX           *\n               REG0=R0,            SAVE INPUT PARAMETER ADDRESS        *\n               REG1=R6,            SAVE INPUT PARAMETER ADDRESS        *\n               RMODE=24,           EXECUTE IN 24-BIT RESIDENCY MODE    *\n               SP=0,               DEFINE WORKAREA SUBPOOL             *\n               SPLEVEL=2,          INDICATE XA/ESA MACRO LEVEL SUPPORT *\n               WKDSECT=PARSWRK     DEFINE WORKAREA NAME\n\n         USING PSA,0\n         USING PPL,R6\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PERFORM INITIALIZATION                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STC   R0,FUNCTION         SAVE CALLER SPECIFIED FUNCTION CODE\n         CLI   FUNCTION,0          CHECK FOR \"IKJSCAN\" FUNCTION\n         BE    PARS0100            B. IF YES\n         CLI   FUNCTION,4          CHECK FOR \"IKJPARS\" FUNCTION\n         BE    PARS0100            B. IF YES\n         EX    0,*                 ELSE. ABEND S0C3\n\nPARS0100 DS    0H\n         IPK   ,                   ACQUIRE CALLER'S PROTECT KEY\n         STC   R2,OLDKEY           SAVE PROTECT KEY\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CHECK IF CALLER IS IN SUPERVISOR STATE OR APF AUTHORIZED     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TESTAUTH STATE=YES,RBLEVEL=1\n         LTR   R15,R15             CHECK IF ALREADY IN SUPERVISOR STATE\n         BZ    PARS0200            B. IF YES\n\n         TESTAUTH FCTN=1\n         LTR   R15,R15             CHECK IF APF AUTHORIZED\n         BNZ   PARS0300            B. IF NOT\n\n         MODESET MODE=SUP          CHANGE TO SUPERVISOR STATE\n\n         OI    WRKFLAG1,WRK$PROB   INDICATE \"PROBLEM PROGRAM\" STATE\n\nPARS0200 DS    0H\n         OI    WRKFLAG1,WRK$AUTH   INDICATE \"AUTHORIZED\"\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ACQUIRE MISSING CONTROL BLOCKS IN KEY SAME KEY AS PLIST      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nPARS0300 DS    0H\n         L     R4,PSATOLD          LOAD TCB  ADDRESS\n         USING TCB,R4\n\n         IVSK  R1,R6               LOAD CPPL/CSPL PLIST KEY\n         SPKA  0(R1)               GET INTO APPROPRIATE KEY\n\n*-------\n*        ACQUIRE & INITIALIZE \"UPT\" IF NOT SUPPLIED\n*-------\n\n         ICM   R1,15,PPLUPT        CHECK IF \"UPT\" WAS SUPPLIED\n         BNZ   PARS0400            B. IF YES\n         GETMAIN RU,LV=UPTLNGTH,SP=0,LOC=BELOW\n         XC    0(UPTLNGTH,R1),0(R1) CLEAR ACQUIRED STORAGE\n         ST    R1,PPLUPT           SAVE ADDRESS IN CALLER'S PPL\n\nPARS0400 DS    0H\n         USING UPT,R1\n\n         MVC   SAVEUPTS,UPTSWS     SAVE UPT SWITCHES\n         MVI   UPTSWS,UPTNPRM+UPTNCOM+UPTMID+UPTWTP\n\n         DROP  R1\n\n*-------\n*        ACQUIRE & INITIALIZE \"ECT\" IF NOT SUPPLIED\n*-------\n\n         ICM   R1,15,PPLECT        CHECK IF \"ECT\" WAS SUPPLIED\n         BNZ   PARS0500            B. IF YES\n         GETMAIN RU,LV=ECTLEN,SP=1,LOC=BELOW\n         XC    0(ECTLEN,R1),0(R1)  CLEAR ACQUIRED STORAGE\n         ST    R1,PPLECT           SAVE ADDRESS IN CALLER'S PPL\n\nPARS0500 DS    0H\n         USING ECT,R1\n\n         MVC   SAVEECTS,ECTSWS     SAVE ECT SWITCHES\n         MVI   ECTSWS,ECTNMAL+ECTNNOT+ECTBKGRD\n         MVC   SAVEECT2,ECTSWS2    SAVE ECT SWITCHES\n         MVI   ECTSWS2,ECTDEFCS\n         DROP  R1\n\n*-------\n*        ACQUIRE & INITIALIZE \"ECB\" IF NOT SUPPLIED\n*-------\n\n         ICM   R0,15,PPLECB        CHECK IF \"ECB\" WAS SUPPLIED\n         BNZ   PARS0600            B. IF YES\n         GETMAIN RU,LV=4,SP=0,LOC=BELOW\n         XC    0(4,R1),0(R1)       CLEAR ACQUIRED STORAGE\n         ST    R1,PPLECB           SAVE ADDRESS IN CALLER'S PPL\n\n*-------\n*        ACQUIRE & INITIALIZE \"CSPL FLAG\" IF NOT SUPPLIED\n*-------\n\nPARS0600 DS    0H\n         CLI   FUNCTION,4          CHECK FOR \"IKJSCAN\" FUNCTION\n         BNE   PARS0800            B. IF NOT\n\n         USING CSPL,R6\n\n         ICM   R0,15,CSPLFLG       CHECK IF \"FLAG WORD\" WAS SUPPLIED\n         BNZ   PARS0700            B. IF YES\n         GETMAIN RU,LV=4,SP=1,LOC=BELOW\n         XC    0(4,R1),0(R1)       CLEAR ACQUIRED STORAGE\n         ST    R1,CSPLFLG          SAVE ADDRESS IN CALLER'S CSPL\n\n*-------\n*        ACQUIRE & INITIALIZE \"CSOA\" IF NOT SUPPLIED\n*-------\n\nPARS0700 DS    0H\n         ICM   R0,15,CSPLOA        CHECK IF \"OUPUT AREA\" WAS SUPPLIED\n         BNZ   PARS0800            B. IF YES\n         GETMAIN RU,LV=CSOALEN,SP=1,LOC=BELOW\n         XC    0(CSOALEN,R1),0(R1) CLEAR ACQUIRED STORAGE\n         ST    R1,CSPLOA           SAVE ADDRESS IN CALLER'S CSPL\n\n*-------\n*        ACQUIRE & INITIALIZE \"IOWA\" IF NOT SUPPLIED\n*-------\n\nPARS0800 DS    0H\n         L     R2,CSPLECT          LOAD ECT ADDRESS\n         USING ECT,R2\n         ICM   R1,15,ECTIOWA       CHECK IF \"I/O WORKAREA\" WAS SUPPLIED\n         BNZ   PARS0900            B. IF YES\n\n         GETMAIN RU,LV=IOSRLEN,SP=0,LOC=BELOW\n         XC    0(IOSRLEN,R1),0(R1) CLEAR ACQUIRED STORAGE\n         ST    R1,ECTIOWA          SAVE ADDRESS IN CALLER'S ECT\n\nPARS0900 DS    0H\n         LR    R2,R1               LOAD IOWA ADDRESS\n         USING IOSRL,R2\n\n*-------\n*        ACQUIRE & INITIALIZE \"STACK\"\n*-------\n\n         ICM   R0,15,IOSTELM       CHECK IF \"STACK ELEMENT\" EXISTS\n         BNZ   PARS1000            B. IF YES\n\n         GETMAIN RU,LV=INSLEN,SP=0,LOC=BELOW\n         XC    0(INSLEN,R1),0(R1)  CLEAR ACQUIRED STORAGE\n         ST    R1,IOSTELM          SAVE ADDRESS IN CALLER'S IOWA\n\n         DROP  R2\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ACQUIRE, INITIALIZE & ACTIVATE \"SVC SCREEN\" FOR TPUTS        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nPARS1000 DS    0H\n         TM    WRKFLAG1,WRK$AUTH   CHECK IF CALLER IS AUTHORIZED\n         BNO   PARS1100            B. IF NOT\n\n         SPKA  0                   GET INTO KEY ZERO\n\n         GETMAIN RU,LV=268,SP=254,LOC=BELOW\n         L     R0,=A(SCREEN)       LOAD SVC SCREEN ROUTINE ADDRESS\n         ST    R0,0(,R1)           SAVE ADDRESS IN SVC SCREEN TABLE\n         ST    R13,264(,R1)        SAVE WORKAREA ADDRESS\n         MVC   4(4,R1),=X'C0000000'\n         MVI   8(R1),X'80'         INSERT MASK TO ALLOW SVC\n         MVC   9(255,R1),8(R1)\n         MVI   8+93(R1),0          INSERT MAST TO INTERCEPT \"TPUT\"\n\n         ST    R1,TCBSVCA2         SAVE SVC TABLE ADDRESS\n         OI    TCBFLGS7,TCBSVCS    ACTIVATE THE SCREEN\n         OI    TCBFLGS7,TCBSVCSP\n\n         IC    R2,OLDKEY           LOAD CALLER'S PROTECT KEY\n         SPKA  0(R2)               RETURN TO ORIGINAL PROTECT KEY\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS THE INPUT BUFFER (CALL IKJSCAN OR IKJPARS)           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nPARS1100 DS    0H\n         LA    R15,CALLPARS        LOAD IKJPARS ROUTINE ADDRESS\n         CLI   FUNCTION,0          CHECK FOR \"PARSE\" FUNCTION\n         BE    PARS1200            B. IF YES\n         LA    R15,CALLSCAN        LOAD IKJSCAN ROUTINE ADDRESS\n\nPARS1200 DS    0H\n         IC    R2,OLDKEY           LOAD CALLER'S PROTECT KEY\n         SPKA  0(R2)               RETURN TO ORIGINAL PROTECT KEY\n\n         SYNCH (15),RESTORE=YES,AMODE=24,MF=(E,SYNCHL)\n\n         #SETRC ,                  SET RETURN CODE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DEACTIVATE AND RELEASE THE \"SVC SCREEN\"                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    WRKFLAG1,WRK$AUTH   CHECK IF CALLER IS AUTHORIZED\n         BNO   PARS1300            B. IF NOT\n\n         SPKA  0                   GET INTO KEY ZERO\n         NI    TCBFLGS7,FF-TCBSVCS DEACTIVATE THE SCREEN\n         NI    TCBFLGS7,FF-TCBSVCSP\n\n         L     R1,TCBSVCA2         LOAD SVC TABLE ADDRESS\n         XC    TCBSVCA2,TCBSVCA2   CLEAR TABLE POINTER IN TCB\n\n         FREEMAIN RU,LV=268,A=(R1),SP=254\n\n         IC    R2,OLDKEY           LOAD CALLER'S PROTECT KEY\n         SPKA  0(R2)               RETURN TO ORIGINAL PROTECT KEY\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RESTORE ORIGINAL CONTROL BLOCK FIELDS                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*-------\n*        RESTORE \"UPT\" SWITCHES\n*-------\n\nPARS1300 DS    0H\n         L     R1,CSPLUPT          LOAD UPT ADDRESS\n         USING UPT,R1\n\n         MVC   UPTSWS,SAVEUPTS     RESTORE UPT SWITCHES\n\n         DROP  R1\n\n*-------\n*        RESTORE \"ECT\" SWITCHES\n*-------\n\n         L     R1,CSPLECT          LOAD ECT ADDRESS\n         USING ECT,R1\n\n         MVC   ECTSWS,SAVEECTS     RESTORE ECT SWITCHES\n         MVC   ECTSWS,SAVEECT2     RESTORE ECT SWITCHES\n\n         DROP  R1\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TERMINATE                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    WRKFLAG1,WRK$PROB   CHECK IF CALLER WAS IN PROBLEM STATE\n         BNO   PARS1400            B. IF NOT\n\n         MODESET MODE=PROB         CHANGE BACK TO PROBLEM PROGRAM STATE\n\nPARS1400 DS    0H\n         IC    R2,OLDKEY           LOAD CALLER'S PROTECT KEY\n         SPKA  0(R2)               RETURN TO ORIGINAL PROTECT KEY\n\n         L     R1,WRKMSG1          LOAD 1ST MESSAGE ADDRESS\nPARSEXIT #STOP R1=(R1)             RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        TPUT SVC SCREEN SUBROUTINE                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  R12\n\n         USING CVT,R3\n         USING TCB,R4\n         USING RBBASIC,R5\n         USING SCREEN,R6\n         USING ASCB,R7\nSCREEN   DS    0H\n         L     R3,TCBSVCA2         LOAD SVC TABLE ADDRESS\n         L     R13,264(,R3)        LOAD WORKAREA ADDRESS\n         USING PARSWRK,R13\n\n         ST    R14,SAVER14         SAVE RETURN ADDRESS\n         STM   R0,R1,SAVER0        SAVE MESSAGE LENGTH & ADDRESS\n\n         IC    R2,OLDKEY           LOAD CALLER'S PROTECT KEY\n         SPKA  0(R2)               GET INTO CALLER'S KEY\n\n         LH    R1,SAVER0+2         LOAD LENGTH OF MESSAGE\n         LA    R1,8(,R1)           ADD CHAIN POINTER & RDW FIELDS\n         GETMAIN RU,LV=(R1),SP=1,LOC=BELOW\n         XC    0(8,R1),0(R1)       CLEAR HEADER SECTION\n         LR    R3,R1\n\n         SPKA  0                   RETURN TO KEY ZERO\n\n         ICM   R0,15,WRKMSG1       CHECK IF THIS IS THE 1ST MESSAGE\n         BNZ   SCREEN10            B. IF NOT\n         ST    R3,WRKMSG1          SAVE ADDRESS OF 1ST MESSAGE\n         B     SCREEN20\n\nSCREEN10 DS    0H\n         L     R2,WRKMSGS          LOAD PREVIOUS CHAIN POINTER ADDRESS\n         ST    R3,0(,R2)           ADD NEW MESSAGE TO THE CHAIN\n\nSCREEN20 DS    0H\n         LA    R0,0(,R3)           LOAD CURRENT MESSAGE CHAIN POINTER\n         ST    R0,WRKMSGS          SAVE FOR NEXT MESSAGE\n\n         L     R1,SAVER1           LOAD CURRENT MESSAGE TEXT ADDRESS\n         LH    R2,SAVER0+2         LOAD CURRENT MESSAGE TEXT LENGTH\n         STH   R2,4(,R3)           SAVE MESSAGE LENGTH IN RDW\n         BCTR  R2,0                DECREMENT FOR EXECUTE\n         #EXEC R2,MVC,8(*-*,R3),0(R1)\n\n         SLR   R15,R15             SET RETURN CODE\n         L     R14,SAVER14         RESTORE RETURN ADDRESS\n         BR    R14                 RETURN TO SVC FLIH\n\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IKJPARS LINKAGE ROUTINE                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  R12\n\nCALLPARS DS    0H\n         LR    R12,R15             LOAD BASE REGISTER\n         USING CALLPARS,R12\n\n         #MODE 31\n         CALLTSSR EP=IKJPARS,      CALL TSO PARSE ROUTINE              *\n               MF=(E,(R6))\n         #MODE 24\n         SVC   3                   RETURN TO CALLER\n\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IKJSCAN LINKAGE ROUTINE                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING\n         DROP  R12\n\nCALLSCAN DS    0H\n         LR    R12,R15             LOAD BASE REGISTER\n         USING CALLSCAN,R12\n\n         #MODE 31\n         CALLTSSR EP=IKJSCAN,      CALL TSO SCAN ROUTINE               *\n               MF=(E,(R6))\n         #MODE 24\n         SVC   3                   RETURN TO CALLER\n\n         POP   USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONSTANTS AND WORK AREA                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #STARTWA ,\nWRKFLAG1 DC    X'00'               FLAG BYTE #1\nWRK$AUTH EQU   BIT0                - AUTHORIZED PROGRAM\nWRK$PROB EQU   BIT1                - PROBLEM PROGRAM\nFUNCTION DC    X'0'                FUNCTION CODE\nOLDIOWA@ DC    A(*-*)              INITIAL IOWA ADDRESS\nOLDKEY   DC    X'0'                CALLER'S PSW PROTECT KEY\nSAVEECTS DC    XL(L'ECTSWS)'0'     SAVE AREA FOR ECTSWS\nSAVEECT2 DC    XL(L'ECTSWS2)'0'    SAVE AREA FOR ECTSWS2\nSAVER0   DC    F'0'                REGISTER  0 SAVE AREA\nSAVER1   DC    F'0'                REGISTER  1 SAVE AREA\nSAVER14  DC    F'0'                REGISTER 14 SAVE AREA\nSAVEUPTS DC    XL(L'UPTSWS)'0'     SAVE AREA FOR UPTSWS\nSYNCHL   SYNCH MF=L                SYNCH PARAMETER LIST\nWRKMSGS  DC    A(*-*)              MESSAGE CHAIN WORD ADDRESS\nWRKMSG1  DC    A(*-*)              ADDRESS OF 1ST MESSAGE\n         #STOPWA ,\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         #IOSRL ,                  I/O SERVICE ROUTINE WORK AREA\nIOSRLEN  EQU   *-IOSRL\n\n         #INSTACK ,                STACK ELEMENT\nINSLEN   EQU   *-INSTACK\n\n         #DSECTS ASCB,CSOA,CSPL,CVT,ECT,PPL,PSA,RB,TCB,UPT\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ULUTSCAN": {"ttr": 20491, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x01P\\x01P\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 336, "newlines": 336, "modlines": 0, "user": "SOURCE"}, "text": "TOOL     TITLE '- ULUTSCAN - UCB Scan using ULUT table'\n*---------------------------------------------------------------------*\n*                 |                                                   *\n* U L U T S C A N |         General UCB Scan Routine using            *\n*                 |         The \"ULUT\" Table.                         *\n*------------------                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Function: Scan the \"ULUT\" table one entry at a time.             *\n*                                                                     *\n*        Note: A long time ago Gilber Saint-Flour discovered the      *\n*              ULUT table and used it to create an unauthorized       *\n*              method of scanning the UCBs.  In z/OS 2.2 the ULUT     *\n*              was moved to 64-bit storage.                           *\n*              This routine continues Gilbert's legacy.               *\n*                                                                     *\n*              Be aware that the UCBs are NOT pinned and could be     *\n*              relocated at any time if the IODF is updated during    *\n*              the scan.                                              *\n*                                                                     *\n*              Read additional notes on the ULUT in CBT file 731.     *\n*                                                                     *\n*       Parms: R1 = Work Area Address                                 *\n*                                                                     *\n*  Exit Codes:  0 - UCB Found and returned in R1                      *\n*               8 - UCB Not Found                                     *\n*                                                                     *\n* Register Usage:   R0 - Work Register                                *\n*                   R1 - Work Register                                *\n*                   R2 - Work Register                                *\n*                   R3 - Work Register                                *\n*                   R4 - Work Register                                *\n*                   R5 - Current UCB Address                          *\n*                   R6 - Scan Return Code                             *\n*                   R7 - Not Used                                     *\n*                   R8 - Input Parameter List                         *\n*                   R9 - Not Used                                     *\n*                  R10 - Not Used                                     *\n*                  R11 - Not Used                                     *\n*                  R12 - Constants Base Register                      *\n*                  R13 - Work Area Base Register                      *\n*                  R14 - Return Address                               *\n*                  R15 - Return Code                                  *\n*                                                                     *\n*    Macros: #CON     #DSECTS  #START   #STARTWA #STOP    #STOPWA     *\n*            ASAXWC   CVT      ECVT     IECDIOCM IEFUCBOB IOSDIOVT    *\n*            IOSDULUT IOSDULU2 IOSDULU3 STORAGE                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*     History: #DD15008 - Jan 08,2015 -  Created.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         SYSSTATE AMODE64=YES      Have The Macros Expand Correctly\n\nULUTSCAN #START ,                  Start Routine                       *\n               AMODE=31,           . Amode(31)                         *\n               RMODE=ANY,          . Rmode(any)                        *\n               BASE=RELATIVE,      . Use Relative Addressing           *\n               CONSTANT=R12,       . Base For Constants And Literals   *\n               COPY=YES,                                               *\n               REG1=R8,            . Save Passed R1                    *\n               USING=(ULUPARM,R8), . Address Parameter List Area       *\n               WKDSECT=WRKSCAN,    . WorkArea Name                     *\n               LOC=BELOW,          . Obtain 24-bit WorkArea Storage    *\n               STORAGE=Y,          . Use \"Storage\" vs \"Getmain\"        *\n               LEVEL=#V015008      Maintenance Level           #DD15008\n         USING PSA,0\n\n         SAM64 ,                   Ensure 64-Bit Mode\n\n         LLGTR R12,R12             Ensure Clean 64-Bit Constant Base\n         LLGTR R13,R13             Ensure Clean 64-Bit Workarea Base\n         LLGTR R8,R8               Ensure Clean 64-Bit Parameter Base\n\n         SLGR  R6,R6               Initialize Return Code\n\n         LLGF  R2,FLCCVT           A(CVT)\n         USING CVT,R2\n         LLGF  R3,CVTIXAVL         A(IOCOM)\n         USING IOCOM,R3\n         LLGF  R3,IOCIOVTP         A(IOS Vector Table)\n         USING IOVT,R3\n\n         MVC   WRKDEVN,ULUDEVN     Save Starting Device Number\n         MVC   ULUDEVNC,BLANKS     Initialize Output Character UCB\n\n         LLGF  R3,IOVTUL31         UCB Lookup Table (31-Bit)\n         LTGR  R3,R3               Check For 31-Bit ULUT\n         JNZ   SCAN0100            B. If 31-Bit Table Exists\n         LG    R3,IOVTULUT         UCB Lookup Table (64-Bit)\n\nSCAN0100 DS    0H\n         CLC   0(4,R3),=C'ULUT'    Check Eyecatcher\n         JE    SCAN0300            B. If Acceptable\n         J     SCAN2400            Else. Invalid ULUT\n         USING ULUT,R3\nSCAN0300 DS    0H\n         CLI   ULUTVERS,1          Check For Type 1 Lookup Table\n         JE    SCAN0400\n         CLI   ULUTVERS,2          Check For Type 2 Lookup Table\n         JE    SCAN0500\n         CLI   ULUTVERS,3          Check For Type 3 Lookup Table\n         JE    SCAN0600\n         J     SCAN2400            Else. Invalid ULUT\n         DROP  R3\n\n*        Type 1 ULUT Processing\n         USING ULUT,R3\nSCAN0400 DS    0H\n         LG    R0,ULUCOUNT         #(Previous Entries)\n         LG    R1,ULUUCB           A(Previous Table Entry)\n         CG    R1,ZEROS            Check If Scan In Progress\n         JNZ   SCAN2100            B. If Yes\n         LLGF  R4,ULUTUCBC         #(Table Entries)\n         LLGF  R3,ULUT1ST          A(1st Table Entry)\n         J     SCAN0700\n         DROP  R3\n\n*        Type 2 ULUT Processing\n         USING ULU2,R3\nSCAN0500 DS    0H\n         LG    R0,ULUCOUNT         #(Previous Entries)\n         LG    R1,ULUUCB           A(Previous Table Entry)\n         CG    R1,ZEROS            Check If Scan In Progress\n         JNZ   SCAN2100            B. If Yes\n         LLGF  R4,ULU2UCBC         #(Table Entries)\n         LLGF  R3,ULU21ST          A(1st Table Entry)\n         J     SCAN0700\n         DROP  R3\n\n*        Type 3 ULUT Processing\n         USING ULU3,R3\nSCAN0600 DS    0H\n         LG    R0,ULUCOUNT         #(Previous Entries)\n         LG    R1,ULUUCB           A(Previous Table Entry)\n         CG    R1,ZEROS            Check If Scan In Progress\n         JNZ   SCAN2100            B. If Yes\n         LLGF  R4,ULU3UCBC         #(Table Entries)\n         LG    R3,ULU31ST          A(1st Table Entry)\n         DROP  R3\n\n*-------\n*        Check For User Specified Filtering\n*-------\n         USING ULUENTRY,R3\nSCAN0700 DS    0H\n         SLGR  R5,R5\n         ICM   R5,15,ULUEUCBP      A(This Unit's UCB)\n         JZ    SCAN2300\n         USING UCBOB,R5\n\n         CLC   UCBCHAN,ULUDEVN     Check For Starting Device Number\n         JL    SCAN2200            B. If Current Is Too Low\n\n         CLI   ULUFLAG1,0          Check For Status/Device Filtering\n         JNE   SCAN0800            B. If Yes\n         TM    ULUVOL,X'BF'        Check For VOLSER= Filtering\n         JNZ   SCAN0800            B. If Yes\n         J     SCAN2500            Else. No Filtering\n\n*        STATUS=ONLINE\nSCAN0800 DS    0H\n         TM    ULUFLAG1,ULU$ONL    Check For \"Online\" Filter\n         JZ    SCAN0900            B. If Not\n         TM    UCBSTAT,UCBONLI     Check If Device Is Online\n         JZ    SCAN2200            B. If Not\n\n*        DEVCLASS=TAPE\nSCAN0900 DS    0H\n         TM    ULUFLAG1,ULU$ALL    Check For Any DEVCLASS Filter\n         JZ    SCAN1600            B. If Not\n         TM    ULUFLAG1,ULU$TAPE   Check For \"Tape\" Filter\n         JZ    SCAN1000            B. If Not\n         TM    UCBTBYT3,UCB3TAPE   Check For Tape Device\n         JZ    SCAN2200            B. If Not\n*        DEVCLASS=COMM\nSCAN1000 DS    0H\n         TM    ULUFLAG1,ULU$COMM   Check For \"Comm\" Filter\n         JZ    SCAN1100            B. If Not\n         TM    UCBTBYT3,UCB3COMM   Check For Communications Device\n         JZ    SCAN2200            B. If Not\n*        DEVCLASS=DASD\nSCAN1100 DS    0H\n         TM    ULUFLAG1,ULU$DASD   Check For \"DASD\" Filter\n         JZ    SCAN1200            B. If Not\n         TM    UCBTBYT3,UCB3DACC   Check For DASD Device\n         JZ    SCAN2200            B. If Not\n*        DEVCLASS=DISP\nSCAN1200 DS    0H\n         TM    ULUFLAG1,ULU$DISP   Check For \"Disp\" Filter\n         JZ    SCAN1300            B. If Not\n         TM    UCBTBYT3,UCB3DISP   Check For Display Device\n         JZ    SCAN2200            B. If Not\n*        DEVCLASS=UREC\nSCAN1300 DS    0H\n         TM    ULUFLAG1,ULU$UREC   Check For \"URec\" Filter\n         JZ    SCAN1400            B. If Not\n         TM    UCBTBYT3,UCB3UREC   Check For Unit Record Device\n         JZ    SCAN2200            B. If Not\n*        DEVCLASS=CHAR\nSCAN1400 DS    0H\n         TM    ULUFLAG1,ULU$UREC   Check For \"Char\" Filter\n         JZ    SCAN1500            B. If Not\n         TM    UCBTBYT3,UCB3CHAR   Check For Character Reader Device\n         JZ    SCAN2200            B. If Not\n*        DEVCLASS=CTC\nSCAN1500 DS    0H\n         TM    ULUFLAG1,ULU$CTC    Check For \"CTC\" Filter\n         JZ    SCAN1600            B. If Not\n         TM    UCBTBYT3,UCB3CTC    Check For Channel-To-Channel Device\n         JZ    SCAN2200            B. If Not\n\n*        VOLSER=\nSCAN1600 DS    0H\n         TM    ULUVOL,X'BF'        Check For \"VOLSER=\" Filter\n         JZ    SCAN2500            B. If Not\n         TM    UCBVOLI,X'BF'       Check If UCB Has A Volser\n         JZ    SCAN2200            B. If Not\n         SAM31 ,                   Ensure 31-Bit Mode\n\n         LA    R0,ULUVOL           A(Start Of VOLSER)\n         LA    R1,ULUVOL+5         A(Last Byte Of VOLSER)\nSCAN1700 DS    0H\n         TM    0(R1),X'BF'         Check For End Of Volser\n         JNZ   SCAN1800            B. If End Found\n         BRCT  R1,SCAN1700         Loop Till End Found\nSCAN1800 DS    0H\n         AHI   R1,1                A(End Of Volser)\n         SR    R1,R0               Calculate Length\n         ST    R1,WRKPLEN          Save Pattern Volser Length\n\n         LA    R0,UCBVOLI          A(Start Of VOLSER)\n         LA    R1,UCBVOLI+5        A(Last Byte Of VOLSER)\nSCAN1900 DS    0H\n         TM    0(R1),X'BF'         Check For End Of Volser\n         JNZ   SCAN2000            B. If End Found\n         BRCT  R1,SCAN1900         Loop Till End Found\nSCAN2000 DS    0H\n         AHI   R1,1                A(End Of Volser)\n         SR    R1,R0               Calculate Length\n         ST    R1,WRKSLEN          Save String Volser Length\n\n         ASAXWC PATTERNSTR=ULUVOL,                                     *\n               PATTERNSTRLEN=WRKPLEN,                                  *\n               STRING=UCBVOLI,                                         *\n               STRINGLEN=WRKSLEN,                                      *\n               ZEROORMORE=STAR,                                        *\n               ONECHAR=ANYCHAR,                                        *\n               DELIMITER=LENGTHS_WERE_SET,                             *\n               RETCODE=WRKRCODE,                                       *\n               WORKAREA=WRKPATWA,                                      *\n               MF=(E,WKASAXWC)\n\n         SAM64 ,                   Ensure 64-Bit Mode\n         LLGF  R15,WRKRCODE        Load Return Code\n         LTR   R15,R15             Check For Matching Volser / Mask\n         JNZ   SCAN2200            B. If Not\n         J     SCAN2500\n\nSCAN2100 DS    0H\n         LGR   R3,R1               A(Previous ULUT Entry)\n         LGR   R4,R0               #(Previous ULUT Entries)\n\nSCAN2200 DS    0H\n         LA    R3,ULUELEN(,R3)     A(Next ULUT Entry)\n         BRCT  R4,SCAN0700         Loop Till End Of UCBs\n\nSCAN2300 DS    0H\n         SLGR  R3,R3\n         SLGR  R4,R4\n         SLGR  R6,R6\n         LHI   R6,8                Indicate End-Of-UCBs\n         J     SCANEXIT\n\nSCAN2400 DS    0H\n         SLGR  R3,R3\n         SLGR  R4,R4\n         SLGR  R6,R6\n         LHI   R6,12               Indicate Invalid \"ULUT\"\n         J     SCANEXIT\n\nSCAN2500 DS    0H\n         MVC   ULUDEVN,UCBCHAN     Save Device Number (Hex)\n         UNPK  WRKDBL1(5),UCBCHAN(3)\n         TR    WRKDBL1(4),HEXTABLE\n         MVC   ULUDEVNC,WRKDBL1    Save Device Number (Char)\n\nSCANEXIT DS    0H\n         STG   R3,ULUUCB\n         STG   R4,ULUCOUNT\n\n         ST    R6,ULURETCD\n         DROP  R3,R5\n\n         SAM31 ,                   Ensure 31-Bit Mode\n         #STOP R0=(R4),R1=(R5),RC=(R6)\n\n         #CON  START               Constants Area\n         LTORG ,\nANYCHAR  DC    CL1'?'              Mask - Single Character\nBLANKS   DC    CL8' '\nHEXTABLE DC    256x'00'\n         ORG   HEXTABLE+C'0'\n         DC    C'0123456789ABCDEF' HEX Conversion Table\n         ORG   ,\nSTAR     DC    CL1'*'              Mask - One Or More\nZEROS    DC    D'0'                Zeros\n         #CON  END\n\n         #STARTWA ,                Dynamic WorkArea\n         ASAXWC MF=(L,WKASAXWC)    ASAXWC Parameter List\nWRKDBL1  DS    D                   DBLWORD Work Area\nWRKDBL2  DS    D                   DBLWORD Work Area\nWRKDEVN  DS    H                   Input Starting Device Number\nWRKPLEN  DS    F                   ASAXWC Pattern Length\nWRKSLEN  DS    F                   ASAXWC String Length\nWRKRCODE DS    F                   ASAXWC Return Code\nWRKPATWA DS    XL256               ASAXWC Work Area\n         #STOPWA ,\n\n         ULUPARM ,                 ULUTSCAN Parameter List\n\n         #DSECTS CVT,IOCOM,PSA,UCB,LIST=YES\n         AIF   (D'CVTZOS_V2R2).GOTCVT  Check If Already Defined\nCVTZOS_V2R2   EQU X'40'      z/OS V2R2                             @NQA\n.GOTCVT  ANOP  ,\n         IOSDIOVT ,                IOVT Mapping\n         IOSDULUT ,                UCB Look-Up Table\n         IOSDULU2 ,                UCB Look-Up Table (Version 2)\n         IOSDULU3 ,                UCB Look-Up Table (Version 3)\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ULUTTEST": {"ttr": 20741, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x00>\\x00>\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:27", "lines": 62, "newlines": 62, "modlines": 0, "user": "SOURCE"}, "text": "*---------------------------------------------------------------------*\n*                                                                     *\n*        This TEST routine will return ALL units for ONLINE DASD      *\n*        devices with a volser beginning with Z.                      *\n*                                                                     *\n*---------------------------------------------------------------------*\nULUTTEST #START ,                  Start Procedure                     *\n               AMODE=31,           Execute In 31-Bit AMode             *\n               RMODE=ANY,          Execute In Any RMode                *\n               BASE=(R12),         Define Base Register                *\n               COPY=YES,                                               *\n               PREFIX=TST,         Define Variable Prefix              *\n               WKDSECT=WRKTEST,    Define WorkArea Name                *\n               LOC=BELOW,          Indicate 24-Bit WorkArea            *\n               LEVEL=**TOOL**      Maintenance Level           #DD15008\n\n         XC    WRKPARM,WRKPARM     Initialize Parameter List\nTEST0100 DS    0H\n         LA    R6,=CL6'Z*'         Testing Register Input\n         LA    R7,WRKPARM          Testing Register Input\n\n         ULUTSCAN DEVCLASS=DASD,   Search For DASD Devices Only        *\n               STATUS=ONLINE,      Search For ONLINE Devices           *\n               VOLSER=(R6),        Search For Volumes With \"Z\" Prefix  *\n               LINKAGE=SYSTEM,     LINK To ULUTSCAN Routine            *\n               MF=(E,(R7))\n         LTR   R15,R15             Check For End Of UCBS\n         BNZ   ULUTEXIT            B. If All Done\n\n         MVI   WRKMSG,C' '\n         MVC   WRKMSG+1(WRKMSGL-1),WRKMSG\n\n         LR    R3,R1               A(Returned UCB)\n         USING UCBOB,R3\n\n         MVC   WRKDEV#,ULUDEVNC-ULUPARM+WRKPARM\n         UNPK  WRKDEVT(9),UCBTYP(5)\n         TR    WRKDEVT(8),TESTHEX-C'0'\n         MVI   WRKDEVT+8,C' '\n         MVC   WRKVOLS,UCBVOLI\n         DROP  R3\n\n         TPUT  WRKMSG,WRKMSGL      Send Message To Terminal\n         B     TEST0100\n\nULUTEXIT #STOP ,                   RETURN TO CALLER\n\nTESTHEX  DC    C'0123456789ABCDEF'\n\n         #STARTWA ,\nWRKPARM  DS    25F                 Work Area\n\nWRKMSG   DS    0F\nWRKDEV#  DS    CL4,CL1             Device Number\nWRKDEVT  DS    CL8,CL1             Device Type\nWRKVOLS  DS    CL6,CL1             Volume Serial\nWRKMSGL  EQU   *-WRKMSG\n         #STOPWA ,\n\n         #DSECTS UCB\n         ULUPARM ,                 ULUTSCAN Parameter List\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USERICLI": {"ttr": 20743, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x12!O\\x01\\x12!O\\x15&\\x00\\x98\\x00\\x98\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-08-01T00:00:00", "modifydate": "2012-08-01T15:26:29", "lines": 152, "newlines": 152, "modlines": 0, "user": "CLIST"}, "text": "PROC 0 TEST\n/*\n/* DISPLAY THE VARIABLES CREATED BY THE USERINFO PROGRAM.\n/*\nUSERINFO SETV\nWRITENR ACCOUNT ----------------> &SYSACCT\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSACCT))\nWRITENR RACF USERID ------------> &SYSRUSR\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSRUSR))\nWRITENR RACF GROUP -------------> &SYSRGRP\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSRGRP))\nWRITENR CPU SERIAL NUMBER ------> &SYSCPID\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSCPID))\nWRITENR DF/DSS LEVEL -----------> &SYSDSSL\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSDSSL))\nWRITENR SCP FMID ---------------> &SYSFMID\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSFMID))\nWRITENR IODF SUFFIX ------------> &SYSIODF\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSIODF))\nWRITENR LAST IPL DATE ----------> &SYSIPLD\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSIPLD))\nWRITENR LAST IPL TIME ----------> &SYSIPLT\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSIPLT))\nWRITENR SYSRES UCB ADDRESS -----> &SYSIPLU\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSIPLU))\nWRITENR SYSRES VOLUME SERIAL ---> &SYSIPLV\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSIPLV))\nWRITENR JOB NUMBER -------------> &SYSJOB#\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSJOB#))\nWRITENR JOB NAME ---------------> &SYSJOBN\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSJOBN))\nWRITENR MASTER CATALOG NAME ----> &SYSMCAT\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSMCAT))\nWRITENR CPU PROCESSING MODE ----> &SYSMODE\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSMODE))\nWRITENR CPU MODEL NUMBER -------> &SYSMODL\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSMODL))\nWRITENR PROGRAMMER NAME --------> &SYSPGMR\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSPGMR))\nWRITENR REQUESTED REGION SIZE --> &SYSREGN\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSREGN))\nWRITENR SCP RELEASE/LEVEL ------> &SYSREL#\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSREL#))\nWRITENR SCP PRODUCT NAME -------> &SYSSCPN\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSSCPN))\nWRITENR SYSTEM SMF ID ----------> &SYSSMFI\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSSMFI))\nWRITENR SYSTEM NAME ------------> &SYSSNAM\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSSNAM))\nWRITENR SUBSYSTEM NAME ---------> &SYSSSNM\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSSSNM))\nWRITENR TERMINAL TYPE ----------> &SYSTERM\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSTERM))\nWRITENR TERMINAL ID ------------> &SYSTMID\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSTMID))\nWRITENR USER ID ----------------> &SYSUSER\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSUSER))\nWRITENR USER SCP VERSION ID ----> &SYSVERS\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSVERS))\nWRITENR DAY OF THE WEEK --------> &SYSWDAY\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSWDAY))\nWRITE\nWRITE IEASYM00 VALUES:\nWRITENR SYSALVL ----------------> &SYSALVL\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSALVL))\nWRITENR SYSCLONE ---------------> &SYSCLONE\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSCLONE))\nWRITENR SYSNAME ----------------> &SYSNAME\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSNAME))\nWRITENR SYSPLEX ----------------> &SYSPLEX\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSPLEX))\nWRITENR SYSR1 ------------------> &SYSR1\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSR1))\nWRITENR SYSR2 ------------------> &SYSR2\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSR2))\nWRITENR SYSR3 ------------------> &SYSR3\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&SYSR3))\nWRITENR UNIXVER ----------------> &UNIXVER\nIF &STR(&TEST) = &STR() -\n THEN WRITE\n ELSE WRITE &STR(-) &LENGTH(&STR(&UNIXVER))\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "USERINFO": {"ttr": 20747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x19 \\x8f\\x01\\x19 \\x8f\"\\x02\\x04[\\x04[\\x04[\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-07-27T00:00:00", "modifydate": "2019-07-27T22:02:31", "lines": 1115, "newlines": 1115, "modlines": 1115, "user": "SOURCE"}, "text": "USERINFO TITLE '- PASS TSO USER INFORMATION TO CLIST VIA &&SYSCMD OR VI*\n                A SYMBOLIC SYSTEM VARIABLES'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n***********************************************************************\n*                                                                     *\n*   FUNCTION: PASS USER INFO TO CLIST VIA SYMBOLIC VARIABLES          *\n*                                                                     *\n*   THE SUPPORTED VARIABLES ARE:                                      *\n*       ACCT  - JOB CARD ACCOUNTING INFORMATION                       *\n*       CPID  - CPU SERIAL NUMBER                                     *\n*       DSSL  - DF/DSS RELEASE/VERSION                                *\n*       FMID  - SCP SMP FMID                                          *\n*       IODF  - ACTIVE I/O CONFIGURATION                              *\n*       IPLD  - LAST IPL DATE                                         *\n*       IPLT  - LAST IPL TIME                                         *\n*       IPLU  - IPL SYSRES UNIT ADDRESS                               *\n*       IPLV  - IPL SYSRES VOLUME SERIAL                              *\n*       JOB#  - CURRENT JOB NUMBER (TSU 1234)                         *\n*       JOBN  - CURRENT JOB NAME                                      *\n*       MCAT  - MASTER CATALOG NAME                                   *\n*       MODE  - SYSTEM EXECUTION MODE (XA OR 370)                     *\n*       MODL  - CPU MODEL NUMBER (IE. 3083)                           *\n*       PGMR  - PROGRAMMER NAME                                       *\n*       REGN  - USER'S REQUESTED REGION SIZE                          *\n*       REL#  - SCP RELEASE/LEVEL NUMBER                              *\n*       RGRP  - RACF GROUP                                            *\n*       RUSR  - RACF USER                                             *\n*       SCPN  - SCP PRODUCT NAME                                      *\n*       SMFI  - SMF IDENTIFIER FOR THIS SYSTEM                        *\n*       SNAM  - SYSTEM IDENTIFIER                                     *\n*       SSNM  - SUBSYSTEM NAME (JES2)                                 *\n*       TERM  - TERMINAL TYPE                                         *\n*       TMID  - TERMINAL ID                                           *\n*       USER  - CURRENT USERID                                        *\n*       VERS  - USER SCP VERSION IDENTIFIER                           *\n*       WDAY  - DAY OF THE WEEK                                       *\n*                                                                     *\n*   THE SYMBOLS DECLARED IN IEASYMXX WILL ALSO BE CREATED.            *\n*   IF ANY OF THESE SYMBOLS ARE DUPLICATES OF THE STANDARD \"USERINFO\" *\n*   SYMBOLS, THE IEASYMXX SYMBOLS WILL PREVAIL.                       *\n*                                                                     *\n*   FUNCTION:                                                         *\n*   THIS COMMAND IS USED TO OBTAIN USER & SYSTEM INFORMATION FROM     *\n*   WITHIN A COMMAND PROCEDURE (CLIST).  SYSXXXX VARIABLES ARE        *\n*   CREATED, AND IF AN OPTION IS SPECIFIED, THE CORRESPONDING         *\n*   INFORMATION IS INSERTED INTO THE &SYSSCMD VARIABLE.  AS THE       *\n*   &SYSSCMD VARIABLE REPRESENTS THE LAST SUBCOMMAND NAME, THE        *\n*   VARIABLE'S INFORMATION MUST BE USED IMMEDIATELY AFTER INVOKING    *\n*   USERINFO, OR COPIED TO ANOTHER VARIABLE OF THE USER'S CHOICE.     *\n*                                                                     *\n*   EXTERNAL ROUTINES: IKJCT441                                       *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*   AN EXAMPLE OF A CLIST WHICH USES USERINFO:                        *\n*                                                                     *\n*   PROC 0                                                            *\n*   USERINFO ACCT                                                     *\n*   SET &A EQ &SYSSCMD                                                *\n*   WRITE USERID &SYSUID - ACCOUNT:&SYSACCT TERMINAL:&SYSTMID         *\n*                                                                     *\n*   OR                                                                *\n*                                                                     *\n*   PROC 0                                                            *\n*   USERINFO                                                          *\n*   WRITE USERID &SYSUID ACCOUNT &SYSACCT                             *\n*                                                                     *\n*        #DD99252 - ALLOW FOR 4 BYTE UCB ADDRESS                      *\n*        #DD99328 - ADD SYSTEM SYMBOLS DECLARED IN IEASYMXX           *\n*        #DD00053 - ADD MASTER CATALOG NAME                           *\n*        #DD00089 - ADD RACF USER & GROUP NAMES                       *\n*        #DD01215 - ADD IODF SUFFIX                                   *\n*        #DD01254 - FIX DF/DSS LEVEL                                  *\n*        #DD02310 - FIX ACCESS TO UCB (AMODE=31)                      *\n*        #DD02316 - CONVERT MODULE TO AMODE=31 & RMODE=ANY            *\n*        #DD10356 - CLEAR SYMBOL VARIABLE DATA AREA                   *\n*        #DD12214 - ADD IKJCT441 RETURN CODE MESSAGE.                 *\n*        #DD19130 - ADD SYSNODE.                                      *\n*                                                                     *\n***********************************************************************\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\n*        Note:\n*          JES3 Users can remove the following lines and SYSNODE\n\n         COPY  $HASPGBL                                        #DD19130\nDSECTS   $MODULE ENVIRON=JES2,                                 #DD19130*\n               TITLE='REQUIRED JES2 DSECTS',                   #DD19130*\n               $HASPEQU,           REQUIRED BY DSECTS          #DD19130*\n               $CADDR,             REQUIRED BY DSECTS          #DD19130*\n               $MIT,               REQUIRED BY DSECTS          #DD19130*\n               $MITETBL,           REQUIRED BY DSECTS          #DD19130*\n               $PADDR,             REQUIRED BY DSECTS          #DD19130*\n               $PARMLST,           REQUIRED BY DSECTS          #DD19130*\n               $PSV,               REQUIRED BY DSECTS          #DD19130*\n               $USERCBS,           REQUIRED BY DSECTS          #DD19130*\n               $HFAME,             REQUIRED BY DSECTS          #DD19130*\n               $SCAT,              REQUIRED BY DSECTS          #DD19130*\n               $XECB,              REQUIRED BY DSECTS          #DD19130*\n               $HCCT               HASP COMMON TABLE           #DD19130\n         $MODEND ,                                             #DD19130\n         TITLE ' '                                             #DD19130\n         PRINT GEN                                             #DD19130\n\n         GBLB  &REGS##(3)\n&REGS##(3) SETB 1\n\nUSERINFO #START BASE=(R12,R11),                                #DD00053*\n               #REGS=NONE,                                     #DD19130*\n               AMODE=31,RMODE=ANY,                             #DD02316*\n               WKDSECT=USERWORK,SP=0,LOC=BELOW,                #DD12214*\n               REG1=R10,USING=(CPPL,R10,PSA,0),                #DD00053*\n               APARS=,COPY=YES,                                        *\n               LEVEL=V001R11                                   #DD19130\n         L     R9,CPPLECT          LOAD ECT ADDRESS\n         USING ECT,R9\n\n*-------\n*        INITIALIZE WORKAREA\n*-------\n         XC    CPECB,CPECB         CLEAR ECB\n         LA    R15,GFPARMS         LOAD IKJEFF19 PLIST ADDRESS\n         ST    R15,JEFF19@\n         LA    R15,TSVEUPDT        LOAD ENTRY CODE\n         ST    R15,ECODE\n         LA    R15,ECODE           LOAD ENTRY CODE ADDRESS\n         ST    R15,CVAREC@\n         MVC   VARNAME,=CL7'SYSXXXX'\n         LA    R15,VARNAME         LOAD VARIABLE NAME ADDRESS\n         ST    R15,VARNAME@\n         LA    R15,VARNAME@        LOAD VARIABLE NAME POINTER ADDRESS\n         ST    R15,CVARNPT@\n         MVC   NAMELEN,=F'7'       INITIALIZE VARIABLE NAME LENGTH\n         LA    R15,NAMELEN         LOAD VARIABLE NAME LENGTH  ADDRESS\n         ST    R15,CVARNLN@\n         LA    R15,VARDATA         LOAD VARIABLE DATA ADDRESS\n         ST    R15,VARDATA@\n         LA    R15,VARDATA@        LOAD VARIABLE DATA POINTER ADDRESS\n         ST    R15,CVARDPT@\n         LA    R15,DATALEN         LOAD VARIABLE DATA LENGTH  ADDRESS\n         ST    R15,CVARDLN@\n         LA    R15,TOKEN           LOAD TOKEN ADDRESS\n         O     R15,=X'80000000'    INDICATE END OF PARAMETER LIST\n         ST    R15,CVARTKN@\n\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         L     R15,CVTTVT          LOAD TVT ADDRESS\n         USING TSVT,R15\n         L     R15,TSVTVACC        LOAD IKJCT441 ADDRESS\n         DROP  R15\n         ST    R15,CLISTRTN\n\n*-------\n*        PARSE THE CURRENT COMMAND BUFFER\n*-------\n         LA    R1,WRKPPL           LOAD PPL ADDRESS\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS\n         LA    R15,CPECB           LOAD ECB ADDRESS\n         ST    R15,PPLECB\n         MVC   PPLPCL,=A(INFOPCL)  LOAD PCL ADDRESS\n         LA    R15,CPANS           LOAD PDL ANSWER ADDRESS\n         ST    R15,PPLANS\n         DROP  R1\n         CALLTSSR EP=IKJPARS,MF=(E,(R1))\n         LTR   R15,R15             CHECK PARSE RETURN CODE\n         BZ    USER0100            B. IF SUCCESSFUL\n         #SETRC (R15)              SET RETURN CODE\n         ST    R15,GFRCODE         STORE RETURN CODE\n         MVC   GFCALLID,=AL2(GFPARSE)\n         ST    R10,GFCPPLP         STORE CPPL ADDRESS          #DD00053\n         LA    R15,CPECB\n         ST    R15,GFECBP          STORE ECB ADDRESS\n         LA    R1,JEFF19@          LOAD PLIST POINTER ADDRESS\n         LINK  EP=IKJEFF19         CALL GENERAL FAIL ROUTINE\n         B     USEREXIT\n\n*-------\n*        LOAD ADDRESS OF FIELD REQUESTED TO BE INSERTED INTO &SYSCMD\n*-------\nUSER0100 DS    0H\n         L     R3,CPANS            LOAD PDL ADDRESS\n         USING IKJPARMD,R3\n         L     R5,PARAM            LOAD PARAMETER ADDRESS\n         LH    R6,PARAM+4          LOAD PARAMETER LENGTH\n\n*-------\n*        CREATE \"SYSACCT\" VARIABLE\n*-------\n         L     R15,PSATOLD         LOAD TCB  ADDRESS\n         USING TCB,R15\n         L     R14,TCBJSCB         LOAD JSCB ADDRESS\n         USING IEZJSCB,R14\n         L     R14,JSCBACT         LOAD ACTIVE JSCB ADDRESS\n         L     R14,JSCBSSIB        LOAD SSIB ADDRESS\n         USING SSIB,R14\n         MVC   SYSJOB#,SSIBJBID    \"JOB09999\" / \"TSU09999\" / \"STC09999\"\n         L     R14,TCBTCT          LOAD TCT  ADDRESS\n         USING SMFTCT,R14\n         L     R14,TCTLCTAD        LOAD LCT  ADDRESS\n         USING LCT,R14\n         L     R14,LCTJCTAD        LOAD JCT  ADDRESS\n         USING JCT,R14\n         MVC   SYSJOBN,JCTJNAME    SAVE JOB NAME\n         MVC   SYSUSER,JCTUSER     SAVE USER IDENTIFIER\n         TM    SYSUSER,X'BF'       CHECK IF \"USER\" FILLED IN\n         BM    USER0199            B. IF YES\n         MVC   SYSUSER,SYSJOBN     ELSE DEFAULT TO JOBNAME\nUSER0199 DS    0H\n         SLR   R15,R15\n         ICM   R15,7,JCTACTAD      LOAD ACT  ADDRESS\n         USING IEFAACTB-16,R15\n         MVC   SYSPGMR,ACTPRGNM    SAVE PROGRAMMER NAME\n\n         MVC   SYSACCT,BLANKS\n         LA    R1,ACTACCNT         LOAD ACCOUNTING FIELD ADDRESS\n         MVI   SYSACCT,C'('        INSERT OPENNING BRACKET\n         LA    R2,SYSACCT+1        POINT TO START OF OUTPUT BUFFER\n         SLR   R4,R4\n         ICM   R4,1,ACTJNFLD       CHECK IF ANY ACCOUNTING FIELDS EXIST\n         BZ    USER0500            B. IF NOT\n         B     USER0300\nUSER0200 DS    0H\n         MVI   0(R2),C','          INSERT ACCOUNTING FIELD SEPARATOR\n         LA    R2,1(,R2)           ADVANCE TO NEXT BYTE\nUSER0300 DS    0H\n         SLR   R3,R3\n         ICM   R3,1,0(R1)          LOAD LENGTH OF ACCOUNTING FIELD\n         BZ    USER0400            B. IF ZERO LENGTH ACCOUNTING FIELD\n         BCTR  R3,0                DECREMENT FOR EXECUTE\n         #EXEC R3,MVC,0(*-*,R2),1(R1)\n         LA    R1,2(R3,R1)         POINT TO NEXT ACCOUNTING FIELD\n         LA    R2,1(R3,R2)         POINT TO NEXT OUTPUT AREA\nUSER0400 DS    0H\n         BCT   R4,USER0200         PROCESS ALL ACCOUNTING FIELDS\nUSER0500 DS    0H\n         MVI   0(R2),C')'          INSERT ENDING QUOTE\n         LA    R2,1(,R2)           POINT TO END OF ACCOUNTING AREA\n         LA    R1,SYSACCT          POINT TO START OF ACCOUNTING AREA\n\n         SR    R2,R1               CALCULATE LENGTH OF ACCOUNTING FIELD\n         LA    R1,SYSACCT          LOAD ADDRESS OF VARIABLE DATA\n         LA    R15,=C'ACCT'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSCPID\" VARIABLE\n*-------\n         L     R15,PSAPCCAV        LOAD PCCA ADDRESS\n         USING PCCA,R15\n         MVC   SYSCPID,PCCACPID    SAVE CPU SERIAL NUMBER\n         DROP  R15\n         LA    R1,SYSCPID          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSCPID        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'CPID'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSWDAY\" VARIABLE\n*-------\n         #DATE SYSWDAY,FORMAT='DAYOFWEEK'\n         LA    R1,SYSWDAY          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSWDAY        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'WDAY'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSRUSR\" AND \"SYSRGRP\" VARIABLES\n*-------\n         MVC   SYSRGRP,BLANKS                                  #DD00089\n         MVC   SYSRUSR,BLANKS                                  #DD00089\n         L     R15,PSAAOLD         A(ASCB)                     #DD00089\n         USING ASCB,R15                                        #DD00089\n         ICM   R15,15,ASCBASXB     A(ASXB)                     #DD00089\n         BZ    USER0550                                        #DD00089\n         USING ASXB,R15                                        #DD00089\n         ICM   R15,15,ASXBSENV     A(ACEE)                     #DD00089\n         BZ    USER0550                                        #DD00089\n         USING ACEE,R15                                        #DD00089\n         SLR   R1,R1                                           #DD00089\n         ICM   R1,1,ACEEGRPL       L(RACF GROUP NAME)          #DD00089\n         BZ    USER0540                                        #DD00089\n         LA    R14,ACEEGRPN        A(RACF GROUP NAME)          #DD00089\n         #EXEC -R1,MVC,SYSRGRP(*-*),0(R14)                     #DD00089\nUSER0540 DS    0H\n         SLR   R1,R1                                           #DD00089\n         ICM   R1,1,ACEEUSRL       L(RACF USER)                #DD00089\n         BZ    USER0550                                        #DD00089\n         LA    R14,ACEEUSRI        A(RACF USER)                #DD00089\n         #EXEC -R1,MVC,SYSRUSR(*-*),0(R14)                     #DD00089\n         DROP  R15                                             #DD00089\n\nUSER0550 DS    0H\n         LA    R1,SYSRGRP          A(VARIABLE DATA)            #DD00089\n         LA    R2,L'SYSRGRP        L(VARIABLE DATA)            #DD00089\n         LA    R15,=C'RGRP'        A(VARIABLE SUFFIX)          #DD00089\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE#DD00089\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\"    #DD00089\n\n         LA    R1,SYSRUSR          A(VARIABLE DATA)            #DD00089\n         LA    R2,L'SYSRUSR        L(VARIABLE DATA)            #DD00089\n         LA    R15,=C'RUSR'        A(VARIABLE SUFFIX)          #DD00089\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE#DD00089\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\"    #DD00089\n\n*-------\n*        CREATE \"SYSFMID\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         LA    R0,256              LOAD PREFIX LENGTH\n         SR    R15,R0              BACK UP TO START OF PREFIX\n         USING CVTFIX,R15\n         MVC   SYSFMID,CVTPRODI    SAVE SCP FMID\n         DROP  R15\n         LA    R1,SYSFMID          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSFMID        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'FMID'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSIODF\" VARIABLE\n*-------\n         MVC   SYSIODF,BLANKS                                  #DD01215\n         L     R15,FLCCVT          LOAD CVT ADDRESS            #DD01215\n         USING CVT,R15                                         #DD01215\n         ICM   R15,15,CVTEXT2      LOAD EXTENSION ADDRESS      #DD01215\n         BZ    USER0560                                        #DD01215\n         USING CVTXTNT2,R15                                    #DD01215\n         MVC   SYSIODF,CVTIOCID    SAVE I/O CONFIGURATION ID   #DD01215\n         DROP  R15                                             #DD01215\nUSER0560 DS    0H                                              #DD01215\n         LA    R1,SYSIODF          LOAD ADDRESS OF VARIABLE    #DD01215\n         LA    R2,L'SYSIODF        LOAD LENGTH OF VARIABLE     #DD01215\n         LA    R15,=C'IODF'        LOAD VARIABLE SUFFIX        #DD01215\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE#DD01215\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\"    #DD01215\n\n*-------\n*        CREATE \"SYSIPLD\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         ICM   R15,15,CVTSMCA      LOAD SMCA ADDRESS\n         BZ    USER0600            B. IF NOT FOUND\n         USING SMCABASE,R15\n         L     R0,SMCAIDTE         INSERT LAST IPL DATE (YYDDDF)\n         DROP  R15\n         #DATE SYSIPLD,FORMAT='MM/DD/CCYY',FROM=(R0)\nUSER0600 DS    0H\n         LA    R1,SYSIPLD          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSIPLD        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'IPLD'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSIPLT\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         ICM   R15,15,CVTSMCA      LOAD SMCA ADDRESS\n         BZ    USER0700            B. IF NOT FOUND\n         USING SMCABASE,R15\n         L     R1,SMCAITME         INSERT LAST IPL TIME (BINARY)\n         DROP  R15\n         LA    R14,SYSIPLT         LOAD OUTPUT BUFFER ADDRESS\n         SLR   R0,R0\n         D     R0,=A(100)          R0=HUNDREDTHS OF SECONDS\n         CVD   R0,USEDBL1\n         UNPK  9(2,R14),USEDBL1\n         SLR   R0,R0\n         D     R0,=A(60)           R0=SECONDS\n         CVD   R0,USEDBL1\n         UNPK  6(2,R14),USEDBL1\n         SLR   R0,R0\n         D     R0,=A(60)           R0=MINUTES\n         CVD   R0,USEDBL1\n         UNPK  3(2,R14),USEDBL1\n         CVD   R1,USEDBL1          R1=HOURS\n         UNPK  0(2,R14),USEDBL1\n         OC    0(11,R14),=C'00:00:00.00'\nUSER0700 DS    0H\n         LA    R1,SYSIPLT          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSIPLT        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'IPLT'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSIPLU\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         L     R15,CVTSYSAD        LOAD SYSRES UCB ADDRESS\n         USING UCBOB,R15\n         UNPK  WRKDBL1(5),UCBCHAN(3)                           #DD99252\n         TR    WRKDBL1(4),TRTABLE3-C'0'                        #DD99252\n         MVC   SYSIPLU,WRKDBL1     COPY UNIT ADDRESS (4 BYTES) #DD99252\n         DROP  R15\n         LA    R1,SYSIPLU          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSIPLU        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'IPLU'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSIPLV\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         L     R15,CVTSYSAD        LOAD SYSRES UCB ADDRESS\n         USING UCBOB,R15\n         MVC   SYSIPLV,UCBVOLI     SAVE VOLUME SERIAL NUMBER\n         DROP  R15\n         LA    R1,SYSIPLV          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSIPLV        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'IPLV'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSJOB#\" VARIABLE\n*-------\n         LA    R1,SYSJOB#          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSJOB#        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'JOB#'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSJOBN\" VARIABLE\n*-------\n         LA    R1,SYSJOBN          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSJOBN        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'JOBN'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------                                                       #DD00053\n*        CREATE \"SYSMCAT\" VARIABLE                             #DD00053\n*-------                                                       #DD00053\n         XC    @CTGPL,@CTGPL       ZERO PARAMETER LIST         #DD00053\n         #CTGPL LISTCAT,                                       #DD00053*\n               CRI=DUMMYPRE,                                   #DD00053*\n               WORK=(WRKAREA,256),                             #DD00053*\n               OPTIONS=(NAME,GENLD,RCATN,SUPLT,AM0),           #DD00053*\n               MF=(E,@CTGPL)                                   #DD00053\n         CATALOG @CTGPL                                        #DD00053\n         LTR   R15,R15             CHECK IF DATA RETURNED      #DD00053\n         BZ    USER0710            B. IF SUCCESSFUL            #DD00053\n         MVC   SYSMCAT,=CL44'UNKNOWN'                          #DD00053\n         B     USER0720                                        #DD00053\n\nUSER0710 DS    0H                                              #DD00053\n         MVC   SYSMCAT,WRKAREA+5   COPY MASTER CATALOG NAME    #DD00053\n\nUSER0720 DS    0H                                              #DD00053\n         LA    R1,SYSMCAT          LOAD ADDRESS OF VARIABLE    #DD00053\n         LA    R2,L'SYSMCAT        LOAD LENGTH OF VARIABLE     #DD00053\n         LA    R15,=C'MCAT'        LOAD VARIABLE SUFFIX        #DD00053\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE#DD00053\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\"    #DD00053\n\n*-------\n*        CREATE \"SYSMODE\" VARIABLE\n*-------\n         LA    R2,3                LOAD LENGTH OF VARIABLE DATA\n         MVC   SYSMODE,=CL9'370'   INDICATE 370 SYSTEM\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         TM    CVTDCB,CVTMVSE      CHECK FOR XA OR ESA SYSTEM\n         BNO   USER0800            B. IF NOT\n         LA    R2,3                LOAD LENGTH OF VARIABLE DATA\n         MVC   SYSMODE,=CL9'ESA'   INDICATE ESA SYSTEM\n         TM    CVTDCB,X'08'        CHECK FOR ESA SYSTEM\n         BO    USER0750            B. IF YES\n         LA    R2,2                LOAD LENGTH OF VARIABLE DATA\n         MVC   SYSMODE,=CL9'XA'    INDICATE XA SYSTEM\n         B     USER0800\nUSER0750 DS    0H\n         TM    CVTOSLV1,X'02'      CHECK FOR \"OS/390\" SYSTEM\n         BZ    USER0800            B. IF NOT\n         L     R15,CVTECVT         A(E-CVT)                    #DD99218\n         USING ECVT,R15                                        #DD99218\n         MVC   SYSMODE(8),=CL8'OS/390 R'                       #DD99218\n         LA    R1,SYSMODE+8                                    #DD99218\n\n         MVC   0(1,R1),ECVTPVER+1                              #DD99218\n         CLI   ECVTPVER,C'0'       LEADING ZERO?               #DD99218\n         BE    USER0760            B. IF YES                   #DD99218\n         MVC   0(2,R1),ECVTPVER                                #DD99218\n         LA    R1,1(,R1)                                       #DD99218\nUSER0760 DS    0H                                              #DD99218\n         LA    R1,1(,R1)                                       #DD99218\n         MVI   0(R1),C'.'                                      #DD99218\n         LA    R1,1(,R1)                                       #DD99218\n\n         MVC   0(1,R1),ECVTPREL+1                              #DD99218\n         CLI   ECVTPREL,C'0'       LEADING ZERO?               #DD99218\n         BE    USER0770            B. IF YES                   #DD99218\n         MVC   0(2,R1),ECVTPREL                                #DD99218\n         LA    R1,1(,R1)                                       #DD99218\nUSER0770 DS    0H                                              #DD99218\n         LA    R1,1(,R1)                                       #DD99218\n         MVI   0(R1),C'.'                                      #DD99218\n         LA    R1,1(,R1)                                       #DD99218\n\n         MVC   0(1,R1),ECVTPMOD+1                              #DD99218\n         CLI   ECVTPMOD,C'0'       LEADING ZERO?               #DD99218\n         BE    USER0780            B. IF YES                   #DD99218\n         MVC   0(2,R1),ECVTPMOD                                #DD99218\n         LA    R1,1(,R1)                                       #DD99218\nUSER0780 DS    0H                                              #DD99218\n         LA    R1,1(,R1)                                       #DD99218\n         DROP  R15                                             #DD99218\n\n         LR    R2,R1               A(END OF &SYSMODE)          #DD99218\n         LA    R1,SYSMODE          A(START OF &SYSMODE)        #DD99218\n         SR    R2,R1               CALCULATE LENGTH            #DD99218\nUSER0800 DS    0H\n         LA    R1,SYSMODE          LOAD ADDRESS OF VARIABLE DATA\n         LA    R15,=C'MODE'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSMODL\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         LA    R0,6\n         SR    R15,R0              LOAD CVTMDL ADDRESS\n         UNPK  SYSMODL(5),0(3,R15) CONVERT MODEL NUMBER TO DECIMAL\n         TR    SYSMODL(4),TRTABLE3-C'0'\n         LA    R1,SYSMODL          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,4                LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'MODL'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSPGMR\" VARIABLE\n*-------\n         LA    R1,SYSPGMR          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSPGMR        LOAD DEFAULT LENGTH OF VARIABLE\n         CLC   SYSPGMR,BLANKS      CHECK FOR NULL PROGRAMMER NAME\n         BE    USER1100            B. IF YES\n         LA    R3,L'SYSPGMR-1(,R1) POINT TO END OF VARIABLE\nUSER0900 DS    0H\n         TM    0(R3),X'BF'         CHECK FOR REAL END OF VARIABLE\n         BM    USER1000            B. IF YES\n         BCT   R3,USER0900         BACK UP 1 BYTE & CONTINUE\nUSER1000 DS    0H\n         LA    R2,1(,R3)           POINT TO END OF PROGRAMMER NAME\n         SR    R2,R1               CALCULATE REAL LENGTH OF VARIABLE\nUSER1100 DS    0H\n         LA    R15,=C'PGMR'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSREGN\" VARIABLE\n*-------\n         L     R15,PSAAOLD         LOAD ASCB ADDRESS\n         USING ASCB,R15\n         L     R15,ASCBLDA         LOAD LDA  ADDRESS\n         USING LDA,R15\n         L     R15,LDAREGRQ        LOAD REQUESTED REGION SIZE\n         SRL   R15,10              DIVIDE BY 1024\n         CVD   R15,USEDBL1         CONVERT TO DECIMAL\n         DROP  R15\n         MVC   SYSREGN,=X'40402020202120D2'\n         ED    SYSREGN+1(6),USEDBL1+5\n         LA    R1,SYSREGN          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSREGN        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'REGN'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSSCPN\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         LA    R0,256              LOAD PREFIX LENGTH\n         SR    R15,R0              BACK UP TO START OF PREFIX\n         USING CVTFIX,R15\n         MVC   SYSSCPN,CVTPRODN    SAVE SCP NAME\n         DROP  R15\n         LA    R1,SYSSCPN          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSSCPN        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'SCPN'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSDSSL\" VARIABLE\n*-------\n         ADRMCLVL ,                GET DF/DSS LEVEL\n\n         XC    WRKDBL1,WRKDBL1                                 #DD01254\n         XC    WRKDBL2,WRKDBL2                                 #DD01254\n         STCM  R1,B'0100',WRKDBL1+3 SAVE \"VERSION\"             #DD01254\n         STCM  R1,B'0010',WRKDBL1+7 SAVE \"RELEASE\"             #DD01254\n         STCM  R1,B'0001',WRKDBL2+3 SAVE \"LEVEL\"               #DD01254\n\n         MVC   SYSDSSL,=C'V#R##.#'                             #DD01254\n         ICM   R1,15,WRKDBL1+1     RELOAD \"VERSION\"            #DD02316\n         CVD   R1,USEDBL1                                      #DD01254\n         OI    USEDBL1+7,X'0F'                                 #DD01254\n         UNPK  SYSDSSL+1(1),USEDBL1   INSERT VERSION           #DD01254\n         L     R1,WRKDBL1+4        RELOAD \"RELEASE\"            #DD01254\n         CVD   R1,USEDBL1                                      #DD01254\n         OI    USEDBL1+7,X'0F'                                 #DD01254\n         UNPK  SYSDSSL+3(2),USEDBL1   INSERT RELEASE           #DD01254\n         L     R1,WRKDBL2+0        RELOAD \"LEVEL\"              #DD01254\n         CVD   R1,USEDBL1                                      #DD01254\n         OI    USEDBL1+7,X'0F'                                 #DD01254\n         UNPK  SYSDSSL+6(1),USEDBL1   INSERT LEVEL             #DD01254\n\n         LA    R1,SYSDSSL          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSDSSL        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'DSSL'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSREL#\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         LA    R0,256              LOAD PREFIX LENGTH\n         SR    R15,R0              BACK UP TO START OF PREFIX\n         USING CVTFIX,R15\n         MVC   SYSREL#(2),CVTNUMB  SAVE SCP RELEASE NUMBER\n         MVI   SYSREL#+2,C'.'\n         MVC   SYSREL#+3(2),CVTLEVL     SCP RELEASE LEVEL\n         DROP  R15\n         LA    R1,SYSREL#          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSREL#        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'REL#'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSSMFI\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         MVC   SYSSMFI,=CL4'????'  INSERT UNKNOWN IDENTIFIER\n         ICM   R15,15,CVTSMCA      LOAD SMCA ADDRESS\n         BZ    USER1200            B. IF NOT FOUND\n         USING SMCABASE,R15\n         MVC   SYSSMFI,SMCASID     INSERT SMF SYSTEM IDENTIFIER\n         DROP  R15\nUSER1200 DS    0H\n         LA    R1,SYSSMFI          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSSMFI        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'SMFI'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSSNAM\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         USING CVTMAP,R15\n         MVC   SYSSNAM,CVTSNAME    SAVE SYSTEM NAME\n         DROP  R15\n         LA    R1,SYSSNAM          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSSNAM        LOAD DEFAULT LENGTH OF VARIABLE\n         LA    R15,=C'SNAM'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSSSNM\" VARIABLE\n*-------\n         L     R15,PSATOLD         LOAD TCB ADDRESS\n         USING TCB,R15\n         L     R15,TCBJSCB         LOAD JSCB ADDRESS\n         USING IEZJSCB,R15\n         L     R15,JSCBACT         LOAD ACTIVE JSCB ADDRESS\n         L     R15,JSCBSSIB        LOAD DEFAULT SSIB ADDRESS\n         USING SSIB,R15\n\n         MVC   SYSSSNM,SSIBSSNM    SAVE CURRENT SUBSYSTEM NAME\n         DROP  R15\n         LA    R1,SYSSSNM          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSSSNM        LOAD DEFAULT LENGTH OF VARIABLE\n         LA    R15,=C'SSNM'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSTERM\" VARIABLE\n*-------\n         #TSOTERM ,                GET CURRENT TERMINAL TYPE\n         ST    R15,SYSTERM         SAVE TERMINAL/LINE INFORMATION\n\n         LA    R7,TYPETABL         LOAD TERMINAL TABLE START ADDRESS\n         LA    R1,NRENT            LOAD NUMBER OF ENTRIES IN TABLE\nUSER1300 DS    0H\n         CLC   0(1,R7),SYSTERM+3   CHECK FOR MATCHING TERMINAL TYPE\n         BE    USER1400            B. IF YES\n         LA    R7,5(,R7)           LOAD ADDRESS OF NEXT TABLE ENTRY\n         BCT   R1,USER1300         LOOP THROUGH TERMINAL TYPE TABLE\n\nUSER1400 DS    0H\n         LA    R1,1(,R7)           LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,4                LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'TERM'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSTMID\" VARIABLE\n*-------\n         LA    R2,1                LOAD DEFAULT VARIABLE LENGTH\n         LA    R3,BLANKS           LOAD DEFAULT VARIABLE VALUE\n         ICM   R15,15,PSAAOLD      LOAD ASCB ADDRESS\n         BZ    USER1500\n         USING ASCB,R15\n         ICM   R15,15,ASCBASXB     LOAD ASXB ADDRESS\n         BZ    USER1500\n         USING ASXB,R15\n         ICM   R15,15,ASXBSENV     LOAD ACEE ADDRESS\n         BZ    USER1500\n         USING ACEE,R15\n         LA    R2,8                LOAD LENGTH OF VARIABLE DATA\n         LA    R3,ACEETRID         LOAD TERMINAL ID ADDRESS\n         DROP  R15\nUSER1500 DS    0H\n         LR    R1,R3               LOAD ADDRESS OF VARIABLE DATA\n         LA    R15,=C'TMID'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSUSER\" VARIABLE\n*-------\n         LA    R1,SYSUSER          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSUSER        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'USER'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSVERS\" VARIABLE\n*-------\n         L     R15,FLCCVT          LOAD CVT ADDRESS\n         LA    R0,256              LOAD PREFIX LENGTH\n         SR    R15,R0              BACK UP TO START OF PREFIX\n         USING CVTFIX,R15\n         MVC   SYSVERS,CVTVERID    SAVE USER SCP VERSION IDENTIFIER\n         DROP  R15\n         LA    R1,SYSVERS          LOAD ADDRESS OF VARIABLE DATA\n         LA    R2,L'SYSVERS        LOAD LENGTH OF VARIABLE DATA\n         LA    R15,=C'VERS'        LOAD VARIABLE SUFFIX\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\" IF REQ'D\n\n*-------\n*        CREATE \"SYSNODE\" VARIABLE\n*-------\n         NOP   USER1530            Change To \"B\" For JES3      #DD19130\n\n         L     R2,FLCCVT           A(CVT)                      #DD19130\n         USING CVT,R2                                          #DD19130\n         L     R2,CVTJESCT         A(JESCT)                    #DD19130\n         USING JESCT,R2                                        #DD19130\n         L     R2,JESSSCT          A(SSCT)                     #DD19130\n         USING SSCT,R2                                         #DD19130\n         L     R3,PSATOLD          A(TCB)                      #DD19130\n         USING TCB,R3                                          #DD19130\n         L     R3,TCBJSCB          A(JSCB)                     #DD19130\n         USING IEZJSCB,R3                                      #DD19130\n         L     R3,JSCBACT          A(ACTIVE JSCB)              #DD19130\n         L     R3,JSCBSSIB         A(SSIB)                     #DD19130\n         USING SSIB,R3                                         #DD19130\n\nUSER1510 DS    0H                                              #DD19130\n         CLC   SSCTSNAM,SSIBSSNM   CHECK FOR CURRENT SUBSYSTEM #DD19130\n         BE    USER1520            B. IF YES                   #DD19130\n         ICM   R2,15,SSCTSCTA      A(NEXT SSCVT)               #DD19130\n         BNZ   USER1510            B. IF ANOTHER ENTRY EXISTS  #DD19130\n         B     USER1530            ELSE. CREATE BLANK VARIABLE #DD19130\n\nUSER1520 DS    0H                                              #DD19130\n         ICM   R1,15,SSCTSUS2      A(HCT)                      #DD19130\n         BZ    USER1530            B. IF SUBSYSTEM IS UP       #DD19130\n         USING HCCT,R1                                         #DD19130\n         MVC   SYSNODE,CCTNDENM    SAVE NODE NAME              #DD19130\n         DROP  R1,R2,R3                                        #DD19130\n\nUSER1530 DS    0H                                              #DD19130\n         LA    R1,SYSNODE          A(VARIABLE DATA)            #DD19130\n         LA    R2,L'SYSNODE        L(VARIABLE DATA             #DD19130\n         LA    R15,=C'NODE'        LOAD VARIABLE SUFFIX        #DD19130\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE#DD19130\n\n         BAL   R14,ECTUPDTE        UPDATE \"SUBCOMMAND NAME\"    #DD19130\n\n*-------\n*        CREATE VARIABLES FOR SYMBOLS DECLARED IN IEASYMXX\n*-------\n         L     R5,FLCCVT           A(CVT)                      #DD99328\n         USING CVT,R5                                          #DD99328\n         ICM   R5,15,CVTECVT       A(ECVT)                     #DD99328\n         BZ    USER1900            B. IF NOT AVAILABLE         #DD99328\n         USING ECVT,R5                                         #DD99328\n         ICM   R5,15,ECVTSYMT      A(SYMBOL TABLE)             #DD99328\n         BZ    USER1900            B. IF NONE DEFINED          #DD99328\n         USING SYMBT,R5                                        #DD99328\n         SLR   R7,R7                                           #DD99328\n         ICM   R7,3,SYMBTNUMBEROFSYMBOLS  NUMBER OF SYMBOLS    #DD99328\n         BZ    USER1900            B. IF NONE DEFINED          #DD99328\n         LA    R6,SYMBTTABLEENTRIES A(START OF SYMBOL ENTRIES) #DD99328\n         LR    R3,R6               A(CURRENT SYMBOL ENTRY)     #DD99328\n         USING SYMBTE,R3                                       #DD99328\nUSER1600 DS    0H                                              #DD99328\n         LM    R1,R2,SYMBTESYMBOLOFFSET O(NAME) & L(NAME)      #DD99328\n         LA    R1,0(R1,R6)         A(IEASYMXX SYMBOL NAME)     #DD99328\n         CLI   0(R1),C'&&'         CHECK FOR LEADING \"&\"       #DD99328\n         BNE   USER1700            B. IF NOT                   #DD99328\n         LA    R1,1(,R1)           ADVANCE PAST \"&\"            #DD99328\n         BCTR  R2,0                SUBTRACT 1 FROM NAME LENGTH #DD99328\nUSER1700 DS    0H                                              #DD99328\n         LA    R15,0(R2,R1)        A(END OF SYMBOL NAME)       #DD99328\n         BCTR  R15,0               BACK UP TO LAST BYTE        #DD99328\n         CLI   0(R15),C'.'         CHECK FOR TRAILING \".\"      #DD99328\n         BNE   USER1800            B. IF NOT                   #DD99328\n         BCTR  R2,0                SUBTRACT 1 FROM NAME LENGTH #DD99328\nUSER1800 DS    0H                                              #DD99328\n         MVC   SYSSYMBN,BLANKS     CLEAR SYMBOL NAME AREA      #DD99328\n         #EXEC -R2,MVC,SYSSYMBN(*-*),0(R1)    COPY SYMBOL NAME #DD99328\n         LM    R1,R2,SYMBTESUBTEXTOFFSET  O(VALUE) & L(VALUE)  #DD99328\n         LA    R1,0(R1,R6)         A(IEASYMXX SYMBOL VALUE)    #DD99328\n         MVC   SYSSYMBV,BLANKS     CLEAR SYMBOL NAME AREA      #DD10356\n         #EXEC -R2,MVC,SYSSYMBV(*-*),0(R1)    COPY SYMBOL NAME #DD99328\n\n         LA    R1,SYSSYMBV         A(IEASYMXX SYMBOL VALUE)    #DD99328\n         LA    R2,L'SYSSYMBV       L(IEASYMXX SYMBOL VALUE)    #DD99328\n         LA    R15,SYSSYMBN        A(IEASYMXX SYMBOL NAME)     #DD99328\n         OI    WRKFLAG1,FULLNAME   INDICATE 8 BYTE SYMBOL NAME #DD99328\n         BAL   R14,TSOCVAR         CREATE/MODIFY CLIST VARIABLE#DD99328\n\n         LA    R3,SYMBTE_LEN(,R3)  A(NEXT SYMBOL TABLE ENTRY)  #DD99328\n         BCT   R7,USER1600         LOOP THROUGH SYMBOL TABLE   #DD99328\n\nUSER1900 DS    0H                                              #DD99328\n\n*-------\n*        TERMINATE\n*-------\nUSEREXIT #STOP ,                   TERMINATE\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CREATE CLIST VARIABLES                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         PUSH  USING                                           #DD99333\nTSOCVAR  DS    0H\n         STM   R0,R15,SAVEREGS     SAVE ALL REGISTERS\n         L     R6,CPANS            LOAD PDL ADDRESS            #DD99333\n         USING IKJPARMD,R6                                     #DD99333\n\n         MVC   VARNAME,0(R15)      INSERT \"FULL\" SYMBOL NAME   #DD99328\n         TM    WRKFLAG1,FULLNAME   CHECK IF FULL NAME PROVIDED #DD99328\n         BO    TSOC0150            B. IF YES                   #DD12214\n         MVC   VARNAME,BLANKS                                  #DD99328\n         MVC   VARNAME(3),=CL3'SYS'                            #DD99328\n         MVC   VARNAME+3(4),0(R15) COMPLETE VARIABLE NAME (&SYSXXXX)\n\nTSOC0100 DS    0H                                              #DD99328\n         CLC   PREFIX+4(2),=AL2(3) CHECK FOR VALID PREFIX LEN. #DD99333\n         BNE   TSOC0150            B. IF NOT                   #DD99333\n         ICM   R3,15,PREFIX        A(VARIABLE PREFIX)          #DD99333\n         BZ    TSOC0150            B. IF NO \"PREFIX(...)\"      #DD99333\n         MVC   VARNAME(3),0(R3)    COPY USER SPECIFIED PREFIX  #DD99333\n\nTSOC0150 DS    0H                                              #DD99333\n         LA    R15,VARNAME+L'VARNAME-1                         #DD99333\nTSOC0160 DS    0H                                              #DD99333\n         TM    0(R15),X'BF'        CHECK FOR END OF NAME       #DD99333\n         BM    TSOC0170            B. IF FOUND                 #DD99333\n         BCT   R15,TSOC0160                                    #DD99333\n\nTSOC0170 DS    0H                                              #DD99333\n         LA    R15,1(,R15)         A(END OF NAME)              #DD99333\n         LA    R14,VARNAME         A(START OF NAME)            #DD99333\n         SR    R15,R14             CALCULATE NAME LENGTH       #DD99333\n         ST    R15,NAMELEN         SET VARIABLE NAME LENGTH    #DD99333\n         MVC   VARDATA,BLANKS      INITIALIZE DATA AREA\n         #EXEC -R2,MVC,VARDATA(*-*),0(R1)\n         LA    R2,1(,R2)\n\n         LR    R14,R2              COPY LENGTH OF DATA\nTSOC0200 DS    0H\n         TM    VARDATA,X'BF'       CHECK FOR BLANK OR ZERO\n         BNZ   TSOC0300            B. IF NOT\n         MVC   VARDATA,VARDATA+1   SHIFT VARIABLE DATA OVER 1 BYTE\n         BCT   R14,TSOC0200        LOOP TILL AT 1ST BYTE OF DATA\n\nTSOC0300 DS    0H\n         LA    R15,VARDATA(R2)     POINT PAST LAST BYTE IN VARIABLE\nTSOC0400 DS    0H\n         BCTR  R15,0               BACK UP 1 BYTE\n         TM    0(R15),X'BF'        CHECK FOR BLANK OR ZERO\n         BNZ   TSOC0500            B. IF NOT\n         BCT   R2,TSOC0400         LOOP TILL AT 1ST BYTE OF DATA\n\nTSOC0500 DS    0H\n         ST    R2,DATALEN          SAVE LENGTH OF VARIABLE DATA\n\n         LA    R1,CVARPARM         LOAD ADDRESS OF IKJCT441 PLIST\n         L     R15,CLISTRTN        LOAD IKJCT441 ADDRESS\n         BALR  R14,R15             INVOKE IKJCT441\n         ST    R15,WRKR15                                      #DD12214\n\n         B     TSOC0600            ZAP TO NOP TO ISSUE MSGS    #DD12214\n         LTR   R15,R15             CHECK RETURN CODE           #DD12214\n         BZ    TSOC0600            B. IF SUCCESSFUL            #DD12214\n         CHI   R15,16              \"BUILT-IN FUNCTION\" NAME ?  #DD12214\n         BE    TSOC0600            B. YES (ALREADY EXISTS)     #DD12214\n         UNPK  WRKDBL1(9),WRKR15(5)                            #DD12214\n         TR    WRKDBL1(8),TRTABLE3-C'0'                        #DD12214\n         MVC   WRKAREA(256),BLANKS                             #DD12214\n         MVC   WRKAREA(8),VARNAME                              #DD12214\n         MVC   WRKAREA+9(24),=C'- IKJCT441 RETURN CODE: '      #DD12214\n         MVC   WRKAREA+32(8),WRKDBL1                           #DD12214\n         TPUT  WRKAREA,40                                      #DD12214\n\nTSOC0600 DS    0H                                              #DD12214\n         NI    WRKFLAG1,255-FULLNAME                           #DD99328\n         LM    R0,R15,SAVEREGS     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n         POP   USING                                           #DD99333\n\n*---------------------------------------------------------------------*\n*        UPDATE SUBCOMMAND NAME WITH SPECIFIED VARIABLE               *\n*---------------------------------------------------------------------*\nECTUPDTE DS    0H\n         CLC   0(4,R5),VARNAME+3   CHECK IF CURRENT VARIABLE SPECIFIED\n         BNER  R14                 B. IF NOT\n\n         STM   R0,R15,SAVEREGS     SAVE ALL REGISTERS\n         CL    R2,=F'8'            CHECK IF VARIABLE LENGTH > 8\n         BNH   *+8                 B. IF NOT\n         LA    R2,8                SET MAXIMUM LENGTH\n         BCTR  R2,0\n         MVC   ECTSCMD,BLANKS      CLEAR &SYSSCMD BUFFER\n         #EXEC R2,MVC,ECTSCMD(*-*),0(R1)\n         LM    R0,R15,SAVEREGS     RESTORE ALL REGISTERS\n         BR    R14                 RETURN TO CALLER\n\n*---------------------------------------------------------------------*\n*        CONSTANTS & TABLES                                           *\n*---------------------------------------------------------------------*\nBLANKS   DC    CL256' '            SOME BLANKS\nDUMMYPRE DC    AL1(12),CL44'SYS1.INVALID'                      #DD00053\n\nTYPETABL DC    X'00',C'????'       TERMINAL TYPE TABLE\n         DC    X'04',C'3270'\n         DC    X'08',C'5041'\n         DC    X'0C',C'2741'\n         DC    X'10',C'TWX '\n         DC    X'14',C'1050'\nNRENT    EQU   (*-TYPETABL)/5      NUMBER OF TERMINAL TYPES\n         DC    X'00',C'    '       LAST TERMINAL TYPE (IF NOT FOUND)\n\nTRTABLE1 DC    256X'00'\n         ORG   TRTABLE1+C' '       FIND BLANKS\n         DC    X'01'\n         ORG   TRTABLE1+C'-'       FIND DASHES\n         DC    X'02'\n         ORG   ,\nTRTABLE2 DC    256X'00'\n         ORG   TRTABLE2+C' '       FIND BLANKS\n         DC    X'01'\n         ORG   ,\nTRTABLE3 DC    C'0123456789ABCDEF' HEX TRANSLATION TABLE\n\n         #STARTWA PATCH=NO\n         IKJEFFGF GFDSECT=NO       IKJEFF19 PARAMETER LIST\nWRKR15   DS    F                   IKJCT441 RETURN CODE        #DD12214\nWRKDBL1  DS    D                   DOUBLEWORD WORK AREA        #DD99252\nWRKDBL2  DS    D                   DOUBLEWORD WORK AREA        #DD01254\nWRKFLAG1 DS    X                   FLAG BYTE #1                #DD99328\nFULLNAME EQU   BIT0   1... ....    - DON'T PREFIX SYMBOL NAME  #DD99328\nWRKAREA  DS    0F,CL256            CATALOG WORKAREA BUFFER     #DD00053\n@CTGPL   DS    XL(CTGPLLEN)        CATALOG PARAMETER LIST      #DD00053\nSYSACCT  DS    CL146               ACCOUNTING INFORMATION\nSYSCPID  DS    CL12                CPU SERIAL NUMBER\nSYSDSSL  DS    CL7                 DF/DSS LEVEL\nSYSWDAY  DS    CL9                 DAY OF THE WEEK\nSYSFMID  DS    CL8                 SCP FMID\nSYSIODF  DS    CL2                 IODF SUFFIX                 #DD01215\nSYSIPLD  DS    CL10                LAST IPL DATE (MM/DD/CCYY)\nSYSIPLT  DS    CL11                LAST IPL TIME (HH:MM:SS.HT)\nSYSIPLU  DS    CL4                 SYSRES UNIT ADDRESS         #DD99252\nSYSIPLV  DS    CL6                 SYSRES VOLUME SERIAL NUMBER\nSYSJOB#  DS    CL8                 JOB NUMBER\nSYSJOBN  DS    CL8                 JOB NAME\nSYSMCAT  DS    CL44                MASTER CATALOG NAME         #DD00053\nSYSMODE  DS    CL9,CL10            PROCESSING MODE\nSYSMODL  DS    CL8                 PROCESSOR MODEL NUMBER\nSYSPGMR  DS    CL(L'ACTPRGNM)      PROGRAMMER NAME             #DD99328\nSYSREGN  DS    CL8                 REQUESTED REGION SIZE\nSYSRGRP  DS    CL8                 RACF GROUP NAME             #DD00089\nSYSRUSR  DS    CL8                 RACF USERID                 #DD00089\nSYSSCPN  DS    CL8                 SCP PRODUCT NAME\nSYSREL#  DS    CL5                 SCP RELEASE NUMBER\nSYSSMFI  DS    CL4                 SMF IDENTIFIER\nSYSSSNM  DS    CL(L'SSIBSSNM)      SUBSYSTEM NAME\nSYSSYMBN DS    CL8                 IEASYMXX SYMBOL NAME        #DD99328\nSYSSYMBV DS    CL254               IEASYMXX SYMBOL VALUE       #DD99328\nSYSSNAM  DS    CL8                 SYSTEM IDENTIFIER\nSYSTERM  DS    F                   TERMINAL TYPE\nSYSTMID  DS    CL8                 TERMINAL IDENTIFIER\nSYSUSER  DS    CL(L'JCTUSER)       USER IDENTIFIER\nSYSVERS  DS    CL16                USER SCP VERSION IDENTIFIER\nSYSNODE  DS    CL8                 JES2 NODE NAME              #DD19130\nCLISTRTN DS    A                   IKJCT441 ADDRESS\nCPANS    DS    A                   RETURNED PDL BUFFER ADDRESS\nCPECB    DS    A                   COMMAND PROCESSOR ECB\nCVARPARM DS    0F                  IKJCT441 PARAMETER LIST\nCVAREC@  DS    A                   ENTRY CODE ADDRESS\nCVARNPT@ DS    A                   VARIABLE NAME POINTER ADDRESS\nCVARNLN@ DS    A                   VARIABLE NAME LENGTH  ADDRESS\nCVARDPT@ DS    A                   VARIABLE DATA POINTER ADDRESS\nCVARDLN@ DS    A                   VARIABLE DATA LENGTH  ADDRESS\nCVARTKN@ DS    A                   TOKEN ADDRESS\nDATALEN  DS    F                   VARIABLE DATA LENGTH\nECODE    DS    A                   CLIST VARIABLE ROUTINE ENTRY CODE\nJEFF19@  DS    F                   IKJEFF19 PARAMETER LIST ADDRESS\nNAMELEN  DS    F                   VARIABLE NAME LENGTH\nSAVEREGS DS    16F                 REGISTER SAVE AREA\nTOKEN    DS    A                   TOKEN USED BY IKJCT441\nVARDATA  DS    CL256               VARIABLE DATA BUFFER\nVARDATA@ DS    A                   VARIABLE DATA POINTER\nVARNAME  DS    CL8                 VARIABLE NAME \"SYSXXXX\"\nVARNAME@ DS    A                   VARIABLE NAME POINTER\nWRKPPL   DS    7F                  PARSE PARAMETER LIST\n         #STOPWA ,\n\n         PRINT NOGEN\n\nINFOPCL  IKJPARM\nINFOPCL  AMODE 31                                              #DD02316\nINFOPCL  RMODE ANY                                             #DD02316\nPARAM    IKJIDENT 'USER INFORMATION FUNCTION',MAXLNTH=4,               *\n               DEFAULT='SETV',                                         *\n               HELP='ACCT, IPLD, IPLT, IPLU, IPLV, JOB#, JOBN, MODE, MO*\n               DL, PGMR, TERM, TMID OR USER'\n\nPREFKW   IKJKEYWD DEFAULT='PREFIX(SYS)'                        #DD99333\n         IKJNAME 'PREFIX',SUBFLD=PREFSUB                       #DD99333\nPREFSUB  IKJSUBF ,                                             #DD99333\nPREFIX   IKJIDENT 'PREFIX',OTHER=ALPHANUM,MAXLNTH=3,           #DD99333X\n               PROMPT='VARIABLE PREFIX'                        #DD99333\n         IKJENDP\n\n         IKJTSVT ,            MAP TSO VECTOR TABLE\n         IHAPCCA ,\n         ASASYMBP DSECT=YES,SYMBP=NO,SYMBT=YES                 #DD99328\n         #DSECTS ACT,ASCB,ASXB,CVT,ECT,ECVT,JCT,LCT,LDA,PSA,SMCA,SSIB, *\n               TCB,TCT,TSO,UCB,ACEE                            #DD00083\n         #DSECTS CATLG                                         #DD00053\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WGREXX": {"ttr": 21255, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x04\"O\\x01\\x04\"O\\x13\\x14\\x00_\\x00_\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-08-11T00:00:00", "modifydate": "2004-08-11T13:14:52", "lines": 95, "newlines": 95, "modlines": 0, "user": "REXX"}, "text": "/* REXX - to \"front end\" the WHOSGOT program.                        */\n/*                                                                   */\n/*  This REXX can be invoked on DLIST panel, or by TSO command with  */\n/*  or without a data set name passed.                               */\n/*  The REXX will not call WHOSGOT if the data set is not DASD       */\n/*  (in some tests, tape mounts were issued - that not good), or     */\n/*  does not exist; and if data set is VSAM, then test for component */\n/*  in data set name, and remove it if found.                        */\n/*                                                                   */\n/*  Author: Greg Shirey of Ben E. Keith Company.                     */\n\nTrace O\nAddress TSO\n\nArg dsn .\ndsn = Strip(dsn)\nDASD_DSN = 'N'\n\nDo While dsn = ''                   /*  If no dsn passed, do this    */\n  Say \" \"\n  Say \"Enter fully qualified data set name:\"\n  Pull Answer\n  Answer = Strip(Answer)\n  If Answer = \"Q\" Then Exit\n  If Answer = \"\" then\n     Say 'Q to exit, otherwise enter a data set name'\n  else\n     dsn = Strip(Answer)\nEnd\n\nppos1 = pos(\"(\",dsn)                 /* Check for '('              */\nIf ppos1 = 0 Then NOP                /* If none, go on             */\nElse Do\n  Say \"WG-REXX - Member names or generation numbers not allowed\"\n  Exit 4\nEnd\n\napos1 = pos(\"'\",dsn)                 /* Check for apostrophe       */\nIf apos1 = 0 then dsn = \"'\"dsn\"'\"    /* Add them if not found      */\n\nRcode = LISTDSI(DSN)                /* Do a LISTDSI on the dsn     */\n/* Uncomment for testing\n  Say \"SYSDSNAME\" SYSDSNAME\n  Say \"SYSUNIT\"   SYSUNIT\n  Say \"SYSRACFA\"  SYSRACFA\n  Say \"SYSUNITS\"  SYSUNITS\n  Say \"SYSREASON\" SYSREASON\n*/\n\nIf Rcode > 4 Then Do\n  Say \"WG-REXX - LISTDSI Return Code\" Rcode \"Reason Code\" SYSREASON\n  exit 4\nEnd\n\nIf substr(SYSUNIT,1,2) = '33' | ,     /* 3390, 3380, 3350 (oldie) */\n          SYSUNIT = 'SYSDA' | SYSUNIT = 'SYSALLDA' ,\n  Then DASD_DSN = 'Y'\n\nIf DASD_DSN = 'N' Then Do             /* Tape or otherwise, leave */\n  Say \"WG-REXX\" dsn \"not on DASD or is uncataloged\"\n  Exit 4\nEnd\n\nIf SYSDSORG = 'VS' Then Do\n Base = 'Full'                        /* Initialize variable      */\n Parts = TRANSLATE(dsn,' ','.')       /* Remove periods from dsn  */\n Count = Words(Parts)                 /* Count the dsn parts      */\n /* Remove component suffix's.  (.DATA .INDEX .D .I)              */\n If Word(Parts,Count) = \"DATA'\"\n   Then Parse Var dsn Base \".DATA'\"\n If Word(Parts,Count) = \"D'\"\n   Then Parse Var dsn Base \".D'\"\n If Word(Parts,Count) = \"INDEX'\"\n   Then Parse Var dsn Base \".INDEX'\"\n If Word(Parts,Count) = \"I'\"\n   Then Parse Var dsn Base \".I'\"\n If Base = 'Full' Then NOP\n Else dsn = Base||\"'\"                 /* Replace dsn with the VSAM*/\nEnd                                   /* Base cluster name and '  */\n\nExist = SYSDSN(dsn)                  /* check dsn existance        */\nIF Exist = 'OK' | Exist = 'UNAVAILABLE DATASET' | ,\n  Exist = 'PROTECTED DATASET' Then NOP\n  Else do\n    Say \"WG-REXX\" Exist \"-\" dsn      /* If no, get out             */\n    Exit\nend\n\nIf Answer <> 'ANSWER' Then              /* Info message for      */\n   Say \"Calling WHOSGOT program.....\"   /*  TSO calls            */\n\n\"WHOSGOT \"dsn                        /* call WHOSGOT program      */\nRcode = rc                           /*       save return code    */\n\nExit Rcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHOSGOT": {"ttr": 21258, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x165\\x8f\\x01\\x165\\x8f\\x12P\\x01\\xd5\\x01\\xd5\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-23T00:00:00", "modifydate": "2016-12-23T12:50:27", "lines": 469, "newlines": 469, "modlines": 0, "user": "SOURCE"}, "text": "WHOSGOT  TITLE 'WHOSGOT - DISPLAY DATASET(S) ENQ STATUS'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Support Email Address: zOS.JES2@Gmail.com                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n* MODNAME     : WHOSGOT                                               *\n*                                                                     *\n* FUNCTION    : THIS MODULE USES GQSCAN TO DISPLAY THE ENQ STATUS OF  *\n*               A SPECIFIED DATASET(S) .                              *\n*                                                                     *\n* ENTRY  PARMS: R1 -> CPPL                                            *\n* EXIT PARMS  : ENQ STATUS DISPLAYED                                  *\n*                                                                     *\n* REGS USED   : R0  -> WORK                                           *\n*               R1  -> WORK                                           *\n*               R2  -> CPPL, WORK                                     *\n*               R3  -> PDL, PDE, WORK                                 *\n*               R4  -> WORK                                           *\n*               R5  -> WORK                                           *\n*               R6  -> NOT USED                                       *\n*               R7  -> NOT USED                                       *\n*               R8  -> NOT USED                                       *\n*               R9  -> NOT USED                                       *\n*               R10 -> NOT USED                                       *\n*               R11 -> 1ST BASE REG                                   *\n*               R12 -> NOT USED                                       *\n*               R13 -> REGISTER SAVE AREA AND WORK AREA               *\n*               R14 -> WORK                                           *\n*               R15 -> WORK                                           *\n*                                                                     *\n* ATTRIBUTES : RENT                                                   *\n*                                                                     *\n* MESSAGES ISSUED : GRS300I                                           *\n*                   GRS301I                                           *\n*                   GRS302I                                           *\n*                   GRS303I                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* HISTORY : 2000.147 - FIX JOBNAME MESSAGE INSERT LENGTH              *\n*                                                                     *\n***********************************************************************\n\n         PUNCH ' ALIAS WG'\n\n         ACONTROL OPTABLE(ZS3)     ASSEMBLY OPTCDE TABLE\n         SPLEVEL  SET=6            SPECIFY OS/390 R2 MACRO FORMAT\n         SYSSTATE ARCHLVL=2        ASSEMBLY REQUIRES Z/ARCHITECTURE\n         SYSSTATE OSREL=ZOSV1R13   ASSEMBLY REQUIRES Z/OS 1.13 & HIGHER\n\nWHOSGOT  #START BASE=R11,WKDSECT=WRKWG,REG1=R2,                        X\n               USING=(CPPL,R2),                                        X\n               APARS=,COPY=YES,                                        X\n               LEVEL=#V001R03                                  #DD00147\n\n*-------\n*        BUILD I/O SERVICE ROUTINE PARAMETER LIST\n*-------\n\n         LA    R1,WIOPL                -> IOPL IN WORKAREA\n         USING IOPL,R1\n         MVC   IOPLUPT,CPPLUPT         COPY UPT ADDR\n         MVC   IOPLECT,CPPLECT         COPY ECT ADDR\n         LA    R0,WORKECB              -> ECB IN WORKAREA\n         ST    R0,IOPLECB              PUT IN IOPL\n\n*-------\n*        BUILD PARSE PARAMETER LIST AND LINK TO IKJPARS TO PARSE\n*        ANY OPERANDS.\n*-------\n\n         LA    R1,WORKPPL              A(PPL IN WORKAREA)\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT          COPY ADDRESS OF UPT\n         MVC   PPLECT,CPPLECT          COPY ADDRESS OF ECT\n         MVC   PPLCBUF,CPPLCBUF        COPY ADDRESS OF COMMAND BUFFER\n         LA    R0,WORKPDLP             A(PDL POINTER IN WORKAREA)\n         ST    R0,PPLANS               PUT IN PPL\n         LA    R0,WORKECB              A(ECB IN WORKAREA)\n         ST    R0,PPLECB               PUT IN PPL\n         L     R0,=A(WGPCL)            -> PCL\n         ST    R0,PPLPCL              PUT IN PPL\n         ST    R13,PPLUWA              PASS ADDR OF WORKAREA\n         CALLTSSR EP=IKJPARS,MF=(E,(1)) PARSE THE COMMAND BUFFER\n         LTR   R15,R15                 PARSE O.K.?\n         BNZ   WGEXIT                  TERMINATE IF NOT\n         DROP  R2\n\n*-------\n*        OBTAIN STORAGE FOR GQSCAN AREA.\n*-------\n\n         MVC   WGETMAIN,GETMAIN        COPY MF=L TO WORKAREA\n         GETMAIN VU,A=VGETAREA,MF=(E,WGETMAIN)\n\n*-------\n*        COPY INFORMATION TO WORKAREA.\n*-------\n\n         MVC   WPTPB,PTPB              COPY MF=L TO WORKAREA\n         L     R3,WORKPDLP             PICK UP ADDR OF PDL\n         USING WGPDL,R3\n         LA    R3,WGDSNAME             -> DSN PDE\n         USING WGDSNAME,R3\nSCANLOOP DS    0H\n         L     R1,WGDSNAME             PICK UP ADDR OF CHAR STRING\n         LH    R15,WGDSNAME+4          PICK UP LNTH OF CHAR STRING\n         STH   R15,WRNAMELN            SAVE LNTH FOR GQSCAN\n         #EXEC -R15,MVC,WRKDSNAM(*-*),0(R1) COPY RNAME (DSNAME)\n\n*-------\n*        USE GQSCAN TO FIND DATASET'S ENQ STATUS\n*-------\n\n         MVC   WGQSCAN,GQSCAN          COPY MF=L TO WORKAREA\n         LH    R2,WRNAMELN             PICK UP LNTH OF RNAME\n         LM    R4,R5,VGETAREA          PICK UP ADDR AND LNTH\n         GQSCAN AREA=((R4),(R5)),RESNAME=(SYSDSN,WRKDSNAM,(R2)),       X\n               MF=(E,WGQSCAN)\n         STM   R15,R0,SCANREGS         SAVE IMPORTANT REGS\n\n*-------\n*        PROCESS RETURN CODE FROM GQSCAN\n*-------\n\n         C     R15,=F'8'               ERROR?\n         BH    SCANERR                 B. IF YES\n         C     R15,=F'4'               NO MATCH?\n         BE    SCANNONE                B. IF YES\n\n*-------\n*        BEGIN PROCESSING THE RIBE\n*-------\n\nSCANPROC DS    0H\n         L     R2,VGETAREA             PICK UP ADDR OF SCAN AREA\n         USING RIB,R2\n         L     R4,RIBNRIBE             PICK UP # OF RIBE\n         AH    R2,RIBVLEN              POINT TO\n         AH    R2,SCANR0HI                     FIRST RIBE\n         USING RIBE,R2\nSCANRIBE DS    0H\n         MVC   WQUEUE,=CL9'allocated'  INDICATE \"ALLOCATED\"    #DD99281\n         TM    RIBESFLG,RIBESTAT       CHECK IF WAITING        #DD99281\n         BNZ   NOWAIT                  B. IF NOT               #DD99281\n         MVC   WQUEUE,=CL9'waiting  '  INDICATE \"WAITING\"      #DD99281\nNOWAIT   DS    0H                                              #DD99281\n         MVC   WALLNAME,RIBEJBNM       COPY JOBNAME TO MSG\n         MVC   WALLSYSN,RIBESYSN       COPY SYSTEM NAME TO MSG\n         MVC   WALLSTAT,=C'SHR'        DEFAULT TO SHR\n         TM    RIBERFLG,RIBETYPE       SHARED?\n         BO    SCANBOLD                B. IF YES\n         MVC   WALLSTAT,=C'EXC'        SET TO EXCLUSIVE\n\n*-------\n*        BUILD THE OLD FOR THE ALLOCATION STATUS MESSAGE.\n*-------\n\nSCANBOLD DS    0H\n         LA    R0,6                    # OF MSG SEGMENTS       #DD99281\n         ST    R0,OLD                  SET IN OLD\n         LA    R0,GRS302               -> 1ST MSG SEGMENT\n         ST    R0,OLD+4                SET IN OLD\n         LA    R0,WDSNSEG              -> 2ND MSG SEGMENT\n         ST    R0,OLD+8                SET IN OLD\n         LH    R1,WRNAMELN             PICK UP DSNAME LNTH\n         LA    R1,4(,R1)               ADD 4 FOR SEGMENT HEADER\n         STH   R1,WDSNSEG              SET LNTH OF DSN MSG SEGMENT\n         LA    R0,GRS302DS             OFFSET TO DSN IN MSG\n         STH   R0,WDSNSEG+2            SET OFFSET TO DSN IN MSG\n         LA    R0,L'WQUEUE+4           LENGTH OF ALLOC/WAIT SEG#DD99281\n         STH   R0,WQUESEG              SET LENGTH OF INSERT    #DD99281\n         LA    R0,GRS302AW             OFFSET TO MSG INSERT    #DD99281\n         STH   R0,WQUESEG+2            SET OFFSET TO INSERT    #DD99281\n         LA    R0,WQUESEG              -> 3RD MSG SEGMENT      #DD99281\n         ST    R0,OLD+12               SET IN OLD              #DD99281\n         LA    R0,WSTATSEG             -> 3RD MSG SEGMENT\n         ST    R0,OLD+16               SET IN OLD              #DD99281\n         LA    R0,7                    LNTH OF STATUS MSG SEGMENT\n         STH   R0,WSTATSEG             SET LNTH OF STATUS MSG SEGMENT\n         LA    R0,GRS302ST             OFFSET TO STATUS IN MSG\n         STH   R0,WSTATSEG+2           SET OFFSET TO STATUS IN MSG\n         LA    R0,WNAMESEG             -> 5TH MSG SEGMENT\n         ST    R0,OLD+20               SET IN OLD              #DD99281\n         LA    R0,12                   LNTH OF JOBNAME MSG SEGMENT\n         STH   R0,WNAMESEG             SET LNTH OF JOBNAME MSG SEGMENT\n         LA    R0,GRS302NM             OFFSET TO JOBNAME IN MSG\n         STH   R0,WNAMESEG+2           SET OFFSET TO JOBNAME IN MSG\n         LA    R0,WSYSNSEG             -> 6TH MSG SEGMENT\n         ST    R0,OLD+24               SET IN OLD              #DD99281\n         LA    R0,12                   LNTH OF SYSNAME MSG SEGMENT\n         STH   R0,WSYSNSEG             SET LNTH OF SYSNAME MSG SEGMENT\n         LA    R0,GRS302SY             OFFSET TO SYSNAME IN MSG\n         STH   R0,WSYSNSEG+2           SET OFFSET TO SYSNAME IN MSG\n\n*-------\n*        ISSUE THE ALLOCATION STATUS MESSAGE\n*-------\n\nSCANPUTL DS    0H\n         PUTLINE PARM=WPTPB,                                           X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR),                         X\n               MF=(E,WIOPL)\n\n*-------\n*        POINT TO NEXT RIBE\n*-------\n\nSCANNRIB DS    0H\n         AH    R2,SCANR0L              -> NEXT RIBE\n         BCT   R4,SCANRIBE             CONTINUE IF MORE TO PROCESS\n\n*-------\n*        ALL RIBE HAVE BEEN PROCESSED. IF THE GQSCAN RETURN CODE WAS\n*        ZERO, PROCESS THE NEXT DATASET.\n*-------\n\n         ICM   R0,15,SCANR15           PICK UP RETURN CODE\n         BZ    SCANNEXT                B. IF ZERO\n\n*-------\n*        THERE WAS INSUFFICIENT STORAGE SUPPLIED TO COMPLETE THE SCAN\n*        FOR THE CURRENT DATASET.\n*-------\n\n         LA    R0,2                    # OF MSG SEGMENTS\n         ST    R0,OLD                  SET IN OLD\n         LA    R0,GRS303               -> 1ST MSG SEGMENT\n         ST    R0,OLD+4                SET IN OLD\n         LA    R0,WDSNSEG              -> 2ND MSG SEGMENT\n         ST    R0,OLD+8                SET IN OLD\n         LH    R1,WRNAMELN             PICK UP DSNAME LNTH\n         LA    R1,4(,R1)               ADD 4 FOR SEGMENT HEADER\n         STH   R1,WDSNSEG              SET LNTH OF DSN MSG SEGMENT\n         LA    R0,GRS303DS             OFFSET TO DSNAME IN MSG\n         STH   R0,WDSNSEG+2            SET OFFSET TO DSN IN MSG\n         PUTLINE PARM=WPTPB,                                           X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR),                         X\n               MF=(E,WIOPL)\n         B     SCANNEXT                CONTINUE WITH NEXT DATASET\n\n*-------\n*        AN ERROR OCCURRED DURING THE GQSCAN\n*-------\n\nSCANERR  DS    0H\n         STC   R15,WORKRC              SAVE RETURN CODE\n         UNPK  GQSCANRC,WORKRC         CONVERT RETURN CODE\n         TR    GQSCANRC,HEXCONV-C'0'   MAKE IT PRINTABLE\n         LA    R0,2                    # OF MSG SEGMENTS\n         ST    R0,OLD                  SET IN OLD\n         LA    R0,GRS301               -> 1ST MSG SEGMENT\n         ST    R0,OLD+4                SET IN OLD\n         LA    R0,RCSEG                -> 2ND MSG SEGMENT\n         ST    R0,OLD+8                SET IN OLD\n         LA    R0,6                    LNTH OF RC MSG SEGMENT\n         STH   R0,RCSEG                SET LNTH OF RC MSG SEGMENT\n         LA    R0,GRS301RC             OFFSET TO RC IN MSG\n         STH   R0,RCSEG+2              SET OFFSET TO RC IN MSG\n         PUTLINE PARM=WPTPB,                                           X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR),                         X\n               MF=(E,WIOPL)\n         B     SCANEND                 TERMINATE NOW\n\n*-------\n*        THE REQUESTED DATASET IS NOT ALLOCATED\n*-------\n\nSCANNONE DS    0H\n         LA    R0,2                    # OF MSG SEGMENTS\n         ST    R0,OLD                  SET IN OLD\n         LA    R0,GRS300               -> 1ST MSG SEGMENT\n         ST    R0,OLD+4                SET IN OLD\n         LA    R0,WDSNSEG              -> 2ND MSG SEGMENT\n         ST    R0,OLD+8                SET IN OLD\n         LH    R1,WRNAMELN             PICK UP DSNAME LNTH\n         LA    R1,4(,R1)               ADD 4 FOR SEGMENT HEADER\n         STH   R1,WDSNSEG              SET LNTH OF DSN MSG SEGMENT\n         LA    R0,GRS300DS             OFFSET TO DSNAME IN MSG\n         STH   R0,WDSNSEG+2            SET OFFSET TO DSN IN MSG\n         PUTLINE PARM=WPTPB,                                           X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR),                         X\n               MF=(E,WIOPL)\n\n*-------\n*        SCAN FOR NEXT DATASET REQUESTED\n*-------\n\nSCANNEXT DS    0H\n         ICM   R3,15,WGDSNAME+24       -> NEXT DSNAME SPECIFIED\n         BNM   SCANLOOP                B. IF NOT AT END\n         DROP  R3\n\n*-------\n*        FREE STORAGE USED FOR GQSCAN AREA\n*-------\n\nSCANEND  DS    0H\n         L     R0,VGETAREA+4           PICK UP LNTH OBTAINED\n         L     R1,VGETAREA             PICK UP ADDR\n         FREEMAIN RU,LV=(0),A=(1),SP=1\n\n*-------\n*        RESTORE REGS AND RETURN\n*-------\n\nWGEXIT   #STOP ,\n\n*-------\n*        IKJPARS DATA SET NAME PROCESSING VALIDATION EXIT\n*-------\n\n         PUSH  USING\n         DROP  ,\nDSNCHECK DS    0H\n         STM   R14,R12,12(R13)         SAVE PARSE'S REG\n         LR    R11,R15                 GET A BASE REG\n         USING DSNCHECK,R11\n         L     R12,4(,R1)              PICK UP ADDR OF WORKAREA\n         USING WRKWG,R12\n         L     R3,0(,R1)               PICK UP ADDR OF PDE\n         USING WGDSNAME,R3\n\n*-------\n*        COPY THE DATASET NAME TO THE WORKAREA\n*-------\n\n         GETMAIN RU,LV=44              ACQUIRE A DSNAME WORK AREA\n         LR    R4,R1\n         MVI   0(R4),C' '              CLEAR DSNAME\n         MVC   1(43,R4),0(R4)\n         L     R1,WGDSNAME             PICK UP ADDR OF CHAR STRING\n         LH    R15,WGDSNAME+4          PICK UP LNTH OF CHAR STRING\n         #EXEC -R15,MVC,0(*-*,R4),0(R1) COPY DSNAME TO WORKAREA\n         ST    R4,WGDSNAME             SAVE CONVERTED DSNAME ADDRESS\n\n         MVC   WRKCTGPL(LOCATEL),LOCATE\n         ST    R4,WRKCTGPL+4           FORMAT\n         LA    R0,WRKCATLG                CATALOG\n         ST    R0,WRKCTGPL+12                PARAMETER LIST\n         LOCATE WRKCTGPL               CONVERT ALIAS TO REAL NAME\n\n         LA    R1,44                   LOAD MAXIMUM DSNAME LENGTH\n         LA    R2,43(,R4)              LOAD ADDRESS OF LAST CHARACTER\nDSNCH001 DS    0H\n         CLI   0(R2),C' '              CHECK FOR END OF DSNAME\n         BNE   DSNCH002                B. IF YES\n         BCTR  R2,0                    BACK UP 1 CHARACTER\n         BCT   R1,DSNCH001             LOOP BACK TO LAST CHARACTER\nDSNCH002 DS    0H\n         STH   R1,WGDSNAME+4           SAVE CONVERTED DSNAME LENGTH\n\n         LA    R15,0                   INDICATE DSNAME IS INVALID\n         L     R14,12(,R13)            RESTORE RETURN ADDR\n         LM    R0,R12,20(R13)          RESTORE OTHER REGS\n         BR    R14                     RETURN TO PARSE\n         DROP  ,\n         POP   USING\n\n*-------\n*        CONSTANTS AND MF=L FORMS OF MACROS\n*-------\n\nHEXCONV  DC    C'0123456789ABCDEF'     USED IN HEX CONVERSION\nVULA     DC    A(1024),A(500*1024)     VAR GETMAIN VAULES\nBLANKS   DC    CL80' '                 USEFUL CONSTANT\nSYSDSN   DC    CL8'SYSDSN'             QNAME FOR ALL DATASETS\nGQSCAN   GQSCAN REQLIM=MAX,                                            X\n               SCOPE=ALL,                                              X\n               REQCNT=1,                                               X\n               MF=L\nGQSCANLN EQU   *-GQSCAN                LNTH OF GQSCAN PARAMATER LIST\n\n*-------\n*        CONSTANTS AND MF=L FORMS OF MACROS\n*-------\n\nPTPB     PUTLINE MF=L                  GENERAL PUTLINE PARAMETER BLOCK\nLPTPB    EQU   *-PTPB                  LNTH OF PTPB\nDUMMY    DS    0C\n\nGETMAIN  GETMAIN VU,LA=VULA,SP=1,MF=L\nLGETMAIN EQU   *-GETMAIN\n\n*-------\n*        MESSAGES\n*-------\n\nGRS300   #MSG  'WHO300I Dataset  not allocated'\nGRS300DS EQU   16                      OFFSET TO DSN IN MSG\n\nGRS301   #MSG  'WHO301I Unexpected return code from GQSCAN, RC='\nGRS301RC EQU   47                      OFFSET TO RETURN CODE IN MSG\n\nGRS302   #MSG  'WHO302I    by  on '                            #DD00147\nGRS302DS EQU   8                       OFFSET TO DSN IN MSG\nGRS302AW EQU   9                       OFFSET TO ALLOCATED/WAITING  281\nGRS302ST EQU   10                      OFFSET TO SHR/EXC IN MSG     281\nGRS302NM EQU   14                      OFFSET TO JOBNAME IN MSG     281\nGRS302SY EQU   18                      OFFSET TO SYSTEM NAME IN MSG 147\n\nGRS303   #MSG  'WHO303I Insufficient storage to complete scan for '\nGRS303DS EQU   50                      OFFSET TO DSN IN MSG\n\n*-------\n*        PCL FOR WHOSGOT COMMAND\n*-------\n\n         PRINT ON,NOGEN\nWGPCL    IKJPARM DSECT=WGPDL\nWGDSNAME IKJPOSIT DSNAME,USID,LIST,VALIDCK=DSNCHECK,                   X\n               PROMPT='DATASET NAME'\n         IKJENDP\n         PRINT ON,GEN\n\nLOCATE   CAMLST NAME,*-*,,*-*\nLOCATEL  EQU   *-LOCATE\n         #STARTWA ,\nOLD      DS    10F                     OLD WITH UP TO 9 MSG SEGMENTS\nWORKECB  DS    F                       ECB FOR PUTLINE AND IKJPARS\nWORKPDLP DS    A                       POINTER TO PDL\nVGETAREA DS    2F                      VAR GETMAIN ADDR AND LNTH\nSCANREGS DS    2F                      GQSCAN REGS R15,R0\n         ORG   SCANREGS\nSCANR15  DS    F                       RETURN FROM GQSCAN\nSCANR0HI DS    H                       HI-ORDER  2 BYTES = RIB  LNTH\nSCANR0L  DS    H                       LOW-ORDER 2 BYTES = RIBE LNTH\n         ORG   ,\nWRKCTGPL CAMLST NAME,*-*,,*-*\nWRKCATLG DS    0F,265C                 CATALOG LOCATE WORKAREA\nWORKPPL  DS    0F,XL(LPPL)             PARSE PARAMETER LIST\nWGETMAIN DS    XL(LGETMAIN)            MF=E GETMAIN\nWPTPB    DS    XL(LPTPB)               MF=E PUTLINE\nWIOPL    DS    XL(LIOPL)               I/O SERVICES PARAMETER LIST\nWGQSCAN  DS    XL(GQSCANLN)            MF=E GQSCAN\nWRNAMELN DS    H                       LENGTH OF DSNAME AS RNAME\nWDSNSEG  DS    2H                      DSN MSG SEGMENT\nWRKDSNAM DS    CL44                    RNAME=DSNAME FOR GQSCAN\nWQUESEG  DS    2H                      ENQ QUEUE MSG SEGMENT   #DD99281\nWQUEUE   DS    CL9                     ALLOCATED/WAITING       #DD99281\nWSTATSEG DS    2H                      SHR/EXC MSG SEGMENT\nWALLSTAT DS    CL3' '                  SHR/EXC\nWSYSNSEG DS    2H                      SYSTEM NAME MSG SEGMENT\nWALLSYSN DS    CL8' '                  SYSTEM NAME\nWNAMESEG DS    2H                      JOBNAME/TSOUSER/STCNAME MSG SEG\nWALLNAME DS    CL8' '                  JOBNAME/TSOUSER/STC NAME\nWORKRC   DS    XL2                     WORK FOR RETURN CODE CONVERSION\nRCSEG    DS    2H                      RC MSG SEGMENT\nGQSCANRC DS    CL3                     WORK FOR RETURN CODE CONVERSION\n         #STOPWA ,\n\n*-------\n*        THE FOLLOWING MACROS GENERATE DSECTS WHICH ARE MAPPED IN THE\n*        DEBUGGING HANDBOOKS AND THUS ARE NOT EXPANDED HERE.\n*-------\n\n         PRINT ON,NOGEN\n         IKJCPPL\n         IKJUPT\n         IKJPPL\nLPPL     EQU   *-PPL\n         IKJIOPL\nLIOPL    EQU   *-IOPL\n         ISGRIB\n         #DSECTS CVT\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT452/FILE452.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT452", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}