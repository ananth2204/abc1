***********************************************************************
*LLL      GGGGGGG M     M H      H LLL      RRRRRRR  CCCCCCC BBBBBBB  *
* L       G     G MM   MM H      H  L       R      R C     C B      B *
* L       G       M M M M H      H  L       R      R C       B      B *
* L       G  GGGG M  M  M HHHHHHHH  L       RRRRRRR  C       BBBBBBB  *
* L       G     G M     M H      H  L       R    R   C       B      B *
* L       G     G M     M H      H  L       R     R  C     C B      B *
* LLLLLLL GGGGGGG M     M H      H  LLLLLLL R      R CCCCCCC BBBBBBB  *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHLRCB                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Above-the-Line Log Record Buffering*
*                                                                     *
* INPUT REGS:      R1  => Standard z/OS Parameter List                *
*                  R14 => Return Point                                *
*                  R13 => Caller's Save Area                          *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to LGRWK2II Logger Work Area        *
*                         (Mapped by LGCPLSWA CopyBook)               *
*                  Parm2: Pointer to Area Containing Count of Log     *
*                         Records in Temporary Work Area              *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return Address                                *
*                  R13, Save Area & Dynamic Area                      *
*                  R12, (RBASE1) Program Base Register                *
*                  R11, (RBASE2) Program Base Register                *
*                  R10, (RCOMM1) Common Dynamic Area                  *
*                  R9,  (RCOMM2) Common Dynamic Area                  *
*                  R8,  (RCOMM3) Common Constants/Routines            *
*                  R7,  (RCOMM4) Common Constants/Routines            *
*                  R0-R6, General Work Registers                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCT - Logger Services Termination Program     *
*                  LGMHRTRY - Logger Services Abend Retry Program     *
*                  LGMHLRCE - Logger Services Log Record Event        *
*                             Publishing Program                      *
*                                                                     *
* CALLED PROGRAMS: LBFR0000 - To Process Insertion of Log Records     *
*                             Into the Buffers.                       *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Serious Error                                 *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Change   V1R1M17 20120721 Support New Fields Expanded from 4 to@@KHF*
*                           8 Bytes in Log Record Control Blocks.@@KHF*
* Update   V1R1M16 20120127 Update VV.RR.MM stats for Fix Pack 16@@KHF*
* Update   V1R1M15 20110930 Update VV.RR.MM stats for Fix Pack 15@@KHF*
* Update   V1R1M14 20110423 Update VV.RR.MM stats for Fix Pack 14@@KHF*
* Update   V1R1M13 20110108 Update VV.RR.MM stats for Fix Pack 13@@KHF*
* Update   V1R1M12 20100306 Update VV.RR.MM stats for Fix Pack 12@@KHF*
* Update   V1R1M11 20091023 Update VV.RR.MM stats for Fix Pack 11@@KHF*
* Update   V1R1M10 20090523 Update VV.RR.MM stats for Fix Pack 10@@KHF*
* Update   V1R1M09 20090110 Updated VV.RR.MM stats for Fix Pack 9@@KHF*
* Update   V1R1M08 20081010 Updated VV.RR.MM stats for Fix Pack 8@@KHF*
* Change   V1R1M07 20080524 Renumbered LGA Msgs (LGA1111A-1114A) @@KHF*
* Fix      V1R1M06 20080223 LGA01109A Not Suppressed on Overrun 6@@KHF*
* Update   V1R1M05 20080112 Updated VV.RR.MM stats for Fix Pack 5@@KHF*
* Update   V1R1M04 20071104 Updated VV.RR.MM stats for Fix Pack 4@@KHF*
* Update   V1R1M03 20070701 Updated VV.RR.MM stats for Fix Pack 3@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Updated VV.RR.MM stats for Fix Pack 1@@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Logger Program
         LCLC  &RMODE              Resident Mode of Logger Program
&KXHVER  SETC  'V1'                Indicate the Program Version Number
&KXHREL  SETC  'R1'                Indicate the Program Release Number
&KXHMOD  SETC  'M17'               Indicate the Pgm Modification Level
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&CPYRITE SETC  '2008,2012'         Program Copyright Year
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
&MODID   SETC  'LGMHLRCB'          Set the Program Module Identifier
*
R0       EQU   0                   Define Program Register 0 Equate
R1       EQU   1                   Define Program Register 1 Equate
R2       EQU   2                   Define Program Register 2 Equate
R3       EQU   3                   Define Program Register 3 Equate
R4       EQU   4                   Define Program Register 4 Equate
R5       EQU   5                   Define Program Register 5 Equate
R6       EQU   6                   Define Program Register 6 Equate
R7       EQU   7                   Define Program Register 7 Equate
R8       EQU   8                   Define Program Register 8 Equate
R9       EQU   9                   Define Program Register 9 Equate
R10      EQU   10                  Define Program Register 10 Equate
R11      EQU   11                  Define Program Register 11 Equate
R12      EQU   12                  Define Program Register 12 Equate
R13      EQU   13                  Define Program Register 13 Equate
R14      EQU   14                  Define Program Register 14 Equate
R15      EQU   15                  Define Program Register 15 Equate
*
RPDX     EQU   6                   Log Records Primary Index Block
RSDX     EQU   5                   Log Records Secondary Index Block
REDB     EQU   4                   Log Records Buffer Area Block
         EJECT  ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHLRCB - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHLRCB                                           *
*                                                                     *
* FUNCTION:        Log Record Buffer Service                          *
*                                                                     *
*                  This routine is the main driver and entry point for*
*                  processing the Log Records to a buffer area that is*
*                  above-the-line. This program is called when two    *
*                  global options have been set when LPGMNTRY=MAIN is *
*                  specified in a user program. If logging is enabled *
*                  by the user program specifying the "LOG=ON" option,*
*                  and if above-the-line buffering is also enabled by *
*                  the user program specifying the "LOGOUT=BUFR"      *
*                  option, then as program LGMHLRCE generates log     *
*                  records, this LGMHLRCB program will be called      *
*                  by program LGMHLRCE to write the log output records*
*                  to a buffer area above-the-line.                   *
*                                                                     *
*                  Upon a normal end of the user's program, the Logger*
*                  Services program LGMHLRCT will write all of the    *
*                  logger records in the above-the-line storage areas *
*                  to the //LGRECOUT DD data set. When LGMHLRCT has   *
*                  completed printing the log records it will call    *
*                  this LGMHLRCB program to release the above-the-line*
*                  storage areas used to hold the indices and log     *
*                  records.                                           *
*                                                                     *
*                  Upon an abend of the user's program, the Logger    *
*                  Services retry program LGMHRTRY will write all of  *
*                  the logger records in the memory objects to the    *
*                  //LGRECOUT DD data set. When LGMHRTRY has completed*
*                  printing the log records then as part of its clean *
*                  up and prior to percolating the abend it will call *
*                  this LGMHLRCB program to release the above-the-line*
*                  storage areas used to hold the indices and log     *
*                  records.                                           *
*                                                                     *
* INPUT REGS:      R1 => Standard z/OS Parameter List                 *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE                                           *
*                                                                     *
* CALLED PROGRAMS: LBFR0000 - Logger Record Insertion Program         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error        (Buffer Overrun)                 *
*                  12 - Severe Error (Storage Exhausted)              *
*                                                                     *
***********************************************************************
*
&MODID   RSECT *                   Main Pgm Read-Only Control Section
&MODID   AMODE &AMODE              Program Addressing Mode -  &AMODE
&MODID   RMODE &RMODE              Program Residence Mode - &RMODE
         SYSSTATE AMODE64=YES,ARCHLVL=2 ...Establish 64-Bit Environment
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LGMA0002 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   DUMMYPNT            Branch Past the Literal Area
         DC    C'&MODID'           Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
       SPLEVEL SET=6               Set for OS/390 R2 or Above (z/OS+)
         DC    50S(*)              Define a Patch Area
DUMMYPNT DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         LA    RBASE2,2048(,RBASE1)  Load 2nd Base w/ Addressable Range
         LA    RBASE2,2048(,RBASE2)  Add to the Preceding Address Range
         USING &MODID+(LGMA0002-LGMHLRCB),RBASE1,RBASE2   Set Base Regs
         LGR   R2,R13              Preserve Caller's Save Area Address
         LLGF  R14,=A(LGW$AREA-LGRWK2II) Index to the Logger Work Area
         LG    R3,0(R1)            Get Starting Address to Work Area
         LA    R3,0(R14,R3)        Point to General Area in Work Area
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
*
*+-------------------------------------------------------------------+*
*| Establish Addressability To A Working Storage Area Within The     |*
*| LGRWK2II Area.                                                    |*
*+-------------------------------------------------------------------+*
*
LRCB1000 DS    0H
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LGR   RCOMM1,R3           Establish Common Work Area Address
         LA    RCOMM2,4095(,RCOMM1) ...Establish Second Base Register
         LA    RCOMM2,1(,RCOMM2)   Remove Overlap of Addressable Range
         LLGT  RCOMM3,=A(COM#P2L8) Common Constants and Routines Area
         LA    RCOMM4,4095(,RCOMM3) ...Establish Second Base Register
         LA    RCOMM4,1(,RCOMM4)   Remove Overlap of Addressable Range
         LG    R1,LCAF64R01-LCASAVE(,R2) Restore Parameter List Address
         LMG   R1,R2,0(R1)         Get the Input Parameters
         STG   R1,COMLG2II         Preserve the Pointer to LGRWK2II
         STG   R2,COMRCDCT         Save the Current Log Record Count
         MVC   COM@EYEC,=CL32'LGMHLRCB COMMON AREA' .Set the Eyecatcher
         XC    COMRETCD,COMRETCD   Initialize the Return Code Area
*
*+-------------------------------------------------------------------+*
*| The Current Log Record Entries Generated by the LGMHLRCE Program  |*
*| Are in the LGRWK2II Temporary Work Area. Now Copy the Log Record  |*
*| Entries From The LGRWK2II Temporary Work Area To The Accumulation |*
*| Buffer Areas.                                                     |*
*+-------------------------------------------------------------------+*
*
LRCB2000 DS    0H
         XC    COMPLIST,COMPLIST   Clear the Call Parameter List
         CALL  LBFR0000,           Process the Log Records to Buffer   X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               COMLG2II,           ..Pass Pntr to the Logger Work Area X
               COMRCDCT),          ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,COMPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Write Log Records to Buffer Area
         LTGFR R15,R15             Was the Insert Request Successful?
         BRZ   LRCB2100            Yes => Branch to Process Request
         ST    R15,COMRETCD        Save Highest Return Code Genearated
         LGHI  R2,((LRCB3000-LRCB2100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LRCB2100            No  => Process Return From Insert
         BRU   LRCBEXIT            Branch to Exit This Routine
LRCB2100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LRCB3000            Process for Records Inserted
         BRU   LRCB3000            Process on Warning
         BRU   LRCB3000            Process on Validation Error
         BRU   LRCBEXIT            Process for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Retain Virtual Storage Old Area and Release Physical Paging to   |*
*|  Clear the Portion of the LGRWK2II Area Being Re-Used as a        |*
*|  Temporary Working Storage Area.                                  |*
*+-------------------------------------------------------------------+*
*
LRCB3000 DS    0H
         LG    R1,COMLG2II         Get the Pointer to the LGRWK2II Area
         LTGR  R1,R1               Is a Pointer Available to LGRWK2II?
         BRZ   LRCB$END            No  => Then Branch to Exit Routine
         LLGF  R0,=A(LGW$AREL)     Obtain the Log General Work Length
         LLGF  R2,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R1,0(R2,R1)         Point to the Log Record Area
         LGR   R3,R1               Log Record Area Starts Work Area
         LGR   R15,R1              General Wrk Area in Our Logger Area
         AGR   R15,R0              Calculate Ending Addr General Area
         NG    R15,=AD(-4096)      Round Area Down to a Page Boundary
         BCTGR R15,R0              Ensure Pointing to Actual End Addr
         LA    R1,4095(,R1)        Add 4K to Existing Starting Address
         NG    R1,=AD(-4096)       Round It Up to Full Page Boundary
         CGR   R15,R1              Any Page Aligned Areas to Release?
         BRNH  LRCB3100            No  => Branch for a Physical Clear
       PGSER R,RELEASE,            Release the General Work Area Pages X
               A=(1),              Addr of Start of General Work Area  X
               EA=(15),            Address of Last Byte in General AreaX
               BRANCH=N            Using SVC Entry for Paging Service
         BRU   LRCB$END            Branch to Exit This Routine
LRCB3100 DS    0H
         LGR   R0,R3               Point to Logger General Work Area
         LLGF  R1,=A(LGW$AREL)     Obtain Logger General Area Length
         SLGR  R14,R14             Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Logger General Wrk Area
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LRCB$END DS    0H
         SLGR  R15,R15             Indicate Successful Completion
LRCBEXIT DS    0H
         ST    R15,COMRETCD        Save Highest Return Code Generated
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove All Listed Regs as Base Regs
*
***********************************************************************
*                 End of LGMHLRCB Main Program                        *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L B F R 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   I n s e r t   I n t o   D a t a   B u f f e r s  |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LBFR0000                                           *
*                                                                     *
* FUNCTION:        Insert Log Record Into Above-the-Line Data Buffers *
*                                                                     *
*                  This routine is responsible for the insertion of   *
*                  log records into the buffer area. This routine     *
*                  directs the call to other log record insertion     *
*                  routines.                                          *
*                                                                     *
*                  As part of the insertion process this routine will *
*                  manage and maintain the buffer areas and indices   *
*                  through search, sort, and insertion functionsÝ1/2¨.*
*                                                                     *
*                  Upon the first call to this routine the primary    *
*                  index pointer field is zero, and initialization is *
*                  performed. Initialization process will consist of  *
*                  of acquiring the storage areas for the primary     *
*                  index block, the first secondary index block, and  *
*                  the first buffer area to hold log records.         *
*                                                                     *
*                  After initialization, this program will move the   *
*                  log records from the temporary work area to the    *
*                  accumulation buffers. As this program is called    *
*                  continuously to handle a new block of records being*
*                  passed from the LGMGLRCE program, it will perform  *
*                  any required expansion of the index blocks as the  *
*                  buffers fill with additional log records.          *
*                                                                     *
*                  A primary index control block is a formatted area  *
*                  which will contain address entries that are        *
*                  pointers to secondary index control blocks which   *
*                  themselves have address entries which point to the *
*                  individual log records in the buffer areas.        *
*                                                                     *
*                  Our input will be log records from a temporary     *
*                  work area which will be written to the buffer      *
*                  areas. Each input log record is indexed. Before    *
*                  insertion a search is done to calculate a slot     *
*                  position in the index area to hold the pointer to  *
*                  the record to be inserted in a buffer area. During *
*                  this search for an index slot position, each log   *
*                  record will also be checked to determine if the    *
*                  record key already exists in the buffers to prevent*
*                  the insertion of any duplicate entries. If a       *
*                  duplicate, the input record is ignored. If not,    *
*                  then the log input record is inserted into the     *
*                  buffers and the index updated.                     *
*                                                                     *
*                  *Ý1¨Professor Donald E. Knuth, Stanford University *
*                      The Art of Computer Programming, Volume 3,     *
*                      2nd Edition, Sorting and Searching             *
*                      Addison-Wesley Publishing, 1998.               *
*                                                                     *
*                  *Ý2¨Professor Spotwood D. Stoddard, University of  *
*                      Nebraska - Lincoln                             *
*                      Principles of Assembler Language Programming   *
*                      for the IBM 370, McGraw-Hill, 1985.            *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Logger Work Area         *
*                  Parm6: Addr of Area for No. of Log Record Entries  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LGMHLRCB - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: LIDX0000 - To Process Build of Log Record Indices  *
*                  LFND0000 - To Process Find of Log Record Index Slot*
*                  LEXP0000 - To Process Expand of Index Blocks       *
*                  LINS0000 - To Process Insert of a Log Record       *
*                  LRLS0000 - To Process Clean Up of Indices          *
*                  WTO      - To Process Messages                     *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
LBFR0000 RSECT *                   Read-Only Control Section Name
LBFR0000 AMODE &AMODE              Establish Addressing Mode
LBFR0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LBFR0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   LBFR0002            Branch Past the Literal Area
         DC    C'LBFR0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLvl
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LBFR0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LBFR0000+(LBFR0001-LBFR0000),RBASE1  Set Addressability
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) Load Common Area Addresses
         LMG   R1,R2,LCAF64R01-LCASAVE(R1)  Get the Input Parameters
         STG   R1,LTBLG2II         Save the Logger Work Area Pointer
         LG    R2,0(,R2)           Get the Count of Record Entries
         STG   R2,LBFRCDCT         Save the Log Record Entry Count
         XC    COMRETCD,COMRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Check if We Have Index Areas and a Buffer Area. If Yes, Then      |*
*| Proceed to Insert the Logger Records. If No, Then This is the     |*
*| First Time Through and Need to Build the Initial Log Record       |*
*| Indices and Buffer Area to Hold Log Records.                      |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R4         Establish Addressability to Log Area
LBFR0100 DS    0H
         LG    R4,LTBLG2II         Get Pntr to Logger Work Area Address
         LG    R4,0(,R4)           Get Address to Logger Work Area
         LA    R3,LGWTSTCK         Get Addr to Log Record Time Stamp
         STG   R3,LBFTRTIM         Save Addr to Log Record Time Stamp
         LA    R3,LGWTCBAD         Get Addr to User Program TCB Address
         STG   R3,LBFTCBAD         Save the User Program TCB Address
         LA    R3,LGWACCUM         Get Addr to Log Record Accumulator
         STG   R3,LBFACCUM         Save the Log Record Accum Address
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R4)         Point to the Log Record Area
         STG   R3,LBFINPUT         Save the Log Record Area Pointer
         LG    RPDX,LGWPINDX       Get the Primary Index Block Address
         LTGR  RPDX,RPDX           Is the Primary Index Already Built?
         BRZ   LBFR0200            No  => Branch to Build Log Indices
         STG   RPDX,LBFPINDX       Save the Primary Index Block Address
         CLM   R2,B'1111',=A(X'7FFFFFFF') High Value Indicate No More?
         BRE   LBFR1000            Yes => All Done, Branch to Clean Up
         BRU   LBFR2000            No  => Branch to Insert Log Records
LBFR0200 DS    0H
         LA    R1,LGWPINDX         Get Pointer to Primary Index Table
         STG   R1,LBFPINDX         Save Pointer to Primary Index Table
         XC    COMPLIST,COMPLIST   Clear the Call Parameter List
         CALL  LIDX0000,           Perform Build of the Buffer Indices X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               LBFPINDX),          ..Pass Log Rcd Primary Index PointerX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,COMPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Build the Buffer Indices
         LTGFR R15,R15             Build Process Complete Successfully?
         BRZ   LBFR0500            Yes => Branch to Process Log Records
         LGHI  R2,((LBFR0600-LBFR0500)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LBFR0500            No  => Process Index Build Request
         BRU   LBFREXIT            Process for Error
LBFR0500 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LBFR0600            Log Rcds Index/Data Blks Processed
         BRU   LBFREXIT            Process for Warning
         BRU   LBFREXIT            Process for Validation Error
         BRU   LBFREXIT            Process for Severe Error - Exit
LBFR0600 DS    0H
         LG    R2,LBFPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R2)         Get the Primary Index Block Address
         STG   RPDX,LBFPINDX       Save the Primary Index Block Address
         BRU   LBFR2000            Branch to Process Input Log Records
         DROP  R4                  Remove Listed Reg as Log Area Base
*
*+-------------------------------------------------------------------+*
*|         Clean Up The Log Record Indices and Buffer Areas          |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R4         Establish Addressability to Logger
LBFR1000 DS    0H
         XC    COMPLIST,COMPLIST   Clear the Call Parameter List
         CALL  LRLS0000,           Perform Clean Up of Buffer Indices  X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               LBFPINDX),          ..Pass Log Rcd Primary Index PointerX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,COMPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Release the Buffer Areas
         LTGFR R15,R15             Clean Process Complete Successfully?
         BRZ   LBFR1100            Yes => Branch to Complete Clean-Up
         LGHI  R2,((LBFR1200-LBFR1100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LBFR1100            No  => Process Index Clean Request
         BRU   LBFREXIT            Process for Error
LBFR1100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LBFR1200            Log Index/Buffer Areas Released
         BRU   LBFREXIT            Process for Warning
         BRU   LBFREXIT            Process for Validation Error
         BRU   LBFREXIT            Process for Severe Error - Exit
LBFR1200 DS    0H
         LG    R4,LTBLG2II         Get Pntr to Logger Work Area Addr
         LG    R4,0(,R4)           Get Address to the Logger Work Area
         LG    RPDX,LBFPINDX       Get the Primary Index Block Address
         STG   RPDX,LGWPINDX       Clear the Primary Index Blk Address
         XC    TASKROWC,TASKROWC   Clear Count of Log Record Rows
         XC    TASKPRTC,TASKPRTC   Clear Area for Print Entries Counter
         BRU   LBFR$END            Branch to Exit This Routine
         DROP  R4                  Remove Listed Register as Base Reg
*
*+-------------------------------------------------------------------+*
*|   Search The Log Record Indices To Find an Index Slot Position    |*
*|   in the Index Area to Hold the Buffer Address for the Log Record |*
*|   to be Inserted in the Buffer.                                   |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish Addressability to 1st Indx
         USING LOGSIBLK,RSDX       Establish Addressability to 2nd Indx
         USING LOGTRBLK,REDB       Establish Addressability to Data Tbl
LBFR2000 DS    0H
         LG    R2,LBFINPUT         Get Current Pntr to Log Record Area
         LG    R4,LBFRCDCT         Get Count of Rows in Log Record Area
LBFR2100 DS    0H
         STG   R4,LBFROWCT         Save Current Count of Rows in Buffer
         LG    R3,LBFACCUM         Get the Log Record Accum Address
         LLGF  R1,0(,R3)           Get the Log Record Accumulate Count
         LA    R1,1(,R1)           Increment to Use as Rcd Sequence No.
         ST    R1,0(,R3)           Save Updated Record Accumulate Count
LBFR2200 DS    0H
         XC    COMPLIST,COMPLIST   Clear the Call Parameter List
         CALL  LFND0000,           Perform Find and Set Slot Position  X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               LBFPINDX,           ..Pass the Primary Index Pointer    X
               LBFSINDX,           ..Pass the Secondary Index Pointer  X
               LBFTRTBL,           ..Pass the Log Buffer Area Pointer  X
               LBFINPUT,           ..Pass the Log Record Area Pointer  X
               LBFOSLOT,           ..Pass the Slot Position Pointer    X
               LBFTRTIM,           ..Pass the Log Record TimeStamp AddrX
               LBFTCBAD,           ..Pass the Current TCB Address      X
               LBFACCUM),          ..Pass the Current Recrd Accum CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,COMPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Search for Slot Position
         LTGFR R15,R15             Find Process Complete Successfully?
         BRZ   LBFR2500            Yes => Process Current Log Record
         ST    R15,LBF$RTCD        Save Highest Return Code Generated
         LGHI  R2,((LBFR3000-LBFR2500)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LBFR2500            No  => Process Log Find Request
         BRU   LBFR7000            Process for Error
LBFR2500 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LBFR3000            Recrd Entry Not in Table - Have Slot
         BRU   LBFR6000            Recrd Entry Found in Tbl - Duplicate
         BRU   LBFR7000            Process for Validation Error
         BRU   LBFR7000            Process for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Verify If There is Sufficient Space in the Secondary Index Block |*
*|  To Insert A Log Record. A Secondary Index Block Will Contain     |*
*|  Pointers To The Log Records In The Buffers. If The Secondary     |*
*|  Index Block Has Filled, Then Expand The Current Index Block Into |*
*|  Two Separate Index Blocks To Make More Room To Hold an Index     |*
*|  Entry To The Log Record We Are Trying To Insert Into a Buffer.   |*
*+-------------------------------------------------------------------+*
*
LBFR3000 DS    0H
         LA    R1,LBFSINDX         Get Pointer to Secondary Index Block
         LG    RSDX,0(,R1)         Get the Secondary Index Block Addr
         LA    R14,LOGSINDX        Get the Last Available Slot Address
         CG    R14,LOGSIFST        Is This Secondary Index Block Full?
         BRNE  LBFR5000            No  => Branch to Insert Log Record
LBFR3100 DS    0H
         LA    R14,LOGPINDX        Get the Last Available Slot Address
         CG    R14,LOGPIFST        First Populated Slot to Overrun Blk?
         BRNE  LBFR4000            No  => Branch to Process Block Split
LBFR3200 DS    0H
         MVI   LGRWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LGRWTOMG+1(L'LGRWTOMG-1),LGRWTOMG ..Propagate the Blank
         MVC   LGRWTOMG(L'LGA01111),LGA01111 Indicate Prim Blk Overrun
         MVC   LGRWTOLN,=Y(L'LGRWTOMG) ..Set the Length of the Message
         MVC   LGRWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LBFR3300 DS    0H
         WTO   TEXT=LGRWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LGRWTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Set for Primary Index Buffer Overrun
         ST    R15,LBF$RTCD        Save Highest Return Code Generated
         BRU   LBFR7000            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| A Secondary Index Block Has Filled and Cannot Hold More Entries.  |*
*| Create a New Secondary Index Block To Expand The Secondary Index  |*
*| Area. Then Go Back To Re-Calculate A New Index Slot Position In   |*
*| the Expanded Secondary Index Area To Hold The Pointer To the Log  |*
*| Record That is Waiting To Be Inserted.                            |*
*+-------------------------------------------------------------------+*
*
LBFR4000 DS    0H
         XC    COMPLIST,COMPLIST   Clear the Call Parameter List
         CALL  LEXP0000,           Perform Expand of Log Rcrds Indx BlkX
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               LBFPINDX,           ..Pass Log Rcd Primary Index PointerX
               LBFSINDX),          ..Pass Log Rcd Secondary Index Pntr X
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,COMPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Expand of Indx Blk
         LTGFR R15,R15             Expansion Complete Successfully?
         BRZ   LBFR4100            Yes => Branch to Set Slot Position
         ST    R15,LBF$RTCD        Save Highest Return Code Generated
         LGHI  R2,((LBFR4200-LBFR4100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LBFR4100            No  => Process Log Record Insert
         BRU   LBFR7000            Process for Error
LBFR4100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LBFR4200            Process Search for New Slot Position
         BRU   LBFR7000            Process for Index Block Expand Error
         BRU   LBFR7000            Process for Index Block Expand Error
         BRU   LBFR7000            Process for Severe Error - Exit
LBFR4200 DS    0H
         BRU   LBFR2200            Go Back to Find a New Slot Position
*
*+-------------------------------------------------------------------+*
*|     Perform The Insert Of the Log Record Into The Buffer Area     |*
*+-------------------------------------------------------------------+*
*
LBFR5000 DS    0H
         XC    COMPLIST,COMPLIST   Clear the Call Parameter List
         CALL  LINS0000,           Perform Insert of Log Record Entry  X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               LBFPINDX,           ..Pass Log Rcd Primary Index PointerX
               LBFSINDX,           ..Pass Log Rcd Secondary Indx Pntr  X
               LBFINPUT,           ..Pass Log Record Entry Pointer     X
               LBFOSLOT,           ..Pass Log Rcd Slot Position PointerX
               LBFTRTIM,           ..Pass the Log Record Timer Addr    X
               LBFTCBAD,           ..Pass the the Current TCB Address  X
               LBFACCUM),          ..Pass the Current Recrd Accum CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,COMPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Insert Log Recrd in Buffer
         LTGFR R15,R15             Insert of Log Record Successfull?
         BRZ   LBFR5100            Yes => Branch to Process Next Insert
         ST    R15,LBF$RTCD        Save Highest Return Code Generated
         LGHI  R2,((LBFR6000-LBFR5100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LBFR5100            No  => Process Return From Routine
         BRU   LBFR7000            Process for Error
LBFR5100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LBFR6000            Log Record Data Component Inserted
         BRU   LBFR7000            Log Record Error
         BRU   LBFR7000            Log Record Validation Error
         BRU   LBFR7000            High Severity Error
*
*+-------------------------------------------------------------------+*
*|   Loop Point to Insert Next Log Record in Work Area to Buffers    |*
*+-------------------------------------------------------------------+*
*
LBFR6000 DS    0H
         LG    R2,LBFINPUT         Get Current Pointer to Log Rcrd List
         LA    R2,L'LGWLINE(,R2)   Move to Next Log Record Entry in Lst
         STG   R2,LBFINPUT         Preseve New Pointer in Record List
         LG    R4,LBFROWCT         Get Current Count of Rows in List
         BRCTG R4,LBFR2100         Loop to Process Next Log Recrd Entry
LBFR6100 DS    0H
         SLGR  R15,R15             Clear the Condition Code Indicator
         ST    R15,LBF$RTCD        Set Highest Return Code Generated
         BRU   LBFR7100            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|  Set Condition Code For Insert Log Records to Buffer Processing   |*
*+-------------------------------------------------------------------+*
*
LBFR7000 DS    0H
         ST    R15,LBF$RTCD        Set Highest Return Code Generated
LBFR7100 DS    0H
         LLGF  R15,LBF$RTCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  LBFR$END            No  => Branch to Exit This Routine
         ST    R15,COMRETCD        Save Highest Return Code Generated
         BRU   LBFREXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LBFR$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
LBFREXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*           End of Log Record Component Buffer Processing             *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*| RRRRRRR   OOOOO  U     U TTTTTTT IIIIIII N     N EEEEEEE   SSSSS  |*
*| R      R O     O U     U    T       I    NN    N E        S     S |*
*| R      R O     O U     U    T       I    N N   N E        S       |*
*| RRRRRRR  O     O U     U    T       I    N  N  N EEEEEE    SSSSS  |*
*| R    R   O     O U     U    T       I    N   N N E              S |*
*| R     R  O     O U     U    T       I    N    NN E        S     S |*
*| R      R  OOOOO   UUUUU     T    IIIIIII N     N EEEEEEE   SSSSS  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************| L I D X 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   B u i l d   O f   B u f f e r    I n d i c e s   |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LIDX0000                                           *
*                                                                     *
* FUNCTION:        Build Log Record Index                             *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  initial build of the log record data indices and   *
*                  buffer area upon the first time through.           *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LBFR0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: WTO      - To Process Messages                     *
*                  STORAGE  - To Acquire Storage                      *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Build Index Process                  *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
LIDX0000 RSECT *                   Read-Only Control Section Name
LIDX0000 AMODE &AMODE              Establish Addressing Mode
LIDX0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LIDX0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   LIDX0002            Branch Past the Literal Area
         DC    C'LIDX0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLvl
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LIDX0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LIDX0000+(LIDX0001-LIDX0000),RBASE1  Set Addressability
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LG    R1,LCAF64R01-LCASAVE(,R1)  Get the Input Parameters
         STG   R1,LDXPINDX         Save Primary Index Block Pointer Adr
         XC    COMRETCD,COMRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|   Acquire Dynamic Storage For The First Log Records Buffer Area   |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
LIDX1000 DS    0H
         LLGF  R0,=A(LOGPIDBS)     Indicate Size of Initial Data Block
       STORAGE OBTAIN,             Get Dynamic Storage for Buffer Area X
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(31,64)         Dynamic Storage Area Above the Line
         LGR   REDB,R1             Get Address of First Buffer Area Blk
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LIDX1200            Yes => Branch to Process Slot Pntrs
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LIDX1300            No  => Branch to Issue Error Message
LIDX1100 DS    0H
         LGR   R0,R1               Starting Address of Buffer Area Blk
         LLGF  R1,=A(LOGPIDBS)     Set Leng of Log Records Data Block
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Log Records Data Blk
LIDX1200 DS    0H
         LLGF  R14,=A(LOGPIDBS)    Obtain Size of Log Recrds Data Block
         STG   R14,LOGTRSIZ        Set Size in our Log Recrd Data Block
         LA    R14,LOGTRHLN(,REDB) Add the Length of the Header Section
         STG   R14,LOGTRSLT        Set Address of First Available Slot
         BRU   LIDX2000            Branch to Process Secondary Indx Blk
*
*+-------------------------------------------------------------------+*
*|   Issue Error Msg for Log Records Buffer Area Storage Failure     |*
*+-------------------------------------------------------------------+*
*
LIDX1300 DS    0H
         CVD   R15,COMWORKD        Create Decimal Version Return Code
         OI    COMWORKD+L'COMWORKD-1,15 Certify Sign to Make Printable
         LA    R1,LDX$RTCD         Address of Area for Message Variable
         UNPK  0(4,R1),COMWORKD    Create a Visible Return Code
LIDX1400 DS    0H
         MVI   LGRWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LGRWTOMG+1(L'LGRWTOMG-1),LGRWTOMG ..Propagate the Blank
         MVC   LGRWTOMG(L'LGA01112),LGA01112 Indicate Data Blk Storage
         MVC   LGRWTOMG+L'LGA01112(4),0(R1) Get the Getmain Return Code
         MVC   LGRWTOLN,=Y(L'LGRWTOMG) ..Set the Length of the Message
         MVC   LGRWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LIDX1500 DS    0H
         WTO   TEXT=LGRWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LGRWTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Termination Error
         ST    R15,COMRETCD        Save Highest Return Code Generated
         BRU   LIDX5000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*|      Acquire Storage for The First Secondary Index Block          |*
*+-------------------------------------------------------------------+*
*
LIDX2000 DS    0H
         LLGF  R0,=A(LOGSILEN)     Indicate Leng of Secondary Index Blk
       STORAGE OBTAIN,             Get Storage for Secondary Index AreaX
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(31,64)         Dynamic Storage Area Above the Line
         LGR   RSDX,R1             Addr of Initial Secondary Index Blk
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LIDX2200            Yes => Branch to Process Index Pntrs
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LIDX2300            No  => Branch to Issue Error Message
LIDX2100 DS    0H
         LGR   R0,R1               Start of Initial Secondary Index Blk
         LLGF  R1,=A(LOGSILEN)     Set Length of Secondary Index Block
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Secondary Index Block
LIDX2200 DS    0H
         LLGF  R14,=A(LOGSILEN)    Obtain Size of Secondary Index Block
         STG   R14,LOGSISIZ        Set Size in our Secondary Index Blk
         LLGF  R14,=A(LOGSILEN-L'LOGSINDX) Get the Offset to Our Entry
         LA    R14,0(R14,RSDX)     Get the Address of the First Entry
         STG   R14,LOGSIFST        Set First Entry Pointer in Index Blk
         MVC   LOGSIHP2,=FD'1'     Set the Initial Count for Power of 2
         BRU   LIDX3000            Branch to Process Primary Index Blk
*
*+-------------------------------------------------------------------+*
*|Issue Error Message for Secondary Index Blk Getmain Storage Failure|*
*+-------------------------------------------------------------------+*
*
LIDX2300 DS    0H
         CVD   R15,COMWORKD        Create Decimal Version Return Code
         OI    COMWORKD+L'COMWORKD-1,15 Certify Sign to Make Printable
         LA    R1,LDX$RTCD         Address of Area for Message Variable
         UNPK  0(4,R1),COMWORKD    Create Visible Return Code
LIDX2400 DS    0H
         MVI   LGRWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LGRWTOMG+1(L'LGRWTOMG-1),LGRWTOMG ..Propagate the Blank
         MVC   LGRWTOMG(L'LGA01113),LGA01113 Indicate Index Blk Storage
         MVC   LGRWTOMG+L'LGA01113(4),0(R1) Get the Getmain Return Code
         MVC   LGRWTOLN,=Y(L'LGRWTOMG) ..Set the Length of the Message
         MVC   LGRWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LIDX2500 DS    0H
         WTO   TEXT=LGRWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LGRWTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Termination Error
         ST    R15,COMRETCD        Save Highest Return Code Generated
         BRU   LIDX5000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*|        Acquire Storage for Log Records Primary Index Block        |*
*+-------------------------------------------------------------------+*
*
LIDX3000 DS    0H
         LLGF  R0,=A(LOGPILEN)     Indicate Leng of Primary Index Block
       STORAGE OBTAIN,             Get Storage for Primary Index Area  X
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(31,64)         Dynamic Storage Area Above the Line
         LGR   RPDX,R1             Addr of Initial Primary Index Block
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LIDX3200            Yes => Branch to Process Index Pntrs
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LIDX4000            No  => Branch to Issue Error Message
LIDX3100 DS    0H
         LGR   R0,R1               Start of Initial Secondary Index Blk
         LLGF  R1,=A(LOGPILEN)     Set Length of Secondary Index Block
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Secondary Index Block
LIDX3200 DS    0H
         LLGF  R14,=A(LOGPILEN)    Obtain Size of Primary Index Block
         STG   R14,LOGPISIZ        Set Size in our Primary Index Block
         STG   RSDX,LOGPISXH       Establish Secondary Index Header
         STG   RSDX,LOGPISXT       Establish Secondary Index Trailer
         STG   REDB,LOGPIMTH       Establish Log Record Data Blk Header
         STG   REDB,LOGPIMTT       Establish Log Recrd Data Blk Trailer
         LLGF  R14,=A(LOGPILEN-L'LOGPINDX) Index to Last Index Entry
         LA    R14,0(R14,RPDX)     Get the Address of Last Index Entry
         STG   R14,LOGPIFST        Set First Entry Pointer in Index Blk
         STG   RSDX,0(,R14)        Set 1st Secondary Index Entry Value
         MVC   LOGPICNT,=FD'1'     Set Initial Primary Indx Entry Count
         MVC   LOGPIHP2,=FD'1'     Set the Initial Count for Power of 2
         LG    R2,LDXPINDX         Get Pointer to Primary Index Pointer
         LG    R2,0(,R2)           Get Pntr to Primary Index Block Addr
         STG   RPDX,0(,R2)         Preserve Primary Index Block Address
         BRU   LIDX$END            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| Issue Error Message for Primary Index Block Storage Obtain Failure|*
*+-------------------------------------------------------------------+*
*
LIDX4000 DS    0H
         CVD   R15,COMWORKD        Create Decimal Version Return Code
         OI    COMWORKD+L'COMWORKD-1,15 Certify Sign to Make Printable
         LA    R1,LDX$RTCD         Address of Area for Message Variable
         UNPK  0(4,R1),COMWORKD    Create Visible Return Code
LIDX4100 DS    0H
         MVI   LGRWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LGRWTOMG+1(L'LGRWTOMG-1),LGRWTOMG ..Propagate the Blank
         MVC   LGRWTOMG(L'LGA01114),LGA01114 Indicate Index Blk Storage
         MVC   LGRWTOMG+L'LGA01114(4),0(R1) Get the Getmain Return Code
         MVC   LGRWTOLN,=Y(L'LGRWTOMG) ..Set the Length of the Message
         MVC   LGRWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LIDX4200 DS    0H
         WTO   TEXT=LGRWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LGRWTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Termination Error
         ST    R15,COMRETCD        Save Highest Return Code Generated
*
*+-------------------------------------------------------------------+*
*|    Check Condition Code For Log Record Entry Buffer Processing    |*
*+-------------------------------------------------------------------+*
*
LIDX5000 DS    0H
         LLGF  R15,COMRETCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  LIDX$END            No  => Branch to Exit This Routine
         BRU   LIDXEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LIDX$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
LIDXEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*           End of Build Index and Data Blocks Processing             *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L F N D 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   F i n d  F o r  L o g   R e c o r d   E n t r y  |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LFND0000                                           *
*                                                                     *
* FUNCTION:        Find A Slot Position In Index Area for Log Record  *
*                                                                     *
*                  This routine will first search the primary index   *
*                  based on the fully qualified log record key. The   *
*                  current key is compared to the highest key in the  *
*                  secondary index block. That secondary index block  *
*                  address was obtained from a secondary index block  *
*                  pointer located in a primary index block entry. The*
*                  point in the primary index block in which the      *
*                  search starts represents the largest power of two  *
*                  that is less than or equal to half the number of   *
*                  current entries in the primary index block.        *
*                                                                     *
*                  If upon the first compare operation the incoming   *
*                  log record key does not match the primary index    *
*                  block, then a check is made to determine whether   *
*                  the compare was greater than or less than the      *
*                  highest log record key range in the secondary index*
*                  block header. This secondary index block is pointed*
*                  to from within the primary index block entry. This *
*                  search is to determine where in the primary index  *
*                  the search key for the secondary index block       *
*                  resides. The secondary index block header contains *
*                  the highest log record key for the range of keys in*
*                  that block. The search is to determine if the      *
*                  incoming log record has a key within the range of  *
*                  keys contained within the secondary index block. If*
*                  the input log record key is within the range of    *
*                  keys contained in the secondary index block or is  *
*                  a match, then the search of the primary index block*
*                  is complete, and a second search will begin in the *
*                  secondary index block for a matching log record in *
*                  the buffer area. Otherwise, the half of the primary*
*                  index entry area based on the current power of two *
*                  count which does not contain the search key range  *
*                  is discarded, and another compare is made at the   *
*                  center index entry area of the remaining entries   *
*                  which again assuming no match eliminates half the  *
*                  the remaining index entries. This process is       *
*                  continued until there is only a single primary     *
*                  index entry left that either falls within the log  *
*                  record key range of a secondary index block or     *
*                  there is no match. If there is no match on anything*
*                  in the primary index, this indicates the first time*
*                  through.                                           *
*                                                                     *
*                  Once a secondary index block is found, then this   *
*                  routine will search the secondary index based on   *
*                  the fully qualified key of the input log record.   *
*                  The comparison will be to the key of the log record*
*                  in the buffer area. The address of the log record  *
*                  in the buffer area was obtained from the secondary *
*                  index entry. The point in the secondary index in   *
*                  which the search starts again represents the       *
*                  largest power of two that is less than or equal to *
*                  half the number of current entries in the secondary*
*                  index block. The log record key is compared to the *
*                  key found at the current pointer to the secondary  *
*                  index block entry to determine in which half of the*
*                  secondary index area the search key must reside. If*
*                  the input log record key is not a match to the key *
*                  in the buffer area, then half the secondary index  *
*                  block area which does not contain the search key is*
*                  discarded, and compares are made to the center     *
*                  point of the remaining entries while continually   *
*                  eliminating half of the remaining secondary index  *
*                  entries.                                           *
*                                                                     *
*                  This search continues until there is only a single *
*                  secondary index entry left which either matches or *
*                  it does not. If there is no match, this means there*
*                  is not a duplicate log record in the buffer. If    *
*                  there is a match, this indicates there exists a    *
*                  duplicate entry in the buffer area. In that case,  *
*                  the request to insert the input log record is      *
*                  ignored. If there is no key match, then a new slot *
*                  position is calculated for the secondary index     *
*                  block to allow for the later insertion into the    *
*                  secondary index of a 64-bit pointer to the new log *
*                  record going into the buffer. This newly calculated*
*                  slot position value will be passed to the insertion*
*                  routine (LINS0000) which will dynamically update   *
*                  the secondary index block during the write of the  *
*                  input log record into the buffer.                  *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                  Parm6: Addr of Pointer to Secondary Index Block    *
*                  Parm7: Addr of Pointer to Log Record Data Table    *
*                  Parm8: Addr of Pointer to Log Record Input Area    *
*                  Parm9: Addr of Pointer to Log Record Slot          *
*                  Parm10:Addr of Pointer to Log Record CPU Time      *
*                  Parm11:Addr of Pointer to Log Record TCB Address   *
*                  Parm12:Addr of Pointer to Log Record Sequence No.  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LBFR0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success - No Matching Record Was Found        *
*                  04 - Warning - Duplicate Record Found              *
*                  08 - Error on Log Record Search Process            *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
LFND0000 RSECT *                   Read-Only Control Section Name
LFND0000 AMODE &AMODE              Establish Addressing Mode
LFND0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LFND0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   LFND0002            Branch Past the Literal Area
         DC    C'LFND0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LFND0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LFND0000+(LFND0001-LFND0000),RBASE1  Set Addressability
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LMG   R15,R6,LCAF64R01-LCASAVE(R1) Get the Input Parameters
         STG   R15,LFNPINDX        Save Adr Primary Index Block Pointer
         STG   R0,LFNSINDX         Save Adr Secondary Index Blk Pointer
         STG   R1,LFNTRTBL         Save Adr Log Record Table Pntr
         STG   R2,LFNINPUT         Save the Log Record Area Pointer
         STG   R3,LFNOSLOT         Save the Recrd Slot Position Pointer
         STG   R4,LFNTRTIM         Save the Log Record Time Address
         LG    R5,0(,R5)           Get Pointer to Log Record TCB Addr
         STG   R5,LFNTCBAD         Save the Log Record TCB Address
         LG    R6,0(,R6)           Get Pointer to Log Rcrd Seq No. Addr
         STG   R6,LFNSEQNO         Save Log Record Sequence No. Address
         XC    COMRETCD,COMRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|Search The Primary Index Block for Pointer To Secondary Index Block|*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
RNGE     USING LOGTRBLK,R11        Establish LOGTRBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
LFND1000 DS    0H
         LG    R1,LFNPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LG    R1,LFNTRTIM         Get Pointer to Log Recrd Timer Addr
         LG    R1,0(,R1)           Get the Log Record Timer Address
         MVC   LFN$TOKN,0(R1)      Build Log Record 1st Key Entry
         LG    R2,LFNTCBAD         Get Address to Log Recrd TCB Addr
         MVC   LFN$TCB@,0(R2)      Build Log Record 2nd Key Entry
         LG    R2,LFNSEQNO         Get Address to Log Rcrd Sequence No.
         MVC   LFN$SEQ#,0(R2)      Build Log Record 3nd Key Entry
         LG    R2,LOGPIFST         Get Address of First Populated Slot
         LG    R3,LOGPIHP2         Get Highest Power of 2 LE Entry Cnt
         LGR   R14,R3              Preserve Index Value as Delimiter
LFND1100 DS    0H
         LTGR  RSDX,R3             Get the Current Index Entry to Check
         BRZ   LFND1200            Branch If 1st Time Entry Validation
         BCTGR RSDX,0              Make Indx Beginning Relative to Zero
         SLLG  RSDX,RSDX,3 Bits    Times Length of an Index Entry (*8)
LFND1200 DS    0H
         LA    RSDX,0(RSDX,R2)     Point At Slot in Index Blk to Check
         LG    RSDX,0(,RSDX)       Get the Secondary Index Address
         CLC   LOGSIKEY,LFN$TKEY   This Entry Have Our Log Record Key?
         BRH   LFND1300            No  => Check for the Index Key Range
         BRL   LFND1400            No  => Move Higher in Index Block
         BRU   LFND2000            Matching Secondary Index Entry Found
LFND1300 DS    0H
         LG    R11,LOGSIFST        Get Address of First Populated Slot
         LG    R11,0(,R11)         Get Log Record Data Table Entry
         CLC   RNGE.LOGTRKEY,LFN$TKEY Entry Within Index Blk Key Range?
         BRNH  LFND2000            Yes => Matching Secondary Indx Found
         BRU   LFND1500            No  => Move Lower in Index Block
LFND1400 DS    0H
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   LFND2000            Secondary Index Key Range Located
         SGR   R3,R14              Point At Slot in the Index Block
         BRU   LFND1100            Branch to Continue Search of Index
LFND1500 DS    0H
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   LFND2000            Secondary Index Key Range Located
LFND1600 DS    0H
         LGR   R15,R14             Establish Current Power of 2 Value
         AGR   R15,R3              Calculate Next Secondary Index Value
         CG    R15,LOGPICNT        Past End of Primary Index Block?
         BRH   LFND1500            Yes => Attempt Moving Higher in Blk
LFND1700 DS    0H
         LGR   R3,R15              Point At Current Slot in Index Block
         BRU   LFND1100            Branch to Continue Search of Index
         DROP  RNGE                Remove Listed Reg as Table Base Reg
*
*+-------------------------------------------------------------------+*
*|   Found the Secondary Index Block. Now Calculate a Slot Position  |*
*|   Within the Secondary Index Block to Insert a Pointer to the     |*
*|   Log Record in the Buffer.                                       |*
*+-------------------------------------------------------------------+*
*
LFND2000 DS    0H
         LG    R2,LOGSIFST         Get Address of First Populated Slot
         LG    R3,LOGSIHP2         Get Highest Power of 2 LE Entry Cnt
         LGR   R14,R3              Preserve Index Value as Delimiter
LFND2100 DS    0H
         LTGR  REDB,R3             Get the Current Index Entry to Check
         BRZ   LFND2200            Branch If 1st Time Record Validation
         BCTGR REDB,0              Make Indx Beginning Relative to Zero
         SLLG  REDB,REDB,3 Bits    Times Length of an Index Entry (*8)
LFND2200 DS    0H
         LA    REDB,0(REDB,R2)     Point At Slot in Index Blk to Check
         LG    REDB,0(,REDB)       Get the Secondary Index Address
         CLC   LOGTRKEY,LFN$TKEY   This Entry Have Our Log Record Key?
         BRH   LFND2300            No  => Move Lower in Index Block
         BRL   LFND2500            No  => Move Higher in Index Block
         BRU   LFND3100            Duplicate Log Recrd Entry Was Found
LFND2300 DS    0H
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   LFND2400            Log Record Data Entry Was Not Found
         SGR   R3,R14              Point At Slot in the Index Block
         BRU   LFND2100            Branch to Continue Search of Index
LFND2400 DS    0H
         BCTGR R3,R0               Decrement Index Slot Position by One
         LG    R1,LFNOSLOT         Get Slot to Insert Log Record After
         STG   R3,0(,R1)           Save Slot to Insert Log Recrd After
         BRU   LFND3000            Log Record Entry Was Not Found
LFND2500 DS    0H
         LG    R1,LFNOSLOT         Get Slot to Insert Log Record After
         STG   R3,0(,R1)           Save Slot to Insert Log Recrd After
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   LFND3000            Log Record Entry Was Not Found
LFND2600 DS    0H
         LGR   R15,R14             Establish Current Power of 2 Value
         AGR   R15,R3              Calculate Next Secondary Index Value
         CG    R15,LOGSICNT        Past End of Secondary Index Block?
         BRH   LFND2500            Yes => Attempt Moving Higher in Blk
LFND2700 DS    0H
         LGR   R3,R15              Point At Current Slot in Index Block
         BRU   LFND2100            Branch to Continue Search of Index
*
*+-------------------------------------------------------------------+*
*|      Indicate Status of Search for Log Record Insert Request      |*
*+-------------------------------------------------------------------+*
*
LFND3000 DS    0H
         SLGR  REDB,REDB           Zero the Log Record Pointer Value
         LG    R3,LFNTRTBL         Get Address Log Recrd Table Pointer
         STG   REDB,0(,R3)         Set Log Component Pointer to Zeros
         LG    R3,LFNSINDX         Get Address Secondary Index Pointer
         STG   RSDX,0(,R3)         Save the Secondary Index Pointer
         BRU   LFND$END            OK to Insert, Component Not Found
LFND3100 DS    0H
         LG    R3,LFNTRTBL         Get Addr Log Record Table Pointer
         STG   REDB,0(,R3)         Save Address of Log Record Found
         LG    R1,LFNINPUT         Get Pointer to Log Rcrd Input Area
         LG    R1,0(,R1)           Get the Log Record Data Area Addr
         MVI   L'LOGTRCRD-1(R1),X'FF' ...Set Duplicate Status Indicator
LFND3200 DS    0H
         LA    R15,4               Indicate Duplicate Log Record Entry
         ST    R15,COMRETCD        Set Highest Return Code Generated
         BRU   LFNDEXIT            Ignore Insert Request, Record Found
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LFND$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
         ST    R15,COMRETCD        Set Highest Return Code Generated
LFNDEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*                 End of Index Area Search Processing                 *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L E X P 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|    P e r f o r m   E x p a n d   o f   I n d e x   B l o c k      |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LEXP0000                                           *
*                                                                     *
* FUNCTION:        Expand the Secondary Index Block To Prepare For The*
*                  Insert Of A Log Record Into Buffer.                *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  expansion of the secondary index. An expansion is  *
*                  required because an insert of a log record into    *
*                  a buffer area is pending because a secondary index *
*                  block which indexes the buffer area has filled up. *
*                  This routine will first acquire an additional page *
*                  aligned block of storage, and then chain in the    *
*                  new index block prior to the old index block which *
*                  has filled up. Thereafter the first half of the    *
*                  index entries in the filled up old block will be   *
*                  copied into the last half of the newly created     *
*                  secondary index block. Then the first half of the  *
*                  index entries in the old block will be cleared to  *
*                  binary zeros to allow the old block to accept new  *
*                  entries. Then the forward and backward chain       *
*                  pointers will be updated. This results in the      *
*                  movement of half the index entries in an old       *
*                  secondary index block to a new secondary index     *
*                  block. Only one new secondary index block is       *
*                  created upon entry into this routine. However this *
*                  routine may be called for as many times as is      *
*                  necessary to create an additional new index block  *
*                  to index an increasing volume of log records until *
*                  the primary index block fills when the record count*
*                  reaches 8 million records.                         *
*                                                                     *
*                  Once a secondary index block as been expanded into *
*                  two secondary index blocks, then the primary index *
*                  block containing the pointers to the secondary     *
*                  index blocks is also updated in order to hold a new*
*                  pointer to the newly created secondary index block *
*                  as a result of the expansion. A new entry is then  *
*                  added by calculating the length of that portion of *
*                  the primary index block which needs to slide over  *
*                  for 8-bytes in order to free up the correct index  *
*                  slot position to maintain the proper sort sequence.*
*                  The 64-bit pointer to the newly created secondary  *
*                  index block is then inserted into the newly opened *
*                  primary index slot position. Thereafter the primary*
*                  and secondary index chain pointers are updated to  *
*                  maintain the proper indexing of the records in the *
*                  log record buffers.                                *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                  Parm6: Addr of Pointer to Secondary Index Block    *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LBFR0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: WTO      - To Process Messages                     *
*                  STORAGE  - To Acquire Storage                      *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Split Index Process                  *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
LEXP0000 RSECT *                   Read-Only Control Section Name
LEXP0000 AMODE &AMODE              Establish Addressing Mode
LEXP0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LEXP0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   LEXP0002            Branch Past the Literal Area
         DC    C'LEXP0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LEXP0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LEXP0000+(LEXP0001-LEXP0000),RBASE1  Set Addressability
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LMG   R1,R2,LCAF64R01-LCASAVE(R1)  Get the Input Parameters
         STG   R1,LEXPINDX         Save Adr Primary Index Block Pointer
         STG   R2,LEXSINDX         Save Adr Secondary Index Blk Pointer
         XC    COMRETCD,COMRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|      Acquire Dynamic Storage for a New Secondary Index Block      |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
PREV     USING LOGSIBLK,R2         Establish Previous Blk Addessability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
LEXP1000 DS    0H
         LG    R1,LEXPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LG    R1,LEXSINDX         Get Pointer to Secondary Index Block
         LG    RSDX,0(,R1)         Get the Secondary Index Block Addr
LEXP1100 DS    0H
         LLGF  R0,=A(LOGSILEN)     Indicate Leng of Secondary Index Blk
       STORAGE OBTAIN,             Get Storage for Secondary Index AreaX
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(31,64)         Dynamic Storage Area Above the Line
         LGR   R2,R1               Address of New Secondary Index Block
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LEXP2000            Yes => Branch to Split Index Block
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LEXP1300            No  => Branch to Issue Error Message
LEXP1200 DS    0H
         LGR   R0,R1               Start of New Secondary Index Block
         LLGF  R1,=A(LOGSILEN)     Set Length of Secondary Index Block
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Secondary Index Block
         BRU   LEXP2000            Branch to Process Index Blocks
*
*+-------------------------------------------------------------------+*
*|Issue Error Message for Secondary Index Blk Getmain Storage Failure|*
*+-------------------------------------------------------------------+*
*
LEXP1300 DS    0H
         CVD   R15,COMWORKD        Create Decimal Version Return Code
         OI    COMWORKD+L'COMWORKD-1,15 Certify Sign to Make Printable
         LA    R1,LEX$RTCD         Address of Area for Message Variable
         UNPK  0(4,R1),COMWORKD    Create Visible Return Code
LEXP1400 DS    0H
         MVI   LGRWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LGRWTOMG+1(L'LGRWTOMG-1),LGRWTOMG ..Propagate the Blank
         MVC   LGRWTOMG(L'LGA01113),LGA01113 Indicate Index Blk Storage
         MVC   LGRWTOMG+L'LGA01113(4),0(R1) Get the Getmain Return Code
         MVC   LGRWTOLN,=Y(L'LGRWTOMG) ..Set the Length of the Message
         MVC   LGRWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LEXP1500 DS    0H
         WTO   TEXT=LGRWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LGRWTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Termination Error
         ST    R15,COMRETCD        Save Highest Return Code Generated
         BRU   LEXP4000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*| A New Empty Secondary Index Block Has Been Created. Now Split The |*
*| Old Secondary Index Block Which Had Filled Up By Moving the Top   |*
*| Half of the Entries From the Old Block to the Bottom Half of the  |*
*| New One. Then Clear that Half of the Old Secondary Index Block    |*
*| That Contained the Entries Which Were Moved to the New Secondary  |*
*| Index Block. This is Done is Order to Create Free Space in the Old|*
*| Block to Hold More Entries. Then Update The Chain Pointers in the |*
*| New and the Old Secondary Index Blocks.                           |*
*+-------------------------------------------------------------------+*
*
LEXP2000 DS    0H
         LLGF  R15,=A(LOGSILEN)    Get Size of Secondary Index Block
         STG   R15,PREV.LOGSISIZ   Set the Size in New Secondary Block
         MVC   PREV.LOGSIPRV,LOGSIPRV Set Prev Block Pointer in New Blk
         STG   RSDX,PREV.LOGSINXT  Set Next Block Pointer in New Block
         STG   R2,LOGSIPRV         Set the New Prev Pointer in Old Blk
         LG    R15,LOGSICNT        Get the Entry Count For a Full Block
         SRLG  R15,R15,1           Divide the Index Entry Count by 2
         STG   R15,LOGSICNT        Set the New Entry Count in Old Block
         STG   R15,PREV.LOGSICNT   Set the New Entry Count in New Block
         LLGF  R15,=A(LOGSISPL)    Get Length of a Split Index Block
         LA    R14,LOGSINDX(R15)   Get the Address of New First Pointer
         STG   R14,LOGSIFST        Set the New First Indx Entry Pointer
         LA    R14,PREV.LOGSINDX(R15) Get Address of New First Pointer
         STG   R14,PREV.LOGSIFST   Set the New First Indx Entry Pointer
         MVC   LOGSIHP2,=AD(256)    Set Highest Power of 2 in Old Block
         MVC   PREV.LOGSIHP2,=AD(256) Set Highest Power of 2 in New Blk
LEXP2100 DS    0H
         LGR   R0,R14              Point to Bottom Half in New Block
         LGR   R1,R15              Set The Length to Receive in New Blk
         LA    R14,LOGSINDX        Point to the Top Half in Old Block
LEXP2200 DS    0H
         MVCLE R0,R14,0            Move Half of the Entries to New Blk
         BRO   LEXP2200            Upon Interrupt Resume Where Left Off
LEXP2300 DS    0H
         LA    R0,0                Indicate the Sending Area is Nulls
         LA    R1,R0               No Length and Pad Character to Zeros
         LA    R14,LOGSINDX        Point to the Top Half in Old Block
         LLGF  R15,=A(LOGSISPL)    Get Length of a Split Index Block
         MVCLE R14,R0,0            Zero Half the Entries in Old Block
LEXP2400 DS    0H
         LLGF  R14,=A(LOGSILEN-L'LOGSILST) Get the Offset to Our Entry
         LG    REDB,0(R14,R2)      Get the Last Entry in New Index Blk
         MVC   PREV.LOGSIKEY,LOGTRKEY Set High Key Value in Index Block
         LG    REDB,0(R14,RSDX)    Get The Last Entry in Old Index Blk
         MVC   LOGSIKEY,LOGTRKEY   Set High Key Value in Index Block
LEXP2500 DS    0H
         LG    R15,LOGSIPRV        Get Secondary Index Previous Block
         LTGR  R15,R15             There A Previous Block to This One?
         BRZ   LEXP3000            No  => Branch to Update Primary Indx
LEXP2600 DS    0H
         LGR   R11,R15             Save the Previous Block to This One
         STG   RSDX,PREV.LOGSINXT  Update Next Blk in New Previous Blk
         DROP  PREV                Remove Listed Reg as New Block Base
*
*+-------------------------------------------------------------------+*
*|  Update The Primary Index Block to Insert A Pointer To The New    |*
*|  Secondary Index Block Which Was Created As A Result Of The Block |*
*|  Split.                                                           |*
*+-------------------------------------------------------------------+*
*
LEXP3000 DS    0H
         LG    R15,LOGPIFST        Get 1st Populated Slot in Index Blk
LEXP3100 DS    0H
         CG    RSDX,0(R15)         Is this our Secondary Index Entry?
         BRE   LEXP3200            Yes => Branch to Process Primary Idx
         LA    R15,8(,R15)         Get the Next Index Entry to Check
         BRU   LEXP3100            Loop to Check Next Primary Idx Entry
LEXP3200 DS    0H
         LG    R14,LOGPIFST        Get 1st Populated Slot in Index Blk
         LGR   R2,R15              Save New Index Slot Position to Fill
         LA    R15,8(,R15)         Point to the Following Slot Position
         SLGR  R15,R14             Calculate the Total Length to Shift
         LGR   R0,R14              Get Address of 1st Populated Slot
         SLGF  R0,=F'8'            Push Slot Position Forward One Entry
         STG   R0,LOGPIFST         Set a New Primary Index First Entry
         LGR   R1,R15              Set the Length to Move Index Entries
LEXP3300 DS    0H
         MVCLE R0,R14,0            Open New Primary Index Slot Position
         BRO   LEXP3300            Upon Interrupt Resume Where Left Off
LEXP3400 DS    0H
         LLGF  R15,=A(LOGPILEN-L'LOGPINDX) Index to Last Index Entry
         LA    R15,0(R15,RPDX)     Get the Address of Last Index Entry
         CGR   R14,R15             Update For First Initial Blk Split?
         BRH   LEXP3500            Yes => Branch to Adjust Chain in Blk
         LG    R14,0(,R14)         Get the Next Previous Block Pointer
         STG   R11,16(,R14)        New Previous Block to Next Previous
LEXP3500 DS    0H
         LGR   RSDX,R11            Set New Previous Blk as Current Blk
         STG   RSDX,0(R2)          Set Address of New Secondary Index
         LG    R14,LOGPICNT        Get Previous Primary Index Entry Cnt
         LA    R14,1(,R14)         Increment Primary Index Entry Count
         STG   R14,LOGPICNT        Store Updated Count in Primary Index
         LG    R14,LOGPIHP2        Get Previous Power of 2 for Index
         SLLG  R14,R14,1 Bit       Primary Index Power of 2 Times 2
         CG    R14,LOGPICNT        Index Count Need Higher Power of 2?
         BRH   LEXP$END            No  => Branch to Exit This Routine
         STG   R14,LOGPIHP2        Yes => Set Next Higher Power of 2
         BRU   LEXP$END            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|   Check Condition Code For Secondary Index Expansion Processing   |*
*+-------------------------------------------------------------------+*
*
LEXP4000 DS    0H
         LLGF  R15,COMRETCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  LEXP$END            No  => Branch to Exit This Routine
         BRU   LEXPEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LEXP$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
         ST    R15,COMRETCD        Save Highest Return Code Generated
LEXPEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*          End of Secondary Index Block Expansion Processing          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L I N S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|      P e r f o r m   I n s e r t   o f   L o g   R e c o r d      |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LINS0000                                           *
*                                                                     *
* FUNCTION:        Insert the Log Record Into the Buffers.            *
*                                                                     *
*                  This routine performs the insertion of a log record*
*                  into the buffers. First acquire the address of the *
*                  last buffer area in the chain of buffer areas that *
*                  comprise the buffer. A check is made to verify if  *
*                  there is sufficient room remaining to insert the   *
*                  next log record into the current buffer area. If   *
*                  not, then acquire an additional page aligned area  *
*                  of storage, and chain in the new buffer area after *
*                  the old buffer area, and then add a backward chain *
*                  pointer to continue the expansion of the log record*
*                  buffer. If there is sufficient room in the current *
*                  buffer area, then proceed with the insertion of the*
*                  input log record by calculating an offset into the *
*                  current buffer area to hold the log record, and    *
*                  write the log record into the buffer area.         *
*                                                                     *
*                  Next this routine was passed from previous routine *
*                  (LFND0000) the address of a secondary index slot   *
*                  position to be used to hold the pointer to the     *
*                  log record inserted into the buffer. This slot     *
*                  position is based on maintaining the secondary     *
*                  index in the proper sorted sequence depending on   *
*                  the record key of the log record to be inserted.   *
*                  The slot position passed may already be occupied by*
*                  another address pointing to another record. This   *
*                  new index entry is then added by calculating the   *
*                  length of that portion of the secondary index block*
*                  which needs to slide over for 8-bytes in order to  *
*                  open up a slot to hold the 64-bit pointer to the   *
*                  log record in the buffer. This establishes an index*
*                  pointer to the log record previously inserted into *
*                  the buffer area. Afterwards, update the count of   *
*                  active entries in the secondary index block, and   *
*                  then update the key range value in the secondary   *
*                  index block.                                       *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                  Parm6: Addr of Pointer to Secondary Index Block    *
*                  Parm7: Addr of Pointer to Input Log Record         *
*                  Parm8: Addr of Pointer to Log Record Slot Position *
*                  Parm9: Addr of Pointer to Log Record Clock Time    *
*                  Parm10:Addr of Pointer to Log Record TCB Address   *
*                  Parm11:Addr of Pointer to Log Record Sequence No.  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LBFR0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: WTO      - To Process Messages                     *
*                  STORAGE  - To Acquire Storage                      *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Insert of Log Record                 *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
LINS0000 RSECT *                   Read-Only Control Section Name
LINS0000 AMODE &AMODE              Establish Addressing Mode
LINS0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LINS0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   LINS0002            Branch Past the Literal Area
         DC    C'LINS0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LINS0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LINS0000+(LINS0001-LINS0000),RBASE1  Set Addressability
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LMG   R0,R6,LCAF64R01-LCASAVE(R1)  Get the Input Parameters
         STG   R0,LINPINDX         Save Adr Primary Index Block Pointer
         STG   R1,LINSINDX         Save Adr Secondary Index Blk Pointer
         STG   R2,LININPUT         Save Input Log Records Area Addr
         LG    R3,0(,R3)           Get Log Record Entry Slot Position
         STG   R3,LINOSLOT         Save Log Recrd Entry Slot Position
         LG    R4,0(,R4)           Get Pointer to Log Record Key Addr
         STG   R4,LINTRTIM         Save Input Log Record Time Address
         LG    R5,0(,R5)           Get Pointer to Log Record TCB Addr
         STG   R5,LINTRTCB         Save Input Log Record TCB Address
         LG    R6,0(,R6)           Get Pointer to Log Record Seq No.
         STG   R6,LINTRSEQ         Save Input Log Record Sequence No.
         XC    COMRETCD,COMRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|Verify If There Is Sufficient Space In Buffer Area To Add Our Input|*
*|Log Record Entry. If No Space, Get Additional Storage For Another  |*
*|Log Record Buffer Area.                                            |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
LINS1000 DS    0H
         LG    R1,LINPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LG    R1,LINSINDX         Get Pointer to Secondary Index Block
         LG    RSDX,0(,R1)         Get the Secondary Index Block Addr
         LG    REDB,LOGPIMTT       Get the Last Data Block on Chain
         CLC   LOGTRCNT,=AD(LOGTRMXB) .Have We Filled This Data Block?
         BRL   LINS2000            No  => Branch to Process Log Record
*
*+-------------------------------------------------------------------+*
*|      Acquire Dynamic Storage for Next Log Record Buffer Area      |*
*+-------------------------------------------------------------------+*
*
LINS1100 DS    0H
         LLGF  R0,=A(LOGPIDBS)     Indicate Size of Initial Data Block
       STORAGE OBTAIN,             Get Dynamic Storage for Buffer Area X
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(31,64)         Dynamic Storage Area Above the Line
         STG   R1,LOGTRNXT         Set Forward Pointer to Next Block
         STG   R1,LOGPIMTT         Set As the Last Data Block on Chain
         LGR   R3,REDB             Hold Addr of Old Log Record Data Blk
         LGR   REDB,R1             Get Addr of New Log Record Data Blk
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LINS1300            Yes => Branch to Adjust Chain Pntrs
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LINS1400            No  => Branch to Issue Error Message
LINS1200 DS    0H
         LGR   R0,R1               Start of Log Record Data Block
         LLGF  R1,=A(LOGPIDBS)     Set Leng of Log Records Data Block
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Buffer Area Data Block
LINS1300 DS    0H
         LLGF  R14,=A(LOGPIDBS)    Obtain the Size of Buffer Area Block
         STG   R14,LOGTRSIZ        Set the Size in our Buffer Area Blk
         LA    R14,LOGTRHLN(,REDB) Add the Length of the Header Section
         STG   R14,LOGTRSLT        Set Address of First Available Slot
         BRU   LINS2000            Branch to Process Log Record Entry
*
*+-------------------------------------------------------------------+*
*|   Issue Error Msg for Log Record Buffer Getmain Storage Failure   |*
*+-------------------------------------------------------------------+*
*
LINS1400 DS    0H
         CVD   R15,COMWORKD        Create Decimal Version Return Code
         OI    COMWORKD+L'COMWORKD-1,15 Certify Sign to Make Printable
         LA    R1,LDX$RTCD         Address of Area for Message Variable
         UNPK  0(4,R1),COMWORKD    Create Visible Return Code
LINS1500 DS    0H
         MVI   LGRWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LGRWTOMG+1(L'LGRWTOMG-1),LGRWTOMG ..Propagate the Blank
         MVC   LGRWTOMG(L'LGA01112),LGA01112 Indicate Data Blk Storage
         MVC   LGRWTOMG+L'LGA01112(4),0(R1) Get the Getmain Return Code
         MVC   LGRWTOLN,=Y(L'LGRWTOMG) ..Set the Length of the Message
         MVC   LGRWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LINS1600 DS    0H
         WTO   TEXT=LGRWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LGRWTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Termination Error
         ST    R15,COMRETCD        Save Highest Return Code Generated
         LGR   REDB,R3             Get Addr of Old Log Buffer Area Blk
         SLGR  R1,R1               Used to Indicate End of Buffer Chain
         STG   R1,LOGTRNXT         Clear the Next Block Forward Pointer
         STG   R1,LOGPIMTT         No More Buffer Area Blocks on Chain
         BRU   LINS4000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*|      Add The Log Record to End of Last Buffer Area on Chain       |*
*+-------------------------------------------------------------------+*
*
LINS2000 DS    0H
         LG    R14,LOGTRCNT        Get Count of Recrd Entries in Buffer
         LA    R15,1(,R14)         Increment Count for This Log Recrd
         STG   R15,LOGTRCNT        Store New Count Value in Buffer Blk
         MGHI  R14,(LOGTRLEN)      Old Count * Leng of Log Record Entry
         LA    REDB,LOGTRHLN(R14,REDB) Point to Log Record Buffer Entry
LINS2100 DS    0H
         LG    R1,LININPUT         Get Pointer to Log Recrd Input Area
         LG    R1,0(,R1)           Get Log Record Input Area Address
         LG    R2,LINTRTIM         Get Address to Log Record CPU Time
         LG    R3,LINTRTCB         Get Address to Log Record TCB Addr
         LG    R15,LINTRSEQ        Get Address to Log Record Seq No.
         STG   REDB,LOG$BLK@       Preserve Addr of Log Rcrd Buffer Blk
         MVC   LOGTRSEQ,0(R15)     Fill Buffer Entry with Log Seq No.
         MVC   LOGTRTCB,0(R3)      Fill Buffer Entry with Log Recrd TCB
         MVC   LOGTRTIM,0(R2)      Fill Buffer Entry with Log Rcrd Time
         MVC   LOGTRCRD,0(R1)      Fill Buffer Entry With Input Record
*
*+-------------------------------------------------------------------+*
*| Update the secondary index block to insert a new entry in the     |*
*| secondary index. This index entry will be a pointer to the new    |*
*| log record just written into the buffer area. A portion of the    |*
*| secondary index block will be moved over for eight bytes to open  |*
*| up a new slot in the index area to hold the pointer to the log    |*
*| record in the buffer.                                             |*
*+-------------------------------------------------------------------+*
*
LINS3000 DS    0H
         LG    R0,LOGSIFST         Get 1st Populated Slot in Index Blk
         LG    R1,LINOSLOT         Get the Slot Position for Our Insert
         MGHI  R1,8                Calculate the Total Length to Shift
         LG    R14,LOGSIFST        Establish Addr to 1st Populated Slot
         LG    R15,LOGSICNT        Get the Secondary Index Slot Count
         LTGR  R15,R15             Count Indicate 1st Time Through?
         BRZ   LINS3300            Yes => Branch to Fill Slot Position
LINS3100 DS    0H
         SGF   R14,=F'8'           Push Slot Position Forward One Entry
         STG   R14,LOGSIFST        Set a New Secondary Indx First Entry
         LGR   R15,R1              Set the Length to Move Index Entries
LINS3200 DS    0H
         MVCLE R14,R0,0            Open Up a New Secondary Index Slot
         BRO   LINS3200            Upon Interrupt Resume Where Left Off
LINS3300 DS    0H
         STG   REDB,0(,R14)        Set Address of New Log Record Entry
         LG    R14,LOGSICNT        Previous Secondary Index Entry Count
         LA    R14,1(,R14)         Increment Secondary Index Entry Cnt
         STG   R14,LOGSICNT        Set Updated Count in Secondary Index
         LG    R14,LOGSIHP2        Get Previous Power of 2 for Index
         SLLG  R14,R14,1 Bit       Secondary Index Power of 2 Times 2
         CG    R14,LOGSICNT        Index Count Need Higher Power of 2?
         BRH   LINS3400            No  => Branch to Update Index Key
         STG   R14,LOGSIHP2        Yes => Set Next Higher Power of 2
LINS3400 DS    0H
         LLGF  R14,=A(LOGSILEN-L'LOGSILST) Get the Offset to Our Entry
         LG    REDB,0(R14,RSDX)    Get the Last Record Entry in Block
         MVC   LOGSITIM,LOGTRTIM   Reset Index to Current Log Rcd Time
         MVC   LOGSITCB,LOGTRTCB   Reset Index to Current Log Rcd TCB
         MVC   LOGSISEQ,LOGTRSEQ   Reset Index to Current Log Rec No.
         LG    R14,LOGPITOT        Previous Log Record Entry Count
         LA    R14,1(,R14)         Increment Log Record Entry Count
         STG   R14,LOGPITOT        Set Updated Count in Primary Index
         BRU   LINS$END            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|       Check Condition Code For Log Record Buffer Processing       |*
*+-------------------------------------------------------------------+*
*
LINS4000 DS    0H
         LLGF  R15,COMRETCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  LINS$END            No  => Branch to Exit This Routine
         BRU   LINSEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LINS$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
LINSEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*          End of Insert Log Record Into Buffer Area Process          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L R L S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   R e l e a s e   I n d e x   P r o c e s s i n g  |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LRLS0000                                           *
*                                                                     *
* FUNCTION:        Perform Release of Index Blocks and Buffer Areas.  *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  release of all storage areas acquired as index     *
*                  blocks and buffers for the processing of the log   *
*                  records.                                           *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LBFR0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Release Resources Process            *
*                  12 - Severe Error - Exit LGMHLRCB Program          *
*                                                                     *
***********************************************************************
*
LRLS0000 RSECT *                   Read-Only Control Section Name
LRLS0000 AMODE &AMODE              Establish Addressing Mode
LRLS0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LRLS0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   LRLS0002            Branch Past the Literal Area
         DC    C'LRLS0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LRLS0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LRLS0000+(LRLS0001-LRLS0000),RBASE1  Set Addressability
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LG    R1,LCAF64R01-LCASAVE(,R1)  Get the Input Parameters
         STG   R1,LRLPINDX         Save the Primary Index Block Pointer
         XC    COMRETCD,COMRETCD   Initialize Return Code
*
*+-------------------------------------------------------------------+*
*|                Release The Log Record Buffer Areas                |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
LRLS1000 DS    0H
         LG    R1,LRLPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LTGR  RPDX,RPDX           Is the Primary Index Blk Available?
         BRNZ  LRLS1100            Yes => Process the Log Rcrd Buffers
         LA    R15,4               Indicate Warning for No Primary Indx
         BRU   LRLSEXIT            Branch to Exit This Routine
LRLS1100 DS    0H
         LG    R2,LOGPIMTH         Load 1st Log Record Buffer Area
         LTGR  REDB,R2             Set Initial Buffer Area Pointer
         BRZ   LRLS2000            Branch If No Buffer Area Chain
LRLS1200 DS    0H
         LTGR  REDB,REDB           Reached End of Buffer Area Chain?
         BRZ   LRLS1400            Yes => Branch to Set the Indicators
LRLS1300 DS    0H
         LGR   R1,REDB             Get Address of Log Recrd Buffer Area
         LG    R0,LOGTRSIZ         Get Length of Log Record Buffer Area
         LG    REDB,LOGTRNXT       Get Adr of Next Buffer Area on Chain
       STORAGE RELEASE,            Free the Log Record Buffer Area     X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
         BRU   LRLS1200            Loop to Process Next Buffer on Chain
LRLS1400 DS    0H
         XC    LOGPIMTH,LOGPIMTH   Indicate Log Record Buffers Released
         XC    LOGPIMTT,LOGPIMTT   Indicate Log Record Buffers Released
*
*+-------------------------------------------------------------------+*
*|             Release Log Record Secondary Index Blocks             |*
*+-------------------------------------------------------------------+*
*
LRLS2000 DS    0H
         LG    R1,LOGPISIZ         Get Length of Primary Index Block
         SLGF  R1,=F'8'            To Point to the Next to Last Entry
         LA    RSDX,0(R1,RPDX)     Point Secondary Index Block Pointer
         LG    RSDX,0(,RSDX)       Get Address to Secondary Index Block
LRLS2100 DS    0H
         LTGR  RSDX,RSDX           Reached End of Secondary Indx Chain?
         BRZ   LRLS2300            Yes => Branch to Set the Indicators
LRLS2200 DS    0H
         LGR   R1,RSDX             Get Address of Secondary Index Block
         LG    R0,LOGSISIZ         Get Length of Secondary Index Block
         LG    RSDX,LOGSINXT       Get Next Secondary Indx Blk on Chain
       STORAGE RELEASE,            Free Secondary Index Area to Buffer X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
         BRU   LRLS2100            Loop to Process Next Block on Chain
LRLS2300 DS    0H
         XC    LOGPISXH,LOGPISXH   Indicate Secondary Index is Released
         XC    LOGPISXT,LOGPISXT   Indicate Secondary Index is Released
*
*+-------------------------------------------------------------------+*
*|              Release Log Record Primary Index Block               |*
*+-------------------------------------------------------------------+*
*
LRLS3000 DS    0H
         LGR   R1,RPDX             Get Address of Primary Index Block
         LLGF  R0,=A(LOGPILEN)     Get Length of Primary Index Block
       STORAGE RELEASE,            Free Primary Index Area to Buffer   X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
         LG    R2,LRLPINDX         Get Pointer to Primary Index Pointer
         SLGR  RPDX,RPDX           Clear Primary Index Block Address
         STG   RPDX,0(,R2)         Indicate Primary Index is Released
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LRLS$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
LRLSEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,COMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*              End of Log Record Buffer Release Processing            *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Program Control Area - (LCA)
RBASE1   EQU   12                  Base Register 1
RBASE2   EQU   11                  Base Register 2
RCOMM1   EQU   10                  Common Dynamic Area Base Register 1
RCOMM2   EQU   9                   Common Dynamic Area Base Register 2
RCOMM3   EQU   8                   Common Constants/Routines Base Reg 1
RCOMM4   EQU   7                   Common Constants/Routines Base Reg 2
         USING COM@PCA,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P2L8,RCOMM3,RCOMM4 Constants&Routines Addressability
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M # P 2 L 8 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P r o g r a m   C o n t r o l   C o m m o n   D a t a   A r e a  |*
*+-------------------------------------------------------------------+*
*
COM#P2L8 RSECT                     Read-Only Control Section Name
COM#P2L8 AMODE &AMODE              Establish Program Addressing Mode
COM#P2L8 RMODE &RMODE              Establish Program Residence Mode
*
H4       DC    H'4'                Establish Halfword Constant '4'
H8       DC    H'8'                Establish Halfword Constant '8'
H12      DC    H'12'               Establish Halfword Constant '12'
ASTERISK DC    80CL1'*'            Define Character String of Asterisks
BLANKS   DC    CL256' '            Define Character String of Blanks
PATTERN  DC    XL15'4020206B2020206B2020206B202120' Pattern for Editing
*
COM$WTO  WTO   TEXT=(LGRWTO),      Write to Operator Message           X
               ROUTCDE=(1,11),MF=L Route to the Syslog and the Joblog
COM$WTOL EQU   *-COM$WTO           WTO List Length
*
LGA01111 DC    C'LGA01111A Primary index block overrun on secondary indX
               ex block split.'
LGA01112 DC    C'LGA01112A Storage exhausted for log buffer area. StoraX
               ge RC = '
LGA01113 DC    C'LGA01113A Storage exhausted for secondary index. StoraX
               ge RC = '
LGA01114 DC    C'LGA01114A Storage exhausted for primary index. StorageX
                RC = '
*
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************|  C O M @ P C A  |**************************
**************************+-----------------+**************************
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|           P r o g r a m   C o n t r o l   A r e a                 |*
*+-------------------------------------------------------------------+*
*
COM@PCA  DSECT ,                   Program Control Area-(CPCA)
COM@EYEC DS    CL32                Work Area Eye-Catcher
COM$SAVE DS    9D                  Save Area
COMWORKD DS    20D                 General Work Area
COMPLIST DS    20FD                CALL Parameter List
COMRSNCD DS    F                   Reason Code for Job
COMRETCD DS    F                   Return Code for Job
COMLG2II DS    AD                  Address of LGRWK2II Logger Work Area
COMRCDCT DS    FD                  LGRWK2II Log Point Output Rcrd Count
PRIMINDX DS    A                   Log Primary Index Block Chain Addr
TASKROWC DS    F                   Count of Log Component Data Rows
TASKPRNT DS    A                   Beginning Address of Print Entries
TASKPRTL DS    F                   Length of Print Entries Area
TASKPRTC DS    F                   Count of Print Entries
LTBLG2II DS    AD                  Logger Work Area (LGRWK2II) Address
LBFOSLOT DS    AD                  Save Area for Record Slot Position
LBFPINDX DS    AD                  Save Area for Primary Index Block
LBFSINDX DS    AD                  Save Area for Secondary Index Block
LBFTRTBL DS    AD                  Save Area for Log Record Table Addr
LBFINPUT DS    AD                  Save Area for Log Record Area Addr
LBFTCBAD DS    AD                  Save Area for Current TCB Address
LBFTRTIM DS    AD                  Save Area for the Log Record Time
LBFACCUM DS    AD                  Save Area for the Log Record Accum
LBFROWCT DS    FD                  Save Area for Current Row Counter
LBFRCDCT DS    FD                  Count of Log Record Component Rows
LBF$RTCD DS    F                   Area for Log Record Return Code
LDX$RTCD DS    F                   Area for Index Build Return Code
LDXPINDX DS    AD                  Save Area for 1st Primary Index Addr
LFNPINDX DS    AD                  Save Area for Primary Index Blk Addr
LFNSINDX DS    AD                  Save Area for Secondary Indx Blk Adr
LFNTRTBL DS    AD                  Save Area for Buffer Area Block Addr
LFNINPUT DS    AD                  Save Area for the Log Record Address
LFNOSLOT DS    AD                  Save Area for Log Record Tble Slot
LFNTCBAD DS    AD                  Save Area for Log Record TCB Addr
LFNTRTIM DS    AD                  Save Area for Log Record Time Addr
LFNSEQNO DS    AD                  Save Area for Log Recrd Sequence No.
LFN$TKEY DS    0CL(L'LOGTRTIM+L'LOGTRTCB) .Log Record Entry Key
LFN$TOKN DS    CL(L'LOGTRTIM)      ..Log Record Time Token Key
LFN$TCB@ DS    CL(L'LOGTRTCB)      ..Log Record TCB Address Key
LFN$SEQ# DS    CL(L'LOGTRSEQ)      ..Log Record Sequence No. Key
LEXPINDX DS    AD                  Save Area for Initial Primary Index
LEXSINDX DS    AD                  Save Area for Initial Secondary Indx
LEX$RTCD DS    F                   Work Area for Return Code Processing
LINOSLOT DS    AD                  Save Area for Record Slot Position
LINPINDX DS    AD                  Save Area for Primary Index Block
LINSINDX DS    AD                  Save Area for Secondary Index Block
LINTRTBL DS    AD                  Save Area for Log Record Buffer Addr
LININPUT DS    AD                  Save Area for Input Log Record Addr
LINTRTIM DS    AD                  Save Area for Input Log Record Time
LINTRTCB DS    AD                  Save Area for Log Record TCB Addr
LINTRSEQ DS    AD                  Save Area for Log Record Seq No.
LIN$RTCD DS    F                   Work Area for Return Code Processing
LRLPINDX DS    AD                  Save Area for Primary Index Block
LGRWTOL  DS    XL(COM$WTOL)        WTO Macro Parameter List
LGRWTO   DS    0F                  Write to Operator Message Data Area
LGRWTOLN DS    H                   Length of Write to Operator Msg Area
LGRWTOMG DS    CL70                Write to Operator Message Area
COMLNGTH EQU   *-COM@PCA           Length of Program Control Area
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|                  Log Record Buffer Area Blocks                    |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
*  LOGPIBLK = Primary Index Block Structure                           *
*  LOGSIBLK = Secondary Index Block Structure                         *
*  LOGTRBLK = Log Record Buffer Area Structure                        *
*                                                                     *
*  The following Log Record control blocks represent the indexing     *
*  structure which is utilized for processing the Log Records. The    *
*  address entries in the primary index control block point to        *
*  secondary index control blocks. The entries in the secondary       *
*  index control blocks will point to the individual log records      *
*  in the buffers.                                                    *
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|              Log Record Primary Index Control Block               |*
*+-------------------------------------------------------------------+*
*
LOGPIBLK DSECT ,                   Log Record Primary Index Block
LOGPISIZ DS    FD                  Size of This Primary Index Block
LOGPINXT DS    AD                  Next Primary Index Block or Zero
LOGPIFST DS    AD                  Address of First Entry in Block
LOGPICNT DS    FD                  Count of Entries in Primary Indx Blk
LOGPITOT DS    FD                  Count of Total Log Record Entries
LOGPIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGPISXH DS    AD                  Secondary Index Block Chain Header
LOGPISXT DS    AD                  Secondary Index Block Chain Trailer
LOGPIMTH DS    AD                  Log Record Data Block Chain Header
LOGPIMTT DS    AD                  Log Record Data Block Chain Trailr
LOGPOIX2 DS    AD                  Secondary Index Memory Object Origin
LOGPHIX2 DS    AD                  Secondary Index Mem Obj High Address
LOGPHUX2 DS    AD                  Secondary Indx Mem Obj High Used Adr
LOGPOLRD DS    AD                  Log Record Data Memory Object Origin
LOGPHLRD DS    AD                  Log Record Data Mem Obj High Address
LOGPGRDZ DS    FD                  Log Recrd Data Mem Object Guard Size
LOGPGRD2 DS    FD                  Secondary Indx Mem Object Guard Size
         ORG   LOGPIBLK+576        (Reserved - LOGGER)
LOGPINDX DS    0AD                 Last Available Primary Index Entry
         DS    16312AD             Allow 16,312 Primary Index Entries
LOGPILEN EQU   *-LOGPIBLK          Set Length of Primary Index Block
*
*+-------------------------------------------------------------------+*
*|             Log Record Secondary Index Control Block              |*
*+-------------------------------------------------------------------+*
*
LOGSIBLK DSECT ,                   Log Record Secondary Index Block
LOGSISIZ DS    FD                  Size of This Secondary Index Block
LOGSIPRV DS    AD                  Prev Secondary Index Block or Zero
LOGSINXT DS    AD                  Next Secondary Index Block or Zero
LOGSIFST DS    AD                  Addr of First Data Entry in Block
LOGSICNT DS    FD                  Count of Data Pointers in This Block
LOGSIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGSIKEY DS    0CL(L'LOGSITIM+L'LOGSITCB+L'LOGSISEQ) Highest Key in Blk
LOGSITIM DS    XL16                ..Log Record Entry Time Stamp
LOGSITCB DS    XL4                 ..Log Record Entry TCB Address
LOGSISEQ DS    XL4                 ..Log Record Entry Sequence No.
         ORG   LOGSIBLK+768        (Reserved - LOGGER)
LOGSINDX DS    0AD                 Last Available Secondary Indx Entry
         DS    4000AD              Allow 4,000 Secondary Index Pointers
         ORG   *-8                 Point at Last Secondary Index Entry
LOGSILST DS    AD                  Addr Highest Secondary Index Entry
LOGSISPL EQU   (*-LOGSINDX)/2      Len of a Split Secondary Index Block
LOGSILEN EQU   *-LOGSIBLK          Set Length of Secondary Index Block
LOGSISGZ EQU   (1024*1024)         Set Size of Secondary Index Segment
*
*+-------------------------------------------------------------------+*
*|             Log Record Control Block for Buffer Areas             |*
*+-------------------------------------------------------------------+*
*
LOGTRBLK DSECT ,                   Log Record Entry Data Cntl Block
LOGTRSIZ DS    FD                  Size of the Log Record Data Block
LOGTRNXT DS    AD                  Address of the Next Block on Chain
LOGTRCNT DS    FD                  Count of Record Entries in Buffer
LOGTRSLT DS    AD                  First Available Slot in Buffer Area
         DS    D                   (Reserved - LOGGER)
LOGTRHLN EQU   *-LOGTRBLK          Length of Data Block Header Section
         ORG   LOGTRBLK            Reset Buffer Area Location Counter
LOGTRRCD DS    0F                  Address of First Log Record Entry
LOGTRKEY DS    0CL(L'LOGTRTIM+L'LOGTRTCB+L'LOGTRSEQ) Log Record Key
LOGTRTIM DS    XL16                ..Log Record Entry Time Stamp
LOGTRTCB DS    XL4                 ..Log Record Entry TCB Address
LOGTRSEQ DS    XL4                 ..Log Record Entry Sequence No.
*
LOGTRCRD DS    CL(L'LGWLINE)       Area for the Log Trace Event Record
LOG$BLK@ DS    AD                  Log Record Buffer Area Block Address
*
LOGTRLEN EQU   *-LOGTRRCD          Length of Log Record Buffer Entry
LOGPIDBS EQU   1024*2048           Size of Data Blks for Getmain (2Meg)
LOGTRMXB EQU   (LOGPIDBS-LOGTRHLN)/LOGTRLEN  Maximum Blocks in a Buffer
LOGMXSIZ EQU   (1*10240)           Max Memlimit in Megabytes (10Gig)
*
         EJECT ,
*+-------------------------------------------------------------------+*
*|        L o g g e r  C o n t r o l   A r e a   -   (LCA )          |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
LGBFRCE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
*+-------------------------------------------------------------------+*
*|            z / O S   S y s t e m   D s e c t s                    |*
*+-------------------------------------------------------------------+*
*
         PRINT  NOGEN
         CVT    DSECT=YES,LIST=YES Communications Vector Table
         DCBD   DSORG=PS,DEVD=DA   Data Control Block
         IHAPSA LIST=YES           Prefix Storage Area
         IHAPVT                    RSM Page Vector Table
         IHAASCB                   Address Space Control Block
         IKJTCB LIST=YES           Job Task Control Block
         IEZJSCB                   Job Step Control Block
         END
