***********************************************************************
* L       GGGGGGG M     M H     H W      W TTTTTTTTT CCCCCCCC H     H *
* L       G     G MM   MM H     H W      W T   T   T C      C H     H *
* L       G       M M M M H     H W      W     T     C        H     H *
* L       G  GGGG M  M  M HHHHHHH W  WW  W     T     C        HHHHHHH *
* L       G     G M     M H     H W W  W W     T     C        H     H *
* L       G     G M     M H     H WW    WW     T     C      C H     H *
* LLLLLLL GGGGGGG M     M H     H W      W     T     CCCCCCCC H     H *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHWTCH                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Storage Watch Program              *
*                                                                     *
* INPUT REGS:      R1  => Standard z/OS Parameter List                *
*                                                                     *
* INPUT DATA:      Parm1: Address of the LGRWK2II Logger Work Area    *
*                         (Mapped by LGCPLSWA CopyBook)               *
*                  Parm2: Address of Storage Area to Show or Watch    *
*                  Parm3: Length of Storage Area to Show or Watch     *
*                  Parm4: Address of Watch Token Return Area          *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return Address                                *
*                  R13, Save Area & Dynamic Area                      *
*                  R12, (RBASE1) Program Base Register                *
*                  R11, (RCOMM1) Common Dynamic Area                  *
*                  R10, (RCOMM2) Common Constants/Routines            *
*                  R0-R9, General Work Registers                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Logger Services Event Publishing Program*
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Serious Error                                 *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Update   V1R1M17 20120721 Update VV.RR.MM stats for Fix Pack 17@@KHF*
* Update   V1R1M16 20120127 Update VV.RR.MM stats for Fix Pack 16@@KHF*
* Update   V1R1M15 20110930 Update VV.RR.MM stats for Fix Pack 15@@KHF*
* Update   V1R1M14 20110430 Update VV.RR.MM stats for Fix Pack 14@@KHF*
* Fix      V1R1M13 20110108 Revise Mixing to Improve Distribution@@KHF*
*                           and Reduce Collisions on Similar Keys@@KHF*
* Update   V1R1M12 20100306 Update VV.RR.MM stats for Fix Pack 12@@KHF*
* Update   V1R1M11 20091023 Update VV.RR.MM stats for Fix Pack 11@@KHF*
* Update   V1R1M10 20090523 Update VV.RR.MM stats for Fix Pack 10@@KHF*
* Update   V1R1M09 20090110 Updated VV.RR.MM stats for Fix Pack 9@@KHF*
* Fix      V1R1M08 20081010 Revised Mix Boxes and Hash Function  @@KHF*
*                           and Output Expanded to 128-Bit Token @@KHF*
* Update   V1R1M07 20080524 Updated VV.RR.MM stats for Fix Pack 7@@KHF*
* Update   V1R1M06 20080223 Updated VV.RR.MM stats for Fix Pack 6@@KHF*
* Update   V1R1M05 20080112 Updated VV.RR.MM stats for Fix Pack 5@@KHF*
* Update   V1R1M04 20071104 Updated VV.RR.MM stats for Fix Pack 4@@KHF*
* Update   V1R1M03 20070101 Updated VV.RR.MM stats for Fix Pack 3@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Updated VV.RR.MM stats for Fix Pack 1@@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Program
         LCLC  &RMODE              Resident Mode of Program
&KXHVER  SETC  'V1'                Indicate the Program Version Number
&KXHREL  SETC  'R1'                Indicate the Program Release Number
&KXHMOD  SETC  'M17'               Indicate the Pgm Modification Level
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&CPYRITE SETC  '2008,2012'         Program Copyright Year
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
&MODID   SETC  'LGMHWTCH'          Set the Program Module Identifier
*
R0       EQU   0                   Define Program Register 0 Equate
R1       EQU   1                   Define Program Register 1 Equate
R2       EQU   2                   Define Program Register 2 Equate
R3       EQU   3                   Define Program Register 3 Equate
R4       EQU   4                   Define Program Register 4 Equate
R5       EQU   5                   Define Program Register 5 Equate
R6       EQU   6                   Define Program Register 6 Equate
R7       EQU   7                   Define Program Register 7 Equate
R8       EQU   8                   Define Program Register 8 Equate
R9       EQU   9                   Define Program Register 9 Equate
R10      EQU   10                  Define Program Register 10 Equate
R11      EQU   11                  Define Program Register 11 Equate
R12      EQU   12                  Define Program Register 12 Equate
R13      EQU   13                  Define Program Register 13 Equate
R14      EQU   14                  Define Program Register 14 Equate
R15      EQU   15                  Define Program Register 15 Equate
         EJECT ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHWTCH - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHWTCH                                           *
*                                                                     *
* FUNCTION:        Storage Watch Main Program                         *
*                                                                     *
*                  This routine is the entry point for processing a   *
*                  watch point over a specified range of storage      *
*                  bytes. This routine is entered because the user    *
*                  coded a #LGPOINT entry or several #LGPOINT entries *
*                  in their assembler source program with the WATCH=  *
*                  parameter, and the WATCH= was encountered in the   *
*                  execution path of the user's program.              *
*                                                                     *
*                  #LGPOINT WATCH=('DATATBLE AREA',DATATBLE,1020)     *
*                                                                     *
*                  A watch point then becomes a lookout for a range   *
*                  of storage which if modified then this routine will*
*                  indicate that a change has occurred. The watch is  *
*                  maintained through the generation of a unique token*
*                  value for the storage area of interest. This       *
*                  routine takes as input a pointer to a work area,   *
*                  the address of a variable length input storage area*
*                  of up to 32K-8 bytes in length, the length of the  *
*                  storage area that is being watched, and an address *
*                  of an area to return the watch token. For example: *
*                                                                     *
*                  R1<---Points to Parameter List                     *
*                   |                                                 *
*                  +-------+                                          *
*                  |Address| --> Address of a Work Area               *
*                  +-------+                                          *
*                  |Address| --> Address of Input Storage Area        *
*                  +-------+                                          *
*                  |Length | --> Length of Input Storage Area         *
*                  +-------+                                          *
*                  |Adress | --> Address of Area to Return Token      *
*                  +-------+                                          *
*                                                                     *
*                  First the input storage area is truncated to remove*
*                  any trailing binary zeros prior to the build of the*
*                  hash token. Then a unique token value will be      *
*                  generated as t=H(k) where 't' is the token value,  *
*                  'H' is a hashing procedure, and 'k' is the key to  *
*                  be hashed. This key is the entire input storage    *
*                  area that was passed to this program. The purpose  *
*                  is to reduce a large input key 'k' to a relatively *
*                  small binary token value 't' with a maximum number *
*                  of unique terms, and a minimum exposure to the     *
*                  incidence of duplicate tokens being created for the*
*                  storage area which is being watched. Each byte in  *
*                  the storage area passed to this program, minus any *
*                  trailing pad bytes, is processed through a hash    *
*                  functionÝ1¨ performing a combining process through *
*                  rotational shifts and mixing over a mix box to a   *
*                  work area. The work area is then further compressed*
*                  through a sequence of mixing and successive halving*
*                  of the work area through exclusive OR'ing.         *
*                                                                     *
*                  The output from this token process will produce a  *
*                  unique 128-bit binary value for the storage area   *
*                  under a watch. Then the input storage address and  *
*                  length passed to this program are used as a key to *
*                  search the storage watch address list. This is to  *
*                  find the matching storage watch entry in the list  *
*                  from a previous run. This entry contains a field   *
*                  for the 128-bit storage area token. The new token  *
*                  gen'ed from the input storage area is compared to  *
*                  the old token for the same storage area from a     *
*                  previous pass. If the list entry for the old token *
*                  is a match to the new token, then no alteration has*
*                  occurred to any single byte in the storage area of *
*                  interest. If it is not a match, then the storage   *
*                  area under the watch has been modified. When not a *
*                  match, then the new 128-bit token overwrites the   *
*                  old token entry in the list, the return code is set*
*                  to indicate that a storage modification has        *
*                  occurred, and the new token value is passed back to*
*                  the calling Logger program LGMHLRCE.               *
*                                                                     *
*                  *Ý1¨Professor Donald E. Knuth, Stanford University *
*                      The Art of Computer Programming, Volume 3, 2nd *
*                      Edition, Sorting and Searching, Addison-Wesley *
*                      Publishing, 1998.                              *
*                                                                     *
* INPUT REGS:      R1  => Standard O/S Parameter List                 *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE                                           *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Storage Area Not Altered                      *
*                  04 - Storage Altered or First Time Through         *
*                  08 - Validation Error For Storage Length or Storage*
*                       Watch Table is Full.                          *
*                  12 - Validation Error For Return Buffer Area       *
*                                                                     *
***********************************************************************
*
&MODID   RSECT *                   Main Pgm Read-Only Control Section
&MODID   AMODE &AMODE              Program Addressing Mode -  &AMODE
&MODID   RMODE &RMODE              Program Residence Mode - &RMODE
         SYSSTATE AMODE64=YES,ARCHLVL=2 ...Establish 64-Bit Environment
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
KXHA00W2 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   DUMMYPNT            Branch Past the Literal Area
         DC    C'&MODID'           Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)'  Program Version.Rlse.ModLvl
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' ...Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
       SPLEVEL SET=6               Set for OS/390 R2 or Above (z/OS+)
         DC    50S(*)              Define a Patch Area
DUMMYPNT DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING &MODID+(KXHA00W2-LGMHWTCH),RBASE1  Program Base Register
         LGR   R2,R13              Preserve Caller's Save Area Address
         LLGF  R14,=A(LGW$AREA-LGRWK2II) Index to Logger Service Area
         LG    R3,0(R1)            Get Starting Address to Logger Area
         LA    R3,0(R14,R3)        Point to Wrk Area within Logger Area
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
*
*+-------------------------------------------------------------------+*
*| Establish Addressability To A Working Storage Area Within The     |*
*| LGRWK2II Area and Get The Input Parameters Which Were Passed to   |*
*| This Program                                                      |*
*+-------------------------------------------------------------------+*
*
LWTC1000 DS    0H
         USING WTC@PCA,RCOMM1      Common Dynamic Area Addressability
         USING COM#H5M7,RCOMM2     Constants&Routines Addressability
         LGR   RCOMM1,R3           Establish Common Work Area Address
         LLGT  RCOMM2,=A(COM#H5M7) Constants and Routines Area Address
         LG    R1,LCAF64R01-LCASAVE(,R2) Restore Parameter List Address
         LMG   R0,R3,0(R1)         Input Parameters From Calling Pgm
         STMG  R0,R3,WTCLG2II      Save Work@, Stor@, Leng, and Return@
         MVC   WTC@EYEC,=CL32'LGMHWTCH COMMON AREA' .Set the Eyecatcher
         XC    WTCRETCD,WTCRETCD   Initialize Return Code
         BRU   LWTC2000            Branch to Process Storage Area Watch
*
*+-------------------------------------------------------------------+*
*|    Perform Initialization Processing For Our Storage Watch        |*
*+-------------------------------------------------------------------+*
*
LWTC2000 DS    0H
         LA    R0,WTC$WORK         Beginning of Watch Process Work Area
         LLILL R1,(L'WTC$WORK)     Set Length of Watch Process Wrk Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Watch Process Work Area
LWTC2100 DS    0H
         LA    R15,WTC$WORK        Beginning of Watch Process Work Area
         USING WATCHARE,R15        Establish Addressability to Wrk Area
         STG   R15,WATCHWK@        Save the Watch Work Area Address
         LG    R3,WTCLG2II         Get Starting Address to Logger Area
         USING LGRWK2II,R3         Establish Addressability to Log Area
         LA    R1,LWTC8600         Get Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         XC    WTCHKSUM,WTCHKSUM   Clear CheckSum to Input Storage Area
         DROP  R3                  Remove Listed Reg as Log Area Base
*
*+-------------------------------------------------------------------+*
*|   Verify The Passed Storage Area Length Is Within Maximum Bounds  |*
*+-------------------------------------------------------------------+*
*
LWTC3000 DS    0H
         LG    R1,WTCSTOR@         Obtain Input Storage Area Address
         LG    R0,WTCSTORL         Obtain Input Storage Area Length
         LTGR  R0,R0               A Positive Value for Storage Length?
         BRNP  LWTC3100            No  => Branch to Set Error Rtrn Code
         CLGF  R0,=F'32760'        Is Storage Area Leng Within Bounds?
         BRNH  LWTC4000            Yes => Branch to Build a Watch Token
LWTC3100 DS    0H
         LA    R15,8               Set Error for Maximum Leng Exceeded
         ST    R15,WTCRTCDE        Save Highest Return Code Generated
         BRU   LWTC9000            Branch to Exit Storage Watch Program
*
*+-------------------------------------------------------------------+*
*|  Find the End of Our Storage Area Minus Any Trailing Pad Bytes    |*
*|  and Initialize Table Pointers                                    |*
*+-------------------------------------------------------------------+*
*
LWTC4000 DS    0H
         LA    R6,1                Addr Reference to One Byte at a Time
         BCTGR R1,R0               Position Before 1st Byte Input Area
         LGR   R3,R1               Beginning Position To Index Register
         AGR   R3,R0               Add Stor Leng to Point to Last Byte
         LNGFR R0,R6               For Negative Displacement Addressing
LWTC4100 DS    0H
         CLI   0(R3),X'00'         Is Our Storage Byte a Zero (Pad)?
         BRNZ  LWTC4200            No  => Process Storage Watch Data
         BRXHG R3,R0,LWTC4100      Move Backwards Thru Trailing Bytes
LWTC4200 DS    0H
         LGR   R4,R3               Pnt to End of Data Minus Pad Bytes
         SGR   R4,R1               Calculated Length of Storage Data
         LTGR  R4,R4               Is Entire Area All Binary Zeros?
         BRZ   LWTC7000            Yes => No Need to Combine and Mix
LWTC4300 DS    0H
         STH   R4,WATCHLEN         Preserve Input Storage Area Length
         AGF   R4,WATCHBCT         Calculate the No. of Bytes Watched
         ST    R4,WATCHBCT         Preserve Number of Bytes Watched
         LA    R2,1                Set Increment To One Byte at a Time
         LA    R1,0(R2,R1)         Point to Start of Input Storage Area
         SLGR  R7,R7               Initialize Checksum Token Register
         LGR   R8,R2               Target Cursor is 1 Byte at a Time
         LA    R9,WATCHAR1+WATCHWLN    Point to Last Byte of Work Area
         LG    R14,WATCHWK@        Get Starting Addr to Watch Work Area
*
*+-------------------------------------------------------------------+*
*| Process all input storage area data to the work area, and also use|*
*| an accumulator to add up the bytes in the storage data considering|*
*| not only the value of each byte but also its position. The input  |*
*| storage area bytes are applied to a 1023 byte work area and mixed.|*
*| If there are more bytes being processed under a watch than what   |*
*| can be contained in the 1023 byte work area, then each 64-bit area|*
*| in the work area is shifted left and rotated by 4-Bits, and then  |*
*| the work area is mixed. Any new bytes being read from input are   |*
*| applied to the previous state of bytes in the work area. This     |*
*| rotation and mixing is repeated for each time the work area fills |*
*| up from writing into the work area all the bytes read from the    |*
*| input storage area. This results in a 'first-stage' one way       |*
*| compression of a much larger input storage area of up to 32,760   |*
*| bytes into a smaller work area of 1,023 bytes.                    |*
*+-------------------------------------------------------------------+*
*
TOK      USING WATCHMIX,R4         Set Addressability to Watch Table
LWTC5000 DS    0H
         STMG  R1,R3,WTCREGSV      Save the Current Working Registers
         XC    0(1,R14),0(R1)      Apply New Input Byte to Work Area
         LLGC  R4,0(,R1)           Get the Current Input Storage Byte
         LGR   R5,R1               Addr of Current Input Storage Byte
         SLG   R5,WTCSTOR@         Calculate the Position of Input Byte
         LA    R5,1(R4,R5)         Add Byte Value + Byte Position + One
         LG    R7,WTCHKSUM         Get CheckSum for Input Storage Area
         ALGR  R7,R5               Add Calculated Result to Accumulator
         STG   R7,WTCHKSUM         Save CheckSum for Input Storage Area
         BRXLG R14,R8,LWTC5400     Increment to Next Byte in Work Area
LWTC5100 DS    0H
         LA    R4,WATCHMIX         Work Area Filled, Get Watch Tble Adr
         LA    R2,WATCHAR1         Get Addr to First Byte in Work Area
         LG    R0,0(R0,R2)         Receiving Field is Our Work Area
         LGHI  R7,(WATCHWLN/8)     Get Count of 8-Byte Sections in Area
LWTC5200 DS    0H
         RLLG  R0,R0,4 Bits        Rotate Work Area 4 Bits Over to Left
         STG   R0,0(,R2)           Put Shifted Bytes Back to Work Area
         LA    R2,8(R0,R2)         Increment to the Next 8-Byte Section
         LG    R0,0(R0,R2)         Contents of Next Section in Work Reg
         BRCTG R7,LWTC5200         Loop to Process Next 8-Byte Section
LWTC5300 DS    0H
         RLLG  R0,R0,4             Rotate Last Area 4 Bits Over to Left
         STCMH R0,B'1111',0(R2)    High Half Shifted Bytes to Work Area
         STCM  R0,B'1110',4(R2)    Low Half Shifted Bytes to Work Area
         TR    WATCHAR1,TOK.WATCHMIX Mix Shifted Bytes in 1st Work Area
         TR    WATCHAR2,TOK.WATCHMIX Mix Shifted Bytes in 2nd Work Area
         TR    WATCHAR3,TOK.WATCHMIX Mix Shifted Bytes in 3rd Work Area
         TR    WATCHAR4,TOK.WATCHMIX Mix Shifted Bytes in 4th Work Area
         OI    WATCHFLG,WATCHFBW   Indicate a Full Block Work Area
         LA    R14,WATCHAR1        Point Back to Beginning of Work Area
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process Next Byte From Input Area to the Work Area  |*
*+-------------------------------------------------------------------+*
*
LWTC5400 DS    0H
         LMG   R1,R3,WTCREGSV      Restore Current Working Registers
         BRXLG R1,R2,LWTC5000      Loop => Get Next Byte in Input Area
         TM    WATCHFLG,WATCHFBW   Input Area Size Less Than Work Area?
         BRO   LWTC6300            No  => Wrk Area Filled at Least Once
*
*+-------------------------------------------------------------------+*
*| Process For a Short Block When Input Area Size Less Than Work Area|*
*+-------------------------------------------------------------------+*
*
LWTC6000 DS    0H
         LA    R4,WATCHMIX         Work Area Short Blk, Get Table Addr
         LA    R2,WATCHAR1         Get Address to First Work Area Block
         LG    R0,0(R0,R2)         Receiving Field is First Work Area
         LA    R2,1(,R2)           Send from 2nd Byte of 1st Work Area
         LGR   R3,R14              Pick Up Addr of Last Byte Processed
         SGR   R3,R2               Calculate the Length of Short Block
         BRNP  LWTC6200            Branch If Nothing Left to Process
         LGR   R1,R3               Leng of Receiving Field in Work Area
         SRAG  R7,R1,3             Divide into No. of 8-Byte Sections
         BRZ   LWTC6200            Branch if Not At Least 1 8-Byte Area
LWTC6100 DS    0H
         RLLG  R0,R0,4             Rotate Work Area 4 Bits Over to Left
         STG   R0,0(,R2)           Put Shifted Bytes Back to Work Area
         LA    R2,8(R0,R2)         Increment to the Next 8-Byte Section
         LG    R0,0(R0,R2)         Contents of Section in Work Register
         BRCTG R7,LWTC6100         Loop to Process Next 8-Byte Section
LWTC6200 DS    0H
         TR    WATCHAR1,TOK.WATCHMIX Mix Shifted Bytes in 1st Work Area
         TR    WATCHAR2,TOK.WATCHMIX Mix Shifted Bytes in 2nd Work Area
         TR    WATCHAR3,TOK.WATCHMIX Mix Shifted Bytes in 3rd Work Area
         TR    WATCHAR4,TOK.WATCHMIX Mix Shifted Bytes in 4th Work Area
*
*+-------------------------------------------------------------------+*
*| All bytes from the input area have been processed to the work     |*
*| area. Now add the length field for the number of bytes processed  |*
*| to the work area. This will incorporate the storage area length   |*
*| in the calculation of the token. First convert the byte length    |*
*| number to the number of bits, and pad with a high order 1 bit. So |*
*| add a pad byte with a high-order 1 bit, and after the pad the     |*
*| last 64-bits of the work area will contain the storage area       |*
*| length, in bits. Any bits between the final 1 and the length bits |*
*| are set to zero. Once the pad and bit value is set, then include  |*
*| the pad and the last 64 bits one byte at a time as trailing bytes |*
*| from the current pointer in the work area. It is possible for the |*
*| current pointer to be near the end of the work area, and not have |*
*| enough room to add all the bytes from the pad and length field.   |*
*| In such an event, add a portion at the end, re-mix the bytes in   |*
*| the work area containing a portion of the pad/length area, then   |*
*| go back to the beginning of the work area, add the remaining      |*
*| bytes from the pad/length area, and re-mix the work area block    |*
*| again.                                                            |*
*+-------------------------------------------------------------------+*
*
LWTC6300 DS    0H
         LLGH  R5,WATCHLEN         Get Storage Leng Processed in Bytes
         SLLG  R5,R5,3 Bits        Times 8 for No. of Bits in a Byte
         STCMH R5,B'1111',WATCHBIT+1 Copy High Half to Length Field
         STCM  R5,B'1111',WATCHBIT+5 Copy Low Half to Length Field
         OI    WATCHBIT,X'80'      Fill Pad Byte with High-Order 1 Bit
         LA    R5,WATCHBIT         Get Address to the Pad/Length Field
         LLILL R6,(L'WATCHBIT)     Count of No. of Bytes to Add to Area
LWTC6400 DS    0H
         XC    0(1,R14),0(R5)      Add Byte from the Pad/Length Field
         BRXLG R14,R8,LWTC6600     Increment to Next Byte in Work Area
LWTC6500 DS    0H
         LA    R4,WATCHMIX         Work Area Filled By Last Byte Insert
         TR    WATCHAR1,TOK.WATCHMIX Mix Shifted Bytes in 1st Work Area
         TR    WATCHAR2,TOK.WATCHMIX Mix Shifted Bytes in 2nd Work Area
         TR    WATCHAR3,TOK.WATCHMIX Mix Shifted Bytes in 3rd Work Area
         TR    WATCHAR4,TOK.WATCHMIX Mix Shifted Bytes in 4th Work Area
         TM    WATCHFLG,WATCH1ST   Did We Reset to Start of Work Area?
         BRO   LWTC6600            Yes => Then Next Byte in Work Area
         LA    R14,WATCHAR1        At End, Point Back to the Beginning
         OI    WATCHFLG,WATCH1ST   Addr Reset to Beginning of Work Area
LWTC6600 DS    0H
         LA    R5,1(,R5)           Next Byte in the Pad/Length Field
         BRCTG R6,LWTC6400         Loop to Add Next Byte to Work Area
         BRU   LWTC7000            Branch to Build Storage Watch Token
         DROP  TOK                 Remove Listed Reg as Watch Tble Base
*
*+-------------------------------------------------------------------+*
*| Build a 128-bit hash token from the work area for our storage data|*
*| under a watch. A further mix and combine process is used as an    |*
*| irreversible compression function. This is done by taking the work|*
*| area and performing additional mixing and exclusive OR'ing        |*
*| resulting in successive halving of the work area as a second-stage|*
*| process to further reduce the larger work area (1023 bytes) down  |*
*| to a relatively small token area of 16 bytes (128 bits).          |*
*|                                                                   |*
*| Work Area (1023 Bytes)                                            |*
*| +---------------+---------------+---------------+---------------+ |*
*| |  Work Area 1  |  Work Area 2  |  Work Area 3  |  Work Area 4  | |*
*| +---------------+---------------+---------------+---------------+ |*
*|     256 Bytes       256 Bytes       256 Bytes       255 Bytes     |*
*|                                                                   |*
*|                                                                   |*
*|        Mix Work Area 3                 Mix Work Area 4            |*
*|               |                               |                   |*
*|       +---------------+               +---------------+           |*
*|       |  Work Area 3  |               |  Work Area 4  |           |*
*|       +---------------+               +---------------+           |*
*|               |                               |                   |*
*|  Combine Area 3 Over Area 1      Combine Area 4 Over Area 2       |*
*|               |                               |                   |*
*|       +---------------+               +--------------+            |*
*|       |  Work Area 1  |               | Work Area 2  |            |*
*|       +---------------+               +--------------+            |*
*|               |                               |                   |*
*|               |                     Mix Work Area 2 and           |*
*|               |                  Combine Area 2 Over Area 1       |*
*|       +---------------+                       |                   |*
*|       |  Work Area 1  |<----------------------+                   |*
*|       +---------------+                                           |*
*|               |                                                   |*
*|               +-------------------------------+                   |*
*|                                               | Work Area 1       |*
*|    +-+      +-+-+      +---+---+      +-------+-------+           |*
*|    | |<-1/2-| | |<-1/2-|   |   |<-1/2-|     <-|--1/2  |           |*
*|    +-+      +-+-+      +---+---+      +-------+-------+           |*
*|    16       32         64             128     256                 |*
*| Repeat the mix and combine of the second half of Work Area 1 over |*
*| the first half so Work Area 1 goes from 256 bytes to 128 bytes to |*
*| 64 bytes to 32 bytes to a final 16 bytes.                         |*
*+-------------------------------------------------------------------+*
*
LWTC7000 DS    0H
         TR    WATCHAR3,WATCHMIX   Mix 3rd Work Area with Watch Table
         TR    WATCHAR4,WATCHMIX   Mix 4th Work Area with Watch Table
         XC    WATCHAR1,WATCHAR3   Combine 3rd Work Area Over 1st Area
         XC    WATCHAR2(L'WATCHAR4),WATCHAR4  Combine 4th Area Over 2nd
         TR    WATCHAR2,WATCHMIX   Mix Second Area With 2nd Watch Table
         XC    WATCHAR1,WATCHAR2   Combine (Add) 2nd Area Over 1st Area
         TR    WATCHAR1+L'WATCHAR1/2(L'WATCHAR1/2),WATCHMIX Mix Nxt 1/2
         XC    WATCHAR1(L'WATCHAR1/2),WATCHAR1+L'WATCHAR1/2 Combine 1/2
         TR    WATCHAR1+L'WATCHAR1/4(L'WATCHAR1/4),WATCHMIX Mix Nxt 1/2
         XC    WATCHAR1(L'WATCHAR1/4),WATCHAR1+L'WATCHAR1/4 Combine 1/2
         TR    WATCHAR1+L'WATCHAR1/8(L'WATCHAR1/8),WATCHMIX Mix Nxt 1/2
         XC    WATCHAR1(L'WATCHAR1/8),WATCHAR1+L'WATCHAR1/8 Combine 1/2
         TR    WATCHAR1+L'WATCHAR1/16(L'WATCHAR1/16),WATCHMIX  Next 1/2
         XC    WATCHAR1(L'WATCHAR1/16),WATCHAR1+L'WATCHAR1/16  Combine
         LG    R0,WATCHAR1         Get High Order DoubleWord of Token
         LRVG  R1,WATCHAR1+8       Get the Low Order DoubleWord of Tokn
         RLLG  R1,R1,8             Rotate Position of 1st Byte to Last
         XGR   R0,R1               Generate 128-Bit Storage Data Token
*
*+-------------------------------------------------------------------+*
*| Add the byte count and the storage data accumulator count to the  |*
*| storage data token to form the finalized 128-bit watch token.     |*
*+-------------------------------------------------------------------+*
*
LWTC7100 DS    0H
         LLGF  R2,WATCHBCT         Obtain the Input Storage Byte Count
         SLL   R2,3 Bits           Indicate the Number of Bits in Bytes
         ALG   R2,WTCHKSUM         Add Checksum Accumlator to # of Bits
         ALGR  R1,R2               Build Finalized 128-Bit Storage Tokn
         STMG  R0,R1,WTCTOKEN      Save Final Storage Token Hash Value
         SLGR  R15,R15             Clear to Indicate Highest Retrn Code
         LG    R2,WTCTOKN@         Get Addr for Watch Token Return Area
         LTGR  R2,R2               An Addr for Watch Token Return Area?
         BRNZ  LWTC7200            Yes => Branch to Fill Area with Tokn
         LA    R15,12              Set As Error for No Return Area
         ST    R15,WTCRTCDE        Save Highest Return Code Generated
         BRU   LWTC9000            Branch to Exit Storage Watch Program
LWTC7200 DS    0H
         MVC   0(L'WTCTOKEN,R2),WTCTOKEN .Token to Caller's Return Area
         DROP  R15                 Remove Listed Register as Base Reg
*
*+-------------------------------------------------------------------+*
*| Search the storage watch table using the storage area address and |*
*| the storage area length which were passed to this routine as the  |*
*| search key in order to find the old 128-bit token in the table.   |*
*| When found, then compare the newly generated 128-bit token to the |*
*| old 128-bit token entry in the storage watch table to determine if|*
*| a change has occurred to the storage area being watched. If the   |*
*| new token and the old token are not the same, this indicates that |*
*| the storage area under a watch has been modified. In that case,   |*
*| save the new token over the old token in the table, and set the   |*
*| return code to RC=04 to indicate the storage area under a watch   |*
*| has been changed since the last pass. If this is the first time   |*
*| through for a storage area of interest, then the new 128-bit token|*
*| is inserted into an empty slot in the storage watch table, and the|*
*| return code is set to RC=04. If this is not the first time through|*
*| for a storage area of interest and no change has occurred to the  |*
*| data because the new token generated and the old token entry in   |*
*| the table are the same, then the return code is set to RC=00.     |*
*+-------------------------------------------------------------------+*
*
LWTC8000 DS    0H
         LLGF  R14,=A(LGW$WLST-LGRWK2II) Index to the Watch Work Area
         LG    R3,WTCLG2II         Get Starting Address to Logger Area
         LA    R3,0(R14,R3)        Point to Storage Watch List Area
         LA    R4,WTCTBLEN         Length of Each Storage Watch Entry
         LLGF  R5,=A(((LGW$ENT#*WTCTBLEN)-WTCTBLEN)-1)  Set a Limit
         LA    R5,0(R5,R3)         Point to the Next to the Last Entry
         USING WATCHLLC,R3         Set Addressability to List Entry
LWTC8100 DS    0H
         CLC   WTCSTOR@(L'WTCSTOR$+L'WTCSTORL),WTCSTOR$   Our Storage?
         BRE   LWTC8300            Yes => Then Check New Token to Old
         LG    R2,WTCSTOR$         Obtain Address of Our Storage Area
         LTGR  R2,R2               Is This An Empty Entry in Our List?
         BRZ   LWTC8500            Yes => New Storage Watch, Save Entry
         BRXLG R3,R4,LWTC8100      Loop to Check Next Entry in List
LWTC8200 DS    0H
         LA    R15,8               Table is Full, No Further Watches
         ST    R15,WTCRTCDE        Save Highest Return Code Generated
         BRU   LWTC9000            Branch to Exit Storage Watch Program
LWTC8300 DS    0H
         CLC   WTCTOKEN,WTCTOKN$   Is New Watch Token Same as Old Tokn?
         BRNE  LWTC8400            No  => Save New Tokn Over Old in Lst
         SLGR  R15,R15             Storage Not Changed Since Last Check
         ST    R15,WTCRTCDE        Set Highest Return Code Generated
         BRU   LWTC9000            Branch to Exit Storage Watch Program
LWTC8400 DS    0H
         MVC   WTCTOKN$,WTCTOKEN   Storage Changed, Save New Watch Tokn
         LA    R15,4               Indicate Storage Alteration Occurred
         ST    R15,WTCRTCDE        Set Highest Return Code Generated
         BRU   LWTC9000            Branch to Exit Storage Watch Program
LWTC8500 DS    0H
         MVC   WTCTOKN$,WTCTOKEN   Add Tokn of Storage Subject to Watch
         MVC   WTCSTOR$(L'WTCSTOR@+L'WTCSTORL),WTCSTOR@ Addr and Length
         LA    R15,4               Indicate First Time For This Watch
         ST    R15,WTCRTCDE        Set Highest Return Code Generated
         BRU   LWTC9000            Branch to Exit Storage Watch Program
         DROP  R3                  Remove Listed Register as Base Reg
LWTC8600 DS    0H
         LA    R15,12              Serious Error Accessing Storage Area
         ST    R15,WTCRTCDE        Set Highest Return Code Generated
*
*+-------------------------------------------------------------------+*
*|   End of Processing For Storage Watch                             |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R3         Establish Addressability to Log Area
LWTC9000 DS    0H
         LG    R3,WTCLG2II         Get Starting Address to Logger Area
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Bytes Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         LTGFR R15,R15             Termination Complete Successfully?
         BRZ   LWTC9100            Yes => Branch to Exit This Routine
         CGF   R15,WTCRTCDE        Current RtnCde Higher than Previous?
         BRH   LWTC9200            Yes =>Then Branch to Exit
LWTC9100 DS    0H
         LLGF  R15,WTCRTCDE        Get Highest Return Code Generated
LWTC9200 DS    0H
         BRU   LWTCEXIT            Exit the Storage Watch Program
         DROP  R3                  Remove Listed Register as Base Reg
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LWTC$END DS    0H
         SLGR  R15,R15             Indicate Successful Completion
LWTCEXIT DS    0H
         ST    R15,WTCRETCD        Save Highest Return Code Generated
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,WTCRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         CNOP  0,8                 Doubleword Boundary - Zero Fill
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove All Listed Regs as Base Regs
*
***********************************************************************
*                 End of LGMHWTCH Program                             *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Logger Control Area-(LCA)
RBASE1   EQU   12                  Program Base Register
RCOMM1   EQU   11                  Common Dynamic Area Base Register
RCOMM2   EQU   10                  Common Constants/Routines Base Reg
         USING COM#H5M7,RCOMM1     Constants&Routines Addressability
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M # H 5 M 7 |**************************
**************************+-----------------+**************************
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  P r o g r a m   C o n t r o l   C o m m o n   D a t a   A r e a  |*
*+-------------------------------------------------------------------+*
*
COM#H5M7 RSECT                     Program Control Section
COM#H5M7 AMODE &AMODE              Establish Addressing Mode
COM#H5M7 RMODE &RMODE              Establish Residence Mode
*
BLANKS   DC    CL256' '            Define Character String of Blanks
*
*+-------------------------------------------------------------------+*
*|       S t o r a g e   W a t c h   T o k e n   M i x   B o x       |*
*+-------------------------------------------------------------------+*
*
         DS    0D                  Establish Doubleword Boundary
WATCHMIX DS    0XL256              Define Bit Pattern Mixing Box
WATCHROW EQU   L'WATCHMIX/16       Define Length of Box Row as 16 Bytes
         DC    XL(WATCHROW)'1823C6E887B8014F36A6D2F5796F9152'  00-0F
         DC    XL(WATCHROW)'60BC9B8EA30C7B351DE0D7C22E4BFE57'  10-1F
         DC    XL(WATCHROW)'157737E59FF04ADA58C9290AB1A06B85'  20-2F
         DC    XL(WATCHROW)'BD5D10F4CB3E0567E427418BA77D95D8'  30-3F
         DC    XL(WATCHROW)'FBEE7C66DD17479ECA2DBF07AD5A8333'  40-4F
         DC    XL(WATCHROW)'6302AA71C81949D9F2E35B889A2632B0'  50-5F
         DC    XL(WATCHROW)'E90FD580BECD3448FF7A905F20681AAE'  60-6F
         DC    XL(WATCHROW)'B454932264F173124008C3ECDBA18D3D'  70-7F
         DC    XL(WATCHROW)'9700CF2B7682D61BB5AF6A5D45F330EF'  80-8F
         DC    XL(WATCHROW)'3F55A2EA65BA2FC0DE1CFD4D9275068A'  90-9F
         DC    XL(WATCHROW)'B2E60E1F62D4A896F9C525598472394C'  A0-AF
         DC    XL(WATCHROW)'5E78388CD1A5E261B3219C1E43C7FC04'  B0-BF
         DC    XL(WATCHROW)'51996D0DFADF7E243BABCE118F4EB7EB'  C0-Cf
         DC    XL(WATCHROW)'3C8194F7B9132CD3E76EC40356447FA9'  D0-DF
         DC    XL(WATCHROW)'2ABBC153DC0B9D6C3174F646AC8914E1'  E0-EF
         DC    XL(WATCHROW)'163A690970B6D0EDCC4298A4285CF886'  F0-FF
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|           P r o g r a m   C o n t r o l   A r e a                 |*
*+-------------------------------------------------------------------+*
*
WTC@PCA  DSECT ,                   Program Control Area-(PCA)
WTC@EYEC DS    CL32                Storage Watch Work Area Eye-Catcher
WTC$SAVE DS    26FD                All Register Save Area
WTCREGSV DS    3FD                 Work Register Save Area
WTCWORKD DS    10D                 General Work Area
WTCLG2II DS    AD                  Addr of LGRWK2II Logger Service Area
WTCSTOR@ DS    AD                  Save Area for Addr of Input Storage
WTCSTORL DS    FD                  Save Area for Input Storage Length
WTCTOKN@ DS    AD                  Save Area for Addr to Return Token
WTCTOKEN DS    XL16                Area for the Finalized Watch Token
WTCHKSUM DS    FD                  Save Area for Input Storage CheckSum
WTCRETCD DS    F                   Return Code for Storage Watch
WTCRTCDE DS    F                   Save Area for Return Code
         DS    0D                  Ensure Area on Doubleword Bounday
WTC$WORK DS    CL(WATCH$LN)        Watch Processing Work area
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|       S t o r a g e   W a t c h   W o r k   A r e a   M a p       |*
*+-------------------------------------------------------------------+*
*
WATCHARE DSECT ,                   Watch Processing Work Area
WATCHAR1 DS    XL(L'WATCHMIX)      Define Section 1 of Watch Work Area
WATCHAR2 DS    XL(L'WATCHMIX)      Define Section 2 of Watch Work Area
WATCHAR3 DS    XL(L'WATCHMIX)      Define Section 3 of Watch Work Area
WATCHAR4 DS    XL(L'WATCHMIX-1)    Define Section 4 of Watch Work Area
WATCHWLN EQU   *-WATCHAR1          Set Length of the Watch Work Area
WATCHSLK DS    X                   General Slack Byte for Any Spill
WATCHFLG DS    X                   General Flag Byte for Processing
WATCH1ST EQU   X'80'               Addr Reset to Beginning of Work Area
WATCHFBW EQU   X'40'               Indicate a Full Block Work Area
WATCHLEN DS    H                   Length of the Current Storage Area
WATCHBCT DS    F                   Area for the Total Length In Bytes
WATCHWK@ DS    AD                  Save Area Starting Addr of Work Area
WATCHBIT DS    XL9                 Save Area for Pad and Length in Bits
WATCH$LN EQU   *-WATCHARE          Length of Watch Processing Area
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|  S t o r a g e   W a t c h   A d d r e s s   L i s t   E n t r y  |*
*+-------------------------------------------------------------------+*
*
WATCHLLC DSECT ,                   Storage Watch Addr List Table Entry
WTCSTOR$ DS    AD                  Address of the Storage Being Watched
WTCSTOLN DS    FD                  Length of the Storage Being Watched
WTCTOKN$ DS    XL(L'WTCTOKEN)      Hash Token Associated with Storage
         DS    0D                  Ensure List on a DoubleWord Boundary
WTCTBLEN EQU   *-WATCHLLC          Length of a Storage Watch List Entry
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   C o n t r o l   A r e a   -   (LCA )         |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Assembler Pgm Setup CopyBook
WTCLRCE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This CSECT    X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
*
         END
