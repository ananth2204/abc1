***********************************************************************
*LLL      GGGGGGG M     M H      H LLL       RRRRRRR  CCCCCCCC IIIIIII*
* L       G     G MM   MM H      H  L        R      R C      C    I   *
* L       G       M M M M H      H  L        R      R C           I   *
* L       G  GGGG M  M  M HHHHHHHH  L        RRRRRRR  C           I   *
* L       G     G M     M H      H  L        R    R   C           I   *
* L       G     G M     M H      H  L        R     R  C      C    I   *
* LLLLLLL GGGGGGG M     M H      H  LLLLLLLL R      R CCCCCCCC IIIIIII*
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHLRCI                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Initialization Program             *
*                                                                     *
* INPUT REGS:      R1  => Standard O/S Parameter List                 *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* CALLING PROGRAM: User Program                                       *
*                                                                     *
* CALLED PROGRAMS: LENV0000 - Environmental Report Processing Routine *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return address                                *
*                  R13, (LCA) Savearea & Dynamic Area                 *
*                  R12, (RBASE1) Program Base Register                *
*                  R11, (RBASE2) Program Base Register                *
*                  R10, (RCOMM1) Common Dynamic Area                  *
*                  R9,  (RCOMM2) Common Constants/Routines            *
*                  R8,  (RLGW) LGRWK2II Logger Service Work Area      *
*                  R7,  (RPGM) PGMLG2II Program Names List Table Area *
*                  R0-R6, General Work registers                      *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Update   V1R1M17 20120721 Update VV.RR.MM stats for Fix Pack 17@@KHF*
* Update   V1R1M16 20120127 Update VV.RR.MM stats for Fix Pack 16@@KHF*
* Fix      V1R1M15 20110930 Wrapped OPEN, CLOSE, and PUTs with   @@KHF*
*                           with SYSSTATE AMODE64=NO/YES Sequence@@KHF*
*                           to Conform to New Macro Changes That @@KHF*
*                           Were Introduced in zOS V1R13 to Test @@KHF*
*                           for Sysstate Amode During Assembly.  @@KHF*
* Update   V1R1M14 20110423 Update VV.RR.MM stats for Fix Pack 14@@KHF*
* Update   V1R1M13 20110108 Update VV.RR.MM stats for Fix Pack 13@@KHF*
* Fix      V1R1M12 20100306 Gregorian Date Off by 1 Day Beginning@@KHF*
*                           March 1 and After on Any Odd-numbered@@KHF*
*                           Non-Leap Year Decades (e.g, 2010).   @@KHF*
* Update   V1R1M11 20091023 Update VV.RR.MM stats for Fix Pack 11@@KHF*
* Update   V1R1M10 20090523 Update VV.RR.MM stats for Fix Pack 10@@KHF*
* Fix      V1R1M09 20090110 TCBFSA Addr + LCA 1st Save Area Addr @@KHF*
*                           in Logger Work Area (Save Area Trace)@@KHF*
* Add      V1R1M08 20081010 Added Hardware Configuration Info.   @@KHF*
* Fix                       Not Including Adjusts to REGION Limit@@KHF*
* Fix                       Garbage in DFARLSE Display with V1R10@@KHF*
* Fix      V1R1M07 20080524 Corrected Bug in WTO Msg Processing. @@KHF*
* Add      V1R1M06 20080223 Added Job Start Date and Time Info.  @@KHF*
* Add      V1R1M06 20080223 Added GMT Local Time Zone Offset Info@@KHF*
* Change   V1R1M06 20080223 Moved Environment Report to Own Rsect@@KHF*
* Fix      V1R1M06 20080223 LOGTRIM Not Suppressing Header Lines @@KHF*
* Add      V1R1M05 20080112 Added Version Info for z/OS and JES. @@KHF*
* Fix      V1R1M04 20071104 Incorrect Length on Jobname Field.   @@KHF*
* Update   V1R1M03 20070701 Updated VV.RR.MM stats for Fix Pack 3@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Add Support For Log Rcrd Trim Option.@@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Program
         LCLC  &RMODE              Resident Mode of Program
&KXHVER  SETC  'V1'                Indicate the Program Version Number
&KXHREL  SETC  'R1'                Indicate the Program Release Number
&KXHMOD  SETC  'M17'               Indicate the Pgm Modification Level
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
         COPY  LGCPLOGR            Logger Services Source-Setup CopyBk
&MODID   SETC  'LGMHLRCI'          Set the Program Module Identifier
         EJECT  ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHLRCI - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHLRCI                                           *
*                                                                     *
* FUNCTION:        Program Logger Initialization Services             *
*                                                                     *
*                  This routine is the main driver and entry point    *
*                  for processing the initialization request for      *
*                  program logger processing.                         *
*                                                                     *
*                  This program is entered only from the LPGMNTRY     *
*                  'TYPE=MAIN' statement when logging is turned on by *
*                  default or the 'LOG=ON' parameter is specified.    *
*                  This program is entered at the very start of user  *
*                  program execution to perform the initialization    *
*                  processing required to create an environment for   *
*                  the logging of a user program for debugging.       *
*                                                                     *
*                  In addition, this program will create a report     *
*                  showing system enviromental information at the time*
*                  the user's program started execution.              *
*                                                                     *
* For example:                                                        *
*                                                                     *
* USRTEST1 LPGMNTRY TYPE=MAIN, <===  Define Main Program Entry        *
*              BASE=(12,11),         Establish Base Registers         *
*              AMOD=64,RMOD=31,      Define Addessing and Residence   *
*              STORAGE=32,           Define LCA Stacked Storage Size  *
*              LCAPFX=URT,           LCA Prefix for This CSECT        *
*         ===> LOG=ON,               Turn On Logging (Default)        *
*              LOGOUT=PRNT,          Write Logger Records to Output   *
*              MSG='Test User Program 1'                              *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
***********************************************************************
*
LGMHLRCI LPGMNTRY TYPE=MAIN,       Define As A Main Program Entry      X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               STORAGE=16,         Define LCA Stacked Storage Size     X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LCAPFX=LSN,         Establish LCA Prefix for This RSECT X
               COPY@RT=YES         To Generate a Copyright Statement
*
*+-------------------------------------------------------------------+*
*|              Setup a Temporary Working Storage Area               |*
*+-------------------------------------------------------------------+*
*
         USING LAX@PCA,RCOMM1      Common Program Area Addressability
         USING COM#B7N3,RCOMM2     Constants&Routines Addressability
LSN00100 DS    0H
         LLGT  RCOMM2,=A(COM#B7N3) Common Constants and Routines Area
         LLILL R2,(LAXLNGTH)       Get the Length of Common Area
         LGR   R0,R2               Pass the Length to R0
       STORAGE OBTAIN,             Get Dynamic Storage for Common Area X
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=DBLWD,        Alignment Is On Doubleword Boundary X
               LOC=(24,31)         Dynamic Area Anywhere Below the Line
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LSN00500            Yes => Branch to Init Logger Service
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRE   LSN00400            Yes => Branch to Init Logger Service
*
*+-------------------------------------------------------------------+*
*|        Issue WTO Error Message for Storage Obtain Failure         |*
*+-------------------------------------------------------------------+*
*
LSN00200 DS    0H
         MVI   DSNWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   DSNWTOMG+1(L'DSNWTOMG-1),DSNWTOMG ..Propogate the Blank
         MVC   DSNWTOMG(L'LGA01109),LGA01109 ..Set the Message to Print
         LA    R1,DSNWTOMG+L'LGA01109 End of Msg for Storage Retrn Code
         ST    R15,DSNWORKD+4      Hexidecimal Return Code to Work Area
         UNPK  0(5,R1),DSNWORKD+4(5) ...To Create a Visible Return Code
         TR    0(4,R1),HEXCONV-C'0' Translate Hex Rtrn Cde to Character
         MVI   4(R1),C'.'          Insert Period after the Return Code
         MVC   DSNWTOLN,=Y(L'DSNWTOMG) ..Set the Length of the Message
         MVC   DSNWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LSN00300 DS    0H
         WTO   TEXT=DSNWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,DSNWTOL)      Indicate Using Remote Parameter List
         BRU   LSNTRTRN            Branch to Exit and Return to Caller
*
*+-------------------------------------------------------------------+*
*|Initialize Work Area, Establish Addressability to Work Area, Set   |*
*|Work Area Eyecatcher, and Verify the Type of Request By the User   |*
*|Program for Logger Services                                        |*
*+-------------------------------------------------------------------+*
*
LSN00400 DS    0H
         LLGFR R4,R1               Beginning Address of Area to Clear
         LLGFR R5,R2               Length of Common Area to Clear
         MVCLE R4,R14,0            RC on Successful Getmain has R15=0
LSN00500 DS    0H
         LGFR  RCOMM1,R1           Establish Common Work Area Address
         ST    RCOMM1,LAXSVCOM     Save Our Common Area Start Address
         ST    R2,LAXSAVEA         Let Length Show in Our Area
         LG    R2,(LSNS64BCK-LSNSAVE)(,R13) Caller's Save Area Address
         LLGF  R4,LSNSA_R1-LSNSAVE(,R2) Restore Logger Services Request
         MVC   LAX@EYEC,=CL32'LGMHLRCI DYNAMIC AREA' Set the Eyecatcher
         LTGFR R4,R4               Is This Request For Initialization?
         BRNZ  LSNTEXIT            No  => Then Exit
         BRU   LSN00600            Yes => Then Its for Initialization
*
*+-------------------------------------------------------------------+*
*| Acquire Storage for Logger Services Work Area Which is Mapped by  |*
*| the LGRWK2II Dsect in the LGCPLSWA Copybook.                      |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,RLGW       Setup LGRWK2II Area Addressability
LSN00600 DS    0H
         LLGF  R0,=A(LGRWK2LN)     Get Length of LGRWK2II Logger Area
       STORAGE OBTAIN,             Get Storage for the Logger Work AreaX
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(24,31)         Dynamic Storage Area Below the Line
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LSN01000            Yes => Branch to Setup Environment
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LSN00800            No  => Branch to Issue Error Message
LSN00700 DS    0H
         LLGFR R4,R1               Get Start of Logger Service Area
         LLGF  R5,=A(LGRWK2LN)     Get Length of LGRWK2II Logger Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R4,R14,0            Clear Entire Logger Service Area
         BRU   LSN01000            Branch to Establish ESTAE Environmnt
*
*+-------------------------------------------------------------------+*
*|        Issue WTO Error Message for Storage Obtain Failure         |*
*+-------------------------------------------------------------------+*
*
LSN00800 DS    0H
         MVI   DSNWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   DSNWTOMG+1(L'DSNWTOMG-1),DSNWTOMG ..Propogate the Blank
         MVC   DSNWTOMG(L'LGA01101),LGA01101 ..Set the Message to Print
         LA    R1,DSNWTOMG+L'LGA01101 End of Msg for Storage Return Cde
         ST    R15,DSNWORKD+4      Hexidecimal Return Code to Work Area
         UNPK  0(5,R1),DSNWORKD+4(5) ...To Create a Visible Return Code
         TR    0(4,R1),HEXCONV-C'0' Translate Hex Rtrn Cde to Character
         MVI   4(R1),C'.'          Insert Period after the Return Code
         MVC   DSNWTOLN,=Y(L'DSNWTOMG) ..Set the Length of the Message
         MVC   DSNWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LSN00900 DS    0H
         WTO   TEXT=DSNWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,DSNWTOL)      Indicate Using Remote Parameter List
         BRU   LSNTRTRN            Branch to Exit and Return to Caller
*
*+-------------------------------------------------------------------+*
*|      Create an AMODE64 ESTAEX Environment to Handle an Abend      |*
*+-------------------------------------------------------------------+*
* Set the eyecatcher and set initial values in Logger Services Work   *
* Area. Establish a Task Abnormal Exit Extended recovery environment  *
* in the event of an abnormal termination event occurring in a user   *
* program or in Logger services. The designated recovery ESTAEX exit  *
* is the Logger service program 'LGMHESTA'.                           *
***********************************************************************
*
CALLER   USING LCALSN,R2           Setup Caller's LCA Addressability
LSN01000 DS    0H
         SAM64
         LLGFR RLGW,R1             Establish Addressability to LGRWK2II
         MVC   LGWEYECT,=C'LGRWK2II' ...Set Eye Catcher in Logger Area
         ST    RLGW,CALLER.LSNTRCDS ...Pass LGRWK2II in Propogated Area
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R1,4(,R1)           Obtain the Current TCB Address
         USING TCB,R1              Establish Addressability to TCB
         LLGT  R1,TCBJSTCB         Get Address of First Job Step TCB
         LLGT  R1,TCBFSA           Get the Address of First Save Area
         N     R1,=A(X'00FFFFFF')  Addr of 1st Pgm Save Area is 3 Bytes
         ST    R1,LGWFSA           Save the TCBFSA in Our Work Area
         DROP  R1                  Remove Listed Reg as TCB Base Reg
         LG    R1,(LSNS64BCK-LSNSAVE)(,R2) Caller's Caller Save Area
         STG   R1,LGW$LFSA         Save LCA First Save Area Address
         ST    R2,LGWMAINP         Save Main Program LCA for our ESTAEX
         MVC   DSNESTAE,COMESTAE   Fill the ESTAEX Parameter List
         STG   RLGW,LGWPARM        Data Area Used by Logger Recovery
         LLGT  R2,=V(LGMHESTA)     Logger Services Recovery Routine Pgm
         O     R2,=A(X'00000001')  Set the Low Order Bit for AMODE-64
LSN01100 DS    0H
         ESTAEX (R2),              Initiate Error Recovery Setup       X
               CT,                 Define a New Recovery Environment   X
               PARAM=LGWPARM,      Address of Parameter List to Pass   X
               PURGE=NONE,         Outstanding I/O Operations Continue X
               ASYNCH=YES,         Allow Asynchronous Exit Processing  X
               CANCEL=YES,         Allow Interruption by Cancel/Detach X
               RECORD=NO,          Do not Record SWDA in System LogRec X
               TERM=YES,           Schedule Routine on Termination     X
               MF=(E,DSNESTAE)     Indicate Using Remote Parameter List
         LTGFR R15,R15             Was Recovery Environment Created?
         BRZ   LSN01400            Yes => Branch to Check for Logging
*
*+-------------------------------------------------------------------+*
*| Issue WTO Error Msg for Unable to Establish Recovery Environment  |*
*+-------------------------------------------------------------------+*
*
LSN01200 DS    0H
         MVI   DSNWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   DSNWTOMG+1(L'DSNWTOMG-1),DSNWTOMG ..Propogate the Blank
         MVC   DSNWTOMG(L'LGA01108),LGA01108 ..Set the Message to Print
         LA    R1,DSNWTOMG+L'LGA01108 End of Msg for ESTAEX Return Code
         STG   R15,DSNWORKD        Hexidecimal Return Code to Work Area
         UNPK  0(5,R1),DSNWORKD+4(5) ...To Create a Visible Return Code
         TR    0(4,R1),HEXCONV-C'0' Translate Hex Rtrn Cde to Character
         MVI   4(R1),C' '          Insert Blank after the Return Code
         LA    R1,5(,R1)           Increment Past the Return Code
         MVC   0(12,R1),=CL12'Reason Code=' Detail Line Hdr Reason Code
         LA    R1,12(,R1)          Increment Past the Reason Cde Header
         ST    R0,DSNWORKD+4       Hexidecimal Reason Code to Work Area
         UNPK  0(5,R1),DSNWORKD+4(5) ...To Create a Visible Reason Code
         TR    0(4,R1),HEXCONV-C'0' Translate Hex Rsn Code to Character
         MVI   4(R1),C'.'          Insert Period after the Reason Code
         MVC   DSNWTOLN,=Y(L'DSNWTOMG) ..Set the Length of the Message
         MVC   DSNWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LSN01300 DS    0H
         WTO   TEXT=DSNWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,DSNWTOL)      Indicate Using Remote Parameter List
         BRU   LSNTRTRN            Branch to Exit and Return to Caller
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
*
*+-------------------------------------------------------------------+*
*|       Search for //LGRSYSIN DD Data Control Block in TIOT         |*
*+-------------------------------------------------------------------+*
*  Verify if the //LGRSYSIN DD input data set for logger control      *
*  cards is allocated. If not allocated then exit indicating that     *
*  logging is not enabled for this program execution.                 *
***********************************************************************
*
LSN01400 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R2,4(,R1)           Obtain the Current TCB Address
         USING TCB,R2              Establish Addressability to TCB
         LLGT  R1,TCBTIO           Obtain Address of Task I/O Table
         USING TIOT1,R1            Establish addressability to TIOT
         LA    R1,TIOENTRY         Point at the First DDname Entry
         USING TIOENTRY,R1         Establish Addressability to Entry
         SLGR  R0,R0               Clear for Use as Work Register
LSN01500 DS    0H
         ICM   R0,B'0001',TIOELNGH Is There a Leng in Bytes for Entry?
         BRZ   LSNT$END            End TIOT, Exit and Return to Caller
         TM    TIOESTTA,TIOSLTYP   Is This a Freed TIOT Entry?
         BRO   LSN01600            Yes => Then Check for Next Entry
         CLC   4(8,R1),=C'LGRSYSIN' ..Is This Our Logger Input DDname?
         BRE   LSN01700            Yes => Branch to Validate DDname
LSN01600 DS    0H
         ALR   R1,R0               Point to the Next TIOT DDname Entry
         BRU   LSN01500            Loop to Check Next DDname in List
*
*+-------------------------------------------------------------------+*
*|Check If The Logger Service //LGRSYSIN DD is a Dummy or a Nullfile |*
*+-------------------------------------------------------------------+*
*  Verify if the //LGRSYSIN DD input data set for logger control      *
*  cards is Dummy or Nullfile. If it is then exit indicating that     *
*  logging is disabled for this program execution.                    *
***********************************************************************
*
LSN01700 DS    0H
         LA    R4,DSNEPA           Get the Address of the EPA
         ST    R4,DSNEPAPT         Initialize the Current EPA Pointer
         USING ZB505,R4            Establish Addressability to the EPA
         XC    SWAEPAX,SWAEPAX     Clear Area to Initialize the EPA
         MVC   SWVA,TIOEJFCB       Move SVA of JFCB into the EPA
         DROP  R1                  Remove Listed Reg as TIOT Base Reg
         SLGR  R2,R2               Clear for Use as a Work Register
         TAM                       Is Current Addressing Mode 31-Bit?
         BRM   LSN01800            Yes => Then Check the Input DSN JFCB
         IPM   R2                  Cond Code From Test Addressing Mode
         LCR   R2,R2               Set Two's Complement of Cond Code
         SRL   R2,29 Bits          Position For Use in Execute Instruct
         O     R2,=A(X'0000000C')  Set Operation Type for Amode Restore
         ST    R2,DSNAMODE         Preserve Operation Type for Amode
         SAM31                     Switch Now to 31-Bit Addressing Mode
LSN01800 DS    0H
       SWAREQ FCODE=RL,EPA=DSNEPAPT,UNAUTH=YES,MF=(E,DSNPARMS)
         LLGT  R4,SWBLKPTR         Set the Pointer to the JFCB
         USING INFMJFCB,R4         Establish addressability to JFCB
         CLC   JFCBDSNM(8),=C'NULLFILE' ...Dummy or Nullfile DD?
         BRE   LSNTEXIT            Yes => Then No Program Logging
         BRU   LSN01900            Branch to Process //LGRECOUT Output
         DROP  R4                  Remove Listed Req as EPA Base Reg
*
*+-------------------------------------------------------------------+*
*|      Search for the //LGRECOUT DD Data Control Block in TIOT      |*
*+-------------------------------------------------------------------+*
*  Verify if the //LGRECOUT DD output data set for printing logger    *
*  records is allocated. If not allocated then exit indicating that   *
*  logging is disabled for this job execution. Also attempt to verify *
*  if there is an open //LGRECOUT DCB by running the DEB chain, and   *
*  if one exists then exit indicating logging is enabled for this job.*
***********************************************************************
*
LSN01900 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R2,4(,R1)           Obtain the Current TCB Address
         USING TCB,R2              Establish Addressability to TCB
         LLGT  R1,TCBTIO           Obtain Address of Task I/O Table
         USING TIOT1,R1            Establish addressability to TIOT
         LA    R1,TIOENTRY         Point at the First DD Entry
         USING TIOENTRY,R1         Establish Addressability to Entry
         SLGR  R0,R0               Clear for Use as Work Register
LSN02000 DS    0H
         ICM   R0,B'0001',TIOELNGH Is There a Leng in Bytes for Entry?
         BRZ   LSN02300            No  => Branch If This is End of TIOT
         CLC   4(8,R1),=C'LGRECOUT' ..Is This Our Logger Output DDname?
         BRE   LSN02100            Yes => Check for DEB to See If Open
         ALR   R1,R0               Point to the Next TIOT DDname Entry
         BRU   LSN02000            Loop to Check Next DDname in List
LSN02100 DS    0H
         SL    R1,TCBTIO           Get the Offset to Our TIOT DD Entry
         LLGFR R3,R1               Preserve the Offset Value
         ICM   R1,B'1111',TCBDEB   Get First Data Extent Block on Chain
         BRZ   LSN02400            No DEBs on Chain
         USING DEBBASIC,R1         Establish Addressability to the DEB
LSN02200 DS    0H
         SLGR  R4,R4               Clear for Use as Work Register
         ICM   R4,B'0111',DEBDCBB  Get Address of Data Control Block
         USING IHADCB,R4           Establish Addressability to the DCB
         CLM   R3,B'0011',DCBTIOT  This Entry Represent Our DCB?
         BRE   LSN02300            Yes =>
         ICM   R1,B'0111',DEBDEBB  Is There Another DEB on the Chain?
         BRZ   LSN02400            No  => Output Data Set Available
         BRU   LSN02200            Yes => Loop to Check the Next DCB
         DROP  R1,R2,R4            Remove Listed Regs as Base Registers
LSN02300 DS    0H
         MVC   DSNRTCDE,=F'4'      //LGRECOUT DD not Found/Already Open
         BRU   LSNTEXIT            Branch to Exit LGMHLRCI Program
*
*+-------------------------------------------------------------------+*
*| Acquire Dynamic Area To Build The Program Names Table for the     |*
*| Input Logging Options Specified by the User in //LGRSYSIN. This   |*
*| Area is Mapped by the PGMLG2II Dsect in the LGCPLSWA Copybook.    |*
*+-------------------------------------------------------------------+*
*
         USING PGMLG2II,RPGM       Establish PGMLG2II Addressability
LSN02400 DS    0H
         LA    R2,32               Indicate Size of Initial Option Area
         SLLG  R2,R2,10 Bits       Shift to Make Option Area Size 32K
         LGR   R0,R2               Pass the Size of Request to R0
       STORAGE OBTAIN,             Get Dynamic Storage for Common Area X
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=DBLWD,        Alignment Is On Doubleword Boundary X
               LOC=(31,64)         Dynamic Storage Area Above the Line
         ST    R1,LGWPGML          Save Address of PGMLG2II Area
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   LSN02500            Yes => Then Set Base Reg for Area
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRNE  LSN02600            No  => Then Issue Error Message
         LLGFR R4,R1               Start of Input Logger Options Area
         LLGFR R5,R2               Get Length for Logger Options Area
         SLGR  R14,R14             Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R4,R14,0            Clear Entire Inpt Logger Option Area
LSN02500 DS    0H
         LLGFR RPGM,R1             Load Base Register for PGMLG2II Area
         ST    R2,PGMLENTH         Save Length of Input Options Area
         MVC   PGMLNTH,=A(L'PGMPREFX) ...Set the Initial Length Used
         BRU   LSN02800            Branch to Process Logging
*
*+-------------------------------------------------------------------+*
*|        Issue WTO Error Message for Storage Obtain Failure         |*
*+-------------------------------------------------------------------+*
*
LSN02600 DS    0H
         MVI   DSNWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   DSNWTOMG+1(L'DSNWTOMG-1),DSNWTOMG ..Propogate the Blank
         MVC   DSNWTOMG(L'LGA01102),LGA01102 ..Set the Message to Print
         CVD   R15,DSNWORKD        Create Decimal Version Return Code
         OI    DSNWORKD+L'DSNWORKD-1,15 Certify Sign to Make Printable
         LA    R1,DSNWTOMG+L'DSNWTOMG Addr of Area for Message Ret Code
         UNPK  0(4,R1),DSNWORKD    To Create a Visible Return Code
         MVC   DSNWTOLN,=Y(L'DSNWTOMG) ..Set the Length of the Message
         MVC   DSNWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LSN02700 DS    0H
         WTO   TEXT=DSNWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,DSNWTOL)      Indicate Using Remote Parameter List
         BRU   LSNTEXIT            No Way to Parse Logger Inpt, So Exit
*
*+-------------------------------------------------------------------+*
*|         Open Logger Services //LGRECOUT Output Data Set           |*
*+-------------------------------------------------------------------+*
* Open the //LGRECOUT DCB to enable logger records to be printed to   *
* an output data set. This DCB will be setup with a DCB Exit Routine. *
* The DCB Exit Routine will determine the options available for       *
* recovery should an abend condition occur during OPEN, CLOSE, or     *
* End-of-Volume where that abend is directly associated with only this*
* Logger output DCB. The DCB, the DCB exit list, and entry point for  *
* the DCB exit routine are required to reside below the 16Meg line.   *
* However, the Logger DCB Exit Routine LGMHDCBX is AMODE64 and        *
* resides above the 16Meg line. This means prior to OPEN, a hard-coded*
* copy of a DCB exit routine stub containing executable code will be  *
* relocated by copying it into a separate get-main'ed work area that  *
* is below-the-line. Then the //LGRECOUT DCB is updated with the      *
* address of a DCB exit list. This exit list will be updated to       *
* contain the address of the stub residing in the get-main area. Upon *
* an abend condition occurring the stub will be entered below-the-line*
* in 24-bit mode. The stub will then redirect the DCB exit processing *
* to the actual Logger Services DCB Exit Routine program named        *
* LGMHDCBX which will execute above-the-line in 64-Bit addressing     *
* mode.                                                               *
***********************************************************************
*
         USING IHADCB,R2           Addressability to Data Control Block
LSN02800 DS    0H
         MVC   LGWODCB(MODCBLEN),MODELDCB  Model DCB for Logger Output
         MVC   LGWODCBE(MODCBELN),MODLDCBE Model DCBE for Logger Output
         LA    R2,LGWODCB          Get the Address of DCB List Area
         LA    R1,LGWODCBE         Get the Address of the DCBE
         ST    R1,DCBDCBE          Put the Address of DCBE in the DCB
         OI    DCBBFTEK,DCBH0+DCBH1 Indicate a DCBE is Present for DCB
         MVC   DCBDDNAM,LOGDDOUT   Indicate Logger Outpt DDnme for Open
         MVC   DCBLRECL,=XL2'0085' Indicate Logical Record Length
         XC    DCBMACR,DCBMACR     Reset Macro Instruction Reference
         OI    DCBMACR2,DCBMRPUT+DCBMRMVP  Set DCB for Output Move Mode
         OI    DCBRECFM,DCBRECF+DCBRECBR+DCBRECCA Set Record Format FBA
         LA    R1,DCB$XLST         Get Address of the DCB Exit List
         STCM  R1,B'0111',DCBEXLSA Point DCB to the DCB Exit List Area
         LA    R0,DCB$EXIT         Get Address to DCB Abend Exit Stub
         STCM  R0,B'0111',DCB$XLST+1 Adr of Exit Stub into DCB Exit Lst
         MVI   DCB$XLST,X'91'      Activate Exit + Indicate End of List
         MVC   DCB$EXIT,MODLEXIT   Copy DCB Exit Stub to Below 16M Area
         LLGT  R0,=V(LGMHDCBX)     Adr of Actual DCB Abend Exit Routine
         ST    R0,DCB@EXIT         For Redirection from Stub to Actual
         MVC   DSNOPENL,MODLOPEN   Build the Open Parameter List
         MVI   DSNOPENL,X'80'      Set VL Bit in Open Parameter List
LSN02900 DS    0H
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         OPEN  ((R2),OUTPUT),      Perform Open Process for Output     X
               MF=(E,DSNOPENL),    Execute Form of Open for Output     X
               MODE=31             Indicate 31-bit Mode for Output
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LGH   R15,DCBLRECL        Get Length of Logger Output Record
         STH   R15,LGWLRECL        Save Length of Logger Output Records
         TM    DCBOFLGS,DCBOFOPN   Is the //LGRECOUT DCB Open?
         BRO   LSN03200            Yes => Branch to Write Header Lines
         BRU   LSN03000            No  => Branch to Issue Error Message
         DROP  R2                  Remove Listed Reg as DCB Base Reg
*
*+-------------------------------------------------------------------+*
*|          Issue Error Message for //LGRECOUT Open Failure          |*
*+-------------------------------------------------------------------+*
*
LSN03000 DS    0H
         MVI   DSNWTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   DSNWTOMG+1(L'DSNWTOMG-1),DSNWTOMG ..Propogate the Blank
         MVC   DSNWTOMG(L'LGA01103),LGA01103 ..Set the Message to Print
         MVC   DSNWTOLN,=Y(L'DSNWTOMG) ..Set the Length of the Message
         MVC   DSNWTOL(COM$WTOL),COM$WTO  List Form of WTO to Parm Area
LSN03100 DS    0H
         WTO   TEXT=DSNWTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,DSNWTOL)      Indicate Using Remote Parameter List
         BRU   LSNTEXIT            No Place To Put Loggr Outpt, So Exit
*
*+-------------------------------------------------------------------+*
*|  Write Header Lines to the //LGRECOUT DD Logger Output Data Set   |*
*|                                                                   |*
*|  For example:                                                     |*
*|                                                                   |*
*|       */************************************************/         |*
*|       */      LOGGRASM Service Information Report      */         |*
*|       */      -----------------------------------      */         |*
*|       */************************************************/         |*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
LNE      USING LGWLINE,R6          Establish Addressability to Rcrd Lne
LSN03200 DS    0H
         LLGT  R6,=A(LGWLINE-LGRWK2II) Index to Logger Record List Area
         LA    R6,0(R6,RLGW)       Point to the Logger Records Area
CALLER   USING LCALSN,R2           Setup Caller's LCA Addressability
         LLGT  R2,LGWMAINP         Get Main Program LCA (Caller's LCA)
         TM    CALLER.LSNWFLAG,LCAWTRIM Request to Trim Log Rcrd Outpt?
         BRO   LSN03800            Yes => Bypass Write of Header Lines
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
LSN03300 DS    0H
         MVI   LNE.LGWCC,C'1'      Set Carriage Control to Top of Page
         MVC   LNE.LGWOLINE,HEADRLNE   Clear the 1st Header Output Line
         MVC   LNE.LGWOLINE+CARDLEN/2-L'HEADER#1/2(L'HEADER#1),HEADER#1
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN03400 DS    0H
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Skip 1 Line
         MVC   LNE.LGWOLINE,HEADRLNE   Clear the 2nd Header Output Line
         MVC   LNE.LGWOLINE+CARDLEN/2-L'HEADER#2/2(L'HEADER#2),HEADER#2
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN03500 DS    0H
         MVC   LNE.LGWOLINE,HEADRLNE   Clear the 3rd Header Output Line
         MVC   LNE.LGWOLINE+CARDLEN/2-L'HEADER#3/2(L'HEADER#3),HEADER#3
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN03600 DS    0H
         MVC   LNE.LGWOLINE,HEADRLNE   Clear 4th Header to Output Line
         MVC   LNE.LGWOLINE+CARDLEN/2-L'HEADER#4/2(L'HEADER#4),HEADER#4
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN03700 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         PUT   LGWODCB,LNE.LGWLINE Print a Blank Line as Separator
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|     Open the //LGRSYSIN DD Input Data Set for Logging Options     |*
*+-------------------------------------------------------------------+*
* Open the //LGRSYSIN DCB to enable logger input statements to be read*
* to direct the processing of logger service events. Upon open the    *
* header records are printed to the //LGRECOUT DD output data set, and*
* a column ruler is inserted to display the column positions of the   *
* input logger control statements which have been specified by the    *
* user in the //LGRSYSIN DD. Thereafter the card images from the input*
* //LGRSYSIN data set are read, printed to the //LGRECOUT DD output   *
* data set, and then a bottom column ruler is inserted.               *
*                                                                     *
* For Example:                                                        *
*                                                                     *
*                            //LGRSYSIN Input Cards                   *
*                             ----------------------                  *
*....+....10...+....20...+....30...+....40...+....50...+....60...+....*
*                                                                     *
*          LOGEVENT PROGRM,NAME=(*))                                  *
*          LOGEVENT SUBRTN,NAME=(*)                                   *
*          LOGEVENT LOGPNT,NAME=(*)                                   *
*                                                                     *
*....+....10...+....20...+....30...+....40...+....50...+....60...+....*
*                                                                     *
*                                                                     *
***********************************************************************
*
         USING IHADCB,R2           Establish Addressablity to the DCB
LSN03800 DS    0H
         MVC   DSNSYSI@(LGRSYSNL),LGRSYSIN .Get the DCB for //LGRSYSIN
         MVC   DSNDCBE@(LGRDCBEL),LGRIDCBE .Get the DCBE for //LGRSYSIN
         LA    R2,DSNSYSI@         Get the Address of DCB List Area
         LA    R1,DSNDCBE@         Get the Address of DCBE
         ST    R1,DCBDCBE          Set Address of DCBE in the DCB
         MVC   DCBDDNAM,DSNSYSI$   Target the DDname for Open
         MVC   DSNOPENL,MODLOPEN   Build the Open Parameter List
         MVI   DSNOPENL,X'80'      Set VL Bit in Parameter List
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         OPEN  ((R2),INPUT),       Perform Open Process for //LGRSYSIN X
               MF=(E,DSNOPENL),    Execute Form of Open for //LGRSYSIN X
               MODE=31             Indicate 31-bit Mode for //LGRSYSIN
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
LSN03900 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is the Input //LGRSYSIN DCB Open?
         BRO   LSN04000            Yes => Branch to Print Column Rulers
         BRU   LSNTEXIT            No  => Exit This LGMHLRCI Program
         DROP  R2                  Remove Listed Reg as DCB Base Reg
LSN04000 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print a Blank Line as Separator
CALLER   USING LCALSN,R2           Setup Caller's LCA Addressability
         LLGT  R2,LGWMAINP         Get Main Program LCA (Caller's LCA)
         TM    CALLER.LSNWFLAG,LCAWTRIM Request to Trim Log Rcrd Outpt?
         BRO   LSN04500            Yes => Process Input Card Images
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
LSN04100 DS    0H
         MVC   LNE.LGWOLINE,HEADRLNE Clear 1st Column Ruler Header Line
         MVC   LNE.LGWOLINE+CARDLEN/2-L'RULER#1/2(L'RULER#1),RULER#1
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN04200 DS    0H
         MVC   LNE.LGWOLINE,HEADRLNE Clear 2nd Column Ruler Header Line
         MVC   LNE.LGWOLINE+CARDLEN/2-L'RULER#2/2(L'RULER#2),RULER#2
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN04300 DS    0H
         MVC   LNE.LGWOLINE,HEADRLNE Clear 3rd Column Ruler Header Line
         MVC   LNE.LGWOLINE(L'RULER#3),RULER#3 Move Column Ruler to Lne
         PUT   LGWODCB,LNE.LGWLINE Print the Logger Output Line
LSN04400 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         PUT   LGWODCB,LNE.LGWLINE Print a Blank Line as Separator
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|  Read a Card Image from the //LGRSYSIN DD for a Logger Operation  |*
*+-------------------------------------------------------------------+*
*  //LGRSYSIN - Logger Services Input Control Cards                   *
*                                                                     *
* Read the //LGRSYSIN data set for card images to process the input   *
* control statements in order to extract the operation code, operands,*
* and keyword parameters specified by the user to direct processing   *
* of all logger activity. Keyword entries from the //LGRSYSIN input   *
* will be placed into the program names table. This table will be     *
* checked by program 'LGMHLRCE' for the inclusion or the exclusion    *
* of logger activity in order to filter the creation of logger records*
* as directed by the user in //LGRSYSIN. For input control statements *
* no continuation is allowed. Comments may be added by either placing *
* an asterisk (*) in column one, or comments may be added after the   *
* closing delimiter Ýright parenthesis ")"¨ for the keyword parameter *
* followed by a blank.                                                *
*                                                                     *
*  Examples:                                                          *
*      //LGRSYSIN  * DD                                               *
*         LOGEVENT PROGRM,NAME=(USERPGM1,USERPGM2,USERPGX?)           *
*         LOGEVENT SUBRTN,NAME=(USERSUB1,USERSUB2,USERSBX?)           *
*         LOGEVENT LOGPNT,NAME=(USER5000,USER5500,USERLGX*)           *
*                                                                     *
***********************************************************************
*
LSN04500 DS    0H
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         GET   DSNSYSI@,DSNCARD    Perform Read of Input Card Image
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         CLI   DSNCARD,C'*'        Is This Card Image a Comment Line?
         BRE   LSN04500            Yes => Loop to Get Next Input Recrd
CALLER   USING LCALSN,R2           Setup Caller's LCA Addressability
         LLGT  R2,LGWMAINP         Get Main Program LCA (Caller's LCA)
         TM    CALLER.LSNWFLAG,LCAWTRIM Request to Trim Log Rcrd Outpt?
         BRO   LSN04600            Yes => Bypass Print of Output Record
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
         MVC   LNE.LGWOLINE(L'DSNCARD),DSNCARD ...Card Image to Output
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print the Card Image from //LGRSYSIN
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
LSN04600 DS    0H
         LA    R3,DSNCARD          Get Beginning Address of Card Input
         LLILL R14,(L'DSNCARD)     Get the Length of Input Card Image
LSN04700 DS    0H
         CLI   0(R3),C' '          Is this Byte Position a Blank?
         BRNE  LSN04800            No  => Check for Logger Card Entry
         LA    R3,1(,R3)           Bump to the Next Byte Position
         BRCTG R14,LSN04700        Loop to Check the Next Byte
         BRU   LSN04500            Blank Card So Get Next Input Record
LSN04800 DS    0H
         CLC   0(L'LOGEVENT,R3),LOGEVENT Logger Card in our Statement?
         BRE   LSN05000            Yes => Process 'LOGEVENT' Operation
         BRU   LSN04900            No  => Branch to Issue Error Message
*
*+-------------------------------------------------------------------+*
*|          Issue Error Message for Unknown Operation Field          |*
*+-------------------------------------------------------------------+*
*
LSN04900 DS    0H
         MVC   LNE.LGWOLINE(L'LGA01104),LGA01104 Show Unknown Operation
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print the Error Message
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         BRU   LSN04500            Ignore Card for Unknown Operation
*
*+-------------------------------------------------------------------+*
*|  Process Control Statement from //LGRSYSIN DD for Logger Operand  |*
*+-------------------------------------------------------------------+*
*
LSN05000 DS    0H
         MVI   DSNINPUT,C'Y'       Indicate Non-Comment Card was Found
         MVI   DSNFLAG,X'00'       Clear the Loggr Processing Indicator
         XC    DSNTYPE,DSNTYPE     Clear the Logger Service Event Type
         LA    R3,L'LOGEVENT+1(,R3) ...Bump Past Logger Operation Code
         LLGFR R4,R3               Save Current Position in Card Image
         LA    R2,DSNCARD          Get the Beginning Address of Card
         SGFR  R4,R2               Calculate Remaining Length in Card
LSN05100 DS    0H
         CLI   0(R3),C' '          Is this Byte Position a Blank?
         BRNE  LSN05300            No  => Check for Operand
         LA    R3,1(,R3)           Bump to the Next Byte Position
         BRCTG R4,LSN05100         Loop to Check the Next Byte
*
*+-------------------------------------------------------------------+*
*|          Issue Error Message for Missing Operand Field            |*
*+-------------------------------------------------------------------+*
*
LSN05200 DS    0H
         MVC   LNE.LGWOLINE(L'LGA01105),LGA01105   Show Missing Operand
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print the Error Message
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         BRU   LSN04500            Ignore Card Input on Missing Operand
*
*+-------------------------------------------------------------------+*
*|      Determine Operand Specified for Logger Service Operation     |*
*+-------------------------------------------------------------------+*
*  Process the operand specified in the control card image to find    *
*  out what types of logger activity were requested. The "PROGRM"     *
*  operand indicates that program entry and program exits are to be   *
*  logged for the program names listed. The "SUBRTN" operand          *
*  operand indicates subroutine entry and subroutine exits are to     *
*  be logged for subroutine names listed in addition to program       *
*  entry and exits for programs specified in the names list. The      *
*  "LOGPNT" operand indicates log points which have been defined      *
*  by the user within their programs.                                 *
*                                                                     *
*  Examples:                                                          *
*      //LGRSYSIN  * DD                                               *
*         LOGEVENT PROGRM,NAME=(*)                                    *
*         LOGEVENT SUBRTN,NAME=(*)                                    *
*         LOGEVENT LOGPNT,NAME=(*)                                    *
*                                                                     *
*      //LGRSYSIN  * DD                                               *
*         LOGEVENT PROGRM,NAME=(USERPGM1,USERPGM2,USERPGX?)           *
*         LOGEVENT SUBRTN,NAME=(USERSUB1,USERSUB2,USERSVL?)           *
*         LOGEVENT LOGPNT,NAME=(USER5000,USER5500,USRXPGS*)           *
*                                                                     *
***********************************************************************
*
LSN05300 DS    0H
         CLC   0(L'PROGRAM,R3),PROGRAM  Request to Log Program Entry?
         BRNE  LSN05400            No  => Check for Other Operands
         OI    DSNFLAG,PGMPFPGM+PGMPFTRC  Init For Pgms and Tracepoints
         MVC   DSNTYPE,PROGRAM     Indicate the Logger Type Name
         BRU   LSN05800            Branch to Process Logger Operand
LSN05400 DS    0H
         CLC   0(L'SUBROUTN,R3),SUBROUTN  To Log Subroutine Entry?
         BRNE  LSN05500            No  => Check for Other Operands
         OI    DSNFLAG,PGMPFSUB    Indicate Logger Program Subroutines
         MVC   DSNTYPE,SUBROUTN    Indicate the Logger Type Name
         BRU   LSN05800            Branch to Process Logger Operand
LSN05500 DS    0H
         CLC   0(L'LOGPOINT,R3),LOGPOINT  Request to Log Log Points?
         BRNE  LSN05600            No  => Check for Other Operands
         OI    DSNFLAG,PGMPFTRC    Indicate Log Program Log Points
         MVC   DSNTYPE,LOGPOINT    Indicate the Logger Type Name
         BRU   LSN05800            Branch to Process Logger Operand
LSN05600 DS    0H
         CLC   0(L'SYSTEM,R3),SYSTEM  Request to Log at System Level?
         BRNE  LSN05700            No  => Unknown Operand Specified
         OI    DSNFLAG,PGMPFSYS    Indicate Logger System Services
         MVC   DSNTYPE,SYSTEM      Indicate the Logger Type Name
         BRU   LSN05800            Branch to Process Keyword Name
*
*+-------------------------------------------------------------------+*
*|           Issue Error Message for Unknown Operand Field           |*
*+-------------------------------------------------------------------+*
*
LSN05700 DS    0H
         MVC   LNE.LGWOLINE(L'LGA01106),LGA01106 Show Unknown Operand
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print the Error Message
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         BRU   LSN04500            Ignore Card for Unknown Operand
*
*+-------------------------------------------------------------------+*
*|        Verify Keyword Parameter Specified in Operand Field        |*
*+-------------------------------------------------------------------+*
*
LSN05800 DS    0H
         LA    R3,7(,R3)           Increment Past the Logger Operand
         CLC   0(L'NAME,R3),NAME   Is Keyword Name in Operand Field?
         BRE   LSN06000            Yes => Process the Logger Keyword
         BRU   LSN05900            Branch to Issue Error Message
*
*+-------------------------------------------------------------------+*
*|          Issue Error Message for Invalid Keyword Name             |*
*+-------------------------------------------------------------------+*
*
LSN05900 DS    0H
         MVC   LNE.LGWOLINE(L'LGA01107),LGA01107 ..Show Invalid Keyword
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,LNE.LGWLINE Print the Error Message
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         BRU   LSN04500            Bypass Card for Invalid Keyword
*
*+-------------------------------------------------------------------+*
*|           Extract the Control Section Names from Keyword          |*
*+-------------------------------------------------------------------+*
*  The "Program name/Control section name" fields may contain         *
*  wildcards in the form of the question mark "?" or in the form      *
*  of the asterisk "*" to allow filtering of logger events. Patterns  *
*  can be developed using these wildcard characters "?" or "*" to     *
*  direct the logger output. The special wildcard character "?" is    *
*  used in this logger implementation to represent any value in a     *
*  single position within the program name or the Csect Name. The     *
*  wildcard character "?" can be used multiple times within a program *
*  or Csect name to indicate any value in exactly that number of      *
*  positions. The special wildcard character "*" represents one or    *
*  more positions in the program or Csect name instead of the exact   *
*  position reference which the "?" provides. Wildcard characters     *
*  need not be restricted to the end of the program or Csect name.    *
*  They can also be specified at the beginning or middle of the       *
*  program or Csect name. The wild card characters may also be        *
*  specified than once in developing a pattern for the program or     *
*  Csect name.                                                        *
*                                                                     *
*   Examples:                                                         *
*      //LGRSYSIN  * DD                                               *
*         LOGEVENT PROGRM,NAME=(USERPGM1,USERPGM2,USERPGX?)           *
*         LOGEVENT SUBRTN,NAME=(USERSUB1,USERSUB2,USERSVL?)           *
*         LOGEVENT LOGPNT,NAME=(USER5000,USER5500,USERLGS*)           *
*                                                                     *
***********************************************************************
*
LSN06000 DS    0H
         LA    R3,5(,R3)           Increment Past the Keyword Name
         CLI   0(R3),C'('          Keyword Have a Subparameter List?
         BRNE  LSN06100            No  =>
         LA    R3,1(,R3)           Bump Past the Left Parentheis
LSN06100 DS    0H
         XC    DSNNAME,DSNNAME     Clear Receiving Field for Pgm Name
         XC    DSNMASK,DSNMASK     Clear Receiving Field for Pgm Mask
         MVC   DSNLNAM,=32C' '     Clear Receiving Field for Pgm Name
         MVC   DSNLMSK,=32X'00'    Clear Receiving field for Pgm Mask
         MVC   DSNCNAM,=32C' '     Clear Receiving Field for Csect Name
         MVC   DSNCMSK,=32X'FF'    Clear Receiving Field for Csect Mask
         LA    R14,DSNCNAM         Get the Address of Csect Name Area
         LA    R15,DSNCMSK         Get the Address of Csect Mask Area
         LLILL R1,(L'DSNCNAM)      Indicate the Maximum Length to Check
LSN06200 DS    0H
         CLI   0(R3),C' '          Are We at the End of Parameter Data?
         BRE   LSN06800            Yes => End of Subparameter List
         CLI   0(R3),C')'          Is This a Right Parenthesis?
         BRE   LSN06800            Yes => End of Subparameter List
         CLI   0(R3),C','          This a Comma Delimiter for Sublist?
         BRE   LSN06800            Yes => End of Subparamter
         CLI   0(R3),C'*'          A Wildcard Character in Our Name?
         BRE   LSN06600            Yes => Process for Asterisk
         BRU   LSN06300            No  => Process for Question Mark
*
*+-------------------------------------------------------------------+*
*|         Process for Question Mark Wildcard in Csect Name          |*
*+-------------------------------------------------------------------+*
*
LSN06300 DS    0H
         CLI   0(R3),C'?'          A WildCard Character in Csect Name?
         BRNE  LSN06400            No  => Branch to Process Csect Name
         MVI   0(R15),X'00'        Set Mask Value for Wildcard Position
         BRU   LSN06500            Branch to Process the Next Character
LSN06400 DS    0H
         MVC   0(1,R14),0(R3)      Copy the Character from Csect Name
LSN06500 DS    0H
         LA    R3,1(,R3)           Increment to the Next Character
         LA    R14,1(,R14)         Increment Name Position in Work Area
         LA    R15,1(,R15)         Increment Mask Position in Work Area
         BRCTG R1,LSN06200         Loop to Process the Next Character
         BRU   LSN06800            Branch to Process Program Name List
*
*+-------------------------------------------------------------------+*
*|          Process for Asterisk Wildcard in Csect Name              |*
*+-------------------------------------------------------------------+*
*
LSN06600 DS    0H
         CLI   0(R3),C' '          Are We at the End of Parameter Data?
         BRE   LSN06700            Yes => End of Subparameter List
         CLI   0(R3),C')'          Is This a Right Parenthesis?
         BRE   LSN06700            Yes => End of Subparameter List
         CLI   0(R3),C','          This a Comma Delimiter for Sublist?
         BRE   LSN06700            Yes => End of Subparameter
         LA    R3,1(,R3)           Bump to Next Character
         BRU   LSN06600            Loop to Process Next Character
LSN06700 DS    0H
         MVI   0(R15),X'00'        Set Mask Value for Wildcard Position
         LA    R14,1(,R14)         Increment Name Position in Work Area
         LA    R15,1(,R15)         Increment Mask Position in Work Area
         BRCTG R1,LSN06700         Loop to Process the Next Character
*
*+-------------------------------------------------------------------+*
*|    Verify If Program Name Already Exists in Program Names Table   |*
*+-------------------------------------------------------------------+*
*
LSN06800 DS    0H
         ICM   RPGM,B'1111',LGWPGML Is There a Pointer to Program List?
         BRZ   LSN07200            No  => Then Build New Pgm Name Entry
         ICM   R14,B'1111',PGMLNTH Is There a Length for Table Used?
         BRZ   LSN07200            No  => Then Build New Pgm Name Entry
         SH    R14,=Y(L'PGMPREFX)  Subtract the Prefix Length
         BRNP  LSN07200            Branch If a Null Program List
LSN06900 DS    0H
         NC    DSNNAME,DSNMASK     Apply Mask Value for Program Name
         CLC   DSNNAME(L'DSNNAME+L'DSNMASK),PGMPNAME Our Program Name?
         BRE   LSN07100            Yes => Entry Found in Program Table
LSN07000 DS    0H
         SH    R14,PGMPLNTH        Decrement for the Total Length
         AH    RPGM,PGMPLNTH       Increment to Next Program Tble Entry
         LTGFR R14,R14             Any There Any More Program Entries?
         BRNZ  LSN06900            Yes => Loop to Process Next Entry
         BRU   LSN07200            No  => Not Found, Build a New One
LSN07100 DS    0H
         OC    PGMPFLAG,DSNFLAG    Add Current Bits to Flag in Pgm Tble
         BRU   LSN07500            Branch to Process Next Csect Name
*
*+-------------------------------------------------------------------+*
*|    Build an Entry in Program Names Table for This Csect Name      |*
*+-------------------------------------------------------------------+*
*
NEW      USING PGMPLNTH,R14        Establish Alternate Addressability
LSN07200 DS    0H
         LLGT  RPGM,LGWPGML        Reload the PGMLG2II Pgm Table Addr
         LLGF  R14,PGMLNTH         Get the Length of Table Area Used
         ALGR  R14,RPGM            Point at the Next Pgm Table Entry
LSN07300 DS    0H
         XC    NEW.PGMPLNTH(PGMNTRYL),NEW.PGMPLNTH  Clear Entry Area
         MVC   NEW.PGMPLNTH,=Y(PGMNTRYL)  Indicate the Length
         MVC   NEW.PGMPTYPE,DSNTYPE ...Copy The Logger Type Name
         MVC   NEW.PGMPNAME,DSNNAME ...Copy the Program Name
         NC    NEW.PGMPNAME,DSNMASK ...Apply the Program Name Mask
         MVC   NEW.PGMPMASK,DSNMASK ...Copy the Current Mask Value
         MVC   NEW.PGMPFLAG,DSNFLAG ...Propogate the Current Flag Value
LSN07400 DS    0H
         LLGF  R14,PGMLNTH         Get the Old Length Which Was Used
         AGHI  R14,(PGMNTRYL)      Add the Length To This Entry
         ST    R14,PGMLNTH         Establsh the New Length Used
*
*+-------------------------------------------------------------------+*
*|    Loop Point to Check for Additional Subparameters Or Get The    |*
*|    Next Input Record from //LGRSYSIN                              |*
*+-------------------------------------------------------------------+*
*
LSN07500 DS    0H
         CLI   0(R3),C','          More Parameters On This Card Image
         BRNE  LSN04500            No  => Loop to Read Next Card Image
         LA    R3,1(,R3)           Increment Past the Comma Delimiter
         BRU   LSN06100            Loop to Process Next Parameter
         DROP  NEW                 Remove Listed Reg as Pgm Table Base
*
*+-------------------------------------------------------------------+*
*|       (EODAD) End of File Routine on //LGRSYSIN DD Records        |*
*+-------------------------------------------------------------------+*
*  At this point all logger input statements have been read and       *
*  processed from the //LGRSYSIN data set. Check if Log Trimming was  *
*  requested, and if 'Yes' then bypass processing of an environmental *
*  report for this job run. If 'No' or default taken, then process the*
*  enviromental report.                                               *
*                                                                     *
* For example:                                                        *
*                                                                     *
* USRTEST1 LPGMNTRY TYPE=MAIN,       Define Main Program Entry        *
*              BASE=(12,11),         Establish Base Registers         *
*              AMOD=64,RMOD=31,      Define Addessing and Residence   *
*              STORAGE=32,           Define LCA Stacked Storage Size  *
*              LCAPFX=URT,           LCA Prefix for This CSECT        *
*              LOG=ON,               Turn On Logging (Default)        *
*         ===> LOGTRIM=YES,          Trim the Log Record Output       *
*              LOGOUT=PRNT,          Write Logger Records to Output   *
*              MSG='Test User Program 1'                              *
*                                                                     *
***********************************************************************
*
CALLER   USING LCALSN,R2           Setup Caller's LCA Addressability
LSN07600 DS    0H
         LLGT  R2,LGWMAINP         Get Main Program LCA (Caller's LCA)
         TM    CALLER.LSNWFLAG,LCAWTRIM Request to Trim Log Rcrd Outpt?
         BRO   LSN09000            Yes => Bypass Environmental Report
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
*
*+-------------------------------------------------------------------+*
*| Process Environmental Report Describing the z/OS System           |*
*+-------------------------------------------------------------------+*
*
LSN07700 DS    0H
         XC    DSNPLIST,DSNPLIST   Clear the Call Parameter List
         CALL  LENV0000,           Perform Environmental Report ProcessX
               ((RCOMM2),          ..Pass Common Constants&Routines    X
               (RCOMM1),           ..Pass Common Area Address          X
               (R8)),              ..Pass LGRWK2II Area Address        X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DSNPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Environmental Rprt
         LTGFR R15,R15             Environmental Report Successful?
         BRZ   LSN07800            Yes => Branch to Process Environment
         LGHI  R2,((LSN07900-LSN07800)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LSN07800            No  => Branch to Process Environment
         BRU   LSN09000            Yes => Branch to Exit This Routine
LSN07800 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LSN07900            Environmental Report Has Completed
         BRU   LSN07900            Branch on Warning-Ignore & Continue
         BRU   LSN09000            Branch on Validation Error - Exit
         BRU   LSN09000            Branch on Severe Error - Exit
LSN07900 DS    0H
         LA    R3,LAXREPRT         Get Addr to Environmental Reprt Area
         LLGTR R3,R3               Ensure Reprt Area Pntr has Good Addr
         LLILL R4,(L'LGWLINE)      Leng of Each Rcrd Line in Reprt Area
         LLGF  R5,=A((LGREPRT#*L'LGWLINE)-L'LGWLINE)  Limit on Entries
         LA    R5,0(R3,R5)         Point to Next to Last Entry in Area
LSN08000 DS    0H
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,(R3)        Print Environmental Info Report Line
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
LSN08100 DS    0H
         BRXLG R3,R4,LSN08000      Loop to Process Next Info Area Line
*
*+-------------------------------------------------------------------+*
*|  Close the //LGRSYSIN Input Data Set                              |*
*+-------------------------------------------------------------------+*
*
LSN09000 DS    0H
         MVC   DSNCLOSL,MODLCLOS   Build the Close Parameter List
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         CLOSE (DSNSYSI@),         Perform Close Process for //LGRSYSINX
               MF=(E,DSNCLOSL),    Execute Form of Close for //LGRSYSINX
               MODE=31             Indicate 31-bit Mode for //LGRSYSIN
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         CLI   DSNINPUT,C'Y'       Any Non-Comment Cards From Input?
         BRNE  LSN09200            No  => Logevent Control Cards Absent
*
*+-------------------------------------------------------------------+*
*| Initialize the Logger Carry-Over Storage Section in Caller's LCA  |*
*+-------------------------------------------------------------------+*
*  Indicate that logger processing should be performed for all log    *
*  events indentified in the control statements from //LGRSYSIN.      *
*  Carry-over storage is a section in the prefix area of the caller's *
*  Logger Control Area (LCA) that is propagated to all called programs*
*  utilizing the copybook LGCPLOGR.                                   *
***********************************************************************
*
LSN09100 DS    0H
CALLER   USING LCALSN,R2           Setup Caller's LCA Addressability
         LG    R2,LSNS64BCK-LSNSAVE(,R13)  Get the Caller's LCA Address
         MVC   CALLER.LSNLGPTP,BASSM  Enable Program Entry/Exit Logging
LSN09200 DS    0H
         BRU   LSNT$END            Branch to Exit LGMHLRCI Program
*
BASSM    BASSM R14,R15             Used To Enable Program Logging
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
         DROP  LNE                 Remove Listed Reg as Loggr Rcrd Base
*
*+-------------------------------------------------------------------+*
*|   Return to Caller (The User's Program)                           |*
*+-------------------------------------------------------------------+*
*
LSNT$END DS    0H
         SLGR  R15,R15             Indicate Successful Completion
LSNTEXIT DS    0H
         ICM   R1,B'1111',DSNAMODE Was There An Addressing Mode Change?
         BRZ   LSNTEXT1            No  => Branch to Release Storage
         EX    R1,SWTCHMOD         Restore Our Previous Addressing Mode
         XC    DSNAMODE,DSNAMODE   Clear the Addressing Mode Switch
LSNTEXT1 DS    0H
         LLGF  R0,LAXSAVEA         Get the Size of Common Storage Area
         LLGT  R1,LAXSVCOM         Get Address of Storage to be Freed
         L     R2,DSNRTCDE         Preserve the Current Return Code
       STORAGE RELEASE,            Release Storage for the Common Area X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
LSNTRTRN DS    0H
         ST    R2,LSN$RC           Set the Return Code
         LPGMEXIT RC=LSN$RC        Define Logger Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Logger Control Area - (LCA)                                    |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Logger Control Area-(LCA)
*
DSNWORKD DS    10D                 General Work Area
DSNPLIST DS    20FD                CALL Parameter List
DSNSIPOS DS    2AD                 Pointer for Secondary Index Position
DSNRTCDE DS    F                   Save Area for Return Code
DSNAMODE DS    F                   Save Area for Addressing Mode
         DS    0D                  Set for Doubleword Alignment
DSNESTAE DS    XL(COMESTAL)        Establish the ESTAEX Parm List Area
DSNPARME DS    F                   Parm Passed to the Retry Routine
         DS    0D                  Set for Doubleword Alignment
DSNWTOL  DS    XL(COM$WTOL)        WTO Macro Parameter List
DSNWTO   DS    0F                  Write to Operator Message Data Area
DSNWTOLN DS    H                   Length of Write to Operator Msg Area
DSNWTOMG DS    CL80                Write to Operator Message Area
         DS    0F
DSNOPENL DS    XL(MODLOPLN)        Open Macro Parameter List
         DS    0F
DSNCLOSL DS    XL(MODLCLLN)        Close Macro Parameter List
DSNSYSI@ DS    0D,XL(LGRSYSNL)     Sysin DCB Parameter List
DSNDCBE@ DS    0D,XL(LGRDCBEL)     Sysin DCBE Parameter List
         DS    0D                  Set for Doubleword Alignment
DSNEPAPT DS    F                   SWA Manager Locate Mode Parm List
DSNEPA   DS    XL(L'SWAEPAX)       SWA Manager External Parameter Area
DSNPARMS SWAREQ UNAUTH=YES,MF=L    SWA Request Parameter List
DSNCARD  DS    CL80                Work Space for Card Image from Input
DSNINPUT DS    C                   Y = Valid Card Image Input was Found
DSNFLAG  DS    XL1                 Flag Indicator for Type of Logging
DSNNAME  DS    0CL64               Save Area for Program/Csect Name
DSNLNAM  DS    CL32                Save Area for Program Name
DSNCNAM  DS    CL32                Save Area for Control Section Name
DSNMASK  DS    0CL64               Save Area for Wildcard Name Mask
DSNLMSK  DS    CL32                Save Area for Wildcard Name Mask
DSNCMSK  DS    CL32                Save Area for Wildcard Name Mask
DSNTYPE  DS    CL6                 Save Area for Logger Event Type
*
         LCA   DEFEND              Define End of Logger Control Area
*
***********************************************************************
*                   End of LGMHLRCI Main Program                      *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*| RRRRRRR   OOOOO  U     U TTTTTTT IIIIIII N     N EEEEEEE   SSSSS  |*
*| R      R O     O U     U    T       I    NN    N E        S     S |*
*| R      R O     O U     U    T       I    N N   N E        S       |*
*| RRRRRRR  O     O U     U    T       I    N  N  N EEEEEE    SSSSS  |*
*| R    R   O     O U     U    T       I    N   N N E              S |*
*| R     R  O     O U     U    T       I    N    NN E        S     S |*
*| R      R  OOOOO   UUUUU     T    IIIIIII N     N EEEEEEE   SSSSS  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************| L E N V 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   E n v i r o n m e n t al   P r o c e s s i n g   |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LENV0000                                           *
*                                                                     *
* FUNCTION:        Environmental Report Processing                    *
*                                                                     *
*                  This routine is responsible for processing the     *
*                  environmental report for the z/OS system. It will  *
*                  clear an output report work area, write a separator*
*                  line (blank line), and write a column ruler line   *
*                  to display the column positions for the input      *
*                  control cards in //LGRSYSIN. The control statements*
*                  from the //LGRSYSIN DD will be written to the      *
*                  environmental report with a column ruler scale to  *
*                  display the input statements and assist with       *
*                  diagnosing control statements errors. Next the     *
*                  execution environment is examined. Informational   *
*                  records describing the general z/OS environment    *
*                  will be written to the output report buffer area.  *
*                  The report records in the buffer area will be      *
*                  written to the //LGRECOUT data set when this called*
*                  subprogram LENV0000 returns to the calling main    *
*                  program LGMHLRCI.                                  *
*                                                                     *
* INPUT REGS:      R1 => Standard z/OS Parameter List                 *
*                                                                     *
*                  Parm1: Address of Common Constants & Routines Base *
*                  Parm2: Address of Common Program Work Area Base    *
*                  Parm3: Address of the LGWK2II Work Area Base       *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHLRCI - Main Control Program                    *
*                                                                     *
* CALLED PROGRAMS: IEFSSREQ - Subsystem Information Request Routine   *
*                  SYSEVENT QVS - Query Virtual Server Service        *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
LENV0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=LEN,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING LAX@PCA,RCOMM1      Common Program Area Addressability
         USING COM#B7N3,RCOMM2     Constants&Routines Addressability
         USING LGRWK2II,RLGW       Setup LGRWK2II Area Addressability
         LMG   RCOMM2,RCOMM1,0(R1) ...Load Common Area Addresses
         LG    RLGW,16(,R1)        Load Address to LGRWK2II Work Area
         XC    LENRETCD,LENRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Clear Environmental Report Work Area and Process the Report Lines |*
*+-------------------------------------------------------------------+*
*
LENV0100 DS    0H
         LA    R0,LAXREPRT         Get Starting Address to Report Area
         LLILL R1,(LGREPRT#*L'LGWLINE) Set Length of Report Build Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Using Pad Character
LENV0200 DS    0H
         MVCLE R0,R14,C' '(0)      Clear the Entire Area to Blanks
         BRO   LENV0200            Upon Interrupt Resume Where Left Off
LENV0300 DS    0H
         LA    R5,LAXREPRT         Get Starting Address to Report Area
         LA    R5,L'LGWLINE(,R5)   Print a Blank Line as Separator
         MVC   1(L'RULER#3,R5),RULER#3 Move Column Ruler to Output Line
         LA    R5,2*L'LGWLINE(,R5) Blank Line and Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*| Process the Detail Line Indicating Program Start, the Day of the  |*
*| Week, Gregorian Calendar Date, and Time of Day the User's Program |*
*| Started Execution in the Following Format:                        |*
*|                                                                   |*
*|"Program execution started on Friday 02/26/2010 at 19:07:17.601280"|*
*+-------------------------------------------------------------------+*
*| The first part of this routine takes the STCKE Format 16-Byte     |*
*| (128-Bit) TOD value, and extracts the high-order 72-bit portion   |*
*| of the TOD into a R0/R1 even-odd grande register pair using IBM   |*
*| z/Architecture 64-bit GPRs. Then the 72-bit TOD will be adjusted  |*
*| through the z/OS CVT (Communications  Vector Table) for Leap      |*
*| Seconds and the Local Time. This routine will support dates beyond|*
*| the year 2042.                                                    |*
*+-------------------------------------------------------------------+*
*
LENV0400 DS    0H
         STCKE LENWORKD            Save the Current Time Clock Value
         LMG   R0,R1,LENWORKD      Restore the Current Time Clock Value
         RLLG  R0,R0,8             Position the TOD +142yr Byte to Last
         SRDL  R0,8                Save TOD Byte to R1, Open Slot in R0
         RLLG  R1,R1,32            TOD 63-71 Bits to Bit Position 32
         SLDL  R0,8                TOD Bits 8-71 Now in R0 as 64-Bits
         SRLG  R1,R1,56 Bits       +142 Yr Byte to Build 0-71 Bit TOD
         XGR   R0,R1               Exchange Contents of TOD Registers
         XGR   R1,R0               R0 and R1 to Produce a STCKE 72-Bit
         XGR   R0,R1               Format TOD in Even/Odd Register Pair
LENV0500 DS    0H
         LLGT  R15,CVTPTR          Absolute Address of Pointer to CVT
         LLGT  R15,CVTEXT2-CVT(,R15) ..Get Address of CVT 2nd Extention
         USING CVTXTNT2,R15        Set Addressability to CVT Extention
         SL    R1,CVTLSOL          Adjust the Low Word for Leap Seconds
         BRC   NOBORROW,LENV0600   Then Branch If There is No Borrow
         LLIHL R14,1               Otherwise, Set to Indicate a Borrow
         SLGR  R1,R14              And Then Subtract for CVT High Word
         BRC   NOBORROW,LENV0600   Then Branch If There is No Borrow
         SLGF  R0,=A(1)            Othewise, Then Borrow From High Word
LENV0600 DS    0H
         LMD   R14,R14,CVTLSOH,CVT$ZTOK  Get CVT Hi Word Offset for TOD
         SLGR  R1,R14              Adjust CVT High Wrd for Leap Seconds
         AL    R1,CVTLDTOR         Adjust Low Word For Time Zone Diff
         BRC   NOCARRY,LENV0700    And Branch If There Is No Carry
         LLIHL R14,1               Otherwise, Set to Indicate a Carry
         ALGR  R1,R14              And Then Add From the CVT High Word
         BRC   NOCARRY,LENV0700    And Branch If There Is No New Carry
         AL    R0,=A(1)            Propogate Carry to the TOD High Byte
LENV0700 DS    0H
         LMD   R14,R14,CVTLDTOL,CVT$ZTOK  Get High Word Time Zone Value
         ALGR  R1,R14              Now Adjust for High Word Time Zone
         DROP  R15                 Remove Listed Reg as CVT Ext Base
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Take the CVT Corrected 72-Bit Binary|*
*| Time Stamp, and Convert the Binary Seconds Portion of the TOD to a|*
*| Displayable Military Time Clock Format Indicating the Hours, the  |*
*| Minutes, and the Seconds in the Day.                              |*
*+-------------------------------------------------------------------+*
*
LENV0800 DS    0H
         SRDL  R0,8 Bits           Drop Last Byte,Put +142Yr Byte in R1
         RLL   R1,R1,8 Bits        +142Yr Byte at End of Low-Half of R1
         RLLG  R1,R1,56 Bits       Rotate to Get Back to Proper Format
         SRLG  R1,R1,17 Bits       Set Microseconds/2**13 (Since 1900)
         DLG   R0,=AD((60*60*24/128)*(1000000/64)) R1=Days R0=Microsecs
         LGR   R15,R1              Preserve the Calculated Elapsed Days
         SRDL  R0,32 Bits          Shift So R0/R1 = Microseconds/2**13
         SLLG  R1,R1,13 Bits       Shift So R0/R1 = Microseconds/2**1
         LLGF  R14,=A(60*60)       Indicate No. of Seconds in an Hour
         MSGF  R14,=A(1000000)     To Obtain Microseconds in an Hour
         SLGR  R0,R0               Clear for the Division Operation
         DLGR  R0,R14              Calculate Total Number of Hours
         CVD   R1,LENWORKD+8       Create Decimal Version No. of Hours
         MVO   LENWORKD+4(2),LENWORKD+14(2) Get Hrs Without High Nibble
         SRDL  R0,32 bits          Prepare for Division to Get Minutes
         D     R0,=A(60*1000000)   Calculate Total Number of Minutes
         CVD   R1,LENWORKD+8       Create Decimal Version No. of Mins
         MVO   LENWORKD+5(2),LENWORKD+14(2) Get Mins Without Hi Nibble
         SRDA  R0,32 bits          Prepare for Division to Get Seconds
         D     R0,=A(1000000)      Calculate the Total No. of Seconds
         CVD   R1,LENWORKD+8       Create Decimal Version No. of Secnds
         MVO   LENWORKD+6(2),LENWORKD+14(2) Get Secnd Without Hi Nibble
         CVD   R0,LENWORKD+8       Decimal Version for Microseconds
         SRP   LENWORKD+12(4),1,0  Shift to Make Last Byte a Slack Byte
         MVC   LENWORKD+7(4),LENWORKD+12 ..Get Fractional Seconds Value
         OI    LENWORKD+10,15      Certify Sign To Make It Displayable
         UNPK  LENWORKD+28(13),LENWORKD+4(7) ..TOD to Character Format
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Take the CVT Corrected 72-Bit Binary|*
*| Time Stamp, and Convert the Elasped Days Portion of the TOD to a  |*
*| Displayable Gregorian Calendar Date Format.                       |*
*+-------------------------------------------------------------------+*
*
LENV0900 DS    0H
         LGR   R1,R15              Get the Total Number of Elapsed Days
         ALGF  R1,=A(1)            Calendars Start At Day 1, Not Day 0
         SLLG  R1,R1,2 Bits        Multiple Total Days by Factor of 4
         DSGF  R0,=A(4*365+1)      Divide by the No. of Days in 4 Years
         SRLG  R0,R0,2 Bits        Divide By 4 So Now R1=Year R0=Days
         ALGF  R0,=A(1)            Add 1 Since First Day Starts at 1
         LA    R1,1900(,R1)        Epoch + No. of Years into Century
         ST    R1,LEN$YEAR         Save for Processing Day of the Week
         CVD   R1,LENWORKD+16      Set Binary Calendar Year to Decimal
         MVO   LENWORKD+16(3),LENWORKD+21(3) Align to Work with Digits
         LGR   R14,R0              Establish Binary Form of Julian Day
         SLGR  R15,R15             Clear for Use as a Working Register
         LA    R4,DATETBLE         Get Addr of Table for Days in Month
         LLGTR R4,R4               Ensure Table Pntr Reg has Good Addr
LENV1000 DS    0H
         AH    R15,0(,R4)          Add in the Current Days in a Month
         CLC   DATFEB28,0(R4)      Is the Indicated Month for February?
         BRNE  LENV1200            No  => Branch to Process Next Month
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(400)          Calendar Moves in 400 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRZ   LENV1100            Yes  => Then Add a Day for Leap Year
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(100)          No Leap Years in 100 Year Cycles
         LTGR  R2,R2               Year From Calendar a Century Year?
         BRZ   LENV1200            Yes  => Not Leap Year, Process Date
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(4)            Calendar Moves in 4 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRNZ  LENV1200            No   => Branch to Process Next Month
LENV1100 DS    0H
         AGHI  R15,(1)             Yes => Add One for 29 Days in Month
LENV1200 DS    0H
         LA    R4,2(,R4)           Increment to Next Month in Date Tble
         CGR   R14,R15             Currently Into the Correct Month?
         BRH   LENV1000            No  => Then Check Following Month
         AGHI  R4,(-2)             Decrement to Back Up One Table Entry
         LGH   R0,0(,R4)           Get Count for No. of Days in Month
         CLC   DATFEB28,0(R4)      Is the Indicated Month for February?
         BRNE  LENV1400            No  => Branch to Process Date
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(400)          Calendar Moves in 400 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRZ   LENV1300            Yes  => Then Add a Day for Leap Year
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(100)          No Leap Years in 100 Year Cycles
         LTGR  R2,R2               Year From Calendar a Century Year?
         BRZ   LENV1400            Yes  => Not Leap Year, Process Date
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(4)            Calendar Moves in 4 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRNZ  LENV1400            No   => Branch to Process Next Month
LENV1300 DS    0H
         AGHI  R0,(1)              Yes => Add One for 29 Days in Month
LENV1400 DS    0H
         SGR   R15,R14             Calculate the Difference In Our Days
         SGR   R0,R15              From the Days in Our Current Month
         STH   R0,LEN$DAY@         Save for Processing Day of the Week
         CVD   R0,LENWORKD+8       Set Day of Month to a Decimal Format
         OI    LENWORKD+15,15      Certify Sign to Make It Printable
         UNPK  TODGRGDD,LENWORKD+8 Set Day of Month to Character Format
         LA    R14,DATETBLE-2      Establish Beginning of Date Table
         SGR   R4,R14              Get Calendar Month Offset for Event
         SRLG  R4,R4,1 Bit         Divide Month Offset by Two for Month
         STH   R4,LEN$MNTH         Save for Processing Day of the Week
         CVD   R4,LENWORKD+8       Set Month of Year to Decimal Format
         OI    LENWORKD+15,15      Certify Sign to Make It Printable
         UNPK  TODGRGMM,LENWORKD+8 Set the Month to a Character Format
         UNPK  TODGRGYY(5),LENWORKD+16(3)  Year to Character Format
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Process the Day of the Week         |*
*+-------------------------------------------------------------------+*
*
LENV1500 DS    0H
         LLGH  R1,LEN$DAY@         Get the the Days into our Month
         LLGH  R15,LEN$MNTH        Get the Month in the Year
         LLGFR R14,R15             Temporarily Hold Month of the Year
         LLGC  R15,MONTHTBL-1(R15) Obtain Month Sequence No. from Table
         ALGR  R1,R15              Apply It to The Day of the Month
         LLGF  R15,LEN$YEAR        Get the Calendar Year Value
         CGHI  R14,(2)             Have We Gone Past Month of February?
         BRH   LENV1600            Yes => Then Calculate Day of Week
         BCTGR R15,R0              Leap Day Has Not Past in Current Yr
LENV1600 DS    0H
         LLILL R0,(3)              Modulo 4 to Set Multiples of 4 to 0
         DSGF  R14,=F'100'         Calculate for Number of Centuries
         NGR   R15,R0              Century in a 400 Yr Cycle (Modulo 4)
         NGR   R0,R14              The Number of Years into 4-Yr Cycle
         SRLG  R14,R14,2 Bits      Divide by 4 to Account for Leap Yrs
         ALGR  R15,R14             Add in Accumulated Leap Year Cycles
         MGHI  R15,(5)             Equalization for Leap Yr Days Mod 4
         ALGR  R1,R15              Add In the Leap Year Days
         ALGR  R1,R0               Progression of Day Thru Common Years
         DSGF  R0,=A(DAYSINWK)     Divide by Seven Days in a Week
         MGHI  R0,(L'DAYSTABL)     Remainder is No. of Days From Sunday
         LA    R14,DAYSTABL        Get Address to Days of the Week Tble
         ALGR  R14,R0              Get Offset to Point to Day of Week
*
*+-------------------------------------------------------------------+*
*| Write the Output Report Line Showing the Day of the Week, the     |*
*| Calendar Date, and Time of Day the User's Program Started.        |*
*|                                                                   |*
*|"Program execution started on Sunday 04/15/2012 at 07:15:33.183226"|*
*+-------------------------------------------------------------------+*
*
LENV1700 DS    0H
         MVC   1(L'LGENVIRN,R5),LGENVIRN  Copy the Detail Line Header
         LLGH  R1,0(,R14)          Get Length of Our Day of the Week
         LA    R15,L'LGENVIRN+1(,R5) Increment Past Detail Line Header
         MVC   0(*-*,R15),2(R14)   Indicated Target of the Execute
         EX    R1,*-6              Copy the Day of Week to Output Area
         LA    R15,1(R15,R1)       Point Past the End of Day of Week
         MVC   0(L'TODGRGMM,R15),TODGRGMM Indicate Month in the Year
         LA    R15,L'TODGRGMM(,R15) Increment Past the Month
         MVI   0(R15),C'/'         Insert the Day and Month Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(L'TODGRGDD,R15),TODGRGDD Indicate the Day in the Month
         LA    R15,L'TODGRGDD(,R15) Increment Past the Day of the Month
         MVI   0(R15),C'/'         Insert the Month and Year Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(L'TODGRGYY,R15),TODGRGYY Indicate 4-Digit Calendar Yr
         LA    R15,L'TODGRGYY+1(,R15) Increment Past the Calendar Year
         MVC   0(2,R15),=CL2'at'   Set Indicator for the Time of Day
         LA    R15,3(,R15)         Increment Past Indicator for Time
         MVC   0(2,R15),LENWORKD+28 Indicate the Hour of the Day
         LA    R15,2(,R15)         Increment to End of the Hour of Day
         MVI   0(R15),C':'         Insert Hours and Minutes Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(2,R15),LENWORKD+30 Indicate Our Minutes into the Hour
         LA    R15,2(,R15)         Increment to End of Minutes in Hour
         MVI   0(R15),C':'         Insert Minutes and Seconds Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(2,R15),LENWORKD+32 Indicate Seconds into the Minute
         LA    R15,2(,R15)         Increment to End of the Seconds
         MVI   0(R15),C'.'         Insert Fractional Seconds Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(6,R15),LENWORKD+34 Indicate Fractional Part of Second
         LA    R5,2*L'LGWLINE(,R5) Blank Line and Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*| Get the System Name Established for Operating Environment         |*
*|                                                                   |*
*| System Name.................: SYSA                                |*
*+-------------------------------------------------------------------+*
*
         USING CVT,R1              Establish Addressability to CVT
LENV1800 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         MVC   3(L'LGSYSNME,R5),LGSYSNME  Copy the Detail Line Header
         MVC   L'LGSYSNME+4(L'CVTSNAME,R5),CVTSNAME Get MVS System Name
         DROP  R1                  Remove Listed Reg as CVT Base Reg
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*| Get the SysPlex Name Established for Operating Environment        |*
*|                                                                   |*
*| Sysplex Name................: PLEX01                              |*
*+-------------------------------------------------------------------+*
*
LENV1900 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING ECVT,R2             Addressability to the Extended CVT
         LLGT  R2,CVTECVT-CVT(,R1) Get Address to the Extended CVT Area
         MVC   3(L'LGPLEXNM,R5),LGPLEXNM   Copy the Detail Line Header
         MVC   L'LGPLEXNM+4(L'ECVTSPLX,R5),ECVTSPLX  Get SysPlex Name
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*| Extract the Operating System and the Version/Release/Modification |*
*| Level for the Operating System Which Was Installed.               |*
*|                                                                   |*
*| Operating System............: z/OS 01.13.00 FMID(HBB7780) SP7.1.3 |*
*+-------------------------------------------------------------------+*
*
LENV2000 DS    0H
         MVC   3(L'LGOSYSTM,R5),LGOSYSTM  Copy the Detail Line Header
         LA    R1,ECVTPNAM         Get Address of CVT Prod Name Field
         LLGTR R0,R1               Hold Address of CVT Prod Name Field
         LLILL R15,(L'ECVTPNAM-1)  Length of CVT Product Name Field
         LA    R1,0(R15,R1)        Point to End of Product Name Field
         LLGT  R14,=A(1)           Check is for One Byte at a Time
         LNGFR R14,R14             To Scan Backwards Through Field
         SLGR  R15,R15             Clear For Use as a Work Register
         ICM   R15,B'0001',=C' '   The Search Is For Trailing Blanks
LENV2100 DS    0H
         BRXHG R1,R14,LENV2200     End of Product Name Going Backward
         BRU   LENV2300            Branch to Process the Version Info
LENV2200 DS    0H
         CLM   R15,B'0001',0(R1)   Is This a Blank Character?
         BRL   LENV2300            No  => Branch to Determine Length
         BRU   LENV2100            Loop to Check Next Byte in Field
LENV2300 DS    0H
         SLGR  R14,R14             Ensure No Residual in High Half
         SGR   R1,R0               Calculate Leng of CVT Product Name
         BRNP  LENV2900            Branch If Nothing Is Left
         LGR   R15,R0              Get Address of CVT Prod Name Field
         MVC   L'LGOSYSTM+4(*-*,R5),0(R15) Indicated Target of Execute
         EX    R1,*-6              Copy Prod Name from CVT to Output
LENV2400 DS    0H
         LA    R15,L'LGOSYSTM+6(R1,R5) ..Move to Next Position in Line
         MVC   0(L'ECVTPVER,R15),ECVTPVER  Get the z/OS Version Level
         MVI   L'ECVTPVER(R15),C'.'  Use Period as Seperator Character
         MVC   3(L'ECVTPREL,R15),ECVTPREL  Get the z/OS Release Level
         MVI   3+L'ECVTPREL(R15),C'.' Use Period as Seperator Character
         MVC   6(L'ECVTPMOD,R15),ECVTPMOD  Get z/OS Modification Level
         LA    R4,L'ECVTPMOD+7(,R15) Increment Line Pntr to FMID Field
LENV2500 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLILL R3,(32)             To Point Back into CVT Prefix Area
         SLGFR R1,R3               Get Address to CVT z/OS FMID Field
         MVC   0(5,R4),=CL5'FMID(' Set Function Modification Identifier
         LA    R4,5(,R4)           Increment Past the FMID Header Text
         MVC   0(8,R4),0(R1)       Obtain Current FMID of z/OS Product
         BCTGR R4,R0               Point to Last Byte in FMID Header
         LGR   R15,R4              Preserve Current Address in Prnt Lne
         LA    R4,L'LGWLINE-1(,R5) Point to End of Output Report Line
         LLILL R14,(1)             Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Line Area
         LLGC  R3,=C' '            Our Search Is For Trailing Blanks
LENV2600 DS    0H
         BRXHG R4,R14,LENV2700     Find End of FMID Info Going Backward
         BRU   LENV2800            Branch to Process Level Information
LENV2700 DS    0H
         CLM   R3,B'0001',0(R4)    Is This a Blank Character?
         BRL   LENV2800            No  => Found End Byte of FMID Info
         BRU   LENV2600            Loop to Check the Next Byte in Line
LENV2800 DS    0H
         MVI   1(R4),C')'          Set Closing Parenthesis for the FMID
         LA    R4,3(,R4)           Increment Line Pointer to Name Field
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLILL R3,(40)             To Point Back into CVT Prefix Area
         SLGFR R1,R3               Get Address to CVT z/OS Name Field
         MVC   0(8,R4),0(R1)       Get Shorthand Name of z/OS Product
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*| Get the Date and Time the z/OS System Was Last IPL'ed             |*
*+-------------------------------------------------------------------+*
*| Take the Binary Time the System was Last IPL'ed, and Convert to a |*
*| Displayable Gregorian Calendar Date and Time of Day With a Format |*
*| Day-of-Week MM/DD/YYYY HH:MM:SS.ttt. The IPL Time Used From the   |*
*| IPA is Already Adjusted for the Local Time, and is Limited To a   |*
*| STCK Format 64-Bit Binary TOD Value Which Will Only Support Dates |*
*| Up to 2042.                                                       |*
*+-------------------------------------------------------------------+*
*
LENV2900 DS    0H
         SLGR  R14,R14             Ensure No Residual in High Half
         USING IPA,R1              Set Addressability Init Parm Area
         LLGT  R1,ECVTIPA-ECVT(,R2) Addr of Initialization Parm Area
         LMD   R0,R1,IPA$ZTOK,IPAILTOD ..Binary Time System Last IPL'ed
         DROP  R1,R2               Remove Listed Regs as Base Registers
         SRDL  R0,12+13            Set Microseconds/2**13 (Since 1900)
         D     R0,=A((60*60*24/128)*(1000000/64)) R1=Days R0=Microscnds
         LLGFR R15,R1              Preserve the Calculated Elapsed Days
         SRDL  R0,32               Shift So R0/R1 = Microseconds/2**13
         LLGFR R0,R0               Ensure No Residual in High Half
         SLLG  R1,R1,13-1 Bits     Shift So R0/R1 = Microseconds/2**1
         DLG   R0,=AD(1000000/100000/2)  Hundred-Thousanths of a Second
         SLGR  R0,R0               Clear for the Division Operation
         DLG   R0,=AD(60*60*100000) Calculate the Total Number of Hours
         CVD   R1,LENWORKD+8       Create Decimal Version No. of Hours
         MVO   LENWORKD+4(2),LENWORKD+14(2) Get Hrs Without High Nibble
         SRDL  R0,32 bits          Prepare for Division to Get Minutes
         DSGF  R0,=A(60*100000)    Calculate Total Number of Minutes
         CVD   R1,LENWORKD+8       Create Decimal Version No. of Mins
         MVO   LENWORKD+5(2),LENWORKD+14(2) Get Mins Without Hi Nibble
         SRDA  R0,32 bits          Prepare for Division to Get Seconds
         DSGF  R0,=A(100000)       Calculate the Total No. of Seconds
         CVD   R1,LENWORKD+8       Create Decimal Version No. of Secnds
         MVO   LENWORKD+6(2),LENWORKD+14(2) Get Secnd Without Hi Nibble
         CVD   R0,LENWORKD+8       Decimal Version 1/1000ths of a Secnd
         SRP   LENWORKD+12(4),1,0  Shift to Make Last Byte a Slack Byte
         MVO   LENWORKD+7(4),LENWORKD+12(4)    Fractional Seconds Value
         OI    LENWORKD+9,15       Certify Sign To Make It Displayable
         UNPK  LENWORKD+28(11),LENWORKD+4(6) ..TOD to Character Format
LENV3000 DS    0H
         LGR   R1,R15              Get the Total Number of Elapsed Days
         ALGF  R1,=A(1)            Calendars Start At Day 1, Not Day 0
         SLLG  R1,R1,2 Bits        Multiple Total Days by Factor of 4
         DSGF  R0,=A(4*365+1)      Divide by the No. of Days in 4 Years
         SRLG  R0,R0,2 Bits        Divide By 4 So Now R1=Year R0=Days
         ALGF  R0,=A(1)            Add 1 Since First Day Starts at 1
         LA    R1,1900(,R1)        Epoch + No. of Years into Century
         ST    R1,LEN$YEAR         Save for Processing Day of the Week
         CVD   R1,LENWORKD+16      Set Binary Calendar Year to Decimal
         MVO   LENWORKD+16(3),LENWORKD+21(3) Align to Work with Digits
         LGR   R14,R0              Establish Binary Form of Julian Day
         SLGR  R15,R15             Clear for Use as a Working Register
         LA    R4,DATETBLE         Get Addr of Table for Days in Month
         LLGTR R4,R4               Ensure Table Reg Pntr has Good Addr
LENV3100 DS    0H
         AH    R15,0(,R4)          Add in the Current Days in a Month
         CLC   DATFEB28,0(R4)      Is the Indicated Month for February?
         BRNE  LENV3300            No  => Branch to Process Next Month
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(400)          Calendar Moves in 400 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRZ   LENV3200            Yes  => Then Add a Day for Leap Year
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(100)          No Leap Years in 100 Year Cycles
         LTGR  R2,R2               Year From Calendar a Century Year?
         BRZ   LENV3300            Yes  => Not Leap Year, Process Date
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(4)            Calendar Also Moves in 4 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRNZ  LENV3300            No   => Branch to Process Next Month
LENV3200 DS    0H
         AGHI  R15,(1)             Yes => Add One for 29 Days in Month
LENV3300 DS    0H
         LA    R4,2(,R4)           Increment to Next Month in Date Tble
         CGR   R14,R15             Currently Into the Correct Month?
         BRH   LENV3100            No  => Then Check Following Month
         AGHI  R4,(-2)             Decrement to Back Up One Table Entry
         LGH   R0,0(,R4)           Get Count for No. of Days in Month
         CLC   DATFEB28,0(R4)      Is the Indicated Month for February?
         BRNE  LENV3500            No  => Branch to Process Date
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(400)          Calendar Moves in 400 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRZ   LENV3400            Yes  => Then Add a Day for Leap Year
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(100)          No Leap Years in 100 Year Cycles
         LTGR  R2,R2               Year From Calendar a Century Year?
         BRZ   LENV3500            Yes  => Not Leap Year, Process Date
         LLGF  R3,LEN$YEAR         Binary Calendar Year for Calculation
         DSGF  R2,=A(4)            Calendar Also Moves in 4 Year Cycles
         LTGR  R2,R2               Is Year From Calendar a Leap Year?
         BRNZ  LENV3500            No   => Branch to Process Next Month
LENV3400 DS    0H
         AGHI  R0,(1)              Yes => Add One for 29 Days in Month
LENV3500 DS    0H
         SGR   R15,R14             Calculate the Difference In Our Days
         SGR   R0,R15              From the Days in Our Current Month
         STH   R0,LEN$DAY@         Save for Processing Day of the Week
         CVD   R0,LENWORKD+8       Set Day of Month to a Decimal Format
         OI    LENWORKD+15,15      Certify Sign to Make It Printable
         UNPK  TODGRGDD,LENWORKD+8 Set Day of Month to Character Format
         LA    R14,DATETBLE-2      Establish Beginning of Date Table
         SGR   R4,R14              Get Calendar Month Offset for Event
         SRLG  R4,R4,1 Bit         Divide Month Offset by Two for Month
         STH   R4,LEN$MNTH         Save for Processing Day of the Week
         CVD   R4,LENWORKD+8       Set Month of Year to Decimal Format
         OI    LENWORKD+15,15      Certify Sign to Make It Printable
         UNPK  TODGRGMM,LENWORKD+8 Set the Month to a Character Format
         UNPK  TODGRGYY(5),LENWORKD+16(3)  Year to Character Format
*
*+-------------------------------------------------------------------+*
*| Process the Day of the Week in Which System Was IPL'ed            |*
*+-------------------------------------------------------------------+*
*
LENV3600 DS    0H
         LLGH  R1,LEN$DAY@         Get the the Days into our Month
         LLGH  R15,LEN$MNTH        Get the Month in the Year
         LLGFR R14,R15             Temporarily Hold Month of the Year
         LLGC  R15,MONTHTBL-1(R15) Obtain Month Sequence No. from Table
         ALGR  R1,R15              Apply It to The Day of the Month
         LLGF  R15,LEN$YEAR        Get the Calendar Year Value
         CGHI  R14,(2)             Have We Gone Past Month of February?
         BRH   LENV3700            Yes => Then Calculate Day of Week
         BCTGR R15,R0              Leap Day Has Not Past in Current Yr
LENV3700 DS    0H
         LLILL R0,(3)              Modulo 4 to Set Multiples of 4 to 0
         DSGF  R14,=F'100'         Calculate for Number of Centuries
         NGR   R15,R0              Century in a 400 Yr Cycle (Modulo 4)
         NGR   R0,R14              The Number of Years into 4-Yr Cycle
         SRLG  R14,R14,2 Bits      Divide by 4 to Account for Leap Yrs
         ALGR  R15,R14             Add in Accumulated Leap Year Cycles
         MGHI  R15,(5)             Equalization for Leap Yr Days Mod 4
         ALGR  R1,R15              Add In the Leap Year Days
         ALGR  R1,R0               Progression of Day Thru Common Years
         DSGF  R0,=A(DAYSINWK)     Divide by Seven Days in a Week
         MGHI  R0,(L'DAYSTABL)     Remainder is No. of Days From Sunday
         LA    R14,DAYSTABL        Get Address to Days of the Week Tble
         ALGR  R14,R0              Get Offset to Point to Day of Week
*
*+-------------------------------------------------------------------+*
*| Format and Write the Output Line for the System IPL Information   |*
*|                                                                   |*
*| System was last IPL'ed on...: Sunday 04/15/2012 at 06:26:15.342   |*
*+-------------------------------------------------------------------+*
*
LENV3800 DS    0H
         MVC   3(L'LGSYSIPL,R5),LGSYSIPL  Copy the Detail Line Header
         LLGH  R1,0(,R14)          Get Length of Our Day of the Week
         LA    R15,L'LGSYSIPL+4(,R5)  Set Pointer in Output Report Line
         MVC   0(*-*,R15),2(R14)   Indicated Target of the Execute
         EX    R1,*-6              Copy the Day of Week to Output Area
         LA    R15,1(R15,R1)       Point Past the End of Day of Week
         MVC   0(L'TODGRGMM,R15),TODGRGMM Indicate Month in the Year
         LA    R15,L'TODGRGMM(,R15) Increment Past the Month
         MVI   0(R15),C'/'         Insert the Day and Month Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(L'TODGRGDD,R15),TODGRGDD Indicate the Day in the Month
         LA    R15,L'TODGRGDD(,R15) Increment Past the Day of the Month
         MVI   0(R15),C'/'         Insert the Month and Year Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(L'TODGRGYY,R15),TODGRGYY Indicate 4-Digit Calendar Yr
         LA    R15,L'TODGRGYY+1(,R15) Increment Past the Calendar Year
         MVC   0(2,R15),=CL2'at'   Set Indicator for the Time of Day
         LA    R15,3(,R15)         Increment Past Indicator for Time
         MVC   0(2,R15),LENWORKD+28 Indicate the Hour of the Day
         LA    R15,2(,R15)         Increment to End of the Hour of Day
         MVI   0(R15),C':'         Insert Hours and Minutes Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(2,R15),LENWORKD+30 Indicate Our Minutes into the Hour
         LA    R15,2(,R15)         Increment to End of Minutes in Hour
         MVI   0(R15),C':'         Insert Minutes and Seconds Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(2,R15),LENWORKD+32 Indicate Seconds into the Minute
         LA    R15,2(,R15)         Increment to End of the Seconds
         MVI   0(R15),C'.'         Insert Fractional Seconds Separator
         LA    R15,1(,R15)         Increment Past Separator Character
         MVC   0(3,R15),LENWORKD+34 Indicate Fractional Part of Second
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the Local Time Zone Offset for Our System                    |*
*|                                                                   |*
*|  Local Time Offset from UTC..: -8 Hours 00 Minutes (GMT West)     |*
*+-------------------------------------------------------------------+*
*
LENV3900 DS    0H
         LLGT  R15,CVTPTR          Absolute Address of Pointer to CVT
         LLGT  R15,CVTEXT2-CVT(,R15)  Get Address of CVT 2nd Extention
         USING CVTXTNT2,R15        Set Addressability to CVT Extention
         ZAP   LENWORKD,=PL1'0'    Init Area to No Time Zone Offset
         LLGF  R1,CVTLDTO          Get the Value of Time Zone Offset
         LTGR  R1,R1               Is There a Local Date/Time Offset?
         BRZ   LENV4600            No  => Then Time Zone Offset is +0
         LA    R14,LENV4500        Get a Retry Recovery Address (ESTAE)
         ST    R14,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         CVD   R1,LENWORKD         Set Binary Offset Value to Decimal
         MP    LENWORKD,=PL4'1048576' Adjust for Units Set at 1.048576
         DP    LENWORKD,=PL4'1000000' Digits to Right of Decimal Point
         ZAP   LENWORKD+L'LENWORKD,LENWORKD(4) No. of Sec to Work Area
         DP    LENWORKD+L'LENWORKD,HOURSECS ..Divide by Seconds in Hour
         ZAP   LENWORKD,LENWORKD+L'LENWORKD(L'LENWORKD-L'HOURSECS)
         ZAP   LENWORKD+L'LENWORKD,LENWORKD+L'LENWORKD+(L'LENWORKD-L'HOX
               URSECS)(L'HOURSECS) ..Get the Remainder from Time Offset
         DP    LENWORKD+L'LENWORKD,MINSECDS  Divide by Seconds in a Min
         DROP  R15                 Remove Reg as CVT Extension Base Reg
LENV4000 DS    0H
         LA    R1,LENFORC3         Preload 1st Forced Result Location
         MVC   LENLOCTM,PATTERN3   Copy in the Number Editing Pattern
         EDMK  LENLOCTM,LENWORKD+4 Edit Time Zone Offset to Character
         BRNM  LENV4100            Branch if GMT East (Result Positive)
         BCTGR R1,R0               Set Pntr in Front of First Character
         MVI   0(R1),C'-'          Indicate Local Time is for GMT West
         MVC   LENGMTTZ,=CL10'(GMT West)' Set Time Zone for GMT West
         BRU   LENV4200            Branch to Process Local Time Offset
LENV4100 DS    0H
         BCTGR R1,R0               Set Pntr in Front of First Character
         MVI   0(R1),C'+'          Indicate Local Time is for GMT East
         MVC   LENGMTTZ,=CL10'(GMT East)' Set Time Zone for GMT East
LENV4200 DS    0H
         LA    R15,LENLOCTM+L'LENLOCTM-1 ..Point to Last Byte in Field
         SGR   R15,R1              Calculate the Length of Offset Value
         MVC   3(L'LGLOCLTM,R5),LGLOCLTM  Copy the Detail Line Header
         MVC   L'LGLOCLTM+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy Local Hour Offset to Outpt Area
         LA    R14,L'LGLOCLTM+4+2(R15,R5) ..Point Past the Hours Offset
         CLI   1(R1),C'1'          Is Offset for a Single Hour Only?
         BRNE  LENV4300            No  => Branch to Set Scale as Hours
         MVC   0(4,R14),=CL4'Hour' Indicate the Offset in Singular Form
         LA    R14,5(,R14)         Increment to Process Offset Minutes
         BRU   LENV4400            Branch to Write Local Time Offset
LENV4300 DS    0H
         MVC   0(5,R14),=CL5'Hours' Indicate the Offset in Plural Form
         LA    R14,6(,R14)         Increment to Process Offset Minutes
LENV4400 DS    0H
         ZAP   LENWORKD,LENWORKD+L'LENWORKD(L'LENWORKD-L'MINSECDS)
         LA    R1,LENFORC4         Preload 1st Forced Result Location
         MVC   LENLOCTM,PATTERN4   Copy in the Number Editing Pattern
         EDMK  LENLOCTM,LENWORKD+4 Edit Time Zone Offset to Character
         LA    R15,LENLOCTM+L'LENLOCTM-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   0(*-*,R14),0(R1)    Indicated Target of Execute
         EX    R15,*-6             Copy Local Minutes Offset to Output
         LA    R14,2(R15,R14)      Increment Past the Minutes Offset
         MVC   0(7,R14),=CL7'Minutes' Set the Descriptor for Minutes
         LA    R14,8(,R14)         Increment Past Minutes Descriptor
         MVC   0(L'LENGMTTZ,R14),LENGMTTZ Indicate if GMT East or West
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
LENV4500 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         NI    LGWFLAG,255-LGWSDUMP  Disable Dump Suppression Indicator
*
*+-------------------------------------------------------------------+*
*|  Get the Data Facilities Product Name and Version for Our System  |*
*|                                                                   |*
*|  Data Facility Product.......: z/OS DFSMS V01R13M00               |*
*+-------------------------------------------------------------------+*
*
LENV4600 DS    0H
         MVC   3(L'LGDFPROD,R5),LGDFPROD  Copy the Detail Line Header
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING DFA,R2              Establish Addressability to the DFA
         LLGT  R2,CVTDFA           Addr Data Facilities Product Id Tble
         CLI   DFAPROD,X'00'       Running DFSMS/MVS as a Product?
         BRE   LENV4900            No  => Branch to Process Job Entry
         CLI   DFAPROD,X'03'       This DFSMS for z/OS V1R3 or Higher?
         BRNE  LENV4900            No  => Branch to Process Job Entry
         USING DFAELNM,R1          Addressability to DFA Element Name
         LLGT  R1,DFAELNMP         Addr of DFA Element Name Structure
         LGH   R15,DFAELNML        Get Length of the DFA Element Name
         MVC   L'LGDFPROD+4(*-*,R5),DFAELTXT Indicate Target of Execute
         EX    R15,*-6             Element Name from DFA to Output Line
         LLGC  R14,DFAVER          Get Data Facilities Product Version
         CVD   R14,LENWORKD+16     Decimal Format of Product Version#
         MVO   LENWORKD+12(2),LENWORKD+22(2) ..Version No. without Sign
         LLGC  R14,DFARLSE         Get Data Facilities Product Release
         CVD   R14,LENWORKD+16     Decimal Format of Product Release#
         MVO   LENWORKD+13(2),LENWORKD+22(2) Rlse No. Without Sign Bits
         LLGC  R14,DFAMOD          Get Data Facilities Product Mod Lvl
         CVD   R14,LENWORKD+16     Decimal Format of Product Release#
         MVO   LENWORKD+14(2),LENWORKD+22(2) Mod Levl without Sign Bits
         SRP   LENWORKD+20(4),1,0  Shift to Make Last Byte a Slack Byte
         UNPK  LENWORKD(7),LENWORKD+12(4)  Version, Rlse, and Mod Level
         DROP  R1,R2               Remove Listed Regs as Base Registers
         LA    R0,L'LGDFPROD+4(,R5) Increment Past Header to Field Area
         LA    R1,L'LGDFPROD+4(R15,R5) Point to End of DFA Element Name
LENV4700 DS    0H
         CLI   R1,C' '             Is this a Blank Character?
         BRNE  LENV4800            No  => Found Last Character in Name
         BCTGR R1,R0               Search Backwards for Trailing Blanks
         CR    R0,R1               Reached Starting Address of Field
         BRH   LENV4900            Yes => No DFA Product Name Available
         BRU   LENV4700            No  => Loop to Process Next Byte
LENV4800 DS    0H
         LA    R1,1(,R1)           Move Forward in Our Record Line
         MVI   0(R1),C'V'          Insert the Product Version Indicator
         MVC   1(2,R1),LENWORKD    Get the Product Version Number
         MVI   3(R1),C'R'          Insert the Product Release Indicator
         MVC   4(2,R1),LENWORKD+2  Get the Product Release Number
         MVI   6(R1),C'M'          Insert Modification Level Indicator
         MVC   7(2,R1),LENWORKD+4  Get the Product Modification Level
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*| Get the Job Entry Subsystem Name and Version Information by       |*
*| performing a Request Subsystem Version Information Call (SSI      |*
*| function code 54).                                                |*
*|                                                                   |*
*| Job Entry Subsystem.........: JES2 Version(z/OS1.13) FMID(HJE7780)|*
*+-------------------------------------------------------------------+*
*
LENV4900 DS    0H
         MVC   3(L'LGJESSYS,R5),LGJESSYS  Copy the Detail Line Header
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING JESCT,R4            Establish Addressability to JESCT
         LLGT  R4,CVTJESCT         Get Addr of JES2 Communications Tble
         DROP  R1                  Remove Listed Reg as CVT Base Reg
         LA    R2,LENSSOB@         Get Addr of Subsystem Optn Blk Area
         LLGTR R2,R2               Ensure We Have a Clean Address
         USING SSOB,R2             Establish Addressability to SSOB
         ST    R2,LENSSPNT         Pointer to SSOB is 1-Word Parm List
         OI    LENSSPNT,X'80'      Parm List Addr has High Order Bit On
         MVC   SSOBLEN,=Y(SSOBHSIZ) .Set Length of the SSOB Control Blk
         LLILL R1,(SSOBSSVI)       Get the System Version Function ID
         STH   R1,SSOBFUNC         Set SSI 54 Function for Version Info
         MVC   SSOBID,=C'SSOB'     Set the SSOB Identifier in Cntl Blk
         LA    R3,SSOB+SSOBHSIZ    Provide a Subsystem Interface Block
         ST    R3,SSOBSSIB         Put the SSIB Address into the SSOB
         USING SSIB,R3             Establish Addressability to the SSIB
         MVC   SSIBID,=C'SSIB'     Set SSIB Indentifier in Control Blk
         MVC   SSIBLEN,=Y(SSIBSIZE) Set the Length of the SSIB Cntl Blk
         MVC   SSIBSSNM,JESPJESN   Name of Subsystem for This Request
         MVC   L'LGJESSYS+4(L'JESPJESN,R5),JESPJESN Get JES Subsys Name
         LA    R3,SSIB+SSIBSIZE    Get Addr of Function Dependent Area
         ST    R3,SSOBINDV         Put Addr of SSVI Area into the SSOB
         USING SSVI,R3             Establish Addressability to the SSVI
         LLILL R1,(L'LENSSOB@)     Leng of Area to Hold Requested Info
         STH   R1,SSVILEN          Put the Length Value into the SSVI
         MVI   SSVIVER,SSVICVER    Set Version Mapping of SSVI Cntl Blk
         MVC   SSVIID,=C'SSVI'     Set SSVI Indentifier in Control Blk
         LLILL R1,(SSVIFSIZ)       Get Len of SSVI Fixed Header Section
         STH   R1,SSVIFLEN         Set the Length of the Fixed Section
         LA    R1,LENV5800         Get a Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         LA    R1,LENSSPNT         Get the Pointer to the SSOB Address
         SAM31                     Switch Now to 31-Bit Addressing Mode
         IEFSSREQ                  Request for Subsystem Version Info
         SAM64                     Switch Back to 64-Bit Address Mode
         LTGFR R15,R15             Was Version Info Request Successful?
         BRNZ  LENV5800            No  => Then Do Not Process Version
         DROP  R2,R4               Remove Listed Registers as Base Regs
LENV5000 DS    0H
         MVC   L'LGJESSYS+9(8,R5),=CL8'Version(' ...Set Version Header
         MVC   L'LGJESSYS+17(L'SSVIVERS,R5),SSVIVERS Version of Product
         LA    R4,L'LGJESSYS+16(,R5) Set Current Pointer in Report Line
         LGR   R15,R4              Preserve Current Pointer in Prnt Lne
         LA    R4,L'LGWLINE-1(,R5) Point to End of Current Report Line
         LLILL R14,(1)             Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Line Area
         LLGC  R2,=C' '            Search Is For Trailing Blanks
LENV5100 DS    0H
         BRXHG R4,R14,LENV5200     Find End of Version Going Backward
         BRU   LENV5300            Branch to Process FMID Information
LENV5200 DS    0H
         CLM   R2,B'0001',0(R4)    Is This a Blank Character?
         BRL   LENV5300            No  => Found End Byte of Version Inf
         BRU   LENV5100            Loop to Check the Next Byte in Line
LENV5300 DS    0H
         MVI   1(R4),C')'          Set Closing Parenthesis for Version
         LA    R4,3(,R4)           Increment Line Pointer to FMID Field
         MVC   0(5,R4),=CL5'FMID(' Set Function Modification Identifier
         LA    R4,5(,R4)           Increment Past the FMID Header Text
         MVC   0(L'SSVIFMID,R4),SSVIFMID Obtain Current FMID of Product
         BCTGR R4,R0               Point to Last Byte in FMID Header
         LGR   R15,R4              Preserve Current Address in Prnt Lne
         LA    R4,L'LGWLINE-1(,R5) Point to End of Current Report Line
         LLILL R14,(1)             Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Line Area
         LLGC  R2,=C' '            Our Search Is For Trailing Blanks
LENV5400 DS    0H
         BRXHG R4,R14,LENV5500     Find End of FMID Info Going Backward
         BRU   LENV5600            Branch to Process Level Information
LENV5500 DS    0H
         CLM   R2,B'0001',0(R4)    Is This a Blank Character?
         BRL   LENV5600            No  => Found End Byte of FMID Info
         BRU   LENV5400            Loop to Check the Next Byte in Line
LENV5600 DS    0H
         MVI   1(R4),C')'          Set Closing Parenthesis for the FMID
         LA    R4,3(R4)            Increment Line Pointer to Levl Field
         LLGC  R2,SSVIPLVL         Get Current Program Product Level
         LTGR  R2,R2               Is There an Available Product Level?
         BRZ   LENV5800            No  =>  Then No Further Processing
LENV5700 DS    0H
         CVDG  R2,LENSTORD         Binary Product Levl Value to Decimal
         MVC   LENSTORC,PATTERN2   Copy in the Number Editing Pattern
         LA    R1,LENFORC2         Load 1st Forced Result Char Location
         EDMK  LENSTORC,LENSTORD+8 Edit Product Levl Value to Character
         BRZ   LENV5800            Branch if Source of Value is Zeros
         LA    R15,LENSTORC+L'LENSTORC-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of our Product Levl
         MVC   0(4,R4),=CL4'Lvl('  Set the Program Product Level Header
         LA    R4,4(R4)            Increment Past the Level Header Text
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy Product Level to Output Area
         LA    R1,1(R15,R4)        Point to End of Product Level
         MVI   0(R1),C'.'          Insert Product/Service Separator
         LA    R1,1(,R1)           Increment to Service Level Field
         LLGC  R2,SSVISLVL         Get the Current Service Level
         CVDG  R2,LENSTORD         Binary Service Levl Value to Decimal
         OI    LENSTORD+L'LENSTORD-1,15 Certify Sign to Make Printable
         UNPK  LENWORKD(3),LENSTORD+14(2) Service Level to Zoned Format
         MVC   0(2,R1),LENWORKD+1  Copy Service Level to Output Area
         MVI   2(R1),C')'          Set the Closing Parenthesis
LENV5800 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         NI    LGWFLAG,255-LGWSDUMP  Disable Dump Suppression Indicator
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         DROP  R3                  Remove Listed Reg as SSVI Base Reg
*
*+-------------------------------------------------------------------+*
*| Get Basic Hardware Configuration Information for our System       |*
*|                                                                   |*
*| CPU Model...................: 2084 Type(C24)  Processors=10  MIPS=|*
*+-------------------------------------------------------------------+*
*
LENV5900 DS    0H
         BRAS  R14,LHDW1000        Process Basic Hardware Config Info
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the Job Type for Our User Program                            |*
*|                                                                   |*
*|  Job Type....................: Batch                              |*
*+-------------------------------------------------------------------+*
*
         USING PSA,R0              Establish Addressability to the PSA
LENV6000 DS    0H
         LLGT  R2,PSAAOLD          Get Address Space Cntrl Blk Old Pntr
         USING ASCB,R2             Establish Addressability to the ASCB
         MVC   LEN$ASID,ASCBASID   Get the Address Space Identifier
         ICM   R1,B'1111',ASCBTSB  Pointer to TSO Terminal Status Blk?
         BRZ   LENV6100            No  => Branch if Caller Not TSO User
         MVC   LENJTYPE,=CL12'TSO' Indicate Job Type is for a TSO User
         ICM   R1,B'1111',ASCBJBNS Pntr to START/MOUNT/LOGON Job Name?
         BRZ   LENV6300            No  => Branch to Write Job Type
         MVC   LENJBNME,0(R1)      Yes => Then Get the Job Name
         BRU   LENV6300            Branch to Write Job Type Executing
LENV6100 DS    0H
         ICM   R1,B'1111',ASCBJBNI Pointer to Initiated Program Field?
         BRZ   LENV6200            No  => Caller Is Not a Batch Job
         MVC   LENJTYPE,=CL12'Batch' ...Indicate Job Type is for Batch
         MVC   LENJBNME,0(R1)      Get the Name of Job Being Executed
         BRU   LENV6300            Branch to Write Job Type Executing
LENV6200 DS    0H
         MVC   LENJTYPE,=CL12'Started Task' Indicate Job Typ Executing
         ICM   R1,B'1111',ASCBJBNS Pntr to START/MOUNT/LOGON Job Name?
         BRZ   LENV6300            No  => Then Job Name Not Available
         MVC   LENJBNME,0(R1)      Get the Name of Job Being Executed
LENV6300 DS    0H
         MVC   3(L'LGJOBTYP,R5),LGJOBTYP  Copy the Detail Line Header
         MVC   L'LGJOBTYP+4(12,R5),LENJTYPE ...Get the Job Type
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         DROP  R2                  Remove Listed Reg as ASCB Base Reg
*
*+-------------------------------------------------------------------+*
*|  Get the Job Name of Our User Program                             |*
*|                                                                   |*
*|  Job Name....................: USERJOB2                           |*
*+-------------------------------------------------------------------+*
*
LENV6400 DS    0H
         MVC   3(L'LGJOBNME,R5),LGJOBNME  Copy the Detail Line Header
         OC    LENJBNME,LENJBNME   Is the Job Name Entry Area Nulls?
         BRZ   LENV6500            Yes => Branch to Process a Default
         BRU   LENV6600            No  => Branch to Write the Job Name
LENV6500 DS    0H
         MVC   LENJBNME,=CL8'N/A'  Indicate Job Name is Not Available
LENV6600 DS    0H
         MVC   L'LGJOBNME+4(L'LENJBNME,R5),LENJBNME ...Get the Job Name
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the Job Number of Our User Program                           |*
*|                                                                   |*
*|  Job Number..................: JOB09919                           |*
*+-------------------------------------------------------------------+*
*
LENV6700 DS    0H
         LLGT  R1,PSATOLD           Get Addr of Current Task Cntl Block
         LLGT  R1,TCBJSCB-TCB(,R1)  Get Address of Job Step Cntl Block
         LLGT  R2,JSCBSSIB-IEZJSCB(,R1) Subsystem Identification Block
         MVC   LENJBNUM,SSIBJBID-SSIB(R2) ...Get Calling Pgm Job Number
         MVC   3(L'LGJOBNUM,R5),LGJOBNUM  Copy the Detail Line Header
         OC    LENJBNUM,LENJBNUM   Is the Job Number Entry Area Nulls?
         BRZ   LENV6800            Yes => Branch to Show Not Available
         CLC   LENJBNUM,BLANKS     Is the Job Number Entry Area Blanks?
         BRNH  LENV6800            Yes => Branch to Show Not Available
         BRU   LENV6900            No  => Branch to Write Job Number
LENV6800 DS    0H
         MVC   LENJBNUM,=CL8'N/A'  Indicate Job Number is Not Available
LENV6900 DS    0H
         MVC   L'LGJOBNUM+4(L'LENJBNUM,R5),LENJBNUM .Get Pgm Job Number
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the Address Space Number (ASID) for User Program             |*
*|                                                                   |*
*|  Address Space ID (ASID).....: 0031                               |*
*+-------------------------------------------------------------------+*
*
LENV7000 DS    0H
         UNPK  LENWORKD(5),LEN$ASID(3)   Unpack from Hexidecimal Format
         TR    LENWORKD(4),HEXCONV-C'0' ...Make Variable Data Printable
         MVC   3(L'LG$ASID,R5),LG$ASID  ...Copy the Detail Line Header
         MVC   L'LG$ASID+4(4,R5),LENWORKD .Get the Job Address Space ID
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the Job Step Program Name and Job Step Name for User Program |*
*|                                                                   |*
*|  Executing Program Name......: USERPGM2                           |*
*|  Executing Job Step Name.....: RUN                                |*
*+-------------------------------------------------------------------+*
*
LENV7100 DS    0H
         LLGT  R1,PSATOLD          Get Addr of Current Task Cntl Block
         LLGT  R1,TCBJSCB-TCB(,R1) Get Address of Job Step Cntl Block
         LLGT  R2,JSCSCT-IEZJSCB(,R1) Get Address to Step Control Table
         LA    R2,16(R2)           Increment Past the Prefix
         MVC   LENPGMNM,SCTPGMNM-INSMSCT(R2) Get Job Step Program Name
         MVC   LENJSTNM,SCTSNAME-INSMSCT(R2) Get the Jobstep Name
         MVC   3(L'LGPGMNME,R5),LGPGMNME  Copy the Detail Line Header
         MVC   L'LGPGMNME+4(L'LENPGMNM,R5),LENPGMNM ...Get Program Name
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGSTEPNM,R5),LGSTEPNM  Copy the Detail Line Header
         MVC   L'LGSTEPNM+4(L'LENJSTNM,R5),LENJSTNM ..Get Job Step Name
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the MEMLIMIT for User Program                                |*
*|                                                                   |*
*|  Memory Limit (MEMLIMIT).....: 16,383 Petabytes                   |*
*+-------------------------------------------------------------------+*
*
LENV7200 DS    0H
         LLGT  R2,PSAAOLD          Get Address Space Cntrl Blk Old Pntr
         LLGT  R1,ASCBRSME-ASCB(,R2) Get RSM Addr Space Blk Extension
         MVC   LENMEMLM,RAXLVMEMLIM-RAX(R1) Get Addr Space Memory Limit
         MVC   3(L'LGMEMLMT,R5),LGMEMLMT  Copy the Detail Line Header
         LG    R0,LENMEMLM         Get MEMLIMIT Value Expressed in Megs
         LTGR  R1,R0               MEMLIMIT=0M/0G/0T/0P Set for Job?
         BRNZ  LENV7300            No  => Branch to Calculate Memory
         MVC   L'LGMEMLMT+4(2,R5),=CL2'0M' ...Show 0M for Above-the-Bar
         BRU   LENV8100            Branch to Write the Memory Size
LENV7300 DS    0H
         LLILL R2,(1024)           Set the Kilobyte Rounding Indicator
         CLGR  R0,R2               More than a Gigabyte for Our Limit?
         BRH   LENV7500            Yes => Check if Limit in Gigabytes
         CG    R1,=AD(1)           Is Compared Size a Single Megabtye?
         BRNE  LENV7400            No  => Branch to Set for Plural
         MVC   LENSTORM,=C'Megabyte ' ..Above-the-Bar Size as Megabyte
         BRU   LENV8000            Branch to Convert Binary Memory Size
LENV7400 DS    0H
         MVC   LENSTORM,=C'Megabytes' ..Above-the-Bar Size in Megabytes
         BRU   LENV8000            Branch to Convert Binary Memory Size
LENV7500 DS    0H
         SRAG  R0,R1,10 Bits       Calculate Gigabytes (Divide by 1K)
         LGR   R1,R0               To Check if Memlimit into Terabytes
         CLGR  R0,R2               More than a Terabyte for Our Limit?
         BRH   LENV7700            Yes => Check if Limit in Terabytes
         CG    R1,=AD(1)           Is Compared Size a Single Gigabyte?
         BRNE  LENV7600            No  => Branch to Set for Plural
         MVC   LENSTORM,=C'Gigabyte ' ..Above-the-Bar Size as Gigabyte
         BRU   LENV8000            Branch to Convert Binary Memory Size
LENV7600 DS    0H
         MVC   LENSTORM,=C'Gigabytes' ..Above-the-Bar Size in Gigabytes
         BRU   LENV8000            Branch to Convert Binary Memory Size
LENV7700 DS    0H
         SRAG  R0,R1,10 Bits       Calculate Terabytes (Divide by 1K)
         LGR   R1,R0               To Check if Memlimit into Petabytes
         CLGR  R0,R2               More than a Petabyte for Our Limit?
         BRH   LENV7900            Yes => Indicate Limit in Petabytes
         CG    R1,=AD(1)           Is Compared Size a Single Terabyte?
         BRNE  LENV7800            No  => Branch to Set for Plural
         MVC   LENSTORM,=C'Terabyte ' ..Above-the-Bar Size as Terabyte
         BRU   LENV8000            Branch to Convert Binary Memory Size
LENV7800 DS    0H
         MVC   LENSTORM,=C'Terabytes' ..Above-the-Bar Size in Terabytes
         BRU   LENV8000            Branch to Convert Binary Memory Size
LENV7900 DS    0H
         MVC   LENSTORM,=C'Petabytes' Show Highest Amount in Petabytes
         SRAG  R0,R1,10 Bits       Calculate Petabytes (Divide by 1K)
LENV8000 DS    0H
         CVDG  R0,LENMEM64         Binary Memory Limit Value to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit Memory Limit Value to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGMEMLMT+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy MEMLIMIT Value to Output Record
         LA    R15,L'LGMEMLMT+6(R15,R5) Pnt Past End of MEMLIMIT Number
         MVC   0(L'LENSTORM,R15),LENSTORM ..Above-the-Bar Boundary Type
LENV8100 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get the MEMLIMIT Source for the User Program                     |*
*|                                                                   |*
*|  MEMLIMIT Source.............: MEMLIMIT source was set from SMF   |*
*+-------------------------------------------------------------------+*
*
         USING CVT,R1              Establish Addressability to CVT
LENV8200 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         TM    CVTOSLV3,CVTH7708   Level at Least z/OS V1.5 (HBB7708)?
         BRZ   LENV8500            No  => Branch to Process Region Size
         DROP  R1                  Remove Listed Reg as CVT Base Reg
         LLGT  R1,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pnt
         LLGT  R1,ASCBRSME-ASCB(,R1)  Get RSM Addr Space Blk Extension
         LLGC  R1,RAXLVMEMLIMS-RAX(,R1) Get the Source for Memory Limit
         CGHI  R1,MEMLIMNM         Is Source Type within Table Bounds?
         BRNH  LENV8300            Yes => Determine Source of Memlimit
         LA    R1,MEMLIMSR         Point to Memlimit Address Tble Entry
         LLGH  R14,0(,R1)          Displacement in Memlimit Text Table
         LLGH  R1,2(,R1)           Length of Memlimit Text Table Entry
         LA    R14,MEMLTABL(R14)   Point to the Memlimit Text Message
         BRU   LENV8400            Branch to Process Memlimit Source
LENV8300 DS    0H
         SLLG  R1,R1,2 Bits        Multiple by 4 for Table Entry Length
         LA    R1,MEMLIMSR(R1)     Point to Memlimit Address Tble Entry
         LLGH  R14,0(,R1)          Displacement in Memlimit Text Table
         LLGH  R1,2(,R1)           Length of Memlimit Text Table Entry
         LA    R14,MEMLTABL(R14)   Point to the Memlimit Text Message
LENV8400 DS    0H
         MVC   3(L'LGMEMSRC,R5),LGMEMSRC  Copy the Detail Line Header
         BCTGR R1,R0               Decrement Line Length for Execute
         MVC   L'LGMEMSRC+4(*-*,R5),0(R14)  Indicated Target of Execute
         EX    R1,*-6              Memlimit Source Type to Output Line
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
*
*+-------------------------------------------------------------------+*
*|  Get Virtual Storage Use of Our User Program                      |*
*+-------------------------------------------------------------------+*
*
LENV8500 DS    0H
         LLGT  R2,PSAAOLD          Get Address Space Cntrl Blk Old Pntr
         LLGT  R1,ASCBLDA-ASCB(,R2) Get VSM Local Data Area Control Blk
         LLGF  R15,LDAREGRQ-LDA(,R1) Get Region Size Requested by Job
         ST    R15,LENREGRQ        Save the Region Size Requested Value
         LLGF  R15,LDALOAL-LDA(,R1) Get Below-the-Line User Area Alloc
         ST    R15,LENUAL24        Save Below-the-Line User Area Alloc
         LLGF  R15,LDAVVRG-LDA(,R1)  Get Below 16M Adjusted Region Size
         LTGFR R15,R15             User Area Limit Adjusted by IEFUSI?
         BRNZ  LENV8600            Yes => Use Adjusted Value for <16M
         LLGF  R15,LDALIMIT-LDA(,R1) Get Default <16Meg User Area Limit
LENV8600 DS    0H
         ST    R15,LENLIMIT        Save Below-the-Line User Area Limit
         LLGF  R15,LDAMRG24-LDA(,R1) Get Max Area Below 16MEG Available
         ST    R15,LENMRG24        Save Value of Max Area Below 16MEG
         LLGF  R15,LDAELOAL-LDA(,R1) Get Above-the-Line User Area Alloc
         ST    R15,LENUAL31        Save Above-the-Line User Area Alloc
         LLGF  R15,LDAEVVRG-LDA(,R1) Get Above 16M Adjusted Region Size
         LTGFR R15,R15             User Area Limit Adjusted by IEFUSI?
         BRNZ  LENV8700            Yes => Use Adjusted Value for >16M
         LLGF  R15,LDAELIM-LDA(,R1) Get Default >16Meg User Area Limit
LENV8700 DS    0H
         ST    R15,LENELIMT        Save Above-the-Line User Area Limit
         LLGF  R15,LDAMRG31-LDA(,R1) Get Max Area Above 16MEG Available
         ST    R15,LENMRG31        Save Value of Max Area Above 16MEG
         LLGT  R1,PSATOLD-PSA(,R0) Get Addr of Current Task Cntl Block
         LLGT  R1,TCBTCT-TCB(,R1)  Get Adr of SMF Timing Common Section
         LTGFR R1,R1               SMF Data Being Collected for Task?
         BRZ   LENV8800            No  => Branch to Process Storage Use
         LLGT  R1,TCTCRTBL-SMFTCT(,R1) Addr of SMF Timing Control Table
         LLGF  R15,TCTRGNB-TCTCORE(,R1)  Get Max Area Below 16M Allowed
         ST    R15,LENMRG24         Save Below-the-Line Max Available
         LLGF  R15,TCTERGNB-TCTCORE(,R1) Get Max Area Above 16M Allowed
         ST    R15,LENMRG31         Save Above-the-Line Max Available
*
*+-------------------------------------------------------------------+*
*| Get the Region Size For User Program                              |*
*|                                                                   |*
*| Region Size.................: 4M                                  |*
*+-------------------------------------------------------------------+*
*
LENV8800 DS    0H
         MVC   3(L'LGREGNSZ,R5),LGREGNSZ  Copy the Detail Line Header
         LLGF  R1,LENREGRQ         Obtain Region Size Requested by Job
         LTGFR R2,R1               Was REGION=0K/0M Specified for Job?
         BRNZ  LENV8900            No  => Branch to Calculate REGION
         MVC   L'LGREGNSZ+4(2,R5),=CL2'0M' ...Has All Available Storage
         BRU   LENV9200            Branch to Process Next Report Line
LENV8900 DS    0H
         SLGR  R0,R0               Clear for the Division Operation
         DSGF  R0,=A(1024*1024)    Divide Region Size by 1M (1048576)
         LTGR  R0,R0               Was Region Size on a 1MEG Boundary?
         BRNZ  LENV9000            No  => Branch to Calculate Kilobytes
         MVI   LENSTORI,C'M'       Yes => Set Region Size in Megabytes
         BRU   LENV9100            Branch to Convert Binary Region Size
LENV9000 DS    0H
         SRLG  R1,R2,10 Bits       Divide the Region Size by 1K (1024)
         MVI   LENSTORI,C'K'       Indicate Region Size is in Kilobytes
LENV9100 DS    0H
         CVDG  R1,LENSTORD         Binary Region Size Value to Decimal
         MVC   LENSTORC,PATTERN2   Copy in the Number Editing Pattern
         LA    R1,LENFORC2         Load 1st Forced Result Char Location
         EDMK  LENSTORC,LENSTORD+8 Edit Region Size Value to Character
         LA    R15,LENSTORC+L'LENSTORC-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGREGNSZ+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy Region Size to Output Area
         LA    R15,L'LGREGNSZ+5(R15,R5) ..Point Past End of Region Size
         MVC   0(1,R15),LENSTORI   Indicate Region Size in Kilo or Megs
*
*+-------------------------------------------------------------------+*
*|  Get the Below 16M Area Available for User Program                |*
*|                                                                   |*
*|  Below 16M Area Available....: 2,097,152                          |*
*+-------------------------------------------------------------------+*
*
LENV9200 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGBL16AV,R5),LGBL16AV  Copy the Detail Line Header
         LLGF  R1,LENLIMIT         Obtain the Below 16M User Area Limit
         LTGFR R1,R1               Below-the-Line User Area Available?
         BRNZ  LENV9300            Yes => Branch to Calculate <16M Area
         MVC   L'LGBL16AV+4(3,R5),=CL3'N/A' Show <16M Value Unavailable
         BRU   LENV9400            Branch to Write the <16M Area Line
LENV9300 DS    0H
         CVDG  R1,LENMEM64         Set Binary <16M User Area to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit the <16M User Area to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGBL16AV+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy <16M User Area to Output Area
*
*+-------------------------------------------------------------------+*
*| Get Below 16M Maximum Area Allowed By System for User Program     |*
*|                                                                   |*
*| Below 16M Maximum Allowed...: 9,412,608                           |*
*+-------------------------------------------------------------------+*
*
LENV9400 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGBL16AL,R5),LGBL16AL  Copy the Detail Line Header
         LLGF  R1,LENMRG24         Obtain Max Area Allowed Below 16Meg
         LTGFR R1,R1               Below-the-Line Max Area Available?
         BRNZ  LENV9500            Yes => Branch to Calculate <16M Max
         MVC   L'LGBL16AL+4(3,R5),=CL3'N/A' Show <16M Value Unavailable
         BRU   LENV9600            Branch to Write the <16M Max Line
LENV9500 DS    0H
         CVDG  R1,LENMEM64         Set Binary <16M Max Area to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit <16M Max Allowed to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGBL16AL+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy <16M Max Allowed Area to Output
*
*+-------------------------------------------------------------------+*
*|  Get the Below 16M Area Used By the User Program                  |*
*|                                                                   |*
*|  Below 16M Area Being Used...: 479,232                            |*
*+-------------------------------------------------------------------+*
*
LENV9600 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGBL16US,R5),LGBL16US  Copy the Detail Line Header
         LLGF  R1,LENUAL24         Obtain Storage Area Used Below 16Meg
         LTGFR R1,R1               Below-the-Line Area Used Available?
         BRNZ  LENV9700            Yes => Branch to Calculate <16M Use
         MVC   L'LGBL16US+4(3,R5),=CL3'N/A' Show <16M Value Unavailable
         BRU   LENV9800            Branch to Write the <16M Use Line
LENV9700 DS    0H
         CVDG  R1,LENMEM64         Set Binary <16M Use Area to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit <16M Area Used to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGBL16US+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy <16M Storage Area Used to Outpt
*
*+-------------------------------------------------------------------+*
*|  Get the Above 16M Area Available for User Program                |*
*|                                                                   |*
*|  Above 16M Area Available....: 33,554,432                         |*
*+-------------------------------------------------------------------+*
*
LENV9800 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGAB16AV,R5),LGAB16AV  Copy the Detail Line Header
         LLGF  R1,LENELIMT         Obtain the Above 16M User Area Limit
         LTGR  R1,R1               Above-the-Line User Area Available?
         BRNZ  LENV9900            Yes => Branch to Calculate >16M Area
         MVC   L'LGAB16AV+4(3,R5),=CL3'N/A' Show >16M Value Unavailable
         BRU   LENVA100            Branch to Write the >16M Area Line
LENV9900 DS    0H
         CVDG  R1,LENMEM64         Set Binary >16M User Area to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit the >16M User Area to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGAB16AV+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy >16M User Area to Output Area
*
*+-------------------------------------------------------------------+*
*| Get Above 16M Maximum Area Allowed By System for User Program     |*
*|                                                                   |*
*| Above 16M Maximum Allowed...: 1,738,539,008                       |*
*+-------------------------------------------------------------------+*
*
LENVA100 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGAB16AL,R5),LGAB16AL  Copy the Detail Line Header
         LLGF  R1,LENMRG31         Obtain Max Area Allowed Above 16Meg
         LTGR  R1,R1               Above-the-Line Max Area Available?
         BRNZ  LENVA200            Yes => Branch to Calculate >16M Max
         MVC   L'LGAB16AL+4(3,R5),=CL3'N/A' Show >16M Value Unavailable
         BRU   LENVA300            Branch to Write the >16M Max Line
LENVA200 DS    0H
         CVDG  R1,LENMEM64         Set Binary >16M Max Area to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit >16M Max Allowed to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGAB16AL+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy >16M Max Allowed Area to Output
*
*+-------------------------------------------------------------------+*
*|  Get the Above 16M Area Used By Our User Program                  |*
*|                                                                   |*
*|  Above 16M Area Being Used...: 241,664                            |*
*+-------------------------------------------------------------------+*
*
LENVA300 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGAB16US,R5),LGAB16US  Copy the Detail Line Header
         LLGF  R1,LENUAL31         Obtain Storage Area Used Above 16Meg
         LTGR  R1,R1               Above-the-Line Area Used Available?
         BRNZ  LENVA400            Yes => Branch to Calculate >16M Use
         MVC   L'LGAB16US+4(3,R5),=CL3'N/A' Show >16M Value Unavailable
         BRU   LENVA500            Branch to Write the >16M Use Line
LENVA400 DS    0H
         CVDG  R1,LENMEM64         Set Binary >16M Use Area to Decimal
         MVC   LENMEMOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LENFORCE         Load 1st Forced Result Char Location
         EDMK  LENMEMOT,LENMEM64   Edit >16M Area Used to Character
         LA    R15,LENMEMOT+L'LENMEMOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate the Length of our Number
         MVC   L'LGAB16US+4(*-*,R5),0(R1) Indicated Target of Execute
         EX    R15,*-6             Copy >16M Storage Area Used to Outpt
*
*+-------------------------------------------------------------------+*
*|  Get the User Id Associated With Our User Program                 |*
*|                                                                   |*
*|  User Id.....................: USER002                            |*
*+-------------------------------------------------------------------+*
*
LENVA500 DS    0H
         LLGT  R2,PSAAOLD          Get Address Space Cntrl Blk Old Pntr
         LLGT  R15,ASCBASXB-ASCB(,R2) Get Address Space Extension Block
         LGR   R0,R15              Save Pntr to Adr Space Extension Blk
         ICM   R15,B'1111',ASXBSENV-ASXB(R15) ...Is There an ACEE?
         BRZ   LENVA600            No  => Then Get User ID from ASXB
         CLC   =CL4'ACEE',ACEEACEE-ACEE(R15) .Have An ACEE Control Blk?
         BRNE  LENVA600            No  => Then Get User ID from ASXB
         MVC   LENUSRID,ACEEUSRI-ACEE(R15) Accessor Environment Element
         BRU   LENVA700            Branch to Print Userid Output Record
LENVA600 DS    0H
         LGR   R15,R0              Retrieve Addr Space Extention Block
         MVC   LENUSRID(7),ASXBUSER-ASXB(R15) Get our User ID from ASXB
         MVI   LENUSRID+7,C' '     Can Only be Seven Characters
         DROP  R0                  Remove Listed Reg as PSA Base Reg
LENVA700 DS    0H
         LA    R5,L'LGWLINE(,R5)   Increment to Skip to the Next Line
         MVC   3(L'LGUSERID,R5),LGUSERID  Copy the Detail Line Header
         MVC   L'LGUSERID+4(L'LENUSRID,R5),LENUSRID Get User Id for Job
*
*+-------------------------------------------------------------------+*
*|    Return To Caller                                               |*
*+-------------------------------------------------------------------+*
*
LENV$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
LENVEXIT DS    0H
         ST    R15,LENRETCD        Set the Return Code
         LPGMEXIT RC=LENRETCD      Define Program Exit Protocol
*
***********************************************************************
**************************+-----------------+**************************
**************************| L H D W 1 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|P r o c e s s  H a r d w a r e  C o n f i g u r a t i o n  I n f o |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: LHDW1000                                           *
*                                                                     *
* FUNCTION:        Process Hardware Configuration Information         *
*                                                                     *
*                  This subroutine will display basic physical        *
*                  hardware information where the z/OS system is      *
*                  running. This subroutine will first determine the  *
*                  CPU hardware model, and the model type.            *
*                                                                     *
*                  Next the number of central processors is determined*
*                  for the CEC. By current convention the inclusion of*
*                  a System z Integrated Information Processor (zIIP) *
*                  or a System z Application Assist Processor (zAAP)  *
*                  does not change the model number or MSU rating of a*
*                  System z platform, so these special processors are *
*                  not included in the central processor count. Only  *
*                  the general purpose central processors (CP's) are  *
*                  considered.                                        *
*                                                                     *
*                  Next a MIPS (Millions of Instructions Per Second)  *
*                  value is calculated. This speed rating in MIPS is  *
*                  only an approximation because no adjustment is made*
*                  for the LPAR configuration. This MIPS value for    *
*                  general purpose central processors is included here*
*                  only as a historical term that is commonly used,   *
*                  but it is not a reliable indicator of CPU workload *
*                  throughput. The MIPS rating calculated here        *
*                  represents a configuration where the physical box  *
*                  is dedicated to a single LPAR with a single z/OS   *
*                  system, the LPAR has the same number of logical    *
*                  processors as physical ones, and the LPAR has      *
*                  complete dedicated access to all processors which  *
*                  are defined to it. The MIPS calculation is based on*
*                  Thierry Falissard's SUSEC in CBT432.               *
*                                                                     *
*                  Next a MSU (Millions of Service Units) value is    *
*                  obtained for the system using the SYSEVNT QVS call *
*                  for Query Virtual Server. This routine provides a  *
*                  work area for use by QVS as a parameter list area  *
*                  where information is returned from the SYSEVENT QVS*
*                  service. The QVSFLAGS flag indicator is checked to *
*                  verify information has been returned. If return    *
*                  information is available, the MSU values for the   *
*                  physical hardware, the logical partition, and      *
*                  virtual machine are extracted and displayed.       *
*+-------------------------------------------------------------------+*
*
*+-------------------------------------------------------------------+*
*| Obtain the CPU Model Designation for Our System                   |*
*+-------------------------------------------------------------------+*
*
LHDW1000 LPGMSUBE                  Set Subroutine Entry Protocol
         MVC   3(L'LGCPMODL,R5),LGCPMODL  Copy the Detail Line Header
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LGR   R15,R1              Pointer to CVT in Work Register
         LLILL R2,(6)              To Point Back into CVT Prefix Area
         SLGFR R15,R2              Get Address to CVT CPU Model Field
         MVC   LENWORKD+8(2),0(R15) CPU Modl in Signless Packed Decimal
         UNPK  LENWORKD(5),LENWORKD+8(3) Convert to Character Format
         MVC   L'LGCPMODL+4(4,R5),LENWORKD ..Get the Hardware CPU Model
*
*+-------------------------------------------------------------------+*
*| Obtain the CPU Model Type for Our System                          |*
*+-------------------------------------------------------------------+*
*
LHDW1100 DS    0H
         LA    R15,L'LGCPMODL+9(,R5) ..Increment to Hardware Type Area
         LLGT  R2,CVTHID-CVT(,R1)  Get Addr to System Host Id Cntl Blk
         MVC   0(5,R15),=CL5'Type(' Copy in System Hardware Type Header
         LA    R15,5(,R15)         Increament Past Detail Line Header
         MVC   0(L'CPCND_MODEL,R15),CPCND_MODEL-SHID(R2) Get the Type
         MVI   L'CPCND_MODEL(R15),C')'  Copy in Closing Parenthesis
         LA    R15,L'CPCND_MODEL+3(,R15) Increment to CPU's Online Area
*
*+-------------------------------------------------------------------+*
*| Obtain Number of General Purpose CPU Engines Available for System |*
*+-------------------------------------------------------------------+*
*
LHDW1200 DS    0H
         TM    CVTOSLV3,CVTH7709   Is Current z/OS Level at least V1R6?
         BRNZ  LHDW1300            Yes => Max CPU's When V1R6 or Higher
         LGHI  R3,((PCCAT16_31P-PCCAVT)/L'PCCAT00P) When Less Than V1R6
         BRU   LHDW1400            Branch to Check Processor Config
LHDW1300 DS    0H
         LGHI  R3,((PCCATEND-PCCAVT)/L'PCCAT00P) ...Max CPU's Supported
LHDW1400 DS    0H
         SLGR  R4,R4               Init Count for No. of CPU's to Zero
         LLGT  R14,CVTPCCAT        Get Addr to Phyical CCA Vector Tble
         LLILL R2,(L'PCCAT00P)     Length of Each Entry in the PCCAVT
         BCTGR R3,R0               To Point to Start of the Last Entry
         MSGFR R3,R2               Leng of Entry Times Entries in Tble
         LA    R3,0(R14,R3)        End Points to Next to Last Entry
         DROP  R1                  Remove Listed Reg as CVT Base Reg
LHDW1500 DS    0H
         LLGT  R1,0(,R14)          Get Pointer to Vector Table for CPU
         LTGFR R1,R1               Is This an Active Processor Engine?
         BRZ   LHDW1700            No  => Check the Next Processor No.
LHDW1600 DS    0H
         TM    PCCAATTR-PCCA(R1),X'04' Is This a zIIP Processor?
         BRNZ  LHDW1700            Yes => Then Exclude from CPU Count
         TM    PCCAATTR-PCCA(R1),X'01' Is This a zAAP Processor?
         BRNZ  LHDW1700            Yes => Then Exclude from CPU Count
         LLGF  R4,LENGPCPU         Get the GP CPU Count Accumulator
         LA    R4,1(,R4)           Add for a General Purpose Processor
         ST    R4,LENGPCPU         Save New General Purpose CPU Count
LHDW1700 DS    0H
         BRXLG R14,R2,LHDW1500     Loop to Process Next Vector Table
LHDW1800 DS    0H
         CVD   R4,LENWORKD         Number of CPUs to a Decimal Format
         LA    R1,LENFORC3         Preload 1st Forced Result Location
         MVC   LENLOCTM,PATTERN3   Copy in the Number Editing Pattern
         EDMK  LENLOCTM,LENWORKD+4 Edit the CPU Number to Character
         LA    R14,LENLOCTM+L'LENLOCTM-1 ..Point to Last Byte in Field
         SGR   R14,R1              Calculate the Length of Offset Value
         MVC   0(11,R15),=CL11'Processors=' Set the Detail Line Header
         MVC   11(*-*,R15),0(R1)   Indicated Target of the Execute
         EX    R14,*-6             Copy Number of CPU's to Output Area
         LA    R15,14(R15,R14)     Increment to Available Mips Field
*
*+-------------------------------------------------------------------+*
*| Calculate an Approximate MIPS Rating for Our System.              |*
*+-------------------------------------------------------------------+*
*
LHDW2000 DS    0H
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLGT  R6,CVTOPCTP         System Resources Manager Cntl Table
         LLGF  R6,RMCTADJC-RMCT(,R6) Get the CPU Rate Adjustment Factor
         LTGR  R6,R6               Is There a Rate Adjustment Factor?
         BRNZ  LHDW2100            Yes => Utilize Factor in MIPS Rating
         STG   R15,LENWORKD        Hold Current Position in Output Line
         BRU   LHDW3000            Branch to Process the MSU Rating
         DROP  R1                  Remove Listed Reg as CVT Base Reg
LHDW2100 DS    0H
         LG    R3,=AD(16000000)    # of 16ths of 1 Microsecond per Sec
         MSGF  R3,=F'1000000'      A Shift Left to Align Decimal Places
         DSGFR R2,R6               Divide by Adjust Factor for SU/sec
         DSGF  R2,=F'48500'        Apply Constant for MIPS to SU/sec
         MSGFR R3,R4               MIPS per CPU Times the No. of CPU's
         CVDG  R3,LENWORKD         Convert MIPS to a Decimal Format
         SRP   LENWORKD+11(5),64-1,5 Drop One Decimal Place and Round
         MVC   0(5,R15),=CL5'MIPS=' ...Set the Detail Line Header
         LA    R15,5(,R15)         Increment to Available MIPS Field
         LA    R1,LENFORC5         Preload 1st Forced Result Location
         MVC   LEN$MIPS,PATTERN5   Copy in the Number Editing Pattern
         EDMK  LEN$MIPS,LENWORKD+10  ..Edit the MIPS Value to Character
         LA    R14,LEN$MIPS+L'LEN$MIPS-1 ..Point to Last Byte in Output
         SGR   R14,R1              Calculate the Length of MIPS Number
         MVC   0(*-*,R15),0(R1)    Indicated Target of Execute
         EX    R14,*-6             Copy the MIPS Value to Output Area
         LA    R15,3(R15,R14)      Increment to the MSU Rating Field
         STG   R15,LENWORKD        Hold Current Position in Output Line
*
*+-------------------------------------------------------------------+*
*| Utilize SYSEVENT QVS to Obtain the MSU Ratings for Our System     |*
*+-------------------------------------------------------------------+*
*
LHDW3000 DS    0H
         LA    R1,QVS_LEN          Get the Length of QVS Parameter List
         ST    R1,LENQVSWK+(QVSLEN-QVS) Len of Parm List into Parm List
         LA    R1,LENQVSWK         Work Area is Our Parameter List Area
         SAM31                     Switch Now to 31-Bit Addressing Mode
         SYSEVENT QVS              Perform Query Virtual Server Service
         SAM64                     Switch Back to 64-Bit Address Mode
LHDW3100 DS    0H
         LG    R15,LENWORKD        Restore Current Position in Outpt Ln
         LA    R2,LENQVSWK         Point to the QVS Parameter List Area
         TM    QVSFLAGS-QVS(R2),QVSCECVALID ..Valid CEC Data Available?
         BRZ   LHDW4000            No  => QvsCec Prefix Fields Invalid
LHDW3200 DS    0H
         LLGF  R3,QVSCECCAPACITY-QVS(,R2) Get CEC CPU Capacity in MSU's
         CVD   R3,LENWORKD         No. of CEC MSU's to a Decimal Format
         LA    R1,LENFORC3         Preload 1st Forced Result Location
         MVC   LENLOCTM,PATTERN3   Copy in the Number Editing Pattern
         EDMK  LENLOCTM,LENWORKD+4 Edit the CEC MSU Number to Character
         LA    R14,LENLOCTM+L'LENLOCTM-1 ..Point to Last Byte in Field
         SGR   R14,R1              Calculate the Length of Offset Value
         MVC   0(9,R15),=CL9'MSU=>CEC:' ...Set the Detail Line Header
         MVC   9(*-*,R15),0(R1)    Indicated Target of the Execute
         EX    R14,*-6             Copy Number of MSU's to Output Area
         LA    R15,11(R15,R14)     Increment to LPAR MSU Capacity Field
LHDW3300 DS    0H
         TM    QVSFLAGS-QVS(R2),QVSIMGVALID Valid Image Data Available?
         BRZ   LHDW4000            No  => QvsImg Prefix Fields Invalid
LHDW3400 DS    0H
         LLGF  R3,QVSIMGCAPACITY-QVS(,R2) ..LPAR CPU capacity in MSU's
         CVD   R3,LENWORKD         No. of LPAR MSU's to Decimal Format
         LA    R1,LENFORC3         Preload 1st Forced Result Location
         MVC   LENLOCTM,PATTERN3   Copy in the Number Editing Pattern
         EDMK  LENLOCTM,LENWORKD+4 Edit LPAR MSU Number to Character
         LA    R14,LENLOCTM+L'LENLOCTM-1 ..Point to Last Byte in Field
         SGR   R14,R1              Calculate the Length of Offset Value
         MVC   0(4,R15),=CL4'IMG:'  ..Set LPAR Image Detail Line Header
         MVC   4(*-*,R15),0(R1)    Indicated Target of the Execute
         EX    R14,*-6             Copy Number of MSU's to Output Area
         LA    R15,6(R15,R14)      Increment to VM MSU Capacity Field
LHDW3500 DS    0H
         TM    QVSFLAGS-QVS(R2),QVSVMVALID Is Valid VM Data Available?
         BRZ   LHDW4000            No  => QvsVM Prefix Fields Invalid
LHDW3600 DS    0H
         LLGF  R3,QVSVMCAPACITY-QVS(,R2)  Get VM CPU capacity in MSU's
         CVD   R3,LENWORKD         No. of VM MSU's to a Decimal Format
         LA    R1,LENFORC3         Preload 1st Forced Result Location
         MVC   LENLOCTM,PATTERN3   Copy in the Number Editing Pattern
         EDMK  LENLOCTM,LENWORKD+4 Edit the VM MSU Number to Character
         LA    R14,LENLOCTM+L'LENLOCTM-1 ..Point to Last Byte in Field
         SGR   R14,R1              Calculate the Length of Offset Value
         MVC   0(3,R15),=CL3'VM:'  Set Virtual Machine Detail Line Hdr
         MVC   3(*-*,R15),0(R1)    Indicated Target of the Execute
         EX    R14,*-6             Copy Number of MSU's to Output Area
LHDW4000 DS    0H
         LPGMSUBX                  Return to Caller of This Subroutine
         LTORG ,                   Establish the Literal Origin Pool
*
*+-------------------------------------------------------------------+*
*|        End of the LHDW1000 Subroutine in Program LENV0000         |*
*+-------------------------------------------------------------------+*
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
LENWORKD DS    10D                 General Work Area
LENRETCD DS    F                   Save Area for the Return Code
LEN$ASID DS    XL2                 Save Area for Address Space Id
         DS    XL1                 Slack Byte for Unpack Operation
LENJTYPE DS    CL12                Save Area for Job Type Indicator
LENJBNUM DS    CL8                 Save Area for the Job Number
LENJBNME DS    CL8                 Save Area for the Job Name
LENPGMNM DS    CL8                 Save Area for Executing Program
LENJSTNM DS    CL8                 Save Area for the Job Step Name
LENUSRID DS    CL8                 Save Area for the User Id
LENMEMLM DS    D                   Save Area for the Binary MEMLIMIT
LENMEM64 DS    CL(2*L'LENMEMLM)    Work Area for the Decimal MEMLIMIT
LENMEMOT DS    CL(L'PATTERN)       Work Area for Character MEMLIMIT
LENFORCE EQU   *-1                 First Forced Result Char Location
LENREGRQ DS    F                   Save Area for Region Size Requested
LENLIMIT DS    F                   Save Area for Below 16M User Limit
LENUAL24 DS    F                   Save Area for Below 16M User Alloc
LENMRG24 DS    F                   Save Area for Max Area Below 16MEG
LENELIMT DS    F                   Save Area for Above 16M User Limit
LENUAL31 DS    F                   Save Area for Above 16M User Alloc
LENMRG31 DS    F                   Save Area for Max Area Above 16MEG
LENSTORM DS    CL9                 Save Area for MEMLIMIT Boundary Type
         DS    0D                  Set for Doubleword Alignment
LENSTORD DS    CL16                Wrk Area for Decimal Storage Amounts
LENSTORC DS    CL(L'PATTERN2)      Wrk Area for Character Stor Amounts
LENFORC2 EQU   *-1                 First Forced Result Char Location
LENSTORI DS    CL1                 Region in Kilobytes or Megabytes
         DS    0D                  Set for Doubleword Alignment
LENDTETM DS    0CL16               Date & Time Values from TOD Clock
LENTIME  DS    PL8                 Time Value Expressed as 'HHMMSS'
LENDATE  DS    PL4                 Date Value Expressed as 'MMDDYYYY'
         DS    XL4                 ..(Reserved)
LEN$YEAR DS    F                   Gregorian Calendar Year in Binary
LEN$MNTH DS    H                   Gregorian Calendar Month in Binary
LEN$DAY@ DS    H                   Gregorian Calendat Day in Binary
TOD$GREG DS    0CL8                Area for Zoned Gregorian Date
TODGRGDD DS    CL2                 Area for Calendar Day in Month
TODGRGMM DS    CL2                 Area for the Calendar Month in Year
TODGRGYY DS    CL4                 Area for Calendar Year (19xx, 20xx)
         DS    CL2                 Slack Bytes for Unpack Processing
LENTODWK DS    CL9                 Date & Time General Work Area
LENGREGD DS    0CL10               Gregorian Date Display Format
LENMONTH DS    CL2                 Current Calendar Month
LENSEPR1 DS    CL1                 Use Slash '/' as Separator Character
LENDAY   DS    CL2                 Current Calendar Day of the Month
LENSEPR2 DS    CL1                 Use Slash '/' as Separator Character
LENYEAR  DS    CL4                 Current Calendar Year Y2K Format
LENGTIME DS    0CL8                Gregorian Time Display Format
LENHOURS DS    CL2                 Current Hour of the Day
LENCOLN1 DS    CL1                 Use a Colon as a Separator Character
LENMINS  DS    CL2                 Current Minute of the Day
LENCOLN2 DS    CL1                 Use a Colon as a Separator Character
LENSECND DS    CL2                 Current Seconds of the Day
LENLOCTM DS    CL8                 Local Time Offset in Seconds to GMT
LENFORC3 EQU   *-1                 First Forced Result Char Location
LENFORC4 EQU   *-2                 First Forced Result Char Location
LENGMTTZ DS    CL10                Indicator for GMT East or GMT West
LENGPCPU DS    F                   No. of General Purpose CPU Engines
LEN$MIPS DS    CL16                Local Time Offset in Seconds to GMT
LENFORC5 EQU   *-3                 First Forced Result Char Location
LENQVSWK DS    32FD
LENQVSLN EQU   *-LENQVSWK
LENSSPNT DS    F                   Save Area for Subsys Optn Blk Addr
LENSSOB@ DS    XL768               Work Area for Subsystem Optns Block
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*              End of Environmental Report Processing                 *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Logger Control Area - (LCA)
RBASE1   EQU   12                  Base Register 1
RBASE2   EQU   11                  Base Register 2
RCOMM1   EQU   10                  Common Dynamic Area Base Register
RCOMM2   EQU   9                   Common Constants/Routines Base Reg
RLGW     EQU   8                   Logger Services Work Area
RPGM     EQU   7                   Logging Input Options Area
         USING LAX@PCA,RCOMM1      Common Program Area Addressability
         USING COM#B7N3,RCOMM2     Constants&Routines Addressability
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M # B 7 N 3 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P r o g r a m   C o n t r o l   C o m m o n   D a t a   A r e a  |*
*+-------------------------------------------------------------------+*
*
COM#B7N3 RSECT
COM#B7N3 AMODE &AMODE
COM#B7N3 RMODE &RMODE
*
BLANKS   DC    CL80' '             Spaces
DSNSYSI$ DC    CL8'LGRSYSIN'       Data Definitiona Name for Input
LOGDDOUT DC    CL8'LGRECOUT'       Definition for Logger Output DDname
LOGEVENT DC    CL8'LOGEVENT'       Definition for Logger Operation
NAME     DC    CL4'NAME'           Definition to Logger Program Keyword
PROGRAM  DC    CL6'PROGRM'         Definition to Logger Program Entry
SUBROUTN DC    CL6'SUBRTN'         Definition to Loggr Subroutine Entry
LOGPOINT DC    CL6'LOGPNT'         Definition to Set Log Point Event
SYSTEM   DC    CL6'SYSTEM'         Definition to Set Logger System Evnt
         DC    H'0'                Ensure Halfword Boundary Alignment
SWTCHMOD DC    X'0100'             Define Instruction to Switch Amodes
CVT$ZTOK DC    D'0'                CVT TOD High Word Offset Zero Token
IPA$ZTOK DC    D'0'                IPA TOD High Word Offset Zero Token
NOCARRY  EQU   8+4                 Condition Code for No Carry
NOBORROW EQU   2+1                 Condition Code for No Borrow
PATTERN  DC    XL42'40206B2020206B2020206B2020206B2020206B2020206B20202X
               06B2020206B2020206B2020206B202120'         Edit Pattern
PATTERN2 DC    XL16'40202020202020202020202020202120'     Edit Pattern
PATTERN3 DC    XL8'4020202020202120'                      Edit Pattern
PATTERN4 DC    XL8'4020202020212020'                      Edit Pattern
PATTERN5 DC    XL16'40402020206B2020206B2020214B2020'
HOURSECS DC    PL3'3600'           Set for Number of Seconds in an Hour
MINSECDS DC    PL3'60'             Set for No. of Seconds in a Minute
*
*+-------------------------------------------------------------------+*
*|    Date Table for Days in Calendar Months                         |*
*+-------------------------------------------------------------------+*
*
DATETBLE DS    0H                  Date Table for Days in a Month
         DC    H'31'               Days in Calendar Month of January
DATFEB28 DC    H'28'               Days in Calendar Month of February
         DC    H'31'               Days in Calendar Month of March
         DC    H'30'               Days in Calendar Month of April
         DC    H'31'               Days in Calendar Month of May
         DC    H'30'               Days in Calendar Month of June
         DC    H'31'               Days in Calendar Month of July
         DC    H'31'               Days in Calendar Month of August
         DC    H'30'               Days in Calendar Month of September
         DC    H'31'               Days in Calendar Month of October
         DC    H'30'               Days in Calendar Month of November
         DC    H'31'               Days in CAlendar Month of December
DATETBLN EQU   *-DATETBLE
         DS    0H
DAYSTABL DS    0CL12               Table for Conversion to Day of Week
         DC    Y(6),CL10'Sunday   ' Sunday is Considered to be Day 0
         DC    Y(6),CL10'Monday   ' Monday is Considered to be Day 1
         DC    Y(7),CL10'Tuesday  ' Tuesday is Considered to Be Day 2
         DC    Y(9),CL10'Wednesday' Wednesday is Considered to Be Day 3
         DC    Y(8),CL10'Thursday ' Thursday is Considered to be Day 4
         DC    Y(6),CL10'Friday   ' Friday is Considered to be Day 5
         DC    Y(8),CL10'Saturday ' Saturday is considered to be Day 6
DAYSINWK EQU   (*-DAYSTABL)/L'DAYSTABL No. of Days of Week Tble Entries
MONTHTBL DC    AL1(0,3,2,5,0,3,5,1,4,6,2,4)  Sequence Numbers for Month
*
*+-------------------------------------------------------------------+*
*|    MEMLIMIT Source Type Table                                     |*
*+-------------------------------------------------------------------+*
*
         CNOP  0,8                 Setup for Doubleword Alignment
MEMLIMSR DS    0CL4                Table for Conversion of MEMLIM Srce
         DC    Y(MEMLSR00-MEMLTABL),Y(L'MEMLSR00) Limit not determined
         DC    Y(MEMLSR01-MEMLTABL),Y(L'MEMLSR01) Set from SMF
         DC    Y(MEMLSR02-MEMLTABL),Y(L'MEMLSR02) Set from JCL
         DC    Y(MEMLSR03-MEMLTABL),Y(L'MEMLSR03) Set from REGION=0
         DC    Y(MEMLSR04-MEMLTABL),Y(L'MEMLSR04) Set from IEFUSI
         DC    Y(MEMLSR05-MEMLTABL),Y(L'MEMLSR05) Set from OMVS Segment
         DC    Y(MEMLSR06-MEMLTABL),Y(L'MEMLSR06) Set (UNIX setrlimit)
         DC    Y(MEMLSR07-MEMLTABL),Y(L'MEMLSR07) Set from UNIX Spawn
         DC    Y(MEMLSR08-MEMLTABL),Y(L'MEMLSR08) Set from SETOMVS Cmd
         DC    Y(MEMLSR09-MEMLTABL),Y(L'MEMLSR09) Set from AUTH Program
         DC    Y(MEMLSR10-MEMLTABL),Y(L'MEMLSR10) Set (IEFUSI+REGION=0)
MEMLIMNM EQU   (*-MEMLIMSR)/L'MEMLIMSR No. of MEMLIM Source Tbl Entries
         CNOP  0,8                 Setup for Doubleword Alignment
MEMLTABL DS    0H                  MEMLIMIT Message Text Table Area
MEMLSR00 DC    C'MEMLIMIT source not determined'
MEMLSR01 DC    C'MEMLIMIT source was set from SMF'
MEMLSR02 DC    C'MEMLIMIT source was set from JCL'
MEMLSR03 DC    C'MEMLIMIT was set to NOLIMIT because JCL specified REGIX
               ON=0'
MEMLSR04 DC    C'MEMLIMIT source was set from the IEFUSI installation eX
               xit'
MEMLSR05 DC    C'MEMLIMIT was set from RACF OMVS Segment'
MEMLSR06 DC    C'MEMLIMIT was set from z/OS UNIX Setrlimit'
MEMLSR07 DC    C'MEMLIMIT was set from z/OS UNIX Spawn'
MEMLSR08 DC    C'MEMLIMIT was set from the SETOMVS operator command'
MEMLSR09 DC    C'MEMLIMIT was set from AUTH Program'
MEMLSR10 DC    C'MEMLIMIT was set from IEFUSI when REGION=0 (OA14391)'
*
*+-------------------------------------------------------------------+*
*     Lists                                                           *
*+-------------------------------------------------------------------+*
*
COM$WTO  WTO   TEXT=(DSNWTO),      Write to Operator Message           X
               ROUTCDE=(1,11),MF=L Route to the Syslog and the Joblog
COM$WTOL EQU   *-COM$WTO           WTO List Length
*
COMESTAE DS    0H                  Specify Task Abnormal Exit Extended
         ESTAEX ,CT,               Define a New Recovery Environment   X
               PARAM=*-*,          Address of Parameter List to Pass   X
               PURGE=NONE,         Outstanding I/O Operations Not SavedX
               ASYNCH=YES,         Allow Asynchronous Exit Processing  X
               CANCEL=YES,         Allow Interruption by Cancel/Detach X
               RECORD=NO,          Do not Record SWDA in System LogRec X
               TERM=YES,           Schedule Routine on Termination     X
               MF=L                Indicate List Form
COMESTAL EQU   *-COMESTAE          ESTAEX List Length
*
COM$TIME TIME  LINKAGE=SYSTEM,MF=L List Form for Time of Day
COMTIMLN EQU   *-COM$TIME          List Length for Time of Day
*
*+-------------------------------------------------------------------+*
*     Data Control Block Definitions                                  *
*+-------------------------------------------------------------------+*
*
         CNOP  2,4                 Set-up for Half-word Alignment
         DC    AL2(LGRSYSNL)       Model Data Control Block Length
LGRSYSIN DCB   DSORG=PS,           Physical Sequential Organization    X
               DDNAME=********,    Data Definition Name                X
               MACRF=(GM),         Indicate Get Move Mode              X
               RECFM=F,            Set Record Format for Fixed         X
               BLKSIZE=80,         Set the Blocksize                   X
               DCBE=LGRIDCBE       Data Control Block Extension
LGRSYSNL EQU   *-LGRSYSIN          Length Definition for DCB
LGRIDCBE DCBE  RMODE31=BUFF,       Specify Open to Get Buffs Above 16M X
               EODAD=LSN07600      Address of Routine upon End of Data
LGRDCBEL EQU   *-LGRIDCBE          Length Definition for Model DCBE
*
         CNOP  2,4                 Set-up for Half-Word Alignment
         DC    AL2(MODCBLEN)       Model Data Control Block Length
MODELDCB DCB   DSORG=PS,           Physical Sequential Organization    X
               DDNAME=********,    Data Definition Name                X
               MACRF=(GL),         Set Default for Get Locate Mode     X
               LRECL=*-*,          Set Placeholder for Record Length   X
               EXLST=*-*,          Set Placeholder DCB Exit List       X
               DCBE=*-*            Use Data Control Block Extension
MODCBLEN EQU   *-MODELDCB          Length Definition for the Model DCB
MODLDCBE DCBE  RMODE31=BUFF,       Specify Open to Get Buffs Above 16M X
               EODAD=*-*           Address of Routine Upon End-of-Data
MODCBELN EQU   *-MODLDCBE          Length Definition for Model DCBE
*
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
MODLOPEN OPEN (,OUTPUT),MF=L,MODE=31  DCB Open Macro Parameter List
MODLOPLN EQU  *-MODLOPEN           Length Definition for DCB Open List
MODLCLOS CLOSE (*-*),MF=L,MODE=31  DCB Close Macro Parameter List
MODLCLLN EQU  *-MODLCLOS           Length Definition for DCB Close List
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|DCB Exit Routine Stub For Copy to Below 16M Area for Amode-24 Entry|*
*+-------------------------------------------------------------------+*
*
         CNOP  0,8                 Set Doubleword Alignment, Zero Fill
MODLEXIT LLGFR R2,R15              Save Entry Point Address Before Use
         LLGT  R15,DCB@EXIT-DCB$EXIT(,R15) Adr DCB Abend Exit >16M Line
         LGHI  R3,(DCB$EXIT-LGRWK2II) Calculate Offset to LGRWK2II Addr
         LNR   R3,R3               Move Backwards to Point to Field
         LA    R2,0(R2,R3)         Get the Address to LGRWK2II Area
         OILL  R15,X'0001'         Set DCB Exit Routine Amode to 64-Bit
         BSM   R14,R15             Save AMODE and Branch to Real Exit
MODLXLEN EQU  *-MODLEXIT           Length Definition for Model DCB Exit
*
*+-------------------------------------------------------------------+*
*|     Logger Header Line Definitions for Output to //LGRECOUT DD    |*
*+-------------------------------------------------------------------+*
*
CARDLEN  EQU   80
HEADRLEN EQU   132
HEADRLNE DC    CL(HEADRLEN)' '
HEADER#1 DC    C'*/************************************************/'
HEADER#2 DC    C'*/      LOGGRASM Service Information Report      */'
HEADER#3 DC    C'*/      -----------------------------------      */'
HEADER#4 DC    C'*/************************************************/'
RULER#1  DC    C'//LGRSYSIN Input Cards'
RULER#2  DC    C'----------------------'
RULER#3  DC    C'....+....10...+....20...+....30...+....40...+....50...X
               +....60...+....70...+....80'
LG$REPRT DS    0CL29               Environmental Report Header Lines
LGSEPLN1 DC    CL29' '
LGRULER  DC    CL29' '
LGSEPLN2 DC    CL29' '
LGENVIRN DC    CL29'Program execution started on '
LGSEPLN3 DC    CL29' '
LGSYSNME DC    CL29'System Name.................:'
LGPLEXNM DC    CL29'Sysplex Name................:'
LGOSYSTM DC    CL29'Operating System............:'
LGSYSIPL DC    CL29'System was last IPL''ed on...:'
LGLOCLTM DC    CL29'Local Time Offset from UTC..:'
LGDFPROD DC    CL29'Data Facility Product.......:'
LGJESSYS DC    CL29'Job Entry Subsystem.........:'
LGCPMODL DC    CL29'CPU Model...................:'
LGJOBTYP DC    CL29'Job Type....................:'
LGJOBNME DC    CL29'Job Name....................:'
LGJOBNUM DC    CL29'Job Number..................:'
LG$ASID  DC    CL29'Address Space ID (ASID).....:'
LGPGMNME DC    CL29'Executing Program Name......:'
LGSTEPNM DC    CL29'Executing Job Step Name.....:'
LGMEMLMT DC    CL29'Memory Limit (MEMLIMIT).....:'
LGMEMSRC DC    CL29'MEMLIMIT Source.............:'
LGREGNSZ DC    CL29'Region Size.................:'
LGBL16AV DC    CL29'Below 16M Area Available....:'
LGBL16AL DC    CL29'Below 16M Maximum Allowed...:'
LGBL16US DC    CL29'Below 16M Area Being Used...:'
LGAB16AV DC    CL29'Above 16M Area Available....:'
LGAB16AL DC    CL29'Above 16M Maximum Allowed...:'
LGAB16US DC    CL29'Above 16M Area Being Used...:'
LGUSERID DC    CL29'User Id.....................:'
LGRPLENG EQU   *-LG$REPRT          Length of Environmental Report Area
LGREPRT# EQU   (*-LG$REPRT)/L'LG$REPRT ...No. of Report Header Lines
*
HEXCONV  DC    C'0123456789ABCDEF' Translation Table for Hex to Char
*
*+-------------------------------------------------------------------+*
*|                   Logger Service Error Messages                   |*
*+-------------------------------------------------------------------+*
*
         DC    0F                  Alignment
LGA01101 DC    C'LGA01101A Storage unavailable for Logger area. StorageX
                Obtain RC='
LGA01102 DC    C'LGA01102A Storage unavailable for options area. StoragX
               e Obtain RC='
LGA01103 DC    C'LGA01103A Unable to open data set for DDnme LGRECOUT.'
LGA01104 DC    C'LGA01104A Unknown operation code for logger option parX
               ameters, card input is ignored.'
LGA01105 DC    C'LGA01105A No operand supplied with logger option paramX
               eters, card input is ignored.'
LGA01106 DC    C'LGA01106A Invalid keyword for logger option parameter,X
                card input is ignored.'
LGA01107 DC    C'LGA01107A Unknown keyword specified for logger option X
               parameter, card input is ignored.'
LGA01108 DC    C'LGA01108A Recovery environment error. ESTAEX Return CoX
               de='
LGA01109 DC    C'LGA01109A Storage unavailable for work area. Storage OX
               btain RC='
*
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************|  L X A @ P C A  |**************************
**************************+-----------------+**************************
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|      P r o g r a m   C o n t r o l   D y n a m i c  A r e a       |*
*+-------------------------------------------------------------------+*
*
LAX@PCA  DSECT ,                   Program Control Area - (CPCA)
LAX@EYEC DS    CL32                Common Work Area Eye-Catcher
LAXSAVEA DS    D                   Our Save Area
LAX$WORK DS    10D                 General Work Area
LAXWORKD DS    D                   General Work Area
LAXPLIST DS    20FD                CALL Parameter List
LAXRETCD DS    F                   Return Code
LAXSVCOM DS    A                   Common Area Save Address
*
LAXSTORG DS    0D                  Getmained Storage Areas
LAXDYN01 DS    A(0,0)              Addr/Length Dynamic Area
LAXDYN02 DS    A(0,0)              Addr/Length Dynamic Area
LAXDYN03 DS    A(0,0)              Addr/Length Dynamic Area
LAXSTLEN EQU   (*-LAXSTORG)/8      Count of Entries For Freemain
LAXREPRT DS    CL(LGREPRT#*L'LGWLINE) ...Work Area for Report Lines
LAXLNGTH EQU   *-LAX@PCA           Length of Program Control Area
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*+-------------------------------------------------------------------+*
*|        L o g g e r   C o n t r o l   A r e a   -   (LCA )         |*
*+-------------------------------------------------------------------+*
*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
LGXRCIE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
*+-------------------------------------------------------------------+*
*|               z / O S   S y s t e m   D s e c t s                 |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         CVT      DSECT=YES,LIST=YES Communications Vector Table
         IHAASCB  DSECT=YES,LIST=YES  Address Space Control Block
         IHAASXB  DSECT=YES,LIST=YES  Address Space Cntrl Blk Extension
         IHAACEE                      Accessor Environment Element
         IHAECVT  DSECT=YES,LIST=YES  Communications Vector Table
         IHAIPA   DSECT=YES,IPA=YES   Initialization Parameter Area
         IHAPCCA  DSECT=YES        Physical Config Communications Area
         IHAPCCAT DSECT=YES        Physical CCA Vector Table
         IOSDSHID                  System Host Id Control Block
         IARRAX                    RSM Address Space Block Extension
         IRARMCT  DSECT=YES        System Resources Manager Cntl Table
         IRAQVS                    SysEvent Query Virtual Server Parms
         IHALDA                    VSM Local Data Area Control Block
         IEFTCT                    SMF Timing Control Table
         IEFASCTB                  Step Control Table Mapping
         IEFJSCVT                  Subsystem Communications Vector Tble
         IEFJESCT TYPE=DSECT,MNTBL=YES  JES Communication Table
         IEFJSSIB                  Subsystem Identification Block
         IEFSSVI  DSECT=YES        Subsys Version Info SSOB Extension
         IEFJSSOB ,                Subsystem Options Block Header
         DCBD     DSORG=PS,DEVD=DA Data Control Block
         IEZDEB   LIST=YES         Data Extent Block
         IHADSAB                   Data Set Association Block
         IHAQDB   DSECT=YES        Queue Descriptor Block
         IHAPSA   LIST=YES         Prefix Storage Area
         IKJTCB   LIST=YES         Job Task Control Block
         IEZJSCB                   Job Step Control Block
         IEFZB505 LOCEPAX=YES      EPA Mapping for SWA Manager
         IEFAJCTB                  JOB Control Table
         IEFJCTX                   JCT Extension
TIODSECT DSECT
         IEFTIOT1                  Task Input/Output Table
JFCB     DSECT *
         IEFJFCBN LIST=YES         Job File Control Block
         IHADFA                    Data Facilities Area
         END
