         PRINT OFF
         PRINT NOGEN
***********************************************************************
***********************************************************************
**   LOGGRASM                                                        **
***********************************************************************
***********************************************************************
*---------------------------------------------------------------------*
*                                                                     *
* Name:      LGCPLOGR                                                 *
*                                                                     *
* Type:      Assembler Copybook                                       *
*                                                                     *
* Version:   V1R1M17                                                  *
*                                                                     *
* Function:  LOGGRASM Assembler Program Source Setup Process          *
*                                                                     *
*            This copybook provides a series of standardized functions*
*            for z/Architecture Assembler source program entry and    *
*            exit. This copybook sets the return code and the reason  *
*            codes, generates in-line code for log points, defines    *
*            the entry and exit protocols, sets up programs to be     *
*            re-enterant, establishes program addressability, and     *
*            defines a Logger Control Area (LCA). This process does   *
*            not require any MF=E or MF=L generations of the macros   *
*            contained herein to maintain re-enterant status.         *
*                                                                     *
* Method of Access:                                                   *
*            COPY LGCPLOGR. Use the COPY Assembler directive. Source  *
*            library in which the copybook component resides must be  *
*            available to the assembler at assembly time (i.e.,       *
*            //SYSLIB DD)                                             *
*                                                                     *
* Storage Attributes:                                                 *
*   SubPool:      SP 3                                                *
*   Key:          User                                                *
*   Residency:    Below 16M Line                                      *
*   Data Space:   No                                                  *
*                                                                     *
* Frequency: Included at Assembly using COPY directive                *
*                                                                     *
* Restrictions:                                                       *
*   z/Architecture Mode                                               *
*                                                                     *
* Dependencies:                                                       *
*   When LOG=OFF: (None)                                              *
*   When LOG=ON   Object......LGMHDCBX (Included at Link-Edit)        *
*                 Object......LGMHESTA (Included at Link-Edit)        *
*                 Object......LGMHLRCB (Included at Link-Edit)        *
*                 Object......LGMHLRCE (Included at Link-Edit)        *
*                 Object......LGMHLRCI (Included at Link-Edit)        *
*                 Object......LGMHLRCT (Included at Link-Edit)        *
*                 Object......LGMHPSTG (Included at Link-Edit)        *
*                 Object......LGMHRTRY (Included at Link-Edit)        *
*                 Object......LGMHWTCH (Included at Link-Edit)        *
*                                                                     *
*                 Object library containing above components must     *
*                 be available to the Binder at link-edit time when   *
*                 LOG=ON (i.e., //SYSLIB DD)                          *
*                                                                     *
* Eye-Catcher: N/A                                                    *
*   Offset:  N/A                                                      *
*   Length:  N/A                                                      *
*                                                                     *
* Change Activity:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Fix      V1R1M17 20120721 Corrected IEW2456E UNRESOLVED SYMBOL @@KHF*
*                           error from Binder When User Specified@@KHF*
*                           LOG=OFF to Bypass Logger Services.   @@KHF*
* Change                    Added Support for the Buffering of   @@KHF*
*                           Log Records to Above-the-Bar Storage.@@KHF*
* Change                    Added Support for 20-Bit Displacement@@KHF*
*                           to Allow 1 Megabyte Addressability to@@KHF*
*                           Fields Specified by User in Logpoint.@@KHF*
* Change   V1R1M16 20120127 Changes to Support Reduced Footprint @@KHF*
*                           Through LOCTR for #LGPOINT Data Area.@@KHF*
* Update   V1R1M15 20110930 Update VV.RR.MM stats for Fix Pack 15@@KHF*
* Change   V1R1M14 20110423 Added New Format-7 Save Area Mapping @@KHF*
*                           Added Equates for Access Registers   @@KHF*
* Update   V1R1M13 20110108 Added Support for Display of the CPU @@KHF*
*                           State(Supervisor/Problem), PSW Key,  @@KHF*
*                           and Addressing Mode at Program Entry.@@KHF*
* Change                    Reduced Each Logpoint Footprint by 8 @@KHF*
*                           Bytes and Reduced the LCA Prefix Area@@KHF*
*                           for Each RSECT by 16 bytes.          @@KHF*
* Change   V1R1M12 20100306 Default Size of Initial Stacked LCA  @@KHF*
*                           Increased from 8K to 32K.            @@KHF*
* Update   V1R1M11 20091023 Update VV.RR.MM stats for Fix Pack 11@@KHF*
* Update   V1R1M10 20090523 Update VV.RR.MM stats for Fix Pack 10@@KHF*
* Fix      V1R1M09 20090110 Condition Code from PSW Not Preserved@@KHF*
* Update   V1R1M08 20081010 Updated VV.RR.MM stats for Fix Pack 8@@KHF*
* Update   V1R1M07 20080524 Updated VV.RR.MM stats for Fix Pack 7@@KHF*
* Update   V1R1M06 20080223 Updated VV.RR.MM stats for Fix Pack 6@@KHF*
* Fix      V1R1M05 20080112 Corrected RMOD= Default Processing   @@KHF*
* Fix      V1R1M04 20071104 S0C4-38 at Pgm Exit When in Amode-64 @@KHF*
* Fix      V1R1M04 20071104 Flag Byte Not Reset on a Storage List@@KHF*
* Fix      V1R1M03 20070701 S0C9 When Attempting Retry From Abend@@KHF*
* Fix      V1R1M03 20070701 Log Shows Incorrect Entry Pnt Address@@KHF*
* Fix      V1R1M02 20070615 LPGMEXIT Error Processing Format-4 SA@@KHF*
* Update   V1R1M01 20070512 Add Support For Log Rcrd Trim Option @@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
***********************************************************************
*                                                                     *
* Description of Parameters:                                          *
* --------------------------                                          *
*                                                                     *
* "LPGMNTRY" Description:                                             *
*                                                                     *
* Label   LPGMNTRY Ýparameters¨                                       *
*                                                                     *
*     Label                                                           *
*             Represents the label name provided on the LPGMNTRY entry*
*             coded in program. It is used to provide the RSECT name  *
*             for a program. It is a required parameter.              *
*                                                                     *
*     TYPE={MAIN | SUB}                                               *
*             Specifies whether this is a user's main program for     *
*             which the initial Logger Control Area (LCA) must be     *
*             be acquired, or a user subprogram invokation where the  *
*             called program is to utilize LCA storage supplied from  *
*             the caller if sufficient storage is available. The      *
*             default value is SUB.                                   *
*                                                                     *
*     AMODE={24 | 31 | 64}                                            *
*             Specifies the user program addressing mode. This is an  *
*             optional parameter, and the default value is '31'.      *
*                                                                     *
*     RMODE={24 | ANY | 31}                                           *
*             Specifies the user program residence mode. The          *
*             specification is mapped to the following values:        *
*             24 => 24; ANY => 31. This is an optional parameter,     *
*             and the default value is '31'.                          *
*                                                                     *
*     BASE=(RxÝ,Rx¨...)                                               *
*             Specifies the base register(s) to be established for    *
*             user program addressability. Any number of registers    *
*             may be specified in the sublist. If multiple base       *
*             registers are specified, enclose the list in parentheses*
*             with the register values separated by a comma. The      *
*             listed registers are loaded and declared as bases in the*
*             order specified. The leftmost listed register is loaded *
*             with the lowest address. The default base value is      *
*             BASE=(12).                                              *
*                                                                     *
*     LCAXTRA=(RxÝ,Rx¨...)                                            *
*             Specifies any extra base register(s) to address the     *
*             user program's dynamic storage area (LCA). R13 is always*
*             used as the first base register for the Logger Control  *
*             Area (LCA). This parameter may be required in order to  *
*             add extra base registers if your LCA addressability is  *
*             larger than 4K. Any number of registers may be specified*
*             in a sublist. If multiple base registers are specified, *
*             enclose the list in parentheses with registers values   *
*             separated by a comma. The listed registers are loaded   *
*             and declared as base registers to the LCA in the order  *
*             specified. This parameter is optional, and there is no  *
*             default for this parameter.                             *
*                                                                     *
*     STORAGE=number                                                  *
*             This parameter is used to specify the amount of storage *
*             to be obtained for the initial user's Logger Control    *
*             Area (LCA) stack. The number is specified in increments *
*             of 1024 bytes or 1K. However, the size requested will be*
*             rounded up to the next 4K boundary before the storage is*
*             obtained. The main program may use this parameter to    *
*             request a larger dynamic storage area for the LCA stack *
*             if the default is deemed insufficient in size for all   *
*             the anticipated called programs in the chain. This is an*
*             optional parameter, and the default value is '32'.      *
*                                                                     *
*     LCAPFX=label                                                    *
*             Represents the label provided for naming the user's     *
*             Logger Control Area (LCA) prefix area. This is a        *
*             required parameter.                                     *
*                                                                     *
*     LCADSECT={YES | NO}                                             *
*             This parameter indicates whether to generate only the   *
*             Logger Control Area dummy section area. Used when the   *
*             requirement is to create only a map of the Program      *
*             Control Area (LCA). It is an optional parameter, and    *
*             the default value is 'NO'.                              *
*                                                                     *
*     LINKRTRN={BR  | BSM}                                            *
*             This parameter indicates the return linkage instruction *
*             to generate upon exit from a program or subprogram. If  *
*             a main program or called program entry was performed    *
*             by means of the BRANCH AND SAVE AND SET MODE (BASSM)    *
*             instruction, then the BRANCH AND SET MODE (BSM) with an *
*             R1 field of zeros is intended to be the standard return *
*             instruction. If this is the case, then specify BSM for  *
*             the LINKRTRN= parameter in order to have the proper     *
*             return linkage generated (i.e., BSM  R0,R14). This      *
*             parameter is optional, and the default value is 'BR'.   *
*                                                                     *
*     LOG={ON | OFF}                                                  *
*             This parameter indicates whether logging is enabled and *
*             whether to generate log points. The default value is    *
*             'ON'.                                                   *
*                                                                     *
*     LOGOUT={PRNT | BUFR | BUF64}                                    *
*             When logging is enabled this parameter indicates whether*
*             log records are to be printed to the output data set at *
*             the time they are generated, or if the log records are  *
*             to be written to a buffer area where printing of the    *
*             log records to the output data set is deferred until    *
*             user program end. Specifying 'BUFR' for the LOGOUT      *
*             parameter results in the write of log records to a      *
*             buffer area above-the-line which will avoid log record  *
*             I/O during user program execution until end of the      *
*             user's program. Specifying 'BUF64' for the LOGOUT       *
*             parameter results in the write of log records to a      *
*             buffer area in above-the-bar memory objects using IARV64*
*             services to obtain storage. 'BUFR' and 'BUF64' are both *
*             optional paramaters and are mutually exclusive. The     *
*             default value is 'PRNT'.                                *
*                                                                     *
*     LOGTRIM={YES | NO}                                              *
*             When logging is enabled this parameter when set to YES  *
*             indicates that the card ruler header, the input card    *
*             images, the environmental report, and TCB/timestamp are *
*             not to be included in the log output. The default value *
*             is 'NO'.                                                *
*                                                                     *
*                                                                     *
*     COPY@RT={YES | NO}                                              *
*             This parameter indicates whether to generate an         *
*             eyecatcher notice as part of program entry. This is an  *
*             optional parameter, and the default value is 'NO'.      *
*                                                                     *
*                                                                     *
* "LPGMEXIT" Description:                                             *
*                                                                     *
* Label   LPGMEXIT Ýparameters¨                                       *
*                                                                     *
*     Label                                                           *
*             Represents the label name provided on the LPGMEXIT entry*
*             coded in program. It is optional, and if coded a label  *
*             will be generated which may be branched to. This entry  *
*             builds the program exit protocol.                       *
*                                                                     *
*     RC=Ýaddr¨                                                       *
*        Ý(Rx)¨                                                       *
*             Represents the program return code value to be passed   *
*             to the caller in R15. This may be specified as a program*
*             label for a fullword containing the return code, or a   *
*             register value enclosed in parentheses. If the parameter*
*             is omitted, R15 will be set to binary zeros.            *
*                                                                     *
*     RS=Ýaddr¨                                                       *
*        Ý(Rx)¨                                                       *
*             Represents the program reason code value to be passed   *
*             to the caller in R0. This may be specified as a program *
*             label for a fullword containing the reason code, or a   *
*             register value enclosed in parentheses. If the parameter*
*             is omitted, R0 will be set to binary zeros.             *
*                                                                     *
*                                                                     *
* "LPGMSUBE" Description:                                             *
*                                                                     *
* Label   LPGMSUBE Ýparameters¨                                       *
*                                                                     *
*     Label                                                           *
*             Represents the label name provided on the LPGMSUBE entry*
*             coded in program. This parameter is required as it      *
*             defines the name of the subroutine.                     *
*                                                                     *
*     RETRN={Rx}                                                      *
*             Specifies the general purpose register to use for the   *
*             return address. The return address is the address of the*
*             instruction following the branch instruction in storage.*
*             When the BRANCH AND SAVE instruction (BAS and BASR) is  *
*             used for linkage to subroutines defined with LPGMSUBE   *
*             for entry, you may specify a register that is to be used*
*             for the return address. This is an optional parameter,  *
*             and the default is 'R14'.                               *
*                                                                     *
*     Note:                                                           *
*             Additional parameters which may be specified with the   *
*             LPGMSUBE entry are the same as those available to the   *
*             #LGPOINT entry. Refer to #LGPOINT for a description.    *
*                                                                     *
*                                                                     *
* "LPGMSUBX" Entry Description:                                       *
*                                                                     *
* Label   LPGMSUBX Ýparameters¨                                       *
*                                                                     *
*     Label                                                           *
*             Represents the label name provided on the LPGMSUBX entry*
*             coded in program. This parameter is required as it      *
*             defines the name of the subroutine exit.                *
*                                                                     *
*     Note:                                                           *
*             Additional parameters which may be specified with the   *
*             LPGMSUBX entry are the same as those available to the   *
*             #LGPOINT entry. Refer to #LGPOINT for a description.    *
*                                                                     *
*                                                                     *
* "LCA" Description:                                                  *
*                                                                     *
* Label   LCA      {DEFINE | DEFEND}                                  *
*                                                                     *
*     Label                                                           *
*             Represents the label name provided on the LCA entry     *
*             coded in program source. This parameter is optional.    *
*                                                                     *
*     DEFINE                                                          *
*             DEFINE indicates this is the beginning of the user's    *
*             Logger Control Area, and that the LCA prefix area must  *
*             be generated. This is a Getmain'ed storage area below   *
*             the line addressable by R13, and to be used by the user *
*             program as a work area. It is here where you may specify*
*             individual fields defined via DS instructions with your *
*             own labels.                                             *
*                                                                     *
*     DEFEND                                                          *
*             DEFEND indicates this is the end of the Logger Control  *
*             Area.                                                   *
*                                                                     *
***********************************************************************
*
         MACRO                     Set Start of Program Entry Macro
&NAME    LPGMNTRY &TYPE=SUB,       Indicate Program Type (MAIN/SUB)    X
               &AMOD=31,           Program Default Addressing Mode 31  X
               &RMOD=31,           Program Default Resident Mode 31    X
               &BASE=(12),         Default Program Base Register(s)    X
               &LCAXTRA=,          To Specify Extra LCA Base Registers X
               &STORAGE=32,        Default Size of Initial Stacked LCA X
               &LCAPFX=LCA,        Logger Control Area Label Prefix    X
               &LCADSECT=NO,       Lgr Cntl Area = YES-> Gen Dsect OnlyX
               &LINKRTRN=,         Program Linkage Return (BR,BSM)     X
               &LOG=ON,            Logging - To Generate Logger RecordsX
               &LOGOUT=PRNT,       Logging - To Print Log Records      X
               &LOGTRIM=NO,        Logging - To Not Trim Log Records   X
               &REG=ALL,           Logging - To Print All Registers    X
               &MSG=,              Logging - A User Message to Print   X
               &COMPRESS=YES,      Logging - COMPRESS Option           X
               &PARMS=,            Logging - Input Parameter Lengths   X
               &COPY@RT=NO         Do Not Generate Copyright Statement
.*
.**********************************************************************
.*  LPGMNTRY - Define the Entry Protocol for a User Program           *
.**********************************************************************
.*
         GBLC  &LGRSHW             SHOW= String for Logger Log Point
         GBLC  &LGRNAME            RSECT Name of User Program
         GBLC  &LOGGR              ON/OFF Generate Logger Output Rcds
         GBLC  &PGMTYP             Establish the Program RSECT Type
         GBLC  &LGRPTYP            Program Log Records Printing Type
         GBLC  &ADMODE             Program Addressing Mode
         GBLC  &LNKR               Return Linkage Branch Instruction
         GBLC  &PX,&PXD            Logger Control Area Prefix Value
         GBLC  &PM                 Set Flag Byte Variables
         GBLC  &LBLPGE0            Label for User Program Entry
         GBLC  &LBLPGE1            Label for User Program Entry
         GBLC  &LBLPGE2            Label for User Program Entry
         GBLC  &LBLPGX1            Label for User Program Exit
         GBLB  &REGDEF             Registers Have Been Defined
         LCLC  &USING              USING Statement Build Area
         LCLC  &START              Label For User Program Housekeeping
         LCLC  &LBLLCAL            Label For Logger Control Area Leng
         LCLC  &LBL1,&LBL2         Establish Generic Labels
         LCLC  &LBL3,&LBL4         Establish Generic Labels
         LCLC  &LBL5,&LBL6         Establish Generic Labels
         LCLC  &LBL7,&LBL8         Establish Generic Labels
         LCLC  &A,&B,&C            Set General Work Variables
         LCLC  &LGRTPNT            Name of Logger Log Point
         LCLA  &DCNT               Count of Program PARMS= Sublist
         LCLA  &X,&Y,&Z            Set General Work Variables
         LCLA  &I,&J               Set General Work Variables
&LOGGR   SETC  '&LOG'              Log Point Indicator for #LOGPNT
&PGMTYP  SETC  '&TYPE'             Program Type Indicator for #LOGPNT
&LGRPTYP SETC  '&LOGOUT'           Program Log Output Processing Type
&ADMODE  SETC  '&AMOD'             Program Addressing Mode Indicator
&LNKR    SETC  '&LINKRTRN'         Return Linkage Instruction Type
.*
         AIF   ('&COPY@RT' NE 'YES').LGCF100
         LCLC  &LGRPVER,&LGRPREL,&LGRPMOD Version/Release/Modification
         LCLC  &LGRPVRM            Set Program Version/Release/ModLvl
         LCLC  &AMODE              Addressing Mode of User Program
         LCLC  &RMODE              Resident Mode of User Program
         LCLB  &BATONLY            Program Batch Invokation-Not Ispf
.*
&LGRPVER SETC  'V1'                Logger Program Version Number
&LGRPREL SETC  'R1'                Logger Program Release Number
&LGRPMOD SETC  'M17'               Logger Program Modification Levl
&LGRPVRM SETC  '&LGRPVER.&LGRPREL..&LGRPMOD'  Set Version/Release/Mod
&CPYRITE SETC  '2008,2012'         Set the Program Copyright Year
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&AMODE   SETC  '31'                Establish Default Addressing Mode
&RMODE   SETC  '31'                Establish Default Residence Mode
.*
.LGCF100 ANOP                      Continue with Next Source Statement
         AIF   ('&LCAPFX' EQ '').MNOTE5 Error If No LCA Prefix Name
&PX      SETC  '&LCAPFX'           Save as Global Symbol for this RSECT
&PXD     SETC  'LCA'               Set Program LCA Default Dsect Name
         AIF   ('&LCAPFX' EQ 'LCA').LGCF120  A Name Specified in Pgm?
&PXD     SETC  'LCA&PX'            Yes, Set Pgm Specified Dsect Name
.LGCF120 ANOP
         AIF   ('&NAME' EQ '').MNOTE1  Error If No RSECT Name Specified
&LGRNAME SETC  '&NAME'             Set Program Control Section Name
         AIF   (('&TYPE' NE 'MAIN') AND ('&TYPE' NE 'SUB')).MNOTE2
         AIF   ('&LCADSECT' EQ 'YES').LGCF880   ..Build LCA Dummy Only?
.*
&NAME    RSECT ,                   Define R/O Control Section
.LGCF200 ANOP                      Define Addressing and Residence Mode
         AIF   ('&AMOD' EQ '' AND '&RMOD' EQ '').LGCF240
         AIF   (('&AMOD' EQ '24') AND ('&RMOD' EQ '24' OR '&RMOD'      X
               EQ '')).LGCF280     Set Rmode for 24 and Amode for 24
         AIF   (('&AMOD' EQ '31') AND ('&RMOD' EQ 'ANY' OR '&RMOD'     X
               EQ '31' OR '&RMOD' EQ '')).LGCF240  Rmode 31 Amode 31
         AIF   (('&AMOD' EQ '31') AND ('&RMOD' EQ '24' OR '&RMOD'      X
               EQ '')).LGCF260     Set Rmode for 24 and Amode for 31
         AIF   (('&AMOD' EQ '64') AND ('&RMOD' EQ 'ANY' OR '&RMOD'     X
               EQ '31' OR '&RMOD' EQ '')).LGCF220  Rmode 31 Amode 64
         AIF   (('&AMOD' EQ '64') AND ('&RMOD' EQ '24' OR '&RMOD'      X
               EQ '')).LGCF210     Set Rmode for 24 and Amode for 64
         AGO   .MNOTE3             Error If Amode/Rmode Conflict Exists
.LGCF210 ANOP
&NAME    RMODE 24                  Residence Mode Below the 16Mb Line
&NAME    AMODE 64                  Addressing Mode is for 64-Bit
         AGO   .LGCF300            Branch to Setup Temp Addressability
.LGCF220 ANOP
&NAME    RMODE 31                  Residence Mode Above the 16Mb Line
&NAME    AMODE 64                  Addressing Mode is for 64-Bit
         AGO   .LGCF300            Branch to Setup Temp Addressability
.LGCF240 ANOP
&NAME    RMODE 31                  Residence Mode Above the 16Mb Line
&NAME    AMODE 31                  Addressing Mode is for 31-Bit
         AGO   .LGCF300            Branch to Setup Temp Addressability
.LGCF260 ANOP
&NAME    RMODE 24                  Residence Mode Below the 16Mb Line
&NAME    AMODE 31                  Addressing Mode is for 31-Bit
         AGO   .LGCF300            Branch to Setup Temp Addressability
.LGCF280 ANOP
&NAME    RMODE 24                  Residence Mode Below the 16Mb Line
&NAME    AMODE 24                  Addressing Mode is for 24-Bit
         AGO   .LGCF300            Branch to Setup Temp Addressability
.*
.LGCF300 ANOP
&LBLPGE0 SETC  'PE0&SYSNDX'        Generate a User Program Entry Label
&LBLPGE1 SETC  'PE1&SYSNDX'        Generate a User Program Entry Label
&LBLPGE2 SETC  'PE2&SYSNDX'        Generate a User Program Entry Label
&LBLPGX1 SETC  'PX3&SYSNDX'        Generate a User Program Exit Label
         AIF   ('&AMOD' EQ '24' OR '&AMOD' EQ '31').LGCF310  24/31-Bit?
         SYSSTATE AMODE64=YES,ARCHLVL=2    Establish 64-Bit Environment
.LGCF310 ANOP
         AIF   ('&TYPE' EQ 'MAIN').LGCF320     Check If a Main Program?
&LBLPGE0 STMG  R14,R12,&PX.F64R14-&PX.SAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         AGO   .LGCF330            Branch to Setup Temp Addressability
.LGCF320 ANOP
&LBLPGE0 STM   R14,R12,&PX.SA_R14-&PX.SAVE(R13) Save Caller's Registers
         CNOP  0,4                 Ensure Fullword Boundary Alignment
.LGCF330 ANOP
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
&LBLPGE1 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
&START   SETC  'PGE&SYSNDX'        Generate a Program Branch Label
&LBLPGE2 BRU   &START              Branch Around Copyright Notice Data
&LBL1    SETC  'PGP&SYSNDX'        Generate a Branch Label
         DC    AL1(&LBL1-*)        Set as Length for SYSUDUMP Display
         DC    CL32'&LGRNAME'      Set Eyecatcher for the Program Name
         AIF   ('&COPY@RT' NE 'YES').LGCF340 Generate CopyRight Notice?
         DC    C' (LOGR-&LGRPVRM)' Set Program Version.Rlse.ModLvl
.LGCF340 ANOP
         DC    C' &SYSDATC &SYSTIME '  Set Assembly Date & Time Stamp
&LBL1    EQU   *
         AIF   ('&COPY@RT' NE 'YES').LGCF360
         DC    C' Copyright &CPYRITE (C)' ...Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
.LGCF360 ANOP
       SPLEVEL SET=6               Set for OS/390 R2 or Above (z/OS+)
         DC    40S(*)              Define a User Program Patch Area
&LBLLCAL SETC  'PCL&SYSNDX'        Generate a Branch Label
&LBLLCAL DC    A(&PX.L)            Define the Length of LCA Required
*
&START   DS    0H
         AIF   ('&TYPE' NE 'MAIN').LGCF380     Check If a Main Program?
         SRLG  R0,R0,32            High Half of R0 into Low Half of R0
         LR    R3,R0               High Half of R0 in Low Half of R3
         SRLG  R1,R1,32            High Half of R1 into Low Half of R1
         LR    R4,R1               High Half of R1 in Low Half of R4
         SRLG  R2,R2,32            High Half of R2 into Low Half of R2
         LR    R5,R2               High Half of R2 in Low Half of R5
         SRLG  R14,R14,32          High Half of R14 into Low Half R15
         LR    R6,R14              High Half of R14 in Low Half of R6
         SRLG  R15,R15,32          High Half of R15 into Low Half R15
         LR    R7,R15              High Half of R15 in Low Half of R7
.LGCF380 ANOP
&LBL1    SETC  'PG1&SYSNDX'        Generate Current Branch Label #1
&LBL2    SETC  'PG2&SYSNDX'        Generate Current Branch Label #2
&LBL3    SETC  'PG3&SYSNDX'        Generate Current Branch Label #3
&LBL4    SETC  'PG4&SYSNDX'        Generate Current Branch Label #4
&LBL5    SETC  'PG5&SYSNDX'        Generate Current Branch Label #5
&LBL6    SETC  'PG6&SYSNDX'        Generate Current Branch Label #6
&LBL7    SETC  'PG7&SYSNDX'        Generate Current Branch Label #7
&LBL8    SETC  'PG8&SYSNDX'        Generate Current Branch Label #8
         USING &PXD,R13            Establish Addressability to LCA
         AIF   ('&TYPE' EQ 'MAIN').LGCF420 ...Branch If a Main Program
*
*+-------------------------------------------------------------------+*
*|Acquire Logger Control Area (LCA) Storage from Caller if Available |*
*+-------------------------------------------------------------------+*
*
.LGCF400 ANOP                      Continue with Next Source Statement
         CLC   0(4,13),&PX.P701    Caller Have a Logger Control Area?
         BRNE  &LBL1               No  => Acquire Dynamic Storage (LCA)
         CLC   &PX.RESID,&PX.P501  Will Our LCA Fit in This One?
         BRL   &LBL1               No  => Acquire Dynamic Storage (LCA)
         LLGT  R1,&PX.NEXTA        Get Our Save Area From the Caller
         SLGR  R2,R2               Clear for Byte Insertion Process
         ICM   R2,B'0111',&PX.RESID ...Get the Caller's Residual Space
         SLGF  R2,&PX.P301         Get the New Residual Value
         BRU   &LBL2               Branch to Initialize Program LCA
.LGCF420 ANOP                      Continue with Next Source Statement
*
*+-------------------------------------------------------------------+*
*|    Getmain Our Logger Control Area (LCA) Storage If Required      |*
*+-------------------------------------------------------------------+*
*
&LBL1    DS    0H
         LLGF  R2,&PX.P301         Get the Length of LCA Dynamic Area
         A     R2,&PX.P3L8         Add for Our Requested Storage Area
         LA    R2,4095(,R2)        Add Another 4K to Establish Alignmnt
         SRL   R2,12               Shift Right To Push Off Suffix Area
         SLL   R2,12               Round Upwards To a 4K Page Boundary
         LGR   R0,R2               Set R0 for Size for Dynamic Acquire
         AIF   ('&AMOD' EQ '24').LGCF440 Is Our Addressing Mode 24-Bit?
       STORAGE OBTAIN,             Issue Storage Request for the LCA   X
               COND=NO,            Request Has Unconditional CompletionX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=(24,&AMOD)      Dynamic Area Anywhere Below the Line
         AGO   .LGCF450            Branch To Process LCA Ownership
.LGCF440 ANOP
       STORAGE OBTAIN,             Issue Storage Request for the LCA   X
               COND=NO,            Request Has Unconditional CompletionX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=PAGE,         Alignment Is On a 4K Page Boundary  X
               LOC=24              Central and Virt Storage Below 16Meg
.LGCF450 ANOP
         SLGF  R2,&PX.P301         Get the Residual Value
         AIF   ('&TYPE' EQ 'MAIN').LGCF460  Processing a Main Program?
         ICM   R2,B'1000',&PX.P601 Indicate the Owner of Storage
         AGO   .LGCF470            Branch to Initialize Program LCA
.LGCF460 ANOP
         ICM   R2,B'1000',&PX.P611   Indicate Pgm LCA Owner & MainPgm
.LGCF470 ANOP                      Continue to Initialize Program LCA
         CHI   R15,20              Area Returned with Storage Cleared?
         BRNE  &LBL2               No  => Branch to Init Storage Area
         AIF   ('&TYPE' EQ 'MAIN').LGCF480    Check If a Main Program?
         STG   R1,&PX.F64FWD-&PX.SAVE(,R13)   Our Addr in Caller's LCA
         AGO   .LGCF490            Branch to Initialize Program LCA
.LGCF480 ANOP                      Continue to Initialize Program LCA
         ST    R1,&PX.SA_FWD-&PX.SAVE(,R13)   Our Addr in Caller's LCA
.LGCF490 ANOP                      Continue to Initialize Program LCA
         BRU   &LBL3               Branch to Perform 'LCA' Setup
&LBL2    DS    0H
         AIF   ('&TYPE' EQ 'MAIN').LGCF500    Check If a Main Program?
         STG   R1,&PX.F64FWD-&PX.SAVE(,R13)   Our Addr in Caller's LCA
         AGO   .LGCF510            Branch to Initialize Program LCA
.LGCF500 ANOP                      Continue to Initialize Program LCA
         ST    R1,&PX.SA_FWD-&PX.SAVE(,R13)   Set Forward Chain Pointer
.LGCF510 ANOP                      Continue to Initialize Program LCA
         LGR   R0,R1               Get the Starting Address of LCA
         LLGF  R1,&PX.P301         Set the Dynamic Area Length of LCA
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear the Entire LCA Dynamic Area
*
*+-------------------------------------------------------------------+*
*| Determine Address for Next Available Area In LCA, Calculate the   |*
*| Area Remaining in the LCA, And Calculate An End Pointer for the   |*
*| Current Area in the LCA.                                          |*
*+-------------------------------------------------------------------+*
*
&LBL3    DS    0H
         AIF   ('&TYPE' EQ 'MAIN').LGCF520    Check If a Main Program?
         LG    R1,&PX.F64FWD-&PX.SAVE(,R13)   Get Addr of Current LCA
         AGO   .LGCF530            Branch to Initialize Program LCA
.LGCF520 ANOP                      Continue to Initialize Program LCA
         L     R1,&PX.SA_FWD-&PX.SAVE(,R13)   Get Addr of Current LCA
.LGCF530 ANOP                      Continue to Initialize Program LCA
         ST    R2,&PX.SRSID-&PXD.(,R1) ...Set Residual Storage Amount
         LLGT  R14,16              Get the Address of the CVT
         L     R14,0(R14)          Get the TCB New/Old Pointers
         L     R14,4(,R14)         Get Address of Current TCB (PSATOLD)
         ST    R14,&PX.TCBAD-&PXD.(,R1)  Save Address of Current TCB
         L     R14,&PX.P301        Get the Length of Current LCA
         LA    R14,0(R14,R1)       Add Length to Current LCA Start Addr
         ST    R14,&PX.NEXTA-&PXD.(,R1)  Save Adr to Next Available LCA
         L     R14,&PX.P311        Get the Offset to LCA End Pointer
         LA    R14,0(R14,R1)       Calculate Address of LCA End Pointer
         ST    R14,0(,R14)         Set Addr for Overlay Check on Exit
         MVC   &PX.LGPTS-&PXD.(L'&PX.LGPTS,R1),&PX.P6L6 .NOP Log Events
         AIF   ('&LOGGR' EQ 'OFF').LGCF590  No Carry-Over If No Logging
         AIF   (('&TYPE' EQ 'MAIN') AND ('&LOGTRIM' EQ 'YES')).LGCF540
         AGO   .LGCF550            Check For Logger Record Buffering
.LGCF540 ANOP                      Continue with Next Source Statement
         OI    &PX.WFLAG-&PXD.(R1),&PX.WTRIM    Trim Logger Records
.LGCF550 ANOP                      Continue with Next Source Statement
         AIF   (('&TYPE' EQ 'MAIN') AND ('&LOGOUT' EQ 'BUFR')).LGCF560
         AIF   (('&TYPE' EQ 'MAIN') AND ('&LOGOUT' EQ 'BUF64')).LGCF570
         AIF   ('&TYPE' NE 'MAIN').LGCF580      Check If a Main Program
         OI    &PX.WFLAG-&PXD.(R1),&PX.WPRNT    Immediately Print Rcrds
         AGO   .LGCF580            Check For Logger Control Area
.LGCF560 ANOP                      Continue with Next Source Statement
         OI    &PX.WFLAG-&PXD.(R1),&PX.WBUFR    Write Rcrds to Buffer
         AGO   .LGCF580            Check For Logger Control Area
.LGCF570 ANOP                      Continue with Next Source Statement
         OI    &PX.WFLAG-&PXD.(R1),&PX.WBU64    Write Rcrds to Buffer
.LGCF580 ANOP                      Check For Logger Control Area
         CLC   0(4,13),&PX.P701    Caller Have a Logger Control Area?
         BRE   &LBL4               Yes => Branch to Carry-Over Storage
         BRU   &LBL5               No  => Branch to Complete Save Area
&LBL4    DS    0H
         MVC   &PX.LGCOB-&PXD.(L'&PX.LGCOB,R1),&PX.LGCOB    Carry-Over
.LGCF590 ANOP                      Continue with Next Source Statement
*
*+-------------------------------------------------------------------+*
*| Finish Program Entry Linkage For Our Save Area in the Prefix      |*
*| Section of the Logger Control Area (LCA).                         |*
*+-------------------------------------------------------------------+*
*
&LBL5    DS    0H
         AIF   ('&TYPE' EQ 'MAIN').LGCF600    Check If a Main Program?
         STG   R13,&PX.F64BCK-&PX.SAVE(,R1)   Set Back Chain Pointer
         MVC   &PX.F64F4A-&PX.SAVE(4,R1),&PX.P7F4   Set Format-4 ID
         LGR   R2,R1               Get Addr of Logger Cntl Area-(LCA)
         CLC   &PX.F64F4A-&PX.SAVE(4,R13),&PX.P7F4 Check if Format-4 ID
         BRE   &LBL6               Yes => Branch to Restore Parm Regs
         CLC   &PX.S64F5A-&PX.SAVE(4,R13),&PX.P7F5 Check if Format-5 ID
         BRE   &LBL6               Yes => Branch to Restore Parm Regs
         LM    R14,R1,&PX.SA_REG-&PX.SAVE(R13)  Restore Parameter Regs
         BRU   &LBL7
&LBL6    DS    0H
         LMG   R14,R1,&PX.S64R14-&PX.SAVE(R13)  Restore Parameter Regs
&LBL7    DS    0H
         LGR   R13,R2              Put Our Save Area Address into R13
         LMD   R2,R6,&PX.P211,&PX.P211  Fill Incoming Regs R2 thru R6
         LMD   R7,R11,&PX.P211,&PX.P211 Fill Incoming Regs R7 thru R11
         AGO   .LGCF610            Check For Logger Control Area
.LGCF600 ANOP                      Continue with Next Source Statement
         STG   R13,&PX.S64BCK-&PX.SAVE(,R1)   Set Back Chain Pointer
         STMH  R3,R14,&PX.H64R03-&PX.SAVE(R1) High Half of R3-R14
         ST    R3,&PX.H64R00-&PX.SAVE(,R1) Save High Half Caller's R0
         ST    R4,&PX.H64R01-&PX.SAVE(,R1) Save High Half Caller's R1
         ST    R5,&PX.H64R02-&PX.SAVE(,R1) Save High Half Caller's R2
         ST    R6,&PX.H64R14-&PX.SAVE(,R1) Save High Half Caller's R14
         ST    R7,&PX.H64R15-&PX.SAVE(,R1) Save High Half Caller's R15
         MVC   &PX.S64F5A-&PX.SAVE(4,R1),&PX.P7F5   Set Format-5 ID
         LGR   R2,R1               Get Addr of Logger Cntl Area-(LCA)
         LM    R14,R1,&PX.SA_REG-&PX.SAVE(R13)  Restore Parameter Regs
         LGR   R13,R2              Put Our Save Area Address into R13
         LMD   R2,R6,&PX.P211,&PX.P211  Fill Incoming Regs R2 thru R6
         LMD   R7,R11,&PX.P211,&PX.P211 Fill Incoming Regs R7 thru R11
*
*+-------------------------------------------------------------------+*
*|Establish Addressability for Control Section (RSECT) and Establish |*
*|Logger Control Area (LCA) Addressability                           |*
*+-------------------------------------------------------------------+*
*
.LGCF610 ANOP
         AIF   (N'&BASE EQ 0).MNOTE4
&X       SETA  1                   Set for Build of USING Statement
&Y       SETA  N'&BASE             Initial No. of Elements in Sublist
.LGCF620 ANOP
         AIF   (&X GT &Y).LGCF640  Reached Max Declared Base Registers?
&USING   SETC  '&USING,&BASE(&X)'  Declare Register for Using Statement
&X       SETA  &X+1                Add One to Element No. Count Field
         AGO   .LGCF620            Loop To Process Register Declaration
.*
.LGCF640 ANOP                      Generate Code to Load Base Registers
&Y       SETA  N'&BASE             Indicate the No. of Base Registers
         LLGTR R&BASE(1),R&BASE(1) Ensure Base Reg Has a Good Address
&X       SETA  2                   Use 2 Since Need At Least 1 Base Reg
.LGCF660 ANOP
         AIF   (&X GT &Y).LGCF680  Reached Max Declared Base Registers?
         LA    R&BASE(&X),2048(,R&BASE(&X-1).)   Load Addressable Range
         LA    R&BASE(&X),2048(,R&BASE(&X).) Add to Preceding Adr Range
         LLGTR R&BASE(&X),R&BASE(&X) Ensure Base Reg Has a Good Address
&X       SETA  &X+1                Add One to Element No. Count Field
         AGO   .LGCF660            Loop to Process Base Register Loads
.LGCF680 ANOP
         DROP  ,                   Remove All Temporary Addressability
         USING &NAME+(&LBLPGE1-&NAME)&USING        RSECT Addressability
.*
&USING   SETC  ',R13'              Set Initial Program Control Base Reg
         AIF   ('&LCAXTRA' EQ '').LGCF760 ...Extra LCA Base Registers?
&X       SETA  1                   Set for Build of USING Statement
&Y       SETA  N'&LCAXTRA          Indicate No. of Elements in Sublist
.LGCF700 ANOP
         AIF   (&X GT &Y).LGCF720  Reached Max Declared Base Registers?
&USING   SETC  '&USING,&LCAXTRA(&X)' ..Declare Register Using Statement
&X       SETA  &X+1                Add One to Element No. Work Field
         AGO   .LGCF700            Loop To Process Register Declares
.*
.LGCF720 ANOP                      Generate Code to Load Base Registers
&Y       SETA  N'&LCAXTRA          Indicate the No. of Base Registers
&X       SETA  1                   Set for Initializing Address Domains
&C       SETC  'R13'               Set the Initial LCA Base Register
.LGCF740 ANOP
         AIF   (&X GT &Y).LGCF760  Reached Max Declared Base Registers?
         LA    &LCAXTRA(&X),2048(,&C) ...Load with Addressable Range
         LA    &LCAXTRA(&X),2048(,&LCAXTRA(&X).) Add to Preceding Range
&C       SETC  '&LCAXTRA(&X)'      Set Next Base Register for Loading
&X       SETA  &X+1                Add One to Element No. to Work Field
         AGO   .LGCF740            Loop to Process Base Register Loads
.LGCF760 ANOP
         USING &PXD.&USING         Establish Program LCA Addressability
*
*+-------------------------------------------------------------------+*
*|  Set RSECT Address & Length and LCA Address & Length In Our LCA   |*
*+-------------------------------------------------------------------+*
*
         AIF   ('&TYPE' EQ 'MAIN').LGCF780    Check If a Main Program?
         MVC   &PX.S64PLI-&PX.SAVE(4,R13),&PX.P701   Set LCA Identifier
         AGO   .LGCF790            Finish LCA Set-up Processing
.LGCF780 ANOP
         MVC   &PX.SA_PLI-&PX.SAVE(4,R13),&PX.P701   Set LCA Identifier
.LGCF790 ANOP
         MVC   &PX.CSADR,&PX.P411  Establish the RSECT Address in LCA
         MVC   &PX.CSLTH,&PX.P4L4  Set the RSECT Length in Our LCA
         ST    R13,&PX.DSADR       Set LCA Address in Logger Cntl Area
         MVC   &PX.DSLTH,&PX.P301  Set LCA Length in Logger Cntl Area
         MVC   &PX.$EYE,&PX.P711   "Eyecatcher" for Lgr Cntl Area (LCA)
         BRU   &LBL8               Branch Around Data Constants Area
         AIF   ('&LOGGR' EQ 'OFF').LGCF800 No Logger Pgms If No Logging
&PX.VCON DC    V(LGMHLRCE)         Define the Logger Service Program
         AGO   .LGCF810            Finish LCA Set-up Processing
.LGCF800 ANOP
&PX.VCON DC    A(0)                Logger Service Program Not Used
.LGCF810 ANOP
&PX.P211 DC    5F'0'               Used to Fill Incoming Registers
&PX.P301 DC    A(&PX.L)            Indicate LCA New Residual Value
&PX.P311 DC    A(&PX.ENDPT-&PXD)   Indicate Offset to LCA End Pointer
&PX.P3L8 DC    A(&STORAGE*1024)    Indicate Requested Storage Area
&PX.P408 DC    A(X'00000001')      Indicate 64-Bit Addressing Mode
&PX.P411 DC    A(&NAME)            RSECT Address in Logger Cntl Area
&PX.P4L4 DC    A(&PX.CSL)          RSECT Length in Logger Cntl Area
&PX.P501 DC    AL3(&PX.L)          Indicate LCA Residual Value
&PX.P601 DC    YL1(&PX.OWNER)      Indicate Owner of Storage
&PX.P611 DC    YL1(&PX.OWNER+&PX.MAINP) Indicator for Owner & MainPgm
&PX.P6L6 DC    6X'0700'            Indicate No Operation on Log Events
&PX.P701 DC    CL4'LCA '           Indicator for Logger Control Area
&PX.P711 DC    CL32'&NAME Dynamic Area(LCA)' For Setting LCA Eyecatcher
&PX.P7F4 DC    CL4'F4SA'           The Save Area Format-4 Identifier
&PX.P7F5 DC    CL4'F5SA'           The Save Area Format-5 Identifier
         LTORG                     Define the Literal Origin Pool
*
&LBL8    DS    0H
         AIF   ('&LOGGR' EQ 'OFF').LGCF870  No Initialization If Off
         AIF   ('&TYPE' NE 'MAIN').LGCF820  Initialize on Main Program
         STMG  R14,R1,&PX.WR141    Save the Current Work Registers
         SLGR  R1,R1               Indicate An Initialization Request
         LLGT  R15,&PX.VC02        Logger Initialization and Setup Pgm
         O     R15,&PX.P408        Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Perform Initialization for Logger
         LMG   R14,R1,&PX.WR141    Restore the Work Registers
*
*+-------------------------------------------------------------------+*
*| Generate Program Entry Log Point                                  |*
*+-------------------------------------------------------------------+*
*
.LGCF820 ANOP
&PM      SETC  '0'                 Default to Parameter Not Specified
         AIF   ('&PARMS' EQ '').LGCF850 ..Verify If PARMS= String Nulls
&DCNT    SETA  N'&PARMS            Establish Count of Parameters
&LGRSHW  SETC  '('                 Assign an Open Parenthesis
*
&I       SETA  0                   Establish the Current Parameter
.LGCF830 ANOP
&J       SETA  &I+1                Update the Current Parameter
&LGRSHW  SETC  '&LGRSHW.''Parm&J'',%&I*4(R1),&PARMS(&I+1)'
&I       SETA  &I+1
         AIF   (&I+1 GT &DCNT).LGCF840
&LGRSHW  SETC  '&LGRSHW,'          Add Comma as a Parm Value Delimiter
         AGO   .LGCF830            Loop to Process Next Parm Value
.LGCF840 ANOP
&LGRSHW  SETC  '&LGRSHW.)'         Assign a Closing Parenthesis
&PM      SETC  '1'                 Indicate PARMS Parameter Specified
         AGO   .LGCF860
.LGCF850 ANOP
&LGRSHW  SETC  ''                  Reset PARMS= String for Log Point
.LGCF860 ANOP
.*
&LGRTPNT SETC  '&LGRNAME._Z'       Generate Logger Log Point Name
         #LGPOINT TYPE=LPRG,MSG=&MSG,REG=&REG,SHOW=&LGRSHW,            X
               COMPRESS=&COMPRESS,NAME=&LGRTPNT
.*
.LGCF870 ANOP
         AIF    (&REGDEF).NOREGS   Have the Regs Already Been Defined?
*
*+-------------------------------------------------------------------+*
*| Set the Program Symbolic Equates for General-Purpose Registers    |*
*+-------------------------------------------------------------------+*
*
&REGDEF  SETB  1
R0       EQU   0                   Define Program Register 0 Equate
R1       EQU   1                   Define Program Register 1 Equate
R2       EQU   2                   Define Program Register 2 Equate
R3       EQU   3                   Define Program Register 3 Equate
R4       EQU   4                   Define Program Register 4 Equate
R5       EQU   5                   Define Program Register 5 Equate
R6       EQU   6                   Define Program Register 6 Equate
R7       EQU   7                   Define Program Register 7 Equate
R8       EQU   8                   Define Program Register 8 Equate
R9       EQU   9                   Define Program Register 9 Equate
R10      EQU   10                  Define Program Register 10 Equate
R11      EQU   11                  Define Program Register 11 Equate
R12      EQU   12                  Define Program Register 12 Equate
R13      EQU   13                  Define Program Register 13 Equate
R14      EQU   14                  Define Program Register 14 Equate
R15      EQU   15                  Define Program Register 15 Equate
AR0      EQU   0                   Define Access Register 0 Equate
AR1      EQU   1                   Define Access Register 1 Equate
AR2      EQU   2                   Define Access Register 2 Equate
AR3      EQU   3                   Define Access Register 3 Equate
AR4      EQU   4                   Define Access Register 4 Equate
AR5      EQU   5                   Define Access Register 5 Equate
AR6      EQU   6                   Define Access Register 6 Equate
AR7      EQU   7                   Define Access Register 7 Equate
AR8      EQU   8                   Define Access Register 8 Equate
AR9      EQU   9                   Define Access Register 9 Equate
AR10     EQU   10                  Define Access Register 10 Equate
AR11     EQU   11                  Define Access Register 11 Equate
AR12     EQU   12                  Define Access Register 12 Equate
AR13     EQU   13                  Define Access Register 13 Equate
AR14     EQU   14                  Define Access Register 14 Equate
AR15     EQU   15                  Define Access Register 15 Equate
.NOREGS  ANOP                      Continue with Next Source Statement
*
*+-------------------------------------------------------------------+*
*| Define Logger Control Area (LCA) Prefix Section                   |*
*+-------------------------------------------------------------------+*
.LGCF880  ANOP
*                                  Save Area & Stack for Prefix Area
&PXD      DSECT ,                  Start of Logger Control Area (LCA)
&PX.SAVE   DS  9D                  Program Save Area==> R13 Points Here
           ORG &PX.SAVE            S T A N D A R D   S A V E   A R E A
&PX.SA_PLI DS  F                   Element SÝ0¨ Reserved PL/I=> 0(R13)
&PX.SA_BCK DS  A                   Element SÝ1¨ SA Calling Pgm  4(R13)
&PX.SA_FWD DS  A                   Element SÝ2¨ SA Called Pgm=> 8(R13)
&PX.SA_REG DS  (60/L'&PX.SA_R14)F  Set the GPR Register Area Length
           ORG &PX.SA_REG          Reset the Current Location Counter
&PX.SA_R14 DS  F                   Element SÝ3¨  Register 14 => 12(R13)
&PX.SA_R15 DS  F                   Element SÝ4¨  Register 15 => 16(R13)
&PX.SA_R0  DS  F                   Element SÝ5¨  Register  0 => 20(R13)
&PX.SA_R1  DS  F                   Element SÝ6¨  Register  1 => 24(R13)
&PX.SA_R2  DS  F                   Element SÝ7¨  Register  2 => 28(R13)
&PX.SA_R3  DS  F                   Element SÝ8¨  Register  3 => 32(R13)
&PX.SA_R4  DS  F                   Element SÝ9¨  Register  4 => 36(R13)
&PX.SA_R5  DS  F                   Element SÝ10¨ Register  5 => 40(R13)
&PX.SA_R6  DS  F                   Element SÝ11¨ Register  6 => 44(R13)
&PX.SA_R7  DS  F                   Element SÝ12¨ Register  7 => 48(R13)
&PX.SA_R8  DS  F                   Element SÝ13¨ Register  8 => 52(R13)
&PX.SA_R9  DS  F                   Element SÝ14¨ Register  9 => 56(R13)
&PX.SA_R10 DS  F                   Element SÝ15¨ Register 10 => 60(R13)
&PX.SA_R11 DS  F                   Element SÝ16¨ Register 11 => 64(R13)
&PX.SA_R12 DS  F                   Element SÝ17¨ Register 12 => 68(R13)
&PX.SA_END EQU *                   Location Cntr for End of Save Area
&PX.SA_SZE EQU &PX.SA_END-&PX.SAVE Establish Leng of Standard Save Area
           DS   18FD               Define a Program Save Area Extension
           ORG &PX.SAVE            F O R M A T - 4   S A V E   A R E A
&PX.F64PLI DS F                    Element SÝ0¨  Reserved PL/I=> 0(R13)
&PX.F64F4A DS F                    Element SÝ1¨  Format-4 ID =>  4(R13)
&PX.F64R14 DS FD                   Element SÝ2¨  Register 14 =>  8(R13)
&PX.F64R15 DS FD                   Element SÝ3¨  Register 15 => 16(R13)
&PX.F64R00 DS FD                   Element SÝ4¨  Register  0 => 24(R13)
&PX.F64R01 DS FD                   Element SÝ5¨  Register  1 => 32(R13)
&PX.F64R02 DS FD                   Element SÝ6¨  Register  2 => 40(R13)
&PX.F64R03 DS FD                   Element SÝ7¨  Register  3 => 48(R13)
&PX.F64R04 DS FD                   Element SÝ8¨  Register  4 => 56(R13)
&PX.F64R05 DS FD                   Element SÝ9¨  Register  5 => 64(R13)
&PX.F64R06 DS FD                   Element SÝ10¨ Register  6 => 72(R13)
&PX.F64R07 DS FD                   Element SÝ11¨ Register  7 => 80(R13)
&PX.F64R08 DS FD                   Element SÝ12¨ Register  8 => 88(R13)
&PX.F64R09 DS FD                   Element SÝ13¨ Register  9 => 96(R13)
&PX.F64R10 DS FD                   Element SÝ14¨ Register 10 =>104(R13)
&PX.F64R11 DS FD                   Element SÝ15¨ Register 11 =>112(R13)
&PX.F64R12 DS FD                   Element SÝ16¨ Register 12 =>120(R13)
&PX.F64BCK DS FD                   Element SÝ17¨ SA Calling Pg 128(R13)
&PX.F64FWD DS FD                   Element SÝ18¨ SA Called Pgm 136(R13)
&PX.F64END EQU *                   Location Cntr for End of Save Area
&PX.F64AID EQU C'F4SA'             Set Format-4 Save Area Identifier
&PX.F64SZE EQU &PX.F64END-&PX.SAVE Set Length of Format-4 Pgm Save Area
           ORG &PX.SAVE            F O R M A T - 5   S A V E   A R E A
&PX.S64PLI DS F                    Element SÝ0¨  Reserved PL/I=> 0(R13)
&PX.S64F5A DS F                    Element SÝ1¨  Format-5 ID =>  4(R13)
&PX.S64R14 DS FD                   Element SÝ2¨  Register 14 =>  8(R13)
&PX.S64R15 DS FD                   Element SÝ3¨  Register 15 => 16(R13)
&PX.S64R00 DS FD                   Element SÝ4¨  Register  0 => 24(R13)
&PX.S64R01 DS FD                   Element SÝ5¨  Register  1 => 32(R13)
&PX.S64R02 DS FD                   Element SÝ6¨  Register  2 => 40(R13)
&PX.S64R03 DS FD                   Element SÝ7¨  Register  3 => 48(R13)
&PX.S64R04 DS FD                   Element SÝ8¨  Register  4 => 56(R13)
&PX.S64R05 DS FD                   Element SÝ9¨  Register  5 => 64(R13)
&PX.S64R06 DS FD                   Element SÝ10¨ Register  6 => 72(R13)
&PX.S64R07 DS FD                   Element SÝ11¨ Register  7 => 80(R13)
&PX.S64R08 DS FD                   Element SÝ12¨ Register  8 => 88(R13)
&PX.S64R09 DS FD                   Element SÝ13¨ Register  9 => 96(R13)
&PX.S64R10 DS FD                   Element SÝ14¨ Register 10 =>104(R13)
&PX.S64R11 DS FD                   Element SÝ15¨ Register 11 =>112(R13)
&PX.S64R12 DS FD                   Element SÝ16¨ Register 12 =>120(R13)
&PX.S64BCK DS FD                   Element SÝ17¨ SA Calling Pg 128(R13)
&PX.S64FWD DS FD                   Element SÝ18¨ SA Called Pgm 136(R13)
&PX.H64R00 DS F                    Element SÝ19¨ High Half Caller's R0
&PX.H64R01 DS F                    Element SÝ20¨ High Half Caller's R1
&PX.H64R02 DS F                    Element SÝ21¨ High Half Caller's R2
&PX.H64R03 DS F                    Element SÝ22¨ High Half Caller's R3
&PX.H64R04 DS F                    Element SÝ23¨ High Half Caller's R4
&PX.H64R05 DS F                    Element SÝ24¨ High Half Caller's R5
&PX.H64R06 DS F                    Element SÝ25¨ High Half Caller's R6
&PX.H64R07 DS F                    Element SÝ26¨ High Half Caller's R7
&PX.H64R08 DS F                    Element SÝ27¨ High Half Caller's R8
&PX.H64R09 DS F                    Element SÝ28¨ High Half Caller's R9
&PX.H64R10 DS F                    Element SÝ29¨ High Half Caller's R10
&PX.H64R11 DS F                    Element SÝ30¨ High Half Caller's R11
&PX.H64R12 DS F                    Element SÝ31¨ High Half Caller's R12
&PX.H64R13 DS F                    Element SÝ32¨ High Half Caller's R13
&PX.H64R14 DS F                    Element SÝ33¨ High Half Caller's R14
&PX.H64R15 DS F                    Element SÝ34¨ High Half Caller's R15
           DS CL8                  Element SÝ35¨ (Undefined)
&PX.S64END EQU *                   Location Cntr for End of Save Area
&PX.S64AID EQU C'F5SA'             Set Format-5 Save Area Identifier
&PX.S64SZE EQU &PX.S64END-&PX.SAVE Set Length of Format-5 Pgm Save Area
           ORG &PX.SAVE            F O R M A T - 7   S A V E   A R E A
&PX.SF7PLI DS F                    Element SÝ0¨  Reserved PL/I=> 0(R13)
&PX.SF7F5A DS F                    Element SÝ1¨  Format-7 ID =>  4(R13)
&PX.SF7R14 DS FD                   Element SÝ2¨  Register 14 =>  8(R13)
&PX.SF7R15 DS FD                   Element SÝ3¨  Register 15 => 16(R13)
&PX.SF7R00 DS FD                   Element SÝ4¨  Register  0 => 24(R13)
&PX.SF7R01 DS FD                   Element SÝ5¨  Register  1 => 32(R13)
&PX.SF7R02 DS FD                   Element SÝ6¨  Register  2 => 40(R13)
&PX.SF7R03 DS FD                   Element SÝ7¨  Register  3 => 48(R13)
&PX.SF7R04 DS FD                   Element SÝ8¨  Register  4 => 56(R13)
&PX.SF7R05 DS FD                   Element SÝ9¨  Register  5 => F7(R13)
&PX.SF7R06 DS FD                   Element SÝ10¨ Register  6 => 72(R13)
&PX.SF7R07 DS FD                   Element SÝ11¨ Register  7 => 80(R13)
&PX.SF7R08 DS FD                   Element SÝ12¨ Register  8 => 88(R13)
&PX.SF7R09 DS FD                   Element SÝ13¨ Register  9 => 96(R13)
&PX.SF7R10 DS FD                   Element SÝ14¨ Register 10 =>104(R13)
&PX.SF7R11 DS FD                   Element SÝ15¨ Register 11 =>112(R13)
&PX.SF7R12 DS FD                   Element SÝ16¨ Register 12 =>120(R13)
&PX.SF7BCK DS FD                   Element SÝ17¨ SA Calling Pg 128(R13)
&PX.SF7FWD DS FD                   Element SÝ18¨ SA Called Pgm 136(R13)
&PX.AF7R14 DS F                    Element SÝ19¨ Access Reg Caller AR14
&PX.AF7R15 DS F                    Element SÝ20¨ Access Reg Caller AR15
&PX.AF7R00 DS F                    Element SÝ21¨ Access Reg Caller AR0
&PX.AF7R01 DS F                    Element SÝ22¨ Access Reg Caller AR1
&PX.AF7R02 DS F                    Element SÝ23¨ Access Reg Caller AR2
&PX.AF7R03 DS F                    Element SÝ24¨ Access Reg Caller AR3
&PX.AF7R04 DS F                    Element SÝ25¨ Access Reg Caller AR4
&PX.AF7R05 DS F                    Element SÝ26¨ Access Reg Caller AR5
&PX.AF7R06 DS F                    Element SÝ27¨ Access Reg Caller AR6
&PX.AF7R07 DS F                    Element SÝ28¨ Access Reg Caller AR7
&PX.AF7R08 DS F                    Element SÝ29¨ Access Reg Caller AR8
&PX.AF7R09 DS F                    Element SÝ30¨ Access Reg Caller AR9
&PX.AF7R10 DS F                    Element SÝ31¨ Access Reg Caller AR10
&PX.AF7R11 DS F                    Element SÝ32¨ Access Reg Caller AR11
&PX.AF7R12 DS F                    Element SÝ33¨ Access Reg Caller AR12
&PX.AF7R13 DS F                    Element SÝ34¨ ALET Previous Savearea
&PX.AF7ASC DS F                    Element SÝ35¨ ASC Mode Caller Progrm
           DS CL4                  Element SÝ36¨ (Undefined)
&PX.SF7END EQU *                   Location Cntr for End of Save Area
&PX.SF7AID EQU C'F7SA'             Set Format-7 Save Area Identifier
&PX.SF7SZE EQU &PX.SF7END-&PX.SAVE Set Length of Format-7 Pgm Save Area
          ORG  ,                   Establish Current Location Counter
&PX.NEXTA DS   F                   Next Available Area in Program LCA
&PX.TCBAD DS   F                   TCB Associated with This LCA Area
&PX.SRSID DS   0F                  Start Residual Storage & Flag
&PX.SFLAG DS   XL1                 User Program Storage Flag Byte
&PX.OWNER EQU  X'80'               Indicates Owner of This Storage
&PX.MAINP EQU  X'40'               Indicates a User Main Program
&PX.RESID DS   AL3                 User Program LCA Residual Length
&PX.$RC   DS   F                   User Program Return Code in R15
&PX.$RS   DS   F                   User Program Reason Code in R0
&PX.CSADR DS   A                   Address of User Program Entry Point
&PX.CSLTH DS   F                   Length of Program Control Section
&PX.DSADR DS   A                   Address of Start of Program LCA
&PX.DSLTH DS   F                   Length of Dynamic Storage for Pgm
&PX.TRIND DS   X                   User Program Log Record Level
&PX.INDNT DS   XL1                 Current Indents Past the Maximum
          DS   XL2                 (Reserved-LOGGER)
*
&PX.LGCOB DS   0XL80               Logger Carry-Over Storage Block
&PX.LGPTS DS   0XL12               Logger Event Entries Area
&PX.LGPTP DS   XL2                 Logger Program Entry/Exit Point
&PX.LGPTB DS   XL2                 Logger Subroutine Entry/Exit Point
&PX.LGPTT DS   XL2                 Logger User Defined Log Point
&PX.LGPTL DS   XL2                 Logger z/OS Service Level Event
&PX.LGPT1 DS   XL2                 (Reserved-LOGGER)
&PX.LGPT2 DS   XL2                 (Reserved-LOGGER)
&PX.WFLAG DS   XL1                 Logger Event Records Flag Byte
&PX.WPRNT EQU  X'80'               ...Immediately Print Rcds to Output
&PX.WBUFR EQU  X'40'               ...Write to Buffer Above the Line
&PX.WBU64 EQU  X'20'               ...Write to Buffer Above the Bar
&PX.WTRIM EQU  X'10'               ...Trim Print Output
&PX.WL88B DS   XL1                 (Reserved-LOGGER)
&PX.TRCDS DS   F                   Address of LGRWK2II Logger Area
&PX.$COMM DS   F                   Address of a Program Common Area
&PX.$COML DS   F                   Length of a Program Common Area
&PX.PWRD1 DS   F                   Word1 - Available to User Program
&PX.PWRD2 DS   F                   Word2 - Available to User Program
&PX.BINTV DS   F                   Log Records Binary-Time Interval
&PX.PSWLC DS   FD                  Logger User Pgm Current PSW
&PX.$CXAC DS   CL28                Logger Communications Area
*
&PX.WR141 DS   4FD                 Save Area for Register R14,R15,R0,R1
&PX.SXLNK DS   FD                  Save Subroutine Exit Return Linkage
&PX.SENTR DS   FD                  Save Area Subroutine Entry Address
&PX.$EYE  DS   CL32                Eye-Catcher Shows Pgm Name Using LCA
*
*+-------------------------------------------------------------------+*
*|End Of Definition For The Logger Control Area (LCA) Prefix Section |*
*+-------------------------------------------------------------------+*
*
         AIF   ('&LCADSECT' EQ 'YES').MEND   A Build of LCA Dummy Only?
&NAME    RSECT ,                   Define Program R/O Control Section
         AGO   .MEND               Done with User Program Source-Setup
.MNOTE1  ANOP ,
         MNOTE 8,'LPGMNTRY: RSECT name not specified and is required.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MNOTE2  ANOP ,
         MNOTE 8,'LPGMNTRY: TYPE=&TYPE is invalid. Must be MAIN/SUB.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MNOTE3  ANOP ,
         MNOTE 8,'LPGMNTRY: AMOD/RMOD parameter conflict, AMOD=&AMOD,RMX
               OD=&RMOD'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MNOTE4  ANOP ,
         MNOTE 8,'LPGMNTRY: No base registers were specified.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MNOTE5  ANOP ,
         MNOTE 8,'LPGMNTRY: LCAPFX= is required and not specified.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MEND    ANOP                      End of the Program Entry Protocol
         MEND                      Terminate the Program Entry Macro
.*
.**********************************************************************
.*  LPGMEXIT - Define Exit Protocol for a User Program                *
.**********************************************************************
.*
         MACRO                     Set Start of Program Exit Macro
&NAME    LPGMEXIT &RC=,            The User Program Return Code        X
               &RS=,               The User Program Reason Code        X
               &REG=ALL,           Registers to Print at Log Point     X
               &MSG=,              Message to Print at Log Point       X
               &COMPRESS=YES       Remove Multiple Blank Chars for MSG=
         GBLC  &LOGGR              ON/OFF Generate Logger Output Recrds
         GBLC  &PGMTYP             Establish the Program Type
         GBLC  &LGRPTYP            Print/Defer Log Records Generated
         GBLC  &LNKR               Return Linkage Branch Instruction
         GBLC  &LKOPS              Return Linkage Instruction Operands
         GBLC  &LGRNAME            RSECT Name of User Program
         GBLC  &LGRSHW             SHOW= String for Logger Log Point
         GBLC  &PX,&PXD            Logger Control Area Prefix Value
         GBLC  &LBLPGX1            Label for User Program Exit
         GBLC  &ADMODE             Addressing Mode of User Program
         LCLC  &LGRTPNT            Name of Logger Services Log Point
         LCLC  &LBL1,&LBL2         Establish Generic Labels
         AIF   ('&NAME' EQ '').LGTX100
&NAME    DS    0H
.LGTX100 ANOP
         AIF   (T'&RC EQ 'O').LGTX140   Check If Parameter Was Omitted?
         AIF   ('&RC' EQ '&RC(1)').LGTX120 ...If not a Register Value?
         AIF   ('&RC' EQ '15' OR '&RC' EQ 'R15').LGTX200
         LR    R15,&RC             Use Return Code Value From Register
         AGO   .LGTX200            Branch to Process the Reason Code
.LGTX120 ANOP
         L     R15,&RC             Use Return Code Value From Storage
         AGO   .LGTX200            Branch to Process the Reason Code
.LGTX140 ANOP
         SLR   R15,R15             Set the Default Return Code Value
.LGTX200 ANOP
         AIF   (T'&RS EQ 'O').LGTX240 ..Check If Parameter Was Omitted?
         AIF   ('&RS' EQ '&RS(1)').LGTX220 ...If not a Register Value?
         AIF   ('&RS' EQ '0' OR '&RS' EQ 'R0').LGTX300
         LR    R0,&RS              Use Reason Code Value From Register
         AGO   .LGTX260            Branch to Set Return & Reason Codes
.LGTX220 ANOP
         L     R0,&RS              Use Reason Code Value From Storage
         AGO   .LGTX260            Branch to Set Return & Reason Codes
.LGTX240 ANOP
         SLR   R0,R0               Set the Default Reason Code Value
.LGTX260 ANOP
         AIF   ('&PGMTYP' EQ 'MAIN').LGTX280   Verify If a Main Program
         LG    R2,&PX.F64BCK-&PX.SAVE(,R13)  Caller's Save Area Address
         AGO   .LGTX290            Branch to Set Return & Reason Codes
.LGTX280 ANOP
         LG    R2,&PX.S64BCK-&PX.SAVE(,R13)  Caller's Save Area Address
.LGTX290 ANOP
         STM   R15,R0,&PX.$RC      Set Retrn Cde & Rsn Code in LCA Area
         AGO   .LGTX300            Branch to Generate Log Point
*
*+-------------------------------------------------------------------+*
*|  Generate a Log Point For Program Exit                            |*
*+-------------------------------------------------------------------+*
*
.LGTX300 ANOP
&LBL1    SETC  'PX1&SYSNDX'        Generate a Branch Label #1
&LBL2    SETC  'PX2&SYSNDX'        Generate a Branch Label #2
&LGRTPNT SETC  '&LGRNAME._Z'       Generate Logger Log Point Name
.*
         #LGPOINT TYPE=LPRX,MSG=&MSG,REG=&REG,SHOW=&LGRSHW,            X
               COMPRESS=&COMPRESS,NAME=&LGRTPNT
.*
         AIF   ('&PGMTYP' EQ 'MAIN').LGTX320   Verify If a Main Program
         STMG  R15,R0,&PX.F64R15-&PX.SAVE(R2)  Set Retrn Cde & Rsn Cde
         AGO   .LGTX340            Branch to Process Program Exit
.LGTX320 ANOP
         STM   R15,R0,&PX.S64R15-&PX.SAVE(R2)  Set Retrn Cde & Rsn Cde
.LGTX340 ANOP
         AIF   ('&LOGGR' EQ 'OFF').LGTX400     Verify If No Logging
         AIF   ('&PGMTYP' NE 'MAIN').LGTX400   Verify If Main Program
         STMG  R14,R1,&PX.WR141    Save the Current Work Registers
         AIF   ('&LGRPTYP' EQ 'PRNT').LGTX360  Verify If Buffer Records
         LA    R1,4                Termination with Buffer Records
         AGO   .LGTX380            Branch to Process Logger Termination
.LGTX360 ANOP
         LA    R1,8                Termination Without Buffer Records
.LGTX380 ANOP
         LLGT  R15,&PX.VC03        Logger Termination Program
         O     R15,&PX.P408        Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Perform Termination of Logger
         LMG   R14,R1,&PX.WR141    Restore the Current Work Registers
.LGTX400 ANOP                      Continue with Next Source Statement
         LLGF  R14,&PX.P811        Get the Offset to LCA End Pointer
         LA    R14,0(R14,R13)      Get Address of the LCA End Pointer
         C     R14,0(,R14)         Was This Pointer Field Overlayed?
         BRE   &LBL1               No  => Verify Ownership and Release
         DC    H'0'                Yes => Then Abend Right at the Msg
         DC    C'ÝABEND¨==>AN LCA STORAGE OVERLAY OCCURRED IN &LGRNAME'
&LBL1    DS    0H
         TM    &PX.SFLAG,&PX.OWNER Does This Program Own The LCA Area?
         BRZ   &LBL2               No => Branch to Return to Caller
         LGR   R1,R13              Get Address of Dynamic Area to Free
         AIF   ('&PGMTYP' NE 'MAIN').LGTX420   Verify If a Main Program
         LMH   R0,R15,&PX.H64R00-&PX.SAVE(R13)   Restore High Half 0-15
.LGTX420 ANOP                      Continue with Next Source Statement
         SLR   R14,R14             Clear To Set Length of Dynamic Area
         ICM   R14,B'0111',&PX.RESID ...Get the Residual Area
         AL    R14,&PX.P801        Calculate Program LCA Area Length
         LLGFR R0,R14              Set R0 for Size of Area to Release
       STORAGE RELEASE,            Release Logger Control Area Storage X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
&LBL2    DS    0H
         AIF   ('&PGMTYP' EQ 'MAIN').LGTX440   Verify If a Main Program
         LLGTR R13,R2              Restore Caller's Save Area Address
         MVC   &PX.F64PLI-&PX.SAVE(4,R13),&PX.P8L2  Restore LCA ID Name
         XC    &PX.F64FWD-&PX.SAVE(8,R13),&PX.F64FWD-&PX.SAVE(R13)
         LMG   R14,R12,&PX.F64R14-&PX.SAVE(R13)  Restore Caller's Regs
         AGO   .LGTX460            Branch to Generate Exit Instruction
.LGTX440 ANOP                      Continue with Next Source Statement
         LLGTR R13,R2              Restore Caller's Save Area Address
         MVC   &PX.SA_PLI-&PX.SAVE(4,R13),&PX.P8L2  Restore LCA ID Name
         XC    &PX.SA_FWD-&PX.SAVE(4,R13),&PX.SA_FWD-&PX.SAVE(R13)
         LM    R14,R12,&PX.SA_R14-&PX.SAVE(R13)  Restore Caller's Regs
.LGTX460 ANOP                      Continue with Next Source Statement
&LKOPS   SETC  'R14'               Indicate R14 Has BCR Return Address
         AIF   (('&LNKR' EQ '') OR ('&LNKR' EQ 'BR')).LGTX500
&LKOPS   SETC  'R0,R14'            Link Info, Amode, and Return Addr
         AIF   ('&LNKR' EQ 'BSM').LGTX510  BSM Requested on Return?
&LKOPS   SETC  '&LKOPS'(4,K'&LKOPS-3)  Instruction Unknown, Set to R14
.LGTX500 ANOP                      Continue with Next Source Statement
&LNKR    SETC  'BR'                Indicate Default Return Instruction
.LGTX510 ANOP                      Continue with Next Source Statement
&LBLPGX1 DS    0H
         &LNKR &LKOPS              Return To The Caller
         CNOP  0,4
         AIF   ('&LOGGR' EQ 'OFF').LGTX520 No Logger Pgms If No Logging
&PX.VC02 DC    V(LGMHLRCI)         The Logger Initialization Program
&PX.VC03 DC    V(LGMHLRCT)         The Logger Termination Program
         AGO   .LGTX530            Finish LCA Set-up Processing
.LGTX520 ANOP
&PX.VC02 DC    A(0)                Logger Initialization Pgm Not Used
&PX.VC03 DC    A(0)                Logger Termination Program Not Used
.LGTX530 ANOP
&PX.P801 DC    A(&PX.L)            Indicate LCA New Residual Value
&PX.P811 DC    A(&PX.ENDPT-&PXD)   Indicate Offset to LCA End Pointer
&PX.P8L2 DC    CL4'LCA '           Indicator for Logger Control Area
         DS    0H
         LTORG ,                   Define The Literal Origin Pool
.*
.MEND    ANOP                      End of the Program Exit Protocol
         MEND                      Terminate the Program Exit Macro
.*
.**********************************************************************
.*  LPGMSUBE - Define Subroutine Entry Protocol for User Program      *
.**********************************************************************
.*
         MACRO                     Set Start of Subroutine Entry Macro
&NAME    LPGMSUBE &MSG=,           Message to Print at Logger Log PointX
               &RETRN=,            Return Register to Save at Log PointX
               &SHOW=,             Data to Print at Logger Log Point   X
               &PVTAREA=,          Private Area to Print at Log Point  X
               &WATCH=,            Storage Watch at Logger Log Point   X
               &REG=NONE,          Registers to Print at Logger Log PntX
               &COMPRESS=YES       Remove Multiple Blank Chars for MSG=
         GBLC  &SUBS(256)          Names of User Program Subroutines
         GBLC  &SBNM               Saved Name for Use in LPGMSUBX
         GBLC  &RETSUB             Register for Subroutine Return Addr
         GBLC  &PX                 Logger Control Area Prefix Value
         GBLA  &SUBC               Count of User Program Subroutines
         GBLB  &SUBR               ON - User Program Subroutine Entry
         LCLC  &LGRTPNT            Name of Logger Service Log Point
         LCLA  &IX,&RX             General Work Variables
         AIF   ('&NAME' EQ '').MNOTE1 Error If No Subroutine Name
         AIF   (&SUBR).MNOTE2      Error If Entry Not Followed by Exit
&SUBR    SETB  1                   Indicate Program 'LPGMSUBE' Entered
&SUBC          SETA  &SUBC+1       Increment the Count of Subroutines
&SUBS(&SUBC)   SETC  '&NAME'       Add This One To The List
&SBNM          SETC  '&NAME'       Save the Original Name
&LGRTPNT       SETC  '&NAME._Z'    Generate Logger Log Point Name
&NAME    DS    0H                  Define Labl for Program Subroutine
&IX      SETA  1                   Start the Search at One
&RX      SETA  0                   Start Comparing Regs with R0
.LGTX540 ANOP                      Continue with Next Source Statement
         AIF   ('&RETRN' EQ '').LGTX580  Branch If No RETRN= Parm
         AIF   ('&RETRN(&IX)' EQ 'R&RX').LGTX560  Reg Notation 'Rn'
         AIF   ('&RETRN(&IX)' EQ '&RX').LGTX560   Reg Notation 'n'
&RX      SETA  &RX+1               Increment for the Register Number
         AIF   (&RX LE 16).LGTX540 Limit To 16 Gen Purpose Registers
         AGO   .MNOTE3             Error If Register No. Exceeds Limit
.LGTX560 ANOP                      Continue with Next Source Statement
&RETSUB  SETC  'R&RX'              Set the Register Notation as 'Rn'
         AGO   .LGTX600            Save Address in Indicated Return Reg
.LGTX580 ANOP
&RETSUB  SETC  'R14'               Set the Default Register for Return
.LGTX600 ANOP
         STG   &RETSUB,&PX.SAVE_&SBNM  Save Subroutine Return Linkage
         LA    &RETSUB,*-6         Get Subroutine Entry Point Address
         STG   &RETSUB,&PX.SENTR   Save Subroutine Entry Point Addr
         LG    &RETSUB,&PX.SAVE_&SBNM  Restore Return Linkage Addr
.*
         #LGPOINT TYPE=LSBE,MSG=&MSG,REG=&REG,SHOW=&SHOW,WATCH=&WATCH, X
               PVTAREA=&PVTAREA,COMPRESS=&COMPRESS,NAME=&LGRTPNT
.*
         AGO   .MEND               Logger Services Process Done
.*
.MNOTE1  ANOP ,
         MNOTE 8,'LPGMSUBE: Label is required as subroutine name.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MNOTE2  ANOP ,
         MNOTE 8,'LPGMSUBE: A previous LPGMSUBE not followed by LPGMSUBX
               X.'
.MNOTE3  ANOP
         MNOTE 8,'RETRN=&RETRN, is an invalid value for parameter.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MEND    ANOP                      End of the Subroutine Entry Protocol
         MEND                      Terminate the Subroutine Entry Macro
.*
.**********************************************************************
.*   LPGMSUBX - Define Subroutine Exit Protocol for User Program      *
.**********************************************************************
.*
         MACRO                     Set Start of Subroutine Exit Macro
&NAME    LPGMSUBX &MSG=,           Msg to Print at User Program Log PntX
               &SHOW=,             Data to Print at User Pgm Log Point X
               &PVTAREA=,          Private Area at User Program Log PntX
               &WATCH=,            Storage Watch at User Pgm Log Point X
               &REG=NONE,          Registers to Print at Log Point     X
               &COMPRESS=YES       Remove Multiple Blank Chars for MSG=
         GBLC  &PX                 Logger Control Area Prefix Value
         GBLC  &SBNM               Saved Name for Use in LPGMSUBX
         GBLC  &RETSUB             Register for Subroutine Return Addr
         GBLB  &SUBR               ON - User Program Subroutine Entry
         LCLC  &LGRTPNT            Name of User Program Log Point
         AIF   (NOT &SUBR).MNOTE1
&SUBR    SETB  0                   Indicate Logger 'LPGMSUBX' Entered
&LGRTPNT       SETC  '&SBNM._X'    Exit Point Name for Logger Process

         AIF   ('&NAME' EQ '').LGTX700  Verify If Name Was Supplied
&NAME    DS    0H                  Define Label for Subroutine Exit
.LGTX700 ANOP
.*
         #LGPOINT TYPE=LSBX,MSG=&MSG,REG=&REG,SHOW=&SHOW,WATCH=&WATCH, X
               PVTAREA=&PVTAREA,COMPRESS=&COMPRESS,NAME=&LGRTPNT
.*
         LG    &RETSUB,&PX.SAVE_&SBNM  Restore Return Linkage Addr
         BR    &RETSUB             Return To The Caller
&SBNM    SETC  ''                  Reset Variable for Cleanup
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE1  ANOP ,
         MNOTE 8,'LPGMSUBE: Label is required as subroutine name.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MNOTE2  ANOP ,
         MNOTE 8,'LPGMSUBX: LPGMSUBX encounterd without preceeding LPGMX
               SUBE.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.MEND    ANOP                      End of the Subroutine Exit Protocol
         MEND                      Terminate the Subroutine Exit Macro
.*
.**********************************************************************
.*   LCA - Define Dynamic Storage Area for User Program               *
.**********************************************************************
.*
         MACRO                     Set Start of Logger Cntl Area Macro
         LCA   &P                  DEFINE/DEFEND
         GBLC  &LGRNAME            RSECT Name of User Program
         GBLC  &SUBS(256)          Names of Program Subroutines
         GBLC  &PX,&PXD            User Program LCA Prefix Value
         GBLA  &SUBC               Count of the Program Subroutines
         GBLB  &SUBR               ON - User Program Subroutine Entry
         AIF   ('&P' EQ 'DEFINE').DEFINE   Definition for LCA Start?
         AIF   ('&P' EQ 'DEFEND').DEFEND   Definition for LCA End?
         AGO   .MNOTE1             Error for an Invalid Operand
.DEFINE  ANOP
&PXD     DSECT ,                   Define Logger Control Area (LCA)
         AGO   .MEND               Logger Defined LCA Process Done
.DEFEND  ANOP
&LGRNAME RSECT ,                   Get the Length of the Program RSECT
         DS    0D                  Assure It's Aligned on a Doublword
&PX.CSL  EQU   *-&LGRNAME          Define the Length of Program RSECT
*
&PXD      DSECT ,
*
&I       SETA  1                   Init the Subroutine Save Area Count
.PCX010  ANOP
         AIF   (&I GT &SUBC).PCX020  Check Count of Subroutines
&PX.SAVE_&SUBS(&I) DS FD           Save Area for Return Linkage
&I       SETA  &I+1                Update Current Subroutine Counter
         AGO   .PCX010             Loop to Process Next Subroutine
.PCX020  ANOP
*
&PX.ENDPT DS    F                  End Pointer (For Overlay Check)
         DS    0D                  Assure LCA Ends on a Doubleword
&PX.L    EQU   *-&PXD              Define the Length of Program LCA
         DROP  ,                   Remove All Listed Regs as Base Regs
         AGO   .MEND               Logger End, Process Done
.*
.MNOTE1  ANOP ,
         MNOTE 8,'LCA: Operand must be DEFINE or DEFEND.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MEND    ANOP                      End of Program Source-Setup Protocol
         MEND                      Terminate Logger Defined Service #1
.**********************************************************************
.* Name:      #LGPOINT                                                *
.*                                                                    *
.* Function:  Generates the Logger log point in order to capture      *
.*            program information. This will allow the logger program *
.*            'LGMHLRCE' to get control, extract the data, and print  *
.*            the log data to the output data set identified by the   *
.*            //LGRECOUT DD.                                          *
.*                                                                    *
.*                                                                    *
.* "#LGPOINT" Description:                                            *
.* -----------------------                                            *
.*                                                                    *
.* Label   #LGPOINT Ýparameters¨                                      *
.*                                                                    *
.* Parameters:                                                        *
.*                                                                    *
.* Label                                                              *
.*            Represents the label name provided on the #LGPOINT entry*
.*            coded in program source. This parameter is required as  *
.*            it defines the name of the log point.                   *
.*                                                                    *
.*                                                                    *
.* MSG=('message text',variableÝ,'message text',variable¨...)         *
.*                                                                    *
.*     text - This parameter specifies a list of text and/or data     *
.*            to be printed when the Logger log point is executed in  *
.*            addition to the standard Logger output. It may be       *
.*            specified as a list with embedded variables. If any     *
.*            variables are used they must be defined in the program  *
.*            source and be generated prior to the execution of this  *
.*            logger entry since the data type and length of the      *
.*            variable are used to determine the proper format.       *
.*                                                                    *
.*                                                                    *
.* PVTAREA={YES | NO}                                                 *
.*                                                                    *
.*   YES/NO - Indicates whether to print the current storage          *
.*            allocations for the Private Area. The default is NO.    *
.*                                                                    *
.*                                                                    *
.* SHOW=(('text',address,length)Ý,('text',address,length)¨...)        *
.*                                                                    *
.*     text - This parameter specifies any text message that should   *
.*            be displayed to identify the data being printed to the  *
.*            log.                                                    *
.*                                                                    *
.*  address - This specifies the address of the data to be printed.   *
.*            It may be specified as a program label, or in register  *
.*            format (i.e., (15) or (R15)).                           *
.*                                                                    *
.*   length - This specifies the length of the data to be printed up  *
.*            to 32K. It may be specified as an equated value, or as  *
.*            a hard coded numeric expression.                        *
.*                                                                    *
.*                                                                    *
.* WATCH=(('text',address,length)Ý,('text',address,length)¨...)       *
.*                                                                    *
.*     text - This parameter specifies any text message that should   *
.*            be displayed to identify the data being printed to the  *
.*            log when a storage alteration occurs.                   *
.*                                                                    *
.*  address - This specifies the address of the data area to be       *
.*            monitored. It may be specified as a program label, or   *
.*            in register format (i.e., (15) or (R15)).               *
.*                                                                    *
.*   length - This specifies the length of the data area to be        *
.*            monitored up to 32K-8. It may be specified as an equated*
.*            value, or as a hard coded numeric expression.           *
.*                                                                    *
.*                                                                    *
.* REG={NONE | ALL | (RxÝ,Rx¨...)}                                    *
.*                                                                    *
.*     NONE - Indicates that no registers are to be printed when the  *
.*            program Logger log point is executed. The default is    *
.*            NONE.                                                   *
.*                                                                    *
.*      ALL - Indicates that all 16 64-bit general purpose registers  *
.*            and all 16 32-bit access registers are to be printed    *
.*            when the program log point is executed.                 *
.*                                                                    *
.*       Rn - Specifies a 64-bit general purpose register and the     *
.*            corresponding same numbered 32-bit access register are  *
.*            to be printed when the program log point is executed.   *
.*            Specify R0 to R15 as a parameter value to identify the  *
.*            register. A single register or any combination of       *
.*            registers numbered R0-R15 may be specified in any       *
.*            order. The registers displayed will be in numeric       *
.*            ascending order. If multiple registers are specified,   *
.*            enclose the list of registers in parentheses with the   *
.*            register values separated by a comma.                   *
.*                                                                    *
.*                                                                    *
.* COMPRESS={YES | NO}                                                *
.*                                                                    *
.*   YES/NO - Indicates whether multiple spaces should be removed     *
.*            from the message before printing. The default is YES.   *
.*                                                                    *
.*                                                                    *
.* SUPHEAD={YES | NO}                                                 *
.*                                                                    *
.*   YES/NO - Available only for LPNT type generations. A Value of    *
.*            'NO' will suppress the '=>Log Point**: NAME' header and *
.*            the '+', 'Msg)' line indicators. This is used internally*
.*            by Logger Services when printing data areas during abend*
.*            processing of a program.                                *
.*                                                                    *
.*                                                                    *
.* NAME=name                                                          *
.*                                                                    *
.*     name - Specifies the name of the log point when generated from *
.*            within another macro.                                   *
.*                                                                    *
.**********************************************************************
.*
         MACRO                     Set Start of Logger Logpoint Macro
&LBL     #LGPOINT &TYPE=LPNT,      Type of Logger Services Log Point   X
               &MSG=,              Msg to Print at User Program Log PntX
               &SHOW=,             Data to Prnt at User Program Log PntX
               &PVTAREA=,          Private Area at User Program Log PntX
               &WATCH=,            Data to Watch at User Pgm Log Point X
               &REG=NONE,          Regs to Prnt at User Progrma Log PntX
               &COMPRESS=YES,      Remove Multiple Blank Chars for MSG=X
               &SUPHEAD=NO,        Do Not Suppress Headers on LPNT TypeX
               &NAME=              Establish Logger Service Log Point
         GBLC  &LGRNAME            RSECT Name of User Program
         GBLC  &LOGGR              ON/OFF to Gen Logger Output Records
         GBLC  &PX                 Logger Control Area Prefix Value
         GBLC  &PM                 Set Flag Byte Variables
         GBLC  &SBNM               Saved Name for Use in LPGMSUBX
         GBLC  &ADMODE             Program Addressing Mode
         GBLC  &LBLPGE0            Label for User Program Entry
         GBLC  &LBLPGE2            Label for User Program Entry
         GBLC  &LBLPGX1            Label for User Program Exit
         LCLC  &WIITNAM            Name of User Program Log Point
         LCLC  &LGRTPNT            Name of User Prg Log Point to Exec
         LCLC  &RGS                Registers for Logger to Process
         LCLC  &FLG,&MG,&DT        Set Flag Byte Variables
         LCLC  &CP,&SH,&WT,&SP     Set Flag Byte Variables
         LCLC  &VT,&C,&LB          Variable Type
         LCLA  &RG(16)             Indicate No. of Registers to Print
         LCLA  &I,&J               General Work Variables
.*
.**********************************************************************
.*   Perform Validation of Required Log Point Parameters              *
.**********************************************************************
.*
         AIF   ('&LBL' EQ '').LGZT100
&LBL     DS    0H
.LGZT100 ANOP
         AIF   ('&LBL' NE '').LGZT120
         AIF   ('&NAME' EQ '').MNOTE1  User Program Log Point Name?
&WIITNAM SETC  '&NAME'             Set User Program Log Point Name
         AGO   .LGZT140            Branch to Validate Next Parameter
.LGZT120 ANOP
&WIITNAM SETC  '&LBL'
.LGZT140 ANOP
         AIF   ('&LOGGR' EQ 'OFF').MEND  Suppress Gen of Logger Output?
.LGZT160 ANOP
         AIF   ('&TYPE' EQ 'LPNT').LGZT180 Log Request User Defined?
         AIF   ('&TYPE' EQ 'LPRG').LGZT200 Log Request Program Entry?
         AIF   ('&TYPE' EQ 'LPRX').LGZT200 Log Request Program Exit?
         AIF   ('&TYPE' EQ 'LSBE').LGZT220 Log Request Subroutine Entry
         AIF   ('&TYPE' EQ 'LSBX').LGZT220 Log Request Subroutine Exit?
         AIF   ('&TYPE' EQ 'LSYP').LGZT240 Log Request System Level?
         AGO   .MNOTE2
.LGZT180 ANOP
&LGRTPNT SETC  '&PX.LGPTT'         Logger Services Program Log Point
         AGO   .LGZT260            Branch to Validate Next Parameter
.LGZT200 ANOP
&LGRTPNT SETC  '&PX.LGPTP'         Logger Services Program Entry/Exit
         AGO   .LGZT260            Branch to Validate Next Parameter
.LGZT220 ANOP
&LGRTPNT SETC  '&PX.LGPTB'         Logger Services Subroutine Ent/Exit
         AGO   .LGZT260            Branch to Validate Next Parameter
.LGZT240 ANOP
&LGRTPNT SETC  '&PX.LGPTL'         Logger Services System Level
         AGO   .LGZT260            Branch to Validate Next Parameter
.*
.LGZT260 ANOP
&TR      SETC  '0'                 Default To Parameter Not Specified
&CP      SETC  '0'                 Default To Parameter Not Specified
         AIF   ('&COMPRESS' EQ 'NO').LGZT280  Branch If No Compression
&CP      SETC  '1'                 Assume Compression of All Messages
         AIF   ('&COMPRESS' EQ 'YES').LGZT280 Branch If Compress Msgs
         AGO   .MNOTE3             Invalid Parameter Value Specified
.*
.LGZT280 ANOP
&SH      SETC  '0'                 Default to Parameter Not Specified
         AIF   ('&SUPHEAD' EQ 'NO').LGZT290   Branch if No Hdr Suppress
&SH      SETC  '1'                 Assume Suppression of Message Header
         AIF   ('&SUPHEAD' EQ 'YES').LGZT290  Branch If Suppress Header
         AGO   .MNOTE8             Invalid Parameter Value Specified
.*
.LGZT290 ANOP
&SP      SETC  '0'                 Default To Parameter Not Specified
         AIF   ('&PVTAREA' EQ '').LGZT300  Branch If No PVTAREA= Parm
         AIF   ('&PVTAREA' EQ 'NO').LGZT300  Was Parm Specified as No?
&SP      SETC  '1'                 Assume Show Private Area Storage
         AIF   ('&PVTAREA' EQ 'YES').LGZT300 Branch If Show Private
         AGO   .MNOTE10            Invalid Parameter Value Specified
.*
.**********************************************************************
.*  If Specified By User Generate Code for the REG= Parameter         *
.**********************************************************************
.*
.LGZT300 ANOP
&RGS     SETC  '0000000000000000'  Default to Parameter Not Specified
         AIF   ('&REG' EQ 'NONE').LGZT380  Branch To Display No Regs
&RGS     SETC  '1111111111111111'  Assume All Registers Are Requested
         AIF   ('&REG' EQ 'ALL').LGZT380   Branch To Display All Regs
.*
&RGS     SETC  ''                  Default to No Operands Specified
&I       SETA  1                   Start Array Subscript Search at One
&J       SETA  0                   Start Comparing Reg from Lst with R0
.LGZT320 ANOP
         AIF   ('&REG(&I)' EQ 'R&J').LGZT340  Check Reg Notation 'Rn'
         AIF   ('&REG(&I)' EQ '&J').LGZT340   Check Reg Notation 'n'
&J       SETA  &J+1                Increment for the Register Number
         AIF   (&J LE 16).LGZT320  Limit To 16 Gen Purpose Registers
         AGO   .LGZT350            Done If Register No. Exceeds Limit
.LGZT340 ANOP
&RG(&J+1) SETA 1                   Turn Bit On To Log a Specified Reg
.LGZT350 ANOP
&I       SETA  &I+1                Increment to Next Position in Sublst
&J       SETA  0                   Start at R0 For Next Register in Lst
         AIF   (&I LE K'&REG).LGZT320 Branch If LE Parm Character Count
.LGZT360 ANOP
&RGS     SETC  '&RG(1)&RG(2)&RG(3)&RG(4)&RG(5)&RG(6)&RG(7)&RG(8)'
&RGS     SETC  '&RGS&RG(9)&RG(10)&RG(11)&RG(12)&RG(13)&RG(14)&RG(15)'
&RGS     SETC  '&RGS&RG(16)'
.LGZT380 ANOP                      Continue with Next Source Statement
.*
&MG      SETC  '0'                 Default to Parameter Not Specified
         AIF   ('&MSG' EQ '').LGZT400  Branch If No MSG= Parameter
&MG      SETC  '1'                 Indicate MSG= Parameter Specified
.*
.LGZT400 ANOP
&DT      SETC  '0'                 Default to Parameter Not Specified
&WT      SETC  '0'                 Default to Parameter Not Specified
         AIF   ('&SHOW' EQ '').LGZT420 Branch If No SHOW= Parameter
&DT      SETC  '1'                 Indicate SHOW Parameter Specified
.LGZT420 ANOP
         AIF   ('&WATCH' EQ '').LGZT500 Branch If No WATCH= Parameter
&WT      SETC  '1'                 Indicate WATCH Parameter Specified
.*
.LGZT500 ANOP
&FLG     SETC  '&MG&DT&CP&SH&PM&WT&SP&TR'  Set Bits in Logger Flag Byte
.*
.**********************************************************************
.*    Perform Program Code Generation for a Log Point                 *
.**********************************************************************
.*
.LGZT600 ANOP
         STMG  R14,R1,&PX.WR141    Save Current Registers Over Log Pnt
         EPSW  R0,R1               Extract Bits 0-63 of Current PSW
         STM   R0,R1,&PX.PSWLC     Save Current Program Status Word
         AIF   ('&TYPE' NE 'LSBX').LGZT610 Processing Subroutine Exit?
         MVC   &PX.SXLNK,&PX.SAVE_&SBNM    Return Linkage Addr For Log
.LGZT610 ANOP
         LLGT  R15,&PX.VCON        Address of Log Process Pgm(LGMHLRCE)
         O     R15,&PX.P408        Turn On the Low Order AMODE-64 Bit
         EX    R0,&LGRTPNT         Execute the Appropriate Log Point
         BRU   P&SYSNDX            Branch Around the Log Point Data
         DC    AL4(L&SYSNDX)       Addr of LogPoint Parameter Data Area
L&SYSNDX LOCTR ,                   Reset Location Counter for Data Area
         DC    CL4'&TYPE'          Set Logger Event Information Type
         DC    AL4(&LBLPGX1-&LBLPGE0) Set the Program Exit Address
         DC    BL2'&RGS'              Indicate Which Registers to Log
         DC    BL1'&FLG'           Flag Byte for Parameters Specified
         DC    AL1(L'N&SYSNDX)     Number of Characters in Name
N&SYSNDX DC    C'&WIITNAM'         Name of This User Program Log Point
&LC      SETA  K'&WIITNAM          Get Log Point Name Character Count
&I       SETA  &LC/2*2             Establish an Integer Result on Count
         AIF   (&LC EQ &I).LGZT620 Count on Log Point Name Even Number?
         DC    X'40'               Add Fill Byte for Halfword Alignment
.LGZT620 ANOP
N&SYSNDX.L EQU *-L&SYSNDX          Length of Data Area Prefix Section
.*
.**********************************************************************
.*  If Specified By User Generate Code for the MSG= Parameter         *
.**********************************************************************
.*
         AIF   ('&MG' EQ '0').LGZT690    ...Generate Message if Present
         DC    YL2(M&SYSNDX.L)     Length of Text Message in MSG= Parm
M&SYSNDX EQU   *                   Beginning of the MSG= Parameter
&I       SETA  1
.LGZT630 ANOP
         AIF   ('&MSG(&I)' EQ '').LGZT680         ...At End of Sublist?
         AIF   ('&MSG(&I)'(1,1) NE '''').LGZT650  ...Is This Test Data?
         DC    C&MSG(&I)
&N       SETA  1                   Set Initial Count for Sublist
&M       SETA  K'&MSG(&N)/2*2      Establish an Integer Result on Count
         AIF   (K'&MSG(&N) EQ &M).LGZT640 Count on User's Message Even?
         DC    X'40'               Add Fill Byte for Halfword Alignment
.LGZT640 ANOP
&N       SETA  &N+1
         AGO   .LGZT670            Branch to Increment Current Position
.LGZT650 ANOP                      Assume a User Program Variable
&TP      SETC  T'&MSG(&I)          Obtain Program Variable Type Code
&C       SETC  '&MSG(&I)'          Obtain the User Program Variable
         AIF   ('&C'(1,1) NE '(').LGZT660   ...If Not Register Notation
&C       SETC  '0&C'               Change (15) to a 0(15) For the Addr
.LGZT660 ANOP
         DC    X'FE',C'&TP'        Indicate a Variable & Variable Type
         RLLG  R0,R0,&MSG(&I)      Address for the Data To Print
         DC    YL2(L'&MSG(&I))     Length of the Message Variable
.LGZT670 ANOP
&I       SETA  &I+1                Increment the Sublist Pointer
         AGO   .LGZT630            Loop to Process Next Subparameter
.LGZT680 ANOP
M&SYSNDX.L EQU *-M&SYSNDX          Length of the Message Area
.*
.**********************************************************************
.*  If Specified By User Generate Code for the SHOW= Parameter        *
.**********************************************************************
.*
.LGZT690 ANOP
         AIF   ('&DT' EQ '0').LGZW100  Generate Data if Present
         DC    YL2(D&SYSNDX.L)     Length of the SHOW= Area
&B0      SETB  0                   Constant Points at 31-Bit Address
&B1      SETB  0                   Constant Points at 24-Bit Address
&B2      SETB  0                   Length is in a Register
D&SYSNDX EQU   *                   Beginning of the SHOW= Parameter
         AIF   ('&SHOW'(1,2) NE '((').LGZT770
&I       SETA  1
.LGZT700 ANOP
         AIF   (&I GT N'&SHOW).LGZT760   ...At End of the Sublist?
         AIF   ('&SHOW(&I,1)'(1,1) NE '''').MNOTE6 ...Must Be Quoted
&C       SETC  '&SHOW(&I,2)'       Obtain Address of Data to Print
         AIF   ('&C'(1,1) NE '%').LGZT710
&B0      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
         AGO   .LGZT720            Branch to Check for Notation
.LGZT710 ANOP
         AIF   ('&C'(1,1) NE '?').LGZT720
&B1      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
*
.LGZT720 ANOP
         AIF   ('&C'(1,1) NE '(').LGZT730
&C       SETC  '0&C'               Change Notation of (1) to a 0(1)
.LGZT730 ANOP
         AIF   ('&SHOW(&I,3)'(1,1) NE '(').LGZT740
&B2      SETB  1                   Indicate the Length in Register
.LGZT740 ANOP
         RLLG  R0,R0,&C            Address for the Data To Print
         DC    YL2(&SHOW(&I,3))    Length of the Data To Print
&LB      SETC  'T&SYSNDX.&I'       Generate a Unique Label
         DC    BL1'&B0.&B1.&B2.00000' ...Data Processing Flag Byte
         DC    YL1(L'&LB)          Indicate the Length of Header
&LB      DC    C&SHOW(&I,1)
&M1      SETA  K'&SHOW(&I,1)       Establish Character Count on Header
&M       SETA  &M1/2*2             Set an Integer Result on Char Count
         AIF   (&M1 EQ &M).LGZT750   Is Character Count on Header Even?
         DC    X'40'               Add Fill Byte for Halfword Alignment
.LGZT750 ANOP
&I       SETA  &I+1                Get the Next Sub-Parameter
&B0      SETB  0                   Reset Constant Indicator for 31-Bit
&B1      SETB  0                   Reset Constant Indicator for 24-Bit
&B2      SETB  0                   Reset Leng in Register Indicator
         AGO   .LGZT700            Loop to Process Next Subparameter
.LGZT760 ANOP
D&SYSNDX.L EQU *-D&SYSNDX          Length of the Data Area
         AGO   .LGZW100            Branch to Check for Storage Watch
.*
.**********************************************************************
.* Process When More Than One Entry Was Specified for SHOW= Parameter *
.* as in SHOW=(('WORKAREA',WRKAREA,L'WRKAREA),('TEMPAREA',(R2),256))  *
.**********************************************************************
.*
.LGZT770 ANOP
&J       SETA  N'&SHOW             Number of Items in List
&I       SETA  (&J/3)*3            Ensure There Are Groups of 3
         AIF   (&I NE &J).MNOTE7   Indicate Error If Not
&J       SETA  &J/3                Count of Groups to Process
&I       SETA  1
.LGZT780 ANOP
         AIF   (&I GT N'&SHOW).LGZT830     ...At End of Sublist?
         AIF   ('&SHOW(&I)'(1,1) NE '''').MNOTE6 ...Must Be Quoted
&C       SETC  '&SHOW(&I+1)'       Get Address of Data to Print
         AIF   ('&C'(1,1) NE '%').LGZT790
&B0      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
         AGO   .LGZT800            Branch to Check Notation
.LGZT790 ANOP
         AIF   ('&C'(1,1) NE '?').LGZT800
&B1      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
.LGZT800 ANOP
         AIF   ('&C'(1,1) NE '(').LGZT810
&C       SETC  '0&C'               Change Notation of (1) to a 0(1)
.LGZT810 ANOP
         AIF   ('&SHOW(&I+2)'(1,1) NE '(').LGZT820
&B2      SETB  1                   Indicate the Length in Register
.LGZT820 ANOP
         RLLG  R0,R0,&C            Address for the Data To Print
         DC    YL2(&SHOW(&I+2))    Length of the Data To Print
&LB      SETC  'T&SYSNDX.&I'       Generate a Unique Label
         DC    BL1'&B0.&B1.&B2.00000' ...Data Processing Flag Byte
         DC    YL1(L'&LB)          Length of the Header
&LB      DC    C&SHOW(&I)
&I       SETA  &I+3                Get the Next Sub-Parameter
         AGO   .LGZT780            Loop to Process Next Sub-Parameter
.LGZT830 ANOP
&V1      SETA  K'&SHOW(&J,1)       Establish Char Count on Data Area
&V       SETA  &V1/2*2             Set an Integer Result on Char Count
         AIF   (&V1 EQ &V).LGZT840   Character Count on Data Area Even?
         DC    X'40'               Add Fill Byte for Halfword Alignment
.LGZT840 ANOP
D&SYSNDX.L EQU *-D&SYSNDX          Length of the Log Point Data Area
.*
.**********************************************************************
.*  If Specified By User Generate Code for the WATCH= Parameter       *
.**********************************************************************
.*
.LGZW100 ANOP
         AIF   ('&WT' EQ '0').LGZW260 Generate Storage Watch if Present
         DC    YL2(D&SYSNDX.L)     Length of the WATCH= Area
&B0      SETB  0                   Constant Points at 31-Bit Address
&B1      SETB  0                   Constant Points at 24-Bit Address
&B2      SETB  0                   Length is in a Register
&B3      SETB  1                   Data Request Includes Storage Watch
D&SYSNDX EQU   *                   Beginning of the WATCH= Parameter
         AIF   ('&WATCH'(1,2) NE '((').LGZW180
&I       SETA  1
.LGZW110 ANOP
         AIF   (&I GT N'&WATCH).LGZW170   ...At End of the Sublist?
         AIF   ('&WATCH(&I,1)'(1,1) NE '''').MNOTE9 ..Must Be Quoted
&C       SETC  '&WATCH(&I,2)'       Obtain Address of Data to Print
         AIF   ('&C'(1,1) NE '%').LGZW120
&B0      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
         AGO   .LGZW130            Branch to Check for Notation
.LGZW120 ANOP
         AIF   ('&C'(1,1) NE '?').LGZW130
&B1      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
.LGZW130 ANOP
         AIF   ('&C'(1,1) NE '(').LGZW140
&C       SETC  '0&C'               Change Notation of (1) to a 0(1)
.LGZW140 ANOP
         AIF   ('&WATCH(&I,3)'(1,1) NE '(').LGZW150
&B2      SETB  1                   Indicate the Length in Register
.LGZW150 ANOP
         RLLG  R0,R0,&C            Address for the Data To Print
         DC    YL2(&WATCH(&I,3))   Length of the Data To Print
&LB      SETC  'T&SYSNDX.&I'       Generate a Unique Label
         DC    BL1'&B0.&B1.&B2.000&B3.0' .Data Processing Flag Byte
         DC    YL1(L'&LB)          Indicate the Length of Header
&LB      DC    C&WATCH(&I,1)
&M1      SETA  K'&WATCH(&I,1)      Establish Character Count on Header
&M       SETA  &M1/2*2             Set an Integer Result on Char Count
         AIF   (&M1 EQ &M).LGZW160   Is Character Count on Header Even?
         DC    X'40'               Add Fill Byte for Halfword Alignment
.LGZW160 ANOP
&I       SETA  &I+1                Get the Next Sub-Parameter
&B0      SETB  0                   Reset Constant Indicator for 31-Bit
&B1      SETB  0                   Reset Constant Indicator for 24-Bit
&B2      SETB  0                   Reset Leng in Register Indicator
         AGO   .LGZW110            Loop to Process Next Subparameter
.LGZW170 ANOP
D&SYSNDX.L EQU *-D&SYSNDX          Length of the Data Area
         AGO   .LGZW260            Branch to Restore Registers
.*
.**********************************************************************
.* Process When More Than One Entry Was Specified for WATCH= Parameter*
.* as in WATCH=(('WORKAREA',WRKAREA,L'WRKAREA),('TEMPAREA',(R2),256)) *
.**********************************************************************
.*
.LGZW180 ANOP
&J       SETA  N'&WATCH            Number of Items in List
&I       SETA  (&J/3)*3            Ensure There Are Groups of 3
         AIF   (&I NE &J).MNOTE5   Indicate Error If Not
&J       SETA  &J/3                Count of Groups to Process
&I       SETA  1
.LGZW190 ANOP
         AIF   (&I GT N'&WATCH).LGZW240     ...At End of Sublist?
         AIF   ('&WATCH(&I)'(1,1) NE '''').MNOTE9 ..Must Be Quoted
&C       SETC  '&WATCH(&I+1)'      Get Address of Data to Print
         AIF   ('&C'(1,1) NE '%').LGZW200
&B0      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
         AGO   .LGZW210            Branch to Check Notation
.LGZW200 ANOP
         AIF   ('&C'(1,1) NE '?').LGZW210
&B1      SETB  1
&C       SETC  '&C'(2,K'&C-1)      Remove the Redirection Indicator
.LGZW210 ANOP
         AIF   ('&C'(1,1) NE '(').LGZW220
&C       SETC  '0&C'               Change Notation of (1) to a 0(1)
.LGZW220 ANOP
         AIF   ('&WATCH(&I+2)'(1,1) NE '(').LGZW230
&B2      SETB  1                   Indicate the Length in Register
.LGZW230 ANOP
         RLLG  R0,R0,&C            Address for the Data To Print
         DC    YL2(&WATCH(&I+2))   Length of the Data To Print
&LB      SETC  'T&SYSNDX.&I'       Generate a Unique Label
         DC    BL1'&B0.&B1.&B2.000&B3.0' .Data Processing Flag Byte
         DC    YL1(L'&LB)          Length of the Header
&LB      DC    C&WATCH(&I)
&I       SETA  &I+3                Get the Next Sub-Parameter
         AGO   .LGZW190            Loop to Process Next Sub-Parameter
.LGZW240 ANOP
&V1      SETA  K'&WATCH(&J,1)      Establish Char Count on Data Area
&V       SETA  &V1/2*2             Set an Integer Result on Char Count
         AIF   (&V1 EQ &V).LGZW250   Character Count on Data Area Even?
         DC    X'40'               Add Fill Byte for Halfword Alignment
.LGZW250 ANOP
D&SYSNDX.L EQU *-D&SYSNDX          Length of the Log Point Data Area
.LGZW260 ANOP                      Continue with Next Source Statement
         DC    0H                  End of Logpoint Area Halfword Align
&LGRNAME LOCTR ,                   Resume Location Counter for RSECT
P&SYSNDX ICM   R0,B'1100',&PX.PSWLC+2 Get Condition Code and Pgm Mask
         SPM   R0                  Restore PSW CC/Mask Before Log Point
         LMG   R14,R1,&PX.WR141    Restore Regs From Before Log Point
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.**********************************************************************
.*   Error Messages                                                   *
.**********************************************************************
.*
.MNOTE1  ANOP
         MNOTE 8,'No label was provided.  A label is required.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE2  ANOP
         MNOTE 8,'TYPE=&TYPE, is an invalid value for parameter.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE3  ANOP
         MNOTE 8,'COMPRESS=&COMPRESS, is an invalid parameter value.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE4  ANOP
         MNOTE 8,'REG=&REG, is an invalid value for parameter.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE5  ANOP
         MNOTE 8,'WATCH= Must be specified in groups of 3 parameters.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE6  ANOP
         MNOTE 8,'SHOW= sub-parameter #1 must be enclosed in quotes.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE7  ANOP
         MNOTE 8,'SHOW= Must be specified in groups of 3 parameters.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE8  ANOP
         MNOTE 8,'SUPHEAD=&SUPHEAD, is an invalid value for parameter.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE9  ANOP
         MNOTE 8,'WATCH= sub-parameter #1 must be enclosed in quotes.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MNOTE10 ANOP
         MNOTE 8,'PVTAREA=&PVTAREA, is an invalid parameter value.'
         AGO   .MEND               Exit to Source-Setup Macro Trailer
.*
.MEND    ANOP                      End of Program Log Point Protocol
         MEND                      Terminate Logger Defined Macro #2
         PRINT ON
