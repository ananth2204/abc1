***********************************************************************
*LLL      GGGGGGG M     M H      H LLL       RRRRRRR  CCCCCCC EEEEEEE *
* L       G     G MM   MM H      H  L        R      R C     C E     E *
* L       G       M M M M H      H  L        R      R C       E       *
* L       G  GGGG M  M  M HHHHHHHH  L        RRRRRRR  C       EEEEE   *
* L       G     G M     M H      H  L        R    R   C       E       *
* L       G     G M     M H      H  L        R     R  C     C E     E *
* LLLLLLL GGGGGGG M     M H      H  LLLLLLLL R      R CCCCCCC EEEEEEE *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHLRCE                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Log Record Event Publishing        *
*                                                                     *
* INPUT DATA:      R14     => Return Point                            *
*                  4(,R14) => Log Point Area Data Mapped by LGRPT2II  *
*                  R13     => Caller's LCA Area (Save Area) Which     *
*                             Contains Field LCATRCDS Holding Pointer *
*                             to Logger Service Work Area Area Mapped *
*                             by the LGRWK2II Dsect Defined in        *
*                             Copybook LGCPLSWA.                      *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* SERIALIZATION:   LGWTCBAD lockword in LGRWK2II Work Area            *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, (RLINK1) Branch and Save Reg + Return Address *
*                  R13, (RTRC)   Savearea & Dynamic Area (LGRWK2II)   *
*                  R12, (RBASE1) First Program Base Register          *
*                  R11, (RBASE2) Second Program Base Register         *
*                  R10, (RBASE3) Third Program Base Register          *
*                  R9,  (RTLG)   Address to Log Point Area (LGRPT2II) *
*                  R8,  (RLCA)   Dynamic Area LCA                     *
*                  R7,  (RPGM)   Address of PGMLG2II Area (LGRWK2II)  *
*                  R6,  (RLINE)  Current Position in Output Line      *
*                  R0-R5, General Work Registers                      *
*                                                                     *
* CALLING PROGRAM: User Program                                       *
*                                                                     *
* CALLED PROGRAMS: LGMHWTCH - Logger Services Storage Watch Program   *
*                  LGMHPSTG - Logger Services Display Private Area    *
*                             Program                                 *
*                  LGMHLRCB - Logger Services Log Record Program for  *
*                             Buffering Records Above-the-Line        *
*                  LGMHLB64 - Logger Services Log Record Program for  *
*                             Buffering Records Above-the-Bar         *
*                                                                     *
* RETURN CODES:    00, Success                                        *
*                  04, Warning                                        *
*                  08, Error                                          *
*                  12, Severe Error                                   *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Change   V1R1M17 20120721 Added Support for the Writing of Log @@KHF*
*                           Records to Above-the-Bar Storage Area@@KHF*
* Change                    Added Support for 20-Bit Displacement@@KHF*
*                           to Allow 1 Megabyte Addressability to@@KHF*
*                           Fields Specified by User in Logpoint.@@KHF*
* Change   V1R1M16 20120127 Changes to Support Reduced Footprint @@KHF*
*                           Through LOCTR for #LGPOINT Data Area.@@KHF*
* Fix      V1R1M15 20110930 Wrapped PUT with SYSSTATE AMODE64=NO/@@KHF*
*                           YES Sequence to Conform to New DFSMS @@KHF*
*                           Macro Changes Introduced in zOS V1R13@@KHF*
*                           That Test for the Sysstate Amode.    @@KHF*
* Change   V1R1M14 20110423 Added Equates for Access Registers   @@KHF*
* Change   V1R1M13 20110108 Added Support for Display of the CPU @@KHF*
*                           State, PSW Key, and Addressing Mode  @@KHF*
*                           at Program Entry and Program Exit.   @@KHF*
* Change                    Obtain Time Stamp Moved from LGCPLOGR@@KHF*
*                           and Placed at LGMHLRCE Program Entry.@@KHF*
* Update   V1R1M12 20100306 Update VV.RR.MM stats for Fix Pack 12@@KHF*
* Fix      V1R1M11 20091023 Reset Odd Addr on Amod64 Branch Entry@@KHF*
* Fix      V1R1M10 20090523 S0C4 in Load Module Search when High @@KHF*
*                           Half of Reg not Cleared Before Load. @@KHF*
* Fix      V1R1M09 20090110 Get of TCBFSA addr moved to LGMHLRCI @@KHF*
* Update   V1R1M08 20081010 Changes to Support LGMHPSTG Pgm Call.@@KHF*
*                           REG= Now Shows the Access Registers  @@KHF*
* Change   V1R1M07 20080524 Print Chars Added to Translate Table @@KHF*
* Update   V1R1M06 20080223 Updated VV.RR.MM stats for Fix Pack 6@@KHF*
* Fix      V1R1M05 20080112 Incorrect Ordinal Day When a Leap Yr @@KHF*
* Update   V1R1M04 20071104 Updated VV.RR.MM stats for Fix Pack 4@@KHF*
* Fix      V1R1M03 20070701 S0C9 When Attempting Retry From Abend@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Add Support For Log Rcrd Trim Option @@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Program
         LCLC  &RMODE              Resident Mode of Program
&KXHVER  SETC  'V1'                Indicate the Program Version Number
&KXHREL  SETC  'R1'                Indicate the Program Release Number
&KXHMOD  SETC  'M17'               Indicate the Pgm Modification Level
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&CPYRITE SETC  '2008,2012'         Program Copyright Year
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
&MODID   SETC  'LGMHLRCE'          Set the Program Module Identifier
*
*+-------------------------------------------------------------------+*
*|   D e f i n e   G e n e r i c   R e g i s t e r   E q u a t e s   |*
*+-------------------------------------------------------------------+*
*
R0       EQU   0                   Define Program Register 0 Equate
R1       EQU   1                   Define Program Register 1 Equate
R2       EQU   2                   Define Program Register 2 Equate
R3       EQU   3                   Define Program Register 3 Equate
R4       EQU   4                   Define Program Register 4 Equate
R5       EQU   5                   Define Program Register 5 Equate
R6       EQU   6                   Define Program Register 6 Equate
R7       EQU   7                   Define Program Register 7 Equate
R8       EQU   8                   Define Program Register 8 Equate
R9       EQU   9                   Define Program Register 9 Equate
R10      EQU   10                  Define Program Register 10 Equate
R11      EQU   11                  Define Program Register 11 Equate
R12      EQU   12                  Define Program Register 12 Equate
R13      EQU   13                  Define Program Register 13 Equate
R14      EQU   14                  Define Program Register 14 Equate
R15      EQU   15                  Define Program Register 15 Equate
AR0      EQU   0                   Define Access Register 0 Equate
AR1      EQU   1                   Define Access Register 1 Equate
AR2      EQU   2                   Define Access Register 2 Equate
AR3      EQU   3                   Define Access Register 3 Equate
AR4      EQU   4                   Define Access Register 4 Equate
AR5      EQU   5                   Define Access Register 5 Equate
AR6      EQU   6                   Define Access Register 6 Equate
AR7      EQU   7                   Define Access Register 7 Equate
AR8      EQU   8                   Define Access Register 8 Equate
AR9      EQU   9                   Define Access Register 9 Equate
AR10     EQU   10                  Define Access Register 10 Equate
AR11     EQU   11                  Define Access Register 11 Equate
AR12     EQU   12                  Define Access Register 12 Equate
AR13     EQU   13                  Define Access Register 13 Equate
AR14     EQU   14                  Define Access Register 14 Equate
AR15     EQU   15                  Define Access Register 15 Equate
RBASE1   EQU   12                  Establish Program Base Register 1
RBASE2   EQU   11                  Establish Program Base Register 2
RBASE3   EQU   10                  Establish Program Base Register 3
RTLG     EQU   9                   Establish Log Point Area Base Reg
RLCA     EQU   8                   Establish Caller's LCA Address (R13)
RPGM     EQU   7                   Address of Associated PGMLG2II Area
RLINE    EQU   6                   Current Position in Print Line
RLINK1   EQU   14                  Branch and Save Register (BRAS)
         EJECT  ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHLRCE - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHLRCE                                           *
*                                                                     *
* FUNCTION:        Program Logger Service                             *
*                                                                     *
*                  This routine is the main driver and entry point for*
*                  processing the Logger. The basic function of this  *
*                  main control program is to direct the calls to     *
*                  other subroutines. This program is called only if  *
*                  the Logger Services initialization program named   *
*                  'LGMHLRCI' has determined that logging is currently*
*                  enabled for execution of a user's job. If logging  *
*                  was enabled, then the LGMHLRCI program created the *
*                  environment to allow this Logger Service program to*
*                  be called each time a Logger Service request coded *
*                  in the source of a user's program is entered. What *
*                  this means is if there is a #LGPOINT in your source*
*                  that is enabled, then this LGMHLRCE program is the *
*                  program which gets called.                         *
*                                                                     *
*                  When a Logpoint is coded by the user in their      *
*                  Assembler program source, at assembly the Logpoint *
*                  code is generated by Logger Services in the user's *
*                  program with a pointer to LGMHLRCE. At program     *
*                  execution when the Logpoint is encountered in the  *
*                  user's program, this LGMHLRCE program is entered by*
*                  an Execute of a BASSM instruction by the Logpoint  *
*                  in the user's program. On entry to this program the*
*                  return address to the user's program is in R14. At *
*                  R14 + 4 bytes is a pointer to the address of the   *
*                  Logpoint parameter data area in the user's program.*
*                  The Logpoint parameter data area is the input which*
*                  is extracted and used by this Logger Services      *
*                  program to direct what is produced in the output   *
*                  log report. When coded by the user a Logpoint will *
*                  generate a footprint of 48 bytes of executable code*
*                  within the user's program that is required to setup*
*                  the call to Logger Services. The Logpoint parameter*
*                  data area will reside in a different part of the   *
*                  control section outside of the user's in-line code *
*                  so it does not use up the addressable range of a   *
*                  base register. So the executable instructions of a *
*                  Logpoint used for calling Logger Services and the  *
*                  data area for that Logpoint remain in their logical*
*                  sequence for easier reading of the listing. However*
*                  the data area generated for each Logpoint will be  *
*                  preceded by a LOCTR Assembler directive identifying*
*                  a different location counter under which the       *
*                  Logpoint data area is to be assembled. This removes*
*                  the expansion of the Logpoint data area within the *
*                  user's in-line code addressable by a base register.*
*                                                                     *
* For Example:                                                        *
*                                                                     *
*  Suppose user codes the following Logpoint somewhere in their       *
*  Assembler source code.                                             *
*                                                                     *
*  XYZ$0300 DS   0H                                                   *
*                                                                     *
*  and the label is changed to                                        *
*                                                                     *
*  XYZ$0300 #LGPOINT SHOW=('Time Stamp',DSNWORKD,L'DSNWORKD),REG=ALL  *
*                                                                     *
*  Then at program execution of the #LGPOINT, the SHOW= will capture  *
*  all the data in field DSNWORKD for the length of field DSNWORKD.   *
*  Also with REG=ALL the contents of the 16 general purpose registers *
*  and access registers are captured. The #LGPOINT code example shown *
*  below is what would be generated automatically in the user's       *
*  program at assembly time. When the user's program is executed and  *
*  the #LGPOINT is encoutered, the 'EX R0,XYZLGPTT' instruction shown *
*  below results in the branch from the #LGPOINT in the user's program*
*  to this LGMHLRCE program to process the logpoint request. The      *
*  parameter data area created by the #LGPOINT is at the label L0017  *
*  in the user's program, and is referenced by this LGMHLRCE program  *
*  so it can determine the actions requested by the user in the       *
*  #LGPOINT.                                                          *
*                                                                     *
* XYZ$0300 DS    0H                                                   *
*          STMG  R14,R1,XYZWR141     Save Current Registers Over Log P*
*          EPSW  R0,R1               Extract Bits 0-63 of Current PSW *
*          STM   R0,R1,XYZPSWLC      Save Current Program Status Word *
*          LLGT  R15,XYZVCON         Address of Log Process Pgm(LGMHLR*
*          O     R15,XYZP408         Turn On the Low Order AMODE-64 Bi*
*   ===>   EX    R0,XYZLGPTT         Execute the Appropriate Log Point*
*          BRU   P0017               Branch Around the Log Point Data *
*          DC    AL4(L0017)          Addr of LogPoint Parameter Data A*
* L0017    LOCTR ,                   Reset Location Counter for Data A*
*          DC    CL4'LPNT'           Set Logger Event Information Type*
*          DC    AL4(PX30001-PE00001)   Set the Program Exit Address  *
*          DC    BL2'1111111111111111'  Indicate Which Registers to Lo*
*          DC    BL1'01100000'       Flag Byte for Parameters Specifie*
*          DC    AL1(L'N0017)        Number of Characters in Name     *
* N0017    DC    C'XYZ$0300'         Name of This User Program Log Poi*
* N0017L     EQU *-L0017             Length of Data Area Prefix Sectio*
*          DC    YL2(D0017L)         Length of the SHOW= Area         *
* D0017    EQU   *                   Beginning of the SHOW= Parameter *
*          RLLG  R0,R0,DSNWORKD      Address for the Data To Print    *
*          DC    YL2(L'DSNWORKD)     Length of the Data To Print      *
*          DC    BL1'00000000'          ...Data Processing Flag Byte  *
*          DC    YL1(L'T00171)       Length of the Header             *
* T00171   DC    C'Time Stamp'                                        *
* D0017L     EQU *-D0017             Length of the Log Point Data Area*
*          DC    0H                  End of Logpoint Area Halfword Ali*
* XYZTEST2 LOCTR ,                   Resume Location Counter for RSECT*
* P0017    ICM   R0,B'1100',XYZPSWLC+2  Get Condition Code and Pgm Mas*
*          SPM   R0                  Restore PSW CC/Mask Before Log Po*
*          LMG   R14,R1,XYZWR141     Restore Regs From Before Log Poin*
*                                                                     *
*                  This program prints user program information based *
*                  on the parameters set in the Logpoint. Upon entry  *
*                  this Logger Services program will determine if this*
*                  is a program, sub-program, subroutine or log point *
*                  request. For a program entry request, this program *
*                  will utilize a filter for the program name to      *
*                  verify if logging was requested for the specified  *
*                  program Csect name. Filter values are specified    *
*                  through the //LGRSYSIN DDname. If no logging is in *
*                  effect for the specific program/Csect name due to  *
*                  filtering being in effect, then this Logger        *
*                  Services program exits. If logging is turned on    *
*                  and filtering is not in effect for the program,    *
*                  sub-program, subroutine or log point request       *
*                  defined in the user's program, then this Logger    *
*                  Services program will enable the request by setting*
*                  the proper indicators in the user program Logger   *
*                  Control Area (LCA). If a request is processed by   *
*                  this program, then the extracted logger data       *
*                  containing information about the user program while*
*                  it is executing will be formatted and printed to   *
*                  the //LGRECOUT DCB based on the type of log request*
*                  made by the user program.                          *
*                                                                     *
*                  In various points of this program abend protection *
*                  will be switched on and off. For any part of the   *
*                  program path at risk of processing bad data from   *
*                  the user program, a retry address will be inserted *
*                  in the LGWRETRY field of the LGRWK2II Dsect to     *
*                  enable ESTAE protection, and a bit will be set to  *
*                  suppress any dumps. This will prevent a possible   *
*                  abend in this program from terminating the user    *
*                  program. When that part of the LGMHLRCE program    *
*                  path at risk of an abend has completed, then ESTAE *
*                  protection is switched off by clearing the LGWRETRY*
*                  field to zeros, and clearing the suppress dump bit.*
*                                                                     *
***********************************************************************
*
&MODID   RSECT *                   Program Main Control Section Name
&MODID   AMODE &AMODE              Addressing Mode - &AMODE
&MODID   RMODE &RMODE              Resident Mode   - &RMODE
         SYSSTATE AMODE64=YES,ARCHLVL=2 ...Establish 64-Bit Environment
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LGHA0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   DUMMYPNT            Branch Past the Literal Area
         DC    C'&MODID'           Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date & Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
       SPLEVEL SET=6               Set for OS/390 R2 or Above (z/OS+)
DUMMYPNT DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,RBASE1       Ensure Base Reg Has a Good Address
         LA    RBASE2,2048(,RBASE1)  Load 2nd Base w/ Addressable Range
         LA    RBASE2,2048(,RBASE2)  Add to the Preceding Address Range
         LLGTR RBASE2,RBASE2       Ensure Base Reg Has a Good Address
         LA    RBASE3,2048(,RBASE2)  Load 3rd Base w/ Addressable Range
         LA    RBASE3,2048(,RBASE3)  Add to the Preceding Address Range
         LLGTR RBASE3,RBASE3       Ensure Base Reg Has a Good Address
         USING &MODID+(LGHA0001-LGMHLRCE),RBASE1,RBASE2,RBASE3 Base Reg
         USING PGMLG2II,RPGM       Establish Names Table Addressability
         LGR   RLCA,R13            Save Caller's Logger Control Area
         USING LCA,RLCA            Establish Addressability to LCA
         N     R14,=A(X'FFFFFFFE') Turn Off the Low-Order AMODE-64 Bit
         LA    RTLG,4(,R14)        Pointer to Log Point Data Address
         LLGTR RTLG,RTLG           Ensure Base Reg Has a Good Address
         LLGT  RTLG,0(,RTLG)       Get Address to Log Point Data Area
         USING LGRPT2II,RTLG       Establish Addressability to Area
         LLGT  R15,LCATRCDS        Get Address of LGRWK2II for Our Pgm
         USING LGRWK2II,R13        Establish Addressability to Area
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         STG   R15,LCAF64FWD-LCASAVE(,R13) Set Forward Chain Pointer
         STG   R13,LCAF64BCK-LCASAVE(,R15) Set the Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R15),=CL4'F4SA' Indicate Format 4
         LGR   R13,R15             LGRWK2II is Logger's Dynamic Area
         STCKE LGWTSTCK            Save Current CPU Clock on Log Entry
*
*+-------------------------------------------------------------------+*
*|  Obtain the Lock For The Logger Area (LGRWK2II) to Serialize      |*
*|  Logger Activity.                                                 |*
*+-------------------------------------------------------------------+*
*
LGRC1000 DS    0H
         SLGR  R1,R1               To Check if TCB Lock Addr is Clear
         SLGR  R2,R2               To Ensure Upper Half of Reg is Clear
         ICM   R2,B'1111',LCATCBAD There a Current TCB Address in LCA?
         BRZ   LGRCEXIT            No  => Then Branch to Exit
         TM    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun?
         BRO   LGRCEXIT            Yes => Then Branch to Exit
         LA    R3,20               Set a Maximum Retry Count
         LA    R5,10               Set a Wait Interval of 1/10 Second
         STCM  R5,B'1111',LCABINTV Preserve Binary Wait Interval Time
         LLGT  R4,=A(LGRTIMER)     Point to Area Containing Timer List
         MVC   LCA$CXAC(LGRTIMRL),0(R4) Fill Remote Parameter List Area
LGRC1100 DS    0H
         CS    R1,R2,LGWTCBAD      Did We Get the Logger Area Lock?
         BRZ   LGRC2000            Yes => Then Branch to Process Logger
         LA    R5,LCABINTV         Get Addr of Binary Wait Time Field
         LA    R4,LCA$CXAC+LGRTIMRL Establish Addr for Timer Identifier
       STIMERM SET,                Request to Establish Time Interval  X
               BINTVL=(R5),        Address of Binary Wait Time Value   X
               WAIT=YES,           Suspend Task Until Interval Expires X
               ID=(R4),            Establish Area for Timer Service Id X
               MF=(E,LCA$CXAC)     Remote Program Parameter List
         BRCTG R3,LGRC1100         Loop to Retry for Up to 2 Seconds
         BRU   LGRCEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Perform Logger Initialization Process                          |*
*+-------------------------------------------------------------------+*
*
LGRC2000 DS    0H
         XC    LGWACCUM,LGWACCUM   Clear Loggr Record Accumulator Count
         BRAS  RLINK1,TINI0000     Perform Loggr Initialization Process
         BRU   LGRC3000            Pointer to Program List Area
         BRU   LGRC4000            A Zero Pointer to Program List Area
*
*+-------------------------------------------------------------------+*
*|    Check if This Request for Logger Services is for a User        |*
*|    Program Entry                                                  |*
*|                                                                   |*
*|    USRTEST1 LPGMNTRY TYPE=MAIN,                                   |*
*|                                                                   |*
*|    USRINIT1 LPGMNTRY TYPE=SUB,                                    |*
*+-------------------------------------------------------------------+*
*
LGRC3000 DS    0H
         CLC   LGRTYPE,=C'LPRG'    Is Logger Request For Program Entry?
         BRNE  LGRC4000            No  => Branch to Check Program Exit
         BRAS  RLINK1,TPGM0000     Process for Logging at Program Entry
         BRU   LGRCEXIT            Branch to Exit LGMHLRCE Program
*
*+-------------------------------------------------------------------+*
*|    Check if This Request for Logger Services is for a User        |*
*|    Program Exit                                                   |*
*|                                                                   |*
*|    USRETURN LPGMEXIT RC=USR$RC                                    |*
*+-------------------------------------------------------------------+*
*
LGRC4000 DS    0H
         CLC   LGRTYPE,=C'LPRX'    Is Logger Request For Program Exit?
         BRNE  LGRC5000            No  => Check for Subroutine Entry
         BRAS  RLINK1,TPGX0000     Process for Logging at Program Exit
         BRU   LGRCEXIT            Branch to Exit LGMHLRCE Program
*
*+-------------------------------------------------------------------+*
*|    Check if This Request for Logger Services is for a User        |*
*|    Program Subroutine Entry                                       |*
*|                                                                   |*
*|    ABCDE100 LPGMSUBE ,                                            |*
*+-------------------------------------------------------------------+*
*
LGRC5000 DS    0H
         CLC   LGRTYPE,=C'LSBE'    Logger Request For Subroutine Entry?
         BRNE  LGRC6000            No  => Check for Subroutine Exit
         BRAS  RLINK1,TSUB0000     Process Logging at Subroutine Entry
         BRU   LGRCEXIT            Branch to Exit LGMHLRCE Program
*
*+-------------------------------------------------------------------+*
*|    Check if This Request for Logger Services is for a User        |*
*|    Program Subroutine Exit                                        |*
*|                                                                   |*
*|    WXYZ1000 LPGMSUBX ,                                            |*
*+-------------------------------------------------------------------+*
*
LGRC6000 DS    0H
         CLC   LGRTYPE,=C'LSBX'    Logger Request For Subroutine Exit?
         BRNE  LGRC7000            No  => Branch to Check Log Point
         BRAS  RLINK1,TSBX0000     Process Logging at Subroutine Exit
         BRU   LGRCEXIT            Branch to Exit LGMHLRCE Program
*
*+-------------------------------------------------------------------+*
*|    Check if This Request for Logger Services is for a User        |*
*|    Program Defined Log Point                                      |*
*|                                                                   |*
*|    ABCDE500 #LGPOINT REG=ALL                                      |*
*+-------------------------------------------------------------------+*
*
LGRC7000 DS    0H
         CLC   LGRTYPE,=C'LPNT'    Logger Request For a Log Point?
         BRNE  LGRCEXIT            No  => Branch to Exit LGMHLRCE Pgm
         BRAS  RLINK1,LGPT0000     Process for a Log Point Entry
         BRU   LGRCEXIT            Branch to Exit LGMHLRCE Program
*
*+-------------------------------------------------------------------+*
*|    Return to Caller of Logger Services (The User's Program)       |*
*+-------------------------------------------------------------------+*
*
LGRCEXIT DS    0H
         XC    LGWTCBAD,LGWTCBAD   Release the Logger Service Area Lock
         LAM   AR0,AR15,LGWACREG   Restore the Current Access Registers
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LMG   R14,R12,LCAF64R14-LCASAVE(R13) Restore Callers Registers
         BSM   R0,R14              Return to Caller
*
***********************************************************************
*                 End of LGMHLRCE Main Program                        *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*| RRRRRRR   OOOOO  U     U TTTTTTT IIIIIII N     N EEEEEEE   SSSSS  |*
*| R      R O     O U     U    T       I    NN    N E        S     S |*
*| R      R O     O U     U    T       I    N N   N E        S       |*
*| RRRRRRR  O     O U     U    T       I    N  N  N EEEEEE    SSSSS  |*
*| R    R   O     O U     U    T       I    N   N N E              S |*
*| R     R  O     O U     U    T       I    N    NN E        S     S |*
*| R      R  OOOOO   UUUUU     T    IIIIIII N     N EEEEEEE   SSSSS  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************| T I N I 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|    P e r f o r m   I n i t i a l i z a t i o n   P r o c e s s    |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TINI0000                                           *
*                                                                     *
* FUNCTION:        Logger Initialization                              *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  initialization for active Logger services. It will *
*                  index to the Log Record area and check for a       *
*                  program list area. Then this routine will preserve *
*                  the contents of the user program's registers at    *
*                  entry to a Logpoint where they will be processed   *
*                  later for display in the Logger services output    *
*                  report.                                            *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
TINI0000 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         XC    LGWRTCNT,LGWRTCNT   Clear Retry Count for This Log Point
TINI1000 DS    0H
         SLGR  RPGM,RPGM           Clear Register For Address Insertion
         ICM   RPGM,B'1111',LGWPGML .There a Pntr to Program List Area?
         BRNZ  TINI2000            Yes => Branch for Register Values
         LA    RLINK1,4(,RLINK1)   Set the Return Linkage Offset
         BRU   TINIEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|      Obtain the 64-Bit Register Values at User Program Entry      |*
*+-------------------------------------------------------------------+*
*
TINI2000 DS    0H
         CLC   LGRTYPE,=C'LPRG'    This Log Event For A Program Entry?
         BRNE  TINI3000            No  => Then Branch to Save Registers
         CLC   LCASAVE+L'LCAS64F5A(L'LCAS64F5A),=C'F5SA' From Main Pgm?
         BRNE  TINI3000            No  => Then Entry is to Sub-Program
TINI2100 DS    0H
         STAM  AR0,AR15,LGWACREG   Save the Current Access Registers
         STMG  R0,R12,LGWSAVRG     Save the General Purpose Registers
         LG    R15,LCASAVE+(LCAS64BCK-LCASAVE) Callers Caller Save Area
         LM    R0,R12,LCASA_R0-LCASAVE(R15)  Get Low Half R0 Thru R12
         L     R15,LCASA_FWD-LCASAVE(R15) Get the Forward Chain Pointer
         LMH   R0,R12,LCAH64R00-LCASAVE(R15) Get High Half R0 Thru R12
         STMG  R0,R12,LGWREG0      Save High and Low Half Regs at Entry
         LMH   R0,R1,LCAH64R14-LCASAVE(R15) Get High Half R14 Thru R15
         STMH  R0,R0,LGWREG14      Save Hi Half R14 Reg Value at Entry
         STMH  R1,R1,LGWREG15      Save Hi Half R15 Reg Value at Entry
         LMG   R0,R12,LGWSAVRG     Restore the Current Work Registers
         LG    R15,LCASAVE+(LCAS64BCK-LCASAVE) Callers Caller Save Area
         LM    R0,R1,LCASA_R14-LCASAVE(R15) Get Low Half R14 Thru R15
         ST    R0,LGWREG14+L'LGWREG14/2  Save Low Half R14 Reg at Entry
         ST    R1,LGWREG15+L'LGWREG15/2  Save Low Half R15 Reg at Entry
         MVC   LGWREG13,LCASAVE+(LCAS64BCK-LCASAVE) Get Value in Reg 13
         BRU   TINIEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| Obtain 64-Bit Register Values for All Other Logger Service Events |*
*+-------------------------------------------------------------------+*
*
TINI3000 DS    0H
         STAM  AR0,AR15,LGWACREG   Save the Current Access Registers
         MVC   LGWREG0(2*L'LGWREG0),LCAWR141+16  Get Values for R0 & R1
         MVC   LGWREG2(LGWREGL2),LCAF64R02-LCASAVE(RLCA)    R2 Thru R12
         STG   RLCA,LGWREG13       Obtain the Value for Our Register 13
         MVC   LGWREG14(LGWRGL14),LCAWR141  Obtain Values for R14 & R15
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TINIEXIT DS    0H
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*               End of Logger Initialization Processing               *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| T P G M 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*| P e r f o r m   L o g g i n g   F o r   P r o g r a m   E n t r y |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TPGM0000                                           *
*                                                                     *
* FUNCTION:        Logging for Program Entry                          *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  build of log records at entry to a user program.   *
*                                                                     *
*                  Label    LPGMNTRY Ýparameters¨                     *
*                  USRTEST1 LPGMNTRY TYPE=MAIN,                       *
*                  USRTEST1 LPGMNTRY TYPE=SUB,                        *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|    Determine the Program Name From Input Address                  |*
*+-------------------------------------------------------------------+*
*
TPGM0000 DS    0H
         STG   RLINK1,LGWRLNK1     Save Our Linkage Register Address
         LG    R15,LCASAVE+(LCAF64BCK-LCASAVE) Callers Caller Save Area
         CLC   LCASAVE+L'LCAS64F5A(L'LCAS64F5A),=C'F5SA' From Main Pgm?
         BRNE  TPGM0100            No  => Then Entry is to Sub-Program
         LLGF  R15,(LCASA_R15-LCASAVE)(,R15) Get Caller's Entry Pnt Adr
         BRU   TPGM0200            Branch to Process for Csect Name
TPGM0100 DS    0H
         LLGF  R15,(LCAF64R15-LCASAVE)+4(,R15) Caller's Entry Point Adr
TPGM0200 DS    0H
         BRAS  RLINK1,TNME0000     Translate Address to a CSECT Name
*
*+-------------------------------------------------------------------+*
*|    Determine If Program Name in the Program Names Table           |*
*+-------------------------------------------------------------------+*
*
TPGM0300 DS    0H
         SLGR  RPGM,RPGM           To Ensure Upper Half of Reg is Clear
         ICM   RPGM,B'1111',LGWPGML ...There a Pointer to Program List?
         BRZ   TPGM1000            No  => Bypass Logging of This Progrm
         ICM   R14,B'1111',PGMLNTH ..Is There a Total Length for Table?
         BRZ   TPGM1000            No  => Bypass Logging of This Progrm
         SH    R14,=Y(L'PGMPREFX)  Tble Leng Represent Only the Prefix?
         BRZ   TPGM1000            Yes => Null Table, Bypass Logging
TPGM0400 DS    0H
         MVC   LGWWRK64(L'LGWLMOD),LGWLMOD Get Current Program's Nme
         MVC   LGWWRK64+L'LGWLMOD(L'LGWCSECT),LGWCSECT Get Csect Name
         NC    LGWWRK64,PGMPMASK   Mask Out the Wildcard Characters
         CLC   LGWWRK64,PGMPNAME   Perform Logging for This Program?
         BRE   TPGM2000            Yes => Check for Logger Requests
TPGM0500 DS    0H
         SH    R14,PGMPLNTH        Length of Pgm Entry from Pgm Table
         BRZ   TPGM0600            None Left, Check for Any Added Logs
         AH    RPGM,PGMPLNTH       Bump to the Next Program Name Entry
         BRU   TPGM0400            Loop to Process Next Pgm Name in Tbl
*
*+-------------------------------------------------------------------+*
*|   Program Name Was Not In The Program Names Table. Now Determine  |*
*|   If Any Additional Logger Services Are To Be Set by Request      |*
*+-------------------------------------------------------------------+*
*
TPGM0600 DS    0H
         MVC   LCALGPTB,NOPR       Default to No Subroutine Logging
         TM    PGMPFLAG,PGMPFSUB   Was Subroutine Tracing Requested?
         BRZ   TPGM0700            No  => Branch to Check for Log Point
         MVC   LCALGPTB,BASSM      Yes => Initiate Subroutine Logging
TPGM0700 DS    0H
         MVC   LCALGPTT,NOPR       Default to Log Point Logging
         TM    PGMPFLAG,PGMPFTRC   Was Log Point Logging Requested?
         BRZ   TPGM0800            No  => Branch to Check System Level
         MVC   LCALGPTT,BASSM      Yes => Initiate Log Point Logging
TPGM0800 DS    0H
         MVC   LCALGPTL,NOPR       Default No System Level Logging
         TM    PGMPFLAG,PGMPFSYS   Was System Level Logging Requested?
         BRZ   TPGM0900            No  => Branch to Check Dsect Entry
         MVC   LCALGPTL,BASSM      Yes => Initiate System Level Logging
TPGM0900 DS    0H
         TM    PGMPFLAG,PGMPFSUB+PGMPFTRC+PGMPFSYS ..Any Added Logging?
         BRM   TPGMEXIT            Yes => Branch to Exit This Routine
TPGM1000 DS    0H
         SGR   RPGM,RPGM           Indicate No PGMLG2II Area Available
         MVC   LCALGPTB,NOPR       Indicate No Subroutine Logging
         MVC   LCALGPTT,NOPR       Indicate No Log Point Logging
         MVC   LCALGPTL,NOPR       Indicate No System Level Logging
         BRU   TPGMEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|   Program Name Is In The Program Names Table. Now Determine If    |*
*|   Any Additional Logger Services Are To Be Set by User Request    |*
*+-------------------------------------------------------------------+*
*
TPGM2000 DS    0H
         MVC   LCALGPTB,NOPR       Default to No Subroutine Logging
         TM    PGMPFLAG,PGMPFSUB   Was Subroutine Logging Requested?
         BRZ   TPGM2100            No  => Branch to Check Log Points
         MVC   LCALGPTB,BASSM      Yes => Initiate Subroutine Logging
TPGM2100 DS    0H
         MVC   LCALGPTT,NOPR       Default to No Log Point Logging
         TM    PGMPFLAG,PGMPFTRC   Was Log Point Tracing Requested?
         BRZ   TPGM2200            No  => Branch to Check System Level
         MVC   LCALGPTT,BASSM      Yes => Initiate Log Point Tracing
TPGM2200 DS    0H
         MVC   LCALGPTL,NOPR       Default No System Level Logging
         TM    PGMPFLAG,PGMPFSYS   Was System Level Logging Requested?
         BRZ   TPGM2300            No  => Branch to Check Dsect Entry
         MVC   LCALGPTL,BASSM      Yes => Initiate System Level Logging
TPGM2300 DS    0H
         LTGR  RPGM,RPGM           Do We Have a PGMLG2II Dsect Entry?
         BRZ   TPGM3000            No  => Branch to Process Output Line
         TM    PGMPFLAG,PGMPFPGM   Was Log Point Tracing Requested?
         BRZ   TPGMEXIT            No  => Branch to Exit This Routine
         BRU   TPGM3000            Yes => Branch to Process Logging
*
*+-------------------------------------------------------------------+*
*|    Print the Separator Line for Program Entry                     |*
*+-------------------------------------------------------------------+*
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
TPGM3000 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         SGR   R4,R4               Clear for Use as a Line Counter
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Rcrd Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
TPGM3100 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Rcrd Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*|  Build the Output Line for Program Name at User Program Entry     |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)==>Program Entry is To:  USERPGM1.INDX0000+(000000)  <===     |*
*| Pgm)==>Program Entry Status: CPU State=Problem Pgm  PSW Key=8  Amo|*
*| Pgm)==>Program Entered From: USERPGM1.USERPGM1+(00043A)           |*
*| Msg) Check Index Searching                                        |*
*| +   General Purpose Registers On Entry:                           |*
*| +    R0 = 000000000000C216  R1 = 000000000001E580  R2 = 0000000000|*
*| +    R4 = 0000000000004865  R5 = 0000000001024C00  R6 = 0000000002|*
*| +    R8 = 000000000102C550  R9 = 000000000001F558  R10= 000000007D|*
*| +    R12= 000000000102A000  R13= 000000000000C000  R14= 0000000001|*
*+-------------------------------------------------------------------+*
*
TPGM4000 DS    0H
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMENT88)     Point to Area Containing Header Line
         MVC   0(L'PGMENT88,RLINE),0(R1)  'Pgm)==>Program Entry is To:'
         LA    RLINE,L'PGMENT88+1(,RLINE) Increment To Field Position
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM ..Put Pgm Name in Prnt Line
         MVC   LGWPGMSV,LGWPGMNM   Put the Program Name in a Save Area
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
         CLC   LCASAVE+L'LCAS64F5A(L'LCAS64F5A),=C'F5SA' From Main Pgm?
         BRE   TPGM4800            Yes => Bypass Attributes When Main
*
*+-------------------------------------------------------------------+*
*|     Build the Output Line for Status of User Program at Entry     |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)==>Program Entry is To:  USERPGM1.INDX0000+(000000)           |*
*| Pgm)==>Program Entry Status: CPU State=Problem Pgm  PSW Key=8 <===|*
*| Pgm)==>Program Entered From: USERPGM1.USERPGM1+(00043A)           |*
*| Msg) Check Index Searching                                        |*
*| +   General Purpose Registers On Entry:                           |*
*| +    R0 = 000000000000C216  R1 = 000000000001E580  R2 = 0000000000|*
*| +    R4 = 0000000000004865  R5 = 0000000001024C00  R6 = 0000000002|*
*| +    R8 = 000000000102C550  R9 = 000000000001F558  R10= 000000007D|*
*| +    R12= 000000000102A000  R13= 000000000000C000  R14= 0000000001|*
*+-------------------------------------------------------------------+*
*
TPGM4100 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMENT91)     Point to Area Containing Header Line
         MVC   0(L'PGMENT91,RLINE),0(R1)  'Pgm)==>Program Attributes: '
         LA    RLINE,L'PGMENT91+1(,RLINE) Increment To Field Position
         MVC   0(10,RLINE),=CL10'CPU State=' ...Set Detail Line Header
         TM    LCAPSWLC+1,X'01'    Was User Progrm in Supervisor State?
         BRO   TPGM4200            No  => User Pgm in Problem State
         MVC   10(11,RLINE),=CL11'Supervisor ' Show as Supervisor State
         BRU   TPGM4300            Branch to Process for Program Key
TPGM4200 DS    0H
         MVC   10(11,RLINE),=CL11'Problem Pgm' ..Indicate Problem State
TPGM4300 DS    0H
         LA    RLINE,23(,RLINE)    Increment to Next Field Position
         MVC   0(8,RLINE),=CL8'PSW Key='  ...Set the Detail Line Header
         LLGC  R1,LCAPSWLC+1       Get Program Status Word Key Area
         SRLG  R1,R1,4 Bits        Isolate Just the PSW Key Value
         CVD   R1,LGWWORKD         Current PSW Key Number to Decimal
         OI    LGWWORKD+L'LGWWORKD-1,15 Certify Sign to Make Printable
         UNPK  LGWWRK09(3),LGWWORKD+6(2) ..PSW Key No. to Zoned Format
         CLI   LGWWRK09+1,C'0'     Does the PSW Key Have Two Digits?
         BRE   TPGM4400            No  => Branch When PSW Key is 0-9
         MVC   8(2,RLINE),LGWWRK09+1 Yes => Current PSW Key is 10-15
         BRU   TPGM4500            Branch to Check for Addressing Mode
TPGM4400 DS    0H
         MVC   8(1,RLINE),LGWWRK09+2 ...Current PSW Key to Output Line
TPGM4500 DS    0H
         LA    RLINE,11(,RLINE)    Increment to Next Field Position
         MVC   0(6,RLINE),=CL6'Amode=' ...Set the Detail Line Header
         ICM   R1,B'0011',LCAPSWLC+3  PSW Amode Indicators for 64-Bit
         TMLL  R1,X'0180'          Was User Program in 64-Bit Amode?
         BRO   TPGM4700            Yes => Process for User Pgm 64-Bit
         TMLL  R1,X'0080'          Was User Program in 31-Bit Amode?
         BRO   TPGM4600            Yes => Process for User Pgm 31-Bit
         MVC   6(2,RLINE),=CL2'24' Indicate User Program Amode is 24
         BRU   TPGM4800            Branch to Process Next Record Line
TPGM4600 DS    0H
         MVC   6(2,RLINE),=CL2'31' Indicate User Program Amode is 31
         BRU   TPGM4800            Branch to Process Next Record Line
TPGM4700 DS    0H
         MVC   6(2,RLINE),=CL2'64' Indicate User Program Amode is 64
TPGM4800 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
*
*+-------------------------------------------------------------------+*
*|   Build Output Line For Where Our User Program Was Called From    |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)==>Program Entry is To:  USERPGM1.INDX0000+(000000)           |*
*| Pgm)==>Program Entry Status: CPU State=Problem Pgm  PSW Key=8  Amo|*
*| Pgm)==>Program Entered From: USERPGM1.USERPGM1+(00043A)   <===    |*
*| Msg) Check Index Searching                                        |*
*| +   General Purpose Registers On Entry:                           |*
*| +    R0 = 000000000000C216  R1 = 000000000001E580  R2 = 0000000000|*
*| +    R4 = 0000000000004865  R5 = 0000000001024C00  R6 = 0000000002|*
*| +    R8 = 000000000102C550  R9 = 000000000001F558  R10= 000000007D|*
*| +    R12= 000000000102A000  R13= 000000000000C000  R14= 0000000001|*
*+-------------------------------------------------------------------+*
*
TPGM4900 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMENT89)     Point to Area Containing Header Line
         MVC   0(L'PGMENT89,RLINE),0(R1) 'Pgm)==>Program Entered From:'
         LA    RLINE,L'PGMENT89+1(,RLINE) Increment Next Field Position
         LLGT  R15,LCASAVE+(LCAF64BCK-LCASAVE)+4 Caller's Caller SvArea
         CGF   R15,LGWFSA          Is This the TCB First Save Area?
         BRE   TPGM6000            Yes => Pgm Started from z/OS Submit
TPGM5000 DS    0H
         LLGT  R15,(LCAF64R14-LCASAVE)+4(R15) Caller's Return Point Adr
         AGHI  R15,(-2)            Set to Show Caller's From Point Addr
TPGM5100 DS    0H
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         BRAS  RLINK1,TNME0000     Translate Address to a CSECT Name
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM Move CSECT Name to Prnt Lne
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TPGM5200 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         BRU   TPGM7800            Branch to Print Generic Log Data
*
*+-------------------------------------------------------------------+*
*|    Build The Output Line for When Program Entry Originated From   |*
*|    z/OS Task Initiation:                                          |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| //JOBSTEP1  EXEC PGM=USERPGM1,PARM='NOUPDATE,CHECKSUM'            |*
*|                                                                   |*
*| Pgm)==>Program Entry is To:  USERPGM1.USERPGM1+(000000)           |*
*| Pgm)==>Program Entered From: z/OS Initiator            <===       |*
*| Pgm)==>Program Attributes: LMod Start=0102D000  LMod Entry Point=0|*
*|                            LMod Mode=64  Lmode Subpool=251  Auth L|*
*|                            CPU State=Problem Pgm  Key=8           |*
*| +    Parm='NOUPDATE,CHECKSUM'                                     |*
*| Msg) My User Test Program                                         |*
*| +   General Purpose Registers On Entry:                           |*
*| +    R0 = 0000000000000000  R1 = 000000000000C090  R2 = 0000000000|*
*| +    R4 = 0000000000000000  R5 = 0000000000000000  R6 = 0000000000|*
*| +    R8 = 0000000000000000  R9 = 0000000000000000  R10= 0000000000|*
*| +    R12= 0000000000000000  R13= 000000000000C000  R14= 0000000000|*
*+-------------------------------------------------------------------+*
*
TPGM6000 DS    0H
         MVC   0(14,RLINE),=C'z/OS Initiator' Tasked Started From z/OS
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TPGM6100 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*|Build Output Lines for 'Program Attributes:' at User Program Entry |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| //JOBSTEP1  EXEC PGM=USERPGM1,PARM='NOUPDATE,CHECKSUM'            |*
*|                                                                   |*
*| Pgm)==>Program Entry is To:  USERPGM1.USERPGM1+(000000)           |*
*| Pgm)==>Program Entered From: z/OS Initiator                       |*
*| Pgm)==>Program Attributes: LMod Start=0102D000  LMod Entry Point=0|*
*|                            LMod Mode=64  Lmode Subpool=251  Auth L|*
*|                            CPU State=Problem Pgm  Key=8           |*
*| +    Parm='NOUPDATE,CHECKSUM'                                     |*
*| Msg) My User Test Program                                         |*
*| +   General Purpose Registers On Entry:                           |*
*| +    R0 = 0000000000000000  R1 = 000000000000C090  R2 = 0000000000|*
*| +    R4 = 0000000000000000  R5 = 0000000000000000  R6 = 0000000000|*
*| +    R8 = 0000000000000000  R9 = 0000000000000000  R10= 0000000000|*
*| +    R12= 0000000000000000  R13= 000000000000C000  R14= 0000000000|*
*+-------------------------------------------------------------------+*
*
TPGM6200 DS    0H
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMATTBX)     Point to Area Containing Header Line
         MVC   0(L'PGMATTBX,RLINE),0(R1)  Copy Start of Detail Line Hdr
         LA    RLINE,L'PGMATTBX(,RLINE)   Increment Next Field Position
         UNPK  LGWWRK09,LGWMSBAD(5) Setup Hex Value to Make Printable
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   0(L'LGWWRK09-1,RLINE),LGWWRK09  LMod Addr to Output Line
         LA    RLINE,10(,RLINE)    Increment to the Next Field Position
         TM    LGWENTPT+3,CDEMOD64 Does Routine Run in 64-Bit Mode?
         BRZ   TPGM6300            No  => Branch to Check for 31-Bit
         MVC   LGWWORK3(2),=CL2'64' ...Indicate Routine is 64-Bit Mode
         BRU   TPGM6500            Branch to Process Entry Point Addr
TPGM6300 DS    0H
         TM    LGWENTPT,CDEMODE    Does Routine Run in 31-Bit Mode?
         BRZ   TPGM6400            No  => Then must be 24-Bit Mode
         MVC   LGWWORK3(2),=CL2'31' ...Indicate Routine is 31-Bit Mode
         BRU   TPGM6500            Branch to Process Entry Point Addr
TPGM6400 DS    0H
         MVC   LGWWORK3(2),=CL2'24' ...Indicate Routine is 24-Bit Mode
TPGM6500 DS    0H
         LLGT  R1,=A(LODENT44)     Point to Area Containing Header Line
         MVC   0(L'LODENT44,RLINE),0(R1) Header Lne 'LMod Entry Point='
         LA    RLINE,L'LODENT44(,RLINE)  Increment Next Field Position
         UNPK  LGWWRK09,LGWENTPT(5) Setup Hex Value to Make Printable
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   0(L'LGWWRK09-1,RLINE),LGWWRK09 LMod Entry Point to Outpt
         LA    RLINE,L'LGWWRK09+1(,RLINE) Increment Next Field Position
         MVC   0(10,RLINE),=CL10'LMod Size=' Set the Detail Line Header
         NC    LGWLODSZ,=A(X'7FFFFFFF') Turn Off Hi-Order Indicator Bit
         UNPK  LGWWRK09,LGWLODSZ(5) Setup Hex Value to Make Printable
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   10(L'LGWWRK09-1,RLINE),LGWWRK09 Module Size to Output Ln
TPGM6600 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         MVC   27(11,RLINE),=CL11'LMod Amode=' Set Detail Line Header
         MVC   38(2,RLINE),LGWWORK3 Set The Load Module Mode Indicator
         LA    RLINE,42(,RLINE)    Increment to the Next Field Position
         MVC   0(13,RLINE),=CL13'LMod Subpool=' Set Detail Line Header
         LLGC  R1,LGWSUBPL         Get the Subpool ID for Load Module
         CVD   R1,LGWWORKD         Current Subpool Number to Decimal
         OI    LGWWORKD+L'LGWWORKD-1,15 Certify Sign to Make Printable
         UNPK  LGWWRK09(3),LGWWORKD+6(2) ..Subpool No. to Zoned Format
         MVC   13(3,RLINE),LGWWRK09 Copy LMod SubPool ID to Output Line
         LA    RLINE,18(,RLINE)    Increment to the Next Field Position
         MVC   0(11,RLINE),=CL11'Auth Lib=No' ...Set Detail Line Header
         TM    LGWATTR2,CDSYSLIB   Program From an Authorized Library?
         BRZ   TPGM6700            No  => Program not from Auth Lib
         MVC   9(3,RLINE),=CL3'Yes' Program is from Authorized Library
TPGM6700 DS    0H
         LA    RLINE,15(,RLINE)    Increment to the Next Field Position
         MVC   0(4,RLINE),=CL4'AC=0' ...Set the Detail Line Header
         TM    LGWATTR2,CDAUTH     Was Program Linked as Authorized?
         BRZ   TPGM6800            No  => Program not Linked Authorized
         MVI   3(RLINE),C'1'       Indicate Program Linked Authorized
TPGM6800 DS    0H
         LA    RLINE,7(,RLINE)     Increment to the Next Field Position
         TM    LGWATTR1,CDREN      Is Load Module Marked as Reenterant?
         BRZ   TPGM6900            No  => Check if Serially Reusable
         MVC   0(4,RLINE),=CL4'Rent' ...Set the Detail Line Attribute
         LA    RLINE,4(,RLINE)     Increment to the Next Field Position
TPGM6900 DS    0H
         TM    LGWATTR1,CDSER      Is Load Module Marked as Reusable?
         BRZ   TPGM7000            No  => Done, Pgm Attributes Complete
         MVC   0(5,RLINE),=CL5'/Reus' ...Set the Detail Line Attribute
TPGM7000 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         MVC   27(10,RLINE),=CL10'CPU State='  Set Detail Line Header
         TM    LCAPSWLC+1,X'01'    Was User Progrm in Supervisor State?
         BRO   TPGM7100            No  => User Pgm in Problem State
         MVC   37(11,RLINE),=CL11'Supervisor ' Show as Supervisor State
         BRU   TPGM7200            Branch to Process for Program Key
TPGM7100 DS    0H
         MVC   37(11,RLINE),=CL11'Problem Pgm' ..Indicate Problem State
TPGM7200 DS    0H
         LA    RLINE,51(,RLINE)    Increment to Next Field Position
         MVC   0(10,RLINE),=CL10'PSW Key=' ..Set the Detail Line Header
         LLGC  R1,LCAPSWLC+1       Get Program Status Word Key Area
         SRLG  R1,R1,4 Bits        Isolate Just the PSW Key Value
         CVD   R1,LGWWORKD         Current PSW Key Number to Decimal
         OI    LGWWORKD+L'LGWWORKD-1,15 Certify Sign to Make Printable
         UNPK  LGWWRK09(3),LGWWORKD+6(2) ..PSW Key No. to Zoned Format
         CLI   LGWWRK09+1,C'0'     Does the PSW Key Have Two Digits?
         BRE   TPGM7300            No  => Branch When PSW Key is 0-9
         MVC   8(2,RLINE),LGWWRK09+1 Yes => Current PSW Key is 10-15
         BRU   TPGM7400            Branch to Check for Parm Address
TPGM7300 DS    0H
         MVC   8(1,RLINE),LGWWRK09+2 ...Current PSW Key to Output Line
TPGM7400 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LG    R15,LCASAVE+(LCAF64BCK-LCASAVE) Callers Caller Save Area
         ICM   R15,B'1111',(LCASA_R1-LCASAVE)(R15) ...A Parm Address?
         BRZ   TPGM7800            No  => Then No Job Step Parameters
         BRU   TPGM7500            Yes => Branch to Process Parameters
*
*+-------------------------------------------------------------------+*
*|          Build the Output Line for Program PARM= Value            |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| //JOBSTEP1  EXEC PGM=USERPGM1,PARM='NOUPDATE,CHECKSUM'            |*
*|                                                                   |*
*| Pgm)==>Program Entry is To:  USERPGM1.USERPGM1+(000000)           |*
*| Pgm)==>Program Entered From: z/OS Initiator                       |*
*| Pgm)==>Program Attributes: LMod Start=0102D000  LMod Entry Point=0|*
*|                            LMod Mode=64  Lmode Subpool=251  Auth L|*
*|                            CPU State=Problem Pgm  Key=8           |*
*| +    Parm='NOUPDATE,CHECKSUM'                          <===       |*
*| Msg) My User Test Program                                         |*
*| +   General Purpose Registers On Entry:                           |*
*| +    R0 = 0000000000000000  R1 = 000000000000C090  R2 = 0000000000|*
*| +    R4 = 0000000000000000  R5 = 0000000000000000  R6 = 0000000000|*
*| +    R8 = 0000000000000000  R9 = 0000000000000000  R10= 0000000000|*
*| +    R12= 0000000000000000  R13= 000000000000C000  R14= 0000000000|*
*+-------------------------------------------------------------------+*
*
TPGM7500 DS    0H
         LLGT  R15,0(,R15)         Get Parameter Addr and Clear VL Bit
         LTGR  R15,R15             Is There a PARM= Value in Job Step?
         BRZ   TPGM7800            No  => Then No Job Step Parameters
         OC    0(2,R15),0(R15)     Is There a Length Value with Parm?
         BRZ   TPGM7800            No  => Then No Parameter Values
TPGM7600 DS    0H
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         MVC   0(11,RLINE),=C'+    Parm=''' .Set the Parm= Value Header
         LA    RLINE,11(,RLINE)    Increment to the Next Field Position
         LGH   R1,0(,R15)          Obtain the Length of Parameter Data
         BCTGR R1,R0               Decrement Indicated Length for EX
         MVC   0(*-*,RLINE),2(R15) ..Indicated Target of Executed Instr
         EX    R1,*-6              Move in Parameter Data to Print Line
         LA    RLINE,1(R1,RLINE)   Bump to the End of Parameter Data
         MVI   0(RLINE),C''''      Close Parm Data with an Ending Quote
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TPGM7700 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         BRU   TPGM7800            Branch to Write Logger Records
*
*+-------------------------------------------------------------------+*
*| Determine if Logger Output Records in the work area buffer are to |*
*| be printed immediately to the //LGRECOUT output data set, or to be|*
*| moved from the temporary work buffer to a larger accumulation     |*
*| buffer area which will defer the printing of Logger output records|*
*| until the end of user progran processing. If the user has taken   |*
*| the default or has specified the default LOGOUT=PRNT in LPGMNTRY  |*
*| indicating to print records to output now, then routine LWRT0000  |*
*| is branched to. If LGOUT=BUFR was specified to defer the print of |*
*| Log records, then program LGMHLRCB is called to write the Log     |*
*| records to storage above-the-line. If LOGOUT=BUF64 was specified  |*
*| then program LGMHLB64 is called to write records to storage areas |*
*| above-the-bar.                                                    |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*| USRTEST1 LPGMNTRY TYPE=MAIN,       Define Main Test Program Entry |*
*|              AMOD=31,RMOD=31,      Define Addessing and Residence |*
*|              STORAGE=64,           Define LCA Stacked Storage Size|*
*|              BASE=(12,11),         Establish Base Registers       |*
*|              LCAPFX=SVN,           LCA Prefix for This CSECT      |*
*|        ===>  LOGOUT=PRNT,          Write Logger Records to Output |*
*|              MSG='Test User Program 1'                            |*
*|                                                                   |*
*| USRTEST1 LPGMNTRY TYPE=MAIN,       Define Main Test Program Entry |*
*|              AMOD=31,RMOD=31,      Define Addessing and Residence |*
*|              STORAGE=64,           Define LCA Stacked Storage Size|*
*|              BASE=(12,11),         Establish Base Registers       |*
*|              LCAPFX=SVN,           LCA Prefix for This CSECT      |*
*|        ===>  LOGOUT=BUFR,          Defer Recrd Write and Buffer it|*
*|              MSG='Test User Program 1'                            |*
*+-------------------------------------------------------------------+*
*
TPGM7800 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TPGMEXIT            No  => Branch to Exit This Routine
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   TPGM7900            Yes => Use Buffers Above-the-Line
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   TPGM8000            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Rcrds To Output Now
         BRU   TPGM9000            Branch For Log Point Msgs and Data
TPGM7900 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   TPGM8100            Branch to Process Records to Buffers
TPGM8000 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
TPGM8100 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Write Logger Recrds to a Buffer AreaX
               (LGRWK2II,          ..Pass Pointer to Logger Data Area  X
               (R4)),              ..Pass Pointer to Logger Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Loggr Rcds to Buffer
         LTGFR R15,R15             Was Write Buffer Request Successful?
         BRZ   TPGM8200            Yes => Branch to Process Request
         LGHI  R2,((TPGM8300-TPGM8200)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   TPGM8200            No  => Process Return to Buffer Rcds
         BRU   TPGMEXIT            Branch to Exit This Routine
TPGM8200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   TPGM9000            Processed Log Records to Buffer
         BRU   TPGM9000            Warning on Log Records to Buffer
         BRU   TPGM8300            Process for Validation Error - Exit
         BRU   TPGM8300            Process for Severe Error - Set Flag
TPGM8300 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   TPGMEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Process Any Additional Messages and Logger Options Which Were     |*
*| Defined by the User in the "LPGMNTRY" Program Entry Request.      |*
*+-------------------------------------------------------------------+*
*
TPGM9000 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRAS  RLINK1,LPRT0000     Print Additional Logger Output Data
         BRU   TPGMEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TPGM$END DS    0H
         SLGR  R15,R15             Indicate Successfull Completion
TPGMEXIT DS    0H
         LG    RLINK1,LGWRLNK1     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
*
NOPR     NOPR  0                   Indicate To Disable Logger Services
BASSM    BASSM R14,R15             Indicate Enable of Logger Services
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*                End of Program Entry Log Processing                  *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| T P G X 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   L o g g i n g   F o r   P r o g r a m   E x i t  |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TPGX0000                                           *
*                                                                     *
* FUNCTION:        Logging for User Program Exit                      *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  build of log records at exit from a user program.  *
*                                                                     *
*                  Label    LPGMEXIT Ýparameters¨                     *
*                           LPGMEXIT RC=USRRETCD                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|    Determine the User Program Csect Name From Input Address       |*
*+-------------------------------------------------------------------+*
*
TPGX0000 DS    0H
         STG   RLINK1,LGWRLNK1     Save Our Linkage Register Address
         LG    R15,LCASAVE+(LCAF64BCK-LCASAVE) Callers Caller Save Area
         CLC   LCASAVE+L'LCAS64F5A(L'LCAS64F5A),=C'F5SA' From Main Pgm?
         BRNE  TPGX0100            No  => Then Entry is to Sub-Program
         LLGF  R15,(LCASA_R15-LCASAVE)(,R15) Get Caller's Entry Pnt Adr
         CLGF  R15,=A(X'FFFFF002') Was 64-Bit Entry Linkage Indicated?
         BRNE  TPGX0050            No  => Branch to Process Load Module
         LLGT  R15,LCACSADR        Get Caller's Actual Entry Point Addr
TPGX0050 DS    0H
         ICM   R3,B'1111',LGREXOFF Obtain Caller's Exit Point Offset
         LA    R15,0(R3,R15)       Obtain the Caller's Exit Point Addr
         BRU   TPGX0200            Branch to Process for Csect Name
TPGX0100 DS    0H
         LLGF  R15,(LCAF64R15-LCASAVE)+4(,R15) Caller's Entry Point Adr
         ICM   R3,B'1111',LGREXOFF Obtain Caller's Exit Point Offset
         LA    R15,0(R3,R15)       Obtain the Caller's Exit Point Addr
TPGX0200 DS    0H
         BRAS  RLINK1,TNME0000     Translate Address to a CSECT Name
*
*+-------------------------------------------------------------------+*
*| Determine If User Program Csect Name is in the Program Names Table|*
*+-------------------------------------------------------------------+*
*
TPGX0300 DS    0H
         ICM   RPGM,B'1111',LGWPGML ...There a Pointer to Program List?
         BRZ   TPGX1000            No  => Bypass Logging This Program
         ICM   R14,B'1111',PGMLNTH ..Is There a Total Length for Table?
         BRZ   TPGX1000            No  => Bypass Logging of This Progrm
         SH    R14,=Y(L'PGMPREFX)  Tble Leng Represent Only the Prefix?
         BRZ   TPGX1000            Yes => Null Table, Bypass Logging
TPGX0400 DS    0H
         MVC   LGWWRK64(L'LGWLMOD),LGWLMOD   Obtain This Program's Name
         MVC   LGWWRK64+L'LGWLMOD(L'LGWCSECT),LGWCSECT  Get Csect Name
         NC    LGWWRK64,PGMPMASK   Mask Out the Wildcard Characters
         CLC   LGWWRK64,PGMPNAME   Do We Perform Logging for Program?
         BRE   TPGX1100            Yes => Branch to Process Logging
TPGX0500 DS    0H
         SH    R14,PGMPLNTH        Length of Pgm Entry from Pgm Table
         BRZ   TPGX0600            None Left, Then Bypass Logging
         AH    RPGM,PGMPLNTH       Bump to the Next Program Name Entry
         BRU   TPGX0400            Loop to Process Next Pgm Name in Tbl
*
*+-------------------------------------------------------------------+*
*| User Program Csect Name Was Not In The Program Names Table. Now   |*
*| Determine If Any Additional Log Points Are To Be Set by Request   |*
*+-------------------------------------------------------------------+*
*
TPGX0600 DS    0H
         MVC   LCALGPTB,NOPR       Default to No Subroutine Logging
         TM    PGMPFLAG,PGMPFSUB   Was Subroutine Logging Requested?
         BRZ   TPGX0700            No  => Branch to Check Log Points
         MVC   LCALGPTB,BASSMX     Yes => Initiate Subroutine Logging
TPGX0700 DS    0H
         MVC   LCALGPTT,NOPR       Default to No Log Point Logging
         TM    PGMPFLAG,PGMPFTRC   Was Log Point Tracing Requested?
         BRZ   TPGX0800            No  => Branch to Check System Level
         MVC   LCALGPTT,BASSMX     Yes => Initiate Log Point Tracing
TPGX0800 DS    0H
         MVC   LCALGPTL,NOPR       Default No System Level Logging
         TM    PGMPFLAG,PGMPFSYS   Was System Level Logging Requested?
         BRZ   TPGX0900            No  => Branch to Check Dsect Entry
         MVC   LCALGPTL,BASSMX     Yes => Initiate System Level Logging
TPGX0900 DS    0H
         TM    PGMPFLAG,PGMPFSUB+PGMPFTRC+PGMPFSYS ...Any Added Logs?
         BRM   TPGXEXIT            Yes => Branch to Exit This Routine
TPGX1000 DS    0H
         SLGR  RPGM,RPGM           Indicate No PGMLG2II Area Available
         MVC   LCALGPTB,NOPRX      Indicate No Subroutine Logging
         MVC   LCALGPTT,NOPRX      Indicate No Log Point Logging
         MVC   LCALGPTL,NOPRX      Indicate No System Level Logging
         BRU   TPGXEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| User Program Name Is In The Program Names Table. Now Determine If |*
*|    Any Additional Log Points Are To Be Set by Request             |*
*+-------------------------------------------------------------------+*
*
TPGX1100 DS    0H
         MVC   LCALGPTB,NOPRX      Default to No Subroutine Logging
         TM    PGMPFLAG,PGMPFSUB   Was Subroutine Logging Requested?
         BRZ   TPGX1200            No  => Branch to Check Log Points
         MVC   LCALGPTB,BASSMX     Yes => Initiate Subroutine Logging
TPGX1200 DS    0H
         MVC   LCALGPTT,NOPRX      Default to No Log Point Logging
         TM    PGMPFLAG,PGMPFTRC   Was Log Point Tracing Requested?
         BRZ   TPGX1300            No  => Branch to Check System Level
         MVC   LCALGPTT,BASSMX     Yes => Initiate Log Point Tracing
TPGX1300 DS    0H
         MVC   LCALGPTL,NOPRX      Default No System Level Logging
         TM    PGMPFLAG,PGMPFSYS   Was System Level Logging Requested?
         BRZ   TPGX1400            No  => Branch to Check Dsect Entry
         MVC   LCALGPTL,BASSMX     Yes => Initiate System Level Logging
TPGX1400 DS    0H
         LTGR  RPGM,RPGM           Do we have a PGMLG2II Dsect Entry?
         BRZ   TPGX2000            No  =>
         TM    PGMPFLAG,PGMPFPGM   Log Point Tracing Requested?
         BRZ   TPGXEXIT            No  => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|   Build the Log Output Line for Where User Program Exited From    |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)<==Program Exited From: USERPGM1.INDX0000+(000B12)  <===      |*
*| Pgm)<==Program Exit Status: CPU State=Problem Pgm  PSW Key=8  Amod|*
*| Pgm)<==Program Exited To:   USERPGM1.USERPGM1+(00044A)            |*
*| +         Return Code =  00000000   Reason Code =  00000000       |*
*| +  General Purpose Registers On Exit:                             |*
*| +   R0 = 0000000000000000  R1 = 0000000000020580  R2 = 00000000000|*
*| +   R4 = 0000000000000008  R5 = 000000000000ED9C  R6 = 00000000000|*
*| +   R8 = 000000000102FEE8  R9 = 0000000000021558  R10= 00000000000|*
*| +   R12= 000000000102EDF8  R13= 000000000000EB90  R14= 00000000810|*
*+-------------------------------------------------------------------+*
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
TPGX2000 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         SLGR  R4,R4               Clear for Use as a Line Counter
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMXIT77)     Point to Area Containing Header Line
         MVC   0(L'PGMXIT77,RLINE),0(R1)  'Pgm)<==Program Exited From:'
         LA    RLINE,L'PGMXIT77+1(,RLINE) Increment Next Field Position
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM ..Put Pgm Name in Prnt Line
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
*
*+-------------------------------------------------------------------+*
*|     Build the Output Line for Status of User Program at Exit      |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)<==Program Exited From: USERPGM1.INDX0000+(000B12)            |*
*| Pgm)<==Program Exit Status: CPU State=Problem Pgm  PSW Key=8  <===|*
*| Pgm)<==Program Exited To:   USERPGM1.USERPGM1+(00044A)            |*
*| +         Return Code =  00000000   Reason Code =  00000000       |*
*| +  General Purpose Registers On Exit:                             |*
*| +   R0 = 0000000000000000  R1 = 0000000000020580  R2 = 00000000000|*
*| +   R4 = 0000000000000008  R5 = 000000000000ED9C  R6 = 00000000000|*
*| +   R8 = 000000000102FEE8  R9 = 0000000000021558  R10= 00000000000|*
*| +   R12= 000000000102EDF8  R13= 000000000000EB90  R14= 00000000810|*
*+-------------------------------------------------------------------+*
*
TPGX2100 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMXIT93)     Point to Area Containing Header Line
         MVC   0(L'PGMXIT93,RLINE),0(R1)  'Pgm)==>Program Attributes: '
         LA    RLINE,L'PGMXIT93(,RLINE) ...Increment To Field Position
         MVC   0(10,RLINE),=CL10'CPU State=' ...Set Detail Line Header
         TM    LCAPSWLC+1,X'01'    Was User Progrm in Supervisor State?
         BRO   TPGX2200            No  => User Pgm in Problem State
         MVC   10(11,RLINE),=CL11'Supervisor ' Show as Supervisor State
         BRU   TPGX2300            Branch to Process for Program Key
TPGX2200 DS    0H
         MVC   10(11,RLINE),=CL11'Problem Pgm' ..Indicate Problem State
TPGX2300 DS    0H
         LA    RLINE,23(,RLINE)    Increment to Next Field Position
         MVC   0(8,RLINE),=CL8'PSW Key='  ...Set the Detail Line Header
         LLGC  R1,LCAPSWLC+1       Get Program Status Word Key Area
         SRLG  R1,R1,4 Bits        Isolate Just the PSW Key Value
         CVD   R1,LGWWORKD         Current PSW Key Number to Decimal
         OI    LGWWORKD+L'LGWWORKD-1,15 Certify Sign to Make Printable
         UNPK  LGWWRK09(3),LGWWORKD+6(2) ..PSW Key No. to Zoned Format
         CLI   LGWWRK09+1,C'0'     Does the PSW Key Have Two Digits?
         BRE   TPGX2400            No  => Branch When PSW Key is 0-9
         MVC   8(2,RLINE),LGWWRK09+1 Yes => Current PSW Key is 10-15
         BRU   TPGX2500            Branch to Check for Addressing Mode
TPGX2400 DS    0H
         MVC   8(1,RLINE),LGWWRK09+2 ...Current PSW Key to Output Line
TPGX2500 DS    0H
         LA    RLINE,11(,RLINE)    Increment to Next Field Position
         MVC   0(6,RLINE),=CL6'Amode=' ...Set the Detail Line Header
         ICM   R1,B'0011',LCAPSWLC+3  PSW Amode Indicators for 64-Bit
         TMLL  R1,X'0180'          Was User Program in 64-Bit Amode?
         BRO   TPGX2700            Yes => Process for User Pgm 64-Bit
         TMLL  R1,X'0080'          Was User Program in 31-Bit Amode?
         BRO   TPGX2600            Yes => Process for User Pgm 31-Bit
         MVC   6(2,RLINE),=CL2'24' Indicate User Program Amode is 24
         BRU   TPGX2800            Branch to Process Next Record Line
TPGX2600 DS    0H
         MVC   6(2,RLINE),=CL2'31' Indicate User Program Amode is 31
         BRU   TPGX2800            Branch to Process Next Record Line
TPGX2700 DS    0H
         MVC   6(2,RLINE),=CL2'64' Indicate User Program Amode is 64
TPGX2800 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
*
*+-------------------------------------------------------------------+*
*|    Build the Log Output Line For Where User Program Exited To     |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)<==Program Exited From: USERPGM1.INDX0000+(000B12)            |*
*| Pgm)<==Program Exit Status: CPU State=Problem Pgm  PSW Key=8  Amod|*
*| Pgm)<==Program Exited To:   USERPGM1.USERPGM1+(00044A)  <===      |*
*| +         Return Code =  00000000   Reason Code =  00000000       |*
*| +  General Purpose Registers On Exit:                             |*
*| +   R0 = 0000000000000000  R1 = 0000000000020580  R2 = 00000000000|*
*| +   R4 = 0000000000000008  R5 = 000000000000ED9C  R6 = 00000000000|*
*| +   R8 = 000000000102FEE8  R9 = 0000000000021558  R10= 00000000000|*
*| +   R12= 000000000102EDF8  R13= 000000000000EB90  R14= 00000000810|*
*+-------------------------------------------------------------------+*
*
TPGX2900 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         LLGT  R1,=A(PGMXIT79)     Point to Area Containing Header Line
         MVC   0(L'PGMXIT79,RLINE),0(R1)    'Pgm)<==Program Exited To:'
         LA    RLINE,L'PGMXIT79+1(,RLINE) Increment Next Field Position
         LLGT  R15,LCASAVE+(LCAF64BCK-LCASAVE)+4 Caller's Caller SArea
         CGF   R15,LGWFSA          Is This the TCB First Save Area?
         BRE   TPGX3300            Yes => Pgm Started from z/OS Submit
TPGX3000 DS    0H
         LLGT  R15,12(,R15)        Obtain Caller's Return Point Address
TPGX3100 DS    0H
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         BRAS  RLINK1,TNME0000     Translate Address to a CSECT Name
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM Move CSECT Name to Prnt Lne
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TPGX3200 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         BRU   TPGX4000            Branch to Print Logger Records
*
*+-------------------------------------------------------------------+*
*|      Build the Log Output Line for User Program Exit To z/OS      |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)<==Program Exited From: USERPGM1.USERPGM1+(0006D2)            |*
*| Pgm)<==Program Exit Status: CPU State=Problem Pgm  PSW Key=8  Amod|*
*| Pgm)<==Program Exited To:   z/OS Initiator            <===        |*
*| +         Return Code =  00000000   Reason Code =  00000000       |*
*| +  General Purpose Registers On Exit:                             |*
*| +   R0 = 0000000000000000  R1 = 000000000000B2D8  R2 = 00000000000|*
*| +   R4 = 0000000000000000  R5 = 0000000000000000  R6 = 00000000000|*
*| +   R8 = 000000000102FEE8  R9 = 0000000000021558  R10= 00000000000|*
*| +   R12= 000000000102D000  R13= 000000000000E000  R14= 00000000810|*
*+-------------------------------------------------------------------+*
*
TPGX3300 DS    0H
         MVC   0(14,RLINE),=C'z/OS Initiator' Program Started from z/OS
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TPGX3400 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*|    Print Return Code and Reason Code From User Program Exit       |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Pgm)<==Program Exited From: USERPGM1.TEST0000+(000B12)            |*
*| Pgm)<==Program Exit Status: CPU State=Problem Pgm  PSW Key=8  Amod|*
*| Pgm)<==Program Exited To:   USERPGM1.USERPGM1+(00044A)            |*
*| +         Return Code =  00000004   Reason Code =  00000005  <=== |*
*| +  General Purpose Registers On Exit:                             |*
*| +   R0 = 0000000000000005  R1 = 0000000000020580  R2 = 00000000000|*
*| +   R4 = 0000000000000008  R5 = 000000000000ED9C  R6 = 00000000000|*
*| +   R8 = 000000000102FEE8  R9 = 0000000000021558  R10= 00000000000|*
*| +   R12= 000000000102EDF8  R13= 000000000000EB90  R14= 00000000810|*
*+-------------------------------------------------------------------+*
*
TPGX4000 DS    0H
         MVI   LNE.LGWOLINE,C'+'   Indicate Continuation of Log Data
         LA    RLINE,LNE.LGWOLINE+13 Set Starting Position in Print Lne
         MVC   0(13,RLINE),=C'Return Code =' Place Label for Return Cde
         UNPK  LGWWRK09,LCA$RC(5)  Obtain the Actual Return Code Value
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   15(L'LGWWRK09-1,RLINE),LGWWRK09 ..Copy Return Code Value
         LA    RLINE,26(,RLINE)    Increment Line Pnter to Reason Field
TPGX4100 DS    0H
         MVC   0(13,RLINE),=C'Reason Code =' Place Label for Reason Cde
         UNPK  LGWWRK09,LCA$RS(5)  Obtain the Actual Reason Code Value
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   15(L'LGWWRK09-1,RLINE),LGWWRK09 Cpy Reason Code to Outpt
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TPGX4200 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*| Determine If Logger Output Records in the Work Area Buffer Are To |*
*| Be Printed Immediately to the //LGRECOUT Output Data Set, Or To Be|*
*| Moved from the Temporary Work Buffer to a Larger Accumulation     |*
*| Buffer Area Which Will Defer the Printing of Logger Output Records|*
*| Until the End Of User Program Processing.                         |*
*+-------------------------------------------------------------------+*
*
TPGX5000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TPGXEXIT            No  => Branch to Exit This Routine
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   TPGX5100            Yes => Don't Print Now, Go to Buffer
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   TPGX5200            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Recds To Output Now
         BRU   TPGX6000            Branch For Log Point Msgs and Data
TPGX5100 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   TPGX5300            Branch to Process Records to Buffers
TPGX5200 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
TPGX5300 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Process Log Records to Buffer Area  X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R4)),              ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Log Recrds to Buffer
         LTGFR R15,R15             Was Write Buffer Request Successful?
         BRZ   TPGX5400            Yes => Branch to Process Request
         LGHI  R2,((TPGX5500-TPGX5400)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   TPGX5400            No  => Process Return to Buffer Rcds
         BRU   TPGXEXIT            Branch to Exit This Routine
TPGX5400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   TPGX6000            Log Records Written to Buffer Area
         BRU   TPGX6000            Warning on Log Recrd Write to Buffer
         BRU   TPGX5500            Process for Validation Error
         BRU   TPGX5500            Process for Severe Error - Set Flag
TPGX5500 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   TPGXEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Process Any Additional Messages and Logger Options Which Were     |*
*| Defined by the User in the "LPGMEXIT" Program Exit Request.       |*
*+-------------------------------------------------------------------+*
*
TPGX6000 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRAS  RLINK1,LPRT0000     Print Additional Logger Output Data
         BRU   TPGXEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TPGXEXIT DS    0H
         LG    RLINK1,LGWRLNK1     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
*
NOPRX    NOPR  0                   Indicate To Disable Program Logging
BASSMX   BASSM R14,R15             Indicate Enablement of Pgm Logging
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*                End of Program Exit Log Processing                   *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| T S U B 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|P e r f o r m  L o g g i n g  F o r  S u b r o u t i n e  E n t r y|*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TSUB0000                                           *
*                                                                     *
* FUNCTION:        Logging for User Subroutine Entry                  *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  build of log records at entry to a user program    *
*                  subroutine.                                        *
*                                                                     *
*                  Label   LPGMSUBE Ýparameters¨                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
TSUB0000 DS    0H
         STG   RLINK1,LGWRLNK1     Save Our Linkage Register Address
*
*+-------------------------------------------------------------------+*
*|    Process to Increment Subroutine Indentation Level              |*
*+-------------------------------------------------------------------+*
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
TSUB1000 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         SLGR  R4,R4               Clear for Use as a Line Counter
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         MVC   0(4,RLINE),=C'Sub)' Copy Subroutine Indicator to Line
         LA    RLINE,4(,RLINE)     Increment Past the Indicator
         LLGC  R15,LCATRIND        Obtain the Current Indention Level
         CLGF  R15,=A(MAXINDNT)    Are We at the Maximum Indention?
         BRH   TSUB1100            Yes => Then Hold Indentation Level
         LA    R15,3(,R15)         Increase Indention for Subroutine
         STC   R15,LCATRIND        Save New Value in Program Cntl Area
         BRU   TSUB1200            Branch to Process the Output Line
TSUB1100 DS    0H
         LLGC  R1,LCAINDNT         Get the Current Indents Past Maximum
         LA    R1,1(,R1)           Increment Current Past the Maximim
         STC   R1,LCAINDNT         Set Current Level Past Max Indents
*
*+-------------------------------------------------------------------+*
*|        Build the Log Output Record for Subroutine Entry           |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Sub)   ==>Subroutine: USERPGM1.INIT0000.RTNE0000                  |*
*|           From: USERPGM1.INIT0000+(00082C)                        |*
*+-------------------------------------------------------------------+*
*
TSUB1200 DS    0H
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(TSUBR851)     Point to Area Containing Header Line
         MVC   0(14,RLINE),0(R1)   Copy in the Header '==>Subroutine:'
         LA    RLINE,15(,RLINE)    Increment to the Next Field Position
         LG    R15,LCASENTR        Load Caller's Entry Point Address
TSUB1300 DS    0H
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         BRAS  RLINK1,TNME0000     Translate Address to a CSECT Name
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM ..Put Pgm Name in Prnt Line
TSUB1400 DS    0H
         CLI   0(RLINE),C' '       Found the End of Our LMOD.CSECT?
         BRE   TSUB1500            Yes => Branch to Format Print Line
         CLI   0(RLINE),C'+'       Found the End of Our LMOD.CSECT?
         BRE   TSUB1500            Yes => Branch to Format Print Line
         LA    RLINE,1(,RLINE)     Increment to the Next Byte in Field
         BRU   TSUB1400            Loop to Find the End of LMOD.CSECT
TSUB1500 DS    0H
         MVC   0(8,RLINE),=CL8'.'  Fill Over the Offset Display Area
         LA    RLINE,1(,RLINE)     Increment Current Output Line Pnter
         LLGC  R15,LGRNAMEL        Get the Length of Subroutine Name
         BCTGR R15,R0              Decrement for the Execute
         SLGF  R15,=F'2'           Strip the '_Z' Suffix From Name
         MVC   0(*-*,RLINE),LGRNAME ...Indicated Target of Execute
         EX    R15,*-6             Copy Subroutine Name to Output Line
TSUB1600 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LLGC  R15,LCATRIND        Obtain the Current Indention Level
         LA    RLINE,LNE.LGWOLINE(R15)  Set Starting Position in Line
         MVC   7(5,RLINE),=CL5'From:'  Set the 'From' Program Header
         LA    RLINE,13(RLINE)     Increment Past the Header
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM ..Copy the Pgm Name to Line
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TSUB1700 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*| Determine If Logger Output Records in the Work Area Buffer Are To |*
*| Be Printed Immediately to the //LGRECOUT Output Data Set, Or To Be|*
*| Moved from the Temporary Work Buffer to a Larger Accumulation     |*
*| Buffer Area Which Will Defer the Printing of Logger Output Records|*
*| Until the End Of User Program Processing.                         |*
*+-------------------------------------------------------------------+*
*
TSUB2000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TSUBEXIT            No  => Branch to Exit This Routine
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   TSUB2100            Yes => Use Buffers Above-the-Line
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   TSUB2200            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Recds To Output Now
         BRU   TSUB3000            Branch For Log Point Msgs and Data
TSUB2100 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   TSUB2300            Branch to Process Records to Buffers
TSUB2200 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
TSUB2300 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Process Log Records to Buffer Area  X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R4)),              ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Log Recrds to Buffer
         LTGFR R15,R15             Was Write Buffer Request Successful?
         BRZ   TSUB2400            Yes => Branch to Process Request
         LGHI  R2,((TSUB2500-TSUB2400)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   TSUB2400            No  => Process Return to Buffer Rcds
         BRU   TSUBEXIT            Branch to Exit This Routine
TSUB2400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   TSUB3000            Log Records Written to Buffer Area
         BRU   TSUB3000            Warning on Log Recrd Write to Buffer
         BRU   TSUB2500            Process for Validation Error
         BRU   TSUB2500            Process for Severe Error - Set Flag
TSUB2500 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   TSUBEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Process Any Additional Messages and Logger Options Which Were     |*
*| Defined by the User in the "LPGMSUBE" Subroutine Entry Request.   |*
*+-------------------------------------------------------------------+*
*
TSUB3000 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRAS  RLINK1,LPRT0000     Print Additional Logger Output Data
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TSUBEXIT DS    0H
         LG    RLINK1,LGWRLNK1     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*              End of Subroutine Entry Log Processing                 *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| T S B X 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*| P e r f o r m  L o g g i n g  F o r  S u b r o u t i n e  E x i t |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TSBX0000                                           *
*                                                                     *
* FUNCTION:        Logging for User Subroutine Exit                   *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  build of log records at exit from a user program   *
*                  subroutine.                                        *
*                                                                     *
*                  Label   LPGMSUBX Ýparameters¨                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
TSBX0000 DS    0H
         STG   RLINK1,LGWRLNK1     Save Our Linkage Register Address
*
*+-------------------------------------------------------------------+*
*|        Build the Logger Output Line for Subroutine Exit           |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*| Sub)   <==Subroutine Exit: USERPGM1.INIT0000.RTNE0000             |*
*+-------------------------------------------------------------------+*
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
TSBX1000 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         SLGR  R4,R4               Clear for Use as a Line Counter
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         MVC   0(4,RLINE),=C'Sub)' Copy Subroutine Indicator to Line
         LA    RLINE,4(,RLINE)     Increment Past the Indicator
         LLGC  R15,LCATRIND        Obtain the Current Indentation Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indentation Level
         LLGT  R1,=A(SUBEXT49)     Point to Area Containing Header Line
         MVC   0(19,RLINE),0(R1)   Copy in Line '<==Subroutine Exit:'
         LA    RLINE,20(,RLINE)    Increment to the Next Field Position
         LG    R15,LCASXLNK        Load Callers Return Point Address
TSBX1100 DS    0H
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         BRAS  RLINK1,TNME0000     Translate Address to a CSECT Name
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         MVC   0(L'LGWPGMNM,RLINE),LGWPGMNM ..Put Pgm Name in Prnt Line
TSBX1200 DS    0H
         CLI   0(RLINE),C' '       Found the End of Our LMOD.CSECT?
         BRE   TSBX1300            Yes => Branch to Format Print Line
         CLI   0(RLINE),C'+'       Found the End of Our LMOD.CSECT?
         BRE   TSBX1300            Yes => Branch to Format Print Line
         LA    RLINE,1(,RLINE)     Increment to the Next Byte in Field
         BRU   TSBX1200            Loop to Find the End of LMOD.CSECT
TSBX1300 DS    0H
         MVC   0(8,RLINE),=CL8'.'  Fill Over the Offset Display Area
         LA    RLINE,1(,RLINE)     Increment Current Output Line Pnter
         LLGC  R15,LGRNAMEL        Get the Length of Subroutine Name
         BCTGR R15,R0              Decrement for Execute
         SLGF  R15,=F'2'           Strip the '_Z' Suffix From Name
         MVC   0(*-*,RLINE),LGRNAME ...Indicated Target of Execute
TSBX1400 DS    0H
         EX    R15,*-6             Copy Subroutine Name to Output Line
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
TSBX1500 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*| Determine If Logger Output Records in the Work Area Buffer Are To |*
*| Be Printed Immediately to the //LGRECOUT Output Data Set, Or To Be|*
*| Moved from the Temporary Work Buffer to a Larger Accumulation     |*
*| Buffer Area Which Will Defer the Printing of Logger Output Records|*
*| Until the End Of User Program Processing.                         |*
*+-------------------------------------------------------------------+*
*
TSBX2000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TSBXEXIT            No  => Branch to Exit This Routine
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   TSBX2100            Yes => Use Buffers Above-the-Line
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   TSBX2200            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Recds To Output Now
         BRU   TSBX3000            Branch For Log Point Msgs and Data
TSBX2100 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   TSBX2300            Branch to Process Records to Buffers
TSBX2200 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
TSBX2300 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Process Log Records to Buffer Area  X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R4)),              ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Log Recrds to Buffer
         LTGFR R15,R15             Was Write Buffer Request Successful?
         BRZ   TSBX2400            Yes => Branch to Process Request
         LGHI  R2,((TSBX2500-TSBX2400)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   TSBX2400            No  => Process Return to Buffer Rcds
         BRU   TSBXEXIT            Branch to Exit This Routine
TSBX2400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   TSBX3000            Log Records Processed to Buffer Area
         BRU   TSBX3000            Warning on Log Recrd Write to Buffer
         BRU   TSBX2500            Process for Validation Error
         BRU   TSBX2500            Process for Severe Error - Set Flag
TSBX2500 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   TSBXEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Process Any Additional Messages and Logger Options Which Were     |*
*| Defined by the User in the "LPGMSUBX" Subroutine Exit Request.    |*
*+-------------------------------------------------------------------+*
*
TSBX3000 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRAS  RLINK1,LPRT0000     Print Additional Logger Output Data
*
*+-------------------------------------------------------------------+*
*|    Process to Decrement Subroutine Indentation Level              |*
*+-------------------------------------------------------------------+*
*
TSBX4000 DS    0H
         SLGR  R15,R15             Clear for Use as Work Register
         CLI   LCAINDNT,X'00'      Are We Past Maximum No. of Indents?
         BRE   TSBX3100            No  => Then Set Indentation Level
         LLGC  R15,LCAINDNT        Get Current Indents Past Maximum
         BCTGR R15,0               Decrement Current Levl Past Maximum
         STC   R15,LCAINDNT        Set Current Indents Past Maximum
         BRU   TSBXEXIT            Branch to Exit This Routine
TSBX3100 DS    0H
         LLGC  R15,LCATRIND        Obtain the Current Indention Level
         SLGF  R15,=F'3'           Decrease Indention for Subroutine
         STC   R15,LCATRIND        Save New Value in Program Cntl Area
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TSBXEXIT DS    0H
         LG    RLINK1,LGWRLNK1     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*                End of Subroutine Exit Log Processing                *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L G P T 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|     P e r f o r m   L o g g i n g   F o r   L o g   P o i n t     |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: LGPT0000                                           *
*                                                                     *
* FUNCTION:        Logger Services Log Point                          *
*                                                                     *
*                  This routine is responsible for processing Log     *
*                  Points defined by the user within their program.   *
*                                                                     *
*                  Label   #LGPOINT Ýparameters¨                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
LGPT0000 DS    0H
         STG   RLINK1,LGWRLNK1     Save Our Linkage Register Address
         ICM   RPGM,B'1111',LGWPGML ...There a Pointer to Program List?
         BRZ   LGPT0300            No  => Bypass Log of Log Point
         ICM   R14,B'1111',PGMLNTH ..Is There a Total Length for Table?
         BRZ   LGPT0300            No  => Bypass Log Point Event
         SH    R14,=Y(L'PGMPREFX)  Tble Leng Represent Only the Prefix?
         BRZ   LGPT0300            Yes => Null Table, Bypass Log Point
LGPT0100 DS    0H
         LLGC  R15,LGRNAMEL        Get the Length of Log Point Name
         BCTGR R15,0               Decrement for the Execute
         MVC   LGWWRK64+L'LGWWRK64/2(*-*),LGRNAME Target of the Execute
         EX    R15,*-6             Obtain the Current Log Point Name
         MVC   LGWWRK64(L'LGWCSECT),LGWCSECT  Get Control Section Name
         NC    LGWWRK64,PGMPMASK   Mask Out the Wildcard Characters
         CLC   LGWWRK64,PGMPNAME   Do We Log This Log Point Event?
         BRNE  LGPT0200            No  => Branch to Check Next Pgm Name
         CLC   PGMPTYPE,=CL6'LOGPNT' Is This For Our Log Point Type?
         BRE   LGPT0400            Yes => Branch to Process This Event
         TM    PGMPFLAG,PGMPFTRC   Is a Program Log Point Indicated?
         BRO   LGPT0400            Yes => Branch to Process This Event
LGPT0200 DS    0H
         SH    R14,PGMPLNTH        Length of Pgm Entry from Pgm Table
         BRZ   LGPT0300            None Left, Then Bypass Logging
         AH    RPGM,PGMPLNTH       Bump to the Next Program Name Entry
         BRU   LGPT0100            Loop to Process Next Pgm Name in Tbl
LGPT0300 DS    0H
         SLGR  R15,R15             Show As No Error, No Work to Process
         BRU   LGPTEXIT            Branch to Exit From This Routine
LGPT0400 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II) Index to Logger Record List Area
         LA    R3,0(R3,R13)        Point to the Logger Record Area
         SLGR  R4,R4               Clear for Use as a Line Counter
         TM    LGRPFLAG,LGRPSHDR   Request to Suppress Header Lines?
         BRZ   LGPT1000            No  => Branch to Build Output Line
LGPT0500 DS    0H
         OI    LGWFLAG,LGWSHDR     Indicate to Suppress Header Lines
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
LGPT0600 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         BRU   LGPT3000            Branch to Print Generic Logger Data
*
*+-------------------------------------------------------------------+*
*|    Build the Output Line for a User Program Log Point Entry       |*
*+-------------------------------------------------------------------+*
*| Example:                                                          |*
*|                                                                   |*
*|  Log) ==>Watch Point: LABL1000                                    |*
*|             -                                                     |*
*|  Log) ==>Log Point**: LABL2000                                    |*
*+-------------------------------------------------------------------+*
*
LGPT1000 DS    0H
         LA    RLINE,LNE.LGWOLINE  Set Starting Position in Print Line
         MVC   0(4,RLINE),=C'Log)' Copy Log Point Indicator to Line
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LLGC  R15,LCATRIND        Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         TM    LGRPFLAG,LGRWATCH   Is This for a Logger Watch Point?
         BRZ   LGPT1100            No  => Process for Storage Display
         LLGT  R1,=A(LGRPT473)     Point to Header '==>Watch Point:'
         BRU   LGPT1200            Branch to Process for Watch Point
LGPT1100 DS    0H
         LLGT  R1,=A(LGRPT475)     Point to Header '==>Log Point**:'
LGPT1200 DS    0H
         MVC   0(15,RLINE),0(R1)   Move in the Detail Line Header
         LA    RLINE,16(,RLINE)    Increment to the Next Field Position
         LLGC  R15,LGRNAMEL        Get the Length of Log Point Name
         BCTGR R15,0               Decrement for the Execute
         MVC   0(*-*,RLINE),LGRNAME ...Indicated Target of the Execute
LGPT1300 DS    0H
         EX    R15,*-6             Copy Log Point Name to Output Line
         LA    RLINE,2(R15,RLINE)  Increment to Point Past the Name
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
LGPT1400 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*| Determine If Logger Output Records in the Work Area Buffer Are To |*
*| Be Printed Immediately to the //LGRECOUT Output Data Set, Or To Be|*
*| Moved from the Temporary Work Buffer to a Larger Accumulation     |*
*| Buffer Area Which Will Defer the Printing of Logger Output Records|*
*| Until the End Of User Program Processing.                         |*
*+-------------------------------------------------------------------+*
*
LGPT2000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   LGPTEXIT            No  => Branch to Exit This Routine
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   LGPT2100            Yes => Use Buffers Above-the-Line
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   LGPT2200            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Recds To Output Now
         BRU   LGPT2500            Branch For Log Point Msgs and Data
LGPT2100 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   LGPT2300            Branch to Process Records to Buffers
LGPT2200 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
LGPT2300 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Process Log Records to Buffer Area  X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R4)),              ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Log Recrds to Buffer
         LTGFR R15,R15             Was Write Buffer Request Successful?
         BRZ   LGPT2400            Yes => Branch to Process Request
         LGHI  R2,((LGPT2500-LGPT2400)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LGPT2400            No  => Process Return to Buffer Rcds
         BRU   LGPTEXIT            Branch to Exit This Routine
LGPT2400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LGPT2500            Process For Log Records to Buffer
         BRU   LGPT2500            Process On Buffer Warning
         BRU   LGPT2600            Process for Validation Error
         BRU   LGPT2600            Process for Severe Error - Set Flag
LGPT2500 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRU   LGPT3000            Process For Log Records to Buffer
LGPT2600 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   LGPTEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Process For Any Additional Messages and Logger Options Which Were |*
*| Defined by the User in the "#LGPOINT" Log Point Request.          |*
*+-------------------------------------------------------------------+*
*
LGPT3000 DS    0H
         BRAS  RLINK1,LPRT0000     Print Additional Logger Output Data
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LGPTEXIT DS    0H
         LG    RLINK1,LGWRLNK1     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*                 End of Log Point Entry Processing                   *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| T N M E 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*| P e r f o r m   T r a n s l a t e   A d d r e s s   To   N a m e  |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TNME0000                                           *
*                                                                     *
* FUNCTION:        Translate Address to Program Name                  *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  the Load Module Name, or the Control Section Name  *
*                  and the Control Section offset for an address      *
*                  within a user program.                             *
*                                                                     *
*                  This translate address routine is passed a given   *
*                  address as input. This routine processes the       *
*                  address by attempting to locate the name of the    *
*                  load module that resides at the storage address    *
*                  which was passed. Initially this routine will      *
*                  locate the current Control Section (CSECT) name    *
*                  and offset into the Control Section represented by *
*                  the requested log point entry. When a user program *
*                  uses the copybook 'LGCPLOGR', that copybook has a  *
*                  protocol which determines the address and the      *
*                  length of the Control Section (CSECT), and places  *
*                  that information in the Logger Control Area (LCA)  *
*                  prefix where its location is known. Obtaining this *
*                  address in the LCA gets the pointer to the start of*
*                  that CSECT. The Control Section (CSECT) name can be*
*                  extracted from the eyecatcher at the beginning of  *
*                  the program.                                       *
*                                                                     *
*                  Otherwise, to locate the load module name may      *
*                  require the use of Contents Supervision of z/OS    *
*                  Program Management Services. This routine will run *
*                  the CDE chain (JPAQ) from the TCB to determine if  *
*                  the storage address passed to this routine points  *
*                  into any program that was entered via the LINK,    *
*                  SYNCH, or ATTACH. If not, then an attempt will be  *
*                  made to run the LLE (Load List Element) chain to   *
*                  verify if the address is in a module that was      *
*                  loaded for the user's job. If still not found then *
*                  search the LPAQ looking at each module in the LPA  *
*                  to verify if our input address that was passed to  *
*                  this routine is in one of the modules in the Link  *
*                  Pack Area (LPA).                                   *
*                                                                     *
* INPUT DATA:      R15      => Storage Address                        *
*                  RLCA     => Pointer to Caller's LCA Area           *
*                                                                     *
* OUTPUT DATA:     LGWLMOD  = The Load Module Name                    *
*                  LGWCSECT = The Program CSECT Name                  *
*                  LGWMODID = The Program CSECT Name and Version      *
*                  LGWOFSET = Offset into CSECT as "+(000000)"        *
*                  LGWPGMNM = The Module Name as LMOD.csect+(000000)  *
*                                                                     *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
TNME0000 DS    0H
         STG   RLINK1,LGWRLNK2     Save Our Linkage Register Address
         LLGT  R1,=A(SPACES)       Point to Area Containing Blanks
         MVC   LGWPGMNM,0(R1)      Clear Program Name Area to Spaces
         LLGTR R2,R15              Preserve the Input Storage Address
         LGR   R3,RLCA             Reserve Logger Control Area Address
         MVC   LGWLMOD(8),=C'UNKNOWN ' Default to Load Module Not Found
         XC    LGWOFSET,LGWOFSET   Clear the Load Module Offset Field
*
*+-------------------------------------------------------------------+*
*|    Locate CSECT Name and Offset from Logger Control Area (LCA)    |*
*+-------------------------------------------------------------------+*
*
TNME0100 DS    0H
         LLGT  R14,LCACSADR        Get the Caller's CSECT Address
         CLGF  R15,=A(X'FFFFF002') Is 64-Bit Entry Linkage Indicated?
         BRNE  TNME0200            No  => Branch to Process Load Module
         LGR   R2,R14              Preserve the Input Storage Address
TNME0200 DS    0H
         LGR   R15,R14             Caller's CSECT Addr to Work Register
         ALGF  R15,LCACSLTH        Add CSECT Length to CSECT Start Addr
         CGR   R2,R14              Input Address Within This Program?
         BRL   TNME0600            No  => User Program Name Not Found
         CGR   R2,R15              Input Address Within This Program?
         BRH   TNME0600            No  => User Program Name Not Found
TNME0300 DS    0H
         CLC   LCASAVE+L'LCAS64F5A(L'LCAS64F5A),=C'F5SA' From Main Pgm?
         BRE   TNME0400            Yes => Then Entry is to Main Program
         MVC   LGWMODID,25(R14)    Obtain the CSECT Name and Version
         BRU   TNME0500            Branch to Process the Csect Name
TNME0400 DS    0H
         MVC   LGWMODID,21(R14)    Obtain the CSECT Name and Version
TNME0500 DS    0H
         LGR   R15,R2              Input Storage Addr to Work Register
         SLGR  R15,R14             Calculate Offset of Addr into CSECT
         NILL  R15,X'FFFE'         Reset Odd Adr on Amod64 Branch Entry
         ST    R15,LGWWORKF        Save Offset Result to Work Area
         UNPK  LGWWORKD(7),LGWWORKF+1(4) .Convert Value in Hex to Zoned
         TR    LGWWORKD(6),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   LGWOFSET(2),=C'+('  Copy In Indicator for Offset Value
         MVC   LGWOFSET+2(6),LGWWORKD   Copy in Actual Calculated Value
         LGR   RLCA,R3             Restore Program Control Area Address
         BRU   TNME1000            Branch to Search Load Module Name
TNME0600 DS    0H
         TM    LCASFLAG,LCAMAINP   Is This the User's Main Program?
         BRZ   TNME0700            No  => Check for End of LCA Chain
         LLGT  R1,=A(LUNKNOWN)     Point to Area Containing Header Line
         MVC   LGWMODID(L'LUNKNOWN),0(R1)  Header Statement 'Unknown'
         LGR   RLCA,R3             Restore Program Control Area Address
         BRU   TNME1000            Branch to Search Load Module Name
TNME0700 DS    0H
         LG    RLCA,LCASAVE+(LCAF64BCK-LCASAVE)  Load Backchain Pointer
         BRU   TNME0100            Loop Up Save Area Chain-All Callers
*
*+-------------------------------------------------------------------+*
*|            Locate the Load Module Name in the z/OS JPAQ           |*
*+-------------------------------------------------------------------+*
*|    Search the job pack area queue representing a chain of CDE     |*
*|    (Contents Directory Entry) control blocks. Each CDE contains   |*
*|    the name of a load module, the address of the entry point for  |*
*|    the load module name, and a use count for how many users are   |*
*|    currently using the module. If the load module has an alias,   |*
*|    then there are two CDE's where one CDE is for the major name   |*
*|    representing the primary name of the module, and the other     |*
*|    CDE for the minor name of the module representing the alias.   |*
*|    The job pack area (JPA) is the virtual storage area that       |*
*|    contains the modules loaded into the private area of the       |*
*|    z/OS address space executing the user's program.               |*
*+-------------------------------------------------------------------+*
*
TNME1000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R1,4(,R1)           Obtain the Current TCB Address
         USING TCB,R1              Establish Addressability to TCB
         SLGR  R4,R4               Clear for Use as Work Register
         ICM   R4,B'0111',TCBJPQB  Get the Address of Last CDE in JPAQ
         USING CDENTRY,R4          Establish Addressability to the CDE
TNME1100 DS    0H
         TM    CDATTR,CDMIN        Is this Entry for a Minor CDE?
         BRO   TNME1600            Yes => Skip This Entry
         TM    CDATTR2,CDXLE       Do We Have an Extent List?
         BRZ   TNME1600            No  => Skip This Entry
         TM    CDATTR,CDNIC        Module in Process of Being Loaded?
         BRO   TNME1600            Yes => Skip This Entry
*
*+-------------------------------------------------------------------+*
*|    Determine if Input Address is in This Program's Extent List    |*
*|    From Job Pack Area Search                                      |*
*+-------------------------------------------------------------------+*
*
TNME1200 DS    0H
         SLGR  R15,R15             To Ensure Upper Half of Reg is Clear
         ICM   R15,B'1111',CDXLMJP There an Address for Extent List?
         BRZ   TNME1600            No  => Skip This Entry
         USING XTLST,R15           Establish Addressability to XTLST
         LLGT  R14,XTLNRFAC        Get the Number of Extents in List
TNME1300 DS    0H
         LLGT  R0,XTLMSBAD         Get the Main Storage Block Address
         LLGT  R1,XTLMSBLA         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Is Input Addr Less Than MSBAD Start?
         BRL   TNME1500            Yes =>
         CGR   R2,R1               Input Addr Greater Than MSBAD End?
         BRH   TNME1500            Yes =>
TNME1400 DS    0H
         MVC   LGWLMOD(L'CDNAME),CDNAME Extract Name of the Load Module
         MVC   LGWENTPT,CDENTPT    Get the Load Module Entry Point
         MVC   LGWSUBPL,CDSP       Get Load Module SubPool Identifier
         MVC   LGWATTR1,CDATTR     Get Load Module Attributes Flag 1
         MVC   LGWATTR2,CDATTR2    Get Load Module Attributes Flag 2
         MVC   LGWATTR3,CDATTR3    Get Load Module Attributes Flag 3
         LLGT  R3,XTLMSBAD         Get the Main Storage Block Address
         ST    R3,LGWMSBAD         Save Lmod Main Storage Block Address
         LLGT  R3,XTLMSBLA         Get Length of Main Storage Block
         ST    R3,LGWLODSZ         Save Length of Main Storage Block
         BRU   TNME4000            Branch to Process Module Name
TNME1500 DS    0H
         LA    R15,8(,R15)         Bump to the Next Main Storage Block
         BRCTG R14,TNME1300        Loop to Check Next Extent Lst Entry
TNME1600 DS    0H
         ICM   R4,B'1111',CDCHAIN  There Another CDE on the CDE Chain?
         BRZ   TNME2000            No  => End-Of-Chain, Check for LLE's
         BRU   TNME1100            Loop to Check the Next CDE
         DROP  R1,R4,R15           Remove Listed Regs as Base Regs
*
*+-------------------------------------------------------------------+*
*|    Locate the Load Module Name in the z/OS Load List              |*
*+-------------------------------------------------------------------+*
*|    Search the load list representing a chain of Load List Elements|*
*|    (LLE) control blocks. There is an LLE and a CDE for each module|*
*|    which has been explicity loaded by a task executing a program, |*
*|    and this queue of modules is available within the z/OS address |*
*|    space executing a user's program.                              |*
*+-------------------------------------------------------------------+*
*
TNME2000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R1,4(,R1)           Obtain the Current TCB Address
         USING TCB,R1              Establish Addressability to TCB
         SLGR  R5,R5               Ensure No Residual in Hi Half of Reg
         ICM   R5,B'1111',TCBLLS   Addr for Last LLE in the Load List?
         BRZ   TNME3000            No  => End-Of-Chain, Check the LPAQ
         USING LLE,R5              Establish Addressability to the LLE
TNME2100 DS    0H
         LLGT  R4,LLECDPT          Get Address of the CDE for the LLE
         USING CDENTRY,R4          Establish Addressability to the CDE
         TM    CDATTR,CDMIN        Is this Entry for a Minor CDE?
         BRO   TNME2600            Yes => Skip This Entry
         TM    CDATTR2,CDXLE       Do We Have an Extent List?
         BRZ   TNME2600            No  => Skip This Entry
         TM    CDATTR,CDNIC        Module in Process of Being Loaded?
         BRO   TNME2600            Yes => Skip This Entry
*
*+-------------------------------------------------------------------+*
*|    Determine if Input Address is in This Program's Extent List    |*
*|    From Load List Search.                                         |*
*+-------------------------------------------------------------------+*
*
TNME2200 DS    0H
         ICM   R15,B'1111',CDXLMJP There an Address for Extent List?
         BRZ   TNME2600            No  => Skip This Entry
         USING XTLST,R15           Establish Addressability to XTLST
         LLGT  R14,XTLNRFAC        Get the Number of Extents in List
TNME2300 DS    0H
         LLGT  R0,XTLMSBAD         Get the Main Storage Block Address
         LLGT  R1,XTLMSBLA         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Is Input Addr Less Than MSBAD Start?
         BRL   TNME2500            Yes => Then Not in This Module
         CGR   R2,R1               Input Addr Greater Than MSBAD End?
         BRH   TNME2500            Yes => Then Not in This Module
TNME2400 DS    0H
         MVC   LGWLMOD(L'CDNAME),CDNAME Extract Name of the Load Module
         MVC   LGWENTPT,CDENTPT    Get the Load Module Entry Point
         MVC   LGWSUBPL,CDSP       Get Load Module SubPool Identifier
         MVC   LGWATTR1,CDATTR     Get Load Module Attributes Flag 1
         MVC   LGWATTR2,CDATTR2    Get Load Module Attributes Flag 2
         MVC   LGWATTR3,CDATTR3    Get Load Module Attributes Flag 3
         LLGT  R3,XTLMSBAD         Get the Main Storage Block Address
         ST    R3,LGWMSBAD         Save Lmod Main Storage Block Address
         LLGT  R3,XTLMSBLA         Get Length of Main Storage Block
         ST    R3,LGWLODSZ         Save Length of Main Storage Block
         MVC   LGWLLECT,LLECOUNT   Get Load Module Responsibility Count
         BRU   TNME4000            Branch to Process Module Name
TNME2500 DS    0H
         LA    R15,8(,R15)         Bump to the Next Main Storage Block
         BRCTG R14,TNME2300        Loop to Check Next Extent Lst Entry
TNME2600 DS    0H
         ICM   R5,B'1111',LLECHN   There Another LLE on the LLE Chain?
         BRZ   TNME3000            No  => End-Of-Chain, Check the LPAQ
         BRU   TNME2100            Loop to Check the Next LLE
         DROP  R1,R4,R5,R15        Remove Listed Regs as Base Regs
*
*+-------------------------------------------------------------------+*
*|    Locate the Load Module Name in the z/OS LPAQ                   |*
*+-------------------------------------------------------------------+*
*|    Search the z/OS Link Pack Area Queue representing a queue of   |*
*|    of Contents Directory Entries (CDE's) for user program related |*
*|    modules residing in the the FLPA, MLPA, and for the currently  |*
*|    active PLPA modules.                                           |*
*+-------------------------------------------------------------------+*
*
TNME3000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         SLGR  R4,R4               Clear for Use as Work Register
         ICM   R4,B'0111',CVTLPDIR  ...Get Address of the LPA Directory
         USING CDENTRY,R4          Establish Addressability to the CDE
TNME3100 DS    0H
         TM    CDATTR,CDMIN        Is this Entry for a Minor CDE?
         BRO   TNME3600            Yes => Skip This Entry
         TM    CDATTR2,CDXLE       Do We Have an Extent List?
         BRZ   TNME3600            No  => Skip This Entry
         TM    CDATTR,CDNIC        Module in Process of Being Loaded?
         BRO   TNME3600            Yes => Skip This Entry
*
*+-------------------------------------------------------------------+*
*|    Determine if Input Address is in This Program's Extent List    |*
*|    From LPAQ Search                                               |*
*+-------------------------------------------------------------------+*
*
TNME3200 DS    0H
         ICM   R15,B'1111',CDXLMJP There an Address for Extent List?
         BRZ   TNME3600            No  => Skip This Entry
         USING XTLST,R15           Establish Addressability to XTLST
         LLGF  R14,XTLNRFAC        Get the Number of Extents in List
TNME3300 DS    0H
         LLGT  R0,XTLMSBAD         Get the Main Storage Block Address
         LLGT  R1,XTLMSBLA         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Is Input Addr Less Than MSBAD Start?
         BRL   TNME3500            Yes =>
         CGR   R2,R1               Input Addr Greater Than MSBAD End?
         BRH   TNME3500            Yes =>
TNME3400 DS    0H
         MVC   LGWLMOD(L'CDNAME),CDNAME Extract Name of the Load Module
         MVC   LGWENTPT,CDENTPT    Get the Load Module Entry Point
         MVC   LGWSUBPL,CDSP       Get Load Module SubPool Identifier
         MVC   LGWATTR1,CDATTR     Get Load Module Attributes Flag 1
         MVC   LGWATTR2,CDATTR2    Get Load Module Attributes Flag 2
         MVC   LGWATTR3,CDATTR3    Get Load Module Attributes Flag 3
         LLGT  R3,XTLMSBAD         Get the Main Storage Block Address
         ST    R3,LGWMSBAD         Save Lmod Main Storage Block Address
         LLGT  R3,XTLMSBLA         Get Length of Main Storage Block
         ST    R3,LGWLODSZ         Save Length of Main Storage Block
         BRU   TNME4000            Branch to Process Module Name
TNME3500 DS    0H
         LA    R15,8(,R15)         Bump to the Next Main Storage Block
         BRCTG R14,TNME3300        Loop to Check Next Extent Lst Entry
TNME3600 DS    0H
         ICM   R4,B'1111',CDCHAIN  There Another CDE on the CDE Chain?
         BRZ   TNME4000            No  => End-Of-Chain, Module Unknown
         BRU   TNME3100            Loop to Check the Next CDE
         DROP  R1,R4,R15           Remove Listed Registers as Base Regs
*
*+-------------------------------------------------------------------+*
*|    Build the Print Line for Module Name and CSECT Information     |*
*+-------------------------------------------------------------------+*
*|    Field LGWLMOD  = The Load Module Name                          |*
*|    Field LGWCSECT = The Program Control Section Name              |*
*|    Field LGWOFSET = The Offset into CSECT as "+(000000)"          |*
*|    Field LGWPGMNM = The Load Module Name as LMOD.CSECT+(000000)   |*
*+-------------------------------------------------------------------+*
*
TNME4000 DS    0H
         OC    LGWOFSET,LGWOFSET   Check If Value Filled in for Offset
         BRZ   TNME4100            No  => Then Calculate from CDE Entry
         BRU   TNME4200            Yes => Value Previously Calculated
TNME4100 DS    0H
         LLGT  R0,LGWMSBAD         Get Load Module Entry Point Address
         LGR   R1,R2               Get the Storage Address Passed to Us
         SGR   R1,R0               Calculate Offset Into Load Module
         ST    R1,LGWWORKF         Place Offset into Workarea
         UNPK  LGWWORKD(7),LGWWORKF+1(4) .Convert Value in Hex to Zoned
         TR    LGWWORKD(6),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   LGWOFSET(2),=C'+('  Copy In Indicator for Offset Value
         MVC   LGWOFSET+2(6),LGWWORKD   Copy in Actual Calculated Value
TNME4200 DS    0H
         LA    R2,LGWPGMNM         Get the Address of Line Build Area
         MVC   0(8,R2),LGWLMOD     Copy Load Module Name to Line
TNME4300 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   TNME4400            Yes => Branch to Process CSECT Name
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   TNME4300            Loop to Find the End of Module Name
TNME4400 DS    0H
         MVI   0(R2),C'.'          Insert the Separator Character
         LA    R2,1(,R2)           Increment Past Separator Character
         MVC   0(L'LGWCSECT,R2),LGWCSECT Copy LMOD Control Section Name
TNME4500 DS    0H
         CLI   0(R2),C' '          Is This The End of the CSECT Name?
         BRE   TNME4600            Yes => Branch to Process Offset
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   TNME4500            Loop to Find the End of CSECT Name
TNME4600 DS    0H
         MVC   0(L'LGWOFSET,R2),LGWOFSET ..Copy Offset Value for CSECT
         MVI   L'LGWOFSET(R2),C')' Set Closing Parenthesis for Offset
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TNMEEXIT DS    0H
         LG    RLINK1,LGWRLNK2     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
*
***********************************************************************
*     End of Translate Program Address to Program Name Processing     *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L P R T 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   F o r m a t   P r i n t   L i n e s   F o r   L o g    D a t a  |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: LPRT0000                                           *
*                                                                     *
* FUNCTION:        Print Logger Services Data                         *
*                                                                     *
*                  This routine is responsible for performing         *
*                  the formatting of logger data from a requested     *
*                  logger service specified in the user's program.    *
*                  The formatted records will either be written       *
*                  immediately to the //LGRECOUT DD data set, or      *
*                  moved to a buffer area to be printed at the        *
*                  termination of the user program.                   *
*                                                                     *
* CALLING ROUTINE: TPGM0000 - Program Entry Logger Routine            *
*                  TPGX0000 - Program Exit Logger Routine             *
*                  TSUB0000 - Program Subroutine Entry Logger Routine *
*                  TSBX0000 - Program Subroutine Exit Logger Routine  *
*                  LGPT0000 - Program Log Point Logger Routine        *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
* Example:                                                            *
*                                                                     *
*  You have Some code in your program:                                *
*                                                                     *
*  LABL3500 DS    0H                                                  *
*           OI    SMFFLAG1,X'80'      Indicate data is available      *
*                                                                     *
*                                                                     *
*  You define a log point in your program:                            *
*                                                                     *
*  LABL3500 #LGPOINT SHOW=(('SMFCOUNT',SMFCOUNT,L'SMFCOUNT),         X*
*              ('SMF$SAVE',SMF$SAVE,L'SMF$SAVE),                     X*
*              ('SMFINDEX',SMFINDEX,L'SMFINDEX)),REG=ALL             X*
*              MSG=('Checking Index for Log Date ',SMFLOGDT)          *
*           OI    SMFFLAG1,X'80'      Indicate data is available      *
*                                                                     *
*                                                                     *
*  SMFCOUNT DS    F                   |                               *
*  SMF$SAVE DS    F                   |   Some data areas defined     *
*  SMFLOGDT DS    CL20                |       in your program         *
*  SMFINDEX DS    XL32                |                               *
*                                                                     *
*                                                                     *
*  This routine creates the following Logger output when your program *
*  execution path excounters the log point (#LGPOINT) example shown   *
*  above:                                                             *
*                                                                     *
*  Log) ==>Log Point**: LABL3500                                      *
*  Msg) Checking Index for Log Date 20110420                          *
*  +    General Purpose Registers At Requested Log Point: LABL3500    *
*  +     R0 = 0000000000000BCC  R1 = 00000000FFFFFF8B  R2 = 000000000B*
*  +     R4 = 00000000F47D8300  R5 = 000000000B98448B  R6 = 000000000B*
*  +     R8 = 000000000B815718  R9 = 0000000000022150  R10= 0000000000*
*  +     R12= 000000000B805218  R13= 0000000000007BE0  R14= 00000000FF*
*  +    Access Registers:                                             *
*  +     AR0 = 00000000         AR1 = 18605308         AR2 = 00000000 *
*  +     AR4 = 00000000         AR5 = 00000000         AR6 = 00000000 *
*  +     AR8 = 00000000         AR9 = 00000000         AR10= 00000000 *
*  +     AR12= 00000000         AR13= 00000000         AR14= 00000000 *
*  +    SMFCOUNT                                                      *
*  +       0000000000007DE4          00000100                         *
*  +    SMF$SAVE                                                      *
*  +       0000000000007DD8          00000001                         *
*  +    SMFINDEX                                                      *
*  +       000000000B97D000          00000000 00003E8E 2DB4B0D0 013CEE*
*  +       000000000B97D010     +10  000003C2 00000000 E3C5E2E3 C9D5C7*
*                                                                     *
***********************************************************************
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
LPRT0000 DS    0H
         STG   RLINK1,LGWRLNK2     Save Our Linkage Register Address
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         SLGR  R4,R4               Clear for Use as a Line Counter
         TM    LGRPFLAG,LGRPMSG    Is There a Message to Print?
         BRZ   LPRT2000            No  => Then Check for REG=
         BRU   LPRT0100            Yes => Branch to Process Message
*
*+-------------------------------------------------------------------+*
*| Process the Output Line For A Logger Service Entry Specified With |*
*| the 'MSG=' Parameter.                                             |*
*|                                                                   |*
*| For Example:                                       (Process This) |*
*|                                                              |    |*
*| LABL3500 #LGPOINT SHOW=(('SMFCOUNT',SMFCOUNT,L'SMFCOUNT),    |    |*
*|             ('SMF$SAVE',SMF$SAVE,L'SMF$SAVE),                |    |*
*|             ('SMFINDEX',SMFINDEX,L'SMFINDEX)),REG=ALL,       |    |*
*|             MSG=('Checking Index for Log Date ',SMFLOGDT) <--+    |*
*+-------------------------------------------------------------------+*
*
LPRT0100 DS    0H
         MVI   LGWMSGTX,C' '       Set-up to Fill Msg Area with Blanks
         MVC   LGWMSGTX+1(L'LGWMSGTX-1),LGWMSGTX ...Propogate the Blank
         LA    RLINE,LGWMSGTX      Point to Start of Message Text Line
         LLGC  R1,LGRNAMEL         Get the Length of the Name Area
         LA    R15,LGRMSGL(R1)     Point at the Message Length
         TMLL  R1,(X'0001')        Length of Message Text Even Number?
         BRZ   LPRT0200            Yes => Obtain Length of Message Text
         LA    R15,1(,R15)         No  => Align on a Halfword Boundary
LPRT0200 DS    0H
         ICM   R1,B'0011',0(R15)   Obtain the Length of Message Text
         LA    R15,L'LGRMSGL(,R15) Increment Past the Message Length
LPRT0300 DS    0H
         CLI   0(R15),X'FE'        Is This an Embedded Variable?
         BRNE  LPRT0500            No  => Branch to Process Msg Text
LPRT0400 DS    0H
         BRAS  RLINK1,TVAR0000     Process the Embedded Variable
         LA    R15,VARLNGTH(R15)   Incremnt Past the Variable
         SLGF  R1,=A(VARLNGTH)     Decrement for the Remaining Length
         BRU   LPRT0600            Branch to Process Message Conversion
LPRT0500 DS    0H
         MVC   0(1,RLINE),0(R15)   Move Text to Line One Byte at a Time
         LA    RLINE,1(,RLINE)     Incremnt the Output Line Pointer
         LA    R15,1(,R15)         Incremnt the Input Text Msg Pointer
         BCTGR R1,R0               Decrement Msg Text Remaining Length
LPRT0600 DS    0H
         LTGR  R1,R1               Message Conversion Process Complete?
         BRNZ  LPRT0300            No  => Loop to Process Message Text
*
*+-------------------------------------------------------------------+*
*|   Compress Out Multiple Spaces If Requested From The 'COMPRESS='  |*
*|   Parameter                                                       |*
*+-------------------------------------------------------------------+*
*
LPRT0700 DS    0H
         TM    LGRPFLAG,LGRPCMPR   Was a Compress Option Requested?
         BRZ   LPRT1300            No  => Branch to Format & Print Msg
LPRT0800 DS    0H
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVI   LNE.LGWOLINE,C' '   Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWOLINE+1(L'LGWOLINE-1),LNE.LGWOLINE Propogate Blnk
         LA    R1,LGWMSGTX         Address of Msg Area Text To Compress
         LA    R2,L'LGWMSGTX       Set the Maximum Length For Move
         LA    R14,LNE.LGWOLINE    Set the Address of the Result Field
         LA    R15,L'LGWOLINE      Set the Maximim Result Length
LPRT0900 DS    0H
         CLC   =C'  ',0(R1)        Have an Area With Double Spaces?
         BRE   LPRT1100            Yes =>
LPRT1000 DS    0H
         MVC   0(1,R14),0(R1)      Move a Character to the Output Line
         LA    R14,1(,R14)         Increment the Output Line Pointer
         LA    R1,1(,R1)           Increment the Input Text Msg Pointer
         AGHI  R2,(-1)             Decrement Msg Text Remaining Length
         BRZ   LPRT1200            Branch If There Is No More Left
         BRCTG R15,LPRT0900        Loop to Process Next Byte in Msg Txt
         BRU   LPRT1200            => Done
LPRT1100 DS    0H
         LA    R1,1(,R1)           Increment the Input Text Msg Pointer
         AGHI  R2,(-1)             Decrement Msg Text Remaining Length
         BRNZ  LPRT0900            Loop to Process Next Byte in Msg Txt
LPRT1200 DS    0H
         MVI   LGWMSGTX,C' '       Set-up to Fill Msg Area with Blanks
         MVC   LGWMSGTX+1(L'LGWMSGTX-1),LGWMSGTX ...Propogate the Blank
         MVC   LGWMSGTX(L'LGWOLINE),LNE.LGWOLINE Put Result Back in Msg
         MVI   LNE.LGWOLINE,C' '   Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWOLINE+1(L'LGWOLINE-1),LNE.LGWOLINE Propogate Blnk
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*|    Format the Output Line From MSG= Parameter                     |*
*+-------------------------------------------------------------------+*
*
LPRT1300 DS    0H
         SLGR  R1,R1               Clear for Use as Work Register
         TM    LGRPFLAG,LGRPSHDR   Request to Suppress Header Lines?
         BRZ   LPRT1400            No  => Branch If No Suppression
         LA    RLINE,LNE.LGWOLINE+0 ..Set Address of the Output Line
         BRU   LPRT1600            Yes => Bypass Detail Line Header
LPRT1400 DS    0H
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVC   LNE.LGWOLINE(5),=C'Msg) ' Set Prefix Identifier for Msg
         LLGC  R1,LCATRIND         Obtain the Current Indention Level
LPRT1500 DS    0H
         LA    RLINE,LNE.LGWOLINE+5(R1) Set Indention Level For Message
LPRT1600 DS    0H
         MVC   0(L'LGWOLINE,RLINE),LGWMSGTX  Copy Message Text to Ouput
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
LPRT1700 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*|    Process the 64-Bit Register Values For A Logger Service Entry  |*
*|    Specified by the User With the 'REG=' Parameter.               |*
*|                                                                   |*
*| For Example:                                       (Process This) |*
*|                                                              |    |*
*| LABL3500 #LGPOINT SHOW=(('SMFCOUNT',SMFCOUNT,L'SMFCOUNT),    |    |*
*|             ('SMF$SAVE',SMF$SAVE,L'SMF$SAVE),                |    |*
*|             ('SMFINDEX',SMFINDEX,L'SMFINDEX)),REG=ALL, <-----+    |*
*|             MSG=('Checking Index for Log Date ',SMFLOGDT)         |*
*|                                                                   |*
*|    First thing Is to Print the Register Header Line.              |*
*|                                                                   |*
*| +    General Purpose Registers At Requested Log Point: LABL3500   |*
*+-------------------------------------------------------------------+*
*
LPRT2000 DS    0H
         CLC   LGRREGS,=X'0000'    Are There Any Registers to Print?
         BRZ   LPRT5000            No  => Check for Other Parameters
LPRT2100 DS    0H
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVI   LNE.LGWOLINE,C' '   Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWOLINE+1(L'LGWOLINE-1),LNE.LGWOLINE Propogate Blnk
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LA    RLINE,LNE.LGWOLINE+5 Get Starting Address of Output Line
         LLGC  R15,LCATRIND        Set the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for Indention Level
LPRT2200 DS    0H
         CLC   LGRTYPE,=C'LPRG'    Is Logger Request For Program Entry?
         BRNE  LPRT2300            No  => Check for Program Exit
         LLGT  R1,=A(PGMEREGS)     Point to Area Containing Header Line
         MVC   0(L'PGMEREGS,RLINE),0(R1)  ...Copy in Register Header
         BRU   LPRT3000            Branch to Process Print of Registers
LPRT2300 DS    0H
         CLC   LGRTYPE,=C'LPRX'    Is Logger Request For Program Exit?
         BRNE  LPRT2400            No  => Check for Subroutine Entry
         LLGT  R1,=A(PGMXREGS)     Point to Area Containing Header Line
         MVC   0(L'PGMXREGS,RLINE),0(R1)  ...Copy in Register Header
         BRU   LPRT3000            Branch to Process Print of Registers
LPRT2400 DS    0H
         CLC   LGRTYPE,=C'LSBE'    Logger Request For Subroutine Entry?
         BRNE  LPRT2500            No  => Check for Subroutine Exit
         LLGT  R1,=A(SUBEREGS)     Point to Area Containing Header Line
         MVC   0(L'SUBEREGS,RLINE),0(R1)  ...Copy in Register Header
         BRU   LPRT3000            Branch to Process Print of Registers
LPRT2500 DS    0H
         CLC   LGRTYPE,=C'LSBX'    Logger Request For Subroutine Exit?
         BRNE  LPRT2600            No  => Check for Logger Log Point
         LLGT  R1,=A(SUBXREGS)     Point to Area Containing Header Line
         MVC   0(L'SUBXREGS,RLINE),0(R1)  ...Copy in Register Header
         BRU   LPRT3000            Branch to Process Print of Registers
LPRT2600 DS    0H
         CLC   LGRTYPE,=C'LPNT'    Is User Request For a Log Point?
         BRNE  LPRT2900            No  => Branch to Print Default Hdr
         TM    LGRPFLAG,LGRWATCH   Is Data Area Under a Storage Watch?
         BRZ   LPRT2700            No  => Branch for Log Point Header
         LLGT  R1,=A(LOGWREGS)     Get Addr to Watch Point Header Line
         MVC   0(L'LOGWREGS,RLINE),0(R1)  ...Copy in Register Header
         LA    RLINE,L'LOGWREGS+1(,RLINE) ...Increment to Next Field
         BRU   LPRT2800            No  => Branch to Process Registers
LPRT2700 DS    0H
         LLGT  R1,=A(LOGPREGS)     Get Address to Log Point Header Line
         MVC   0(L'LOGPREGS,RLINE),0(R1)  ...Copy in Register Header
         LA    RLINE,L'LOGPREGS+1(,RLINE) ...Increment to Next Field
LPRT2800 DS    0H
         LLGC  R15,LGRNAMEL        Get the Length of Log Point Name
         BCTGR R15,R0              Decrement for the Execute
         MVC   0(*-*,RLINE),LGRNAME ...Indicated Target of Execute
         EX    R15,*-6             Copy Log Point Name to Output Line
         BRU   LPRT3000            Branch to Process Print of Registers
LPRT2900 DS    0H
         LLGT  R1,=A(DFLTREGS)     Point to Area Containing Header Line
         MVC   0(L'DFLTREGS,RLINE),0(R1)  ...Copy in Register Header
LPRT3000 DS    0H
         SLGR  R0,R0               Clear for Use as a Work Register
         SLGR  R1,R1               Clear for Use as a Work Register
         ICM   R1,B'1100',LGRREGS  Obtain the Register Numbers to Print
         LA    R2,4                Max No. of Regs to Print on One Line
         SLGR  R5,R5               Set Register Counter, Start With R0
         LA    R14,LGWREGS         Point to the Actual Register Values
         BRU   LPRT3600            Branch to Begin Loop to Print Regs
*
*+-------------------------------------------------------------------+*
*| Next Loop Through Register Numbers and Process Register Contents  |*
*| To Produce the General Purpose Register Output Lines.             |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*| +     R0 = 0000000000000BCC  R1 = 00000000FFFFFF8B  R2 = 000000000|*
*| +     R4 = 00000000F47D8300  R5 = 000000000B98448B  R6 = 000000000|*
*| +     R8 = 000000000B815718  R9 = 0000000000022150  R10= 000000000|*
*| +     R12= 000000000B805218  R13= 0000000000007BE0  R14= 00000000F|*
*+-------------------------------------------------------------------+*
*
LPRT3100 DS    0H
         SLGR  R0,R0               Clear for Use as Work Register
         SLDL  R0,1 Bit            Perform Shift One Bit Left Into R0
         LTGR  R0,R0               Bit Mask From R1 Get Pushed Into R0?
         BRNZ  LPRT3300            Yes => Then Process Register Value
LPRT3200 DS    0H
         LA    R14,8(,R14)         Increment Length to Next Reg Value
         LA    R5,1(,R5)           Increment Count to Next Reg Number
         CGHI  R5,(16)             With 16 GPR's, Any More to Process?
         BRE   LPRT3600            No  => Done
         BRU   LPRT3100            Yes => Branch to Check Next Reg No.
LPRT3300 DS    0H
         CVD   R5,LGWWORKD         Current Register Number to Decimal
         UNPK  LGWWORKD(3),LGWWORKD+6(2) ..Register No. to Zoned Format
         OC    LGWWORKD(3),=3C'0'  Set Proper Sign to Make Printable
         MVI   LGWWORKD,C'R'       Character Symbol 'R' on Register No.
         CGHI  R5,(9)              Is Current Register a Two Digit No.?
         BRH   LPRT3400            Yes => Then No Alignment
         MVC   LGWWORKD+1(1),LGWWORKD+2  Shift It Over for Single Digit
         MVI   LGWWORKD+2,C' '     End It with a Blank
LPRT3400 DS    0H
         MVC   0(3,RLINE),LGWWORKD Copy the Register No. to Output Line
         MVI   3(RLINE),C'='       Move in Equal Sign to Make 'Rn = '
         LA    RLINE,5(,RLINE)     Increment Past Reg No. Identifier
         UNPK  LGWWRK16(9),0(5,R14) Obtain the High-Half Register Value
         UNPK  LGWWRK16+8(9),4(5,R14) ...Obtain Low-Half Register Value
         TR    LGWWRK16(16),HEXCONV-C'0' ...Translate Hex to Character
         MVC   0(L'LGWWRK16,RLINE),LGWWRK16 Register Value to Output Ln
         LA    RLINE,18(,RLINE)    Increment Line Pnter for Next Field
LPRT3500 DS    0H
         LA    R5,1(,R5)           Increment to Next Register Number
         CGHI  R5,(16)             With 16 GPR's, Any More to Print?
         BRE   LPRT3600            No  => Done
         LA    R14,8(,R14)         Increment Length to Next Reg Value
         BRCTG R2,LPRT3100         Loop Within a Single Detail Line
LPRT3600 DS    0H
         LLGT  R15,=A(EBCDIC)      Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R15) Translate Hex to Ensure Printable
LPRT3700 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LA    RLINE,LNE.LGWOLINE+5 ...Set the Address of Output Line
         LLGC  R15,LCATRIND        Set the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for Current Indention Lvl
LPRT3800 DS    0H
         LA    R2,4                Max No. of Regs to Print on One Line
         LTGR  R1,R1               Any More General Registers to Print?
         BRNZ  LPRT3100            Yes => Loop For Next Detail Line
LPRT4000 DS    0H
         LLGT  R1,=A(DFLAREGS)     Point to Area Containing Header Line
         MVC   0(L'DFLAREGS,RLINE),0(R1) Copy in Access Register Header
         SLGR  R0,R0               Clear for Use as a Work Register
         SLGR  R1,R1               Clear for Use as a Work Register
         ICM   R1,B'1100',LGRREGS  Obtain the Register Numbers to Print
         LA    R2,4                Max No. of Regs to Print on One Line
         SLGR  R5,R5               Set Register Counter, Start With AR0
         LA    R14,LGWACREG        Point to the Access Register Values
         BRU   LPRT4600            Branch to Begin Loop to Print Regs
*
*+-------------------------------------------------------------------+*
*| Next Loop Through Access Register Numbers and Process Register    |*
*| Contents To Produce the Access Register Output Lines.             |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*| +    Access Registers:                                            |*
*| +    AR0 = 00000000         AR1 = 00000000         AR2 = 00000000 |*
*| +    AR4 = 00000000         AR5 = 00000000         AR6 = 00000000 |*
*| +    AR8 = 00000001         AR9 = 00000000         AR10= 00000000 |*
*| +    AR12= 00000001         AR13= 00000000         AR14= 00000000 |*
*+-------------------------------------------------------------------+*
*
LPRT4100 DS    0H
         SLGR  R0,R0               Clear for Use as Work Register
         SLDL  R0,1 Bit            Perform Shift One Bit Left Into R0
         LTGR  R0,R0               Bit Mask From R1 Get Pushed Into R0?
         BRNZ  LPRT4300            Yes => Then Process Register Value
LPRT4200 DS    0H
         LA    R14,L'LGWACREG(,R14) Increment Length to Next Reg Value
         LA    R5,1(,R5)           Increment Count to Next Reg Number
         CGHI  R5,(16)             With 16 AR's, Any More to Process?
         BRE   LPRT4600            No  => Done With Access Registers
         BRU   LPRT4100            Yes => Branch to Check Next Reg No.
LPRT4300 DS    0H
         CVD   R5,LGWWORKD         Current Register Number to Decimal
         UNPK  LGWWORKD+1(3),LGWWORKD+6(2) Register No. to Zoned Format
         OC    LGWWORKD+1(3),=3C'0' ..Set Proper Sign to Make Printable
         MVC   LGWWORKD(2),=C'AR'  Prefix Character Symbol 'AR' on Reg#
         CGHI  R5,(9)              Is Current Register a Two Digit No.?
         BRH   LPRT4400            Yes => Then No Alignment
         MVC   LGWWORKD+2(1),LGWWORKD+3  Shift It Over for Single Digit
         MVI   LGWWORKD+3,C' '     End It with a Blank
LPRT4400 DS    0H
         MVC   0(4,RLINE),LGWWORKD Copy the Register No. to Output Line
         MVI   4(RLINE),C'='       Move in Equal Sign to Make 'ARn = '
         LA    RLINE,6(,RLINE)     Increment Past Reg No. Identifier
         UNPK  LGWWRK09,0(5,R14)   Obtain the Actual Register Value
         TR    LGWWRK09(8),HEXCONV-C'0' ...Translate Hex to Character
         MVC   0(L'LGWWRK09-1,RLINE),LGWWRK09 Register Value to Output
         LA    RLINE,17(,RLINE)    Increment Line Pnter for Next Field
LPRT4500 DS    0H
         LA    R5,1(,R5)           Increment to Next Register Number
         CGHI  R5,(16)             With 16 AR's, Any More to Print?
         BRE   LPRT4600            No  => Done With Access Registers
         LA    R14,L'LGWACREG(,R14) Increment Length to Next Reg Value
         BRCTG R2,LPRT4100         Loop Within a Single Detail Line
LPRT4600 DS    0H
         LLGT  R15,=A(EBCDIC)      Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R15) Translate Hex to Ensure Printable
LPRT4700 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LA    RLINE,LNE.LGWOLINE+5 ...Set the Address of Output Line
         LLGC  R15,LCATRIND        Set the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for Current Indention Lvl
LPRT4800 DS    0H
         LA    R2,4                Max No. of Regs to Print on One Line
         LTGR  R1,R1               Any More Access Registers to Print?
         BRNZ  LPRT4100            Yes => Loop For Next Detail Line
*
*+-------------------------------------------------------------------+*
*|  Verify If There Is Any Data Requested From a Log Point Defined   |*
*|  In User Program With the 'PVTAREA=YES' Parameter                 |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*|  XYZ01000  #LGPOINT REG=ALL,PVTAREA=YES                           |*
*+-------------------------------------------------------------------+*
*
LPRT5000 DS    0H
         TM    LGRPFLAG,LGRPRIVT   A Request for Priv Area Allocations?
         BRZ   LPRT6000            No  => Branch to Check Storage Data
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  LGMHPSTG,           Process for Private Area AllocationsX
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R3),               ..Pass Current Line Position in BuffX
               (R4),               ..Pass Current Line Count in Buffer X
               LCATRIND),          ..Pass Pntr to Current Ident Level  X
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Priv Area Storage
         LTGFR R15,R15             Was Private Area Request Successful?
         BRZ   LPRT5100            Yes => Branch to Process Request
         LGHI  R5,((LPRT5200-LPRT5100)-4) ...Length of Branch Table
         CGR   R15,R5              Ret Code in R15 Exceed Table Length?
         BRL   LPRT5100            No  => Process Private Area Request
         BRU   LPRTEXIT            Branch to Exit This Routine
LPRT5100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LPRT5300            Build Records for Pvt Area Request
         BRU   LPRT5300            Warning on Processing Private Area
         BRU   LPRT5200            Validation Error Processing Pvt Area
         BRU   LPRT5200            Severe Error Processing Private Area
LPRT5200 DS    0H
         LMG   R3,R4,LGWOPOSI      Restore Lne Position/Count in Buffer
         LTGR  R3,R3               Current Lne Position Addr Available?
         BRZ   LPRTEXIT            No  => Branch to Exit This Routine
         BRU   LPRT6000            Yes => Attempt to Recover, Continue
LPRT5300 DS    0H
         LMG   R3,R4,LGWOPOSI      Restore Lne Position/Count in Buffer
*
*+-------------------------------------------------------------------+*
*|Verify If There Is Any Data Requested From a Log Point Defined in a|*
*|User Program With the 'SHOW=' Parameter or the 'WATCH=' Parameter. |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*|  XYZ02000 #LGPOINT SHOW=('SETWORKD',SETWORKD,L'SETWORKD),REG=ALL  |*
*|                                                                   |*
*|  XYZ03000 #LGPOINT WATCH=('IARV64 AREA',(R4),32760)               |*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
LPRT6000 DS    0H
         TM    LGRPFLAG,LGRPTRIM   There a Request to Trim Logger Data?
         BRZ   LPRT6100            No  => Check for Logger Data to Prnt
         OI    LGWFLAG,LGWSCVTM    Yes => Indicate Subject to Trimming
LPRT6100 DS    0H
         TM    LGRPFLAG,LGRPSHOW+LGRWATCH There Data to Print or Watch?
         BRZ   LPRT6200            No  => Check for Pending Data
         TM    LGRPFLAG,LGRWATCH   Is Data Area Under a Storage Watch?
         BRZ   LPRT6900            No  => Branch to Process the Data
         OI    LGWFLAG2,LGW$WTCH   Yes => Indicate Subject to a Watch
         BRU   LPRT6900            Continue on to Process the Data
LPRT6200 DS    0H
         LTGR  R4,R4               Is Any Previous Logger Data Pending?
         BRZ   LPRT7800            No  => Branch to Bypass Data Process
*
*+-------------------------------------------------------------------+*
*| Determine If Logger Output Records in the Work Area Buffer Are To |*
*| Be Printed Immediately to the //LGRECOUT Output Data Set, Or To Be|*
*| Moved from the Temporary Work Buffer to a Larger Accumulation     |*
*| Buffer Area Which Will Defer the Printing of Logger Output Records|*
*| Until the End Of User Program Processing.                         |*
*+-------------------------------------------------------------------+*
*
LPRT6300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   LPRTEXIT            No  => Branch to Exit This Routine
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   LPRT6400            Yes => Use Buffers Above-the-Line
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   LPRT6500            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Recds To Output Now
         BRU   LPRTEXIT            Branch to Process Remaining Records
LPRT6400 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   LPRT6600            Branch to Process Records to Buffers
LPRT6500 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
LPRT6600 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Process Log Records to Buffer Area  X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R4)),              ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Log Recrds to Buffer
         LTGFR R15,R15             Was Buffer Logs Request Successful?
         BRZ   LPRT6700            Yes => Branch to Process Request
         LGHI  R5,((LPRT6800-LPRT6700)-4) ...Length of Branch Table
         CGR   R15,R5              Ret Code in R15 Exceed Table Length?
         BRL   LPRT6700            No  => Process Return to Buffer Rcds
         BRU   LPRTEXIT            Branch to Exit This Routine
LPRT6700 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LPRTEXIT            Log Records Processed to Buffer
         BRU   LPRTEXIT            Warning on Log Records to Buffer
         BRU   LPRTEXIT            Validation Error - Ignore & Continue
         BRU   LPRT6800            Process for Severe Error - Set Flag
LPRT6800 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   LPRTEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Process Any Storage Areas Associated With A Log Point Where User |*
*|  Defined the 'SHOW=' Parameter or the 'WATCH=' Parameter in Their |*
*|  Program.                                                         |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*|  ABCD0100 #LGPOINT SHOW=('WORKAREA',WORKAREA,L'WORKAREA),REG=ALL, |*
*|              MSG='Show Contents of Work Area and Regs'            |*
*|                                                                   |*
*|  ABCD1500 #LGPOINT WATCH=('IARV64 AREA',(R4),32760),REG=ALL       |*
*+-------------------------------------------------------------------+*
*
LPRT6900 DS    0H
         CLC   LGRTYPE,=C'LPNT'    Is User Request For a Log Point?
         BRNE  LPRT7000            No  => Check for Input Parameters
         TM    LGRPFLAG,LGRPMSG    Is There a Message to Print?
         BRZ   LPRT7600            No  => Then Branch to Process Data
         BRU   LPRT7400            Yes => Branch to Calculate Position
LPRT7000 DS    0H
         TM    LGRPFLAG,LGRPPARM   Are There Any Input Parms to Print?
         BRZ   LPRT7400            No  => Branch to Process Data
         CLC   LGRTYPE,=C'LPRG'    Is Log Request For Program Entry?
         BRNE  LPRT7800            No  => Bypass Print of Input Parms
LPRT7100 DS    0H
         TM    LGWFLAG,LGWSHDR     Suppress Header Lines Indicated?
         BRO   LPRT7400            Yes => Bypass Print of Header Lines
LPRT7200 DS    0H
         LA    RLINE,LNE.LGWOLINE+5   Obtain Address of the Output Line
         LLGT  R1,=A(INPTPRMH)     Point to Area Containing Header Line
         MVC   0(L'INPTPRMH,RLINE),0(R1) ...Copy in Input Parm Header
         MVC   L'INPTPRMH+1(L'LGWPGMSV,RLINE),LGWPGMSV  ...Program Name
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
LPRT7300 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
LPRT7400 DS    0H
         LA    R15,LGRSHOWL        Address of the SHOW=/WATCH= Segment
         LLGC  R1,LGRNAMEL         Get the Length of the Name Area
         LA    R15,LGRMSGL(R1)     Point at the Message Length
         TMLL  R1,(X'0001')        Length of Message Text Even Number?
         BRZ   LPRT7500            Yes => Obtain Length of Message Text
         LA    R15,1(,R15)         No  => Align on a Halfword Boundary
LPRT7500 DS    0H
         ICM   R1,B'0011',0(R15)   Obtain the Length of Message Text
         LA    R15,L'LGRMSGL(,R15) Increment Past the Message Text
         LA    R15,0(R1,R15)       Increment Past the Message Length
         BRU   LPRT7700            Branch to Print Associated Data
LPRT7600 DS    0H
         LLGC  R1,LGRNAMEL         Get the Length of the Name Area
         LA    R15,LGRMSGL(R1)     Point at the Data Length
         TMLL  R15,(X'0001')       Address to Data on Halfwrd Boundary?
         BRZ   LPRT7700            Yes => Branch for Log Point Data
         LA    R15,1(,R15)         No ==> Align on a Halfword Boundary
LPRT7700 DS    0H
         BRAS  RLINK1,LDAT0000     Process the Log Point Storage Data
LPRT7800 DS    0H
         BRU   LPRTEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LPRTEXIT DS    0H
         NI    LGWFLAG2,255-LGW$WTCH  Clear the Current Watch Indicator
         LG    RLINK1,LGWRLNK2     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*                  End of Print Log Data Processing                   *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| T V A R 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|      P e r f o r m   R e s o l v e   o f   V a r i a b l e s      |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: TVAR0000                                           *
*                                                                     *
* FUNCTION:        Perform Resolve and Copy Inline Variable           *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  resolution of an inline logger variable, and       *
*                  copying the contents of that variable to the       *
*                  message line.                                      *
*                                                                     *
*  For Example:                                                       *
*                                                                     *
*  LABL3500 #LGPOINT SHOW=(('SMFCOUNT',SMFCOUNT,L'SMFCOUNT),         X*
*              ('SMF$SAVE',SMF$SAVE,L'SMF$SAVE),                     X*
*              ('SMFINDEX',SMFINDEX,L'SMFINDEX)),REG=ALL             X*
*              MSG=('Checking Index for SMF Date ',SMFLOGDT)          *
*                                                     |               *
*      +---------------------------Resolve this-------+               *
*      |                                                              *
*  SMFLOGDT DS    CL20                                                *
*                                                                     *
*                                                                     *
* INPUT DATA:      R3       => Current Output Pointer in Record Area  *
*                  R4       => Current Record Position Count          *
*                  RLINE    => Current Output Pointer in LGWMSGTX     *
*                                                                     *
* CALLING ROUTINE: LPRT0000 - Print Logger Output Data Routine        *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
         USING VARS@TRC,R2         Establish Addressability to Var Area
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
TVAR0000 DS    0H
         STG   RLINK1,LGWRLNK3     Save Our Linkage Register Address
         STG   R15,LGWSAVRG        Preserve Message Text Length
         STG   R1,LGWSAVRG+8       Preserve Name Area Length
         STG   R2,LGWSAVRG+16      Preserve Additional Register
*
*+-------------------------------------------------------------------+*
*|    Resolve the Address Expression and Get the Length              |*
*+-------------------------------------------------------------------+*
*
TVAR0200 DS    0H
         TMLL  R15,(X'0001')       Address to Data on Halfwrd Boundary?
         BRZ   TVAR0300            Yes => Then Extract Base Register
         LA    R15,1(,R15)         No ==> Align on a Halfword Boundary
TVAR0300 DS    0H
         LGR   R2,R15              Set VARS@TRC Variable Area Address
         SLGR  R0,R0               Clear for Use as Work Register
         LLGC  R14,VARADDR+2       Base Register Used For Addr of Data
         SRLG  R14,R14,4 Bits      Isolate Just a Base Register Number
         SLLG  R14,R14,3 Bits      Offset Into LGWREGS (Multiply by 8)
         LG    R14,LGWREGS(R14)    Get the Address in the Base Register
         ICMH  R0,B'1100',VARADDR+2  Get B2 Field and DL2 (low) Field
         SRLG  R0,R0,4 Bits        Open a Byte Where DH2 to Overlay B2
         ICMH  R0,B'1000',VARADDR+4  Move DH2 High Field to Left of DL2
         SRAG  R1,R0,32+12 Bits    Create Signed 20-bit Binary Integer
         AGR   R14,R1              Reg Addr+Displacement Points at Data
         LA    R5,LGWMSGTX+L'LGWMSGTX Indicate Maximum Size For Message
         SLGR  R15,R15             Clear for Use as a Work Register
         ICM   R15,B'0011',VARLNTH ...Obtain the Length of Data
*
*+-------------------------------------------------------------------+*
*|  Determine the Type of Variable Data for the Formatting Routine   |*
*|  By Checking the Instruction Type Used to Define the Field in the |*
*|  User's Assembler Source.                                         |*
*+-------------------------------------------------------------------+*
*
TVAR0400 DS    0H
         CLI   VARTYPE,VARTYP@C    Is This Defined as Character Data?
         BRE   TVAR1000            Yes => Process for Character Format
         CLI   VARTYPE,VARTYP@Z    Defined as Zoned Character Data?
         BRE   TVAR1000            Yes => Process for Character Format
TVAR0600 DS    0H
         CLI   VARTYPE,VARTYP@H    This Data Defined as a Halfword?
         BRE   TVAR2200            Yes => Process for Binary Format
         CLI   VARTYPE,VARTYP@F    Is This Data Defined as a Fullword?
         BRNE  TVAR0800            No  => Then Check If Packed Decimal
         CGHI  R15,(8)             Length Indicate Data Defined as FD?
         BRE   TVAR4000            Yes => Then Use Hexidecimal Format
         BRU   TVAR2000            No  => Process for Binary Format
TVAR0800 DS    0H
         CLI   VARTYPE,VARTYP@P    This Data Defined as Packed Decimal?
         BRE   TVAR3000            Yes => Process for Packed Decimal
         BRU   TVAR4000            No  => Default to Hexidecimal Format
*
*+-------------------------------------------------------------------+*
*|    Process Variable Type for Character Data                       |*
*+-------------------------------------------------------------------+*
*
TVAR1000 DS    0H
         LA    R1,TVAR5000         Get Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         MVC   0(1,RLINE),0(R14)   Reference One Byte of Variable Data
         CLI   VARTYPE,VARTYP@Z    Is This Character Zoned Decimal?
         BRNE  TVAR1100            No  => Then Branch to Bump it Along
         OC    0(1,RLINE),=X'F0'   Then Ensure We Have a Good Zone
TVAR1100 DS    0H
         LA    RLINE,1(,RLINE)     Increment the Output Line Pointer
         LA    R14,1(,R14)         Increment Input Data Area Pointer
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Byte Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         CGR   RLINE,R5            Have We Filled The Output Buffer?
         BRE   TVAREXIT            Yes => Then Done, Do Not Overflow
         AGHI  R15,(-1)            Decrement the Length
         BRZ   TVAREXIT            Done - Branch to Exit This Routine
         BRU   TVAR1000            Loop to Process Next Byte of Data
*
*+-------------------------------------------------------------------+*
*|  Where the Variable Type Has Been Defined in the Assembler Source |*
*|  as a Halfword or Fullword, Display the Binary Value Within as a  |*
*|  Decimal Number.                                                  |*
*+-------------------------------------------------------------------+*
*
TVAR2000 DS    0H
         LA    R1,TVAR5000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         LLGF  R0,0(R14)           Get Input Variable Data - (Fullword)
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         BRU   TVAR2300            Branch to Process Binary Fullword
TVAR2200 DS    0H
         LA    R1,TVAR5000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         LLGH  R0,0(,R14)          Get Input Variable Data - (Halfword)
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
TVAR2300 DS    0H
         CVD   R0,LGWWORKD         Convert Number to Packed Decimal
         LLGT  R1,=A(PATTERN)      Point to Area Containing Header Line
         MVC   LGWWRK20,0(R1)      Copy In the Number Editing Pattern
         ED    LGWWRK20,LGWWORKD   Edit the Source Number to Character
TVAR2400 DS    0H
         LA    R14,L'LGWWRK20      Get the Length of Our Work Area
         LA    R15,LGWWRK20        Get the Address of Our Work Area
TVAR2500 DS    0H
         CLI   0(R15),C' '         Is This Byte a Blank Character?
         BRNE  TVAR2600            No  =>
         LA    R15,1(,R15)         Increment Input Data Area Pointer
         BRCTG R14,TVAR2500        Loop to Process the Next Byte
TVAR2600 DS    0H
         MVC   0(1,RLINE),0(R15)   Move Input Data One Byte At a Time
         LA    R15,1(,R15)         Increment Input Data Area Pointer
         LA    RLINE,1(,RLINE)     Increment the Output Line Pointer
         BRCTG R14,TVAR2600        Loop to Process the Next Byte
         LA    RLINE,1(,RLINE)     Set Output Pointer to Trailing Space
         BRU   TVAREXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Process Variable Type for Packed Decimal Data                  |*
*+-------------------------------------------------------------------+*
*
TVAR3000 DS    0H
         LA    R1,TVAR5000         Get Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         BCTGR R15,R0              Decrement Length for the Execute
         N     R15,=A(X'0000000F') Allow for a Maximum Length of 16
         O     R15,=A(X'00000070') Add To The Length (LGWWORKD)
         EX    R15,*+8             Move the Data to the LGWWORKD Area
         BRU   TVAR3100            Branch to Process Data to Output
         ZAP   LGWWORKD,0(*-*,R14) Indicated Target of the Execute
TVAR3100 DS    0H
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         LLGT  R1,=A(PATTERN)      Point to Area Containing Header Line
         MVC   LGWWRK20,0(R1)      Copy In The Number Editing Pattern
         ED    LGWWRK20,LGWWORKD   Edit The Source Number to Character
TVAR3200 DS    0H
         LA    R14,L'LGWWRK20      Get the Length of Our Work Area
         LA    R15,LGWWRK20        Get the Address of Our Work Area
TVAR3300 DS    0H
         CLI   0(R15),C' '         Is This Byte a Blank Character?
         BRNE  TVAR3400            No  =>
         LA    R15,1(,R15)         Increment Input Data Area Pointer
         BRCTG R14,TVAR3300        Loop to Process the Next Byte
TVAR3400 DS    0H
         MVC   0(1,RLINE),0(R15)   Move Input Data One Byte At a Time
         LA    R15,1(,R15)         Increment Input Data Area Pointer
         LA    RLINE,1(,RLINE)     Increment the Output Line Pointer
         BRCTG R14,TVAR3400        Loop to Process the Next Byte
         LA    RLINE,1(,RLINE)     Set Output Pointer to Trailing Space
         BRU   TVAREXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Process Variable Type for Hexidecimal Data                     |*
*+-------------------------------------------------------------------+*
*
TVAR4000 DS    0H
         LA    R1,TVAR5000         Get Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         MVC   LGWWORKD+4(1),0(R14) ..Reference a Byte of Variable Data
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Byte Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
TVAR4100 DS    0H
         UNPK  LGWWORKD(3),LGWWORKD+4(2) Unpack from Hexidecimal Format
         TR    LGWWORKD(2),HEXCONV-C'0' ...Make Variable Data Printable
         MVC   0(2,RLINE),LGWWORKD  Move Formatted Data to Print Line
TVAR4200 DS    0H
         LA    R14,1(,R14)         Increment Pointer for Input Data
         LA    RLINE,2(,RLINE)     Increment the Output Line Pointer
         CGR   RLINE,R5            Have We Filled The Output Buffer?
         BRE   TVAREXIT            Yes => Then Done, Do Not Overflow
         AGHI  R15,(-1)            Decrement the Length
         BRZ   TVAREXIT            Done-Branch to Exit This Routine
         BRU   TVAR4000            Loop to Process Next Byte of Data
*
*+-------------------------------------------------------------------+*
*|  Process For Abend Recovery If An Abend Has Occurred Attempting   |*
*|  to Reference the Variable Data. Write Error Message Indicating   |*
*|  an Abend Has Occurred Attempting to Reference Data the User Has  |*
*|  Specified, And Show the Address of the Data Which We Were        |*
*|  Attempting to Reference at the Time of the Abend (i.e., the most |*
*|  likely condition here being a S0C4 or S0C7).                     |*
*+-------------------------------------------------------------------+*
*
TVAR5000 DS    0H
         STG   R14,LGWWORK3        Current Data Address to Work Area
         UNPK  LGWWRK16(9),LGWWORK3(5) Get High-Half Register Value
         UNPK  LGWWRK16+8(9),LGWWORK3+4(5) Get Low-Half Register Value
         TR    LGWWRK16(16),HEXCONV-C'0' ...Translate Hex to Character
         MVI   LNE.LGWOLINE,C' '   Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWOLINE+1(L'LGWOLINE-1),LNE.LGWOLINE Propogate Blnk
         LA    RLINE,LNE.LGWOLINE+5  Obtain the Address of Output Line
         LLGC  R14,LCATRIND        Acquire the Current Indention Level
         LA    RLINE,0(R14,RLINE)  Increment For the Indention Level
TVAR5100 DS    0H
         LLGT  R1,=A(ABNDMSG1)     Indicate Abend on Referencing Data
         MVC   0(L'ABNDMSG1,RLINE),0(R1) Abend Event Msg to Detail Line
         LA    RLINE,L'ABNDMSG1(,RLINE) Increment to End of Event Msg
         MVC   0(L'LGWWRK16,RLINE),LGWWRK16 Show Adr Tried to Reference
TVAR5300 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
TVAREXIT DS    0H
         LG    R15,LGWSAVRG        Restore the Message Text Length
         LG    R1,LGWSAVRG+8       Restore the Name Area Length
         LG    R2,LGWSAVRG+16      Restore Additional Register
         LG    RLINK1,LGWRLNK3     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  R2                  Remove Listed Reg As Variable Base
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*        End of Resolve and Copy Inline Variables Processing          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L D A T 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   P e r f o r m   F o m a t   o f   L o g   P o i n t   D a t a   |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: LDAT0000                                           *
*                                                                     *
* FUNCTION:        Format Storage Data Associated With A Log Point    *
*                  Request.                                           *
*                                                                     *
*                  This routine is responsible for processing the     *
*                  dump of any storage data areas defined by a log    *
*                  point in a user program.                           *
*                                                                     *
*                  For Example:                                       *
*                                                                     *
*                  #LGPOINT SHOW=('SMF$DATA',SMF$DATA,L'SMF$DATA)     *
*                                                                     *
*                  #LGPOINT WATCH=('IARV64 AREA',(R4),32760)          *
*                                                                     *
*                                                                     *
* INPUT DATA:      R3       => LGWLINE                                *
*                  R4       => Pending Write Count                    *
*                  R15      => LGRMSGL                                *
*                                                                     *
* CALLING ROUTINE: LPRT0000 - Print Logger Output Data Routine        *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
         PUSH  USING               Save the Previous Environment Status
         DROP  RTLG                Remove Listed Reg to Log Point Area
         USING LGRSHOWL,R15        Establish Addressability to Data Fld
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
LDAT0000 DS    0H
         STG   RLINK1,LGWRLNK3     Save Our Linkage Register Address
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         LLGH  R2,LGRSHOWL         Get Leng of All SHOW=/WATCH= Entries
*
*+-------------------------------------------------------------------+*
*| Print The Message Heading For Storage Area to be Displayed        |*
*|                                                                   |*
*| For example:                                                      |*
*|                      +--Print this character string               |*
*|                      |                                            |*
*|   #LGPOINT SHOW=('SMF$DATA',SMF$DATA,L'SMF$DATA)                  |*
*+-------------------------------------------------------------------+*
*
LDAT1000 DS    0H
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         TM    LGWFLAG,LGWSHDR     Suppress Header Lines Indicated?
         BRZ   LDAT1100            No  => Branch If No Suppression
         LA    RLINE,LNE.LGWOLINE+0 ..Set Address of the Output Line
         BRU   LDAT1200            Branch to Process Current Print Line
LDAT1100 DS    0H
         LA    RLINE,LNE.LGWOLINE+5 ..Obtain Address of the Output Line
LDAT1200 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         TM    LGWFLAG,LGWSHDR     Suppress Header Lines Indicated?
         BRO   LDAT1400            Yes =>
LDAT1300 DS    0H
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LLGC  R14,LCATRIND        Set the Current Indention Level
         LA    RLINE,0(R14,RLINE)  Increment for the Indention Level
LDAT1400 DS    0H
         CLI   LGRDHDRL,X'00'      Was a Log Point Heading Provided?
         BRE   LDAT2000            No  =>
         LLGC  R14,LGRDHDRL        Obtain the Length of Heading
         BCTGR R14,0               Decrement the Length for Execute
         MVC   0(*-*,RLINE),LGRDHDR ...Indicated Target of Execute
LDAT1500 DS    0H
         EX    R14,*-6             Move the Heading to the Output Line
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
LDAT1600 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
*
*+-------------------------------------------------------------------+*
*| Resolve the Address Expression in the #LGPOINT Parameter Data Area|*
*| to Locate the Storage Area to be Dumped.                          |*
*|                                                                   |*
*| For example:                 +--To Resolve This Program Label     |*
*|                              |                                    |*
*| #LGPOINT SHOW=('SMF$DATA',SMF$DATA,L'SMF$DATA)                    |*
*|                              |                                    |*
*| In parameter data            V                                    |*
*| area of #LGPOINT-----> EB00 7670 001C     RLLG  R0,R0,SMF$DATA    |*
*|                             |                                     |*
*|                             |-----For 1 megabyte addressability a |*
*|                             |     20-bit (x'670 00') displacement |*
*|              Register 7-----+     format is used, and then must be|*
*|            + Offset               converted to valid signed binary|*
*|              ----------           integer that can be added to the|*
*|              Address to           address in register 7 to find   |*
*|               Storage             the location of the 1st byte of |*
*|                                   the storage area to be dumped.  |*
*+-------------------------------------------------------------------+*
*
LDAT2000 DS    0H
         SLGR  R0,R0               Clear for Use as Work Register
         LLGC  R3,LGR$ADDR+2       Base Register Used For Addr of Data
         SRLG  R3,R3,4 Bits        Isolate Just a Base Register Number
         SLLG  R3,R3,3 Bits        Offset Into LGWREGS (Multiply by 8)
         LG    R3,LGWREGS(R3)      Get the Address in the Base Register
         ICMH  R0,B'1100',LGR$ADDR+2  Get B2 Field and DL2 (low) Field
         SRLG  R0,R0,4 Bits        Open a Byte Where DH2 to Overlay B2
         ICMH  R0,B'1000',LGR$ADDR+4 Move DH2 High Field to Left of DL2
         SRAG  R1,R0,32+12 Bits    Create Signed 20-bit Binary Integer
         AGR   R3,R1               Reg Addr+Displacement Points at Data
         TM    LGRDFLAG,LGRDRD31+LGRDRD24  ...Redirection of Data?
         BRZ   LDAT2400            No  => Branch to Process Length
LDAT2100 DS    0H
         TM    LGRDFLAG,LGRDRD31   Is There 31-Bit Redirection of Data?
         BRZ   LDAT2300            No  => Assume 24-Bit Redirection
LDAT2200 DS    0H
         LA    R1,LDAT7000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         LLGT  R3,0(,R3)           Perform Redirect and Clear High Bit
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         BRU   LDAT2400            Branch to Check Length Value
LDAT2300 DS    0H
         LA    R1,LDAT7000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         LLGF  R3,0(,R3)           Perform Redirection of Address
         N     R3,=A(X'00FFFFFF')  Clear High Order Byte (24-Bit)
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
*
*+-------------------------------------------------------------------+*
*|  Get the Length of Storage Area to be Displayed                   |*
*|                                                                   |*
*| For example:                              +--Get Storage Length   |*
*|                                           |                       |*
*|   #LGPOINT SHOW=('SMF$DATA',SMF$DATA,L'SMF$DATA)                  |*
*+-------------------------------------------------------------------+*
*
LDAT2400 DS    0H
         SLGR  R4,R4               Clear for Use as Work Register
         XC    LGWOFF04,LGWOFF04   Clear the Offset Value Field
         ICM   R4,B'0011',LGRDLNTH Obtain the Length of Data to Print
         TM    LGRDFLAG,LGRDLREG   Is the Length in the Register?
         BRZ   LDAT2700            No  => Branch to Process Storage
LDAT2500 DS    0H
         SLLG  R4,R4,3 Bits        Get Offset Into LGWREGS (Multiply*8)
         LG    R4,LGWREGS(R4)      Obtain the Register Value
         LLGFR R4,R4               Ensure No Residual in High Half
         CLGF  R4,=F'32760'        Is Storage Area Leng Within Bounds?
         BRNH  LDAT2600            Yes => Branch to Process Storage
         LGHI  R4,(32760)          No  => Set a Maximum Storage Length
LDAT2600 DS    0H
         BRU   LDAT2700            Branch to Process Storage Area
*
*+-------------------------------------------------------------------+*
*|  Check If Our Data Area Is Under a Storage Watch. If the User     |*
*|  Specified the WATCH= Parameter Instead of the SHOW= Parameter,   |*
*|  Then Check the Storage Area to Determine if Any Data Has Changed.|*
*|  If No Change Has Occurred to Any Byte in the Designated Storage  |*
*|  Area, Then Bypass Printing the Storage Area. If Any Byte in the  |*
*|  Entire Storage Area Under a Watch Has Been Altered, Then Dump the|*
*|  Storage Area To Show the Changed Data.                           |*
*+-------------------------------------------------------------------+*
*
LDAT2700 DS    0H
         TM    LGWFLAG2,LGW$WTCH   Is There Data Under a Storage Watch?
         BRZ   LDAT3300            No  => Branch to Print the Data Area
         LA    R5,LGWHASH@         Get Adr of Storage Token Return Area
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  LGMHWTCH,           Check Data Area Under Storage Watch X
               (LGRWK2II,          ..Pass Addr to Logger Work Area     X
               (R3),               ..Pass Addr Storage Area Under WatchX
               (R4),               ..Pass the Length of Storage Area   X
               (R5)),              ..Pass Addr to Token Return Area    X
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Area Under a Watch
         LTGFR R15,R15             Storage Watch Request Successful?
         BRZ   LDAT2800            Yes => Branch to Process Request
         LGHI  R5,((LDAT2900-LDAT2800)-4) ...Length of Branch Table
         CGR   R15,R5              Ret Code in R15 Exceed Table Length?
         BRL   LDAT2800            No  => Branch to Process Request
         BRU   LDATEXIT            Branch to Exit This Routine
LDAT2800 DS    0H
         B     *+4(R15)            Branch Based on the Return Code
         BRU   LDAT2900            No Change to Data Area, Bypass Print
         BRU   LDAT3000            Data Changed or First Time Through
         BRU   LDAT3100            Process for Validation Error
         BRU   LDAT3200            Process for Severe Error
LDAT2900 DS    0H
         STMG  R3,R4,LGWSAVRG      Preserve Data Address and Length
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         BRU   LDAT8600            No Change to Storage, Bypass Dump
LDAT3000 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRU   LDAT3300            Data Changed - Dump the Storage Area
LDAT3100 DS    0H
         OI    LGWFLAG2,LGWTCERR   Show a Storage Watch Error Occurred
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRU   LDAT3300            Ignore Error - Dump the Storage Area
LDAT3200 DS    0H
         OI    LGWFLAG2,LGWTABND   Show a Storage Watch Abend Occurred
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         BRU   LDAT7000            Process for Recovery, Bypass Dump
*
*+-------------------------------------------------------------------+*
*|   Prepare for a New Output Line and Format the Storage Address    |*
*+-------------------------------------------------------------------+*
*
LDAT3300 DS    0H
         STMG  R3,R4,LGWSAVRG      Preserve Data Address and Length
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         TM    LGWFLAG,LGWSHDR     Suppress Header Lines Indicated?
         BRZ   LDAT3400            No  => Branch If No Suppression
         LA    RLINE,LNE.LGWOLINE+3 ..Set Address of the Output Line
         BRU   LDAT3500            Branch to Process Current Print Line
LDAT3400 DS    0H
         LA    RLINE,LNE.LGWOLINE+8 ...Set the Address of Output Line
LDAT3500 DS    0H
         LMG   R3,R4,LGWSAVRG      Restore Data Address and Length
         TM    LGWFLAG,LGWSHDR     Suppress Header Lines Indicated?
         BRO   LDAT3700            Yes =>
LDAT3600 DS    0H
         LG    R3,LGWWORK2         Restore Current Position in Rcd Area
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LG    R3,LGWSAVRG         Restore Data Address and Length
         LLGC  R14,LCATRIND        Set the Current Indention Level
         LA    RLINE,0(R14,RLINE)  Increment for the Indention Level
LDAT3700 DS    0H
         STG   R3,LGWWORK3         Current Data Address to Work Area
         UNPK  LGWWRK16(9),LGWWORK3(5) Get High-Half Storage Address
         UNPK  LGWWRK16+8(9),LGWWORK3+4(5) Get Low-Half Storage Address
         TR    LGWWRK16(16),HEXCONV-C'0' ...Translate Hex to Character
         MVC   0(L'LGWWRK16,RLINE),LGWWRK16 Address Value to Output Lne
         UNPK  LGWWRK09,LGWOFF04(5) Setup Hex Value to Make Printable
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0' Convert Hex to Char
         LA    R1,LGWWRK09         Work Area Has Offset into Data Area
         LA    R0,L'LGWWRK09-1     Get Leng of Work Area Holding Offset
LDAT3800 DS    0H
         CLI   0(R1),C'0'          This a Leading Zero in Offset No.?
         BRNE  LDAT3900            No  => Branch to Put a Prefix Char
         MVI   0(R1),C' '          Yes => Then Suppress Leading Zero
         LA    R1,1(,R1)           Increment to Next Byte in Work Area
         BRCTG R0,LDAT3800         Branch to Check for Leading Zero
         BRU   LDAT4000            If All Zeros, No Offset, 1st Line
LDAT3900 DS    0H
         BCTGR R1,R0               Backup to Position Before Offset No.
         MVI   0(R1),C'+'          Prefix '+' Character to Offset Value
         MVC   17(7,RLINE),LGWWRK09+1 Copy Offset Value to Output Line
LDAT4000 DS    0H
         LLGT  R1,LGWOFF04         Get Current Offset Value to Data
         LA    R1,16(,R1)          Each Output Line Dumps 16 Bytes Data
         ST    R1,LGWOFF04         Offset Value Bumped Up for Next Line
         LA    RLINE,26(,RLINE)    Still On Current Line, to Next Field
*
*+-------------------------------------------------------------------+*
*|  Process Sixteen Bytes of Storage Data One Fullword (4-Bytes) at  |*
*|  a Time and Convert to a Dump Format.                             |*
*|                                                                   |*
*|00000000000108CA       C1C2D3D3 D4D5C4C5 C6C3C4C5 D4D5D6D7   *ABLLM|*
*|00000000000108DA  +10  D9E6E9E8 E2E3E5C1 C1C1C2C2 C2C3C3C3   *RWZYS|*
*|00000000000108EA  +20  C6C6C6C5 C5C5D1D2 D3C2C3C4 C3C4C5C4   *FFFEE|*
*|                                                                   |*
*|<64-Bit Address>  Off  <----------- 16 bytes ------------>   Char  |*
*|                  Set              Hex Format                Format|*
*+-------------------------------------------------------------------+*
*
LDAT4100 DS    0H
         LA    R14,4               Max No. of Fullwrds to Print Per Lne
         LA    R5,38(,RLINE)       Point at Where Character Data Goes
         MVI   0(R5),C'*'          Copy in Starting Field Separator
         MVI   17(R5),C'*'         Copy in Ending Field Separator
         LA    R5,1(,R5)           Increment Past Starting Separator
LDAT4200 DS    0H
         LTGR  R4,R4               There Any Data Remaining to Process?
         BRZ   LDAT4800            No  => Then Print the Last Line
         CGF   R4,=F'4'            Do We Have at Least 4 Storage Bytes?
         BRNL  LDAT4600            Yes => Then Obtain the Data
LDAT4300 DS    0H
         XC    LGWWORKF,LGWWORKF   Clear Any Remaining Residual Data
         LA    R1,LDAT7000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         BCTGR R4,0                Decrement For the Execute
         MVC   LGWWORKF(*-*),0(R3) Indicated Target of Execute
LDAT4400 DS    0H
         EX    R4,*-6              Copy Our Data to the LGWWORKF Area
         LA    R4,1(,R4)           Increment to Restore Actual Length
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         UNPK  LGWWRK09,LGWWORKF(5) ...Extract Addr in Hex Char Format
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0' Convert Hex to Char
         SLLG  R4,R4,1 Bit         Double Length Value for Char Format
         BCTGR R4,0                Decrement for the Execute
         MVC   0(*-*,RLINE),LGWWRK09 ...Indicated Target of Execute
LDAT4500 DS    0H
         EX    R4,*-6              Copy Last Fullword to Output Line
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LGWWORKF,0(R1)      Translate Hex to Ensure Printable
         MVC   0(4,R5),LGWWORKF    Copy Character Data to Output Line
         SLGR  R4,R4               Clear the Current Count, All Done
         BRU   LDAT4800            Branch to Format the Output Line
LDAT4600 DS    0H
         LA    R1,LDAT7000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         MVC   LGWWORKF,0(R3)      Obtain a Fullword of Data to Format
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         UNPK  LGWWRK09,LGWWORKF(5) ...Extract Data in Hex Char Format
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0' Convert Hex to Char
         MVC   0(L'LGWWRK09-1,RLINE),LGWWRK09 Copy Addr to Output Line
         LA    RLINE,9(,RLINE)     Increment the Output Line Pointer
         LA    R3,4(,R3)           Increment the Input Pointer 4 Bytes
         SLGF  R4,=F'4'            Decrement Count of Bytes to Print
*
*+-------------------------------------------------------------------+*
*| An EBCDIC Translation of Each Byte of Storage Data is Printed to  |*
*| the Right of the Hexidecimal Representation of the Storage Data,  |*
*| With Periods "." Substituted for Those Bytes That Do Not Translate|*
*| to Valid Printable Characters. At This Point Copy Four Bytes of   |*
*| the EBCIDIC Formatted Storage Data to the Output Line, and Then   |*
*| Loop to Process the Next Fullword of Storage Data to the Current  |*
*| Output Line.                                                      |*
*+-------------------------------------------------------------------+*
*
LDAT4700 DS    0H
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LGWWORKF,0(R1)      Translate Hex to Ensure Printable
         MVC   0(4,R5),LGWWORKF    Copy Character Data to Output Line
         LA    R5,4(,R5)           Increment to Next Fullword Area
         BRCTG R14,LDAT4200        Loop to Process the Next Fullword
*
*+-------------------------------------------------------------------+*
*| Complete the Build of the Output Line in the Work Area Buffer     |*
*| Which Will Display in Character Format a Dump of Up to 16 Bytes   |*
*| Hex Data in the Storage Data. Then Check If There is More Storage |*
*| Data to Dump. If No More Storage Data, Then Write the Dump Lines  |*
*| in the Work Area Buffer. If More Storage, Then Continue with the  |*
*| Processing of the Remaining Bytes in the Storage Area.            |*
*+-------------------------------------------------------------------+*
*
LDAT4800 DS    0H
         STMG  R3,R4,LGWSAVRG      Preserve Data Address and Length
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         LA    R1,LDAT7000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         LLGT  R1,=A(EBCDIC)       Obtain the Addr of Translate Table
         TR    LNE.LGWOLINE,0(R1)  Translate Hex to Ensure Printable
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         LMG   R3,R4,LGWSAVRG      Restore Data Address and Length
         LTGR  R4,R4               Any More Storage Data to Process?
         BRNZ  LDAT5000            Yes => Branch to Check for More Data
LDAT4900 DS    0H
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         LA    R4,1(,R4)           Increment the Current Line Count
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         BRU   LDAT8000            Branch to Process Output Lines
*
*+-------------------------------------------------------------------+*
*| Process the Dump of the Remaining Storage Area. Before Fomatting  |*
*| the Next 16 Bytes of Storage Data to the Output Line, Perform a   |*
*| Look-Ahead Process to Check if the Previous 16 Byte Storage Area  |*
*| and The Current 16 Byte Storage Area Have Identical Contents. If  |*
*| Yes, Then Continue Looking Ahead Until a Different Line is Found. |*
*| Do Not Build Output Lines For Contiguous 16-Byte Storage Areas    |*
*| With Identical Contents, and Write Only a Single Output Line      |*
*| Indicating "SAME AS ABOVE" for the Range of Bytes with the Same   |*
*| Contents.                                                         |*
*|                                                                   |*
*|0000000001033F97       40404040 40404040 40404040 40404040   *     |*
*|0000000001033FA7  +10  0000000001033FA7 TO 0000000001033FD6 SAME AS|*
*|0000000001033FD7  +40  20414243 44454647 4849202E 3C282B7C   *.....|*
*|                                                                   |*
*|<64-Bit Address>  Off  <----------- 16 bytes ------------>   Char  |*
*|                  Set              Hex Format                Format|*
*+-------------------------------------------------------------------+*
*
LDAT5000 DS    0H
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVI   LNE.LGWOLINE,C'+'   Indicate This a Log Point Data Line
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         LMG   R3,R4,LGWSAVRG      Restore Storage Area Addr and Length
LDAT5100 DS    0H
         LA    R1,LDAT7000         Get Retry Recovery Address - (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         CGHI  R4,(16*3)           More Than 3 Output Lines of Data?
         BRNH  LDAT6000            No  => Branch to Process Next Line
         LG    R1,LGWWORK3         Get Address of the Previous Line
         CLC   16(32,R1),0(R1)     Prior Line and This Line Identical?
         BRNE  LDAT6000            No  => Branch to Process Next Line
         LGR   R0,R3               Start of Storage with the Same Area
         LA    R1,0(R3,R4)         Set Pointer to the Very End of Area
         BCTGR R1,R0               Point to Last Byte in Storage Area
LDAT5200 DS    0H
         CLC   16(16,R3),0(R3)     Next 16-Bytes Same as Previous One?
         BRNE  LDAT5300            No  => Show Lines with Same Contents
         AGHI  R3,(16)             Yes => Forward to Next 16-Byte Area
         LA    R14,32(,R3)         Look Ahead 32 Bytes Beyond Our Addr
         CLGR  R14,R1              Are More Than 32 Storage Bytes Left?
         BRNH  LDAT5200            Yes => Loop to Check the Next Area
LDAT5300 DS    0H
         LGR   R5,R3               Get Adr Last Line with Same Contents
         AGHI  R5,(16)             Point to 1st Line That is Different
         SLGR  R5,R0               Storage Area Size with Same Contents
         SLGR  R4,R5               Indicate Remaining Bytes in Our Area
         LA    R1,15(,R3)          Point to Last Byte of Last Same Line
LDAT5400 DS    0H
         STMG  R3,R4,LGWSAVRG      Save Storage Area Address and Length
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         TM    LGWFLAG,LGWSHDR     Is Suppress Header Lines Indicated?
         BRZ   LDAT5500            No  => Branch If No Suppression
         LA    RLINE,LNE.LGWOLINE+3 .Set the Address in the Output Line
         BRU   LDAT5600            Branch to Process Current Print Line
LDAT5500 DS    0H
         LA    RLINE,LNE.LGWOLINE+8 .Set the Address in the Output Line
LDAT5600 DS    0H
         LLGC  R14,LCATRIND        Acquire the Current Indention Level
         LA    RLINE,0(R14,RLINE)  Increment For the Indention Level
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         LMG   R3,R4,LGWSAVRG      Restore Storage Area Addr and Length
         STG   R0,LGWWORK3         Current Storage Address to Work Area
         UNPK  LGWWRK16(9),LGWWORK3(5) Get High-Half Storage Address
         UNPK  LGWWRK16+8(9),LGWWORK3+4(5) Get Low-Half Storage Address
         TR    LGWWRK16(16),HEXCONV-C'0' ...Translate Hex to Character
         MVC   0(L'LGWWRK16,RLINE),LGWWRK16 64-Bit Addr Value to Output
         UNPK  LGWWRK09,LGWOFF04(5) Get Offset Value to Make Printable
         TR    LGWWRK09(L'LGWWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         LA    R14,LGWWRK09        Work Area Has Offset into Data Area
         LA    R0,L'LGWWRK09-1     Get Leng of Work Area Holding Offset
LDAT5700 DS    0H
         CLI   0(R14),C'0'         This a Leading Zero in Offset No.?
         BRNE  LDAT5800            No  => Branch to Put a Prefix Char
         MVI   0(R14),C' '         Yes => Then Suppress Leading Zero
         LA    R14,1(,R14)         Increment to Next Byte in Work Area
         BRCTG R0,LDAT5700         Branch to Check for Leading Zero
         BRU   LDAT5900            If All Zeros, No Offset, 1st Line
LDAT5800 DS    0H
         BCTGR R14,R0              Backup to Position Before Offset No.
         MVI   0(R14),C'+'         Prefix '+' Character to Offset Value
         MVC   17(7,RLINE),LGWWRK09+1 Copy Offset Value to Output Line
LDAT5900 DS    0H
         MVC   26(16,RLINE),LGWWRK16 Addr of 1st Byte in 1st Same Line
         MVC   43(2,RLINE),=CL2'TO' Copy In Address Range Indicator
         STG   R1,LGWWORK3         Addr of Last Byte in Last Same Line
         UNPK  LGWWRK16(9),LGWWORK3(5) Get High-Half Storage Address
         UNPK  LGWWRK16+8(9),LGWWORK3+4(5) Get Low-Half Storage Address
         TR    LGWWRK16(16),HEXCONV-C'0' ...Translate Hex to Character
         MVC   46(L'LGWWRK16,RLINE),LGWWRK16  Copy Address of Last Byte
         MVC   63(13,RLINE),=CL13'SAME AS ABOVE' Area Has Same Contents
         STMG  R3,R4,LGWSAVRG      Save Storage Area Address and Length
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         MVI   LNE.LGWOLINE,C'+'   Indicate That This is a Data Line
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         LMG   R3,R4,LGWSAVRG      Restore Storage Address and Length
         LA    R3,16(,R3)          Start of Storage with Different Data
         LLGF  R14,LGWOFF04        Get the Offset into Storage Area
         ALGR  R14,R5              Add Last Offset to Present Offset
         ST    R14,LGWOFF04        Save New Current Offset into Storage
LDAT6000 DS    0H
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Data Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
*
*+-------------------------------------------------------------------+*
*|        Loop Point To Process the Next 16 Bytes of Storage         |*
*+-------------------------------------------------------------------+*
*
LDAT6100 DS    0H
         BRU   LDAT3300            Loop to Dump Next 16-bytes Storage
*
*+-------------------------------------------------------------------+*
*|  Process For Abend Recovery If An Abend Has Occurred Attempting   |*
*|  to Reference the Storage Data Due to the User Specifying an      |*
*|  Invalid Address.  Write an Error Message Indicating an Abend Had |*
*|  Occurred When Logger Services Attempted to Reference a Storage   |*
*|  Area the User Specified, and in the Message Show the Address of  |*
*|  the Storage Area That Logger Services Was Attempting to Reference|*
*|  at the Time of the Abend (i.e., the most likely condition here   |*
*|  being a S0C4).                                                   |*
*+-------------------------------------------------------------------+*
*
LDAT7000 DS    0H
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         STG   R3,LGWWORK3         Current Data Address to Work Area
         UNPK  LGWWRK16(9),LGWWORK3(5) Get High-Half Register Value
         UNPK  LGWWRK16+8(9),LGWWORK3+4(5) Get Low-Half Register Value
         TR    LGWWRK16(16),HEXCONV-C'0' ...Translate Hex to Character
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE+5 ..Obtain the Address of Output Line
         LLGC  R14,LCATRIND        Acquire the Current Indention Level
         LA    RLINE,0(R14,RLINE)  Increment For the Indention Level
LDAT7100 DS    0H
         TM    LGWFLAG2,LGWTABND   Recovery for Storage Watch Abend?
         BRZ   LDAT7200            No  => Branch for Storage Dump Abend
         LLGT  R1,=A(ABNDMSG3)     Indicate Abend on Storage Watch Data
         MVC   0(L'ABNDMSG3,RLINE),0(R1) Abend Event Msg to Detail Line
         LA    RLINE,L'ABNDMSG3(,RLINE) Increment to End of Event Msg
         MVC   0(L'LGWWRK16,RLINE),LGWWRK16 Show Address Tried to Watch
         NI    LGWFLAG2,255-LGWTABND Turn Off Flag for Stor Watch Abend
         BRU   LDAT7300            Branch to Process Abend Notification
LDAT7200 DS    0H
         LLGT  R1,=A(ABNDMSG2)     Indicate Abend on Referencing Data
         MVC   0(L'ABNDMSG2,RLINE),0(R1) Abend Event Msg to Detail Line
         LA    RLINE,L'ABNDMSG2(,RLINE) Increment to End of Event Msg
         MVC   0(L'LGWWRK16,RLINE),LGWWRK16 Show Adr Tried to Reference
LDAT7300 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
         LMG   R14,R1,LGWWORKD     Save the Current Working Registers
*
*+-------------------------------------------------------------------+*
*| Determine If Logger Output Records in the Work Area Buffer Are To |*
*| Be Printed Immediately to the //LGRECOUT Output Data Set, Or To Be|*
*| Moved from the Temporary Work Buffer to a Larger Accumulation     |*
*| Buffer Area Which Will Defer the Printing of Logger Output Records|*
*| to the //LGRECOUT DD Until the End Of User Program Processing.    |*
*+-------------------------------------------------------------------+*
*
LDAT8000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   LDATEXIT            No  => Branch to Exit This Routine
         STMG  R14,R1,LGWWORKD     Save the Current Working Registers
         LMG   R3,R4,LGWWORK2      Restore Current Position in Rcd Area
         TM    LCAWFLAG,LCAWBUFR   Defer Prnt and Write to Buffer Area?
         BRO   LDAT8100            Yes => Use Buffers Above-the-Line
         TM    LCAWFLAG,LCAWBU64   Defer Prnt and Write to Buffer Area?
         BRO   LDAT8200            Yes => Use Buffers Above-the-Bar
         BRAS  RLINK1,LWRT0000     No  => Print Log Recds To Output Now
         BRU   LDAT8600            Chck If More Entries to SHOW=/WATCH=
LDAT8100 DS    0H
         LLGT  R15,=A(LGXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   LDAT8300            Branch to Process Records to Buffers
LDAT8200 DS    0H
         LLGT  R15,=A(LGXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
LDAT8300 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  (15),               Process Log Records to Table Buffer X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R4)),              ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Write Log Recrds to Buffer
         LTGFR R15,R15             Was Write Buffer Request Successful?
         BRZ   LDAT8400            Yes => Branch to Process Request
         LGHI  R5,((LDAT8500-LDAT8400)-4) ...Length of Branch Table
         CGR   R15,R5              Ret Code in R15 Exceed Table Length?
         BRL   LDAT8400            No  => Process Return to Buffer Rcds
         BRU   LDATEXIT            Branch to Exit This Routine
LDAT8400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LDAT8600            Process Log Records for Next in List
         BRU   LDAT8600            Process On Buffer Warning
         BRU   LDAT8500            Process for Validation Error
         BRU   LDAT8500            Process for Severe Error - Set Flag
LDAT8500 DS    0H
         OI    LGWFLAG2,LGWSTEXH   Storage Exhausted or Block Overrun
         BRU   LDATEXIT            Indicate for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  A storage area specified in a Logpoint has now completed and is  |*
*|  done. However, multiple storage areas may have been specified by |*
*|  the user in a single 'SHOW=' or a single 'WATCH=' logpoint. At   |*
*|  this point check if more that one storage entry parameter was    |*
*|  specified in a single 'SHOW=' or 'WATCH='. If more than one      |*
*|  storage entry parameter was listed when the 'SHOW=' or 'WATCH='  |*
*|  was used, then loop to process the dump of the "next" storage    |*
*|  area in the concatenated list of storage areas to be displayed.  |*
*|                                                                   |*
*|  For example:                                                     |*
*|                                                                   |*
*|LABL3500 #LGPOINT SHOW=(('SMFCOUNT',SMFCOUNT,L'SMFCOUNT), Done This|*
*|            ('SMF$SAVE',SMF$SAVE,L'SMF$SAVE),      <===Next in List|*
*|            ('SMFINDEX',SMFINDEX,L'SMFINDEX))      <===Next in List|*
*+-------------------------------------------------------------------+*
*
LDAT8600 DS    0H
         LMG   R14,R1,LGWWORKD     Restore Current Working Registers
         LLGC  R1,LGRDHDRL         Obtain the Length of the Header
         LA    R1,LGRDHDR-LGRSHOW(,R1) Get Length of SHOW=/WATCH= Entry
         TMLL  R1,(X'0001')        Length of SHOW/WATCH an Even Number?
         BRZ   LDAT8700            Yes => Then Check If Another Entry
         LA    R1,1(,R1)           No  => Entry is Aligned on Halfword
LDAT8700 DS    0H
         SGR   R2,R1               Decrement for This Entry
         LA    R15,0(R1,R15)       Increment to the Next Area to Print
         LTGR  R2,R2               Are There Any More Entries?
         BRH   LDAT8800            Yes => Branch to Process Next Entry
         BRU   LDATEXIT            No  => Branch to Exit This Routine
LDAT8800 DS    0H
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
         SLGR  R4,R4               Clear for Use as a Line Counter
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         STMG  R3,R4,LGWWORK2      Save Current Position in Record Area
*
*+-------------------------------------------------------------------+*
*| Loop Point To Process The Next Storage List Entry in SHOW=/WATCH= |*
*+-------------------------------------------------------------------+*
*
LDAT8900 DS    0H
         BRU   LDAT1000            Loop to Process the Next List Entry
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LDATEXIT DS    0H
         LG    RLINK1,LGWRLNK3     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
         POP   USING               Restore Previous Environment Status
*
***********************************************************************
*              End of Logger Log Point Data Processing                *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L W R T 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|         P e r f o r m   W r i t e   O f   L o g   D a t a         |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: LWRT0000                                           *
*                                                                     *
* FUNCTION:        Log Record Write To Output Data Set                *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  write of logger records to an output data set.     *
*                  We are here because the user has taken the default *
*                  or specified the default LOGOUT=PRNT in LPGMNTRY   *
*                  indicating that log records are to be be printed to*
*                  the output data set //LGRECOUT at the time they are*
*                  generated by this LGMHLRCE program.                *
*                                                                     *
* For Example:                                                        *
*                                                                     *
* USRTEST1 LPGMNTRY TYPE=MAIN,       Define IICF Main Program Entry   *
*              AMOD=31,RMOD=31,      Define Addessing and Residence   *
*              STORAGE=64,           Define LCA Stacked Storage Size  *
*              BASE=(12,11),         Establish Base Registers         *
*              LCAPFX=SVN,           LCA Prefix for This CSECT        *
*        ===>  LOGOUT=PRNT,          Write Logger Records to Output   *
*              MSG='Test User Program 1'                              *
*                                                                     *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Main Control Program                    *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                                                                     *
***********************************************************************
*
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
LWRT0000 DS    0H
         STG   RLINK1,LGWRLNK4     Save Our Linkage Register Address
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R13)        Point to the Log Record Area
LWRT1000 DS    0H
         LLGT  R1,=A(SPACES)       Point to Area Containing Blanks
         CLC   LNE.LGWLINE(L'SPACES),0(R1) Current Record a Blank Line?
         BRE   LWRT4100            Yes => Branch to Print Log Record
         TM    LCAWFLAG,LCAWTRIM   Request to Trim Logger Output Rcrds?
         BRO   LWRT4100            Yes => Branch to Print Log Record
         TM    LGWFLAG,LGWSCVTM    Request from Retry to Trim on Abend?
         BRO   LWRT4100            Yes => Branch to Print Log Record
*
*+-------------------------------------------------------------------+*
*|  Get Binary CPU Clock Time And Convert To A Julian Date And Time  |*
*+-------------------------------------------------------------------+*
*| The CPU clock time is in STCKE format. Previously the CPU clock   |*
*| time and TCB address of the executing task were acquired when the |*
*| logger service was entered in order to place a date and time      |*
*| stamp at the time the log event occurred. The CPU clock time and  |*
*| TCB address were placed in the prefix area of the user program's  |*
*| LCA. Then the STCKE TOD and TCB address were extracted from the   |*
*| LCA and placed in Logger Control Block LGRWK2II. For each input   |*
*| logger record we are converting the binary clock time into a      |*
*| displayable format that will show up in the logger output record  |*
*| written to the output data set.                                   |*
*|                                                                   |*
*| For the time stamp the 128-bit TOD Store Clock Extended (STCKE)   |*
*| was used to provide a date beyond the year 2042. The existing     |*
*| 64-bit TOD clock from STCK will wrap in the year 2042 (i.e.,      |*
*| approximately 09/17/2042 @ 23:53:52.613376 - GMT). The additional |*
*| bits added by the STCKE format TOD time-stamp will provide support|*
*| beyond the wrap date. Therefore, this routine will support dates  |*
*| beyond the year 2042 and beyond the year 2100.                    |*
*|                                                                   |*
*| The first part of this routine takes the STCKE Format 16-Byte     |*
*| (128-Bit) TOD value, and extracts the high-order 72-bit portion   |*
*| of the TOD into a R0/R1 even-odd grande register pair.  Then the  |*
*| 72-bit TOD will be adjusted through the z/OS CVT (Communications  |*
*| Vector Table) for Leap Seconds and for the Local Time based on    |*
*| the CLOCKxx member of Parmlib, which member contains information  |*
*| for controlling z/OS time management (i.e., Sysplex Timer,        |*
*| Time Zones).                                                      |*
*+-------------------------------------------------------------------+*
*
LWRT1100 DS    0H
         UNPK  LGW$TCB@(L'LGW$TCB@+1),LGWTCBAD(L'LGWTCBAD+1) ..TCB Addr
         TR    LGW$TCB@,HEXCONV-C'0' ...Translate Hex to Character
         MVI   LGW$SEP1,C' '       Insert Blank as a Field Separator
         LMG   R0,R1,LGWTSTCK      Extended CPU Clock Time of Log Event
         RLLG  R0,R0,8 Bits        Position the TOD +142yr Byte to Last
         SRDL  R0,8                Save TOD Byte to R1, Open Slot in R0
         RLLG  R1,R1,32 Bits       TOD 63-71 Bits to Bit Position 32
         SLDL  R0,8                TOD Bits 8-71 Now in R0 as 64-Bits
         SRLG  R1,R1,56 Bits       +142 Yr Byte to Build 0-71 Bit TOD
         XGR   R0,R1               Exchange Contents of TOD Registers
         XGR   R1,R0               R0 and R1 to Produce a STCKE 72-Bit
         XGR   R0,R1               Format TOD in Even/Odd Register Pair
LWRT1200 DS    0H
         LLGT  R15,CVTPTR          Absolute Address of Pointer to CVT
         L     R15,CVTEXT2-CVT(,R15) ..Get Address of CVT 2nd Extention
         USING CVTXTNT2,R15        Set Addressability to CVT Extention
         SL    R1,CVTLSOL          Adjust the Low Word for Leap Seconds
         BRC   NOBORROW,LWRT1300   Then Branch If There is No Borrow
         LLIHL R14,1               Otherwise, Set to Indicate a Borrow
         SLGR  R1,R14              And Then Subtract for CVT High Word
         BRC   NOBORROW,LWRT1300   Then Branch If There is No Borrow
         SLGF  R0,=A(1)            Othewise, Then Borrow From High Word
LWRT1300 DS    0H
         LMD   R14,R14,CVTLSOH,TOD$ZTOK  Get CVT Hi Word Offset for TOD
         SLGR  R1,R14              Adjust CVT High Wrd for Leap Seconds
         AL    R1,CVTLDTOR         Adjust Low Word For Time Zone Diff
         BRC   NOCARRY,LWRT1400    And Branch If There Is No Carry
         LLIHL R14,1               Otherwise, Set to Indicate a Carry
         ALGR  R1,R14              And Then Add From the CVT High Word
         BRC   NOCARRY,LWRT1400    And Branch If There Is No New Carry
         AL    R0,=A(1)            Propogate Carry to the TOD High Byte
LWRT1400 DS    0H
         LMD   R14,R14,CVTLDTOL,TOD$ZTOK  Get High Word Time Zone Value
         ALGR  R1,R14              Now Adjust for High Word Time Zone
         DROP  R15                 Remove Listed Reg as CVT Ext Base
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Take the CVT Corrected 72-Bit Binary|*
*| Time Stamp, and Convert the Binary Seconds Portion of the TOD Down|*
*| to a Micosecond (1/1,000,000ths of a Second) With the Result      |*
*| Placed in Storage in Packed Decimal Format.                       |*
*+-------------------------------------------------------------------+*
*
LWRT2000 DS    0H
         SRDL  R0,8                Drop Last Byte/Put +142Yr Byte in R1
         RLL   R1,R1,8 Bits        +142Yr Byte at End of Low-Half of R1
         RLLG  R1,R1,56 Bits       Rotate to Get Back to Proper Format
         SRLG  R1,R1,17 Bits       Set Microseconds/2**13 (Since 1900)
         DLG   R0,=AD((60*60*24/128)*(1000000/64)) R1=Days R0=Microsecs
         LGR   R15,R1              Preserve the Calculated Elapsed Days
         SRDL  R0,32 Bits          Shift So R0/R1 = Microseconds/2**13
         SLLG  R1,R1,13 Bits       Shift So R0/R1 = Microseconds/2**1
         LLGF  R14,=A(60*60)       Indicate No. of Seconds in an Hour
         MSGF  R14,=A(1000000)     To Obtain Microseconds in an Hour
         SLGR  R0,R0               Clear for the Division Operation
         DLGR  R0,R14              Calculate Total Number of Hours
         CVD   R1,LGWWORK$+8       Create Decimal Version No. of Hours
         MVO   LGWWORK$+4(2),LGWWORK$+14(2) Get Hrs Without High Nibble
         SRDL  R0,32 bits          Prepare for Division to Get Minutes
         D     R0,=A(60*1000000)   Calculate Total Number of Minutes
         CVD   R1,LGWWORK$+8       Create Decimal Version No. of Mins
         MVO   LGWWORK$+5(2),LGWWORK$+14(2) Get Mins Without Hi Nibble
         SRDA  R0,32 bits          Prepare for Division to Get Seconds
         D     R0,=A(1000000)      Calculate the Total No. of Seconds
         CVD   R1,LGWWORK$+8       Create Decimal Version No. of Secnds
         MVO   LGWWORK$+6(2),LGWWORK$+14(2) Get Secnd Without Hi Nibble
         CVD   R0,LGWWORK$+8       Decimal Version for Microseconds
         SRP   LGWWORK$+12(4),1,0  Shift to Make Last Byte a Slack Byte
         MVC   LGWWORK$+7(4),LGWWORK$+12 ..Get Fractional Seconds Value
         OI    LGWWORK$+10,15      Certify Sign To Make It Displayable
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Process the Binary Date Portion Of  |*
*| the TOD Representing the Days (i.e., Completed days + Current Day)|*
*| Since the z/OS Epoch (01/01/1900), and Convert The Binary Days to |*
*| a Displayable Julian Date Format (i.e., Ordinal Date).            |*
*+-------------------------------------------------------------------+*
*
LWRT3000 DS    0H
         LGR   R1,R15              Get the Total Number of Elapsed Days
         CLGF  R1,=A(36525+1461+365) Leap Century+4yr Cycle+Non-Leap Yr
         BRNL  LWRT3200            Use Extended Date Processing for TOD
LWRT3100 DS    0H
         ALGF  R1,=A(1)            Calendars Start At Day 1, Not Day 0
         SLLG  R1,R1,2 Bits        Multiply Total Days by Factor of 4
         DSGF  R0,=A(4*365+1)      Divide by the No. of Days in 4 Years
         SRLG  R0,R0,2 Bits        Divide By 4 So Now R1=Year R0=Days
         ALGF  R0,=A(1)            Add 1 Since First Day Starts at 1
         LA    R15,1900(,R1)       Epoch + No. of Years into Century
         MGHI  R15,(1000)          Shift The Years to Align with Days
         ALGFR R15,R0              Add to Merge the Years and the Date
         CVD   R15,LGWWORK$+16     Create Decimal Version of the Date
         MVC   LGWWORK$(4),LGWWORK$+20 ...Save The Packed Julian Date
         OI    LGWWORK$+3,15       Certify Sign To Make It Displayable
         BRU   LWRT4000            Process TOD to a Character Format
LWRT3200 DS    0H
         ALGF  R1,=A(36524)        Add the Number of Days in a Century
         SLLG  R1,R1,2 Bits        Multiply Total Days by a Factor of 4
         DSGF  R0,=A(146097)       Days + Leap Century/Days in 400 Yrs
         BCTGR R1,R0               Equalize for the Leap Century Added
         LLGFR R14,R1              Save Elapsed Centuries Since 1900
         LLGFR R1,R0               Get No. of Days into Current Century
         DSGF  R0,=A(1461*4)       Divide by No. of Days in Leap Year
         LLGFR R15,R1              Save No. of Completed 4-Year Cycles
         LLGFR R1,R0               No. of Completed Days in 4-Yr Period
         DSGF  R0,=A(4)            Divide by 4 so Now R1 Has The Days
         DSGF  R0,=A(365)          Determine No. of Yrs into 4-Yr Cycle
         LTGR  R1,R1               Is this Year Currently a Leap Year?
         BRNZ  LWRT3300            No  => Then Set Calendar Start Day
         LLGFR R5,R14              Get the Elapsed Centuries Since 1900
         BCTGR R5,R0               Set the Century Code to Yr 2000 Base
         TMLL  R5,X'0003'          This a Leap Century (400 Year Rule)?
         BRNZ  LWRT3300            No  => Then Set Calendar Start Day
         ALGF  R0,=A(1)            Add a Day to Account for a Leap Year
LWRT3300 DS    0H
         ALGF  R0,=A(1)            Calendar Starts at Day 1, Not Day 0
         SLLG  R15,R15,2 Bits      Completed 4-Yr Cycles x 4 = Years
         ALGFR R1,R15              Add Years into Current 4-Year Cycle
         MGHI  R14,(100)           No. of Years for Completed Centuries
         LA    R1,1900(R14,R1)     Epoch + Century Yrs + Yrs in Century
         LLGFR R15,R1              Copy the Years to Setup an Alignment
         MGHI  R15,(1000)          Shift The Years to Align with Days
         ALGFR R15,R0              Add to Merge the Years and the Days
         CVD   R15,LGWWORK$+16     Create Decimal Version of the Date
         MVC   LGWWORK$(4),LGWWORK$+20 ...Save The Packed Julian Date
         OI    LGWWORK$+3,15       Certify Sign To Make It Displayable
*
*+-------------------------------------------------------------------+*
*| Place The TCB Address and Date/Time Stamp At The End Of The Log   |*
*| Record And Write The Log Record To The //LGRECOUT Output Data Set.|*
*|                                                                   |*
*|   Example:                                                        |*
*|              008DCB08 2011092-22:08:54.247288                     |*
*|                 |        |     |  |  |   |                        |*
*|                TCB    Ordinal Hrs | Sec  |                        |*
*|               Address  Date      Min     |                        |*
*|                                    To 1/1,000,000ths              |*
*|                                      of a Second                  |*
*+-------------------------------------------------------------------+*
*
LWRT4000 DS    0H
         UNPK  LGWJULDT(7),LGWWORK$(4) Julian Date to Character Format
         UNPK  LGWWORK$+20(13),LGWWORK$+4(7) ..TOD to Character Format
         MVC   LGWJULTM(12),LGWWORK$+20 ...Time of Day to Output Area
         MVI   LGW$SEP2,C'-'       Insert Date/Time Separator Character
         MVC   LGWDHOUR,LGWJULHH   Obtain Current Hour of the Day
         MVI   LGW$SEP3,C':'       Colon as Hour/Minute Separator
         MVC   LGWDMINS,LGWJULMM   Obtain Current Minute of the Hour
         MVI   LGW$SEP4,C':'       Colon as Minute/Seconds Separator
         MVC   LGWDSECD,LGWJULSS   Obtain Current Seconds of the Min
         MVI   LGW$SEP5,C'.'       Period as Fractional Scnds Separator
         MVC   LGWDSTTH,LGWJULTT   Set to '1/1,000,000ths' of a Second
         MVC   LNE.LGWLINE+L'LNE.LGWLINE-LGWDMPLN(LGWDMPLN),LGW$TCB@
LWRT4100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   LWRTEXIT            No  => Branch to Exit This Routine
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,LNE.LGWLINE Print Log Record From Data Table
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|   Loop Point for Each Log Record in Temporary Work Buffer Area    |*
*+-------------------------------------------------------------------+*
*
LWRT5000 DS    0H
         LA    R3,L'LGWLINE(,R3)   Move to Next Log Entry in List
         BRCTG R4,LWRT1000         Loop to Process Next Log Recrd Entry
         SLGR  R15,R15             Clear the Condition Code Indicator
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LWRTEXIT DS    0H
         LG    RLINK1,LGWRLNK4     Restore Our Linkage Register Address
         BR    RLINK1              Return to Caller
         DROP  LNE                 Remove Listed Reg as Record Base Reg
*
***********************************************************************
*             End of Log Record Write To Output Data Set              *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
MAXINDNT EQU   5                   Set the Maximum Indention Level
*
HEXCONV  DC    C'0123456789ABCDEF' Translate Table for Hex to Character
         DC    H'0'                Ensure Halfword Boundary Alignment
SWTCHMOD DC    X'0100'             Define Instruction to Switch Amodes
TOD$ZTOK DC    D'0'                CVT TOD High Word Offset Zero Token
NOCARRY  EQU   8+4                 Condition Code for No Carry
NOBORROW EQU   2+1                 Condition Code for No Borrow
         DC    0D                  Set for DoubleWord Alignment
         LTORG ,                   Define the Literal Origin Pool
*
LGR#L827 RSECT                     Establish Control Section
LGR#L827 AMODE &AMODE              Establish Addressing Mode
LGR#L827 RMODE &RMODE              Establish Residence Mode
*
ABNDMSG1 DC    CL60'???> An Abend Occurred Referencing Variable Data atX
                Address '
ABNDMSG2 DC    CL59'???> An Abend Occurred Referencing Storage Data at X
               Address '
ABNDMSG3 DC    CL59'???> An Abend Occurred Referencing Watched Data at X
               Address '
PGMATTBX DC    CL38'Pgm)==>Program Attributes: LMod Start='
PGMENT88 DC    CL28'Pgm)==>Program Entry is To: '     ...Message Header
PGMENT89 DC    CL28'Pgm)==>Program Entered From:'     ...Message Header
PGMENT91 DC    CL28'Pgm)==>Program Entry Status:'     ...Message Header
PGMXIT93 DC    CL28'Pgm)<==Program Exit Status:'      ...Message Header
PGMXIT77 DC    CL27'Pgm)<==Program Exited From:'      ...Message Header
PGMXIT79 DC    CL27'Pgm)<==Program Exited To:'        ...Message Header
SUBEXT49 DC    CL19'<==Subroutine Exit:'              ...Message Header
LODENT44 DC    CL17'LMod Entry Point='                ...Message Header
LGRPT271 DC    CL31'*Error Processing Private Area*'  ...Message Header
LGRPT369 DC    CL31'Private Area Storage Allocated:'  ...Message Header
LGRPT473 DC    CL15'==>Watch Point:'                  ...Message Header
LGRPT475 DC    CL15'==>Log Point**:'                  ...Message Header
TSUBR851 DC    CL14'==>Subroutine:'                   ...Message Header
LUNKNOWN DC    CL20'Unknown'                          ...Message Header
INPTPRMH DC    CL26'Input Parameters Passed To'       ...Message Header
DFLAREGS DC    CL17'Access Registers:'                ...Message Header
DFLTREGS DC    CL26'General Purpose Registers:'       ...Message Header
PGMEREGS DC    CL35'General Purpose Registers On Entry:' Message Header
PGMXREGS DC    CL34'General Purpose Registers On Exit:'  Message Header
SUBEREGS DC    CL46'General Purpose Registers On Subroutine Entry:' Hdr
SUBXREGS DC    CL45'General Purpose Registers On Subroutine Exit:'  Hdr
LOGPREGS DC    CL39'General Purpose Registers At Log Point:'
LOGWREGS DC    CL41'General Purpose Registers At Watch Point:'
         DC    0D                  Set for DoubleWord Alignment
LGRTIMER STIMERM SET,MF=L          List Form for Remote Parameter List
LGRTIMRL EQU   *-LGRTIMER          Length of STIMERM Parameter List
PATTERN  DC    XL20'402020206B2020206B2020206B2020206B202120' ..Editing
SPACES   DC    CL80' '             Define Character String of Blanks
LGXALRCB DC    V(LGMHLRCB)         Vcon for Log Services Buffer Program
LGXALB64 DC    V(LGMHLB64)         Vcon for Log Services Buffer Program
*
         DC    0D                  Set for DoubleWord Alignment (DUMP)
EBCDIC   DS    0CL256              Area for Character Translation Table
         DC    256CL1'.'           All Characters Set to Period (DUMP)
         ORG   EBCDIC+C','         Reset Counter for Print Translation
         DC    C','                Set Storage Dump to Display Comma
         ORG   EBCDIC+C'.'         Reset Counter for Print Translation
         DC    C'.'                Set Storage Dump to Display Period
         ORG   EBCDIC+C' '         Reset Counter for Print Translation
         DC    C' '                Set Storage Dump to Display Blanks
         ORG   EBCDIC+C'>'         Reset Counter for Print Translation
         DC    C'>'                Set Stor Dump to Display Right Arrow
         ORG   EBCDIC+C'<'         Reset Counter for Print Translation
         DC    C'<'                Set Stor Dump to Display Left Arrow
         ORG   EBCDIC+C':'         Reset Counter for Print Translation
         DC    C':'                Set Storage Dump to Display Colon
         ORG   EBCDIC+C'%'         Reset Counter for Print Translation
         DC    C'%'                Set Stor Dmp to Display Percent Sign
         ORG   EBCDIC+C'_'         Reset Counter for Print Translation
         DC    C'_'                Set Stor Dump to Display Underscore
         ORG   EBCDIC+C'?'         Reset Counter for Print Translation
         DC    C'?'                Set Stor Dump Display Question Mark
         ORG   EBCDIC+C'('         Reset Counter for Print Translation
         DC    C'(+|'              Left Parand,Plus Sign,Vertical Bar
         ORG   EBCDIC+C'&&'        Reset Counter for Print Translation
         DC    C'&&'               Set Stor Dump to Display Ampersand
         ORG   EBCDIC+C'!'         Reset Counter for Print Translation
         DC    C'!'                Set Dump Display Exclamation Point
         ORG   EBCDIC+C'$'         Reset Counter for Print Translation
         DC    C'$*)'              Dollar Sign, Asterisk & Right Parand
         ORG   EBCDIC+C'-'         Reset Counter for Print Translation
         DC    C'-/'               Display Hyphen and Forward Slash
         ORG   EBCDIC+C'#'         Reset Counter for Print Translation
         DC    C'#@''='            # Sign, @ Sign, Apostrophe & Equal
         ORG   EBCDIC+C'a'         Reset Counter for Print Translation
         DC    C'abcdefghi'        Set Dump to Display Lower Case a - i
         ORG   EBCDIC+C'j'         Reset Counter for Print Translation
         DC    C'jklmnopqr'        Set Dump to Display Lower Case j - r
         ORG   EBCDIC+C's'         Reset Counter for Print Translation
         DC    C'stuvwxyz'         Set Dump to Display Lower Case s - z
         ORG   EBCDIC+C'A'         Reset Counter for Print Translation
         DC    C'ABCDEFGHI'        Set Dump to Display Upper Case A - I
         ORG   EBCDIC+C'J'         Reset Counter for Print Translation
         DC    C'JKLMNOPQR'        Set Dump to Display Upper Case J - R
         ORG   EBCDIC+C'S'         Reset Counter for Print Translation
         DC    C'STUVWXYZ'         Set Dump to Display Upper Case S - Z
         ORG   EBCDIC+C'0'         Reset Counter for Print Translation
         DC    C'0123456789'       Set Dump to Display Numerics 0 - 9
         ORG   ,                   Reset Location Counter to End of Tbl
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|                    L o g   P o i n t   A r e a                    |*
*+-------------------------------------------------------------------+*
*
LGRPT2II DSECT ,                   Define the Log Point Area
LGRTYPE  DS    CL4                 Define the Type of Program Log
LGREXOFF DS    AL4                 Program Exit Offset
LGRREGS  DS    BL2                 Indicated Registers to Print: 0-15
LGRPFLAG DS    BL1                 Flag Byte for Log Point Parameters
LGRPMSG  EQU   X'80'               ..MSG= Parameter Was Specified
LGRPSHOW EQU   X'40'               ..SHOW= Parameter Was Specified
LGRPCMPR EQU   X'20'               ..COMPRESS=YES Parameter Specified
LGRPSHDR EQU   X'10'               ..SUPHEAD=YES Parameter Specified
LGRPPARM EQU   X'08'               ..PARMS= Parameter Was Specified
LGRWATCH EQU   X'04'               ..WATCH= Parameter Was Specifed
LGRPRIVT EQU   X'02'               ..PVTAREA= Parameter Was Specified
LGRPTRIM EQU   X'01'               ..LOGTRIM= Parameter Was Specified
LGRNAMEL DS    AL1                 Length of the Program Log Point Name
LGRNAME  DS    0C                  Start of the Program Log Point Name
LGRMSGL  DS    YL2                 Length of the Log Message Area
LGRMSG   DS    0C                  Log Message Data Area
LGRSHOWL DS    HL2                 Length of the SHOW=/WATCH= Segment
LGRSHOW  DS    0X                  Beginning of SHOW=/WATCH= Segment
LGR$ADDR DS    XL6                 Address of the Data To Print
LGRDLNTH DS    YL2                 Length of the Data To Print
LGRDFLAG DS    BL1                 Data Processing Flag Byte
LGRDRD31 EQU   X'80'               ..31-Bit Redirection
LGRDRD24 EQU   X'40'               ..24-Bit Redirection
LGRDLREG EQU   X'20'               ..Length Value Is In a Register
LGRDHDRL DS    YL1                 Length of Heading or Zero
LGRDHDR  DS    0C                  Start of the Log Point Heading
LGRLNGTH EQU   *-LGRPT2II          Length of Log Point Dsect Area
*
*+-------------------------------------------------------------------+*
*|  L o g g i n g   V a r i a b l e s   M S G =   P a r m   A r e a  |*
*+-------------------------------------------------------------------+*
*
VARS@TRC DSECT ,                   Define Embedded Variable for Message
VARID    DS    X                   X'FE' Byte Defines Embedded Variable
VARTYPE  DS    C                   Indicator for Type of Variable Data
VARTYP@C EQU   C'C'                ..Character Constant
VARTYP@Z EQU   C'Z'                ..Numeric Constant - Character
VARTYP@F EQU   C'F'                ..Numeric Constant - Binary
VARTYP@H EQU   C'H'                ..Numeric Constant - Binary
VARTYP@P EQU   C'P'                ..Numeric Constant - Packed
VARADDR  DS    XL6                 Address of the Variable Data
VARLNTH  DS    YL2                 Length of the Variable Data
VARLNGTH EQU   *-VARS@TRC          Length of Variable Area DSECT Entry
         EJECT ,
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*+-------------------------------------------------------------------+*
*|        L o g g e r   C o n t r o l   A r e a   -   (LCA )         |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
PSALRCE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
*+-------------------------------------------------------------------+*
*|              z / O S   S y s t e m   D s e c t s                  |*
*+-------------------------------------------------------------------+*
*
         PRINT  NOGEN
         CVT    DSECT=YES,LIST=YES Communications Vector Table
         DCBD   DSORG=PS,DEVD=DA   Data Control Block
         IHAPSA LIST=YES           Prefix Storage Area
         IKJTCB LIST=YES           Job Task Control Block
         IHADFA ,                  Data Facilities Area
         IHASDWA ,                 System Diagnostic Work Area Recovery
         IHALLE ,                  Load List Element
         IHACDE ,                  Contents Directory Entry (JPAQ)
         IHAXTLST ,                Extent List for CDE/LPDE Modules
         END
