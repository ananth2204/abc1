***********************************************************************
*LLL      GGGGGGG M     M H     H PPPPPPP   SSSSSS  TTTTTTTTT GGGGGGG *
* L       G     G MM   MM H     H P      P S      S T   T   T G     G *
* L       G       M M M M H     H P      P S            T     G       *
* L       G  GGGG M  M  M HHHHHHH PPPPPPP   SSSSSS      T     G GGGGG *
* L       G     G M     M H     H P               S     T     G     G *
* L       G     G M     M H     H P        S      S     T     G     G *
* LLLLLLL GGGGGGG M     M H     H P         SSSSSS      T     GGGGGGG *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHPSTG                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Private Area Storage Analysis Pgm  *
*                                                                     *
* INPUT REGS:      R1  => Standard z/OS Parameter List                *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to LGRWK2II Logger Work Area        *
*                         (Mapped by LGCPLSWA CopyBook)               *
*                  Parm2: Pointer to Current Line Position in Output  *
*                         Buffer                                      *
*                  Parm3: Current Line Count in Output Buffer         *
*                  Parm4: Pointer to Current Indentation Level Value  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return Address                                *
*                  R13, Save Area & Dynamic Area                      *
*                  R12, (RBASE1) Program Base Register                *
*                  R11, (RCOMM1) Common Dynamic Area                  *
*                  R10, (RCOMM2) Common Constants/Routines            *
*                  R0-R9, General Work Registers                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE - Logger Services Event Publishing Program*
*                  LGMHRTRY - Logger Services Diagnostic ESTAEX Retry *
*                             Program                                 *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Serious Error                                 *
*                  12 - Severe Error                                  *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Update   V1R1M17 20120721 Update VV.RR.MM stats for Fix Pack 17@@KHF*
* Update   V1R1M16 20120127 Update VV.RR.MM stats for Fix Pack 16@@KHF*
* Update   V1R1M15 20110930 Update VV.RR.MM stats for Fix Pack 15@@KHF*
* Update   V1R1M14 20110423 Update VV.RR.MM stats for Fix Pack 14@@KHF*
* Update   V1R1M13 20110108 Update VV.RR.MM stats for Fix Pack 13@@KHF*
* Update   V1R1M12 20100306 Update VV.RR.MM stats for Fix Pack 12@@KHF*
* Add      V1R1M11 20091023 Display Stats for Common Mem Objects.@@KHF*
*                           Changed Hdrs for Mem Obj Description.@@KHF*
* Update   V1R1M10 20090523 Update VV.RR.MM stats for Fix Pack 10@@KHF*
* Update   V1R1M09 20090110 Updated VV.RR.MM stats for Fix Pack 9@@KHF*
* Add      V1R1M08 20081010 Add Display of Storage Area Subpools @@KHF*
* Update   V1R1M07 20080524 Updated VV.RR.MM stats for Fix Pack 7@@KHF*
* Add      V1R1M06 20080223 Added Job Step CPU/SRB Time Used Info@@KHF*
* Update   V1R1M05 20080112 Updated VV.RR.MM stats for Fix Pack 5@@KHF*
* Fix      V1R1M04 20071104 Garbage Characters in Output Report  @@KHF*
* Update   V1R1M03 20070701 Updated VV.RR.MM stats for Fix Pack 3@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Updated VV.RR.MM stats for Fix Pack 1@@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Address Mode of Program
         LCLC  &RMODE              Resident Mode of Program
&KXHVER  SETC  'V1'                Indicated Program Version Number
&KXHREL  SETC  'R1'                Indicated Program Release Number
&KXHMOD  SETC  'M17'               Indicated Program Modification Lvl
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&CPYRITE SETC  '2008,2012'         Program Copyright Year
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
&MODID   SETC  'LGMHPSTG'          Set the Program Module Identifier
*
R0       EQU   0                   Define Program Register 0 Equate
R1       EQU   1                   Define Program Register 1 Equate
R2       EQU   2                   Define Program Register 2 Equate
R3       EQU   3                   Define Program Register 3 Equate
R4       EQU   4                   Define Program Register 4 Equate
R5       EQU   5                   Define Program Register 5 Equate
R6       EQU   6                   Define Program Register 6 Equate
R7       EQU   7                   Define Program Register 7 Equate
R8       EQU   8                   Define Program Register 8 Equate
R9       EQU   9                   Define Program Register 9 Equate
R10      EQU   10                  Define Program Register 10 Equate
R11      EQU   11                  Define Program Register 11 Equate
R12      EQU   12                  Define Program Register 12 Equate
R13      EQU   13                  Define Program Register 13 Equate
R14      EQU   14                  Define Program Register 14 Equate
R15      EQU   15                  Define Program Register 15 Equate
         EJECT  ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHPSTG - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHPSTG                                           *
*                                                                     *
* FUNCTION:        Check Private Area Storage Utilization             *
*                                                                     *
*                  This routine is the entry point for processing the *
*                  current utilization of the user's private area     *
*                  storage at the time a Log Point with PVTAREA=YES is*
*                  encountered in the user's program. This routine is *
*                  a basic means to show an in-use map of storage in  *
*                  the private area while a user program is executing.*
*                                                                     *
*                  An analysis will be made for storage areas that are*
*                  below-the-line, above-the-line, and above-the-bar. *
*                  In the user's address space, a virtual line marks  *
*                  the 16-Megabyte address. This line separates       *
*                  storage below the 24-bit address, and is referred  *
*                  to as "Below-the-Line. The 31-bit address includes *
*                  the virtual line at the 16-Megabyte address and is *
*                  known as "Above-the-Line". The 64-bit address space*
*                  also includes the virtual line at the 16-megabyte  *
*                  address. It will also include a second virtual line*
*                  called the bar that marks the 2-gigabyte address.  *
*                  The bar separates storage below the 2-gigabyte     *
*                  address, called "Below-the-Bar, from storage above *
*                  the 2-gigabyte address, which is referred to as    *
*                  "Above-the-Bar.                                    *
*                                                                     *
*                  For identifying the below-the-bar storage, the     *
*                  Desciptor Queue Elements are examined. The DQEs    *
*                  describe allocated pages of virtual storage. The   *
*                  z/OS Virtual Storage Manager creates a DQE whenever*
*                  a storage request requires a new 4K page. This     *
*                  means if a user issues a storage request for 4,096 *
*                  bytes (4K), the z/OS Virtual Storage Manager will  *
*                  either cause a new DQE to be created or cause an   *
*                  existing DQE to be changed. If a user generates    *
*                  many storage requests for less than 4K among       *
*                  several Subpools, this may result is numerous areas*
*                  of unused space within each partially used page.   *
*                  For this the z/OS Virtual Storage Manger maintains *
*                  another control block referred to as the Free Queue*
*                  Element (FQE) to describe an area of free space    *
*                  within a storage page described by the DQE. Since  *
*                  the FQE's are used to describe the free space      *
*                  within a virtual storage page, the free space      *
*                  amounts should be fairly limited. However, if a    *
*                  user made a storage request for 8,192 bytes (8K),  *
*                  and then all but the first and last eight bytes    *
*                  were freed, then a free area of up to 8,176 bytes  *
*                  (8192-16) could exist. This routine will also      *
*                  process the FQE's which means adjustments will be  *
*                  made to account for the fragmented free space areas*
*                  which may exist when calculating the total in-use  *
*                  storage amounts.                                   *
*                                                                     *
*                  In the event that a user program is multi-tasking, *
*                  this routine will loop through the TCB chain to    *
*                  process the DQE's and the FQE's for any storage    *
*                  owned by other TCB's. However, no local locks are  *
*                  held to prevent the z/OS dispatcher from scheduling*
*                  any other TCB's in the address space while this    *
*                  routine is running the TCB chain.                  *
*                                                                     *
*                  Next the RSM Address Space Block Extension (RAX)   *
*                  is analyzed for use of any large virtual storage   *
*                  areas. Then this routine will build report lines   *
*                  displaying the current above-the-bar memory        *
*                  configuration for all amounts of 64-bit storage    *
*                  allocations in usable memory objects and           *
*                  unaccessible guard areas. In addition, shared      *
*                  memory object counts, shared memory allocations,   *
*                  commom memory object counts, common memory         *
*                  allocations, and large page counts will be         *
*                  reported for 1MB pages.                            *
*                                                                     *
*                  Next, the LVSM0000 routine is called which will    *
*                  invoke VSMLIST. The VSMLIST routine will return    *
*                  allocated storage information blocks for Subpools  *
*                  and free space information blocks for Subpools.    *
*                  The information returned by VSMLIST is then        *
*                  analyzed by the LVSM000 program. From this analysis*
*                  a detailed Subpool summary report will be created  *
*                  to display how all of the allocated and free space *
*                  storage areas in the private area below-the-bar    *
*                  are distributed among the various subpools.        *
*                                                                     *
*                  Next the CPU time used is calculated, and a        *
*                  formatted output line is displayed showing         *
*                  the job step CPU time and job step SRB time which  *
*                  has been used at the point where the PVTAREA=YES   *
*                  was encountered in the user's program.             *
*                                                                     *
*                  Report lines used to display the user's storage    *
*                  configuration information are written to a message *
*                  buffer area in the LGRWK2II work area passed by    *
*                  calling programs LGMHLRCE or LGMHRTRY. Upon exit   *
*                  from this program, calling program LGMHLRCE or     *
*                  LGMHRTRY will print the storage display report     *
*                  lines which were created in the buffer area by this*
*                  LGMHPSTG program.                                  *
*                                                                     *
* For example:                                                        *
*                                                                     *
*Private Area Storage Allocated:                                      *
*  <16M: In Use=620K     Unused=8571K     Limit=9192K     HighU=620K  *
*  >16M: In Use=347942K  Unused=1352921K  Limit=1700864K  HighU=347942*
*  >BAR: Allocated=10 Gigabytes            Guard Amount=6,240 Megabyte*
*  >BAR: Pvt Used =4,000 Megabytes         Pvt Hi-Water=4,000 Megabyte*
*  >BAR: Pvt Obj  =1                       Shr Objects =0             *
*  >BAR: Shr Alloc=0 Megabytes             Shr Hi-Water=0 Megabytes   *
*  >BAR: Com Alloc=0 Megabytes             Com Hi-Water=0 Megabytes   *
*  >BAR: Com Obj  =0                       Large Pages =0             *
*Private Area Subpools Allocated: Owned by Task - Acquired by GETMAIN/*
* SP-Key  Allocated   Free Space  Allocated   Free Space    Allocated *
*         Areas-DQE   Areas-FQE   Below 16M   Below 16M   Above 16M Li*
* 003-8   3,968       1           475,136     2,872       352,239,616 *
* 004-8   500         500         0           0           2,048,000   *
* 005-8   500         500         0           0           2,048,000   *
* 229-5   2           2           0           0           12,288      *
* 230-0   1           1           4,096       760         0           *
* 230-5   3           7           8,192       7,232       4,096       *
* 230-8   1           1           0           0           4,096       *
* 251-8   2           2           0           0           200,704     *
*         ----------  ----------  ----------  ----------  ------------*
* Totals  4,977       1,014       487,424     10,864      356,556,800 *
*Job Step CPU: 0HR 2MIN 24.68882SEC  Job Step SRB: 0HR 0MIN 0.18772SEC*
*                                                                     *
*                                                                     *
* INPUT REGS:      R1  => Standard O/S Parameter List                 *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLED PROGRAMS: LVSM0000 - Process Storage Information for Subpools*
*                             in Private Area                         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error                                  *
*                                                                     *
***********************************************************************
*
&MODID   RSECT *                   Main Pgm Read-Only Control Section
&MODID   AMODE &AMODE              Program Addressing Mode -  &AMODE
&MODID   RMODE &RMODE              Program Residence Mode - &RMODE
         SYSSTATE AMODE64=YES,ARCHLVL=2 ...Establish 64-Bit Environment
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
KXHA00S2 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         B     DUMMYPNT            Branch Past the Literal Area
         DC    C'&MODID'           Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
       SPLEVEL SET=6               Set for OS/390 R2 or Above (z/OS+)
         DC    50S(*)              Define a Program Patch Area
DUMMYPNT DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING &MODID+(KXHA00S2-LGMHPSTG),RBASE1  Program Base Register
         LGR   R2,R13              Preserve Caller's Save Area Address
         LLGF  R14,=A(LGW$AREA-LGRWK2II) Index to Logger Service Area
         LG    R3,0(R1)            Get Starting Addr to LGRWK2II Area
         LA    R3,0(R14,R3)        Point to Wrk Area within Logger Area
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
*
*+-------------------------------------------------------------------+*
*| Establish Addressability to a Working Storage Area Within The     |*
*| LGRWK2II Area and Get The Input Parameters                        |*
*+-------------------------------------------------------------------+*
*
LSTG0100 DS    0H
         USING STG@PCA,RCOMM1      Common Dynamic Area Addressability
         USING COM#P3M6,RCOMM2     Constants&Routines Addressability
         LGR   RCOMM1,R3           Establish Common Work Area Address
         LLGT  RCOMM2,=A(COM#P3M6) Constants and Routines Area Address
         LG    R1,LCAF64R01-LCASAVE(,R2) Restore Parameter List Address
         LMG   R0,R3,0(R1)         Get the Input Parameters
         STMG  R0,R3,STGLG2II      Save the Input Parameters
         MVC   STG@EYEC,=CL32'LGMHPSTG COMMON AREA' .Set LCA Eyecatcher
         XC    STGRETCD,STGRETCD   Initialize Return Code to Zeroes
         BRU   LSTG0200            Branch to Process Storage Analysis
*
*+-------------------------------------------------------------------+*
*|  Begin Setup of Private Area Storage Analysis for User's Program  |*
*+-------------------------------------------------------------------+*
*
LSTG0200 DS    0H
         LG    R3,STGLG2II         Get Starting Address to Logger Area
         USING LGRWK2II,R3         Establish Addressability to Log Area
         LMG   R0,R1,STGOPOSI      Line Position and Count in Buffer
         STMG  R0,R1,LGWOPOSI      Save Line Position and Count in Buff
         XC    LGWMSXCT,LGWMSXCT   Clear Message Build Area Line Count
         LA    R1,LSTG7800         Get Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         DROP  R3                  Remove Listed Reg as Log Area Base
         LLGF  R14,=A(LGW$SPVT-LGRWK2II) Index to the Private Area List
         LG    R3,STGLG2II         Get Starting Address to Logger Area
         LA    R8,0(R14,R3)        Point to Private Storage List Area
         USING STGPRVT@,R8         Establish Addressability to List
LSTG0300 DS    0H
         LLGT  R1,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pntr
         LLGT  R1,ASCBLDA-ASCB(,R1) Get VSM Local Data Area Control Blk
         LLGF  R15,LDALIMIT-LDA(,R1) Get Below-the-Line User Area Limit
         STG   R15,STGLIM24        Save the Below-the-Line Max Allowed
         LLGF  R15,LDAELIM-LDA(,R1) Get Above-the-Line User Area Limit
         STG   R15,STGLIM31        Save the Above-the-Line Max Allowed
         XC    STGTCBFQ,STGTCBFQ   Clear TCB Subtask Hierarchy Queue
         XC    STGFRE24,STGFRE24   Accumulator for Free Space <16Meg
         XC    STGFRE31,STGFRE31   Accumulator for Free Spave >16Meg
         SLGR  R0,R0               Accumulator for Storage Alloc <16Meg
         SLGR  R1,R1               Accumulator for Storage Alloc >16Meg
         LLGT  R2,PSATOLD-PSA(,R0) Get Addr of Current Task Cntl Block
         CLGF  R2,TCBJSTCB-TCB(,R2) ...This Task Current Job Step Task?
         BRE   LSTG0400            Yes => Branch to Process Pvt Area
         LLGT  R2,TCBJSTCB-TCB(,R2) ..Get the Address for Job Step TCB
         BRU   LSTG0400            Branch to Process User Private Area
*
*+-------------------------------------------------------------------+*
*| Process for Allocated Pages in User's Private Area                |*
*+-------------------------------------------------------------------+*
*| Each Sub-Pool Queue Element (SPQE) will describe a single         |*
*| Subpool/Storage Key for the storage owned by that TCB. The SPQE's |*
*| examined will be for Subpools 0-127, 229, 230, 249, 251, and 252. |*
*| SPQE's are chained togther in a singly linked list. Each SPQE     |*
*| points to a Sub-Pool Queue Anchor (SPQA). The SPQA is the address |*
*| holder for a set of three Descriptor Queue Element (DQE) chains.  |*
*| One is a chain for storage with both virtual and real below,      |*
*| another is a chain for storage with virtual below but real        |*
*| anywhere, and another a chain for virtual above and real anywhere.|*
*| The DQE's then describe allocated 4K pages of virtual storage     |*
*| where the DQE contains information on the size and the starting   |*
*| address of the the storage area.                                  |*
*+-------------------------------------------------------------------+*
*
LSTG0400 DS    0H
         LLGT  R3,TCBMSS-TCB(,R2)  Problem State, SP 0-127, 251, 252
         STG   R3,STGSQMMS         Address to Start of SP Queue Element
LSTG0500 DS    0H
         LLGT  R3,TCBSWA-TCB(,R2)  Scheduler Work Area SP 236 and 237
         STG   R3,STGSQSWA         Address to Start of SP Queue Element
LSTG0600 DS    0H
         LLGT  R3,TCBUKYSP-TCB(,R2) User Storage Key SP 229, 230, 249
         STG   R3,STGSQUKY         Address to Start of SP Queue Element
LSTG0700 DS    0H
         LA    R3,STGSQMMS         Get Addr to Sub-Pool Elements Table
         LLILL R14,(L'STGSQMMS)    Len of Each User Storage Table Entry
         LLGF  R15,=A((STGSQNUM*L'STGSQMMS)-L'STGSQMMS) Indicate Limit
         LA    R15,0(R3,R15)       Point to the Next to the Last Entry
*
*+-------------------------------------------------------------------+*
*| Process the Sub-Pool Queue Elements (SPQE)                        |*
*+-------------------------------------------------------------------+*
*
         USING SPQE,R4             Set Addressability to Queue Element
LSTG0800 DS    0H
         STMG  R14,R15,STGSPELE    Save Sub-Pool Elements Table Values
         LG    R4,0(,R3)           Get Sub-Pool Queue Element Pointer
         LTGFR R4,R4               There a Sub-Pool Queue Element Pntr?
         BRZ   LSTG2500            No => Check Next SP Element Tbl Pntr
LSTG0900 DS    0H
         CLGF  R2,TCBJSTCB-TCB(,R2) ...This Task Current Job Step Task?
         BRE   LSTG1000            Yes => SP Storage Associated To Us
         CLGF  R2,SPQETCB          Address of Owning TCB Match our TCB?
         BRE   LSTG1000            Yes => Then Process Queue Element
         TM    SPQEFLGS,SPQEOWN    Is This Subpool Owned?
         BRZ   LSTG2400            No  => Then Bypass The Queue Element
         USING SPQA,R5             Set Addressability to Queue Anchor
LSTG1000 DS    0H
         LLGT  R5,SPQESPQA         From This SPQE Get Address to SPQA
         LLILL R6,(SPQA_LEN/(2*L'SPQABDQE)) .Set No. of Entries in SPQA
LSTG1100 DS    0H
         CLGF  R5,0(,R5)           Addr Entry for 1st DQE for This SP?
         BRE   LSTG1600            No  => Check Next Queue Anchor Entry
         LLGT  R7,0(,R5)           Get Addr to Descriptor Queue Element
         USING DQE,R7              Set Addressability to Descriptor
LSTG1200 DS    0H
         ALGF  R0,DQESIZE          Accumulate Allocations Below the Lne
         SLGR  R15,R15             Clear Accumulator Reg for FQE Chain
         LLGT  R9,DQEFFQE          Get Addr of First Free Queue Element
LSTG1300 DS    0H
         CLGFR R7,R9               Are We at the End of the FQE Chain?
         BRE   LSTG1400            Yes => Branch to Process Next DQE
         ALGF  R15,FQESIZE-FQE(,R9) ..Add Free Space Bytes for This FQE
         LLGT  R9,FQENEXT-FQE(,R9) Get Addr of Next Free Queue Element
         BRU   LSTG1300            Branch to Process the Next FQE
LSTG1400 DS    0H
         ALG   R15,STGFRE24        Add Free Space Bytes to Accumulator
         STG   R15,STGFRE24        Save Below 16M Free Space Area Bytes
         BRU   LSTG1500            Check Next DQE in List of DQE's
*
*+-------------------------------------------------------------------+*
*|Loop Point To Process Next DQE For Same SPQA Entry for Same Subpool|*
*+-------------------------------------------------------------------+*
*| Check for End of List of DQE's for Allocated Storage Areas. The   |*
*| DQE's are chained as a Singly Linked List. However, the End of The|*
*| List is Indicated Not by the Usual Null Pointer, But by the Next  |*
*| DQE Pointer Pointing Back to the Parent SPQA block.               |*
*+-------------------------------------------------------------------+*
*
LSTG1500 DS    0H
         CLGF  R7,L'SPQALBDQ(,R5)  Addr Of Last DQE for This Sub-Pool?
         BRE   LSTG1600            Yes => Then Get Next Entry in SPQA
         LLGT  R7,DQENEXT          No  => Next DQE Entry for Sub-Pool
         BRU   LSTG1200            Loop=> Sub-Pool Has More Allocations
*
*+-------------------------------------------------------------------+*
*|  Loop Point To Process Next Entry Within SPQA for Same Sub-Pool   |*
*+-------------------------------------------------------------------+*
*| The SPQA is the Address Holder for a Set of DQE Chains. Bump to   |*
*| the Next Address in the SPQA for Next DQE chain.                  |*
*+-------------------------------------------------------------------+*
*
LSTG1600 DS    0H
         LA    R5,8(,R5)           Get Next Entry in SP Queue Anchor
         BRCTG R6,LSTG1100         Loop to Process Next Entry in SPQA
         DROP  R5                  Remove Listed Register as SPQA Base
*
*+-------------------------------------------------------------------+*
*| Still With the Same SPQE, Now Process the SPQX for Extended DQE's |*
*+-------------------------------------------------------------------+*
*
LSTG1700 DS    0H
         LLGT  R5,SPQESPQX         From This SPQE Get Address to SPQX
         LLILL R6,(SPQX_LEN/(2*L'SPQXEDQE)) .Set No. of Entries in SPQX
         USING SPQX,R5             Set Addressability to Queue Anchor
LSTG1800 DS    0H
         CLGF  R5,0(,R5)           Addr Entry for 1st DQE for This SP?
         BRE   LSTG2300            No  => Check Next Queue Anchor Entry
         LLGT  R7,0(,R5)           Get Addr to Descriptor Queue Element
         USING DQE,R7              Set Addressability to Descriptor
LSTG1900 DS    0H
         ALGF  R1,DQESIZE          Accumulate Allocations Above the Lne
         SLGR  R15,R15             Clear Accumulator Reg for FQE Chain
         LLGT  R9,DQEFFQE          Get Addr of First Free Queue Element
LSTG2000 DS    0H
         CLGFR R7,R9               Are We at the End of the FQE Chain?
         BRE   LSTG2100            Yes => Branch to Process Next DQE
         ALGF  R15,FQESIZE-FQE(,R9) ..Add Free Space Bytes for This FQE
         LLGT  R9,FQENEXT-FQE(,R9) Get Addr of Next Free Queue Element
         BRU   LSTG2000            Branch to Process the Next FQE
LSTG2100 DS    0H
         ALG   R15,STGFRE31        Add Free Space Bytes to Accumulator
         STG   R15,STGFRE31        Save Above 16M Free Space Area Bytes
         BRU   LSTG2200            Check Next DQE in List of DQE's
*
*+-------------------------------------------------------------------+*
*|Loop Point To Process Next DQE For Same SPQA Entry for Same Subpool|*
*+-------------------------------------------------------------------+*
*| Check for end of list of DQE's for allocated storage areas. The   |*
*| DQE's are chained as a singly linked list. However, the end of the|*
*| list is indicated not by the usual null pointer, but by the next  |*
*| DQE address pointing back to the parent SPQA block.               |*
*+-------------------------------------------------------------------+*
*
LSTG2200 DS    0H
         CLGF  R7,L'SPQALBDQ(,R5)  Addr Of Last DQE for This Sub-Pool?
         BRE   LSTG2300            Yes => Then Get Next Entry in SPQA
         LLGT  R7,DQENEXT          No  => Next DQE Entry for Sub-Pool
         BRU   LSTG1900            Loop=> Sub-Pool Has More Allocations
*
*+-------------------------------------------------------------------+*
*|  Loop Point To Process Next Entry Within SPQA for Same Sub-Pool   |*
*+-------------------------------------------------------------------+*
*| The SPQA is the address holder for a set of (3) DQE chains. Bump  |*
*| to the next address in the SPQA for next DQE chain.               |*
*+-------------------------------------------------------------------+*
*
LSTG2300 DS    0H
         LA    R5,8(,R5)           Get Next Entry in SP Queue Anchor
         BRCTG R6,LSTG1800         Loop to Process Next Entry in SPQA
         DROP  R5                  Remove Listed Register as SPQA Base
*
*+-------------------------------------------------------------------+*
*|  Loop Point To Process the Next SPQE for Next Sub-Pool            |*
*+-------------------------------------------------------------------+*
*
LSTG2400 DS    0H
         ICM   R4,B'1111',SPQENEXT There Another SPQE for Next Subpool?
         BRNZ  LSTG0900            Yes => Loop to Process Next Sub-Pool
*
*+-------------------------------------------------------------------+*
*|  Loop Point To Process Next Sub-Pool Group                        |*
*+-------------------------------------------------------------------+*
*
LSTG2500 DS    0H
         LMG   R14,R15,STGSPELE    Restore Sub-Pool Elements Tbl Values
         BRXLG R3,R14,LSTG0800     Loop to Process Next Sub-Pool Group
*
*+-------------------------------------------------------------------+*
*|  Loop Point To Process Storage for Next Subtask in TCB Chain      |*
*+-------------------------------------------------------------------+*
*
LSTG2600 DS    0H
         LLGT  R14,TCBLTC-TCB(,R2) TCB Adr of Most Recent Daughter Task
         LTGFR R14,R14             Does This Task Have Any Subtasks?
         BRZ   LSTG3000            No  => Done, Calculate Allocations
LSTG2700 DS    0H
         LGR   R15,R2              Hold the Current TCB Address
         LLGT  R2,TCBLTC-TCB(,R2)  Addr of Daughter TCB Last Attached
         LG    R9,STGTCBFQ         Depth of the Subtask Family Queue
         LA    R9,1(,R9)           Increment to Find Our Family Members
         STG   R9,STGTCBFQ         Save Depth of Family Queue Search
LSTG2800 DS    0H
         LTGFR R2,R2               Are We at the End of Our TCB Chain?
         BRNZ  LSTG2900            No  => Process Storage for Subtask
         LLGT  R2,TCBNTC-TCB(,R15) Get Sister In Family (Next Subtask)
         LLGT  R15,TCBOTC-TCB(,R15) .Who's the Mother (Owning) TCB Addr
         BRCTG R9,LSTG2800         Find a Subtask We Haven't Done Yet
         BRU   LSTG3000            Done, Calculate Storage Allocations
LSTG2900 DS    0H
         TM    TCBFLGS5-TCB(R2),TCBFC Has This Task Already Terminated?
         BRO   LSTG2600            Yes => Then Branch to Check Next TCB
         BRU   LSTG0400            Loop to Process Storage for Subtask
         DROP  R4,R7               Remove Listed Registers as Base Regs
*
*+-------------------------------------------------------------------+*
*|   Calculate The User's Current Private Area Storage Allocations   |*
*+-------------------------------------------------------------------+*
*
LSTG3000 DS    0H
         AGHI  R0,(24576)          Add for the System Region and PSA
         SG    R0,STGFRE24         Remove Free Space From Allocations
         BRNP  LSTG3100            Branch If No Storage Area Remaining
         LG    R2,STGLIM24         Get the Below-the-Line Max Allowed
         SGR   R2,R0               Calculate <16M Storage Remaining
         BRP   LSTG3200            Branch If Storage Area is Remaining
LSTG3100 DS    0H
         LA    R2,1                Indicate Remaining Storage as 1K
         BRU   LSTG3300            Branch to Process Below 16M Storage
LSTG3200 DS    0H
         SRLG  R2,R2,10            Show Our Remaining Area in KiloBytes
LSTG3300 DS    0H
         STG   R2,STGURM24         Save Below-the-Line Area Remaining
         SRLG  R0,R0,10            Show Currently Used in KiloBytes
         STG   R0,STGUAL24         Save the Below-the-Line Area Used
         LG    R2,STGLIM24         Get the Below-the-Line Max Allowed
         SRLG  R2,R2,10            Show Current Maximum in KiloBytes
         STG   R2,STGLIM24         Save the Below 16M Max in Kilobutes
         CG    R0,STGUHI24         Is Currently Used a High-Water Mark?
         BRNH  LSTG3400            No  => Branch to Process Above 16M
         STG   R0,STGUHI24         Save New Below 16M High-Water Mark
LSTG3400 DS    0H
         SG    R1,STGFRE31         Remove Free Space From Allocations
         BRNP  LSTG3500            Branch If No Storage Area Remaining
         LG    R2,STGLIM31         Get the Above-the-Line Max Allowed
         SGR   R2,R1               Calculate >16M Storage Remaining
         BRP   LSTG3600            Branch If Storage Area Remaining
LSTG3500 DS    0H
         LA    R2,1                Indicate Remaining Storage as 1K
         BRU   LSTG3700            Branch to Process Above 16M Storage
LSTG3600 DS    0H
         SRLG  R2,R2,10            Show Remaining Area in KiloBytes
LSTG3700 DS    0H
         STG   R2,STGURM31         Save Above-the-Line Area Remaining
         SRLG  R1,R1,10            Show the Current Area in KiloBytes
         STG   R1,STGUAL31         Save the Above-the-Line Area Used
         LG    R2,STGLIM31         Get the Above-the-Line Max Allowed
         SRLG  R2,R2,10            Show Current Maximum in KiloBytes
         STG   R2,STGLIM31         Save the Above 16M Max in Kilobutes
         CG    R1,STGUHI31         Is Currently Used a High-Water Mark?
         BRNH  LSTG3800            No  => Branch to Process Above 16M
         STG   R1,STGUHI31         Save New Above 16M High-Water Mark
*
*+-------------------------------------------------------------------+*
*| Format Output Line Displaying Private Area Use Below the 16M Line |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*| <16M: In Use=480K    Unused=8712K     Limit=9192K     HighU=480K  |*
*+-------------------------------------------------------------------+*
*
LSTG3800 DS    0H
         LG    R3,STGLG2II         Get Starting Address to Logger Area
         USING LGRWK2II,R3         Establish Addressability to Log Area
         LA    R0,LGWMSGTX         Get Starting Address to Message Area
         LLILL R1,(L'LGWMSGTX*4)   Set the Length of Message Build Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Using Pad Character
LSTG3900 DS    0H
         MVCLE R0,R14,C' '(0)      Clear the Entire Area to Blanks
         BRO   LSTG3900            Upon Interrupt Resume Where Left Off
LSTG4000 DS    0H
         MVC   LGWMSGTX+1(L'DTLINE$1),DTLINE$1 Fill Output Line Headers
         LA    R1,LGWMSGTX+1       Point to Start of Output Line Area
         STG   R1,STGLNPNT         Save Current Line Position in Area
STOR     USING RPTLNE$1,R1         Set Addressability to Detail Line
         MVC   STOR.RPTSTYPE,=CL5'<16M:' Show Below-the-Line Stor Info
         DROP  STOR                Removed Listed Register as Base Reg
         LA    R1,LGWMSGTX+(1+(RPT@USED-RPTLNE$1)) Get Address to Field
         LA    R5,STGUAL24         Get Address to User Storage Table
         LLILL R14,(L'STGUAL24)    Len of Each User Storage Table Entry
         LLGF  R15,=A((STG24NUM*L'STGUAL24)-L'STGUAL24) Indicate Limit
         LA    R15,0(R5,R15)       Point to the Next to the Last Entry
LSTG4100 DS    0H
         STG   R5,STGWORKD         Preserve Current Position in Table
         LG    R0,0(,R5)           Get User Storage Statistical Value
         CVD   R0,STGWORK2         Convert Storage Value to Decimal
         LGR   R5,R1               Position in Output Line to Work Reg
         LA    R1,STGFORC1         Preload 1st Forced Result Location
         MVC   STGWRK08,PATTERN    Copy in the Number Editing Pattern
         EDMK  STGWRK08,STGWORK2+4 Edit Storage Value to Character
         BRZ   LSTG4200            Branch if Source Value is Zeros
         LA    R14,STGWRK08+L'STGWRK08 Point to End of Edit Work Area
         MVI   0(R14),C'K'         Set Number Notation for Kilobytes
         SGR   R14,R1              Calculate Len of Storage Stat Value
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R14,*-6             Storage Statistic to Output Area
         BRU   LSTG4300            Branch to Process Next Field in Rcrd
LSTG4200 DS    0H
         MVC   0(3,R5),=CL3'N/A'   Show Statistical Value Unavailable
LSTG4300 DS    0H
         LGR   R1,R5               Current Position in Output Area
         LA    R1,RPTFILLR(,R1)    To the Next Field Position in Record
         LG    R5,STGWORKD         Restore Current Position in Table
         LLILL R14,(L'STGUAL24)    Len of Each User Storage Table Entry
         BRXLG R5,R14,LSTG4100     => Loop to Process Next Table Entry
LSTG4400 DS    0H
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preseve Updated Message Line Count
*
*+-------------------------------------------------------------------+*
*|   Format Output Line Displaying Private Area Above the 16M Line   |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*| >16M: In Use=2588K   Unused=1700324K  Limit=1702912K  HighU=2588K |*
*+-------------------------------------------------------------------+*
*
LSTG4500 DS    0H
         MVC   LGWMSGTX+1+L'DTLINE$1(L'DTLINE$1),DTLINE$1  Fill Headers
         LA    R1,LGWMSGTX+1+L'DTLINE$1 Point to Start of the Line Area
         STG   R1,STGLNPNT         Save Current Line Position in Area
STOR     USING RPTLNE$1,R1         Set Addressability to Detail Line
         MVC   STOR.RPTSTYPE,=CL5'>16M:' Show Above-the-Line Stor Info
         DROP  STOR                Removed Listed Register as Base Reg
         LA    R1,LGWMSGTX+(L'RPTLNE$1+1+(RPT@USED-RPTLNE$1)) Get Addr
         LA    R5,STGUAL31         Get Address to User Storage Table
         LLILL R14,(L'STGUAL31)    Len of Each User Storage Table Entry
         LLGF  R15,=A((STG31NUM*L'STGUAL31)-L'STGUAL31) Indicate Limit
         LA    R15,0(R5,R15)       Point to the Next to the Last Entry
LSTG4600 DS    0H
         STG   R5,STGWORKD         Preserve Current Position in Table
         LG    R0,0(,R5)           Get User Storage Statistical Value
         CVD   R0,STGWORK2         Convert Storage Value to Decimal
         LGR   R5,R1               Position in Output Line to Work Reg
         LA    R1,STGFORC1         Preload 1st Forced Result Location
         MVC   STGWRK08,PATTERN    Copy in the Number Editing Pattern
         EDMK  STGWRK08,STGWORK2+4 Edit Storage Value to Character
         BRZ   LSTG4700            Branch if Source Value is Zeros
         LA    R14,STGWRK08+L'STGWRK08 Point to End of Edit Work Area
         MVI   0(R14),C'K'         Set Number Notation for Kilobytes
         SGR   R14,R1              Calculate Len of Storage Stat Value
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R14,*-6             Storage Statistic to Output Area
         BRU   LSTG4800            Branch to Process Next Field in Rcrd
LSTG4700 DS    0H
         MVC   0(3,R5),=CL3'N/A'   Show Statistical Value Unavailable
LSTG4800 DS    0H
         LGR   R1,R5               Current Position in Output Area
         LA    R1,RPTFILLR(,R1)    To the Next Field Position in Record
         LG    R5,STGWORKD         Restore Current Position in Table
         LLILL R14,(L'STGUAL31)    Len of Each User Storage Table Entry
         BRXLG R5,R14,LSTG4600     => Loop to Process Next Table Entry
LSTG4900 DS    0H
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preseve Updated Message Line Count
         DROP  R3                  Remove Listed Reg as Log Area Base
*
*+-------------------------------------------------------------------+*
*| Process the RSM Address Space Block Extension (RAX) for storage   |*
*| areas above-the-bar acquired through IARV64 requests.             |*
*+-------------------------------------------------------------------+*
*
LSTG5000 DS    0H
         LLGT  R1,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pnt
         LLGT  R1,ASCBRSME-ASCB(,R1) Get RSM Addr Space Blk Extension
         LTGR  R1,R1               Is There a Pointer to RAX Cntl Blk?
         BRZ   LSTG7700            No  => ByPass Large Storage Check
         LLGF  R2,RAXLVNMOMB-RAX(,R1) .Private Memory Objects Allocated
         LTGR  R2,R2               There Any Private Memory Allocated?
         BRZ   LSTG5200            No  => Check for Shared Allocations
LSTG5100 DS    0H
         STG   R2,STG#MO64         Save No. of Priv Objects Allocated
         LG    R2,RAXLVABYTES-RAX(,R1) ..Pvt Memory Obj Bytes Allocated
         STG   R2,STGALC64         Save No. Pvt Memory Bytes Allocated
         LG    R2,RAXLVHBYTES-RAX(,R1) Get Private Object Bytes Hidden
         STG   R2,STGUAR64         Save Value for No. of Bytes Hidden
         LG    R2,RAXLVGBYTES-RAX(,R1) Pvt Memory Object Bytes Hi-Water
         STG   R2,STGUHI64         Save No. of High-Water Mark Bytes
         LG    R2,STGALC64         Get Pvt Memory Obj Bytes Allocated
         SLG   R2,STGUAR64         Bytes Guarded from Bytes Allocated
         STG   R2,STGUSE64         No. of Usable Pvt Memory Objct Bytes
LSTG5200 DS    0H
         LLGT  R3,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R3              Establish Addressability to CVT
         TM    CVTOSLV3,CVTH7708   Level at Least z/OS V1.5 (HBB7708)?
         BRZ   LSTG5500            No  => Branch to Process Storage Tbl
         LLGF  R2,RAXLVSHRNMOMB-RAX(,R1) Shared Memory Objects Alloc
         LTGR  R2,R2               There Any Shared Memory Allocated?
         BRZ   LSTG5500            No  => Branch to Process Storage Tbl
         STG   R2,STG#SO64         Save No. of Shared Objects Allocated
         LG    R2,RAXLVSHRBYTES-RAX(,R1) Get Shared Memory Object Bytes
         STG   R2,STGSHR64         Save No. of Shared Bytes Allocated
         LG    R2,RAXLVSHRGBYTES-RAX(,R1) Shared Object Bytes Hi-Water
         STG   R2,STGSHI64         Save Shared High-Water Mark Bytes
         TM    CVTOSLV5,X'08'      Level at Least z/OS V1.10 (HBB7750)?
         BRZ   LSTG5500            No  => Branch to Process Storage Tbl
         LLGF  R2,280(,R1)         No. of Common Memory Objects
         LTGR  R2,R2               There Any Common Memory Allocated?
         BRZ   LSTG5500            No  => Branch to Process Storage Tbl
         STG   R2,STG#CO64         Save No. of Common Objects Allocated
         LG    R2,264(,R1)         Get Common Memory Object Bytes
         STG   R2,STGCOM64         Save No. of Common Bytes Allocated
         LG    R2,272(,R1)         Common Object Bytes, Hi-Water Mark
         STG   R2,STGCHI64         Save Common High-Water Mark Bytes
LSTG5300 DS    0H
         TM    CVTOSLV5,X'10'      Level at Least z/OS V1.9 (HBB7740)?
         BRZ   LSTG5500            No  => Branch to Process Storage Tbl
         LGR   R15,R3              Pointer to CVT in Work Register
         AGHI  R15,(-6)            To Point Back into CVT Prefix Area
         CLC   0(2,R15),=A(X'2097') ...Are We Running on a z10 EC?
         BRE   LSTG5400            Yes => Then Check for Large Pages
         CLC   0(2,R15),=A(X'2098') ...Are We Running on a z10 BC?
         BRE   LSTG5400            Yes => Then Check for Large Pages
         CLC   0(2,R15),=A(X'2817') ...Are We Running on a z196?
         BRNE  LSTG5500            No  => Bypass Check for Large Pages
LSTG5400 DS    0H
         TM    CVTFLAG2,X'01'      Enhanced DAT Architecture Available?
         BRZ   LSTG5500            No  => Should be, Bypass Large Pages
         LG    R2,256(,R1)         No. of Large Pages Backed in Real
         STG   R2,STG#LO64         Large Pages Owned by Address Space
         DROP  R3                  Remove Listed Reg as CVT Base Reg
*
*+-------------------------------------------------------------------+*
*| Convert Above-the Bar Storage Byte Counts to Power of 2 Notation  |*
*+-------------------------------------------------------------------+*
*| Storage sizes in actual bytes will be converted and displayed as  |*
*| the number of bytes on a scale using megabytes as the smallest    |*
*| unit. Larger notations are used when the decimal byte count falls |*
*| on the exact boundary of the highest hex notation. For example,   |*
*| 1,023 gigabytes or 1,025 gigabytes will be displayed as 1,023     |*
*| Gigabytes or 1,025 Gigabytes. A storage size of 1,024 Gigabytes is|*
*| displayed as 1 Terabyte. The largest scale used for reporting a   |*
*| storage size is Petabytes. This means 8 Exabytes would be reported|*
*| as 8,192 Petabytes.                                               |*
*+-------------------------------------------------------------------+*
*
LSTG5500 DS    0H
         LA    R0,STGALC6C         Get Start Addr to Large Storage Tble
         LLILL R1,(STGLEN6C)       Set Leng of Large Storage Table Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Using Pad Character
LSTG5600 DS    0H
         MVCLE R0,R14,C' '(0)      Clear Entire Table Area to Blanks
         BRO   LSTG5600            Upon Interrupt Resume Where Left Off
LSTG5700 DS    0H
         LA    R4,STGALC64         Get Address to Large Storage Table
         LA    R5,STGALC6C         Get Addr to Character Format Table
         LLILL R14,(L'STGALC64)    Len of Each Large Storage Tble Entry
         LLGF  R15,=A((STG64NUM*L'STGALC64)-L'STGALC64) Indicate Limit
         LA    R15,0(R4,R15)       Point to the Next to the Last Entry
LSTG5800 DS    0H
         LG    R1,0(,R4)           Get User Storage Statistical Value
         LTGR  R0,R1               Is a Large Virtual Amount Available?
         BRZ   LSTG5900            No  => Branch to Process No Value
         LGR   R3,R1               Current Memory Size to Hold Register
         LLILL R2,(1)              Initialize to Set Value for Divisor
         SLLG  R2,R2,30 Bits       Set Value of Divisor at One Gigabyte
         SLGR  R0,R0               Clear for the Division Operation
         DLGR  R0,R2               Check if Memory Size in Gigabytes
         LTGR  R0,R0               Is Size on a Even Gigabyte Boundary?
         BRZ   LSTG6000            Yes => Check if Size Fits Terabyte
         SRLG  R0,R3,20 Bits       Calculate Megabytes (Divide by 1M)
         CG    R0,=AD(1)           Is Compared Size a Single Megabtye?
         BRNE  LSTG5900            No  => Branch to Set for Plural
         MVC   STGTYP64,=C'Megabyte ' ..Above-the-Bar Size as Megabyte
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG5900 DS    0H
         MVC   STGTYP64,=C'Megabytes' ..Above-the-Bar Size in Megabytes
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG6000 DS    0H
         LGR   R1,R3               To Check if Memlimit into Terabytes
         SLGR  R0,R0               Clear for the Division Operation
         SLLG  R2,R2,10 Bits       Set Value of Divisor at One Terabyte
         DLGR  R0,R2               Check If Memory Size in Terabytes
         LTGR  R0,R0               Is Size on a Even Terabyte Boundary?
         BRZ   LSTG6200            Yes => Check if Size Fits Petabyte
         SRLG  R0,R3,30 Bits       Calculate Gigabytes (Divide by 1G)
         CG    R0,=AD(1)           Is Compared Size a Single Gigabyte?
         BRNE  LSTG6100            No  => Branch to Set for Plural
         MVC   STGTYP64,=C'Gigabyte ' ..Above-the-Bar Size as Gigabyte
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG6100 DS    0H
         MVC   STGTYP64,=C'Gigabytes' ..Above-the-Bar Size in Gigabytes
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG6200 DS    0H
         LGR   R1,R3               To Check if Memlimit into Terabytes
         SLGR  R0,R0               Clear for the Division Operation
         SLLG  R2,R2,10 Bits       Set Value of Divisor at One Petabyte
         DLGR  R0,R2               Check If Memory Size in Terabytes
         LTGR  R0,R0               Is Size on a Even Petabyte Boundary?
         BRZ   LSTG6400            Yes => Final Measured Size=Petabytes
         SRLG  R0,R3,40 Bits       Calculate Terabytes (Divide by 1T)
         CG    R0,=AD(1)           Is Compared Size a Single Gigabyte?
         BRNE  LSTG6300            No  => Branch to Set for Plural
         MVC   STGTYP64,=C'Terabyte ' ..Above-the-Bar Size as Terabyte
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG6300 DS    0H
         MVC   STGTYP64,=C'Terabytes' ..Above-the-Bar Size in Terabytes
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG6400 DS    0H
         SRLG  R0,R3,50 Bits       Calculate Petabytes (Divide by 1P)
         CG    R0,=AD(1)           Is Compared Size a Single Petabyte?
         BRNE  LSTG6500            No  => Branch to Set for Plural
         MVC   STGTYP64,=C'Petabyte ' ..Above-the-Bar Size as Petabyte
         BRU   LSTG6600            Branch to Convert Binary Memory Size
LSTG6500 DS    0H
         MVC   STGTYP64,=C'Petabytes' ..Above-the-Bar Size in Petabytes
LSTG6600 DS    0H
         CVDG  R0,STGMEM64         Binary Large Memory Value to Decimal
         MVC   STGLGMEM,PATTERN2   Copy in the Number Editing Pattern
         SLGR  R1,R1               Ensure No Residual in High Half
         LA    R1,STGFORC2         Load 1st Forced Result Char Location
         EDMK  STGLGMEM,STGMEM64   Edit Large Memory Value to Character
         SLGR  R2,R2               Ensure No Residual in High Half
         LA    R2,STGLGMEM+L'STGLGMEM-1 ..Point to Last Byte in Output
         SGR   R2,R1               Calculate the Length of our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of Execute
         EX    R2,*-6              Copy Memory Value to Character Table
         LA    R2,2(R2,R5)         Pnt Past End of Memory Bytes Number
         MVC   0(L'STGTYP64,R2),STGTYP64 ..Above-the-Bar Boundary Type
         LA    R5,L'STGALC6C(,R5)  Increment to Next Entry in Char Tble
         BRXLG R4,R14,LSTG5800     => Loop to Next Entry in Binary Tble
*
*+-------------------------------------------------------------------+*
*|Process the Above-the-Bar Memory Object Counts for Private, Shared,|*
*|and Common Objects, and for the Number of 1MB Large Pages Backed by|*
*|Real for Our Address Space.                                        |*
*+-------------------------------------------------------------------+*
*
LSTG6700 DS    0H
         LA    R5,STG#MO6C         Get Addr to Character Format Table
         LG    R0,STG#MO64         Number of Private Memory Objects
         CVDG  R0,STGMEM64         Binary No. of Objects to Decimal
         MVC   STGLGMEM,PATTERN2   Copy in the Number Editing Pattern
         SLGR  R1,R1               Ensure No Residual in High Half
         LA    R1,STGFORC2         Load 1st Forced Result Char Location
         EDMK  STGLGMEM,STGMEM64   Edit Number of Objects to Character
         SLGR  R2,R2               Ensure No Residual in High Half
         LA    R2,STGLGMEM+L'STGLGMEM-1 ..Point to Last Byte in Output
         SGR   R2,R1               Calculate the Length of our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of Execute
         EX    R2,*-6              Copy No. of Objects to Character Tbl
LSTG6800 DS    0H
         LA    R5,STG#SO6C         Get Addr to Character Format Table
         LG    R0,STG#SO64         Number of Shared Memory Objects
         CVDG  R0,STGMEM64         Binary No. of Objects to Decimal
         MVC   STGLGMEM,PATTERN2   Copy in the Number Editing Pattern
         SLGR  R1,R1               Ensure No Residual in High Half
         LA    R1,STGFORC2         Load 1st Forced Result Char Location
         EDMK  STGLGMEM,STGMEM64   Edit Number of Objects to Character
         SLGR  R2,R2               Ensure No Residual in High Half
         LA    R2,STGLGMEM+L'STGLGMEM-1 ..Point to Last Byte in Output
         SGR   R2,R1               Calculate the Length of our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of Execute
         EX    R2,*-6              Copy No. of Objects to Character Tbl
LSTG6900 DS    0H
         LA    R5,STG#CO6C         Get Addr to Character Format Table
         LG    R0,STG#CO64         Number of Common Memory Objects
         CVDG  R0,STGMEM64         Binary No. of Objects to Decimal
         MVC   STGLGMEM,PATTERN2   Copy in the Number Editing Pattern
         SLGR  R1,R1               Ensure No Residual in High Half
         LA    R1,STGFORC2         Load 1st Forced Result Char Location
         EDMK  STGLGMEM,STGMEM64   Edit Number of Objects to Character
         SLGR  R2,R2               Ensure No Residual in High Half
         LA    R2,STGLGMEM+L'STGLGMEM-1 ..Point to Last Byte in Output
         SGR   R2,R1               Calculate the Length of our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of Execute
         EX    R2,*-6              Copy No. of Objects to Character Tbl
LSTG7000 DS    0H
         LA    R5,STG#LO6C         Get Addr to Character Format Table
         LG    R0,STG#LO64         Number of Large Pages for our ASID
         CVDG  R0,STGMEM64         Binary No. of Large Pages to Decimal
         MVC   STGLGMEM,PATTERN2   Copy in the Number Editing Pattern
         SLGR  R1,R1               Ensure No Residual in High Half
         LA    R1,STGFORC2         Load 1st Forced Result Char Location
         EDMK  STGLGMEM,STGMEM64   Edit Number of Objects to Character
         SLGR  R2,R2               Ensure No Residual in High Half
         LA    R2,STGLGMEM+L'STGLGMEM-1 ..Point to Last Byte in Output
         SGR   R2,R1               Calculate the Length of our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of Execute
         EX    R2,*-6              Copy No. of Objects to Character Tbl
*
*+-------------------------------------------------------------------+*
*| Format Output Lines Displaying the User's Storage Configuration   |*
*| for Above-the-Bar                                                 |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*|  >BAR: Allocated=256 Megabytes          Guard Amount=255 Megabytes|*
*|  >BAR: Pvt Used =1 Megabyte             Pvt Hi-Water=1 Megabyte   |*
*|  >BAR: Pvt Obj  =1                      Shr Objects =0            |*
*|  >BAR: Shr Alloc=0 Megabytes            Shr Hi-Water=0 Megabytes  |*
*|  >BAR: Com Alloc=0 Megabytes            Com Hi-Water=0 Megabytes  |*
*|  >BAR: Com Obj  =0                      Large Pages =0            |*
*+-------------------------------------------------------------------+*
*
LSTG7100 DS    0H
         LG    R3,STGLG2II         Get Starting Address to Logger Area
         USING LGRWK2II,R3         Establish Addressability to Log Area
         LG    R1,STGLNPNT         Get Old Line Position in Msg Area
         LA    R1,L'DTLINE$1(,R1)  Go Past End of Old Line to Start New
         STG   R1,STGLNPNT         Save New Line Position in Msg Area
         MVC   0(L'DTLINE$2,R1),DTLINE$2 Fill Msg Area with Lne Headers
STOR2    USING RPTLNE$2,R1         Set Addressability to Detail Line
         MVC   STOR2.RPT@ALLO,STGALC6C Amt of Large Storage Allocation
         MVC   STOR2.RPTGUARD,STGUAR6C Amt of Large Storage Guarded
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preseve Updated Message Line Count
         DROP  STOR2               Remove Listed Register as Base Reg
LSTG7200 DS    0H
         LG    R1,STGLNPNT         Get Old Line Position in Msg Area
         LA    R1,L'RPTLNE$2(,R1)  Go Past End of Old Line to Start New
         STG   R1,STGLNPNT         Save New Line Position in Msg Area
         MVC   0(L'DTLINE$3,R1),DTLINE$3 Fill Msg Area with Lne Headers
STOR3    USING RPTLNE$3,R1         Set Addressability to Detail Line
         MVC   STOR3.RPT@USE$,STGUSE6C Amt of Large Storage Useable
         MVC   STOR3.RPTHIWTR,STGUHI6C Amt of Large Storage Hi-Water
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preseve Updated Message Line Count
         DROP  STOR3               Remove Listed Register as Base Reg
LSTG7300 DS    0H
         LG    R1,STGLNPNT         Get Old Line Position in Msg Area
         LA    R1,L'RPTLNE$3(,R1)  Go Past End of Old Line to Start New
         STG   R1,STGLNPNT         Save New Line Position in Msg Area
         MVC   0(L'DTLINE$4,R1),DTLINE$4 Fill Msg Area with Lne Headers
STOR4    USING RPTLNE$4,R1         Set Addressability to Detail Line
         MVC   STOR4.RPT@OBJT,STG#MO6C Number of Private Memory Objects
         MVC   STOR4.RPT@SOBJ,STG#SO6C Number of Shared Memory Objects
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preseve Updated Message Line Count
         DROP  STOR4               Remove Listed Register as Base Reg
LSTG7400 DS    0H
         LG    R1,STGLNPNT         Get Old Line Position in Msg Area
         LA    R1,L'RPTLNE$4(,R1)  Go Past End of Old Line to Start New
         STG   R1,STGLNPNT         Save New Line Position in Msg Area
         MVC   0(L'DTLINE$5,R1),DTLINE$5 Fill Msg Area with Lne Headers
STOR5    USING RPTLNE$5,R1         Set Addressability to Detail Line
         MVC   STOR5.RPTSHALC,STGSHR6C Amt of Shared Objects Storage
         MVC   STOR5.RPTSHRHI,STGSHI6C Amt of Shared Objects Hi-Water
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preserve Updated Message Line Count
         DROP  STOR5               Remove Listed Register as Base Reg
LSTG7500 DS    0H
         LG    R1,STGLNPNT         Get Old Line Position in Msg Area
         LA    R1,L'RPTLNE$5(,R1)  Go Past End of Old Line to Start New
         STG   R1,STGLNPNT         Save New Line Position in Msg Area
         MVC   0(L'DTLINE$6,R1),DTLINE$6 Fill Msg Area with Lne Headers
STOR6    USING RPTLNE$6,R1         Set Addressability to Detail Line
         MVC   STOR6.RPTCMALC,STGCOM6C Amt of Common Objects Storage
         MVC   STOR6.RPTCOMHI,STGCHI6C Amt of Common Objects Hi-Water
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preserve Updated Message Line Count
         DROP  STOR6               Remove Listed Register as Base Reg
LSTG7600 DS    0H
         LG    R1,STGLNPNT         Get Old Line Position in Msg Area
         LA    R1,L'RPTLNE$6(,R1)  Go Past End of Old Line to Start New
         STG   R1,STGLNPNT         Save New Line Position in Msg Area
         MVC   0(L'DTLINE$7,R1),DTLINE$7 Fill Msg Area with Lne Headers
STOR7    USING RPTLNE$7,R1         Set Addressability to Detail Line
         MVC   STOR7.RPTCOBJT,STG#CO6C Number of Common Memory Objects
         MVC   STOR7.RPTLGPGE,STG#LO6C Number of Large Pages Owned
         LLGF  R2,LGWMSXCT         Get Message Build Area Line Count
         LA    R2,1(,R2)           Increment Count for the Message Line
         ST    R2,LGWMSXCT         Preseve Updated Message Line Count
         DROP  STOR7,R3            Remove Listed Registers as Base Regs
*
*+-------------------------------------------------------------------+*
*| Copy the Formatted Report Lines for Private Area Storage Use to   |*
*| the Temporary Output Buffer.                                      |*
*+-------------------------------------------------------------------+*
*
LSTG7700 DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         BRU   LSTG7900            Branch to Process Print of Storage
LSTG7800 DS    0H
         LA    R15,8               Serious Error Processng Storage Chck
         ST    R15,STGRETCD        Set Highest Return Code Generated
LSTG7900 DS    0H
         LG    R5,STGLG2II         Get Starting Address to Logger Area
         USING LGRWK2II,R5         Establish Addressability to Log Area
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Bytes Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         LMG   R3,R4,STGOPOSI      Outpt Buffer Line Position and Count
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
         LTGFR R15,R15             Storage Analysis Process Successful?
         BRZ   LSTG8100            Yes => Branch to Prnt Storage Result
LSTG8000 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LG    R15,STGODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH100)     Point to Private Area Error Message
         MVC   0(L'PVTMH100,RLINE),0(R1) Move in Detail Line Error Msg
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         BRU   LSTGEXIT            Branch on Error to Exit This Routine
LSTG8100 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LG    R15,STGODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH101)     Point to Header for Private Area
         MVC   0(L'PVTMH101,RLINE),0(R1) Move in the Detail Line Header
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LLGF  R1,LGWMSXCT         Get the Message Build Line Count
         LTGR  R1,R1               Any Storage Display Lines Available?
         BRZ   LSTG8400            No  => Process Other Log Point Data
         LA    R14,LGWMSGTX        Get Address of Message Build Area
LSTG8200 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set the Address of Output Line
         LG    R15,STGODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,5(R15,RLINE)  Increment for the Indention Level
         MVC   0(100,RLINE),0(R14) Copy Storage Allocation Info Line
         MVI   LNE.LGWOLINE,C'+'   Indicate This is Log Point Data
         LA    R14,100(,R14)       Point to Next Line in Message Buffer
         BRCTG R1,LSTG8200         => Loop to Process Next Line
LSTG8300 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
LSTG8400 DS    0H
         STMG  R3,R4,LGWOPOSI      Save Line Position and Count in Buff
*
*+-------------------------------------------------------------------+*
*| Analyze Allocated Storage Information for Subpools in the Private |*
*| Area of the User's Program, and Build a Subpool Id Summary Report.|*
*+-------------------------------------------------------------------+*
*
LSTG8500 DS    0H
         XC    LGWPLIST,LGWPLIST   Clear the Call Parameter List
         CALL  LVSM0000,           SubPool Id Summary for Private Area X
               (LGRWK2II,          ..Pass Pntr to Logger Work Area     X
               (R3),               ..Pass Current Line Position in BuffX
               (R4),               ..Pass Current Line Count in Buffer X
               STGODENT),          ..Pass Pntr to Current Ident Level  X
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LGWPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Sub Pool Summary
         LTGFR R15,R15             Sub Pool Summary Request Successful?
         BRZ   LSTG8600            Yes => Branch to Process Request
         LGHI  R2,((LSTG8700-LSTG8600)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   LSTG8600            No  => Process Sub Pool Area Request
         BRU   LSTGEXIT            Branch to Exit This Routine
LSTG8600 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   LSTG8700            Subpool Summary Report Completed
         BRU   LSTG8700            Warning on Processing Sub Pools
         BRU   LSTG8800            Validation Error Processing Subpools
         BRU   LSTG8900            Severe Error Processing Sub Pools
LSTG8700 DS    0H
         LMG   R3,R4,LGWOPOSI      Restore Lne Position/Count in Buffer
         BRU   LSTG9000            Branch to Process Job CPU Times
LSTG8800 DS    0H
         LMG   R3,R4,LGWOPOSI      Restore Lne Position/Count in Buffer
         LTGR  R3,R3               Current Lne Position Addr Available?
         BRZ   LSTGEXIT            No  => Branch to Exit This Routine
         BRU   LSTG9000            Yes => Then Attempt to Continue
LSTG8900 DS    0H
         LMG   R3,R4,LGWOPOSI      Restore Lne Position/Count in Buffer
         BRZ   LSTGEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| Process Job Step CPU Time and Job Step SRB Time for User Program  |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*|Job Step CPU: 0HR 0MIN 5.57331SEC Job Step SRB: 0HR 0MIN 1.02456SEC|*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
LSTG9000 DS    0H
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LG    R15,STGODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         MVC   0(13,RLINE),=CL13'Job Step CPU:' ...Fill Msg Area Header
         LA    RLINE,14(,RLINE)    Set Pointer in the Output Work Line
         LLGT  R2,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pntr
         LG    R1,ASCBEJST-ASCB(,R2) Get the Elapsed Job Step CPU Time
         SRLG  R1,R1,13            Set Microseconds/2**13
         DSGF  R0,=A(1000000/100000/2)  Hundred-Thousanths of a Second
         DSGF  R0,=A(60*60*100000) Calculate No. of Accumlated CPU Hrs
         CVDG  R1,STGWORKD         Binary CPU Hours Value to Decimal
         MVC   STGCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,STGFORC3         Load 1st Forced Result Char Location
         EDMK  STGCPUOT,STGWORKD+12 Edit CPU Hours Value to Character
         LA    R15,STGCPUOT+L'STGCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of CPU Hours Used
         MVC   0(*-*,RLINE),0(R1)  Indicated Target of the Execute
         EX    R15,*-6             Copy CPU Hours Used to Output Area
         LA    RLINE,1(R15,RLINE)  Point to the End of CPU Hours Used
         MVC   0(2,RLINE),=CL2'HR' Insert the CPU Hours Used Indicator
         LA    RLINE,3(,RLINE)     Increment to CPU Minutes Used Field
LSTG9100 DS    0H
         LGR   R1,R0               Prepare for Division to Get Minutes
         DSGF  R0,=A(60*100000)    Calculate Total Number of Minutes
         LGR   R14,R0              Preserve the Accumlated CPU Seconds
         CVDG  R1,STGWORKD         Binary CPU Minutes Value to Decimal
         MVC   STGCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,STGFORC3         Load 1st Forced Result Char Location
         EDMK  STGCPUOT,STGWORKD+12 Edit CPU Minutes Used to Character
         LA    R15,STGCPUOT+L'STGCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of CPU Minutes Used
         MVC   0(*-*,RLINE),0(R1)  Indicated Target of the Execute
         EX    R15,*-6             Copy CPU Minutes Used to Output Area
         LA    RLINE,1(R15,RLINE)  Point to the End of CPU Minutes Used
         MVC   0(3,RLINE),=CL3'MIN' ..Insert CPU Minutes Used Indicator
         LA    RLINE,4(,RLINE)     Increment to CPU Seconds Used Field
LSTG9200 DS    0H
         LGR   R1,R14              Prepare for Division to Get Seconds
         DSGF  R0,=A(100000)       Calculate the Total No. of Seconds
         CVDG  R1,STGWORKD         Binary CPU Seconds Value to Decimal
         MVC   STGCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,STGFORC3         Load 1st Forced Result Char Location
         EDMK  STGCPUOT,STGWORKD+12 Edit CPU Seconds Value to Character
         LA    R15,STGCPUOT+L'STGCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Leng of CPU Seconds Value
         MVC   0(*-*,RLINE),0(R1)  Indicated Target of the Execute
         EX    R15,*-6             Copy CPU Seconds to Output Area
         LA    RLINE,1(R15,RLINE)  Point to End of Whole CPU Seconds
         MVI   0(RLINE),C'.'       Insert Fractional Seconds Separator
         LA    RLINE,1(,RLINE)     Increment to Fractional Seconds Area
LSTG9300 DS    0H
         CVD   R0,STGWORKD         Decimal Version of Fractional Secnds
         OI    STGWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  0(5,RLINE),STGWORKD+5(3) Fractional Seconds to Character
         MVC   5(3,RLINE),=CL3'SEC' ..Insert CPU Seconds Used Indicator
*
*+-------------------------------------------------------------------+*
*|  Process the Job Step SRB Time                                    |*
*+-------------------------------------------------------------------+*
*
LSTG9400 DS    0H
         LA    RLINE,12(,RLINE)    Increment to the SRB Time Used Field
         MVC   3(13,RLINE),=CL13'Job Step SRB:' ...Fill Msg Area Header
         LA    RLINE,17(,RLINE)    Set Pointer in the Output Work Line
         LLGT  R2,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pntr
         LG    R1,ASCBSRBT-ASCB(,R2) Get the Elapsed Job Step SRB Time
         SRLG  R1,R1,13            Set Microseconds/2**13
         DSGF  R0,=A(1000000/100000/2)  Hundred-Thousanths of a Second
         DSGF  R0,=A(60*60*100000) Calculate No. of Accumlated SRB Hrs
         CVDG  R1,STGWORKD         Binary SRB Hours Value to Decimal
         MVC   STGCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,STGFORC3         Load 1st Forced Result Char Location
         EDMK  STGCPUOT,STGWORKD+12 Edit SRB Hours Value to Character
         LA    R15,STGCPUOT+L'STGCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of SRB Hours Used
         MVC   0(*-*,RLINE),0(R1)  Indicated Target of the Execute
         EX    R15,*-6             Copy SRB Hours Used to Output Area
         LA    RLINE,1(R15,RLINE)  Point to the End of SRB Hours Used
         MVC   0(2,RLINE),=CL2'HR' Insert the SRB Hours Used Indicator
         LA    RLINE,3(,RLINE)     Increment to SRB Minutes Used Field
LSTG9500 DS    0H
         LGR   R1,R0               Prepare for Division to Get Minutes
         DSGF  R0,=A(60*100000)    Calculate Total Number of Minutes
         LGR   R14,R0              Preserve the Accumlated SRB Seconds
         CVDG  R1,STGWORKD         Binary SRB Minutes Value to Decimal
         MVC   STGCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,STGFORC3         Load 1st Forced Result Char Location
         EDMK  STGCPUOT,STGWORKD+12 Edit SRB Minutes Used to Character
         LA    R15,STGCPUOT+L'STGCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of SRB Minutes Used
         MVC   0(*-*,RLINE),0(R1)  Indicated Target of the Execute
         EX    R15,*-6             Copy SRB Minutes Used to Output Area
         LA    RLINE,1(R15,RLINE)  Point to the End of SRB Minutes Used
         MVC   0(3,RLINE),=CL3'MIN' ..Insert SRB Minutes Used Indicator
         LA    RLINE,4(,RLINE)     Increment to SRB Seconds Used Field
LSTG9600 DS    0H
         LGR   R1,R14              Prepare for Division to Get Seconds
         DSGF  R0,=A(100000)       Calculate the Total No. of Seconds
         CVDG  R1,STGWORKD         Binary SRB Seconds Value to Decimal
         MVC   STGCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,STGFORC3         Load 1st Forced Result Char Location
         EDMK  STGCPUOT,STGWORKD+12 Edit SRB Seconds Value to Character
         LA    R15,STGCPUOT+L'STGCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Leng of SRB Seconds Value
         MVC   0(*-*,RLINE),0(R1)  Indicated Target of the Execute
         EX    R15,*-6             Copy SRB Seconds to Output Area
         LA    RLINE,1(R15,RLINE)  Point to End of Whole SRB Seconds
         MVI   0(RLINE),C'.'       Insert Fractional Seconds Separator
         LA    RLINE,1(,RLINE)     Increment to Fractional Seconds Area
LSTG9700 DS    0H
         CVD   R0,STGWORKD         Decimal Version of Fractional Secnds
         OI    STGWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  0(5,RLINE),STGWORKD+5(3) Fractional Seconds to Character
         MVC   5(3,RLINE),=CL3'SEC' ..Insert SRB Seconds Used Indicator
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         STMG  R3,R4,LGWOPOSI      Save Line Position and Count in Buff
         SLGR  R15,R15             Indicate Successful Completion
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LSTGEXIT DS    0H
         ST    R15,STGRETCD        Save Highest Return Code Generated
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         L     R15,STGRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
*
*+-------------------------------------------------------------------+*
*|             P r o g r a m   C o n t r o l   A r e a               |*
*+-------------------------------------------------------------------+*
*
STG@PCA  DSECT ,                   Logger Program Control Area-(LCA)
STG@EYEC DS    CL32                EyeCatcher for This RSECT's LCA Area
STG$SAVE DS    26FD                Save Area
STGWORKD DS    10D                 General Work Area
*
STGLG2II DS    AD                  Addr of LGRWK2II Logger Service Area
STGOPOSI DS    AD                  Current Lne Position in Outpt Buffer
STGOCNTR DS    FD                  Current Line Count in Output Buffer
STGODENT DS    AD                  Addr of Current Indentation Level
*
STGSPELE DS    2FD                 Pointer for Sub-Pool Elements Table
STGFRE24 DS    FD                  Area for Below 16M Free Space Bytes
STGFRE31 DS    FD                  Area for Above 16M Free Space Bytes
STGLNPNT DS    AD                  Save Current Line Position in Area
STGTCBFQ DS    FD                  TCB Subtask Family Hierarchy Queue
STGRETCD DS    F                   Return Code for Storage Check
STGWORK2 DS    2D                  General Work Area
STGWRK08 DS    CL8                 Work Area for Editing Decimal Values
STGFORC1 EQU   *-2                 First Forced Result Char Location
STGMEM64 DS    CL16                Work Area for the Decimal MEMLIMIT
STGLGMEM DS    CL(L'PATTERN2)      Binary Large Area Bytes to Character
STGFORC2 EQU   *-1                 First Forced Result Char Location
STGCPUOT DS    CL(L'PATTERN)       Work Area for Character Formatting
STGFORC3 EQU   *-1                 First Forced Result Char Location
STGTYP64 DS    CL9                 Save Area for Storage Boundary Type
STG$LINE DS    CL133               Formatted Output Line Work Area
         DS    0D                  Ensure Boundary Ends On Doubleword
STGPCALN EQU   *-STG@PCA           Leng of Logger Program Control Area
         DROP  ,                   Remove All Listed Regs as Base Regs
*
***********************************************************************
*                 End of LGMHPSTG Main Program                        *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*| RRRRRRR   OOOOO  U     U TTTTTTT IIIIIII N     N EEEEEEE   SSSSS  |*
*| R      R O     O U     U    T       I    NN    N E        S     S |*
*| R      R O     O U     U    T       I    N N   N E        S       |*
*| RRRRRRR  O     O U     U    T       I    N  N  N EEEEEE    SSSSS  |*
*| R    R   O     O U     U    T       I    N   N N E              S |*
*| R     R  O     O U     U    T       I    N    NN E        S     S |*
*| R      R  OOOOO   UUUUU     T    IIIIIII N     N EEEEEEE   SSSSS  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************| L V S M 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   V i r t u a l   S t o r a g e   S u b p o o l   R e p o r t     |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: LVSM0000                                           *
*                                                                     *
* FUNCTION:        Build Virtual Storage Subpool Id Summary Report    *
*                                                                     *
*                  This routine will process allocated storage        *
*                  information for the subpools in the Private Area,  *
*                  and build a Subpool Summary Report. The VSMLIST    *
*                  routine is called which will return in a work area *
*                  allocated storage information blocks and free space*
*                  information blocks for subpools. This routine will *
*                  analyze the allocated block descriptors returned in*
*                  the VSMLIST work area, and add the size of each    *
*                  allocated block in a subpool to a Subpool Summary  *
*                  Work Area to hold the number of allocated areas    *
*                  and total size in bytes of all allocated areas. If *
*                  there are multiple owning TCB's active, VSMLIST    *
*                  will format out the subpools under the owning TCB  *
*                  that was current at the time storage was acquired  *
*                  which may result in multiples of each subpool in   *
*                  the work area being returned by VSMLIST. These     *
*                  multiples of one subpool will have their allocated *
*                  area counts, and allocated and free space area     *
*                  bytes accumulated to the corresponding subpool id  *
*                  entry in the Subpool Summary Work Area. This means *
*                  if one TCB has allocations to Subpool 3 and another*
*                  TCB has allocations to Subpool 3, the allocated    *
*                  area counts, allocated bytes, and free space bytes *
*                  from two or more Subpool 3 entries listed in the   *
*                  VSMLIST return area will be added to the one       *
*                  Subpool 3 entry in the Subpool Summary Work Area.  *
*                                                                     *
*                  Once the work area returned by the VSMLIST routine *
*                  is processed, the VSMLIST return code is checked   *
*                  to verify if all the subpool information to be     *
*                  obtained was able to fit in the available work     *
*                  area. If a RC=04, this indicates all of the        *
*                  requested subpool information did not fit in the   *
*                  32K work area, and more information needs to be    *
*                  returned. In which case this routine will call     *
*                  VSMLIST mutiple times until VSMLIST produces a     *
*                  RC=00 indicating there is no more remaining subpool*
*                  information, and the requested information returned*
*                  on the last VSMLIST call fit in the work area.     *
*                                                                     *
*                  Information on the format of the VSMLIST work area *
*                  is described in "z/OS MVS Programming: Authorized  *
*                  Assembler Services Guide", Chapter 10 'Virtual     *
*                  Storage Management'.                               *
*                                                                     *
*                  Once all of the subpool information has been       *
*                  obtained from VSMLIST and placed in the Subpool    *
*                  Summary Work Area, it will be sorted. If there were*
*                  multiple owning TCB's active, then the entries in  *
*                  the Subpool Summary Work Area may not be in order. *
*                  This routine will first calculate the highest power*
*                  of 2 less than or equal to the entry count in the  *
*                  Subpool Summary Work Area, and then sort the       *
*                  Subpool Summary Work Area entries in ascending     *
*                  order by subpool id and storage protection key.    *
*                                                                     *
*                  Next this routine will build and format a report   *
*                  showing how all the allocated virtual storage areas*
*                  in the private area below-the-bar are distributed  *
*                  among the various Subpools. Subpool ids available  *
*                  for reporting are those Subpools in the private    *
*                  area owned by tasks in the user's program, and may *
*                  include Subpools 1-127, 129-132, 229, 230, 236,    *
*                  237, 244, 249, and 251.                            *
*                                                                     *
* For example:                                                        *
*                                                                     *
*Private Area Subpools Allocated: Owned by Task - Acquired by GETMAIN/*
* SP-Key  Allocated   Free Space  Allocated   Free Space    Allocated *
*         Areas-DQE   Areas-FQE   Below 16M   Below 16M   Above 16M Li*
* 003-8   3,968       1           475,136     2,872       352,239,616 *
* 004-8   500         500         0           0           2,048,000   *
* 005-8   500         500         0           0           2,048,000   *
* 229-5   2           2           0           0           12,288      *
* 230-0   1           1           4,096       760         0           *
* 230-5   3           7           8,192       7,232       4,096       *
* 230-8   1           1           0           0           4,096       *
* 251-8   2           2           0           0           200,704     *
*         ----------  ----------  ----------  ----------  ------------*
* Totals  4,977       1,014       487,424     10,864      356,556,800 *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to LGRWK2II Logger Work Area        *
*                         (Mapped by LGCPLSWA CopyBook)               *
*                  Parm2: Pointer to Current Line Position in Output  *
*                         Buffer                                      *
*                  Parm3: Current Line Count in Output Buffer         *
*                  Parm4: Pointer to Current Indentation Level Value  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LGMHPSTG - Private Area Storage Analysis Main Pgm  *
*                                                                     *
* CALLED PROGRAMS: VSMLIST  - Virtual Storage Manager Routine         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Serious Error                                 *
*                  12 - Severe Error                                  *
*                                                                     *
***********************************************************************
*
LVSM0000 RSECT *                   Read-Only Control Section Name
LVSM0000 AMODE &AMODE              Establish Addressing Mode
LVSM0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
LVSM0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         B     LVSM0002            Branch Past the Literal Area
         DC    C'LVSM0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLvl
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
LVSM0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING LVSM0000+(LVSM0001-LVSM0000),RBASE1 Progrm Base Register
         LGR   R2,R13              Preserve Caller's Save Area Address
         LLGF  R14,=A((LGW$AREA-LGRWK2II)+STGPCALN) Index to Work Area
         LG    R3,0(R1)            Get Starting Addr to LGRWK2II Area
         LA    R3,0(R14,R3)        Point to Wrk Area within Logger Area
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
*
*+-------------------------------------------------------------------+*
*| Establish Addressability To A LCA Working Storage Area Within The |*
*| LGRWK2II Area and Get The Input Parameters                        |*
*+-------------------------------------------------------------------+*
*
LVSM1000 DS    0H
         USING LVM@PCA,RCOMM1      Common Dynamic Area Addressability
         USING COM#P3M6,RCOMM2     Constants&Routines Addressability
         LGR   RCOMM1,R3           Establish Common Work Area Address
         LLGT  RCOMM2,=A(COM#P3M6) Constants and Routines Area Address
         LG    R1,LCAF64R01-LCASAVE(,R2) Restore Parameter List Address
         LMG   R0,R3,0(R1)         Get the Input Parameters
         STMG  R0,R3,LVMLG2II      Save the Input Parameters
         MVC   LVM@EYEC,=CL32'LVSM0000 WORK AREA' ...Set LCA Eyecatcher
         XC    LVMRETCD,LVMRETCD   Initialize Return Code
*
*+-------------------------------------------------------------------+*
*|  Retain Virtual Storage Old Area and Release Physical Paging to   |*
*|  Clear the Portion of the LGRWK2II Area Being Re-Used as Two Work |*
*|  Areas. One Work Area is to Hold Data Returned From the VSMLIST   |*
*|  Call and the Other is for the Subpool Summary Work Area.         |*
*+-------------------------------------------------------------------+*
*
LVSM1100 DS    0H
         LG    R1,LVMLG2II         Get Starting Address to Logger Area
         LLGF  R0,=A(LGW$VSLN)     Len of VSMLIST+ SP Summary Wrk Areas
         LLGF  R2,=A(LGW$PVSM-LGRWK2II)  Index to the VSMLIST Work Area
         LA    R1,0(R2,R1)         Addr of VSMLIST/Subpool Summary Area
         LGR   R3,R1               Hold Start Addr of VSMLIST Work Area
         LGR   R15,R1              Starting Address of Mapping Wrk Area
         AGR   R15,R0              Calculate Ending Address of Wrk Area
         NG    R15,=AD(-4096)      Round Area Down to a Page Boundary
         BCTGR R15,R0              Ensure Pointing to Actual End Addr
         LA    R1,4095(,R1)        Add 4K to Existing Starting Address
         NG    R1,=AD(-4096)       Round It Up to Full Page Boundary
         CGR   R15,R1              Any Page Aligned Areas to Release?
         BRNH  LVSM1200            No  => Branch for a Physical Clear
       PGSER R,RELEASE,            Release VSMLIST+Subpool Summary PageX
               A=(1),              Addr of VSMLIST/Subpool Summary AreaX
               EA=(15),            Address of Last Byte in Work Areas  X
               BRANCH=N            Using SVC Entry for Paging Service
         BRU   LVSM2000            Branch to Obtain Virtual Storage Map
LVSM1200 DS    0H
         LGR   R0,R3               Addr to VSMLIST/Subpool Summary Area
         LLGF  R1,=A(LGW$VSLN)     Leng VSMLIST + SP Summary Work Areas
         SLGR  R14,R14             Our Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear VSMLIST + Subpool Summary Area
*
*+-------------------------------------------------------------------+*
*|   Get Storage Subpool Info for the User Program's Private Area    |*
*+-------------------------------------------------------------------+*
*
LVSM2000 DS    0H
         LG    R5,LVMLG2II         Get Starting Address to Logger Area
         USING LGRWK2II,R5         Establish Addressability to Log Area
         LMG   R0,R1,LVMOPOSI      Line Position and Count in Buffer
         STMG  R0,R1,LGWOPOSI      Save Line Position and Count in Buff
         XC    LGWMSXCT,LGWMSXCT   Clear Message Build Area Line Count
         LA    R1,LVSM4700         Get Retry Recovery Address (ESTAE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP    Indicate Suppress Dump If An Abend
         XC    LVMSUMCT,LVMSUMCT   Init Entry Count for SP Summary Area
         LLGF  R1,=A(LGW$PVSM-LGRWK2II) Index to the VSMLIST Work Area
         LA    R3,0(R1,R5)         Address of Work Area to Return Data
         STG   R3,LVMRDAT@         Save Address of Returned Data Area
LVSM2100 DS    0H
         LG    R3,LVMRDAT@         Get Start Addr of Returned Data Area
         SAM31                     Switch Now to 31-Bit Addressing Mode
         VSMLIST SP=PVT,           Get Info on Subpools in Private AreaX
               TCB=(,ALL),         Subpool Info is for TCB and SubtasksX
               SPACE=FREE,         Subpool Info on Allocated+Free SpaceX
               WKAREA=(0(R3),LGW$PVML), Address and Leng of Return AreaX
               PVTSP=OWNED,        Subpool Info Returned Owned by Task X
               LOC=31,             Subpool Info for Areas Below the BarX
               LINKAGE=SYSTEM      Problem State-PC to VSMLIST Routine
         SAM64                     Switch Back to 64-Bit Address Mode
LVSM2200 DS    0H
         LLGF  R1,0(,R3)           Get Return Code from VSMLIST Routine
         CGHI  R1,4                Was Full or Partial Info Returned?
         BRH   LVSM4700            No  => Exit on a Sub-Pool List Error
*
*+-------------------------------------------------------------------+*
*| Work Area and Data Area Has Been Returned From VSMLIST. Parse the |*
*| Allocated Block Descriptors and Free Space Descriptors Associated |*
*| With Each Subpool Descriptor Listed in the Returned Work Area.    |*
*+-------------------------------------------------------------------+*
*
LVSM2300 DS    0H
         LLGF  R1,=A(LGWSPSUM-LGRWK2II) ..Index to Subpool Summary Area
         LA    R6,0(R1,R5)         Address of Subpool Summary Work Area
         STG   R6,LVMSUMM@         Save Adr of Subpool Summary Wrk Area
         LG    R7,LVMSUMCT         Get Entry Count for SP Summary Area
         USING SPLSUMM@,R6         Addressability Subpool Summary Entry
LVSM2400 DS    0H
         LLGT  R1,4(,R3)           Get Address of Returned Data Area
         LLGF  R2,8(,R3)           Get the Length of Returned Data Area
         LA    R15,0(R1,R2)        Calculate Ending Addr of Data Area
         STG   R15,LVMRDATZ        Ending Address of Returned Data Area
         LLGF  R2,0(,R1)           Get the No. of TCB's in Private Area
         STG   R2,LVMTCBCT         Save the Private Area TCB Count
         LLGT  R9,8(,R1)           Get the Count for No. of Subpools
         LA    R4,12(,R1)          Get the Subpool Descriptor Entry
         USING VSMD,R4             Addressability to the VSM Descriptor
         LTGR  R7,R7               Is This the First Time Through?
         BRZ   LVSM2600            Yes => No Entries in SP Summary Area
LVSM2500 DS    0H
         CLC   0(L'VSMDID+L'VSMDKEY,R6),VSMDID  Our Subpool Id and Key?
         BRE   LVSM2700            Yes => Branch to Process Subpool
         LA    R6,SPLSUMLN(,R6)    Increment to Next Entry in Wrk Area
         BRCTG R7,LVSM2500         Loop to Process the Next Entry
LVSM2600 DS    0H
         LG    R7,LVMSUMCT         Get Entry Count for SP Summary Area
         LA    R7,1(,R7)           Add to Count for Subpool Id and Key
         STG   R7,LVMSUMCT         Save Entry Count for SP Summary Area
LVSM2700 DS    0H
         MVC   SPLSPNUM,VSMDID     Get the Sub Pool Identifier
         MVC   SPLSPKEY,VSMDKEY    Get Subpool Storage Protection Key
         LA    R4,VSMD+L'VSMDSP+L'VSMDTCBP ..Point to Descriptor Count
         LLGF  R0,SPLALLOC         Old Allocated Block Descriptor Count
         ALGF  R0,VSMDCNT          Add to Count on This Subpool and Key
         ST    R0,SPLALLOC         Save Allocated Blk Descriptor Count
         LLGF  R8,VSMDCNT          Current Allocated Blk Descriptor Cnt
         LA    R4,VSMD+L'VSMDCNT   Point to Allocated Block Descriptor
*
*+-------------------------------------------------------------------+*
*| Process the Allocated Block Descriptors to Add the Size of Each   |*
*| Allocated Block in a Subpool to the Subpool Summary Work Area to  |*
*| Accumulate the No. of Areas and Total Size in Bytes of Allocated  |*
*| and Free Space Areas Within the Subpool and Storage Key.          |*
*+-------------------------------------------------------------------+*
*
LVSM3000 DS    0H
         TM    VSMDAREA,X'7F'      Is the Address of Our Block 31-Bit?
         BRNZ  LVSM3100            Yes => Branch to Process 31-Bit Addr
         LLGF  R15,SPL24ALC        Number of Allocated Bytes Below 16M
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         ST    R15,SPL24ALC        Accumulated Byte Count for Below 16M
         BRU   LVSM3200            Branch to Check If Free Space Areas
LVSM3100 DS    0H
         LLGF  R15,SPL31ALC        Number of Allocated Bytes Above 16M
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         ST    R15,SPL31ALC        Accumulated Byte Count for Above 16M
LVSM3200 DS    0H
         LA    R4,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         LLGF  R1,SPLFREEA         Free Space Descriptors Accumulator
         LLGF  R2,VSMDCNT          Get the Free Space Descriptors Count
         ALGR  R1,R2               Add to Count on This Subpool and Key
         ST    R1,SPLFREEA         Save Free Space Blk Descriptor Count
         LA    R4,VSMD+L'VSMDCNT   Point to Free Space Block Descriptor
         LTGR  R2,R2               Allocated Block Have Any Free Space?
         BRZ   LVSM3600            No  => Branch to Check Allocated Blk
*
*+-------------------------------------------------------------------+*
*|  Process Any Free Space Descriptors Which May Be Associated With  |*
*|  This Allocated Block Descriptor for the Subpool and Storage Key. |*
*+-------------------------------------------------------------------+*
*
LVSM3300 DS    0H
         TM    VSMDAREA,X'7F'      Is the Address of Our Block 31-Bit?
         BRNZ  LVSM3400            Yes => Branch to Process 31-Bit Addr
         LLGF  R15,SPL24FRE        Number of Allocated Bytes Below 16M
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         ST    R15,SPL24FRE        Accumulated Byte Count for Below 16M
         BRU   LVSM3500            Branch to Process Next Allocated Blk
LVSM3400 DS    0H
         LLGF  R15,SPL31FRE        Number of Allocated Bytes Above 16M
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         ST    R15,SPL31FRE        Accumulated Byte Count for Above 16M
LVSM3500 DS    0H
         LA    R4,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         BRCTG R2,LVSM3300         Loop to Process Next Free Space Blk
LVSM3600 DS    0H
         BRCTG R8,LVSM3000         Loop to Next Alloc Descriptor Block
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process Allocated and Free Areas for Next Subpool   |*
*+-------------------------------------------------------------------+*
*
LVSM4000 DS    0H
         LG    R6,LVMSUMM@         Get Addr of Subpool Summary Wrk Area
         LG    R7,LVMSUMCT         Get Entry Count for SP Summary Area
         BRCTG R9,LVSM2500         Loop to Process the Next Sub Pool ID
*
*+-------------------------------------------------------------------+*
*|Loop Point to Process Allocated and Free Areas for Subpools Owned  |*
*|by the Next TCB Listed in the VSMLIST Work Area.                   |*
*+-------------------------------------------------------------------+*
*
LVSM4100 DS    0H
         LG    R2,LVMTCBCT         Get the No. of TCB's in Private Area
         LTGR  R2,R2               A Rollover in Remaining TCB Count?
         BRNP  LVSM4300            Yes => Branch to Check Return Code
         BRCTG R2,LVSM4200         No  => Process Next TCB's Subpools
         BRU   LVSM4300            Done, Branch to Check Return Code
LVSM4200 DS    0H
         STG   R2,LVMTCBCT         Save Remaining Priv Area TCB Count
         LLGT  R9,L'VSMDTCB(,R4)   Count for Number of Subpools for TCB
         LA    R4,8(,R4)           Get the Subpool Descriptor Entry
         LG    R6,LVMSUMM@         Get Addr of Subpool Summary Wrk Area
         LG    R7,LVMSUMCT         Get Entry Count for SP Summary Area
         BRU   LVSM2500            Loop to Process Subpools of Next TCB
*
*+-------------------------------------------------------------------+*
*| The Work Area has Been Processed. Now Check the Return Code from  |*
*| VSMLIST to Verify If There is Any Remaining Subpool Information.  |*
*| If VSMLIST Indicated a RC=04, Then Loop to Call VSMLIST as There  |*
*| is Additional Subpool Information Pending.                        |*
*+-------------------------------------------------------------------+*
*
LVSM4300 DS    0H
         LG    R3,LVMRDAT@         Start Addr of Returned Subpool Data
         LLGF  R15,0(,R3)          Get Return Code from VSMLIST Routine
         CGHI  R15,4               Was Partial Information Returned?
         BRE   LVSM2100            Yes => Loop If Only Partial Info
LVSM4400 DS    0H
         BRL   LVSM4600            Full Info Was Returned from VSMLIST
LVSM4500 DS    0H
         BRU   LVSM4700            Error, Branch to Set Condition Code
         DROP  R4,R6               Remove Listed Registers as Base Regs
LVSM4600 DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         BRU   LVSM4800            Branch to Process Subpool Summary
LVSM4700 DS    0H
         LA    R15,8               Serious Error Processng Subpool IDs
         ST    R15,LVMRETCD        Set Highest Return Code Generated
LVSM4800 DS    0H
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Bytes Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         LMG   R3,R4,LVMOPOSI      Outpt Buffer Line Position and Count
LNE      USING LGWLINE,R3          Establish Addressability to Rcrd Lne
         LTGFR R15,R15             Subpool Analysis Process Successful?
         BRZ   LVSM5000            Yes => Continue to Subpool Area Sort
         BRU   LVSM4900            No  => Write SP List Error Message
*
*+-------------------------------------------------------------------+*
*|   Issue Error Message for Unable to Obtain Subpool Information    |*
*+-------------------------------------------------------------------+*
*
LVSM4900 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH200)     Point to Subpool List Error Message
         MVC   0(L'PVTMH200,RLINE),0(R1) Move in Detail Line Error Msg
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         STMG  R3,R4,LGWOPOSI      Save Line Position and Count in Buff
         LLGF  R15,LVMRETCD        Get Highest Return Code Generated
         BRU   LVSMEXIT            Branch on Error to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|Get Highest Power of 2 Less Than or Equal to SP Summary Entry Count|*
*+-------------------------------------------------------------------+*
*
LVSM5000 DS    0H
         LG    R7,LVMSUMCT         Get Entry Count for SP Summary Area
         LA    R14,1               Start With the Lowest Value
         CGR   R7,R14              More Than One Entry in SP Summary?
         BRNH  LVSM6000            No  => Branch to Process Summary
         LGR   R6,R7               Set the Subpool Summary Entry Count
LVSM5100 DS    0H
         CGR   R14,R6              Are We Greater than the Entry Count?
         BRNL  LVSM5200            Yes => Then Divide the Count by Two
         SLLG  R14,R14,1 Bit       No  => Then Multiply Count Times Two
         BRU   LVSM5100            Loop to Compare Value to Entry Count
LVSM5200 DS    0H
         SRLG  R14,R14,1 bit       Divide SP Summary Entry Count By 2
         STG   R14,LVMSPWR2        Save Highest Power of 2 of Entry Cnt
         LGR   R1,R7               Total No. of Entries Filled in List
         LG    R2,LVMSUMM@         Get Addr of Subpool Summary Wrk Area
         LA    R15,SPLSUMLN        Len of Entry in Subpool Summary Area
         MSGFR R15,R1              Times No. of Entries Filled in Area
         ALGR  R15,R2              Calculate Addr of Last Summary Entry
         STG   R15,LVMSPEND        Save Address to End of Last SP Entry
*
*+-------------------------------------------------------------------+*
*| Perform Sort Of The Subpool Summary Work Area Ascending by the    |*
*| Subpool Id and Storage Protection Key.                            |*
*+-------------------------------------------------------------------+*
*
LO       USING SPLSUMM@,R2         Bind Addressability to Summary Entry
HI       USING SPLSUMM@,R6         Bind Addressability to Summary Entry
LVSM5300 DS    0H
         LG    R1,LVMSPWR2         Highest P**2 LE of Total Subpool Cnt
LVSM5400 DS    0H
         LG    R2,LVMSUMM@         Get Adr of 1st Subpool Summary Entry
         LA    R15,SPLSUMLN        Len of Entry in Subpool Summary Area
         MSGFR R15,R1              Times # of Entries as P**2 LE of Ent
         ALGR  R15,R2              Calculate SP Summary Entry to Check
         LGR   R6,R15              Point to SP Summary Entry to Check
LVSM5500 DS    0H
         CLC   LO.SPLSPNUM(L'SPLSPNUM+L'SPLSPKEY),HI.SPLSPNUM In Order?
         BRNH  LVSM5700            Yes => Branch to Check Next Entry
         XC    0(SPLSUMLN,R2),0(R6) ..Swap Entries in SP Summary Area
         XC    0(SPLSUMLN,R6),0(R2) ..Exchange Subpool Summary Entries
         XC    0(SPLSUMLN,R2),0(R6) ..Exchange Subpool Summary Entries
         CGHI  R1,(1)              This Last Pass Special Processing?
         BRNE  LVSM5700            No  => Branch to Check Next Entry
         CG    R2,LVMSUMM@         At Beginning of SubPl Summary Area?
         BRE   LVSM5700            Yes => Branch to Check Next Entry
LVSM5600 DS    0H
         AGHI  R2,(-SPLSUMLN)      Decrement the Low Key Entry Position
         AGHI  R6,(-SPLSUMLN)      Decrement High Key Entry Position
         BRU   LVSM5500            Loop for Each Summary Entry in Pass
LVSM5700 DS    0H
         LA    R2,SPLSUMLN(,R2)    Next Low Key Summary Entry to Check
         LA    R6,SPLSUMLN(,R6)    Next High Key Summary Entry to Check
         LG    R8,LVMSPEND         Get Ending Address of Summary Area
         CGR   R6,R8               Past End of Last Entry in Summary?
         BRL   LVSM5500            No  => Then Loop to Check Next Entry
LVSM5800 DS    0H
         SRAG  R1,R1,1 bit         Divide By 2 for Next Pass Thru Area
         BRNZ  LVSM5400            Non-Zero? Then Begin the Next Pass
         DROP  HI,LO               Remove as SP Summary Entry Base Regs
*
*+-------------------------------------------------------------------+*
*| Now Write the Header Lines for the Subpool Summary Report to the  |*
*| Output Buffer Area.                                               |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*|Private Area Subpools Allocated: Owned by Task - Acquired by GETMAI|*
*| SP-Key  Allocated   Free Space  Allocated   Free Space    Allocate|*
*|         Areas-DQE   Areas-FQE   Below 16M   Below 16M   Above 16M |*
*+-------------------------------------------------------------------+*
*
LVSM6000 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH201)     Point to Header for Subpool Summary
         MVC   0(L'PVTMH201,RLINE),0(R1) Move in the Detail Line Header
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
LVSM6100 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set the Address of Output Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,5(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH202)     Point to Header for Subpool Summary
         MVC   0(L'PVTMH202,RLINE),0(R1) Move in the Detail Line Header
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
LVSM6200 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set the Address of Output Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,5(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH203)     Point to Header for Subpool Summary
         MVC   0(L'PVTMH203,RLINE),0(R1) Move in the Detail Line Header
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
LVSM6300 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
*
*+-------------------------------------------------------------------+*
*| Write a Detail Line for the Specific Subpool Id and Storage Key   |*
*| in the SubPool Summary Report to the Output Buffer Area. Then Loop|*
*| to Process the Next Detail Line for the Next Subpool Id and       |*
*| Storage Key.                                                      |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*|Private Area Subpools Allocated: Owned by Task - Acquired by GETMAI|*
*| SP-Key  Allocated   Free Space  Allocated   Free Space    Allocate|*
*|         Areas-DQE   Areas-FQE   Below 16M   Below 16M   Above 16M |*
*|003-8   3,968       1           475,136     2,872       352,239,616|*
*|004-8   500         500         0           0           2,048,000  |*
*|005-8   500         500         0           0           2,048,000  |*
*|229-5   2           2           0           0           12,288     |*
*|230-0   1           1           4,096       760         0          |*
*|230-5   3           7           8,192       7,232       4,096      |*
*|230-8   1           1           0           0           4,096      |*
*|251-8   2           2           0           0           200,704    |*
*| |                                                                 |*
*| +--Subpool Id and Storage Key                                     |*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
LVSM7000 DS    0H
         LG    R7,LVMSUMM@         Get Addr of Subpool Summary Wrk Area
         LG    R8,LVMSUMCT         Get Entry Count for SP Summary Area
         XC    LVMALLOC(LVMACCUM),LVMALLOC Clear the Accumulator Fields
         USING SPLSUMM@,R7         Addressability Subpool Summary Entry
SSR      USING SSRLINE$,RLINE      Establish Addressability to Work Lne
LVSM7100 DS    0H
         LA    RLINE,LNE.LGWOLINE  Set the Address of Output Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,5(R15,RLINE)  Increment for the Indention Level
         LLGC  R0,SPLSPNUM         Get the Binary Subpool Id
         CVD   R0,LVMWORK2         Decimal Version of Subpool Id
         OI    LVMWORK2+7,15       Certify Sign To Make It Displayable
         UNPK  SSR.SSRPOOL#,LVMWORK2+6(2) ...Subpool Id to Report Line
         MVI   SSR.SSRSEPAR,C'-'   Insert Hyphen as Separator Character
LVSM7200 DS    0H
         LLGC  R0,SPLSPKEY         Get Storage Protect Key + Flag Byte
         SRLG  R0,R0,4             Push Off Flag Bits So Just the Key
         CVD   R0,LVMWORK2         Convert Storage Key Value to Decimal
         LA    R1,LVMFORC1         Preload 1st Forced Result Location
         MVC   LVMWRK08,PATTERN    Copy in the Number Editing Pattern
         EDMK  LVMWRK08,LVMWORK2+4 Edit Storage Key Value to Character
         LA    R14,LVMWRK08+L'LVMWRK08-1 Point to End of Edit Work Area
         SGR   R14,R1              Calculate Leng of Storage Key Value
         MVC   SSR.SSRPTKEY(*-*),0(R1) Indicated Target of the Execute
         EX    R14,*-6             Storage Protect Key to Output Line
LVSM7300 DS    0H
         LLGF  R1,SPLALLOC         Number of Allocated Storage Areas
         LG    R2,LVMALLOC         Get Allocated Areas Accumulator Cnt
         ALGR  R2,R1               Add the Current Count to Accumulator
         STG   R2,LVMALLOC         Save the Allocated Areas Accum Count
         CVDG  R1,LVMSPWRK         Binary Number of Areas to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Allocated Areas to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Areas Number
         MVC   SSR.SSRALLO#(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Copy No. of Allocated Areas to Line
LVSM7400 DS    0H
         LLGF  R1,SPLFREEA         Number of Free Space Areas
         LG    R2,LVMFREEA         Get Free Space Areas Accumulator Cnt
         ALGR  R2,R1               Add the Current Count to Accumulator
         STG   R2,LVMFREEA         Save Free Space Areas Accum Count
         CVDG  R1,LVMSPWRK         Binary Number of Areas to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Free Space Areas to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Areas Number
         MVC   SSR.SSRFREE#(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Copy No. of Free Space Areas to Line
LVSM7500 DS    0H
         LLGF  R1,SPL24ALC         Number of Allocated Bytes Below 16M
         LG    R2,LVM24ALC         Get Allocated Bytes <16M Accumulator
         ALGR  R2,R1               Add the Current Count to Accumulator
         STG   R2,LVM24ALC         Save Allocated Bytes <16M Accum Cnt
         CVDG  R1,LVMSPWRK         Binary Number of Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Below 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRALC24(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Copy No. Bytes Below 16M to Line
LVSM7600 DS    0H
         LLGF  R1,SPL24FRE         Number of Free Space Bytes Below 16M
         LG    R2,LVM24FRE         Get Free Spce Bytes <16M Accumulator
         ALGR  R2,R1               Add the Current Count to Accumulator
         STG   R2,LVM24FRE         Save Free Space Bytes <16M Accum Cnt
         CVDG  R1,LVMSPWRK         Binary No. of Free Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Below 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRFRE24(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Copy No. of Free Bytes Below 16M
LVSM7700 DS    0H
         LLGF  R1,SPL31ALC         Number of Allocated Bytes Above 16M
         LG    R2,LVM31ALC         Get Allocated Bytes >16M Accumulator
         ALGR  R2,R1               Add the Current Count to Accumulator
         STG   R2,LVM31ALC         Save Allocated Bytes >16M Accum Cnt
         CVDG  R1,LVMSPWRK         Binary No. of Alloc Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Above 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRALC31(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Cpy No. of Allocated Bytes Above 16M
LVSM7800 DS    0H
         LLGF  R1,SPL31FRE         Number of Free Space Bytes Above 16M
         LG    R2,LVM31FRE         Get Free Spce Bytes >16M Accumulator
         ALGR  R2,R1               Add the Current Count to Accumulator
         STG   R2,LVM31FRE         Save Free Space Bytes >16M Accum Cnt
         CVDG  R1,LVMSPWRK         Binary No. of Free Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Above 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRFRE31(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             No. of Free Space Bytes Above 16M
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
LVSM7900 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    R7,SPLSUMLN(,R7)    Bump to Next Subpool Summary Entry
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process the Next Detail Line for the Next Subpool Id|*
*+-------------------------------------------------------------------+*
*
LVSM8000 DS    0H
         CGHI  R4,(LGW$LNE#)       Exceeded Max Line Count in Buffer?
         BRL   LVSM8100            No  => Branch If Buffer Available
         LA    R15,8               Indicate Buffer Full,Prepare to Exit
         BRU   LVSMEXIT            Branch to Exit This Routine
LVSM8100 DS    0H
         BRCTG R8,LVSM7100         Loop to Process the Next Sub Pool ID
*
*+-------------------------------------------------------------------+*
*| Write the Total Line for the Subpool Summary Report to the Output |*
*| Buffer Area. This will Show the Totals for All Subpools Combined. |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*|        ----------  ----------  ----------  ----------  -----------|*
*|Totals  4,977       1,014       487,424     10,864      356,556,800|*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
LVSM8200 DS    0H
         LA    RLINE,LNE.LGWOLINE+5 ...Readdress Position in Print Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,0(R15,RLINE)  Increment for the Indention Level
         LLGT  R1,=A(PVTMH204)     Point to Separator Line for Totals
         MVC   0(L'PVTMH204,RLINE),0(R1) Move in Totals Separator Line
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
LVSM8300 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         LA    RLINE,LNE.LGWOLINE  Set the Address of Output Line
         LG    R15,LVMODENT        Get Addr to Current Indentation Levl
         LLGC  R15,0(,R15)         Obtain the Current Indention Level
         LA    RLINE,5(R15,RLINE)  Increment for the Indention Level
         MVC   SSR.SSRSUBPL,=CL6'Totals' Set Detail Line Indentifier
LVSM8400 DS    0H
         LG    R1,LVMALLOC         Get Allocated Areas Accumulator Cnt
         CVDG  R1,LVMSPWRK         Binary Number of Areas to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Allocated Areas to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Areas Number
         MVC   SSR.SSRALLO#(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Copy Total No. of Allocated Areas
LVSM8500 DS    0H
         LG    R1,LVMFREEA         Get Free Space Areas Accumulator Cnt
         CVDG  R1,LVMSPWRK         Binary Number of Areas to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Free Space Areas to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Areas Number
         MVC   SSR.SSRFREE#(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Copy Total No. of Free Space Areas
LVSM8600 DS    0H
         LG    R1,LVM24ALC         Get Allocated Bytes <16M Accumulator
         CVDG  R1,LVMSPWRK         Total No. of Alloc Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Below 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRALC24(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Total No. of Allocated Bytes <16M
LVSM8700 DS    0H
         LG    R1,LVM24FRE         Get Free Spce Bytes <16M Accumulator
         CVDG  R1,LVMSPWRK         Total No. of Free Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Below 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRFRE24(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Total No. of Free Space Bytes <16M
LVSM8800 DS    0H
         LG    R1,LVM31ALC         Get Allocated Bytes >16M Accumulator
         CVDG  R1,LVMSPWRK         Total No. of Alloc Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Above 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRALC31(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Total No. of Allocated Bytes >16M
LVSM8900 DS    0H
         LG    R1,LVM31FRE         Get Free Spce Bytes >16M Accumulator
         CVDG  R1,LVMSPWRK         Total No. of Free Bytes to Decimal
         MVC   LVMSPSUM,PATTERN3   Copy in the Number Editing Pattern
         LA    R1,LVMFORC2         Load 1st Forced Result Char Location
         EDMK  LVMSPSUM,LVMSPWRK+9 Edit No. of Bytes Above 16M to Char
         LA    R15,LVMSPSUM+L'LVMSPSUM-1 Point to End of Edit Work Area
         SGR   R15,R1              Calculate Length of the Bytes Number
         MVC   SSR.SSRFRE31(*-*),0(R1) Indicated Target of the Execute
         EX    R15,*-6             Total No. of Free Space Bytes >16M
         MVI   LNE.LGWOLINE,C'+'   Indicate Data For This Log Point
LVSM9000 DS    0H
         LA    R3,L'LGWLINE(,R3)   Increment to Next Record Line Area
         LA    R4,1(,R4)           Increment the Current Line Count
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Prnt Line with Blanks
         MVC   LNE.LGWLINE+1(L'LGWLINE-1),LNE.LGWLINE  Propogate Blanks
         MVI   LNE.LGWCC,C' '      Set Carriage Control to Single Space
         STMG  R3,R4,LGWOPOSI      Save Line Position and Count in Buff
         SLGR  R15,R15             Indicate Successful Completion
         DROP  SSR,R5,R7           Remove Listed Registers as Base Regs
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
LVSMEXIT DS    0H
         ST    R15,LVMRETCD        Save Highest Return Code Generated
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         L     R15,LVMRETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
*
*+-------------------------------------------------------------------+*
*|             P r o g r a m   C o n t r o l   A r e a               |*
*+-------------------------------------------------------------------+*
*
LVM@PCA  DSECT ,                   Logger Program Control Area-(LCA)
LVM@EYEC DS    CL32                EyeCatcher for This RSECT's LCA Area
LVM$SAVE DS    26FD                Save Area
LVMWORKD DS    10D                 General Work Area
*
LVMLG2II DS    AD                  Addr of LGRWK2II Logger Service Area
LVMOPOSI DS    AD                  Current Lne Position in Outpt Buffer
LVMOCNTR DS    FD                  Current Line Count in Output Buffer
LVMODENT DS    AD                  Addr of Current Indentation Level
*
LVMALLOC DS    FD                  Accumulator for Allocated Areas
LVMFREEA DS    FD                  Accumulator for Free Space Areas
LVM24ALC DS    FD                  Accumulator for Allocated Bytes <16M
LVM24FRE DS    FD                  Accumulator for Free Spce Bytes <16M
LVM31ALC DS    FD                  Accumulator for Allocated Bytes >16M
LVM31FRE DS    FD                  Accumulator for Free Spce Bytes >16M
LVMACCUM EQU   *-LVMALLOC          Leng of Combined Accumulator Fields
*
LVMLNPNT DS    AD                  Save Current Line Position in Area
LVMSUMM@ DS    AD                  Starting Addr Subpool Summary Area
LVMSUMCT DS    FD                  Count of Entries in SP Summary Area
LVMRDAT@ DS    AD                  Start Addr of Returned Subpool Data
LVMRDATZ DS    AD                  Ending Addr of Returned Subpool Data
LVMTCBCT DS    FD                  TCB Count for Returned Subpool Data
LVMSPWR2 DS    FD                  Save Area for Highest Power of 2 Cnt
LVMSPEND DS    AD                  Addr of End of Last Entry in Summary
LVMRETCD DS    F                   Return Code for Sub Pool Summary
LVMWORK2 DS    2D                  General Work Area
LVMWRK08 DS    CL(L'PATTERN)       Work Area for Editing Decimal Values
LVMFORC1 EQU   *-1                 First Forced Result Char Location
LVMSPWRK DS    2D                  Subpool Summary Statistics Work Area
LVMSPSUM DS    CL(L'PATTERN3)      Work Area for Editing Decimal Values
LVMFORC2 EQU   *-1                 First Forced Result Char Location
LVM$LINE DS    CL133               Formatted Output Line Work Area
         DS    0D                  Ensure Boundary Ends On Doubleword
LVMPCALN EQU   *-LVM@PCA           Leng of Logger Program Control Area
         DROP  ,                   Remove All Listed Regs as Base Regs
*
***********************************************************************
*              End of Subpool Summary Report Processing               *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Program Control Area-(LCA)
RBASE1   EQU   12                  Program Base Register
RCOMM1   EQU   11                  Common Dynamic Area Base Register
RCOMM2   EQU   10                  Common Constants/Routines Base Reg
RLINE    EQU   6                   Current Position in Print Line
         USING COM#P3M6,RCOMM1     Constants&Routines Addressability
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M # P 3 M 6 |**************************
**************************+-----------------+**************************
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  P r o g r a m   C o n t r o l   C o m m o n   D a t a   A r e a  |*
*+-------------------------------------------------------------------+*
*
COM#P3M6 RSECT                     Program Control Section
COM#P3M6 AMODE &AMODE              Establish Addressing Mode
COM#P3M6 RMODE &RMODE              Establish Residence Mode
*
BLANKS   DC    CL256' '            Define Character String of Blanks
PATTERN  DC    XL8'4020202020202120'  Pattern for Editing
PATTERN2 DC    XL42'40206B2020206B2020206B2020206B2020206B2020206B20202X
               06B2020206B2020206B2020206B202120'   Pattern for Editing
PATTERN3 DC    XL18'40206B2020206B2020206B2020206B202120' .Edit Pattern
PVTMH100 DC    CL31'*Error Processing Private Area*'  ...Message Header
PVTMH101 DC    CL31'Private Area Storage Allocated:'  ...Message Header
PVTMH200 DC    CL31'*Error Processing Subpool List*'  ...Message Header
PVTMH201 DC    CL76'Private Area Subpools Allocated: Owned by Task - AcX
               quired by GETMAIN/STORAGE'
PVTMH202 DC    CL85' SP-Key  Allocated   Free Space  Allocated   Free SX
               pace    Allocated       Free Space'
PVTMH203 DC    CL87'         Areas-DQE   Areas-FQE   Below 16M   Below X
               16M   Above 16M Line  Above 16M Line'
PVTMH204 DC    CL87'         ----------  ----------  ----------  ------X
               ----  --------------  --------------'
*
DTLINELN EQU   100                 Indicate Detail Line Leng to Process
DTLFILLR EQU   18                  Indicate Detail Line Len to Next Hdr
DTLINE$1 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLSTYPE DC    CL5' '              Indicate Storage Typ of <16M or >16M
         DC    CL1' '              ..Filler
DTLHDR01 DC    CL7'In Use='        Header for Storage Currently in Use
DTLNFLD1 DC    CL(DTLFILLR)' '     ..Filler
         ORG   DTLNFLD1            Reset the Current Location Counter
DTL@USED DC    CL9' '              Detail Line Field for Current Use
DTLFILL1 DC    CL2' '              ..Filler
DTLHDR02 DC    CL7'Unused='        Header for Storage Area Remaining
         ORG   ,                   Reset the Current Location Counter
DTLNFLD2 DC    CL(DTLFILLR)' '     ..Filler
         ORG   DTLNFLD2            Reset the Current Location Counter
DTLRMAIN DC    CL9' '              Detail Line Field for Unused Storage
DTLFILL2 DC    CL3' '              ..Filler
DTLHDR03 DC    CL6'Limit='         Header for Maximum Storage Allowed
         ORG   ,                   Reset the Current Location Counter
DTLNFLD3 DC    CL(DTLFILLR)' '     ..Filler
         ORG   DTLNFLD3            Reset the Current Location Counter
DTLLIMIT DC    CL9' '              Detail Line Field for Max Storage
DTLFILL3 DC    CL3' '              ..Filler
DTLHDR04 DC    CL6'HighU='         Header for Storage High-Water Mark
         ORG   ,                   Reset the Current Location Counter
DTLNFLD4 DC    CL(DTLFILLR)' '     ..Filler
         ORG   DTLNFLD4            Reset the Current Location Counter
DTLHIUSE DC    CL9' '              Detail LIne Field for Hi-Water Mark
         ORG   ,                   Reset the Current Location Counter
         DC    CL(DTLINELN-(*-DTLINE$1))' ' ..Fill with Trailing Blanks
         ORG   ,                   Set Location Counter to End of Line
DTLINE$2 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLTYPM2 DC    CL5'>BAR:'          Indicate Storage Type of Above Bar
         DC    CL1' '              ..Filler
DTLHDR2A DC    CL10'Allocated='    Header for Large Storage Allocated
DTL@ALLO DS    CL(L'STGALC6C)      Detail Line Field for Allocated
DTLHDR2B DC    CL13'Guard Amount=' Header for Storage Area Guarded
DTLGUARD DS    CL(L'STGUAR6C)      Detail Lne Field for Guarded Storage
         DC    CL(DTLINELN-(*-DTLINE$2))' ' ..Fill with Trailing Blanks
DTLINE$3 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLTYPM3 DC    CL5'>BAR:'          Indicate Storage Type of Above Bar
         DC    CL1' '              ..Filler
DTLHDR3A DC    CL10'Pvt Used ='    Header for Large Storage Useable
DTL@USE$ DS    CL(L'STGUSE6C)      Detail Line Field for Allocated
DTLHDR3B DC    CL13'Pvt Hi-Water=' Header for Large Storage High-Water
DTLHIWTR DS    CL(L'STGUHI6C)      Detail Lne Field for High-Water Mark
         DC    CL(DTLINELN-(*-DTLINE$3))' ' ..Fill with Trailing Blanks
DTLINE$4 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLTYPM4 DC    CL5'>BAR:'          Indicate Storage Type of Above Bar
         DC    CL1' '              ..Filler
DTLHDR4A DC    CL10'Pvt Obj  ='    Header for Private Storage Objects
DTL@OBJT DS    CL(L'STG#MO6C)      Detail Line Field for No. of Objects
DTLHDR4B DC    CL13'Shr Objects =' Header for Shared Large Storage Obj
DTL@SOBJ DS    CL(L'STG#SO6C)      Detail Line Field for Shared Objects
         DC    CL(DTLINELN-(*-DTLINE$4))' ' ..Fill with Trailing Blanks
DTLINE$5 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLTYPM5 DC    CL5'>BAR:'          Indicate Storage Type of Above Bar
         DC    CL1' '              ..Filler
DTLHDR5A DC    CL10'Shr Alloc='    Header for Shared Large Storage
DTLSHALC DS    CL(L'STGSHR6C)      Detail Line Field for Shared Alloc
DTLHDR5B DC    CL13'Shr Hi-Water=' Header for Large Storage High-Water
DTLSHRHI DS    CL(L'STGSHI6C)      Detail Lne Field for Shared Hi-Water
         DC    CL(DTLINELN-(*-DTLINE$5))' ' ..Fill with Trailing Blanks

DTLINE$6 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLTYPM6 DC    CL5'>BAR:'          Indicate Storage Type of Above Bar
         DC    CL1' '              ..Filler
DTLHDR6A DC    CL10'Com Alloc='    Header for Common Large Storage
DTLCMALC DS    CL(L'STGCOM6C)      Detail Line Field for Common Alloc
DTLHDR6B DC    CL13'Com Hi-Water=' Header for Common Storage High-Water
DTLCOMHI DS    CL(L'STGCHI6C)      Detail Lne Field for Common Hi-Water
         DC    CL(DTLINELN-(*-DTLINE$6))' ' ..Fill with Trailing Blanks

DTLINE$7 DS    0CL(DTLINELN)       Start of Storage Use Detail Line
         DC    CL1' '              ..Filler
DTLTYPM7 DC    CL5'>BAR:'          Indicate Storage Type of Above Bar
         DC    CL1' '              ..Filler
DTLHDR7A DC    CL10'Com Obj  ='    Header for Common Storage Objects
DTL@COBT DS    CL(L'STG#CO6C)      Detail Line Field for No. of Objects
DTLHDR7B DC    CL13'Large Pages =' Header for Large Page Count
DTL@LOBJ DS    CL(L'STG#SO6C)      Detail Line Field for Large Pages
         DC    CL(DTLINELN-(*-DTLINE$7))' ' ..Fill with Trailing Blanks
         EJECT ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|         S t o r a g e   C h e c k   L i s t   E n t r y           |*
*+-------------------------------------------------------------------+*
*
STGPRVT@ DSECT ,                   Storage Check List Table Entry
STGUAL24 DS    FD                  Save Area for Below 16M Used
STGURM24 DS    FD                  Save Area for Below 16M Remaining
STGLIM24 DS    FD                  Save Area for Below 16M Limit
STGUHI24 DS    FD                  Save Area for Below 16M Hi-Water
STG24NUM EQU   (*-STGUAL24)/L'STGUAL24  No. of User Storage Tbl Entries
*
STGUAL31 DS    FD                  Save Area for Above 16M Used
STGURM31 DS    FD                  Save Area for Above 16M Remaining
STGLIM31 DS    FD                  Save Area for Above 16M Limit
STGUHI31 DS    FD                  Save Area for Above 16M Hi-Water
STG31NUM EQU   (*-STGUAL31)/L'STGUAL31  No. of User Storage Tbl Entries
*
STGSQMMS DS    AD                  Save Area Addr SP MSS Queue Element
STGSQSWA DS    AD                  Save Area Addr SP SWA Queue Element
STGSQUKY DS    AD                  Save Area Addr SP User Key Element
STGSQNUM EQU   (*-STGSQMMS)/L'STGSQMMS  No. of SP Queue Element Entries
*
STGALC64 DS    FD                  Private Memory Object Bytes Alloc
STGUSE64 DS    FD                  Private Memory Object Bytes Useable
STGUAR64 DS    FD                  Private Memory Object Bytes Guarded
STGUHI64 DS    FD                  Private Memory Objects Hi-Water Mark
STGSHR64 DS    FD                  Shared Memory Object Bytes Allocated
STGSHI64 DS    FD                  Shared Memory Object Bytes Hi-Water
STGCOM64 DS    FD                  Common Memory Object Bytes Allocated
STGCHI64 DS    FD                  Common Memory Object Bytes Hi-Water
STG64NUM EQU   (*-STGALC64)/L'STGALC64  No. of User Storage Tbl Entries
*
STG#MO64 DS    FD                  Private Above-the-Bar Memory Objects
STG#SO64 DS    FD                  Shared Above-the-Bar Memory Objects
STG#CO64 DS    FD                  Common Above-the-Bar Memory Objects
STG#LO64 DS    FD                  Large Pages Owned by Address Space
*
STGALC6C DS    CL30                Private Large Virtual Area Allocated
STGUSE6C DS    CL30                Private Large Virtual Area Useable
STGUAR6C DS    CL30                Private Large Virtual Area Guarded
STGUHI6C DS    CL30                Private Large Virtual Area Hi-Water
STGSHR6C DS    CL30                Shared Large Virtual Area Allocated
STGSHI6C DS    CL30                Shared Large Virtual Area Hi-Water
STGCOM6C DS    CL30                Common Large Virtual Area Allocated
STGCHI6C DS    CL30                Common Large Virtual Area Hi-Water
STG#MO6C DS    CL30                Private Above-the-Bar Objects Count
STG#SO6C DS    CL30                Shared Above-the-Bar Objects Count
STG#CO6C DS    CL30                Common Above-the-Bar Objects Count
STG#LO6C DS    CL30                Count for Large Pages Owned by ASID
STGLEN6C EQU   *-STGALC6C          Length of Large Memmory Char Table
STG6CNUM EQU   (STGLEN6C)/L'STGALC6C  No. of User Storage Tbl Entries
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|       O u t p u t   R e p o r t   D e t a i l   L i n e s         |*
*+-------------------------------------------------------------------+*
*
RPTLINE$ DSECT ,                   Storage Check List Table Entry
RPTLNELN EQU   100                 Indicate Detail Line Leng to Process
RPTFILLR EQU   18                  Indicate Detail Line Len to Next Hdr
RPTLNE$1 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTSTYPE DS    CL5                 Indicate Storage Typ of <16M or >16M
         DS    CL1                 ..Filler
RPTHDR01 DS    CL7                 Header for Storage Currently in Use
RPTNFLD1 DS    CL(RPTFILLR)        ..Filler
         ORG   RPTNFLD1            Reset the Current Location Counter
RPT@USED DS    CL9                 Detail Line Field for Current Use
RPTFILL1 DS    CL2                 ..Filler
RPTHDR02 DS    CL7                 Header for Storage Area Remaining
         ORG   ,                   Reset the Current Location Counter
RPTNFLD2 DS    CL(RPTFILLR)        ..Filler
         ORG   RPTNFLD2            Reset the Current Location Counter
RPTRMAIN DS    CL9                 Detail Line Field for Unused Storage
RPTFILL2 DS    CL3                 ..Filler
RPTHDR03 DS    CL6                 Header for Maximum Storage Allowed
         ORG   ,                   Reset the Current Location Counter
RPTNFLD3 DS    CL(RPTFILLR)        ..Filler
         ORG   RPTNFLD3            Reset the Current Location Counter
RPTLIMIT DS    CL9                 Detail Line Field for Max Storage
RPTFILL3 DS    CL3                 ..Filler
RPTHDR04 DS    CL6                 Header for Storage High-Water Mark
         ORG   ,                   Reset the Current Location Counter
RPTNFLD4 DS    CL(RPTFILLR)        ..Filler
         ORG   RPTNFLD4            Reset the Current Location Counter
RPTHIUSE DS    CL9                 Detail LIne Field for Hi-Water Mark
         ORG   ,                   Reset the Current Location Counter
         DS    CL(RPTLNELN-(*-RPTLNE$1))    ..Fill with Trailing Blanks
         ORG   ,                   Set Location Counter to End of Line
RPTLNE$2 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTTYPM2 DS    CL5                 Indicate Storage Type of Above Bar
         DS    CL1                 ..Filler
RPTHDR2A DS    CL10                Header for Large Storage Allocated
RPT@ALLO DS    CL(L'STGALC6C)      Detail Line Field for Allocated
RPTHDR2B DS    CL13                Header for Storage Area Guarded
RPTGUARD DS    CL(L'STGUAR6C)      Detail Lne Field for Guarded Storage
         DS    CL(RPTLNELN-(*-RPTLNE$2))   ...Filler for End of Line
RPTLNE$3 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTTYPM3 DS    CL5                 Indicate Storage Type of Above Bar
         DS    CL1                 ..Filler
RPTHDR3A DS    CL10                Header for Large Storage Useable
RPT@USE$ DS    CL(L'STGUSE6C)      Detail Line Field for Allocated
RPTHDR3B DS    CL13                Header for Large Storage High-Water
RPTHIWTR DS    CL(L'STGUHI6C)      Detail Lne Field for High-Water Mark
         DS    CL(RPTLNELN-(*-RPTLNE$3))   ...Filler for End of Line
RPTLNE$4 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTTYPM4 DS    CL5                 Indicate Storage Type of Above Bar
         DS    CL1                 ..Filler
RPTHDR4A DS    CL10                Header for Large Storage Objects
RPT@OBJT DS    CL(L'STG#MO6C)      Detail Line Field for No. of Objects
RPTHDR4B DS    CL13                Header for Shared Large Storage Obj
RPT@SOBJ DS    CL(L'STG#SO6C)      Detail Line Field for Shared Objects
         DS    CL(RPTLNELN-(*-RPTLNE$4))  ...Filler for End of Line
RPTLNE$5 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTTYPM5 DS    CL5                 Indicate Storage Type of Above Bar
         DS    CL1                 ..Filler
RPTHDR5A DS    CL10                Header for Shared Large Storage
RPTSHALC DS    CL(L'STGSHR6C)      Detail Line Field for Shared Alloc
RPTHDR5B DS    CL13                Header for Large Storage High-Water
RPTSHRHI DS    CL(L'STGSHI6C)      Detail Lne Field for Shared Hi-Water
         DS    CL(RPTLNELN-(*-RPTLNE$5))  ...Filler for End of Line
RPTLNE$6 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTTYPM6 DS    CL5                 Indicate Storage Type of Above Bar
         DS    CL1                 ..Filler
RPTHDR6A DS    CL10                Header for Common Objects Storage
RPTCMALC DS    CL(L'STGCOM6C)      Detail Line Field for Common Alloc
RPTHDR6B DS    CL13                Header for Common Objects High-Water
RPTCOMHI DS    CL(L'STGCHI6C)      Detail Lne Field for Common Hi-Water
         DS    CL(RPTLNELN-(*-RPTLNE$6))  ...Filler for End of Line
RPTLNE$7 DS    0CL(RPTLNELN)       Start of Storage Use Detail Line
         DS    CL1                 ..Filler
RPTTYPM7 DS    CL5                 Indicate Storage Type of Above Bar
         DS    CL1                 ..Filler
RPTHDR7A DS    CL10                Header for Common Storage Objects
RPTCOBJT DS    CL(L'STG#CO6C)      Detail Line Field for No. of Objects
RPTHDR7B DS    CL13                Header for Large Storage Pages
RPTLGPGE DS    CL(L'STG#SO6C)      Detail Line Field for Large Pages
         DS    CL(RPTLNELN-(*-RPTLNE$7))  ...Filler for End of Line
*
*+-------------------------------------------------------------------+*
*|       S u b   P o o l   S u m m a r y   L i s t   E n t r y       |*
*+-------------------------------------------------------------------+*
*
SPLSUMM@ DSECT ,                   Sub Pool Summary List Table Entry
SPLSPNUM DS    AL1                 Sub Pool Number
SPLSPKEY DS    AL1                 Sub Pool Storage Protection Key
SPLSPFLG DS    H                   Sub Pool Flags
SPLALLOC DS    F                   Number of Allocated Storage Areas
SPLFREEA DS    F                   Number of Free Space Areas
SPL24ALC DS    F                   Number of Allocated Bytes Below 16M
SPL24FRE DS    F                   Number of Free Space Bytes Below 16M
SPL31ALC DS    F                   Number of Allocated Bytes Above 16M
SPL31FRE DS    F                   Number of Free Space Bytes Above 16M
SPLSUMLN EQU   *-SPLSUMM@          Length of Subpool Summary List Entry
*
*+-------------------------------------------------------------------+*
*|S u b p o o l   S u m m a r y   R e p o r t   D e t a i l   L i n e|*
*+-------------------------------------------------------------------+*
*
SSRLINE$ DSECT ,                   Subpool Summary Report Detail Line
SSRLNELN EQU   100                 Indicate Detail Line Leng to Process
SSRDLINE DS    0CL(SSRLNELN)       Start of Subpool Summary Detail Line
         DS    CL1                 ..Filler
SSRSUBPL DS    0CL6                Subpool Id and Storage Protect Key
SSRPOOL# DS    CL3                 Subpool Identifier
SSRSEPAR DS    CL1                 Separator Character Between Pool/Key
SSRPTKEY DS    CL2                 Storage Protect Key
SSRFILL1 DS    CL2                 ..Filler
SSRALLO# DS    CL10                Number of Allocated Areas in Subpool
SSRFILL2 DS    CL2                 ..Filler
SSRFREE# DS    CL10                Number of Free Areas in Subpool
SSRFILL3 DS    CL2                 ..Filler
SSRALC24 DS    CL10                Allocated Bytes in SP Below the Line
SSRFILL4 DS    CL2                 ..Filler
SSRFRE24 DS    CL10                Free Space Bytes in SP Below the Lne
SSRFILL5 DS    CL2                 ..Filler
SSRALC31 DS    CL14                Allocated Bytes in SP Above the Line
SSRFILL6 DS    CL2                 ..Filler
SSRFRE31 DS    CL14                Free Space Bytes in SP Above the Lne
         DS    CL(SSRLNELN-(*-SSRDLINE))  ...Filler for End of Line
*
*+-------------------------------------------------------------------+*
*|         L o g g e r   S e r v i c e   W o r k   A r e a           |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|     L o g g e r   C o n t r o l   A r e a   M a p   -   (LCA )    |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
STGLRCE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|               z / O S   S y s t e m   D s e c t s                 |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         CVT      DSECT=YES,LIST=YES  Communications Vector Table
         IHAPSA   LIST=YES         Prefix Storage Area
         IHAASCB  DSECT=YES,LIST=YES  Address Space Control Block
         IKJTCB   LIST=YES         Job Task Control Block
         DCBD     DSORG=PS,DEVD=DA Data Control Block
         IGVVSMD                   VSM Descriptors
         IHALDA                    VSM Local Data Area Control Block
         IHASPQE                   Sub-Pool Queue Element
         IHASPQA                   Sub-Pool Queue Element Anchors
         IHADQE                    Descriptor Queue Element
         IHAFQE                    Free Queue Element
         IHAFBQE                   Free Block Queue Element
         IARRAX                    RSM Address Space Block Extension
         END
