***********************************************************************
*LLL      GGGGGGG M     M H     H LLL      RRRRRRR  CCCCCCCC TTTTTTTTT*
* L       G     G MM   MM H     H  L       R      R C      C T   T   T*
* L       G       M M M M H     H  L       R      R C            T    *
* L       G  GGGG M  M  M HHHHHHH  L       RRRRRRR  C            T    *
* L       G     G M     M H     H  L       R    R   C            T    *
* L       G     G M     M H     H  L       R     R  C      C     T    *
* LLLLLLL GGGGGGG M     M H     H  LLLLLLL R      R CCCCCCCC     T    *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHLRCT                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Termination Program                *
*                                                                     *
* INPUT REGS:      R1  => Standard O/S Parameter List                 *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* CALLING PROGRAM: User Program                                       *
*                                                                     *
* CALLED PROGRAMS: LGMHLRCB - Logger Services Log Record Program for  *
*                             Buffering Records Above-the-Line        *
*                  LGMHLB64 - Logger Services Log Record Program for  *
*                             Buffering Records Above-the-Bar         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return address                                *
*                  R13, (LCA) Savearea & Dynamic Area                 *
*                  R12, (RBASE1) Program Base Register                *
*                  R11, (RBASE2) Program Base Register                *
*                  R10, (RCOMM1) Common Dynamic Area                  *
*                  R9,  (RCOMM2) Common Constants/Routines            *
*                  R8,  (RLGW) LGRWK2II Logger Service Work Area      *
*                  R7,  (RPGM) PGMLG2II Program Names List Table Area *
*                  R0-R6, General Work registers                      *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Change   V1R1M17 20120721 To Support Processing of Log Records @@KHF*
*                           Residing in Above-the-Bar Storage.   @@KHF*
* Update   V1R1M16 20120127 Update VV.RR.MM stats for Fix Pack 16@@KHF*
* Fix      V1R1M15 20110930 Wrapped PUTs with SYSSTATE AMODE64=NO@@KHF*
*                           /YES Sequence to Conform to New DFSMS@@KHF*
*                           Macro Changes Introduced in zOS V1R13@@KHF*
*                           That Test for the Sysstate Amode.    @@KHF*
* Update   V1R1M14 20110423 Update VV.RR.MM stats for Fix Pack 14@@KHF*
* Update   V1R1M13 20110108 Update VV.RR.MM stats for Fix Pack 13@@KHF*
* Update   V1R1M12 20100306 Update VV.RR.MM stats for Fix Pack 12@@KHF*
* Update   V1R1M11 20091023 Update VV.RR.MM stats for Fix Pack 11@@KHF*
* Update   V1R1M10 20090523 Update VV.RR.MM stats for Fix Pack 10@@KHF*
* Update   V1R1M09 20090110 Updated VV.RR.MM stats for Fix Pack 9@@KHF*
* Update   V1R1M08 20081010 Updated VV.RR.MM stats for Fix Pack 8@@KHF*
* Update   V1R1M07 20080524 Updated VV.RR.MM stats for Fix Pack 7@@KHF*
* Add      V1R1M06 20080223 Added Job Step CPU/SRB Time Used Info@@KHF*
* Fix      V1R1M05 20080112 Incorrect Ordinal Day When a Leap Yr @@KHF*
* Update   V1R1M04 20071104 Updated VV.RR.MM stats for Fix Pack 4@@KHF*
* Update   V1R1M03 20070701 Updated VV.RR.MM stats for Fix Pack 3@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Add Support For Log Rcrd Trim Option @@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Program
         LCLC  &RMODE              Resident Mode of Program
&KXHVER  SETC  'V1'                Indicate the Program Version Number
&KXHREL  SETC  'R1'                Indicate the Program Release Number
&KXHMOD  SETC  'M17'               Indicate the Pgm Modification Level
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
         COPY  LGCPLOGR            Logger Services Source-Setup CopyBk
&MODID   SETC  'LGMHLRCT'          Set the Program Module Identifier
RPDX     EQU   6                   Logger Buffer Primary Index Block
RSDX     EQU   5                   Logger Buffer Secondary Index Block
REDB     EQU   4                   Logger Buffer Record Data Block
         EJECT  ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHLRCT - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHLRCT                                           *
*                                                                     *
* FUNCTION:        Program Logger Termination Services                *
*                                                                     *
*                  This routine is the main driver and entry point    *
*                  for processing the termination for program logger  *
*                  processing.                                        *
*                                                                     *
*                  Upon normal end of a user program this program is  *
*                  called to perform termination processing. Upon     *
*                  termination, this program removes the Logger       *
*                  ESTAEX, prints the contents of the log record      *
*                  buffers to the output data set //LGRECOUT if       *
*                  LOG=BUFR or LOG=BUF64 was specified, releases any  *
*                  log record buffers which were acquired by LGMHLRCB *
*                  or LGMHLB64, processes the CPU time and SRB time   *
*                  time used, prints the log record output trailer    *
*                  records, closes the //LGRECOUT output data set, and*
*                  releases the storage areas originally acquired by  *
*                  Logger Services program LGMHLRCI. When done, this  *
*                  program will exit and return to the user program   *
*                  for completion of normal termination.              *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
***********************************************************************
*
LGMHLRCT LPGMNTRY TYPE=MAIN,       Define As A Main Program Entry      X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               STORAGE=16,         Define LCA Stacked Storage Size     X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LCAPFX=LNX,         Establish LCA Prefix for This RSECT X
               COPY@RT=YES         To Generate a Copyright Statement
*
*+-------------------------------------------------------------------+*
*|                    Setup a Work Area                              |*
*+-------------------------------------------------------------------+*
*
TLNX0100 DS    0H
         LLILL R2,(LXALNGTH)       Get the Length of Common Area
         LGR   R0,R2               Pass the Length to R0
       STORAGE OBTAIN,             Get Dynamic Storage for Common Area X
               COND=YES,           Get Conditional on Available StorageX
               LENGTH=(R0),        Indicate Amount of Storage RequestedX
               ADDR=(R1),          Return Addr of Storage Area AcquiredX
               SP=3,               Task Owned,No Page-Fix,No Fetch ProtX
               CALLRKY=NO,         Key for Storage SP from Key of TCB  X
               CHECKZERO=YES,      Set RC for Area Received Was ClearedX
               BNDRY=DBLWD,        Alignment Is On Doubleword Boundary X
               LOC=(24,31)         Dynamic Area Anywhere Below the Line
         C     R15,=F'20'          Area Returned with Storage Cleared?
         BRE   TLNX0300            Yes => Branch to Init Logger Service
         C     R15,=F'0'           New Storage Successfully Acquired?
         BRE   TLNX0200            Yes => Branch to Init Logger Service
         LLGFR R2,R15              Preserve the Getmain Return Code
         BRU   TLNXRTRN            No  => Branch to Return to Caller
TLNX0200 DS    0H
         LLGFR R4,R1               Beginning Address of Area to Clear
         LLGFR R5,R2               Length of Common Area to Clear
         MVCLE R4,R14,0            RC on Successful Getmain has R15=0
TLNX0300 DS    0H
         USING LXA@PCA,RCOMM1      Common Program Area Addressability
         USING COM#U6H4,RCOMM2     Constants&Routines Addressability
         LGFR  RCOMM1,R1           Establish Common Work Area Address
         LLGT  RCOMM2,=A(COM#U6H4) Common Constants and Routines Area
         ST    R2,LXASAVEA         Let Length Show in Our Area
         ST    RCOMM1,LXASVCOM     Save Our Common Area Start Address
         LG    R2,(LNXS64BCK-LNXSAVE)(,R13) Caller's Save Area Address
         LLGF  R4,24(,R2)          Restore the Logging Services Request
         MVC   LXA@EYEC,=CL32'LGMHLRCT DYNAMIC AREA' Set the Eyecatcher
*
*+-------------------------------------------------------------------+*
*| Verify the Type of Request By the User Program for Logger Services|*
*+-------------------------------------------------------------------+*
*
TLNX0500 DS    0H
         LTGFR R4,R4               Is This Request For Termination
         BRNZ  TLNX1000            Yes => OK, Then Its for Termination
         BRU   TLNXRTRN            No  => Something Got Hosed, Exit
*
***********************************************************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|           Perform Logger Services Termination Processing          |*
*+-------------------------------------------------------------------+*
***********************************************************************
***********************************************************************
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|  Our logger event services created an ESTAEX environment during   |*
*|  initialization. At termination remove the ESTAEX prior to        |*
*|  returning to our respective caller. Next, check if logger records|*
*|  generated during program execution have been written to a buffer |*
*|  area to avoid log record I/O during execution. If yes, then take |*
*|  the logger records accumulated in the indexed buffer areas and   |*
*|  write these records to the output //LGRECOUT DCB. Then release   |*
*|  the storage areas used by logger services and exit.              |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
         USING LGRWK2II,RLGW       Setup LGRWK2II Area Addressability
         USING PGMLG2II,RPGM       Establish PGMLG2II Addressability
CALLER   USING LCALNX,R2           Setup Caller's LCA Addressability
LNE      USING LGWLINE,R6          Establish Addressability to Rcrd Lne
TLNX1000 DS    0H
         LLGT  RLGW,CALLER.LNXTRCDS ...LGRWK2II from Carry-Over Storage
         LLGF  R6,=A(LGWLINE-LGRWK2II) Index to Logger Record List Area
         LA    R6,0(R6,RLGW)       Point to the Logger Record Area
         ESTAEX 0                  Cancel ESTAEX Recovery Environment
TLNX1100 DS    0H
         USING IHADCB,LGWODCB      Establish Addressablity to the DCB
         TM    DCBOFLGS,DCBOFOPN   Is the LGRECOUT Output Dataset Open?
         BRZ   TLNX4800            No  => No Output to Write Loggr Rcds
         C     R4,=F'8'            Logger Output Already Been Printed?
         BRE   TLNX3300            Yes => Logger Records Not Buffered
*
*+-------------------------------------------------------------------+*
*| Obtain The Index Block Pointers to Logger Records in Buffer Areas |*
*+-------------------------------------------------------------------+*
*
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
TLNX1200 DS    0H
         LA    R3,LGWPINDX         Get Pointer to Primary Indx Blk Addr
         LG    RSDX,0(R3)          Get the Primary Index Block Address
         LTGR  RSDX,RSDX           There a Primary Index Block Address?
         BRZ   TLNX3300            No  => Branch to Print Trailer Rcrds
         PUSH  USING               Save Current Addressable Environment
         USING LOGPIBLK,RSDX       Establish Addressability to LOGPIBLK
         LG    R1,LOGPISIZ         Get Length of Primary Index Block
         SLGF  R1,=F'8'            To Point to the Next to Last Entry
         LA    RSDX,0(R1,RSDX)     Point to the Secondary Index Block
         LG    RSDX,0(,RSDX)       Get Pointer to Component Data Block
         POP   USING               Restore the Addressable Environment
*
*+-------------------------------------------------------------------+*
*|           Access The Logger Records In The Buffers                |*
*+-------------------------------------------------------------------+*
*
TLNX1300 DS    0H
         LG    R14,LOGSIFST        Get the Initial Index Entry Address
         LG    R15,LOGSICNT        Get Count of Entries in This Block
TLNX1400 DS    0H
         STMG  R14,R15,LNXSIPOS    Preserve the Current Index Positions
         LG    REDB,0(,R14)        Get the Logger Record Entry Pointer
         CLC   LOGTRCRD(L'BLANKS/2),BLANKS Current Record a Blank Line?
         BRNE  TLNX1500            No  => Check if Processing TCB/Clock
         MVC   LNE.LGWLINE,LOGTRCRD Loggr Rcrd from Buffr to Output Lne
         BRU   TLNX2600            Branch to Write Loggr Rcrd to Output
TLNX1500 DS    0H
         TM    CALLER.LNXWFLAG,LCAWTRIM Request to Trim Log Rcrd Outpt?
         BRZ   TLNX1600            No  => Branch to Process Time Stamp
         MVC   LNE.LGWLINE,LOGTRCRD Loggr Rcrd from Table to Output Lne
         BRU   TLNX2600            Bypass Time Stamp Suffix, Write Rcrd
*
*+-------------------------------------------------------------------+*
*| Get Current CPU Clock Time And Convert To A Julian Date And Time  |*
*+-------------------------------------------------------------------+*
*| The CPU clock time is in STCKE format. Previously the CPU clock   |*
*| time and TCB address of the executing task were acquired when     |*
*| logger service was entered in order to place a date and time      |*
*| stamp at the time the log event occurred. The CPU clock time and  |*
*| TCB address were placed in the prefix area of the user program's  |*
*| LCA. Then the STCKE TOD and TCB address were extracted from the   |*
*| LCA and placed in Logger Control Block LGRWK2II. The CPU clock    |*
*| time was used as the key in the insertion of the log record in    |*
*| the buffer area. For each input logger record we are getting the  |*
*| the CPU clock time from the buffer key, and converting the binary |*
*| clock time to a displayable format that will show up in the logger|*
*| record written from the buffer to the output data set.            |*
*|                                                                   |*
*| The 128-bit TOD Store Clock Extended (STCKE) is being used here   |*
*| to provide a date beyond the year 2042. The existing 64-bit TOD   |*
*| clock from STCK will wrap in the year 2042 (i.e., approximately   |*
*| 09/17/2042 @ 23:53:52.613376 - GMT). The additional bits added to |*
*| the STCKE format TOD time-stamp will provide support beyond the   |*
*| wrap date. Therefore, this routine will support dates beyond the  |*
*| year 2042 and beyond the year 2100.                               |*
*|                                                                   |*
*| The first part of this routine takes the STCKE Format 16-Byte     |*
*| (128-Bit) TOD value, and extracts the high-order 72-bit portion   |*
*| of the TOD into a R0/R1 even-odd grande register pair using       |*
*| z/Architecture 64-bit GPRs. Then the 72-bit TOD will be adjusted  |*
*| through the z/OS CVT (Communications  Vector Table) for Leap      |*
*| Seconds and the Local Time based on the CLOCKxx member of         |*
*| Parmlib, which member contains specifications for controlling     |*
*| z/OS time management (i.e., Sysplex Timer, Time Zones).           |*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
TLNX1600 DS    0H
         UNPK  LGW$TCB@(L'LGW$TCB@+1),LOGTRTCB(L'LOGTRTCB+1) ..TCB Addr
         TR    LGW$TCB@,HEXCONV-C'0' ...Translate Hex to Character
         MVI   LGW$SEP1,C' '       Insert Blank as a Field Separator
         LMG   R0,R1,LOGTRTIM      Extended CPU Clock Time of Log Event
         RLLG  R0,R0,8             Position the TOD +142yr Byte to Last
         SRDL  R0,8                Save TOD Byte to R1, Open Slot in R0
         RLLG  R1,R1,32            TOD 63-71 Bits to Bit Position 32
         SLDL  R0,8                TOD Bits 8-71 Now in R0 as 64-Bits
         SRLG  R1,R1,56            +142 Yr Byte to Build 0-71 Bit TOD
         XGR   R0,R1               Exchange Contents of TOD Registers
         XGR   R1,R0               R0 and R1 to Produce a STCKE 72-Bit
         XGR   R0,R1               Format TOD in Even/Odd Register Pair
TLNX1700 DS    0H
         LLGT  R15,CVTPTR          Absolute Address of Pointer to CVT
         LLGT  R15,CVTEXT2-CVT(,R15) ..Get Address of CVT 2nd Extention
         USING CVTXTNT2,R15        Set Addressability to CVT Extention
         SL    R1,CVTLSOL          Adjust the Low Word for Leap Seconds
         BRC   NOBORROW,TLNX1800   Then Branch If There is No Borrow
         LLIHL R14,1               Otherwise, Set to Indicate a Borrow
         SLGR  R1,R14              And Then Subtract for CVT High Word
         BRC   NOBORROW,TLNX1800   Then Branch If There is No Borrow
         SLGF  R0,=A(1)            Othewise, Then Borrow From High Word
TLNX1800 DS    0H
         LMD   R14,R14,CVTLSOH,CVT$ZTOK  Get CVT Hi Word Offset for TOD
         SLGR  R1,R14              Adjust CVT High Wrd for Leap Seconds
         AL    R1,CVTLDTOR         Adjust Low Word For Time Zone Diff
         BRC   NOCARRY,TLNX1900    And Branch If There Is No Carry
         LLIHL R14,1               Otherwise, Set to Indicate a Carry
         ALGR  R1,R14              And Then Add From the CVT High Word
         BRC   NOCARRY,TLNX1900    And Branch If There Is No New Carry
         AL    R0,=A(1)            Propogate Carry to the TOD High Byte
TLNX1900 DS    0H
         LMD   R14,R14,CVTLDTOL,CVT$ZTOK  Get High Word Time Zone Value
         ALGR  R1,R14              Now Adjust for High Word Time Zone
         DROP  R15                 Remove Listed Reg as CVT Ext Base
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Take the CVT Corrected 72-Bit Binary|*
*| Time Stamp, and Convert the Binary Seconds Portion of the TOD Down|*
*| to a Micosecond (1/1,000,000ths of a Second) With the Result      |*
*| Placed in Storage in Packed Decimal Format.                       |*
*+-------------------------------------------------------------------+*
*
TLNX2000 DS    0H
         SRDL  R0,8 Bits           Drop Last Byte/Put +142Yr Byte in R1
         RLL   R1,R1,8 Bits        +142Yr Byte at End of Low-Half of R1
         RLLG  R1,R1,56 Bits       Rotate to Get Back to Proper Format
         SRLG  R1,R1,17 Bits       Set Microseconds/2**13 (Since 1900)
         DLG   R0,=AD((60*60*24/128)*(1000000/64)) R1=Days R0=Microsecs
         LGR   R15,R1              Preserve the Calculated Elapsed Days
         SRDL  R0,32 Bits          Shift So R0/R1 = Microseconds/2**13
         SLLG  R1,R1,13 Bits       Shift So R0/R1 = Microseconds/2**1
         LLGF  R14,=A(60*60)       Indicate No. of Seconds in an Hour
         MSGF  R14,=A(1000000)     To Obtain Microseconds in an Hour
         SLGR  R0,R0               Clear for the Division Operation
         DLGR  R0,R14              Calculate Total Number of Hours
         CVD   R1,LNXWORKD+8       Create Decimal Version No. of Hours
         MVO   LNXWORKD+4(2),LNXWORKD+14(2) Get Hrs Without High Nibble
         SRDL  R0,32 bits          Prepare for Division to Get Minutes
         D     R0,=A(60*1000000)   Calculate Total Number of Minutes
         CVD   R1,LNXWORKD+8       Create Decimal Version No. of Mins
         MVO   LNXWORKD+5(2),LNXWORKD+14(2) Get Mins Without Hi Nibble
         SRDA  R0,32 bits          Prepare for Division to Get Seconds
         D     R0,=A(1000000)      Calculate the Total No. of Seconds
         CVD   R1,LNXWORKD+8       Create Decimal Version No. of Secnds
         MVO   LNXWORKD+6(2),LNXWORKD+14(2) Get Secnd Without Hi Nibble
         CVD   R0,LNXWORKD+8       Decimal Version for Microseconds
         SRP   LNXWORKD+12(4),1,0  Shift to Make Last Byte a Slack Byte
         MVC   LNXWORKD+7(4),LNXWORKD+12 ..Get Fractional Seconds Value
         OI    LNXWORKD+10,15      Certify Sign To Make It Displayable
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Process the Binary Date Portion Of  |*
*| the TOD Representing the Days (i.e., Completed days + Current Day)|*
*| Since the z/OS Epoch (01/01/1900), and Convert The Binary Days to |*
*| a Displayable Julian Date Format (i.e., Ordinal Date).            |*
*+-------------------------------------------------------------------+*
*
TLNX2100 DS    0H
         LGR   R1,R15              Get the Total Number of Elapsed Days
         CLGF  R1,=A(36525+1461+365) Leap Century+4yr Cycle+Non-Leap Yr
         BRNL  TLNX2300            Use Extended Date Processing for TOD
TLNX2200 DS    0H
         ALGF  R1,=A(1)            Calendars Start At Day 1, Not Day 0
         SLLG  R1,R1,2 Bits        Multiple Total Days by Factor of 4
         DSGF  R0,=A(4*365+1)      Divide by the No. of Days in 4 Years
         SRLG  R0,R0,2 Bits        Divide By 4 So Now R1=Year R0=Days
         ALGF  R0,=A(1)            Add 1 Since First Day Starts at 1
         LA    R15,1900(,R1)       Epoch + No. of Years into Century
         MGHI  R15,(1000)          Shift The Years to Align with Days
         ALGFR R15,R0              Add to Merge the Years and the Date
         CVD   R15,LNXWORKD+16     Create Decimal Version of the Date
         MVC   LNXWORKD(4),LNXWORKD+20 ...Save The Packed Julian Date
         OI    LNXWORKD+3,15       Certify Sign To Make It Displayable
         BRU   TLNX2500            Process TOD to a Character Format
TLNX2300 DS    0H
         ALGF  R1,=A(36524)        Add the Number of Days in a Century
         SLLG  R1,R1,2 Bits        Multiply Total Days by a Factor of 4
         DSGF  R0,=A(146097)       Days + Leap Century/Days in 400 Yrs
         BCTGR R1,R0               Equalize for the Leap Century Added
         LLGFR R14,R1              Save Elapsed Centuries Since 1900
         LLGFR R1,R0               Get No. of Days into Current Century
         DSGF  R0,=A(1461*4)       Divide by No. of Days in Leap Year
         LLGFR R15,R1              Save No. of Completed 4-Year Cycles
         LLGFR R1,R0               No. of Completed Days in 4-Yr Period
         DSGF  R0,=A(4)            Divide by 4 so Now R1 Has The Days
         DSGF  R0,=A(365)          Determine No. of Yrs into 4-Yr Cycle
         LTGR  R1,R1               Is this Year Currently a Leap Year?
         BRNZ  TLNX2400            No  => Then Set Calendar Start Day
         LLGFR R3,R14              Get the Elapsed Centuries Since 1900
         BCTGR R3,R0               Set the Century Code to Yr 2000 Base
         TMLL  R3,X'0003'          This a Leap Century (400 Year Rule)?
         BRNZ  TLNX2400            No  => Then Set Calendar Start Day
         ALGF  R0,=A(1)            Add a Day to Account for a Leap Year
TLNX2400 DS    0H
         ALGF  R0,=A(1)            Calendar Starts at Day 1, Not Day 0
         SLLG  R15,R15,2 Bits      Completed 4-Yr Cycles x 4 = Years
         ALGFR R1,R15              Add Years into Current 4-Year Cycle
         MGHI  R14,(100)           No. of Years for Completed Centuries
         LA    R1,1900(R14,R1)     Epoch + Century Yrs + Yrs in Century
         LLGFR R15,R1              Copy the Years to Setup an Alignment
         MGHI  R15,(1000)          Shift The Years to Align with Days
         ALGFR R15,R0              Add to Merge the Years and the Days
         CVD   R15,LNXWORKD+16     Create Decimal Version of the Date
         MVC   LNXWORKD(4),LNXWORKD+20 ...Save The Packed Julian Date
         OI    LNXWORKD+3,15       Certify Sign To Make It Displayable
*
*+-------------------------------------------------------------------+*
*| Place The TCB Address and Date/Time Stamp At The End Of The Logger|*
*| Record And Write The Logger Record To The //LGRECOUT Output Data  |*
*| Set.                                                              |*
*|   Example:                                                        |*
*|             0089B758  2011095-21:44:31.412352                     |*
*|                 |        |     |  |  |   |                        |*
*|                TCB    Ordinal Hrs | Sec  |                        |*
*|               Address  Date      Min     |                        |*
*|                                    To 1/1,000,000ths              |*
*|                                      of a Second                  |*
*+-------------------------------------------------------------------+*
*
TLNX2500 DS    0H
         UNPK  LGWJULDT(7),LNXWORKD(4) Julian Date to Character Format
         UNPK  LNXWORKD+20(13),LNXWORKD+4(7) ..TOD to Character Format
         MVC   LGWJULTM(12),LNXWORKD+20 ...Time of Day to Output Area
         MVI   LGW$SEP2,C'-'       Insert Date/Time Separator Character
         MVC   LGWDHOUR,LGWJULHH   Obtain Current Hour of the Day
         MVI   LGW$SEP3,C':'       Colon as Hour/Minute Separator
         MVC   LGWDMINS,LGWJULMM   Obtain Current Minute of the Hour
         MVI   LGW$SEP4,C':'       Colon as Minute/Seconds Separator
         MVC   LGWDSECD,LGWJULSS   Obtain Current Seconds of the Min
         MVI   LGW$SEP5,C'.'       Period as Fractional Scnds Separator
         MVC   LGWDSTTH,LGWJULTT   Set to '1/1,000,000ths' of a Second
         MVC   LNE.LGWLINE,LOGTRCRD Loggr Rcrd from Table to Output Lne
         MVC   LNE.LGWLINE+L'LNE.LGWLINE-LGWDMPLN(LGWDMPLN),LGW$TCB@
TLNX2600 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TLNX4300            No  => No Further Writes, Do Release
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,LNE.LGWLINE Print Logger Recrd From Buffer Area
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LMG   R14,R15,LNXSIPOS    Restore the Current Index Positions
         LA    R14,L'LOGSINDX(,R14) Bump to Next Recrd Pointer in Index
*
*+-------------------------------------------------------------------+*
*|       Loop Point for Each Logger Record in the Buffer Area        |*
*+-------------------------------------------------------------------+*
*
TLNX2700 DS    0H
         BRCTG R15,TLNX1400        => Loop to Process Next Logger Recrd
*
*+-------------------------------------------------------------------+*
*|      Loop Point for Each Logger Record Secondary Index Block      |*
*+-------------------------------------------------------------------+*
*
TLNX2800 DS    0H
         LG    RSDX,LOGSINXT       Get the Next Secondary Index Block
         LTGR  RSDX,RSDX           Have We Processed All Loggr Records?
         BRNZ  TLNX1300            No  => Loop to Process Next Record
*
*+-------------------------------------------------------------------+*
*|            Release Logger Records Buffer Storage Area             |*
*+-------------------------------------------------------------------+*
*
TLNX2900 DS    0H
         LA    R3,LGWPINDX         Get Pointer to Primary Indx Blk Addr
         LG    RSDX,0(,R3)         Get the Primary Index Block Address
         LTGR  RSDX,RSDX           There a Primary Index Block Address?
         BRZ   TLNX3300            No  => Finish Printing Trailer Rcrds
         TM    CALLER.LNXWFLAG,LCAWBUFR Log Rcd Buffers Above-the-Line?
         BRO   TLNX3000            Yes => Free Above-the-Line Storage
         TM    CALLER.LNXWFLAG,LCAWBU64 Log Rcrd Buffers Above-the-Bar?
         BRO   TLNX3100            Yes => Release Above-the-Bar Storage
         BRU   TLNX3300            No  => Branch to Print Rcrd Trailers
TLNX3000 DS    0H
         LLGT  R15,=A(LNXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   TLNX3200            Branch to Release Log Record Buffers
TLNX3100 DS    0H
         LLGT  R15,=A(LNXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
TLNX3200 DS    0H
         LLGF  R4,=A(X'7FFFFFFF')  Set High Value Indicator to Rcrd Cnt
         XC    LXAPLIST,LXAPLIST   Clear the Call Parameter List
         LGR   R2,R13              Preserve Current Save Area Address
         LA    R13,LNXSAVEG        Provide Save Area Stack for Program
         CALL  (15),               Process Release of Log Recd Buffers X
               (LGRWK2II,          ..Pass Pntr to Logger Service Area  X
               (R4)),              ..Pass Pntr to Input Loggr Rcd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LXAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Release Logger Recrds Buffer Storage
         LGR   R13,R2              Restore Current Save Area Address
*
*+-------------------------------------------------------------------+*
*|    All Logger Records Have Been Printed -  Now Print Trailers     |*
*+-------------------------------------------------------------------+*
*
TLNX3300 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ..Propogate
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TLNX4300            No  => No Further Writes, Do Release
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,LNE.LGWLINE Print a Blank Line as Separator
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         MVC   LNE.LGWOLINE(L'LGA01110),LGA01110 Successfull Completion
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TLNX4300            No  => No Further Writes, Do Release
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,LNE.LGWLINE Print the Job Completed Info Message
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|                  Process the Job Step CPU Time                    |*
*+-------------------------------------------------------------------+*
*
TLNX3400 DS    0H
         MVI   LNE.LGWLINE,C' '    Set-up to Fill Field with Blanks
         MVC   LNE.LGWLINE+1(L'LNE.LGWLINE-1),LNE.LGWLINE ...Propogate
         MVC   LNE.LGWLINE+3(13),=CL13'Job Step CPU:' ..Detail Line Hdr
         LA    R4,LNE.LGWLINE+17   Set Pointer in Print Output Wrk Line
         LLGT  R2,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pntr
         LG    R1,ASCBEJST-ASCB(,R2) Get the Elapsed Job Step CPU Time
         SRLG  R1,R1,13 Bits       Set Microseconds/2**13
         DSGF  R0,=A(1000000/100000/2)  Hundred-Thousanths of a Second
         DSGF  R0,=A(60*60*100000) Calculate No. of Accumlated CPU Hrs
         CVDG  R1,LNXWORKD         Binary CPU Hours Value to Decimal
         MVC   LNXCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LNXFORC1         Load 1st Forced Result Char Location
         EDMK  LNXCPUOT,LNXWORKD+12 Edit CPU Hours Value to Character
         LA    R15,LNXCPUOT+L'LNXCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of CPU Hours Used
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy CPU Hours Used to Output Area
         LA    R4,1(R15,R4)        Point to the End of CPU Hours Used
         MVC   0(2,R4),=CL2'HR'    Insert the CPU Hours Used Indicator
         LA    R4,3(,R4)           Increment to CPU Minutes Used Field
TLNX3500 DS    0H
         LGR   R1,R0               Prepare for Division to Get Minutes
         DSGF  R0,=A(60*100000)    Calculate Total Number of Minutes
         LGR   R14,R0              Preserve the Accumlated CPU Seconds
         CVDG  R1,LNXWORKD         Binary CPU Minutes Value to Decimal
         MVC   LNXCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LNXFORC1         Load 1st Forced Result Char Location
         EDMK  LNXCPUOT,LNXWORKD+12 Edit CPU Minutes Used to Character
         LA    R15,LNXCPUOT+L'LNXCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of CPU Minutes Used
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy CPU Minutes Used to Output Area
         LA    R4,1(R15,R4)        Point to the End of CPU Minutes Used
         MVC   0(3,R4),=CL3'MIN'   Insert CPU Minutes Used Indicator
         LA    R4,4(,R4)           Increment to CPU Seconds Used Field
TLNX3600 DS    0H
         LGR   R1,R14              Prepare for Division to Get Seconds
         DSGF  R0,=A(100000)       Calculate the Total No. of Seconds
         CVDG  R1,LNXWORKD         Binary CPU Seconds Value to Decimal
         MVC   LNXCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LNXFORC1         Load 1st Forced Result Char Location
         EDMK  LNXCPUOT,LNXWORKD+12 Edit CPU Seconds Value to Character
         LA    R15,LNXCPUOT+L'LNXCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Leng of CPU Seconds Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy CPU Seconds to Output Area
         LA    R4,1(R15,R4)        Point to End of Whole CPU Seconds
         MVI   0(R4),C'.'          Insert Fractional Seconds Separator
         LA    R4,1(,R4)           Increment to Fractional Seconds Area
TLNX3700 DS    0H
         CVD   R0,LNXWORKD         Decimal Version of Fractional Secnds
         OI    LNXWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  0(5,R4),LNXWORKD+5(3) ...Fractional Seconds to Character
         MVC   5(3,R4),=CL3'SEC'   Insert CPU Seconds Used Indicator
*
*+-------------------------------------------------------------------+*
*|                  Process the Job Step SRB Time                    |*
*+-------------------------------------------------------------------+*
*
TLNX3800 DS    0H
         LA    R4,12(,R4)          Increment to the SRB Time Used Field
         MVC   3(13,R4),=CL13'Job Step SRB:'  Fill Msg Area with Header
         LA    R4,17(,R4)          Set Pointer in the Output Work Line
         LLGT  R2,PSAAOLD-PSA(,R0) Get Address Space Cntrl Blk Old Pntr
         LG    R1,ASCBSRBT-ASCB(,R2) Get the Elapsed Job Step SRB Time
         SRLG  R1,R1,13 Bits       Set Microseconds/2**13
         DSGF  R0,=A(1000000/100000/2)  Hundred-Thousanths of a Second
         DSGF  R0,=A(60*60*100000) Calculate No. of Accumlated SRB Hrs
         CVDG  R1,LNXWORKD         Binary SRB Hours Value to Decimal
         MVC   LNXCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LNXFORC1         Load 1st Forced Result Char Location
         EDMK  LNXCPUOT,LNXWORKD+12 Edit SRB Hours Value to Character
         LA    R15,LNXCPUOT+L'LNXCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of SRB Hours Used
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy SRB Hours Used to Output Area
         LA    R4,1(R15,R4)        Point to the End of SRB Hours Used
         MVC   0(2,R4),=CL2'HR'    Insert the SRB Hours Used Indicator
         LA    R4,3(,R4)           Increment to SRB Minutes Used Field
TLNX3900 DS    0H
         LGR   R1,R0               Prepare for Division to Get Minutes
         DSGF  R0,=A(60*100000)    Calculate Total Number of Minutes
         LGR   R14,R0              Preserve the Accumlated SRB Seconds
         CVDG  R1,LNXWORKD         Binary SRB Minutes Value to Decimal
         MVC   LNXCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LNXFORC1         Load 1st Forced Result Char Location
         EDMK  LNXCPUOT,LNXWORKD+12 Edit SRB Minutes Used to Character
         LA    R15,LNXCPUOT+L'LNXCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Length of SRB Minutes Used
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy SRB Minutes Used to Output Area
         LA    R4,1(R15,R4)        Point to the End of SRB Minutes Used
         MVC   0(3,R4),=CL3'MIN'   Insert SRB Minutes Used Indicator
         LA    R4,4(,R4)           Increment to SRB Seconds Used Field
TLNX4000 DS    0H
         LGR   R1,R14              Prepare for Division to Get Seconds
         DSGF  R0,=A(100000)       Calculate the Total No. of Seconds
         CVDG  R1,LNXWORKD         Binary SRB Seconds Value to Decimal
         MVC   LNXCPUOT,PATTERN    Copy in the Number Editing Pattern
         LA    R1,LNXFORC1         Load 1st Forced Result Char Location
         EDMK  LNXCPUOT,LNXWORKD+12 Edit SRB Seconds Value to Character
         LA    R15,LNXCPUOT+L'LNXCPUOT-1 ..Point to Last Byte in Output
         SGR   R15,R1              Calculate Leng of SRB Seconds Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy SRB Seconds to Output Area
         LA    R4,1(R15,R4)        Point to End of Whole SRB Seconds
         MVI   0(R4),C'.'          Insert Fractional Seconds Separator
         LA    R4,1(,R4)           Increment to Fractional Seconds Area
TLNX4100 DS    0H
         CVD   R0,LNXWORKD         Decimal Version of Fractional Secnds
         OI    LNXWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  0(5,R4),LNXWORKD+5(3) ...Fractional Seconds to Character
         MVC   5(3,R4),=CL3'SEC'   Insert SRB Seconds Used Indicator
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TLNX4300            No  => No Further Writes, Do Release
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,LNE.LGWLINE Print the Job Step SRB Time
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|               Close the //LGRECOUT Output Data Set                |*
*+-------------------------------------------------------------------+*
*
TLNX4200 DS    0H
         MVC   LNXCLOSL,LNXLCLOS   Build the Close Parameter List
         LA    R2,LGWODCB          Get Address of the //LGRECOUT DCB
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   TLNX4300            No  => No Further Writes, Do Release
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         CLOSE ((R2)),             Perform Close Process for //LGRECOUTX
               MF=(E,LNXCLOSL),    Execute Form of Close for //LGRECOUTX
               MODE=31             Indicate 31-bit Mode for //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|   Perform Release of Storage Areas Utilized For Logger Services   |*
*+-------------------------------------------------------------------+*
*
TLNX4300 DS    0H
         LA    R2,LGWPINDX         Get Pointer to Primary Indx Blk Addr
         LG    RSDX,0(,R2)         Get the Primary Index Block Address
         LTGR  RSDX,RSDX           There a Primary Index Block Address?
         BRZ   TLNX4700            No  => Branch to Release Pgm Nms Tbl
         LG    R2,(LNXS64BCK-LNXSAVE)(,R13) Caller's Save Area Address
         TM    CALLER.LNXWFLAG,LCAWBUFR Log Rcd Buffers Above-the-Line?
         BRO   TLNX4400            Yes => Free Above-the-Line Storage
         TM    CALLER.LNXWFLAG,LCAWBU64 Log Rcrd Buffers Above-the-Bar?
         BRO   TLNX4500            Yes => Release Above-the-Bar Storage
         BRU   TLNX4700            No  => Branch to Release Names Table
TLNX4400 DS    0H
         LLGT  R15,=A(LNXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   TLNX4600            Branch to Release Log Record Buffers
TLNX4500 DS    0H
         LLGT  R15,=A(LNXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
TLNX4600 DS    0H
         LLGF  R4,=A(X'7FFFFFFF')  Set High Value Indicator to Rcrd Cnt
         XC    LXAPLIST,LXAPLIST   Clear the Call Parameter List
         LGR   R2,R13              Preserve Current Save Area Address
         LA    R13,LNXSAVEG        Provide Save Area Stack for Program
         CALL  (15),               Process Release of Log Recd Buffers X
               (LGRWK2II,          ..Pass Pntr to Logger Service Area  X
               (R4)),              ..Pass Pntr to Input Loggr Rcd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,LXAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Release Logger Recrds Buffer Storage
         LGR   R13,R2              Restore Current Save Area Address
TLNX4700 DS    0H
         ICM   R1,B'1111',LGWPGML  Address For Program Names Tble Area?
         BRZ   TLNX4800            No  => Branch to Release Logger Area
         LLGTR RPGM,R1             Restore Pgm Tble Pointer to Base Reg
         LLGF  R0,PGMLENTH         Get Length of Area to Release
       STORAGE RELEASE,            Release Storage for PGMLG2II Area   X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
TLNX4800 DS    0H
         LTGR  R1,RLGW             An Addr to Logger Work Area to Free?
         BRZ   TLNXEXIT            No  => Branch to Exit This Routine
         LLGF  R0,=A(LGRWK2LN)     Get Leng of Logger Service Work Area
       STORAGE RELEASE,            Release Storage for LGRWK2II Area   X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
         BRU   TLNXEXIT            Branch to Exit LGMHLRCT Program
         DROP  CALLER              Remove Listed Reg as Caller LCA Base
         DROP  LNE                 Remove Listed Reg as Loggr Rcrd Base
*
*+-------------------------------------------------------------------+*
*|   Return to Caller (The User's Program)                           |*
*+-------------------------------------------------------------------+*
*
TLNX$END DS    0H
         SLGR  R15,R15             Indicate Successful Completion
TLNXEXIT DS    0H
         LLGF  R0,LXASAVEA         Get the Size of Common Storage Area
         LLGT  R1,LXASVCOM         Get Address of Storage to be Freed
         L     R2,LNXRTCDE         Preserve the Current Return Code
       STORAGE RELEASE,            Release Storage for the Common Area X
               COND=YES,           Indicate Conditional Release of AreaX
               LENGTH=(R0),        Set the Amount of Storage to ReleaseX
               ADDR=(R1),          Set Address of Storage to Release   X
               SP=3                Task Owned,No Page-Fix,No Fetch Prot
TLNXRTRN DS    0H
         ST    R2,LNX$RC           Set the Return Code
         LPGMEXIT RC=LNX$RC        Define Logger Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Logger Control Area - (LCA)                                    |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Logger Control Area-(LCA)
*
LNXSAVEG DS    27FD                Program Save Area 1 - (GPR's)
LNXSAVE2 DS    27FD                Stacked Save Area 2 - (F5SA Format)
LNXSAVE3 DS    27FD                Stacked Save Area 3 - (F5SA Format)
LNXSAVE4 DS    27FD                Stacked Save Area 4 - (F5SA Format)
LNXSAVE5 DS    27FD                Stacked Save Area 5 - (F5SA Format)
LNXWORKD DS    10D                 General Work Area
LNXSIPOS DS    2AD                 Pointer for Secondary Index Position
LNXRTCDE DS    F                   Save Area for Return Code
         DS    0D                  Set for Doubleword Alignment
LNXESTAE DS    XL(COMESTAL)        Establish the ESTAEX Parm List Area
         DS    0D                  Set for Doubleword Alignment
LNXCLOSL DS    XL(LNXLCLLN)        Close Macro Parameter List
         DS    0D                  Set for Doubleword Alignment
LNXCPUOT DS    CL(L'PATTERN)       Work Area for Character Formatting
LNXFORC1 EQU   *-1                 First Forced Result Char Location
*
         LCA   DEFEND              Define End of Logger Control Area
*
         DROP  ,                   Remove Listed Regs as Base Registers
***********************************************************************
*                   End of LGMHLRCT Main Program                      *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Logger Control Area - (LCA)
RBASE1   EQU   12                  Base Register 1
RBASE2   EQU   11                  Base Register 2
RCOMM1   EQU   10                  Common Dynamic Area Base Register
RCOMM2   EQU   9                   Common Constants/Routines Base Reg
RLGW     EQU   8                   Logger Services Work Area
RPGM     EQU   7                   Logging Input Options Area
         USING LXA@PCA,RCOMM1      Common Program Area Addressability
         USING COM#U6H4,RCOMM2     Constants&Routines Addressability
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M # U 6 H 4 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P r o g r a m   C o n t r o l   C o m m o n   D a t a   A r e a  |*
*+-------------------------------------------------------------------+*
*
COM#U6H4 RSECT
COM#U6H4 AMODE &AMODE
COM#U6H4 RMODE &RMODE
*
BLANKS   DC    CL256' '            Spaces
CVT$ZTOK DC    D'0'                CVT TOD High Word Offset Zero Token
NOCARRY  EQU   8+4                 Condition Code for No Carry
NOBORROW EQU   2+1                 Condition Code for No Borrow
PATTERN  DC    XL8'4020202020202120' ...Pattern for Editing
LNXALRCB DC    V(LGMHLRCB)         Vcon for Log Services Buffer Program
LNXALB64 DC    V(LGMHLB64)         Vcon for Log Services Buffer Program
*
*+-------------------------------------------------------------------+*
*     Lists                                                           *
*+-------------------------------------------------------------------+*
*
COMESTAE DS    0H                  Specify Task Abnormal Exit Extended
         ESTAEX ,CT,               Define a New Recovery Environment   X
               PURGE=NONE,         Outstanding I/O Operations Not SavedX
               ASYNCH=YES,         Allow Asynchronous Exit Processing  X
               CANCEL=YES,         Allow Interruption by Cancel/Detach X
               RECORD=NO,          Do not Record SWDA in System LogRec X
               TERM=YES,           Schedule Routine on Termination     X
               MF=L                Indicate List Form
COMESTAL EQU   *-COMESTAE          ESTAEX List Length
*
COM$TIME TIME  LINKAGE=SYSTEM,MF=L List Form for Time of Day
COMTIMLN EQU   *-COM$TIME          List Length for Time of Day
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
LNXLCLOS CLOSE (*-*),MF=L,MODE=31  DCB Close Macro Parameter List
LNXLCLLN EQU  *-LNXLCLOS           Length Definition for DCB Close List
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*|                     Logger Service Messages                       |*
*+-------------------------------------------------------------------+*
*
         DC    0F                  Alignment
LGA01110 DC    C'LGA01110I Assembler program logging has completed.'
*
HEXCONV  DC    C'0123456789ABCDEF' Translation Table for Hex to Char
*
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************|  L X A @ P C A  |**************************
**************************+-----------------+**************************
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|      P r o g r a m   C o n t r o l   D y n a m i c  A r e a       |*
*+-------------------------------------------------------------------+*
*
LXA@PCA  DSECT ,                   Program Control Area - (CPCA)
LXA@EYEC DS    CL32                Common Work Area Eye-Catcher
LXASAVEA DS    D                   Our Save Area
LXA$WORK DS    10D                 General Work Area
LXAWORKD DS    D                   General Work Area
LXAPLIST DS    20FD                CALL Parameter List
LXARETCD DS    F                   Return Code
LXASVCOM DS    A                   Common Area Save Address
LXASTORG DS    0D                  Getmained Storage Areas
LXADYN01 DS    AD(0,0)             Addr/Length Dynamic Area
LXADYN02 DS    AD(0,0)             Addr/Length Dynamic Area
LXADYN03 DS    AD(0,0)             Addr/Length Dynamic Area
LXASTLEN EQU   (*-LXASTORG)/8      Count of Entries For Freemain
LXALNGTH EQU   *-LXA@PCA           Length of Program Control Area
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*+-------------------------------------------------------------------+*
*|        L o g g e r   C o n t r o l   A r e a   -   (LCA )         |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
LGXRCIE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|           Program Logger Record Buffer Control Blocks             |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
*  LOGPIBLK = Primary Index Block Structure                           *
*  LOGSIBLK = Secondary Index Block Structure                         *
*  LOGTRBLK = Log Record Buffer Area Structure                        *
*                                                                     *
*  The following Log Record control blocks represent the indexing     *
*  structure which is utilized for processing the Log Records. The    *
*  address entries in the primary index control block point to        *
*  secondary index control blocks. The entries in the secondary       *
*  index control blocks will point to the individual log records      *
*  in the buffers.                                                    *
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|              Log Record Primary Index Control Block               |*
*+-------------------------------------------------------------------+*
*
LOGPIBLK DSECT ,                   Log Record Primary Index Block
LOGPISIZ DS    FD                  Size of This Primary Index Block
LOGPINXT DS    AD                  Next Primary Index Block or Zero
LOGPIFST DS    AD                  Address of First Entry in Block
LOGPICNT DS    FD                  Count of Entries in Primary Indx Blk
LOGPITOT DS    FD                  Count of Total Log Record Entries
LOGPIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGPISXH DS    AD                  Secondary Index Block Chain Header
LOGPISXT DS    AD                  Secondary Index Block Chain Trailer
LOGPIMTH DS    AD                  Log Record Data Block Chain Header
LOGPIMTT DS    AD                  Log Record Data Block Chain Trailr
LOGPOIX2 DS    AD                  Secondary Index Memory Object Origin
LOGPHIX2 DS    AD                  Secondary Index Mem Obj High Address
LOGPHUX2 DS    AD                  Secondary Indx Mem Obj High Used Adr
LOGPOLRD DS    AD                  Log Record Data Memory Object Origin
LOGPHLRD DS    AD                  Log Record Data Mem Obj High Address
LOGPGRDZ DS    FD                  Log Recrd Data Mem Object Guard Size
LOGPGRD2 DS    FD                  Secondary Indx Mem Object Guard Size
         ORG   LOGPIBLK+576        (Reserved - LOGGER)
LOGPINDX DS    0AD                 Last Available Primary Index Entry
         DS    131000AD            Allow 131,000 Primary Index Entries
LOGPILEN EQU   *-LOGPIBLK          Set Length of Primary Index Block
*
*+-------------------------------------------------------------------+*
*|             Log Record Secondary Index Control Block              |*
*+-------------------------------------------------------------------+*
*
LOGSIBLK DSECT ,                   Log Record Secondary Index Block
LOGSISIZ DS    FD                  Size of This Secondary Index Block
LOGSIPRV DS    AD                  Prev Secondary Index Block or Zero
LOGSINXT DS    AD                  Next Secondary Index Block or Zero
LOGSIFST DS    AD                  Addr of First Data Entry in Block
LOGSICNT DS    FD                  Count of Data Pointers in This Block
LOGSIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGSIKEY DS    0CL(L'LOGSITIM+L'LOGSITCB+L'LOGSISEQ) Highest Key in Blk
LOGSITIM DS    XL16                ..Log Record Entry Time Stamp
LOGSITCB DS    XL4                 ..Log Record Entry TCB Address
LOGSISEQ DS    XL4                 ..Log Record Entry Sequence No.
         ORG   LOGSIBLK+768        (Reserved - LOGGER)
LOGSINDX DS    0AD                 Last Available Secondary Indx Entry
         DS    4000AD              Allow 4,000 Secondary Index Pointers
         ORG   *-8                 Point at Last Secondary Index Entry
LOGSILST DS    AD                  Addr Highest Secondary Index Entry
LOGSISPL EQU   (*-LOGSINDX)/2      Len of a Split Secondary Index Block
LOGSILEN EQU   *-LOGSIBLK          Set Length of Secondary Index Block
LOGSISGZ EQU   (1024*1024)         Set Size of Secondary Index Segment
*
*+-------------------------------------------------------------------+*
*|             Log Record Control Block for Buffer Areas             |*
*+-------------------------------------------------------------------+*
*
LOGTRBLK DSECT ,                   Log Record Entry Data Cntl Block
LOGTRSIZ DS    FD                  Size of the Log Record Data Block
LOGTRNXT DS    AD                  Address of the Next Block on Chain
LOGTRCNT DS    FD                  Count of Record Entries in Buffer
LOGTRSLT DS    AD                  First Available Slot in Buffer Area
         DS    D                   (Reserved - LOGGER)
LOGTRHLN EQU   *-LOGTRBLK          Length of Data Block Header Section
         ORG   LOGTRBLK            Reset Buffer Area Location Counter
LOGTRRCD DS    0F                  Address of First Log Record Entry
LOGTRKEY DS    0CL(L'LOGTRTIM+L'LOGTRTCB+L'LOGTRSEQ) Log Record Key
LOGTRTIM DS    XL16                ..Log Record Entry Time Stamp
LOGTRTCB DS    XL4                 ..Log Record Entry TCB Address
LOGTRSEQ DS    XL4                 ..Log Record Entry Sequence No.
*
LOGTRCRD DS    CL(L'LGWLINE)       Area for the Log Trace Event Record
LOG$BLK@ DS    AD                  Log Record Buffer Area Block Address
*
LOGTRLEN EQU   *-LOGTRRCD          Length of Log Record Buffer Entry
LOGPIDBS EQU   1024*8192           Size of Rcrd Area for Storage (8Meg)
LOGTRMXB EQU   (LOGPIDBS-LOGTRHLN)/LOGTRLEN  Maximum Blocks in a Buffer
LOGMXSIZ EQU   (1*10240)           Max Memlimit in Megabytes (10Gig)
*
         EJECT ,
*+-------------------------------------------------------------------+*
*|               z / O S   S y s t e m   D s e c t s                 |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         CVT      DSECT=YES,LIST=YES Communications Vector Table
         IHAASCB  DSECT=YES,LIST=YES  Address Space Control Block
         DCBD     DSORG=PS,DEVD=DA Data Control Block
         IEZDEB   LIST=YES         Data Extent Block
         IHAPSA   LIST=YES         Prefix Storage Area
         END
