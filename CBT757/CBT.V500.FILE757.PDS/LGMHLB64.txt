***********************************************************************
*LLL      GGGGGGG M     M H      H LLL      BBBBBBB  6666666 4     4  *
* L       G     G MM   MM H      H  L       B      B 6       4     4  *
* L       G       M M M M H      H  L       B      B 6       4     4  *
* L       G  GGGG M  M  M HHHHHHHH  L       BBBBBBB  6  6666 4444444  *
* L       G     G M     M H      H  L       B      B 6  6  6       4  *
* L       G     G M     M H      H  L       B      B 6     6       4  *
* LLLLLLL GGGGGGG M     M H      H  LLLLLLL BBBBBBB  6666666       4  *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHLB64                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Above-the-Bar Log Record Buffering *
*                                                                     *
* INPUT REGS:      R1  => Standard z/OS Parameter List                *
*                  R14 => Return Point                                *
*                  R13 => Caller's Save Area                          *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to LGRWK2II Logger Work Area        *
*                         (Mapped by LGCPLSWA CopyBook)               *
*                  Parm2: Pointer to Area Containing Count of Log     *
*                         Records in Temporary Work Area              *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return Address                                *
*                  R13, Save Area & Dynamic Area                      *
*                  R12, (RBASE1) Program Base Register                *
*                  R11, (RBASE2) Program Base Register                *
*                  R10, (RCOMM1) Common Dynamic Area                  *
*                  R9,  (RCOMM2) Common Dynamic Area                  *
*                  R8,  (RCOMM3) Common Constants/Routines            *
*                  R7,  (RCOMM4) Common Constants/Routines            *
*                  R0-R6, General Work Registers                      *
*                                                                     *
* CALLING PROGRAM: LGMHLRCT - Logger Services Termination Program     *
*                  LGMHRTRY - Logger Services Abend Retry Program     *
*                  LGMHLRCE - Logger Services Log Record Event        *
*                             Publishing Program                      *
*                                                                     *
* CALLED PROGRAMS: L6BF0000 - To Process Insertion of Log Records     *
*                             Into the Buffers.                       *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Serious Error                                 *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* (New)    V1R1M17 20120721 New Module to Support Writing of Log @@KHF*
*                           Records to Above-the-Bar Storage Area@@KHF*
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Logger Program
         LCLC  &RMODE              Resident Mode of Logger Program
&KXHVER  SETC  'V1'                Indicate the Program Version Number
&KXHREL  SETC  'R1'                Indicate the Program Release Number
&KXHMOD  SETC  'M17'               Indicate the Pgm Modification Level
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&CPYRITE SETC  '2008,2012'         Program Copyright Year
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
&MODID   SETC  'LGMHLB64'          Set the Program Module Identifier
R0       EQU   0                   Define Program Register 0 Equate
R1       EQU   1                   Define Program Register 1 Equate
R2       EQU   2                   Define Program Register 2 Equate
R3       EQU   3                   Define Program Register 3 Equate
R4       EQU   4                   Define Program Register 4 Equate
R5       EQU   5                   Define Program Register 5 Equate
R6       EQU   6                   Define Program Register 6 Equate
R7       EQU   7                   Define Program Register 7 Equate
R8       EQU   8                   Define Program Register 8 Equate
R9       EQU   9                   Define Program Register 9 Equate
R10      EQU   10                  Define Program Register 10 Equate
R11      EQU   11                  Define Program Register 11 Equate
R12      EQU   12                  Define Program Register 12 Equate
R13      EQU   13                  Define Program Register 13 Equate
R14      EQU   14                  Define Program Register 14 Equate
R15      EQU   15                  Define Program Register 15 Equate
RPDX     EQU   6                   Log Records Primary Index Block
RSDX     EQU   5                   Log Records Secondary Index Block
REDB     EQU   4                   Log Records Buffer Area Block
         EJECT  ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHLB64 - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHLB64                                           *
*                                                                     *
* FUNCTION:        Above-the-Bar Log Record Buffer Service            *
*                                                                     *
*                  This routine is the main driver and entry point for*
*                  processing the Log Records to a buffer area that is*
*                  above-the-bar. This program is called when two     *
*                  global options have been set when LPGMNTRY=MAIN is *
*                  specified in a user program. If logging is enabled *
*                  by the user program specifying the "LOG=ON" option,*
*                  and if above-the-bar buffering is also enabled by  *
*                  the user program specifying the "LOGOUT=BUF64"     *
*                  option, then as program LGMHLRCE generates log     *
*                  records, this LGMHLB64 program will be called      *
*                  by program LGMHLRCE to write the log output records*
*                  to a buffer area in an above-the-bar memory object.*
*                                                                     *
*                  Upon a normal end of the user's program, the Logger*
*                  Services program LGMHLRCT will write all of the    *
*                  logger records in the above-the-bar memory objects *
*                  to the //LGRECOUT DD data set. When LGMHLRCT has   *
*                  completed printing the log records it will call    *
*                  this LGMHLB64 program to release the above-the-bar *
*                  memory objects used to hold the indices and log    *
*                  records.                                           *
*                                                                     *
*                  Upon an abend in the user's program, the Logger    *
*                  Services retry program LGMHRTRY will write all of  *
*                  the logger records in the memory objects to the    *
*                  //LGRECOUT DD data set. When LGMHRTRY has completed*
*                  printing the log records then as part of its clean *
*                  up and prior to percolating the abend it will call *
*                  this LGMHLB64 program to release the above-the-bar *
*                  memory objects used to hold the indices and log    *
*                  records.                                           *
*                                                                     *
* INPUT REGS:      R1 => Standard z/OS Parameter List                 *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHLRCE                                           *
*                                                                     *
* CALLED PROGRAMS: L6BF0000 - Logger Record Insertion Program         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error        (Buffer Overrun)                 *
*                  12 - Severe Error (Storage Exhausted)              *
*                                                                     *
***********************************************************************
*
&MODID   RSECT *                   Main Pgm Read-Only Control Section
&MODID   AMODE &AMODE              Program Addressing Mode -  &AMODE
&MODID   RMODE &RMODE              Program Residence Mode - &RMODE
         SYSSTATE AMODE64=YES,ARCHLVL=2 ...Establish 64-Bit Environment
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6MA0002 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   DUMMYPNT            Branch Past the Literal Area
         DC    C'&MODID'           Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
       SPLEVEL SET=6               Set for OS/390 R2 or Above (z/OS+)
         DC    50S(*)              Define a Patch Area
DUMMYPNT DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         LA    RBASE2,2048(,RBASE1)  Load 2nd Base w/ Addressable Range
         LA    RBASE2,2048(,RBASE2)  Add to the Preceding Address Range
         USING &MODID+(L6MA0002-LGMHLB64),RBASE1,RBASE2   Set Base Regs
         LGR   R2,R13              Preserve Caller's Save Area Address
         LLGF  R14,=A(LGW$AREA-LGRWK2II) Index to the Logger Work Area
         LG    R3,0(R1)            Get Starting Address to Work Area
         LA    R3,0(R14,R3)        Point to General Area in Work Area
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
*
*+-------------------------------------------------------------------+*
*| Establish Addressability To A Working Storage Area Within The     |*
*| LGRWK2II Area.                                                    |*
*+-------------------------------------------------------------------+*
*
L6RB1000 DS    0H
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LGR   RCOMM1,R3           Establish Common Work Area Address
         LA    RCOMM2,4095(,RCOMM1) ...Establish Second Base Register
         LA    RCOMM2,1(,RCOMM2)   Remove Overlap of Addressable Range
         LLGT  RCOMM3,=A(COM#P6L9) Common Constants and Routines Area
         LA    RCOMM4,4095(,RCOMM3) ...Establish Second Base Register
         LA    RCOMM4,1(,RCOMM4)   Remove Overlap of Addressable Range
         LG    R1,LCAF64R01-LCASAVE(,R2) Restore Parameter List Address
         LMG   R1,R2,0(R1)         Get the Input Parameters
         STG   R1,CM6LG2II         Preserve the Pointer to LGRWK2II
         STG   R2,CM6RCDCT         Save the Current Log Record Count
         MVC   COM6EYEC,=CL32'LGMHLB64 COMMON AREA' .Set the Eyecatcher
         XC    CM6RETCD,CM6RETCD   Initialize the Return Code Area
*
*+-------------------------------------------------------------------+*
*| The Current Group of Log Record Entries Generated by the LGMHLRCE |*
*| Program Are in the LGRWK2II Temporary Work Area. Now Take the Log |*
*| Record Entries From The LGRWK2II Temporary Work Area Located in   |*
*| Storage Below-the-Line, and Copy Them to the Accumulation Buffer  |*
*| Areas in 64-bit Storage Above-the-Bar.                            |*
*+-------------------------------------------------------------------+*
*
L6RB2000 DS    0H
         XC    CM6PLIST,CM6PLIST   Clear the Call Parameter List
         CALL  L6BF0000,           Process the Log Records to Buffer   X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               CM6LG2II,           ..Pass Pntr to the Logger Work Area X
               CM6RCDCT),          ..Pass Pntr to Input Log Recrd CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CM6PLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Write Log Records to Buffer Area
         LTGFR R15,R15             Was the Insert Request Successful?
         BRZ   L6RB2100            Yes => Branch to Process Request
         ST    R15,CM6RETCD        Save Highest Return Code Genearated
         LGHI  R2,((L6RB3000-L6RB2100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   L6RB2100            No  => Process Return From Insert
         BRU   L6RBEXIT            Branch to Exit This Routine
L6RB2100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   L6RB3000            Process for Records Inserted
         BRU   L6RB3000            Process on Warning
         BRU   L6RB3000            Process on Validation Error
         BRU   L6RBEXIT            Process for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Done Inserting Log Records into the Above-the-Bar Buffer. Before  |*
*| Exiting Ensure the Section Within the LGRWK2II Area That is Being |*
*| Re-Used as a Temporary Work Area is Cleared of Old Log Records.   |*
*+-------------------------------------------------------------------+*
*
L6RB3000 DS    0H
         LG    R1,CM6LG2II         Get the Pointer to the LGRWK2II Area
         LTGR  R1,R1               Is a Pointer Available to LGRWK2II?
         BRZ   L6RB$END            No  => Then Branch to Exit Routine
         LLGF  R0,=A(LGW$AREL)     Get Temporary Log Recrod Area Length
         LLGF  R2,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R1,0(R2,R1)         Point to Temporary Log Record Area
         LGR   R3,R1               Save Addr Temporary Log Record Area
         LGR   R15,R1              Set Temporary Log Record Work Area
         AGR   R15,R0              Calculate Ending Addr of Work Area
         NG    R15,=AD(-4096)      Round Area Down to a Page Boundary
         BCTGR R15,R0              Ensure Pointing to Actual End Addr
         LA    R1,4095(,R1)        Add 4K to Existing Starting Address
         NG    R1,=AD(-4096)       Round It Up to Full Page Boundary
         CGR   R15,R1              Any Page Aligned Areas to Release?
         BRNH  L6RB3100            No  => Branch for a Physical Clear
       PGSER R,RELEASE,            Release Temporary Work Area Pages   X
               A=(1),              Addr of Start of Temporary Work AreaX
               EA=(15),            Addr of Last Byte in Temporary Area X
               BRANCH=N            Using SVC Entry for Paging Service
         BRU   L6RB$END            Branch to Exit This Routine
L6RB3100 DS    0H
         LGR   R0,R3               Set Temporary Log Record Work Area
         LLGF  R1,=A(LGW$AREL)     Obtain Temporary Log Recrd Area Leng
         SLGR  R14,R14             Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear Entire Temporary Log Work Area
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6RB$END DS    0H
         SLGR  R15,R15             Indicate Successful Completion
L6RBEXIT DS    0H
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove All Listed Regs as Base Regs
*
***********************************************************************
*                 End of LGMHLB64 Main Program                        *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*| RRRRRRR   OOOOO  U     U TTTTTTT IIIIIII N     N EEEEEEE   SSSSS  |*
*| R      R O     O U     U    T       I    NN    N E        S     S |*
*| R      R O     O U     U    T       I    N N   N E        S       |*
*| RRRRRRR  O     O U     U    T       I    N  N  N EEEEEE    SSSSS  |*
*| R    R   O     O U     U    T       I    N   N N E              S |*
*| R     R  O     O U     U    T       I    N    NN E        S     S |*
*| R      R  OOOOO   UUUUU     T    IIIIIII N     N EEEEEEE   SSSSS  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 B F 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   I n s e r t   I n t o   D a t a   B u f f e r s  |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: L6BF0000                                           *
*                                                                     *
* FUNCTION:        Insert Log Records Into Above-the-Bar Data Buffers *
*                                                                     *
*                  This routine is responsible for the insertion of   *
*                  log records into the buffer area. This routine     *
*                  directs the call to other log record insertion     *
*                  routines.                                          *
*                                                                     *
*                  As part of the insertion process this routine will *
*                  manage and maintain the buffer areas and indices   *
*                  residing in above-the-bar memory objects through   *
*                  search, sort, and insertion functionsÝ1/2¨.        *
*                                                                     *
*                  Upon the first call to this routine the primary    *
*                  index pointer field is zero, and initialization is *
*                  performed. The initialization process will consist *
*                  of utilizing the IARV64 GETSTORE service to acquire*
*                  separate memory objects for the primary index      *
*                  block, the first secondary index block, and the    *
*                  the first buffer area to hold log records.         *
*                                                                     *
*                  After initialization, this program will move the   *
*                  log records from the temporary work area to the    *
*                  accumulation buffers in a memory object. As this   *
*                  program is called continuously to handle a new     *
*                  block of records being passed from the LGMGLRCE    *
*                  program, it will perform any required expansion of *
*                  the index blocks as the buffers in above-the-bar   *
*                  memory object fills with incoming log records.     *
*                                                                     *
*                  A primary index control block is a formatted area  *
*                  which will contain address entries that are        *
*                  pointers to secondary index control blocks which   *
*                  themselves have address entries which point to the *
*                  individual log records in the buffer areas.        *
*                                                                     *
*                  Our input will be log records from a temporary     *
*                  work area which will be written to the buffer      *
*                  areas. Each input log record is indexed. Before    *
*                  insertion a search is done to calculate a slot     *
*                  position in the index area to hold the pointer to  *
*                  the record to be inserted in a buffer area. During *
*                  this search for an index slot position, each log   *
*                  record will also be checked to determine if the    *
*                  record key already exists in the buffers to prevent*
*                  the insertion of any duplicate entries. If a       *
*                  duplicate, the input record is ignored. If not,    *
*                  then the input record is inserted into the buffers *
*                  and the index to the log records is updated.       *
*                                                                     *
*                  *Ý1¨Professor Donald E. Knuth, Stanford University *
*                      The Art of Computer Programming, Volume 3,     *
*                      2nd Edition, Sorting and Searching             *
*                      Addison-Wesley Publishing, 1998.               *
*                                                                     *
*                  *Ý2¨Professor Spotwood D. Stoddard, University of  *
*                      Nebraska - Lincoln                             *
*                      Principles of Assembler Language Programming   *
*                      for the IBM 370, McGraw-Hill, 1985.            *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Logger Work Area         *
*                  Parm6: Addr of Area for No. of Log Record Entries  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: LGMHLB64 - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: L6BX0000 - To Process Build of Log Record Indices  *
*                  L6FD0000 - To Process Find of Log Record Index Slot*
*                  L6EX0000 - To Process Expand of Index Blocks       *
*                  L6IN0000 - To Process Insert of a Log Record       *
*                  L6RL0000 - To Process Clean Up of Indices          *
*                  WTO      - To Process Messages                     *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
L6BF0000 RSECT *                   Read-Only Control Section Name
L6BF0000 AMODE &AMODE              Establish Addressing Mode
L6BF0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6BF0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   L6BF0002            Branch Past the Literal Area
         DC    C'L6BF0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLvl
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
L6BF0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING L6BF0000+(L6BF0001-L6BF0000),RBASE1  Set Addressability
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) Load Common Area Addresses
         LMG   R1,R2,LCAF64R01-LCASAVE(R1)  Get the Input Parameters
         STG   R1,L6BLG2II         Save the Logger Work Area Pointer
         LG    R2,0(,R2)           Get the Count of Record Entries
         STG   R2,L6BFCDCT         Save the Log Record Entry Count
         XC    CM6RETCD,CM6RETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Check if We Have Index Areas and a Record Buffer Area. If Yes,    |*
*| Then Proceed to Insert the Logger Records. If No, Then This is the|*
*| First Time Through, and Need to Create the Above-the-Bar Memory   |*
*| Objects to Hold the Log Record Indices and Log Records.           |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R4         Establish Addressability to Log Area
L6BF0100 DS    0H
         LG    R4,L6BLG2II         Get Pntr to Logger Work Area Address
         LG    R4,0(,R4)           Get Address to Logger Work Area
         LA    R3,LGWTSTCK         Get Addr to Log Record Time Stamp
         STG   R3,L6FTRTIM         Save Addr to Log Record Time Stamp
         LA    R3,LGWTCBAD         Get Addr to User Program TCB Address
         STG   R3,L6FTCBAD         Save the User Program TCB Address
         LA    R3,LGWACCUM         Get Addr to Log Record Accumulator
         STG   R3,L6FACCUM         Save the Log Record Accum Address
         LLGF  R3,=A(LGWLINE-LGRWK2II)  Index to Log Record List Area
         LA    R3,0(R3,R4)         Point to the Log Record Area
         STG   R3,L6FINPUT         Save the Log Record Area Pointer
         LG    RPDX,LGWPINDX       Get the Primary Index Block Address
         LTGR  RPDX,RPDX           Is the Primary Index Already Built?
         BRZ   L6BF0200            No  => Branch to Build Log Indices
         STG   RPDX,L6FPINDX       Save the Primary Index Block Address
         CLM   R2,B'1111',=A(X'7FFFFFFF') High Value Indicate No More?
         BRE   L6BF1000            Yes => All Done, Branch to Clean Up
         BRU   L6BF2000            No  => Branch to Insert Log Records
L6BF0200 DS    0H
         LA    R1,LGWPINDX         Get Pointer to Primary Index Address
         STG   R1,L6FPINDX         Save Pointer to Primary Index Addr
         XC    CM6PLIST,CM6PLIST   Clear the Call Parameter List
         CALL  L6BX0000,           Create Memory Objects and Init IndexX
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               L6FPINDX),          ..Pass Log Rcd Primary Index PointerX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CM6PLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Create Memory Objects
         LTGFR R15,R15             Create Memory Objects Successfull?
         BRZ   L6BF0500            Yes => Branch to Process Log Records
         LGHI  R2,((L6BF0600-L6BF0500)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   L6BF0500            No  => Process Incoming Log Records
         BRU   L6BFEXIT            Process for Error
L6BF0500 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   L6BF0600            Log Rcds Index/Data Blks Processed
         BRU   L6BFEXIT            Process for Warning
         BRU   L6BFEXIT            Process for Validation Error
         BRU   L6BFEXIT            Process for Severe Error - Exit
L6BF0600 DS    0H
         LG    R2,L6FPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R2)         Get the Primary Index Block Address
         STG   RPDX,L6FPINDX       Save the Primary Index Block Address
         BRU   L6BF2000            Branch to Process Input Log Records
         DROP  R4                  Remove Listed Reg as Log Area Base
*
*+-------------------------------------------------------------------+*
*| Perform Detach of Memory Objects to Release Above-the-Bar Storage |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R4         Establish Addressability to Logger
L6BF1000 DS    0H
         XC    CM6PLIST,CM6PLIST   Clear the Call Parameter List
         CALL  L6RL0000,           Detach Mem Object to Release StorageX
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               L6FPINDX),          ..Pass Log Rcd Primary Index PointerX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CM6PLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Release the Memory Objects
         LTGFR R15,R15             Did Detach Complete Successfully?
         BRZ   L6BF1100            Yes => Branch to Complete Clean-Up
         LGHI  R2,((L6BF1200-L6BF1100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   L6BF1100            No  => Process Index Clean Request
         BRU   L6BFEXIT            Process for Error
L6BF1100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   L6BF1200            Log + Index Memory Objects Released
         BRU   L6BFEXIT            Process for Warning
         BRU   L6BFEXIT            Process for Validation Error
         BRU   L6BFEXIT            Process for Severe Error - Exit
L6BF1200 DS    0H
         LG    R4,L6BLG2II         Get Pntr to Logger Work Area Addr
         LG    R4,0(,R4)           Get Address to the Logger Work Area
         LG    RPDX,L6FPINDX       Get the Primary Index Block Address
         STG   RPDX,LGWPINDX       Clear the Primary Index Blk Address
         XC    TSK6ROWC,TSK6ROWC   Clear Count of Log Record Rows
         XC    TSK6PRTC,TSK6PRTC   Clear Area for Print Entries Counter
         BRU   L6BF$END            Branch to Exit This Routine
         DROP  R4                  Remove Listed Register as Base Reg
*
*+-------------------------------------------------------------------+*
*|  Search The Log Record Indices To Find an Index Slot Position in  |*
*|  the Secondary Index Area to Hold the 64-Bit Buffer Address for   |*
*|  the Log Record to be Inserted in the Buffer.                     |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish Addressability to 1st Indx
         USING LOGSIBLK,RSDX       Establish Addressability to 2nd Indx
         USING LOGTRBLK,REDB       Establish Addressability to Data Tbl
L6BF2000 DS    0H
         LG    R2,L6FINPUT         Get Current Pntr to Log Record Area
         LG    R4,L6BFCDCT         Get Count of Rows in Log Record Area
L6BF2100 DS    0H
         STG   R4,L6BFOWCT         Save Current Count of Rows in Buffer
         LG    R3,L6FACCUM         Get the Log Record Accum Address
         LLGF  R1,0(,R3)           Get the Log Record Accumulate Count
         LA    R1,1(,R1)           Increment to Use as Rcd Sequence No.
         ST    R1,0(,R3)           Save Updated Record Accumulate Count
L6BF2200 DS    0H
         XC    CM6PLIST,CM6PLIST   Clear the Call Parameter List
         CALL  L6FD0000,           Perform Find and Set Slot Position  X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               L6FPINDX,           ..Pass the Primary Index Pointer    X
               L6FSINDX,           ..Pass the Secondary Index Pointer  X
               L6FTRTBL,           ..Pass the Log Buffer Area Pointer  X
               L6FINPUT,           ..Pass the Log Record Area Pointer  X
               L6FOSLOT,           ..Pass the Slot Position Pointer    X
               L6FTRTIM,           ..Pass the Log Record TimeStamp AddrX
               L6FTCBAD,           ..Pass the Current TCB Address      X
               L6FACCUM),          ..Pass the Current Recrd Accum CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CM6PLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Search for Slot Position
         LTGFR R15,R15             Find Process Complete Successfully?
         BRZ   L6BF2500            Yes => Process Current Log Record
         ST    R15,L6F$RTCD        Save Highest Return Code Generated
         LGHI  R2,((L6BF3000-L6BF2500)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   L6BF2500            No  => Process Log Find Request
         BRU   L6BF7000            Process for Error
L6BF2500 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   L6BF3000            Recrd Entry Not in Table - Have Slot
         BRU   L6BF6000            Recrd Entry Found in Tbl - Duplicate
         BRU   L6BF7000            Process for Validation Error
         BRU   L6BF7000            Process for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Verify If There is Sufficient Space in the Secondary Index Block |*
*|  To Insert A Log Record. A Secondary Index Block Will Contain     |*
*|  Pointers To The Log Records In The Buffers. If The Secondary     |*
*|  Index Block Has Filled, Then Expand The Current Secondary Index  |*
*|  Block Into Two Separate Index Blocks To Make More Room To Hold   |*
*|  an Index Entry To The Log Record We Are Trying To Insert Into a  |*
*|  Buffer.                                                          |*
*+-------------------------------------------------------------------+*
*
L6BF3000 DS    0H
         LA    R1,L6FSINDX         Get Pointer to Secondary Index Block
         LG    RSDX,0(,R1)         Get the Secondary Index Block Addr
         LA    R14,LOGSINDX        Get the Last Available Slot Address
         CG    R14,LOGSIFST        Is This Secondary Index Block Full?
         BRNE  L6BF5000            No  => Branch to Insert Log Record
L6BF3100 DS    0H
         LA    R14,LOGPINDX        Get the Last Available Slot Address
         CG    R14,LOGPIFST        First Populated Slot to Overrun Blk?
         BRNE  L6BF4000            No  => Branch to Process Block Split
L6BF3200 DS    0H
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         MVC   LG6WTOMG(L'LGA01111),LGA01111 Indicate Prim Blk Overrun
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
L6BF3300 DS    0H
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Set for Primary Index Buffer Overrun
         ST    R15,L6F$RTCD        Save Highest Return Code Generated
         BRU   L6BF7000            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| A Secondary Index Block Has Filled and Cannot Hold More Entries.  |*
*| Create a New Secondary Index Block To Expand The Secondary Index  |*
*| Area. Then Go Back To Re-Calculate A New Index Slot Position In   |*
*| the Expanded Secondary Index Area To Hold The 64-Bit Pointer To   |*
*| the Log Record That is Waiting to be Inserted.                    |*
*+-------------------------------------------------------------------+*
*
L6BF4000 DS    0H
         XC    CM6PLIST,CM6PLIST   Clear the Call Parameter List
         CALL  L6EX0000,           Perform Expand of Log Rcrds Indx BlkX
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               L6FPINDX,           ..Pass Log Rcd Primary Index PointerX
               L6FSINDX),          ..Pass Log Rcd Secondary Index Pntr X
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CM6PLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Expand of Indx Blk
         LTGFR R15,R15             Expansion Complete Successfully?
         BRZ   L6BF4100            Yes => Branch to Set Slot Position
         ST    R15,L6F$RTCD        Save Highest Return Code Generated
         LGHI  R2,((L6BF4200-L6BF4100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   L6BF4100            No  => Process Log Record Insert
         BRU   L6BF7000            Process for Error
L6BF4100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   L6BF4200            Process Search for New Slot Position
         BRU   L6BF7000            Process for Index Block Expand Error
         BRU   L6BF7000            Process for Index Block Expand Error
         BRU   L6BF7000            Process for Severe Error - Exit
L6BF4200 DS    0H
         BRU   L6BF2200            Go Back to Find a New Slot Position
*
*+-------------------------------------------------------------------+*
*|     Perform The Insert Of the Log Record Into The Buffer Area     |*
*+-------------------------------------------------------------------+*
*
L6BF5000 DS    0H
         XC    CM6PLIST,CM6PLIST   Clear the Call Parameter List
         CALL  L6IN0000,           Perform Insert of Log Record Entry  X
               ((RCOMM4),          ..Pass Common Constants&Routines 2  X
               (RCOMM3),           ..Pass Common Constants&Routines 1  X
               (RCOMM2),           ..Pass Common Area Address 2        X
               (RCOMM1),           ..Pass Common Area Address 1        X
               L6FPINDX,           ..Pass Log Rcd Primary Index PointerX
               L6FSINDX,           ..Pass Log Rcd Secondary Indx Pntr  X
               L6FINPUT,           ..Pass Log Record Entry Pointer     X
               L6FOSLOT,           ..Pass Log Rcd Slot Position PointerX
               L6FTRTIM,           ..Pass the Log Record Timer Addr    X
               L6FTCBAD,           ..Pass the the Current TCB Address  X
               L6FACCUM),          ..Pass the Current Recrd Accum CountX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CM6PLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Insert Log Recrd in Buffer
         LTGFR R15,R15             Insert of Log Record Successfull?
         BRZ   L6BF5100            Yes => Branch to Process Next Insert
         ST    R15,L6F$RTCD        Save Highest Return Code Generated
         LGHI  R2,((L6BF6000-L6BF5100)-4) ...Length of Branch Table
         CGR   R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   L6BF5100            No  => Process Return From Routine
         BRU   L6BF7000            Process for Error
L6BF5100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   L6BF6000            Log Record Data Component Inserted
         BRU   L6BF7000            Log Record Error
         BRU   L6BF7000            Log Record Validation Error
         BRU   L6BF7000            High Severity Error
*
*+-------------------------------------------------------------------+*
*| Loop Point to Insert the Next Log Record From Temporary Work Area |*
*| Below-the-Line to Buffer Area Above-the-Bar                       |*
*+-------------------------------------------------------------------+*
*
L6BF6000 DS    0H
         LG    R2,L6FINPUT         Get Current Pointer to Log Rcrd List
         LA    R2,L'LGWLINE(,R2)   Move to Next Log Record Entry in Lst
         STG   R2,L6FINPUT         Preseve New Pointer in Record List
         LG    R4,L6BFOWCT         Get Current Count of Rows in List
         BRCTG R4,L6BF2100         Loop to Process Next Log Recrd Entry
L6BF6100 DS    0H
         SLGR  R15,R15             Clear the Condition Code Indicator
         ST    R15,L6F$RTCD        Set Highest Return Code Generated
         BRU   L6BF7100            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|  Set Condition Code For Insert Log Records to Buffer Processing   |*
*+-------------------------------------------------------------------+*
*
L6BF7000 DS    0H
         ST    R15,L6F$RTCD        Set Highest Return Code Generated
L6BF7100 DS    0H
         LLGF  R15,L6F$RTCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  L6BF$END            No  => Branch to Exit This Routine
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         BRU   L6BFEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6BF$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
L6BFEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*           End of Log Record Component Buffer Processing             *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 B X 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   B u i l d   O f   B u f f e r    I n d i c e s   |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: L6BX0000                                           *
*                                                                     *
* FUNCTION:        Build Log Record Indices and Record Buffers in     *
*                  Storage Above-the-Bar.                             *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  initial build of the log record data indices and   *
*                  buffer area upon the first time through.           *
*                                                                     *
*                  The log record indices and record buffers are      *
*                  created as memory objects using the IARV64 GETSTOR *
*                  service. This routine will create the memory       *
*                  objects with a size sufficiently large enough to   *
*                  meet anticipated requirements for long-term needs  *
*                  subject to the MEMLIMIT. The COND=YES parameter is *
*                  used in order to avoid abends in the event an      *
*                  attempt is made to acquire more storage above the  *
*                  bar than what the current MEMLIMIT will allow. In  *
*                  this event, if the request exceeds the MEMLIMIT and*
*                  the IARV64 service fails the request, this routine *
*                  will issue an error message and will exit. The user*
*                  program that Logger Services is tracking will      *
*                  continue to run normally. However, no new log      *
*                  records will be written to the output data set as  *
*                  there would be no buffers from which to retrieve   *
*                  them. Those log records which have already been    *
*                  placed into the existing buffers will be printed to*
*                  the output data set at the end of the user's job.  *
*                                                                     *
*                  This routine will determine the MEMLIMIT set for   *
*                  the job, and within the established MEMLIMIT three *
*                  distinct and separate memory objects are created   *
*                  with one memory object dedicated to the primary    *
*                  index area, a second memory object dedicated to the*
*                  secondary index area, and a third memory object for*
*                  the log records area. Even if a higher Memlimit is *
*                  set for the address space, the maximum amount of   *
*                  above-the-bar storage that may be used by the three*
*                  memory objects will be capped at a total of 10     *
*                  gigabytes (10GB). For purposes of buffering log    *
*                  records, 10 gigabytes should be a large enough     *
*                  number to be considered conceptual infinity.       *
*                                                                     *
*                  The log record data areas and index areas which are*
*                  created as above-the-bar memory objects will use   *
*                  the GUARDSIZE and GUARDHIGH parameters where each  *
*                  memory object will consist of two different areas. *
*                  One area is called a guard area, and this storage  *
*                  is not accessible. However, it is available to     *
*                  allow for a later request by Logger Services to    *
*                  change the guard area into a usable area where the *
*                  usable area can expand into the guard area when    *
*                  additional above-the-bar storage is needed to hold *
*                  log records accumulating in the buffers.           *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: L6BF0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: WTO      - To Process Messages                     *
*                  IARV64   - To Acquire Above the Bar Storage        *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Build Index Process                  *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
L6BX0000 RSECT *                   Read-Only Control Section Name
L6BX0000 AMODE &AMODE              Establish Addressing Mode
L6BX0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6BX0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   L6BX0002            Branch Past the Literal Area
         DC    C'L6BX0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLvl
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
L6BX0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING L6BX0000+(L6BX0001-L6BX0000),RBASE1  Set Addressability
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LG    R1,LCAF64R01-LCASAVE(,R1)  Get the Input Parameters
         STG   R1,L6XPINDX         Save Primary Index Block Pointer Adr
         XC    CM6RETCD,CM6RETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|  Check the Current MEMLIMIT Available for Creating Memory Objects |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
L6BX1000 DS    0H
         USING PSA,R0              Establish Addressability to the PSA
         LLGT  R2,PSAAOLD          Get Address Space Cntrl Blk Old Pntr
         LLGT  R1,ASCBRSME-ASCB(,R2) Get RSM Addr Space Blk Extension
         MVC   L6XMEMLM,RAXLVMEMLIM-RAX(R1) Get Addr Space Memory Limit
         DROP  R0                  Remove Listed Reg as PSA Base Reg
         LG    R0,L6XMEMLM         Get MEMLIMIT Value Expressed in Megs
         LTGR  R4,R0               MEMLIMIT=0M/0G/0T/0P Set for Job?
         BRNZ  L6BX1200            No  => Set Above the Bar Storage
         LLGT  R3,CVTPTR           Absolute Address of Pointer to CVT
         USING ECVT,R3             Addressability to the Extended CVT
         LLGT  R3,CVTECVT-CVT(,R3) Get Address to the Extended CVT Area
         CLC   ECVTPSEQ,=XL4'01011000' z/OS Version at V1R10 or Higher?
         BRL   L6BX1300            No  => A Zero MEMLIMIT Value Allowed
L6BX1100 DS    0H
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         MVC   LG6WTOMG(L'LGA01116),LGA01116 .Nonzero Memlimit Required
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Severe Error on IARV64 Fail
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         BRU   L6BX4000            Branch to Verify Final Condition Cde
         DROP  R3                  Remove Listed Reg as ECVT Base Reg
L6BX1200 DS    0H
         CGHI  R4,(LOGMXSIZ)       Is Max Request More Than Mem Limit?
         BRNH  L6BX1400            Yes -> Then Use What System Allows
L6BX1300 DS    0H
         LLGF  R4,=A(LOGMXSIZ)     Cap Total Storage at 10 Gigabytes
         BRU   L6BX1500            Branch to Process GetStore Request
L6BX1400 DS    0H
         CGHI  R4,(20)             Is Our Request for at Least 20 Meg?
         BRNL  L6BX1500            Yes -> Branch to Process GetStore
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         MVC   LG6WTOMG(L'LGA01117),LGA01117 .Minimum Memlimit Required
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Severe Error on IARV64 Fail
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         BRU   L6BX4000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*|       Acquire Memory Object For The Log Records Buffer Area       |*
*+-------------------------------------------------------------------+*
*
L6BX1500 DS    0H
         LGR   R0,R4               Get MemLimit Amount for All Objects
         SRLG  R0,R0,3 bits        Divide By 8 for the Secondary Index
         STG   R0,L6XOBIX2         Secondary Index Memory Object Size
         SLGR  R4,R0               Account for Secondary Index Object
         AGHI  R4,(-2)             Account for Primary Index Object
         STG   R4,L6XOBJSZ         Remaining Object Size for Log Recrds
         AGHI  R4,(-8)             Start Out With 8 Megs Usable Storage
         ST    R4,L6XGRDSZ         Anything Past 8 Megs is a Guard Area
         LGR   R11,R4              Hold the Log Record Guard Area Size
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6BX1600        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         DROP  R14                 Remove as Logger Work Area Base Reg
         LA    R3,LGA01120         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         LLILL R1,(L'LGA01120)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
         LA    R3,L6XOBJSZ         No. of 1 Meg Segments in Mem Object
         LA    R4,L6XGRDSZ         Size of the Guard Area in Mem Object
         IARV64 REQUEST=GETSTOR,   Create Memory Object for Log RecordsX
               COND=YES,           Set RC If Unable to Satisfy Request X
               CONTROL=UNAUTH,     Free by Unauth Caller Owning Object X
               FPROT=NO,           Memory Object is Not Fetch ProtectedX
               SVCDUMPRGN=YES,     Dump Usable Area of Obj on SDATA=RGNX
               SEGMENTS=(R3),      Indicate Object Size in Megabytes   X
               GUARDLOC=HIGH,      Guard Area Starts Top of Memory Obj X
               GUARDSIZE=(R4),     In Case More Storage is Needed LaterX
               ORIGIN=L6XORGIN,    Return Addr of 1st Byte of Mem ObjctX
               RETCODE=(R15),      Show Return Code for Memory Request X
               RSNCODE=(R0),       Show Reason Code for Memory Request X
               TTOKEN=NO_TTOKEN,   Memory Owned by TCB Creating Object X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Memory Object Getstor Successful?
         BRZ   L6BX1700            Yes => Then Branch to Process Object
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Set Return Code for Later Processing
         LA    R1,LGA01115         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         LLILL R1,(L'LGA01115)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
L6BX1600 DS    0H
         BRAS  R14,L6BXM100        Branch to Issue the Error Message
         BRU   L6BX4000            Branch to Exit This Routine
L6BX1700 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Completed
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         LG    REDB,L6XORGIN       Get Starting Address of Mem Object
         LGR   R0,REDB             Current Start Addr for Calculation
         ALGF  R0,=A(LOGPIDBS)     Calculate Ending Address Data Block
         STG   R0,L6X$HIGH         Preserve Ending Address of Data Blk
         LLGF  R14,=A(LOGPIDBS)    Obtain Size of Log Recrds Data Block
         STG   R14,LOGTRSIZ        Set Size in our Log Recrd Data Block
         LA    R14,LOGTRHLN(,REDB) Add the Length of the Header Section
         STG   R14,LOGTRSLT        Set Address of First Available Slot
*
*+-------------------------------------------------------------------+*
*|        Acquire Memory Object For The Secondary Index Area         |*
*+-------------------------------------------------------------------+*
*
L6BX2000 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6BX2100        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         DROP  R14                 Remove as Logger Work Area Base Reg
         LA    R3,LGA01121         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         LLILL R1,(L'LGA01121)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
         LG    R2,L6XOBIX2         Secondary Index Memory Object Size
         AGHI  R2,(-1)             Start Out With 1 Meg Usable Storage
         ST    R2,L6XGRDZ2         Anything Past 1 Meg is a Guard Area
         LA    R3,L6XOBIX2         No. of 1 Meg Segments in Mem Object
         LA    R2,L6XGRDZ2         Size of the Guard Area in Mem Object
         IARV64 REQUEST=GETSTOR,   Memory Object for a Secondary Index X
               COND=YES,           Set RC If Unable to Satisfy Request X
               CONTROL=UNAUTH,     Free by Unauth Caller Owning Object X
               FPROT=NO,           Memory Object is Not Fetch ProtectedX
               SVCDUMPRGN=YES,     Dump Usable Area of Obj on SDATA=RGNX
               SEGMENTS=(R3),      Indicate Object Size in Megabytes   X
               GUARDLOC=HIGH,      Guard Area Starts Top of Memory Obj X
               GUARDSIZE=(R2),     In Case More Storage is Needed LaterX
               ORIGIN=L6XORGIN,    Return Addr of 1st Byte of Mem ObjctX
               RETCODE=(R15),      Show Return Code for Memory Request X
               RSNCODE=(R0),       Show Reason Code for Memory Request X
               TTOKEN=NO_TTOKEN,   Memory Owned by TCB Creating Object X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Memory Object Getstor Successful?
         BRZ   L6BX2200            Yes => Then Branch to Process Object
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Set Return Code for Later Processing
         LA    R1,LGA01118         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         LLILL R1,(L'LGA01118)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
L6BX2100 DS    0H
         BRAS  R14,L6BXM100        Branch to Issue the Error Message
         BRU   L6BX4000            Branch to Exit This Routine
L6BX2200 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Completed
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         LG    RSDX,L6XORGIN       Addr of Initial Secondary Index Blk
         LLGF  R14,=A(LOGSILEN)    Obtain Size of Secondary Index Block
         STG   R14,LOGSISIZ        Set Size in our Secondary Index Blk
         LLGF  R14,=A(LOGSILEN-L'LOGSINDX) Get the Offset to Our Entry
         LA    R14,0(R14,RSDX)     Get the Address of the First Entry
         STG   R14,LOGSIFST        Set First Entry Pointer in Index Blk
         MVC   LOGSIHP2,=FD'1'     Set the Initial Count for Power of 2
*
*+-------------------------------------------------------------------+*
*|         Acquire Memory Object For The Primary Index Area          |*
*+-------------------------------------------------------------------+*
*
L6BX3000 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6BX3100        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         DROP  R14                 Remove as Logger Work Area Base Reg
         LA    R3,LGA01122         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         LLILL R1,(L'LGA01122)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
         LGHI  R2,(2)              Set Object Size of 2 Meg for Primary
         STG   R2,L6XOBIX1         Set the Usable Area for 1 Megabyte
         AGHI  R2,(-1)             Start Out With 1 Meg Usable Storage
         ST    R2,L6XGRDSZ         Set the Guard Area for 1 Megabyte
         LA    R3,L6XOBIX1         No. of 1 Meg Segments in Mem Object
         LA    R2,L6XGRDSZ         Size of the Guard Area in Mem Object
         IARV64 REQUEST=GETSTOR,   Create Mem Object for Primary Index X
               COND=YES,           Set RC If Unable to Satisfy Request X
               CONTROL=UNAUTH,     Free by Unauth Caller Owning Object X
               FPROT=NO,           Memory Object is Not Fetch ProtectedX
               SVCDUMPRGN=YES,     Dump Usable Area of Obj on SDATA=RGNX
               SEGMENTS=(R3),      Indicate Object Size in Megabytes   X
               GUARDLOC=HIGH,      Guard Area Starts Top of Memory Obj X
               GUARDSIZE=(R2),     In Case More Storage is Needed LaterX
               ORIGIN=L6XORGIN,    Return Addr of 1st Byte of Mem ObjctX
               RETCODE=(R15),      Show Return Code for Memory Request X
               RSNCODE=(R0),       Show Reason Code for Memory Request X
               TTOKEN=NO_TTOKEN,   Memory Owned by TCB Creating Object X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Memory Object Getstor Successful?
         BRZ   L6BX3200            Yes => Then Branch to Process Object
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Set Return Code for Later Processing
         LA    R1,LGA01119         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         LLILL R1,(L'LGA01119)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
L6BX3100 DS    0H
         BRAS  R14,L6BXM100        Branch to Issue the Error Message
         BRU   L6BX4000            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|              Initialize the Primary Index Area                    |*
*+-------------------------------------------------------------------+*
*
L6BX3200 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Completed
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         LG    RPDX,L6XORGIN       Addr of Initial Primary Index Block
         LLGF  R14,=A(LOGPILEN)    Obtain Size of Primary Index Block
         STG   R14,LOGPISIZ        Set Size in our Primary Index Block
         STG   RSDX,LOGPISXH       Establish Secondary Index Header
         STG   RSDX,LOGPISXT       Establish Secondary Index Trailer
         STG   REDB,LOGPIMTH       Establish Log Record Data Blk Header
         STG   REDB,LOGPIMTT       Establish Log Recrd Data Blk Trailer
         STG   RSDX,LOGPOIX2       Secondary Index Memory Object Origin
         LG    R14,=AD(LOGSISGZ)   Get Size of Secondary Index Segment
         LA    R14,0(RSDX,R14)     Pnt to End of Secondary Index Segmnt
         STG   R14,LOGPHIX2        Secondary Index Segment High Address
         LG    R14,=AD(LOGSILEN)   Get Length of Secondary Index Block
         LA    R14,0(RSDX,R14)     Pnt to End of Secondary Index Block
         STG   R14,LOGPHUX2        Secondary Indx Segment High Used Adr
         STG   REDB,LOGPOLRD       Log Record Data Memory Object Origin
         STG   R11,LOGPGRDZ        Log Record Memory Object Guard Size
         LLGF  R14,L6XGRDZ2        Secondary Indx Mem Object Guard Size
         STG   R14,LOGPGRD2        Maintain Guard Size in Primary Index
         LG    R14,=AD(LOGPIDBS)   Get Size of Log Record Data Segment
         LA    R14,0(REDB,R14)     Point to End of Log Record Segment
         STG   R14,LOGPHLRD        Log Record Data Segment High Address
         LLGF  R14,=A(LOGPILEN-L'LOGPINDX) Index to Last Index Entry
         LA    R14,0(R14,RPDX)     Get the Address of Last Index Entry
         STG   R14,LOGPIFST        Set First Entry Pointer in Index Blk
         STG   RSDX,0(,R14)        Set 1st Secondary Index Entry Value
         MVC   LOGPICNT,=FD'1'     Set Initial Primary Indx Entry Count
         MVC   LOGPIHP2,=FD'1'     Set the Initial Count for Power of 2
         LG    R2,L6XPINDX         Get Pointer to Primary Index Pointer
         LG    R2,0(,R2)           Get Pntr to Primary Index Block Addr
         STG   RPDX,0(,R2)         Preserve Primary Index Block Address
         BRU   L6BX$END            Done, Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|     Check Condition Code For Create Memory Objects Processing     |*
*+-------------------------------------------------------------------+*
*
L6BX4000 DS    0H
         LLGF  R15,CM6RETCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  L6BX$END            No  => Branch to Exit This Routine
         BRU   L6BXEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6BX$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
L6BXEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
*
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 B X M 1 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|I s s u e   I A R V 6 4   G e t s t o r   E r r o r  M e s s a g e |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: L6BXM100                                           *
*                                                                     *
* FUNCTION.......: Issues WTO Error Message on IARV64 Getstor Failure *
***********************************************************************
*
         USING LGRWK2II,R14        Establish Addressability to Log Area
L6BXM100 DS    0H
         STG   R14,CM6RTADR        Hold the Return Address in Save Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Referenced
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Work Area Base
         LLGFR R2,R2               Clear High Half to Prepare for Shift
         SRLG  R2,R2,12            Isolate the IARV64 System Abend Code
         ST    R2,CM6SYSCD         IARV64 System Abend Code to Wrk Area
         UNPK  CM6WORKD(5),CM6SYSCD+2(3) .Convert Value in Hex to Zoned
         TR    CM6WORKD(4),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   L6ISYSCD,CM6WORKD+1 IARV64 System Abend Code to Wrk Area
         LA    R1,L6ISYSCD         Point to IARV64 System Abend Code
         LLILL R15,(L'L6ISYSCD-1)  Set Length for IARV64 Abend Code
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         LG    R14,L6IMSGAD        Get Address for Error Message Text
         LLGH  R4,L6IMSGLN         Get the Length of Error Message Text
         BCTGR R4,R0               Decrement Indicated Length for EX
         MVC   LG6WTOMG(0),0(R14)  Show That an IARV64 Error Occurred
         EX    R4,*-6              Copy Text of Error Msg to Outpt Line
         LA    R2,LG6WTOMG+1(R4)   Point to End of Error Message Text
         MVC   0(*-*,R2),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy Completion Code to Output Line
         LA    R2,2(R15,R2)        Point to the End of Completion Code
         MVC   0(12,R2),=CL12'Reason Code=' ..Insert Reason Code Header
         LA    R2,12(,R2)          Increment to IARV64 Reason Cde Field
L6BXM200 DS    0H
         ST    R3,L6X$RSCD         Copy IARV64 Reason Code to Work Area
         LA    R11,L6X$RSCD        Get Addr IARV64 Reason Code Wrk Area
         LA    R14,L'L6X$RSCD      Obtain Leng in Bytes of Reason Code
         LA    R15,LDX$RWRK        Address of Area to Unpack Reason Cde
         LGR   R4,R14              Current Leng in Bytes of Reason Code
         SLLG  R4,R4,1 Bit         Multiply the Current Length by Two
         LGR   R5,R4               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R14              Put the Two Unpack Lengths Together
         UNPK  LDX$RWRK(0),0(0,R11) ...Indicated Target of the Execute
         EX    R5,*-6              Unpack IARV64 Reason Cde to Wrk Area
         BCTGR R4,R0               Decrement Length for the Execute
         EX    R4,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),LDX$RWRK    Indicated Target of the Next Execute
         EX    R4,*-6              Displayable Reason Code to WTO Line
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Severe Error on IARV64 Fail
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         LG    R14,CM6RTADR        Get Return Address From Save Area
         BR    R14                 Branch to Return To Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*           End of Build Index and Record Data Processing             *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 F D 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   F i n d  F o r  L o g   R e c o r d   E n t r y  |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: L6FD0000                                           *
*                                                                     *
* FUNCTION:        Find A Slot Position In Index Area for Log Record  *
*                                                                     *
*                  This routine will first search the primary index   *
*                  based on the fully qualified log record key. The   *
*                  current key is compared to the highest key in the  *
*                  secondary index block. That secondary index block  *
*                  address was obtained from a secondary index block  *
*                  pointer located in a primary index block entry. The*
*                  point in the primary index block in which the      *
*                  search starts represents the largest power of two  *
*                  that is less than or equal to half the number of   *
*                  current entries in the primary index block.        *
*                                                                     *
*                  If upon the first compare operation the incoming   *
*                  log record key does not match the primary index    *
*                  block, then a check is made to determine whether   *
*                  the compare was greater than or less than the      *
*                  highest log record key range in the secondary index*
*                  block header. This secondary index block is pointed*
*                  to from within the primary index block entry. This *
*                  search is to determine where in the primary index  *
*                  the search key for the secondary index block       *
*                  resides. The secondary index block header contains *
*                  the highest log record key for the range of keys in*
*                  that block. The search is to determine if the      *
*                  incoming log record has a key within the range of  *
*                  keys contained within the secondary index block. If*
*                  the input log record key is within the range of    *
*                  keys contained in the secondary index block or is  *
*                  a match, then the search of the primary index block*
*                  is complete, and a second search will begin in the *
*                  secondary index block for a matching log record in *
*                  the buffer area. Otherwise, the half of the primary*
*                  index entry area based on the current power of two *
*                  count which does not contain the search key range  *
*                  is discarded, and another compare is made at the   *
*                  center index entry area of the remaining entries   *
*                  which again assuming no match eliminates half the  *
*                  the remaining index entries. This process is       *
*                  continued until there is only a single primary     *
*                  index entry left that either falls within the log  *
*                  record key range of a secondary index block or     *
*                  there is no match. If there is no match on anything*
*                  in the primary index, this indicates the first time*
*                  through.                                           *
*                                                                     *
*                  Once a secondary index block address is found in   *
*                  the primary index, then this routine will search   *
*                  the secondary index block based on the fully       *
*                  qualified key of the input log record. The         *
*                  comparison will be to the key of the log record in *
*                  the buffer area. The address of the log record in  *
*                  the buffer area was obtained from the secondary    *
*                  index entry. The point in the secondary index in   *
*                  which the search starts again represents the       *
*                  largest power of two that is less than or equal to *
*                  half the number of current entries in the secondary*
*                  index block. The log record key is compared to the *
*                  key found at the current pointer to the secondary  *
*                  index block entry to determine in which half of the*
*                  secondary index area the search key must reside. If*
*                  the input log record key is not a match to the key *
*                  in the buffer area, then half the secondary index  *
*                  block area which does not contain the search key is*
*                  discarded, and compares are made to the center     *
*                  point of the remaining entries while continually   *
*                  eliminating half of the remaining secondary index  *
*                  entries.                                           *
*                                                                     *
*                  This search continues until there is only a single *
*                  secondary index entry left which either matches or *
*                  it does not. If there is no match, this means there*
*                  is not a duplicate log record in the buffer. If    *
*                  there is a match, this indicates there exists a    *
*                  duplicate entry in the buffer area. In that case,  *
*                  the request to insert the input log record is      *
*                  ignored. If there is no key match, then a new slot *
*                  position is calculated for the secondary index     *
*                  block to allow for the later insertion into the    *
*                  secondary index of a 64-bit pointer to the new log *
*                  record going into the buffer. This newly calculated*
*                  slot position value will be used later in the      *
*                  insertion routine (L6IN0000) which will dynamically*
*                  update the secondary index block during the write  *
*                  of the input log record into the above-the-bar     *
*                  buffer.                                            *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                  Parm6: Addr of Pointer to Secondary Index Block    *
*                  Parm7: Addr of Pointer to Log Record Data Table    *
*                  Parm8: Addr of Pointer to Log Record Input Area    *
*                  Parm9: Addr of Pointer to Log Record Slot          *
*                  Parm10:Addr of Pointer to Log Record CPU Time      *
*                  Parm11:Addr of Pointer to Log Record TCB Address   *
*                  Parm12:Addr of Pointer to Log Record Sequence No.  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: L6BF0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success - No Matching Record Was Found        *
*                  04 - Warning - Duplicate Record Found              *
*                  08 - Error on Log Record Search Process            *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
L6FD0000 RSECT *                   Read-Only Control Section Name
L6FD0000 AMODE &AMODE              Establish Addressing Mode
L6FD0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6FD0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   L6FD0002            Branch Past the Literal Area
         DC    C'L6FD0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
L6FD0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING L6FD0000+(L6FD0001-L6FD0000),RBASE1  Set Addressability
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LMG   R15,R6,LCAF64R01-LCASAVE(R1) Get the Input Parameters
         STG   R15,L6NPINDX        Save Adr Primary Index Block Pointer
         STG   R0,L6NSINDX         Save Adr Secondary Index Blk Pointer
         STG   R1,L6NTRTBL         Save Adr Log Record Table Pntr
         STG   R2,L6NINPUT         Save the Log Record Area Pointer
         STG   R3,L6NOSLOT         Save the Recrd Slot Position Pointer
         STG   R4,L6NTRTIM         Save the Log Record Time Address
         LG    R5,0(,R5)           Get Pointer to Log Record TCB Addr
         STG   R5,L6NTCBAD         Save the Log Record TCB Address
         LG    R6,0(,R6)           Get Pointer to Log Rcrd Seq No. Addr
         STG   R6,L6NSEQNO         Save Log Record Sequence No. Address
         XC    CM6RETCD,CM6RETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|Search The Primary Index Block for Pointer To Secondary Index Block|*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
RNGE     USING LOGTRBLK,R11        Establish LOGTRBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
L6FD1000 DS    0H
         LG    R1,L6NPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LG    R1,L6NTRTIM         Get Pointer to Log Recrd Timer Addr
         LG    R1,0(,R1)           Get the Log Record Timer Address
         MVC   L6N$TOKN,0(R1)      Build Log Record 1st Key Entry
         LG    R2,L6NTCBAD         Get Address to Log Recrd TCB Addr
         MVC   L6N$TCB@,0(R2)      Build Log Record 2nd Key Entry
         LG    R2,L6NSEQNO         Get Address to Log Rcrd Sequence No.
         MVC   L6N$SEQ#,0(R2)      Build Log Record 3nd Key Entry
         LG    R2,LOGPIFST         Get Address of First Populated Slot
         LG    R3,LOGPIHP2         Get Highest Power of 2 LE Entry Cnt
         LGR   R14,R3              Preserve Index Value as Delimiter
L6FD1100 DS    0H
         LTGR  RSDX,R3             Get the Current Index Entry to Check
         BRZ   L6FD1200            Branch If 1st Time Entry Validation
         BCTGR RSDX,0              Make Indx Beginning Relative to Zero
         SLLG  RSDX,RSDX,3 Bits    Times Length of an Index Entry (*8)
L6FD1200 DS    0H
         LA    RSDX,0(RSDX,R2)     Point At Slot in Index Blk to Check
         LG    RSDX,0(,RSDX)       Get the Secondary Index Address
         CLC   LOGSIKEY,L6N$TKEY   This Entry Have Our Log Record Key?
         BRH   L6FD1300            No  => Check for the Index Key Range
         BRL   L6FD1400            No  => Move Higher in Index Block
         BRU   L6FD2000            Matching Secondary Index Entry Found
L6FD1300 DS    0H
         LG    R11,LOGSIFST        Get Address of First Populated Slot
         LG    R11,0(,R11)         Get Log Record Data Table Entry
         CLC   RNGE.LOGTRKEY,L6N$TKEY Entry Within Index Blk Key Range?
         BRNH  L6FD2000            Yes => Matching Secondary Indx Found
         BRU   L6FD1500            No  => Move Lower in Index Block
L6FD1400 DS    0H
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   L6FD2000            Secondary Index Key Range Located
         SGR   R3,R14              Point At Slot in the Index Block
         BRU   L6FD1100            Branch to Continue Search of Index
L6FD1500 DS    0H
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   L6FD2000            Secondary Index Key Range Located
L6FD1600 DS    0H
         LGR   R15,R14             Establish Current Power of 2 Value
         AGR   R15,R3              Calculate Next Secondary Index Value
         CG    R15,LOGPICNT        Past End of Primary Index Block?
         BRH   L6FD1500            Yes => Attempt Moving Higher in Blk
L6FD1700 DS    0H
         LGR   R3,R15              Point At Current Slot in Index Block
         BRU   L6FD1100            Branch to Continue Search of Index
         DROP  RNGE                Remove Listed Reg as Table Base Reg
*
*+-------------------------------------------------------------------+*
*|  Found the Secondary Index Block. Now Calculate a Slot Position   |*
*|  Within the Secondary Index Block to Insert a 64-Bit Pointer to   |*
*|  the Log Record to be Inserted in the Above-the-Bar Buffer.       |*
*+-------------------------------------------------------------------+*
*
L6FD2000 DS    0H
         LG    R2,LOGSIFST         Get Address of First Populated Slot
         LG    R3,LOGSIHP2         Get Highest Power of 2 LE Entry Cnt
         LGR   R14,R3              Preserve Index Value as Delimiter
L6FD2100 DS    0H
         LTGR  REDB,R3             Get the Current Index Entry to Check
         BRZ   L6FD2200            Branch If 1st Time Record Validation
         BCTGR REDB,0              Make Indx Beginning Relative to Zero
         SLLG  REDB,REDB,3 Bits    Times Length of an Index Entry (*8)
L6FD2200 DS    0H
         LA    REDB,0(REDB,R2)     Point At Slot in Index Blk to Check
         LG    REDB,0(,REDB)       Get the Secondary Index Address
         CLC   LOGTRKEY,L6N$TKEY   This Entry Have Our Log Record Key?
         BRH   L6FD2300            No  => Move Lower in Index Block
         BRL   L6FD2500            No  => Move Higher in Index Block
         BRU   L6FD3100            Duplicate Log Recrd Entry Was Found
L6FD2300 DS    0H
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   L6FD2400            Log Record Data Entry Was Not Found
         SGR   R3,R14              Point At Slot in the Index Block
         BRU   L6FD2100            Branch to Continue Search of Index
L6FD2400 DS    0H
         BCTGR R3,R0               Decrement Index Slot Position by One
         LG    R1,L6NOSLOT         Get Slot to Insert Log Record After
         STG   R3,0(,R1)           Save Slot to Insert Log Recrd After
         BRU   L6FD3000            Log Record Entry Was Not Found
L6FD2500 DS    0H
         LG    R1,L6NOSLOT         Get Slot to Insert Log Record After
         STG   R3,0(,R1)           Save Slot to Insert Log Recrd After
         SRAG  R14,R14,1           Set for the Next Lower Power of Two
         BRZ   L6FD3000            Log Record Entry Was Not Found
L6FD2600 DS    0H
         LGR   R15,R14             Establish Current Power of 2 Value
         AGR   R15,R3              Calculate Next Secondary Index Value
         CG    R15,LOGSICNT        Past End of Secondary Index Block?
         BRH   L6FD2500            Yes => Attempt Moving Higher in Blk
L6FD2700 DS    0H
         LGR   R3,R15              Point At Current Slot in Index Block
         BRU   L6FD2100            Branch to Continue Search of Index
*
*+-------------------------------------------------------------------+*
*|      Indicate Status of Search for Log Record Insert Request      |*
*+-------------------------------------------------------------------+*
*
L6FD3000 DS    0H
         SLGR  REDB,REDB           Zero the Log Record Pointer Value
         LG    R3,L6NTRTBL         Get Address Log Recrd Table Pointer
         STG   REDB,0(,R3)         Set Log Component Pointer to Zeros
         LG    R3,L6NSINDX         Get Address Secondary Index Pointer
         STG   RSDX,0(,R3)         Save the Secondary Index Pointer
         BRU   L6FD$END            OK to Insert, Component Not Found
L6FD3100 DS    0H
         LG    R3,L6NTRTBL         Get Addr Log Record Table Pointer
         STG   REDB,0(,R3)         Save Address of Log Record Found
         LG    R1,L6NINPUT         Get Pointer to Log Rcrd Input Area
         LG    R1,0(,R1)           Get the Log Record Data Area Addr
         MVI   L'LOGTRCRD-1(R1),X'FF' ...Set Duplicate Status Indicator
L6FD3200 DS    0H
         LA    R15,4               Indicate Duplicate Log Record Entry
         ST    R15,CM6RETCD        Set Highest Return Code Generated
         BRU   L6FDEXIT            Ignore Insert Request, Record Found
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6FD$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
         ST    R15,CM6RETCD        Set Highest Return Code Generated
L6FDEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*                 End of Index Area Search Processing                 *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 E X 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|    P e r f o r m   E x p a n d   o f   I n d e x   B l o c k      |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: L6EX0000                                           *
*                                                                     *
* FUNCTION:        Expand the Secondary Index To Prepare For The      *
*                  Insert Of A Log Record Into Buffer.                *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  expansion of the secondary index. An expansion is  *
*                  required because an insert of a log record into    *
*                  a log record memory object is pending because a    *
*                  secondary index block which indexes the log records*
*                  in the log record memory object has filled up.     *
*                                                                     *
*                  When a secondary index block has filled then this  *
*                  routine will increment by 32K the high-used address*
*                  field maintained in the primary index, and the old *
*                  high-used address becomes the start point for a new*
*                  secondary index block within the available usable  *
*                  area of the secondary index memory object. This    *
*                  build of new secondary index blocks which are 32K  *
*                  in size will continue as more log records are      *
*                  added. With each build of a new secondary index    *
*                  block the high-used address is incremented by 32K  *
*                  and then compared to the high-address for the      *
*                  current usable area. If the high-used address      *
*                  calculated for a new secondary index block becomes *
*                  greater than the current high-address for the      *
*                  usable area, then more secondary index blocks are  *
*                  needed that what can fit in the available usable   *
*                  area of the above-the-bar memory object. A usable  *
*                  area of one megabyte can hold up to 32 separate    *
*                  secondary index blocks. When 32 32K blocks have    *
*                  been filled, then a usable 1 megabyte memory object*
*                  segment has also become full. When this happens, in*
*                  addition to creating another secondary index block,*
*                  another one megabyte segment also needs to be      *
*                  obtained from the guard area to expand the usable  *
*                  area. This means that for every 4,000 index entries*
*                  a secondary index block is created from the usable *
*                  area, and for every 128,000 index entries a one    *
*                  megabyte segment is required from the guard area.  *
*                                                                     *
*                  In the event that the current usable area for the  *
*                  secondary index memory object fills up and is      *
*                  unable to hold a new secondary index block, then   *
*                  the IARV64 CHANGEGUARD request is utilized to      *
*                  increase the amount of usable area in the secondary*
*                  index memory object by adjusting the size of the   *
*                  initial guard area. This is done through the       *
*                  removal of a 1 megabyte segment from the guard area*
*                  as storage needs increase from the filling of      *
*                  secondary index blocks. This means if there is not *
*                  enough room in the usable area for the next index  *
*                  block, then the IARV64 REQUEST=CHANGEGUARD service *
*                  is used to allocate another megabyte from the guard*
*                  area. When this occurs the address in field        *
*                  LOGPHIX2 is updated to set a new high-address for  *
*                  the usable area. LOGPHIX2 is the usable area       *
*                  high-address field maintained in the primary index *
*                  which is incremented by one megabyte. This becomes *
*                  the new usable area high-address for comparision   *
*                  to the high-used address field LOGPHUX2 maintained *
*                  in the primary index block. This high-used field is*
*                  being incremented by 32K for each new secondary    *
*                  index block created in the usable area from the    *
*                  addition of new log records. When a one megabyte   *
*                  segment fills with 32 32K secondary index blocks,  *
*                  that's when the CHANGEGUARD is used to add to the  *
*                  usable area in the secondary index memory object.  *
*                                                                     *
*                  All addresses in the usable area are incremented   *
*                  upwards as GUARDLOC=HIGH was used in a previous    *
*                  invokation of IARV64 GETSTOR which created the     *
*                  guard area at the high addresses of the memory     *
*                  object. The usable area is increased as needed to  *
*                  hold secondary index blocks until the guard area is*
*                  exhausted, with the total above-the-bar storage    *
*                  available to the secondary index memory object     *
*                  being subject to the amount specified in MEMLIMIT. *
*                                                                     *
*                  Once an additional one megabyte area of usable     *
*                  storage is acquired within the memory object for a *
*                  new secondary index block or a new secondary index *
*                  block is created within an existing usable area    *
*                  segment, then this routine will chain in the new   *
*                  index block prior to the old index block which has *
*                  filled up. Thereafter the first half of the index  *
*                  entries in the filled up old block will be copied  *
*                  into the last half of the newly created secondary  *
*                  index block. Then the first half of the index      *
*                  entries in the old block will be cleared to binary *
*                  zeros to allow the old block to accept new entries.*
*                  Then the forward and backward chain pointers will  *
*                  be updated. This results in the movement of half   *
*                  the index entries in an old secondary index block  *
*                  to a new secondary index block. Only one new       *
*                  secondary index block is created upon entry to this*
*                  routine. However, this routine may be called for as*
*                  many times as is necessary to create an additional *
*                  new index block to index the increasing volume of  *
*                  log records being placed in the log record memory  *
*                  object.                                            *
*                                                                     *
*                  Once a secondary index block as been split into two*
*                  separate secondary index blocks, then the primary  *
*                  index block in the primary index memory object is  *
*                  updated. The primary index block contains the      *
*                  pointers to all of the secondary index blocks which*
*                  themselves contain pointers to the log records in  *
*                  the log record memory object. The primary index is *
*                  updated in order to add a pointer to the newly     *
*                  created secondary index block as a result of the   *
*                  split. A new entry is added to the primary index by*
*                  calculating the length of that particular area     *
*                  within the primary index block which needs to slide*
*                  over for 8-bytes in order to free up the correct   *
*                  index slot position calculated to maintain the     *
*                  proper sort sequence for the indices. The 64-bit   *
*                  address pointing to the newly created secondary    *
*                  index block is then inserted into the newly opened *
*                  primary index slot position. Thereafter the primary*
*                  and secondary index chain pointers are updated to  *
*                  maintain the proper indexing of the records in the *
*                  log record buffers.                                *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                  Parm6: Addr of Pointer to Secondary Index Block    *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: L6BF0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: WTO      - To Process Messages                     *
*                  STORAGE  - To Acquire Storage                      *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Split Index Process                  *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
L6EX0000 RSECT *                   Read-Only Control Section Name
L6EX0000 AMODE &AMODE              Establish Addressing Mode
L6EX0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6EX0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   L6EX0002            Branch Past the Literal Area
         DC    C'L6EX0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
L6EX0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING L6EX0000+(L6EX0001-L6EX0000),RBASE1  Set Addressability
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LMG   R1,R2,LCAF64R01-LCASAVE(R1)  Get the Input Parameters
         STG   R1,L6EXINDX         Save Adr Primary Index Block Pointer
         STG   R2,L6XSINDX         Save Adr Secondary Index Blk Pointer
         XC    CM6RETCD,CM6RETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|Verify if there is sufficient space in the usable area to create   |*
*|a new secondary index. If no space, acquire an additional usable   |*
*|area from the guard area of the secondary index memory object to   |*
*|hold more secondary index blocks. Also, since the guard size counts|*
*|against the segments if not the MEMLIMIT, verify that if a         |*
*|CHANGEGUARD request is made it does not exceed the available guard |*
*|size. Use a recovery routine for the IARV64 CHANGEGUARD service in |*
*|the event of an abend in IARV64.                                   |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
PREV     USING LOGSIBLK,R2         Establish Previous Blk Addessability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
L6EX1000 DS    0H
         LG    R1,L6EXINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LG    R1,L6XSINDX         Get Pointer to Secondary Index Block
         LG    RSDX,0(,R1)         Get the Secondary Index Block Addr
         LG    R2,LOGPHUX2         Secondary Indx Mem Obj High Used Adr
         LLGF  R3,=A(LOGSILEN)     Get Length of Secondary Index Block
         LA    R11,0(R2,R3)        Add for Next Secondary Index Block
         CLG   R11,LOGPHIX2        Hi-Used Address to Exceed Hi-Usable?
         BRNH  L6EX2000            No  -> Add Index Blk to Usable Area
         LG    R1,LOGPGRD2         Secondary Indx Mem Object Guard Size
         CGHI  R1,(1)              Is Remaining Guard Size Sufficient?
         BRNL  L6EX1200            Yes => Process the Secondary Index
L6EX1100 DS    0H
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         MVC   LG6WTOMG(L'LGA01128),LGA01128 Request Exceeds Guard Area
         BRU   L6EX1600            Branch to Issue Error Message
*
*+-------------------------------------------------------------------+*
*|Get More Usable Area from Memory Object for New Secondary Index Blk|*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R14        Establish Addressability to Log Area
L6EX1200 DS    0H
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6EX1400        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         LA    R3,LGA01125         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         DROP  R14                 Remove Listed Reg as Log Area Base
         AGHI  R1,(-1)             Reduce Guard Size to Add Usable Area
         STG   R1,LOGPGRD2         Remaining Secondary Index Guard Size
         LA    R3,LOGPOIX2         Secondary Index Memory Object Origin
         IARV64 REQUEST=CHANGEGUARD, Convert Guard Area to Usable Area X
               COND=YES,           Set RC If Unable to Satisfy Request X
               CONVERT=FROMGUARD,  Change a Guard Area to a Usable AreaX
               CONVERTSIZE==A(1),  Add One Megabyte to the Usable Area X
               MEMOBJSTART=(R3),   Addr of First Byte in Memory Object X
               RETCODE=(R15),      Return Code for ChangeGuard Request X
               RSNCODE=(R0),       Reason Code for ChangeGuard Request X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Was Memory Object Change Successful?
         BRZ   L6EX1300            Yes => Then Branch to Process Index
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Later on This Will be Shifted Back
         LA    R1,LGA01123         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         BRU   L6EX1400            Branch to Process Error Message
L6EX1300 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Byte Referenced
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         LG    R1,LOGPHIX2         Secondary Index Mem Object High Addr
         LLGF  R14,=A(LOGSISGZ)    Get Size of the Usable Area Added
         LA    R14,0(R1,R14)       Add 1 Meg to Memory Object Address
         STG   R14,LOGPHIX2        Set New High Address for Usable Area
         BRU   L6EX2000            Branch to Process Index Blocks
*
*+-------------------------------------------------------------------+*
*| Issue Error Message for Secondary Index Block ChangeGuard Failure |*
*+-------------------------------------------------------------------+*
*
L6EX1400 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Byte Referenced
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Work Area Base
         LLGFR R2,R2               Clear High Half to Prepare for Shift
         SRLG  R2,R2,12            Isolate the IARV64 System Abend Code
         ST    R2,CM6SYSCD         IARV64 System Abend Code to Wrk Area
         UNPK  CM6WORKD(5),CM6SYSCD+2(3) .Convert Value in Hex to Zoned
         TR    CM6WORKD(4),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   L6ISYSCD,CM6WORKD+1 IARV64 System Abend Code to Wrk Area
         LA    R1,L6ISYSCD         Point to IARV64 System Abend Code
         LLILL R15,(L'L6ISYSCD)    Set Length for IARV64 Abend Code
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         LG    R14,L6IMSGAD        Get Address for Error Message Text
         MVC   LG6WTOMG(L'LGA01125),0(R14)  ..Indicate an IARV64 Error
         LA    R2,LG6WTOMG+L'LGA01125 Point to the End of Message Text
         MVC   0(*-*,R2),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy Return Cde Value to Output Line
         LA    R2,2(R15,R2)        Point to the End of Abend Code Value
         MVC   0(12,R2),=CL12'Reason Code=' ..Insert Reason Code Header
         LA    R2,12(,R2)          Increment to IARV64 Reason Cde Field
L6EX1500 DS    0H
         ST    R3,L6X$RSCD         ChangeGuard Reason Code to Work Area
         LA    R11,L6X$RSCD        Addr ChangeGuard Reason Code Field
         LA    R14,L'L6X$RSCD      Obtain Leng in Bytes of Reason Code
         LA    R15,LDX$RWRK        Addr of IARV64 Reason Code Work Area
         LGR   R4,R14              Current Leng in Bytes of Reason Code
         SLLG  R4,R4,1 Bit         Multiply the Current Length by Two
         LGR   R5,R4               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R14              Put the Two Unpack Lengths Together
         UNPK  LDX$RWRK(0),0(0,R11) ...Indicated Target of the Execute
         EX    R5,*-6              Unpack IARV64 Reason Cde to Wrk Area
         BCTGR R4,R0               Decrement Length for the Execute
         EX    R4,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),LDX$RWRK    Indicated Target of the Next Execute
         EX    R4,*-6              Displayable Reason Code to WTO Line
L6EX1600 DS    0H
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Severe Error on IARV64 Fail
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         BRU   L6EX4000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*| A new empty secondary index block has been created in the         |*
*| above-the-bar usable area of the memory object. Now split the old |*
*| secondary index block which had filled up by moving the top half  |*
*| of the entries from the old block to the bottom half of the new   |*
*| one. Then clear that half of the old secondary index block that   |*
*| contained the entries which were moved to the new secondary index |*
*| block. This is done in order to create free space in the old block|*
*| to hold more entries in addition to the new free space in the new |*
*| secondary index block. Then update the chain pointers in the new  |*
*| and the old secondary index blocks.                               |*
*+-------------------------------------------------------------------+*
*
L6EX2000 DS    0H
         LLGF  R15,=A(LOGSILEN)    Get Size of Secondary Index Block
         STG   R15,PREV.LOGSISIZ   Set the Size in New Secondary Block
         MVC   PREV.LOGSIPRV,LOGSIPRV Set Prev Block Pointer in New Blk
         STG   RSDX,PREV.LOGSINXT  Set Next Block Pointer in New Block
         STG   R2,LOGSIPRV         Set the New Prev Pointer in Old Blk
         LG    R15,LOGSICNT        Get the Entry Count For a Full Block
         SRLG  R15,R15,1           Divide the Index Entry Count by 2
         STG   R15,LOGSICNT        Set the New Entry Count in Old Block
         STG   R15,PREV.LOGSICNT   Set the New Entry Count in New Block
         LLGF  R15,=A(LOGSISPL)    Get Length of a Split Index Block
         LA    R14,LOGSINDX(R15)   Get the Address of New First Pointer
         STG   R14,LOGSIFST        Set the New First Indx Entry Pointer
         LA    R14,PREV.LOGSINDX(R15) Get Address of New First Pointer
         STG   R14,PREV.LOGSIFST   Set the New First Indx Entry Pointer
         MVC   LOGSIHP2,=AD(1024)  Set Highest Power of 2 in Old Block
         MVC   PREV.LOGSIHP2,=AD(1024)   Set Highest Power 2 in New Blk
L6EX2100 DS    0H
         LGR   R0,R14              Point to Bottom Half in New Block
         LGR   R1,R15              Set The Length to Receive in New Blk
         LA    R14,LOGSINDX        Point to the Top Half in Old Block
L6EX2200 DS    0H
         MVCLE R0,R14,0            Move Half of the Entries to New Blk
         BRO   L6EX2200            Upon Interrupt Resume Where Left Off
L6EX2300 DS    0H
         LA    R0,0                Indicate the Sending Area is Nulls
         LA    R1,R0               No Length and Pad Character to Zeros
         LA    R14,LOGSINDX        Point to the Top Half in Old Block
         LLGF  R15,=A(LOGSISPL)    Get Length of a Split Index Block
         MVCLE R14,R0,0            Zero Half the Entries in Old Block
L6EX2400 DS    0H
         LLGF  R14,=A(LOGSILEN-L'LOGSILST) Get the Offset to Our Entry
         LG    REDB,0(R14,R2)      Get the Last Entry in New Index Blk
         MVC   PREV.LOGSIKEY,LOGTRKEY Set High Key Value in Index Block
         LG    REDB,0(R14,RSDX)    Get The Last Entry in Old Index Blk
         MVC   LOGSIKEY,LOGTRKEY   Set High Key Value in Index Block
L6EX2500 DS    0H
         LG    R15,LOGSIPRV        Get Secondary Index Previous Block
         LTGR  R15,R15             There A Previous Block to This One?
         BRZ   L6EX3000            No  => Branch to Update Primary Indx
L6EX2600 DS    0H
         LGR   R11,R15             Save the Previous Block to This One
         STG   RSDX,PREV.LOGSINXT  Update Next Blk in New Previous Blk
         DROP  PREV                Remove Listed Reg as New Block Base
*
*+-------------------------------------------------------------------+*
*|  Update The Primary Index Block by Inserting Into the Primary     |*
*|  Index a 64-Bit Pointer to the New Secondary Index Block Which    |*
*|  Was Created as a Result of the Block Split.                      |*
*+-------------------------------------------------------------------+*
*
L6EX3000 DS    0H
         LG    R15,LOGPIFST        Get 1st Populated Slot in Index Blk
         LG    R14,LOGPISIZ        Get Size of Primary Index Block
         LA    R14,0(RPDX,R14)     Point to End of Primary Index Block
L6EX3100 DS    0H
         CG    RSDX,0(R15)         Is this our Secondary Index Entry?
         BRE   L6EX3200            Yes => Branch to Process Primary Idx
         LA    R15,8(,R15)         Get the Next Index Entry to Check
         CGR   R15,R14             At End of the Primary Index Block?
         BRL   L6EX3100            Loop to Check Next Primary Idx Entry
         LA    R15,8               Indicate Severe Error on Undex Entry
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         BRU   L6EX4000            Branch to Exit From This Routine
L6EX3200 DS    0H
         LG    R14,LOGPIFST        Get 1st Populated Slot in Index Blk
         LGR   R2,R15              Save New Index Slot Position to Fill
         LA    R15,L'LOGPINDX(,R15) ...Point to Following Slot Position
         SLGR  R15,R14             Calculate the Total Length to Shift
         LGR   R0,R14              Get Address of 1st Populated Slot
         SLGF  R0,=A(L'LOGPINDX)   Push Slot Position Forward One Entry
         STG   R0,LOGPIFST         Set a New Primary Index First Entry
         LGR   R1,R15              Set the Length to Move Index Entries
L6EX3300 DS    0H
         MVCLE R0,R14,0            Open New Primary Index Slot Position
         BRO   L6EX3300            Upon Interrupt Resume Where Left Off
L6EX3400 DS    0H
         LLGF  R15,=A(LOGPILEN-L'LOGPINDX) Index to Last Index Entry
         LA    R15,0(R15,RPDX)     Get the Address of Last Index Entry
         CGR   R14,R15             Update For First Initial Blk Split?
         BRH   L6EX3500            Yes => Branch to Adjust Chain in Blk
         LG    R14,0(,R14)         Get the Next Previous Block Pointer
         STG   R11,16(,R14)        New Previous Block to Next Previous
L6EX3500 DS    0H
         LGR   RSDX,R11            Set New Previous Blk as Current Blk
         STG   RSDX,0(R2)          Set Address of New Secondary Index
         LLGF  R14,=A(LOGSILEN)    Get Length of Secondary Index Block
         LA    R14,0(R14,RSDX)     New Hi Used Addr for Secondary Index
         STG   R14,LOGPHUX2        Copy High Used Addr to Primary Index
         LG    R14,LOGPICNT        Get Previous Primary Index Entry Cnt
         LA    R14,1(,R14)         Increment Primary Index Entry Count
         STG   R14,LOGPICNT        Store Updated Count in Primary Index
         LG    R14,LOGPIHP2        Get Previous Power of 2 for Index
         SLLG  R14,R14,1 Bit       Primary Index Power of 2 Times 2
         CG    R14,LOGPICNT        Index Count Need Higher Power of 2?
         BRH   L6EX$END            No  => Branch to Exit This Routine
         STG   R14,LOGPIHP2        Yes => Set Next Higher Power of 2
         BRU   L6EX$END            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|   Check Condition Code For Secondary Index Expansion Processing   |*
*+-------------------------------------------------------------------+*
*
L6EX4000 DS    0H
         LLGF  R15,CM6RETCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  L6EX$END            No  => Branch to Exit This Routine
         BRU   L6EXEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6EX$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
         ST    R15,CM6RETCD        Save Highest Return Code Generated
L6EXEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*          End of Secondary Index Block Expansion Processing          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 I N 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|      P e r f o r m   I n s e r t   o f   L o g   R e c o r d      |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: L6IN0000                                           *
*                                                                     *
* FUNCTION:        Insert Log Record Into the Above-the-Bar Buffer    *
*                                                                     *
*                  This routine performs the insertion of a log record*
*                  into the buffers. First acquire the address of the *
*                  last buffer area in the chain of buffer areas that *
*                  comprise the above-the-bar log record memory       *
*                  object. A check is made to verify if there is      *
*                  sufficient room remaining in the usable area of the*
*                  memory object to insert the next log record. If    *
*                  not, then acquire more storage by converting a     *
*                  portion of the guard area to a usable area with the*
*                  IARV64 CHANGEGUARD service for the nonshared       *
*                  private memory object used to hold the log records.*
*                                                                     *
*                  The CHANGEGUARD is invoked with the COND=YES option*
*                  to prevent an abend in the event the MEMLIMIT is   *
*                  exceeded. This is about the only abend that the    *
*                  COND=YES option will prevent, and any other        *
*                  requests where there is an environmental issue, or *
*                  the request cannot be satisfied will result in the *
*                  abend of the IARV64 service in this program. To    *
*                  mitigate this exposure, before calling the IARV64  *
*                  CHANGEGUARD service, the remaining memory object   *
*                  guard size is checked to verify if the guard area  *
*                  for the memory object has been used up before the  *
*                  MEMLIMIT has been reached. In addition the AMODE64 *
*                  ESTAEX recovery program LGMHESTA is wrapped around *
*                  the IARV64 CHANGEGUARD call. The LGMHESTA recovery *
*                  routine will use a Register Update Block (RUB) in  *
*                  the SETRP to load registers R2 and R3 to return the*
*                  IARV64 abend code and the reason code back to this *
*                  L6IN0000 routine. On abend the IARV64 places the   *
*                  abend code in R0 and the reason code in R15. Now   *
*                  without the RUP these values are not preserved when*
*                  a CHANGEGUARD abend occurs. On abend the sequence  *
*                  is the CHANGEGUARD call is made, the CHANGEGUARD   *
*                  fails, CHANGEGUARD then calls the Abend macro to   *
*                  terminate, RTM intercepts the abend, followed by   *
*                  invocation of the ESTAEX recovery program LGMHESTA,*
*                  and then its a SETRUP back to the retry address at *
*                  label L6IN1400 in this routine to issue an error   *
*                  message on the cause of the IARV64 failure, then   *
*                  return to the LGMHLRCE program, and then LGMHLRCE  *
*                  returns back to the user program. This means if the*
*                  IARV64 CHANGEGUARD service does abend, program     *
*                  execution continues to completion, but the IARV64  *
*                  CHANGEGUARD failure will prevent any further       *
*                  buffering of log records. The user program runs to *
*                  normal completion except for the log report which  *
*                  is cut short, and only the log records which were  *
*                  created previous to the IARV64 abend will be       *
*                  written to the output //LGRECOUT data set.         *
*                                                                     *
*                  If the IARV64 CHANGEGUARD request is successful,   *
*                  then a new usable 8 meg area has been created from *
*                  the guard area where the boundary for the usable   *
*                  area is moved higher for the number of segments    *
*                  specified by CONVERTSIZE= which will be for 8      *
*                  megabytes. The usable area address is moved upwards*
*                  because the guard area was originally allocated    *
*                  from the high virtual address and downwards because*
*                  a previous IARV64 GETSTOR used the GUARDLOC=HIGH   *
*                  option where the guard area starts at the top of   *
*                  the memory object. Once a new 8 megabyte usable    *
*                  area has been acquired, then this routine will     *
*                  update the Log Record Control Block to chain in the*
*                  new usable area after the previous high usable     *
*                  address in the memory object, and add a backward   *
*                  chain pointer. This routine will continue with the *
*                  insertion of the log record into the expanding     *
*                  usable area of the above-the-bar memory object by  *
*                  calculating an offset into the usable area to find *
*                  space to hold the record, and then write the log   *
*                  record into the log record memory object.          *
*                                                                     *
*                  Next this routine was passed from the calling      *
*                  routine (L6BF0000) an address of a secondary index *
*                  slot position to be used to hold the pointer to the*
*                  log record inserted into the log record memory     *
*                  object. This slot position is based on maintaining *
*                  the secondary index in the proper sorted sequence  *
*                  depending on the record key of the log record to be*
*                  inserted. The slot position calculated in the      *
*                  secondary index for the current log record may     *
*                  already be occupied by another address pointing to *
*                  a previously inserted log record. This new index   *
*                  entry is inserted into the secondary index by      *
*                  calculating the length of that portion within the  *
*                  secondary index block which needs to slide over for*
*                  8 bytes in order to open up a new slot position to *
*                  hold the 64-bit pointer to the new log record in   *
*                  the memory object. This will establish in the      *
*                  secondary index a pointer to the log record which  *
*                  was inserted into the log record memory object.    *
*                  Afterwards this routine will update the count of   *
*                  active entries in the secondary index block, and   *
*                  then update the key range value in the secondary   *
*                  index block.                                       *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                  Parm6: Addr of Pointer to Secondary Index Block    *
*                  Parm7: Addr of Pointer to Input Log Record         *
*                  Parm8: Addr of Pointer to Log Record Slot Position *
*                  Parm9: Addr of Pointer to Log Record Clock Time    *
*                  Parm10:Addr of Pointer to Log Record TCB Address   *
*                  Parm11:Addr of Pointer to Log Record Sequence No.  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: L6BF0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: WTO      - To Process Messages                     *
*                  STORAGE  - To Acquire Storage                      *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Insert of Log Record                 *
*                  12 - Severe Error - Exit Program                   *
*                                                                     *
***********************************************************************
*
L6IN0000 RSECT *                   Read-Only Control Section Name
L6IN0000 AMODE &AMODE              Establish Addressing Mode
L6IN0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6IN0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   L6IN0002            Branch Past the Literal Area
         DC    C'L6IN0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
L6IN0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING L6IN0000+(L6IN0001-L6IN0000),RBASE1  Set Addressability
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LMG   R0,R6,LCAF64R01-LCASAVE(R1)  Get the Input Parameters
         STG   R0,L6IPINDX         Save Adr Primary Index Block Pointer
         STG   R1,L6ININDX         Save Adr Secondary Index Blk Pointer
         STG   R2,L6IINPUT         Save Input Log Records Area Addr
         LG    R3,0(,R3)           Get Log Record Entry Slot Position
         STG   R3,L6IOSLOT         Save Log Recrd Entry Slot Position
         LG    R4,0(,R4)           Get Pointer to Log Record Key Addr
         STG   R4,L6ITRTIM         Save Input Log Record Time Address
         LG    R5,0(,R5)           Get Pointer to Log Record TCB Addr
         STG   R5,L6ITRTCB         Save Input Log Record TCB Address
         LG    R6,0(,R6)           Get Pointer to Log Record Seq No.
         STG   R6,L6ITRSEQ         Save Input Log Record Sequence No.
         XC    CM6RETCD,CM6RETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|Verify if there is sufficient space in the usable area to add our  |*
*|input log record entry. If no space, acquire an additional usable  |*
*|area from the guard area of the log record memory object to insert |*
*|incoming records. Also, since the guard size counts against the    |*
*|segments if not the MEMLIMIT, verify that the CHANGEGUARD request  |*
*|does not exceed the available guard size. Use a recovery routine in|*
*|the event of an abend in IARV64 CHANGEGURAD service.               |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
L6IN1000 DS    0H
         LG    R1,L6IPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LG    R1,L6ININDX         Get Pointer to Secondary Index Block
         LG    RSDX,0(,R1)         Get the Secondary Index Block Addr
         LG    REDB,LOGPIMTT       Get the Last Data Block on Chain
         CLC   LOGTRCNT,=AD(LOGTRMXB) ..Have We Filled This Data Block?
         BRL   L6IN2000            No  => Branch to Process Log Record
         LG    R1,LOGPGRDZ         Log Record Memory Object Guard Size
         CGHI  R1,(8)              Is Remaininmg Guard Size Sufficient?
         BRNL  L6IN1200            Yes => Branch to Process Log Record
L6IN1100 DS    0H
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         MVC   LG6WTOMG(L'LGA01127),LGA01127 Request Exceeds Guard Area
         LA    R3,LOGPOLRD         Log Record Data Memory Object Origin
         STMG  R3,R6,COM6SAVE      Preserve Regs for Error Msg Process
         BRU   L6IN1600            Branch to Issue Error Message
*
*+-------------------------------------------------------------------+*
*|Get More Usable Area from Memory Object for Next Log Record Insert |*
*+-------------------------------------------------------------------+*
*
         USING LGRWK2II,R14        Establish Addressability to Log Area
L6IN1200 DS    0H
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6IN1400        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         LA    R3,LGA01126         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         DROP  R14                 Remove Listed Reg as Log Area Base
         AGHI  R1,(-8)             Reduce Guard Size to Add Usable Area
         STG   R1,LOGPGRDZ         Save Remaining Log Record Guard Size
         LG    R2,LOGPHLRD         Log Record Memory Obj High Used Addr
         LLGF  R3,=A(LOGPIDBS)     Get Length of Log Record Data Area
         LA    R11,0(R2,R3)        High Used Addr for Next Usable Area
         LA    R3,LOGPOLRD         Log Record Data Memory Object Origin
         STMG  R3,R6,COM6SAVE      Preserve Regs Over Call If an Abend
         IARV64 REQUEST=CHANGEGUARD, Convert Guard Area to Usable Area X
               COND=YES,           Set RC If Unable to Satisfy Request X
               CONVERT=FROMGUARD,  Change a Guard Area to a Usable AreaX
               CONVERTSIZE==A(8),  Add 8 Megabytes to the Usable Area  X
               MEMOBJSTART=(R3),   Addr of First Byte in Memory Object X
               RETCODE=(R15),      Return Code for ChangeGuard Request X
               RSNCODE=(R0),       Reason Code for ChangeGuard Request X
               MF=(E,LDXSTOR1,COMPLETE)  Remote Form of Parameter List
         LTGFR R15,R15             Was Memory Object Change Successful?
         BRZ   L6IN1300            Yes => Then Branch to Process Recrds
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Later on This Will be Shifted Back
         LA    R1,LGA01124         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         BRU   L6IN1400            Branch to Process Error Message
L6IN1300 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Byte Referenced
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         STG   R11,LOGPHLRD        New High Used Addr for Memory Object
         STG   R2,LOGTRNXT         Forward Pointer to Next Record Area
         STG   R2,LOGPIMTT         Set As the Last Record Area on Chain
         LGR   R3,REDB             Hold Adr of Old Log Record Data Area
         LGR   REDB,R2             Get Addr of New Log Record Data Area
         LLGF  R14,=A(LOGPIDBS)    Obtain the Size of Record Data Area
         STG   R14,LOGTRSIZ        Set the Size in our Record Area Blk
         LA    R14,LOGTRHLN(,REDB) Add the Length of the Header Section
         STG   R14,LOGTRSLT        Set Address of First Available Slot
         BRU   L6IN2000            Branch to Process Log Record Entry
*
*+-------------------------------------------------------------------+*
*| Issue Error Message for ChangeGuard Failure on Log Record Insert  |*
*+-------------------------------------------------------------------+*
*
L6IN1400 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Byte Referenced
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Work Area Base
         LLGFR R2,R2               Clear High Half to Prepare for Shift
         SRLG  R2,R2,12            Isolate the IARV64 System Abend Code
         ST    R2,CM6SYSCD         Save the IARV64 System Abend Code
         UNPK  CM6WORKD(5),CM6SYSCD+2(3) .Convert Value in Hex to Zoned
         TR    CM6WORKD(4),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   L6ISYSCD,CM6WORKD+1 IARV64 System Abend Code to Wrk Area
         LA    R1,L6ISYSCD         Point to IARV64 System Abend Code
         LLILL R15,(L'L6ISYSCD)    Set Length for IARV64 Abend Code
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         LG    R14,L6IMSGAD        Get Address for Error Message Text
         MVC   LG6WTOMG(L'LGA01126),0(R14)  ..Indicate an IARV64 Error
         LA    R2,LG6WTOMG+L'LGA01126 Point to the End of Message Text
         MVC   0(*-*,R2),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy Return Cde Value to Output Line
         LA    R2,2(R15,R2)        Point to the End of Abend Code Value
         MVC   0(12,R2),=CL12'Reason Code=' ..Insert Reason Code Header
         LA    R2,12(,R2)          Increment to IARV64 Reason Cde Field
L6IN1500 DS    0H
         ST    R3,L6I$RSCD         ChangeGuard Reason Code to Work Area
         LA    R11,L6I$RSCD        Addr ChangeGuard Reason Code Field
         LA    R14,L'L6I$RSCD      Obtain Leng in Bytes of Reason Code
         LA    R15,LDX$RWRK        Addr of IARV64 Reason Code Work Area
         LGR   R4,R14              Current Leng in Bytes of Reason Code
         SLLG  R4,R4,1 Bit         Multiply the Current Length by Two
         LGR   R5,R4               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R14              Put the Two Unpack Lengths Together
         UNPK  LDX$RWRK(0),0(0,R11) ...Indicated Target of the Execute
         EX    R5,*-6              Unpack IARV64 Reason Cde to Wrk Area
         BCTGR R4,R0               Decrement Length for the Execute
         EX    R4,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),LDX$RWRK    Indicated Target of the Next Execute
         EX    R4,*-6              Displayable Reason Code to WTO Line
L6IN1600 DS    0H
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Severe Error on IARV64 Fail
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         LMG   R3,R6,COM6SAVE      Restore Registers as Buffer Pointers
         SLGR  R1,R1               Used to Indicate End of Buffer Chain
         STG   R1,LOGTRNXT         Clear the Next Block Forward Pointer
         STG   R1,LOGPIMTT         No More Buffer Area Blocks on Chain
         BRU   L6IN4000            Branch to Verify Final Condition Cde
*
*+-------------------------------------------------------------------+*
*|      Add The Log Record to End of Last Record Area on Chain       |*
*+-------------------------------------------------------------------+*
*
L6IN2000 DS    0H
         LG    R14,LOGTRCNT        Get Count of Recrd Entries in Object
         LA    R15,1(,R14)         Increment Count for This Log Recrd
         STG   R15,LOGTRCNT        Store New Count Value in Record Blk
         MGHI  R14,(LOGTRLEN)      Old Count * Leng of Log Record Entry
         LA    REDB,LOGTRHLN(R14,REDB)   Point to Log Record Area Entry
L6IN2100 DS    0H
         LG    R1,L6IINPUT         Get Pointer to Log Recrd Input Area
         LG    R1,0(,R1)           Get Log Record Input Area Address
         LG    R2,L6ITRTIM         Get Address to Log Record CPU Time
         LG    R3,L6ITRTCB         Get Address to Log Record TCB Addr
         LG    R15,L6ITRSEQ        Get Address to Log Record Seq No.
         STG   REDB,LOG$BLK@       Preserve Addr of Log Record Area Blk
         MVC   LOGTRSEQ,0(R15)     Log Seq No. Entry to Memory Object
         MVC   LOGTRTCB,0(R3)      Log Rcrd TCB Entry to Memory Object
         MVC   LOGTRTIM,0(R2)      Log Rcd Time Entry to Memory Object
         MVC   LOGTRCRD,0(R1)      Input Log Record to Memory Object
*
*+-------------------------------------------------------------------+*
*| Update the secondary index block to insert a new entry in the     |*
*| secondary index. This index entry will be a pointer to the new    |*
*| log record just written into the log record memory object. A      |*
*| portion of the secondary index block residing in another memory   |*
*| object will be moved over for eight bytes to open up a new slot in|*
*| the index area. This new slot in the secondary index memory object|*
*| will hold the 64-bit address pointing to the log record just      |*
*| inserted in the log record memory object.                         |*
*+-------------------------------------------------------------------+*
*
L6IN3000 DS    0H
         LG    R0,LOGSIFST         Get 1st Populated Slot in Index Blk
         LG    R1,L6IOSLOT         Get the Slot Position for Our Insert
         MGHI  R1,(L'LOGSINDX)     Calculate the Total Length to Shift
         LG    R14,LOGSIFST        Establish Addr to 1st Populated Slot
         LG    R15,LOGSICNT        Get the Secondary Index Slot Count
         LTGR  R15,R15             Count Indicate 1st Time Through?
         BRZ   L6IN3300            Yes => Branch to Fill Slot Position
L6IN3100 DS    0H
         SGF   R14,=A(L'LOGSINDX)  Push Slot Position Forward One Entry
         STG   R14,LOGSIFST        Set a New Secondary Indx First Entry
         LGR   R15,R1              Set the Length to Move Index Entries
L6IN3200 DS    0H
         MVCLE R14,R0,0            Open Up a New Secondary Index Slot
         BRO   L6IN3200            Upon Interrupt Resume Where Left Off
L6IN3300 DS    0H
         STG   REDB,0(,R14)        Set Address of New Log Record Entry
         LG    R14,LOGSICNT        Previous Secondary Index Entry Count
         LA    R14,1(,R14)         Secondary Index Cnt for New Log Rcrd
         STG   R14,LOGSICNT        Set Updated Count in Secondary Index
         LG    R14,LOGSIHP2        Get Previous Power of 2 for Index
         SLLG  R14,R14,1 Bit       Secondary Index Power of 2 Times 2
         CG    R14,LOGSICNT        Index Count Need Higher Power of 2?
         BRH   L6IN3400            No  => Branch to Update Index Key
         STG   R14,LOGSIHP2        Yes => Set Next Higher Power of 2
L6IN3400 DS    0H
         LLGF  R14,=A(LOGSILEN-L'LOGSILST) Get the Offset to Our Entry
         LG    REDB,0(R14,RSDX)    Get the Last Record Entry in Block
         MVC   LOGSITIM,LOGTRTIM   Reset Index to Current Log Rcd Time
         MVC   LOGSITCB,LOGTRTCB   Reset Index to Current Log Rcd TCB
         MVC   LOGSISEQ,LOGTRSEQ   Reset Index to Current Log Rec No.
         LG    R14,LOGPITOT        Previous Log Record Entry Count
         LA    R14,1(,R14)         Increment Log Record Entry Count
         STG   R14,LOGPITOT        Set Updated Count in Primary Index
         BRU   L6IN$END            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|       Check Condition Code For Log Record Buffer Processing       |*
*+-------------------------------------------------------------------+*
*
L6IN4000 DS    0H
         LLGF  R15,CM6RETCD        Get Highest Return Code Generated
         CGHI  R15,(4)             Any Error Higher than a Warning?
         BRNH  L6IN$END            No  => Branch to Exit This Routine
         BRU   L6INEXIT            Yes => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6IN$END DS    0H
         SLGR  R15,R15             Indicate No Errors in Processing
L6INEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*          End of Insert Log Record Into Buffer Area Process          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 R L 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P e r f o r m   R e l e a s e   I n d e x   P r o c e s s i n g  |*
*+-------------------------------------------------------------------+*
* SUBPROGRAM NAME: L6RL0000                                           *
*                                                                     *
* FUNCTION:        Perform Release of Index Blocks and Buffer Areas.  *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  release of all above-the-bar memory objects        *
*                  acquired to hold the contents of index blocks and  *
*                  log record buffers for the processing of log       *
*                  records.                                           *
*                                                                     *
*                  The log record indices and record buffers were     *
*                  created as memory objects using the IARV64 GETSTOR *
*                  service. This routine will use the IARV64 DETACH   *
*                  service to release those same memory objects.      *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Common Constants & Routines Base 2  *
*                  Parm2: Addr of Common Constants & Routines Base 1  *
*                  Parm3: Addr of Common Program Control Area Base 2  *
*                  Parm4: Addr of Common Program Control Area Base 1  *
*                  Parm5: Addr of Pointer to Primary Index Block      *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY                                *
*                                                                     *
* CALLING PROGRAM: L6BF0000 - Log Record Insertion Control Program    *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error on Release Resources Process            *
*                  12 - Severe Error - Exit LGMHLB64 Program          *
*                                                                     *
***********************************************************************
*
L6RL0000 RSECT *                   Read-Only Control Section Name
L6RL0000 AMODE &AMODE              Establish Addressing Mode
L6RL0000 RMODE &RMODE              Establish Residence Mode
         STMG  R14,R12,LCAF64R14-LCASAVE(R13) Save Caller's Registers
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R12,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
L6RL0001 L     R12,0(R12,R0)       Set up to Address of Static Data
         USING *-4,R12             Set Program Temporary Base Register
         BRU   L6RL0002            Branch Past the Literal Area
         DC    C'L6RL0000'         Set Eyecatcher for the Program Name
         DC    C' (LOGGRASM-&KXHVRM)' Program Version.Rlse.ModLevel
         DC    C' &SYSDATC &SYSTIME ' Set Compile Date and Time Stamp
         DC    C' Copyright &CPYRITE (C)' Establish Copyright Notice
         DC    C' LOGGRASM Information Logger for Assembler'
         DC    50S(*)              Define a Patch Area
L6RL0002 DS    0H
         DROP  ,                   Remove All Listed Regs as Base Regs
         LLGTR RBASE1,R12          Ensure Base Reg Has a Good Address
         USING L6RL0000+(L6RL0001-L6RL0000),RBASE1  Set Addressability
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
         LA    R14,LCAS64SZE(,R13) Our Caller Passes Stacked Save Areas
         STG   R14,LCAF64FWD-LCASAVE(,R13) Establish Forward Chain Pntr
         STG   R13,LCAF64BCK-LCASAVE(,R14) Establish Back Chain Pointer
         MVC   LCAF64F4A-LCASAVE(4,R14),=CL4'F4SA'  Indicate Format 4
         LGR   R13,R14             Establish a New Save Area in Stack
         LMG   RCOMM4,RCOMM1,0(R1) ...Load Common Area Addresses
         LG    R1,LCAF64R01-LCASAVE(,R1)  Get the Input Parameters
         STG   R1,L6LPINDX         Save the Primary Index Block Pointer
         XC    CM6RETCD,CM6RETCD   Initialize Return Code
*
*+-------------------------------------------------------------------+*
*|               Release The Log Record Memory Object                |*
*+-------------------------------------------------------------------+*
*
         USING LOGPIBLK,RPDX       Establish LOGPIBLK Addressability
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
L6RL1000 DS    0H
         LG    R1,L6LPINDX         Get Pointer to Primary Index Block
         LG    RPDX,0(,R1)         Get the Primary Index Block Address
         LTGR  RPDX,RPDX           Is the Primary Index Blk Available?
         BRNZ  L6RL1100            Yes => Process Log Rcd Memory Object
         LA    R15,4               Indicate Warning for No Primary Indx
         BRU   L6RLEXIT            Branch to Exit This Routine
L6RL1100 DS    0H
         LG    R2,LOGPIMTH         Load the 1st Log Record Buffer Area
         LTGR  REDB,R2             Set Initial Buffer Area Pointer
         BRZ   L6RL2000            Branch If No Buffer Area Chain
L6RL1200 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6RL1300        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         DROP  R14                 Remove as Logger Work Area Base Reg
         LA    R3,LGA01132         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         LLILL R1,(L'LGA01132)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
         STG   REDB,L6XORGIN       Starting Address of Memory Object
         IARV64 REQUEST=DETACH,    Release Memory Object for Log RecrdsX
               COND=YES,           Set RC If Unable to Satisfy Request X
               MATCH=SINGLE,       Release is for Single Memory Object X
               MEMOBJSTART=L6XORGIN, Addr of 1st Byte of Memory Object X
               RETCODE=(R15),      Show Return Code for Detach Request X
               RSNCODE=(R0),       Show Reason Code for Detach Request X
               TTOKEN=NO_TTOKEN,   Memory Owned by TCB Creating Object X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Was Memory Object Detach Successful?
         BRZ   L6RL1400            Yes => Process Detach of Next Object
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Set Return Code for Later Processing
         LA    R1,LGA01129         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         LLILL R1,(L'LGA01129)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
L6RL1300 DS    0H
         BRAS  R14,L6RLM100        Branch to Issue the Error Message
L6RL1400 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Completed
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         XC    LOGPIMTH,LOGPIMTH   Log Record Area No Longer Available
         XC    LOGPIMTT,LOGPIMTT   Log Record Area No Longer Available
*
*+-------------------------------------------------------------------+*
*|        Release Log Record Secondary Index Memory Object           |*
*+-------------------------------------------------------------------+*
*
L6RL2000 DS    0H
         LG    RSDX,LOGPOIX2       Get Address to Secondary Index Block
         LTGR  RSDX,RSDX           Do We Have a Secondary Indx Chain?
         BRZ   L6RL3000            No  => Branch to Check Primary Index
L6RL2100 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6RL2200        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         DROP  R14                 Remove as Logger Work Area Base Reg
         LA    R3,LGA01133         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         LLILL R1,(L'LGA01133)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
         IARV64 REQUEST=DETACH,    Release Mem Obj for Secondary Index X
               COND=YES,           Set RC If Unable to Satisfy Request X
               MATCH=SINGLE,       Release is for Single Memory Object X
               MEMOBJSTART=LOGPOIX2, Addr of 1st Byte of Memory Object X
               RETCODE=(R15),      Show Return Code for Detach Request X
               RSNCODE=(R0),       Show Reason Code for Detach Request X
               TTOKEN=NO_TTOKEN,   Memory Owned by TCB Creating Object X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Was Memory Object Detach Successful?
         BRZ   L6RL2300            Yes => Process Detach of Next Object
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Set Return Code for Later Processing
         LA    R1,LGA01130         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         LLILL R1,(L'LGA01130)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
L6RL2200 DS    0H
         BRAS  R14,L6RLM100        Branch to Issue the Error Message
L6RL2300 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Completed
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         DROP  R14                 Remove Listed Reg as Log Area Base
         XC    LOGPISXH,LOGPISXH   Secondary Index No Longer Available
         XC    LOGPISXT,LOGPISXT   Secondary Index No Longer Available
*
*+-------------------------------------------------------------------+*
*|         Release Log Record Primary Index Memory Object            |*
*+-------------------------------------------------------------------+*
*
L6RL3000 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         LA    R15,L6RL3100        Get Retry Recovery Address (ESTAE)
         ST    R15,LGWRETRY        Preserve It In Case of an Abend
         OI    LGWFLAG,LGWSDUMP+LGW@SRSV  Set Abend Recovery Indicators
         DROP  R14                 Remove as Logger Work Area Base Reg
         LA    R3,LGA01134         Get Address for Abend Error Message
         STG   R3,L6IMSGAD         Msg When IARV64 Has Abnormally Ended
         LLILL R1,(L'LGA01134)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
         STG   RPDX,L6XORGIN       Starting Address of Memory Object
         IARV64 REQUEST=DETACH,    Release Memory Obj for Primary IndexX
               COND=YES,           Set RC If Unable to Satisfy Request X
               MATCH=SINGLE,       Release is for Single Memory Object X
               MEMOBJSTART=L6XORGIN, Addr of 1st Byte of Memory Object X
               RETCODE=(R15),      Show Return Code for Detach Request X
               RSNCODE=(R0),       Show Reason Code for Detach Request X
               TTOKEN=NO_TTOKEN,   Memory Owned by TCB Creating Object X
               MF=(E,LDXSTOR1,COMPLETE) Remote Form of Parameter List
         LTGFR R15,R15             Was Memory Object Detach Successful?
         BRZ   L6RL3200            Yes => Process Primary Index Pointer
         LLGFR R2,R15              Save IARV64 Return Code to Work Reg
         LLGFR R3,R0               Save IARV64 Reason Code to Work Reg
         SLLG  R2,R2,12 Bits       Set Return Code for Later Processing
         LA    R1,LGA01131         Get Address for Designated Error Msg
         STG   R1,L6IMSGAD         Msg When IARV64 Not Abnormally Ended
         LLILL R1,(L'LGA01131)     Get Length of This IARV64 Error Msg
         STH   R1,L6IMSGLN         Save Length of the IARV64 Message
L6RL3100 DS    0H
         BRAS  R14,L6RLM100        Branch to Issue the Error Message
L6RL3200 DS    0H
         USING LGRWK2II,R14        Establish Addressability to Log Area
         LG    R14,CM6LG2II        Get Pntr to Logger Work Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, IARV64 Completed
         NI    LGWFLAG,255-LGWSDUMP-LGW@SRSV Disable Recovery Indicator
         LA    R1,LGWPINDX         Get Pointer to Primary Indx Blk Addr
         SLGR  RPDX,RPDX           Clear Primary Index Block Address
         STG   RPDX,0(,R1)         Primary Index is No Longer Available
         LG    R1,L6LPINDX         Get Pointer to Primary Index Block
         STG   RPDX,0(,R1)         Clear Primary Index Address Field
         DROP  R14                 Remove Listed Reg as Log Area Base
*
*+-------------------------------------------------------------------+*
*|    Return to Caller                                               |*
*+-------------------------------------------------------------------+*
*
L6RLEXIT DS    0H
         LG    R13,LCAF64BCK-LCASAVE(,R13)  Get Caller's Save Area Addr
         LLGF  R15,CM6RETCD        Obtain the Return Code Generated
         LG    R14,LCAF64R14-LCASAVE(,R13) ...Obtain the Return Address
         LMG   R0,R12,LCAF64R00-LCASAVE(R13) Restore Caller's Registers
         BSM   R0,R14              Return to Caller
*
***********************************************************************
**************************+-----------------+**************************
**************************| L 6 R L M 1 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  I s s u e   I A R V 6 4   D e t a c h   E r r o r  M e s s a g e |*
*+-------------------------------------------------------------------+*
* SUBROUTINE NAME: L6RLM100                                           *
*                                                                     *
* FUNCTION.......: Issues WTO Error Message on IARV64 Detach Failure  *
***********************************************************************
*
         USING LGRWK2II,R14        Establish Addressability to Log Area
L6RLM100 DS    0H
         STG   R14,CM6RTADR        Hold the Return Address in Save Area
         STMG  R4,R6,CM6RSAVE      Save LOGPIBLK, LOGSIBLK, LOGTRBLK
         LLGFR R2,R2               Clear High Half to Prepare for Shift
         SRLG  R2,R2,12            Isolate the IARV64 System Abend Code
         ST    R2,CM6SYSCD         IARV64 System Abend Code to Wrk Area
         UNPK  CM6WORKD(5),CM6SYSCD+2(3) .Convert Value in Hex to Zoned
         TR    CM6WORKD(4),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   L6ISYSCD,CM6WORKD+1 IARV64 System Abend Code to Wrk Area
         LA    R1,L6ISYSCD         Point to IARV64 System Abend Code
         LLILL R15,(L'L6ISYSCD-1)  Set Length for IARV64 Abend Code
         MVI   LG6WTOMG,C' '       Set-up to Fill Field with Blanks
         MVC   LG6WTOMG+1(L'LG6WTOMG-1),LG6WTOMG ..Propagate the Blank
         LG    R14,L6IMSGAD        Get Address for Error Message Text
         LLGH  R4,L6IMSGLN         Get the Length of Error Message Text
         BCTGR R4,R0               Decrement Indicated Length for EX
         MVC   LG6WTOMG(0),0(R14)  Show That an IARV64 Error Occurred
         EX    R4,*-6              Copy Text of Error Msg to Outpt Line
         LA    R2,LG6WTOMG+1(R4)   Point to End of Error Message Text
         MVC   0(*-*,R2),0(R1)     Indicated Target of the Execute
         EX    R15,*-6             Copy Completion Code to Output Line
         LA    R2,2(R15,R2)        Point to the End of Completion Code
         MVC   0(12,R2),=CL12'Reason Code=' ..Insert Reason Code Header
         LA    R2,12(,R2)          Increment to IARV64 Reason Cde Field
L6RLM200 DS    0H
         ST    R3,L6X$RSCD         Copy IARV64 Reason Code to Work Area
         LA    R11,L6X$RSCD        Get Addr IARV64 Reason Code Wrk Area
         LA    R14,L'L6X$RSCD      Obtain Leng in Bytes of Reason Code
         LA    R15,LDX$RWRK        Address of Area to Unpack Reason Cde
         LGR   R4,R14              Current Leng in Bytes of Reason Code
         SLLG  R4,R4,1 Bit         Multiply the Current Length by Two
         LGR   R5,R4               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R14              Put the Two Unpack Lengths Together
         UNPK  LDX$RWRK(0),0(0,R11) ...Indicated Target of the Execute
         EX    R5,*-6              Unpack IARV64 Reason Cde to Wrk Area
         BCTGR R4,R0               Decrement Length for the Execute
         EX    R4,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),LDX$RWRK    Indicated Target of the Next Execute
         EX    R4,*-6              Displayable Reason Code to WTO Line
         MVC   LG6WTOLN,=Y(L'LG6WTOMG) ..Set the Length of the Message
         MVC   LG6WTOL(CM6$WTOL),CM6$WTO  List Form of WTO to Parm Area
         WTO   TEXT=LG6WTO,        Perform Write to Operator Process   X
               ROUTCDE=(1,11),     Route to the Syslog and the Joblog  X
               MF=(E,LG6WTOL)      Indicate Using Remote Parameter List
         LA    R15,12              Indicate Severe Error on IARV64 Fail
         ST    R15,CM6RETCD        Save Highest Return Code Generated
         LMG   R4,R6,CM6RSAVE      Restore LOGPIBLK, LOGSIBLK, LOGTRBLK
         LG    R14,CM6RTADR        Get Return Address From Save Area
         BR    R14                 Branch to Return To Caller
         LTORG ,                   Define the Literal Origin Pool
         DROP  ,                   Remove Listed Regs as Base Registers
*
***********************************************************************
*         End of Log Record Memory Object Release Processing          *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Program Control Area - (LCA)
RBASE1   EQU   12                  Base Register 1
RBASE2   EQU   11                  Base Register 2
RCOMM1   EQU   10                  Common Dynamic Area Base Register 1
RCOMM2   EQU   9                   Common Dynamic Area Base Register 2
RCOMM3   EQU   8                   Common Constants/Routines Base Reg 1
RCOMM4   EQU   7                   Common Constants/Routines Base Reg 2
         USING COM@L6B,RCOMM1,RCOMM2 Common Program Area Addressability
         USING COM#P6L9,RCOMM3,RCOMM4 Constants&Routines Addressability
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M # P 6 L 9 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  P r o g r a m   C o n t r o l   C o m m o n   D a t a   A r e a  |*
*+-------------------------------------------------------------------+*
*
COM#P6L9 RSECT                     Read-Only Control Section Name
COM#P6L9 AMODE &AMODE              Establish Program Addressing Mode
COM#P6L9 RMODE &RMODE              Establish Program Residence Mode
*
H4       DC    H'4'                Establish Halfword Constant '4'
H8       DC    H'8'                Establish Halfword Constant '8'
H12      DC    H'12'               Establish Halfword Constant '12'
ASTERISK DC    80CL1'*'            Define Character String of Asterisks
BLANKS   DC    CL256' '            Define Character String of Blanks
PATTERN  DC    XL8'4020202020202120'                Pattern for Editing
*
CM6$WTO  WTO   TEXT=(LGRWTO),      Write to Operator Message           X
               ROUTCDE=(1,11),MF=L Route to the Syslog and the Joblog
CM6$WTOL EQU   *-CM6$WTO           WTO List Length
LGRPTIME TIME  LINKAGE=SYSTEM,MF=L List Form
LGRTIMLN EQU   *-LGRPTIME          Length of System Time Parameter List
HEXCONV  DC    C'0123456789ABCDEF' Translate Table for Hex to Character
TRNSLATE TR    0(*-*,R15),HEXCONV-C'0' ...Translate Hex to Character
*
LGA01111 DC    C'LGA01111A Primary index block overrun on secondary indX
               ex block split.'
LGA01115 DC    C'LGA01115A IARV64 GetStore error on log: RC='
LGA01116 DC    C'LGA01116A MEMLIMIT is zero value indicating no above tX
               he bar storage.'
LGA01117 DC    C'LGA01117A MEMLIMIT less than 20 meg and insufficient fX
               or processing.'
LGA01118 DC    C'LGA01118A IARV64 Getstore error 2nd Indx. RC='
LGA01119 DC    C'LGA01119A IARV64 GetStore error 1st indx. RC='
LGA01120 DC    C'LGA01120A IARV64 Getstore abended on Log '
LGA01121 DC    C'LGA01121A IARV64 Getstore abended on Index2 '
LGA01122 DC    C'LGA01122A IARV64 Getstore abended on Index1 '
LGA01123 DC    C'LGA01123A IARV64 Changeguard error: * RC= '
LGA01124 DC    C'LGA01124A IARV64 Changeguard error: * RC= '
LGA01125 DC    C'LGA01125A IARV64 Changeguard abended with '
LGA01126 DC    C'LGA01126A IARV64 Changeguard abended with '
LGA01127 DC    C'LGA01127A Changeguard for record area exceeds availablX
               e guard area.'
LGA01128 DC    C'LGA01128A Changeguard for 2nd Index area exceeds availX
               able guard area.'
LGA01129 DC    C'LGA01129A IARV64 Detach error Log Area. RC='
LGA01130 DC    C'LGA01130A IARV64 Detach error 2nd Indx. RC='
LGA01131 DC    C'LGA01131A IARV64 Detach error 1st Indx. RC='
LGA01132 DC    C'LGA01132A IARV64 Detach Log Area abended '
LGA01133 DC    C'LGA01133A IARV64 Detach 2nd Index abended '
LGA01134 DC    C'LGA01134A IARV64 Detach 1st Index abended '
*
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************|  C O M @ L 6 B  |**************************
**************************+-----------------+**************************
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|           P r o g r a m   C o n t r o l   A r e a                 |*
*+-------------------------------------------------------------------+*
*
COM@L6B  DSECT ,                   Program Control Area-(CPCA)
COM6EYEC DS    CL32                Work Area Eye-Catcher
COM6SAVE DS    9D                  Save Area
CM6WORKD DS    20D                 General Work Area
CM6PLIST DS    20FD                CALL Parameter List
CM6RSAVE DS    3FD                 Register Save Area
CM6SYSCD DS    F                   System Completion Code for Job
CM6RSNCD DS    F                   Reason Code for Job
CM6RETCD DS    F                   Return Code for Job
PRIM6IDX DS    A                   Log Primary Index Block Chain Addr
TSK6ROWC DS    F                   Count of Log Component Data Rows
TSK6PRNT DS    A                   Beginning Address of Print Entries
TSK6PRTL DS    F                   Length of Print Entries Area
TSK6PRTC DS    F                   Count of Print Entries
CM6RTADR DS    AD                  Save Area to Hold Return Address
CM6LG2II DS    AD                  Address of LGRWK2II Logger Work Area
CM6RCDCT DS    FD                  LGRWK2II Log Point Output Rcrd Count
L6BLG2II DS    AD                  Logger Work Area (LGRWK2II) Address
L6FOSLOT DS    AD                  Save Area for Record Slot Position
L6FPINDX DS    AD                  Save Area for Primary Index Block
L6FSINDX DS    AD                  Save Area for Secondary Index Block
L6FTRTBL DS    AD                  Save Area for Log Record Table Addr
L6FINPUT DS    AD                  Save Area for Log Record Area Addr
L6FTCBAD DS    AD                  Save Area for Current TCB Address
L6FTRTIM DS    AD                  Save Area for the Log Record Time
L6FACCUM DS    AD                  Save Area for the Log Record Accum
L6XGRDSZ DS    FD                  Save Area for Mem Object Guard Size
L6XGRDZ2 DS    FD                  Save Area for 2nd Index Guard Size
L6X$HIGH DS    FD                  Ending Address of Unguarded Area
L6XORGIN DS    FD                  Addr of 1st Byte in Unguarded Area
L6XMEMLM DS    FD                  Save Area for the Binary MEMLIMIT
L6XOBJSZ DS    FD                  Save Area for Record Mem Object Size
L6XOBIX1 DS    FD                  Save Area for Primary Index Obj Size
L6XOBIX2 DS    FD                  Save Area Secondary Index Obj Size
L6BFOWCT DS    FD                  Save Area for Current Row Counter
L6BFCDCT DS    FD                  Count of Log Record Component Rows
L6XPINDX DS    AD                  Save Area for 1st Primary Index Addr
L6NPINDX DS    AD                  Save Area for Primary Index Blk Addr
L6NSINDX DS    AD                  Save Area for Secondary Indx Blk Adr
L6NTRTBL DS    AD                  Save Area for Buffer Area Block Addr
L6NINPUT DS    AD                  Save Area for the Log Record Address
L6NOSLOT DS    AD                  Save Area for Log Record Tble Slot
L6NTCBAD DS    AD                  Save Area for Log Record TCB Addr
L6NTRTIM DS    AD                  Save Area for Log Record Time Addr
L6NSEQNO DS    AD                  Save Area for Log Recrd Sequence No.
L6N$TKEY DS    0CL(L'LOGTRTIM+L'LOGTRTCB) .Log Record Entry Key
L6N$TOKN DS    CL(L'LOGTRTIM)      ..Log Record Time Token Key
L6N$TCB@ DS    CL(L'LOGTRTCB)      ..Log Record TCB Address Key
L6N$SEQ# DS    CL(L'LOGTRSEQ)      ..Log Record Sequence No. Key
L6EXINDX DS    AD                  Save Area for Initial Primary Index
L6XSINDX DS    AD                  Save Area for Initial Secondary Indx
L6IOSLOT DS    AD                  Save Area for Record Slot Position
L6IPINDX DS    AD                  Save Area for Primary Index Block
L6ININDX DS    AD                  Save Area for Secondary Index Block
L6ITRTBL DS    AD                  Save Area for Log Record Buffer Addr
L6IINPUT DS    AD                  Save Area for Input Log Record Addr
L6ITRTIM DS    AD                  Save Area for Input Log Record Time
L6ITRTCB DS    AD                  Save Area for Log Record TCB Addr
L6ITRSEQ DS    AD                  Save Area for Log Record Seq No.
L6ILG2II DS    AD                  Save Area for Logger Work Area Addr
L6IMSGAD DS    AD                  Save Area for Addr of IARV64 Message
L6LPINDX DS    AD                  Save Area for Primary Index Block
L6F$RTCD DS    F                   Area for Log Record Return Code
L6X$RTCD DS    F                   Area for IARV64 GetStore Return Code
L6X$RSCD DS    F                   Area for IARV64 GetStore Reason Code
L6I$RTCD DS    F                   Work Area for Return Code Processing
L6I$RSCD DS    F                   Work Area for Reason Code Processing
L6IMSGLN DS    H                   Save Area for Length of IARV64 Msg
L6ISYSCD DS    CL3                 Work Area for System Completion Code
         DS    XL1                 Slack Byte
LG6WTOM  DS    0F                  Fullword Align WTO Parm List Area
LG6WTOL  DS    XL(CM6$WTOL)        WTO Macro Parameter List
LG6WTO   DS    0F                  Write to Operator Message Data Area
LG6WTOLN DS    H                   Length of Write to Operator Msg Area
LG6WTOMG DS    CL70                Write to Operator Message Area
         DS    0D                  Set for Doubleword Alignment
LDX$TIME DS    XL(LGRTIMLN)        Date and Time Parameter List
         DS    0D                  Set for Doubleword Alignment
LDX$DTTM DS    0CL16               Date & Time Values from TOD Clock
LDXTIME@ DS    PL8                 Used for the Time of Day Value
LDX@DATE DS    PL8                 Date Value Expressed as 'MMDDYYYY'
         DS    XL4                 ..(Reserved)
LDXWRK08 DS    CL(L'PATTERN)       Work Area for Editing Decimal Values
LDXFORC1 EQU   *-2                 First Forced Result Char Location
LDX$RWRK DS    XL16                Work Area for Unpacking Reason Code
         DS    XL1                 Slack for Reverse of Low Order Byte
IAR64STR IARV64 PLISTVER=MAX,      Ensure List Sufficient for All ParmsX
               MF=(L,LDXSTOR1,0D)  List Form of Parameter List
IARV64LN EQU   *-IAR64STR
CM6LNGTH EQU   *-COM@L6B           Length of Program Control Area
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|                  Log Record Buffer Area Blocks                    |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
*  LOGPIBLK = Primary Index Block Structure                           *
*  LOGSIBLK = Secondary Index Block Structure                         *
*  LOGTRBLK = Log Record Buffer Area Structure                        *
*                                                                     *
*  The following Log Record control blocks represent the indexing     *
*  structure which is utilized for processing the Log Records. The    *
*  address entries in the primary index control block point to        *
*  secondary index control blocks. The entries in the secondary       *
*  index control blocks will point to the individual log records      *
*  in the buffers.                                                    *
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|              Log Record Primary Index Control Block               |*
*+-------------------------------------------------------------------+*
*
LOGPIBLK DSECT ,                   Log Record Primary Index Block
LOGPISIZ DS    FD                  Size of This Primary Index Block
LOGPINXT DS    AD                  Next Primary Index Block or Zero
LOGPIFST DS    AD                  Address of First Entry in Block
LOGPICNT DS    FD                  Count of Entries in Primary Indx Blk
LOGPITOT DS    FD                  Count of Total Log Record Entries
LOGPIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGPISXH DS    AD                  Secondary Index Block Chain Header
LOGPISXT DS    AD                  Secondary Index Block Chain Trailer
LOGPIMTH DS    AD                  Log Record Data Block Chain Header
LOGPIMTT DS    AD                  Log Record Data Block Chain Trailr
LOGPOIX2 DS    AD                  Secondary Index Memory Object Origin
LOGPHIX2 DS    AD                  Secondary Index Mem Obj High Address
LOGPHUX2 DS    AD                  Secondary Indx Mem Obj High Used Adr
LOGPOLRD DS    AD                  Log Record Data Memory Object Origin
LOGPHLRD DS    AD                  Log Record Data Mem Obj High Address
LOGPGRDZ DS    FD                  Log Recrd Data Mem Object Guard Size
LOGPGRD2 DS    FD                  Secondary Indx Mem Object Guard Size
         ORG   LOGPIBLK+576        (Reserved - LOGGER)
LOGPINDX DS    0AD                 Last Available Primary Index Entry
         DS    131000AD            Allow 131,000 Primary Index Entries
LOGPILEN EQU   *-LOGPIBLK          Set Length of Primary Index Block
*
*+-------------------------------------------------------------------+*
*|             Log Record Secondary Index Control Block              |*
*+-------------------------------------------------------------------+*
*
LOGSIBLK DSECT ,                   Log Record Secondary Index Block
LOGSISIZ DS    FD                  Size of This Secondary Index Block
LOGSIPRV DS    AD                  Prev Secondary Index Block or Zero
LOGSINXT DS    AD                  Next Secondary Index Block or Zero
LOGSIFST DS    AD                  Addr of First Data Entry in Block
LOGSICNT DS    FD                  Count of Data Pointers in This Block
LOGSIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGSIKEY DS    0CL(L'LOGSITIM+L'LOGSITCB+L'LOGSISEQ) Highest Key in Blk
LOGSITIM DS    XL16                ..Log Record Entry Time Stamp
LOGSITCB DS    XL4                 ..Log Record Entry TCB Address
LOGSISEQ DS    XL4                 ..Log Record Entry Sequence No.
         ORG   LOGSIBLK+768        (Reserved - LOGGER)
LOGSINDX DS    0AD                 Last Available Secondary Indx Entry
         DS    4000AD              Allow 4,000 Secondary Index Pointers
         ORG   *-8                 Point at Last Secondary Index Entry
LOGSILST DS    AD                  Addr Highest Secondary Index Entry
LOGSISPL EQU   (*-LOGSINDX)/2      Len of a Split Secondary Index Block
LOGSILEN EQU   *-LOGSIBLK          Set Length of Secondary Index Block
LOGSISGZ EQU   (1024*1024)         Set Size of Secondary Index Segment
*
*+-------------------------------------------------------------------+*
*|             Log Record Control Block for Buffer Areas             |*
*+-------------------------------------------------------------------+*
*
LOGTRBLK DSECT ,                   Log Record Entry Data Cntl Block
LOGTRSIZ DS    FD                  Size of the Log Record Data Block
LOGTRNXT DS    AD                  Address of the Next Block on Chain
LOGTRCNT DS    FD                  Count of Record Entries in Buffer
LOGTRSLT DS    AD                  First Available Slot in Buffer Area
         DS    D                   (Reserved - LOGGER)
LOGTRHLN EQU   *-LOGTRBLK          Length of Data Block Header Section
         ORG   LOGTRBLK            Reset Buffer Area Location Counter
LOGTRRCD DS    0F                  Address of First Log Record Entry
LOGTRKEY DS    0CL(L'LOGTRTIM+L'LOGTRTCB+L'LOGTRSEQ) Log Record Key
LOGTRTIM DS    XL16                ..Log Record Entry Time Stamp
LOGTRTCB DS    XL4                 ..Log Record Entry TCB Address
LOGTRSEQ DS    XL4                 ..Log Record Entry Sequence No.
*
LOGTRCRD DS    CL(L'LGWLINE)       Area for the Log Trace Event Record
LOG$BLK@ DS    AD                  Log Record Buffer Area Block Address
*
LOGTRLEN EQU   *-LOGTRRCD          Length of Log Record Buffer Entry
LOGPIDBS EQU   1024*8192           Size of Rcrd Area for Storage (8Meg)
LOGTRMXB EQU   (LOGPIDBS-LOGTRHLN)/LOGTRLEN  Maximum Blocks in a Buffer
LOGMXSIZ EQU   (1*10240)           Max Memlimit in Megabytes (10Gig)
*
         EJECT ,
*+-------------------------------------------------------------------+*
*|        L o g g e r  C o n t r o l   A r e a   -   (LCA )          |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
LGBFRCE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
*+-------------------------------------------------------------------+*
*|            z / O S   S y s t e m   D s e c t s                    |*
*+-------------------------------------------------------------------+*
*
         PRINT  NOGEN
         CVT    DSECT=YES,LIST=YES Communications Vector Table
         IHAECVT  DSECT=YES,LIST=YES Extended Communications Vector Tbl
         IARRAX                    RSM Address Space Block Extension
         DCBD   DSORG=PS,DEVD=DA   Data Control Block
         IHAPSA LIST=YES           Prefix Storage Area
         IHAPVT                    RSM Page Vector Table
         IHAASCB                   Address Space Control Block
         IKJTCB LIST=YES           Job Task Control Block
         IEZJSCB                   Job Step Control Block
         END
