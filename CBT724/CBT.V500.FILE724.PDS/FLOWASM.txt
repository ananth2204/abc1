         PRINT OFF,NOPRINT
FLOWASM  RSECT ,
FLOWASM  AMODE 31
FLOWASM  RMODE 31
         COPY  ASMMSP
         TITLE 'FLOW - High Level Assembler Exit'
         PRINT ON,NOPRINT
         EJECT ,
*START OF SPECIFICATIONS***************************************
*                                                             *
* MODULE NAME = FLOWASM                                       *
*                                                             *
* DESCRIPTIVE NAME = High Level Assembler Source/Library Exit *
*                                                             *
* FUNCTION =                                                  *
*                                                             *
*    This exit reformats assembler source input to make       *
*    assembler language easier to code and use, especially    *
*    when using structured programming macros.                *
*                                                             *
* AUTHOR =                                                    *
*                                                             *
*    Edward E. Jaffe                                          *
*    Phoenix Software International                           *
*    5200 W. Century Blvd., Suite 800                         *
*    Los Angeles, CA 90045 U.S.A.                             *
*                                                             *
* ATTRIBUTES =                                                *
*                                                             *
*    Reentrant, Amode(31), Rmode(Any)                         *
*    Must be in APF Library if Invoked by SMP/E               *
*                                                             *
* OPERATION = Please Read the Following                       *
*                                                             *
*    ======================================================== *
*                                                             *
*    Assembler Specification:                                 *
*                                                             *
*    EXIT(INX(FLOWASM),LBX(FLOWASM))                          *
*                                                             *
*    ======================================================== *
*                                                             *
*    Input Formats:                                           *
*                                                             *
*    Only fixed length records with LRECL=80 are supported    *
*    for library input (SYSLIB). Source input may be any of   *
*    the following:                                           *
*                                                             *
*    1) Fixed records of any size. Sequence numbers are       *
*    allowed in columns LRECL-7 through LRECL. The            *
*    continuation column is LRECL-8.                          *
*                                                             *
*    2) Variable length records without sequence numbers.     *
*    Continuation is indicated with a trailing '+' character. *
*                                                             *
*    3) Variable length records with sequence numbers in      *
*    columns 1-8. Continuation is indicated with a trailing   *
*    '+' character.                                           *
*                                                             *
*    4) Fixed length records "pretending" to be variable      *
*    length records without sequence numbers. This format is  *
*    useful when, for example, your variable length file is   *
*    input to the assembler in-stream via JCL. Trailing       *
*    blanks are ignored and processing is as for variable     *
*    length records without sequence numbers. To distinguish  *
*    this format from true fixed length records, include the  *
*    following as the first statement of the source module:   *
*                                                             *
*    *FLOWOPT RECFM=V                                         *
*                                                             *
*    5) Fixed length records "pretending" to be variable      *
*    length records with sequence numbers in columns 1-8.     *
*    This format is useful when, for example, your variable   *
*    length file is input to the assembler in-stream via JCL. *
*    Trailing blanks are ignored and processing is as for     *
*    variable length records with sequence numbers. To        *
*    distinguish this format from true fixed length records,  *
*    include the following as the first statement of the      *
*    source module:                                           *
*                                                             *
*    *FLOWOPT RECFM=V                                         *
*                                                             *
*    ======================================================== *
*                                                             *
*    Comment Block Identification:                            *
*                                                             *
*    Normally, the assembler requires comment blocks be       *
*    marked with an asterisk in column 1. With this exit,     *
*    comment blocks may begin anywhere on the line. They may  *
*    be denoted by an asterisk or by a /* sequence. The exit  *
*    recognizes these comments and supplies the asterisk in   *
*    column 1.                                                *
*                                                             *
*    ======================================================== *
*                                                             *
*    Blank Elimination / Wrapping of Long Lines:              *
*                                                             *
*    If a statement is too long to fit in a standard 80-byte  *
*    assembler source line, the statement is reformatted as   *
*    follows:                                                 *
*    1) All extraneous blanks between the operation code and  *
*       operand are eliminated.                               *
*    2) If the statement is still too long, extraneous blanks *
*       between the operand and commentary are removed.       *
*    3) If the statement is still too long, extraneous blanks *
*       in front of the operation code are removed.           *
*    4) If the statement is still too long:                   *
*       a) If the operand fits on the line, the commentary is *
*          truncated.                                         *
*       b) If the operand is too long to fit, it is wrapped   *
*          and continued in column 16 of the next line along  *
*          with any commentary.                               *
*                                                             *
*    ======================================================== *
*                                                             *
*    Automatic Continuation:                                  *
*                                                             *
*    Good coding standards usually expect macro operands to   *
*    be spread out, with one operand and associated           *
*    commentary per source line. The exit detects such        *
*    sequences and automatically supplies the '-'             *
*    continuation character. The '-' is chosen to distinguish *
*    it from '+' characters coded by the programmer.          *
*                                                             *
*    When continuation lines are coded, there is no need to   *
*    continue in column 16. The exit knows when it has        *
*    supplied continuation for the previous source line. The  *
*    continuation line is reformatted so that the operand     *
*    begins in column 16. (This may be either a left or right *
*    shift of the operand.) If the commentary must be moved   *
*    from its current position, either because it conflicts   *
*    with the new operand position or because the statement   *
*    is too long, it is moved immediately after the operand.  *
*    If the statement is still too long, wrapping and/or      *
*    comment truncation occurs as described above under       *
*    "Blank Elimination / Wrapping of Long Lines".            *
*                                                             *
*    ======================================================== *
*                                                             *
*    Manual Continuation:                                     *
*                                                             *
*    The blank elimination / wrapping and automatic continua- *
*    tion features are disabled for any line that is manually *
*    continued and for all subsequent continuation lines for  *
*    the same statement. Automatic continuation and manual    *
*    continuation may be mixed within a continued statement,  *
*    but once manual continuation begins, no more automatic   *
*    continuation is allowed.                                 *
*                                                             *
*    ======================================================== *
*                                                             *
*    Example Program:                                         *
*                                                             *
*    Freed from the confines of traditional assembler syntax, *
*    structured programming macros provide a considerably     *
*    more powerful and easy to use language. For example:     *
*                                                             *
*  ********************************************************   *
*  * Get Dynamic Working Storage                          *   *
*  ********************************************************   *
*    ICM R3,B'1111',DwsAddr         Get storage address       *
*    IF Z                           If not yet acquired       *
*      STORAGE OBTAIN,                Storage obtain          *
*              SP=1,                  - Subpool 1             *
*              LENGTH=DwsSize         - Length of request     *
*      ST    R1,DwsAddr               Save storage address    *
*      LR    R3,R1                    (same)                  *
*      LR    R14,R1                   Clear the area          *
*      LHI   R15,DwsSize              (same)                  *
*      XR    R1,R1                    (same)                  *
*      MVCL  R14,R0                   (same)                  *
*    ENDIF ,                        EndIf not yet acquired    *
*                                                             *
*  ********************************************************   *
*  * Perform Requested Function                           *   *
*  ********************************************************   *
*    L R1,CubicleTkn                Get cubicle token         *
*    SELECT CLI,InReqCode,EQ        Select InReqCode          *
*                                                             *
*    ************************************                     *
*    * Open the Cubicle                 *                     *
*    ************************************                     *
*      WHEN InReqOpen                 Open                    *
*        JAS  R14,OpenCubicle           Open the Cubicle      *
*        IF LTR,R2,R15,NZ               If Open failed        *
*          JAS  R14,CloseCubicle          Clean it up         *
*          LR R15,R2                      Restore retcode     *
*        ENDIF ,                        EndIf Open failed     *
*                                                             *
*    ************************************                     *
*    * Close the Cubicle                *                     *
*    ************************************                     *
*      WHEN InReqClose                Close                   *
*        JAS  R14,CloseCubicle          Close the Cubicle     *
*                                                             *
*    ************************************                     *
*    * Reformat the Cubicle             *                     *
*    ************************************                     *
*      WHEN InReqReformat             Reformat                *
*        JAS  R14,ReformatCubicle       Reformat the Cubicle  *
*                                                             *
*    ************************************                     *
*    * Refresh the Cubicle              *                     *
*    ************************************                     *
*      WHEN InReqrefresh              Refresh                 *
*        JAS  R14,ReformatCubicle       Refresh the Cubicle   *
*                                                             *
*    ************************************                     *
*    * Invalid Request Received         *                     *
*    ************************************                     *
*      OTHRWISE ,                     Otherwise               *
*        CUBSRV TYPE=SETMSG,            Set message data      *
*               MSGPARM=(LogicErr,      - Type = logic error  *
*                        InReqCode,     - Request code        *
*                        CubicleTkn)    - Cubicle token       *
*               THREAD=ThreadTkn        - Thread token        *
*        LHI R15,RetcodeError           Error return code     *
*                                                             *
*    ENDSEL ,                       EndSel InReqCode          *
*                                                             *
* RESTRICTIONS =                                              *
*                                                             *
*    1) This routine does not use any of its own facilities   *
*       for obvious reasons.                                  *
*                                                             *
*    2) This routine ignores source that comes from data sets *
*       that start with 'SYS'.                                *
*                                                             *
*    3) It is not possible for this exit to detect certain    *
*       ambiguities. For example, it cannot distinguish       *
*       between a trailing comma in the operand field and     *
*       a trailing comma in the first word of the comment     *
*       if no operand is present. For example, the following  *
*       appears in IBM's IFGACBVS macro:                      *
*                                                             *
*       ____________________________________________________  *
*      |                                                    | *
*      |      AIF   ('&AM' NE 'VTAM').ENDACBX    IS IT VTAM | *
*      |         ISTACBEX          YES, GET VTAM EXTENSIONN | *
*      |.ENDACBX ANOP                                       | *
*      |____________________________________________________| *
*                                                             *
*       Therefore, we maintain a list of members for which no *
*       FLOWASM processing is to be performed. This list is   *
*       the FLOWERRM table.                                   *
*                                                             *
*       If you discover additional IBM or ISV macros that get *
*       assembly errors when processed by this exit, please   *
*       let the author (Ed Jaffe) know about them and, of     *
*       course, add them to FLOWERRM in your copy of this     *
*       exit routine.                                         *
*                                                             *
*END OF SPECIFICATIONS ****************************************

    PRINT NOGEN

    ASMAXITP ,                     Define exit parm lists
    ASMDREG ,                      Define register equates
    DCBD  DSORG=PS,DEVD=DA         Define DCB DSECT
JFCB DSECT ,                       Define JFCB DSECT
    IEFJFCBN ,                     (same)
    PRINT GEN

***************************************************************
* Main-Line                                                   *
***************************************************************
FLOWASM  RSECT ,

* Save Registers / Establish Addressability
    SAVE  (14,12),,*               Save the registers
    LR    R12,R15                  Load base register
    USING FLOWASM,R12          *** Synchronize base register

* Load Important Pointers
    LR    R11,R1                   Point to exit parm list
    USING AXPXITP,R11          *** Synchronize AXPXITP DSECT
    L     R10,AXPRIP               Load request information ptr
    USING AXPRIL,R10           *** Synchronize AXPRIL DSECT
    L     R9,AXPSIP                Load source information ptr
    USING AXPSIL,R9            *** Synchronize AXPSIL DSECT

* Load Common Storage Address
    ICM   R1,B'1111',AXPUCOM       Load address of common area
    IF Z                           If common area not acquired
      STORAGE OBTAIN,                Acquire the common area           +
               LENGTH=FLOWDWSL,      (same)                            +
               LOC=(24,64)           (same)
      ST   R1,AXPUCOM                Save common area address
      LR   R0,R1                     Zero out the storage
      LA   R1,FLOWDWSL               (same)
      XR   R15,R15                   (same)
      MVCL R0,R14                    (same)
      L    R1,AXPUCOM                Load DWS address into R1
    ENDIF ,                        EndIf

* Chain Save Areas
    ST    R13,4(,R1)               Chain save areas
    ST    R1,8(,R13)               (same)

* Establish Dynamic Working Storage
    LR    R13,R1                   Load DWS pointer
    USING FLOWDWS,R13          *** Synchronize FLOWDWS DSECT
    USING IHADCB,FLOWDCB       *** Synchronize IHADCB
    USING JFCB,FLOWJFCB        *** Synchronize JFCB

    MVC   AXPRETC,=F'0'            Set return code = 0
    MVC   AXPREAC,=F'0'            Set reason code = 0
    MVI   FLOWTFL1,X'00'           Zero temporary flags

    IF CLC,AXPTYPE,EQ,=A(AXPTSRC), If Source exit                      +
               OR,                 .. <OR>                             +
               CLC,AXPTYPE,EQ,     .. Library exit                     +
               =A(AXPTLIB)         .. and not IBM source
*              ANDIF,CLC,=C'SYS',NE,AXPDSN    code

      SELECT CLC,AXPRTYP,EQ          Select Request Type

      WHEN =A(AXPROPN)               When OPEN request
        BAS   R14,FLOWOPN              Open the file
        ST    R15,AXPRETC              Pass back return code
        ST    R0,AXPREAC               Pass back reason code

      WHEN =A(AXPRCLS)               When CLOSE request
        BAS   R14,FLOWCLS              Close the file
        OI    FLOWTFL1,FLOWTCLS        Indicate CLOSE call

      WHEN =A(AXPREAD)               When READ request
        BAS   R14,FLOWWRAP             Get wrapped remainder
        IF LTR,R15,R15,Z               If wrapped remainder
          BAS   R14,FLOWCOPY             Copy the statement
        ELSE ,                         Else no wrapped remainder
          BAS   R14,FLOWREAD             Read a record
          ST    R15,AXPRETC              Pass back return code
          IF LTR,R15,R15,Z               If record available
            BAS   R14,FLOWPROC             Process the statement
            BAS   R14,FLOWCOPY             Copy the statement
          ENDIF ,                        EndIf record available
        ENDIF ,                        EndIf no wrapped remainder

      WHEN (=A(AXPRPRO),             When PROCESS request              +
               =A(AXPRPCPY))         (same)
        L     R1,AXPBUFP               Get buffer address
        L     R0,AXPBUFL               Get statement length
        AHI   R0,-8                    Adjust for seqnum area
        BAS   R14,FLOWPROC             Process the statement
        BAS   R14,FLOWCOPY             Copy statement (if needed)

      WHEN (=A(AXPRFMAC),            When FIND request                 +
               =A(AXPRFCPY))         (same)
        LA    R1,FLOWERRM              Point to error macro list
        LHI   R0,FLOWERRM#             Get number of macros in list
        DO FROM=(R0)                   Do for entire list
          IF CLC,0(L'FLOWERRM,R1),EQ,    If matching macro name        +
               AXPMEMN                   ..
            OI    FLOWPFL1,FLOWIGNR        Ignore this member
            ASMLEAVE ,                     Exit the loop
          ENDIF ,                        EndIf matching macro name
          AHI   R1,L'FLOWERRM            Advance pointer
        ENDDO ,                        EndDo for entire list
        MVC   AXPRETC,=A(AXPCMNF)      Show member not found

      WHEN =A(AXPREOM)               When END-OF-MEMBER notification
        NI    FLOWPFL1,X'FF'-FLOWIGNR  Turn off member ignore flag

      ENDSEL ,                       EndSel Request Type

    ENDIF ,                        EndIf Source or Library exit

* Return to Caller
    LR    R2,R13                   Place DWS address into R2
    L     R13,4(,R13)              Load caller save area address
    IF TM,FLOWTFL1-FLOWDWS(R2),    If CLOSE requested                  +
               FLOWTCLS,O
      STORAGE RELEASE,               Release Dynamic Work Area         +
               ADDR=(2),             (same)                            +
               LENGTH=FLOWDWSL       (same)
      MVC   AXPUCOM,=F'0'            Zero out storage pointer
    ENDIF ,                        EndIf
    RETURN (14,12),RC=0            Return to the assembler

***************************************************************
* Open the File                                               *
***************************************************************
FLOWOPN DC 0H
    LHI   R15,AXPCOPL              Both HLASM & exit process lib
    LHI   R0,AXPEEOM               Need END-OF-MEMBER calls
    CLC   AXPTYPE,=A(AXPTSRC)      Source input ?
    BNER  R14                      Branch if not
    STM   R1,R14,FLOWSAV1+4        Save registers 1-14

    MVC   FLOWDCB(FLOWDCBML),FLOWDCBM Copy DCB model
    MVC   FLOWDCBX(FLOWDCBEL),FLOWDCBE Copy DCBE model
    LA    R0,FLOWDCBX              Set address of DCBE
    ST    R0,DCBDCBE               (same)
    LA    R0,FLOWDCBL              Set address of exit list
    STCM  R0,B'0111',DCBEXLSA      (same)
    LA    R0,FLOWJFCB              Set JFCB address in exit list
    ICM   R0,B'1000',=X'07'        (same)
    ST    R0,FLOWDCBL+00           (same)
    OI    FLOWDCBL+00,X'80'        Indicate end of list

    DO ,                           Do for OPEN processing
      LA    R2,FLOWDCB               Point to the DCB
      MVC   FLOWMACW(FLOWRDFML),FLOWRDFM Copy model RDJFCB macro
      RDJFCB ((2)),                  Read the JFCB                     +
               MF=(E,FLOWMACW)       (same)
      IF LTR,R15,R15,NZ              If non-zero return code
        LA    R15,AXPCBAD              Indicate OPEN failed
        XR    R0,R0                    Set reason code = 0
        ASMLEAVE ,                     Leave the structure
      ENDIF ,                        EndIf
      IF CLC,=C'SYS',EQ,JFCBDSNM     If data set starts with 'SYS'
        XR    R15,R15                  Set return code = 0
        XR    R0,R0                    Set reason code = 0
        ASMLEAVE ,                     Leave the structure
      ENDIF ,                        EndIf data set starts with 'SYS'

      MVC   AXPDSN(44),JFCBDSNM      Copy data set name
      MVC   AXPMEMN(8),JFCBELNM      Copy member name
      MVC   AXPVOL(6),JFCBVOLS       Copy volume
      MVC   FLOWMACW(FLOWOPNML),FLOWOPNM Copy model OPEN macro
      OPEN  ((2),INPUT),             Open the DCB                      +
               MODE=31,              (same)                            +
               MF=(E,FLOWMACW)       (same)
      IF LTR,R15,R15,NZ              If non-zero return code
        LA    R15,AXPCBAD              Indicate OPEN failed
        XR    R0,R0                    Set reason code = 0
        ASMLEAVE ,                     Leave the structure
      ENDIF ,                        EndIf
      IF TM,DCBRECFM,DCBRECU,O       If RECFM=U
        CLOSE ((2)),                   Close the DCB                   +
               MODE=31,                (same)                          +
               MF=(E,FLOWMACW)         (same)
        LA    R15,AXPCBAD              Indicate OPEN failed
        XR    R0,R0                    Set reason code = 0
        ASMLEAVE ,                     Leave the structure
      ENDIF ,                        EndIf RECFM=U
      LA    R15,AXPCOPN              Indicate exit did the open
      LA    R0,AXPEDSA               Indicate data set info available
    ENDDO ,                        Do for OPEN processing

* Return to Caller
  LM    R1,R14,FLOWSAV1+4          Restore registers 1-14
  BR    R14                        Return

***************************************************************
* Close the File                                              *
***************************************************************
FLOWCLS DC 0H
    CLC   AXPTYPE,=A(AXPTSRC)      Source input ?
    BNER  R14                      Branch if not
    STM   R0,R15,FLOWSAV1          Save the registers

    IF TM,DCBOFLGS,DCBOFOPN,O      If DCB is open
      MVC   FLOWMACW(FLOWOPNML),FLOWOPNM Copy model OPEN macro
      CLOSE (FLOWDCB),               Close the DCB                     +
               MODE=31,              (same)                            +
               MF=(E,FLOWMACW)       (same)
    ENDIF ,                        EndIf DCB is open

* Return to Caller
    LM    R0,R15,FLOWSAV1          Restore the registers
    BR    R14                      Return

***************************************************************
* Get Wrapped Remainder of Source Record                      *
***************************************************************
FLOWWRAP DC 0H
    LHI   R15,4                    Set return code = 4
    TM    FLOWPFL1,FLOWPWRP        Any wrapped record ?
    BZR   R14                      Return if not

    STM   R2,R14,FLOWSAV1+8        Save registers 2-14

    NI    FLOWPFL1,X'FF'-FLOWPWRP  Turn off wrapping flag
    LM    R0,R1,FLOWRECL           Get internal rec len & ptr
    A     R1,AXPBUFL               Advance pointer
    AHI   R1,-8-16                 (same)
    AHI   R0,8+16                  Adjust remaining length
    S     R0,AXPBUFL               (same)
    IF NP                          If nothing left to wrap
      LHI   R15,4                    Set return code = 4
    ELSE ,                         Else
      MVC   0(15,R1),=CL15' '        Set 15 leading blanks
      IF CLC,FLOWOFFS,NE,=H'0'       If sequence numbers
        L     R14,FLOWRECP             Point to seqnum (if any)
        SH    R14,FLOWOFFS             (same)
        LR    R15,R1                   Point where seqnum goes
        AHI   R15,-8                   (same)
        MVC   0(8,R15),0(R14)          Copy sequence number
      ENDIF ,                        EndIf sequence numbers
      XR    R15,R15                  Set return code = 0
    ENDIF ,                        EndIf nothing left to wrap

* Return to Caller
    LM    R2,R14,FLOWSAV1+8        Restore registers 2-14
    BR    R14                      Return

***************************************************************
* Read A Record                                               *
***************************************************************
FLOWREAD DC 0H
    STM   R2,R14,FLOWSAV1+8        Save registers 2-14

    GET   FLOWDCB                  Get a record (locate mode)
    LR    R3,R1                    Save record address

* Handle *FLOWOPT Statement
    IF TM,FLOWTFL1,FLOWTEOD,Z      If record available
      IF TM,FLOWPFL1,FLOWP1ST,Z      If first record
        XR    R0,R0                    Zero search length
        IF CLC,=CL9'*FLOWOPT ',EQ,     If *FLOWOPT in pos 1            +
               0(R1)                   ..
          LA    R1,9(,R1)                Point past *FLOWOPT
          IF TM,DCBRECFM,DCBRECV,O       If variable format
            LH    R0,0(,R3)                Get length of record
            AHI   R0,-(4-9)                Adjust for RDW & *FLOWOPT
          ELSE ,                         Else must be fixed format
            LH    R0,DCBLRECL              Get length of record
            AHI   R0,-9                    Adjust for *FLOWOPT
          ENDIF ,                        EndIf variable format
        ENDIF ,                        EndIf *FLOWOPT in pos 1
        IF CLC,=CL9'*FLOWOPT ',EQ,     If *FLOWOPT in pos 9            +
               8(R1)                   ..
          LA    R1,8+9(,R1)              Point past *FLOWOPT
          IF TM,DCBRECFM,DCBRECV,O       If variable format
            LH    R0,0(,R3)                Get length of record
            AHI   R0,-(4-8-9)              Adjust for RDW, seq, & HOPTS
          ELSE ,                         Else must be fixed format
            LH    R0,DCBLRECL              Get length of record
            AHI   R0,-(8-9)                Adjust for seqnum & *FLOWOPT
          ENDIF ,                        EndIf variable format
        ENDIF ,                        EndIf *FLOWOPT in pos 9
        IF LTR,R0,R0,NZ                If *FLOWOPT present
          DO FROM=(R0)                   Do for entire record
            IF CHI,R0,GE,7                 If remaining len >= 7
              IF CLC,=C'RECFM=V',EQ,0(R1)    If RECFM=V specified
                OI    FLOWOPTS,FLOWOVAR        Show variable source
              ENDIF ,                        EndIf
            ENDIF ,                        EndIf
            AHI   R1,1                     Increment pointer
          ENDDO ,                        EndDo for entire record
          GET   FLOWDCB                  Get a record (locate mode)
          LR    R3,R1                    Save record address
        ENDIF ,                        EndIf *FLOWOPT present
      ENDIF ,                        EndIf first record
    ENDIF ,                        EndIf record available

    IF TM,FLOWTFL1,FLOWTEOD,Z      If record available

*   Handle Variable Length Records
      IF TM,DCBRECFM,DCBRECV,O       If variable format
        OI    FLOWTFL1,FLOWTVAR        Show variable length records

*     Check if Records are Numbered
        IF TM,FLOWPFL1,FLOWP1ST,Z      If first record
          MVC   FLOWMACW(8),4(R3)        Copy possible seqnum
          OC    FLOWMACW(8),=8C'0'       OR with X'F0' characters
          IF CLC,FLOWMACW(8),EQ,4(R3)    If no change (numbered)
            MVC   FLOWOFFS,=H'8'           Set offset past seqnum
          ENDIF ,                        EndIf
        ENDIF ,                        EndIf first record

*     Load Record Pointers
        LA    R1,4(,R3)                Point to start of record
        AH    R1,FLOWOFFS              Adjust for seqnum
        LH    R0,0(,R3)                Get length of record
        AHI   R0,-4                    Subtract length of RDW
        SH    R0,FLOWOFFS              Adjust for seqnum

*   Handle Fixed Length Records
      ELSE ,                         Else must be fixed format

        IF TM,FLOWOPTS,FLOWOVAR,O      If FLOWOPTS RECFM=V
          OI    FLOWTFL1,FLOWTVAR        Treat like variable length

*       Check if Records are Numbered
          IF TM,FLOWPFL1,FLOWP1ST,Z      If first record
            MVC   FLOWMACW(8),0(R3)        Copy possible seqnum
            OC    FLOWMACW(8),=8C'0'       OR with X'F0' characters
            IF CLC,FLOWMACW(8),EQ,0(R3)    If no change (numbered)
              MVC   FLOWOFFS,=H'8'           Set offset past seqnum
            ENDIF ,                        EndIf
          ENDIF ,                        EndIf first record

*       Trim Trailing Blanks
          LH    R0,DCBLRECL              Get length of record
          LR    R1,R3                    Point to end of record
          AR    R1,R0                    (same)
          AHI   R1,-1                    (same)
          SH    R0,FLOWOFFS              Adjust length for seqnum
          DO FROM=(R0)                   Do for trailing blanks
            DOEXIT CLI,0(R1),GT,C' '       Exit loop if non-blank
            AHI   R1,-1                    Decrement pointer
          ENDDO ,                        EndDo for trailing blanks

*       Load Record Pointer
          LR    R1,R3                    Point to start of record
          AH    R1,FLOWOFFS              Adjust for seqnum

        ELSE ,                         Else truly fixed length
          LR    R1,R3                    Point to start of record
          LH    R0,DCBLRECL              Get length of record
          AHI   R0,-8                    Adjust for seqnum
        ENDIF ,                        EndIf FLOWOPTS RECFM=V

      ENDIF ,                        EndIf variable format

      OI    FLOWPFL1,FLOWP1ST        Show first record processed
      XR    R15,R15                  Set return code = 0
    ELSE ,                         Else end of data reached
      LA    R15,AXPCEOD              Indicate end of data
    ENDIF ,                        EndIf record available

* Return to Caller
    LM    R2,R14,FLOWSAV1+8        Restore registers 2-14
    BR    R14                      Return

***************************************************************
* End-Of-Data Exit                                            *
***************************************************************
FLOWEOD DC 0H
    OI    FLOWTFL1,FLOWTEOD        Indicate end of data
    BR    R14                      Return

***************************************************************
* Process the Statement                                       *
***************************************************************
FLOWPROC DC 0H
    STM   R0,R15,FLOWSAV1          Save the registers

    MVI   FLOWCCHR,C' '            Blank continuation char
    IF TM,FLOWPFL1,FLOWPMAN,O      If manually continued
      NI    FLOWPFL1,X'FF'-FLOWPMAN  Turn off manual cont. flg
      BAS   R14,FLOWMANC             Check for manual cont.
    ELSE ,                         Else
      IF TM,FLOWPFL1,FLOWPCON,O      If continued statement
        NI    FLOWPFL1,X'FF'-FLOWPCON  Turn off continue flag
        BAS   R14,FLOWMANC             Check for manual cont.
        BAS   R14,FLOWCONT             Process continuation
      ELSE ,                         Else
        BAS   R14,FLOWMANC             Check for manual cont.
        IF TM,FLOWPFL1,FLOWPMAN,Z      If not manual cont.
          IF TM,FLOWPFL1,FLOWIGNR,Z      If not ignored
            BAS   R14,FLOWNEWS             Process new statement
          ENDIF ,                        EndIf
        ENDIF ,                        EndIf not manual cont.
      ENDIF ,                        EndIf continued statement
    ENDIF ,                        EndIf manually continued

* Return to Caller
    LM    R2,R15,FLOWSAV1+8        Restore registers 2-15
    BR    R14                      Return

***************************************************************
* Copy the Statement                                          *
***************************************************************
FLOWCOPY DC 0H
    STM   R0,R15,FLOWSAV1          Save the registers

    STM   R0,R1,FLOWRECL           Save internal rec len & ptr
    IF C,R1,NE,AXPBUFP             If input != output
      L     R2,AXPBUFP               Get buffer address
      L     R3,AXPBUFL               Get buffer length
      AHI   R3,-8                    Adjust for seqnum
      LR    R14,R1                   Point to start of record
      LR    R15,R0                   Get length of record
      ICM   R15,B'1000',=C' '        Set blank pad character
      AHI   R3,-1                    Adjust for continuation
      MVCL  R2,R14                   Copy record to buffer
      IF TM,FLOWTFL1,FLOWTVAR,O      If variable length
        IF CLC,FLOWOFFS,NE,=H'0'       If numbered records
          SH    R1,FLOWOFFS              Point to seqnum
          MVC   1(8,R2),0(R1)            Copy seqnum
        ELSE ,                         Else ,
          MVC   1(8,R2),=CL8' '          Make seqnum blanks
        ENDIF ,                        EndIf numbered records
      ELSE ,                         Else fixed length
        AH    R1,DCBLRECL              Point to seqnum
        AHI   R1,-8                    (same)
        MVC   1(8,R2),0(R1)            Copy seqnum
      ENDIF ,                        EndIf variable length
    ENDIF ,                        EndIf input != output

    L     R1,AXPBUFP               Get buffer address
    L     R0,AXPBUFL               Get buffer length
    AHI   R0,-8                    Adjust for seqnum
    STM   R0,R1,FLOWSAV1           Pass back new length & ptr
    AR    R1,R0                    Point to where cchr goes
    AHI   R1,-1                    (same)
    MVC   0(1,R1),FLOWCCHR         Copy continuation char
    IF TM,FLOWPFL1,FLOWPWRP,O      If record should be wrapped
      MVI   0(R1),C'-'               Force continuation char
    ENDIF ,                        EndIf record should be wrapped

* Return to Caller
    LM    R0,R15,FLOWSAV1          Restore the registers
    BR    R14                      Return

***************************************************************
* Check for Manual Continuation                               *
***************************************************************
FLOWMANC DC 0H
    STM   R0,R15,FLOWSAV2          Save the registers

* Check for Continuation
    AR    R1,R0                    Point to last character
    AHI   R1,-1                    (same)
    IF TM,FLOWTFL1,FLOWTVAR,O      If variable length
      IF CLI,0(R1),EQ,C'+'           If statement manually continued
        OI    FLOWPFL1,FLOWPMAN        Show manually continued
        MVC   FLOWCCHR,0(R1)           Copy user's cont character
        MVI   0(R1),C' '               Blank out user's character
      ENDIF ,                        EndIf
    ELSE ,                         Else fixed length
      IF CLI,0(R1),NE,C' '           If statement manually continued
        OI    FLOWPFL1,FLOWPMAN        Show manually continued
        MVC   FLOWCCHR,0(R1)           Copy user's cont character
        MVI   0(R1),C' '               Blank out user's character
      ENDIF ,                        EndIf
    ENDIF ,                        EndIf variable length

* Trim Trailing Blanks
    DO FROM=(R0)                   Do for trailing blanks
      DOEXIT CLI,0(R1),GT,C' '       Exit loop if non-blank
      AHI   R1,-1                    Decrement pointer
    ENDDO ,                        EndDo for trailing blanks

* Return to Caller
    LM    R1,R15,FLOWSAV2+4        Restore registers 1-15
    BR    R14                      Return

***************************************************************
* Process Continued Statement                                 *
***************************************************************
FLOWCONT DC 0H
    STM   R0,R15,FLOWSAV2          Save the registers

    LR    R3,R1                    Load statement address
    LR    R4,R0                    Get statement length
    MVC   FLOWOPRA,=F'0'           Zero out Operand address
    MVC   FLOWOPRZ,=F'0'           Zero out Operand size
    MVC   FLOWCMTA,=F'0'           Zero out Comment address
    MVC   FLOWCMTZ,=F'0'           Zero out Comment size

* Parse Continued Statement
    IF CLI,0(R3),GT,C' '           If label present
      L     R14,AXPERRP              Load error buffer address
      MVC   0(L'FLOWERR1,R14),FLOWERR1 Set error message text
      MVC   AXPERRL,=A(L'FLOWERR1)   Set error message length
      MVC   AXPSEVC,=F'4'            Set error message severity
    ELSE ,                         Else
      DO ,                           Do for continued statement
        BAS   R14,FLOWPSPC             Find the Operand
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        ST    R3,FLOWOPRA              Save Operand address
        BAS   R14,FLOWPTRM             Advance past Operand
        ST    R1,FLOWOPRZ              Save Operand size
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        BAS   R14,FLOWPSPC             Find the Comment
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        ST    R3,FLOWCMTA              Save Comment address
        L     R3,FLOWSAV2              Point to last byte of stmt
        A     R3,FLOWSAV2+4            (same)
        AHI   R3,-1                    (same)
        DO WHILE=(CLI,0(R3),LE,C' ')   Do while trailing blank
          BCTR  R3,0                     Decrement pointer
        ENDDO ,                        EndDo
        AHI   R3,1                     Compute size of Comment
        S     R3,FLOWCMTA              (same)
        ST    R3,FLOWCMTZ              Save Comment size
      ENDDO ,                        EndDo for continued statement
    ENDIF ,                        EndIf

* Supply Continuation if Operand Requires it
    ICM   R14,B'1111',FLOWOPRA     Load Operand address
    IF NZ                          If Operand exists
      IF CLI,0(R14),NE,C','          If 1st byte not a comma
        A     R14,FLOWOPRZ             Point to last Operand byte
        AHI   R14,-1                   (same)
        IF CLI,0(R14),EQ,C','          If last byte is a comma
          MVI   FLOWCCHR,C'-'            Set continuation char
          OI    FLOWPFL1,FLOWPCON        Set continuation flag
        ENDIF ,                        EndIf
      ENDIF ,                        EndIf
    ENDIF ,                        EndIf

* Make the Continuation Statement Valid
    ICM   R14,B'1111',FLOWOPRA     Load Operand address
    IF NZ                          If Operand exists
      S     R14,FLOWSAV2+4           Compute Operand offset

*   Move Operand if Necessary
      IF CHI,R14,NE,16-1             If Operand in wrong location
        MVI   FLOWSTMW,C' '            Blank out statement work area
        MVC   FLOWSTMW+1(L'FLOWSTMW-1),FLOWSTMW               (same)

        IF CLC,AXPRTYP,EQ,=A(AXPRPRO), If library input (SYSLIB) AND   +
               AND,CLC,FLOWOPRZ,GT,    .. Operand size > available     +
               =A(FLOWVSTL-16)         .. area size.
          L     R14,AXPERRP              Load error buffer address
          MVC   0(L'FLOWERR2,R14),FLOWERR2 Set error message text
          MVC   AXPERRL,=A(L'FLOWERR2)   Set error message length
          MVC   AXPSEVC,=F'8'            Set error message severity
        ELSE ,                         Else wrapping allowed
          L     R14,FLOWOPRA             Point to source location
          L     R15,FLOWOPRZ             Get source length
          LA    R0,FLOWSTMW+(16-1)       Point to target location
          LR    R1,R15                   Get target length
          MVCL  R0,R14                   Move the Operand

*       Move Comment if Necessary
          IF CLC,FLOWCMTA,NE,=A(0)       If Comment exists
*
* Remove Annoying Error Message
*           LA    R1,FLOWVSTL-(16+1)       Compute length available
*           S     R1,FLOWOPRZ              (same)
*           IF C,R1,LT,FLOWCMTZ            If Comment too large
*             L     R14,AXPERRP              Load error buffer address
*             MVC   0(L'FLOWERR3,R14),FLOWERR3 Set error message text
*             MVC   AXPERRL,=A(L'FLOWERR3)   Set error message length
*             MVC   AXPSEVC,=F'0'            Set error message severity
*           ENDIF ,                        EndIf
*
            LA    R1,16                    Get first possible Comment
            A     R1,FLOWOPRZ                offset (Operand + 1).
            L     R0,FLOWCMTA              Compute existing offset
            S     R0,FLOWSAV2+4            (same)
            IF CR,R0,GT,R1                 If existing offset OK
              LR    R1,R0                    Use existing offset
            ENDIF ,                        EndIf
            LA    R0,FLOWSTMW(R1)          Point to target address
            L     R1,FLOWCMTZ              Get target length
            L     R14,FLOWCMTA             Point to source location
            LR    R15,R1                   Get source length
            MVCL  R0,R14                   Move the Comment
          ENDIF ,                        EndIf

          LA    R1,FLOWSTMW              Point to work area
          SR    R0,R1                    Compute length of data
          STM   R0,R1,FLOWSAV2           Pass back new length & ptr
        ENDIF ,                        EndIf SYSLIB & Operand too big
      ENDIF ,                        EndIf Operand in wrong location

      IF CLC,FLOWOPRZ,GT,            If operand will wrap              +
               =A(FLOWVSTL-(16-1))   (same)
        OI    FLOWPFL1,FLOWPWRP        Request wrapping of operand
      ENDIF ,                        EndIf operand will wrap

    ENDIF ,                        EndIf Operand exists

* Return to Caller
    LM    R0,R15,FLOWSAV2          Restore the registers
    BR    R14                      Return to caller

***************************************************************
* Process New Statement                                       *
***************************************************************
FLOWNEWS DC 0H
    STM   R0,R15,FLOWSAV2          Save the registers
    LR    R3,R1                    Load statement address
    LR    R4,R0                    Get statement length
    MVC   FLOWOPRA,=F'0'           Zero out Operand address
    MVC   FLOWOPRZ,=F'0'           Zero out Operand size

* Locate First Non-Blank Character
    LR    R14,R3                   Save current address
    LTR   R0,R4                    Save remaining length
    IF P                           If something left
      DO FROM=(R0)                   Do for chars remaining
        DOEXIT CLI,0(R14),GT,C' '      Exit if non-blank found
        LA    R14,1(,R14)              Advance pointer
      ENDDO ,                        EndDo for chars remaining
    ENDIF ,                        EndIf something left

* Process Unaligned Comments
    IF LTR,R0,R0,NZ                If entire line not blank
      IF CLI,0(R14),EQ,C'*'          If a leading asterisk
        MVI   0(R3),C'*'               Set asterisk in column 1
      ELSE ,                         Else ..
        IF CLC,=C'/*',EQ,0(R14)        If a leading '/*'
          MVI   0(R3),C'*'               Set asterisk in column 1
        ENDIF ,                        EndIf
      ENDIF ,                        EndIf
    ENDIF ,                        EndIf

    IF (CLI,0(R3),NE,C'*'),AND,    If not a comment AND                +
               (CLI,0(R3),NE,C'.') .. not a macro statement

*   Parse the Statement
      IF CLI,0(R3),GT,C' '           If label present
        BAS   R14,FLOWPTRM             Advance past Label
      ENDIF ,                        EndIf
      DO ,                           Do for parse
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        BAS   R14,FLOWPSPC             Find the OpCode
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        BAS   R14,FLOWPTRM             Advance past OpCode
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        BAS   R14,FLOWPSPC             Find the Operand
        DOEXIT LTR,R4,R4,NP            Exit if no more data
        ST    R3,FLOWOPRA              Save Operand address
        BAS   R14,FLOWPTRM             Advance past Operand
        ST    R1,FLOWOPRZ              Save Operand size
      ENDDO ,                        EndDo for parse

*   Supply Continuation if Operand Requires it
      ICM   R3,B'1111',FLOWOPRA      Load Operand address
      IF NZ                          If Operand exists
        IF CLI,0(R3),NE,C','           If 1st byte not a comma
          A     R3,FLOWOPRZ              Point to last Operand byte
          BCTR  R3,0                     (same)
          IF CLI,0(R3),EQ,C','           If last byte is a comma
            MVI   FLOWCCHR,C'-'            Set continuation char
            OI    FLOWPFL1,FLOWPCON        Set continuation flag
          ENDIF ,                        EndIf
        ENDIF ,                        EndIf
      ENDIF ,                        EndIf

*   Remove Pre-Comment Blanks for Long Statements
      LM    R0,R1,FLOWSAV2           Get statement length & ptr
      IF CHI,R0,GT,FLOWVSTL          If statement too long
        ICM   R14,B'1111',FLOWOPRA     Get Operand address
        IF NZ                          If Operand exists
          SR    R14,R1                   Get offset to operand
          AR    R1,R14                   Point past operand
          A     R1,FLOWOPRZ              (same)
          S     R0,FLOWOPRZ              Compute length remaining
          SR    R0,R14                   (same)
          AHI   R1,1                     Advance past blank
          AHI   R0,-1                    Decrement length remaining
          IF P,AND,CLI,0(R1),LE,C' '     If two blanks in a row
            LR    R2,R1                    Point to current blank
            LR    R3,R0                    Get length remaining
            DO FROM=(R3)                   Do for extra blanks
              DOEXIT CLI,0(R2),GT,C' '       Exit if non-blank found
              AHI   R2,1                     Advance pointer
            ENDDO ,                        EndDo for extra blanks
            LR    R14,R1                   Get target address
            LR    R15,R3                   Get target length
            SR    R0,R3                    Compute # of squeezed blanks
            MVCL  R14,R2                   Squeeze out the blanks
            LNR   R0,R0                    Adjust total length
            A     R0,FLOWSAV2              (same)
            ST    R0,FLOWSAV2              (same)
          ENDIF ,                        EndIf two blanks in a row
        ENDIF ,                        EndIf Operand exists
      ENDIF ,                        EndIf statement too long

*   Remove Pre-Operand Blanks for Long Statements
      LM    R0,R1,FLOWSAV2           Get statement length & ptr
      IF CHI,R0,GT,FLOWVSTL          If statement too long
        ICM   R0,B'1111',FLOWOPRA      Get Operand address
        IF NZ                          If Operand exists
          SR    R0,R1                    Compute bytes before operand
          LR    R14,R0                   Save value in R14
          L     R1,FLOWOPRA              Point to byte before operand
          AHI   R1,-1                    (same)
          DO FROM=(R0)                   Do for all blanks
            DOEXIT CLI,0(R1),GT,C' '       Exit if non-blank
            AHI   R1,-1                    Decrement pointer
          ENDDO ,                        EndDo for all blanks
          SR    R14,R0                   Compute blanks between terms
          AHI   R14,-1                   Adjust for necessary blank
          IF P                           If something to squeeze
            LR    R0,R14                   Save squeeze count
            LA    R14,2(,R1)               Get target address
            L     R2,FLOWOPRA              Get source address
            LR    R1,R2                    Compute bytes before Operand
            S     R1,FLOWSAV2+4            (same)
            L     R3,FLOWSAV2              Get total length
            SR    R3,R1                    Compute source length
            LR    R15,R3                   Target length = source
            MVCL  R14,R2                   Squeeze out the blanks
            L     R14,FLOWOPRA             Adjust operand address
            SR    R14,R0                   (same)
            ST    R14,FLOWOPRA             (same)
            LNR   R0,R0                    Adjust total length
            A     R0,FLOWSAV2              (same)
            ST    R0,FLOWSAV2              (same)
          ENDIF ,                        If something to squeeze
        ENDIF ,                        EndIf Operand exists
      ENDIF ,                        EndIf statement too long

*   Remove Pre-Opcode Blanks for Long Statements
      LM    R0,R1,FLOWSAV2           Get statement length & ptr
      IF CHI,R0,GT,FLOWVSTL          If statement too long
        DO FROM=(R0)                   Do for non-blanks
          DOEXIT CLI,0(R1),LE,C' '       Exit if blank found
          AHI   R1,1                     Increment pointer
        ENDDO ,                        EndDo for non-blanks
        AHI   R1,1                     Advance past blank
        AHI   R0,-1                    Decrement length remaining
        IF P,AND,CLI,0(R1),LE,C' '     If two blanks in a row
          LR    R2,R1                    Point to current blank
          LR    R3,R0                    Get length remaining
          DO FROM=(R3)                   Do for extra blanks
            DOEXIT CLI,0(R2),GT,C' '       Exit if non-blank found
            AHI   R2,1                     Advance pointer
          ENDDO ,                        EndDo for extra blanks
          LR    R14,R1                   Get target address
          LR    R15,R3                   Get target length
          SR    R0,R3                    Compute # of squeezed blanks
          MVCL  R14,R2                   Squeeze out the blanks
          L     R14,FLOWOPRA             Adjust operand address
          SR    R14,R0                   (same)
          ST    R14,FLOWOPRA             (same)
          LNR   R0,R0                    Adjust total length
          A     R0,FLOWSAV2              (same)
          ST    R0,FLOWSAV2              (same)
        ENDIF ,                        EndIf two blanks in a row
      ENDIF ,                        EndIf statement too long

      ICM   R14,B'1111',FLOWOPRA     Get Operand address
      IF NZ                          If Operand exists
        A     R14,FLOWOPRZ             Point past Operand
        S     R14,FLOWSAV2+4           Compute offset past operand
        IF CHI,R14,GT,FLOWVSTL         If operand will wrap
          OI    FLOWPFL1,FLOWPWRP        Request wrapping of operand
        ENDIF ,                        EndIf operand will wrap
      ENDIF ,                        EndIf Operand exists

    ENDIF ,                        EndIf not commant & not macro

* Return to Caller
    LM    R0,R15,FLOWSAV2          Restore the registers
    BR    R14                      Return

***************************************************************
* Parse a Term                                                *
***************************************************************
FLOWPTRM DC 0H
    LR    R6,R3                    Save current address
    XR    R5,R5                    Indicate no quotes (yet)
    DO FROM=(R4)                   Do for all chars
      DOEXIT CLI,0(R3),EQ,C' ',      Exit loop if blank found          +
               AND,LTR,R5,R5,Z         and not in quoted string.
      IF CLI,0(R3),EQ,C''''          If quote located
        IF LTR,R5,R5,NZ                If already in quotes
          XR    R5,R5                    Indicates no quotes
        ELSE ,                         Else
          LR    R15,R3                   Load quote address
          BCTR  R15,0                    Point to previous character
          DO WHILE=(C,R15,GE,FLOWSAV2+4) Do while still in buffer
            TRT 0(1,R15),FLOWPTRM_SPEC     Test for special char
            DOEXIT Z                       End loop if special char
            IF CLI,0(R15),EQ,C'='          If possible literal
              AHI   R15,1                    Point past '='
              DO WHILE=(CR,R15,LT,R3)        Do for numerics
                DOEXIT CLI,0(R15),LT,C'0'      Exit if not numeric
                AHI   R15,1                    Advance pointer
              ENDDO ,                        EndDo for numerics
              IF CLI,0(R15),EQ,C'C',OR,      If char string <OR>       +
               CLI,0(R15),EQ,C'G',OR,        .. DBCS string <OR>       +
               CLI,0(R15),EQ,C'X'            .. hex string
                LR    R5,R3                    Save quote address
                ASMLEAVE ,                     Exit the loop
              ENDIF ,                        EndIf char/DBCS/hex
              LA    R15,1(,R3)               Point past quote
              LR    R0,R4                    Get length remaining
              AHI   R0,-1                    (same)
              IF P                           If more data
                DO FROM=(R0)                   Do for chars
                  DOEXIT CLI,0(R15),EQ,C''''     Exit if quote
                  AHI   R15,1                    Advance pointer
                ENDDO ,                        EndDo for chars
                IF LTR,R0,R0,NZ                If matching quote
                  LR    R5,R3                    Save quote address
                  ASMLEAVE ,                     Exit the loop
                ENDIF ,                        EndIf matching quote
              ENDIF ,                        EndIf more data
              ASMLEAVE ,                     Exit the loop
            ENDIF ,                        EndIf possible literal
            BCTR  R15,0                    Decrement pointer
          ENDDO ,                        EndDo while still in buffer
          LR    R15,R3                   Point to char before quote
          BCTR  R15,0                    (same)
          TRT   0(1,R15),FLOWPTRM_ATTR   Test if attribute
          IF NZ                          If not attribute
            LR    R5,R3                    Save address of quote
          ENDIF ,                        EndIf
        ENDIF ,                        EndIf already in quotes
      ENDIF ,                        EndIf quote located
      LA    R3,1(,R3)                Advance pointer
    ENDDO ,                        EndDo for all chars
    LR    R1,R3                    Compute length of term
    SR    R1,R6                    (same)
    BR    R14                      Return

FLOWPTRM_SPEC DC  63X'00',193X'FF'   Special character table
              ORG FLOWPTRM_SPEC+C'(' Left paren
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C')' Right paren
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C',' Comma
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C'/' Slash
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C'*' Asterisk
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C'+' Plus
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C'-' Minus
              DC  X'00'              (same)
              ORG FLOWPTRM_SPEC+C' ' Blank
              DC  X'00'              (same)
              ORG ,

FLOWPTRM_ATTR DC  256X'FF'           Attribute reference table
              ORG FLOWPTRM_ATTR+C'd' Defined
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'D' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'i' Integer
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'I' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'k' Count
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'K' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'l' Length
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'L' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'n' Number
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'N' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'o' Operation code
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'O' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C's' Scaling
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'S' (same)
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C't' Type
              DC  X'00'              (same)
              ORG FLOWPTRM_ATTR+C'T' (same)
              DC  X'00'              (same)
              ORG ,

***************************************************************
* Parse White Space                                           *
***************************************************************
FLOWPSPC DC 0H
    DO FROM=(R4)                   Do for remaining chars
      DOEXIT CLI,0(R3),GT,C' '       Exit if non-blank found
      AHI   R3,1                     Advance pointer
    ENDDO ,                        EndDo
    BR    R14                      Return

***************************************************************
* Equates                                                     *
***************************************************************
FLOWVSTL EQU   71                  Statement length

***************************************************************
* Constants                                                   *
***************************************************************
FLOWDCBM DCB   DSORG=PS,           Sequential data set                 +
               MACRF=GL,           Get locate mode                     +
               DDNAME=SYSIN,       DD name = SYSIN                     +
               DCBE=FLOWDCBE       DCBE address
FLOWDCBML EQU  *-FLOWDCBM          Length of DCB model
FLOWDCBE DCBE  EODAD=FLOWEOD,      End of data address                 +
               RMODE31=BUFF        Use 31-bit buffers
FLOWDCBEL EQU  *-FLOWDCBE          Length of DCBE model
FLOWRDFM RDJFCB FLOWDCBM,MF=L      RDJFCB model
FLOWRDFML EQU  *-FLOWRDFM          Length of RDJFCB model
FLOWOPNM OPEN  FLOWDCBM,           OPEN model                          +
               MODE=31,MF=L        (same)
FLOWOPNML EQU  *-FLOWOPNM          Length of RDJFCB model

FLOWERR1 DC    C'First column of continued statement is non-blank'
FLOWERR2 DC    C'Not enough room for continued operand data'
FLOWERR3 DC    C'Not enough room for all of continued comment'

FLOWERRM DC   0CL8                 Macros with syntax errors
         DC    CL8'IAZSMF84'       (same)
         DC    CL8'IEAMSTS'        (same)
         DC    CL8'IEFSSSA'        (same)
         DC    CL8'IEZVG111'       (same)
         DC    CL8'IFGACBVS'       (same)
         DC    CL8'IFGEXLVS'       (same)
         DC    CL8'IHASPTRC'       (same)
         DC    CL8'IHATMTRC'       (same)
         DC    CL8'IRDDFSD'        (same)
         DC    CL8'TRKCALC'        (same)
         DC    CL8'#DIE'           (same)
FLOWERRM# EQU  (*-FLOWERRM)/8      Number of table entries

***************************************************************
* Working Storage                                             *
***************************************************************
FLOWDWS  DSECT ,                   Dynamic Working Storage

         DS    18F                 Standard save area
FLOWSAV1 DS    16F                 Register save area
FLOWSAV2 DS    16F                 Register save area
FLOWSAV3 DS    16F                 Register save area

FLOWRECL DS    F    <-------Keep-\ Final record length
FLOWRECP DS    F  <-----Together-/ Final record pointer

FLOWOPRA DS    A                   Operand Address
FLOWOPRZ DS    F                   Operand Size

FLOWCMTA DS    A                   Comment Address
FLOWCMTZ DS    F                   Comment Size

FLOWMACW DS    XL256               Macro work area

FLOWDCB  DS    0D,XL(FLOWDCBML)    DCB area
FLOWDCBX DS    0D,XL(FLOWDCBEL)    DCB extension
FLOWDCBL DS    4F                  DCB exit list
FLOWJFCB DS    XL(JFCBLGTH)        JFCB area

FLOWOFFS DS    H                   Variable source record offset

FLOWPFL1 DS    XL1                 Permanent flags
FLOWP1ST EQU    X'80'              - First record processed
FLOWPCON EQU    X'40'              - Statement automatically continued
FLOWPMAN EQU    X'20'              - Statement manually continued
FLOWPWRP EQU    X'10'              - Statement should be wrapped
FLOWIGNR EQU    X'01'              - Member should be ignored
FLOWTFL1 DS    XL1                 Temporary flags
FLOWTVAR EQU    X'80'              - Variable length records
FLOWTEOD EQU    X'40'              - End of data reached on input
FLOWTCLS EQU    X'01'              - Close processing requested
FLOWOPTS DS    XL1                 Options
FLOWOVAR EQU    X'80'              - FLOWOPT RECFM=V
FLOWCCHR DS    CL1                 Continuation character

FLOWSTMW DS    CL256               Statement work area
         DS    CL256               Padding area for overflows

         DS    0D                  Align to doubleword boundary
FLOWDWSL EQU   *-FLOWDWS           Length of Dynamic Working Storage

   END ,
