{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012653000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE724.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE724.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x03'", "DS1TRBAL": "b'\\xb3\\xf6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xfa\\x00\\t\\x04\\xfa\\x00\\x0e\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\t/\\x01\\x06\\t/\\x10U\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-04-02T00:00:00", "modifydate": "2006-04-02T10:55:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  724\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE724\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,831 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/02/06    10:55:47    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE724": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\t/\\x01\\x06\\t/\\x10U\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-04-02T00:00:00", "modifydate": "2006-04-02T10:55:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 724 is from Ed Jaffe and contains his improvements to     *   FILE 724\n//*           IBM's HLASM Toolkit.  Some other HLASM-related tools  *   FILE 724\n//*           are also included, such as the ASMFLOW program that   *   FILE 724\n//*           cleans and prettifies Assembler source code.          *   FILE 724\n//*                                                                 *   FILE 724\n//*           email:  edjaffe@phoenixsoftware.com                   *   FILE 724\n//*                                                                 *   FILE 724\n//*       These modifications were dramatically simplified after    *   FILE 724\n//*       APAR PK01283, since IBM adopted most of my suggestions.   *   FILE 724\n//*                                                                 *   FILE 724\n//*       The only modification remaining is the NEXTWHEN macro.    *   FILE 724\n//*       This macro allows you to pass control from one WHEN       *   FILE 724\n//*       clause to the next WHEN clause or the OTHRWISE clause.    *   FILE 724\n//*                                                                 *   FILE 724\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMFLOW": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x06\\x01\\x04\\x17\\x0f\\x01\\x05(\\x1f\\x147\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc5\\xc5\\xd1@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-06-18T00:00:00", "modifydate": "2005-10-08T14:37:06", "lines": 15, "newlines": 15, "modlines": 0, "user": "EEJ"}, "text": "//ASMFLOW  JOB 1,JAFFE,CLASS=A,MSGCLASS=T,NOTIFY=&SYSUID\n//*\n// SET SRCLIB=EDJXADM.FLOWASM.PDS\n// SET MODLIB=SYS2.LINKLIB\n//*\n//ASM     EXEC ASMACL,\n//             PARM.L='LIST=SUMMARY,LET,XREF,MAP,RENT,REUS,REFR'\n//C.SYSLIB  DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//          DD DSN=HLA.SASMMAC1,DISP=SHR\n//          DD DSN=HLA.SASMMAC2,DISP=SHR\n//          DD DSN=&SRCLIB.,DISP=SHR\n//C.SYSIN   DD DSN=&SRCLIB.(FLOWASM),DISP=SHR\n//L.SYSLMOD DD DSN=&MODLIB.(FLOWASM),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EEJASM1": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x005\\x01\\x04\\x17\\x0f\\x01\\x05(\\x1f\\x00\\x12\\x00K\\x00\\xa8\\x00\\x00\\xc5\\xc5\\xd1@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-06-18T00:00:00", "modifydate": "2005-10-08T00:12:35", "lines": 75, "newlines": 168, "modlines": 0, "user": "EEJ"}, "text": "//EEJASM1  JOB 1,JAFFE,CLASS=A,MSGCLASS=T,NOTIFY=&SYSUID\n//*MAIN CLASS=QUIKPROD,SYSTEM=MVS60\n//APP1    EXEC PGM=GIMSMP,REGION=64M\n//SMPCSI   DD  DSN=MVS.GLOBAL.CSI,DISP=SHR\n//SMPCNTL  DD  *\n  SET BOUNDARY(GLOBAL) .\n    RECEIVE SYSMODS LIST .\n  SET BOUNDARY(MVST) .\n    APPLY S(EEJASM1) REDO /* CHECK */ .\n/*\n//SMPPTFIN DD *\n++USERMOD(EEJASM1) /*\n *START OF SPECIFICATIONS**************************************\n *                                                            *\n * USERMOD NAME = EEJASM1                                     *\n *                                                            *\n * DESCRIPTIVE NAME = Mods to Structured Programming Macros.  *\n *                    for HLASM 1.4 Toolkit Release.          *\n *                                                            *\n * FUNCTION =                                                 *\n *                                                            *\n *    These modifications were dramatically simplified after  *\n *    APAR PK01283, since IBM adopted most of my suggestions. *\n *                                                            *\n *    The only modification remaining is the NEXTWHEN macro.  *\n *    This macro allows you to pass control from one WHEN     *\n *    clause to the next WHEN clause or the OTHRWISE clause.  *\n *                                                            *\n * AUTHOR =                                                   *\n *                                                            *\n *    Edward E. Jaffe                                         *\n *    Phoenix Software International                          *\n *    5200 W. Century Blvd., Suite 800                        *\n *    Los Angeles, CA 90045 U.S.A.                            *\n *    edjaffe@phoenixsoftware.com                             *\n *                                                            *\n *END OF SPECIFICATIONS****************************************\n */ .\n++VER(Z038) FMID(JMQ414A)\n            PRE(UK06145)\n            .\n++MACUPD(ASMMSP) .\n./ CHANGE NAME=ASMMSP\n.EXIT    ANOP  ,                                               *EEJASM1\n         POP     PRINT,NOPRINT                                 *EEJASM1\n         MEND  ,                                               *EEJASM1\n        MACRO  ,                                               *EEJASM1\n.***************************************************************EEJASM1\n.*   Macro:   NEXTWHEN                                        **EEJASM1\n.*   Author:  Edward E. Jaffe                                 **EEJASM1\n.*   Company: Phoenix Software International, Inc.            **EEJASM1\n.*   License: This macro is \"freeware\".                       **EEJASM1\n.***************************************************************EEJASM1\n         NEXTWHEN ,                                            *EEJASM1\n         PUSH  PRINT,NOPRINT                                   *EEJASM1\n         PRINT NOMCALL,NOPRINT                                 *EEJASM1\n         COPY  ASMMGBLV                                        *EEJASM1\n         LCLA  &LBLIND,&IDX                                    *EEJASM1\n&IDX     SETA  &ASMA_NI                                        *EEJASM1\n.CHKNEST ANOP  ,                                               *EEJASM1\n         AIF   ('&ASMA_NEST(&IDX)'(5,*) EQ 'SELECT').IDXOK     *EEJASM1\n&IDX     SETA  &IDX-1                                          *EEJASM1\n         AIF   (&IDX GE 1).CHKNEST                             *EEJASM1\n         AGO   .BADLOC                                         *EEJASM1\n.IDXOK   ANOP  ,                                               *EEJASM1\n         AIF   ('&ASMA_NEST(&IDX)'(3,1) EQ ' ').BADLOC         *EEJASM1\n         AIF   ('&ASMA_NEST(&IDX)'(4,1) EQ 'O').BADLOC         *EEJASM1\n&LBLIND  SETA  &ASMA_ST(&IDX) GET INDEX FOR PREV LEVEL         *EEJASM1\n         B&ASMA_REL.C 15,&ASMA_LIND(&LBLIND) GOTO NEXT WHEN    *EEJASM1\n         AGO   .EXIT                                           *EEJASM1\n.BADLOC  ANOP  ,                                               *EEJASM1\n         MNOTE 8,'Improperly placed NEXTWHEN. Must appear inside WHEN c+\n               lause'                                          *EEJASM1\n./ ENDUP\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EEJASM2": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Y\\x01\\x04&\\x8f\\x01\\x05(\\x1f\\x00\\x10\\x00K\\x00\\xa9\\x00\\x00\\xc5\\xc5\\xd1@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-09-24T00:00:00", "modifydate": "2005-10-08T00:10:59", "lines": 75, "newlines": 169, "modlines": 0, "user": "EEJ"}, "text": "//EEJASM2  JOB 1,JAFFE,CLASS=A,MSGCLASS=T,NOTIFY=&SYSUID\n//*MAIN CLASS=QUIKPROD,SYSTEM=MVS60\n//APP1    EXEC PGM=GIMSMP,REGION=64M\n//SMPCSI   DD  DSN=MVS.GLOBAL.CSI,DISP=SHR\n//SMPCNTL  DD  *\n  SET BOUNDARY(GLOBAL) .\n    RECEIVE SYSMODS LIST .\n  SET BOUNDARY(MVST) .\n    APPLY S(EEJASM2) REDO /* CHECK */ .\n/*\n//SMPPTFIN DD *\n++USERMOD(EEJASM2) /*\n *START OF SPECIFICATIONS**************************************\n *                                                            *\n * USERMOD NAME = EEJASM2                                     *\n *                                                            *\n * DESCRIPTIVE NAME = Mods to Structured Programming Macros.  *\n *                    for HLASM 1.5 Toolkit Release.          *\n *                                                            *\n * FUNCTION =                                                 *\n *                                                            *\n *    These modifications were dramatically simplified after  *\n *    APAR PK01283, since IBM adopted most of my suggestions. *\n *                                                            *\n *    The only modification remaining is the NEXTWHEN macro.  *\n *    This macro allows you to pass control from one WHEN     *\n *    clause to the next WHEN clause or the OTHRWISE clause.  *\n *                                                            *\n * AUTHOR =                                                   *\n *                                                            *\n *    Edward E. Jaffe                                         *\n *    Phoenix Software International                          *\n *    5200 W. Century Blvd., Suite 800                        *\n *    Los Angeles, CA 90045 U.S.A.                            *\n *    edjaffe@phoenixsoftware.com                             *\n *                                                            *\n *END OF SPECIFICATIONS****************************************\n */ .\n++VER(Z038) FMID(JMQ415A)\n            PRE(UK06158)\n            .\n++MACUPD(ASMMSP) .\n./ CHANGE NAME=ASMMSP\n        MACRO  ,                                               *EEJASM2\n.***************************************************************EEJASM2\n.*   Macro:   NEXTWHEN                                        **EEJASM2\n.*   Author:  Edward E. Jaffe                                 **EEJASM2\n.*   Company: Phoenix Software International, Inc.            **EEJASM2\n.*   License: This macro is \"freeware\".                       **EEJASM2\n.***************************************************************EEJASM2\n         NEXTWHEN ,                                            *EEJASM2\n         PUSH  PRINT,NOPRINT                                   *EEJASM2\n         PRINT NOMCALL,NOPRINT                                 *EEJASM2\n         COPY  ASMMGBLV                                        *EEJASM2\n         LCLA  &LBLIND,&IDX                                    *EEJASM2\n&IDX     SETA  &ASMA_NI                                        *EEJASM2\n.CHKNEST ANOP  ,                                               *EEJASM2\n         AIF   ('&ASMA_NEST(&IDX)'(5,*) EQ 'SELECT').IDXOK     *EEJASM2\n&IDX     SETA  &IDX-1                                          *EEJASM2\n         AIF   (&IDX GE 1).CHKNEST                             *EEJASM2\n         AGO   .BADLOC                                         *EEJASM2\n.IDXOK   ANOP  ,                                               *EEJASM2\n         AIF   ('&ASMA_NEST(&IDX)'(3,1) EQ ' ').BADLOC         *EEJASM2\n         AIF   ('&ASMA_NEST(&IDX)'(4,1) EQ 'O').BADLOC         *EEJASM2\n&LBLIND  SETA  &ASMA_ST(&IDX) GET INDEX FOR PREV LEVEL         *EEJASM2\n         B&ASMA_REL.C 15,&ASMA_LIND(&LBLIND) GOTO NEXT WHEN    *EEJASM2\n         AGO   .EXIT                                           *EEJASM2\n.BADLOC  ANOP  ,                                               *EEJASM2\n         MNOTE 8,'Improperly placed NEXTWHEN. Must appear inside WHEN c+\n               lause'                                          *EEJASM2\n.EXIT    ANOP  ,                                               *EEJASM2\n         POP   PRINT,NOPRINT                                   *EEJASM2\n         MEND  ,                                               *EEJASM2\n./ ENDUP\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLOWASM": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x008\\x01\\x04\\x17\\x0f\\x01\\x05(_\\x109\\x04\\xda\\x04\\x7f\\x00\\x00\\xc5\\xc5\\xd1@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-06-18T00:00:00", "modifydate": "2005-10-12T10:39:38", "lines": 1242, "newlines": 1151, "modlines": 0, "user": "EEJ"}, "text": "         PRINT OFF,NOPRINT\nFLOWASM  RSECT ,\nFLOWASM  AMODE 31\nFLOWASM  RMODE 31\n         COPY  ASMMSP\n         TITLE 'FLOW - High Level Assembler Exit'\n         PRINT ON,NOPRINT\n         EJECT ,\n*START OF SPECIFICATIONS***************************************\n*                                                             *\n* MODULE NAME = FLOWASM                                       *\n*                                                             *\n* DESCRIPTIVE NAME = High Level Assembler Source/Library Exit *\n*                                                             *\n* FUNCTION =                                                  *\n*                                                             *\n*    This exit reformats assembler source input to make       *\n*    assembler language easier to code and use, especially    *\n*    when using structured programming macros.                *\n*                                                             *\n* AUTHOR =                                                    *\n*                                                             *\n*    Edward E. Jaffe                                          *\n*    Phoenix Software International                           *\n*    5200 W. Century Blvd., Suite 800                         *\n*    Los Angeles, CA 90045 U.S.A.                             *\n*                                                             *\n* ATTRIBUTES =                                                *\n*                                                             *\n*    Reentrant, Amode(31), Rmode(Any)                         *\n*    Must be in APF Library if Invoked by SMP/E               *\n*                                                             *\n* OPERATION = Please Read the Following                       *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Assembler Specification:                                 *\n*                                                             *\n*    EXIT(INX(FLOWASM),LBX(FLOWASM))                          *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Input Formats:                                           *\n*                                                             *\n*    Only fixed length records with LRECL=80 are supported    *\n*    for library input (SYSLIB). Source input may be any of   *\n*    the following:                                           *\n*                                                             *\n*    1) Fixed records of any size. Sequence numbers are       *\n*    allowed in columns LRECL-7 through LRECL. The            *\n*    continuation column is LRECL-8.                          *\n*                                                             *\n*    2) Variable length records without sequence numbers.     *\n*    Continuation is indicated with a trailing '+' character. *\n*                                                             *\n*    3) Variable length records with sequence numbers in      *\n*    columns 1-8. Continuation is indicated with a trailing   *\n*    '+' character.                                           *\n*                                                             *\n*    4) Fixed length records \"pretending\" to be variable      *\n*    length records without sequence numbers. This format is  *\n*    useful when, for example, your variable length file is   *\n*    input to the assembler in-stream via JCL. Trailing       *\n*    blanks are ignored and processing is as for variable     *\n*    length records without sequence numbers. To distinguish  *\n*    this format from true fixed length records, include the  *\n*    following as the first statement of the source module:   *\n*                                                             *\n*    *FLOWOPT RECFM=V                                         *\n*                                                             *\n*    5) Fixed length records \"pretending\" to be variable      *\n*    length records with sequence numbers in columns 1-8.     *\n*    This format is useful when, for example, your variable   *\n*    length file is input to the assembler in-stream via JCL. *\n*    Trailing blanks are ignored and processing is as for     *\n*    variable length records with sequence numbers. To        *\n*    distinguish this format from true fixed length records,  *\n*    include the following as the first statement of the      *\n*    source module:                                           *\n*                                                             *\n*    *FLOWOPT RECFM=V                                         *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Comment Block Identification:                            *\n*                                                             *\n*    Normally, the assembler requires comment blocks be       *\n*    marked with an asterisk in column 1. With this exit,     *\n*    comment blocks may begin anywhere on the line. They may  *\n*    be denoted by an asterisk or by a /* sequence. The exit  *\n*    recognizes these comments and supplies the asterisk in   *\n*    column 1.                                                *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Blank Elimination / Wrapping of Long Lines:              *\n*                                                             *\n*    If a statement is too long to fit in a standard 80-byte  *\n*    assembler source line, the statement is reformatted as   *\n*    follows:                                                 *\n*    1) All extraneous blanks between the operation code and  *\n*       operand are eliminated.                               *\n*    2) If the statement is still too long, extraneous blanks *\n*       between the operand and commentary are removed.       *\n*    3) If the statement is still too long, extraneous blanks *\n*       in front of the operation code are removed.           *\n*    4) If the statement is still too long:                   *\n*       a) If the operand fits on the line, the commentary is *\n*          truncated.                                         *\n*       b) If the operand is too long to fit, it is wrapped   *\n*          and continued in column 16 of the next line along  *\n*          with any commentary.                               *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Automatic Continuation:                                  *\n*                                                             *\n*    Good coding standards usually expect macro operands to   *\n*    be spread out, with one operand and associated           *\n*    commentary per source line. The exit detects such        *\n*    sequences and automatically supplies the '-'             *\n*    continuation character. The '-' is chosen to distinguish *\n*    it from '+' characters coded by the programmer.          *\n*                                                             *\n*    When continuation lines are coded, there is no need to   *\n*    continue in column 16. The exit knows when it has        *\n*    supplied continuation for the previous source line. The  *\n*    continuation line is reformatted so that the operand     *\n*    begins in column 16. (This may be either a left or right *\n*    shift of the operand.) If the commentary must be moved   *\n*    from its current position, either because it conflicts   *\n*    with the new operand position or because the statement   *\n*    is too long, it is moved immediately after the operand.  *\n*    If the statement is still too long, wrapping and/or      *\n*    comment truncation occurs as described above under       *\n*    \"Blank Elimination / Wrapping of Long Lines\".            *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Manual Continuation:                                     *\n*                                                             *\n*    The blank elimination / wrapping and automatic continua- *\n*    tion features are disabled for any line that is manually *\n*    continued and for all subsequent continuation lines for  *\n*    the same statement. Automatic continuation and manual    *\n*    continuation may be mixed within a continued statement,  *\n*    but once manual continuation begins, no more automatic   *\n*    continuation is allowed.                                 *\n*                                                             *\n*    ======================================================== *\n*                                                             *\n*    Example Program:                                         *\n*                                                             *\n*    Freed from the confines of traditional assembler syntax, *\n*    structured programming macros provide a considerably     *\n*    more powerful and easy to use language. For example:     *\n*                                                             *\n*  ********************************************************   *\n*  * Get Dynamic Working Storage                          *   *\n*  ********************************************************   *\n*    ICM R3,B'1111',DwsAddr         Get storage address       *\n*    IF Z                           If not yet acquired       *\n*      STORAGE OBTAIN,                Storage obtain          *\n*              SP=1,                  - Subpool 1             *\n*              LENGTH=DwsSize         - Length of request     *\n*      ST    R1,DwsAddr               Save storage address    *\n*      LR    R3,R1                    (same)                  *\n*      LR    R14,R1                   Clear the area          *\n*      LHI   R15,DwsSize              (same)                  *\n*      XR    R1,R1                    (same)                  *\n*      MVCL  R14,R0                   (same)                  *\n*    ENDIF ,                        EndIf not yet acquired    *\n*                                                             *\n*  ********************************************************   *\n*  * Perform Requested Function                           *   *\n*  ********************************************************   *\n*    L R1,CubicleTkn                Get cubicle token         *\n*    SELECT CLI,InReqCode,EQ        Select InReqCode          *\n*                                                             *\n*    ************************************                     *\n*    * Open the Cubicle                 *                     *\n*    ************************************                     *\n*      WHEN InReqOpen                 Open                    *\n*        JAS  R14,OpenCubicle           Open the Cubicle      *\n*        IF LTR,R2,R15,NZ               If Open failed        *\n*          JAS  R14,CloseCubicle          Clean it up         *\n*          LR R15,R2                      Restore retcode     *\n*        ENDIF ,                        EndIf Open failed     *\n*                                                             *\n*    ************************************                     *\n*    * Close the Cubicle                *                     *\n*    ************************************                     *\n*      WHEN InReqClose                Close                   *\n*        JAS  R14,CloseCubicle          Close the Cubicle     *\n*                                                             *\n*    ************************************                     *\n*    * Reformat the Cubicle             *                     *\n*    ************************************                     *\n*      WHEN InReqReformat             Reformat                *\n*        JAS  R14,ReformatCubicle       Reformat the Cubicle  *\n*                                                             *\n*    ************************************                     *\n*    * Refresh the Cubicle              *                     *\n*    ************************************                     *\n*      WHEN InReqrefresh              Refresh                 *\n*        JAS  R14,ReformatCubicle       Refresh the Cubicle   *\n*                                                             *\n*    ************************************                     *\n*    * Invalid Request Received         *                     *\n*    ************************************                     *\n*      OTHRWISE ,                     Otherwise               *\n*        CUBSRV TYPE=SETMSG,            Set message data      *\n*               MSGPARM=(LogicErr,      - Type = logic error  *\n*                        InReqCode,     - Request code        *\n*                        CubicleTkn)    - Cubicle token       *\n*               THREAD=ThreadTkn        - Thread token        *\n*        LHI R15,RetcodeError           Error return code     *\n*                                                             *\n*    ENDSEL ,                       EndSel InReqCode          *\n*                                                             *\n* RESTRICTIONS =                                              *\n*                                                             *\n*    1) This routine does not use any of its own facilities   *\n*       for obvious reasons.                                  *\n*                                                             *\n*    2) This routine ignores source that comes from data sets *\n*       that start with 'SYS'.                                *\n*                                                             *\n*    3) It is not possible for this exit to detect certain    *\n*       ambiguities. For example, it cannot distinguish       *\n*       between a trailing comma in the operand field and     *\n*       a trailing comma in the first word of the comment     *\n*       if no operand is present. For example, the following  *\n*       appears in IBM's IFGACBVS macro:                      *\n*                                                             *\n*       ____________________________________________________  *\n*      |                                                    | *\n*      |      AIF   ('&AM' NE 'VTAM').ENDACBX    IS IT VTAM | *\n*      |         ISTACBEX          YES, GET VTAM EXTENSIONN | *\n*      |.ENDACBX ANOP                                       | *\n*      |____________________________________________________| *\n*                                                             *\n*       Therefore, we maintain a list of members for which no *\n*       FLOWASM processing is to be performed. This list is   *\n*       the FLOWERRM table.                                   *\n*                                                             *\n*       If you discover additional IBM or ISV macros that get *\n*       assembly errors when processed by this exit, please   *\n*       let the author (Ed Jaffe) know about them and, of     *\n*       course, add them to FLOWERRM in your copy of this     *\n*       exit routine.                                         *\n*                                                             *\n*END OF SPECIFICATIONS ****************************************\n\n    PRINT NOGEN\n\n    ASMAXITP ,                     Define exit parm lists\n    ASMDREG ,                      Define register equates\n    DCBD  DSORG=PS,DEVD=DA         Define DCB DSECT\nJFCB DSECT ,                       Define JFCB DSECT\n    IEFJFCBN ,                     (same)\n    PRINT GEN\n\n***************************************************************\n* Main-Line                                                   *\n***************************************************************\nFLOWASM  RSECT ,\n\n* Save Registers / Establish Addressability\n    SAVE  (14,12),,*               Save the registers\n    LR    R12,R15                  Load base register\n    USING FLOWASM,R12          *** Synchronize base register\n\n* Load Important Pointers\n    LR    R11,R1                   Point to exit parm list\n    USING AXPXITP,R11          *** Synchronize AXPXITP DSECT\n    L     R10,AXPRIP               Load request information ptr\n    USING AXPRIL,R10           *** Synchronize AXPRIL DSECT\n    L     R9,AXPSIP                Load source information ptr\n    USING AXPSIL,R9            *** Synchronize AXPSIL DSECT\n\n* Load Common Storage Address\n    ICM   R1,B'1111',AXPUCOM       Load address of common area\n    IF Z                           If common area not acquired\n      STORAGE OBTAIN,                Acquire the common area           +\n               LENGTH=FLOWDWSL,      (same)                            +\n               LOC=(24,64)           (same)\n      ST   R1,AXPUCOM                Save common area address\n      LR   R0,R1                     Zero out the storage\n      LA   R1,FLOWDWSL               (same)\n      XR   R15,R15                   (same)\n      MVCL R0,R14                    (same)\n      L    R1,AXPUCOM                Load DWS address into R1\n    ENDIF ,                        EndIf\n\n* Chain Save Areas\n    ST    R13,4(,R1)               Chain save areas\n    ST    R1,8(,R13)               (same)\n\n* Establish Dynamic Working Storage\n    LR    R13,R1                   Load DWS pointer\n    USING FLOWDWS,R13          *** Synchronize FLOWDWS DSECT\n    USING IHADCB,FLOWDCB       *** Synchronize IHADCB\n    USING JFCB,FLOWJFCB        *** Synchronize JFCB\n\n    MVC   AXPRETC,=F'0'            Set return code = 0\n    MVC   AXPREAC,=F'0'            Set reason code = 0\n    MVI   FLOWTFL1,X'00'           Zero temporary flags\n\n    IF CLC,AXPTYPE,EQ,=A(AXPTSRC), If Source exit                      +\n               OR,                 .. <OR>                             +\n               CLC,AXPTYPE,EQ,     .. Library exit                     +\n               =A(AXPTLIB)         .. and not IBM source\n*              ANDIF,CLC,=C'SYS',NE,AXPDSN    code\n\n      SELECT CLC,AXPRTYP,EQ          Select Request Type\n\n      WHEN =A(AXPROPN)               When OPEN request\n        BAS   R14,FLOWOPN              Open the file\n        ST    R15,AXPRETC              Pass back return code\n        ST    R0,AXPREAC               Pass back reason code\n\n      WHEN =A(AXPRCLS)               When CLOSE request\n        BAS   R14,FLOWCLS              Close the file\n        OI    FLOWTFL1,FLOWTCLS        Indicate CLOSE call\n\n      WHEN =A(AXPREAD)               When READ request\n        BAS   R14,FLOWWRAP             Get wrapped remainder\n        IF LTR,R15,R15,Z               If wrapped remainder\n          BAS   R14,FLOWCOPY             Copy the statement\n        ELSE ,                         Else no wrapped remainder\n          BAS   R14,FLOWREAD             Read a record\n          ST    R15,AXPRETC              Pass back return code\n          IF LTR,R15,R15,Z               If record available\n            BAS   R14,FLOWPROC             Process the statement\n            BAS   R14,FLOWCOPY             Copy the statement\n          ENDIF ,                        EndIf record available\n        ENDIF ,                        EndIf no wrapped remainder\n\n      WHEN (=A(AXPRPRO),             When PROCESS request              +\n               =A(AXPRPCPY))         (same)\n        L     R1,AXPBUFP               Get buffer address\n        L     R0,AXPBUFL               Get statement length\n        AHI   R0,-8                    Adjust for seqnum area\n        BAS   R14,FLOWPROC             Process the statement\n        BAS   R14,FLOWCOPY             Copy statement (if needed)\n\n      WHEN (=A(AXPRFMAC),            When FIND request                 +\n               =A(AXPRFCPY))         (same)\n        LA    R1,FLOWERRM              Point to error macro list\n        LHI   R0,FLOWERRM#             Get number of macros in list\n        DO FROM=(R0)                   Do for entire list\n          IF CLC,0(L'FLOWERRM,R1),EQ,    If matching macro name        +\n               AXPMEMN                   ..\n            OI    FLOWPFL1,FLOWIGNR        Ignore this member\n            ASMLEAVE ,                     Exit the loop\n          ENDIF ,                        EndIf matching macro name\n          AHI   R1,L'FLOWERRM            Advance pointer\n        ENDDO ,                        EndDo for entire list\n        MVC   AXPRETC,=A(AXPCMNF)      Show member not found\n\n      WHEN =A(AXPREOM)               When END-OF-MEMBER notification\n        NI    FLOWPFL1,X'FF'-FLOWIGNR  Turn off member ignore flag\n\n      ENDSEL ,                       EndSel Request Type\n\n    ENDIF ,                        EndIf Source or Library exit\n\n* Return to Caller\n    LR    R2,R13                   Place DWS address into R2\n    L     R13,4(,R13)              Load caller save area address\n    IF TM,FLOWTFL1-FLOWDWS(R2),    If CLOSE requested                  +\n               FLOWTCLS,O\n      STORAGE RELEASE,               Release Dynamic Work Area         +\n               ADDR=(2),             (same)                            +\n               LENGTH=FLOWDWSL       (same)\n      MVC   AXPUCOM,=F'0'            Zero out storage pointer\n    ENDIF ,                        EndIf\n    RETURN (14,12),RC=0            Return to the assembler\n\n***************************************************************\n* Open the File                                               *\n***************************************************************\nFLOWOPN DC 0H\n    LHI   R15,AXPCOPL              Both HLASM & exit process lib\n    LHI   R0,AXPEEOM               Need END-OF-MEMBER calls\n    CLC   AXPTYPE,=A(AXPTSRC)      Source input ?\n    BNER  R14                      Branch if not\n    STM   R1,R14,FLOWSAV1+4        Save registers 1-14\n\n    MVC   FLOWDCB(FLOWDCBML),FLOWDCBM Copy DCB model\n    MVC   FLOWDCBX(FLOWDCBEL),FLOWDCBE Copy DCBE model\n    LA    R0,FLOWDCBX              Set address of DCBE\n    ST    R0,DCBDCBE               (same)\n    LA    R0,FLOWDCBL              Set address of exit list\n    STCM  R0,B'0111',DCBEXLSA      (same)\n    LA    R0,FLOWJFCB              Set JFCB address in exit list\n    ICM   R0,B'1000',=X'07'        (same)\n    ST    R0,FLOWDCBL+00           (same)\n    OI    FLOWDCBL+00,X'80'        Indicate end of list\n\n    DO ,                           Do for OPEN processing\n      LA    R2,FLOWDCB               Point to the DCB\n      MVC   FLOWMACW(FLOWRDFML),FLOWRDFM Copy model RDJFCB macro\n      RDJFCB ((2)),                  Read the JFCB                     +\n               MF=(E,FLOWMACW)       (same)\n      IF LTR,R15,R15,NZ              If non-zero return code\n        LA    R15,AXPCBAD              Indicate OPEN failed\n        XR    R0,R0                    Set reason code = 0\n        ASMLEAVE ,                     Leave the structure\n      ENDIF ,                        EndIf\n      IF CLC,=C'SYS',EQ,JFCBDSNM     If data set starts with 'SYS'\n        XR    R15,R15                  Set return code = 0\n        XR    R0,R0                    Set reason code = 0\n        ASMLEAVE ,                     Leave the structure\n      ENDIF ,                        EndIf data set starts with 'SYS'\n\n      MVC   AXPDSN(44),JFCBDSNM      Copy data set name\n      MVC   AXPMEMN(8),JFCBELNM      Copy member name\n      MVC   AXPVOL(6),JFCBVOLS       Copy volume\n      MVC   FLOWMACW(FLOWOPNML),FLOWOPNM Copy model OPEN macro\n      OPEN  ((2),INPUT),             Open the DCB                      +\n               MODE=31,              (same)                            +\n               MF=(E,FLOWMACW)       (same)\n      IF LTR,R15,R15,NZ              If non-zero return code\n        LA    R15,AXPCBAD              Indicate OPEN failed\n        XR    R0,R0                    Set reason code = 0\n        ASMLEAVE ,                     Leave the structure\n      ENDIF ,                        EndIf\n      IF TM,DCBRECFM,DCBRECU,O       If RECFM=U\n        CLOSE ((2)),                   Close the DCB                   +\n               MODE=31,                (same)                          +\n               MF=(E,FLOWMACW)         (same)\n        LA    R15,AXPCBAD              Indicate OPEN failed\n        XR    R0,R0                    Set reason code = 0\n        ASMLEAVE ,                     Leave the structure\n      ENDIF ,                        EndIf RECFM=U\n      LA    R15,AXPCOPN              Indicate exit did the open\n      LA    R0,AXPEDSA               Indicate data set info available\n    ENDDO ,                        Do for OPEN processing\n\n* Return to Caller\n  LM    R1,R14,FLOWSAV1+4          Restore registers 1-14\n  BR    R14                        Return\n\n***************************************************************\n* Close the File                                              *\n***************************************************************\nFLOWCLS DC 0H\n    CLC   AXPTYPE,=A(AXPTSRC)      Source input ?\n    BNER  R14                      Branch if not\n    STM   R0,R15,FLOWSAV1          Save the registers\n\n    IF TM,DCBOFLGS,DCBOFOPN,O      If DCB is open\n      MVC   FLOWMACW(FLOWOPNML),FLOWOPNM Copy model OPEN macro\n      CLOSE (FLOWDCB),               Close the DCB                     +\n               MODE=31,              (same)                            +\n               MF=(E,FLOWMACW)       (same)\n    ENDIF ,                        EndIf DCB is open\n\n* Return to Caller\n    LM    R0,R15,FLOWSAV1          Restore the registers\n    BR    R14                      Return\n\n***************************************************************\n* Get Wrapped Remainder of Source Record                      *\n***************************************************************\nFLOWWRAP DC 0H\n    LHI   R15,4                    Set return code = 4\n    TM    FLOWPFL1,FLOWPWRP        Any wrapped record ?\n    BZR   R14                      Return if not\n\n    STM   R2,R14,FLOWSAV1+8        Save registers 2-14\n\n    NI    FLOWPFL1,X'FF'-FLOWPWRP  Turn off wrapping flag\n    LM    R0,R1,FLOWRECL           Get internal rec len & ptr\n    A     R1,AXPBUFL               Advance pointer\n    AHI   R1,-8-16                 (same)\n    AHI   R0,8+16                  Adjust remaining length\n    S     R0,AXPBUFL               (same)\n    IF NP                          If nothing left to wrap\n      LHI   R15,4                    Set return code = 4\n    ELSE ,                         Else\n      MVC   0(15,R1),=CL15' '        Set 15 leading blanks\n      IF CLC,FLOWOFFS,NE,=H'0'       If sequence numbers\n        L     R14,FLOWRECP             Point to seqnum (if any)\n        SH    R14,FLOWOFFS             (same)\n        LR    R15,R1                   Point where seqnum goes\n        AHI   R15,-8                   (same)\n        MVC   0(8,R15),0(R14)          Copy sequence number\n      ENDIF ,                        EndIf sequence numbers\n      XR    R15,R15                  Set return code = 0\n    ENDIF ,                        EndIf nothing left to wrap\n\n* Return to Caller\n    LM    R2,R14,FLOWSAV1+8        Restore registers 2-14\n    BR    R14                      Return\n\n***************************************************************\n* Read A Record                                               *\n***************************************************************\nFLOWREAD DC 0H\n    STM   R2,R14,FLOWSAV1+8        Save registers 2-14\n\n    GET   FLOWDCB                  Get a record (locate mode)\n    LR    R3,R1                    Save record address\n\n* Handle *FLOWOPT Statement\n    IF TM,FLOWTFL1,FLOWTEOD,Z      If record available\n      IF TM,FLOWPFL1,FLOWP1ST,Z      If first record\n        XR    R0,R0                    Zero search length\n        IF CLC,=CL9'*FLOWOPT ',EQ,     If *FLOWOPT in pos 1            +\n               0(R1)                   ..\n          LA    R1,9(,R1)                Point past *FLOWOPT\n          IF TM,DCBRECFM,DCBRECV,O       If variable format\n            LH    R0,0(,R3)                Get length of record\n            AHI   R0,-(4-9)                Adjust for RDW & *FLOWOPT\n          ELSE ,                         Else must be fixed format\n            LH    R0,DCBLRECL              Get length of record\n            AHI   R0,-9                    Adjust for *FLOWOPT\n          ENDIF ,                        EndIf variable format\n        ENDIF ,                        EndIf *FLOWOPT in pos 1\n        IF CLC,=CL9'*FLOWOPT ',EQ,     If *FLOWOPT in pos 9            +\n               8(R1)                   ..\n          LA    R1,8+9(,R1)              Point past *FLOWOPT\n          IF TM,DCBRECFM,DCBRECV,O       If variable format\n            LH    R0,0(,R3)                Get length of record\n            AHI   R0,-(4-8-9)              Adjust for RDW, seq, & HOPTS\n          ELSE ,                         Else must be fixed format\n            LH    R0,DCBLRECL              Get length of record\n            AHI   R0,-(8-9)                Adjust for seqnum & *FLOWOPT\n          ENDIF ,                        EndIf variable format\n        ENDIF ,                        EndIf *FLOWOPT in pos 9\n        IF LTR,R0,R0,NZ                If *FLOWOPT present\n          DO FROM=(R0)                   Do for entire record\n            IF CHI,R0,GE,7                 If remaining len >= 7\n              IF CLC,=C'RECFM=V',EQ,0(R1)    If RECFM=V specified\n                OI    FLOWOPTS,FLOWOVAR        Show variable source\n              ENDIF ,                        EndIf\n            ENDIF ,                        EndIf\n            AHI   R1,1                     Increment pointer\n          ENDDO ,                        EndDo for entire record\n          GET   FLOWDCB                  Get a record (locate mode)\n          LR    R3,R1                    Save record address\n        ENDIF ,                        EndIf *FLOWOPT present\n      ENDIF ,                        EndIf first record\n    ENDIF ,                        EndIf record available\n\n    IF TM,FLOWTFL1,FLOWTEOD,Z      If record available\n\n*   Handle Variable Length Records\n      IF TM,DCBRECFM,DCBRECV,O       If variable format\n        OI    FLOWTFL1,FLOWTVAR        Show variable length records\n\n*     Check if Records are Numbered\n        IF TM,FLOWPFL1,FLOWP1ST,Z      If first record\n          MVC   FLOWMACW(8),4(R3)        Copy possible seqnum\n          OC    FLOWMACW(8),=8C'0'       OR with X'F0' characters\n          IF CLC,FLOWMACW(8),EQ,4(R3)    If no change (numbered)\n            MVC   FLOWOFFS,=H'8'           Set offset past seqnum\n          ENDIF ,                        EndIf\n        ENDIF ,                        EndIf first record\n\n*     Load Record Pointers\n        LA    R1,4(,R3)                Point to start of record\n        AH    R1,FLOWOFFS              Adjust for seqnum\n        LH    R0,0(,R3)                Get length of record\n        AHI   R0,-4                    Subtract length of RDW\n        SH    R0,FLOWOFFS              Adjust for seqnum\n\n*   Handle Fixed Length Records\n      ELSE ,                         Else must be fixed format\n\n        IF TM,FLOWOPTS,FLOWOVAR,O      If FLOWOPTS RECFM=V\n          OI    FLOWTFL1,FLOWTVAR        Treat like variable length\n\n*       Check if Records are Numbered\n          IF TM,FLOWPFL1,FLOWP1ST,Z      If first record\n            MVC   FLOWMACW(8),0(R3)        Copy possible seqnum\n            OC    FLOWMACW(8),=8C'0'       OR with X'F0' characters\n            IF CLC,FLOWMACW(8),EQ,0(R3)    If no change (numbered)\n              MVC   FLOWOFFS,=H'8'           Set offset past seqnum\n            ENDIF ,                        EndIf\n          ENDIF ,                        EndIf first record\n\n*       Trim Trailing Blanks\n          LH    R0,DCBLRECL              Get length of record\n          LR    R1,R3                    Point to end of record\n          AR    R1,R0                    (same)\n          AHI   R1,-1                    (same)\n          SH    R0,FLOWOFFS              Adjust length for seqnum\n          DO FROM=(R0)                   Do for trailing blanks\n            DOEXIT CLI,0(R1),GT,C' '       Exit loop if non-blank\n            AHI   R1,-1                    Decrement pointer\n          ENDDO ,                        EndDo for trailing blanks\n\n*       Load Record Pointer\n          LR    R1,R3                    Point to start of record\n          AH    R1,FLOWOFFS              Adjust for seqnum\n\n        ELSE ,                         Else truly fixed length\n          LR    R1,R3                    Point to start of record\n          LH    R0,DCBLRECL              Get length of record\n          AHI   R0,-8                    Adjust for seqnum\n        ENDIF ,                        EndIf FLOWOPTS RECFM=V\n\n      ENDIF ,                        EndIf variable format\n\n      OI    FLOWPFL1,FLOWP1ST        Show first record processed\n      XR    R15,R15                  Set return code = 0\n    ELSE ,                         Else end of data reached\n      LA    R15,AXPCEOD              Indicate end of data\n    ENDIF ,                        EndIf record available\n\n* Return to Caller\n    LM    R2,R14,FLOWSAV1+8        Restore registers 2-14\n    BR    R14                      Return\n\n***************************************************************\n* End-Of-Data Exit                                            *\n***************************************************************\nFLOWEOD DC 0H\n    OI    FLOWTFL1,FLOWTEOD        Indicate end of data\n    BR    R14                      Return\n\n***************************************************************\n* Process the Statement                                       *\n***************************************************************\nFLOWPROC DC 0H\n    STM   R0,R15,FLOWSAV1          Save the registers\n\n    MVI   FLOWCCHR,C' '            Blank continuation char\n    IF TM,FLOWPFL1,FLOWPMAN,O      If manually continued\n      NI    FLOWPFL1,X'FF'-FLOWPMAN  Turn off manual cont. flg\n      BAS   R14,FLOWMANC             Check for manual cont.\n    ELSE ,                         Else\n      IF TM,FLOWPFL1,FLOWPCON,O      If continued statement\n        NI    FLOWPFL1,X'FF'-FLOWPCON  Turn off continue flag\n        BAS   R14,FLOWMANC             Check for manual cont.\n        BAS   R14,FLOWCONT             Process continuation\n      ELSE ,                         Else\n        BAS   R14,FLOWMANC             Check for manual cont.\n        IF TM,FLOWPFL1,FLOWPMAN,Z      If not manual cont.\n          IF TM,FLOWPFL1,FLOWIGNR,Z      If not ignored\n            BAS   R14,FLOWNEWS             Process new statement\n          ENDIF ,                        EndIf\n        ENDIF ,                        EndIf not manual cont.\n      ENDIF ,                        EndIf continued statement\n    ENDIF ,                        EndIf manually continued\n\n* Return to Caller\n    LM    R2,R15,FLOWSAV1+8        Restore registers 2-15\n    BR    R14                      Return\n\n***************************************************************\n* Copy the Statement                                          *\n***************************************************************\nFLOWCOPY DC 0H\n    STM   R0,R15,FLOWSAV1          Save the registers\n\n    STM   R0,R1,FLOWRECL           Save internal rec len & ptr\n    IF C,R1,NE,AXPBUFP             If input != output\n      L     R2,AXPBUFP               Get buffer address\n      L     R3,AXPBUFL               Get buffer length\n      AHI   R3,-8                    Adjust for seqnum\n      LR    R14,R1                   Point to start of record\n      LR    R15,R0                   Get length of record\n      ICM   R15,B'1000',=C' '        Set blank pad character\n      AHI   R3,-1                    Adjust for continuation\n      MVCL  R2,R14                   Copy record to buffer\n      IF TM,FLOWTFL1,FLOWTVAR,O      If variable length\n        IF CLC,FLOWOFFS,NE,=H'0'       If numbered records\n          SH    R1,FLOWOFFS              Point to seqnum\n          MVC   1(8,R2),0(R1)            Copy seqnum\n        ELSE ,                         Else ,\n          MVC   1(8,R2),=CL8' '          Make seqnum blanks\n        ENDIF ,                        EndIf numbered records\n      ELSE ,                         Else fixed length\n        AH    R1,DCBLRECL              Point to seqnum\n        AHI   R1,-8                    (same)\n        MVC   1(8,R2),0(R1)            Copy seqnum\n      ENDIF ,                        EndIf variable length\n    ENDIF ,                        EndIf input != output\n\n    L     R1,AXPBUFP               Get buffer address\n    L     R0,AXPBUFL               Get buffer length\n    AHI   R0,-8                    Adjust for seqnum\n    STM   R0,R1,FLOWSAV1           Pass back new length & ptr\n    AR    R1,R0                    Point to where cchr goes\n    AHI   R1,-1                    (same)\n    MVC   0(1,R1),FLOWCCHR         Copy continuation char\n    IF TM,FLOWPFL1,FLOWPWRP,O      If record should be wrapped\n      MVI   0(R1),C'-'               Force continuation char\n    ENDIF ,                        EndIf record should be wrapped\n\n* Return to Caller\n    LM    R0,R15,FLOWSAV1          Restore the registers\n    BR    R14                      Return\n\n***************************************************************\n* Check for Manual Continuation                               *\n***************************************************************\nFLOWMANC DC 0H\n    STM   R0,R15,FLOWSAV2          Save the registers\n\n* Check for Continuation\n    AR    R1,R0                    Point to last character\n    AHI   R1,-1                    (same)\n    IF TM,FLOWTFL1,FLOWTVAR,O      If variable length\n      IF CLI,0(R1),EQ,C'+'           If statement manually continued\n        OI    FLOWPFL1,FLOWPMAN        Show manually continued\n        MVC   FLOWCCHR,0(R1)           Copy user's cont character\n        MVI   0(R1),C' '               Blank out user's character\n      ENDIF ,                        EndIf\n    ELSE ,                         Else fixed length\n      IF CLI,0(R1),NE,C' '           If statement manually continued\n        OI    FLOWPFL1,FLOWPMAN        Show manually continued\n        MVC   FLOWCCHR,0(R1)           Copy user's cont character\n        MVI   0(R1),C' '               Blank out user's character\n      ENDIF ,                        EndIf\n    ENDIF ,                        EndIf variable length\n\n* Trim Trailing Blanks\n    DO FROM=(R0)                   Do for trailing blanks\n      DOEXIT CLI,0(R1),GT,C' '       Exit loop if non-blank\n      AHI   R1,-1                    Decrement pointer\n    ENDDO ,                        EndDo for trailing blanks\n\n* Return to Caller\n    LM    R1,R15,FLOWSAV2+4        Restore registers 1-15\n    BR    R14                      Return\n\n***************************************************************\n* Process Continued Statement                                 *\n***************************************************************\nFLOWCONT DC 0H\n    STM   R0,R15,FLOWSAV2          Save the registers\n\n    LR    R3,R1                    Load statement address\n    LR    R4,R0                    Get statement length\n    MVC   FLOWOPRA,=F'0'           Zero out Operand address\n    MVC   FLOWOPRZ,=F'0'           Zero out Operand size\n    MVC   FLOWCMTA,=F'0'           Zero out Comment address\n    MVC   FLOWCMTZ,=F'0'           Zero out Comment size\n\n* Parse Continued Statement\n    IF CLI,0(R3),GT,C' '           If label present\n      L     R14,AXPERRP              Load error buffer address\n      MVC   0(L'FLOWERR1,R14),FLOWERR1 Set error message text\n      MVC   AXPERRL,=A(L'FLOWERR1)   Set error message length\n      MVC   AXPSEVC,=F'4'            Set error message severity\n    ELSE ,                         Else\n      DO ,                           Do for continued statement\n        BAS   R14,FLOWPSPC             Find the Operand\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        ST    R3,FLOWOPRA              Save Operand address\n        BAS   R14,FLOWPTRM             Advance past Operand\n        ST    R1,FLOWOPRZ              Save Operand size\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        BAS   R14,FLOWPSPC             Find the Comment\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        ST    R3,FLOWCMTA              Save Comment address\n        L     R3,FLOWSAV2              Point to last byte of stmt\n        A     R3,FLOWSAV2+4            (same)\n        AHI   R3,-1                    (same)\n        DO WHILE=(CLI,0(R3),LE,C' ')   Do while trailing blank\n          BCTR  R3,0                     Decrement pointer\n        ENDDO ,                        EndDo\n        AHI   R3,1                     Compute size of Comment\n        S     R3,FLOWCMTA              (same)\n        ST    R3,FLOWCMTZ              Save Comment size\n      ENDDO ,                        EndDo for continued statement\n    ENDIF ,                        EndIf\n\n* Supply Continuation if Operand Requires it\n    ICM   R14,B'1111',FLOWOPRA     Load Operand address\n    IF NZ                          If Operand exists\n      IF CLI,0(R14),NE,C','          If 1st byte not a comma\n        A     R14,FLOWOPRZ             Point to last Operand byte\n        AHI   R14,-1                   (same)\n        IF CLI,0(R14),EQ,C','          If last byte is a comma\n          MVI   FLOWCCHR,C'-'            Set continuation char\n          OI    FLOWPFL1,FLOWPCON        Set continuation flag\n        ENDIF ,                        EndIf\n      ENDIF ,                        EndIf\n    ENDIF ,                        EndIf\n\n* Make the Continuation Statement Valid\n    ICM   R14,B'1111',FLOWOPRA     Load Operand address\n    IF NZ                          If Operand exists\n      S     R14,FLOWSAV2+4           Compute Operand offset\n\n*   Move Operand if Necessary\n      IF CHI,R14,NE,16-1             If Operand in wrong location\n        MVI   FLOWSTMW,C' '            Blank out statement work area\n        MVC   FLOWSTMW+1(L'FLOWSTMW-1),FLOWSTMW               (same)\n\n        IF CLC,AXPRTYP,EQ,=A(AXPRPRO), If library input (SYSLIB) AND   +\n               AND,CLC,FLOWOPRZ,GT,    .. Operand size > available     +\n               =A(FLOWVSTL-16)         .. area size.\n          L     R14,AXPERRP              Load error buffer address\n          MVC   0(L'FLOWERR2,R14),FLOWERR2 Set error message text\n          MVC   AXPERRL,=A(L'FLOWERR2)   Set error message length\n          MVC   AXPSEVC,=F'8'            Set error message severity\n        ELSE ,                         Else wrapping allowed\n          L     R14,FLOWOPRA             Point to source location\n          L     R15,FLOWOPRZ             Get source length\n          LA    R0,FLOWSTMW+(16-1)       Point to target location\n          LR    R1,R15                   Get target length\n          MVCL  R0,R14                   Move the Operand\n\n*       Move Comment if Necessary\n          IF CLC,FLOWCMTA,NE,=A(0)       If Comment exists\n*\n* Remove Annoying Error Message\n*           LA    R1,FLOWVSTL-(16+1)       Compute length available\n*           S     R1,FLOWOPRZ              (same)\n*           IF C,R1,LT,FLOWCMTZ            If Comment too large\n*             L     R14,AXPERRP              Load error buffer address\n*             MVC   0(L'FLOWERR3,R14),FLOWERR3 Set error message text\n*             MVC   AXPERRL,=A(L'FLOWERR3)   Set error message length\n*             MVC   AXPSEVC,=F'0'            Set error message severity\n*           ENDIF ,                        EndIf\n*\n            LA    R1,16                    Get first possible Comment\n            A     R1,FLOWOPRZ                offset (Operand + 1).\n            L     R0,FLOWCMTA              Compute existing offset\n            S     R0,FLOWSAV2+4            (same)\n            IF CR,R0,GT,R1                 If existing offset OK\n              LR    R1,R0                    Use existing offset\n            ENDIF ,                        EndIf\n            LA    R0,FLOWSTMW(R1)          Point to target address\n            L     R1,FLOWCMTZ              Get target length\n            L     R14,FLOWCMTA             Point to source location\n            LR    R15,R1                   Get source length\n            MVCL  R0,R14                   Move the Comment\n          ENDIF ,                        EndIf\n\n          LA    R1,FLOWSTMW              Point to work area\n          SR    R0,R1                    Compute length of data\n          STM   R0,R1,FLOWSAV2           Pass back new length & ptr\n        ENDIF ,                        EndIf SYSLIB & Operand too big\n      ENDIF ,                        EndIf Operand in wrong location\n\n      IF CLC,FLOWOPRZ,GT,            If operand will wrap              +\n               =A(FLOWVSTL-(16-1))   (same)\n        OI    FLOWPFL1,FLOWPWRP        Request wrapping of operand\n      ENDIF ,                        EndIf operand will wrap\n\n    ENDIF ,                        EndIf Operand exists\n\n* Return to Caller\n    LM    R0,R15,FLOWSAV2          Restore the registers\n    BR    R14                      Return to caller\n\n***************************************************************\n* Process New Statement                                       *\n***************************************************************\nFLOWNEWS DC 0H\n    STM   R0,R15,FLOWSAV2          Save the registers\n    LR    R3,R1                    Load statement address\n    LR    R4,R0                    Get statement length\n    MVC   FLOWOPRA,=F'0'           Zero out Operand address\n    MVC   FLOWOPRZ,=F'0'           Zero out Operand size\n\n* Locate First Non-Blank Character\n    LR    R14,R3                   Save current address\n    LTR   R0,R4                    Save remaining length\n    IF P                           If something left\n      DO FROM=(R0)                   Do for chars remaining\n        DOEXIT CLI,0(R14),GT,C' '      Exit if non-blank found\n        LA    R14,1(,R14)              Advance pointer\n      ENDDO ,                        EndDo for chars remaining\n    ENDIF ,                        EndIf something left\n\n* Process Unaligned Comments\n    IF LTR,R0,R0,NZ                If entire line not blank\n      IF CLI,0(R14),EQ,C'*'          If a leading asterisk\n        MVI   0(R3),C'*'               Set asterisk in column 1\n      ELSE ,                         Else ..\n        IF CLC,=C'/*',EQ,0(R14)        If a leading '/*'\n          MVI   0(R3),C'*'               Set asterisk in column 1\n        ENDIF ,                        EndIf\n      ENDIF ,                        EndIf\n    ENDIF ,                        EndIf\n\n    IF (CLI,0(R3),NE,C'*'),AND,    If not a comment AND                +\n               (CLI,0(R3),NE,C'.') .. not a macro statement\n\n*   Parse the Statement\n      IF CLI,0(R3),GT,C' '           If label present\n        BAS   R14,FLOWPTRM             Advance past Label\n      ENDIF ,                        EndIf\n      DO ,                           Do for parse\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        BAS   R14,FLOWPSPC             Find the OpCode\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        BAS   R14,FLOWPTRM             Advance past OpCode\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        BAS   R14,FLOWPSPC             Find the Operand\n        DOEXIT LTR,R4,R4,NP            Exit if no more data\n        ST    R3,FLOWOPRA              Save Operand address\n        BAS   R14,FLOWPTRM             Advance past Operand\n        ST    R1,FLOWOPRZ              Save Operand size\n      ENDDO ,                        EndDo for parse\n\n*   Supply Continuation if Operand Requires it\n      ICM   R3,B'1111',FLOWOPRA      Load Operand address\n      IF NZ                          If Operand exists\n        IF CLI,0(R3),NE,C','           If 1st byte not a comma\n          A     R3,FLOWOPRZ              Point to last Operand byte\n          BCTR  R3,0                     (same)\n          IF CLI,0(R3),EQ,C','           If last byte is a comma\n            MVI   FLOWCCHR,C'-'            Set continuation char\n            OI    FLOWPFL1,FLOWPCON        Set continuation flag\n          ENDIF ,                        EndIf\n        ENDIF ,                        EndIf\n      ENDIF ,                        EndIf\n\n*   Remove Pre-Comment Blanks for Long Statements\n      LM    R0,R1,FLOWSAV2           Get statement length & ptr\n      IF CHI,R0,GT,FLOWVSTL          If statement too long\n        ICM   R14,B'1111',FLOWOPRA     Get Operand address\n        IF NZ                          If Operand exists\n          SR    R14,R1                   Get offset to operand\n          AR    R1,R14                   Point past operand\n          A     R1,FLOWOPRZ              (same)\n          S     R0,FLOWOPRZ              Compute length remaining\n          SR    R0,R14                   (same)\n          AHI   R1,1                     Advance past blank\n          AHI   R0,-1                    Decrement length remaining\n          IF P,AND,CLI,0(R1),LE,C' '     If two blanks in a row\n            LR    R2,R1                    Point to current blank\n            LR    R3,R0                    Get length remaining\n            DO FROM=(R3)                   Do for extra blanks\n              DOEXIT CLI,0(R2),GT,C' '       Exit if non-blank found\n              AHI   R2,1                     Advance pointer\n            ENDDO ,                        EndDo for extra blanks\n            LR    R14,R1                   Get target address\n            LR    R15,R3                   Get target length\n            SR    R0,R3                    Compute # of squeezed blanks\n            MVCL  R14,R2                   Squeeze out the blanks\n            LNR   R0,R0                    Adjust total length\n            A     R0,FLOWSAV2              (same)\n            ST    R0,FLOWSAV2              (same)\n          ENDIF ,                        EndIf two blanks in a row\n        ENDIF ,                        EndIf Operand exists\n      ENDIF ,                        EndIf statement too long\n\n*   Remove Pre-Operand Blanks for Long Statements\n      LM    R0,R1,FLOWSAV2           Get statement length & ptr\n      IF CHI,R0,GT,FLOWVSTL          If statement too long\n        ICM   R0,B'1111',FLOWOPRA      Get Operand address\n        IF NZ                          If Operand exists\n          SR    R0,R1                    Compute bytes before operand\n          LR    R14,R0                   Save value in R14\n          L     R1,FLOWOPRA              Point to byte before operand\n          AHI   R1,-1                    (same)\n          DO FROM=(R0)                   Do for all blanks\n            DOEXIT CLI,0(R1),GT,C' '       Exit if non-blank\n            AHI   R1,-1                    Decrement pointer\n          ENDDO ,                        EndDo for all blanks\n          SR    R14,R0                   Compute blanks between terms\n          AHI   R14,-1                   Adjust for necessary blank\n          IF P                           If something to squeeze\n            LR    R0,R14                   Save squeeze count\n            LA    R14,2(,R1)               Get target address\n            L     R2,FLOWOPRA              Get source address\n            LR    R1,R2                    Compute bytes before Operand\n            S     R1,FLOWSAV2+4            (same)\n            L     R3,FLOWSAV2              Get total length\n            SR    R3,R1                    Compute source length\n            LR    R15,R3                   Target length = source\n            MVCL  R14,R2                   Squeeze out the blanks\n            L     R14,FLOWOPRA             Adjust operand address\n            SR    R14,R0                   (same)\n            ST    R14,FLOWOPRA             (same)\n            LNR   R0,R0                    Adjust total length\n            A     R0,FLOWSAV2              (same)\n            ST    R0,FLOWSAV2              (same)\n          ENDIF ,                        If something to squeeze\n        ENDIF ,                        EndIf Operand exists\n      ENDIF ,                        EndIf statement too long\n\n*   Remove Pre-Opcode Blanks for Long Statements\n      LM    R0,R1,FLOWSAV2           Get statement length & ptr\n      IF CHI,R0,GT,FLOWVSTL          If statement too long\n        DO FROM=(R0)                   Do for non-blanks\n          DOEXIT CLI,0(R1),LE,C' '       Exit if blank found\n          AHI   R1,1                     Increment pointer\n        ENDDO ,                        EndDo for non-blanks\n        AHI   R1,1                     Advance past blank\n        AHI   R0,-1                    Decrement length remaining\n        IF P,AND,CLI,0(R1),LE,C' '     If two blanks in a row\n          LR    R2,R1                    Point to current blank\n          LR    R3,R0                    Get length remaining\n          DO FROM=(R3)                   Do for extra blanks\n            DOEXIT CLI,0(R2),GT,C' '       Exit if non-blank found\n            AHI   R2,1                     Advance pointer\n          ENDDO ,                        EndDo for extra blanks\n          LR    R14,R1                   Get target address\n          LR    R15,R3                   Get target length\n          SR    R0,R3                    Compute # of squeezed blanks\n          MVCL  R14,R2                   Squeeze out the blanks\n          L     R14,FLOWOPRA             Adjust operand address\n          SR    R14,R0                   (same)\n          ST    R14,FLOWOPRA             (same)\n          LNR   R0,R0                    Adjust total length\n          A     R0,FLOWSAV2              (same)\n          ST    R0,FLOWSAV2              (same)\n        ENDIF ,                        EndIf two blanks in a row\n      ENDIF ,                        EndIf statement too long\n\n      ICM   R14,B'1111',FLOWOPRA     Get Operand address\n      IF NZ                          If Operand exists\n        A     R14,FLOWOPRZ             Point past Operand\n        S     R14,FLOWSAV2+4           Compute offset past operand\n        IF CHI,R14,GT,FLOWVSTL         If operand will wrap\n          OI    FLOWPFL1,FLOWPWRP        Request wrapping of operand\n        ENDIF ,                        EndIf operand will wrap\n      ENDIF ,                        EndIf Operand exists\n\n    ENDIF ,                        EndIf not commant & not macro\n\n* Return to Caller\n    LM    R0,R15,FLOWSAV2          Restore the registers\n    BR    R14                      Return\n\n***************************************************************\n* Parse a Term                                                *\n***************************************************************\nFLOWPTRM DC 0H\n    LR    R6,R3                    Save current address\n    XR    R5,R5                    Indicate no quotes (yet)\n    DO FROM=(R4)                   Do for all chars\n      DOEXIT CLI,0(R3),EQ,C' ',      Exit loop if blank found          +\n               AND,LTR,R5,R5,Z         and not in quoted string.\n      IF CLI,0(R3),EQ,C''''          If quote located\n        IF LTR,R5,R5,NZ                If already in quotes\n          XR    R5,R5                    Indicates no quotes\n        ELSE ,                         Else\n          LR    R15,R3                   Load quote address\n          BCTR  R15,0                    Point to previous character\n          DO WHILE=(C,R15,GE,FLOWSAV2+4) Do while still in buffer\n            TRT 0(1,R15),FLOWPTRM_SPEC     Test for special char\n            DOEXIT Z                       End loop if special char\n            IF CLI,0(R15),EQ,C'='          If possible literal\n              AHI   R15,1                    Point past '='\n              DO WHILE=(CR,R15,LT,R3)        Do for numerics\n                DOEXIT CLI,0(R15),LT,C'0'      Exit if not numeric\n                AHI   R15,1                    Advance pointer\n              ENDDO ,                        EndDo for numerics\n              IF CLI,0(R15),EQ,C'C',OR,      If char string <OR>       +\n               CLI,0(R15),EQ,C'G',OR,        .. DBCS string <OR>       +\n               CLI,0(R15),EQ,C'X'            .. hex string\n                LR    R5,R3                    Save quote address\n                ASMLEAVE ,                     Exit the loop\n              ENDIF ,                        EndIf char/DBCS/hex\n              LA    R15,1(,R3)               Point past quote\n              LR    R0,R4                    Get length remaining\n              AHI   R0,-1                    (same)\n              IF P                           If more data\n                DO FROM=(R0)                   Do for chars\n                  DOEXIT CLI,0(R15),EQ,C''''     Exit if quote\n                  AHI   R15,1                    Advance pointer\n                ENDDO ,                        EndDo for chars\n                IF LTR,R0,R0,NZ                If matching quote\n                  LR    R5,R3                    Save quote address\n                  ASMLEAVE ,                     Exit the loop\n                ENDIF ,                        EndIf matching quote\n              ENDIF ,                        EndIf more data\n              ASMLEAVE ,                     Exit the loop\n            ENDIF ,                        EndIf possible literal\n            BCTR  R15,0                    Decrement pointer\n          ENDDO ,                        EndDo while still in buffer\n          LR    R15,R3                   Point to char before quote\n          BCTR  R15,0                    (same)\n          TRT   0(1,R15),FLOWPTRM_ATTR   Test if attribute\n          IF NZ                          If not attribute\n            LR    R5,R3                    Save address of quote\n          ENDIF ,                        EndIf\n        ENDIF ,                        EndIf already in quotes\n      ENDIF ,                        EndIf quote located\n      LA    R3,1(,R3)                Advance pointer\n    ENDDO ,                        EndDo for all chars\n    LR    R1,R3                    Compute length of term\n    SR    R1,R6                    (same)\n    BR    R14                      Return\n\nFLOWPTRM_SPEC DC  63X'00',193X'FF'   Special character table\n              ORG FLOWPTRM_SPEC+C'(' Left paren\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C')' Right paren\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C',' Comma\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C'/' Slash\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C'*' Asterisk\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C'+' Plus\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C'-' Minus\n              DC  X'00'              (same)\n              ORG FLOWPTRM_SPEC+C' ' Blank\n              DC  X'00'              (same)\n              ORG ,\n\nFLOWPTRM_ATTR DC  256X'FF'           Attribute reference table\n              ORG FLOWPTRM_ATTR+C'd' Defined\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'D' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'i' Integer\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'I' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'k' Count\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'K' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'l' Length\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'L' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'n' Number\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'N' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'o' Operation code\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'O' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C's' Scaling\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'S' (same)\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C't' Type\n              DC  X'00'              (same)\n              ORG FLOWPTRM_ATTR+C'T' (same)\n              DC  X'00'              (same)\n              ORG ,\n\n***************************************************************\n* Parse White Space                                           *\n***************************************************************\nFLOWPSPC DC 0H\n    DO FROM=(R4)                   Do for remaining chars\n      DOEXIT CLI,0(R3),GT,C' '       Exit if non-blank found\n      AHI   R3,1                     Advance pointer\n    ENDDO ,                        EndDo\n    BR    R14                      Return\n\n***************************************************************\n* Equates                                                     *\n***************************************************************\nFLOWVSTL EQU   71                  Statement length\n\n***************************************************************\n* Constants                                                   *\n***************************************************************\nFLOWDCBM DCB   DSORG=PS,           Sequential data set                 +\n               MACRF=GL,           Get locate mode                     +\n               DDNAME=SYSIN,       DD name = SYSIN                     +\n               DCBE=FLOWDCBE       DCBE address\nFLOWDCBML EQU  *-FLOWDCBM          Length of DCB model\nFLOWDCBE DCBE  EODAD=FLOWEOD,      End of data address                 +\n               RMODE31=BUFF        Use 31-bit buffers\nFLOWDCBEL EQU  *-FLOWDCBE          Length of DCBE model\nFLOWRDFM RDJFCB FLOWDCBM,MF=L      RDJFCB model\nFLOWRDFML EQU  *-FLOWRDFM          Length of RDJFCB model\nFLOWOPNM OPEN  FLOWDCBM,           OPEN model                          +\n               MODE=31,MF=L        (same)\nFLOWOPNML EQU  *-FLOWOPNM          Length of RDJFCB model\n\nFLOWERR1 DC    C'First column of continued statement is non-blank'\nFLOWERR2 DC    C'Not enough room for continued operand data'\nFLOWERR3 DC    C'Not enough room for all of continued comment'\n\nFLOWERRM DC   0CL8                 Macros with syntax errors\n         DC    CL8'IAZSMF84'       (same)\n         DC    CL8'IEAMSTS'        (same)\n         DC    CL8'IEFSSSA'        (same)\n         DC    CL8'IEZVG111'       (same)\n         DC    CL8'IFGACBVS'       (same)\n         DC    CL8'IFGEXLVS'       (same)\n         DC    CL8'IHASPTRC'       (same)\n         DC    CL8'IHATMTRC'       (same)\n         DC    CL8'IRDDFSD'        (same)\n         DC    CL8'TRKCALC'        (same)\n         DC    CL8'#DIE'           (same)\nFLOWERRM# EQU  (*-FLOWERRM)/8      Number of table entries\n\n***************************************************************\n* Working Storage                                             *\n***************************************************************\nFLOWDWS  DSECT ,                   Dynamic Working Storage\n\n         DS    18F                 Standard save area\nFLOWSAV1 DS    16F                 Register save area\nFLOWSAV2 DS    16F                 Register save area\nFLOWSAV3 DS    16F                 Register save area\n\nFLOWRECL DS    F    <-------Keep-\\ Final record length\nFLOWRECP DS    F  <-----Together-/ Final record pointer\n\nFLOWOPRA DS    A                   Operand Address\nFLOWOPRZ DS    F                   Operand Size\n\nFLOWCMTA DS    A                   Comment Address\nFLOWCMTZ DS    F                   Comment Size\n\nFLOWMACW DS    XL256               Macro work area\n\nFLOWDCB  DS    0D,XL(FLOWDCBML)    DCB area\nFLOWDCBX DS    0D,XL(FLOWDCBEL)    DCB extension\nFLOWDCBL DS    4F                  DCB exit list\nFLOWJFCB DS    XL(JFCBLGTH)        JFCB area\n\nFLOWOFFS DS    H                   Variable source record offset\n\nFLOWPFL1 DS    XL1                 Permanent flags\nFLOWP1ST EQU    X'80'              - First record processed\nFLOWPCON EQU    X'40'              - Statement automatically continued\nFLOWPMAN EQU    X'20'              - Statement manually continued\nFLOWPWRP EQU    X'10'              - Statement should be wrapped\nFLOWIGNR EQU    X'01'              - Member should be ignored\nFLOWTFL1 DS    XL1                 Temporary flags\nFLOWTVAR EQU    X'80'              - Variable length records\nFLOWTEOD EQU    X'40'              - End of data reached on input\nFLOWTCLS EQU    X'01'              - Close processing requested\nFLOWOPTS DS    XL1                 Options\nFLOWOVAR EQU    X'80'              - FLOWOPT RECFM=V\nFLOWCCHR DS    CL1                 Continuation character\n\nFLOWSTMW DS    CL256               Statement work area\n         DS    CL256               Padding area for overflows\n\n         DS    0D                  Align to doubleword boundary\nFLOWDWSL EQU   *-FLOWDWS           Length of Dynamic Working Storage\n\n   END ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAMPLE": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x04\\x17\\x0f\\x01\\x05(\\x1f\\x147\\x00:\\x00<\\x00\\x00\\xc5\\xc5\\xd1@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-06-18T00:00:00", "modifydate": "2005-10-08T14:37:23", "lines": 58, "newlines": 60, "modlines": 0, "user": "EEJ"}, "text": "//SAMPLE   JOB 1,JAFFE,CLASS=A,MSGCLASS=T,NOTIFY=&SYSUID\n//ASM     EXEC ASMAC,\n//             PARM.C='EXIT(INX(FLOWASM),LBX(FLOWASM))'\n//C.STEPLIB DD DSN=SYS2.LINKLIB,DISP=SHR\n//C.SYSLIB  DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//          DD DSN=HLA.SASMMAC1,DISP=SHR\n//          DD DSN=HLA.SASMMAC2,DISP=SHR\n//          DD DSN=EDJXADM.FLOWASM.PDS,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\nSAMPLE CSECT ,\nSAMPLE AMODE 31\nSAMPLE RMODE 31\n     COPY  ASMMSP                  Structured assembler support\n     SYSSTATE ARCHLVL=1            Program supports immediate/relative\n     ASMMREL ON                    Enable relative branch for SPMs\n\n     STM   R14,R12,12(R13)         Save the registers\n\n     CNOP  0,4                     Align to fullword\n     JAS   R12,*+8                 Point to constants\n     DC    A(SAMPLE_Const-*)       (same)\n     AL    R12,0(,R12)             (same)\n     USING SAMPLE_Const,R12    *** Synchronize base register\n     USING STKSECT,StackCntl   *** Synchronize STKSECT\n\n     STKSAVE INIT,                 Initialize save area stack\n           ARMODE=YES,             - Support AR mode\n           PREFIX=Sample           - Program prefix\n\n     JAS   R14,Routine1            Invoke Routine1\n\n     LM    R14,R12,12(R13)         Restore the registers\n     BR    R14                     Return\n\nRoutine1 DC 0H\n     STKSAVE PUSH                  Save the registers\n\n     XR    R15,R15                 Set return code = 0\n\n     STKSAVE POP,                  Restore the registers\n           RETREGS=(R15)           - Pass back return code\n     BR    R14                     Return\n\nSAMPLE_Const DC 0D                 Constants for SAMPLE\nStackCntl    DC (STKLNTH)X'00'     Stack control area\n             STKSAVE DEFINE,       Define save area stack\n                   COUNT=20,       - Number of stack frames\n                   ARMODE=YES,     - Support AR mode\n                   PREFIX=Sample   - Program prefix\n\n             LTORG ,               Literals\n\n             ASMDREG ,             Register equates\n\n     END   SAMPLE                  End the program\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STKSAVE": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00R\\x01\\x04\\x17\\x0f\\x01\\x05(\\x1f\\x14$\\x01T\\x01\\x14\\x00\\x00\\xc5\\xc5\\xd1@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-06-18T00:00:00", "modifydate": "2005-10-08T14:24:52", "lines": 340, "newlines": 276, "modlines": 0, "user": "EEJ"}, "text": "         MACRO ,\n&LABEL   STKSAVE &TYPE,            Requested function                  +\n               &ARMODE=,           AR mode indicator                   +\n               &RETREGS=,          Registers to be returned            +\n               &REGS=(R14:R13),    Registers to be saved/restored      +\n               &LST=,              Load or STore operation             +\n               &COUNT=10,          Number of stack frames              +\n               &PREFIX=            Program prefix\n.*START OF SPECIFICATIONS**************************************\n.*                                                            *\n.* MACRO NAME = STKSAVE                                       *\n.*                                                            *\n.* DESCRIPTIVE NAME = Local Save Area Stack Services          *\n.*                                                            *\n.* FUNCTION =                                                 *\n.*                                                            *\n.*    This macro provides low-overhead local save area stack  *\n.*    services. A local save area stack is not intended to be *\n.*    used for inter-program linkage. Other functions exist   *\n.*    to address that need.                                   *\n.*                                                            *\n.* AUTHOR =                                                   *\n.*                                                            *\n.*    Edward E. Jaffe                                         *\n.*    Phoenix Software International                          *\n.*    5200 W. Century Blvd., Suite 800                        *\n.*    Los Angeles, CA 90045 U.S.A.                            *\n.*                                                            *\n.*                                                            *\n.* OPERATION =                                                *\n.*                                                            *\n.*    STKSAVE DEFINE                                          *\n.*          {,COUNT=count}                                    *\n.*          {,ARMODE=YES|NO}                                  *\n.*          {,PREFIX=prefix}                                  *\n.*                                                            *\n.*      Defines storage for the stack. Specify the number     *\n.*      of stack frames using the COUNT= keyword. ARMODE=YES  *\n.*      generates stack frames large enough to save both the  *\n.*      access and general purpose registers. Use of the      *\n.*      optional PREFIX= allows multiple uniquely-named stack *\n.*      areas to exist within a single assembly.              *\n.*                                                            *\n.*    STKSAVE INIT                                            *\n.*          {,ARMODE=YES|NO}                                  *\n.*          {,PREFIX=prefix}                                  *\n.*                                                            *\n.*      Generates code to initialize the stack control area.  *\n.*      Use of the optional PREFIX= allows multiple uniquely- *\n.*      named stacks to exist within a single assembly.       *\n.*                                                            *\n.*    STKSAVE PUSH                                            *\n.*          {,REGS=(low{:high}{,low{:high}}{, ...})           *\n.*                                                            *\n.*      Saves the registers. The optional REGS= keyword       *\n.*      allows you to specify which registers are saved.      *\n.*      You can specify single registers or ranges. For       *\n.*      example: REGS=(R14:R2,R13) specifies R14 through      *\n.*      R2 (wrapping after R15) and R13. The default is       *\n.*      REGS=(R14:R13).                                       *\n.*                                                            *\n.*    STKSAVE POP                                             *\n.*          {,REGS=(low{:high}{,low{:high}}{, ...})           *\n.*          {,RETREGS=(reg1,reg2,...,regn)}                   *\n.*                                                            *\n.*      Restores the registers. The optional REGS= keyword    *\n.*      allows you to specify which registers are restored.   *\n.*      You can specify single registers or ranges. For       *\n.*      example: REGS=(R14:R2,R13) specifies R14 through      *\n.*      R2 (wrapping after R15) and R13. The default is       *\n.*      REGS=(R14:R13).                                       *\n.*                                                            *\n.*      Registers that must be passed back in-tact to the     *\n.*      caller are listed in the RETREGS= register list.      *\n.*      R14 is not eligible for this treatment.               *\n.*                                                            *\n.*    ------------------------------------------------------- *\n.*                                                            *\n.*    Notes: ARMODE=YES|NO sets a macro global variable.      *\n.*           Only the first of DEFINE or INIT need specify    *\n.*           this value. One of these must precede the first  *\n.*           use of PUSH and/or POP in the assembly.          *\n.*                                                            *\n.*    ------------------------------------------------------- *\n.*                                                            *\n.*    To define the stack control area, place the following   *\n.*    at the top of your program after addressability to your *\n.*    working storage has been established:                   *\n.*                                                            *\n.*             USING STKSECT,label                            *\n.*                                                            *\n.*    and place the following in your working storage area:   *\n.*                                                            *\n.*    label    DC    (STKLNTH/8)D'0'                          *\n.*                                                            *\n.*END OF SPECIFICATIONS****************************************\n         GBLB  &STKAR\n         GBLB  &STKSECT\n         LCLB  &REG(16)\n         AIF   ('&TYPE' EQ 'ARMODE').ARMODE  Handle ARMODE keyword\n         AIF   ('&TYPE' EQ 'DEFINE').DEFINE  Define save area stack\n         AIF   ('&TYPE' EQ 'INIT').INIT      Init save area stack\n         AIF   ('&TYPE' EQ 'PUSH').PUSH      Save the registers\n         AIF   ('&TYPE' EQ 'POP').POP        Restore the registers\n         AIF   ('&TYPE' EQ 'REGS').REGS      Manipulate the registers\n         MNOTE 8,'*** &TYPE is invalid ***'\n         MEXIT ,\n.*\n.ARMODE  ANOP  ,\n         AIF   ('&ARMODE' EQ '').ARMODE1\n&STKAR   SETB  0\n         AIF   ('&ARMODE' EQ 'NO').ARMODE1\n&STKAR   SETB  1\n         AIF   ('&ARMODE' EQ 'YES').ARMODE1\n         MNOTE 8,'*** ARMODE=''&ARMODE'' is invalid ***'\n.ARMODE1 ANOP  ,\n         MEXIT ,\n.*\n.DEFINE  ANOP  ,\n         AIF   (&STKSECT).DEFINE1\n&STKSECT SETB  1\n****************************************************************\n*                 Save Area Stack Control Area                 *\n****************************************************************\nSTKSECT  DSECT ,                   Save Area Stack Control\nSTKCUR   DS    A                   Pointer to current element\nSTKBGN   DS    A                   Pointer to start of stack\nSTKEND   DS    A                   Pointer past end of stack\nSTKWORK  DS    F                   Work register save area\n         DS    0D                  Ensure doubleword alignment\nSTKLNTH  EQU   *-STKSECT           Length of Stack Control data\nSTKESIZ  EQU   4*16                Length of save area element\nSTKAESZ  EQU   4*32                Length of save area element (ARMODE)\n\n&SYSECT  &SYSSTYP ,                Restore section\n\n.DEFINE1 ANOP  ,\n         PUSH  PRINT,NOPRINT\n         PRINT NOMCALL,NOPRINT\n         STKSAVE ARMODE,ARMODE=&ARMODE\n         POP   PRINT,NOPRINT\n&P       SETC  '&PREFIX'\n         AIF   (&STKAR).DEFINE2\n&P.STAKZ EQU   &COUNT*STKESIZ      Size of save area stack\n         AGO   .DEFINE3\n.DEFINE2 ANOP  ,\n&P.STAKZ EQU   &COUNT*STKAESZ      Size of save area stack\n.DEFINE3 ANOP  ,\n&P.STAK  DC    (&P.STAKZ/8)D'0'    Save area stack\n&P.STAKE EQU   *                   (same)\n         MEXIT ,\n.*\n.INIT    ANOP ,\n         PUSH  PRINT,NOPRINT\n         PRINT NOMCALL,NOPRINT\n         STKSAVE ARMODE,ARMODE=&ARMODE\n         POP   PRINT,NOPRINT\n&P       SETC  '&PREFIX'\n     LA    R15,&P.STAK             Point to stack start\n     ST    R15,STKBGN              Save stack begin address\n     LR    R14,R15                 Save starting address\n     AHI   R15,&P.STAKZ            Point past end of stack\n     ST    R15,STKEND              Save stack end address\n         AIF   (&STKAR).INIT1\n     AHI   R14,-STKESIZ            Prime stack pointer\n     ST    R14,STKCUR              (same)\n         MEXIT ,\n.INIT1   ANOP  ,\n     AHI   R14,-STKAESZ            Prime stack pointer\n     ST    R14,STKCUR              (same)\n         MEXIT ,\n.*\n.PUSH    ANOP ,\n     ST    R14,STKWORK             Save work register\n     L     R14,STKCUR              Get current pointer\n         AIF   (&STKAR).PUSH1\n     AHI   R14,STKESIZ             Advance pointer\n         AGO   .PUSH2\n.PUSH1   ANOP ,\n     LAE   R14,STKAESZ(R14,0)      Advance pointer\n.PUSH2   ANOP ,\n     C     R14,STKEND              Overflow ?\n     BNL   1(0,0)                  Abend if yes\n     ST    R14,STKCUR              Save new pointer\n     MVC   0(4,R14),STKWORK        Save register 14\n     PUSH  PRINT,NOPRINT\n     PRINT NOMCALL,NOPRINT\n     STKSAVE REGS,                 Save the registers\n           LST=ST,                 (same)\n           REGS=&REGS              (same)\n     POP   PRINT,NOPRINT\n     L     R14,STKWORK             Restore work register\n         MEXIT ,\n.*\n.POP     ANOP ,\n     L     R14,STKCUR              Get current pointer\n         AIF   (&STKAR).POP1\n     AHI   R14,-STKESIZ            Decrement pointer\n         AGO   .POP2\n.POP1    ANOP ,\n     AHI   R14,-STKAESZ            Decrement pointer\n     LAE   R14,0(R14,0)            Zero AR14\n.POP2    ANOP ,\n     C     R14,STKBGN              Underflow ?\n     BL    1(0,0)                  Abend if yes\n     ST    R14,STKCUR              Save new pointer\n     PUSH  PRINT,NOPRINT\n     PRINT NOMCALL,NOPRINT\n     STKSAVE REGS,                 Load select registers\n           LST=L,                  (same)\n           REGS=&REGS,             (same)\n           RETREGS=&RETREGS        (same)\n     POP   PRINT,NOPRINT\n         MEXIT ,\n.*\n.REGS       ANOP  ,\n.* Populate Register Bit Mask\n&REG(1)     SETB  0\n&REG(2)     SETB  0\n&REG(3)     SETB  0\n&REG(4)     SETB  0\n&REG(5)     SETB  0\n&REG(6)     SETB  0\n&REG(7)     SETB  0\n&REG(8)     SETB  0\n&REG(9)     SETB  0\n&REG(10)    SETB  0\n&REG(11)    SETB  0\n&REG(12)    SETB  0\n&REG(13)    SETB  0\n&REG(14)    SETB  0\n&REG(15)    SETB  1\n&REG(16)    SETB  1\n&I1         SETA  1\n.REG1       ANOP  ,\n&C1         SETC  '&REGS(&I1)'\n&C2         SETC  '&C1'\n&I2         SETA  INDEX('&C1',':')\n            AIF   (&I2 EQ 0).REG2\n&C2         SETC  '&C1'(&I2+1,*)\n&C1         SETC  '&C1'(1,&I2-1)\n.REG2       ANOP  ,\n&C1         SETC  '&C1'(2,*)\n&C2         SETC  '&C2'(2,*)\n&I2         SETA  &C1\n&I3         SETA  &C2\n.REG3       ANOP  ,\n&REG(&I2+1) SETB  1\n            AIF   (&I2 EQ &I3).REG4\n&I2         SETA  &I2+1\n            AIF   (&I2 LE 15).REG3\n&I2         SETA  0\n            AGO   .REG3\n.REG4       ANOP  ,\n&I1         SETA  &I1+1\n            AIF   (&I1 LE N'&REGS).REG1\n.* Remove any RETREGS from list\n&I1         SETA  1\n.REG5       ANOP  ,\n            AIF   (&I1 GT N'&RETREGS).REG6\n&C1         SETC  '&RETREGS(&I1)'\n&C1         SETC  '&C1'(2,*)\n&I2         SETA  &C1\n&REG(&I2+1) SETB  0\n&I1         SETA  &I1+1\n            AGO   .REG5\n.REG6       ANOP  ,\n.* LOAD/STORE Registers\n&P          SETC  '&LST'\n&I5         SETA  &STKAR\n&I5         SETA  &I5*64+64\n            AIF   ('&P' EQ 'L').REG7\n&REG(15)    SETB  0\n&I5         SETA  0\n.REG7       ANOP  ,\n&I1         SETA  14\n.REG8       ANOP  ,\n            AIF   (&REG(&I1)).REG9\n&I1         SETA  &I1-1\n            AIF   (&I1 GT 0).REG8\n            AGO   .REG16\n.REG9       ANOP  ,\n&I3         SETA  &I1-1\n.REG10      ANOP  ,\n&I1         SETA  &I1-1\n            AIF   (&I1 EQ 0).REG11\n            AIF   (&REG(&I1)).REG10\n.REG11      ANOP  ,\n&I2         SETA  &I1\n&I4         SETA  8+(4*&I2)+&I5\n            AIF   (&I2 GT 0).REG12\n            AIF   (NOT &REG(16)).REG12\n&I2         SETA  15\n&I4         SETA  4+&I5\n&REG(16)    SETB  0\n            AIF   (NOT &REG(15)).REG12\n&I2         SETA  14\n&I4         SETA  0+&I5\n&REG(15)    SETB  0\n.REG12      ANOP  ,\n            AIF   (NOT &STKAR).REG13\n            AIF   (&I2 EQ 14).REG$$\n     &P.AM &I2,&I3,64+&I4.(R14)    ARs\n            AGO   .REG13\n.REG$$      ANOP  ,\n            AIF   (&I3 EQ 14).REG13\n     &P.AM R15,&I3,64+4+&I4.(R14)  ARs\n.REG13      ANOP  ,\n            AIF   (&I2 NE &I3).REG14\n     &P    &I2,&I4.(,R14)          A single GPR\n            AGO   .REG15\n.REG14      ANOP  ,\n     &P.M  &I2,&I3,&I4.(R14)       Multiple GPRs\n.REG15      ANOP  ,\n            AIF   (&I1 GT 0).REG8\n.REG16      ANOP  ,\n            AIF   (NOT &REG(15) AND NOT &REG(16)).REG99\n&I2         SETA  14\n&I3         SETA  14\n&I4         SETA  0+&I5\n            AIF   (&REG(15) AND NOT &REG(16)).REG17\n&I2         SETA  15\n&I3         SETA  15\n&I4         SETA  4+&I5\n            AIF   (NOT &REG(15) AND &REG(16)).REG17\n&I2         SETA  14\n&I3         SETA  15\n&I4         SETA  0+&I5\n.REG17      ANOP  ,\n            AIF   (NOT &STKAR OR NOT &REG(16)).REG18\n     &P.AM R15,R15,64+&I4.(R14)    AR15\n.REG18      ANOP  ,\n            AIF   (&I2 NE &I3).REG19\n     &P    &I2,&I4.(,R14)          A single GPR\n            AGO   .REG99\n.REG19      ANOP  ,\n     &P.M  &I2,&I3,&I4.(R14)       Multiple GPRs\n.REG99      ANOP  ,\n            MEXIT ,\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT724/FILE724.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT724", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}