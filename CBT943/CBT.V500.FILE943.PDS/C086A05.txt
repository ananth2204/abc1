Remote screen and COMMAREA viewing

In the December 1987 issue of CICS Update, Ernie Ishman
published a series of programs to provide a remote screen
viewing facility. I have found this function to be very useful,
but I also needed to see the COMMAREA that was associated
with that task/screen. Along with adding the ability to view the
COMMAREA, I have implemented the following:

o      Reduced the number of programs and transactions from
      three to two by using a DELAY.

o      Allowed repetitive use without the need to re-key the command.

o      Allowed the facility to be used in a TOR/AOR environment.

o      Replaced a DFHTC macro with an INQUIRE command.

To use the facility, all you need to do is enter a transaction-id
followed by the terminal-id of the screen you would like to
view (eg SCV1 xxxx). The screen image will be displayed on
your terminal. By pressing ENTER, you can view the
COMMAREA associated with the task (it is presented in
hexadecimal and display format). While viewing the
COMMAREA, PF8 can be used to scroll down and PF7 to
scroll up. PF12 will do a refresh (ie retrieve the screen and
COMMAREA again). Hitting CLEAR will exit you from the
application.

To install, you need to define two Assembler programs
(SCV001 and SCV001) in the PPT along with the associated
entries for the transaction-ids SCV1 and SCV2 in the PCT. The
programs currently run under CICS 2.1.1 in an MVS
environment.


SCV001 SOURCE CODE

SCV001   TITLE ' REMOTE SCREEN/COMMAREA VIEWING PROGRAM'
***PROGRAMS SCV001 AND SCV002 ARE USED TO REMOTELY VIEW A TERMINAL'S **
*  SCREEN AND COMMAREA. ENTER SCV1 XXXX (XXXX IS THE TERMID TO VIEW). *
*  THIS WILL START SCV2 ON THE TERMINAL TO PASS THE INFORMATION BACK  *
*  TO THIS PROGRAM IN A TEMP STORAGE QUEUE. THIS PROGRAM WILL THEN    *
*  DISPLAY THE REQUESTED SCREEN. HITTING ENTER WILL SWAP BETWEEN THE  *
*  SCREEN AND COMMAREA. PF7/8 IS FOR SCROLLING UP AND DOWN IN THE     *
***COMMAREA. USE CLEAR TO EXIT.                                      **
SCV001  DFHEIENT CODEREG=(R3),DATAREG=(R5),EIBREG=(R11)
         B     PASTDT                  * BRANCH AROUND DATE/TIME
         DC    CL8'SCV001  '
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
PASTDT   DS    0H
         CLC   EIBCALEN,HWD0           * ANY COMMAREA
         BH    USECOMM                 * YES, CONTINUATION PROCESSING
*                                      * ELSE INITIAL REQUEST
RECVSCRN DS    0H
         MVC   WSHALF,HWD80            * SET MAX LENGTH OF RECEIVE
         EXEC CICS RECEIVE SET(R10) LENGTH(WSHALF) NOHANDLE
         CLI   0(R10),X'11'            * SBA PRESENT?
         BNE   NOSBA                   * NO
         LA    R10,3(R10)              * BUMP PAST SBA
NOSBA    DS    0H
         MVC   INBUFF,0(R10)           * MOVE DATA TO INPUT BUFFER
         EXEC CICS HANDLE CONDITION TERMIDERR(NOTCT)
         EXEC CICS INQUIRE TERMINAL(INTERMID) REMOTESYSTEM(TERMREM)    X
                   ACQSTATUS(TERMACQ) SERVSTATUS(TERMSERV)             X
                   DEVICE(TERMTYPE)
         XC    TERMFLAG,TERMFLAG       * CLEAR TERMFLAG
         CLC   TERMTYPE,DFHVALUE(T3277L)  * LOCAL 3277
         BE    VERSESS                 * YES
         CLC   TERMTYPE,DFHVALUE(T3277R)  REMOTE 3277
         BE    VERSESS                 * YES
         OI    TERMFLAG,FLAG2          * NO, INDICATE SO
         B     TERMCHEK                * NO NEED TO GO FURTHER
NOTCT    DS    0H
         MVC   MSGDATA(L'NOTCTMSG),NOTCTMSG  * MOVE 'NO TCT' MESSAGE
         B     ERRSEND
VERSESS  DS    0H
         CLC   TERMREM,SPACES          * TOR TERMINAL
         BNE   CHKSERV                 * YES, SKIP CHECK FOR ACQUIRED
         CLC   TERMACQ,DFHVALUE(ACQUIRED)  * TERMINAL ACQUIRED ?
         BE    CHKSERV                 * YES
         OI    TERMFLAG,FLAG1          * NO, INDICATE SO
         B     TERMCHEK                * NO NEED TO GO FURTHER
CHKSERV  DS    0H
         CLC   TERMSERV,DFHVALUE(INSERVICE)  * TERMINAL IN SERVICE ?
         BE    TERMCHEK                * YES
         OI    TERMFLAG,FLAG1          * NO, INDICATE SO
TERMCHEK DS    0H
         TM    TERMFLAG,ERRORS         * TERMINAL PROBLEM ?
         BNZ   TERMBAD                 * YES - EXIT
*   START TASK AT TERMINAL WHOSE SCREEN WE ARE RETRIEVING
         MVC   WSHALF,HWD8             * SENDING 8 BYTES
         MVC   WSREQ,EIBTRNID          * HEADER TO WSREQID
         MVC   WSTERM,EIBTRMID         * TERMINAL ID TO WSREQID
*   CLEAR THE QUEUE IN CASE IT EXISTS
         EXEC CICS DELETEQ TS QUEUE(WSREQID) NOHANDLE
         EXEC CICS START TRANSID(RETRVTSK) TERMID(INTERMID)            X
                   FROM(WSREQID) LENGTH(WSHALF)
* WE DELAY HERE FOR 30 SECONDS, AND GIVE STARTED TASK A CHANCE TO
* WRITE THE SCREEN/COMMAREA TO TEMP-STORAGE. WHEN IT IS DONE,
* IT CANCELS THE DELAY IN THIS PROGRAM BEFORE RETURNING TO CICS. WE
* START  BACK UP, READ  THE TS QUEUE, AND DISPLAY THE SCREEN OF
* THE REMOTE TERMINAL.
         EXEC CICS DELAY INTERVAL(30) REQID(WSREQID)
         EXEC CICS HANDLE CONDITION QIDERR(NOTASK) ITEMERR(NOTASK)
         MVC   QITEM,=H'1'             * SET ITEM TO READ
*    READ THE TS QUEUE. LENGTH WILL BE RETURNED BECAUSE OF SET OPTION.
         EXEC CICS READQ TS QUEUE(WSREQID) LENGTH(WSHALF) SET(R8)      X
                   ITEM(QITEM)
         EXEC CICS GETMAIN LENGTH(WSHALF) SET(R4) INITIMG(HWD0)
         LR    R6,R4                   * LOAD COMMAREA ADDR INTO R6
         MVC   EIBCALEN,WSHALF         * SET COMMAREA LENGTH
         LH    R7,WSHALF               * PUT LENGTH INTO R7
         LH    R9,WSHALF               * PUT LENGTH INTO R9
         MVCL  R6,R8                   * MOVE QUEUE DATA TO GETMAIN
         USING SCRNCOMM,R4             * SET UP ADDRESSABILITY
*  CLEAR THE TEMP STORAGE QUEUE
         EXEC CICS DELETEQ TS QUEUE(WSREQID)
*  NOW SHOW THE SCREEN
         MVC   SCRNSBA,SBA             * SET SBA
         LH    R8,SCRNLEN              * GET SCREEN LENGTH
         AH    R8,=H'3'                * ADD 3 FOR SBA
         STH   R8,SCRNLEN              * AND STORE IT
         MVC   SAVBUFF,INBUFF          * SAVE USER INPUT FOR REFRESH
DISPSCRN DS    0H
         MVI   SCRNUPSW,C'S'           * INDICATE SCREEN IS UP
         EXEC CICS SEND FROM(SCRNSBA) CTLCHAR(HEX42) ERASE             X
                   LENGTH(SCRNLEN)
RETCOMM  DS    0H
         EXEC CICS RETURN COMMAREA(SCRNCOMM) LENGTH(EIBCALEN)          X
                   TRANSID(EIBTRNID)
*        ERROR PROCESSING
NOTASK DS      0H
         MVC   MSGDATA(L'NOTASKQ),NOTASKQ  * MOVE MESSAGE
         B     ERRSEND                     * GO SEND MESSAGE
TERMBAD  DS    0H
         TM    TERMFLAG,FLAG1          * FLAG1 ON
         BZ    TERMBAD2                * NO, MUST BE FLAG2
TERMBAD1 DS    0H
         MVC   MSGDATA(L'NOTONMSG),NOTONMSG  * MOVE MESSAGE
         B     ERRSEND                       * GO SEND IT
TERMBAD2 DS    0H
         MVC   MSGDATA(L'BADTPMSG),BADTPMSG  * MOVE MESSAGE
ERRSEND  DS    0H
         MVC   MSGTERM(04),INTERMID    * MOVE TERMINAL
         MVC   MSGSBA,HILITE           * SET UP HIGH INTENSITY
         MVC   MSGATTR,ATTRMSG         * MOVE IN RESET ATTRIBUTE
         MVC   WSHALF,=AL2(TIOALEN)    * SET LENGTH
         EXEC CICS SEND FROM(IOAREA) ERASE LENGTH(WSHALF)
RETURN   DS    0H
         EXEC CICS RETURN
***TRANSACTION HAS ALREADY RETRIEVED THE SCREEN AND COMMAREA, NOW
*  PROCESS USER REQUESTS:
*      CLEAR = END
*      ENTER = SWAP SCREEN/COMMAREA
*      PF7   = SCROLL UP IN COMMAREA   (IF COMMAREA IS ON THE SCREEN)
***    PF8   = SCROLL DOWN IN COMMAREA (IF COMMAREA IS ON THE SCREEN)
USECOMM  DS    0H
         CLI   EIBAID,CLEARKEY         * CLEAR KEY
         BE    RETURN                  * YES, EXIT TRANSACTION
         L     R4,DFHEICAP             * ADDRESS COMMAREA
         USING SCRNCOMM,R4             * SET UP ADDRESSABILITY
         CLI   EIBAID,PF12KEY          * PF12 ENTERED
         BE    REFRESH                 * YES, REFRESH SCREEN
         CLI   EIBAID,ENTERKEY         * ENTER KEY PRESSED
         BE    SWAPSCRN                * YES, GO SWAP SCREENS
         CLI   SCRNUPSW,C'S'           * IS SCREEN UP
         BE    NOACTION                * YES, DO NOTHING
         CLC   COMMLEN,HWD0            * ANY COMMAREA
         BE    NOACTION                * NO
         CLI   EIBAID,PF7KEY           * PF7 ENTERED
         BE    COMMUP                  * YES, SCROLL UP
         CLI   EIBAID,PF8KEY           * PF8 ENTERED
         BE    COMMDOWN                * YES, SCROLL DOWN
NOACTION DS    0H
         EXEC CICS SEND CONTROL FREEKB
         B     RETCOMM                 * EXIT PROGRAM W/COMM
REFRESH  DS    0H
         LA    R10,SAVBUFF             * POINT TO USER INPUT
         B     NOSBA                   * GO START OVER
*  SWAP SCREEN/COMMAREA
SWAPSCRN DS    0H
         CLI   SCRNUPSW,C'C'           * IS COMMAREA UP
         BE    DISPSCRN                * YES, PUT UP SCREEN
*                                      * ELSE, PUT UP COMMAREA
         MVI   SCRNUPSW,C'C'           * SET TO COMMAREA
         XC    COMMDISP,COMMDISP       * CLEAR COMMAREA DISPLACEMENT
         CLC   COMMLEN,HWD0            * ANY COMMAREA
         BE    DISPNOCA                * NO
         LA    R12,COMMHOLD            * POINT TO COMMAREA
         B     DISPCOMM                * GO DISPLAY COMMAREA
*  DISPLAY MESSAGE THAT THERE IS NO COMMAREA
DISPNOCA DS    0H
         MVC   WSHALF,HWD80            * SET SEND LENGTH
         EXEC CICS SEND FROM(NOCAMSG) LENGTH(WSHALF) ERASE
         B     RETCOMM                 * EXIT PROGRAM W/COMM
*  SCROLL UP IN THE COMMAREA
COMMUP   DS    0H
         LH    R9,COMMDISP             * LOAD DISPLACEMENT TO R9
         CH    R9,HWD0                 * AT TOP OF COMMAREA
         BE    NOACTION                * YES, NO ACTION
         LA    R12,COMMHOLD            * POINT TO COMMAREA
         SH    R9,HWD256               * SUBTRACT 256 (SCREEN FULL)
         STH   R9,COMMDISP             * STORE DISPLACEMENT BACK
         AR    R12,R9                  * ADD DISP TO START
         B     DISPCOMM                * GO DISPLAY COMMAREA
*  SCROLL DOWN IN THE COMMAREA
COMMDOWN DS    0H
         LA    R12,COMMHOLD            * POINT TO COMMAREA
         LH    R9,COMMLEN              * LOAD COMMAREA LENGTH INTO R9
         AR    R12,R9                  * NOW R12 POINTS TO END OF COMM
         LA    R2,COMMHOLD             * POINT TO COMMAREA
         LH    R9,COMMDISP             * LOAD DISPLACEMENT INTO R9
         AH    R9,HWD256               * ADD 256 (SCREEN FULL) TO DISP
         AR    R2,R9                   * ADD DISP+SCREEN FULL TO START
         CR    R2,R12                  * PAST END OF COMMAREA
         BNL   NOACTION                * YES, NO ACTION
         LA    R12,COMMHOLD            * POINT TO COMMAREA
         AR    R12,R9                  * ADD DISP TO START
         STH   R9,COMMDISP             * STORE DISPLACEMENT BACK
         B     DISPCOMM                * GO DISPLAY COMMAREA
***DISPLAY CONTENTS OF THE COMMAREA.                               **
*      R6  POINTS TO THE OUTPUT SCREEN                              *
*      R9  IS CALCULATED TO HOLD NUMBER OF BYTES TO DISPLAY         *
***    R12 POINTS TO THE START OF COMMAREA DATA                    **
DISPCOMM DS    0H
         LA    R6,PGWKSCRN             * POINT R6 TO SCREEN
         L     R8,=V(SCRNAREA)         * POINT R8 TO PRIME DATA
         LA    R7,SCRNLENG             * LOAD SCREEN LENGTH
         LR    R9,R7                   * LENGTH ALSO IN R9
         MVCL  R6,R8                   * PRIME SCREEN AREA
         LH    R9,COMMLEN              * PUT COMMAREA LENGTH IN R9
         CVD   R9,WSPACK               * CONVERT TO PACKED
         UNPK  WSUNPK,WSPACK           * UNPACK IT
         OI    WSUNPK+5,X'F0'          * SECURE SIGN
         MVC   PGWKSCRN+100(6),WSUNPK  * MOVE LENGTH TO DISPLAY
***  CONVERT HEX DISPLACEMENT TO DISPLAY AND PUT ON SCREEN
         LH    R9,COMMDISP             * PUT COMMAREA DISP INTO R9
         STCM  R9,B'0111',HOLDDATA     * MOVE DISPLACEMENT TO HOLDDATA
         NC    HOLDDATA(3),ODDCHAR     * 'AND' ON ONLY ODD DIGITS
         TR    HOLDDATA(3),TRTABLE1    * TR EACH 4 BITS TO DISPLAY
         MVI   WORKDATA,X'00'          * SET FIRST BYTE TO X'00'
         MVC   WORKDATA+1(3),HOLDDATA  * MOVE 3 BYTES, LEAVE 1ST X'00'
         MVC   PRTLINE1(6),ODDMASK     * MOVE MASK TO TR IN ODD
         TR    PRTLINE1(6),WORKDATA    * DO THE TRANSLATE
         STCM  R9,B'0111',HOLDDATA     * MOVE DISPLACEMENT TO HOLDDATA
         NC    HOLDDATA(3),EVENCHAR    * 'AND' ON ONLY EVEN DIGITS
         TR    HOLDDATA(3),TRTABLE1    * TR EACH 4 BITS TO DISPLAY
         MVI   WORKDATA,X'00'          * SET FIRST BYTE TO X'00'
         MVC   WORKDATA+1(3),HOLDDATA  * MOVE 3 BYTES, LEAVE 1ST X'00'
         MVC   PRTLINE2(6),EVENMASK    * MOVE MASK TO TR IN EVEN
         TR    PRTLINE2(6),WORKDATA    * DO THE TRANSLATE
         OC    PRTLINE1(6),PRTLINE2    * OR THE ODD AND EVEN TOGETHER
         LA    R6,PGWKSCRN             * POINT R6 AT SCREEN AREA
         LA    R7,DATADISP             * DISPLACEMENT TO DATA
         AR    R6,R7                   * POINT TO DATA AREA OF SCREEN
         LA    R8,LINELNTH             * PUT LINE LENGTH INTO R8
         LA    R7,16                   * SET UP FOR BCT (16 LINES)
OFFSTLP  DS    0H
         MVC   6(2,R6),PRTLINE1+2      * MOVE OFFSET TO DISPLAY
         AR    R6,R8                   * BUMP TO NEXT SCREEN LINE
         BCT   R7,OFFSTLP              * LOOP THROUGH SCREEN
         LA    R9,COMMHOLD             * POINT TO COMMAREA START
         AH    R9,COMMLEN              * ADD LENGTH TO GET TO END
         SR    R9,R12                  * SUBTRACT TO GET DISPLAY LENGTH
         LA    R6,PGWKSCRN             * POINT R6 AT SCREEN AREA
         LA    R7,DATADISP             * DISPLACEMENT TO DATA
         AR    R6,R7                   * POINT TO DATA AREA OF SCREEN
         LA    R7,16                   * SET UP FOR BCT (16 LINES)
***  LOOP THROUGH THE COMMAREA AND DISPLAY ON THE SCREEN
***  (HEX AND DISPLAY) 256 BYTES AT A TIME.
SCRNLOOP DS    0H
         MVC   HOLDDATA,0(R12)         * MOVE LINE OF DATA TO HOLDDATA
         NC    HOLDDATA,ODDCHAR        * 'AND' ON ONLY ODD DIGITS
         TR    HOLDDATA,TRTABLE1       * TR EACH 4 BITS TO DISPLAY
         MVI   WORKDATA,X'00'          * SET FIRST BYTE TO X'00'
         MVC   WORKDATA+1(16),HOLDDATA * MOVE 16 BYTES, LEAVE 1ST X'00'
         MVC   PRTLINE1,ODDMASK        * MOVE IN MASK TO TR IN ODD
***                                    * CHARACTERS TO ODD POSITIONS
         TR    PRTLINE1,WORKDATA       * DO THE TRANSLATE
         MVC   HOLDDATA,0(R12)         * MOVE LINE OF DATA TO HOLDDATA
         NC    HOLDDATA,EVENCHAR       * 'AND' ON ONLY EVEN DIGITS
         TR    HOLDDATA,TRTABLE1       * TR EACH 4 BITS TO DISPLAY
         MVI   WORKDATA,X'00'          * SET FIRST BYTE TO X'00'
         MVC   WORKDATA+1(16),HOLDDATA * MOVE 16 BYTES, LEAVE 1ST X'00'
         MVC   PRTLINE2,EVENMASK       * MOVE MASK TO TR IN EVEN
***                                    * CHARACTERS TO EVEN POSITIONS
         TR    PRTLINE2,WORKDATA       * DO THE TRANSLATE
         OC    PRTLINE1,PRTLINE2       * OR THE ODD AND EVEN TOGETHER
         MVI   PRTSPACE,X'40'          * MOVE SPACE TO FIRST BYTE
         MVC   PRTLINE3,PRTLN3A        * REPLICATE THROUGH FIELD
         CH    R9,HWD16                * 16 BYTES LEFT TO DISPLAY?
         BH    MOVEALLH                * > 16, DISPLAY ENTIRE LINE
         LR    R2,R9                   * LOAD LENGTH INTO R2
         SLL   R2,1                    * MULT BY 2 (NUM OF HEX CHARS)
         B     MOVEHEXL                * GO MOVE LINE
MOVEALLH DS    0H
         LA    R2,32                   * SET UP FOR 32 BYTE MOVE
MOVEHEXL DS    0H
         BCTR  R2,0                    * DECREMENT BY 1 FOR EXECUTE
         EX    R2,PRTLMOVE             * MOVE LINE OF DATA TO PRINT
         MVC   12(35,R6),PRTMASK       * MOVE PRINT MASK TO SCREEN AREA
         TR    12(35,R6),PRTLN3A       * TRANSLATE DATA INTO SCREEN
         MVC   HOLDDATA,0(R12)         * MOVE LINE OF DATA TO HOLDDATA
         TR    HOLDDATA,TRTABLE2       * SELECT ONLY DISPLAY CHARACTERS
         CH    R9,HWD16                * 16 BYTES LEFT TO DISPLAY?
         BH    MOVE16                  * > 16, DISPLAY ENTIRE LINE
         LR    R2,R9                   * LOAD LENGTH INTO R2
         B     MOVELINE                * GO MOVE LINE
MOVE16   DS    0H
         LA    R2,16                   * SET UP FOR 16 BYTE MOVE
MOVELINE DS    0H
         BCTR  R2,0                    * DECREMENT BY 1 FOR EXECUTE
         EX    R2,SCRNMOVE             * MOVE LINE OF DATA TO SCREEN
* ALL DONE WITH CURRENT LINE, ON TO NEXT LINE
NEXTLINE DS    0H
         CH    R9,HWD16                * CHECK NUM OF BYTES LEFT
         BNH   BCTDONE                 * NO MORE LINES
         SH    R9,HWD16                * SUBTRACT LINE LENGTH
         AR    R6,R8                   * BUMP TO NEXT SCREEN LINE
         LA    R12,16(,R12)            * BUMP TO NEXT 16 BYTES OF DATA
         BCT   R7,SCRNLOOP             * LOOP UNTIL BUFFER FILLED
BCTDONE  DS    0H
         MVC   WSHALF,=AL2(SCRNLENG)   * SET LENGTH
         EXEC CICS SEND FROM(PGWKSCRN) ERASE LENGTH(WSHALF)
         B     RETCOMM                 * EXIT PROGRAM W/COMMAREA
*  EXECUTED MOVE INSTRUCTIONS
SCRNMOVE MVC    51(0,R6),HOLDDATA      * MOVE DATA TO THE SCREEN FIELD
PRTLMOVE MVC    PRTLINE3(0),PRTLINE1   * MOVE DATA TO PRINT AREA
*  CONSTANTS
HWD0     DC    H'0'
HWD8     DC    H'8'
HWD16    DC    H'16'
HWD80    DC    H'80'
HWD256   DC    H'256'
SBA      DC    X'114040'
HILITE   DC    X'11C7601DE8'
ATTRMSG  DC    X'1DC5'
NOTONMSG DC    C'XXXX NOT SIGNED ON'
BADTPMSG DC    C'XXXX IS AN INVALID TERMINAL TYPE'
NOTCTMSG DC    C'XXXX NOT IN TCT'
NOTASKQ  DC    C'XXXX IS NOT CURRENTLY RUNNING A TASK '
NOCAMSG  DS    0CL80
         DC    X'1140401DF113',CL30'TRANSACTION HAS NO COMMAREA'
         DC    X'115CF01DF1'
         DC    CL39'ENTER=SCREEN, PF12=REFRESH, CLEAR=END  '
RETRVTSK DC    CL4'SCV2'
SPACES   DC    CL4'    '
HEX42    DC    X'42'
CLEARKEY EQU   X'6D'
ENTERKEY EQU   X'7D'
PF7KEY   EQU   C'7'
PF8KEY   EQU   C'8'
PF12KEY  EQU   X'7C'
FLAG1    EQU   X'01'
FLAG2    EQU   X'02'
ERRORS   EQU   X'0F'
ODDCHAR  DC    X'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'
ODDMASK  DS    0CL32        MASK TO MOVE TO ODD NUMBERED POSITIONS
         DC    X'01000200030004000500060007000800'
         DC    X'09000A000B000C000D000E000F001000'
EVENCHAR DC    X'0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F'
EVENMASK DS    0CL32        MASK TO MOVE TO EVEN NUMBERED POSITIONS
         DC    X'00010002000300040005000600070008'
         DC    X'0009000A000B000C000D000E000F0010'
PRTMASK  DS    0CL35        MASK TO MOVE DATA TO SCREEN
         DC    X'010203040506070800090A0B0C0D0E0F1000'
         DC    X'111213141516171800191A1B1C1D1E1F20'
*   TABLE BELOW USED TO CONVERT HEX TO DISPLAY. EX) X'04' TO F4
*   IF NOT DISPLAYABLE IT WILL MOVE A PERIOD.
TRTABLE1 DC    C'0123456789ABCDEF1',15X'00',C'2',15X'00'
         DC    C'3',15X'00',C'4',15X'00',C'5',15X'00'
         DC    C'6',15X'00',C'7',15X'00',C'8',15X'00'
         DC    C'9',15X'00',C'A',15X'00',C'B',15X'00'
         DC    C'C',15X'00',C'D',15X'00',C'E',15X'00',C'F'
*   TABLE BELOW USED TO SELECT SCREEN DISPLAYABLE CHARACTERS,
*   IF NOT DISPLAYABLE IT WILL MOVE A PERIOD.
TRTABLE2 DS    0CL256
         DC    64C'.'
         DC    CL1' '                  SPACE
         DC    9C'.'
         DC    XL7'4A4B4C4D4E4F50'     SPECIAL CHARACTERS
         DC    9C'.'
         DC    XL8'5A5B5C5D5E5F6061'   SPECIAL CHARACTERS
         DC    8C'.'
         DC    XL6'6A6B6C6D6E6F'       SPECIAL CHARACTERS
         DC    9C'.'
         DC    XL7'797A7B7C7D7E7F'     SPECIAL CHARACTERS
         DC    65C'.'
         DC    CL9'ABCDEFGHI'          A - I
         DC    7C'.'
         DC    CL9'JKLMNOPQR'          J - R
         DC    8C'.'
         DC    CL8'STUVWXYZ'           S - Z
         DC    6C'.'
         DC    CL10'0123456789'        0 - 9
         DC    6C'.'
         LTORG
*  CSECT TO HOLD SCREEN CONSTANTS
SCRNAREA CSECT
SCRNPRIM DS    0CL2000                 * SCREEN PRIME AREA
LINE1    DC    X'1140401DF113',CL79'COMMAREA DISPLAY'
LINE2    DC    CL80' TOTAL LENGTH=0000000'
LINE3A   DC    X'11C2601DF1',C'OFFSET                 CONTENTS'
LINE3B   DC    34CL1' ',C'       '
DATADISP EQU   *-SCRNPRIM
LINE4    DC  X'11C3F01DF1',C'+0000',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINELNTH EQU   *-LINE4
LINE5    DC  X'11C5401DF1',C'+0010',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE6    DC  X'11C6501DF1',C'+0020',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE7    DC  X'11C7601DF1',C'+0030',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE8    DC  X'11C8F01DF1',C'+0040',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE9    DC  X'114A401DF1',C'+0050',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE10   DC  X'114B501DF1',C'+0060',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE11   DC  X'114C601DF1',C'+0070',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE12   DC  X'114DF01DF1',C'+0080',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE13   DC  X'114F401DF1',C'+0090',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE14   DC  X'1150501DF1',C'+00A0',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE15   DC  X'11D1601DF1',C'+00B0',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE16   DC  X'11D2F01DF1',C'+00C0',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE17   DC  X'11D4401DF1',C'+00D0',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE18   DC  X'11D5501DF1',C'+00E0',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
LINE19   DC  X'11D6601DF1',C'+00F0',39CL1' ',C'*',18CL1' ',C'*',9CL1' '
MSGDISP  EQU   *-SCRNPRIM+5
LINE24SB DC    X'115CF01DF1'
LINE24M1 DC    CL40'ENTER=SWAP SCREEN/COMMAREA, PF7=PAGE UP,'
LINE24M2 DC    CL39' PF8=PAGE DOWN, PF12=REFRESH, CLEAR=END'
SCRNLENG EQU   *-SCRNPRIM
         DC    (2000-SCRNLENG)CL1' '   * SPACE FILL REST OF 2000 BYTES
*  DSECT FOR COMMAREA
SCRNCOMM DSECT
SCRNLEN  DS    H
COMMLEN  DS    H
COMMDISP DS    H
SCRNUPSW DS    CL1
SAVBUFF  DS    CL9
FILL     DS    CL11
SCRNSBA  DS    CL3
SCRNHOLD DS    CL3000
COMMHOLD DS    CL1000        * VARIABLE SIZE, NOT REALLY 1000 BYTES
*  PROGRAM WORK AREAS
DFHEISTG DSECT
STARTERM DS    F
TERMACQ  DS    F
TERMSERV DS    F
TERMTYPE DS    F
WSHALF   DS    H
QITEM    DS    H
         DS    0D
WSPACK   DS    CL8
WSUNPK   DS    CL6
TERMFLAG DS    XL1
TERMREM  DS    CL4
WSREQID  DS    0CL8
WSREQ    DS    CL4
WSTERM   DS    CL4
IOAREA   DS    0CL103
IOSBA    DS    CL3
INBUFF   DS    0CL9
INTRANID DS    CL4
         DS    CL1
INTERMID DS    CL4
MSGAREA  DS    0CL86
MSGSBA   DS    CL5
MSGTERM  EQU   *
MSGDATA  DS    CL79
MSGATTR  DS    CL2
TIOALEN  EQU   *-IOAREA
HOLDDATA DS    CL16
WORKDATA DS    CL17
PRTLINE1 DS    CL32
PRTLINE2 DS    CL32
PRTLN3A  DS    0CL33
PRTSPACE DS    CL1
PRTLINE3 DS    CL32
PGWKSCRN DS    CL2000
         END


SCV002 SOURCE CODE

SCV002   TITLE ' REMOTE SCREEN/COMMAREA RETRIEVAL PROGRAM'
***THIS PROGRAM IS PART OF THE REMOTE SCREEN/COMMAREA RETRIEVAL      **
*  PROCESS. IT IS STARTED ON THE TERMINAL THAT HAS THE SCREEN AND     *
*  COMMAREA THAT IS TO BE VIEWED. THE SCREEN AND COMMAREA ARE PUT     *
*  TO A TEMP STORAGE QUEUE AND THE REQUESTING TASKS DELAY IS CANCELLED*
***TO RESTART THE TASK.                                              **
TCTTEAR  EQU R4                        * TCTTE ADDRESS
CSACBAR  EQU R13                       * CSA ADDRESS
         COPY DFHCSADS                 * CSA LAYOUT
         USING DFHTCADY,R12            * SET UP TCA ADDRESSABILITY
         DFHTCA   CICSYST=YES          * TCA LAYOUT
         DFHTCTZE CICSYST=YES          * TCT TERMINAL ENTRY LAYOUT
SCV002   DFHEIENT DATAREG=(R2),CODEREG=(R5),EIBREG=(R11)
         B     PASTDT                  * BRANCH AROUND DATE/TIME
         DC    CL8'SCV002  '
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
PASTDT   DS    0H
         MVC   WSHALF,HWD8             * SET RETRIEVE LENGTH
         EXEC CICS RETRIEVE INTO(RETNAME) LENGTH(WSHALF)
         EXEC CICS ADDRESS CSA(CSACBAR)
         MVC   QNAME,RETNAME           * SET QNAME=RETNAME FROM SCV001
         L     TCACBAR,CSACDTA         * GET TCA ADDRESS
         L     TCTTEAR,TCAFCAAA        * GET TCTTE ADDRESS
         MVC   NEXTTRAN,TCTTETC        * STORE NEXT TRANSID
         LH    R6,EIBCALEN             * LOAD COMMAREA LENGTH
         AH    R6,=H'3030'             * ADD SCREEN & CONTROL LENGTH
         STH   R6,WSGMLENG             * STORE LENGTH
         EXEC CICS GETMAIN LENGTH(WSGMLENG) SET(R4) INITIMG(LOWVALS)
         USING SCRNCOMM,R4             * SET UP ADDRESSABILITY
         MVC   COMMLEN,EIBCALEN        * MOVE COMMAREA LENGTH
         MVC   WSHALF,HWD3000          * SET MAX LENGTH
*        READ TERMINAL BUFFER INTO GETMAIN
         EXEC CICS RECEIVE INTO(SCRNHOLD) ASIS BUFFER LENGTH(WSHALF)
         MVC   SCRNLEN,WSHALF          * MOVE SCREEN LENGTH
         LH    R7,EIBCALEN             * LOAD COMMAREA LENGTH
         CH    R7,LOWVALS              * ANY COMMAREA
         BE    SKIPMOVE                * NO, SKIP MOVING IT
         LA    R6,COMMHOLD             * POINT TO COMMHOLD
         L     R8,DFHEICAP             * POINT TO COMMAREA
         LH    R9,EIBCALEN             * LOAD COMMAREA LENGTH
         MVCL  R6,R8                   * MOVE COMMAREA TO HOLD AREA
SKIPMOVE DS    0H
         MVC   QITEM,HWD1              * SET QUEUE ITEM NUMBER
*        PUT TO TEMP STORAGE
         EXEC CICS WRITEQ TS QUEUE(QNAME) FROM(SCRNCOMM)               X
                   LENGTH(WSGMLENG) ITEM(QITEM)
*   NOW WE CANCEL THE DELAY IN REQUESTOR SO IT CAN CONTINUE
         EXEC CICS CANCEL REQID(RETNAME)
*        TASK COMPLETE, GET OUT BUT DON'T DISRUPT INITIAL TASK
RETURN   DS    0H
         CLC   EIBCALEN,LOWVALS        * ANY COMMAREA
         BE    RETNOCOM                * NO, JUST EXIT
         L     R10,DFHEICAP            * POINT R10 AT COMMAREA
         EXEC CICS RETURN TRANSID(NEXTTRAN) COMMAREA(0(R10))           X
                   LENGTH(EIBCALEN)
RETNOCOM DS    0H
         CLC   NEXTTRAN,LOWVALS        * ANY TRANSID
         BE    RETNOTRN                * NO, JUST EXIT
         EXEC CICS RETURN TRANSID(NEXTTRAN)
RETNOTRN DS    0H
         EXEC CICS RETURN
*  CONSTANTS
HWD1     DC    H'1'
HWD8     DC    H'8'
HWD3000  DC    H'3000'
LOWVALS  DC    4XL1'00'
         LTORG
*  TEMP STORAGE QUEUE LAYOUT
SCRNCOMM DSECT
SCRNLEN  DS    H
COMMLEN  DS    H
COMMDISP DS    H
SCRNUPSW DS    CL1
SAVBUFF  DS    CL9
FILL     DS    CL11
SCRNSBA  DS    CL3
SCRNHOLD DS    CL3000
COMMHOLD DS    CL1000        * VARIABLE SIZE, NOT REALLY 1000 BYTES
*  PROGRAM WORK AREAS
DFHEISTG DSECT
WSHALF   DS    H
WSGMLENG DS    H
QNAME    DS    CL8
QITEM    DS    H
RETNAME  DS    CL8
NEXTTRAN DS    CL4
         END


Richard Stumpf
Technical Specialist (USA)

