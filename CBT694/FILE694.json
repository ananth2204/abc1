{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012618000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE694.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE694.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x05'", "DS1TRBAL": "b'\\x91\\xd4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xd5\\x00\\x03\\x04\\xd5\\x00\\x07\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x04(\\x8f\\x01\\x04(\\x8f\\x14T\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-10-14T00:00:00", "modifydate": "2004-10-14T14:54:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-467"}, "text": "REGULAR CBT TAPE - VERSION 467    FILE:  694\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT467.FILE694\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 5 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,303 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/14/04    14:54:35    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE694": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x04(\\x8f\\x01\\x04(\\x8f\\x14T\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-10-14T00:00:00", "modifydate": "2004-10-14T14:54:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT-467"}, "text": "//***FILE 694 is from Mark Yuhas and contains a macro called        *   FILE 694\n//*           MACTREE that will help you do a binary search         *   FILE 694\n//*           through a table of values.  A two-part article        *   FILE 694\n//*           that explains the thinking behind this macro, has     *   FILE 694\n//*           been included, through the courtesy of Technical      *   FILE 694\n//*           Support magazine.                                     *   FILE 694\n//*                                                                 *   FILE 694\n//*           email:  Mark.Yuhas@PACCAR.com                         *   FILE 694\n//*                                                                 *   FILE 694\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ARTICLE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00U\\x01\\x04(\\x8f\\x01\\x04(\\x8f\\x18'\\x01T\\x01Q\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-10-14T00:00:00", "modifydate": "2004-10-14T18:27:55", "lines": 340, "newlines": 337, "modlines": 0, "user": "SBGOLOB"}, "text": "Table Processing Part One: A New Approach\nBy Mark Yuhas\n\nThe intent of this article is to present a new approach to the\nold subject of table processing.  We know Table processing is not\nexactly focused on the leading edge of technology.  Furthermore,\nmany programmers - application and systems - have written search\nroutines, especially binary search routines.  The intent of this\narticle is to present a new approach to an old subject.\n\n\n       Definition of Terms\n\n  Entry          A set of fields in contiguous storage containing\n                 user-defined data\n  Table          A set of entries in contiguous storage\n  Key            An indexing field or fields of an entry usually\n                 fixed in length\n  Keyed table    A table where the entries are ordered by a key\n                 (For this discussion, the key will be restricted\n                 to one field)\n  Binary search  An iterative search process where the upper and\n                 lower bounds of the keyed table are redefined by\n                 the result of the key comparison in the previous\n                 iteration\n  Serial search  An iterative search process where the lower\n                 bound of a table is redefined by the result of\n                 the key comparison in the previous iteration.\n\n\nThe binary search requires a table with entries of a fixed length\nand unique keys.  The serial search usually requires a table with\nfixed-length entries.  However, certain table structures can\npreventobviate the need for fixed-length entries.\n\nBinary Versus Serial\n\nFigure 1 contains an example of a serial search.  The path length\nis short and concise.  If the routine doesn't find a match, it\nwill always examine the next entry.  Although the serial search\nis very simple and straightforward, it is also inefficient and\ntime-cconsuming.  Time consuming because as the number of\nentries increases, so does the time to search the table.  This is\neven more time-consuming when one considers the 'hit ratio'---,\ni.e. the number of times a matching entry is found versus the\nnumber of times the search is performed.\n\n\n    Figure 1 - Serial search code\n\n                  LA    R14,TABLEA_START\n                  LA    R15,TABLEA_STOP\n  SERIAL_SEARCH   DS    0H\n                  CLC   SEARCH_FOR,0(R14)\n                  BNL   SEARCH_DONE\n                  LA    R14,0(ENTRY_LENGTH,R14)\n                  CR    R14,R15\n                  BL    SERIAL_SEARCH\n  SEARCH_DONE     DS    0H\n            .\n            .\n            .\n  SEARCH_FOR      DC    CL8'some value'\n  TABLEA_START    EQU   *\n                  DC    CL8'whatever'\n  ENTRY_LENGTH    EQU   *-TABLEA_START\n                  DS    CL??\n                  DS    CL??\n                  .\n                  .\n                  .\n  TABLEA_STOP     EQU  *\n\n\nFigure 2 contains an example of a binary search.\n\nFigure 2:  The binary search of Table A:\n\n\n                  LA    R14,TABLEA_START\n                  LA    R15,TABLEA_STOP\n  BINARY_SEARCH   DS    0H\n                  XR    R10,R10\n                  SR    R11,R15\n                  SR    R11,R14\n                  C     R11,=F'1'\n                  BH    CONTINUE_SEARCH\n                  CLC   SCAN_FOR,0(R14)\n                  BE    SEARCH_DONE\n                  CLC   SCAN_FOR,0(R15)\n                  BE    SEARCH_DONE\n                  B     SEARCH_FAIL\n  CONTINUE_SEARCH DS    0H\n                  D     R10,=A(ENTRY_LENGTH)\n                  SRL   R11,1\n                  XR    R10,R10\n                  M     R10,=A(ENTRY_LENGTH)\n                  AR    R11,R14\n                  CLC   SCAN_FOR,0(R11)\n                  BH    UPPER_HALF\n                  BE    SEARCH_DONE\n                  LR    R15,R11\n                  B     BINARY_SEARCH\n  UPPER_HALF      DS    0H\n                  LR    R14,R11\n                  B     BINARY_SEARCH\n  SEARCH_DONE     DS    0H\n                  .\n                  .\n                  .\n  SEARCH_FAIL     DS    0H\n                  .\n                  .\n                  .\n  SEARCH_FOR      DC    CL8'some value'\n  TABLEA_START    EQU   *\n                  DC    CL8'whatever'\n                  DS    CL??\n                  DS    CL??\n  ENTRY_LENGTH    EQU   *-TABLEA_START\n                  .\n                  .\n                  .\n  TABLEA_STOP     EQU  *\n\n\nWhile the binary search code has a longer path, it is much more\nefficient.  The binary search becomes more efficient as the table\nsize increases, as this chart shows:\n\n  # of Entries    Maximum Search Iterations    Average Search Iterations\n  ------------    -------------------------    -------------------------\n  10               Binary  5                        3.3\n                  Serial  10                        5.5\n\n  100              Binary  8                        6.3\n                  Serial  100                      50.5\n\n  1000             Binary  11                       9.2\n                  Serial  1000                    500.5\n\n  10000            Binary  15                      12.9\n                  Serial  10000                  5000.5\n\nOnce again, stating the obvious, the binary search is much more\nefficient, even for tables with a small number of entries.\n\nCloser Scrutiny of the Binary Search\n\nDespite being quite efficient, the binary search will invariably\nexamine the same entries for a given search argument for each\nsearch invocation.  For example, the binary search of a table of\n100 entries would have this standard search sequence for Entry\n#76:\n\n  Entry #50, Entry #75, Entry #87, Entry #81, Entry #78, Entry #76\n\nIf this sequence is known, why should the search routine perform\nthe calculations to determine the next entry to examine?  The\nefficiency of the binary search would be dramatically improved if\nthis search sequence could be mapped prior to invocation.\n\nAttempts to derive an algorithm/mapping to identify this search\nsequence proved to be fruitless.  However, a construct called the\nbinary tree table appeared to provide the desired mapping.  In\nthis construct, each entry points to its higher and lower\nentries for the next search iteration--, i.e. the midpoint of the\nnext interval.  The definition of the next interval being\ndetermined by the comparison for the current interval (, for\nexample, e.g. for a table of 10 entries):\n\n  #1 points to null & null\n  #2 points to null & #1\n  #3 points to #4 & #2\n  #4 points to null & null\n  #5 points to #7 & #3\n  #6 points to null & null\n  #7 points to #8 & #6\n  #8 points to #9 & null\n  #9 points to #10 & null\n  #10 points to null & null\n\nOnce the midpoint of the array is found, the search proceeds in a\ncascade effect with each subsequent iteration determined only by\nthe result of the previous iteration's comparison.  This is\nbetter illustrated in Figure 3:\n\n\n\nWhen to Map the Tree\n\nA run-time programmatic solution seemed to be the fastest method\nto impose the tree structure on the table.  A programmatic\nsolution would also provide the flexibility needed when the table\nsize changed.  Further, the programmatic solution was immensely\nfaster and more accurate than any manual method.  This approach\nhad a major flaw--, i.e. any user/application/service requiring\naccess to the table would have to wait until the programmatic\nsolution completed.  Thus, the tree structure needed to be\ncreated with the table itself.  In other words, the structure\nwould have to be part of the source code.  Since any addition or\ndeletion of entries would change the structure, the source code\nwould have to change accordingly.  This type of flexibility and\nspeed could only be achieved via a MACRO.\n\nBefore I begin the explanation of the MACRO, I should make\nsomething clear.  I am not omniscient, nor, do I mind-meld with\nthe machine.  There are probably as many approaches to coding\nthis MACRO as there are readers.  My intent here is to explain\nhow I was able to achieve a faster search mechanism by defining\nthe tree structure via this MACRO.\n\nThe MACRO required 4 phases:\n\n  Input, editing and retention of table entries\n  Sorting the table entries\n  Creating the tree structure\n  Generating the source\n\nPhase 1:  Input, Editing and Retention of Table Entries\n\nFirst, any macro that builds individual table entries can be\nused.  Modifying the existing macro to build the individual\nentries and save them in a global array performs the input\nportion.  Figure 4 lists the MACRO declarations.  The pointer for\nthe current array entry is &GINDEX.  This variable will also\nserve as the control for the subsequent loops in the other\nphases.  Also, the declarations include the local array LTBL1 and\nLTBL2, which are critical for the deriving the tree structure.\n\n&NAME  TREEMAC  &MSGID,        +\n                &FLAG1=OFF,    +\n                &FLAG2=OFF,    +\n                &FLAG3=OFF,    +\n                &FLAG4=OFF,    +\n                &FLAG5=OFF,    +\n                &FLAG6=OFF,    +\n                &FLAG7=OFF,    +\n                &FLAG8=OFF,    +\n                &MESSAGE=NO,   +\n                &PROCESS=NO,   +\n                &USEID=\n        GBLC    &GSORTKEY(1500)\n        GBLC    &GMSGID(1500)\n        GBLC    &GFLAG1(1500)\n        GBLC    &GFLAG2(1500)\n        GBLC    &GFLAG3(1500)\n        GBLC    &GFLAG4(1500)\n        GBLC    &GFLAG5(1500)\n        GBLC    &GFLAG6(1500)\n        GBLC    &GFLAG7(1500)\n        GBLC    &GFLAG8(1500)\n        GBLC    &GMESSAGE(1500)\n        GBLC    &GPROCESS(1500)\n        GBLA    &GLO(1500)\n        GBLA    &GHI(1500)\n        GBLB    &GDONE(1500)\n        GBLA    &GINDEX\n        GBLA    &GTBLNO\n        LCLC    &LSORTKEY\n        LCLC    &LMSGID\n        LCLC    &LFLAG1\n        LCLC    &LFLAG2\n        LCLC    &LFLAG3\n        LCLC    &LFLAG4\n        LCLC    &LFLAG5\n        LCLC    &LFLAG6\n        LCLC    &LFLAG7\n        LCLC    &LFLAG8\n        LCLC    &LMESSAGE\n        LCLC    &LPROCESS\n        LCLA    &LLO\n        LCLA    &LHI\n        LCLA    &LSEED\n        LCLA    &L1\n        LCLA    &L2\n        LCLA    &L3\n        LCLA    &L4\n        LCLA    &L5\n        LCLA    &L6\n        LCLA    &L7\n        LCLA    &L8\n        LCLA    &L9\n        LCLA    &LTBL1(1500)\n        LCLA    &LTBL2(1500)\n\n\nSecond, Phase 1 needs a method to control the starting and\nstopping of the population of the array.  This control method was\nachieved through the definition of specific key values indicating\nthe beginning and end of this phase--, i.e. TABLE_START &\nTABLE_STOP.  TABLE_START initializes the global variables for\nsubsequent processing.  TABLE_STOP establishes the limits for the\nsubsequent source and sets variables disabling any further\ninvocations to create any further array entries.\n\nPhase 2:  Sorting the Table Eentries\n\nSorting proved to be an interesting exercise in itself.  The\nbubble sort technique was used.  Storage was not a restriction,\nand processing time was more than ample.  However, after coding\nthe sort, an attempt to sort a table with 10 entries was made.\nLo and behold, the sort results were strange.  Keys with higher\nvalues were lower in the collation, and, vice versa.  For\nexample, if the table contained keys of:\n\n                         ABCD, ABC, CB, XYZ, Z, YZ\n\nthe sorted result would be:\n\n                         Z, CB, YZ, ABC, XYZ, ABCD\n\nApparently, in the macro world, the lengths of the variables are\ncompared before comparing the variables themselves.  This wrinkle\nrequired a modification to the bubble sort, where a comparison of\nthe lengths would determine which length to use for the\nsubsequent comparison.  Or, Phase 1 could be altered to add\nanother field to the global array.  This new field would contain\na left-justified key padded with blanks.  This field would\nbecome the key field for the sort.  This modification reduced a\nlot of extraneous coding and left the actual fields of the entry\nalone.  Refer to Figure 4 and the variable &GSORTKEY.  When the\nMACRO detects another element for the array, the MACRO checks the\nlength of the key, and, if necessary, pads the key value with\nblanks in &GSORTKEY.\n\nConclusion\n\nBy design, this table has unique keys.  When the bubble sort\ndetects a duplicate key, the macro ends with an appropriate MNOTE\ndetailing the equal keys.  In part two However, later in the\narticle,we will see that  duplicate keys do not affect the\nintegrity of the table. We will also address the next two phases\nin part two of this article.\n\nMark Yuhas I has worked have been in in the IT area for 31 years,\nincluding the last 19 years of experience as an MVS systems\nprogrammer.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ARTICLE2": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x04(\\x8f\\x01\\x04(\\x8f\\x14E\\x01t\\x01t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-10-14T00:00:00", "modifydate": "2004-10-14T14:45:01", "lines": 372, "newlines": 372, "modlines": 0, "user": "SBGOLOB"}, "text": "\nTable Processing Part Two:  A New Approach\nBy Mark Yuhas\n\nThis second article in a two-part series will further address the\nsteps in table processing, including creating the tree structure\nand generating the source.\n\nPhase 3:  Creating the Tree Structure\n\nThis phase constructs the binary tree structure.  The previous\nbubble sort has the array in the key sequence.  E.G., a table of\n10 entries with keys:\n\n  Entry1  - KEYA\n  Entry2  - KEYB\n  Entry3  - KEYC\n  .\n  .\n  .\n  Entry9  - KEYI\n  Entry10 - KEYJ\n\nwhere:\n\n  KEYA < KEYB < KEYC < ... < KEYI < KEYJ\n\nThis sequenced structure allows the usage of an integer subset of\n{1,2,3,..n} instead of Entry1, Entry2,...  I.E.:\n\n  {1,2,3,..10} as opposed to {Entry1, Entry2, Entry3,...,Entry10}.\n\nYes, actually, the mapping is just using the subscripts of the\nentries of the global array.  In the vernacular of the\nmathematician, the array has a one-to-one and onto mapping to the\ninteger set.  This mapping also has another benefit--whatever\noperation/sequencing performed on the integer set will hold for\nthe table as well.\n\nPhase 3:  Creating the Tree Structure: The Specific Case\nDefining the tree structure consists of a series of iterations of\ndetermining the middle element of a series of subsets defined by\nthe results of the previous iteration.  Sounds a lot like a\nbinary search, which it is.  The mapping begins with the\nendpoints and determination of the midpoint of the interval:\n\n  {1,10} will yield a .midpoint of 5\n\n  For:\n    (1+10)/2 = 5\n\nNow, the subset looks like:\n\n  {1,5,10}\n\nThe next iteration yields new midpoints of 3 and 7:\n\n  (1+5)/2 = 3  (5+10)/2 = 7\n\nThe subset becomes:\n\n  {1,3,5(3,7),7,10}\n\n  where A(B,C) is the notation to indicate that B is the element\n  for the next iteration of the search if the key in element A is\n  less than the target key. And, C is the next the element for\n  the next iteration if the key in element A is greater than the\n  target key.\n\nThe next iteration yields midpoints of 2, 4, 6 and 8:\n\n  (1+3)/2=2   (3+5)/2=4    (5+7)/2=6    (7+10)/2=8\n\nThe subset is now:\n\n  {1,2,3(2,4),4,5(3,7),6,7(6,8),8,10}\n\nThe next iteration yields midpoints of 1,0,0,0,0,0,0,9;\n\n  (1+2)/2=1   (2+3)/2=0    (3+4)/2=0    (4+5)/2=0\n  (5+6)/2=0   (6+7)/2=0    (7+8)/2=0    (8+10)/2=9\n\nIt should be obvious the 'zero midpoints' occur when the length\nof any of the subset is 1.  In other words, the subset consists\nof consecutive integers, which means the midpoint is nonexistent\nor zero.  So why doesn't (1+2)/2=0?  By definition, These subset\n{1,2} and {9,10} are special subsets that by definition do not\nhave midpoints.  Thus, the algorithm will not map to the\nendpoints.  The only way to make this mapping a one-to-one and\nonto mapping is by defining this condition for these subsets.\n\nThe subset is now:\n\n  {1,2(1,0),3(2,4),4(0,0),5(3,7),6(0,0),7(6,8),8(0,9),9,10}\n\nAnd, the final iteration yields:\n\n  (1,2(1,0),3(2,4),4(0,0),5(3,7),6(0,0),7(6,8),8(0,9),9(0,10),10}\n\nOne more adjustment is needed.  You will notice 1 and 10 do not\nhave any pairs defined with them.  Actually, these elements will\nalways have the pairs of (0,0).  Why?  Suppose that one of these\nhad a 'nonzero midpoint.'  If this were true, then that would\nmean that either the Minimum or Maximum was a midpoint of some\nsubset.  Again, if either of these was a midpoint, then a value\nlower than the Minimum or the greater than the Maximum would\nexist.  By definition, there cannot be such a value.  Therefore,\nthe Minimum and Maximum have null or '0' values.  This yields the\nfollowing structure:\n\n {1(0,0),2(1,0),3(2,4),4(0,0),5(3,7),6(0,0),7(6,8),8(0,9),9(0,10),10(0,0)}\n\nPhase 3:  Creating the Tree Structure: The General Case\nUsing this information, the general case macro can be developed.\nThis general process requires the usage of 3 arrays:\n\n  A master array that was inputted previously designated by the\n  &G prefix\n\n  2 local arrays for the iterative process designated &LTBL1 &\n  &LTBL2, respectively\n\nThe first local array (&LTBL1) will contain the entries for each\niteration.  These entries are the endpoints for the subsets for\nthe subsequent midpoint determination and the previous midpoint\nresults.  The second array (&LTBL2) is a superset of the first\narray containing &LTBL1 and the calculated midpoints.  At the end\nof the iteration, &LTBL2 is moved to &LTBL1, establishing the\nnext subset for the next iteration.  This process continues until\nthe number of elements in the superset (&LTBL2) equals the number\nof elements in the master array.\n\nAt the start of this procedure, first local array on has two\nentries, the minimum (Min or 1) and the maximum (Max or &GINDEX).\nUsing these two values, the midpoint (Mid) can be calculated:\n\n  Mid = (1+Max)/2\n\nFor lack of a better term, this is the 'seed' for the actual\nsearch.  Remember the critical step to this process is finding\nthis \"seed\" to \"kick start\" the search procedure.  This yields a\nnew array:\n\n  {1,Mid,Max}\n\nNext, the midpoints of the two subsets are determined yielding\nthe first initial array of:\n\n  {1, (1+Mid)/2, Mid, (Mid+Max)/2, Max}\n\nEach element in the array is the index/subscript of the Master\narray.  The Master array contains 3 additional elements:\n\n  GLO    Index/subscript of the lower midpoint\n  GHI      Index/subscript of the higher midpoint\n  GDONE    Binary variable indicating whether GLO or GHI was set\n\nThe master array entries for Min (1) and Max (&GINDEX) have GLO\nand GHI set to zero and GDONE is turned on.  The master array\nentry for Mid has the corresponding GLO set to (1+Mid)/2, GHI set\nto (Mid+Max)/2, and GDONE turned on.  Now, the iterations begin.\n\nEach subset is defined by two consecutive entries in the first\nlocal array, i.e. L2 & L2+1.  L3 is the index for LTBL2  The\ncontrol for each iteration is L1 whichL1, which contains the\nnumber of elements in LTBL1 + 1.This is the framework for each\niteration:\n\nCheck for GDONE turned on.  If it is, move &LTBL1(&L2) to\n&LTBL2(&L3) and increment &L2 and &L3, accordingly.\n\nIf the difference between &LTBL1(&L2) and &LTBL1(&L2-1) is\ngreater than 1, then calculate the new lower midpoint, and, then\naddress the high midpoint for the subset:\n    {&LTBL1(&L2),&LTBL1(&L2+1)}\n\nIf &LTBL1(&L2) is equal to 2, then set GLO for &LTBL1(&L2) to 1,\nmove this entry to &LTBL2, set &L3 to 3, and, then address the\nhigh midpoint for the subset:\n    {&LTBL1(&L2),&LTBL1(&L2+1)}.\n\nIf &LTBL1(&L2) is greater than 2, then set GLO for &LTBL1(&L2) to\nzero, move this entry to &LTBL2, increment &L3, and, then address\nthe high midpoint for the subset:\n    {&LTBL1(&L2),&LTBL1(&L2+1)}.\n\nFor the high midpoint:\n\nIf the difference between &LTBL1(&L2) and &LTBL1(&L2+1) is\ngreater than 1, then calculate the new higher midpoint and then\nincrement &L2 and &L3 accordingly.\n\nIf &LTBL1(&L2+1) is equal to GINDEX, then set GHI for &LTBL1(&L2)\nto GINDEX, move this entry to &LTBL2, set &L3 to 3 and then\nincrement &L2 and &L3 accordingly\n\nIf &LTBL1(&L2) is greater than 2, then set GHI for &LTBL1(&L2) to\n    zero, move this entry to &LTBL2, increment &L3 and then\n    address the high midpoint for the subset:\n    {&LTBL1(&L2),&LTBL1(&L2+1)}.\n\nSet GDONE to 1.\n\nIf all the entries of the array have been addressed, i.e.\n&L2=&L1, this iteration is complete.\n\nAll the elements in &LTBL2 are moved to &LTBL1.  As they are\nmoved the count of elements for &LTBL1 is established for the\nnext iteration.  Also, the count of GDONE is kept track of in\n&L4.\n\nAt the end of the move, if &L4 is equal to &GINDEX, the mapping\nhas completed.  If not, the next iteration control is in &L1 and\nthe corresponding entries in &LTBL1.\n\nPhase 3:  Creating the Tree Structure: Verifying the Mapping\nThe mapping performed successfully for arrays with 10, 25, 50 and\n100 entries.  However, a test of an array with 950 entries failed\nwith an error stating ACTR was negative.  ACTR is  the\nconditional assembly language counter, thatcounter that begins\nwith a value and is decremented with every successful branch.\nWhen ACTR contains a negative value, the assembler ends the\nassembly.  This prevents loops in the assembly.\n\nThe programmer can set ACTR in the MACRO, but what to set it to?\n1000?  2000?  It would be advantageous and elegant if the macro\ncould set ACTR according to the number of table entries.  Only\nthe sort and the tree mapping required revaluation of ACTR.\n\nThe bubble sort provided a fairly simple solution.  What\nconditions would cause the most number of branches for the master\narray?  That condition would arise if the master array were in\ndescending sequence.  The bubble sort would have to move every\nentry in the master array.  How many iterations and how many\nbranches would this condition create?  The number of iterations\nis the sum of the sequence:\n\n  {GINDEX, GEINDEX-1, GEINDEX-2, ..., 3,2,1}\n\nwhich is\n\n  \u00dd(GINDEX+1)GINDEX\u00a8/2\n\nThis yields the number of iterations.  Multiplying the number of\nbranches in the bubble sort by the sum of the sequence would\nproduce a value for ACTR.  It would be inflated because not every\nbranch is taken in any iteration.  The number would be too high,\nwhich is preferable to too low.\n\nThe second consideration is the building of the tree structure.\nThis seemed like a SWAG.SWAG.  But it, too, had a simple\nsolution.  For the first iteration, LTBL1 has two elements.  For\nthe second, LTBL1 has 5.  The third has 11.  The fourth has 23.\nBasically, the mapping doubles the local array until all elements\nare addressed.  Thus, beginning with 4 or 22,this addresses the\nfirst iteration.  8 or 23 addresses the second iteration.  16 or\n24 addresses the third iteration. and  32 or 25 addresses the\nfourth.  And so on.  This pattern continues until there is a\nnumber n such that 2n is greater than GINDEX.  The number of\niterations is equal to the sum of the elements of the sequence:\n\n  {4,8,16, ...,2n}\n\nThe following is a subset of the sequence.;\n\n  {1,24,8,16, ...,2n}\n\nThis sum of the elements in the second sequence is:\n\n  2n+1-1\n\nMultiplying this sum by the total number of branches in the tree\nbuilding will yield a value for ACTR that will not be exceeded.\n\nPhase 4:  Generating the Source\nGenerating the source for the individual table entries is pretty\nstraightforward.  Before building the source for each entry, the\nmacro generates the 'seed', i.e. TABLE_SEED.  This 'seed' is the\n'kick-start' alluded to previously.\n\nEach entry of the global array contains two fields that point to\nthe higher and lower midpoints.  Since each entry's\nindex/subscript is unique, this value can be used as a label,\ni.e. ELEMENT_index.  This makes the generated table easier to\ntrace via the source listing.  Further, the pointers to the high\nand low values can use the same ELEMENT_index, i.e. ELEMENT_high\n& ELEMENT_low.  The generated table entry becomes:\n\nTABLE_SEED    DC    A(ELEMENT_seed)\nELEMENT_0001  DC    C(TABLEKEY_0001_value),A(0),A(0)\n              DC    table data\n              .\n              .\n              .\nELEMENT_index DC C'TABLEKEY_index_valuex',A(ELEMENT_low),A(ELEMENT_high)\n              DC    table data\n\nThis continues until the master array is exhausted.\n\nIt may appear that the individual table entries must have a\nlength divisible by 4 and that the key length must be divisible\nby 4.  If not, then the entries will not be contiguous, as the\nassembler will align the data values according to type and\nlength.  A simple revision of the table entry format yields:\n\n  ELEMENT_index  DC A(ELEMENT_low),A(ELEMENT_high),C'TABLEKEY_index_value'\n                 DC table data\n\nNow, the entry will always be aligned on a full word boundary due\nto the ADCON as the first field of the entry.  However, the full\nword ADCON is superfluous.  The generated entry could easily be:\n\n  ELEMENT_index  DC   AL4(ELEMENT_low),AL4(ELEMENT_high)\n                 DC   C'TABLEKEY_inde_valuex',table data\n\nThis structure obviates the need for a full word boundary.  Going\none step further and redefining the table entry as:\n\n  ELEMENT_index  DC   AL4(ELEMENT_low),AL4(ELEMENT_high), table data\n                 DC   AL1(L'TABLEKEY_index)\n  TABLEKEY_index DC   C'TABLEKEY_inde-valuex'\n\nThis structure yields a table with entries of variable length\nwith variable length keys.  Who would want to create something as\ndeviant?  I, for one.would do so because  I actually have a need\nfor a keyed table with this structure.  And, the macro generates\nthe source code just fine for a binary search using the tree\nstructure.\n\nFinally, after all this work and contortions, this is the new\nsearch code:\n\n              L     R15,SEED_ADDRESS\n  TREE_SEARCH DS    0H\n              LTR   R15,R15\n              BZ    NOT_FOUND\n              CLC   SEARCH_FOR,0(R15)\n              BE    FOUND\n              BL    SET_LOW\n              L     R15,HIGH_MIDPOINT\n              B     TREE_SEARCH\n  SET_LOW     DS    0H\n              L     R15,LOW_MIDPOINT\n              B     TREE_SEARCH\n  FOUND       DS    0H\n\n\nFinally, using this macro, the definition of a table can be\nchanged to:\n\n  Entry    A set of fields in contiguous storage containing\n           user-defined data.\n  Table    A set of entries in storage.\n           Contiguous is not a requirement because the macro will\n           generate the addressing to the entries as needed.\n  Key      An indexing field or fields of an entry.\n           The key can be variable in length and still maintain\n           the necessary structure because the macro will impose\n           that structure via the tree structure mapping.\n\nThe revised binary search routine combines the brevity of the\ncode path of the serial search and the efficiency of the binary\nsearch.  This search routine references neither the number of\nentries nor the entry length.  In addition, duplicate entries\nwill not invalidate the integrity of the binary tree.\nFurthermore, all of the intermediate calculations have been\neliminated.  The macro has replaced these calculations via the\ntree structure construction during the assembly.  The assembly\nwill take longer, but it is a one-time performance hit.\n\nTry it.  You just may like it.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACTREE": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x05\\x01\\x03&_\\x01\\x04(o\\x11@\\x02:\\x020\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-09-22T00:00:00", "modifydate": "2004-10-12T11:40:05", "lines": 570, "newlines": 560, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME    MACTREE  &MSGID,                                              +\n               &FLAG1=OFF,                                             +\n               &FLAG2=OFF,                                             +\n               &FLAG3=OFF,                                             +\n               &FLAG4=OFF,                                             +\n               &FLAG5=OFF,                                             +\n               &FLAG6=OFF,                                             +\n               &FLAG7=OFF,                                             +\n               &FLAG8=OFF,                                             +\n               &MESSAGE=NO,                                            +\n               &PROCESS=NO,                                            +\n               &USEID=\n         GBLC  &GSORTKEY(1500)\n         GBLC  &GMSGID(1500)\n         GBLC  &GFLAG1(1500)\n         GBLC  &GFLAG2(1500)\n         GBLC  &GFLAG3(1500)\n         GBLC  &GFLAG4(1500)\n         GBLC  &GFLAG5(1500)\n         GBLC  &GFLAG6(1500)\n         GBLC  &GFLAG7(1500)\n         GBLC  &GFLAG8(1500)\n         GBLC  &GMESSAGE(1500)\n         GBLC  &GPROCESS(1500)\n         GBLA  &GLO(1500)\n         GBLA  &GHI(1500)\n         GBLB  &GDONE(1500)\n         GBLA  &GINDEX\n         GBLA  &GTBLNO\n.* ================================================================== *\n.* &GSET1 - SET ON WHEN 'MESSAGE_TBLSTART' DETECTED                   *\n.* &GSET2 - SET ON MNOTE FOR NOT SET1 ISSUED TO PREVENT FURTHER       *\n.*          MESSAGES                                                  *\n.* &GSET3 - SET ON WHEN 'MESSAGE_TBLSTOP' DETECTED                    *\n.* &GSET4 - SET ON WHEN MNOTE FOR SET3 IS ISSUED TO PREVENT FURTHER   *\n.*          MESSAGES                                                  *\n.* &GSET5 - SET ON WHEN THE MAXIMUM NUMBER OF TABLE ENTRIES HAVE BEEN *\n.*          EXCEEDED                                                  *\n.* &GSET6 - SET ON WHEN MNOTE FOR GSET5 IS ISSUED TO PREVENT FURTHER  *\n.*          MESSAGES                                                  *\n.* ================================================================== *\n         GBLB  &GSET1\n         GBLB  &GSET2\n         GBLB  &GSET3\n         GBLB  &GSET4\n         GBLB  &GSET5\n         GBLB  &GSET6\n         LCLC  &LSORTKEY\n         LCLC  &LMSGID\n         LCLC  &LFLAG1\n         LCLC  &LFLAG2\n         LCLC  &LFLAG3\n         LCLC  &LFLAG4\n         LCLC  &LFLAG5\n         LCLC  &LFLAG6\n         LCLC  &LFLAG7\n         LCLC  &LFLAG8\n         LCLC  &LMESSAGE\n         LCLC  &LPROCESS\n         LCLA  &LLO\n         LCLA  &LHI\n         LCLA  &LSEED\n         LCLA  &L1\n         LCLA  &L2\n         LCLA  &L3\n         LCLA  &L4\n         LCLA  &L5\n         LCLC  &L6\n         LCLC  &L7\n         LCLC  &L8\n         LCLC  &L9\n         LCLA  &LTBL1(1500)\n         LCLA  &LTBL2(1500)\n         AIF   (&GSET3).MNOTE14\n         AIF   (&GSET1).CHECK_MSGID\n         AIF   ('&MSGID' NE 'MESSAGE_TBLSTART').MNOTE15\n&GSET1   SETB  1\n         MEXIT\n.* ================================================================== *\n.CHECK_MSGID   ANOP\n         AIF   ('&MSGID' EQ '').MNOTE2\n         AIF   ('&MSGID' EQ 'MESSAGE_TBLSTART').MNOTE3\n         AIF   ('&MSGID' EQ 'MESSAGE_TBLSTOP').SORT_TABLE\n         AIF   (&GSET5).MNOTE16\n         AIF   ('&FLAG1' NE 'OFF' AND '&FLAG1' NE 'ON').MNOTE2\n         AIF   ('&FLAG2' NE 'OFF' AND '&FLAG2' NE 'ON').MNOTE3\n         AIF   ('&FLAG3' NE 'OFF' AND '&FLAG3' NE 'ON').MNOTE4\n         AIF   ('&FLAG4' NE 'OFF' AND '&FLAG4' NE 'ON').MNOTE5\n         AIF   ('&FLAG5' NE 'OFF' AND '&FLAG5' NE 'ON').MNOTE6\n         AIF   ('&FLAG6' NE 'OFF' AND '&FLAG6' NE 'ON').MNOTE7\n         AIF   ('&FLAG7' NE 'OFF' AND '&FLAG7' NE 'ON').MNOTE8\n         AIF   ('&FLAG8' NE 'OFF' AND '&FLAG8' NE 'ON').MNOTE9\n         AIF   ('&MESSAGE' NE 'YES' AND '&MESSAGE' NE 'NO').MNOTE10\n         AIF   ('&PROCESS' NE 'YES' AND '&PROCESS' NE 'NO').MNOTE11\n         AIF   ('&FLAG1' EQ 'ON' AND '&MESSAGE' EQ 'NO').MNOTE12\n         AIF   ('&FLAG2' EQ 'ON' AND '&FLAG4' EQ 'ON').MNOTE18\n         AIF   ('&FLAG4' EQ 'ON' AND '&PROCESS' EQ 'NO').MNOTE19\n.* ================================================================== *\n&LMSGID      SETC    '&MSGID'\n             AIF    ('&FLAG1' EQ 'OFF').FLAG1_OFF\n&LFLAG1      SETC   '1'\n             AGO    .CHECK_FLAG2\n.* ------------------------------------------------------------------ *\n.FLAG1_OFF   ANOP\n&LFLAG1      SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG2   ANOP\n               AIF    ('&FLAG2' EQ 'OFF').FLAG2_OFF\n&LFLAG2        SETC   '2'\n               AGO    .CHECK_FLAG3\n.* ------------------------------------------------------------------ *\n.FLAG2_OFF     ANOP\n&LFLAG2        SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG3   ANOP\n               AIF    ('&FLAG3' EQ 'OFF').FLAG3_OFF\n&LFLAG3        SETC   '3'\n               AGO    .CHECK_FLAG4\n.* ------------------------------------------------------------------ *\n.FLAG3_OFF     ANOP\n&LFLAG3        SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG4   ANOP\n               AIF    ('&FLAG4' EQ 'OFF').FLAG4_OFF\n&LFLAG4        SETC   '4'\n               AGO    .CHECK_FLAG5\n.* ------------------------------------------------------------------ *\n.FLAG4_OFF     ANOP\n&LFLAG4        SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG5   ANOP\n               AIF    ('&FLAG5' EQ 'OFF').FLAG5_OFF\n&LFLAG5        SETC   '5'\n               AGO    .CHECK_FLAG6\n.* ------------------------------------------------------------------ *\n.FLAG5_OFF     ANOP\n&LFLAG5        SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG6   ANOP\n               AIF    ('&FLAG6' EQ 'OFF').FLAG6_OFF\n&LFLAG6        SETC   '6'\n               AGO    .CHECK_FLAG7\n.* ------------------------------------------------------------------ *\n.FLAG6_OFF     ANOP\n&LFLAG6        SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG7   ANOP\n               AIF    ('&FLAG7' EQ 'OFF').FLAG7_OFF\n&LFLAG7        SETC   '7'\n               AGO    .CHECK_FLAG8\n.* ------------------------------------------------------------------ *\n.FLAG7_OFF     ANOP\n&LFLAG7        SETC   '0'\n.* ================================================================== *\n.CHECK_FLAG8   ANOP\n               AIF    ('&FLAG8' EQ 'OFF').FLAG8_OFF\n&LFLAG8        SETC   '8'\n               AGO   .CHECK_MESSAGE\n.* ------------------------------------------------------------------ *\n.FLAG8_OFF     ANOP\n&LFLAG8        SETC   '0'\n.* ================================================================== *\n.CHECK_MESSAGE   ANOP\n                 AIF    ('&MESSAGE' EQ 'NO').MESSAGE_NO\n                 AIF    ('&USEID' EQ '').BYPASS1\n&LMESSAGE        SETC   'A(&USEID._MVCL)'\n                 AGO    .CHECK_PROCESS\n.* ------------------------------------------------------------------ *\n.BYPASS1         ANOP\n&LMESSAGE        SETC   'A(&MSGID._MVCL)'\n                 AGO    .CHECK_PROCESS\n.* ------------------------------------------------------------------ *\n.MESSAGE_NO      ANOP\n&LMESSAGE        SETC   'A(0)'\n.* ================================================================== *\n.CHECK_PROCESS   ANOP\n                 AIF    ('&FLAG2' EQ 'ON').SET_COMMAND\n                 AIF    ('&PROCESS' EQ 'NO').PROCESS_NO\n                 AIF    ('&USEID' NE '').SET_PROCESS\n&LPROCESS        SETC   'A(PROCESS_&MSGID.)'\n                 AGO    .BUILD_GBLENTRY\n.* ------------------------------------------------------------------ *\n.SET_PROCESS     ANOP\n&LPROCESS        SETC   'A(PROCESS_&USEID.)'\n                 AGO    .BUILD_GBLENTRY\n.* ------------------------------------------------------------------ *\n.SET_COMMAND     ANOP\n                 AIF    ('&USEID' NE '').COMMAND_SET\n&LPROCESS        SETC   'A(&MSGID._COMMANDS)'\n                 AGO    .BUILD_GBLENTRY\n.* ------------------------------------------------------------------ *\n.COMMAND_SET     ANOP\n&LPROCESS        SETC   'A(&USEID._COMMANDS)'\n                 AGO    .BUILD_GBLENTRY\n.* ------------------------------------------------------------------ *\n.PROCESS_NO      ANOP\n&LPROCESS        SETC   'A(0)'\n.* ================================================================== *\n.BUILD_GBLENTRY      ANOP\n&GINDEX              SETA   &GINDEX+1\n                     AIF    (&GINDEX GT 1500).MNOTE16\n&LSORTKEY            SETC  '&LMSGID'.'            '\n&LSORTKEY            SETC  '&LSORTKEY'(1,12)\n&GSORTKEY(&GINDEX)   SETC  '&LSORTKEY'\n&GMSGID(&GINDEX)     SETC  '&LMSGID'\n&GFLAG1(&GINDEX)     SETC  '&LFLAG1'\n&GFLAG2(&GINDEX)     SETC  '&LFLAG2'\n&GFLAG3(&GINDEX)     SETC  '&LFLAG3'\n&GFLAG4(&GINDEX)     SETC  '&LFLAG4'\n&GFLAG5(&GINDEX)     SETC  '&LFLAG5'\n&GFLAG6(&GINDEX)     SETC  '&LFLAG6'\n&GFLAG7(&GINDEX)     SETC  '&LFLAG7'\n&GFLAG8(&GINDEX)     SETC  '&LFLAG8'\n&GMESSAGE(&GINDEX)   SETC  '&LMESSAGE'\n&GPROCESS(&GINDEX)   SETC  '&LPROCESS'\n&GLO(&GINDEX)        SETA  9999\n&GHI(&GINDEX)        SETA  9999\n&GDONE(&GINDEX)      SETB  0\n                     MEXIT\n.* ================================================================== *\n.SORT_TABLE   ANOP\n&GSET3        SETB   1\n&L1           SETA   1\n                  ACTR   (((&GINDEX-1)*&GINDEX)*9)/2\n&L5           SETA   (((&GINDEX-1)*&GINDEX)*9)/2\n.* ------------------------------------------------------------------ *\n.SORT_OUTERLOOP   ANOP\n&L2               SETA   &L1+1\n.* ------------------------------------------------------------------ *\n.SORT_INNERLOOP   ANOP\n                  AIF    ('&GSORTKEY(&L1)' LT '&GSORTKEY(&L2)').NEXT_L2\n                  AIF    ('&GSORTKEY(&L1)' EQ '&GSORTKEY(&L2)').MNOTE17\n.* ------------------------------------------------------------------ *\n.SWITCH   ANOP\n&LSORTKEY         SETC   '&GSORTKEY(&L2)'\n&LMSGID           SETC   '&GMSGID(&L2)'\n&LFLAG1           SETC   '&GFLAG1(&L2)'\n&LFLAG2           SETC   '&GFLAG2(&L2)'\n&LFLAG3           SETC   '&GFLAG3(&L2)'\n&LFLAG4           SETC   '&GFLAG4(&L2)'\n&LFLAG5           SETC   '&GFLAG5(&L2)'\n&LFLAG6           SETC   '&GFLAG6(&L2)'\n&LFLAG7           SETC   '&GFLAG7(&L2)'\n&LFLAG8           SETC   '&GFLAG8(&L2)'\n&LMESSAGE         SETC   '&GMESSAGE(&L2)'\n&LPROCESS         SETC   '&GPROCESS(&L2)'\n&GSORTKEY(&L2)    SETC   '&GSORTKEY(&L1)'\n&GMSGID(&L2)      SETC   '&GMSGID(&L1)'\n&GFLAG1(&L2)      SETC   '&GFLAG1(&L1)'\n&GFLAG2(&L2)      SETC   '&GFLAG2(&L1)'\n&GFLAG3(&L2)      SETC   '&GFLAG3(&L1)'\n&GFLAG4(&L2)      SETC   '&GFLAG4(&L1)'\n&GFLAG5(&L2)      SETC   '&GFLAG5(&L1)'\n&GFLAG6(&L2)      SETC   '&GFLAG6(&L1)'\n&GFLAG7(&L2)      SETC   '&GFLAG7(&L1)'\n&GFLAG8(&L2)      SETC   '&GFLAG8(&L1)'\n&GMESSAGE(&L2)    SETC   '&GMESSAGE(&L1)'\n&GPROCESS(&L2)    SETC   '&GPROCESS(&L1)'\n&GSORTKEY(&L1)    SETC   '&LSORTKEY'\n&GMSGID(&L1)      SETC   '&LMSGID'\n&GFLAG1(&L1)      SETC   '&LFLAG1'\n&GFLAG2(&L1)      SETC   '&LFLAG2'\n&GFLAG3(&L1)      SETC   '&LFLAG3'\n&GFLAG4(&L1)      SETC   '&LFLAG4'\n&GFLAG5(&L1)      SETC   '&LFLAG5'\n&GFLAG6(&L1)      SETC   '&LFLAG6'\n&GFLAG7(&L1)      SETC   '&LFLAG7'\n&GFLAG8(&L1)      SETC   '&LFLAG8'\n&GMESSAGE(&L1)    SETC   '&LMESSAGE'\n&GPROCESS(&L1)    SETC   '&LPROCESS'\n.* ------------------------------------------------------------------ *\n.NEXT_L2   ANOP\n&L2        SETA   &L2+1\n           AIF    (&L2 LE &GINDEX).SORT_INNERLOOP\n&L1        SETA   &L1+1\n           AIF    (&L1 LT &GINDEX).SORT_OUTERLOOP\n.* ================================================================== *\n.* THIS NEXT SET OF INSTRUCTIONS BUILDS THE ENTRIES FOR THE BINARY    *\n.* TREE.  SINCE THE TABLE HAS BEEN SORTED BY THE ABOVE ROUTINE, THE   *\n.* MESSAGE TABLE IS NOW ISOMORPHIC WITH THE NATURAL NUMBERS.  THUS,   *\n.* BY TAKING THE INTERVAL OF FROM 1 TO THE NUMBER OF ENTRIES, I.E.    *\n.* (MIN,MAX), AND, USING THE MIDPOINT OF THE INTERVAL, I CAN FIND THE *\n.* MIDPOINT.  NEXT, I HAVE THIS SET OF POINTS - (MIN,MID,MAX).        *\n.* AGAIN, I CAN FIND MIDPOINTS TO CREATE THIS SET OF POINTS:          *\n.*                                                                    *\n.*        (MIN,(MIN+MID)/2,MID,(MAX+MID)/2,MAX).                      *\n.*                                                                    *\n.* AS I CALCULATE THESE MIDPOINTS, THEY ARE STORED IN THE             *\n.* CORRESPONDING ENTRY IN THE SORTED TABLE AS &GLO &GHI.              *\n.*                                                                    *\n.* THE NEXT ITERATION WILL DETERMINE NEW MIDPOINTS BETWEEN THE POINTS *\n.* ESTABLISHED IN THE PREVIOUS ITERATION.                             *\n.* ================================================================== *\n&L1               SETA   1\n&L5               SETA   &GINDEX\n&L3               SETA   (&L5+&L1)/2\n&LSEED            SETA   &L3\n&L2               SETA   (&L3+&L1)/2\n&L4               SETA   (&L3+&L5)/2\n&GLO(&L3)         SETA   &L2\n&GHI(&L3)         SETA   &L4\n&GDONE(&L3)       SETB   1\n&GLO(1)           SETA   0\n&GHI(1)           SETA   0\n&GDONE(1)         SETB   1\n&GLO(&GINDEX)     SETA   0\n&GHI(&GINDEX)     SETA   0\n&GDONE(&GINDEX)   SETB   1\n&LTBL1(1)         SETA   &L1\n&LTBL1(2)         SETA   &L2\n&LTBL1(3)         SETA   &L3\n&LTBL1(4)         SETA   &L4\n&LTBL1(5)         SETA   &L5\n.* ================================================================== *\n&L1               SETA   6\n&L5               SETA   4\n.ACTR_LOOP        ANOP\n&L2               SETA   (&L5*2)+1\n                  AIF    (&L2 GT &GINDEX).END_ACTR\n&L5               SETA   &L5*2\n                  AGO    .ACTR_LOOP\n.END_ACTR         ANOP\n&L2               SETA   ((&L5*4)-1)*14\n                  ACTR   &L2\n.TREE_OUTERLOOP   ANOP\n&L2               SETA   1\n&L3               SETA   1\n.* ------------------------------------------------------------------ *\n.TREE_INNERLOOP   ANOP\n                  AIF    (&GDONE(&LTBL1(&L2))).ENTRY_DONE\n                  AIF    ((&LTBL1(&L2)-&LTBL1(&L2-1)) GT 1).USUAL_LOW\n                  AIF    (&LTBL1(&L2) GT 2).SET_NOLOW\n&GLO(2)           SETA   1\n&LTBL2(2)         SETA   2\n&L3               SETA   3\n                  AGO    .HIGH_TIME\n.SET_NOLOW        ANOP\n&L4               SETA   &LTBL1(&L2)\n&GLO(&L4)         SETA   0\n&LTBL2(&L3)       SETA   &LTBL1(&L2)\n&L3               SETA   &L3+1\n                  AGO    .HIGH_TIME\n.* ------------------------------------------------------------------ *\n.USUAL_LOW        ANOP\n&L4               SETA   ((&LTBL1(&L2)+&LTBL1(&L2-1)))/2\n&L5               SETA   &LTBL1(&L2)\n&GLO(&L5)         SETA   &L4\n&LTBL2(&L3)       SETA   &L4\n&L3               SETA   &L3+1\n&LTBL2(&L3)       SETA   &LTBL1(&L2)\n&L3               SETA   &L3+1\n.* ------------------------------------------------------------------ *\n.HIGH_TIME        ANOP\n                  AIF    ((&LTBL1(&L2+1)-&LTBL1(&L2)) GT 1).USUAL_HIGH\n                  AIF    (&LTBL1(&L2+1) NE &GINDEX).SET_NOHIGH\n&L4               SETA   &LTBL1(&L2)\n&GHI(&L4)         SETA   &GINDEX\n&GDONE(&L4)       SETB   1\n                  AGO    .INNER_LOOPEND\n.SET_NOHIGH       ANOP\n&L4               SETA   &LTBL1(&L2)\n&GHI(&L4)         SETA   0\n&GDONE(&L4)       SETB   1\n                  AGO    .INNER_LOOPEND\n.* ------------------------------------------------------------------ *\n.USUAL_HIGH       ANOP\n&L4               SETA   ((&LTBL1(&L2)+&LTBL1(&L2+1)))/2\n&L5               SETA   &LTBL1(&L2)\n&GHI(&L5)         SETA   &L4\n&LTBL2(&L3)       SETA   &L4\n&L3               SETA   &L3+1\n&L4               SETA   &LTBL1(&L2)\n&GDONE(&L4)       SETB   1\n                  AGO    .INNER_LOOPEND\n.* ------------------------------------------------------------------ *\n.ENTRY_DONE       ANOP\n&LTBL2(&L3)       SETA   &LTBL1(&L2)\n&L3               SETA   &L3+1\n.INNER_LOOPEND    ANOP\n&L2               SETA   &L2+1\n                  AIF    (&L2 LT &L1).TREE_INNERLOOP\n.* ------------------------------------------------------------------ *\n&L1               SETA   1\n&L4               SETA   0\n.MOVE_TABLES      ANOP\n&LTBL1(&L1)       SETA   &LTBL2(&L1)\n                  AIF    (NOT &GDONE(&L1)).NEXT_L1\n&L4               SETA   &L4+1\n.NEXT_L1          ANOP\n&L1               SETA   &L1+1\n                  AIF    (&L1 LT &L3).MOVE_TABLES\n                  AIF    (&L4 LT &GINDEX).TREE_OUTERLOOP\n.* ------------------------------------------------------------------ *\n&L1       SETA  1\n                   AIF   (&LSEED LT 10).LSEED_1\n                   AIF   (&LSEED LT 100).LSEED_2\n                   AIF   (&LSEED LT 1000).LSEED_3\nMESSAGE_TBLSEED    DC    A(MESSAGE_&LSEED)\n                   AGO   .SEED_SOURCE\n.LSEED_3           ANOP\nMESSAGE_TBLSEED    DC    A(MESSAGE_0&LSEED)\n                   AGO   .SEED_SOURCE\n.LSEED_2           ANOP\nMESSAGE_TBLSEED    DC    A(MESSAGE_00&LSEED)\n                   AGO   .SEED_SOURCE\n.LSEED_1           ANOP\nMESSAGE_TBLSEED    DC    A(MESSAGE_000&LSEED)\n.SEED_SOURCE       ANOP\nMESSAGE_TBLSTART   EQU   *\n.SOURCE_LOOP       ANOP\n&L2                SETA  &GLO(&L1)\n&L3                SETA  &GHI(&L1)\n                   AIF   (&L2 LT 10).L6_1\n                   AIF   (&L2 LT 100).L6_2\n                   AIF   (&L2 LT 1000).L6_3\n&L6                SETC  'MESSAGE_&L2'\n                   AGO   .L6_SOURCE\n.L6_3              ANOP\n&L6                SETC  'MESSAGE_0&L2'\n                   AGO   .L6_SOURCE\n.L6_2              ANOP\n&L6                SETC  'MESSAGE_00&L2'\n                   AGO   .L6_SOURCE\n.L6_1              ANOP\n&L6                SETC  'MESSAGE_000&L2'\n.L6_SOURCE         ANOP\n                   AIF   (&L3 LT 10).L7_1\n                   AIF   (&L3 LT 100).L7_2\n                   AIF   (&L3 LT 1000).L7_3\n&L7                SETC  'MESSAGE_&L3'\n                   AGO   .L7_SOURCE\n.L7_3              ANOP\n&L7                SETC  'MESSAGE_0&L3'\n                   AGO   .L7_SOURCE\n.L7_2              ANOP\n&L7                SETC  'MESSAGE_00&L3'\n                   AGO   .L7_SOURCE\n.L7_1              ANOP\n&L7                SETC  'MESSAGE_000&L3'\n.L7_SOURCE         ANOP\n&L8                SETC  '&GFLAG1(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG2(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG3(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG4(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG5(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG6(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG7(&L1)'.','\n&L8                SETC  '&L8'.'&GFLAG8(&L1)'\n&L9                SETC  '&L1'\n                   AIF   (&L1 LT 10).L9_1\n                   AIF   (&L1 LT 100).L9_2\n                   AIF   (&L1 LT 1000).L9_3\n&L9                SETC  'MESSAGE_&L9'\n                   AGO   .L9_SOURCE\n.L9_3              ANOP\n&L9                SETC  'MESSAGE_0&L9'\n                   AGO   .L9_SOURCE\n.L9_2              ANOP\n&L9                SETC  'MESSAGE_00&L9'\n                   AGO   .L9_SOURCE\n.L9_1              ANOP\n&L9                SETC  'MESSAGE_000&L9'\n.L9_SOURCE         ANOP\n&L9                DC    CL12'&GMSGID(&L1)'\n                   DC    AL1(&L8)\n                   DC    &GMESSAGE(&L1)\n                   DC    &GPROCESS(&L1)\n                   AIF   (&GLO(&L1) NE 0).SOURCE_LOW\n                   DC    A(0)\n                   AGO   .HIGH_SOURCE\n.SOURCE_LOW        ANOP\n                   DC    A(&L6)\n.HIGH_SOURCE       ANOP\n                   AIF   (&GHI(&L1) NE 0).SOURCE_HIGH\n                   DC    A(0)\n                   AGO   .CHECK_L1\n.SOURCE_HIGH       ANOP\n                   DC    A(&L7)\n.CHECK_L1          ANOP\n                   AIF   (&L1 GT 1).SOURCE_BYPASS\nMESSAGE_TBLENTRYLEN      EQU   *-&L9\n.SOURCE_BYPASS     ANOP\n&L1                SETA  &L1+1\n                   AIF   (&L1 LE &GINDEX).SOURCE_LOOP\nMESSAGE_TBLSTOP    EQU   *\n                   MEXIT\n.* ================================================================== *\n.MNOTE1   MNOTE 8,'MSGID NOT SPECIFIED'\n          MEXIT\n.* ================================================================== *\n.MNOTE2   MNOTE 8,'INVALID SETTING FOR FLAG1'\n          MEXIT\n.* ================================================================== *\n.MNOTE3   MNOTE 8,'INVALID SETTING FOR FLAG2'\n          MEXIT\n.* ================================================================== *\n.MNOTE4   MNOTE 8,'INVALID SETTING FOR FLAG3'\n          MEXIT\n.* ================================================================== *\n.MNOTE5   MNOTE 8,'INVALID SETTING FOR FLAG4'\n          MEXIT\n.* ================================================================== *\n.MNOTE6   MNOTE 8,'INVALID SETTING FOR FLAG5'\n          MEXIT\n.* ================================================================== *\n.MNOTE7   MNOTE 8,'INVALID SETTING FOR FLAG6'\n          MEXIT\n.* ================================================================== *\n.MNOTE8   MNOTE 8,'INVALID SETTING FOR FLAG7'\n          MEXIT\n.* ================================================================== *\n.MNOTE9   MNOTE 8,'INVALID SETTING FOR FLAG8'\n          MEXIT\n.* ================================================================== *\n.MNOTE10  MNOTE 8,'INVALID SETTING FOR MESSAGE'\n          MEXIT\n.* ================================================================== *\n.MNOTE11  MNOTE 8,'INVALID SETTING FOR PROCESS'\n          MEXIT\n.* ================================================================== *\n.MNOTE12  MNOTE 8,'FLAG1 IS ON AND MESSAGE IS OFF'\n          MEXIT\n.* ================================================================== *\n.MNOTE13  MNOTE 8,'FLAG2 IS ON AND PROCESS IS OFF'\n          MEXIT\n.* ================================================================== *\n.MNOTE14  ANOP\n          AIF   (&GSET4).MEXIT14\n          MNOTE   0,'THE ''MESSAGE_TBLSTOP'' ENTRY HAS BEEN DETECTED'\n          MNOTE   0,'THIS AND SUBSEQUENT INVOCATIONS WILL BE IGNORED'\n&GSET4    SETB    1\n.* ------------------------------------------------------------------ *\n.MEXIT14  ANOP\n          MEXIT\n.* ================================================================== *\n.MNOTE15  ANOP\n          AIF   (&GSET2).MEXIT15\n          MNOTE   0,'THE ''MESSAGE_TBLSTART'' ENTRY HAS NOT BEEN DETECT+\n               ED'\n          MNOTE   0,'THIS AND SUBSEQUENT INVOCATIONS WILL BE IGNORED'\n          MNOTE   0,'UNTIL THE ''MESSAGE_TBLSTART'' ENTRY IS DETECTED'\n&GSET2    SETB    1\n.* ------------------------------------------------------------------ *\n.MEXIT15  ANOP\n          MEXIT\n.* ================================================================== *\n.MNOTE16  ANOP\n          AIF   (&GSET6).MEXIT16\n&GSET5    SETB    1\n          MNOTE   0,'THIS TABLE HAS MORE THAN 1500 ENTRIES'\n          MNOTE   0,'SUBSEQUENT ENTRIES WILL BE IGNORED'\n          MNOTE   0,'EXCEPT FOR THE ''MESSAGE_TBLSTOP'' ENTRY'\n&GSET6    SETB    1\n.* ------------------------------------------------------------------ *\n.MEXIT16  ANOP\n          MEXIT\n.* ================================================================== *\n.MNOTE17   ANOP\n           MNOTE 8,'THIS TABLE HAS EQUAL KEYS'\n           MNOTE 8,'MESSAGE:  &GMSGID(&L1)'\n          MEXIT\n.* ================================================================== *\n.MNOTE18   ANOP\n           MNOTE 8,'BOTH FLAG3 AND FLAG4 CANNOT BE ON'\n          MEXIT\n.* ================================================================== *\n.MNOTE19   ANOP\n           MNOTE 8,'FLAG4 CANNOT BE ON AND PROCESS=NO'\n          MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT694/FILE694.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT694", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}