{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "TSAZFA", "INMTNODE": "JES2", "INMTUID": "TSAZFA", "INMFTIME": "20170928181409000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2998086, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "TSAZF.CBT.CBT495.FILE960.EXEC", "INMMEMBR": "TSAZF.CBT.CBT495.FILE960.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2998086, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2998086, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"TSAZF.CBT.CBT495.FILE960.EXEC": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00-\\x18H\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00-\\x18H\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00-\\x18H\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$LIST": {"ttr": 119, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00@\\x01\\x17$\\x0f\\x01\\x17%O\\x12Y\\x00]\\x006\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2017-08-28T00:00:00", "modifydate": "2017-09-11T12:59:40", "lines": 93, "newlines": 54, "modlines": 0, "user": "AL-FERG"}, "text": "FROM '&SYSUID..CBT.FILE960.EXEC'\n    ACEENAME - Pull Name field value from current ACEE\n    ALIASMC  - Initial Edit Macro to Setup various ISPF Edit command Aliases\n    ALL      - ISPF Macro to Display ALL\n    AR       - ISPF Macro to Display Rest\n    BR       - Point-N-Shoot Browse REXX\n               Works as both a REXX (useful as ISPF CMD) & Edit Macro\n    CDTINFO  - Use IBMs REXX R_Admin (IRRXUTIL) interface to get RACF info\n               on from the RACF CDT Class for dynamically defined Classes.\n               The order of information in this Class *CAN* inpact how/if\n               these Classes work properly. The R_Admin interface is the\n               only way to get the actual order these are defined to RACF!\n    CENTER   - Center selected records Macro\n    CHECKJOB - SDSF REXX to check the RCs of a JOBs STEPs and report back\n               on any issues found.\n    CMDLIST  - Display the list of ISPF Commands available for an APPID\n    CMDMAINT - Do Maintenace on the ISPF Commands available for an APPID\n    CMDTAG   - Convert an ISPF APPLID Command Table to DTL Format\n               (from before IBMs ISPCMDTB EXEC was available)\n    CNTL     - Edit ISPF temporary \".CNTL\" file\n    COMPPRF  - Compress ISPF Profile DSN, w/profile mbr compression\n    CR       - ISPF Macro to Change Rest\n    DATEX    - Date manipulation reXx\n    DB2DRAW  - \"DRAW\" a DB2 SELECT * WHERE as a NOTE in current session\n    DSLIST   - REXX that uses the Catalog Search Interface (CSI) to\n               programatically get a list of DSNs (and requested\n               information) directly from the system catalog. This does\n               not require TSO to function.\n    DSNS     - Point-N-Shoot Dataset List REXX, plus DSLIST capability\n               Works as both a REXX (useful as ISPF CMD) & Edit Macro\n    ED       - Point-N-Shoot Edit REXX\n               Works as both a REXX (useful as ISPF CMD) & Edit Macro\n    EDITLIBS - Edit/View various System Libraries by pulling information\n               from System Memory and then call the ML REXX to display\n               thier Member Lists. Works best as an ISPF CMD.\n    FIXMAC   - A sample ISPF Macro that can be called by MACREP to make\n               mass changes to the members of a PDS.\n    GDGCOPY  - Copies GDG in olders to newest order\n    GETSYSOT - SDSF REXX to extract SYSOUT DD output from a JOB.\n    HRECV    - Extract HSM Backup data & display for recovery\n    ISPTAG   - Convert an ISPF APPLID CMDS or KEY Table to DTL Format\n    ISPTIME  - Display current system Date & Time in an ISPF Message\n    KEYTAG   - Convert an ISPF APPLID PF Key List to DTL Format\n    LJUST    - Left JUSTify selected rows macro\n    MACLST   - ISPF Macro to EXECute the commands in the current Edit DSN.\n    MACREP   - REXX to repeat an ISPF Macro against every member of a PDS.\n    MACREPM  - Initial Edit Macro used by MACREP\n    MAN      - Display USS Man Page for a USS Unix command\n    MIGLEVEL - REXX using Catalog Search Interface (CSI) to ensure all\n               G00V0000s for a GDG are Migrated.\n    ML       - Point-N-Shoot PDS Member List REXX\n               Works as both a REXX (useful as ISPF CMD) & Edit Macro\n    MU       - Point-N-Shoot Member Utility (aka Muck-Up) REXX\n               Works as both a REXX (useful as ISPF CMD) & Edit Macro\n    PFKSET   - Used to manage/switch between different sets of user PF Keys\n    PK       - ISPF Macro to \"PeeK\" at DSN content in JCL\n    RACFACEE - Simple example of using IBMs RACF RACVAR REXX interface\n               to check for a valid ACEE for the current Address Space.\n    RACFGRPS - Extract list of Groups (RACF or TopSecret) from the current\n               Address Spaces ACEE.\n    RACFSTCS - Use IBMs REXX R_Admin (IRRXUTIL) interface to get RACF info\n               on the STCs defined in the RACF STARTED Class.\n    RACFVARS - Use IBMs REXX R_Admin (IRRXUTIL) interface to get RACF info\n               from the RACF RACFVARS Class.\n    REXXTRY  - My version to dynamicly trying a piece of REXX Code\n    RJUST    - Right JUSTify selected rows macro\n    SENDMAIL - REXX Socket program to send email to an SMTP Server.\n               (RFC implementation of SendMail Socket Client)\n    SETMSG   - Display passed string and ISPF Long Error Message\n    SETVAR   - Set an ISPF Profile Variable (useful as ISPF CMD)\n    SHFT     - ISPF Macro to shift selected rows Left or Right\n    SHOWVAR  - Show the value of an ISPF Profile Variable (useful as ISPF CMD)\n    SMPQREXX - Extract & Display information from SMP/E CSI\n    STARTUP  - Dynamically concatinate your ISPF/TSO DSNs infront of\n               those defined to LOGON PROC.\n    STUFFIT  - An ISPF Macro that compresses the current PDS\n    TOASCII  - Sample REXX calling USS to convert DSNs to ASCII (& back)\n    TSOVIEW  - Trap TSO Output and View (or Browse) it (useful as ISPF CMD)\n    TSOVSORT - Trap TSO Output, Sort Output, and View it\n    UMODCHCK - Verify all specified USERMODS are APPLIED to an SMP/E Zone\n    USSMAIL  - Read a pre-allocated email file and send via /bin/sendmail\n    USSMSG   - Display the meaning of a zOS USS RC | Error Code number\n    VSAMRD   - MVS REXX using Catalog Search Interface (CSI) to create\n               IDCAMS DELETE and DEFINE records for VSAM DSNs in a DSN\n               Filter Listing.\n    VSAMRDEF - MVS REXX using Catalog Search Interface (CSI) to create\n               IDCAMS DELETE and DEFINE records for VSAM DSNs in a DSN\n               Filter Listing.\n    VW       - Point-N-Shoot View REXX.\n               Works as both a REXX (useful as ISPF CMD) & Edit Macro\n    XR       - ISPF Macro to Exclude Rest\n    ZSTART   - Manage your ISPF ZSTART Variable via Edit\n    ZSTRTMAC - Initial ISPF Edit Macro used by ZSTART\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACEENAME": {"ttr": 111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x00R\\x01\\x00\\x13\\x0f\\x01\\x17%O\\x10)\\x01W\\x01M\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "2000-05-09T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 343, "newlines": 333, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX retrieves the RACF USER NAME from the current ACEE and\n      either displays it as an ISPF Message or RETURNs it to the\n      CALLing EXEC. This works under both RACF and CA-TopSecret.\n\nNOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\n                           --- EXAMPLE ---\nTSO <%>ACEENAME <TEST(TraceOption)>\nTSO <%>ACEENAME -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: Created for use in REXX Code Macros.\n             CCMASS   - Update Common REXX Code via COPYCODE in mass.\n             COPYCODE - Copies Common REXX Code from ISPSLIB\n             NV       - Standard REXX New Version/Change History\n\nEXEC History\n\n REXX EXEC Name: ACEENAME\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.28\n                 AL Hulsebosch (HUL2353)\n         Writen: 19JAN01\n        History: 06FEB17 - v1.36 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.35 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.34 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 02NOV15 - v1.32 - Updates to support full ACEE Name\n                           (works with RACF & TSS)\n                 19MAY01 - v1.00\n\n***************************** Rexx ***********************************/\nPARSE ARG InParms                            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nPARSE SOURCE . calltype .\nIF ABBREV(calltype, 'COMMAND') THEN\n     CALL SET_MSG , SYSUID\"'s RACF NAME is '\"GET_NAME()\"'.\", \"NO\"\nELSE RETURN GET_NAME()\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4                   /* NP-Parms match on first # chars  */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID=USERID()\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Go to the ADDRESS Spaces ACEE and Get the list of GROUPs\n***********************************************************************/\nGET_NAME:\n  ASXB_ptr  = STORAGE(224,4)\n  ASXB      = STORAGE(D2X(C2D(ASXB_ptr) + 108),4)\n  ACEE      = STORAGE(D2X(C2D(ASXB) + 200),4)\n  ACEE_name = STORAGE(D2X(C2D(ACEE) + 100),4)\nRETURN STORAGE(D2X(C2D(ACEE_name)+1),20)\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIASMC": {"ttr": 13, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x10\\x00R\\x00\\x99'/\\x01\\x17%O\\x10)\\x01\\x90\\x01f\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.16", "flags": 0, "createdate": "1999-09-29T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 400, "newlines": 358, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO is used to create a list of ALIASes for use with the\n        ED and MU REXXs. It can be used as an initial macro by entering\n        it in the INTIAL Macro field of the ISPF EDIT Option (Main Menu\n        Option 2) or by using the SETINIT Macro.\n\n   Creates the following ALIASes         for ISPF Macro\n                          A        ALIAS for ALL\n                          B        ALIAS for BR as a Macro\n                          CC       ALIAS for COPYCODE\n                          CEN      ALIAS for CENTER\n                          JC       ALIAS for JOBCARD\n                          LJ       ALIAS for LJUST\n                          M        ALIAS for MU as a Macro\n                          NN       ALIAS for NONUMS\n                          P        ALIAS for RPRINT\n                          RJ       ALIAS for RJUST\n                          S        ALIAS for ED as a Macro\n                          STUFF    ALIAS for STUFFIT\n                          SRCHFOR  ALIAS for Find\n                          TV       ALIAS for TSOVIEW\n                          V        ALIAS for VW   as a Macro\n                          XC       ALIAS for XCOM\n\n                       --- EXAMPLE ---\n<%>ALIASMC <TEST(TraceOption)>\n<%>ALIASMC -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n      Files: NONE\nOther EXECS: Can be used w/SETINIT to set Initial Macro in profile.\n             Also, part of REXX coding Macros:\n             ALIASMC  - Creates Aliases for REXX Coding Macros, etc.\n             CCMASS   - Update Common REXX Code via COPYCODE in mass.\n             CCMSTUB  - INIT Macro used by CCMASS to envoke COPYCODE.\n             COPYCODE - Copies Common REXX Code from ISPSLIB\n             NOARG    - Removes passed argument from Common REXX Code\n             NOCOPY   - Excludes /*COPY*/ commented Common REXX Code\n             NV       - Standard REXX New Version/Change History\n             XCOM     - Exclude Common REXX Code in current member\n\nEXEC History\n\nISPF MACRO Name: ALIASMC\n         Author: AL FERGUSON - TS ADM (TSAZFA) from v1.64\n                 FERGUSON AL (HUL2353) from v1.47\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 28JUN93\n        History: 15MAR17 - v2.02 - Add STUFFIT to list of Macro\n                           Aliases\n                 06FEB17 - v1.99 - Get updated version of Common Code.\n                 06JAN17 - v1.94 - Add XC ALIAS of XCOM\n                 23NOV16 - v1.83 - Updates to support Command/Macro\n                           versions of BR, ED, MU, & VIEW.\n                 04SEP16 - v1.72 - Fix HILITE with USS Files.\n                 04NOV15 - v1.64 - Add SRCHFOR as Alias to FIND.\n                 22FEB11 - v1.47 - Enable ISPF HILITEing.\n                 18MAY95 - v1.22 - Update all REXXes with current\n                           commom routines via %CCMASS\n                  2AUG94 - v1.20 - Add the PK alias for PEEK@ Macro\n                 19JUL93 - v1.06 - Add support for NOPANV Macro\n                           using alias 'NP'.\n                 28JUN93 - v1.00\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) PROCESS\"\n\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0'\n  ADDRESS \"ISREDIT\" \"RESET\"\n  ADDRESS \"ISREDIT\" \"RECOVERY ON\"\n  ADDRESS \"ISREDIT\" \"DEF A       ALIAS ALL     \"\n  ADDRESS \"ISREDIT\" \"DEF B       ALIAS BR      \"\n  ADDRESS \"ISREDIT\" \"DEF CC      ALIAS COPYCODE\"\n  ADDRESS \"ISREDIT\" \"DEF CEN     ALIAS CENTER  \"\n  ADDRESS \"ISREDIT\" \"DEF JC      ALIAS JOBCARD \"\n  ADDRESS \"ISREDIT\" \"DEF LJ      ALIAS LJUST   \"\n  ADDRESS \"ISREDIT\" \"DEF M       ALIAS MU      \"\n  ADDRESS \"ISREDIT\" \"DEF NN      ALIAS NONUMS  \"\n  ADDRESS \"ISREDIT\" \"DEF P       ALIAS RPRINT  \"\n  ADDRESS \"ISREDIT\" \"DEF RJ      ALIAS RJUST   \"\n  ADDRESS \"ISREDIT\" \"DEF RP      ALIAS RPRINT  \"\n  ADDRESS \"ISREDIT\" \"DEF S       ALIAS ED      \"\n  ADDRESS \"ISREDIT\" \"DEF STUFF   ALIAS STUFFIT\"\n  ADDRESS \"ISREDIT\" \"DEF SRCHFOR ALIAS FIND\"\n  ADDRESS \"ISREDIT\" \"DEF TV      ALIAS TSOVIEW \"\n  ADDRESS \"ISREDIT\" \"DEF V       ALIAS VW      \"\n  ADDRESS \"ISREDIT\" \"DEF XC      ALIAS XCOM    \"\n  ADDRESS \"ISREDIT\" \"SETU KEEP\"\n\nok='0 12';ADDRESS \"ISREDIT\" \"HILITE RESET\"\nIF RC = 0 THEN DO     /* Check because USS Files don't support HILITE */\n   ADDRESS \"ISREDIT\" \"(DsName) = DATASET\"\n   SELECT\n     WHEN INDEX(DsName,\"EXEC\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE REXX\"\n     WHEN INDEX(DsName,\"REXX\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE REXX\"\n     WHEN INDEX(DsName,\"RULES\") > 0 THEN ADDRESS \"ISREDIT\" \"HILITE REXX\"\n     WHEN INDEX(DsName,\"COBOL\") > 0 THEN ADDRESS \"ISREDIT\" \"HILITE COBOL\"\n     WHEN INDEX(DsName,\".PLI\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE PLI\"\n     WHEN INDEX(DsName,\".DTL\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE DTL\"\n     WHEN INDEX(DsName,\".ISPG\") > 0 THEN ADDRESS \"ISREDIT\" \"HILITE DTL\"\n     WHEN INDEX(DsName,\".ISPS\") > 0 THEN ADDRESS \"ISREDIT\" \"HILITE SKEL\"\n     WHEN INDEX(DsName,\"SENU\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE SKEL\"\n     WHEN INDEX(DsName,\".SRC\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE COBOL\"\n     WHEN INDEX(DsName,\"HTML\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE HTML\"\n     WHEN INDEX(DsName,\"BOOK\")  > 0 THEN ADDRESS \"ISREDIT\" \"HILITE BOOK\"\n   OTHERWISE; NOP; END\n   ADDRESS \"ISREDIT\" \"HILITE PAREN\"\n   ok='*';ADDRESS \"ISREDIT\" \"HILITE LOGIC\"\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4                  /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALL": {"ttr": 15, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x01\\x19\\x01\"\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 281, "newlines": 290, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO displays all lines that contain a given string. A\n        simplified version of IBM's ONLY Macro (created before ONLY).\n        I have had better luck when using ISPF Regex FIND strings\n        with this version.\n\n   It should produce the same results as IBM's \"ONLY\" command found\n        in 'ISP.SISPEXEC(ONLY)' after USERMOD APPLYed to move from\n        'ISP.SISPSAMP(ONLY)' (where IBM Delivers it now).\n\n                           --- EXAMPLE ---\n<%>ALL allarg <TEST(TraceOption)>\n<%>ALL -H -- To display help for this ISPF Macro\n\n  Arguments: allarg      - String to search for.\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: Current EDIT file\nOther EXECS: NONE\n\nEXEC History\n\nISPF MACRO Name: ALL\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.19\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 18JUN93\n        History: 27AUG17 - v1.32 - Update Comments & minor refactoring\n                 31JAN17 - v1.19 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.16 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 04NOV93 - v1.13 - Support added for NP-Parms and\n                           search arguments with ampersands. Ampersand\n                           support possible with a idea from Pete V.\n                           (TTECPV1)\n                 29OCT93 - v1.07 - Fix to trap instances where no\n                           string is passed, i.e. all issued with no\n                           parameters.\n                 23JUN93 - v1.03 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18JUN93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (allarg) PROCESS\"\nPARSE UPPER VALUE allarg WITH allarg 'TEST(' TEST ')' .\n\nCALL INITIALIZE_THIS_REXX\nIF WORDPOS(allarg, '-h -H') > 0 THEN CALL DISPLAY_HELP\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 4'                               /* Acceptable ISREDIT RCs      */\nIF allarg = '' THEN\n   CALL SET_MSG \"All WHAT?\",\"All requires a string to search for!\",\"YES\"\nELSE DO\n    orig_string=allarg\n    IF INDEX(allarg,'&') > 0 THEN allarg=AMPER_HANDLING(allarg)\n\n    ADDRESS \"ISREDIT\" \"EXCLUDE ALL\"\n    ADDRESS \"ISREDIT\" \"FIND\" allarg \"ALL X\"\n    ExitError=RC                       /* Exit ISREDIT FIND RC        */\n    ADDRESS \"ISREDIT\" \"(var1,var2) = FIND_COUNTS\"\n\n    CALL SET_MSG \"All showing.\",\"Found and displaying\" STRIP(var1,\"L\",\"0\"),\n                 \"occurances of the string --\" orig_string,\n                 \"-- on\" STRIP(var2,\"L\",\"0\") \"lines.\",\"NO\"\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0    /* REXX functional values for TRUE and FALSE */\n  ExitError=0\n\nRETURN\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY AMPERHAN */\n/********************************************************************** /*COPY*/\n  Handle Ampersands in ISREDIT strings within Macros Assumes String     /*COPY*/\n     being processed containes an ampersand. To Ensure this use:        /*COPY*/\n  IF INDEX(string,'&') > 0 THEN string = AMPER_HANDLING(string)         /*COPY*/\n***********************************************************************//*COPY*/\nAMPER_HANDLING: PROCEDURE                                               /*COPY*/\nARG Process                                                             /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN SUBSTR(Process,1,1) = \"'\" THEN Process = STRIP(Process,\"B\",\"'\") /*COPY*/\n   WHEN SUBSTR(Process,1,1) = '\"' THEN Process = STRIP(Process,\"B\",'\"') /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\nRETURN \"X'\"C2X(Process)\"'\"                                              /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AR": {"ttr": 17, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01&\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x01&\\x01+\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.38", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 294, "newlines": 299, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO display all records after current cursor possition\n        which contain the given string.  Works with selected lines as\n        well.  AR is the opposite of XR.\n\n                           --- EXAMPLE ---\n<%>AR allarg <TEST(TraceOption)>\n<%>AR -H -- To display help for this ISPF Macro\n\n  Arguments: allarg      - Search Argument\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n      Files: Current EDIT file\nOther EXECS: NONE\n\nEXEC History\n\nISPF MACRO Name: AR -- All Rest\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.19\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 18JUN93\n        History: 06FEB17 - v1.32 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.20 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.19 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.14 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                  4NOV93 - v1.11 - Support added for NP-Parms and\n                           search arguments with ampersands. Ampersand\n                           support possible with a hint from Pete V.\n                           (TTECPV1)\n                 15JUL93 - v1.08 - Fix to handle single record SETs\n                 23JUN93 - v1.06 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 18JUN93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (allarg) NOPROCESS\"\nPARSE UPPER VALUE allarg WITH allarg 'TEST(' TEST ')' .\n\nIF WORDPOS(allarg, '-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 4 16';ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nok='0'\nIF RC = 0 THEN DO\n   ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFRANGE\"\n   ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLRANGE\"\n   ADDRESS \"ISREDIT\" \"RESET COMMAND\"\n  END\nELSE DO\n   ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZCSR\"\n   ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLAST\"\nEND\nADDRESS \"ISREDIT\" \"LABEL\" first \"= .FLINE\"\n\nIF first \u00ac= last THEN DO\n    ADDRESS \"ISREDIT\" \"LABEL\" last \"= .LLINE\"\n    last_label = \".LLINE\"\n  END\nELSE last_label = \".FLINE\"\nok='0 4 8 20';ADDRESS \"ISREDIT\" \"X P'=' .FLINE\" last_label \"ALL\"\n\norig_string = allarg\nIF INDEX(allarg, '&') > 0 THEN allarg = AMPER_HANDLING(allarg)\nok='0 4'\n  ADDRESS \"ISREDIT\" \"FIND\" allarg \".FLINE\" last_label \"ALL X\"\n  ADDRESS \"ISREDIT\" \"(var1,var2) = FIND_COUNTS\"\nCALL SET_MSG \"All showing.\",\"Found and displaying\" STRIP(var1,\"L\",\"0\"),\n             \"occurances of the string --\" orig_string,\n             \"-- on\" STRIP(var2,\"L\",\"0\") \"lines.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; NbrSubmited = 0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY AMPERHAN */\n/********************************************************************** /*COPY*/\n  Handle Ampersands in ISREDIT strings within Macros Assumes String     /*COPY*/\n     being processed containes an ampersand. To Ensure this use:        /*COPY*/\n  IF INDEX(string,'&') > 0 THEN string = AMPER_HANDLING(string)         /*COPY*/\n***********************************************************************//*COPY*/\nAMPER_HANDLING: PROCEDURE                                               /*COPY*/\nARG Process                                                             /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN SUBSTR(Process,1,1) = \"'\" THEN Process = STRIP(Process,\"B\",\"'\") /*COPY*/\n   WHEN SUBSTR(Process,1,1) = '\"' THEN Process = STRIP(Process,\"B\",'\"') /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\nRETURN \"X'\"C2X(Process)\"'\"                                              /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BR": {"ttr": 147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x03\\x003\\x01\\x02\\x03o\\x01\\x17'\\x1f\\x13\\x13\\x02\\x04\\x01\\xb5\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.03", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-28T13:13:33", "lines": 516, "newlines": 437, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF Macro supports full screen Point-N-Shoot. To improve\n        this functionality, assign it to a PFKey, add it as an ISPF CMD,\n        or, better yet, do both! If this is envoked as an ISPF Macro and\n        a valid dataset is not passed (via PARM or Cursor Position), it\n        will Browse the current DSN or member, if one is passed.\n\n   This REXX/ISPF MACRO supports multiple BROWSE levels, so you may\n        BROWSE a dataset from within another.\n\n   This REXX/ISPF MACRO supports member list patern matching, i.e.  If\n        it is envoked with a DSN of highlev.lowlev(AB*) it will display\n        a member list for the PDS of all members starting with AB.  If\n        it is envoked with a DSN of highlev.lowlev(AB%) it will display\n        a member list for the PDS of all members starting with AB and are\n        three characters in length.\n\n                       --- EXAMPLE as TSO CMD ---\nTSO <%>BR  dsname  <TEST(valid REXX trace option)> <VOLSER(volser)>\n                     --- EXAMPLE as ISPF Macro ---\n    <%>BR <dsname> <TEST(valid REXX trace option)> <VOLSER(volser)>\n<TSO> <%>BR -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: dsname      - Dataset to BROWSE\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n                  VOLSER - Volume Serial Number to display DSNs for.\n                           default:  blank (display cataloged DSNs only)\n\n      Files: The EXEC BROWSEs the DSN provided as an argument\nOther EXECS: None\n\nEXEC History\n\nEXEC/MACRO Name: BR\n         Author: AL FERGUSON - TS ADM (TSAZFA) from v3.12\n                 FERGUSON AL (HUL2353) from v3.00\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 30DEC92\n        History: 28SEP17 - v4.00 - More Point-N-Shoot Fixes.\n                 21JUN17 - v3.89 - Cleanup point & shoot, plus add\n                           support for ZCURWID ISPF System Variable.\n                 19MAY17 - v3.86 - Keep Cursor Col & Advance Row when\n                           invoked as Macro.\n                 13MAR17 - v3.78 - More Point-N-Shoot corrections.\n                 06FEB17 - v3.54 - Fix Point-N-Shoot math.\n                 06FEB17 - v3.43 - Pick up updated version of ERRINFO\n                           Common Code routines.\n                 01FEB17 - v3.38 - Mass update for Error Handling Fixes.\n                 31JAN17 - v3.37 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 26JAN17 - v3.37 - Tweak Point & Shoot logic.\n                 23NOV16 - v3.28 - Tweak Point-n-Shoot math\n                 22NOV16 - v3.21 - Rewrite of Point and shoot section\n                           to make work as an ISPF Command when not in\n                           an edit session.\n                 10AUG16 - v3.19 - More Support use against DDs.\n                 05AUG16 - v3.12 - Support for DDs vs DSNs\n                 14FEB11 - v3.04 - Point & Shoot for USS PATHs.\n                 13MAR09 - v3.00 - Support for USS Files\n                 29APR96 - v2.19 - Support VOLUME specific DSNs.\n                 18MAY95 - v2.08 - Update all REXXes with latest\n                           commom routines via %CCMASS\n                 03MAR94 - v2.06 - Support exit_error use by MU.\n                 10NOV93 - v2.04 - Fix '-h' from a Macro invocation\n                 13AUG93 - v2.02 - Fix to point & shot routine.\n                 23JUN93 - v2.00 - Update all REXXes with latest\n                           commom routines via %CCMASS\n                 26MAY93 - v1.60 - Fixs and more point&shoot DSN formats\n                 16MAR93 - v1.50 - Modify logic/program flow,\n                           point & EDIT support, use of ED01 panel\n                 22MAR93 - v1.40 - Support for member list patern\n                           matching using * and %\n                 16MAR93 - v1.30 - Modify logic/program flow\n                           point & BROWSE support\n                 30DEC92 - v1.20 - ISPF ERROR MSG and NPARMs\n                 01SEP92 - v1.10 - TSO REXX or ISPF BROWSE MACRO\n                 01AUG92 - v1.00 - ISPF BROWSE MACRO only\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG DsName InParms\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF ABBREV('.',DsName)          THEN DO; DsName=\"\"; CALL INVOKE_AS_MACRO; END\nIF DsName = ''                 THEN EXIT\n   ELSE                             CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0 12 14 16 20'\n  ADDRESS \"ISPEXEC\" \"BROWSE\" PROCESS_DSNAME(DsName)\nSELECT\n  WHEN RC = 0  THEN\n    IF IsMacro THEN ADDRESS \"ISREDIT\" \"CURSOR =\"RowPos+1 CurPos\n  WHEN RC = 14 THEN CALL SET_MSG 'Dataset in USE!', DsName '--' ZERRLM\n  WHEN RC = 16 THEN CALL SET_MSG \"No Members in PDS!\", DsName '--' ZERRLM\nOTHERWISE\n   CALL SET_MSG \"Can't %BR this DSN!\", DsName '--' ZERRLM, \"YES\"\n   ExitErr=021\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This INITIALIZEs any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n  ADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL)\"\n  SELECT              /* Support ISPF 3.4/DSLIST VOLSERs              */\n    WHEN RC \u00ac= 0                   THEN NOP\n    WHEN ABBREV(\"*ALIAS\", ZDLVOL)  THEN InParms = InParms \"VOLSER()\"\n    WHEN ABBREV(DsName, \"'\"ZDLDSN) THEN InParms = InParms \"VOLSER(\"ZDLVOL\")\"\n  OTHERWISE; NOP; END\n                                    /* Initialize NonPositional parms */\n  ValidParms=\"TEST(O) VOLSER()\"\n  MatchLength=4                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitErr=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  IF VOLSER = \"\" THEN ADDRESS \"ISPEXEC\" \"VGET (VOLSER) SHARED\"\n  response=''; member=''\n  IF IsMacro \u00ac= TRUE THEN IsMacro=FALSE\nRETURN\n/* COPY PNTNSHOT */\n/********************************************************************** /*COPY*/\n             If no arguments, was it envoked as a MACRO                 /*COPY*/\n**********************************************************************/ /*COPY*/\nINVOKE_AS_MACRO:                                                        /*COPY*/\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"                                        /*COPY*/\n  IF RC \u00ac= 0 THEN RETURN                                                /*COPY*/\n  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */ /*COPY*/\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"                  /*COPY*/\n  IF RC = 0 THEN DO                                                     /*COPY*/\n     IsMacro=TRUE                                                       /*COPY*/\n     ADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"                             /*COPY*/\n     ADDRESS \"ISREDIT\" \"(RowPos,CurPos) = CURSOR\"                       /*COPY*/\n     IF DsName = \"\" & RowPos = 1 & CurPos = 0 THEN DsName=\"'\"PdsDsn\"'\"  /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO; IsMacro=FALSE; PdsDsn=\"\"; END                                /*COPY*/\n  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/\n                                                                        /*COPY*/\n  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/\n  IF ABBREV(PDS,\"'\")           THEN PDS=STRIP(PDS,\"T\",\"'\")\"'\"           /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN DsName = \"\"           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/\n    WHEN ABBREV(DsName,\"DD:\")  THEN NOP                                 /*COPY*/\n    WHEN ABBREV(DsName,\"dd:\")  THEN NOP                                 /*COPY*/\n    WHEN POS(\"/\",DsName) > 0   THEN NOP                                 /*COPY*/\n    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"          THEN DsName=\"'\"PdsDsn\"(\"DsName\")'\"       /*COPY*/\n  OTHERWISE;                        NOP; END                            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_POINT_N_SHOOT:                                                       /*COPY*/\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"                  /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn                        /*COPY*/\n  OTHERWISE;                       RETURN \"\"; END                       /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/\n    WHEN POS(\"='\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"='\" word . \"'\"                        /*COPY*/\n    WHEN POS(\"DSN=\",word) > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"                     /*COPY*/\n    WHEN POS(\"=\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH   \"=\" word . \",\"                        /*COPY*/\n    WHEN POS(\"''\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"''\" word . \"'\"                        /*COPY*/\n    WHEN ABBREV(word,'\"//')   THEN                                      /*COPY*/\n       PARSE VALUE word    WITH \"//\" word . '\"'                         /*COPY*/\n    WHEN POS(\"(\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"                        /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word          /*COPY*/\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word          /*COPY*/\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN       /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"                                     /*COPY*/\n    WHEN PdsDsn                        \u00ac= ''   THEN DO                  /*COPY*/\n         DsNme=\"'\"PdsDsn\"'\"; filter=word                                /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; DsNme = \"\"; END                                            /*COPY*/\nRETURN DsNme                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_CURRENT_LINE:                                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"        /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC = 0 & \u00ac(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/\n    WHEN IsMacro                                THEN DO                 /*COPY*/\n       ADDRESS \"ISREDIT\" \"(Line) = LINE\" RowPos                         /*COPY*/\n       RETURN Line                                                      /*COPY*/\n      END                                                               /*COPY*/\n    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/\n         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/\n       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/\n       IF ABBREV(LstLn,\"***\")                   THEN Wdth=ZSCREENW+8    /*COPY*/\n          ELSE                                       Wdth=ZSCREENW      /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/\n       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/\n     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/\n  END                                                                   /*COPY*/\n  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth),\" \",\",\")         /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC \u00ac= 0                   THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/\n        ELSE                           ZERRALRM='NO'                    /*COPY*/\n     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                     /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Process DsName and return ISPF Allocation Type\n***********************************************************************/\nPROCESS_DSNAME:\nPARSE ARG PDS '(' member ')' .\n  SELECT\n    WHEN ABBREV(PDS, \"DD:\")   |,\n         ABBREV(PDS, \"dd:\")   THEN DO\n       ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DDNAME(\"SUBSTR(PDS,4)\") ENQ(SHRW)\"\n       IF member = \"\" THEN         _type_ = \"DATAID(\"id\")\"\n          ELSE                     _type_ = \"DATAID(\"id\") MEMBER(\"member\")\"\n      END\n    WHEN INDEX(PDS,\"/\") > 0   THEN _type_ = \"FILE(PDS)\"\n    WHEN INDEX(PDS,\"'\") > 0   &,\n         (member = \"\")        THEN _type_ = \"DATASET(\"STRIP(PDS,\"T\",\"'\")\"')\"\n    WHEN INDEX(PDS,\"'\") > 0   THEN\n         _type_ = \"DATASET(\"STRIP(PDS,\"T\",\"'\")\"(\"member\")')\"\n    WHEN (member = \"\")        THEN _type_ = \"DATASET(\"PDS\")\"\n  OTHERWISE;                       _type_ = \"DATASET(\"PDS\"(\"member\"))\"; END\n  IF VOLSER \u00ac= \"\" THEN _type_ = _type_ \"VOLUME(\"VOLSER\")\"\nRETURN _type_\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CDTINFO": {"ttr": 101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x18\\x00R\\x00\\x99'\\x1f\\x01\\x17%O\\x10)\\x01\\x82\\x01\\xd0\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.24", "flags": 0, "createdate": "1999-09-28T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 386, "newlines": 464, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX displays information about RACF Dynamic Class via the\n        IRRXUTIL R_Admin Interface.\n\n  This REXX uses the RACF REXX R_Admin interface (IRRXUTIL). For more\n       docmucmentation see the \"Security Server RACF Macros and\n       Interfaces\" Manual (Chapter 14). Relevent check code starts at\n       line 48 and runs to the EXIT in line 68.\n NOTE: This REXX uses the IRRXUTIL R_Admin Interface.  READ Access to\n       the RACF profile protecting the FACILITY IRR.RADMIN.RLIST\n       resource is required to use the IRRXUTIL interface.\n\n                           --- EXAMPLE ---\nTSO <%>CDTINFO <TEST(TraceOption)>\nTSO <%>CDTINFO -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: None\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: CDTINFO\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 2.04\n                 FERGUSON AL (HUL2353)\n         Writen: 27APR10\n        History: 06FEB17 - v2.06 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v2.05 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v2.04 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 09AUG10 - v2.01 - Fix First Character and Other\n                           Character display\n                 09AUG10 - v1.99 - Fix First Character and Other\n                           Character display\n                 27APR10 - v1.0\n***************************** Rexx ***********************************/\nPARSE ARG InParms            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n   profile = LEFT(\"\",8)   /* EXTRACTN w/blank Profile = 1st profile   */\n/* rc = IRRXUTIL(command,type,profile,stem,prefix,generic)            */\n   rc=IRRXUTIL(\"EXTRACTN\",\"CDT\",profile,\"stem\",\"\",\"FALSE\")\n\nIF ABBREV(rc, \"0\") THEN DO i=1 UNTIL \u00ac(ABBREV(rc, \"0\"))\n   SELECT\n     WHEN stem.CDTINFO.CDTGROUP.1 \u00ac= \"\"    THEN\n       SAY RIGHT(\"PROFILE:\" ,9) LEFT(stem.PROFILE,8)        ,\n           \"POSIT:\" RIGHT(stem.CDTINFO.CDTPOSIT.1,3)        ,\n           \"OWNER:\" LEFT(stem.BASE.OWNER.1,8)               ,\n           \"GRPCLASS:\" stem.CDTINFO.CDTGROUP.1\n     WHEN stem.CDTINFO.CDTMEMBR.1 \u00ac= \"\"    THEN\n       SAY RIGHT(\"PROFILE:\" ,9) LEFT(stem.PROFILE,8)        ,\n           \"POSIT:\" RIGHT(stem.CDTINFO.CDTPOSIT.1,3)        ,\n           \"OWNER:\" LEFT(stem.BASE.OWNER.1,8)               ,\n           \"MBRCLASS:\" stem.CDTINFO.CDTMEMBR.1\n   OTHERWISE\n       SAY RIGHT(\"PROFILE:\" ,9) LEFT(stem.PROFILE,8)        ,\n           \"POSIT:\" RIGHT(stem.CDTINFO.CDTPOSIT.1,3)        ,\n           \"OWNER:\" LEFT(stem.BASE.OWNER.1,8)\n   END\n   IF stem.BASE.DATA.1 \u00ac= \"\"               THEN\n       SAY RIGHT(\"DATA:\",9) stem.BASE.DATA.1\n   SAY RIGHT(\"UACC:\"    ,9) stem.CDTINFO.CDTUACC.1          ,\n       RIGHT(\"OPER:\"    ,9) stem.CDTINFO.CDTOPER.1          ,\n       RIGHT(\"DfltRC:\"  ,9) stem.CDTINFO.CDTDFTRC.1\n   SAY RIGHT(\"CASE:\"    ,9) stem.CDTINFO.CDTCASE.1          ,\n       RIGHT(\"MAXLN:\"   ,9) stem.CDTINFO.CDTMAXLN.1         ,\n       RIGHT(\"MAXLX:\"   ,9) stem.CDTINFO.CDTMAXLX.1\n   _nxt_ = RIGHT(\"FIRST:\",9)\n   DO j=1 TO stem.CDTINFO.CDTFIRST.0;_nxt_=_nxt_ stem.CDTINFO.CDTFIRST.j;END\n   _nxt_ = _nxt_ \" OTHER:\"\n   DO j=1 TO stem.CDTINFO.CDTOTHER.0;_nxt_=_nxt_ stem.CDTINFO.CDTOTHER.j;END\n   SAY _nxt_\n   SAY RIGHT(\"GENERIC:\" ,9) LEFT(stem.CDTINFO.CDTGEN.1 ,10) ,\n       RIGHT(\"GENLIST:\" ,9) LEFT(stem.CDTINFO.CDTGENL.1,10) ,\n       RIGHT(\"RACLIST:\" ,9) LEFT(stem.CDTINFO.CDTRACL.1,10) ,\n       RIGHT(\"MACPROC:\" ,9) stem.CDTINFO.CDTMAC.1\n   IF stem.CDTINFO.CDTKEYQL.1 > 0          THEN\n      SAY RIGHT(\"KEYQUAL:\" ,9) stem.CDTINFO.CDTKEYQL.1\n   IF stem.CDTINFO.CDTOTHER.1 > 0          THEN\n      SAY RIGHT(\"OTHER:\"   ,9) stem.CDTINFO.CDTOTHER.1\n   IF ABBREV(stem.CDTINFO.CDTPRFAL.1,\"NO\") THEN\n      SAY \" No PROFILEs Allowed in the Class!\"\n   SAY LEFT(\"\",80,\"-\")\n   rc=IRRXUTIL(\"EXTRACTN\",\"CDT\",stem.PROFILE,\"stem\",\"\",\"FALSE\")\n  END\nELSE CALL SET_MSG ,\"EXTRACT rc=\"rc,\"NO\"\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4        /* NP-Parms match on first # chars             */\n  AcceptAll=FALSE      /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited=0\n  SYSUID=USERID()\n  UserPrefix=LEFT(SYSUID,4)\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname=MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CENTER": {"ttr": 19, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x01o\\x01p\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 367, "newlines": 368, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO centers a row or set of rows between the left and\n        the right edges of the current EDIT member.\n\n                           --- EXAMPLE ---\n<%>CENTER <TEST(TraceOption)> parm1 parm2\n<%>CENTER -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n ------------------------- Positional  PARMS --------------------------\n             parm1       - If parm2 blank then width to center on, else\n                           the colume to move centered string.\n             parm2       - If non-blank, the ending colume for centered\n                           string (parm2 - parm1 + 1 is the width to center\n                           on).\n\n      Files: The current EDIT member\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: CENTER\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.17\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 14JUN93\n        History: 06FEB17 - v1.19 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.18 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.17 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.07 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 23JUN93 - v1.01 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 14JUN93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) NOPROCESS\"\n\nCALL INITIALIZE_THIS_REXX\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 4 16';ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nIF RC = 0 THEN DO\n    ok='0';ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFRANGE\"\n    ok='0';ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLRANGE\"\n    ok='0';ADDRESS \"ISREDIT\" \"RESET COMMAND\"\n    ok='0';ADDRESS \"ISREDIT\" \"(line) = LINE\" first\n    ok='0';ADDRESS \"ISREDIT\" \"LINE\" first '= \"'line'\"'\n    DO i = first TO last\n        ADDRESS \"ISREDIT\" \"(tobecntr) = LINE\" i\n        centered = LEFT(\"\",offset) || CENTER(STRIP(tobecntr), width)\n        ADDRESS \"ISREDIT\" \"LINE\" i '= \"'centered'\"'\n    END\nEND\nCALL SET_MSG \"Lines centered.\", STRIP(last - first + 1,\"L\",\"0\") \"lines\",\n     \"have been centered.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n                    /* Initialize and process non-positional parms   */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4                 /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  PARSE VALUE AnythingElse WITH parm1 parm2 .\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n\n  SELECT\n    WHEN parm1 = '' THEN DO\n        ADDRESS \"ISREDIT\" \"(width) = LRECL\"\n        offset = 0\n      END\n    WHEN parm2 = '' THEN DO\n        width = parm1\n        offset = 0\n      END\n  OTHERWISE\n      width = parm2 - parm1 + 1\n      offset = parm1\n  END\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHECKJOB": {"ttr": 21, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x015\\x00R\\x01\\x17\\x13\\x0f\\x01\\x17%O\\x10)\\x00n\\x00\\x19\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.53", "flags": 0, "createdate": "2017-05-10T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 110, "newlines": 25, "modlines": 0, "user": "AL-FERG"}, "text": "/******************************** REXX ********************************\n  This REXX runs under TSO using:\n     - The SDSF REXX Interface to retrieve the current JOBS JESMSGLG.\n     - The BPXWUNIX Interface w/grep to search for unacceptable STEP RCs.\n     - Finally it writes any found out to the ....@SCCNTL.BUILD Library\n       as a @#sys##X member (@#sys## is current JOB) identifying the\n       issue and which Listing to use for more details.\n\n  This REXX Requires TSO because it uses:\n       - The PDS/PDS86 program from http://CBTTape.org\n       - The SDSF REXX Interface\n  This REXX also uses:\n       - MVS to writes the create @#sys##X Members\n       - USS BPXWUNIX interface to the /bin/grep & /bin/sed commands\n\n NOTE: This REXX requires use of CCID IBM-1047 to ensure Regex strings\n       function correctly (square Brackets & not character).\n\n ******************************** Rexx ********************************/\nTRACE(\"O\")                     /* Set REXX TRACE for Debugging        */\nMsgStat=MSG(\"OFF\")\nARG RptDsn Type . 1 RptPds '(' RptMbr ')' . 1 RptHlq '@' .\n  CALL INITIALIZE_REXX\n  CALL GET_CURRENT_JESMSGLG\n  CALL CHECK_FOR_ERRORS\n  IF Issues.0 > 0 THEN DO\n     IssuesFound = TRUE\n     CALL FORMAT_JESJOBS\n     CALL WRITE_ISSUES\n    END\n  ELSE DO\n     IssuesFound = FALSE\n     SAY \" No Issues discovered for this JOB.\"\n     ADDRESS \"TSO\" \"PDS '\"RptPds\"' DEL\" RptMbr\n  END\nMsgStat=MSG(MsgStat)\nEXIT IssuesFound\n/*\n       Setup Various Variable to be used by this REXX\n*/\nINITIALIZE_REXX:\n  TRUE=1; FALSE=0\n  Env.=\"\"; Env.0=2; Env.1=\"_UNIX03=YES\"; Env.2=\"PATH=/bin:/usr/sbin\"\n          /* Steps that have \"FAILed\" and need attention              */\n  RcErrors = \".{8} .{8}  (  12|  16|  20)\"\n  Rc8PStps = \".{8}\",\n             \"(ASMPGM  |GENPGM  |LINKDYL |LINKEDIT|CICSPREC|LANGX   )    08\"\n  Ok8Steps = \"(ABEXIT   ASMPGM      08)\"\n  RcAbends = \".{8} .{8} (U\u00dd\u00dd:digit:\u00a8\u00a8{4}|.S\u00dd\u00dd:digit:\u00a8\u00a8{3})\"\n          /* Listing dataset to update Element Member USERIDs         */\n  ReviewPDS= RptHlq\"GENERATE.LISTINGS\"\n\nRETURN\n/*\n       Use SDSF to retrieve current JOBs JESMSGLG Output ...\n*/\nGET_CURRENT_JESMSGLG:\n  IsfJesName = MVSVAR(\"SYMDEF\",\"JES\")\n  x=ISFCALLS('ON')\n    IsfOwner = USERID(); IsfPrefix = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n    IsfSysname = MVSVAR(\"SYMDEF\",\"SYSNAME\")\n\n    ADDRESS \"SDSF\" \"ISFEXEC DA\"\n    ADDRESS \"SDSF\" \"ISFACT  DA TOKEN('\"Token.1\"') PARM(NP ?) (PREFIX Jds)\"\n    DO i=1 TO JdsDdName.0 UNTIL ABBREV(JdsDdName.i,\"JESMSGLG\"); END\n    ADDRESS \"SDSF\" \"ISFACT  DA TOKEN('\"JdsToken.i\"') PARM(NP SA)\"\n    ADDRESS \"MVS\" \"EXECIO * DISKR\" IsfDdName.1 \"(STEM JesMsgLg. FINIS\"\n  x=ISFCALLS('OFF')\nRETURN\n/*\n       Get JSEMSGLG and Review for BAD RCs ...\n*/\nCHECK_FOR_ERRORS:\n  IsIssue = \"-e'\u00ac.{21}(\"RcErrors\"|\"Rc8PStps\"|\"RcAbends\") '\"\n  x=BPXWUNIX(\"grep -E\" IsIssue,\"JesMsgLg.\",\"MaybeIssue.\",\"StdErr.\",\"Env.\")\n    DO i=1 TO StdErr.0; SAY \"  grep IsIssue StdErr:\" StdErr.i; END\n  IsOk    = \"-e'\u00ac.{21}\"Ok8Steps\"'\"\n  x=BPXWUNIX(\"grep -Ev\" IsOk,\"MaybeIssue.\",\"Issues.\",\"StdErr.\",\"Env.\")\n    DO i=1 TO StdErr.0; SAY \"  grep IsOk StdErr:\" StdErr.i; END\nRETURN\n/*\n       Remove Parts of JESMSGLG that are not needed ...\n*/\nFORMAT_JESJOBS:\n  trim = LENGTH(Issues.1)-44\n  Replace = \"'s/.{\"trim\"}$//g'\"\n  x=BPXWUNIX(\"sed -E\" Replace,\"Issues.\",\"Issues.\",\"StdErr.\",\"Env.\")\n    DO i=1 TO StdErr.0; SAY \"  sed1 StdErr:\" StdErr.i; END\n  Replace = \"'s/\u00ac.{21}//g'\"\n  x=BPXWUNIX(\"sed -E\" Replace,\"Issues.\",\"Issues.\",\"StdErr.\",\"Env.\")\n    DO i=1 TO StdErr.0; SAY \"  sed2 StdErr:\" StdErr.i; END\n\n  DO i=1 TO Issues.0\n     IF Type = \"MAP\" THEN Member = WORD(Issues.i,1)||\"M\"\n        ELSE              Member = WORD(Issues.i,1)\n     Issues.i=Issues.i \"===> '\"ReviewPDS\"(\"Member\")'\"\n     ADDRESS \"TSO\" \"PDS '\"ReviewPds\"' A\" Member \"ID(>ERROR<) ADDSTATS EXTEND\"\n  END\nRETURN\n/*\n      Save issues to specified File and add ISPF Stats ...\n*/\nWRITE_ISSUES:\n  SAY \"\"; SAY \"===>\" Issues.0 \"Issues discovered for this JOB!\"\n  x = BPXWDYN(\"ALLOC DD(CHECKRPT) DSN('\"RptDsn\"') SHR REUSE\")\n  ADDRESS \"MVS\" \"EXECIO * DISKW CHECKRPT (STEM Issues. FINIS\"\n  x = BPXWDYN(\"FREE DD(CHECKRPT)\")\n\n  ADDRESS \"TSO\" \"PDS '\"RptPds\"' A\" RptMbr \"ADDSTATS EXTEND\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDLIST": {"ttr": 23, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x01\\xa1\\x01\\xa4\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 417, "newlines": 420, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO is used to list all the ShopKo Added Commands\n        in an ISPF Application's CMDS table.\n\n                           --- EXAMPLE ---\n<TSO> <%>CMDLIST applid <AFTER(command)> <DSN(output_DSN)> <TEST(TraceOption)>\n<TSO> <%>CMDLIST -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: applid      - The 1-4 charactor ISPF Application ID whose\n                           command table you want to look at.  If blank\n                           it defaults to the current ISPF Applid.\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                   AFTER - Begin displaying ISPF Commands after this command,\n                           if found.                     default: SCDC\n                     DSN - Optional output DSN, if blank output is to\n                           SYSOUT.                       default: blank\n                    TEST - Used to control traces        default: Off\n\n      Files: ISPF Command file for Application ID interested in\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: CMDLIST\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.16\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 12MAY94\n        History: 07AUG17 - v1.24 - Minor refactoring & reformating\n                 06FEB17 - v1.18 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.17 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.16 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.03 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 12MAY94 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG applid InParms\n\nIF applid = ''                 THEN CALL INVOKE_AS_MACRO\nIF WORDPOS(applid,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0 8';ADDRESS \"ISPEXEC\" \"TBOPEN\" TableNme \"NOWRITE SHARE\"\nIF RC = 0 THEN DO\n   ZCTVERB = AFTER              /* Don't display standard commands */\n   ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN\" TableNme,\n                    \"ARGLIST(ZCTVERB) POSITION(rowid)\"\n   ok='0';ADDRESS \"ISPEXEC\" \"TBVCLEAR\" TableNme\n   ok='0';ADDRESS \"ISPEXEC\" \"TBTOP\" TableNme\n   ZCTVERB = \"*\"\n   ok='0 8';ADDRESS \"ISPEXEC\" \"TBSARG\" TableNme \"NAMECOND(ZCTVERB EQ)\"\n   ok='0 8';ADDRESS \"ISPEXEC\" \"TBSKIP\" TableNme \"NUMBER(\"rowid\")\"\n\n   IF SYSVAR('SYSENV') = 'BACK' | DSN \u00ac= \"\" THEN DO\n      DO i = 1 UNTIL RC \u00ac= 0\n         ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN\" TableNme \"NEXT\"\n         cmd_row = \"   \" LEFT(ZCTVERB, 8) \"-\" STRIP(ZCTDESC)\n         IF DSN = \"\" THEN SAY cmd_row; ELSE QUEUE cmd_row\n      END\n      CALL SET_MSG STRIP(i) \"Commands found!\"\n      IF DSN \u00ac= \"\" THEN DO\n         QUEUE \"\"\n         ok='0';ADDRESS \"MVS\" \"EXECIO * DISKW OUTFILE (FINIS)\"\n         ok='*';ADDRESS \"TSO\" \"FREE DD(OUTFILE)\"\n      END\n     END\n   ELSE DO\n      ok='0 8'                    /* Handleable RC's for TBDISPL  */\n      DO UNTIL RC \u00ac= 0\n          ADDRESS \"ISPEXEC\" \"TBDISPL\" TableNme \"PANEL(CMDLIST1)\"\n      END\n   END\n   ok='0';ADDRESS \"ISPEXEC\" \"TBEND\" TableNme\n  END\nELSE CALL SET_MSG \"Table not found!\", \"You currently do not have an\",\n     \"ISPF Command Table for Appl-ID '\"STRIP(applid)\"' in your ISPTABLE\",\n     \"concatination.\", \"YES\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional VALUEs for TRUE and FALSE */\n                    /* Initialize and process non-positional parms   */\n  IF INDEX(applid, \")\") > 0 THEN DO\n     InParms = applid InParms\n     applid = \"\"\n  END\n  ValidParms = \"AFTER(SCDC) DSN() TEST(O)\"\n  MatchLength = 3                 /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0         /* Number of batch jobs submitted          */\n  SYSUID      = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError   = 0\n  SqlError    = 5\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n\n  IF DSN \u00ac= \"\" THEN DO\n      PARSE VALUE DSN WITH DsNme \"(\" .\n      IF LEFT(DsNme, 1) = \"'\" THEN DsNme = STRIP(DsNme,\"T\",\"'\")||\"'\"\n      CALL CHECK_DSN DsNme\n      ok='0';ADDRESS \"TSO\" \"ALLOC DD(OUTFILE) DSN(\"DSN\") SHR REUSE\"\n  END\n  IF applid = \"\" THEN DO\n     ADDRESS \"ISPEXEC\" \"VGET (ZAPPLID)\"\n     applid = ZAPPLID\n     IF applid = \"ISR\" THEN applid = \"ISP\"\n    END\n  ELSE UPPER applid\n  TableNme = STRIP(applid) || \"CMDS\"\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n  ADDRESS \"ISREDIT\" \"MACRO (applid InParms) NOPROCESS\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY CHECKDSN */\n/********************************************************************** /*COPY*/\n            Check existance of a Dataset returning error_msg            /*COPY*/\n***********************************************************************//*COPY*/\nCHECK_DSN: PROCEDURE                                                    /*COPY*/\nARG PDS_DSN .                                                           /*COPY*/\n  error_msg = SYSDSN(PDS_DSN)                                           /*COPY*/\n  IF error_msg \u00ac= 'OK' & SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO             /*COPY*/\n     CALL SET_MSG error_msg, PDS_DSN error_msg, \"YES\"                   /*COPY*/\n     EXIT 8                                                             /*COPY*/\n  END                                                                   /*COPY*/\nRETURN error_msg                                                        /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ADDRESS \"ISPEXEC\" \"TBEND\" TableNme\n  ADDRESS \"TSO\" \"FREE DD(OUTFILE)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDMAINT": {"ttr": 93, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x02\\xb8\\x02\\xca\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 696, "newlines": 714, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is an alternative to ISPF/PDF option 3.9.  It supports all the\n      function of option 3.9 plus the following:\n      1. Any application ID may be specified, even a currently active\n         one (including ISP and ISR) -- If a table for an active\n         application is changed, it is stored on DASD, but the active\n         copy is not affected;\n      2. The application ID defaults to the currently active one;\n      3. The output table library may be specified (the default is the\n         data set currently allocated to ISPTABL;\n      4. The following additional commands are supported:\n         a. FIND finds a character string WITHin the verb, action or\n            description fields;\n         b. LOCATE positions the display by verb;\n         c. RFIND repeats the FIND action;\n         d. SORT sorts by verb, except that all ALIASes are sorted at\n            the beginning of the commands table (ALIASes must precede\n            the commands they reference) -- the order of duplicate verbs\n            is preserved.\n      5. With a Terminal capable of handling screens wider then 80, Support\n         for the full 80 charactors allowed in the Command section.\n\n                           --- EXAMPLE ---\nTSO <%>CMDMAINT ApplId <TEST(TraceOption)>\nTSO <%>CMDMAINT -H -- To display help for this REXX\n\n  Arguments: ApplId      - ISPF ApplId who's CMDS you want to EDIT\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: The ISPF CMDS Profile member for the ApplId Choosen.\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: CMDMAINT\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.16\n                 ALBERT HULSEBOSCH (TTECAH1) Since version 2.0\n               : Douglas H. Adams (original author)\n                 Mail code 110-SH28\n                 Rockwell International Corporation\n                 2201 Seal Beach Boulevard\n                 P.O. Box 2515\n                 Seal Beach, California 90740-1515\n                 (213) 797-2618\n         Writen: 19SEP90\n        History: 06FEB17 - v1.18 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.17 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.16 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 14MAY96 - v2.16 - Added support for Wide Actions\n                           on Terminals less the 100 wide.\n                 14MAY96 - v2.15 - Fix to changed? logic.\n                 13MAY96 - v2.08 - Add support for screens wider\n                           the 80 charactors to allow the full 80 char-\n                           actors in the Command definition section.\n                 13MAY96 - v2.0\n                 19SEP90 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG ApplId InParms\n\nSELECT\n  WHEN WORDPOS(ApplId,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN ApplId = \"\"                 THEN DO\n     ADDRESS \"ISPEXEC\" \"VGET (ZApplId)\"\n     ADDRESS \"ISPEXEC\" \"SELECT CMD(%CMDMAINT\" ZApplId\") NEWAPPL(ISC)\"\n     EXIT RC\n    END\nOTHERWISE;                              CALL INITIALIZE_THIS_REXX; END\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nDO FOREVER\n    ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(CMDMAIN1)\"\n    IF RC = 8 THEN LEAVE\n\n    ApplCmds=ApplId\"CMDS\"; ApplTemp=ApplId\"TEMP\"\n    ok='0 12';ADDRESS \"TSO\" \"ALLOCATE DD(\"file\") DSN(\"TableDsn\") SHR REUSE\"\n\n    IF BUILD() THEN CALL COMMANDS\n\n    ok='0'\n      ADDRESS \"ISPEXEC\" \"TBSTATS DUMMY LIBRARY(DUMMY)\"\n      ADDRESS \"TSO\" \"FREE DD(\"file\")\"\nEND\n\nok='0';ADDRESS \"ISPEXEC\" \"VPUT (TableDsn) PROFILE\"\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional VALUEs for TRUE and FALSE */\n                    /* Initialize and process non-positional parms   */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4                   /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID=USERID()\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n\n  ADDRESS \"ISPEXEC\" \"VGET (ZApplId ZSCREEN ZSCREENW TableDsn)\"\n  file=\"CMDMAIN\"ZSCREEN; sort=\"CMDSORT\"ZSCREEN; CMDSCRW=MIN(100,ZSCREENW)\n  IF TableDsn=\"\" THEN DO\n     x=LISTDSI(\"ISPTABL FILE\")\n     TableDsn=\"'\"SYSDsName\"'\"\n  END\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/***********************************************************************\n     Alias resolution\n***********************************************************************/\nALIAS: PROCEDURE EXPOSE ApplTemp\n  ok='0';ADDRESS \"ISPEXEC\" \"TBGET\" ApplTemp \"ROWID(ROWID)\"\n  DO level=1 UNTIL \u00ac(ABBREV(ZCTACT, \"ALIAS\")) | RC \u00ac= 0\n     ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n     ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN\" ApplTemp \"ARGLIST(ZCTVERB)\"\n  END\n  ok='0';ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"ROW(\"rowid\") NOREAD\"\nRETURN level\n/***********************************************************************\n     Build temporary command table\n***********************************************************************/\nBUILD:\n  ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE\" ApplTemp \"LIBRARY(\"file\")\",\n                           \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\"\n  IF RC \u00ac= 0 THEN DO\n     CALL SET_MSG , \"Unable to create temporary table for\" ApplId\"!\", \"YES\"\n     RETURN FALSE\n  END\n  Rowcurr=0\n  ok='0';ADDRESS \"ISPEXEC\" \"TBSTATS\" ApplCmds \"ROWCURR(ROWCURR)\",\n                           \"STATUS1(STATUS1) STATUS2(STATUS2)\"\n  Exist? =(status1 == TRUE)\n  Closed?=(status2 == TRUE)\n  IF \u00ac(exist?) | rowcurr = 0 THEN DO\n     Zctverb=COPIES(\"_\",8)\n     Zcttrunc=\"_\"\n     Zctact=COPIES(\"_\",60)\n     Zctdesc=COPIES(\"_\",57)\n     ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp\n    END\n  ELSE DO\n     IF closed? THEN ADDRESS \"ISPEXEC\" \"TBOPEN\" ApplCmds \"NOWRITE\"\n     ADDRESS \"ISPEXEC\" \"TBTOP\" ApplCmds\n     DO rowcurr\n        ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplCmds\n        ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp \"MULT(\"rowcurr\")\"\n     END\n     IF closed? THEN ADDRESS \"ISPEXEC\" \"TBEND\" ApplCmds\n  END\n  ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\nRETURN TRUE\n/***********************************************************************\n* Command Processing                                                   *\n***********************************************************************/\nCOMMANDS:\n  csrpos=\"0\"; cursor=\"\"; verb=\"\"; operand=\"\"; changed?=FALSE\n  ok='0 4 8'\n      ADDRESS \"ISPEXEC\" \"TBDISPL\" ApplTemp \"PANEL(CMDMAIN2) POSITION(CRP)\"\n  DO WHILE RC < 8\n     IF crp = 0 THEN crp=ZTDTOP\n     DO ZTDSELS\n        PARSE UPPER VALUE sel WITH linecmd +1 number\n        IF number = \"\" THEN number=1\n        SELECT\n          WHEN linecmd = \"D\" THEN CALL DELETE\n          WHEN linecmd = \"I\" THEN CALL INSERT\n          WHEN linecmd = \"R\" THEN CALL REPEAT\n          WHEN linecmd = \"W\" THEN CALL UPDATE\n          WHEN linecmd = \" \" THEN CALL UPDATE\n        OTHERWISE\n           CALL SET_MSG \"Invalid line option.\", \"'\"linecmd\"' is not a\",\n                        \"currently supported line command!\", \"YES\"\n        END\n        IF ZTDSELS = 1 THEN ITERATE\n        ok='0 4';ADDRESS \"ISPEXEC\" \"TBDISPL\" ApplTemp\n     END\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n            ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"NUMBER(\"ZTDTOP\")\"\n     PARSE VALUE ZCMD WITH verb operand\n     SELECT\n       WHEN verb = \"\"                 THEN NOP\n       WHEN ABBREV(\"CANCEL\", verb, 3) THEN LEAVE\n       WHEN ABBREV(\"FIND\", verb, 1)   THEN CALL FIND\n       WHEN ABBREV(\"LOCATE\", verb, 1) THEN CALL LOCATE\n       WHEN ABBREV(\"RFIND\", verb, 1)  THEN CALL RFIND\n       WHEN ABBREV(\"SORT\", verb, 1)   THEN CALL SORT\n     OTHERWISE\n        CALL SET_MSG \"Invalid option.\", \"'\"verb\"' is not a\",\n                     \"currently supported command!\", \"YES\"\n     END\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL\" ApplTemp \"PANEL(CMDMAIN2)\"      ,\n               \"CURSOR(\"cursor\") CSRROW(\"crp\") CSRPOS(\"csrpos\") AUTOSEL(NO)\",\n               \"POSITION(CRP)\"\n  END\n  CALL DOEND\nRETURN\n/***********************************************************************\n     Delete Command\n***********************************************************************/\nDELETE:\n  DO number\n      ok='0';ADDRESS \"ISPEXEC\" \"TBDELETE\" ApplTemp\n      ok='0 8';ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"NOREAD\"\n  END\n  changed? = TRUE\n  IF ZTDSELS = 1 THEN crp = MAX(crp-1,0)\nRETURN\n/***********************************************************************\n     END command\n***********************************************************************/\nDOEND:\n  ok='0'\n  IF ABBREV(\"CANCEL\", verb, 3) | \u00ac changed?   THEN DO\n     ADDRESS \"ISPEXEC\" \"TBEND\" ApplTemp\n     RETURN\n  END\n  ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n  ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp\n  ok='0 8'\n  DO WHILE RC = 0\n     IF TRANSLATE(zctverb,\" \",\"_\") = \"\" THEN\n        ADDRESS \"ISPEXEC\" \"TBDELETE\" ApplTemp\n     ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp\n  END\n  ADDRESS \"ISPEXEC\" \"TBQUERY\" ApplTemp \"ROWNUM(ROWNUM)\"\n  ok='0'\n  IF rownum = 0 THEN DO\n     ADDRESS \"ISPEXEC\" \"TBERASE\" ApplCmds \"LIBRARY(\"file\")\"\n     ADDRESS \"ISPEXEC\" \"TBEND\" ApplTemp\n    END\n  ELSE DO\n     ADDRESS \"ISPEXEC\" \"TBQUERY\" ApplTemp \"ROWNUM(CURSIZE)\"\n     Cursize = FORMAT(cursize)\n     Moddate = DATE(\"Ordered\")\n     Modtime = LEFT(TIME(\"Normal\"),5)\n     ADDRESS \"ISPEXEC\" \"TBCLOSE\" ApplTemp \"LIBRARY(\"file\") NAME(\"ApplCmds\")\"\n     ADDRESS \"ISPEXEC\" \"LMINIT DATAID(DATAID) DDNAME(\"file\")\"\n     ADDRESS \"ISPEXEC\" \"LMMSTATS DATAID(\"dataid\") MEMBER(\"ApplCmds\")\",\n                       \"MODTIME(\"modtime\") CURSIZE(\"cursize\")\",\n                       \"USER(\"SYSUID\") MODDATE(\"moddate\")\",\n                       \"INITSIZE(\"cursize\")\"\n     ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"dataid\")\"\n  END\n  CALL SET_MSG ApplId\"CMDS saved.\",,\n               \"Commands table\" ApplId\"CMDS saved in\" TableDsn\".\", \"NO\"\nRETURN\n/***********************************************************************\n     Find command\n***********************************************************************/\nFIND:\n  ok='0';ADDRESS \"ISPEXEC\" \"TBGET\" ApplTemp\n  Csrpos=1; Cursor=\"\"\n  CALL SEARCH\n  SaveOperand=operand; SaveCrp=crp; SaveCsrPos=csrpos; SaveCursor=cursor\nRETURN\n/***********************************************************************\n     Insert command\n***********************************************************************/\nINSERT:\n  CALL UPDATE\n  ZCTVERB=COPIES(\"_\",8); ZCTTRUNC=\"_\"; ZCTACT=COPIES(\"_\",60)\n  ZCTDESC=COPIES(\"_\",57)\n\n  ok='0';ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp \"MULT(\"number\")\"\n  DO number - 1; ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp; END\n  IF ZTDSELS = 1 THEN crp=crp+1\nRETURN\n/***********************************************************************\n     Locate command\n***********************************************************************/\nLOCATE:\n  Zctverb=operand\"*\"\n  ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN\" ApplTemp ,\n                   \"ARGLIST(ZCTVERB) NOREAD POSITION(CRP)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n     ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN\" ApplTemp ,\n                      \"ARGLIST(ZCTVERB) NOREAD POSITION(CRP)\"\n  END\n  IF RC = 0 THEN ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"NUMBER(-1)\"\nRETURN\n/***********************************************************************\n     Repeat command\n***********************************************************************/\nREPEAT:\n  CALL UPDATE\n  ok='0';ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp \"MULT(\"number\")\"\n  DO number-1; ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp; END\n  IF ZTDSELS = 1 THEN crp=crp+1\nRETURN\n/***********************************************************************\n     RFIND command\n***********************************************************************/\nRFIND:\n  IF SYMBOL(\"SaveOperand\") \u00ac= \"VAR\" THEN DO\n     CALL SET_MSG \"Enter a FIND!\",,\n          \"RFIND works only after a FIND string has been entered!\", \"YES\"\n     RETURN\n  END\n  Operand=SaveOperand\n  IF crp = SaveCrp THEN DO; Cursor=SaveCursor; Csrpos=SaveCsrPos+1; END\n     ELSE               DO; Cursor=\"\";         Csrpos=1;            END\n  CALL SEARCH\n  SaveCrp=crp; SaveCursor=cursor; SaveCsrPos=csrpos\nRETURN\n/***********************************************************************\n     Search for character string\n***********************************************************************/\nSEARCH:\n  Operand=STRIP(operand,\"B\",\"'\")\n  Operand=STRIP(operand,\"B\",\"\"\"\")\n  IF operand = \"\" THEN DO\n     CALL SET_MSG \"Search for What?\",,\n          \"SEARCH requires search string to look for!\", \"YES\"\n     RETURN\n  END\n  SELECT\n    WHEN cursor = \"ZCTVERB\" THEN DO\n       PosVerb=POS(operand,zctverb,csrpos)\n       PosAct =POS(operand,zctact)\n       PosDesc=POS(operand,zctdesc)\n      END\n    WHEN cursor = \"ZCTACT\" THEN DO\n       PosVerb=0\n       PosAct =POS(operand,zctact,csrpos)\n       PosDesc=POS(operand,zctdesc)\n      END\n    WHEN cursor = \"ZCTDESC\" THEN DO\n       PosVerb=0\n       PosAct =0\n       PosDesc=POS(operand,zctdesc,csrpos)\n      END\n  OTHERWISE\n     PosVerb=POS(operand,zctverb)\n     PosAct =POS(operand,zctact)\n     PosDesc=POS(operand,zctdesc)\n  END\n  DO WHILE RC = 0 & PosVerb = 0 & PosAct = 0 & PosDesc = 0\n      ok='0';ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"POSITION(CRP)\"\n      PosVerb=POS(operand,zctverb)\n      PosAct =POS(operand,zctact)\n      PosDesc=POS(operand,zctdesc)\n  END\n  SELECT\n    WHEN RC = 0 & PosVerb \u00ac= 0 THEN DO\n       Cursor = \"ZCTVERB\"; Csrpos=PosVerb\n      END\n    WHEN RC=0 & PosAct \u00ac= 0    THEN DO\n       Cursor=\"ZCTACT\"; Csrpos=PosAct\n      END\n    WHEN RC = 0 & PosDesc \u00ac= 0 THEN DO\n       Cursor=\"ZCTDESC\"; Csrpos=PosDesc\n      END\n  OTHERWISE\n     Cursor=\"\"; Csrpos=0\n     CALL SET_MSG \"Bottom of data reached\",,\n                  operand \"not found!  Use RFIND to continue from top.\", \"YES\"\n     ok='0'\n       ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n       ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"NUMBER(\"ZTDTOP\") POSITION(CRP)\"\n  END\nRETURN\n/***********************************************************************\n     Sort command\n***********************************************************************/\nSORT:\n  ok='0'\n  ADDRESS \"ISPEXEC\" \"TBCREATE\" sort \"REPLACE LIBRARY(\"file\")\",\n                    \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC LEVEL ORDER)\"\n  ADDRESS \"ISPEXEC\" \"TBSORT\" sort \"FIELDS(LEVEL,N,D ZCTVERB,C,A ORDER,C,A)\"\n  ADDRESS \"ISPEXEC\" \"TBQUERY\" ApplTemp \"ROWNUM(ROWNUM)\"\n  ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n  DO rownum\n     ADDRESS \"ISPEXEC\" \"TBSKIP\" ApplTemp \"POSITION(ORDER)\"\n     PARSE VALUE zctact WITH action .\n     IF action = \"ALIAS\" THEN level = alias(); ELSE level = 0\n\n     ADDRESS \"ISPEXEC\" \"TBADD\" sort \"ORDER MULT(\"rownum\")\"\n  END\n  ADDRESS \"ISPEXEC\" \"TBTOP\" sort\n  ADDRESS \"ISPEXEC\" \"TBEND\" ApplTemp\n  ADDRESS \"ISPEXEC\" \"TBCREATE\" ApplTemp \"LIBRARY(\"file\")\",\n                           \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\"\n  DO rownum\n     ADDRESS \"ISPEXEC\" \"TBSKIP\" sort\n     ADDRESS \"ISPEXEC\" \"TBADD\" ApplTemp \"MULT(\"rownum\")\"\n  END\n  ADDRESS \"ISPEXEC\" \"TBEND\" sort\n  ADDRESS \"ISPEXEC\" \"TBTOP\" ApplTemp\n  changed? = TRUE\nRETURN 0\n/***********************************************************************\n     Update SELECTed row\n***********************************************************************/\nUPDATE:\n  IF linecmd = \"W\" THEN DO\n     ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(CMDMAIN3)\"\n     IF RC = 8 THEN RETURN\n  END\n  ZCTVERB =TRANSLATE(ZCTVERB,\" \",\"_\")\n  ZCTTRUNC=TRANSLATE(ZCTTRUNC,\" \",\"_\")\n  ZCTACT  =TRANSLATE(ZCTACT,\" \",\"_\")\n  ZCTDESC =TRANSLATE(ZCTDESC,\" \",\"_\")\n  ok='0';ADDRESS \"ISPEXEC\" \"TBPUT\" ApplTemp\n  changed? = TRUE\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                            /* Ignore all non-0 RCs           */\n    ADDRESS \"ISPEXEC\" \"TBSTATS DUMMY LIBRARY(DUMMY)\"\n    IF closed? THEN ADDRESS \"ISPEXEC\" \"TBEND\" ApplCmds\n    ADDRESS \"ISPEXEC\" \"TBEND\" sort\n    ADDRESS \"ISPEXEC\" \"TBEND\" ApplTemp\n    ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"dataid\")\"\n    ADDRESS \"TSO\" \"FREE DD(\"file\")\"\n    ZISPFRC=ExitError\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDTAG": {"ttr": 25, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00R\\x01\\x102o\\x01\\x17%O\\x10)\\x01\\x84\\x01a\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2010-11-22T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 388, "newlines": 353, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX converts and ISPF CMDS Table into DTL Format so it can be\n      maintained/updated. This table can be re-compiled back to an\n      usable ISPF CMDS Table using the ISPDTLC utility.\n\nNOTE: This ISPF REXX uses ISPF File Tayloring enbedded REXX support.\n\n                           --- EXAMPLE ---\nTSO <%>CMDTAG ApplidPds <TEST(TraceOption)>\nTSO <%>CMDTAG -H -- To display help for this REXX\n\n  Arguments: ApplidPds   - ISPF APPLID or PDS w/member name, for CMD\n                           table to convert.\n                     NOTE: This will NOT override a version of the CMDS\n                           Table currently in you concatination!\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: INPUT - ISPF File Tayloring member CMDSTAG0 from ISPSLIB\n             INPUT - ISPF CMDS table to convert. If APPID supplied,\n                     it must be in current ISPTLIB Concatination.\n                     Otherwise supply the full PDS w/member.\n            OUTPUT - VIEW Session on Dialog Tag version of ISPF\n                     commands.  You will need to save this somewhere, if\n                     you want to use it later.\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: CMDTAG\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.19\n                 FERGUSON AL (HUL2353)\n         Writen: 22NOV10\n        History: 06FEB17 - v1.21 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.20 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.19 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 02MAR11 - v1.11 - Ensure APPLID is Capalized and\n                           CMDS Table is TBCLOSEd if there are problems.\n                 12JAN11 - v1.09 - Fix to ensure APPLID showing up\n                           in DTL File properly.\n                 12JAN11 - v1.05 - Add support for dynamically\n                           allocated ISPF CMDS not currently in your\n                           ISPTLIB concatination.\n                 22NOV10 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG ApplidPds InParms                        /* Place arguments here */\n\nIF WORDPOS(ApplidPds,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF INDEX(ApplidPds, \"(\") > 0 THEN DO\n    PARSE VALUE ApplidPds WITH pds_name \"(\" tname \")\" .\n    IF ABBREV(pds_name,\"'\") THEN pds_name = pds_name\"'\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID(\"pds_name\") STACK\"\n  END\nELSE tname = ApplidPds||\"CMDS\"\nPARSE VALUE tname WITH applid \"CMDS\" .\n\nok='0 8';ADDRESS \"ISPEXEC\" \"TBOPEN\" tname \"NOWRITE SHARE\"\nIF RC = 0 THEN DO\n    ADDRESS \"ISPEXEC\" \"TBTOP\" tname\n    ADDRESS \"TSO\" \"ALLOC DD(ISPFILE) NEW REUSE\"             ,\n                  \"AVGREC(K) SPACE(1,5) TRACKS UNIT(VIO)\"   ,\n                  \"DSORG(PS) LRECL(255) RECFM(V B) BLKSIZE(0)\"\n    ADDRESS \"ISPEXEC\" \"FTOPEN\"\n    ADDRESS \"ISPEXEC\" \"FTINCL CMDSTAG0\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"\n    ADDRESS \"MVS\" \"EXECIO * DISKR ISPFILE (STEM tname. FINIS\"\n    ADDRESS \"TSO\" \"FREE DD(ISPFILE)\"\n    ADDRESS \"ISPEXEC\" \"TBEND\" tname\n    CALL STEMDISP \"VIEW\",\"tname.\"\n  END\nELSE CALL SET_MSG \"Table not found!\", \"You currently do not have an\",\n     \"ISPF Table named '\"STRIP(tname)\"' in your ISPTLIB concatination.\",,\n     \"YES\"\n\nIF INDEX(ApplidPds, \"(\") > 0 THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    IF INDEX(ApplidPds, \"(\") > 0 THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ADDRESS \"ISPEXEC\" \"TBCLOSE\" tname\n    ZISPFRC = ExitError                /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNTL": {"ttr": 27, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00R\\x01\\x16\"?\\x01\\x17%O\\x10)\\x01d\\x01]\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2016-08-10T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 356, "newlines": 349, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX will edit current ISPF Temporary (....SPFTEMP#.CNTL) DSNs.\n      By default it will edit the current one based on the SCREEN you\n      are in, but you can specify others by passing the the CNTL file\n      number as a parameter.\n\n This mimics the CNTL function built into FASTPATH by Gilbert Saint-Flour.\n\n                           --- EXAMPLE ---\nTSO <%>CNTL _no_ _ext_ <TEST(TraceOption)>\nTSO <%>CNTL -H -- To display help for this REXX\n\n  Arguments: _no_        - ISPF CNTL file Number 0-8\n                           default: blank, i.e. current screens ZTEMPN\n             _ext_       - ISPF FT Extention\n                           default: blank, i.e. '.CNTL'\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: ISPF File Tayloring DSNs for current session.\nOther EXECS: This calls ED to do actual ISPF Edit.\n\nEXEC History\n\n REXX EXEC Name: CNTL\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 10AUG16\n        History: 06FEB17 - v1.08 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.07 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.06 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 10AUG16 - v1.03 - Tweaks to better deal with FT\n                           Files that are not yet allocated.\n                 10AUG16 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG _no_ InParms       /* Place arguments here */\n\nIF WORDPOS(_no_,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0';ADDRESS \"ISPEXEC\" \"VGET (ZMLPS ZSEQ ZSCREEN) SHARED\"\nIF _no_ = \"\"                    THEN _no_ = ZSCREEN\nELSE IF \u00ac(DATATYPE(_no_,\"NUM\")) THEN CALL SET_MSG ,,\n          \"CNTL requires the argument to be numeric 1-8, or blank!\", \"YES\"\nIF AnythingElse = \"\"            THEN _ext_ = \".CNTL\" /* Default Extention */\n   ELSE                              _ext_ = \".\"STRIP(AnythingElse,\"B\",\".\")\nIF ABBREV(ZMLPS,\"Y\")            THEN _FT_ = \"ISP\"ZSEQ\".SPFTEMP\"_no_||_ext_\n   ELSE                              _FT_ = \"SPFTEMP\"_no_||_ext_\nx = LISTDSI(_FT_)\nSELECT\n  WHEN x = 0 & _no_ = ZSCREEN THEN DO\n     ADDRESS \"ISPEXEC\" \"VGET (ZTEMPN) SHARED\"\n                                   CALL ED \"DD:\"ZTEMPN\n    END\n  WHEN x = 0                  THEN CALL ED _FT_\n  WHEN ABBREV(ZMLPS,\"Y\")      THEN CALL ED \"ISP\"ZSEQ\".SPFTEMP0\"_ext_\nOTHERWISE;                         CALL ED \"SPFTEMP0\"_ext_          ; END\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPPRF": {"ttr": 29, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01)\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x01\\xa1\\x01\\x9f\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.41", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 417, "newlines": 415, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX cleans up/compresses the ISPF profile members & Profile DSN.\n\n                           --- EXAMPLE ---\nTSO <%>COMPPRF profile_DSN <COMP(N|Y)> <TEST(valid REXX trace option)>\nTSO <%>COMPPRF -H -- To display help for this REXX\n\n  Arguments: profile_DSN - ISPF profile dataset to clean up\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    COMP - N or Y to compress after cleanup  default: N\n                    TEST - Used to control traces\n\n      Files: profile_DSN\nOther EXECS:\n\nEXEC History\n\n REXX EXEC Name: COMPPRF\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.22\n                 Al Ferguson (HUL2353)   from version 1.14\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 3MAR93\n        History: 06FEB17 - v1.24 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.23 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.22 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 19MAR04 - v1.14 - Prefix ZPREFIX vs SYSUID to\n                           non-qulified DSNs.\n                 18MAY95 - v2.19 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 23JUN93 - v2.16 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 15JUN93 - v2.00 - Support for Profile DSN\n                           information reporting\n                  3MAR93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG profile_DSN InParms /* Place arguments here */\n\nIF WORDPOS(profile_DSN,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF CHECK_DSN(profile_DSN) = 'OK' THEN DO\n    CALL SAY_DSN_INFO full_DSN, \"Before any work for DSN\" full_DSN\n    ok='0'; ADDRESS \"ISPEXEC\" \"LIBDEF PROF DATASET ID(\"profile_DSN\") STACK\"\n    CALL GET_IT(profile_DSN)\n    ok='0 12 20'                       /* Handleable ISPEXEC TB RCs */\n    DO i = 1 TO filtered.0\n        ADDRESS \"ISPEXEC\" \"TBOPEN\" filtered.i  \"WRITE   LIBRARY(PROF)\"\n        IF RC \u00ac= 0 THEN ITERATE\n        ADDRESS \"ISPEXEC\" \"TBCLOSE\" filtered.i \"NEWCOPY LIBRARY(PROF)\"\n    END\n    ok='0'; ADDRESS \"ISPEXEC\" \"LIBDEF PROF\"\n\n    ok='0'                             /* Handleable ISPEXEC TB RCs */\n    IF LEFT(COMP,1) = 'Y' THEN DO\n        ADDRESS \"ISPEXEC\"\n            \"LMINIT DATAID(profid) DATASET(\"profile_DSN\") ENQ(EXCLU)\"\n            \"LMCOMP DATAID(\"profid\")\"\n            \"ISPEXEC\" \"LMFREE DATAID(\"profid\")\"\n        ADDRESS \"TSO\"\n        CALL SAY_DSN_INFO full_DSN, \"After COMPRESS done on\" full_DSN\n    END\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n            Initialize varables and get startup parameters\n**********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                    /* Initialize and process non-positional parms   */\n  ValidParms = \"COMP(N) TEST(O)\"\n  MatchLength = 4                 /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS   /* Got any...prime em  */\n\n  NbrSubmited = 0         /* Number of batch jobs submitted          */\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0\n\n  IF INDEX(profile_DSN,\"'\") > 0 THEN full_DSN = STRIP(profile_DSN,\"B\",\"'\")\n  ELSE DO\n      ADDRESS \"ISPEXEC\" \"VGET (ZPREFIX)\"\n      full_DSN = ZPREFIX || \".\" || profile_DSN\n  END\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY GETMEMS */\n/********************************************************************** /*COPY*/\n          Use TSO \"LISTDS\" command to get a member list of PDS          /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_IT: PROCEDURE EXPOSE filtered.                                      /*COPY*/\nARG PDS_DSN .                                                           /*COPY*/\n  x = OUTTRAP(\"list.\")             /* Trap output from TSO command   */ /*COPY*/\n  ok='0';ADDRESS \"TSO\" \"LISTDS (\"PDS_DSN\") MEMBERS\"                     /*COPY*/\n  x = OUTTRAP(\"OFF\")                                                    /*COPY*/\nRETURN FILTER_IT()                                                      /*COPY*/\n/********************************************************************** /*COPY*/\n          Filter out everything but the member names of PDS             /*COPY*/\n**********************************************************************/ /*COPY*/\nFILTER_IT:                                                              /*COPY*/\n  DO i = 1 TO list.0 UNTIL list.i = '--MEMBERS--' | i > list.0 ; END    /*COPY*/\n  DO j = 1 TO list.0-i; k=i+j; filtered.j = STRIP(list.k); END          /*COPY*/\n  filtered.0 = list.0 - i                                               /*COPY*/\nRETURN filtered.0                                                       /*COPY*/\n/* COPY CHECKDSN */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n            Check existance of a Dataset returning error_msg            /*COPY*/\n***********************************************************************//*COPY*/\nCHECK_DSN: PROCEDURE                                                    /*COPY*/\nARG PDS_DSN .                                                           /*COPY*/\n  error_msg = SYSDSN(PDS_DSN)                                           /*COPY*/\n  IF error_msg \u00ac= 'OK' & SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO             /*COPY*/\n     CALL SET_MSG error_msg, PDS_DSN error_msg, \"YES\"                   /*COPY*/\n     EXIT 8                                                             /*COPY*/\n  END                                                                   /*COPY*/\nRETURN error_msg                                                        /*COPY*/\n/**********************************************************************\n            Get DSN information and SAY\n***********************************************************************/\nSAY_DSN_INFO:\nPARSE ARG DSN_name, comment\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDINIT LISTID(profile) LEVEL(\"DSN_name\")\"\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDLIST LISTID(\"profile\") OPTION(LIST)\",\n                           \"DATASET(dsnname) STATS(YES)\"\n  SAY\n  SAY comment\n  SAY \"     Tracks allocate:\" STRIP(ZDLSIZE) \"for:\" dsnname\n  SAY \"     Current extents:\" STRIP(ZDLEXT)\n  SAY \"        Percent used:\" STRIP(ZDLUSED)\n  SAY \"Tracks actually used:\" STRIP(ZDLUSED * ZDLSIZE / 100)\n  SAY\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDLIST LISTID(\"profile\") OPTION(FREE)\"\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ADDRESS \"ISPEXEC\" \"LIBDEF PROF\"\n  ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"profid\")\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CR": {"ttr": 31, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x0f\\x00R\\x01\\x02\\x03o\\x01\\x17%O\\x10)\\x016\\x01B\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "03.15", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 310, "newlines": 322, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO changes a string to another string starting at the\n        current cursor possition until the end of the dataset.\n\n                           --- EXAMPLE ---\n<%>CR changarg <TEST(TraceOption)>\n<%>CR -H -- To display help for this ISPF Macro\n\n  Arguments: changarg    - Normal ISPF change command arguments less\n                           leading 'C' or 'CHANGE' command.\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n      Files: Current EDIT dataset\nOther EXECS: none\n\nEXEC History\n\nEXEC/MACRO Name: CR - Change Rest\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.16\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 06APR93\n        History: 03MAR17 - v3.02 - Minor refactoring for efficency\n                 06FEB17 - v3.01 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v3.00 - Mass update for Error Handling Fixes.\n                 31JAN17 - v2.24 - Update all REXXes with latest common\n                           routines via %CCMASS\n                 18MAY95 - v2.21 - Update all REXXes with latest common\n                           routines via %CCMASS\n                 17NOV93 - v2.19 - Fixes to '&' support and TEST NP-PARM.\n                 04NOV93 - v2.16 - Support added for NP-Parms and change\n                           arguments w/ampersands (support possible with\n                           hint from Pete V. - TTECPV1).\n                 15JUL93 - v2.10 - Fix to handle single record SETs\n                 23JAN93 - v2.04 - Update all REXXes with latest common\n                           routines via %CCMASS\n                 6APR93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (changarg) NOPROCESS\"\nIF WORDPOS(changarg, '-h -H') > 0 THEN CALL DISPLAY_HELP\n\nPARSE UPPER VALUE changarg WITH . 'TEST(' TEST ')' .\nIF TEST \u00ac= '' & RIGHT(STRIP(changarg),1) = ')' THEN DO\n   test_string = changarg; UPPER test_string\n   test_starts_at = INDEX(test_string, 'TEST(') - 1\n   changarg = STRIP(LEFT(changarg, test_starts_at))\n  END\nELSE TEST = 'O'\n\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 4 16';ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nok='0'\nIF RC = 0 THEN DO\n    ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFRANGE\"\n    ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLRANGE\"\n    ADDRESS \"ISREDIT\" \"RESET COMMAND\"\n  END\nELSE DO\n   ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZCSR\"\n   ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLAST\"\nEND\nADDRESS \"ISREDIT\" \"LABEL\" first \"= .FLINE\"\n\nIF first \u00ac= last THEN DO\n   ADDRESS \"ISREDIT\" \"LABEL\" last \"= .LLINE\"\n   last_label = \".LLINE\"\n  END\nELSE last_label = \".FLINE\"\n\nPARSE VALUE changarg WITH OldArg NewArg\nSELECT\n  WHEN ABBREV(OldArg,\"'\") & RIGHT(OldArg,1) \u00ac= \"'\" THEN DO\n     PARSE VALUE NewArg WITH more \"' \" NewArg\n     OldArg = OldArg more\"'\"\n    END\n  WHEN ABBREV(OldArg,'\"') & RIGHT(OldArg,1) \u00ac= '\"' THEN DO\n     PARSE VALUE NewArg WITH more '\" ' NewArg\n     OldArg = OldArg more'\"'\n    END\nOTHERWISE; NOP; END\n\nIF INDEX(OldArg,'&') > 0 THEN OldArg = AMPER_HANDLING(OldArg)\nIF INDEX(NewArg,'&') > 0 THEN NewArg = AMPER_HANDLING(NewArg)\nok='0 4 8 20';ADDRESS \"ISREDIT\" \"C\" OldArg NewArg \".FLINE\" last_label \"ALL\"\nok='0 4';ADDRESS \"ISREDIT\" \"(var1,var2) = CHANGE_COUNTS\"\n\nIF var1 = 0 THEN success = '0'\n   ELSE          success = STRIP(var1,\"L\",\"0\")\nIF var2 = 0 THEN failure = '0'\n   ELSE          failure = STRIP(var2,\"L\",\"0\")\nCALL SET_MSG success \"changes.\",,\n             \"CHANGE\" OldArg NewArg \".FLINE\" last_label \"ALL\",\n             \"-- Resulted in\" success \"changes with\" failure \"failures.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n  ExitError = 0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY AMPERHAN */\n/********************************************************************** /*COPY*/\n  Handle Ampersands in ISREDIT strings within Macros Assumes String     /*COPY*/\n     being processed containes an ampersand. To Ensure this use:        /*COPY*/\n  IF INDEX(string,'&') > 0 THEN string = AMPER_HANDLING(string)         /*COPY*/\n***********************************************************************//*COPY*/\nAMPER_HANDLING: PROCEDURE                                               /*COPY*/\nARG Process                                                             /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN SUBSTR(Process,1,1) = \"'\" THEN Process = STRIP(Process,\"B\",\"'\") /*COPY*/\n   WHEN SUBSTR(Process,1,1) = '\"' THEN Process = STRIP(Process,\"B\",'\"') /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\nRETURN \"X'\"C2X(Process)\"'\"                                              /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATEX": {"ttr": 33, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03+\\x00R\\x01\\x00 \\x7f\\x01\\x17%O\\x10)\\x01\\xce\\x01\\xd7\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "03.43", "flags": 0, "createdate": "2000-07-25T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 462, "newlines": 471, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX converts date formates and can be used to do date arithmetic.\n\n                        Date conversion routines\n                  See help at bottom for instructions\n            original Algorithms (c) 1991 by David A. Cromley\n                 as published in Tech Support Magazine\n               modified Algorithms - 2000 by Al Ferguson\n    Use of any of these algorithms requires this notice be included.\n\n                           --- EXAMPLE ---\nTSO <%>DATEX p1 <p2 <p3>> <TEST(valid REXX trace option)>\nTSO <%>DATEX -H -- To display help for this REXX\n\n  Arguments: p1          - First parm  -- see below\n             p2          - Second parm -- see below\n             p3          - Third parm  -- see below\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n                     --- Input Format Examples ---\n              datex today       converts from todays date\n              datex tommorow    converts from tomorrows date\n              datex yesterday   converts from yesterdays date\n              datex bbbbbb      converts from base date\n              datex yyyy jjj    converts from julian date\n              datex dd mm yyyy  converts from day, month, year\n\n\n  In all cases, output is:  YYYY-MM-DD.JJJ BBBBBB Day-of-week\n     where mm is month 1-12\n           dd is day 1-31\n          jjj is julian date 1-366\n         yyyy is year >= 0001\n       bbbbbb is the number of days since 01 January 0001\n  day-of-week is the full English Day of the Week in mixed case\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n  EXEC Name: DATEX\n     Author: AL FERGUSON - TS ADM (TSAZFA) from version 3.29\n             Al Ferguson (HUL2353) from version 3.03\n             Al Ferguson (TTECAH1) from version 1.01\n             David A. Cromley, Brought in and enhanced by\n                   Al Ferguson (TTECAH1)\n     Writen: 1991\n    History: 06FEB17 - v3.31 - Update Error Handling Routines\n             22FEB11 - v3.27 - Ensure we are in a Leap Year if trying to\n                       use February 29th as a date or Julian 366.\n             22FEB11 - v3.24 - Add support for TOMORROW and use REXX DATE\n                       Function conversions were possible.\n             26AUG08 - v3.20 - Add support for \"YESTERDAY\"\n             26JUL00 - v3.03 - Reworking of algorithms to avoid\n                       Y2K problems and support wider date range.\n             07JUL98 - v2.17 - Use the SET_MSG vs SAY FUNCTION to\n                       better support being CALLed.\n             18MAY95 - v2.07 - Update all REXXes w/latest versions of\n                       commom routines via %CCMASS\n             23FEB95 - v2.06 - Remove dependance on TSO to allow\n                       use as a CALLed REXX Function under MVS & IRXJCL.\n             15DEC93 - v2.03 - Support for ISPF and TSO base Help\n                       screens added.\n             23JUN93 - v2.00 - Maintenance done to include the\n                       latest changes to many COPY members.  This\n                       maintenance done via CCMASS.\n             26MAY93 - v1.10 - ERROR handling, Help display, and\n                       NP-PARM Support added.\n             1991    - v1.00\n***************************** Rexx ***********************************/\nARG p1 p2 p3 InParms\n\nIF WORDPOS(p1,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nSELECT\n  WHEN ABBREV(\"TODAY\", p1)     THEN CALL BBB2ALL DATE('B')\n  WHEN ABBREV(\"TOMORROW\", p1)  THEN CALL BBB2ALL DATE('B')+1\n  WHEN ABBREV(\"YESTERDAY\", p1) THEN CALL BBB2ALL DATE('B')-1\n  WHEN p2=''                   THEN DO   /* SAY 'Converting bbb'      */\n      IF p1 < 1 THEN DO\n          CALL SET_MSG , \"ccccc must be greater then 1!\", \"YES\"\n          EXIT ExitError\n      END\n      CALL BBB2ALL p1\n    END\n  WHEN \u00ac(DATATYPE(p2,'W'))     THEN CALL DISPLAY_HELP\n  WHEN p3=''                   THEN DO   /* 'Converting yyyy jjj'     */\n      year = EDPY(p1)\n      IF p2<1 | p2>366 THEN DO\n          CALL SET_MSG , \"Julian must be 1-366.\", \"YES\"\n          EXIT ExitError\n      END\n      IF p2=366 & \u00ac(IS_LEAP(year)) THEN DO\n          CALL SET_MSG , \"Julian must be 1-365 for\" year\".\", \"YES\"\n          EXIT ExitError\n      END\n      CALL BBB2ALL DATE(\"B\",RIGHT(year,2)||RIGHT(p2,3,\"0\"),\"J\")\n    END\n  WHEN DATATYPE(p3,'w')=0      THEN CALL DISPLAY_HELP\nOTHERWISE                                /* 'Converting mm dd yyyy'   */\n   year = EDPY(p3)\n   SELECT\n     WHEN p1<1 | p1>12                         THEN DO\n         CALL SET_MSG , \"Month must be 1-12\", \"YES\"\n         EXIT ExitError\n       END\n     WHEN  p2<1 | p2>31                        THEN DO\n         CALL SET_MSG , \"Day must be 1-31\", \"YES\"\n         EXIT ExitError\n       END\n     WHEN p2 = 29 & p1 = 02 & \u00ac(IS_LEAP(year)) THEN DO\n         CALL SET_MSG , \"February 29th not valid for '\"year\"'!\", \"YES\"\n         EXIT ExitError\n       END\n   OTHERWISE; NOP; END\n   CALL BBB2ALL DATE(\"B\",RIGHT(year,4)||RIGHT(p1,2,\"0\")||RIGHT(p2,2,\"0\"),\"S\")\nEND\n\nok = '*';\"SUBCOM TSO\"             /* How do we end this REXX?         */\nIF RC = 0 THEN DO                 /* If TSO, RETURN if CALLed         */\n   IF SYSVAR(\"SYSNEST\") = 'YES' THEN RETURN zzz\n   ELSE DO                       /* or if EXECed from CMD Line        */\n      CALL SET_MSG , zzz, \"YES\"\n      EXIT ExitError\n   END\n  END\nELSE RETURN zzz                   /* If MVS, RETURN                    */\n/***************************** REXX ************************************\n                            END of REXX\n****************************** REXX ************************************\n                       Beginning of PROCEDURES\n****************************** REXX ************************************/\n/***********************************************************************\n            INITIALIZE varables and get startup parameters\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0     /* REXX functional values for TRUE and FALSE    */\n                      /* INITIALIZE and process non-positional parms  */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n        Validate and format Year\n**********************************************************************/\nEDPY:\nARG py\n  SELECT\n    WHEN LENGTH(py) = 4 THEN IF py < 1 THEN DO /* Valid Year?        */\n       CALL SET_MSG ,\"'\"py\"' is an invalid Year! The Year must be > 1!\",,\n                     \"YES\"\n       EXIT 8\n      END\n    WHEN py < 50        THEN py = py + 2000    /* Y2K Windowing      */\n    WHEN py < 100       THEN py = py + 1900    /* Y2K Windowing      */\n  OTHERWISE; NOP; END\nRETURN py\n/**********************************************************************\n        Convert days since 1 ,1 ,1 AD to MMDDYY.JJJ\n          final results -- \"YYYY-MM-DD.JJJ BBBBBB Day-of-week\"\n**********************************************************************/\nBBB2ALL:                         /* CONVERT BBBBBB TO MM DD YYYY.JJJ */\nARG bbb .\n  dow = DATE(\"W\", bbb, \"B\")\n  PARSE VALUE DATE(\"S\", bbb, \"B\") WITH yyyy 5 mm 7 dd .\n\n  y1    = 365\n  y4    =  4*y1   + 1\n  y100  = 24*y4   + (4*y1)\n  y400  =  4*y100 + 1\n\n  y400s = bbb  %y400; l400s = bbb  //y400\n  y100s = l400s%y100; l100s = l400s//y100\n  y4s   = l100s%y4  ; l4s   = l100s//y4\n  y1s   = l4s  %y1  ; jjj   = l4s  //y1 + 1\n\n  IF jjj = 1 & dd = 31 & mm = 12 THEN jjj = 366\n\n  zzz=RIGHT(yyyy,4,'0')'-'RIGHT(mm,2,'0')'-'RIGHT(dd,2,'0')'.'RIGHT(jjj,3,'0'),\n      bbb dow\nRETURN\n/**********************************************************************\n      Is the Year a Leap Year?\n***********************************************************************/\nIS_LEAP:\nARG check_me .\n  SELECT\n    WHEN (check_me//400) = 0 THEN RETURN TRUE\n    WHEN (check_me//100) = 0 THEN RETURN FALSE\n    WHEN (check_me//  4) = 0 THEN RETURN TRUE\n  OTHERWISE;                      RETURN FALSE; END\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2DRAW": {"ttr": 117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01>\\x00R\\x01\\x01\\x13\\x1f\\x01\\x17%O\\x10)\\x03N\\x02U\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.62", "flags": 0, "createdate": "2001-05-11T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 846, "newlines": 597, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO creates basic SQL queries by retrieving the\n        description of a table. You must specify the name of the table\n        or view to be queried. You can specify the type of query you\n        want to compose, i.e. TYPE(SELECT), TYPE(INSERT), TYPE(LOAD),\n        or TYPE(UPDATE).  If you are not running under DB2I you will\n        need to specify the SSID of the DB2 subsystem, e.g. SSID(DBS1),\n        SSID(DBT1), SSID(DBT2), SSID(DBP1), or SSID(DBP2).\n\n   This ISPF MACRO is based on the DRAW Sample REXX Exec in the IBM\n        DB2 for OS/390 REXX Language Support Version 5 manual.\n\n  NOTE: DB2's ADDRESS DSNREXX interface requires the appropriate\n        DB2 SDSNLOAD to be in you STEPLIB or TASKLIB Concatination.\n\n                           --- EXAMPLE ---\n<%>DB2DRAW table <LINETYPE(DATA|NOTE)> <REXX(TRUE|FALSE)> ,\n                 <SSID(DB2_ssid)> <TEST(trace option)>    ,\n                 <TYPE(SELECT|INSERT|UPDATE|LOAD)>\n<%>DB2DRAW -H -- To display help for this ISPF Macro\n\n  Arguments: table       - The DB2 table to DRAW\n             inparms     - Non-Possitional parameters\n ----------------------------- NP-PARMS -------------------------------\n                LINETYPE - Insert Draw output as DATALINEs or NOTELINEs\n                           default: DATALINE\n                    REXX - Use to build DSNREXX format statments\n                           default: blank\n                    SSID - Specifies the SSID of the DB2 subsystem\n                           default: blank\n                    TEST - Used to control traces\n                    TYPE - The type of statement that DRAW builds\n                           default: SELECT\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\nISPF MACRO Name: DB2DRAW\n         Author: Al Hulsebosch (HUL2353)\n         Writen: 11MAY01\n        History: 18FEB02 - v1.39 - Check for owner. If none then add the\n                           default for that DB2 SSID.\n                 04FEB02 - v1.29 - Changes to SSID Verification to\n                           handle new SYSNAMEs.\n                 01JUN01 - v1.26 - Improved SQL Error handling!\n                 17MAY01 - v1.22 - Changes to move DB2 Error handling to\n                           common routines.\n                 14MAY01 - v1.18 - Add support for REXX Formated output\n                           and more cleanup.\n                 14MAY01 - v1.15 - Some more prettying up.\n                 11MAY01 - v1.0\n***************************** Rexx ***********************************/\nmsgstat = MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (table inparms) PROCESS\"\n\nCALL INITIALIZE_THIS_REXX\nSELECT\n  WHEN WORDPOS(table,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN table = \"\"                 THEN DO\n     CALL SET_MSG \"No DB2 table!\",\"What DB2 table do you want Drawn?\",\"YES\"\n     CALL DISPLAY_HELP\n    END\n  WHEN SSID = \"\"                  THEN DO\n     CALL SET_MSG \"No DB2 SSID!\",\"You need to specifya DB2 SSID!\",\"YES\"\n     CALL DISPLAY_HELP\n    END\nOTHERWISE;                              UPPER table; END\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n    ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"  /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='*';ADDRESS \"ISREDIT\" \"(LeftBnd,RightBnd) = BOUNDS\"\nIF REXX THEN LeftBnd=LeftBnd + 1\n   ELSE      LeftBnd=LeftBnd + 3\nBndSize=RightBnd-LeftBnd\nIf BndSize > 68 THEN BndSize=68\n\nSELECT     /* Based on RC From ISPF EDIT BOUNDS Command ...          */\n  WHEN RC = 0  THEN DO\n      ok='*';ADDRESS \"ISREDIT\" \"(ZDest) = LINENUM .ZCSR\"\n      IF ZDest=0 THEN ZDest=1\n    END\n  WHEN RC <= 8 THEN DO /* No A or B entered */\n      CALL SET_MSG 'Enter \"A\"/\"B\" line cmd',,\n                   'DRAW requires an \"A\" or \"B\" line command', \"YES\"\n      EXIT 12\n    END\n  WHEN RC < 20 THEN EXIT 12 /* Conflicting cmds - edit sets message  */\n  WHEN RC = 20 THEN ZDest=0\nOTHERWISE;          EXIT 12; END\n       /* Connect to DB2 and DESCRIBE the table                      */\nok='*'\n  ADDRESS \"DSNREXX\" \"CONNECT\" SSID\n    IF RC > 1 & SQLCODE \u00ac= 0 THEN CALL DISPLAY_SQLCA\n  ADDRESS \"DSNREXX\" \"EXECSQL DESCRIBE table :table INTO :SQLDA\"\n    IF SQLCODE \u00ac= 0 THEN CALL DISPLAY_SQLCA\n  ADDRESS \"DSNREXX\" \"EXECSQL COMMIT\"\n  ADDRESS \"DSNREXX\" \"DISCONNECT\"\nCALL DB2STEP SSID \"ADD_DROP(DROP)\"\n  IF SQLCODE \u00ac= 0 THEN CALL DISPLAY_SQLCA\n       /* Now figure out what to do with DESCRIBE and then do it!    */\nSELECT\n  WHEN ABBREV(TYPE, \"S\") & REXX THEN CALL DrawSELECT_REXX\n  WHEN ABBREV(TYPE, \"S\")        THEN CALL DrawSELECT\n  WHEN ABBREV(TYPE, \"I\") & REXX THEN CALL DrawInsert_REXX\n  WHEN ABBREV(TYPE, \"I\")        THEN CALL DrawInsert\n  WHEN ABBREV(TYPE, \"U\") & REXX THEN CALL DrawUpdate_REXX\n  WHEN ABBREV(TYPE, \"U\")        THEN CALL DrawUpdate\n  WHEN ABBREV(TYPE, \"L\")        THEN CALL DrawLoad\nOTHERWISE;                           EXIT 20; END\nok='0' /* RC=0 is only acceptable RC for LINE_AFTER in DO Loop       */\nDO I = Line.0 TO 1 BY -1\n    InsertLine=\"'\"LEFT(\" \",LeftBnd)||Line.I\"'\"\n    ADDRESS \"ISREDIT\" \"LINE_AFTER\" ZDest \"=\" LINETYPE InsertLine\nEND\nok='0';ADDRESS \"ISREDIT\" \"CURSOR =\" ZDest \"0\"\n\nmsgstat = MSG(msgstat)\nEXIT EXIT_error\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms=\"LINETYPE(DATALINE) REXX() SSID() TEST(O) TYPE(SELECT)\"\n  match_length=4                  /* NP-Parms match on first # chars  */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  no_submited=0\n  SYSUID=SYSVAR(\"SYSUID\")\n  user_prefix=LEFT(SYSUID,4)\n  EXIT_error=0; sql_error=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF ABBREV(LINETYPE,\"NOTE\") THEN LINETYPE=\"NOTELINE\"\n     ELSE                         LINETYPE=\"DATALINE\"\n\n  CALL VALIDATE_DB2_SSID SSID\n  IF INDEX(table, \".\") = 0 THEN table=owner\".\"table\n\n  IF REXX = \"\" THEN DO\n      ADDRESS \"ISREDIT\" \"(dsname) = DATASET\"\n      backwards=REVERSE(dsname)\n      SELECT\n        WHEN ABBREV(backwards, \"XXER\")    THEN REXX=TRUE\n        WHEN ABBREV(backwards, \"CEXE\")    THEN REXX=TRUE\n        WHEN ABBREV(backwards, \"TSILC\")   THEN REXX=TRUE\n        WHEN ABBREV(backwards, \"BILCPSI\") THEN REXX=TRUE\n        WHEN ABBREV(backwards, \"CORPSYS\") THEN REXX=TRUE\n      OTHERWISE;                               REXX=FALSE; END\n  END\n  IF SSID = \"\" THEN DO\n      ADDRESS \"ISPEXEC\" \"VGET (DSNEOV01)\"\n      IF RC = 0 THEN SSID=DSNEOV01\n  END\n  CALL DEFINE_DB2_TYPES\n\nRETURN\n/* COPY DBSUBSYS */\n/********************************************************************** /*COPY*/\n    Validate the DB2 SSID, verify it is up, and then set OWNER          /*COPY*/\n       Valid combinations are: DEV2 - DBS1 - NMLTEST                    /*COPY*/\n                               PRD1 - DBP1 - NMLPROD                    /*COPY*/\n                               TST2 - DBT1 - NMLPROD or NMLTEST         /*COPY*/\n                               TST2 - DBT2 - NMLTEST                    /*COPY*/\n                               TST2 - DBT3 - NMLTEST                    /*COPY*/\n***********************************************************************//*COPY*/\nVALIDATE_DB2_SSID:                                                      /*COPY*/\nARG SSID .                                                              /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(MVSVAR(\"SYSNAME\"), \"TST\")   THEN IF,                    /*COPY*/\n         WORDPOS(SSID,\"DBT1 DBT2 DBT3\") = 0 THEN DO                     /*COPY*/\n       SSID = \"DBT1\"; OWNER = \"NMLPROD\"                                 /*COPY*/\n     END                                                                /*COPY*/\n    WHEN ABBREV(MVSVAR(\"SYSNAME\"), \"DEV\")   THEN SSID = \"DBS1\"          /*COPY*/\n  OTHERWISE;                                     SSID = \"DBP1\"; END     /*COPY*/\n  IF CHECK_DB2(SSID \"YES\") \u00ac= 0  THEN EXIT 4                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(SSID, \"DBP\")     THEN OWNER = \"NMLPROD\"                 /*COPY*/\n    WHEN ABBREV(SSID, \"DBT\")     &,                                     /*COPY*/\n         ABBREV(\"NMLPROD\",OWNER) THEN OWNER = \"NMLPROD\"                 /*COPY*/\n    WHEN ABBREV(SSID, \"DBT\")     THEN OWNER = \"NMLTEST\"                 /*COPY*/\n    WHEN ABBREV(SSID, \"DBS\")     THEN OWNER = \"NMLTEST\"                 /*COPY*/\n  OTHERWISE;                          OWNER = \"DB_ERROR\"; END           /*COPY*/\nRETURN SSID                                                             /*COPY*/\n/* COPY CHECKDB2 */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n           Is DB2 Sub-System available at this time?                    /*COPY*/\n**********************************************************************/ /*COPY*/\nCHECK_DB2: PROCEDURE                                                    /*COPY*/\nARG SSID respond_on_fail .                                              /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM TSO\"                                     /*COPY*/\n  IF RC = 0 THEN IF DB2STEP(SSID \"ADD_DROP(ADD)\") > 0 THEN EXIT 8       /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM DSNREXX\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN x = RXSUBCOM('ADD','DSNREXX','DSNREXX')               /*COPY*/\n  ok='*';ADDRESS \"DSNREXX\" \"CONNECT\" SSID                               /*COPY*/\n  IF RC > 1 & ABBREV('YES', respond_on_fail, 1) THEN CALL SET_MSG,      /*COPY*/\n         SSID \"not up!\",                                         ,      /*COPY*/\n        \"The DB2 Sub-System\" SSID \"is not up at this time!\", \"YES\"      /*COPY*/\nRETURN RC                                                               /*COPY*/\n/* COPY DB2SUPP */\n/* COPY DB2TYPES */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n   This PROCEDURE sets up definitions for the various DB2 SQL Types     /*COPY*/\n***********************************************************************//*COPY*/\nDEFINE_DB2_TYPES:                                                       /*COPY*/\n  SQLTYPE. = \"UNKNOWN TYPE\"                                             /*COPY*/\n  DATYPE   = 384; SQLTYPES.DATYPE   = 'DATE'                            /*COPY*/\n  TITYPE   = 388; SQLTYPES.TITYPE   = 'TIME'                            /*COPY*/\n  TSTYPE   = 392; SQLTYPES.TSTYPE   = 'TIMESTAMP'                       /*COPY*/\n  BLOBTYP  = 404; SQLTYPES.BLOBTYP  = 'BLOB'                            /*COPY*/\n  CLOBTYP  = 408; SQLTYPES.CLOBTYP  = 'CLOB'                            /*COPY*/\n  DBCLTYP  = 412; SQLTYPES.DBCLTYP  = 'DBCLOB'                          /*COPY*/\n  VCHTYPE  = 448; SQLTYPES.VCHTYPE  = 'VARCHAR'                         /*COPY*/\n  CHTYPE   = 452; SQLTYPES.CHTYPE   = 'CHAR'                            /*COPY*/\n  LVCHTYPE = 456; SQLTYPES.LVCHTYPE = 'VARCHAR'                         /*COPY*/\n  VGRTYP   = 464; SQLTYPES.VGRTYP   = 'VARGRAPHIC'                      /*COPY*/\n  GRTYP    = 468; SQLTYPES.GRTYP    = 'GRAPHIC'                         /*COPY*/\n  LVGRTYP  = 472; SQLTYPES.LVGRTYP  = 'VARGRAPHIC'                      /*COPY*/\n  FLOTYPE  = 480; SQLTYPES.FLOTYPE  = 'FLOAT'                           /*COPY*/\n  DCTYPE   = 484; SQLTYPES.DCTYPE   = 'DECIMAL'                         /*COPY*/\n  INTYPE   = 496; SQLTYPES.INTYPE   = 'INTEGER'                         /*COPY*/\n  SMTYPE   = 500; SQLTYPES.SMTYPE   = 'SMALLINT'                        /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRORDB2 */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n    Determine current environment and then display SQLCA accordingly    /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_SQLCA:                                                          /*COPY*/\n  elineno = sigl - 1                /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   GET_ERROR_INFO             /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  SQLERRD = SQLERRD.1\",\"SQLERRD.2\",\",                                   /*COPY*/\n     || SQLERRD.3\",\"SQLERRD.4\",\"SQLERRD.5\",\"SQLERRD.6                   /*COPY*/\n  SQLWARN = SQLWARN.0\",\"SQLWARN.1\",\"SQLWARN.2\",\"SQLWARN.3\",\",           /*COPY*/\n     || SQLWARN.4\",\"SQLWARN.5\",\"SQLWARN.6\",\"SQLWARN.7\",\",               /*COPY*/\n     || SQLWARN.8\",\" SQLWARN.9\",\"SQLWARN.10                             /*COPY*/\n                                                                        /*COPY*/\n  IF INDEX(expandl, \"DSNREXX\") > 0 &,                                   /*COPY*/\n     INDEX(expandl, \"FROM :\")  > 0 THEN DO                              /*COPY*/\n      PARSE VALUE expandl WITH . \"FROM :\" eSQL                          /*COPY*/\n      eSQL = VALUE(eSQL)                                                /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE eSQL = \"  *--- Unable to determine SQL ---*\"                     /*COPY*/\n                                                                        /*COPY*/\n  ok='*';ADDRESS \"ISREDIT\" \"(maclevel) = MACRO_LEVEL\"                   /*COPY*/\n  IF RC = 0 THEN CALL DISPLAY_SQLCA_ISREDIT                             /*COPY*/\n  ELSE DO                                                               /*COPY*/\n      ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                             /*COPY*/\n      SELECT                                                            /*COPY*/\n        WHEN RC \u00ac= 0                   THEN CALL DISPLAY_SQLCA_MVS      /*COPY*/\n        WHEN SYSVAR('SYSENV') = 'BACK' THEN CALL DISPLAY_SQLCA_MVS      /*COPY*/\n      OTHERWISE                                                         /*COPY*/\n          ADDRESS \"ISPEXEC\" \"PQUERY PANEL(ERRORDB2) AREANAME(eSQL)\",    /*COPY*/\n                            \"WIDTH(width) DEPTH(depth)\"                 /*COPY*/\n          cur_ = 1; orig_eSQL = eSQL                                    /*COPY*/\n          orig_ = MAX(LENGTH(orig_eSQL), width+1)                       /*COPY*/\n          l_row = (orig_+width-1)%width                                 /*COPY*/\n          left_ = \"SQL ERROR Reporting\"                                 /*COPY*/\n          DO FOREVER                                                    /*COPY*/\n              top_ = (cur_%width) + 1                                   /*COPY*/\n              bottom_ =  MIN((top_ + depth) - 1, l_row)                 /*COPY*/\n              sqltitle = OVERLAY(left_, RIGHT(top_\"-\"bottom_ ,          /*COPY*/\n                                 \"of\" l_row,width-1))                   /*COPY*/\n              ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(ERRORDB2)\"               /*COPY*/\n              display_RC = RC                                           /*COPY*/\n              ADDRESS \"ISPEXEC\" \"VGET (ZVERB ZSCROLLN)\"                 /*COPY*/\n              SELECT                                                    /*COPY*/\n                WHEN display_RC = 8           THEN LEAVE                /*COPY*/\n                WHEN ABBREV(ZVERB, \"DOWN\")    THEN DO                   /*COPY*/\n                    cur_ = MIN(cur_ + (ZSCROLLN*width), orig_-width)    /*COPY*/\n                    eSQL = SUBSTR(orig_eSQL, cur_)                      /*COPY*/\n                  END                                                   /*COPY*/\n                WHEN ABBREV(ZVERB, \"UP\")      THEN DO                   /*COPY*/\n                    cur_ = MAX(cur_ - (ZSCROLLN*width), 1)              /*COPY*/\n                    eSQL = SUBSTR(orig_eSQL, cur_)                      /*COPY*/\n                  END                                                   /*COPY*/\n              OTHERWISE; NOP; END                                       /*COPY*/\n          END                                                           /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n        /* Done with DB2, cleanup up the connection                  */ /*COPY*/\n  ok='*';ADDRESS \"DSNREXX\" \"DISCONNECT\"                                 /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM TSO\"                                     /*COPY*/\n  IF RC = 0 THEN CALL DB2STEP SSID \"ADD_DROP(DROP)\"                     /*COPY*/\n  exit_rc = SQLCODE                                                     /*COPY*/\nCALL CLEANUP                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n    Display the DB2 SQLCA when under ISPF EDIT                          /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_SQLCA_ISREDIT:                                                  /*COPY*/\n  x = \" BAD SQL =\" LEFT(eSQL,LINESIZE() - 20)                           /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \" BAD CMD =\" LEFT(expandl,LINESIZE() - 20)                        /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \" SQLWARN =\" SQLWARN                                              /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \" SQLERRD =\" SQLERRD                                              /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \" SQLERRP =\" SQLERRP                                              /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \" SQLERRM =\" SQLERRM                                              /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \"SQLSTATE =\" SQLSTATE                                             /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\n  x = \" SQLCODE =\" SQLCODE                                              /*COPY*/\n  ok='0 4';ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = MSGLINE (x)\"           /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n    Display the DB2 SQLCA when under ISPF                               /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_SQLCA_MVS:                                                      /*COPY*/\n  SAY \"A SQL Error in\" erexx \"has occured!\"                             /*COPY*/\n  SAY \"Resulting in an DSNREXX RC of:\" erc \"on Line\" elineno            /*COPY*/\n  SAY \"Line No.\" elineno \"is '\"expandl\"'\"                               /*COPY*/\n  SAY \"  --------    ----------------------------\"                      /*COPY*/\n  SAY \"   SQLCODE = '\"SQLCODE\"'\"                                        /*COPY*/\n  SAY \"  SQLSTATE = '\"SQLSTATE\"'\"                                       /*COPY*/\n  SAY \"   SQLERRM = '\"SQLERRM\"'\"                                        /*COPY*/\n  SAY \"   SQLERRP = '\"SQLERRP\"'\"                                        /*COPY*/\n  SAY \"   SQLERRD = '\"SQLERRD\"'\"                                        /*COPY*/\n  SAY \"   SQLWARN = '\"SQLWARN\"'\"                                        /*COPY*/\n  SAY \"   BAD SQL =  \"eSQL                                              /*COPY*/\n  SAY \"  --------    ----------------------------\"                      /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG exit_or_return .                                                    /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n      source.i = SOURCELINE(i + 1)  /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO   /* No ISPF, use SAY to display help            *//*COPY*/\n      DO i = 1 TO i                                                     /*COPY*/\n          SAY source.i                                                  /*COPY*/\n      END                                                               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n      PARSE SOURCE . . rname .      /* Get REXX EXEC name             *//*COPY*/\n                                                                        /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\" /*COPY*/\n      DO i = 1 TO i    /* Build HELP table to display                 *//*COPY*/\n          source = source.i                                             /*COPY*/\n          ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"                             /*COPY*/\n      END                                                               /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                          /*COPY*/\n      ZTDMARK = CENTER(\"----> END of Help <----\",80)                    /*COPY*/\n      ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"     /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                        /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',exit_or_return,3) THEN RETURN                        /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Possitional Parms in a           /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  vp_list = valid_parms ' '; in_list = inparms ' '                      /*COPY*/\n  parm_list = ''; parm_error_list = ''                                  /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(valid_parms) UNTIL vp_list = ''                  /*COPY*/\n      PARSE VALUE vp_list WITH parm.linx '(' parm_val.linx ') ' vp_list /*COPY*/\n      parm_list = parm_list STRIP(LEFT(parm.linx,match_length))         /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(in_list, '(') > 0                                      /*COPY*/\n      PARSE VALUE in_list WITH parm '(' value ') ' in_list              /*COPY*/\n      UPPER parm           /* Don't want to translate value to UPPER */ /*COPY*/\n      parm = STRIP(parm)                                                /*COPY*/\n      parm_number = WORDPOS(STRIP(LEFT(parm,match_length)), parm_list)  /*COPY*/\n      IF parm_number > 0 THEN parm_val.parm_number = value              /*COPY*/\n      ELSE IF INDEX(value,\")\") > 0 THEN                                 /*COPY*/\n           parm_error_list = parm_error_list parm\"(\"value               /*COPY*/\n      ELSE parm_error_list = parm_error_list parm\"(\"value\")\"            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN parm_error_list \u00ac= '' & accept_all = TRUE THEN                 /*COPY*/\n        anything_else = STRIP(in_list) parm_error_list                  /*COPY*/\n    WHEN parm_error_list \u00ac= ''                     THEN DO              /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"parm_error_list\"' not valid Parm(s) for\" rname\"!\", \"YES\" /*COPY*/\n        EXIT 8                                                          /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      anything_else = STRIP(in_list)                                    /*COPY*/\n  END                                                                   /*COPY*/\n  DO parm_inx = 1 TO linx                                               /*COPY*/\n      SELECT                                                            /*COPY*/\n        WHEN ABBREV(parm_val.parm_inx, \"&\")               |,            /*COPY*/\n             ABBREV(parm_val.parm_inx, \"*\")               THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"           /*COPY*/\n        WHEN DATATYPE(parm_val.parm_inx, \"NUM\")           THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN WORDPOS(parm_val.parm_inx, \"FALSE TRUE\") > 0 THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN (LEFT(parm_val.parm_inx,1) = \"'\"             & ,           /*COPY*/\n              RIGHT(parm_val.parm_inx,1) = \"'\")           | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,':') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'*') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'%') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'=') > 0             THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= parm_val.\"parm_inx               /*COPY*/\n        WHEN INDEX(STRIP(parm_val.parm_inx), \" \") > 0     THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n      OTHERWISE                                                         /*COPY*/\n          ADDRESS \"MVS\" \"SUBCOM TSO\"                                    /*COPY*/\n          IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE       /*COPY*/\n          PARSE VALUE parm_val.parm_inx WITH PDS_name '(' rest          /*COPY*/\n          SELECT                                                        /*COPY*/\n            WHEN \u00ac(TSO_avail)                            THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN SYSVAR(\"SYSNEST\") = 'YES'               THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN (INDEX(rest, \")\") > 0                   &,             /*COPY*/\n                 (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")   |,             /*COPY*/\n                  ABBREV(rest, \"0)\")))                   THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"       /*COPY*/\n            WHEN (LISTDSI(parm_val.parm_inx)       <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"parm_val.parm_inx\"'\") <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"PDS_name\"'\")          <= 4  | ,            /*COPY*/\n                  LISTDSI(PDS_name)                <= 4) THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= parm_val.\"parm_inx           /*COPY*/\n          OTHERWISE                                                     /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n          END                                                           /*COPY*/\n          INTERPRET parm.parm_inx \"=\" parm_val.parm_inx                 /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM                              /*COPY*/\n  IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'                   /*COPY*/\n     ELSE ZERRALRM = 'NO'                                               /*COPY*/\n  IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                       /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ002)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n     Draw SELECT for a REXX EXEC Using DSNREXX\n***********************************************************************/\nDrawSELECT_REXX:\n  Line.0=0; Line='sql_SELECT=\"SELECT '\n  DO I=1 TO SQLDA.SQLD\n      IF I > 1 THEN Line=Line', '\n      Null=SQLDA.I.SQLTYPE//2\n      IF LENGTH(Line SQLDA.I.SQLNAME'\" ,') >= BndSize THEN DO\n         L=Line.0 + 1; Line.0=L; Line.L=Line'\" ,'; Line=RIGHT('\"',21)\n      END\n      Line=Line||SQLDA.I.SQLNAME\n  END I\n  IF Line \u00ac= \"\" THEN DO; L=Line.0 + 1; Line.0=L; Line.L=Line'\" ,'; END\n  L=Line.0+1; Line.0=L; Line.L=RIGHT('\"FROM',19) table '\" ,'\n  L=Line.0+1; Line.0=L; Line.L=RIGHT('\"WHERE',19) RIGHT('\"',48)\nRETURN\n/**********************************************************************\n     Draw SELECT\n***********************************************************************/\nDrawSELECT:\n  Line.0=0; Line=\"SELECT\"\n  DO I=1 TO SQLDA.SQLD\n      IF I > 1 THEN Line=Line\",\"\n      Null=SQLDA.I.SQLTYPE//2\n      IF LENGTH(Line SQLDA.I.SQLNAME\",\") >= BndSize THEN DO\n          L=Line.0+1; Line.0=L; Line.L=Line; Line=LEFT(\"\",6)\n      END\n      Line=Line SQLDA.I.SQLNAME\n  END I\n  IF Line \u00ac= \"\" THEN DO; L=Line.0+1; Line.0=L; Line.L=Line; END\n  L=Line.0+1; Line.0=L; Line.L=\"  FROM\" table\nRETURN\n/**********************************************************************\n      Draw INSERT for a REXX EXEC Using DSNREXX\n***********************************************************************/\nDrawINSERT_REXX:\n  Line.0=0; Line='sql_INSERT=\"INSERT INTO' table '('\n  DO I=1 TO SQLDA.SQLD\n      IF I > 1 THEN Line=Line', '\n      IF LENGTH(Line SQLDA.I.SQLNAME'\" ,') >= BndSize THEN DO\n          L=Line.0+1; Line.0=L; Line.L=Line'\" ,'; Line=RIGHT('\"',21)\n      END\n      Line=Line||SQLDA.I.SQLNAME\n      IF I = SQLDA.SQLD THEN Line=Line ')'\n  END I\n  IF Line \u00ac= \"\" THEN DO\n      L=Line.0+1; Line.0=L; Line.L=Line'\" ,'; Line=RIGHT('\"',21)\n    END\n  L=Line.0+1; Line.0=L; Line.L=LEFT(\"\",12)'\"VALUES (\" ,',\n                              \"        /* Enter values over column name   */\"\n  DO I=1 TO SQLDA.SQLD\n      IF SQLDA.SQLD = 1 THEN Line=RIGHT('\"  ',22)\n         ELSE                Line=RIGHT('\", ',22)\n      Line=Line || Left(SQLDA.I.SQLNAME,18)'\", /*'\n      Type=SQLDA.I.SQLTYPE\n      Null=Type//2\n      IF Null THEN Type=Type - 1\n      Len=SQLDA.I.SQLLEN\n      SELECT\n        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,\n             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP ) THEN\n           Type=SQLTYPES.Type\"(\"STRIP(Len)\")\"\n        WHEN (Type = FLOTYPE )                                THEN\n           Type=SQLTYPES.Type\"(\"STRIP((Len*4)-11) \")\"\n        WHEN (Type = DCTYPE )                                 THEN DO\n            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION\n            Scale = SQLDA.I.SQLLEN.SQLSCALE\n            Type=SQLTYPES.Type\"(\"STRIP(Prcsn)\",\"STRIP(Scale)\")\"\n          END\n      OTHERWISE; Type=SQLTYPES.Type; END\n      L=Line.0 + 1; Line.0=L\n      IF Null = 0 THEN Line.L=Line LEFT(Type,12) \"NOT NULL */\"\n         ELSE          Line.L=Line LEFT(Type,21) \"*/\"\n  END I\n  L=Line.0 + 1; Line.0=L; Line.L=RIGHT('\")\"',22)\nRETURN\n/**********************************************************************\n      Draw INSERT\n***********************************************************************/\nDrawINSERT:\n  Line.0=0; Line=\"INSERT INTO\" table \"(\"\n  DO I=1 TO SQLDA.SQLD\n      IF I > 1 THEN Line=Line\",\"\n      IF LENGTH(Line SQLDA.I.SQLNAME\",\") >= BndSize THEN DO\n          L=Line.0+1; Line.0=L; Line.L=Line; Line=LEFT(\"\",6)\n      END\n      Line=Line SQLDA.I.SQLNAME\n      IF I = SQLDA.SQLD THEN Line=Line ')'\n  END I\n  IF Line \u00ac= \"\" THEN DO; L=Line.0+1;Line.0=L;Line.L=Line;Line=LEFT(\"\",6); END\n  L=Line.0 + 1; Line.0=L; Line.L=\"VALUES (\",\n                             \" -- ENTER VALUES BELOW COLUMN NAME DATA TYPE\"\n  DO I=1 TO SQLDA.SQLD\n      IF SQLDA.SQLD = 1 THEN Line=RIGHT('  --',11)\n         ELSE                Line=RIGHT(', --',11)\n      Line=Line Left(SQLDA.I.SQLNAME,18)\n      Type=SQLDA.I.SQLTYPE\n      Null=Type//2\n      IF Null THEN Type=Type - 1\n      Len=SQLDA.I.SQLLEN\n      SELECT\n        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,\n             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP ) THEN\n           Type=SQLTYPES.Type\"(\"STRIP(Len)\")\"\n        WHEN (Type = FLOTYPE )                                THEN\n           Type=SQLTYPES.Type\"(\"STRIP((Len*4)-11) \")\"\n        WHEN (Type = DCTYPE )                                 THEN DO\n            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION\n            Scale = SQLDA.I.SQLLEN.SQLSCALE\n            Type=SQLTYPES.Type\"(\"STRIP(Prcsn)\",\"STRIP(Scale)\")\"\n          END\n      OTHERWISE; Type=SQLTYPES.Type; END\n      L=Line.0 + 1; Line.0=L\n      IF Null = 0 THEN Line.L=Line LEFT(Type,12) \"NOT NULL\"\n         ELSE          Line.L=Line Type\n  END I\n  L=Line.0+1; Line.0=L; Line.L=RIGHT(\")\",8)\nRETURN\n/**********************************************************************\n     Draw UPDATE for a REXX EXEC Using DSNREXX\n***********************************************************************/\nDrawUPDATE_REXX:\n  Line.0=1; Line.1='sql_UPDATE= \"UPDATE' table 'SET\" ,'\n  L=Line.0 + 1; Line.0=L\n  Line.L=LEFT(\"\",16) \"/* Colume Name ENTER values over comment           */\"\n  DO I=1 TO SQLDA.SQLD\n      IF I = 1 THEN Line=RIGHT('\" ',19); ELSE Line=RIGHT('\",',19)\n      Line=Line LEFT(SQLDA.I.SQLNAME,18) \"= /*\"\n      Type=SQLDA.I.SQLTYPE\n      Null=Type//2\n      IF Null THEN Type=Type - 1\n      Len=SQLDA.I.SQLLEN\n      SELECT\n        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,\n             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP) THEN\n           Type=SQLTYPES.Type\"(\"STRIP(Len)\")\"\n        WHEN (Type = FLOTYPE )                               THEN\n           Type=SQLTYPES.Type\"(\"STRIP((Len*4)-11)\")\"\n        WHEN (Type = DCTYPE )                                THEN DO\n            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION\n            Scale = SQLDA.I.SQLLEN.SQLSCALE\n            Type=SQLTYPES.Type\"(\"STRIP(Prcsn)\",\"STRIP(Scale)\")\"\n          END\n      OTHERWISE; Type=SQLTYPES.Type; END\n      L=Line.0+1; Line.0=L\n      IF Null = 0 THEN Line.L=Line LEFT(Type,12) \"NOT NULL */\"\n         ELSE          Line.L=Line LEFT(Type,21) \"*/\"\n  END I\n  L=Line.0+1; Line.0=L; Line.L=RIGHT('\"WHERE',19) RIGHT('\"',48)\nRETURN\n/**********************************************************************\n     Draw UPDATE\n***********************************************************************/\nDrawUPDATE:\n  Line.0=1; Line.1=\"UPDATE\" table \"SET\"\n  L=Line.0 + 1; Line.0=L\n  Line.L=LEFT(\"\",4)\"-- Column Name            ENTER values over data type\"\n  DO I=1 TO SQLDA.SQLD\n      IF I = 1 THEN Line=RIGHT(\"\",6); ELSE Line=RIGHT(\",\",6)\n      Line=Line LEFT(SQLDA.I.SQLNAME, 18) \"=\"\n      Type=SQLDA.I.SQLTYPE\n      Null=Type//2\n      IF Null THEN Type=Type - 1\n      Len=SQLDA.I.SQLLEN\n      SELECT\n        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,\n             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP) THEN\n           Type=SQLTYPES.Type\"(\"STRIP(Len)\")\"\n        WHEN (Type = FLOTYPE )                               THEN\n           Type=SQLTYPES.Type\"(\"STRIP((Len*4)-11)\")\"\n        WHEN (Type = DCTYPE )                                THEN DO\n            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION\n            Scale = SQLDA.I.SQLLEN.SQLSCALE\n            Type=SQLTYPES.Type\"(\"STRIP(Prcsn)\",\"STRIP(Scale)\")\"\n          END\n      OTHERWISE; Type=SQLTYPES.Type; END\n      Line=Line \"--\" LEFT(Type,14)\n      IF Null = 0 THEN Line=Line \"NOT NULL\"\n      L=Line.0+1; Line.0=L; Line.L=Line\n  END I\n  L=Line.0+1; Line.0=L; Line.L=\" WHERE\"\nRETURN\n/**********************************************************************\n     Draw LOAD\n***********************************************************************/\nDrawLOAD:\n  Line.0=1; Line.1=\"LOAD DATA INDDN SYSREC\"\n  Line.0=2; Line.2=\"         INTO table\" table\n  Line.0=3; Line.3=\"      -- REPLACE\"\n  Line.0=4; Line.4=\"      -- LOG  NO\"\n  Line.0=5; Line.5=\"      -- WHEN(###:###)='??????????'\"\n  Position=1\n  DO I=1 TO SQLDA.SQLD\n      IF I = 1 THEN Line=RIGHT(\"(\",4); ELSE Line=RIGHT(\",\",4)\n      Line=Line Left(SQLDA.I.SQLNAME,20)\n      Line=Line \"POSITION(\"RIGHT(Position,5)\")\"\n      Type=SQLDA.I.SQLTYPE\n      Null=Type//2\n      IF Null THEN Type=Type - 1\n      Len=SQLDA.I.SQLLEN\n      SELECT\n        WHEN (Type = CHTYPE|Type = GRTYP )                THEN\n            Type=SQLTYPES.Type\"(\"STRIP(Len)\")\"\n        WHEN (Type = FLOTYPE )                            THEN\n            Type=SQLTYPES.Type\"(\"STRIP((Len*4)-11) \")\"\n        WHEN (Type = DCTYPE )                             THEN DO\n            Prcsn=SQLDA.I.SQLLEN.SQLPRECISION\n            Scale=SQLDA.I.SQLLEN.SQLSCALE\n            Type=SQLTYPES.Type \"EXTERNAL\"\n            Type=Type\"(\"STRIP(Prcsn)\",\"STRIP(Scale)\")\"\n            Len=(Prcsn+2)%2\n          END\n        WHEN WORDPOS(Type,DATYPE TITYPE TSTYPE) > 0       THEN\n            Type=SQLTYPES.Type \"EXTERNAL\"\n      OTHERWISE; Type=SQLTYPES.Type; END\n      SELECT\n        WHEN WORDPOS(Type,DATYPE TITYPE TSTYPE) > 0          THEN Len=Len*2\n        WHEN WORDPOS(Type,VCHTYPE LVCHTYPE VGTYPE LVGRTYP)>0 THEN Len=Len+2\n      OTHERWISE; NOP; END\n      Line=Line Type; L=Line.0+1; Line.0=L; Line.L=Line\n      IF Null = 1 THEN DO\n          Line=LEFT(\"\",22) \"NULLIF(\"RIGHT(Position,5)\")='?'\"\n          L=Line.0+1; Line.0=L; Line.L=Line\n      END\n      Position=Position + Len + 1\n  END I\n  L=Line.0+1; Line.0=L; Line.L=\" )\"\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    CALL DB2STEP SSID \"ADD_DROP(DROP)\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ZISPFRC=exit_error                 /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT exit_error                        /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok = '*' THEN RETURN  /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n            PARSE PULL eresult                                          /*COPY*/\n            eresults = STRIP(eresults \"NL ===>\" eresult)                /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n      nextl = SOURCELINE(elineno + e_i)                                 /*COPY*/\n      IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)       /*COPY*/\n      sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                     /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n      ecause  = ERRORTEXT(RC)       /* Brief description of error     *//*COPY*/\n      expandl = \"Can't INTERPRET source with SYNTAX errors!\"            /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n      ecause  = CONDITION('D')      /* Brief description of error     *//*COPY*/\n      full_line = sourcel           /* Begin getting EXECuted source  *//*COPY*/\n      PARSE VALUE full_line WITH srcl ';' full_line                     /*COPY*/\n      IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) &,                               /*COPY*/\n         \u00ac(ABBREV(STRIP(srcl),\"SAY\"))  THEN INTERPRET \"evals =\" srcl    /*COPY*/\n          ELSE evals = \"\"                                               /*COPY*/\n      IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl          /*COPY*/\n      expandl = evals                                                   /*COPY*/\n      DO WHILE full_line \u00ac= ''      /* loop to handle ';' in source   *//*COPY*/\n          PARSE VALUE full_line WITH srcl ';' full_line                 /*COPY*/\n          IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) THEN INTERPRET \"evals =\" srcl/*COPY*/\n              ELSE evals = \"\"                                           /*COPY*/\n          IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl      /*COPY*/\n          expandl = expandl ';' evals                                   /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR'      THEN           /*COPY*/\n         emsg = ZERRLM                                                  /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') = 'VAR' & SYSMSGLVL1 \u00ac= \"\" THEN           /*COPY*/\n         IF SYMBOL('SYSMSGLVL2') = 'VAR'                 THEN           /*COPY*/\n              emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                         /*COPY*/\n         ELSE emsg = SYSMSGLVL1                                         /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      emsg = 'No available ERROR description.'                          /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0 THEN                      /*COPY*/\n     QUEUE \"SYSREASON: '\"SYSREASON\"'\"                                   /*COPY*/\n  IF etype = 'NOVALUE' THEN exit_error = 4   /* Set EXIT error level  *//*COPY*/\n     ELSE exit_error = RC                                               /*COPY*/\n  erc = exit_error      /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  TRACE(\"O\")                                                            /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresults = 1 TO eresult.0                                          /*COPY*/\n      PARSE PULL eresult.eresults                                       /*COPY*/\n  END                                                                   /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls) /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(LEFT('          Error Type:' etype,80),ls)                 /*COPY*/\n  SAY CENTER(LEFT('         Error Cause:' ecause,80),ls)                /*COPY*/\n  SAY CENTER(LEFT('                  RC:' erc,80),ls)                   /*COPY*/\n  SAY CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)             /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n      SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)  /*COPY*/\n  END                                                                   /*COPY*/\n  SAY CENTER(LEFT('         Source Line:' elineno,80),ls)               /*COPY*/\n  SAY LEFT('   Error Description:' emsg,ls)                             /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('Source line reads as:' sourcel,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('  Source EXECutes as:' expandl,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\n  SAY ''                                                                /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = exit_error              /* SET ISPF RC to exit_error      *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT exit_error                     /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSLIST": {"ttr": 35, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1c\\x00R\\x01\\x061/\\x01\\x17%O\\x10)\\x02\\xfc\\x01\\xb7\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.28", "flags": 0, "createdate": "2006-11-08T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 764, "newlines": 439, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to test out IGGCSI00 (the Catalog Search Interface)\n      programming. This REXX does not require TSO, i.e. it can run\n      under the IRXJCL Batch interface.\n\nNOTE: This was writen before I had access to ISPF's DSLIST Command.\n      Remember to use a leading '%' under ISPF to ensure you get\n      this REXX EXEC vs. ISPF's DSLIST DSN Listing Command.\n\n                           --- EXAMPLE ---\n<TSO> <%>DSLIST DsnLevel <CATALOG(CatalogName)> <TEST(TraceOption)>,\n               <CSIDTYPS(TypesToDisplay)> <FIELDS(FieldsToDisplay)>,\n               <CALLED(TRUE|FALSE)>\n<TSO> <%>DSLIST -H -- To display help for this REXX\n\n  Arguments: DsnLevel    - Standard SMS DSN pattern template\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                  CALLED - Was this Called as a function? default: FALSE\n                 CATALOG - Name of Catalog to search.     default: Blank\n                CSIDTYPS - DSN Types to list.             default: A\n                     NOTE: CSIDTYPS is not checked before use!\n                           Valid entires are only 'ABCGHLRUWX'\n                           A - non-VSAM data set\n                           B - Generation data group\n                           C - Cluster\n                           G - Alternate index\n                           H - Generation data set\n                           L - Tape volume catalog library entry\n                           R - VSAM path\n                           U - User catalog connector entry\n                           W - Tape volume catalog volume entry\n                           X - Alias\n                  FIELDS - Additional fields to display.  default: VOLSER 6\n                     NOTE: FIELDS Values are not checked before use!\n                     NOTE: If DEFAULT is used, list is by CSIDTYPS used\n                    TEST - Used to control traces.        default: Off\n\n      Files: Input data is pulled from the System Catalog STC\nOther EXECS: NONE\n      Other: This requires STEMPUSH & STEMPULL from CBTTape.org to\n             use as a CALLed Function by other EXECs\n\nEXEC History\n\n REXX EXEC Name: DSLIST\n         Author: AL FERGUSON - TS ADM (TSAZFA) from v1.84\n                 FERGUSON AL (HUL2353)\n         Writen: 08NOV06\n        History: 07AUG17 - v2.22 - Minor refactoring of IGG Common Code\n                 06AUG17 - v2.21 - Support for FIELD Checking & Lookup\n                 06FEB17 - v2.08 - Update versions of Common Code.\n                 11JAN17 - v2.01 - Minor refactoring\n                 21DEC16 - v1.89 - Minor refactoring\n                 19OCT16 - v1.88 - Minor refactoring\n                 28JUN16 - v1.86 - Minor refactoring for performace\n                 14APR16 - v1.84 - Update Default Field Processing\n                 05OCT11 - v1.68 - Refactor VSAMTYPE.\n                           Add ENTYPE & VSAMREUS interpretation.\n                 21JUN11 - v1.65 - Update support for Tape Volume\n                           Catalog Library/Volume entry. Add G0000V00\n                           count to GDG DEFAULT Fields.\n                 09JUN11 - v1.63 - Formating for GENLEVEL & FIELD(DEBUG)\n                 08JUN11 - v1.59 - Add Data Field expansions and some\n                           DEFAULT Fields for some dataset types.\n                 02JUN11 - v1.51 - Add conversion support for LTBACKDT,\n                           RECVTIME, & RECVTIMG (TOD Format), as well\n                           as GDGALTDT (in PACKED Decimal)\n                 11FEB11 - v1.45 - Fix handling multiple FIELDS and the\n                           translation of DSCRDT2 & DSEXDT2 FIELDS from\n                           PACKED Decimal to Julian Date.\n                 03FEB11 - v1.41 - Add support for using as a CALLed\n                           REXX function, returning the DSList vs\n                           displaying it. This returns the list using\n                           the CBT STEMPUSH & STEMPOP functions.\n                 01DEC09 - v1.22 - Move CSIDTYPS and FIELDS to NPPARMS\n                           vs hard coded values.\n                 09NOV06 - v1.08 - 1st Working version with FIELDS\n                 08NOV06 - v1.00\n***************************** Rexx ***********************************/\nADDRESS \"MVS\" \"SUBCOM TSO\"                /* Is TSO available?       */\nIF RC = 0 THEN MsgStat=MSG(\"OFF\")\nARG DsnLevel InParms                      /* Place arguments here    */\n\nSELECT\n  WHEN WORDPOS(DsnLevel,'-h -H')  > 0 THEN CALL DISPLAY_HELP\n  WHEN DsnLevel = \"\"                  THEN DO\n     CALL SET_MSG \"DSN Filter needed!\",,\n          \"This needs a DSN filter to find information for!\", \"YES\"\n     EXIT 4\n    END\nOTHERWISE; CALL INITIALIZE_THIS_REXX; END\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL SET_IGGCSI_DEFAULTS\nCALL INITIALIZE_IGGCSI_API\n\nDO UNTIL RESUME \u00ac= 'Y'                /*  SET UP LOOP FOR RESUME       */\n   ok='*';ADDRESS \"LINKPGM\" \"IGGCSI00 MODRSNRC CSIFIELD DWORK\"\n   IF RC \u00ac= 0 THEN CALL DISPLAY_IGGCSI_ERROR\n\n   RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */\n   PARSE VALUE DWORK WITH . +8 CSIUSDLN +4 CSINUMFD +2 rest\n   rest = LEFT(rest, C2D(CSIUSDLN)-14)\n   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/\n      PARSE VALUE rest WITH CSICFLG  +1 CSICTYPE +1 CSICNAME +44 CSICRETM,\n                         +2 CSICRETR +1 CSICRETN +1 rest\n      IF CSICTYPE = '0' THEN CALL PROCESS_CATALOGS\n         ELSE                CALL PROCESS_NONCATALOGS\n   END\nEND\n\nIF CALLED THEN RETURN STEMPUSH(\"dsns.\")\n   ELSE DO k = 1 TO dsns.0; SAY dsns.k; END\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"CALLED(FALSE) CATALOG() CSIDTYPS(A) FIELDS() TEST(O)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF CALLED \u00ac= TRUE THEN CALLED = FALSE\n  DEBUG = FALSE; DEFAULT = TRUE\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Set various IGGCSI Defaults based on Passed Parameter\n***********************************************************************/\nSET_IGGCSI_DEFAULTS:\n  SELECT  /* Initialize DEFAULT FIELDS Values per CSID Type           */\n    WHEN CSIDTYPS = \"A\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* non-VSAM       */\n         FIELDS = 'VOLSER DSCRDT2 LTBACKDT'\n    WHEN CSIDTYPS = \"AX\" & ABBREV(\"DEFAULT\", FIELDS) THEN /* nonVSAM & Alias */\n         FIELDS = 'VOLSER DSCRDT2 NAME'\n    WHEN CSIDTYPS = \"B\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* GDG Base       */\n         FIELDS = 'GDGLIMIT GENLEVEL DSCRDT2 GDGALTDT GDGATTR'\n    WHEN CSIDTYPS = \"B\" & ABBREV(FIELDS, \"DEBUG\")   THEN DO /* GDG Base       */\n         FIELDS = 'GDGLIMIT DSCRDT2 GDGALTDT GDGATTR GENLEVEL'\n         DEBUG = TRUE; DEFAULT = FALSE\n      END\n    WHEN CSIDTYPS = \"C\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* VSAM Cluster   */\n         FIELDS = 'ENTYPE FSDSFLAG VSAMTYPE'\n    WHEN CSIDTYPS = \"G\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* VSAM AIX       */\n         FIELDS = 'AKEYPOS'\n    WHEN CSIDTYPS = \"H\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* GDG DSN        */\n         FIELDS = 'VOLSER DSCRDT2 LTBACKDT'\n    WHEN CSIDTYPS = \"L\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* Tape Library   */\n         FIELDS = 'LCBCONID'\n    WHEN CSIDTYPS = \"R\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* VSAM Path      */\n         FIELDS = 'NAME'\n    WHEN CSIDTYPS = \"U\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* USER Catalog   */\n         FIELDS = 'NAME'\n    WHEN CSIDTYPS = \"W\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* Tape Volume Ent*/\n         FIELDS = 'VCBLIBNM'\n    WHEN CSIDTYPS = \"X\" & ABBREV(\"DEFAULT\", FIELDS) THEN    /* Alias          */\n         FIELDS = 'NAME'\n  OTHERWISE; DEFAULT = FALSE; END\n          /* Initial variables used by IGGCSI interface (& Macro)     */\nRETURN\n/* COPY IGGINIT */\n/********************************************************************** /*COPY*/\n      Initialze the API before calling IGGCSI                           /*COPY*/\n***********************************************************************//*COPY*/\nINITIALIZE_IGGCSI_API:                                                  /*COPY*/\n  MODRSNRC = LEFT(' ',4)              /* CLEAR MODULE/RETURN/REASON   *//*COPY*/\n  CSIFILTK = LEFT(STRIP(DsnLevel,\"B\",\"'\"),44) /*MOVE FILTER INTO LIST*/ /*COPY*/\n  CSICATNM = LEFT(STRIP(CATALOG,\"B\",\"'\"),44)   /*   SET CATALOG NAME  *//*COPY*/\n  CSIRESNM = LEFT(' ',44)             /* CLEAR RESUME NAME            *//*COPY*/\n  CSIDTYPS = LEFT(CSIDTYPS,16)        /* ABCGHRUX are valid entries   *//*COPY*/\n  CSICLDI  = LEFT('Y',1)              /* INDICATE DATA AND INDEX      *//*COPY*/\n  CSIRESUM = LEFT(' ',1)              /* CLEAR RESUME FLAG            *//*COPY*/\n  IF CATALOG = \"\" THEN                /* Did we specify a catalog?    *//*COPY*/\n       CSIS1CAT = LEFT(' ',1)         /* ... No, search > 1 Catalog   *//*COPY*/\n  ELSE CSIS1CAT = LEFT('Y',1)         /* ... Yes, search that Catalog *//*COPY*/\n  CSIOPTNS = LEFT(' ',1)              /* CLEAR RESERVE CHARACTER      *//*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN WORDS(FIELDS)            = 0     THEN DO; fld.=\"\"; fld.0=0; END/*COPY*/\n    WHEN WORDS(FIELDS)            = 1     THEN CALL FLDS_WO_LENGTH      /*COPY*/\n    WHEN DATATYPE(WORD(FIELDS,2)) = \"NUM\" THEN CALL FLDS_WITH_LENGTH    /*COPY*/\n    WHEN WORD(FIELDS,2) = \"VL\"            THEN CALL FLDS_WITH_LENGTH    /*COPY*/\n  OTHERWISE;                                   CALL FLDS_WO_LENGTH ; END/*COPY*/\n  CSINUMEN = X2C(RIGHT(D2X(fld.0),4,'0'))                               /*COPY*/\n  /********************************************************************//*COPY*/\n  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      *//*COPY*/\n  /********************************************************************//*COPY*/\n  CSIOPTS  = CSICLDI ||CSIRESUM||CSIS1CAT||CSIOPTNS                     /*COPY*/\n  CSIFIELD = CSIFILTK||CSICATNM||CSIRESNM||CSIDTYPS||CSIOPTS||CSINUMEN  /*COPY*/\n  DO i = 1 TO fld.0; CSIFIELD = CSIFIELD||fld.i.nm; END                 /*COPY*/\n  /********************************************************************//*COPY*/\n  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     *//*COPY*/\n  /********************************************************************//*COPY*/\n  WORKLEN = 32768; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))            /*COPY*/\n  DWORK = CSIUSRLN||COPIES('00'X,WORKLEN-4)                             /*COPY*/\n                                                                        /*COPY*/\n  CATNAMET = ''; DNAMET = ''; dsns. = \"\"; dsns.0 = 0                    /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Process FIELDS Variable when Length is provided                   /*COPY*/\n***********************************************************************//*COPY*/\nFLDS_WITH_LENGTH:                                                       /*COPY*/\n  fld. = \"\"; fld.0 = WORDS(FIELDS)/2                                    /*COPY*/\n  DO i=1 TO WORDS(FIELDS)/2                                             /*COPY*/\n     fld.i.nm=LEFT(WORD(FIELDS,(((i-1)*2)+1)),8)                        /*COPY*/\n     fld.i.ln=WORD(FIELDS,(((i-1)*2)+2))                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Process FIELDS Variable when Length is NOT provided               /*COPY*/\n***********************************************************************//*COPY*/\nFLDS_WO_LENGTH:                                                         /*COPY*/\n  fld. = \"\"; fld.0 = WORDS(FIELDS)                                      /*COPY*/\n  DO i=1 TO fld.0                                                       /*COPY*/\n     fld.i.nm = LEFT(WORD(FIELDS,i),8)                                  /*COPY*/\n     PARSE VALUE VER_FNM(fld.i.nm) WITH fld.i.ln fld.i.ty fld.i.rp      /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY IGGFNM */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n      Verify Field Name and Set Attributes (from SYS1.MACLIB(IGGCSI))   /*COPY*/\n***********************************************************************//*COPY*/\nVER_FNM:                                                                /*COPY*/\nARG fnm .                                                               /*COPY*/\n  SELECT               /* Validate Field name and assign attributes   *//*COPY*/\n    WHEN fnm = \"ACTOKEN\"  THEN RETURN 36   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"AKEYPOS\"  THEN RETURN 2    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"AMDCIREC\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"AMDKEY\"   THEN RETURN 4    \"R\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"ASSOCSYM\" THEN RETURN 45   \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"ATTR1\"    THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"ATTR2\"    THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"BUFSIZE\"  THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"CATTR\"    THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"COMPIND\"  THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"COMUDSIZ\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"DATACLAS\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"DEVTYP\"   THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"DSCBTTR\"  THEN RETURN 3    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"DSCRDT2\"  THEN RETURN 4    \"MX\" \"N\"                     /*COPY*/\n    WHEN fnm = \"DSEXDT2\"  THEN RETURN 4    \"MX\" \"N\"                     /*COPY*/\n    WHEN fnm = \"ENTYPE\"   THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"ENTNAME\"  THEN RETURN 44   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"EXCPEXIT\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"FILESEQ\"  THEN RETURN 2    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"GDGALTDT\" THEN RETURN 4    \"MX\" \"N\"                     /*COPY*/\n    WHEN fnm = \"GDGATTR\"  THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"GDGLIMIT\" THEN RETURN 1    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"GENLEVEL\" THEN RETURN 4    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"HARBA\"    THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"HARBADS\"  THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"HIKEYV\"   THEN RETURN \"VL\" \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"HKRBA\"    THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"HURBA\"    THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"HURBADS\"  THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"ITYPEXT\"  THEN RETURN 1    \"BS\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"LOGPARMS\" THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LOGSTRID\" THEN RETURN 26   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LOKEYV\"   THEN RETURN \"VL\" \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"LRECL\"    THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LTBACKDT\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"MGMTCLAS\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"NAME\"     THEN RETURN 44   \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOBLKTRK\" THEN RETURN 2    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOBYTAU\"  THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOBYTTRK\" THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOEXTNT\"  THEN RETURN 1    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOTRKAU\"  THEN RETURN 2    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NVSMATTR\" THEN RETURN 1    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"OPENIND\"  THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"OWNERID\"  THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"PASSATMP\" THEN RETURN 2    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"PASSPRMT\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"PASSWORD\" THEN RETURN 32   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"PHYBLKSZ\" THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"PRIMSPAC\" THEN RETURN 3    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RECVTIME\" THEN RETURN 8    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RECVTIMG\" THEN RETURN 8    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RGATTR\"   THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"RLSBWO\"   THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RLSFLAGS\" THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"SCONSPAC\" THEN RETURN 3    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"SECFLAGS\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"SPACOPTN\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"STORCLAS\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"STRIPCNT\" THEN RETURN  2   \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"TYPE\"     THEN RETURN 1    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"UDATASIZ\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"USVRMDUL\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"USERAREC\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VOLSER\"   THEN RETURN 6    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"VOLFLG\"   THEN RETURN 1    \"BS\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"VSAMREUS\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VSAMSTAT\" THEN RETURN 46   \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"VSAMTYPE\" THEN RETURN 2    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VVRNFLGS\" THEN RETURN 2    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"XACIFLAG\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"XHARBA\"   THEN RETURN 8    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"XHARBADS\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"XHKRBA\"   THEN RETURN 8    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"XHURBADS\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"XHURBA\"   THEN RETURN 8    \"F\"  \"Y\"                     /*COPY*/\n /* Tape Library Entry Field Names                                    *//*COPY*/\n    WHEN fnm = \"LCBCONID\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBDEVTP\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBDESCR\" THEN RETURN 120  \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBEMPTY\" THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBLIBID\" THEN RETURN 5    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBLOGIC\" THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBSCRTH\" THEN RETURN 1020 \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBSLOTS\" THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBTHRES\" THEN RETURN 1020 \"F\"  \"N\"                     /*COPY*/\n /* Tape Volume Entry Field Names                                     *//*COPY*/\n    WHEN fnm = \"VCBCHKPT\" THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBCRDT\"  THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBDEVTP\" THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBEDATE\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBERRST\" THEN RETURN 2    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBEXPDT\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBLIBNM\" THEN RETURN 44   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBLOC\"   THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBMOUNT\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBOWNER\" THEN RETURN 64   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBSGRP\"  THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBSHELF\" THEN RETURN 32   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBUATTR\" THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBWPROT\" THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBWRITE\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     CALL SET_MSG ,\"Unsupported Field Name: '\"fnm\"'\",\"YES\"              /*COPY*/\n  END                                                                   /*COPY*/\nEXIT 8                                                                  /*COPY*/\n/**********************************************************************\n      Expand CSICTYPE Value for Dataset Type\n***********************************************************************/\nSET_DSN_TYPE:\n  SELECT                           /* ASSIGN ENTRY TYPE NAME          */\n    WHEN CSICTYPE = 'A' THEN DTYPE = 'NONVSAM '\n    WHEN CSICTYPE = 'X' THEN DTYPE = 'ALIAS   '\n    WHEN CSICTYPE = 'U' THEN DTYPE = 'UCAT    '\n    WHEN CSICTYPE = 'H' THEN DTYPE = 'GDS     '\n    WHEN CSICTYPE = 'B' THEN DTYPE = 'GDG     '\n    WHEN CSICTYPE = 'C' THEN DTYPE = 'CLUSTER '\n    WHEN CSICTYPE = 'D' THEN DTYPE = 'DATA    '\n    WHEN CSICTYPE = 'I' THEN DTYPE = 'INDEX   '\n    WHEN CSICTYPE = 'R' THEN DTYPE = 'PATH    '\n    WHEN CSICTYPE = 'G' THEN DTYPE = 'AIX     '\n    WHEN CSICTYPE = 'L' THEN DTYPE = 'TAPELIB '\n    WHEN CSICTYPE = 'W' THEN DTYPE = 'TAPEVOL '\n  OTHERWISE;                 DTYPE = '        '; END\nRETURN\n/**********************************************************************\n      Check for and process Fields in non-viewable format\n***********************************************************************/\nPROCESS_FIELDS:\n  SELECT    /* Handle the translation of FIELDS          */\n    WHEN WORDPOS(fld.i.nm, \"DSCRDT2 DSEXDT2 GDGALTDT\")   > 0 THEN DO\n        IF C2X(fld.i.lst) = 'FFFFFFFF' THEN fld.i.lst = \"?????????\"\n        ELSE DO\n           PARSE VALUE C2X(fld.i.lst) WITH yy 3 jjj 6 . 7 cent .\n           fld.i.lst = VALUE(19 + cent) || yy || jjj\n        END\n      END\n    WHEN WORDPOS(fld.i.nm, \"LTBACKDT RECVTIME RECVTIMG\") > 0 THEN DO\n        TUNITS = C2X(fld.i.lst)\n        IF TUNITS \u00ac= 'FFFFFFFFFFFFFFFF' THEN DO /* Convert TimeStamp */\n           TIMESTAMP = LEFT('',26)\n           ok='0';ADDRESS \"LINKPGM\" \"BLSUXTOD TUNITS TIMESTAMP\"\n           fld.i.lst = TIMESTAMP\n          END\n        ELSE fld.i.lst = LEFT(fld.i.nm '- Unknown',26)\n      END\n    WHEN WORDPOS(fld.i.nm, \"GDGLIMIT\")                   > 0 THEN\n        fld.i.lst = RIGHT(C2D(fld.i.lst),3)\n    WHEN WORDPOS(fld.i.nm, \"GENLEVEL\") > 0 & DEFAULT         THEN\n        fld.i.lst = RIGHT(fld.i.totln%4,3)\n    WHEN WORDPOS(fld.i.nm, \"GENLEVEL\")                   > 0 THEN DO\n        PARSE VALUE fld.i.lst WITH _list_ 5 fld.i.lst\n        DO WHILE fld.i.lst \u00ac= \"\"\n           PARSE VALUE fld.i.lst WITH _level_ 5 fld.i.lst\n           _list_ = _list_ _level_\n        END\n        fld.i.lst = RIGHT(fld.i.totln%4,3) \"Levels\" _list_\n      END\n    WHEN WORDPOS(fld.i.nm, \"GDGATTR\")                    > 0 THEN DO\n       SELECT\n         WHEN fld.i.lst = '40'x THEN fld.i.lst = \"DEL Oldest -     SCRATCH\"\n         WHEN fld.i.lst = '80'x THEN fld.i.lst = \"Delete All - NoScratch\"\n         WHEN fld.i.lst = 'C0'x THEN fld.i.lst = \"Delete All -     SCRATCH\"\n       OTHERWISE;                    fld.i.lst = \"DEL Oldest - NoScratch\";END\n      END\n    WHEN WORDPOS(fld.i.nm, \"ENTYPE\")                     > 0 THEN DO\n       SELECT\n         WHEN fld.i.lst = 'C'   THEN fld.i.lst = LEFT(\"Cluster\",9)\n         WHEN fld.i.lst = 'D'   THEN fld.i.lst = LEFT(\"Data\",9)\n         WHEN fld.i.lst = 'I'   THEN fld.i.lst = LEFT(\"Index\",9)\n         WHEN fld.i.lst = 'G'   THEN fld.i.lst = LEFT(\"Alt-Index\",9)\n         WHEN fld.i.lst = 'R'   THEN fld.i.lst = LEFT(\"VSAM-Path\",9)\n         WHEN fld.i.lst = 'A'   THEN fld.i.lst = LEFT(\"Non-VSAM\",9)\n       OTHERWISE; NOP; END\n       IF fld.i.lst = \"Cluster\" THEN is_Clust = TRUE\n      END\n    WHEN WORDPOS(fld.i.nm, \"FSDSFLAG\")                   > 0 THEN DO\n       IF fld.i.lst = '80'x      THEN is_zFS   = TRUE\n       fld.i.lst = \"\"\n      END\n    WHEN WORDPOS(fld.i.nm, \"NAME\")                       > 0 &,\n         WORDS(fld.i.lst) > 1                                THEN DO\n       _list_ = STRIP(WORD(fld.i.lst,1))\n       DO _w_ = 2 TO WORDS(fld.i.lst)\n          _list_ = _list_ STRIP(WORD(fld.i.lst,_w_))\n       END\n       fld.i.lst = _list_\n      END\n    WHEN WORDPOS(fld.i.nm, \"VSAMTYPE\") > 0 & is_zFS          THEN\n       fld.i.lst = \"zFS Linear\"\n    WHEN WORDPOS(fld.i.nm, \"VSAMTYPE\") > 0 & is_Clust        THEN DO\n       PARSE VALUE fld.i.lst WITH byte1 2 byte2\n       SELECT\n         WHEN BITAND(byte1,'80'x) > '00'x &,\n              BITAND(byte2,'80'x)>'00'x THEN fld.i.lst = \"KSDS Unique\"\n         WHEN BITAND(byte1,'80'x)>'00'x THEN fld.i.lst = \"KSDS non-Unique\"\n         WHEN BITAND(byte2,'04'x)='00'x THEN fld.i.lst = \"Linear\"\n       OTHERWISE;                            fld.i.lst = \"\"; END\n       IF BITAND(byte1,'20'x)    ='00'x THEN fld.i.lst = fld.i.lst \"Imbed\"\n       IF BITAND(byte1,'10'x)    ='00'x THEN fld.i.lst = fld.i.lst \"Replicate\"\n       IF BITAND(byte1,'04'x)    ='00'x THEN fld.i.lst = fld.i.lst \"KeyRanged\"\n      END\n    WHEN WORDPOS(fld.i.nm, \"VSAMTYPE\") > 0                   THEN\n       fld.i.lst = \"\"\n    WHEN WORDPOS(fld.i.nm, \"VSAMREUS\")                   > 0 THEN DO\n       PARSE VALUE fld.i.lst WITH byte1 2 byte2\n       IF BITAND(byte1,'80'x)    >'00'x THEN fld.i.lst = \"Discrete Profile\"\n          ELSE                               fld.i.lst = \"\"\n       IF BITAND(byte1,'40'x)    >'00'x THEN fld.i.lst = fld.i.lst \"Index\"\n       IF BITAND(byte1,'20'x)    >'00'x THEN fld.i.lst = fld.i.lst \"Reusable\"\n       IF BITAND(byte1,'10'x)    >'00'x THEN fld.i.lst = fld.i.lst \"Erase\"\n       IF BITAND(byte1,'02'x)    >'00'x THEN fld.i.lst = fld.i.lst \"SwapSpace\"\n       IF BITAND(byte1,'01'x)    >'00'x THEN fld.i.lst = fld.i.lst \"PageSpace\"\n      END\n  OTHERWISE; NOP; END\nRETURN\n/**********************************************************************\n      Processing CATALOG information, output the CATALOG header\n***********************************************************************/\nPROCESS_CATALOGS:\n  IF CSICNAME \u00ac= CATNAMET & CSICFLG = '00'x THEN DO\n     IF dsns.0 > 0 THEN DO; k=1+dsns.0; dsns.0=k ; dsns.k=''; END\n     k = 1+dsns.0; dsns.0 = k\n     dsns.k = \"Catalog\" Strip(CSICNAME) \"of code type\" C2X(CSICFLG),\n              \"with RC=\"C2D(CSICRETR) \"and RSN=\"C2D(CSICRETN)\n  END\n  CATNAMET = CSICNAME\nRETURN\n/**********************************************************************\n      We now have NAME AND TYPE ... Get the rest of the Info\n***********************************************************************/\nPROCESS_NONCATALOGS:\n  is_zFS = FALSE; is_Clust = FALSE\n  CSICRETM = C2D(CSICRETM)\n  start_at = 2*fld.0; fld_start = 1\n  lengths  = SUBSTR(rest,1,start_at)\n  fld_list = SUBSTR(rest,start_at+1,CSICRETM-(start_at+4))\n  rest     = SUBSTR(rest,CSICRETM-3)\n  IF DNAMET = CSICNAME THEN ITERATE; ELSE DNAMET = CSICNAME\n  k = 1+dsns.0; dsns.0 = k; dsns.k = LEFT('',3) CSICNAME\n  DO i = 1 TO fld.0\n     fld.i.totln = C2D(SUBSTR(lengths,((i*2)-1),2))\n     fld.i.lst   = SUBSTR(fld_list,fld_start,fld.i.totln)\n     CALL PROCESS_FIELDS\n     dsns.k      = dsns.k fld.i.lst\n     fld_start   = fld_start + fld.i.totln\n  END\nRETURN\n/**********************************************************************\n      An error occured calling IGGCSI00; Display RC, MODRSNRC, the\n         PARMs used in CALL, and the Returned WORK area.\n***********************************************************************/\nDISPLAY_IGGCSI_ERROR:\n  SAY  \"IGGCSI Error!  LINK RC=\"RC \"MOD=\"LEFT(MODRSNRC,2),\n       \"RSN=\"C2D(SUBSTR(MODRSNRC,3,1)) \"RC=\"C2D(SUBSTR(MODRSNRC,4,1))\n  SAY  \"_______________________ CSIFIELD ______________________\"\n  SAY  CSIFIELD\n  SAY  \"________________________ DWORK ________________________\"\n  SAY  DWORK\n  SAY  \"_______________________________________________________\"\nEXIT RC\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNS": {"ttr": 37, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00R\\x01\\x01\\x11?\\x01\\x17%O\\x10)\\x01\\x92\\x01g\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "2001-04-23T00:00:00", "modifydate": "2017-09-11T10:29:52", "lines": 402, "newlines": 359, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO brings up a list of DSNs similar to the ISPF\n        option '=3.4'.  This can be used as a TSO command or an ISPF\n        EDIT Macro.  High level qualifies must not be enclosed in \"'\"s\n        and must be fully quallified, i.e. your User-ID will not be\n        abended to the beginning of the high level qualifies.\n\n   **********       A High Level Qualifier MUST be provided       **********\n\n                           --- EXAMPLE ---\n<TSO> <%>DSNs DsName <TEST(TraceOption)> <VOLSER(volser)>\n<TSO> <%>DSNs -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: DsName      - High level Qualifiers for DSN list\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n                  VOLSER - Volume Serial Number to display DSNs for.\n                           default:  blank (display cataloged DSNs only)\n\n      Files: Brings up a list of cataloged DSN's matching provided\n             DsName\nOther EXECS: Can use BR, ED, MU, COMPSHR, RCLONE, or any other EXEC usable\n             from the 3.4 DSN list.\n\nEXEC History\n\nEXEC/MACRO Name: DSNs\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.18\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 18OCT93\n        History: 16AUG17 - v1.43 - Use ISRDSLST vs LMDDISP\n                 16AUG17 - v1.42 - Minor refactoring for ease up\n                           future updates to use ISRDSLST\n                 16AUG17 - v1.40 - Add Point-N-Shoot capability\n                 06FEB17 - v1.20 - Update ERRINFO Common Code routine.\n                 01FEB17 - v1.19 - Mass update of Error Handling Fixes.\n                 31JAN17 - v1.18 - Update all REXXes w/latest common\n                           routines via %CCMASS\n                 18MAY95 - v1.04 - Update all REXXes w/latest common\n                           routines via %CCMASS\n                 18OCT93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG DsName InParms\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF DsName = ''                 THEN CALL INVOKE_AS_MACRO\nIF DsName = ''                 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nDsLstOpts = \"DSL LL1 LL2 PL1 PL2\"\nSELECT\n  WHEN WORDPOS(WORD(DsName,1),DslstOpts) > 0 THEN DsLstParm=DsName\n  WHEN \u00ac(ABBREV(DsName,\"'\"))                 THEN DsLstParm=\"DSL\" DsName\nOTHERWISE; DsLstParm=\"DSL '\"STRIP(DsName,,\"'\")\"'\"; END\n\nok='0';ADDRESS \"ISPEXEC\" \"SELECT PGM(ISRDSLST) PARM(\"DsLstParm\") SUSPEND\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O) VOLSER()\"\n  MatchLength = 3                   /* NpParms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\n  PARSE VALUE STRIP(DsName AnythingElse) WITH DsName '(' member ')' .\n\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  TRUE=1; FALSE=0;     null = X2C('00')\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"\n  IF RC = 0 THEN ADDRESS \"ISREDIT\" \"(CRow,CCol) = CURSOR\"\n\n  SELECT\n    WHEN DsName = \"\"               THEN DsName=DO_POINT_N_SHOOT()\n    WHEN WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP\n  OTHERWISE; NOP; END\n\nRETURN\n/**********************************************************************\n     Use Point-n-Shoot to Read dataset from screen\n**********************************************************************/\nDO_POINT_N_SHOOT:\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END\n  IF i = 0 THEN RETURN \"\"\n\n  word = WORD(ln,i-1)\n  SELECT\n    WHEN SYSDSN(word) = 'OK' THEN RETURN word\n    WHEN POS(\"''\",word)  > 0 THEN PARSE VALUE word WITH \"''\" word . \"'\"\n    WHEN POS(\"='\",word)  > 0 THEN PARSE VALUE word WITH \"='\" word . \"'\"\n    WHEN POS(\"=\",word)   > 0 THEN PARSE VALUE word WITH \"=\" word . \",\"\n    WHEN POS(\"(\",word)   > 0 THEN PARSE VALUE word WITH \"(\" word . \")\"\n  OTHERWISE; NOP; END\nRETURN \"'\"word\"'\"\n/**********************************************************************\n   Use Current Screen Stream & Cursor Possition to get Current Line\n**********************************************************************/\nGET_CURRENT_LINE:\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"\n  IF RC = 0 THEN Width = ZCURWID\n  ELSE DO\n     Length=LENGTH(ZSCREENI)\n     SELECT\n       WHEN (Length/ZSCREENW)   = ZSCREEND THEN Width=ZSCREENW\n       WHEN (Length%ZSCREENW)+1 = ZSCREEND THEN Width=ZSCREENW\n       WHEN (Length//ZSCREEND)  = 0        THEN Width=Length%ZSCREEND\n       WHEN (Length//88)        = 0        THEN Width=88\n     OTHERWISE; Width=MIN(88,ZSCREENW); END\n  END\n  CurPos=(ZSCREENC//Width)+1; RowPos=(ZSCREENC%Width)\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Width)+1,Width),\" \",\",\")\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ED": {"ttr": 145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x03\\x003\\x01\\x02\\x03o\\x01\\x17'\\x1f\\x13\\x13\\x02/\\x01\\xd3\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.03", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-28T13:13:33", "lines": 559, "newlines": 467, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF Macro supports full screen Point-N-Shoot. To improve\n        this functionality, assign it to a PFKey, add it as an ISPF CMD,\n        or, better yet, do both! If this is envoked as an ISPF Macro and\n        a valid dataset is not passed (via PARM or Cursor Position), it\n        will Edit the current DSN or member, if one is passed.\n\n   This REXX/ISPF MACRO supports multiple EDIT levels, so you may\n        EDIT a dataset from within another.\n\n   This REXX/ISPF MACRO supports member list patern matching, i.e.  If\n        it is envoked with a DSN of highlev.lowlev(AB*) it will display\n        a member list for the PDS of all members starting with AB.  If\n        it is envoked with a DSN of highlev.lowlev(AB%) it will display\n        a member list for the PDS of all members starting with AB and are\n        three characters in length.\n\n                       --- EXAMPLE as TSO CMD ---\nTSO <%>ED <dsname> <IMAcro(macro_name)> <TEST(TraceOption)> <VOLSER(volser)>\n                   <FORMAT(blank|ASCII|UTF8)>\n                     --- EXAMPLE as ISPF Macro ---\n    <%>ED <dsname> <IMAcro(macro_name)> <TEST(TraceOption)> <VOLSER(volser)>\n                   <FORMAT(blank|ASCII|UTF8)>\n<TSO> <%>ED -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: dsname      - Dataset to Edit\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                  FORMAT - Charactor encoding          default: blank\n                           blank (EBCDIC), ASCII, or UTF8\n                  IMACRO - Initial ISPF EDIT Macro\n                               default: ALIASMC\n                    TEST - Used to control traces\n                  VOLSER - Volume Serial Number to display DSNs for.\n                           default:  blank (display cataloged DSNs only)\n      Files: The EXEC edits the DSN provided as an argument\nOther EXECS: None\n\nEXEC History\n\nEXEC/MACRO Name: ED\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 3.07\n                 FERGUSON AL (HUL2353) from version 3.00\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 30DEC92\n        History: 28SEP17 - v4.00 - More Point-N-Shoot Fixes.\n                 09AUG17 - v3.95 - Add support for ASCII & UTF8 formats\n                 21JUN17 - v3.87 - Cleanup point & shoot, plus add\n                           support for ZCURWID ISPF System Variable.\n                 19MAY17 - v3.84 - Keep Cursor Col & Advance Row when\n                           invoked as Macro.\n                 13MAR17 - v3.74 - More Point-N-Shoot corrections.\n                 06FEB17 - v3.58 - Fix Point-N-Shoot math.\n                 06FEB17 - v3.50 - Pick up updated version of ERRINFO\n                           Common Code routines.\n                 01FEB17 - v3.48 - Mass update for Error Handling Fixes.\n                 31JAN17 - v3.47 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 26JAN17 - v3.46 - Tweak Point & Shoot logic.\n                 23NOV16 - v3.40 - Tweak Point-n-Shoot math\n                 22NOV16 - v3.31 - Rewrite of Point and shoot section\n                           to make work as an ISPF Command when not in\n                           an edit session.\n                 10AUG16 - v3.22 - More Changes to support DDs\n                 05AUG16 - v3.14 - Add support for DDs\n                 04MAY16 - v3.07 - Use IBM Default Edit/View PANEL vs\n                           custom ED01 Panel.\n                 14FEB11 - v3.03 - Add point & Shoot for USS PATHs.\n                 13MAR09 - v3.00 - Add support for USS Files\n                 29APR96 - v2.49 - Support for VOLUME specific DSNs.\n                 03JAN96 - v2.38 - Add Edit Recovery Checking & Support.\n                 18MAY95 - v2.29 - Update all REXXes with latest commom\n                           routines. This done via %CCMASS\n                 07JUN94 - v2.28 - Support use of new 'COBOL' ISPF Command.\n                 03MAR94 - v2.25 - Support for exit_error use by MU.\n                 10NOV93 - v2.21 - Fix '-h' help from Macro invocations\n                 13AUG93 - v2.09 - Fix to Point and Shot routine.\n                 15JUL93 - v2.07 - Support added for INITIAL MACRO.\n                 23JUN93 - v2.00 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 26MAY93 - v1.40 - Minor fixxes and more point & shoot\n                           DSN formats supported\n                 16MAR93 - v1.30 - Modify logic/program flow, point &\n                           EDIT support, use of ED01 panel\n                 30DEC92 - v1.20 - ISPF ERROR MSG and NPARMs\n                 01SEP92 - v1.10 - TSO REXX or ISPF EDIT MACRO\n                 01AUG92 - v1.00 - ISPF EDIT MACRO only\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG DsName InParms\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF ABBREV('.',DsName)          THEN DO; DsName=\"\"; CALL INVOKE_AS_MACRO; END\nIF DsName = ''                 THEN EXIT\n   ELSE                             CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL CHECK_EDIT_RECOVERY       /* Any pending EDIT Recovery Sessions? */\n\nok='0 4 12 14 16 20'\n  ADDRESS \"ISPEXEC\" \"EDIT\" PROCESS_DSNAME(DsName) \"MACRO(\"IMACRO\")\" FORMAT\nSELECT\n  WHEN RC=0 | RC=4 THEN\n    IF IsMacro     THEN ADDRESS \"ISREDIT\" \"CURSOR =\"RowPos+1 CurPos\n  WHEN RC = 14     THEN CALL SET_MSG 'Dataset in USE!', DsName '--' ZERRLM\n  WHEN RC = 16     THEN CALL SET_MSG \"No Members in PDS!\", DsName '--' ZERRLM\nOTHERWISE\n   CALL SET_MSG \"Can't %ED this DSN!\", DsName '--' ZERRLM, \"YES\"\n   ExitErr=021\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This INITIALIZEs any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n  ADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL)\"\n  SELECT              /* Support ISPF 3.4/DSLIST VOLSERs              */\n    WHEN RC \u00ac= 0                   THEN NOP\n    WHEN ABBREV(\"*ALIAS\", ZDLVOL)  THEN InParms = InParms \"VOLSER()\"\n    WHEN ABBREV(DsName, \"'\"ZDLDSN) THEN InParms = InParms \"VOLSER(\"ZDLVOL\")\"\n  OTHERWISE; NOP; END\n                                    /* Initialize NonPositional parms */\n  ValidParms=\"FORMAT() IMACRO(%ALIASMC) TEST(O) VOLSER()\"\n  MatchLength=3                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitErr=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  IF VOLSER = \"\" THEN ADDRESS \"ISPEXEC\" \"VGET (VOLSER) SHARED\"\n  response=''; member=''\n\n  IF IsMacro \u00ac= TRUE THEN IsMacro=FALSE\n  SELECT\n    WHEN FORMAT = \"\"            THEN NOP\n    WHEN ABBREV(\"ASCII\",FORMAT) THEN FORMAT=\"ASCII\"\n    WHEN ABBREV(\"UTF8\", FORMAT) THEN FORMAT=\"UTF8\"\n  OTHERWISE;                         FORMAT=\"\"     ; END\n\nRETURN\n/* COPY PNTNSHOT */\n/********************************************************************** /*COPY*/\n             If no arguments, was it envoked as a MACRO                 /*COPY*/\n**********************************************************************/ /*COPY*/\nINVOKE_AS_MACRO:                                                        /*COPY*/\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"                                        /*COPY*/\n  IF RC \u00ac= 0 THEN RETURN                                                /*COPY*/\n  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */ /*COPY*/\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"                  /*COPY*/\n  IF RC = 0 THEN DO                                                     /*COPY*/\n     IsMacro=TRUE                                                       /*COPY*/\n     ADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"                             /*COPY*/\n     ADDRESS \"ISREDIT\" \"(RowPos,CurPos) = CURSOR\"                       /*COPY*/\n     IF DsName = \"\" & RowPos = 1 & CurPos = 0 THEN DsName=\"'\"PdsDsn\"'\"  /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO; IsMacro=FALSE; PdsDsn=\"\"; END                                /*COPY*/\n  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/\n                                                                        /*COPY*/\n  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/\n  IF ABBREV(PDS,\"'\")           THEN PDS=STRIP(PDS,\"T\",\"'\")\"'\"           /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN DsName = \"\"           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/\n    WHEN ABBREV(DsName,\"DD:\")  THEN NOP                                 /*COPY*/\n    WHEN ABBREV(DsName,\"dd:\")  THEN NOP                                 /*COPY*/\n    WHEN POS(\"/\",DsName) > 0   THEN NOP                                 /*COPY*/\n    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"          THEN DsName=\"'\"PdsDsn\"(\"DsName\")'\"       /*COPY*/\n  OTHERWISE;                        NOP; END                            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_POINT_N_SHOOT:                                                       /*COPY*/\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"                  /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn                        /*COPY*/\n  OTHERWISE;                       RETURN \"\"; END                       /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/\n    WHEN POS(\"='\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"='\" word . \"'\"                        /*COPY*/\n    WHEN POS(\"DSN=\",word) > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"                     /*COPY*/\n    WHEN POS(\"=\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH   \"=\" word . \",\"                        /*COPY*/\n    WHEN POS(\"''\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"''\" word . \"'\"                        /*COPY*/\n    WHEN ABBREV(word,'\"//')   THEN                                      /*COPY*/\n       PARSE VALUE word    WITH \"//\" word . '\"'                         /*COPY*/\n    WHEN POS(\"(\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"                        /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word          /*COPY*/\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word          /*COPY*/\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN       /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"                                     /*COPY*/\n    WHEN PdsDsn                        \u00ac= ''   THEN DO                  /*COPY*/\n         DsNme=\"'\"PdsDsn\"'\"; filter=word                                /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; DsNme = \"\"; END                                            /*COPY*/\nRETURN DsNme                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_CURRENT_LINE:                                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"        /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC = 0 & \u00ac(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/\n    WHEN IsMacro                                THEN DO                 /*COPY*/\n       ADDRESS \"ISREDIT\" \"(Line) = LINE\" RowPos                         /*COPY*/\n       RETURN Line                                                      /*COPY*/\n      END                                                               /*COPY*/\n    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/\n         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/\n       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/\n       IF ABBREV(LstLn,\"***\")                   THEN Wdth=ZSCREENW+8    /*COPY*/\n          ELSE                                       Wdth=ZSCREENW      /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/\n       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/\n     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/\n  END                                                                   /*COPY*/\n  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth),\" \",\",\")         /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC \u00ac= 0                   THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/\n        ELSE                           ZERRALRM='NO'                    /*COPY*/\n     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                     /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY CHECKER */\n/********************************************************************** /*COPY*/\n        Check for pending EDIT Recovery and process accordingly         /*COPY*/\n***********************************************************************//*COPY*/\nCHECK_EDIT_RECOVERY:                                                    /*COPY*/\n  DO FOREVER                                                            /*COPY*/\n      ok='0 4';ADDRESS \"ISPEXEC\" \"EDREC QUERY\"                          /*COPY*/\n      IF RC = 0  THEN LEAVE                                             /*COPY*/\n      ELSE DO            /* Display standard PDF EDIT Recovery Screen *//*COPY*/\n          ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(ISREDM02)\"          /*COPY*/\n          SELECT                                                        /*COPY*/\n            WHEN ABBREV(ZEDCMD, \"C\") THEN DO                            /*COPY*/\n                ok='0';ADDRESS \"ISPEXEC\" \"EDREC CANCEL\"                 /*COPY*/\n              END                                                       /*COPY*/\n            WHEN ABBREV(ZEDCMD, \"D\") | RC = 8 THEN DO                   /*COPY*/\n                ok='0';ADDRESS \"ISPEXEC\" \"EDREC DEFER\"                  /*COPY*/\n              END                                                       /*COPY*/\n          OTHERWISE                                                     /*COPY*/\n              ok='0 4 20';ADDRESS \"ISPEXEC\" \"EDREC PROCESS\"             /*COPY*/\n              IF RC = 20 THEN DO                                        /*COPY*/\n                  ok='*';ADDRESS \"ISPEXEC\" \"EDREC CANCEL\"               /*COPY*/\n              END                                                       /*COPY*/\n          END                                                           /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Process DsName and return ISPF Allocation Type\n***********************************************************************/\nPROCESS_DSNAME:\nPARSE ARG PDS '(' member ')' .\n  SELECT\n    WHEN ABBREV(PDS, \"DD:\")   |,\n         ABBREV(PDS, \"dd:\")   THEN DO\n       ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DDNAME(\"SUBSTR(PDS,4)\") ENQ(SHRW)\"\n       IF member = \"\" THEN         _type_ = \"DATAID(\"id\")\"\n          ELSE                     _type_ = \"DATAID(\"id\") MEMBER(\"member\")\"\n      END\n    WHEN INDEX(PDS,\"/\") > 0   THEN _type_ = \"FILE(PDS)\"\n    WHEN INDEX(PDS,\"'\") > 0   &,\n         (member = \"\")        THEN _type_ = \"DATASET(\"STRIP(PDS,\"T\",\"'\")\"')\"\n    WHEN INDEX(PDS,\"'\") > 0   THEN\n         _type_ = \"DATASET(\"STRIP(PDS,\"T\",\"'\")\"(\"member\")')\"\n    WHEN (member = \"\")        THEN _type_ = \"DATASET(\"PDS\")\"\n  OTHERWISE;                       _type_ = \"DATASET(\"PDS\"(\"member\"))\"; END\n  IF VOLSER \u00ac= \"\" THEN _type_ = _type_ \"VOLUME(\"VOLSER\")\"\nRETURN _type_\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITLIBS": {"ttr": 123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00F\\x01\\x16\"O\\x01\\x17\\'\\x1f\\x10\"\\x02=\\x01d\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2016-08-11T00:00:00", "modifydate": "2017-09-28T10:22:46", "lines": 573, "newlines": 356, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX determines various system Concatenations, allocates them,\n      and then opens the DD for management using the MU (Member\n      Utility) REXX. Currently supported System Concatenation are:\n          JOBlibs  - The STC JOBs libraries from JES2/MSTJCL00\n          PARMlibs - The System PARMLIB Concatenation at IPL Time\n          PROClibs - The STC & default PROCLIBs from JES2/MSTJCL00\n          PROCMstr - The STC sub=MSTR PROCLIBs from MSTJCL00\n\n                           --- EXAMPLE ---\nTSO <%>EDITLIBS LIB_Type <MEMBERS(member_filter)> <TEST(TraceOption)>\nTSO <%>EDITLIBS -H -- To display help for this REXX\n\n  Arguments: LIB_Type    - Type of System Concatenation to be managed.\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                 MEMBERS - Member Filter to use against Concatenation\n                    TEST - Used to control traces\n\n      Files: System PARMLIB, PROCLIB, and STCJOBS libraries\nOther EXECS: CALLs MU (Member Utility) against the DD.\n\nEXEC History\n\n REXX EXEC Name: EDITLIBS\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 11AUG16\n        History: 28SEP17 - v1.30 - Minor Refactoring\n                 15AUG17 - v1.28 - PROClibs returns JES PROC00 & MSTJCL00\n                           IEFPDSI. PROCMstr returns MSTJCL00 IEFPDSI.\n                           JOBs returns JES PROC00, MSTJCL00 IEFPDSI,\n                           & MSTJCL00 IEFJOBS.\n                 14AUG17 - v1.23 - Add support for JES2 PROCLIB\n                           PROC00 Concatination.\n                 14AUG17 - v1.21 - Add view option for fully\n                           specified members.\n                 14AUG17 - v1.19 - Refactoring for perfomance.\n                 06FEB17 - v1.11 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.10 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.09 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 16AUG16 - v1.07 - First functioning version with\n                           PARMLIB, PROCLIB, JOBLIB, & STCLIB support.\n                 11AUG16 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG LIB_Type InParms                         /* Place arguments here */\n\nIF WORDPOS(LIB_Type,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL DIGEST_MSTJCL GET_MSTJCL()\n\nSELECT\n  WHEN ABBREV(LIB_Type,\"PARM\")  THEN CALL GET_PARMLIBS\n  WHEN ABBREV(LIB_Type,\"PROCM\") THEN CALL GET_MSTRPROC\n  WHEN ABBREV(LIB_Type,\"PROC\")  THEN CALL GET_JESPROC\n  WHEN ABBREV(LIB_Type,\"JOB\")   THEN CALL GET_JOBLIBS\nOTHERWISE\n  CALL SET_MSG ,\"'\"LIB_Type\"' NOT supported at this time.\",\"NO\"\n  EXIT 1\nEND\n\nLIB_DD=\"@@@\"TIME(\"S\")\nx=ALLOC_DD(LIB_DD)\nSELECT\n  WHEN MEMBERS = \"\"             THEN CALL MU \"DD:\"LIB_DD\n  WHEN POS('*',MEMBERS) = 0     &,\n       POS('%',MEMBERS) = 0     THEN CALL VW \"DD:\"LIB_DD\"(\"MEMBERS\")\"\nOTHERWISE;                           CALL MU \"DD:\"LIB_DD\"(\"MEMBERS\")\"; END\n\nx=BPXWDYN(\"FREE DD(\"LIB_DD\")\")\nDO _i_ = 2 TO Dsns.0; x=BPXWDYN(\"FREE DD(TMP\"_i_\")\"); END\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n                                    /* Initialize NonPositional parms */\n  ValidParms = \"MEMBERS() TEST(O)\"\n  MatchLength=3                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitErr=0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\";Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF MEMBERS = \"\"     THEN MEMBERS = AnythingElse\n\n  CVT     = C2D(STORAGE(10,4))                /* point to CVT         */\n  ECVT    = C2D(STORAGE(D2X(CVT+140),4))      /* point to CVTECVT     */\n  ECVTIPA = C2D(STORAGE(D2X(ECVT+392),4))     /* point to IPA         */\n\n  SYSNAME  = MVSVAR(\"SYSNAME\")            /* zOS SysName Symbol       */\n  SYSCLONE = MVSVAR(\"SYMDEF\",\"SYSCLONE\")  /* zOS SysClone Symbol      */\n  ENVNAME  = MVSVAR(\"SYMDEF\",\"ENVNAME\")   /* Shop Environ Name Symbol */\n  ENVCLONE = MVSVAR(\"SYMDEF\",\"ENVCLONE\")  /* Shop Envir Clone Symbol  */\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Digest MSTJCL00 to GET PROCLIB (IEFPDSI) & STCJOBS (IEFJOBS)\n***********************************************************************/\nDIGEST_MSTJCL:\nARG MstrJcl .\n  x=BPXWDYN(\"ALLOC DD(MSTJCL00) DSN(\"MstrJcl\") SHR REUSE\")\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC MSTJCL00\" MstrJcl)\n  ok='0';ADDRESS \"MVS\" \"EXECIO * DISKR MSTJCL00 (STEM MstJcl. FINIS\"\n  x=BPXWDYN(\"FREE DD(MSTJCL00)\")\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"FREE MSTJCL00\")\n  IEFPDSI. = \"\";IEFPDSI.0 = 0; IEFJOBS. = \"\";IEFJOBS.0 = 0\n  DO i=1 TO MstJcl.0\n     SELECT\n       WHEN ABBREV(MstJcl.i,\"//IEFPDSI \") THEN DO\n          j=1; PARSE VALUE MstJcl.i WITH . 'DSN=' IEFPDSI.j . ','\n          DO i=i+1 TO MstJcl.0 WHILE ABBREV(MstJcl.i,\"// \")\n             j=j+1; PARSE VALUE MstJcl.i WITH . 'DSN=' IEFPDSI.j . ','\n          END\n          IEFPDSI.0=j; i=i-1\n         END\n       WHEN ABBREV(MstJcl.i,\"//IEFJOBS \") THEN DO\n          j=1; PARSE VALUE MstJcl.i WITH . 'DSN=' IEFJOBS.j . ','\n          DO i=i+1 TO MstJcl.0 WHILE ABBREV(MstJcl.i,\"// \")\n             j=j+1; PARSE VALUE MstJcl.i WITH . 'DSN=' IEFJOBS.j . ','\n          END\n          IEFJOBS.0=j; i=i-1\n         END\n     OTHERWISE; NOP; END\n  END\nRETURN\n/**********************************************************************\n      Get PROCLIB Concatenation from zOS System Memory & MSTJCL\n***********************************************************************/\nGET_MSTJCL:\n  IPASTOR = D2X(ECVTIPA + 2152 + (37*8))       /* point to PDE addr    */\n  IPAPDE  = C2X(STORAGE((IPASTOR),8))          /* point to PDE         */\n  IPAADDR = SUBSTR(IPAPDE,1,8)                 /* PARM address         */\n  IPALEN  = X2D(SUBSTR(IPAPDE,9,4))            /* PARM length          */\n  IPAPRM  = \"MSTJCL\"||STORAGE((IPAADDR),IPALEN)\n  CALL GET_PARMLIBS\n  DO i=1 TO Dsns.0\n     IF SYSDSN(\"'\"Dsns.i.DSN\"(\"IPAPRM\")'\")=\"OK\" THEN LEAVE i\n  END\nRETURN \"'\"Dsns.i.DSN\"(\"IPAPRM\")'\"\n/**********************************************************************\n      Get PARMLIB Concatenation from zOS System Memory\n***********************************************************************/\nGET_PARMLIBS:\n  IPAPLNUMX = STORAGE(D2X(ECVTIPA+2134),2)    /* number of parmlibs   */\n  Dsns. = \"\";Dsns.0 = C2D(IPAPLNUMX)\n  Dsns.0.DSN = STRIP(STORAGE(D2X(ECVTIPA+48),44))   /* loadparm dsn   */\n  POFF = 0\n  DO p=1 TO Dsns.0\n     PARSE VALUE STORAGE(D2X(ECVTIPA+416+POFF),63) WITH Dsns.p.DSN Dsns.p.VOL .\n     POFF=POFF+64\n  END\nRETURN\n/**********************************************************************\n      Get PROCLIB Concatenation from zOS System Memory & MSTJCL\n***********************************************************************/\nGET_MSTRPROC:\n  Dsns.=\"\";Dsns.0=IEFPDSI.0\n  DO i=1 TO IEFPDSI.0\n     IF INDEX(IEFPDSI.i,\"&SYS\") = 0 THEN Dsns.i.DSN = IEFPDSI.i\n     ELSE DO\n        PARSE VALUE IEFPDSI.i WITH before '&SYSNAME.' after\n        Dsns.i.DSN = before||SYSNAME||after\n     END\n  END\nRETURN\n/**********************************************************************\n      Get JES2 PROCLIB Concatination from JES2 PROC & PARM\n***********************************************************************/\nGET_JESPROC:\n  CALL GET_MSTRPROC\n  ProcFound=FALSE\n  DO i=1 TO Dsns.0\n     IF SYSDSN(\"'\"Dsns.i.DSN\"(JES2)'\")\u00ac=\"OK\" THEN ITERATE i\n     ProcFound=TRUE; LEAVE i\n  END\n  IF ProcFound THEN DO\n     CALL DIGEST_JESPROC \"'\"Dsns.i.DSN\"(JES2)'\"\n     Dsns.=\"\";Dsns.0=PROC00.0\n     DO i=1 TO PROC00.0\n        SELECT\n          WHEN INDEX(PROC00.i,\"&SYS\")      = 0 &,\n               INDEX(PROC00.i,\"&ENV\")      = 0 THEN Dsns.i.DSN=PROC00.i\n          WHEN INDEX(PROC00.i,\"&SYSNAME\")  > 0 THEN DO\n             PARSE VALUE PROC00.i WITH before '&SYSNAME.' after\n             Dsns.i.DSN = before||SYSNAME||after\n            END\n          WHEN INDEX(PROC00.i,\"&SYSCLONE\") > 0 THEN DO\n             PARSE VALUE PROC00.i WITH before '&SYSCLONE.' after\n             Dsns.i.DSN = before||SYSCLONE||after\n            END\n          WHEN INDEX(PROC00.i,\"&ENVNAME\")  > 0 THEN DO\n             PARSE VALUE PROC00.i WITH before '&ENVNAME.' after\n             Dsns.i.DSN = before||ENVNAME||after\n            END\n          WHEN INDEX(PROC00.i,\"&ENVCLONE\") > 0 THEN DO\n             PARSE VALUE PROC00.i WITH before '&ENVCLONE.' after\n             Dsns.i.DSN = before||ENVCLONE||after\n            END\n        OTHERWISE; NOP; END\n     END\n    END\n  ELSE CALL SET_MSG ,\"JES2 PROC not found! Displaying MSTJCL PROCLIBs.\",\"YES\"\nRETURN\n/**********************************************************************\n      Digest JES PROC from MSTJCL PROCLIB Concatination\n***********************************************************************/\nDIGEST_JESPROC:\nARG JesProcDsn .\n  x=BPXWDYN(\"ALLOC DD(JESPROC)  DSN(\"JesProcDsn\") SHR REUSE\")\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC MSTJCL00\" JesProcDsn)\n  ok='0';ADDRESS \"MVS\" \"EXECIO * DISKR JESPROC (STEM JesProc. FINIS\"\n  x=BPXWDYN(\"FREE DD(JESPROC)\")\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"FREE JESPROC\")\n  PROC00. = \"\";PROC00.0 = 0\n  DO i=1 TO JesProc.0\n     IF \u00ac(ABBREV(JesProc.i,\"//PROC00 \")) THEN ITERATE i\n\n     j=1; PARSE VALUE JesProc.i WITH . 'DSN=' PROC00.j . ','\n     DO i=i+1 TO JesProc.0 WHILE ABBREV(JesProc.i,\"// \") |,\n                                 ABBREV(JesProc.i,\"//*\")\n        IF ABBREV(JesProc.i,\"//*\") THEN ITERATE i\n        j=j+1; PARSE VALUE JesProc.i WITH . 'DSN=' PROC00.j . ','\n     END\n     PROC00.0=j; LEAVE i\n  END\nRETURN\n/**********************************************************************\n      Get PROCLIB Concatenation from zOS System Memory & MSTJCL\n***********************************************************************/\nGET_JOBLIBS:\n  CALL GET_JESPROC\n  j=Dsns.0; Dsns.0=Dsns.0+IEFPDSI.0+IEFJOBS.0\n  DO i=1 TO IEFJOBS.0\n     j=j+1\n     IF INDEX(IEFJOBS.i,\"&SYS\") = 0 THEN Dsns.j.DSN = IEFJOBS.i\n     ELSE DO\n        PARSE VALUE IEFJOBS.i WITH before '&SYSNAME.' after\n        Dsns.j.DSN = before||SYSNAME||after\n     END\n  END\n  DO i=1 TO IEFPDSI.0\n     j=j+1\n     IF INDEX(IEFPDSI.i,\"&SYS\") = 0 THEN Dsns.j.DSN = IEFPDSI.i\n     ELSE DO\n        PARSE VALUE IEFPDSI.i WITH before '&SYSNAME.' after\n        Dsns.j.DSN = before||SYSNAME||after\n     END\n  END\nRETURN\n/*---------------------------------------------------------------------*\n                Use BPXWDYN to update DD Concatenations\n *---------------------------------------------------------------------*/\nALLOC_DD:\nARG DdName .\n  DdList = DdName; DsnList = Dsns.1.DSN\n  IF Dsns.1.VOL = \"\" THEN DsnSpec = \"DSN(\"Dsns.1.DSN\")\"\n     ELSE                 DsnSpec = \"DSN(\"Dsns.1.DSN\") VOL(\"Dsns.1.VOL\")\"\n  x=BPXWDYN(\"ALLOC DD(\"DdName\") SHR REUSE\" DsnSpec)\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC\" DdName Dsns.1.DSN)\n  DO i=2 TO Dsns.0\n     IF WORDPOS(Dsns.i.DSN,DsnList) > 0 THEN ITERATE i\n     DsnList = DsnList Dsns.i.DSN\n     IF Dsns.i.VOL = \"\" THEN DsnSpec = \"DSN(\"Dsns.i.DSN\")\"\n        ELSE                 DsnSpec = \"DSN(\"Dsns.i.DSN\") VOL(\"Dsns.i.VOL\")\"\n     x=BPXWDYN(\"ALLOC DD(TMP\"i\") SHR REUSE\" DsnSpec)\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC TMP\"i  Dsns.1.DSN)\n     DdList = DdList\",TMP\"i\n  END\n  IF Dsns.0 > 1 THEN DO\n     x=BPXWDYN(\"CONCAT DdList(\"DdList\")\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"CONCAT\" DdName DdList)\n  END\nRETURN DdList\n/*---------------------------------------------------------------------*\n      Display BPXWDYN error information for non-zero Return Codes\n *---------------------------------------------------------------------*/\nBPXWDYN_ERR:\nPARSE ARG BPXWDYN_rc arg2 arg3\n  SAY RIGHT(arg2,7) \"of:\" arg3\n  IF BPXWDYN_rc > 0 THEN DO\n     PARSE VALUE RIGHT(D2X(BPXWDYN_rc),8,\"0\") WITH dyn_EC 5 dyn_RC .\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc \"(\"dyn_EC dyn_RC\")\"\n    END\n  ELSE DO\n     dyn_EC = ABS(BPXWDYN_rc); SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc\n  END\n  IF SYMBOL(\"S99MSG.0\")=\"VAR\" THEN DO i=1 TO S99MSG.0;SAY \"  \"S99MSG.i;END\nRETURN dyn_EC\n/**********************************************************************\n      Cleanup and exit gracefully\n***********************************************************************/\nCLEANUP:\nok='*'\n  x=BPXWDYN(\"FREE DD(MSTJCL00)\")\n  x=BPXWDYN(\"FREE DD(\"LIB_DD\")\")\n  DO _i_ = 2 TO Dsns.0; x=BPXWDYN(\"FREE DD(TMP\"_i_\")\"); END\n  ZISPFRC = ExitErr                 /* SET ISPF RC to ExitErr         */\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nRETURN ExitErr\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXMAC": {"ttr": 39, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x02\\x01\\x17!\\x9f\\x01\\x17%O\\x100\\x00(\\x00*\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2017-08-07T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 40, "newlines": 42, "modlines": 0, "user": "AL-FERG"}, "text": "/**************************** REXX ************************************\n  This Macro can be use to do Mass Changes via the MACREP Mass Replace\n       ISPF REXX & MACREPM Macro. It will not change itself or other\n       ISPF REXXes & Macros it relies on.\n\n***************************** Rexx ***********************************/\nADDRESS \"ISREDIT\" \"MACRO (InParms) NOPROCESS\"\n\nADDRESS \"ISREDIT\" \"(member) = MEMBER\"\nIF WORDPOS(member,\"COPYCODE MAPREP MACREPM FIXMAC XCOM\") > 0 THEN EXIT\n          /* Changes that would impact the edit members REXX Header  */\n  ADDRESS \"ISREDIT\" \"C 'TRUE=1;   FALSE=0' 'TRUE=1; FALSE=0' ALL NX\"\n\nADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"\nIF POS(\".Z.EXEC\",PdsDsn) > 0 THEN ADDRESS \"ISREDIT\" \"%XCOM\"\n          /* Changes that would not impact common code or Headers    */\n  ADDRESS \"ISREDIT\" \"C 'Accept_All'     'AcceptAll'      ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Anything_Else'  'AnythingElse'   ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'DsName'         'DsName'         ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Exit_Error'     'ExitError'      ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Exit_Or_Return' 'ExitOrReturn'   ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'MailCc'         'MailCc'         ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'MailFrom'       'MailFrom'       ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'MailRep'        'MailRep'        ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'MailTo'         'MailTo'         ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Mail_Cc_List'   'MailCcList'     ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Mail_Rep_List'  'MailRepList'    ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Mail_To_List'   'MailToList'     ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Match_Length'   'MatchLength'    ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Mime_Header'    'MimeHeader'     ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'MsgStat'        'MsgStat'        ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'No_Submited'    'NbrSubmited'    ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Sql_Error'      'SqlError'       ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'User_Prefix'    'UserPrefix'     ALL NX\"\n  ADDRESS \"ISREDIT\" \"C 'Valid_Parms'    'ValidParms'     ALL NX\"\n\nIF POS(\".Z.EXEC\",PdsDsn) > 0 THEN ADDRESS \"ISREDIT\" \"%COPYCODE\"\n\nEXIT 0\n  ADDRESS \"ISREDIT\" \"C ''               ''               ALL NX\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGCOPY": {"ttr": 41, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x02\\x01\\x10\\x14\\x0f\\x01\\x17%O\\x100\\x01\\x9a\\x01x\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2010-05-20T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 410, "newlines": 376, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX uses IGGCSI00 (the Catalog Search Interface), then BPXWDYN\n      to dynmically ALLOCATE all the GDSs in a GDG Base and then to\n      CONCATinate them into a single SYSUT1 DD, and then finally\n      ICEGENER to COPY then into a single file specified by SYSUT2.\n\nNOTE: This is done without using TSO!\n\n                           --- EXAMPLE ---\nIRXJCL GDGCOPY GdgBase <CATALOG(catalog_to_check)> <TEST(TraceOption)>\nIRXJCL GDGCOPY -H -- To display help for this REXX\n\n  Arguments: GdgBase     - The GdgBase name to return GDSes for\n                           i.e. the individual \"G0000V00\"s for the GDG\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                 CATALOG - Catalog to search against.    default: blank\n                    TEST - Used to control traces\n\n      Files: The GDS List for a GDG Base retrieved via CSI\n             SYSUT2 must be pre-allocated before calling GDGCOPY\nOther EXECS: NONE\n Sample JCL: //STEP0001 EXEC PGM=IRXJCL,TIME=5,DYNAMNBR=30,\n             //         PARM='GDGCOPY GDG.BASE.NAME.HERE TEST(O)'\n             //SYSEXEC  DD DISP=SHR,DSN=YOUR.SYSEXEC.LIBRARY\n             //SYSIN    DD DUMMY\n             //SYSPRINT DD SYSOUT=Z\n             //SYSTSPRT DD SYSOUT=*\n             //SYSUT2   DD DISP=(MOD,PASS),SPACE=(???,(###,##))\n\nEXEC History\n\n REXX EXEC Name: GDGCOPY\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.91\n                 FERGUSON AL (HUL2353)\n         Writen: 08NOV06\n        History: 06FEB17 - v2.01 - Update ERROR Handling routines\n                 14FEB11 - v1.85 - Fixes to BPXWDYN_ERR Reporting.\n                 21DEC10 - v1.84 - Miscelanious code cleanup.\n                 21MAY10 - v1.71 - First Working version!\n                 20MAY10 - v1.0\n***************************** Rexx ***********************************/\nARG GdgBase InParms                       /* Place arguments here    */\n\nSELECT\n  WHEN WORDPOS(GdgBase,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN GdgBase = \"\"                 THEN DO\n     SAY  \" You must supply a GdgBase for %GDGCOPY!\"\n     EXIT 12\n    END\nOTHERWISE; CALL INITIALIZE_THIS_REXX; END\n/**********************************************************************\n              Initialize ERROR handling\n***********************************************************************/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     */\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT */\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  */\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO */\nTRACE (TEST)\n\nDO UNTIL RESUME \u00ac= 'Y'              /* SET UP FOR RESUME, IF NECESSARY */\n   ok='*';ADDRESS \"LINKPGM\" \"IGGCSI00 MODRSNRC CSIFIELD DWORK\"\n   IF RC \u00ac= 0 THEN CALL DISPLAY_IGGCSI_ERROR\n\n   RESUME = SUBSTR(CSIFIELD,150,1)  /* GET RESUME FLAG FOR NEXT LOOP   */\n   PARSE VALUE DWORK WITH . +4 . +4 CSIUSDLN +4 . +2 rest\n   rest=LEFT(rest, C2D(CSIUSDLN)-14)\n   /********************************************************************/\n   /*  PROCESS DATA RETURNED IN WORK AREA                              */\n   /********************************************************************/\n   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/\n      PARSE VALUE rest WITH . +1 CSICTYPE +1 CSICNAME +44 . +2 . +1 . +1 rest\n      SELECT\n        WHEN CSICTYPE = '0'     THEN ITERATE\n        WHEN LENGTH(rest) <= 49 THEN ITERATE\n        WHEN tmp = 0            THEN DO\n            tmp=1; DDLIST=\"SYSUT1\"\n            x=BPXWDYN(\"ALLOC DD(SYSUT1) DSN(\"STRIP(CSICNAME)\") OLD REUSE\")\n            IF x \u00ac= 0 THEN ExitError = BPXWDYN_ERR(x \"ALLOC\" CSICNAME)\n          END\n      OTHERWISE\n          tmp=tmp+1; DDLIST=DDLIST\",TMP\"tmp\n          x=BPXWDYN(\"ALLOC DD(TMP\"tmp\") DSN(\"STRIP(CSICNAME)\") OLD REUSE\")\n          IF x \u00ac= 0 THEN ExitError = BPXWDYN_ERR(x \"ALLOC\" CSICNAME)\n      END\n   END\nEND\n\nIF tmp > 0 THEN DO\n   ok='0'\n   x=BPXWDYN(\"CONCAT DDLIST(\"DDLIST\")\")\n   IF x = 0 THEN ADDRESS \"LINKMVS\" \"ICEGENER\"\n      ELSE ExitError=BPXWDYN_ERR(x \"CONCAT\" DDLIST)\n  END\nELSE ExitError=1\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"CATALOG() TEST(O)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        /* Initial variables used by IGGCSI interface                 */\n  MODRSNRC = LEFT(' ',4)              /* CLEAR MODULE/RETURN/REASON   */\n  CSIFILTK = LEFT(STRIP(GdgBase)'.*',44)\n  CSICATNM = LEFT(CATALOG,44)         /* CLEAR CATALOG NAME           */\n  CSIRESNM = LEFT(' ',44)             /* CLEAR RESUME NAME            */\n  CSIDTYPS = LEFT('H',16)             /* Get these entry types        */\n  CSICLDI  = ' '                      /* Indicate DATA and INDEX      */\n  CSIRESUM = LEFT(' ',1)              /* CLEAR RESUME FLAG            */\n  CSIS1CAT = LEFT(' ',1)              /* INDICATE SEARCH > 1 CATALOGS */\n  CSIOPTNS = LEFT(' ',1)              /* CLEAR RESERVE CHARACTER      */\n  CSINUMEN = X2C(RIGHT(D2X(0),4,'0'))\n  /********************************************************************/\n  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */\n  /********************************************************************/\n  CSIOPTS  = CSICLDI ||CSIRESUM||CSIS1CAT||CSIOPTNS\n  CSIFIELD = CSIFILTK||CSICATNM||CSIRESNM||CSIDTYPS||CSIOPTS||CSINUMEN\n  /********************************************************************/\n  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */\n  /********************************************************************/\n  WORKLEN = 64000; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))\n  DWORK   = CSIUSRLN || COPIES('00'X,WORKLEN-4)\n\n  tmp = 0   /* Number of TMP DDs allocated (GDGs - 1)                 */\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      An error occured when calling IGGCSI00, dislay MODRSNRC, the\n         parms used to call it, and the WORK area returned.\n***********************************************************************/\nDISPLAY_IGGCSI_ERROR:\n  SAY  \"IGGCSI Error!  LINK RC=\"RC \"MOD=\"LEFT(MODRSNRC,2),\n       \"RSN=\"C2D(SUBSTR(MODRSNRC,3,1)) \"RC=\"C2D(SUBSTR(MODRSNRC,4,1))\n  SAY  \"_______________________ CSIFIELD ______________________\"\n  SAY  CSIFIELD\n  SAY  \"________________________ DWORK ________________________\"\n  SAY  DWORK\n  SAY  \"_______________________________________________________\"\nEXIT RC\n/**********************************************************************\n     Display BPXWDYN error information for non-zero Return Codes\n***********************************************************************/\nBPXWDYN_ERR:\nPARSE ARG BPXWDYN_rc arg2 arg3\n  SAY RIGHT(arg2,7) \"of:\" arg3\n  IF BPXWDYN_rc > 0 THEN DO\n     PARSE VALUE RIGHT(D2X(BPXWDYN_rc),8,\"0\") WITH dyn_EC 5 dyn_RC .\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc \"(\"dyn_EC dyn_RC\")\"\n    END\n  ELSE DO\n     dyn_EC = ABS(BPXWDYN_rc)\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc\n  END\n  IF SYMBOL(\"S99MSG.0\")=\"VAR\" THEN DO m=1 TO S99MSG.0;SAY \"  \"S99MSG.m;END\nRETURN dyn_EC\n/* COPY ERRMVS */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETSYSOT": {"ttr": 43, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01C\\x00\\x02\\x01\\x17\\x13\\x0f\\x01\\x17%O\\x100\\x00H\\x00\\x19\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.67", "flags": 0, "createdate": "2017-05-10T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 72, "newlines": 25, "modlines": 0, "user": "AL-FERG"}, "text": "/******************************** REXX ********************************\n  This REXX Requires TSO because it uses:\n       - The PDS/PDS86 program from http://CBTTape.org\n       - The SDSF REXX Interface\n\n  This REXX also uses:\n       - MVS to writes the merged output to the REPORTS DD member\n ******************************** Rexx ********************************/\nTRACE(\"O\")                     /* Set REXX TRACE for Debugging        */\nMsgStat=MSG(\"OFF\")\nARG Element .\n\nCALL INITIALIZE_REXX\n\nx=ISFCALLS('ON')\n  ADDRESS \"SDSF\" \"ISFEXEC DA\"\n  CALL CAPTURE_LIST_SYSOUT 1\nx=ISFCALLS('OFF')\n\nCALL WRITE_LIST_SYSOUT\n\nMsgStat=MSG(MsgStat)\nEXIT\n/*\n       Setup Various Variable to be used by this REXX\n*/\nINITIALIZE_REXX:\n  TRUE=1; FALSE=0\n  StepLst   = \"MAPP030  MAPP040  COL902   ASMMAPR  LINKMAPR\",\n              \"CICSPREC ASMPGM   LINKEDIT CICSCOPY AMPMCPRE\",\n              \"GENPGM   DYL280   LINKDYL  PREPRCSR\"\n  SysoutLst = \"STATOUT  STATOUT  SYSTSPRT SYSPRINT SYSPRINT\",\n              \"SYSPRINT SYSPRINT SYSPRINT SYSPRINT SYSPRINT\",\n              \"SYSPRINT SYSPRINT SYSPRINT LSTIN   \"\n  FndDds.=\"\"; FndDds.0=0\n  IsfJesName = MVSVAR(\"SYMDEF\",\"JES\")\n  IsfOwner = USERID(); IsfPrefix = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n  IsfSysname = MVSVAR(\"SYMDEF\",\"SYSNAME\")\nRETURN\n/*\n      Capture Utility SYSOUT from Current PROC Run ...\n*/\nCAPTURE_LIST_SYSOUT:\nARG RowNo .\n  ADDRESS \"SDSF\" \"ISFACT DA TOKEN('\"Token.RowNo\"') PARM(NP ?) (PREFIX Jds)\"\n  DO i=(JdsDdName.0-5) TO JdsDdName.0\n     IF \u00ac(ABBREV(Element,JdsStepN.i))           THEN ITERATE i\n     IF WORDPOS(JdsDdName.i,SysoutLst) = 0      THEN ITERATE i\n     StepCnts = WORDPOS(JdsProcS.i,StepLst)\n     IF StepCnts = 0                            THEN ITERATE i\n     IF JdsDdName.i \u00ac= WORD(SysoutLst,StepCnts) THEN ITERATE i\n\n     ADDRESS \"SDSF\" \"ISFACT DA TOKEN('\"JdsToken.i\"') PARM(NP SA)\"\n     tmp = 1+FndDds.0; FndDds.0 = tmp\n     ADDRESS \"MVS\" \"EXECIO * DISKR\" IsfDdName.1 \"(STEM FndDds.\"tmp\". FINIS\"\n  END\nRETURN\n/*\n      Save Captured utility SYSOUTs to Specified Reports DD\n*/\nWRITE_LIST_SYSOUT:\n  x = BPXWDYN(\"INFO DD(REPORTS) INRTDSN(Dsn)\") /* Get MapPrm DSN      */\n  x = BPXWDYN(\"ALLOC DD(REPORTS) DSN('\"Dsn\"(\"Element\")') BUFNO(75) SHR REUSE\")\n  DO k = 1 TO FndDds.0\n     ADDRESS \"MVS\" \"EXECIO * DISKW REPORTS (STEM FndDds.\"k\".\"\n  END\n  ADDRESS \"MVS\" \"EXECIO 0 DISKW REPORTS (FINIS\"\n  x = BPXWDYN(\"FREE DD(REPORTS)\")\n  DROP FndDds. ; FndDds.=\"\"; FndDds.0=0\n\n  ADDRESS \"TSO\" \"PDS '\"Dsn\"' A\" Element \"ADDSTATS\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HRECV": {"ttr": 121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x017\\x00'\\x01\\x02\\x03o\\x01\\x17%_\\x17\\x07\\x02\\x02\\x01\\xe3\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "01.55", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-12T17:07:27", "lines": 514, "newlines": 483, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO is used to display HSM DSN Recovery Data and\n        allow Recovery of the DSN(s) via an ISPF selection Panel.\n\n                           --- EXAMPLE ---\n<TSO> <%>HRECV DsnLevel <LEVEL(TRUE|FALSE)> <TEST(TraceOption)>\n<TSO> <%>HRECV -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: DsnLevel    - DSN name or DSN LEVEL to RECOVER\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                   LEVEL - DsnLevel is a DSN Level filter, TRUE or FALSE.\n                           default:  FALSE (it is an indvidule DSN name)\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: HRECV\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.29\n                 FERGUSON AL (HUL2353)\n         Writen: 22AUG95\n        History: 11SEP17 - v1.54 - Refactor\n                 06FEB17 - v1.33 - Mass Update of Error routines.\n                 01FEB17 - v1.32 - Update for Error Handling Fixes.\n                 31JAN17 - v1.31 - Update all REXXes w/latest common\n                           routines via %CCMASS\n                 17DEC15 - v1.29 - Fix use of \"YES\" & \"NO\" for LEVEL.\n                 08MAR12 - v1.27 - Changes to help set LEVEL value\n                           automatically for non-quoted datasets that do\n                           not exist as personal datasets.\n                 05APR10 - v1.25 - Changes for zOS 1.11 HLIST updates.\n                 27MAR06 - v1.23 - Changes to support stacking the command.\n                 27MAR06 - v1.21 - Add POPUP if now DsnLevel provided.\n                 27MAR06 - v1.18 - First Working Version\n                 22AUG95 - v1.00\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG DsnLevel InParms\n\nIF WORDPOS(DsnLevel,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF DsnLevel = ''                 THEN CALL INVOKE_AS_MACRO\nIF DsnLevel = ''                 THEN DO\n   CALL SET_MSG \"%HRECV What?!?!\",\"%HRECV requires a DSN to work with!\",\"YES\"\n   ExitError=8\n  END\nELSE                               CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nSELECT\n  WHEN GET_HSM_INFO() THEN DO\n     DO FOREVER\n        ok='4 8';ADDRESS \"ISPEXEC\" \"TBDISPL\" _RES@ \"PANEL(HRECV01) AUTOSEL(NO)\"\n        IF RC = 8 & ZTDSELS \u00ac= 1 THEN LEAVE\n        IF ZTDSELS = 0           THEN ITERATE\n        DO selected=1 TO ZTDSELS\n           CALL PROCESS_SELECTION\n           ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN\" _RES@\n        END\n        ok='0';ADDRESS \"ISPEXEC\" \"TBSKIP\" _RES@ \"ROW(\"ZTDTOP\")\"\n     END\n     ok='0';ADDRESS \"ISPEXEC\" \"TBEND\" _RES@\n    END\n  WHEN LEVEL          THEN\n     CALL SET_MSG \"No HSM Backup Data!\", \"There is no HSM Backup Data\",\n                  \"for the DSN LEVEL: \" DsnLevel \"!!!\", \"YES\"\nOTHERWISE\n     CALL SET_MSG \"No HSM Backup Data!\", \"There is no HSM Backup Data\",\n                  \"for the DSN: \" DsnLevel \"!!!\", \"YES\"\nEND\n\nIF ExitError \u00ac= 0 THEN DO\n   ZISPFRC=ExitError;ok=\"0\";ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEND\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n                                    /* Initialize NonPositional parms */\n  ValidParms=\"LEVEL(FALSE) TEST(O)\"\n  MatchLength=4                     /* NP-Parms match first # chars   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n  _RES@=\"RT\"||TIME(\"S\")\n\n  SELECT\n    WHEN LEVEL = TRUE            THEN DsnLevel=STRIP(DsnLevel,\"B\",\"'\")\n    WHEN ABBREV(LEVEL,\"Y\")       THEN DO\n             DsnLevel=STRIP(DsnLevel,\"B\",\"'\"); LEVEL=TRUE\n      END\n    WHEN ABBREV(DsnLevel,\"'\")    THEN          LEVEL=FALSE\n    WHEN SYSDSN(DsnLevel) = \"OK\" THEN          LEVEL=FALSE\n  OTHERWISE; DsnLevel=STRIP(DsnLevel,\"B\",\"'\"); LEVEL=TRUE ; END\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREEN ZSCRMAXW)\"\n  col=(ZSCRMAXW - 58)/2\n  POP_loc=\"ROW(8) COLUMN(\"col\")\"\n  ODS_dsn=\"SPFTEMP\"ZSCREEN\".HLIST\"\n\n  ZTDMARK=CENTER(\"--->  No More HSM Info  <---\", ZSCRMAXW)\n          /* Valid HRECV DSN selection options                       */\n          /*     C - HCANcel, Cancel an existing queued request      */\n          /*     D - HBDELete, Delete a backup version of a DSN      */\n          /*     I - All HSM Info from HLIST BCDS                    */\n          /*     L - HList, List HSM information on this DSN         */\n          /*     Q - HQuery, List DFSMShsm Request for DSN           */\n          /*     R - HRECOVer, recover a DSN from a backup version   */\n  valopts=\"C D I L Q R\"\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n  ADDRESS \"ISREDIT\" \"MACRO (DsnLevel InParms) NOPROCESS\"\n  IF RC \u00ac= 0 | DsnLevel = \"\" THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"ADDPOP ROW(5) COLUMN(12)\"\n     ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(HRECV05)\"\n     display_RC=RC\n     ok='0';ADDRESS \"ISPEXEC\" \"REMPOP\"\n     IF display_RC \u00ac= 0 THEN EXIT\n  END\n  UPPER DsnLevel\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY DISPMSG */\n/********************************************************************** /*COPY*/\n           Use ISPF CONTROL DISPLAY LOCK to give user STATUS            /*COPY*/\n                 during a long running portion of REXX                  /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_MSG:                                                            /*COPY*/\nPARSE ARG ZERRLM, ZERRALRM .                                            /*COPY*/\n  ZERRSM=\"\"; ZERRHM=\"ISR2MACR\"           /* Initialize ISRZ002 Fields *//*COPY*/\n  IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                      /*COPY*/\n     ELSE                           ZERRALRM='NO'                       /*COPY*/\n  IF SYSVAR('SYSENV') = 'BACK' THEN SAY ZERRLM                          /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     ok='*';ADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"                    /*COPY*/\n            ADDRESS \"ISPEXEC\" \"DISPLAY MSG(ISRZ002)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n     Use HSM HLIST commond to get DSN or DSN Level info from HSM\n***********************************************************************/\nGET_HSM_INFO:\n  CALL DISPLAY_MSG \"Retrieving information from HSM.  Please wait ...\", \"NO\"\n\n  ok='0 8';ADDRESS \"TSO\" \"DELETE (\"ODS_dsn\") NVSAM\"\n  ok='0'                /* Acceptable RC for following Commands       */\n  IF LEVEL THEN ADDRESS \"TSO\" \"HLIST LEVEL(\"DsnLevel\") ODS(\"ODS_dsn\") BCDS\"\n           ELSE ADDRESS \"TSO\" \"HLIST DSN(\"DsnLevel\")   ODS(\"ODS_dsn\") BCDS\"\n  CALL DISPLAY_MSG \"Digesting HSM retrieved information.  Please wait ...\", \"NO\"\n    ADDRESS \"TSO\" \"ALLOC DD(HLISTOUT) DSN(\"ODS_dsn\") OLD REUSE\"\n    ADDRESS \"MVS\" \"EXECIO * DISKR HLISTOUT (STEM HLIST. FINIS)\"\n    ADDRESS \"TSO\" \"FREE DD(HLISTOUT) DELETE\"\n  IF HLIST.0 <= 6 THEN RETURN FALSE  /* No HSM BCDS Data for this DSN */\n\n  ok='0 4'\n    ADDRESS \"ISPEXEC\" \"TBCREATE\" _RES@ \"KEYS(DsName versnmbr)\"           ,\n            \"NAMES(DsName2 bkpdsn bkpvol fromvol bkpdate bkptime syscat\" ,\n            \"unsret racfind bkpprof bkpfreq maxver) NOWRITE REPLACE\"\n  DO i = 4 TO (HLIST.0 - 3)\n     SELECT\n       WHEN LEFT(HLIST.i,30) = \"\"                     THEN NOP\n       WHEN ABBREV(HLIST.i, \"1\")                      THEN NOP\n       WHEN INDEX(HLIST.i, \"DATA SET NAME\") > 0       THEN NOP\n       WHEN INDEX(HLIST.i, \"VOLUME  VOLUME DATE\") > 0 THEN NOP\n       WHEN INDEX(HLIST.i, \"DSNAME =\") > 0            THEN PARSE VALUE ,\n            HLIST.i WITH . \"DSNAME =\" DsName ,\n                         . \"BACKUP FREQ =\" bkpfreq \",\",\n                         . \"VERSIONS = \" maxver\n       WHEN ABBREV(WORD(HLIST.i,1), \"TOTAL\")          THEN NOP\n     OTHERWISE\n        PARSE VALUE HLIST.i WITH bkpdsn bkpvol fromvol bkpdate bkptime ,\n                                 syscat versnmbr unsret racfind bkpprof\n        IF versnmbr = 0 THEN DsName2=DsName; ELSE DsName2=\"\"\n        ok='0 8';ADDRESS \"ISPEXEC\" \"TBADD\" _RES@\n     END\n  END\n  ok='0';ADDRESS \"ISPEXEC\" \"TBSORT\" _RES@ \"FIELDS(DsName,C,A VersNmbr,C,A)\"\n         ADDRESS \"ISPEXEC\" \"TBTOP\" _RES@\nRETURN TRUE\n/**********************************************************************\n            Process HRECV01 Panel Selection for current row\n***********************************************************************/\nPROCESS_SELECTION:\n  SELECT\n    WHEN sel = \"C\" THEN DO   /* HCANcel, Cancel a queued request       */\n       ok='0';ADDRESS \"TSO\" \"HCANCEL DsName('\"DsName\"')\"\n       CALL SET_MSG , \"HCANCEL sent for DsName('\"DsName\"').\", \"NO\"\n      END\n    WHEN sel = \"D\" THEN DO   /* HBDELete, Delete a DSN backup          */\n       ok='0';ADDRESS \"ISPEXEC\" \"ADDPOP\" POP_loc\n       ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(HRECV02)\"\n       display_RC=RC\n       ok='0';ADDRESS \"ISPEXEC\" \"REMPOP\"\n       IF display_RC = 0 THEN DO\n          ADDRESS \"TSO\" \"HBDELETE ('\"DsName\"') VERSIONS(\"versnmbr\")\"\n          CALL SET_MSG ,\"HBDELETE on version\" versnmbr \"backup of '\"DsName\"'.\"\n       END\n      END\n    WHEN sel = \"I\" THEN DO   /* HBDELete, Delete a DSN backup          */\n       ok='0';ADDRESS \"ISPEXEC\" \"ADDPOP\" POP_loc\n       ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(HRECV03)\"\n       ok='0';ADDRESS \"ISPEXEC\" \"REMPOP\"\n      END\n    WHEN sel = \"L\" THEN DO   /* HBDELete, Delete a DSN backup          */\n       ok='0';ADDRESS \"TSO\" \"HLIST DATASET('\"DsName\"')\"\n       CALL SET_MSG ,\"HBDELETE on version\" versnmbr \"backup of '\"DsName\"'.\"\n      END\n    WHEN sel = \"Q\" THEN DO   /* HQuery, List HFSMShsm Request for DSN  */\n       ok='0';ADDRESS \"TSO\" \"HQUERY DATASETNAMES('\"DsName\"')\"\n       CALL SET_MSG ,\"HQUERY done on '\"DsName\"'.\"\n      END\n    WHEN sel = \"R\" THEN DO   /* HRECOVer, recover DSN from a backupn   */\n       ok='0';ADDRESS \"ISPEXEC\" \"ADDPOP\" POP_loc\n       ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(HRECV04)\"\n       display_RC=RC\n       ok='0';ADDRESS \"ISPEXEC\" \"REMPOP\"\n       IF display_RC = 0 THEN DO\n          ADDRESS \"TSO\" \"HRECOVER '\"DsName\"' GENERATION(\"versnmbr\")\",\n                                  \"NEWNAME('\"newname\"')\" REPLACE\n          CALL SET_MSG ,\"HRECOVER of '\"DsName\"' scheduled to '\"newname\"'.\"\n       END\n      END\n  OTHERWISE\n     CALL SET_MSG , sel \"- not currently supported.\",\n                   \"Supported options are:\" valopts, \"YES\"\n  END\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                            /* Ignore all non-0 RCs           */\n   ADDRESS \"ISPEXEC\" \"TBEND\" _RES@\n   ADDRESS \"TSO\" \"FREE DD(HLISTOUT)\"\n   ADDRESS \"TSO\" \"DELETE (\"ODS_dsn\") NVSAM\"\n   ZISPFRC=ExitError\n   ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype  =CONDITION('C')            /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause =ERRORTEXT(RC)         /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause  =CONDITION('D')        /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl =\"\"                                                        /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg=ZERRLM                                                   /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg='No available ERROR description.'                        /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg='No available ERROR description.'                        /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                               /*COPY*/\n     ELSE emsg=SYSMSGLVL1                                               /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg=\"SYSREASON: '\"SYSREASON\"'\"                               /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError=4      /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError=RC                                                  /*COPY*/\n  erc=ExitError         /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPTAG": {"ttr": 45, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x02\\x01\\x11\\t\\x8f\\x01\\x17%O\\x100\\x01\\x8c\\x01\\x8b\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2011-04-08T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 396, "newlines": 395, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX converts and ISPF CMDS or KEYS Table into DTL Format so it\n      can be maintained/updated. This table can be re-compiled back to\n      an usable ISPF CMDS or KEYS Table using the ISPDTLC utility.\n\nNOTE: This ISPF REXX uses ISPF File Tayloring enbedded REXX support.\n\n                           --- EXAMPLE ---\nTSO <%>ISPTAG applid_pds <TYPE(CMDS|KEYS)> <TEST(TraceOption)>\nTSO <%>ISPTAG -H -- To display help for this REXX\n\n  Arguments: applid_pds  - ISPF APPLID or PDS w/member name, for CMD\n                           table to convert.\n                     NOTE: This will NOT override a version of the CMDS\n                           or KEYS Table currently in you concatination!\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TYPE - ISPF Table Type, currently support are ISPF\n                           CMD & KEY Tables               default: CMDS\n                    TEST - Used to control traces\n\n      Files: INPUT - ISPF File Tayloring members CMDTAG0 & KEYTAG0 from\n                     ISPSLIB.  ISPF CMDS or KEYS table to convert. If\n                     APPID supplied, it must be in current ISPTLIB\n                     Concatination.  Otherwise supply the full PDS\n                     w/member.\n            OUTPUT - VIEW Session on Dialog Tag version of ISPF\n                     commands.  You will need to save this somewhere, if\n                     you want to use it later.\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: ISPTAG\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 2.06\n                 FERGUSON AL (HUL2353)\n         Writen: 22NOV10\n        History: 06FEB17 - v2.08 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v2.07 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v2.06 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 08APR11 - v2.01 - First versions supporting both\n                           CMDS & KEYS.\n                 02MAR11 - v1.11 - Ensure APPLID is Capalized and\n                           CMDS Table is TBCLOSEd if there are problems.\n                 12JAN11 - v1.09 - Fix to ensure APPLID showing up\n                           in DTL File properly.\n                 12JAN11 - v1.05 - Add support for dynamically\n                           allocated ISPF CMDS not currently in your\n                           ISPTLIB concatination.\n                 22NOV10 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG applid_pds InParms                       /* Place arguments here */\n\nIF WORDPOS(applid_pds,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF INDEX(applid_pds, \"(\") > 0 THEN DO\n    PARSE VALUE applid_pds WITH pds_name \"(\" tname \")\" .\n    IF ABBREV(pds_name,\"'\") THEN pds_name = pds_name\"'\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID(\"pds_name\") STACK\"\n  END\nELSE tname = applid_pds||TYPE\nPARSE VALUE tname WITH applid (TYPE) .\n\nok='0 8';ADDRESS \"ISPEXEC\" \"TBOPEN\" tname \"NOWRITE SHARE\"\nIF RC = 0 THEN DO\n    ADDRESS \"ISPEXEC\" \"TBTOP\" tname\n    ADDRESS \"TSO\" \"ALLOC DD(ISPFILE) NEW REUSE\"             ,\n                  \"AVGREC(K) SPACE(1,5) TRACKS UNIT(VIO)\"   ,\n                  \"DSORG(PS) LRECL(255) RECFM(V B) BLKSIZE(0)\"\n    ADDRESS \"ISPEXEC\" \"FTOPEN\"\n    ADDRESS \"ISPEXEC\" \"FTINCL\" TYPE\"TAG0\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"\n    ADDRESS \"MVS\" \"EXECIO * DISKR ISPFILE (STEM tname. FINIS\"\n    ADDRESS \"TSO\" \"FREE DD(ISPFILE)\"\n    ADDRESS \"ISPEXEC\" \"TBEND\" tname\n    CALL STEMDISP \"VIEW\",\"tname.\"\n  END\nELSE CALL SET_MSG \"Table not found!\", \"You currently do not have an\",\n     \"ISPF Table named '\"STRIP(tname)\"' in your ISPTLIB concatination.\",,\n     \"YES\"\n\nIF INDEX(applid_pds, \"(\") > 0 THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TYPE(CMD) TEST(O)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\n  valid_types = \"CMDS KEYS\"\n  IF WORDPOS(TYPE, valid_types) = 0 THEN TYPE = \"CMDS\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    IF INDEX(applid_pds, \"(\") > 0 THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ADDRESS \"ISPEXEC\" \"TBCLOSE\" tname\n    ZISPFRC = ExitError                /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPTIME": {"ttr": 47, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x02\\x01\\x16\"\\x9f\\x01\\x17%O\\x100\\x01J\\x01I\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2016-08-16T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 330, "newlines": 329, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to display the current DATE() and TIME() in the\n      standard ISPF Short Message.\n\n                           --- EXAMPLE ---\nTSO <%>ISPTIME <TEST(TraceOption)>\nTSO <%>ISPTIME -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: ISPTIME\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 16AUG16\n        History: 06FEB17 - v1.05 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.04 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.03 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 16AUG16 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG InParms            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL SET_MSG DATE(\"N\")\".\"RIGHT(DATE(\"J\"),3)\"-\"TIME(),,\"NO\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KEYTAG": {"ttr": 49, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x02\\x01\\x102o\\x01\\x17%O\\x100\\x01}\\x01a\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2010-11-22T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 381, "newlines": 353, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX converts and ISPF KEYS Table into DTL Format so it can be\n      maintained/updated. This table can be re-compiled back to an\n      usable ISPF KEYS Table using the ISPDTLC utility.\n\nNOTE: This ISPF REXX uses ISPF File Tayloring enbedded REXX support.\n\n                           --- EXAMPLE ---\nTSO <%>KEYTAG applid_pds <TEST(TraceOption)>\nTSO <%>KEYTAG -H -- To display help for this REXX\n\n  Arguments: applid_pds  - ISPF APPLID or PDS w/member name, for KEY\n                           table to convert.\n                     NOTE: This will NOT override a version of the KEYS\n                           Table currently in you concatination!\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: INPUT - ISPF File Tayloring member KEYSTAG0 from ISPSLIB\n             INPUT - ISPF KEYS table to convert. If APPID supplied,\n                     it must be in current ISPTLIB Concatination.\n                     Otherwise supply the full PDS w/member.\n            OUTPUT - VIEW Session on Dialog Tag version of ISPF\n                     commands.  You will need to save this somewhere, if\n                     you want to use it later.\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: KEYTAG\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.18\n                 FERGUSON AL (HUL2353)\n         Writen: 02MAR11\n        History: 06FEB17 - v1.20 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.19 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.18 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 02MAR11 - v1.0 - Copy from CMDTAG REXX\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG applid_pds InParms                       /* Place arguments here */\n\nIF WORDPOS(applid_pds,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF INDEX(applid_pds, \"(\") > 0 THEN DO\n    PARSE VALUE applid_pds WITH pds_name \"(\" tname \")\" .\n    IF ABBREV(pds_name,\"'\") THEN pds_name = pds_name\"'\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID(\"pds_name\") STACK\"\n  END\nELSE tname = applid_pds||\"KEYS\"\nPARSE VALUE tname WITH applid \"KEYS\" .\n\nok='0 8';ADDRESS \"ISPEXEC\" \"TBOPEN\" tname \"NOWRITE SHARE\"\nIF RC = 0 THEN DO\n    ADDRESS \"ISPEXEC\" \"TBTOP\" tname\n    ADDRESS \"TSO\" \"ALLOC DD(ISPFILE) NEW REUSE\"             ,\n                  \"AVGREC(K) SPACE(1,5) TRACKS UNIT(VIO)\"   ,\n                  \"DSORG(PS) LRECL(255) RECFM(V B) BLKSIZE(0)\"\n    ADDRESS \"ISPEXEC\" \"FTOPEN\"\n    ADDRESS \"ISPEXEC\" \"FTINCL KEYSTAG0\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"\n    ADDRESS \"MVS\" \"EXECIO * DISKR ISPFILE (STEM tname. FINIS\"\n    ADDRESS \"TSO\" \"FREE DD(ISPFILE)\"\n    ADDRESS \"ISPEXEC\" \"TBEND\" tname\n    CALL STEMDISP \"VIEW\",\"tname.\"\n  END\nELSE CALL SET_MSG \"Table not found!\", \"You currently do not have an\",\n     \"ISPF Table named '\"STRIP(tname)\"' in your ISPTLIB concatination.\",,\n     \"YES\"\n\nIF INDEX(applid_pds, \"(\") > 0 THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    IF INDEX(applid_pds, \"(\") > 0 THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ADDRESS \"ISPEXEC\" \"TBCLOSE\" tname\n    ZISPFRC = ExitError                /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LJUST": {"ttr": 51, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x02\\x01\\x02\\x03o\\x01\\x17%O\\x100\\x01V\\x01\\\\\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 342, "newlines": 348, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n    This ISPF MACRO left justifies a row or set of rows.\n\n                           --- EXAMPLE ---\n<%>LJUST <TEST(TraceOption)>\n<%>LJUST -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: The current EDIT member\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: LJUST\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.15\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 14JUN93\n        History: 06FEB17 - v1.17 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.16 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.15 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.13 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 23JUN93 - v1.10 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 14JUN93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) NOPROCESS\"\n\nCALL INITIALIZE_THIS_REXX\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 4 16';ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nIF RC = 0 THEN DO\n   ok='0'\n     ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFRANGE\"\n     ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLRANGE\"\n     ADDRESS \"ISREDIT\" \"RESET COMMAND\"\n     ADDRESS \"ISREDIT\" \"(line) = LINE\" first\n     ADDRESS \"ISREDIT\" \"LINE\" first \"= '\"line\"'\"\n   DO i=first TO last\n      ADDRESS \"ISREDIT\" \"(line) = LINE\" i\n      string=LEFT(STRIP(line),WIDTH)\n      ADDRESS \"ISREDIT\" \"LINE\" i \"= '\"string\"'\"\n   END\nEND\nCALL SET_MSG \"Lines justified.\", STRIP(last - first + 1,\"L\",\"0\"),\n             \"lines have been LEFT justified.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0    /* REXX functional values for TRUE and FALSE     */\n                     /* Initialize and process non-positional parms   */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4                    /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\n  ADDRESS \"ISREDIT\" \"(width) = LRECL\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACLST": {"ttr": 53, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x02\\x01\\x02\\x03o\\x01\\x17%O\\x100\\x01x\\x01\\x81\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:30:02", "lines": 376, "newlines": 385, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO reads a file containing TSO REXXs, CLists, TSO/ISPF\n        native commands, or ISPF Macros.  Each must be on its own line\n        followed by all its required parameters.\n\n                           --- EXAMPLE ---\n<%>MACLST inputdsn <TEST(TraceOption)>\n<%>MACLST -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: inputdsn    - File containing list to be executed.\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: A file with a REXX and its parms per record\nOther EXECS: Should work with most REXXs, CLists, TSO commands, ISPF\n             commands, and ISPF Macros.\n\nEXEC History\n\nEXEC/MACRO Name: MACLST\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.15\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 23JUN93\n        History: 06FEB17 - v1.17 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.16 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.15 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.05 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 23JUN93 - v1.02 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 23JUN93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (inputdsn InParms) PROCESS\"\n\nPARSE VALUE inputdsn WITH maybe_a_pds '(' member_name ')' rest\nIF LEFT(maybe_a_pds,1) = \"'\" THEN maybe_a_pds = maybe_a_pds\"'\"\nIF INDEX(inputdsn, \"(\") > 0 & SYSDSN(maybe_a_pds) \u00ac= 'OK' THEN DO\n   InParms=inputdsn InParms; inputdsn=''\nEND\nIF WORDPOS(inputdsn,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF inputdsn = '' THEN DO\n   ADDRESS \"ISREDIT\" \"SAVE\"\n   ADDRESS \"ISREDIT\" \"(inputdsn) = DATASET\"\n   ADDRESS \"ISREDIT\" \"(member) = MEMBER\"\n   IF (member \u00ac= '') THEN inputdsn=\"'\"inputdsn\"(\"member\")'\"\n      ELSE                inputdsn=\"'\"inputdsn\"'\"\nEND\n\nCALL CHECK_DSN(inputdsn)\nCALL READ_IT(inputdsn 'ispfmac')\n\nok='*'                                     /* Turn off Error Trapping */\nDO i=1 to ispfmac.0\n   PARSE VALUE ispfmac.i WITH CmdToProcess '/*' comment '*/' rest\n   IF CmdToProcess = '' THEN ITERATE\n   INTERPRET '\"'CmdToProcess'\"'            /* Cmds Executed here      */\nEND\n\nCALL SET_MSG \"Command(s) processed.\", ispfmac.0 \"TSO command(s),\",\n             \"REXX(s), CList(s), ISPF command(s), and/or ISPF\",\n             \"EDIT Macro(s) processed from\" inputdsn\".\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0   /* REXX functional values for TRUE and FALSE      */\n                    /* Initialize and process non-positional parms    */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4                 /* NP-Parms match on first # chars  */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY CHECKDSN */\n/********************************************************************** /*COPY*/\n            Check existance of a Dataset returning error_msg            /*COPY*/\n***********************************************************************//*COPY*/\nCHECK_DSN: PROCEDURE                                                    /*COPY*/\nARG PDS_DSN .                                                           /*COPY*/\n  error_msg = SYSDSN(PDS_DSN)                                           /*COPY*/\n  IF error_msg \u00ac= 'OK' & SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO             /*COPY*/\n     CALL SET_MSG error_msg, PDS_DSN error_msg, \"YES\"                   /*COPY*/\n     EXIT 8                                                             /*COPY*/\n  END                                                                   /*COPY*/\nRETURN error_msg                                                        /*COPY*/\n/* COPY READIT */\n/********************************************************************** /*COPY*/\n            Read a Dataset into a REXX Compound variable                /*COPY*/\n***********************************************************************//*COPY*/\nREAD_IT:                                                                /*COPY*/\nARG PDS_DSN comp_var .                                                  /*COPY*/\n  ok='0'           /* Acceptable RC for ALLOC, EXECIO & FREE Commands *//*COPY*/\n    ADDRESS \"TSO\" \"ALLOC DD(dataset) DSN(\"PDS_DSN\") SHR REUSE BUFNO(10)\"/*COPY*/\n    ADDRESS \"MVS\" \"EXECIO * DISKR dataset (STEM\" comp_var\". FINIS)\"     /*COPY*/\n    ADDRESS \"TSO\" \"FREE DD(dataset)\"                                    /*COPY*/\nRETURN VALUE(comp_var\".0\")                                              /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACREP": {"ttr": 55, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01*\\x00\\x03\\x01\\x02\\x03o\\x01\\x17%O\\x100\\x01\\x90\\x01\\x85\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.42", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 400, "newlines": 389, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX uses the MACREPM ISPF macro to repeat any non-self ENDing\n      ISPF Macro through all members of a PDS.  This REXX can uses a\n      NP-Parameter to filter the members to be processed.  If the\n      FILTER NP-PARM matches the leading characters of the member then\n      the member is processed, otherwise it is skipped.\n\n This REXX is similar to the REPEATIT REXX EXEC, but does not require the\n      'imacro' Macro to be self ENDing.  This means the same Macro can\n      be used on an individual member while in EDIT mode or as part of\n      a BATCH process on all members of a PDS.\n\n                           --- EXAMPLE ---\nTSO <%>MACREP PdsDsn RepMac <RepParm> <FILTER(*|filter*)> <TEST(TraceOption)>\nTSO <%>MACREP -H -- To display help for this REXX\n\n  Arguments: PdsDsn       - PDS to execute the imacro against\n             RepMac       - Macro to repeat through all members of a PDS\n             RepParm      - Macro to repeat through all members of a PDS\n             InParms      - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                   FILTER - Member list filter, i.e. only process those\n                            members which match the filter.\n                            default:  '*'\n                     TEST - Used to control traces\n\n      Files: The current PDS and all it's members\nOther EXECS: Can use DSNS to bring up a DSN list similar to ISPF's 3.4\n             to issue the MACREP command against.\n\nEXEC History\n\n REXX EXEC Name: MACREP\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.16\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 26OCT93\n        History: 02MAY17 - v1.28 - Add Support for MACREPM RepParm\n                           Parameter.\n                 06FEB17 - v1.18 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.17 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.16 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.22 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 26OCT93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG PdsDsn RepMac RepParm InParms\n\nSELECT\n  WHEN WORDPOS(PdsDsn,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN WORDPOS(PdsParm,\"(\")    > 0 THEN DO\n     InParms = RepParm InParms; RepParm = \"\"\n    END\nOTHERWISE\n  CALL INITIALIZE_THIS_REXX\nEND\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL CHECK_DSN(\"'\"PdsDsn\"'\")           /* Does PDS exist?             */\nCALL GET_IT(\"'\"PdsDsn\"'\" FILTER) /* Get member list                   */\n\nok='0'; ADDRESS \"ISPEXEC\" \"VPUT (RepMac RepParm) SHARED\"\nok='0 4'\nDO i = 1 TO filtered.0\n   member = WORD(filtered.i,1)\n   IF ABBREV(member,\"!\") THEN ITERATE i\n   IF TEST \u00ac= \"O\" THEN SAY RIGHT(i,,3) \"iMacro\" RepMac \"against:\" member\n   ADDRESS \"ISPEXEC\" \"EDIT DATASET('\"PdsDsn\"(\"member\")') MACRO(%MACREPM)\"\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n            Initialize varables and get startup parameters\n**********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n                    /* Initialize and process non-positional parms   */\n  ValidParms = \"FILTER(*) TEST(O)\"\n  MatchLength = 4                 /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS   /* Got any...prime em  */\n\n  NbrSubmited = 0         /* Number of batch jobs submitted          */\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n\n  IF INDEX(PdsDsn,\"'\") = 0 THEN PdsDsn = SYSUID\".\"PdsDsn\n     ELSE PdsDsn = STRIP(PdsDsn,\"B\",\"'\")\n  IF AnythingElse \u00ac= \"\" THEN RepParm = AnythingElse\nRETURN\n/**********************************************************************\n          Use TSO \"LISTDS\" command to get a member list of PDS\n**********************************************************************/\nGET_IT: PROCEDURE EXPOSE filtered.\nARG PDS_DSN member_filter .\n  x = OUTTRAP(\"list.\")             /* Trap output from TSO command   */\n  ok='0'; ADDRESS \"TSO\" \"LISTDS (\"PDS_DSN\") MEMBERS\"\n  x = OUTTRAP(\"OFF\")\nRETURN FILTER_IT(STRIP(member_filter,\"T\",\"*\"))\n/**********************************************************************\n          Filter out everything but the member names of PDS\n**********************************************************************/\nFILTER_IT:\nARG mem_filter .\n  DO i = 1 TO list.0 UNTIL list.i = '--MEMBERS--' | i > list.0 ; END\n  k = 0\n  DO i = i + 1 TO list.0 WHILE list.i <= \"ZZZZZZZZ\"\n      IF \u00ac(ABBREV(STRIP(list.i), mem_filter)) THEN ITERATE\n      k = k + 1\n      filtered.k = STRIP(list.i)\n  END\n  filtered.0 = k\nRETURN filtered.0\n/* COPY CHECKDSN */\n/********************************************************************** /*COPY*/\n            Check existance of a Dataset returning error_msg            /*COPY*/\n***********************************************************************//*COPY*/\nCHECK_DSN: PROCEDURE                                                    /*COPY*/\nARG PDS_DSN .                                                           /*COPY*/\n  error_msg = SYSDSN(PDS_DSN)                                           /*COPY*/\n  IF error_msg \u00ac= 'OK' & SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO             /*COPY*/\n     CALL SET_MSG error_msg, PDS_DSN error_msg, \"YES\"                   /*COPY*/\n     EXIT 8                                                             /*COPY*/\n  END                                                                   /*COPY*/\nRETURN error_msg                                                        /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACREPM": {"ttr": 9, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x03\\x01\\x02\\x03o\\x01\\x17%O\\x100\\x01W\\x01`\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 343, "newlines": 352, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO is used in conjuction with the MACREP REXX EXEC.  It\n        is used to EXEC a non-self ENDing ISPF MACRO and then END out\n        of the current EDIT session.  This macro gets its input from\n        the ISPF SHARED variable POOL via a VGET (The VPUT was done by\n        the MACREP REXX EXEC before entering an EDIT sesion on a member\n        using this Macro as the initial EDIT Macro).\n\n                           --- EXAMPLE ---\n<%>MACREPM <TEST(trace option)>\n<%>MACREPM -H -- To display help for this ISPF Macro\n\n  Arguments: inparms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: Current EDIT member\nOther EXECS: Can be use with SETVAR to set the 'repmac' variable for testing.\n\nEXEC History\n\nISPF MACRO Name: MACREPM\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.16\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 26OCT93\n        History: 06FEB17 - v1.18 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.17 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.16 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.14 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 26OCT93 - v1.0\n\n***************************** Rexx ***********************************/\nmsgstat = MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) PROCESS\"\n\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0';ADDRESS \"ISREDIT\" \"%ALIASMC\"              /* Set initial Macro */\nok='0 8';ADDRESS \"ISPEXEC\" \"VGET (repmac repparm) SHARED\"\nok='*';ADDRESS \"ISREDIT\" repmac repparm\n\nIF RC > 1 THEN EXIT 1        /* Stay in current member to fix problem */\n/* COPY MACROEND */\n/*********************************************************************  /*COPY*/\n        Macro END of edit sesion, and background macro end              /*COPY*/\n**********************************************************************/ /*COPY*/\nok='*';ADDRESS \"ISREDIT\" \"END\"                                          /*COPY*/\nIF SYSVAR('SYSENV') = 'BACK' THEN DO                                    /*COPY*/\n   ADDRESS \"ISREDIT\" \"MEND\"                                             /*COPY*/\n   EXIT ExitError                                                       /*COPY*/\nEND                                                                     /*COPY*/\n\nmsgstat = MSG(msgstat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1;   FALSE=0      /* REXX functional values for TRUE and FALSE */\n                     /* Initialize and process non-positional parms   */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4                  /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & accept_all = TRUE         THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAN": {"ttr": 57, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x03\\x01\\x17\\x17\\x1f\\x01\\x17%O\\x100\\x01q\\x01K\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2017-06-20T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 369, "newlines": 331, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX uses the BPXWUNIX interface and STEMVIEW to display Unix\n      Man Pages (Unix command Help Doc).\n\n                           --- EXAMPLE ---\nTSO <%>MAN entry <TEST(TraceOption)>\nTSO <%>MAN -H -- To display help for this REXX\n\n  Arguments: entry       - Man Page Entry to look up, if blank display\n                           a list of Man Pages available.\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - REXX Trace Option              default: Off\n\n      Files: USS Man Pages in $MANPATH.\nOther EXECS: NONE\n\nNOTE: To Enable MAN pages, copy EPH.SEPHSAMP(EPHWP00) to SYS1.PARMLIB\n      and change DSN=EPH.SEPHTAB to match your SYSRES EPH SEPHTAB.\n\nEXEC History\n\n REXX EXEC Name: MAN\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 20JUN17\n        History: 15AUG17 - v1.27 - Minor refactoring & Add CLEANUP\n                           Function on Error.\n                 10AUG17 - v1.19 - First functional version\n                 20JUN17 - v1.00\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG entry InParms                      /* Place arguments here */\n\nIF WORDPOS(entry,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n  /* ISPF Folds most cmd line input, Unix cmds are usually lower case */\nIF entry \\= \"\" THEN ManParm=TRANSLATE(entry AnythingElse,Lower,Upper)\n   ELSE             ManParm=\"-k .|grep -Ev\" Exclude\n\nx=BPXWUNIX(\"man\" ManParm,,\"SOut.\",\"SErr.\",\"Env.\")\n  IF DATATYPE(x,\"X\") & LENGTH(x)=8 THEN CALL BPX_RC_TO_MSG_TEXT x\n  IF SErr.0 > 0 THEN CALL STEMEDIT \"BROWSE\",\"SErr.\",,,\"Err MAN\" ManParm\n  IF SOut.0 > 0 THEN CALL STEMEDIT \"BROWSE\",\"SOut.\",,,\"MAN\" ManParm\nDROP SOut. SErr.\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\n  HOME=\"/u/\"TRANSLATE(USERID(),Lower,Upper)\n  Env.=\"\";Env.0=3\n  Env.1=\"_UNIX03=YES\"\n  Env.2=\"PATH=/bin:/usr/bin:/usr/sbin:/usr/local/bin:\"HOME\"/bin\"\n  Env.3=\"MANPATH=/usr/man/%L:/usr/local/man:\"HOME\"/man:\"HOME\"/share/man\"\n\n  Exclude = \"'(\u00ac\u00dd\u00dd:blank:\u00a8\u00a8*$|\\(tcsh shell\\))'\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY BPXRCMSG */\n/********************************************************************** /*COPY*/\n      Display Message Text for a Unix Rc || Ec combination              /*COPY*/\n***********************************************************************//*COPY*/\nBPX_RC_TO_MSG_TEXT:                                                     /*COPY*/\nARG RcEc .                                                              /*COPY*/\n  UssEnv.=\"\";UssEnv.0=2;UssEnv.1=\"_UNIX03=YES\";UssEnv.2=\"PATH=/bin\"     /*COPY*/\n  x = BPXWUNIX(\"edcmtext\" RcEc,,\"MT.\",\"SE.\",\"UssEnv.\")                  /*COPY*/\n  IF ABBREV(SYSVAR(\"SYSENV\"),\"FORE\") THEN DO                            /*COPY*/\n     IF SE.0 > 0 THEN CALL STEMEDIT \"BROWSE\",\"SE.\",,,\"STD Err:\"         /*COPY*/\n     IF MT.0 > 0 THEN CALL STEMEDIT \"BROWSE\",\"MT.\",,,\"Uss RC:\" RcEc     /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     IF SE.0 > 0 THEN DO i=1 TO SE.0; SAY \"    \" SE.i; END              /*COPY*/\n     IF MT.0 > 0 THEN DO i=1 TO MT.0; SAY \"    \" MT.i; END              /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  IF DATATYPE(RC,\"X\") & LENGTH(RC)=8 THEN CALL BPX_RC_TO_MSG_TEXT RC\n  DROP SOut. SErr.                   /* Free possibly large STEM Vars */\n  ZISPFRC = ExitError                /* SET ISPF RC to ExitError      */\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Pass Exit RC to ISPF          */\nEXIT ExitError                       /* EXIT with error return code   */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MIGLEVEL": {"ttr": 59, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x013\\x00\\x03\\x01\\x061/\\x01\\x17%O\\x100\\x01\\xc0\\x01\\xb7\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.51", "flags": 0, "createdate": "2006-11-08T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 448, "newlines": 439, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is uses the Catalog Search Interface (CSI) to determine\n      which DSNs for a LEVEL are not Migrate and then HMIGs them.\n\n                           --- EXAMPLE ---\n<TSO> <%>MIGLEVEL DsnLevel <TEST(TraceOption)>\n<TSO> <%>MIGLEVEL -H -- To display help for this REXX\n\n  Arguments: DsnLevel    - Dataset level to check for migrated DSNs\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: Input data is pulled from the System Catalog via CSI\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: MIGLEVEL\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.31\n                 FERGUSON AL (HUL2353)\n         Writen: 12SEP07\n        History: 06FEB17 - v1.33 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.32 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.31 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 12SEP07 - v1.13 - First Working Version.\n                 12SEP07 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG DsnLevel InParms                         /* Place arguments here */\n\nSELECT\n  WHEN WORDPOS(DsnLevel,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN DsnLevel = \"\"                  THEN DO\n     CALL SET_MSG \"DSN Filter needed!\",,\n          \"This needs a Dataset Name Level to find DSNs to Migrate!\", \"YES\"\n     EXIT 4\n    END\nOTHERWISE\n   CALL INITIALIZE_THIS_REXX\nEND\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCATNAMET = ''; DNAMET   = ''\nDO UNTIL RESUME \u00ac= 'Y'  /* SET UP Resume LOOP, if necessary             */\n   ok='*';ADDRESS \"LINKPGM\" \"IGGCSI00 MODRSNRC CSIFIELD DWORK\"\n   IF RC \u00ac= 0 THEN CALL DISPLAY_IGGCSI_ERROR\n\n   RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */\n   PARSE VALUE DWORK WITH CSIUSRLN +4 CSIREQLN +4 CSIUSDLN +4 CSINUMFD +2 rest\n   CSIUSRLN = C2D(CSIUSRLN)           /* Total Length of WORK AREA     */\n   CSIREQLN = C2D(CSIREQLN)           /* Minimum Required Work         */\n   CSIUSDLN = C2D(CSIUSDLN)           /* GET AMOUNT OF WORK AREA USED  */\n   CSINUMFD = C2D(CSINUMFD)           /* Number of field names +1      */\n   rest = LEFT(rest, CSIUSDLN-14)\n   /********************************************************************/\n   /*  PROCESS DATA RETURNED IN WORK AREA                              */\n   /********************************************************************/\n   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/\n      CALL PARSE_DSN\n      IF CSICTYPE = '0' THEN DO      /* IF CATALOG, PRINT CATALOG HEAD*/\n          IF CSICNAME \u00ac= CATNAMET & CSICFLG = 0 THEN ExitError = CSICRETR\n          CATNAMET = CSICNAME\n        END\n      ELSE DO\n         CALL SET_DSN_TYPE\n     /*  We now have NAME AND TYPE ... Get additional Info         */\n         start_at = 2*fld.0\n         _length = CSICRETM-(start_at+4); _trail = _length//6\n         _string = SUBSTR(rest,start_at+1,_length)\n         _volume = LEFT(_string, (_length - _trail))\n         _type   = RIGHT(_string, _trail)\n         rest = SUBSTR(rest,CSICRETM-3)\n         IF DNAMET = CSICNAME THEN ITERATE; ELSE DNAMET = CSICNAME\n         IF \u00ac(ABBREV(_volume, \"MIGRAT\") | ABBREV(_type, \"C\")) THEN DO\n            IF ABBREV(SYSVAR(\"SYSENV\"),\"BACK\") THEN\n                             SAY \"HMIG ('\"CSICNAME\"') NOWAIT\"\n            ok='*';ADDRESS \"TSO\" \"HMIG ('\"STRIP(CSICNAME)\"') NOWAIT\"\n         END\n      END\n   END\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n        /* Initial variables used by IGGCSI interface                  */\n  MODRSNRC = LEFT(' ',4)              /*   CLEAR MODULE/RETURN/REASON  */\n  CSIFILTK = LEFT(STRIP(DsnLevel,\"B\",\"'\"),44) /*MOVE FILTER KEY INTO LIST */\n  CSICATNM = LEFT(' ',44)             /*   CLEAR CATALOG NAME          */\n  CSIRESNM = LEFT(' ',44)             /*   CLEAR RESUME NAME           */\n  CSIDTYPS = LEFT('AC',16)            /*   Get NONVSAM & CLUSTERs      */\n  CSICLDI  = LEFT('Y',1)              /*   INDICATE DATA AND INDEX     */\n  CSIRESUM = LEFT(' ',1)              /*   CLEAR RESUME FLAG           */\n  CSIS1CAT = LEFT(' ',1)              /*   INDICATE SEARCH > 1 CATALOGS*/\n  CSIOPTNS = LEFT(' ',1)              /*   CLEAR RESERVE CHARACTER     */\n  fld. = \"\"; fld.0 = 2\n  fld.1.nm = LEFT('VOLSER  ',8); fld.1.ln = 6\n  fld.2.nm = LEFT('TYPE    ',8); fld.2.ln = 1\n  CSINUMEN = X2C(RIGHT(D2X(fld.0),4,'0'))\n  /********************************************************************/\n  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */\n  /********************************************************************/\n  CSIOPTS  = CSICLDI  || CSIRESUM || CSIS1CAT || CSIOPTNS\n  CSIFIELD = CSIFILTK || CSICATNM || CSIRESNM || CSIDTYPS || CSIOPTS,\n          || CSINUMEN\n  DO i = 1 TO fld.0; CSIFIELD = CSIFIELD || fld.i.nm; END\n  /********************************************************************/\n  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */\n  /********************************************************************/\n  WORKLEN = 64000 ; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))\n  DWORK = CSIUSRLN || COPIES('00'X,WORKLEN-4)\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Pull out Dataset Name information\n***********************************************************************/\nPARSE_DSN:\n  PARSE VALUE rest WITH CSICFLG  +1 CSICTYPE +1 CSICNAME +44 CSICRETM ,\n                     +2 CSICRETR +1 CSICRETN +1 rest\n  CSICFLG  = C2X(CSICFLG )\n  CSICRETM = C2D(CSICRETM)\n  CSICRETR = C2D(CSICRETR)         /* Catalog return reason code    */\n  CSICRETN = C2D(CSICRETN)         /* Catalog return code           */\nRETURN\n/**********************************************************************\n      Expand CSICTYPE Value for Dataset Type\n***********************************************************************/\nSET_DSN_TYPE: PROCEDURE\nARG CSICTYPE .\n  SELECT                   /*  ASSIGN ENTRY TYPE NAME  */\n    WHEN CSICTYPE = 'C' THEN DTYPE = 'CLUSTER '\n    WHEN CSICTYPE = 'D' THEN DTYPE = 'DATA    '\n    WHEN CSICTYPE = 'I' THEN DTYPE = 'INDEX   '\n    WHEN CSICTYPE = 'A' THEN DTYPE = 'NONVSAM '\n    WHEN CSICTYPE = 'H' THEN DTYPE = 'GDS     '\n    WHEN CSICTYPE = 'B' THEN DTYPE = 'GDG     '\n    WHEN CSICTYPE = 'R' THEN DTYPE = 'PATH    '\n    WHEN CSICTYPE = 'G' THEN DTYPE = 'AIX     '\n    WHEN CSICTYPE = 'X' THEN DTYPE = 'ALIAS   '\n    WHEN CSICTYPE = 'U' THEN DTYPE = 'UCAT    '\n    WHEN CSICTYPE = 'L' THEN DTYPE = 'TAPELIB '\n    WHEN CSICTYPE = 'W' THEN DTYPE = 'TAPEVOL '\n  OTHERWISE;                 DTYPE = '        '; END\nRETURN DTYPE\n/**********************************************************************\n      An error occured when calling IGGCSI00, dislay MODRSNRC, the\n         parms used to call it, and the WORK area returned.\n***********************************************************************/\nDISPLAY_IGGCSI_ERROR:\n  SAY  \"IGGCSI Error!  LINK RC=\"RC \"MOD=\"LEFT(MODRSNRC,2),\n       \"RSN=\"C2D(SUBSTR(MODRSNRC,3,1)) \"RC=\"C2D(SUBSTR(MODRSNRC,4,1))\n  SAY  \"_______________________ CSIFIELD ______________________\"\n  SAY  CSIFIELD\n  SAY  \"________________________ DWORK ________________________\"\n  SAY  DWORK\n  SAY  \"_______________________________________________________\"\nEXIT RC\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ML": {"ttr": 143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x03\\x003\\x01\\x17#\\x0f\\x01\\x17'\\x1f\\x13\\x13\\x01\\xe7\\x01\\xd4\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.03", "flags": 0, "createdate": "2017-08-18T00:00:00", "modifydate": "2017-09-28T13:13:33", "lines": 487, "newlines": 468, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF Macro supports full screen Point-N-Shoot. To improve\n        this functionality, assign it to a PFKey, add it as an ISPF CMD,\n        or, better yet, do both! If this is envoked as an ISPF Macro and\n        a valid dataset is not passed (via PARM or Cursor Position), it\n        will view the current DSN or member, if one is passed.\n\n   This REXX/ISPF MACRO supports multiple MEMLIST levels, so you may\n        MEMLIST a dataset from within another.\n\n   This REXX/ISPF MACRO supports USS File Directory Lists\n\n   This REXX/ISPF MACRO supports member list pattern matching, i.e.  If\n        it is envoked with a DSN of highlev.lowlev(AB*) it will display\n        a member list for the PDS of all members starting with AB.  If\n        it is envoked with a DSN of highlev.lowlev(AB%) it will display\n        a member list for the PDS of all members starting with AB and are\n        three characters in length.\n\n                       --- EXAMPLE as TSO CMD ---\nTSO <%>ML <dsname> <TEST(TraceOption)> <VOLSER(volser)>,\n                     --- EXAMPLE as ISPF Macro ---\n    <%>ML <dsname> <TEST(TraceOption)> <VOLSER(volser)>,\n<TSO> <%>ML -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: dsname      - Dataset to View\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n                  VOLSER - Volume Serial Number to display DSNs for.\n                           default:  blank (display cataloged DSNs only)\n      Files: The EXEC does a DSN member, or Directory List on DsName\nOther EXECS: None\n\nEXEC History\n\nEXEC/MACRO Name: ML\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 18AUG17\n        History: 28SEP17 - v1.04 - More Point-N-Shoot Fixes.\n                 21AUG17 - v1.03 - Minor Refactoring\n                 21AUG17 - v1.02 - Add support for USS Directory\n                           Listing when DsName starts with a '/' or\n                           '~/', i.e. is a Path.\n                 18AUG17 - v1.00 - Based off MU & VW ISPF Macro based\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG DsName InParms\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF ABBREV('.',DsName)          THEN DO; DsName=\"\"; CALL INVOKE_AS_MACRO; END\nIF DsName = ''                 THEN CALL DISPLAY_HELP\n   ELSE                             CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nPARSE VALUE DsName WITH Pds . \"(\" MbrFltr \")\" .\n\nok='0 4 8 12'\nSELECT\n  WHEN POS(\"/\",DsName) > 0 THEN ADDRESS \"ISPEXEC\" \"DIRLIST PATH(DsName)\"\n  WHEN ABBREV(Pds,\"DD:\")   THEN DO\n     ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DDNAME(\"SUBSTR(Pds,4)\") ENQ(SHRW)\"\n     IF RC = 8 THEN CALL SET_MSG \"Can't %ML\", DsName '--' ZERRLM, \"YES\"\n     ADDRESS \"ISPEXEC\" \"LMOPEN DATAID(\"id\") OPTION(INPUT)\"\n     ADDRESS \"ISPEXEC\" \"MEMLIST DATAID(\"id\") MEMBER(\"MbrFltr\") FIELD(9)\"\n    END\nOTHERWISE\n   ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DATASET(\"Pds\") ENQ(SHRW)\",\n                     \"VOLUME(\"VOLSER\")\"\n   IF RC = 8 THEN CALL CALL SET_MSG \"Can't %ML\", DsName '--' ZERRLM, \"YES\"\n   ADDRESS \"ISPEXEC\" \"LMOPEN DATAID(\"id\") OPTION(INPUT)\"\n   ADDRESS \"ISPEXEC\" \"MEMLIST DATAID(\"id\") MEMBER(\"MbrFltr\") FIELD(9)\"\nEND\n\nCALL CLEANUP\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This INITIALIZEs any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n  ADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL)\"\n  SELECT              /* Support ISPF 3.4/DSLIST VOLSERs              */\n    WHEN RC \u00ac= 0                   THEN NOP\n    WHEN ABBREV(\"*ALIAS\", ZDLVOL)  THEN InParms=InParms \"VOLSER()\"\n    WHEN ABBREV(DsName, \"'\"ZDLDSN) THEN InParms=InParms \"VOLSER(\"ZDLVOL\")\"\n  OTHERWISE; NOP; END\n                                    /* Initialize NonPositional parms */\n  ValidParms = \"TEST(O) VOLSER()\"\n  MatchLength=4                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitErr=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n\n  IF VOLSER = \"\" THEN ADDRESS \"ISPEXEC\" \"VGET (VOLSER) SHARED\"\n  response=''; member=''\n  IF IsMacro \u00ac= TRUE THEN IsMacro=FALSE\n\nRETURN\n/* COPY PNTNSHOT */\n/********************************************************************** /*COPY*/\n             If no arguments, was it envoked as a MACRO                 /*COPY*/\n**********************************************************************/ /*COPY*/\nINVOKE_AS_MACRO:                                                        /*COPY*/\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"                                        /*COPY*/\n  IF RC \u00ac= 0 THEN RETURN                                                /*COPY*/\n  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */ /*COPY*/\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"                  /*COPY*/\n  IF RC = 0 THEN DO                                                     /*COPY*/\n     IsMacro=TRUE                                                       /*COPY*/\n     ADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"                             /*COPY*/\n     ADDRESS \"ISREDIT\" \"(RowPos,CurPos) = CURSOR\"                       /*COPY*/\n     IF DsName = \"\" & RowPos = 1 & CurPos = 0 THEN DsName=\"'\"PdsDsn\"'\"  /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO; IsMacro=FALSE; PdsDsn=\"\"; END                                /*COPY*/\n  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/\n                                                                        /*COPY*/\n  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/\n  IF ABBREV(PDS,\"'\")           THEN PDS=STRIP(PDS,\"T\",\"'\")\"'\"           /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN DsName = \"\"           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/\n    WHEN ABBREV(DsName,\"DD:\")  THEN NOP                                 /*COPY*/\n    WHEN ABBREV(DsName,\"dd:\")  THEN NOP                                 /*COPY*/\n    WHEN POS(\"/\",DsName) > 0   THEN NOP                                 /*COPY*/\n    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"          THEN DsName=\"'\"PdsDsn\"(\"DsName\")'\"       /*COPY*/\n  OTHERWISE;                        NOP; END                            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_POINT_N_SHOOT:                                                       /*COPY*/\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"                  /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn                        /*COPY*/\n  OTHERWISE;                       RETURN \"\"; END                       /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/\n    WHEN POS(\"='\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"='\" word . \"'\"                        /*COPY*/\n    WHEN POS(\"DSN=\",word) > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"                     /*COPY*/\n    WHEN POS(\"=\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH   \"=\" word . \",\"                        /*COPY*/\n    WHEN POS(\"''\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"''\" word . \"'\"                        /*COPY*/\n    WHEN ABBREV(word,'\"//')   THEN                                      /*COPY*/\n       PARSE VALUE word    WITH \"//\" word . '\"'                         /*COPY*/\n    WHEN POS(\"(\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"                        /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word          /*COPY*/\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word          /*COPY*/\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN       /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"                                     /*COPY*/\n    WHEN PdsDsn                        \u00ac= ''   THEN DO                  /*COPY*/\n         DsNme=\"'\"PdsDsn\"'\"; filter=word                                /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; DsNme = \"\"; END                                            /*COPY*/\nRETURN DsNme                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_CURRENT_LINE:                                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"        /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC = 0 & \u00ac(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/\n    WHEN IsMacro                                THEN DO                 /*COPY*/\n       ADDRESS \"ISREDIT\" \"(Line) = LINE\" RowPos                         /*COPY*/\n       RETURN Line                                                      /*COPY*/\n      END                                                               /*COPY*/\n    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/\n         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/\n       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/\n       IF ABBREV(LstLn,\"***\")                   THEN Wdth=ZSCREENW+8    /*COPY*/\n          ELSE                                       Wdth=ZSCREENW      /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/\n       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/\n     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/\n  END                                                                   /*COPY*/\n  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth),\" \",\",\")         /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC \u00ac= 0                   THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/\n        ELSE                           ZERRALRM='NO'                    /*COPY*/\n     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                     /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Cleanup & Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  IF RC = 0 & IsMacro     THEN ADDRESS \"ISREDIT\" \"CURSOR =\"RowPos+1 CurPos\n  IF RC > 8               THEN DO\n     ExitErr=RC\n     CALL SET_MSG \"Can't %ML\", DsName '--' ZERRLM, \"YES\"\n  END\n  IF SYMBOL(\"id\") = \"VAR\" THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"id\")\"\n            ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"id\")\"\n  END\n  ZISPFRC = ExitErr                 /* SET ISPF RC to ExitErr         */\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitErr                        /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MU": {"ttr": 141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x07\\x08\\x003\\x01\\x13(\\x9f\\x01\\x17'\\x1f\\x13\\x13\\x06Z\\x05\\xa0\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "07.08", "flags": 0, "createdate": "2013-10-16T00:00:00", "modifydate": "2017-09-28T13:13:33", "lines": 1626, "newlines": 1440, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO dices, it slices, it does Julian Fries; So order\n        before midnight tonight and receive this handy dandy utility\n        REXX absolutely free... oops, wrong comercial.\n\n   This REXX/ISPF Macro supports full screen Point-N-Shoot. To improve\n        this functionality, assign it to a PFKey, add it as an ISPF CMD,\n        or, better yet, do both!\n\n   This REXX/ISPF Macro is a combination for the ISPF option 3.4 'M'\n        (PDS Maintenance) selection for PDSs, ISPF option 3.3 (Member\n        Copy/Move), and many other useful utilities for PDS members.\n\n   MU will also accept ISPF Macros as line commands.  You must proceed the\n        macro with a '%' (or '!' if is is compiled) to indicate it is an\n        ISPF Macro.  If the macro finishes with a RC <= 1 you will be\n        returned to the member list.  If the RC > 1 you will be placed\n        in an EDIT session on the member the macro was being applied\n        against.\n\n   Valid line options:\n            ALIAS: 'a A'        -- Create ALIAS for specified member\n            ALLOC: 'aa AL'      -- Allocate member to DD\n           BROWSE: 'b B'        -- Browse member\n            CLIST: 'cl'         -- EXECUTE the member as a CLIST\n             COPY: 'c C'        -- Copy member to a PDS\n           DELETE: 'd D'        -- Delete member from PDS\n             EDIT: 'e s E S /'  -- Edit member\n             EXEC: 'exec'       -- EXECUTE the member as a REXX\n        EXEC View: 'exv'        -- EXECUTE the member using TSOVIES\n             HELP: 'h H -h -H'  -- Display MU help\n       MAKE ALIAS: 'ma MA'      -- Make an ALIAS to the specified name\n             MOVE: 'm M'        -- Move member to a PDS\n     NEXT VERSION: 'n N'        -- Update member stats incrementing version\n            PRINT: 'p P'        -- Print member using RPRINT saved info\n           RENAME: 'r R'        -- Rename member\n           SUBMIT: 'j J'        -- Submit the current member\n            TOUCH: 't T'        -- Update Changed and ID info for member\n             VIEW: 'v V'        -- View member\n          EXCLUDE: 'x X'        -- Excludes the Current Member from the list\n     Xmit Receive: 'xr XR'      -- TSO XMIT Receive the selected Member\n        Xmit Send: 'xs XS'      -- TSO XMIT Send the selected Member\n       ISPF Macro: all else     -- Invoke the ISPF Macro against member\n   Additional options from member list command line:\n             COMPRess           -- Compress current PDS and refresh member list\n             NP-PARMS           -- As defined below\n             REFresh            -- Refresh current PDS member list\n             RESet              -- Reset current member list\n             TSO COMMANDs       -- As normal, but leading 'TSO ' not required\n\n                           --- EXAMPLE ---\nTSO <%>MU DsName NP_PARMS       -- As a TSO REXX\n    <%>MU DsName NP_PARMS       -- AS an ISPF Macro\n\n NP-PARMS: <COMpress(N|Y)> <IMAcro(macro_name)> <MEMbers(mem_filter)>,\n           <NOData(N|Y)> <SYSuid(7_char_stamp> <TESt(TraceOption)>\n           <VOLser(dsn_volser)> <EXTended(YES|NO)>\n                   <FORMAT(blank|ASCII|UTF8)>\n                           blank (EBCDIC), ASCII, or UTF8\n<TSO> <%>MU -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: DsName      - PDS to %MU, with or without member filter.\n             InParms     - Non-Positional  parameters\n             --- NP-PARMs can also be entered from the ---\n             --- MEMBER LIST OPTION ===> line.         ---\n ----------------------------- NP-PARMS -------------------------------\n                  ALWAYS - Use copy information on copy panel, N or Y.\n                           Usually set via copy or move panel.\n                           default: N\n                COMPRESS - Compress current DsName, N or Y.\n                           default: N\n                EXTENDED - Use ISPF Extended Member Statistics, YES or NO.\n                           default: YES\n                  FORMAT - Charactor encoding          default: blank\n                  IMACRO - Initial ISPF EDIT Macro\n                           default: ALIASMC\n                 MEMBERS - Member template to filter member list\n                           default: *\n                  NODATA - Blank member statistics when \"TOUCHed\", Y or N\n                           default: N\n                  PROMPT - Confirm member deletes, TRUE or FALSE\n                           NP-Parm supported but currently not used.\n                           default: TRUE\n                  SYSUID - 7 Character \"ID\" to use for ID when a member is\n                           \"TOUCHed\", \"NEXT VERSIONed\", and as ID in \"XMIT\"\n                           default: Current RACF ID\n                  VOLSER - Volume Serial Number to display DSNs for.\n                           default: ZDLVOL\n                    TEST - Used to control traces\n\n      Files: Current and target PDSs\nOther EXECS: ALIASMC & MACREPM Edit Macros\n             CREC CList to all XR (TSO RECEIVE) command to work.\n\nEXEC History\n\nEXEC/MACRO Name: MU\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 5.10\n                 Al Ferguson (HUL2353) from version 1.00\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 01APR93\n        History: 28SEP17 - v7.05 - More Point-N-Shoot Fixes.\n                 18SEP17 - v7.02 - Refactoring\n                 12SEP17 - v6.57 - Fixes to TSO RECEIVE under ISPF REXX.\n                 12SEP17 - v6.42 - Blank out EXTENDED when not 'YES'\n                 29AUG17 - v6.34 - Better handle LMMDISP OPTION(PUT)\n                           Failures. Fix RECEIVE to run under REXX.\n                 09AUG17 - v6.20 - Add support for ASCII & UTF8 formats\n                 21JUN17 - v6.10 - Cleanup point & shoot, plus add\n                           support for ZCURWID ISPF System Variable.\n                 19MAY17 - v6.06 - Keep Cursor Col & Advance Row when\n                           invoked as Macro.\n                 02MAY17 - v6.02 - Minor Refactoring\n                 02MAY17 - v6.00 - Add support for MACREPM RepParm\n                           Parameter\n                 13MAR17 - v5.96 - More Point-N-Shoot corrections.\n                 01MAR17 - v5.81 - Fixes to XMIT to support multiple\n                           members in selection.\n                 28FEB17 - v5.59 - Re-enamble Xmit Send & Receive.\n                 06FEB17 - v5.55 - Fix Point-N-Shoot math, again.\n                 06FEB17 - v5.47 - Pick up updated version of ERRINFO\n                           Common Code routines.\n                 01FEB17 - v5.45 - Mass update for Error Handling Fixes.\n                 31JAN17 - v5.44 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 26JAN17 - v5.44 - Tweak Point & Shoot logic.\n                 23NOV16 - v5.36 - Tweak Point-n-Shoot math\n                 22NOV16 - v5.28 - Rewrite of Point and shoot section\n                           to make work as an ISPF Command when not in\n                           an edit session.\n                 10AUG16 - v5.19 - Changes to support use of DDs.\n                 04MAY16 - v5.10 - Use IBM Default Edit/View PANEL vs\n                           custom ED01 Panel.\n                 16OCT13 - v5.00 - Updates to Macro support, MU now\n                           behaves like ISPF's Member command (all\n                           non-line commands are treated as ISPF Macros\n                           or Member Commands\n                 14FEB11 - v4.49 - Add point & Shoot against USS PATHs.\n                 08SEP10 - v4.46 - Support Extended Statistics with TOUCH\n                 09APR10 - v4.41 - Initial 'J - SUBMIT' option support,\n                           similar to the ISPF Member List option.\n                 03DEC02 - v4.04 - Support for 'EX - EXEC' Line option.\n                 31MAR00 - v4.00 - Added MAKE ALIAS line command.\n                 17SEP98 - v3.99 - Fix problems with bad INITIAL\n                           Macro during VIEWs.\n                 18JUL96 - v3.90 - Add support for ISPF Viewing\n                 16JUL96 - v3.88 - Display correct message from TSO\n                           RENAME-ALIAS command failure.\n                 16JUL96 - v3.85 - Have LMMDISP use PANEL ISRUDSM,\n                           same panel as used be 3.4 functions.\n                 29APR96 - v3.79 - Support for VOLSER specific DSNs\n                 03JAN96 - v3.65 - Edit Recovery Checking and Support.\n                 26DEC95 - v3.57 - Enhanced '=' logic in Copy/Move window.\n                 20DEC95 - v3.55 - Added REFresh option to rebuild the\n                           current memberlist.\n                 13OCT95 - v3.49 - Changes to rename function to handle\n                           renaming a member to an already existing\n                           member name.\n                 04OCT95 - v3.48 - Update standard routines and take\n                           advantage of new ones.  Fix to Macro\n                           invocation to work with member patern for\n                           current EDIT PDS.\n                 27SEP95 - v3.38 - Minor Fix to RENAME option.\n                 13SEP95 - v3.35 - Fixed COMPRESS_IT Messaging and ZCMD\n                           to clear COMMAND line of COMPRess option\n                           after compress completed.\n                 17AUG95 - v3.34 - Update RENAME PROCEDURE to\n                           handle failed RENAME attemps.\n                 11AUG95 - v3.26 - Miscellaneous cleanup and tuning\n                 18MAY95 - v3.22 - Update all REXXes with latest commom\n                           routines via %CCMASS\n                 24AUG94 - v3.19 - Fix to handle LMMADDs to browsed\n                           members of a PDS which are not on the current\n                           list (but are in the PDS).\n                 19JUL94 - v3.17 - Added a 'CONTROL DISPLAY LOCK'\n                           when doing a COMPRESS.\n                 03MAR94 - v3.00 - Support for EDing or BRing PS\n                           DSORGed DSNs.\n                 18NOV93 - v2.99 - Support added for PDF commands like\n                           'SUB' via use of the '&' prefix\n                 12NOV93 - v2.99 - Now accepts ISPF Macro's as line\n                           commands.\n                 11NOV93 - v2.99 - Restructuring and modifications,\n                           including 9 columns for line commands, in\n                           preperation for supporting ISPF Macros from\n                           line command.\n                 21OCT93 - v2.86 - Refresh member list after a\n                           compress is done and support for RESET option.\n                 12OCT93 - v2.80 - Warning message added for BROWSE\n                           of a non-existent member.\n                 31AUG93 - v2.74 - Prompting to confirm member\n                           deletes has been added.\n                 13AUG93 - v2.68 - Fix to point and shot routine\n                           and support for COMPRESS command line option\n                           from member list panel.\n                 15JUL93 - v2.57 - Fix of XMIT option to work with other\n                           USERIDs and PDS members.  Removal of '%' from\n                           RPRINT references to allow use of compiled\n                           version of of RPRINT link edited into\n                           compiled version of MU.\n                 30JUN93 - v2.48 - More little errors, improved & more\n                           relevent messages, support for IMACRO\n                           (initial EDIT Macro) NP-Parm.\n                 23JUN93 - v2.38 - Numerous tweeks, new versions of\n                           standar modules, re-design of NP-PARM support\n                           for the OPTION ===> line, et. al.\n                 23JUN93 - v2.26 - Add support for DSN compression.\n                 22JUN93 - v2.18 - Support added for NODATA NP-PARM\n                           being entered from the MEMBER LIST OPTION\n                           line.  Also, TOUCH fixes when there is no\n                           ver mod level.\n                 15JUN93 - v2.10 - Support for DSNs & SYSUIDs entered on\n                           command line\n                 14JUN93 - v2.03 - Minor fixed and NEXT support\n                 09JUN93 - v1.40 - XMIT support added\n                 26MAY93 - v1.30 - Minor fixes and enhancements\n                 30APR93 - v1.20 - Print support, better error handling\n                           better ISPF messaging, point and shoot, & TOUCH\n                 29APR93 - v1.10 - Added Copy, Delete, Move, and\n                           Rename support.\n                 01APR93 - v1.00\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG DsName InParms\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF ABBREV('.',DsName)          THEN DO; DsName=\"\"; CALL INVOKE_AS_MACRO; END\nIF DsName = ''                 THEN DO\n   CALL SET_MSG \"%MU What?\", \"%MU requires a Dataset Name!\", \"YES\"\n   EXIT 1\n  END\nELSE                                CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nCALL CHECK_AND_INIT\nDO dummy = 1           /* Until CREATE_MEMLIST() RCs > 0              */\n   IF CREATE_MEMLIST() > 0 THEN LEAVE dummy\n   MemFunc.=0          /* Re-initialize all function count variables  */\n   IF ZCMD   \u00ac= '' THEN IF PROCESS_ZCMD() = 'RESET' THEN ITERATE\n   IF ZLLCMD \u00ac= '' THEN DO WHILE RC = 0\n      IF ZLLCMD = '=' THEN ZLLCMD=LastCommand\n      IF LINE_COMMANDS(ZLLCMD ZLMEMBER ZLUDATA) > 4 THEN LEAVE\n      LastCommand=ZLLCMD\n      ok='0 4 8'       /* Acceptable RCs for LMMDISP below            */\n        ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(GET) STATS(YES)\"\n   END\n   IF MemFunc.xmited     > 1 THEN CALL DO_XMIT_IT\n   IF MemFunc.processed > 1 THEN CALL SET_ISPF_MSG\nEND\nok='0';ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"id\")\"\nok='0';ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"id\")\"\nIF sameid \u00ac= '' THEN ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"sameid\")\"\n\nIF IsMacro THEN DO; ok='0 12';ADDRESS \"ISREDIT\" \"CURSOR =\"RowPos+1 CurPos; END\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n  ADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL)\"\n  SELECT              /* Support ISPF 3.4/DSLIST VOLSERs              */\n    WHEN RC \u00ac= 0                   THEN VOLSER=\"\"\n    WHEN ABBREV(\"*ALIAS\", ZDLVOL)  THEN VOLSER=\"\"\n    WHEN ABBREV(DsName, \"'\"ZDLDSN) THEN VOLSER=ZDLVOL\n  OTHERWISE;                            VOLSER=\"\"; END\n                                    /* Initialize NonPositional parms */\n  ValidParms=\"ALWAYS(N) COMPRESS(N) FORMAT() IMACRO(%ALIASMC) MEMBERS()\",\n             \"NODATA(N) PROMPT(TRUE) SYSUID(USERID()) TEST(O)\" ,\n             \"VOLSER(\"VOLSER\") EXTENDED(YES)\"\n  MatchLength=3                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitErr=0; it_rc=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n\n  IF PROMPT \u00ac= FALSE THEN PROMPT=TRUE\n  IF AnythingElse \u00ac= '' THEN DO\n     PARSE VALUE STRIP(AnythingElse) WITH pds_name '(' filter ')' .\n     SELECT\n       WHEN LEFT(pds_name,1)  = \"'\"  THEN DsName=\"'\"STRIP(pds_name,,\"'\")\"'\"\n       WHEN SYSDSN(pds_name) \u00ac= \"OK\" THEN filter=pds_name\n     OTHERWISE;                           DsName=\"'\"SYSUID'.'pds_name\"'\"; END\n     IF MEMBERS = '' THEN member=filter; ELSE member=MEMBERS\n    END\n  ELSE DO\n     PARSE VALUE DsName WITH DsName '(' member ')' .\n     IF LEFT(DsName,1) = \"'\" THEN DsName=\"'\"STRIP(DsName,,\"'\")\"'\"\n     IF member = ''          THEN member=MEMBERS\n  END\n\n  UPPER DsName NODATA\n  LnCmds='A AL B C CL D E EXEC EXV H J M MA N P R S T V X XR XS / % ! &'\n  LastCommand='*'\n  second_half=\"is not a valid Copy/Move destination.\"\n  sameid=''; dest=''\n  MemFunc.processed=0; MemFunc.compressed=0\n\n  AbbrevParms=LEFT(WORD(ValidParms,1), MatchLength)\n  DO i=2 TO WORDS(ValidParms)\n     AbbrevParms=AbbrevParms LEFT(WORD(ValidParms,i), MatchLength)\n  END\n  IF IsMacro \u00ac= TRUE THEN IsMacro=FALSE\n  SELECT\n    WHEN FORMAT = \"\"            THEN NOP\n    WHEN ABBREV(\"ASCII\",FORMAT) THEN FORMAT=\"ASCII\"\n    WHEN ABBREV(\"UTF8\", FORMAT) THEN FORMAT=\"UTF8\"\n  OTHERWISE;                         FORMAT=\"\"     ; END\n\nRETURN\n/* COPY PNTNSHOT */\n/********************************************************************** /*COPY*/\n             If no arguments, was it envoked as a MACRO                 /*COPY*/\n**********************************************************************/ /*COPY*/\nINVOKE_AS_MACRO:                                                        /*COPY*/\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"                                        /*COPY*/\n  IF RC \u00ac= 0 THEN RETURN                                                /*COPY*/\n  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */ /*COPY*/\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"                  /*COPY*/\n  IF RC = 0 THEN DO                                                     /*COPY*/\n     IsMacro=TRUE                                                       /*COPY*/\n     ADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"                             /*COPY*/\n     ADDRESS \"ISREDIT\" \"(RowPos,CurPos) = CURSOR\"                       /*COPY*/\n     IF DsName = \"\" & RowPos = 1 & CurPos = 0 THEN DsName=\"'\"PdsDsn\"'\"  /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO; IsMacro=FALSE; PdsDsn=\"\"; END                                /*COPY*/\n  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/\n                                                                        /*COPY*/\n  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/\n  IF ABBREV(PDS,\"'\")           THEN PDS=STRIP(PDS,\"T\",\"'\")\"'\"           /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN DsName = \"\"           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/\n    WHEN ABBREV(DsName,\"DD:\")  THEN NOP                                 /*COPY*/\n    WHEN ABBREV(DsName,\"dd:\")  THEN NOP                                 /*COPY*/\n    WHEN POS(\"/\",DsName) > 0   THEN NOP                                 /*COPY*/\n    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"          THEN DsName=\"'\"PdsDsn\"(\"DsName\")'\"       /*COPY*/\n  OTHERWISE;                        NOP; END                            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_POINT_N_SHOOT:                                                       /*COPY*/\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"                  /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn                        /*COPY*/\n  OTHERWISE;                       RETURN \"\"; END                       /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/\n    WHEN POS(\"='\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"='\" word . \"'\"                        /*COPY*/\n    WHEN POS(\"DSN=\",word) > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"                     /*COPY*/\n    WHEN POS(\"=\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH   \"=\" word . \",\"                        /*COPY*/\n    WHEN POS(\"''\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"''\" word . \"'\"                        /*COPY*/\n    WHEN ABBREV(word,'\"//')   THEN                                      /*COPY*/\n       PARSE VALUE word    WITH \"//\" word . '\"'                         /*COPY*/\n    WHEN POS(\"(\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"                        /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word          /*COPY*/\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word          /*COPY*/\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN       /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"                                     /*COPY*/\n    WHEN PdsDsn                        \u00ac= ''   THEN DO                  /*COPY*/\n         DsNme=\"'\"PdsDsn\"'\"; filter=word                                /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; DsNme = \"\"; END                                            /*COPY*/\nRETURN DsNme                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_CURRENT_LINE:                                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"        /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC = 0 & \u00ac(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/\n    WHEN IsMacro                                THEN DO                 /*COPY*/\n       ADDRESS \"ISREDIT\" \"(Line) = LINE\" RowPos                         /*COPY*/\n       RETURN Line                                                      /*COPY*/\n      END                                                               /*COPY*/\n    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/\n         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/\n       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/\n       IF ABBREV(LstLn,\"***\")                   THEN Wdth=ZSCREENW+8    /*COPY*/\n          ELSE                                       Wdth=ZSCREENW      /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/\n       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/\n     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/\n  END                                                                   /*COPY*/\n  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth),\" \",\",\")         /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC \u00ac= 0                   THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/\n        ELSE                           ZERRALRM='NO'                    /*COPY*/\n     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                     /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY DISPMSG */\n/********************************************************************** /*COPY*/\n           Use ISPF CONTROL DISPLAY LOCK to give user STATUS            /*COPY*/\n                 during a long running portion of REXX                  /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_MSG:                                                            /*COPY*/\nPARSE ARG ZERRLM, ZERRALRM .                                            /*COPY*/\n  ZERRSM=\"\"; ZERRHM=\"ISR2MACR\"           /* Initialize ISRZ002 Fields *//*COPY*/\n  IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                      /*COPY*/\n     ELSE                           ZERRALRM='NO'                       /*COPY*/\n  IF SYSVAR('SYSENV') = 'BACK' THEN SAY ZERRLM                          /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     ok='*';ADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"                    /*COPY*/\n            ADDRESS \"ISPEXEC\" \"DISPLAY MSG(ISRZ002)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Verify we are dealing with a PDS, COMPRESS it if requested,\n      and open the PDS for member list processing\n***********************************************************************/\nCHECK_AND_INIT:\n  x=PROCESS_DSNAME(DsName)\n  IF RC = 8 THEN DO\n     ok='*';ADDRESS \"ISPEXEC\" \"EDIT DATASET(\"DsName\") MACRO(\"IMACRO\")\",\n                              \"VOLUME(\"VOLSER\")\" FORMAT\n     SELECT\n       WHEN RC = 0  |,\n            RC = 4  THEN NOP\n       WHEN RC = 14 THEN CALL SET_MSG 'Dataset in USE!', DsName '--' ZERRLM\n       WHEN RC = 16 THEN CALL SET_MSG \"No Members in PDS!\", DsName '--' ZERRLM\n     OTHERWISE\n        ADDRESS \"ISPEXEC\" \"BROWSE DATASET(\"DsName\") VOLUME(\"VOLSER\")\"\n        IF RC = 20 THEN DO\n           CALL SET_MSG \"Can't %MU\", DsName '--' ZERRLM, \"YES\"\n           ExitErr=21\n        END\n     END\n     EXIT ExitErr\n  END\n  IF ABBREV('YES',COMPRESS) THEN CALL COMPRESS_IT\n\n  ok='0';ADDRESS \"ISPEXEC\" \"LMOPEN DATAID(\"id\") OPTION(INPUT)\"\nRETURN\n/**********************************************************************\n      Process DsName and DO Appropriate LMINIT\n***********************************************************************/\nPROCESS_DSNAME:\nPARSE ARG _dsn_ .\n  ok='0 8'\n  SELECT\n    WHEN ABBREV(_dsn_, \"DD:\") | ABBREV(_dsn_, \"dd:\") THEN\n      ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DDNAME(\"SUBSTR(_dsn_,4)\") ENQ(SHRW)\"\n    WHEN VOLSER \u00ac= \"\"                                THEN\n      ADDRESS \"ISPEXEC\" \"LMINIT DATASET(\"_dsn_\") DATAID(id) ENQ(SHRW)\",\n                        \"VOLUME(\"VOLSER\")\"\n  OTHERWISE\n      ADDRESS \"ISPEXEC\" \"LMINIT DATASET(\"_dsn_\") DATAID(id) ENQ(SHRW)\"\n  END\nRETURN member\n/**********************************************************************\n    Create member list for display\n***********************************************************************/\nCREATE_MEMLIST:\n  ok='0 4 8'\n    ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(DISPLAY) PANEL(ISRUDSM)\",\n                      \"FIELD(9) STATS(YES) MEMBER(\"member\") COMMANDS(ANY)\"\n  IF RC = 4 THEN DO\n      SELECT\n        WHEN member = ''         THEN disp_pds=DsName\n        WHEN ABBREV(DsName, \"'\") THEN\n          disp_pds=STRIP(DsName,\"T\",\"'\")\"(\"member\")'\"\n      OTHERWISE\n          disp_pds=DsName\"(\"member\")\"\n      END\n      CALL SET_MSG \"No members to %MU!\", \"No members in\" disp_pds, 'YES'\n  END\nRETURN RC\n/**********************************************************************\n    Process non-blank command lines\n***********************************************************************/\nPROCESS_ZCMD:\n  CommandLine=ZCMD; ResetDone=''\n  PARSE VALUE ZCMD WITH command cl_member cl_data .\n  ZCMD='';ok='0';ADDRESS \"ISPEXEC\" \"VPUT (ZCMD)\"\n  SELECT\n    WHEN ABBREV('COMPRESS',command,3) THEN DO\n       it_rc=COMPRESS_IT()        /* compress current PDS    */\n                                  /* refresh PDS Member List */\n       ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(FREE)\"\n       ResetDone='RESET'\n      END\n    WHEN ABBREV('REFRESH',command,3)  THEN DO\n       ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(FREE)\"\n       ResetDone='RESET'; ZCMD=\"\"\n       MemFunc.processed=MemFunc.processed+1\n       CALL SET_MSG , DsName \"member list refreshed.\", \"NO\"\n      END\n    WHEN WORDPOS(command, 'H -H') > 0 THEN CALL DISPLAY_HELP('RETURN')\n    WHEN INDEX(command, '(') > 0      THEN DO\n       PARSE VALUE command WITH NpParm \"(\" value \")\" .\n       NpParmNo=WORDPOS(LEFT(NpParm,3),AbbrevParms)\n       SELECT\n         WHEN NpParmNo > 0 THEN DO\n            NpParm=WORD(ValidParms, NpParmNo)\n            PARSE VALUE NpParm WITH NpParm \"(\" .\n            SIGNAL OFF NOVALUE\n            IF ABBREV(NpParm, \"PRO\") THEN DO\n               PROMPT=value\n               IF PROMPT \u00ac= FALSE THEN PROMPT=TRUE\n              END\n            ELSE INTERPRET NpParm '= value'\n            TRACE(TEST)\n            SIGNAL ON  NOVALUE NAME ERROR_PROC\n           END\n         WHEN SYSDSN(NpParm)='OK' | SYSDSN(NpParm\"'\")='OK' THEN DO\n            ok='0';ADDRESS \"TSO\" \"MU\" CommandLine\n           END\n       OTHERWISE  /* It must be a TSO command!? */\n           ok='*';ADDRESS \"TSO\" CommandLine\n           IF RC > 4 | RC < 0 THEN CALL BAD_CMD command\n       END\n      END\n    WHEN SYSDSN(CommandLine) = 'OK' THEN DO\n       ok='0';ADDRESS \"TSO\" \"MU\" CommandLine\n      END\n  OTHERWISE  /* It must be a Line command!? */\n      lc_rc=LINE_COMMANDS(command cl_member cl_data)\n      IF RC > 4 | RC < 0 THEN CALL BAD_CMD command\n  END\n  CommandLine=''\nRETURN ResetDone\n/**********************************************************************\n    Process Line Commands from member list\n***********************************************************************/\nLINE_COMMANDS:\nARG LnCmd MbrNme LnData .\n  SELECT\n    WHEN LnCmd='A'                  THEN it_rc=ALIAS_IT()\n    WHEN LnCmd='AL'                 THEN it_rc=ALLOC_IT()\n    WHEN LnCmd='B'                  THEN it_rc=BROWSE_IT()\n    WHEN LnCmd='C'                  THEN it_rc=COPY_IT()\n    WHEN LnCmd='CL'                 THEN it_rc=EXEC_IT(\"CLIST\")\n    WHEN LnCmd='CLV'                THEN it_rc=EXEC_VIEW_IT(\"CLIST\")\n    WHEN LnCmd='D'                  THEN it_rc=DELETE_IT()\n    WHEN WORDPOS(LnCmd,'E S /') > 0 THEN it_rc=EDIT_IT()\n    WHEN LnCmd='EXEC'               THEN it_rc=EXEC_IT(\"EXEC\")\n    WHEN LnCmd='EXV'                THEN it_rc=EXEC_VIEW_IT(\"EXEC\")\n    WHEN WORDPOS(LnCmd,'H -H')  > 0 THEN CALL DISPLAY_HELP('RETURN')\n    WHEN LnCmd='J'                  THEN it_rc=SUBMIT_IT()\n    WHEN LnCmd='M'                  THEN it_rc=MOVE_IT()\n    WHEN LnCmd='MA'                 THEN it_rc=MAKE_ALIAS()\n    WHEN LnCmd='N'                  THEN it_rc=NEXT_VERSION()\n    WHEN LnCmd='P'                  THEN it_rc=PRINT_IT()\n    WHEN LnCmd='R'                  THEN it_rc=RENAME_IT()\n    WHEN LnCmd='T'                  THEN it_rc=TOUCH_IT()\n    WHEN LnCmd='V'                  THEN it_rc=VIEW_IT()\n    WHEN LnCmd='X'                  THEN it_rc=EXCLUDE_IT()\n    WHEN LnCmd='XR'                 THEN it_rc=XMITREC_IT()\n    WHEN LnCmd='XS'                 THEN it_rc=XMIT_IT()\n  OTHERWISE;                             it_rc=MACRO_IT(); END\nRETURN it_rc\n/**********************************************************************\n    Create an ALIAS of the specified member\n***********************************************************************/\nALIAS_IT:\n  IF ABBREV(LnData,'*') | LnData = '' THEN DO\n     CALL SET_MSG \"ALIAS to what?\", \"No ALIAS name given for\" MbrNme,\n                  \"to create ALIAS for!\", \"YES\"\n     RETURN 1\n  END\n\n  IF ABBREV(DsName, \"'\") THEN DO\n     OldNme=STRIP(DsName,\"T\",\"'\")\"(\"MbrNme\")'\"\n     NewNme=STRIP(DsName,\"T\",\"'\")\"(\"LnData\")'\"\n    END\n  ELSE DO\n     OldNme=DsName\"(\"MbrNme\")\"\n     NewNme=DsName\"(\"LnData\")\"\n  END\n\n  CALL DO_ALIAS\nRETURN 0\n/**********************************************************************\n    ALLOC the member to the specified DD\n***********************************************************************/\nALLOC_IT:\n  IF LEFT(LnData,1) = '*' | LnData = '' THEN DO\n     CALL SET_MSG \"ALLOC to what DD?\", \"No ALLOC DD given for\" MbrNme,\n                  \"to use in ALLOCating!\", \"YES\"\n     RETURN 1\n  END\n\n  ok='0'\n  IF ABBREV(DsName, \"'\") THEN\n       ADDRESS \"TSO\" \"ALLOC DD(\"LnData\") SHR REUSE\",\n                          \"DSN(\"STRIP(DsName,\"T\",\"'\")\"(\"MbrNme\")')\"\n  ELSE ADDRESS \"TSO\" \"ALLOC DD(\"LnData\") SHR REUSE\",\n                          \"DSN(\"DsName\"(\"MbrNme\"))\"\n  MemFunc.processed=MemFunc.processed+1\n  MemFunc.alloced=MemFunc.alloced+1\n  ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*ALLOCed)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*ALLOCed)\"\n  END\nRETURN 0\n/**********************************************************************\n    Create an the specified member name an ALIAS\n***********************************************************************/\nMAKE_ALIAS:\n  IF LEFT(LnData,1) = '*' | LnData = '' THEN DO\n     CALL SET_MSG \"MAKE ALIAS of what?\", \"No original name given for\",\n                  MbrNme \"to create ALIAS from!\", \"YES\"\n     RETURN 1\n  END\n\n  IF ABBREV(DsName, \"'\") THEN DO\n     NewNme=STRIP(DsName,\"T\",\"'\")\"(\"MbrNme\")'\"\n     OldNme=STRIP(DsName,\"T\",\"'\")\"(\"LnData\")'\"\n    END\n  ELSE DO\n     NewNme=DsName\"(\"MbrNme\")\"\n     OldNme=DsName\"(\"LnData\")\"\n  END\n\n  CALL DO_ALIAS\nRETURN 0\n/**********************************************************************\n    Invoke ISPF ALIAS Command to create a member ALIAS\n***********************************************************************/\nDO_ALIAS:\n  xmsg=MSG(\"ON\"); x=OUTTRAP(\"ALIAS.\",2)\n  ok='0 12';ADDRESS \"TSO\" \"RENAME\" OldNme NewNme \"ALIAS\"\n  xmsg=MSG(xmsg); x=OUTTRAP(\"OFF\")\n  ALIAS_RC=RC\n\n  SELECT\n    WHEN ALIAS_RC = 0                   THEN DO\n        MemFunc.processed=MemFunc.processed+1\n        MemFunc.alias=MemFunc.alias+1\n        ok='0 8'\n        ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                          \"MEMBER(\"MbrNme\") ZLUDATA(*Alias)\"\n        IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                \"MEMBER(\"MbrNme\") ZLUDATA(*Alias)\"\n        ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD) MEMBER(\"LnData\")\"\n        IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                                          \"MEMBER(\"LnData\")\"\n      END\n    WHEN MbrNme = LnData                 THEN DO\n        CALL SET_MSG \"Not a new name!\", \"You can't ALIAS a member to the\",\n                     \"same name?!?!?!\", \"YES\"\n      END\n    WHEN WORDPOS(ALIAS_RC, \"12\") \u00ac= 0 THEN CALL SET_MSG , ALIAS.1 ALIAS.2, \"YES\"\n  OTHERWISE; NOP; END\nRETURN 0\n/**********************************************************************\n    Browse member in current %MU member list\n***********************************************************************/\nBROWSE_IT:\n  ok='0 12 14 20';ADDRESS \"ISPEXEC\" \"BROWSE DATAID(\"id\") MEMBER(\"MbrNme\")\"\n  SELECT\n    WHEN RC = 12 THEN DO\n        CALL SET_MSG \"ERROR on\" STRIP(MbrNme)\"!\", \"An ERROR occured while\",\n                     \"BROWSEing\" STRIP(MbrNme) \"--\" ZERRLM, 'YES'\n        ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                       \"MEMBER(\"MbrNme\") ZLUDATA(*BRError)\"\n      END\n    WHEN RC >= 14 THEN CALL SET_MSG STRIP(MbrNme) \"not found!\",,\n        \"No member\" STRIP(MbrNme) \"found --\" ZERRLM, 'YES'\n  OTHERWISE\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.browsed=MemFunc.browsed+1\n      ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*Browsed)\"\n      IF RC = 8 THEN DO      /* New member to ADD to member list      */\n          ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                           \"MEMBER(\"MbrNme\") ZLUDATA(*Browsed)\"\n      END\n  END\nRETURN 0\n/**********************************************************************\n    Compress the PDS %MU is currently being envoked on\n***********************************************************************/\nCOMPRESS_IT:\n  IF LEFT(DsName,1) \u00ac= \"'\" THEN dsnname=USERID()\".\"DsName\n     ELSE dsnname=STRIP(DsName,\"B\",\"'\")\n  UPPER dsnname\n\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDINIT LISTID(profile) LEVEL(\"dsnname\")\"\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDLIST LISTID(\"profile\") OPTION(LIST)\",\n                           \"DATASET(dsnname) STATS(YES)\"\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDLIST LISTID(\"profile\") OPTION(FREE)\"\n  trks=STRIP(ZDLSIZE); exts=STRIP(ZDLEXT); used=ZDLUSED\n\n  ok='0 8';ADDRESS \"ISPEXEC\" \"LMINIT DATAID(profid) DATASET(\"DsName\")\",\n                             \"ENQ(EXCLU) VOLUME(\"VOLSER\")\"\n  IF RC = 8 THEN DO\n      CALL SET_MSG \"Can't compress now!\", ZERRLM, 'YES'\n      RETURN 1\n  END\n  CALL DISPLAY_MSG \"Doing a compress of\" dsnname \"at this time!\", \"NO\"\n  ok='*';ADDRESS \"ISPEXEC\" \"LMCOMP DATAID(\"profid\")\"\n  COMP_RC=RC\n  ok='0';ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"profid\")\"\n\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDINIT LISTID(profile) LEVEL(\"dsnname\")\"\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDLIST LISTID(\"profile\") OPTION(LIST)\",\n                           \"DATASET(dsnname) STATS(YES)\"\n  ok='0';ADDRESS \"ISPEXEC\" \"LMDLIST LISTID(\"profile\") OPTION(FREE)\"\n\n  COMPRESS='NO';ZCMD=\"\"\n  IF COMP_RC = 0 THEN DO\n     freed=STRIP(used - ZDLUSED); freed_trks=trks*freed/100\n     MemFunc.processed=MemFunc.processed+1\n     MemFunc.compressed=MemFunc.compressed+1\n     CALL SET_MSG , \"'\"dsnname\"' compressed freeing\",\n                    freed\"% of\" trks \"TRKS, i.e.\" freed_trks \"TRKS.\"\n    END\n  ELSE CALL SET_MSG , ZERRLM, \"NO\"\nRETURN 0\n/**********************************************************************\n    Copy member in current %MU member list\n***********************************************************************/\nCOPY_IT:\n  option='Copying:'\n  SELECT\n    WHEN LEFT(ALWAYS,1) = 'Y' & dest \u00ac = '' THEN CALL DO_COPY\n    WHEN GET_C_M_INFO() THEN CALL DO_COPY\n  OTHERWISE; NOP; END\nRETURN 0\n/**********************************************************************\n    Process an ENDEVOR Batch GENERATE\n***********************************************************************/\nGENERATE_IT:\n  sub_RC=\"\"\nRETURN sub_RC\n/**********************************************************************\n    Get Copy/Move info, i.e. dest. PDS, new name, replace option, etc.\n***********************************************************************/\nGET_C_M_INFO:\n  IF LEFT(DsName,1) = \"'\" THEN\n       origmem=STRIP(DsName,\"T\",\"'\") || \"(\" || STRIP(MbrNme) || \")'\"\n  ELSE origmem=DsName || \"(\" || STRIP(MbrNme) || \")\"\n  IF LnData = '' | LEFT(LnData,1) = '*' THEN newname=MbrNme\n     ELSE                                    newname=LnData\n\n  destattr='INTENS(LOW)'\n  ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(MU01)\"\n  IF RC = 8 THEN RETURN FALSE\n\n  IF INDEX(dest,\"=\") > 0 | INDEX(dest,\"+\") > 0 THEN DO\n    SELECT\n        WHEN   STRIP(dest) = \"=\" THEN dest=DsName\n        WHEN ABBREV(dest,\"+\")    &,\n             ABBREV(DsName,\"'\") THEN\n             dest=STRIP(DsName,\"T\",\"'\")\".\"SUBSTR(dest,2)\"'\"\n        WHEN RIGHT(dest,1) = \"+\" &,\n             ABBREV(DsName,\"'\") THEN\n             dest=\"'\"STRIP(dest,\"T\",\"+\")\".\"STRIP(DsName,\"L\",\"'\")\n        WHEN ABBREV(dest,\"+\")    THEN dest=DsName\".\"SUBSTR(dest,2)\n        WHEN RIGHT(dest,1) = \"+\" THEN dest=STRIP(dest,\"T\",\"+\")\".\"DsName\n        WHEN ABBREV(dest,\"=\")    THEN DO\n            dest=STRIP(dest,\"L\",\"=\")\n            temp=STRIP(dest,\"T\",\".\")\n            hlq=REVERSE(DsName)\n            DO qual_count=1\n                PARSE VALUE hlq WITH . \".\" hlq\n                IF INDEX(temp, \".\") = 0 THEN LEAVE qual_count\n                PARSE VALUE temp WITH . \".\" temp\n            END\n            IF hlq = \"\" THEN PARSE VALUE DsName WITH hlq \".\" .\n               ELSE          hlq=REVERSE(hlq)\n            IF LEFT(hlq,1) = \"'\" THEN dest=hlq\".\"STRIP(dest)\"'\"\n               ELSE                   dest=hlq\".\"STRIP(dest)\n          END\n        WHEN RIGHT(dest,1) = \"=\" THEN DO\n            dest=STRIP(dest,\"T\",\"=\")\n            temp=STRIP(dest,\"T\",\".\")\n            llq=DsName\n            DO qual_count=1\n                PARSE VALUE llq WITH . \".\" llq\n                IF INDEX(temp, \".\") = 0 THEN LEAVE qual_count\n                PARSE VALUE temp WITH . \".\" temp\n            END\n            IF llq = \"\" THEN DO\n                PARSE VALUE REVERSE(DsName) WITH llq \".\" .\n                llq=REVERSE(llq)\n            END\n            IF RIGHT(llq,1) = \"'\" THEN dest=\"'\"STRIP(dest)\".\"llq\n               ELSE                    dest=STRIP(dest)\".\"llq\n          END\n      OTHERWISE; NOP; END\n    END\n  ELSE IF ABBREV(dest, \"'\") THEN dest=STRIP(dest,\"T\",\"'\")\"'\"\n  DO WHILE SYSDSN(dest) \u00ac= 'OK'\n      destattr='INTENS(HIGH)'\n      CALL SET_MSG \"Invalid Dataset Name!\", dest second_half\n      ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(MU01) CURSOR(dest)\"\n      IF RC = 8 THEN RETURN FALSE\n      IF dest = \"=\" THEN dest=DsName\n      ELSE IF ABBREV(dest, \"'\") THEN dest=STRIP(dest,\"T\",\"'\")\"'\"\n  END\n\n  IF replike = 'Y' THEN REPLACE='REPLACE'; ELSE REPLACE=''\n  ok='0';ADDRESS \"ISPEXEC\" \"LMINIT DATASET(\"dest\") DATAID(trgtid) ENQ(SHRW)\"\n                   /*      \"VOLUME(\"trgVOL\")\" */\nRETURN TRUE\n/**********************************************************************\n            Copy Member Logic\n***********************************************************************/\nDO_COPY:\n  IF LnData = '' | LEFT(LnData,1) = '*' THEN\n       x=COPY_MEMBER(MbrNme MbrNme)\n  ELSE x=COPY_MEMBER(LnData MbrNme)\n  IF x = 0 THEN DO\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.copied=MemFunc.copied+1\n      ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                                 \"MEMBER(\"MbrNme\") ZLUDATA(*Copied)\"\n      IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                        \"MEMBER(\"to_member\") ZLUDATA(*Copied)\"\n  END\nRETURN\n/**********************************************************************\n            Copy Member to a new PDS\n***********************************************************************/\nCOPY_MEMBER:\nARG to_member fm_member .\n  ok='0 4 8 12'\n  ADDRESS \"ISPEXEC\" \"LMCOPY FROMID(\"id\") FROMMEM(\"fm_member\")\",\n                    \"TODATAID(\"trgtid\") TOMEM(\"to_member\") TRUNC\" REPLACE\n  success=RC; IF RC \u00ac= 0 THEN excuse=ZERRLM\n  IF LEFT(ALWAYS,1) \u00ac= 'Y' THEN DO\n      ok='0';ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"trgtid\")\"\n      trgtid=''\n  END\n  IF success = 0 & (DsName = dest | DsName = \"'\"SYSUID\".\"dest\"'\") THEN DO\n      ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                       \"MEMBER(\"to_member\") ZLUDATA(*NewCopy)\"\n      IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                                        \"MEMBER(\"to_member\") ZLUDATA(*NewCopy)\"\n  END\n  IF MemFunc.processed > 0 THEN RETURN success\n  SELECT\n    WHEN success = 0  THEN CALL SET_MSG fm_member \"copied.\", \"Member\" ,\n                           fm_member \"copied to\" dest, 'NO'\n    WHEN success <= 8 THEN CALL SET_MSG ,\"Couldn't copy\" fm_member\".\",\n                           fm_member \"--\" excuse, \"YES\"\n  OTHERWISE\n      CALL SET_MSG \"No COPY done!?\", excuse\n  END\nRETURN success\n/**********************************************************************\n    Delete member in current %MU member list\n***********************************************************************/\nDELETE_IT:\n  IF PROMPT THEN sure=DELETE_QUERY()\n     ELSE        sure=TRUE\n  IF sure THEN DO\n      ADDRESS \"ISPEXEC\" \"LMINIT DATASET(\"DsName\")\",\n                        \"DATAID(sameid) ENQ(SHRW) VOLUME(\"VOLSER\")\"\n      ADDRESS \"ISPEXEC\" \"LMOPEN DATAID(\"sameid\") OPTION(OUTPUT)\"\n      ADDRESS \"ISPEXEC\" \"LMMDEL DATAID(\"sameid\") MEMBER(\"MbrNme\")\"\n      IF RC = 0 THEN DO\n          MemFunc.processed=MemFunc.processed+1\n          MemFunc.deleted=MemFunc.deleted+1\n      END\n      ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"sameid\")\"\n      ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"sameid\")\"\n      sameid=''\n      ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                         \"MEMBER(\"MbrNme\") ZLUDATA(*Deleted)\"\n      IF RC \u00ac= 0 THEN DO\n         ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                        \"MEMBER(\"MbrNme\") ZLUDATA(*Deleted)\"\n      END\n  END\nRETURN 0\n/**********************************************************************\n            Delete member from current %MU PDS\n***********************************************************************/\nDELETE_QUERY:\n  ZCFDSN=DsName; ZCFMEM=ZLMEMBER\n  ok='0';ADDRESS \"ISPEXEC\" \"ADDPOP\"\n  ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(ISRUDELC)\"\n  display_RC=RC\n  ok='0';ADDRESS \"ISPEXEC\" \"REMPOP\"\n\n  SELECT\n    WHEN display_RC > 0 THEN RETURN FALSE\n    WHEN ZMEMCOV \u00ac= \"\"  THEN PROMPT=FALSE\n  OTHERWISE; NOP ;END\nRETURN TRUE\n/**********************************************************************\n            EDIT member from current %MU PDS\n***********************************************************************/\nEDIT_IT:\n  CALL CHECK_EDIT_RECOVERY\n  ok='*';ADDRESS \"ISPEXEC\" \"EDIT DATAID(\"id\") MEMBER(\"MbrNme\")\",\n                           \"MACRO(\"IMACRO\")\" FORMAT\n  IF RC > 4 THEN DO\n      CALL SET_MSG \"ERROR on\" STRIP(MbrNme)\"!\", \"An ERROR occured while\",\n                   \"EDITing\" STRIP(MbrNme) \"--\" ZERRLM, 'YES'\n      ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*EDError)\"\n    END\n  ELSE DO\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.edited=MemFunc.edited+1\n      IF RC = 0 THEN UserData='*Edited'\n         ELSE        UserData='*Browsed'\n      ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                       \"MEMBER(\"MbrNme\") ZLUDATA(\"UserData\")\"\n      IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                        \"MEMBER(\"MbrNme\") ZLUDATA(\"UserData\")\"\n  END\nRETURN 0\n/**********************************************************************\n    eXclude a member from the current member List\n***********************************************************************/\nEXCLUDE_IT:\n  MemFunc.processed=MemFunc.processed+1\n  MemFunc.xcluded=MemFunc.xcluded+1\n  ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(DELETE)\",\n                           \"MEMBER(\"MbrNme\")\"\nRETURN 0\n/**********************************************************************\n            EXEC the member from current %MU PDS\n***********************************************************************/\nEXEC_IT:\nARG Type .\n  IF LnData||ZCMD \u00ac= \"\" THEN Parm=\"'\"LnData||ZCMD\"' PROMPT\" Type\n     ELSE                    Parm=\"PROMPT\" Type\n  ADDRESS \"TSO\" \"NEWSTACK\"; y=MSG(\"OFF\")\n    ok='*';ADDRESS \"TSO\" \"EXEC '\"STRIP(DsName,\"B\",\"'\")\"(\"MbrNme\")'\" Parm\n  y=MSG(y); ADDRESS \"TSO\" \"DELSTACK\"\n\n  CALL SET_MSG \"EXEC RC=\"RC, \"EXECing of '\"MbrNme\"' completed with RC=\"RC\n  ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                             \"MEMBER(\"MbrNme\") ZLUDATA(*EXECed)\"\n  IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                    \"MEMBER(\"MbrNme\") ZLUDATA(*EXECed)\"\nRETURN TRUE\n/**********************************************************************\n            EXEC the member from current %MU PDS\n***********************************************************************/\nEXEC_VIEW_IT:\nARG Type .\n  IF LnData||ZCMD \u00ac= \"\" THEN Parm=\"'\"LnData||ZCMD\"' PROMPT\" Type\n     ELSE                    Parm=\"PROMPT\" Type\n\n  CALL TSOVIEW \"EXEC '\"STRIP(DsName,\"B\",\"'\")\"(\"MbrNme\")'\" Parm\n\n  CALL SET_MSG \"EXEC View RC=\"RC,,\n       \"EXecute & Viewing of '\"MbrNme\"' completed with RC=\"RC\n  ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                             \"MEMBER(\"MbrNme\") ZLUDATA(*EXECed)\"\n  IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                    \"MEMBER(\"MbrNme\") ZLUDATA(*EXECed)\"\nRETURN TRUE\n/* COPY CHECKER */\n/********************************************************************** /*COPY*/\n        Check for pending EDIT Recovery and process accordingly         /*COPY*/\n***********************************************************************//*COPY*/\nCHECK_EDIT_RECOVERY:                                                    /*COPY*/\n  DO FOREVER                                                            /*COPY*/\n      ok='0 4';ADDRESS \"ISPEXEC\" \"EDREC QUERY\"                          /*COPY*/\n      IF RC = 0  THEN LEAVE                                             /*COPY*/\n      ELSE DO            /* Display standard PDF EDIT Recovery Screen *//*COPY*/\n          ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(ISREDM02)\"          /*COPY*/\n          SELECT                                                        /*COPY*/\n            WHEN ABBREV(ZEDCMD, \"C\") THEN DO                            /*COPY*/\n                ok='0';ADDRESS \"ISPEXEC\" \"EDREC CANCEL\"                 /*COPY*/\n              END                                                       /*COPY*/\n            WHEN ABBREV(ZEDCMD, \"D\") | RC = 8 THEN DO                   /*COPY*/\n                ok='0';ADDRESS \"ISPEXEC\" \"EDREC DEFER\"                  /*COPY*/\n              END                                                       /*COPY*/\n          OTHERWISE                                                     /*COPY*/\n              ok='0 4 20';ADDRESS \"ISPEXEC\" \"EDREC PROCESS\"             /*COPY*/\n              IF RC = 20 THEN DO                                        /*COPY*/\n                  ok='*';ADDRESS \"ISPEXEC\" \"EDREC CANCEL\"               /*COPY*/\n              END                                                       /*COPY*/\n          END                                                           /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n    Process Macro against a member\n***********************************************************************/\nMACRO_IT:\n  IF LEFT(LnCmd, 1) = '&' THEN RepMac=SUBSTR(LnCmd,2)\n     ELSE                      RepMac=RIGHT(LnCmd,8)\n  RepParm=\"\"\n              /* VPUT Macro to be invoked by MACREPM */\n  ok='0'; ADDRESS \"ISPEXEC\" \"VPUT (RepMac RepParm TEST) SHARED\"\n\n  ok='*';ADDRESS \"ISPEXEC\" \"EDIT DATAID(\"id\") MEMBER(\"MbrNme\") MACRO(MACREPM)\"\n  IF RC > 4 THEN DO\n      CALL SET_MSG \"ERROR on\" STRIP(MbrNme)\"!\", \"An ERROR occured while\",\n                   \"EDITing\" STRIP(MbrNme) \"--\" ZERRLM, 'YES'\n      ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*MacErr)\"\n    END\n  ELSE DO\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.edited=MemFunc.macroed+1\n\n      IF RC = 0 THEN UserData='*MEDITED'; ELSE UserData='*MBrowse'\n      ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                       \"MEMBER(\"MbrNme\") ZLUDATA(\"UserData\")\"\n      IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                        \"MEMBER(\"MbrNme\") ZLUDATA(\"UserData\")\"\n  END\nRETURN 0\n/**********************************************************************\n    Move member in current %MU member list\n***********************************************************************/\nMOVE_IT:\n  option=' Moving:'\n  SELECT\n    WHEN LEFT(ALWAYS,1) = 'Y' THEN CALL DO_MOVE\n    WHEN GET_C_M_INFO() THEN CALL DO_MOVE\n  OTHERWISE; NOP; END\nRETURN 0\n/**********************************************************************\n            Move Member Logic\n***********************************************************************/\nDO_MOVE:\n  IF LnData = '' | LEFT(LnData,1) = '*' THEN\n       x=MOVE_MEMBER(MbrNme MbrNme)\n  ELSE x=MOVE_MEMBER(LnData MbrNme)\n  IF x = 0 THEN DO\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.moved=MemFunc.moved+1\n      ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                                 \"MEMBER(\"MbrNme\") ZLUDATA(*Moved)\"\n      IF RC \u00ac= 0 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                        \"MEMBER(\"MbrNme\") ZLUDATA(*Moved)\"\n  END\nRETURN\n/**********************************************************************\n            Move Member to a new PDS\n***********************************************************************/\nMOVE_MEMBER:\nARG to_member fm_member .\n  ok='0 4 8 12'\n    ADDRESS \"ISPEXEC\" \"LMMOVE FROMID(\"id\") FROMMEM(\"fm_member\")\",\n                      \"TODATAID(\"trgtid\") TOMEM(\"to_member\") TRUNC\" REPLACE\n  success=RC; IF RC \u00ac= 0 THEN excuse=ZERRLM\n  IF LEFT(ALWAYS,1) \u00ac= 'Y' THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"trgtid\")\"\n     trgtid=''\n  END\n  IF success = 0 & (DsName = dest | DsName = \"'\"SYSUID\".\"dest\"'\") THEN DO\n     ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                                \"MEMBER(\"to_member\") ZLUDATA(*NewCopy)\"\n     IF RC = 8 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                                      \"MEMBER(\"to_member\") ZLUDATA(*NewCopy)\"\n  END\n  IF MemFunc.processed > 0 THEN RETURN success\n  SELECT\n    WHEN success  = 0 THEN CALL SET_MSG fm_member \"moved.\", \"Member\" ,\n                           fm_member \"moved to\" dest, 'NO'\n    WHEN success <= 8 THEN CALL SET_MSG \"Couldn't move\" fm_member\".\",,\n                           fm_member \"--\" excuse\n  OTHERWISE\n      CALL SET_MSG \"No MOVE done!?\", excuse\n  END\nRETURN success\n/**********************************************************************\n            Next Version, Modified Date/Time, and Userid\n***********************************************************************/\nNEXT_VERSION:\n  IF ZLVERS='' THEN ZLVERS=1\n  ADDRESS \"ISPEXEC\" \"LMMSTATS DATAID(\"id\") MEMBER(\"MbrNme\")\",\n                    \"MODDATE(\"DATE('O')\") MODTIME(\"TIME('N')\")\",\n                    \"VERSION(\"ZLVERS+1\") MODLEVEL(0)\",\n                    \"USER(\"STRIP(LEFT(SYSUID,7))\")\"\n  IF RC = 0 THEN DO\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.nexted=MemFunc.nexted+1\n  END\n  ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*NextVer)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*NextVer)\"\n  END\nRETURN 0\n/**********************************************************************\n    Print member in current %MU member list\n***********************************************************************/\nPRINT_IT:\n  IF LEFT(DsName,1) \u00ac= \"'\" THEN FullDsn=DsName\"(\"STRIP(MbrNme)\")\"\n     ELSE FullDsn=STRIP(DsName,\"T\",\"'\")\"(\"STRIP(MbrNme)\")'\"\n  IF ABBREV(ZLUDATA,\"*\") THEN\n       ADDRESS \"TSO\" \"RPRINT DSN(\"FullDsn\")\"\n  ELSE ADDRESS \"TSO\" \"RPRINT DSN(\"FullDsn\")\" ZLUDATA\n  MemFunc.processed=MemFunc.processed+1\n  MemFunc.printed=MemFunc.printed+1\n  ok='0 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                   \"MEMBER(\"MbrNme\") ZLUDATA(*Printed)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*Printed)\"\n  END\nRETURN 0\n/**********************************************************************\n    Rename member in current %MU member list\n***********************************************************************/\nRENAME_IT:\n  IF LEFT(LnData,1) = '*' | LnData = '' THEN DO\n      CALL SET_MSG \"Rename to what?\", \"No new name given for\" MbrNme,\n                   \"to be renamed to!\", \"YES\"\n      RETURN 1\n  END\n\n  ADDRESS \"ISPEXEC\" \"LMINIT DATASET(\"DsName\") DATAID(sameid) ENQ(SHRW)\",\n                    \"VOLUME(\"VOLSER\")\"\n  ADDRESS \"ISPEXEC\" \"LMOPEN DATAID(\"sameid\") OPTION(OUTPUT)\"\n  ok='0 4 12';ADDRESS \"ISPEXEC\" \"LMMREN DATAID(\"sameid\") MEMBER(\"MbrNme\")\",\n                    \"NEWNAME(\"LnData\")\"\n  rename_RC = RC\n\n  ok='0';ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"sameid\")\"\n  ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"sameid\")\"\n  sameid = ''\n\n  SELECT\n    WHEN rename_RC = 0                   THEN DO\n        MemFunc.processed=MemFunc.processed+1\n        MemFunc.renamed=MemFunc.renamed+1\n        ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                          \"MEMBER(\"MbrNme\") ZLUDATA(*ReNamed)\"\n        ok='0 8'\n          ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD) MEMBER(\"LnData\")\"\n          IF RC = 8 THEN ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                                           \"MEMBER(\"LnData\")\"\n      END\n    WHEN MbrNme = LnData                 THEN DO\n        CALL SET_MSG \"Not a new name!\", \"You can't RENAME a member to the\",\n                     \"same name?!?!?!\", \"YES\"\n      END\n    WHEN WORDPOS(rename_RC, \"4 12\") \u00ac= 0 THEN CALL SET_MSG , ZERRLM, \"YES\"\n  OTHERWISE; NOP; END\nRETURN 0\n/**********************************************************************\n    Sumbit the member in current %MU member list\n***********************************************************************/\nSUBMIT_IT:\n  IF LEFT(DsName,1) \u00ac= \"'\" THEN\n       FullDsn = DsName\"(\"STRIP(MbrNme)\")\"\n  ELSE FullDsn = STRIP(DsName,\"T\",\"'\")\"(\"STRIP(MbrNme)\")'\"\n\n  MsgStat=MSG(\"ON\");   x = OUTTRAP(\"X.\")\n    ADDRESS \"TSO\" \"SUBMIT (\"FullDsn\")\"\n  x = OUTTRAP(\"OFF\"); MsgStat=MSG(MsgStat)\n\n  ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*Submit)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*Submit)\"\n  END\n  MemFunc.submit    =MemFunc.submit+1\n  IF MemFunc.submit_msgs = 0 THEN DO\n      MemFunc.submit_msgs = X.1\n      CALL SET_MSG , X.1, \"NO\"\n    END\n  ELSE MemFunc.submit_msgs = MemFunc.submit_msgs X.1\n  MemFunc.processed=MemFunc.processed+1\nRETURN 0\n/**********************************************************************\n            Touch Version, Modified Date/Time, and Userid\n***********************************************************************/\nTOUCH_IT:\n  IF ABBREV('YES',NODATA)     THEN\n     ADDRESS \"ISPEXEC\" \"LMMSTATS DATAID(\"id\") MEMBER(\"MbrNme\") DELETE\"\n  ELSE DO\n      IF ZLVERS = ''          THEN DO; ZLVERS = 1; ZLMOD = -1; END\n      IF ZLMOD = 99           THEN DO; ZLVERS=ZLVERS+1; ZLMOD=-1; END\n      IF ABBREV(EXTENDED,\"Y\") THEN EXTENDED=\"YES\"; ELSE EXTENDED=\"\"\n      ADDRESS \"ISPEXEC\" \"LMMSTATS DATAID(\"id\") MEMBER(\"MbrNme\")\",\n                        \"MODDATE(\"DATE('O')\") MODTIME(\"TIME('N')\")\",\n                        \"VERSION(\"ZLVERS\") MODLEVEL(\"ZLMOD+1\")\",\n                        \"USER(\"STRIP(LEFT(SYSUID,7))\") EXT(\"EXTENDED\")\"\n  END\n  IF RC = 0 THEN DO\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.touched=MemFunc.touched+1\n  END\n  ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*Touched)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*Touched)\"\n  END\nRETURN 0\n/**********************************************************************\n    View member in current %MU member list\n***********************************************************************/\nVIEW_IT:\n  ok='*';ADDRESS \"ISPEXEC\" \"VIEW DATAID(\"id\") MEMBER(\"MbrNme\")\",\n                           \"MACRO(\"IMACRO\")\" FORMAT\n  SELECT\n    WHEN RC = 12 THEN DO\n        CALL SET_MSG \"ERROR on\" STRIP(MbrNme)\"!\", \"An ERROR occured while\",\n                     \"VIEWing\" STRIP(MbrNme) \"--\" ZERRLM, 'YES'\n        ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                       \"MEMBER(\"MbrNme\") ZLUDATA(*BRError)\"\n      END\n    WHEN RC >= 14 THEN CALL SET_MSG STRIP(MbrNme) \"not found!\",,\n        \"No member\" STRIP(MbrNme) \"found --\" ZERRLM, 'YES'\n  OTHERWISE\n      MemFunc.processed=MemFunc.processed+1\n      MemFunc.viewed=MemFunc.viewed+1\n      ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                         \"MEMBER(\"MbrNme\") ZLUDATA(*Viewed)\"\n      IF RC \u00ac= 0 THEN DO      /* New member to ADD to member list      */\n         ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                        \"MEMBER(\"MbrNme\") ZLUDATA(*Viewed)\"\n      END\n  END\nRETURN 0\n/**********************************************************************\n    Setup to Transmit member(s) to a dataset\n***********************************************************************/\nXMIT_IT:\n  MemFunc.xmit_mems=STRIP(STRIP(MemFunc.xmit_mems MbrNme,\"L\",\"0\"))\n  MemFunc.processed=MemFunc.processed+1\n  MemFunc.xmited=MemFunc.xmited+1\n  ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                               \"MEMBER(\"MbrNme\") ZLUDATA(*Xmited)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*Xmited)\"\n  END\nRETURN 0\n/**********************************************************************\n    Transmit member(s) to a Dataset\n***********************************************************************/\nDO_XMIT_IT:\n  IF ABBREV(DsName,\"'\") THEN OutDsn=STRIP(DsName,\"T\",\"'\")\".XMIT'\"\n     ELSE                    OutDsn=DsName\".XMIT\"\n  ADDRESS \"TSO\" \"NEWSTACK\"\n    ADDRESS \"TSO\" \"XMIT JES2.\"SYSUID \"DSN(\"DsName\") OUTDSN(\"OutDsn\")\",\n                  \"NOLOG NONOTIFY MEMBERS(\"MemFunc.xmit_mems\")\"\n  ADDRESS \"TSO\" \"DELSTACK\"\nRETURN 0\n/**********************************************************************\n    Receive a XMIT Datasets member\n***********************************************************************/\nXMITREC_IT:\n  IF ABBREV(DsName,\"'\") THEN DO\n     RecDsn=STRIP(DsName,\"T\",\"'\"); OutDsn=RecDsn\".\"MbrNme\"'\"\n     RecDsn=RecDsn\"(\"MbrNme\")'\"\n    END\n  ELSE DO\n     RecDsn=DsName\"(\"MbrNme\")\";    OutDsn=DsName\".\"MbrNme\n  END\n  ok='*'\n  x=PROMPT(\"ON\"); y=MSG(\"OFF\"); ADDRESS \"TSO\" \"NEWSTACK\"\n    QUEUE \"DSN(\"OutDsn\") SYSOUT(0)\"\n    QUEUE \"\"\n    ADDRESS \"TSO\" \"RECEIVE INDSN(\"RecDsn\") NONAMES\"\n    IF RC = 12 THEN ADDRESS \"TSO\" \"RECEIVE INDSN(\"RecDsn\") NONAMES\"\n  ADDRESS \"TSO\" \"DELSTACK\"; y=MSG(y); x=PROMPT(x)\n\n  MemFunc.processed=MemFunc.processed+1\n  MemFunc.xmitreced=MemFunc.xmitreced+1\n  ok='0 4 8';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(PUT)\",\n                     \"MEMBER(\"MbrNme\") ZLUDATA(*RECed)\"\n  IF RC \u00ac= 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"LMMDISP DATAID(\"id\") OPTION(ADD)\",\n                    \"MEMBER(\"MbrNme\") ZLUDATA(*RECed)\"\n  END\nRETURN 0\n/**********************************************************************\n    Set ISPF messages appropriately\n***********************************************************************/\nSET_ISPF_MSG:\n  lmsg=''\n  IF MemFunc.submit > 0      THEN lmsg=MemFunc.submit_msgs\n  IF MemFunc.alias > 0       THEN lmsg=MemFunc.alias \"-- member(s) ALIASed\"\n  IF MemFunc.alloced > 0     THEN lmsg=MemFunc.alloced \"-- member(s)    ALLOCed\"\n  IF MemFunc.browsed > 0     THEN lmsg=MemFunc.browsed \"-- member(s)    Browsed\"\n  IF MemFunc.compressed > 0 THEN lmsg=lmsg MemFunc.compressed ,\n                                       \"-- member(s) Compressed\"\n  IF MemFunc.copied > 0      THEN lmsg=lmsg MemFunc.copied,\n                                       \"-- member(s) Copied\"\n  IF MemFunc.deleted > 0     THEN lmsg=lmsg MemFunc.deleted,\n                                       \"-- member(s) Deleted\"\n  IF MemFunc.edited > 0      THEN lmsg=lmsg MemFunc.edited,\n                                       \"-- member(s) Edited\"\n  IF MemFunc.macroed > 0     THEN lmsg=lmsg MemFunc.macroed,\n                                       \"-- member(s) Macroed\"\n  IF MemFunc.moved > 0       THEN lmsg=lmsg MemFunc.moved \"-- member(s) Moved\"\n  IF MemFunc.nexted > 0      THEN  msg=lmsg MemFunc.nexted,\n                                       \"-- member(s) Nexted\"\n  IF MemFunc.printed > 0     THEN lmsg=lmsg MemFunc.printed,\n                                       \"-- member(s) Printed\"\n  IF MemFunc.renamed > 0     THEN lmsg=lmsg MemFunc.renamed,\n                                       \"-- member(s) ReNamed\"\n  IF MemFunc.touched > 0     THEN lmsg=lmsg MemFunc.touched,\n                                       \"-- member(s) Touched\"\n  IF MemFunc.viewed > 0      THEN lmsg=MemFunc.viewed \"-- member(s) Viewed\"\n  IF MemFunc.xcluded > 0     THEN lmsg=lmsg MemFunc.xcluded,\n                                       \"-- member(s) eXcluded\"\n  IF MemFunc.xmited > 0      THEN lmsg=lmsg MemFunc.xmited,\n                                       \"-- member(s) SENT\"\n  IF MemFunc.xmitreced > 0   THEN lmsg=lmsg MemFunc.xmitreced,\n                                       \"-- member(s) RECed\"\n  IF MemFunc.non > 0         THEN lmsg=lmsg MemFunc.non,\n                                       \"-- UN-supported command(s)\"\n  IF MemFunc.submit > 0      THEN\n       CALL SET_MSG , lmsg, 'NO'\n  ELSE CALL SET_MSG MemFunc.processed \"member(s) processed.\", lmsg, 'NO'\nRETURN\n/**********************************************************************\n            Line command which is not currently handled\n***********************************************************************/\nBAD_CMD:\nARG bad_cmd .\n  MemFunc.non=MemFunc.non+1\n  it_rc=0\n  MemFunc.processed=MemFunc.processed+1\n  IF MemFunc.processed = 1 THEN CALL SET_MSG \"UN-supported line option!\",,\n     \"'\"bad_cmd\"' not a supported line option by %MU at this time!\"\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'\n    ADDRESS \"TSO\" \"DELSTACK\"; y=MSG(y); x=PROMPT(x)\n    ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"id\")\"\n    ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"sameid\")\"\n    ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"trgtid\")\"\n    ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"profid\")\"\n    ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"id\")\"\n    ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"sameid\")\"\n    ADDRESS \"ISPEXEC\" \"LMFREE  DATAID(\"trgtid\")\"\nEXIT ExitErr                        /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PFKSET": {"ttr": 61, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x07\\x00\\x03\\x01\\x02\\x03o\\x01\\x17%O\\x100\\x02{\\x02\\xa9\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "03.07", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 635, "newlines": 681, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO is used to maintain and use multiple sets of\n        PFKeys.  It can SAVE PF Key Sets, SWAP PF Key Sets, DELETE\n        saved PF Key sets, and restore your current ISPF APPLID's\n        PF Key Set as it was during the first SWAP.  All changes\n        to your PF Keys are saved at SWAP time.\n\n                           --- EXAMPLE ---\n<TSO> %PFKSET <ACTion(valid PFKSET action)> <NEWCOPY(Y)> ,\n              <PROFILE(PROFILE|SHARED)> Set_Name Set_Desc\n<TSO> <%>PFKSET -H -- To display help for this REXX/ISPF Macro\n\n   **** If you forget to restore your PF Keys before logging off,  ****\n   **** you can restore them next time you use that ISPF APPLID    ****\n\n   Invoking the first time creates the PFKSET01 ISPF Table creating\n        3 PF Key Sets:  Your current ISPF Key set with a SET ID of\n        your current ZAPPLID.  A set of ISPF standard PF Keys with\n        a SET ID of 'STANDARD'.  And a useful set for use when editting\n        with a SET ID of 'ED01'.\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                  ACTion - DELete    = Delete a PF Keys set\n                           DISplay   = Use ISPF Messages to display\n                                       current PF Key Set Name & Desc.\n                           LISt      = List a PF Key set\n                           RECreate  = Delete and Recreate PFKSET01\n                           SAVe      = Save a PF Key set\n                           SWAp      = Swap PF Key sets    ===> default\n                 NEWCOPY - blank     = TBCLOSE REPLACE     ===> default\n                           Y|NEWCOPY = TBCLOSE NEWCOPY\n                 PROFILE - PROFILE = Save to PROFILE Pool  ===> default\n                           SHARED  = Save to SHARED Pool\n                    TEST - Used to control traces\n ------------------------Positional  Arguments-------------------------\n             PFKey_Set   - Name of PFKey Set to perform ACTION on.\n                           If blank, RESTORE PF Key set to current ISPF\n                           profiles PF Key set (if previously saved or\n                           SWAPed)\n             PFKey_Desc  - Description of PFKey Set for SAVEs.\n\n      Files: Uses ISPF TABLE PFKSET01 in the user's ISPF PROFILE dataset\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: PFKSET\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.18\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 6MAR93\n        History: 06FEB17 - v3.05 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v2.07 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v2.06 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v2.05 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 23JUN93 - v2.00 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 26MAY93 - v1.3 Minor fixes to standard functions\n                 20APR93 - v1.2 Logic fixes and DISPLAY support\n                 14APR93 - v1.1 Logic fixes and ENDEVOR base\n                           PF Key Set creation\n                 06MAR93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG InParms\n\nIF InParms = '' THEN CALL INVOKE_AS_MACRO\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF ABBREV('RECREATE',ACTION,3) THEN DO\n    ok='0 8';ADDRESS \"ISPEXEC\" \"TBERASE PFKSET01\"\n    CALL INITIALIZE_PROFILE_TABLE\n  END\nELSE DO\n    ok='0 8';ADDRESS \"ISPEXEC\" \"TBOPEN PFKSET01 WRITE\"\n    IF RC = 8 THEN CALL INITIALIZE_PROFILE_TABLE  /* Table doesn't exist */\n\n    IF ABBREV('LIST',ACTION,3) THEN CALL LIST_PFK_SETS\n    SELECT\n      WHEN ABBREV('DELETE',ACTION,3)  THEN CALL DELETE_PFKEY_SET(PFKey_Set)\n      WHEN ABBREV('DISPLAY',ACTION,3) THEN DO\n         CALL SET_MSG \"PF Key Set is '\"PFKSET03\"'.\",,\n              \"PF Key Set is '\"PFKSET03\"' --\" PFKSET04\".\", \"NO\"\n        END\n      WHEN ABBREV('LIST',ACTION,3) THEN NOP\n      WHEN ABBREV('SAVE',ACTION,3) THEN CALL SAVE_PFKEY_SET\n      WHEN ABBREV('SWAP',ACTION,3) THEN DO\n         IF PFKey_Set \u00ac= PFKSET03  THEN CALL SWAP_PFKEYS\n         ELSE DO\n             CALL SET_MSG  \"Already using '\"PFKSET03\"'!\",,\n                  \"Already using the '\"PFKSET03\"' PF Key Set!\", \"YES\"\n             ExitError=4\n         END\n        END\n    OTHERWISE\n       CALL SET_MSG \"Unknown ACTION()!.\",,\n            \"'\"ACTION\"' is not a valid %PFKSET ACTION value.\", \"YES\"\n       ExitError=8\n    END\nEND\n\nok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE PFKSET01\" NEWCOPY\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                     /* Initialize and process non-positional parms   */\n  ValidParms=\"ACTION(SWAP) NEWCOPY(NO) PROFILE(PROFILE) TEST(O)\"\n  MatchLength=3                    /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\n  PARSE VALUE AnythingElse WITH PFKey_Set PFKey_Desc\n  UPPER PFKey_Set ACTION NEWCOPY\n  PFKey_list  = 'ZPF01  ZPF02  ZPF03  ZPF04  ZPF05  ZPF06  ZPF07  ZPF08',\n                'ZPF09  ZPF10  ZPF11  ZPF12  ZPF13  ZPF14  ZPF15  ZPF16',\n                'ZPF17  ZPF18  ZPF19  ZPF20  ZPF21  ZPF22  ZPF23  ZPF24'\n  PFKeyL_list = 'ZPFL01 ZPFL02 ZPFL03 ZPFL04 ZPFL05 ZPFL06 ZPFL07 ZPFL08',\n                'ZPFL09 ZPFL10 ZPFL11 ZPFL12 ZPFL13 ZPFL14 ZPFL15 ZPFL16',\n                'ZPFL17 ZPFL18 ZPFL19 ZPFL20 ZPFL21 ZPFL22 ZPFL23 ZPFL24'\n\n  IF PROFILE \u00ac= 'PROFILE' THEN PROFILE = 'SHARED'\n  IF LEFT(NEWCOPY,1) \u00ac= 'Y' & NEWCOPY \u00ac= 'NEWCOPY' THEN NEWCOPY = ''\n     ELSE                                               NEWCOPY = 'NEWCOPY'\n  ADDRESS \"ISPEXEC\" \"VGET (PFKSET03 PFKSET04) ASIS\"\n  ADDRESS \"ISPEXEC\" \"VGET (ZAPPLID)\"\n\n  IF PFKSET03  = '' THEN DO\n     PFKSET03=ZAPPLID; PFKSET04=\"PF Keys for the\" ZAPPLID \"ISPF Profile\"\n  END\n  SELECT\n    WHEN PFKey_Set = '' & ACTION = 'SAVE'   THEN DO\n       PFKey_Set=PFKSET03; PFKey_Desc=PFKSET04\n      END\n    WHEN PFKey_Set = ''                     THEN DO\n       PFKey_Set=ZAPPLID; PFKey_Desc=\"PF Keys for\" ZAPPLID \"ISPF Profile\"\n      END\n    WHEN PFKey_Desc \u00ac= '' & ACTION = 'SWAP' THEN ACTION='SAVE'\n  OTHERWISE; NOP; END\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n  ADDRESS \"ISREDIT\" \"MACRO (InParms) NOPROCESS \"\n  IF RC \u00ac= 0 THEN RETURN                          /* May be TSO call */\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Create and Initialize ISPF TABLE PFKSET01\n***********************************************************************/\nINITIALIZE_PROFILE_TABLE:\n  ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE PFKSET01 WRITE KEYS(PFKSET01)\",\n                           \"NAMES(PFKSET02 \"PFKey_List PFKeyL_List\")\"\n  PFKSET01=ZAPPLID; PFKSET02=\"PF Keys for the\" ZAPPLID \"ISPF Profile\"\n  ok='0';ADDRESS \"ISPEXEC\" \"TBADD PFKSET01\"\n\n  CALL STANDARD_PFKEYS\n  CALL ED01_PFKEYS\n\n  PFKSET01=PFKSET03\n  ok='0';ADDRESS \"ISPEXEC\" \"TBSAVE PFKSET01\"\n  ok='0';ADDRESS \"ISPEXEC\" \"TBSCAN PFKSET01 ARGLIST(PFKSET01) PREVIOUS\"\n\n  CALL SET_MSG 'PF Key Table Created.',,\n       'PF Key Table, PFKSET01, created in your ISPF.PROFILE DSN', \"NO\"\n\n  PFKSET03=ZAPPLID              /* Back to default PROFILE PF Key Set */\n  PFKSET04=\"PF Keys for the\" ZAPPLID \"ISPF Profile\"\n  ok='0 8';ADDRESS \"ISPEXEC\" \"VPUT (PFKSET03 PFKSET04)\" PROFILE\n\nIF ACTION = 'SAVE' & PFKey_Set = ZAPPLID THEN EXIT\n   ELSE RETURN\n/**********************************************************************\n            ISPF Standard PF Key Definitions\n***********************************************************************/\nSTANDARD_PFKEYS:\n  PFKSET01='STANDARD'; PFKSET02=\"Modified version of Standard ISPF PF Keys\"\n\n  ZPF01='HELP'     ; ZPFL01='HELP'\n  ZPF02='SPLIT'    ; ZPFL02='SPLIT'\n  ZPF03='END'      ; ZPFL03='END'\n  ZPF04='RETURN'   ; ZPFL04='RETURN'\n  ZPF05='RFIND'    ; ZPFL05='RFIND'\n  ZPF06='RCHANGE'  ; ZPFL06='RCHANGE'\n  ZPF07='UP'       ; ZPFL07='UP'\n  ZPF08='DOWN'     ; ZPFL08='DOWN'\n  ZPF09='SWAP NEXT'; ZPFL09='SWAPNext'\n  ZPF10='LEFT'     ; ZPFL10='LEFT'\n  ZPF11='RIGHT'    ; ZPFL11='RIGHT'\n  ZPF12='RETRIEVE '; ZPFL12='RETRIEVE'\n  ZPF13='TSOVIEW'  ; ZPFL13='TSO View'\n  ZPF14='SPLIT'    ; ZPFL14='SPLIT'\n  ZPF15='END'      ; ZPFL15='END'\n  ZPF16='=X'       ; ZPFL16='Exit'\n  ZPF17='RFIND'    ; ZPFL17='RE-FIND'\n  ZPF18='%PFKSET'  ; ZPFL18='Set PF Keys'\n  ZPF19='UP M'     ; ZPFL19='MAX UP'\n  ZPF20='DOWN M'   ; ZPFL20='MAX DOWN'\n  ZPF21='SWAP LIST'; ZPFL21='SWAPList'\n  ZPF22='LEFT M'   ; ZPFL22='MAX LEFT'\n  ZPF23='RIGHT M'  ; ZPFL23='MAX RIGHT'\n  ZPF24='MUCMD'    ; ZPFL24='MBR Utility'\n\n  ok='0';ADDRESS \"ISPEXEC\" \"TBADD PFKSET01\"\nRETURN\n/**********************************************************************\n            Sample ISPF EDIT PF Key Set number 01\n***********************************************************************/\nED01_PFKEYS:\n  PFKSET01='ED01'; PFKSET02=\"Useful sample EDit PF Key Set\"\n\n  ZPF01='HELP'      ; ZPFL01='HELP'\n  ZPF02='SPLIT'     ; ZPFL02='SPLIT'\n  ZPF03='END'       ; ZPFL03='END'\n  ZPF04='RETURN'    ; ZPFL04='RETURN'\n  ZPF05='RFIND'     ; ZPFL05='RFIND'\n  ZPF06='RCHANGE'   ; ZPFL06='RCHANGE'\n  ZPF07='UP'        ; ZPFL07='UP'\n  ZPF08='DOWN'      ; ZPFL08='DOWN'\n  ZPF09='SWAP NEXT' ; ZPFL09='SWAPNext'\n  ZPF10='LEFT'      ; ZPFL10='LEFT'\n  ZPF11='RIGHT'     ; ZPFL11='RIGHT'\n  ZPF12='RETRIEVE'  ; ZPFL12='RETRIEVE'\n  ZPF13='TSOVIEW'   ; ZPFL13='TSO CMD'\n  ZPF14='%VW'       ; ZPFL14='View Parm'\n  ZPF15='%HYPER$'   ; ZPFL15='Hyper Cache'\n  ZPF16='=3.4'      ; ZPFL16='DSN List'\n  ZPF17='JC'        ; ZPFL17='JOB CARD'\n  ZPF18='%PFKSET'   ; ZPFL18='Rst PFKs'\n  ZPF19='UP M'      ; ZPFL19='MAX UP'\n  ZPF20='DOWN M'    ; ZPFL20='MAX DOWN'\n  ZPF21='SWAP LIST' ; ZPFL21='SWAPList'\n  ZPF22='%RPRINT'   ; ZPFL22='R Print'\n  ZPF23='%BR'       ; ZPFL23='Browse DSN'\n  ZPF24='%ED'       ; ZPFL24='Edit DSN'\n\n  ok='0';ADDRESS \"ISPEXEC\" \"TBADD PFKSET01\"\nRETURN\n/**********************************************************************\n            Display List of PF Key Sets\n***********************************************************************/\nLIST_PFK_SETS:\n  PFKSET01=PFKSET03; PFKSET02=PFKSET04        /* Save current PF Keys */\n  ok='0 8';ADDRESS \"ISPEXEC\" \"TBMOD PFKSET01\"\n\n  ok='0';ZTDMARK=\"                      ----> LAST PF KEY SET <----\"\n    ADDRESS \"ISPEXEC\" \"TBSORT PFKSET01 FIELDS(PFKSET01,C,A)\"\n    ADDRESS \"ISPEXEC\" \"TBTOP PFKSET01\"\n  ok='0 4 8';crp=1                    /* Handleable RC's for TBDISPL  */\n  DO UNTIL RC \u00ac= 0\n     ADDRESS \"ISPEXEC\" \"TBDISPL PFKSET01 PANEL(PFKSET01) AUTOSEL(NO)\",\n             \"CSRROW(\"crp\") CURSOR(selopt)\"\n  END\n                                      /* START actual processing here */\n  DO ZTDSELS\n     CALL PROCESS_ROW\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL PFKSET01\"\n  END\n\n  ok='0';PFKSET01=PFKSET03; PFKSET02=PFKSET04  /* Get current PF Keys */\n    ADDRESS \"ISPEXEC\" \"TBTOP PFKSET01\"\n    ADDRESS \"ISPEXEC\" \"TBSCAN PFKSET01 ARGLIST(PFKSET01)\"\nRETURN\n/**********************************************************************\n            Process each selected row\n***********************************************************************/\nPROCESS_ROW:\n  SELECT\n    WHEN (selopt = 'D') & (PFKSET01 \u00ac= PFKSET03) THEN DO\n        ok='0';ADDRESS \"ISPEXEC\" \"TBDELETE PFKSET01\"\n        NEWCOPY = 'NEWCOPY'                   /* Retrieve Freed Space */\n        CALL SET_MSG 'PF Key Set Deleted.',,\n             'PF Key Table set' PFKSET01 'has been deleted.', \"NO\"\n      END\n    WHEN (selopt = 'D') & (PFKSET01 = PFKSET03) THEN DO\n        CALL SET_MSG \"Can't DELETE\" PFKSET03\"!\",,\n             \"'\"PFKSET03\"' is the current PF Key Set, you must be in\",\n             \"another PF Key Set to DELETE it!\", \"NO\"\n      END\n    WHEN WORDPOS(selopt, '/ S') > 0 THEN DO\n        PFKey_Set=PFKSET01; PFKey_Desc=PFKSET02; ACTION='SWAP'\n      END\n  OTHERWISE; NOP; END\nRETURN\n/**********************************************************************\n            Delete a set of PF Keys\n***********************************************************************/\nDELETE_PFKEY_SET:\nARG PFKSET01 .\n  ok='0';ADDRESS \"ISPEXEC\" \"TBTOP PFKSET01\"\n  ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN PFKSET01 ARGLIST(PFKSET01)\"\n  IF RC = 0 THEN DO\n     ok='0';ADDRESS \"ISPEXEC\" \"TBDELETE PFKSET01\"\n     NEWCOPY = 'NEWCOPY'                     /* Retrieve Freed Space */\n  END\n\n  CALL SET_MSG 'PF Key Set Deleted.',,\n       'PF Key Table set' PFKSET01 'has been deleted.', \"NO\"\nRETURN\n/**********************************************************************\n            Swap current keys for PFKey_Set\n***********************************************************************/\nSWAP_PFKEYS:\n  PFKSET01=PFKSET03; PFKSET02=PFKSET04\n  ok='0 8';ADDRESS \"ISPEXEC\" \"TBMOD PFKSET01\"\n\n  PFKSET01=PFKey_Set\n  ok='0';ADDRESS \"ISPEXEC\" \"TBTOP PFKSET01\"\n  ok='0 8';ADDRESS \"ISPEXEC\" \"TBSCAN PFKSET01 ARGLIST(PFKSET01)\"\n\n  IF RC = 0 THEN DO           /* We have successfully swapped PF Keys */\n     CALL SET_MSG \"PF Keys Swapped.\",,\n         \"PF Keys swapped from PF Key Set '\"PFKSET03\"' to '\"PFKSET01\"'\",\n         \"--\" PFKSET02\".\", \"NO\"\n\n     IF PFKSET01 = ZAPPLID THEN DO; PFKSET03=''; PFKSET04='';             END\n        ELSE                    DO; PFKSET03=PFKSET01; PFKSET04=PFKSET02; END\n     ok='0 8'\n       ADDRESS \"ISPEXEC\" \"VPUT (PFKSET03 PFKSET04)\" PROFILE\n       ADDRESS \"ISPEXEC\" \"VPUT (\"PFKey_List\" )\" PROFILE\n       ADDRESS \"ISPEXEC\" \"VPUT (\"PFKeyL_List\")\" PROFILE\n    END\n  ELSE DO                     /* PFKey_Set doesn't exist?!?           */\n     CALL SET_MSG 'PF Keys Not Swapped!',,\n          \"No PF Key Set\" PFKey_Set \"exists, PF Key Set remains\" PFKSET03, \"NO\"\n  END\nRETURN\n/**********************************************************************\n            Save the current PF Key set as PFKey_Set\n***********************************************************************/\nSAVE_PFKEY_SET:\n  PFKSET01=PFKey_Set; PFKSET02=PFKey_Desc\n  ok='0';  ADDRESS \"ISPEXEC\" \"TBTOP PFKSET01\"\n  ok='0 8';ADDRESS \"ISPEXEC\" \"TBMOD PFKSET01\"\n\n  IF RC = 0 THEN                      /* PFKey_Set already existed    */\n       CALL SET_MSG 'PF Keys Set Updated.',,\n           \"PF Keys set\" PFKey_Set \"--\" PFKey_Desc\"; has been updated.\",\"NO\"\n  ELSE CALL SET_MSG 'PF Keys Set Created.',,\n           \"PF Keys set\" PFKey_Set \"--\" PFKey_Desc\"; has been created.\",\"NO\"\n\n  IF PFKey_Set = ZAPPLID THEN DO; PFKSET03=''; PFKSET04='';                END\n     ELSE                     DO; PFKSET03=PFKey_Set; PFKSET04=PFKey_Desc; END\n  ok='0 8';ADDRESS \"ISPEXEC\" \"VPUT (PFKSET03 PFKSET04)\" PROFILE\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ADDRESS \"ISPEXEC\" \"TBCLOSE PFKSET01\" NEWCOPY\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PK": {"ttr": 139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x03\\x003\\x01\\x02\\x03o\\x01\\x17'\\x1f\\x13\\x13\\x02\\x87\\x02/\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.03", "flags": 0, "createdate": "2002-02-05T00:00:00", "modifydate": "2017-09-28T13:13:33", "lines": 647, "newlines": 559, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO expands small control parms as ISPF EDIT NOTEs and\n        throws you into browse mode for larger ones.  It will also\n        handle symbolic substitution in JCL PROC DSNs.  It does this\n        by bringing up an editiable ISPF panel with the symbolics and\n        thier default values.\n\n                           --- EXAMPLE ---\n<%>PK <ADVance(Y|N> <MAXlines(###)> <TESt(valid REXX trace option)>\n<%>PK -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                 ADVANCE - Advance to next line, Y or N    default: Y\n                MAXLINES - Maximum number of lines to expand\n                           after this BROWSE dataset       default: 100\n                    TEST - Used to control traces          default: O\n\n      Files: This macro reads control card members passed as dsname.\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: PK\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 3.00\n                 FERGUSON AL (HUL2353) from v1.16\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 03MAR93\n        History: 28SEP17 - v4.00 - More Point-N-Shoot Fixes.\n                 14MAR17 - v3.38 - Rework Current Line Logic to use\n                           ISREDIT functions, as this MUST be called as\n                           an ISPF Edit Macro, so full screen\n                           Point-N-Shoot Logic is overkill.\n                           Added logic to handle Blank Line at Cursor.\n                 01MAR17 - v3.35 - Use Common Point-N-Shoot Routines\n                 06FEB17 - v3.10 - Pick up updated version of the\n                           ERRINFO Common Code routine.\n                 01FEB17 - v3.07 - Mass update to pickup Updated Error\n                           Handling Fixes.\n                 31JAN17 - v3.06 - Update all REXXes with latest common\n                           routines via %CCMASS\n                 23NOV16 - v3.05 - Refactoring & Common Routine Refresh\n                 30JUN11 - v3.00 - Add support for USS Paths & Files\n                 19MAR99 - v2.31 - Change use of BROWSE on DSNs to VIEW,\n                           to allow use of ISPF EDIT Commands and Macros.\n                 18MAY95 - v2.21 - Update all REXXes with latest commom\n                           routines via %CCMASS\n                 23AUG93 - v2.15 - Used SET_MSG common routine and\n                           improved PROC symbolic default parsing.\n                 23JUN93 - v2.00 - Update all REXXes with latest commom\n                           routines via %CCMASS\n                 26MAY93 - v1.30 - Minor fixes to standard functions\n                 30MAR93 - v1.20 - Support for JCL PROC symbolics\n                 29MAR93 - v1.10 - Added ADVANCE NPPARM support\n                  3MAR93 - v1.00\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG DsName InParms\n\nCALL INITIALIZE_THIS_REXX\nIF DsName = ''                 THEN CALL INVOKE_AS_MACRO\nIF DsName = ''                 THEN EXIT\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF member = '' THEN ADDRESS \"ISPEXEC\" \"VIEW\" ViewType\nELSE DO\n   ok='0 8';ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id)\" ViewType \"ENQ(SHR)\"\n   IF RC = 0 THEN DO\n      ADDRESS \"ISPEXEC\" \"LMOPEN DATAID(\"id\")\"\n      ADDRESS \"ISPEXEC\" \"LMMFIND DATAID(\"id\") MEMBER(\"member\") STATS(YES)\"\n      SELECT\n        WHEN ZLCNORC = 0         THEN CALL SET_MSG ,member \"is Empty!\",\"YES\"\n        WHEN ZLCNORC <= MAXLINES &,\n             ISMacro             THEN CALL INSERT_AS_NOTE\n      OTHERWISE;                      ADDRESS \"ISPEXEC\" \"VIEW\" ViewType; END\n      ok='0';ADDRESS \"ISPEXEC\" \"LMCLOSE DATAID(\"id\")\"\n             ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"id\")\"\n     END\n   ELSE CALL SET_MSG \"Un-PEEKable DSN!\", DsName \"--\" ZERRLM, \"YES\"\nEND\n\nok='0 12'\nIF ABBREV(ADVANCE,\"Y\") THEN ADDRESS \"ISREDIT\" \"CURSOR =\"RowPos+1 CurPos\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n                                    /* Initialize NonPositional parms */\n  ValidParms=\"ADVANCE(Y) MAXLINES(100) TEST(O)\"\n  MatchLength=3                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID=USERID()\n  ExitErr=0; ok='0'\n\n  ISMacro=FALSE\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/**********************************************************************\n     Use Point-n-Shoot to Read dataset from screen\n**********************************************************************/\nDO_POINT_N_SHOOT:\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END\n  SELECT\n    WHEN i                > 0 THEN word=WORD(ln,i-1)\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn\n  OTHERWISE;                       RETURN \"\"; END\n  SELECT\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word\n    WHEN POS(\"='\",word)   > 0 THEN\n       PARSE VALUE word    WITH  \"='\" word . \"'\"\n    WHEN POS(\"DSN=\",word) > 0 THEN\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"\n    WHEN POS(\"=\",word)    > 0 THEN\n       PARSE VALUE word    WITH   \"=\" word . \",\"\n    WHEN POS(\"''\",word)   > 0 THEN\n       PARSE VALUE word    WITH  \"''\" word . \"'\"\n    WHEN ABBREV(word,'\"//')   THEN\n       PARSE VALUE word    WITH \"//\" word . '\"'\n    WHEN POS(\"(\",word)    > 0 THEN\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"\n  OTHERWISE; NOP; END\n  IF INDEX(word,\"&\") > 0      THEN word=HANDLE_SYMBOLICS(word)\n  SELECT\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word\n    WHEN ABBREV(word,'\"//')                    THEN\n         DsNme=STRIP(SUBSTR(word,4),,'\"')\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"\n    WHEN PdsDsn                        \u00ac= ''   THEN DO\n         DsNme=\"'\"PdsDsn\"'\"; filter=word\n      END\n  OTHERWISE; DsNme = \"\"; END\n  IF INDEX(DsNme,\"/\") > 0 THEN ViewType=\"FILE(PdsDsn)\"\n     ELSE                      ViewType=\"DATASET(\"PdsDsn\")\"\nRETURN DsNme\n/* COPY PNTNSHOT */\n/********************************************************************** /*COPY*/\n             If no arguments, was it envoked as a MACRO                 /*COPY*/\n**********************************************************************/ /*COPY*/\nINVOKE_AS_MACRO:                                                        /*COPY*/\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"                                        /*COPY*/\n  IF RC \u00ac= 0 THEN RETURN                                                /*COPY*/\n  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */ /*COPY*/\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"                  /*COPY*/\n  IF RC = 0 THEN DO                                                     /*COPY*/\n     IsMacro=TRUE                                                       /*COPY*/\n     ADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"                             /*COPY*/\n     ADDRESS \"ISREDIT\" \"(RowPos,CurPos) = CURSOR\"                       /*COPY*/\n     IF DsName = \"\" & RowPos = 1 & CurPos = 0 THEN DsName=\"'\"PdsDsn\"'\"  /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO; IsMacro=FALSE; PdsDsn=\"\"; END                                /*COPY*/\n  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/\n                                                                        /*COPY*/\n  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/\n  IF ABBREV(PDS,\"'\")           THEN PDS=STRIP(PDS,\"T\",\"'\")\"'\"           /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN DsName = \"\"           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/\n    WHEN ABBREV(DsName,\"DD:\")  THEN NOP                                 /*COPY*/\n    WHEN ABBREV(DsName,\"dd:\")  THEN NOP                                 /*COPY*/\n    WHEN POS(\"/\",DsName) > 0   THEN NOP                                 /*COPY*/\n    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"          THEN DsName=\"'\"PdsDsn\"(\"DsName\")'\"       /*COPY*/\n  OTHERWISE;                        NOP; END                            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_POINT_N_SHOOT:                                                       /*COPY*/\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"                  /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn                        /*COPY*/\n  OTHERWISE;                       RETURN \"\"; END                       /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/\n    WHEN POS(\"='\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"='\" word . \"'\"                        /*COPY*/\n    WHEN POS(\"DSN=\",word) > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"                     /*COPY*/\n    WHEN POS(\"=\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH   \"=\" word . \",\"                        /*COPY*/\n    WHEN POS(\"''\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"''\" word . \"'\"                        /*COPY*/\n    WHEN ABBREV(word,'\"//')   THEN                                      /*COPY*/\n       PARSE VALUE word    WITH \"//\" word . '\"'                         /*COPY*/\n    WHEN POS(\"(\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"                        /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word          /*COPY*/\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word          /*COPY*/\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN       /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"                                     /*COPY*/\n    WHEN PdsDsn                        \u00ac= ''   THEN DO                  /*COPY*/\n         DsNme=\"'\"PdsDsn\"'\"; filter=word                                /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; DsNme = \"\"; END                                            /*COPY*/\nRETURN DsNme                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_CURRENT_LINE:                                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"        /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC = 0 & \u00ac(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/\n    WHEN IsMacro                                THEN DO                 /*COPY*/\n       ADDRESS \"ISREDIT\" \"(Line) = LINE\" RowPos                         /*COPY*/\n       RETURN Line                                                      /*COPY*/\n      END                                                               /*COPY*/\n    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/\n         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/\n       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/\n       IF ABBREV(LstLn,\"***\")                   THEN Wdth=ZSCREENW+8    /*COPY*/\n          ELSE                                       Wdth=ZSCREENW      /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/\n       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/\n     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/\n  END                                                                   /*COPY*/\n  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth),\" \",\",\")         /*COPY*/\n/**********************************************************************\n        Build real DSN from a symbolic DSN in a JCL PROC\n***********************************************************************/\nHANDLE_SYMBOLICS: PROCEDURE EXPOSE ln RowPos CurPos\nPARSE ARG word .\n  WordLeft=word; qualifier.=''; qualifier.0=0\n  j=0; sym.=''; sym.0=0; val.=''; val.0=0\n\n  CALL BREAK_OUT_SYMBOLICS\n  IF sym.0 = 1 THEN CALL CHECK_FOR_TEMP_DATASETS\n                              /* Move data to ISPF screen variables */\n  DO j=1 TO 9; z=VALUE('sym'j,sym.j); z=VALUE('val'j,val.j); END\n  DO j=1 TO sym.0 UNTIL val.j=''; END\n  IF val.j = '' & j <= sym.0 THEN set_cursor='val'||j\n     ELSE set_cursor='val1'\n\n  ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(PEEK01) CURSOR(\"set_cursor\")\"\n  IF RC = 8 THEN EXIT\n                            /* Move back from ISPF screen variables */\n  DO j=1 TO 9; val.j=VALUE('val'j); END\n\n  NewWord=qualifier.1\n  DO j=2 TO qualifier.0\n     k=j-1\n     IF INDEX(qualifier.j, sym.k'.') > 0 THEN\n          INTERPRET \"PARSE VALUE qualifier.j WITH . '\"sym.k\".' los .\"\n     ELSE INTERPRET \"PARSE VALUE qualifier.j WITH . '\"sym.k\"' los .\"\n     NewWord=NewWord || val.k || los\n  END\nRETURN STRIP(NewWord)\n/**********************************************************************\n        Break out symbolics from DSNs in JCL\n***********************************************************************/\nBREAK_OUT_SYMBOLICS:\n  DO index=1 UNTIL WordLeft = ''\n     IF INDEX(WordLeft, '&&') > 0 & ,\n       (INDEX(WordLeft, '&&') <= INDEX(WordLeft, '&')) THEN\n          PARSE VALUE WordLeft WITH qualifier.index '&&' WordLeft\n     ELSE PARSE VALUE WordLeft WITH qualifier.index '&'  WordLeft\n  END\n  qualifier.0=index\n  DO index=2 TO qualifier.0\n     j=j+1\n     PARSE VALUE qualifier.index WITH sym.j '.' .\n     IF INDEX(sym.j, '(') > 0 THEN PARSE VALUE sym.j WITH sym.j '(' .\n     IF INDEX(sym.j, ')') > 0 THEN PARSE VALUE sym.j WITH sym.j ')' .\n     val.j=FIND_JCL_SYMBOL_VALUE(sym.j)\n  END\n  sym.0=j\nRETURN\n/**********************************************************************\n     Search single symbolics DD statements for DISP clauses\n***********************************************************************/\nCHECK_FOR_TEMP_DATASETS:\n  IF INDEX(ln, 'DISP') > 0           THEN disp=IS_IT_A_TEMP(ln)\n  ELSE DO\n     disp=''\n     DO index=1 UNTIL \u00ac(ABBREV(newline,'// ')) | disp \u00ac= '' |,\n                      POS(' DD ',newline) > 0\n        ADDRESS \"ISREDIT\" \"(newline) = LINE\" RowPos + index\n        IF POS('DISP',newline) > 0 & ABBREV(newline,'// ') THEN\n           disp=IS_IT_A_TEMP(newline)\n     END\n     newline=ln\n     DO index=1 WHILE INDEX(newline, ' DD ') = 0 | disp = ''\n        ADDRESS \"ISREDIT\" \"(newline) = LINE\" RowPos - index\n        IF INDEX(newline,'DISP') > 0 THEN disp=IS_IT_A_TEMP(newline)\n     END\n  END\n  IF disp \u00ac= 'TEMP' THEN RETURN /* Not a temp file, continue processing */\n\n  CALL SET_MSG \"JCL TEMP DSN!\", sym.1 \"is a TEMP DSN, so un-PEEKable\",\"YES\"\nEXIT\n/**********************************************************************\n        Are we dealing with a single symbolic or a temp dataset?\n***********************************************************************/\nIS_IT_A_TEMP: PROCEDURE\nARG dd_line\n  SELECT\n    WHEN INDEX(dd_line,'PASS')      > 0 THEN RETURN 'TEMP'\n    WHEN INDEX(dd_line,'OLD,DELETE')> 0 THEN RETURN 'TEMP'\n    WHEN INDEX(dd_line,'(,DELETE)') > 0 THEN RETURN 'TEMP'\n  OTHERWISE; NOP; END\nRETURN 'SYMBOLIC'\n/**********************************************************************\n        Break out PROC Related Symbolics\n***********************************************************************/\nFIND_JCL_SYMBOL_VALUE:\nPARSE ARG symbol .\n  SrchString=symbol\"=\"; RegEx=\"R'\u00dd ,\u00a8\"SrchString\"'\"\n  ADDRESS \"ISREDIT\" \"(var1,var2) = CURSOR\"\n  ADDRESS \"ISREDIT\" \"FIND .ZCSR .ZFIRST\" RegEx \"PREV 4 71\"\n  IF RC \u00ac= 0 THEN RETURN \"\"\n  ADDRESS \"ISREDIT\" \"(SymLine) = LINE .ZCSR\"\n  PARSE VALUE SymLine WITH . (SrchString) val\n  SELECT\n    WHEN ABBREV(val,\"'\") THEN PARSE VALUE val WITH \"'\" val \"'\" .\n    WHEN INDEX(val,\",\") > 0                  &,\n         INDEX(val,\",\") < INDEX(val,\"=\") THEN\n       PARSE VALUE val WITH val \",\" .\n  OTHERWISE; NOP; END\nRETURN val\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC \u00ac= 0                   THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/\n        ELSE                           ZERRALRM='NO'                    /*COPY*/\n     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                     /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n        Insert Control member into current datset as NOTELINEs\n***********************************************************************/\nINSERT_AS_NOTE:\n  IF ABBREV(DsName,\"/\") THEN AllocParm = \"PATH(\"DsName\") KEEP REUSE\"\n     ELSE                    AllocParm = \"DSN(\"DsName\") SHR REUSE\"\n  ok='0';\n    ADDRESS \"TSO\" \"ALLOC DD(control)\" AllocParm\n    ADDRESS \"MVS\" \"EXECIO * DISKR control (STEM CntlRecs. FINIS)\"\n    ADDRESS \"TSO\" \"FREE DD(control)\"\n    ADDRESS \"ISREDIT\" \"CURSOR =\" var1 var2\n  ok='0 4'\n  IF CntlRecs.0 = 0 THEN CALL SET_MSG , member \"is Empty!\",\"YES\"\n  ELSE DO i = CntlRecs.0 TO 1 BY -1\n     ADDRESS \"ISREDIT\" \"LINE_AFTER .ZCSR = NOTELINE\" ,\n             '\"'TRANSLATE(STRIP(CntlRecs.i,\"T\"),\"`\",'\"')'\"'\n  END\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"id\")\"\n  ADDRESS \"TSO\" \"FREE DD(control)\"\nEXIT ExitErr                        /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFACEE": {"ttr": 105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x017\\x00\\x03\\x01\\x00\\x13\\x0f\\x01\\x17%O\\x100\\x01B\\x01M\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.55", "flags": 0, "createdate": "2000-05-09T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 322, "newlines": 333, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX checks for a VALID ACEE. It returns TRUE if there is an\n      ACEE and FALSE if there is no ACEE.\n\nNOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\n                           --- EXAMPLE ---\nTSO <%>RACFACEE <TEST(TraceOption)>\nTSO <%>RACFACEE -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: RACFACEE\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.34\n                 AL Hulsebosch (HUL2353)\n         Writen: 10APR01\n        History: 06FEB17 - v1.36 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.35 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.34 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 10APR01 - v1.0\n***************************** Rexx ***********************************/\nPARSE ARG InParms                            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n\nRETURN ABBREV(RACVAR('ACEESTAT'), 'DEFINED')\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4                   /* NP-Parms match on first # chars  */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFGRPS": {"ttr": 109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x03\\x01\\x00\\x13\\x0f\\x01\\x17%O\\x100\\x01[\\x01M\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2000-05-09T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 347, "newlines": 333, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX Indicates whether the user is a member of a GROUP or RETURNs\n      all groups to which a user is CONNECTed.  If a GROUP is specified,\n      it RETURNs TRUE when the USER is CONNECTed to group and RETURNs\n      FALSE if user is not.  If no GROUP is not specified, it RETURNs a\n      list of all GROUPs the USER is CONNECTed to separated by spaces.\n      This works under both RACF and CA-TopSecret.\n\nNOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\n                           --- EXAMPLE ---\nTSO <%>RACFGRPS checkgroup <TEST(trace_option)>\nTSO <%>RACFGRPS -H -- To display help for this REXX\n\n  Arguments: checkgroup  - RACF Group to check\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: RACFGRPS\n         Author: AL Hulsebosch (HUL2353)\n         Writen: 09MAY00\n        History: 09MAY00 - Version 1.0 - This is a reformat of a sample\n                           REXX (RACFGRPS) obtained from the CBT Tapes.\n***************************** Rexx ***********************************/\nPARSE ARG checkgroup InParms                 /* Place arguments here */\n\nIF WORDPOS(checkgroup,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL GET_GROUPS\n\nPARSE SOURCE . calltype .\nSELECT\n  WHEN calltype = 'COMMAND'             THEN\n    CALL SET_MSG ,\"You are CONNECTed to the following GROUPs: \" AllGrps,\"NO\"\n  WHEN checkgroup = \"\"                  THEN RETURN AllGrps\n  WHEN WORDPOS(checkgroup, AllGrps) > 0 THEN RETURN TRUE\nOTHERWISE;                                   RETURN FALSE; END\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4                   /* NP-Parms match on first # chars  */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Go to the ADDRESS Spaces ACEE and Get the list of GROUPs\n***********************************************************************/\nGET_GROUPS:\n  ASXB_ptr      = STORAGE(224,4)\n  ASXB          = STORAGE(D2X(C2D(ASXB_ptr) + 108),4)\n  ACEE          = STORAGE(D2X(C2D(ASXB) + 200),4)\n  ACEE_cgrp     = STORAGE(D2X(C2D(ACEE) + 116),4)\n  ACEE_grpl_len = C2D(STORAGE(D2X(C2D(ACEE_cgrp) + 5),3))\n  ACEE_grpl     = STORAGE(D2X(C2D(ACEE_cgrp) + 32),ACEE_grpl_len)\n\n  AllGrps = \"\"\n  DO i=1 TO C2D(STORAGE(D2X(C2D(ACEE_cgrp)+8),2))\n     PARSE VALUE ACEE_grpl WITH 1 group 9 . 25 ACEE_grpl\n     AllGrps=group AllGrps\n  END\nRETURN\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFSTCS": {"ttr": 103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x03\\x01\\x13\\x01_\\x01\\x17%O\\x100\\x01d\\x01m\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2013-01-15T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 356, "newlines": 365, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n  This REXX Checks all the RACF USERIDs that can be used for STCs. It\n       then displays the USERID, the DFLTGRP, and the PROTECTED status\n       as it would be used by an STC.\n\n  This REXX uses the RACF REXX R_Admin interface (IRRXUTIL). For more\n       docmucmentation see the \"Security Server RACF Macros and\n       Interfaces\" Manual (Chapter 14). Relevent check code starts at\n       line 48 and runs to the EXIT in line 68.\n NOTE: This REXX uses the IRRXUTIL R_Admin Interface. READ Access to\n       the RACF profile protecting the FACILITY IRR.RADMIN.RLIST\n       resource is required to use the IRRXUTIL interface.\n NOTE: This REXX does not require TSO to function, although it may be\n       invoked while under TSO.\n\n                           --- EXAMPLE ---\nIRXJCL RACFSTCS <TEST(trace_option)>\nTSO <%>RACFSTCS <TEST(trace_option)>\nTSO <%>RACFSTCS -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: INPUT: The current RACF Database\nOther EXECS: Works w/TSOVIEW, i.e. \"TSO %TSOVIEW RACFSTCS user_id\"\n\nEXEC History\n\n REXX EXEC Name: RACFSTCS\n         Author: FERGUSON AL (HUL2353)\n         Writen: 15JAN13\n        History: 15JAN13 - Version 1.0\n***************************** Rexx ***********************************/\nARG InParms                                  /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nGrpLst=\"\"; IdLst=\"\"\nIRR_rc=IRRXUTIL(\"EXTRACTN\",\"STARTED\",LEFT(\"\",8),\"stc\",,\"TRUE\")\n\nDO WHILE ABBREV(IRR_rc, \"0\")  /* While there are STARTED Profiles ... */\n   IF ABBREV(stc.STDATA.USER.1,\"=MEMBER\") THEN DO\n      IF WORDPOS(stc.STDATA.GROUP.1,GrpLst) = 0 THEN\n         GrpLst=GrpLst stc.STDATA.GROUP.1\n     END\n   ELSE DO\n      IF WORDPOS(stc.STDATA.USER.1, IdLst) = 0 THEN DO\n         lu_rc=IRRXUTIL(\"EXTRACT\",\"USER\",stc.STDATA.USER.1,\"lu\",,\"FALSE\")\n         pc_rc=IRRXUTIL(\"EXTRACT\",\"PROPCNTL\",stc.STDATA.USER.1,\"pc\",,\"FALSE\")\n         IF ABBREV(pc_rc, \"0\") THEN PROPCNTL = \"TRUE\"; ELSE PROPCNTL = \"FALSE\"\n         IF stc.STDATA.GROUP.1 = \"\" THEN\n              SAY \"USER=\"LEFT(lu.PROFILE,8) \"GROUP=-DFLTGRP\",\n                  \"PROTECTED=\"LEFT(lu.BASE.PROTECTD.1,5) \"PROPCNTL=\"PROPCNTL\n         ELSE SAY \"USER=\"LEFT(lu.PROFILE,8) \"GROUP=\"LEFT(stc.STDATA.GROUP.1,8),\n                  \"PROTECTED=\"LEFT(lu.BASE.PROTECTD.1,5) \"PROPCNTL=\"PROPCNTL\n         IdLst=IdLst stc.STDATA.USER.1\n      END\n   END\n            /* Get the next STARTED Profile ...                       */\n   IRR_rc=IRRXUTIL(\"EXTRACTN\",\"STARTED\",stc.PROFILE,\"stc\",,\"TRUE\")\nEND\n\nDO i = 1 TO WORDS(GrpLst)     /* ... check the STARTED GROUP= ...     */\n   group=WORD(GrpLst, i)\n   SAY \"     Checking USERIDs connected to:\" group\n   lg_rc=IRRXUTIL(\"EXTRACT\",\"GROUP\",group,\"lg\",,\"FALSE\")\n\n   IF ABBREV(lg_rc, \"0\") THEN DO j = 1 TO lg.BASE.GUSERID.0\n      IF WORDPOS(lg.BASE.GUSERID.j, IdLst) > 0 THEN ITERATE j\n      lu_rc=IRRXUTIL(\"EXTRACT\",\"USER\",lg.BASE.GUSERID.j,\"lu\",,\"FALSE\")\n      pc_rc=IRRXUTIL(\"EXTRACT\",\"PROPCNTL\",lg.BASE.GUSERID.j,\"pc\",,\"FALSE\")\n      IF ABBREV(pc_rc, \"0\") THEN PROPCNTL = \"TRUE\"; ELSE PROPCNTL = \"FALSE\"\n      SAY \"USER=\"LEFT(lu.PROFILE,8) \"GROUP=\"LEFT(group,8),\n          \"PROTECTED=\"LEFT(lu.BASE.PROTECTD.1,5) \"PROPCNTL=\"PROPCNTL\n     END\n   ELSE CALL SET_MSG ,\"LG rc=\"lg_rc,\"NO\"\nEND\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms=\"TEST(O)\"\n  match_length=4       /* NP-Parms match on first # chars             */\n  accept_all=FALSE     /* Allow un-recognized NP-PARMS to be passed   */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname=MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRMVS  */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFVARS": {"ttr": 107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\t\\x00\\x03\\x00\\x99'\\x1f\\x01\\x17%O\\x100\\x01g\\x01\\xd0\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.09", "flags": 0, "createdate": "1999-09-28T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 359, "newlines": 464, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n  This REXX displays information about RACF Profiles in the RACFVARS\n       Class using the IRRXUTIL R_Admin Interface. This REXX will run\n       under the IRXJCL Batch interface, and does not require TSO.\n\n  This REXX uses the RACF REXX R_Admin interface (IRRXUTIL). For more\n       docmucmentation see the \"Security Server RACF Macros and\n       Interfaces\" Manual (Chapter 14). Relevent check code starts at\n       line 48 and runs to the EXIT in line 68.\n NOTE: This REXX uses the IRRXUTIL R_Admin Interface.  READ Access to\n       the RACF profile protecting the FACILITY IRR.RADMIN.RLIST\n       resource is required to use the IRRXUTIL interface.\n NOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\n                           --- EXAMPLE ---\nTSO <%>RACFVARS profile <TEST(trace_option)>\nIRXJCL RACFVARS profile <TEST(trace_option)>\nTSO <%>RACFVARS -H -- To display help for this REXX\n\n  Arguments: profile     - RACFVARS PROFILE to get information on\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: None\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: RACFVARS\n         Author: FERGUSON AL (HUL2353)\n         Writen: 27APR10\n        History: 03FEB11 - Version 2.06 - Remove TSO Dependencies to\n                           support IRXJCL batch environment.\n                 27APR10 - Version 1.0\n***************************** Rexx ***********************************/\nADDRESS \"MVS\" \"SUBCOM TSO\"\nIF RC = 0 THEN DO\n   TSO_avail = 1\n   msgstat = MSG(\"OFF\")\n  END\nELSE TSO_avail = 0\nPARSE ARG profile InParms                    /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n/*   rc=IRRXUTIL(command,type,profile,stem,prefix,generic)           */\nIF profile = \"\" THEN\n     rc=IRRXUTIL(\"EXTRACTN\",\"RACFVARS\",LEFT(\"\",8),\"stem\",\"\",\"FALSE\")\nELSE rc=IRRXUTIL(\"EXTRACT\",\"RACFVARS\",profile,\"stem\",\"\",\"FALSE\")\n\nIF ABBREV(rc, \"0\") THEN DO WHILE ABBREV(rc, \"0\")\n   SAY \" CLASS: RACFVARS  PROFILE:\" LEFT(stem.PROFILE,8),\n        \"OWNER:\" stem.BASE.OWNER.1\n   SAY \"  DATA:\" stem.BASE.DATA.1\n   DO i = stem.BASE.MEMBER.0 TO 1 BY -1 /* R_Admin returns in REVERSE ORDER!  */\n       SAY LEFT(\"\",7) \"MEMBER:\" stem.BASE.MEMBER.i\n   END\n   SAY LEFT(\" \",81,\"-\")\n   IF profile = \"\" THEN\n        rc=IRRXUTIL(\"EXTRACTN\",\"RACFVARS\",stem.PROFILE,\"stem\",\"\",\"FALSE\")\n   ELSE rc=4\n  END\nELSE CALL SET_MSG ,\"EXTRACT rc=\"rc,\"NO\"\n\nIF TSO_avail THEN msgstat = MSG(msgstat)\nEXIT exit_error\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms = \"TEST(O)\"\n  match_length = 4     /* NP-Parms match on first # chars             */\n  accept_all = FALSE   /* Allow un-recognized NP-PARMS to be passed   */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  no_submited = 0\n  SYSUID = SYSVAR(\"SYSUID\")\n  user_prefix = LEFT(SYSUID,4)\n  exit_error = 0; sql_error = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXTRY": {"ttr": 63, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x03\\x01\\x16\"\\x9f\\x01\\x17%O\\x100\\x00\\xda\\x01N\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2016-08-16T00:00:00", "modifydate": "2017-09-11T10:30:03", "lines": 218, "newlines": 334, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX will INTERPRET anything passed to it, attempting to execute\n      it as a REXX Command string. This is used to test Simple REXX\n      CODE Snippets.\n\n                           --- EXAMPLE ---\nTSO <%>REXXTRY try_this\nTSO <%>REXXTRY -H -- To display help for this REXX\n\n  Arguments: try_this    - REXX Statements to TRY\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: REXXTRY\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 16AUG16\n        History: 06FEB17 - v1.11 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.07 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.06 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 16AUG16 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG try_this                           /* Place arguments here */\n\nIF WORDPOS(try_this,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/**********************************************************************\n              Initialize ERROR handling\n***********************************************************************/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     */\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT */\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  */\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       */\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle */\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  */\nEND\nTRACE (\"O\")\n\nINTERPRET TRANSLATE(try_this,';',':')\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n  SYSUID = USERID()\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RJUST": {"ttr": 65, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x17%O\\x100\\x01W\\x01^\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 343, "newlines": 350, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n    This ISPF MACRO right justifies a row or set of rows.\n\n                           --- EXAMPLE ---\n<%>RJUST <TEST(TraceOption)>\n<%>RJUST -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: The current EDIT member\nOther EXECS: NONE\n\nEXEC History\n\nEXEC/MACRO Name: RJUST\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.13\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 14JUN93\n        History: 06FEB17 - v1.15 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.14 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.13 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.04 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 23JUN93 - v1.01 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 14JUN93 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) NOPROCESS\"\n\nCALL INITIALIZE_THIS_REXX\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0';ADDRESS \"ISREDIT\" \"RECOVERY ON\"\nok='0 4 16';ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nIF RC = 0 THEN DO\n   ok='0'\n     ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFRANGE\"\n     ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLRANGE\"\n     ADDRESS \"ISREDIT\" \"RESET COMMAND\"\n     ADDRESS \"ISREDIT\" \"(line) = LINE\" first\n     ADDRESS \"ISREDIT\" \"LINE\" first \"= '\"line\"'\"\n   DO i=first TO last\n      ADDRESS \"ISREDIT\" \"(line) = LINE\" i\n      string = RIGHT(STRIP(line),WIDTH)\n      ADDRESS \"ISREDIT\" \"LINE\" i \"= '\"string\"'\"\n   END\nEND\nCALL SET_MSG \"Lines justified.\", STRIP(last - first + 1,\"L\",\"0\"),\n             \"lines have been RIGHT justified.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0    /* REXX functional values for TRUE and FALSE     */\n                     /* Initialize and process non-positional parms   */\n  ValidParms = \"TEST(O)\"\n  MatchLength=4                    /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\n  ADDRESS \"ISREDIT\" \"(width) = LRECL\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SENDMAIL": {"ttr": 67, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02?\\x00\\x13\\x01\\x08\\x12o\\x01\\x17%O\\x100\\x03\\x0f\\x01J\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.63", "flags": 0, "createdate": "2008-05-05T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 783, "newlines": 330, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to send SMTP Mail via the REXX RXSOCKET API vs the\n      USS /bin/sendmail command. This allows the manipulations of\n      additional SMTP Headers not available when using sendmail.\n\n This REXX does NOT Require TSO, it will run in batch under IRXJCL.\n\n To BASE64 encoding requires access to ENCODE64 REXX Function:\n       http://www.homerow.net/asm/index.htm\n\n                           --- EXAMPLE ---\nIRXJCL SENDMAIL <EM_DOM(@default_email_domain)> <EM_TYPE(PLAIN|HTML)>   ,\n      <IMPORT(Normal|High|Low)> <PORT(smtp_port)>                       ,\n      <SERVER(server_dns_name)> <TOKEN(STEMPUSH_token)> <TEST(trace_opt)>\nTSO <%>SENDMAIL <EM_DOM(@default_email_domain)> <EM_TYPE(PLIAN|HTML)>   ,\n      <IMPORT(Normal|High|Low)> <PORT(smtp_port)>                       ,\n      <SERVER(server_dns_name)> <TOKEN(STEMPUSH_token)> <TEST(trace_opt)>\nTSO <%>SENDMAIL -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                  EM_DOM - Default Email Domain to add to email address\n                           default: @sccompanies.com\n                 EM_TYPE - Email Body Type, plain text or html\n                           default: PLAIN\n                  IMPORT - Message Importance       default: Normal\n                    PORT - SMTP Server Port Number. default: DEFAULT\n                  SERVER - SMTP Server DNS Name.    default: DEFAULT\n                   TOKEN - Token created by STEMPUSH in calling REXX\n                           and used by STEMPULL to ID stem variable\n                           used to pass email.      default: blank\n                    TEST - Used to control traces.\n\n      Files: EMCNTL - Pre-Allocated EMail Control DD (see PARMs below)\n             EMBODY - Pre-Allocated EMail Body DD\n             ?????? - Pre-Allocated EMail Attachments DDs as defined\n                      in EMail Control DD\n                NOTE: The above files are not used if TOKEN is provided.\n      PARMs: *        - In column 1 indicates a comment.\n             From     - eMail address in message From field.\n             Received - Used in SMTP header to trace path of a message\n                        from its source to its destination.\n             Reply-to - eMail address used when user does a REPLY, if\n                        different then the From address.\n             To       - Primary eMail receipients.\n             Cc       - Carbon Copy eMail receipients.\n             Bcc      - Blind Carbon Copy eMail receipients.\n             Subject  - eMail one line subject.\n             Comment  - Comment embedded in eMail header information.\n             Import   - Set eMail Importance: Normal, High, or Low.\n             Attach   - Attachment file information: DD_name, MIME\n                        Content-type, and attachment file name.\n   STEM Var: em. = \"\"\n             em.hdr.to.0   = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0\n             em.hdr.to.#   = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.cc.#   = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.bc.#   = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.fm     = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.sub    = \"\"             /* Email Subject line         */\n             em.hdr.com    = \"\"             /* Hidden Header comment      */\n             em.hdr.imp    = \u00ddN | H | L\u00a8    /* Email Importance           */\n             em.hdr.rec    = email@domain   /* SMTP Received from address */\n             em.hdr.rep.#  = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.atch.0     = #              /* Number of attachments      */\n             em.atch.#.dat = \"\"             /* Attachment file date       */\n             em.atch.#.fnm = \"\"             /* Attachment filename        */\n             em.atch.#.typ = \u00ddPLAIN | HTML | OCTET-STREAM | INLINE | BASE64\u00a8\n             em.body.0     = #              /* Number records in body     */\n             em.body.#     = \"\"             /* Record # of email body     */\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: SENDMAIL\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 2.43\n                 Al Ferguson (HUL2353)\n         Writen: 07JUL08\n        History: 06FEB17 - v2.49 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v2.48 - Mass update to Error Handling Fixes.\n                 10MAY16 - v2.43 - Remove NAR support (obsolete)\n                 25APR13 - v2.38 - Fix multiple Reply-to email\n                           address support, while supporting old calls.\n                 09JAN12 - v2.31 - Add support for HTML Based\n                           Email Bodies & Attachments.\n                 16DEC11 - v2.17 - Add support for using SENDMAIL\n                           as a CALLED REXX that passes the email via\n                           stem variables using Rob Scott's STEMPUSH and\n                           STEMPULL REXX Functions (CBT File 411).\n                 14JUL08 - v1.84 - Fixed SET_MSG when being CALLed\n                           from within another REXX EXEC.\n                 09JUL08 - v1.71 - Miscellanious cleanup.\n                 09JUL08 - v1.69 - Fix Socket Error handling and\n                           handle PORT(DEFAULT) or PORT() when the SERVER\n                           is passed.\n                 08JUL08 - v1.66 - Cleanup Mime headers and reduce\n                           CALLs to RXSOCKET. Ensure RANDOM returns valid\n                           values to pick random letters properly.\n                 07JUL08 - v1.0 -- Based off of SCRTML v1.57\n***************************** Rexx ***********************************/\nPARSE ARG InParms                            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL GET_EMAIL_CNTL\nCALL INIT_SMTP_SOCKET\n\nCALL EMAIL_HEADER\nCALL EMAIL_BODY\nCALL EMAIL_ATTACHMENTS\nCALL CLOSE_EMAIL\n\nCALL CLOSE_SMTP_SOCKET\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"EM_DOM(@sccompanies.com) EM_TYPE(PLAIN) IMPORT()\",\n                \"PORT(DEFAULT) SERVER(DEFAULT) TOKEN() TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0\n  Lower   = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper   = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  letters = Lower || Upper\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SOCKMAIL */\n/* COPY MAILCNTL */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n     Read eMail Header and Control information,then parse it, and       /*COPY*/\n           build stings for SMTP Header commands.                       /*COPY*/\n                                                                        /*COPY*/\n  The structure of the em. STEM Varaible used here and passed via the   /*COPY*/\n      STEMPUSH & STEMPULL REXX Functions.                               /*COPY*/\n    em. = \"\"                                                            /*COPY*/\n    em.hdr.to.0 = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0; em.hdr.rep.0 = 0 /*COPY*/\n    em.hdr.to.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.cc.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.bc.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.fm   = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.sub  = \"\"               /* Email Subject line              *//*COPY*/\n    em.hdr.com  = \"\"               /* Hidden Header comment           *//*COPY*/\n    em.hdr.imp  = \u00ddN | H | L\u00a8      /* Email Importance                *//*COPY*/\n    em.hdr.rec  = email@domain     /* SMTP Received from address      *//*COPY*/\n    em.hdr.rep.# = \u00dd<email@domain> | name <email@domain>\u00a8 /* Reply-To *//*COPY*/\n    em.atch.0     = #              /* Number of attachments           *//*COPY*/\n    em.atch.#.dat = \"\"             /* Attachment file date (optional) *//*COPY*/\n    em.atch.#.fnm = \"\"             /* Attachment filename             *//*COPY*/\n    em.atch.#.typ = \u00ddPLAIN | OCTET-STREAM | INLINE | BASE64\u00a8            /*COPY*/\n    em.body.0   = #                /* Number of records in email body *//*COPY*/\n***********************************************************************//*COPY*/\nGET_EMAIL_CNTL:                                                         /*COPY*/\n  ok_to = \"postmaster POSTMASTER MAILER-DAEMON\"                         /*COPY*/\n  crlf = X2C(\"0D25\"); tab = X2C(\"05\")                                   /*COPY*/\n  dte = LEFT(DATE(\"W\"),3)\",\" DATE(\"N\") TIME(\"N\")                        /*COPY*/\n  _os_ = MVSVAR(\"SYMDEF\",\"LHHMMSS\") - MVSVAR(\"SYMDEF\",\"HHMMSS\")         /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN LENGTH(_os_) = 5 THEN dte = dte \"+0\"LEFT(_os_,3)               /*COPY*/\n    WHEN LENGTH(_os_) = 7 THEN dte = dte LEFT(_os_,5)                   /*COPY*/\n    WHEN ABBREV(_os_,\"-\") THEN dte = dte \"-0\"SUBSTR(_os_,2,3)           /*COPY*/\n  OTHERWISE;                   dte = dte \"+\"LEFT(_os_,4); END           /*COPY*/\n  mid = SUBSTR(letters,RANDOM(51)+1,1)||DATE(\"B\") ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)||TIME(\"S\")                       /*COPY*/\n  PARSE SOURCE . . rname .               /* Get REXX EXEC name        *//*COPY*/\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")     /* Get Job Name              *//*COPY*/\n  mbound = \"USER=\"SYSUID\";JOB=\"jname\";REXX=\"rname\";\"mid                 /*COPY*/\n  em. = \"\"; em.atch.0 = 0; em.body.0 = 0                                /*COPY*/\n  em.hdr.to.0 = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0; em.hdr.rep.0 = 0   /*COPY*/\n                                                                        /*COPY*/\n  IF TOKEN = \"\" THEN DO                                                 /*COPY*/\n    ADDRESS \"MVS\" \"EXECIO * DISKR EMCNTL (STEM _emcntl_. FINIS\"         /*COPY*/\n    DO i = 1 TO _emcntl_.0                                              /*COPY*/\n       PARSE VALUE _emcntl_.i WITH keyword \": \" _rest_                  /*COPY*/\n       UPPER keyword; _rest_ = STRIP(_rest_)                            /*COPY*/\n       SELECT                                                           /*COPY*/\n         WHEN ABBREV(keyword,\"*\")        THEN ITERATE i                 /*COPY*/\n         WHEN ABBREV(keyword,\"TO\")       THEN DO                        /*COPY*/\n            k = 1 + em.hdr.to.0; em.hdr.to.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN WORDPOS(_rest_,ok_to) THEN em.hdr.to.k = _rest_      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.to.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.to.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.to.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"CC\")       THEN DO                        /*COPY*/\n            k = 1 + em.hdr.cc.0; em.hdr.cc.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.cc.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.cc.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.cc.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"BCC\")      THEN DO                        /*COPY*/\n            k = 1 + em.hdr.bc.0; em.hdr.bc.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.bc.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.bc.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.bc.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"FROM\")     THEN SELECT                    /*COPY*/\n             WHEN ABBREV(_rest_, \"<\")    THEN em.hdr.fm = _rest_        /*COPY*/\n             WHEN ABBREV(_rest_, \"'\")    THEN em.hdr.fm = _rest_        /*COPY*/\n             WHEN INDEX(_rest_, \"@\") > 0 THEN em.hdr.fm = \"<\"_rest_\">\"  /*COPY*/\n           OTHERWISE; em.hdr.fm = \"<\"_rest_||EM_DOM\">\"; END             /*COPY*/\n         WHEN ABBREV(keyword,\"RECEIVED\") THEN DO                        /*COPY*/\n             PARSE VALUE _rest_ WITH sid \"@\" domain .                   /*COPY*/\n             IF domain = \"\" THEN domain = EM_DOM                        /*COPY*/\n             em.hdr.ret = STRIP(sid\"@\"domain)                           /*COPY*/\n             em.hdr.rec = \"From\" sid \"at\" domain \"with SMTP id\",        /*COPY*/\n                          mid\";\"crlf||tab dte                           /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"REPLY\")    THEN DO                        /*COPY*/\n            k = 1 + em.hdr.rep.0; em.hdr.rep.0 = k                      /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.rep.k=_rest_       /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.rep.k=\"<\"_rest_\">\" /*COPY*/\n            OTHERWISE; em.hdr.rep.k = \"<\"_rest_||EM_DOM\">\"; END         /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"SUBJECT\")  THEN em.hdr.sub = STRIP(_rest_)/*COPY*/\n         WHEN ABBREV(keyword,\"COMMENT\")  THEN em.hdr.com = _rest_       /*COPY*/\n         WHEN ABBREV(keyword,\"IMPORT\")   &,                             /*COPY*/\n              em.hdr.imp = \"\"            THEN em.hdr.imp = _rest_       /*COPY*/\n         WHEN ABBREV(keyword,\"ATTACH\")   THEN DO                        /*COPY*/\n             k = 1 + em.atch.0; em.atch.0 = k                           /*COPY*/\n             PARSE UPPER VALUE _rest_ WITH em.atch.k.dd em.atch.k.typ . /*COPY*/\n             em.atch.k.fnm = WORD(_rest_,3)                             /*COPY*/\n           END                                                          /*COPY*/\n       OTHERWISE; NOP; END                                              /*COPY*/\n    END                                                                 /*COPY*/\n  END                                                                   /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     rc = STEMPULL(TOKEN,\"DELETE\")                                      /*COPY*/\n     IF em.hdr.rec \u00ac= \"\" THEN DO                                        /*COPY*/\n        IF INDEX(em.hdr.rec, \"@\") > 0 THEN                              /*COPY*/\n                 PARSE VALUE em.hdr.rec WITH sid \"@\" domain .           /*COPY*/\n        ELSE DO; sid = em.hdr.rec; domain = EM_DOM; END                 /*COPY*/\n        em.hdr.ret = em.hdr.rec                                         /*COPY*/\n        em.hdr.rec = \"From\" sid \"at\" domain \"with SMTP id\",             /*COPY*/\n                     mid\";\"crlf||tab dte                                /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                           /* Set email importance level      *//*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"N\") THEN em.hdr.imp = \"Normal\"             /*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"H\") THEN em.hdr.imp = \"High\"               /*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"L\") THEN em.hdr.imp = \"Low\"                /*COPY*/\n  OTHERWISE; em.hdr.imp = \"Normal\"; END                                 /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILBODY */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Read in and then Send eMail Body using inline MIME format.        /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_BODY:                                  /* Get eMail Body        *//*COPY*/\n  IF TOKEN = \"\" THEN                                                    /*COPY*/\n     ADDRESS \"MVS\" \"EXECIO * DISKR EMBODY (STEM em.body. FINIS\"         /*COPY*/\n  IF em.body.0 = 0 THEN RETURN               /* No body to add        *//*COPY*/\n                                             /* Add body MIME Header  *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,crlf||'--'mbound||crlf)                      /*COPY*/\n  IF ABBREV(SYMBOL(\"EM_TYPE\"),\"VAR\") & ABBREV(EM_TYPE,\"HTML\") THEN      /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid,'Content-Type: text/html;',             /*COPY*/\n                                'charset=\"ISO-8859-1\"'crlf)             /*COPY*/\n  ELSE sm = SOCKET(\"WRITE\",_sid,'Content-Type: text/plain;',            /*COPY*/\n                                'charset=\"ISO-8859-1\"'crlf)             /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,'Content-Transfer-Encoding: 7bit'crlf||crlf) /*COPY*/\n  /* Add eMail Body Text                                              *//*COPY*/\n  DO i = 1 TO em.body.0; sm = SOCKET(\"WRITE\",_sid,em.body.i||crlf); END /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILATCH */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n Read any MIME Attachments identified in the EMCNTL, set MIME Header,   /*COPY*/\n      ENCODE when necessary, and then write as MIME Attachment.         /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_ATTACHMENTS:                                                      /*COPY*/\n  DO k = 1 TO em.atch.0                                                 /*COPY*/\n      IF TOKEN = \"\" THEN ADDRESS \"MVS\",                                 /*COPY*/\n         \"EXECIO * DISKR\" em.atch.k.dd \"(STEM em.atch.\"k\". FINIS\"       /*COPY*/\n      IF em.atch.k.0 = 0    THEN ITERATE k  /* Empty Attachement      *//*COPY*/\n      IF em.atch.k.dat = \"\" THEN em.atch.k.dat = dte                    /*COPY*/\n      SELECT                                /* Add MIME Type info     *//*COPY*/\n        WHEN ABBREV(\"PLAIN\", em.atch.k.typ) THEN DO                     /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/plain; name=\"'em.atch.k.fnm'\"'crlf, /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment file    *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"HTML\", em.atch.k.typ)  THEN DO                     /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/html; name=\"'em.atch.k.fnm'\"'crlf,  /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||        'charset=iso-8859-1'crlf                        /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment file    *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"OCTET-STREAM\", em.atch.k.typ) THEN DO              /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: application/octet-stream; ',             /*COPY*/\n              ||              'name=\"'em.atch.k.fnm'\"'crlf,             /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment         *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN k=1 & ABBREV(\"INLINE\", em.atch.k.typ) THEN,                /*COPY*/\n          DO j = 1 TO em.atch.k.0                                       /*COPY*/\n            sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)                 /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"INLINE\", em.atch.k.typ)       THEN DO              /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/plain; charset=\"ISO-8859-1\"'crlf,   /*COPY*/\n              ||'Content-Disposition: inline'crlf,                      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Inline file        *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n      OTHERWISE   /* ENCODE64 CBT Rexx Function must be available     *//*COPY*/\n         MimeHeader = crlf'--'mbound || crlf,                           /*COPY*/\n            ||'Content-Type: application/octet-stream; ',               /*COPY*/\n            ||              'name=\"'em.atch.k.fnm'\"'crlf,               /*COPY*/\n            ||'Content-Disposition: attachment; ',                      /*COPY*/\n            ||        'filename=\"'em.atch.k.fnm'\"; ',                   /*COPY*/\n            ||        'modification-date=\"'em.atch.k.dat'\"'crlf,        /*COPY*/\n            ||'Content-Transfer-Encoding: base64'crlf                   /*COPY*/\n         sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                     /*COPY*/\n         x = ENCODE64(\"em.atch.k.\",\"_atch_64.\")  /* Convert to Base64 *//*COPY*/\n         DO j = 1 TO _atch_64.0                  /* Add ENCODEd file  *//*COPY*/\n            sm = SOCKET(\"WRITE\",_sid,_atch_64.j||crlf)                  /*COPY*/\n         END                                                            /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILSOCK */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Initialize Socket and get necessary info from TCP/IP Stack.       /*COPY*/\n***********************************************************************//*COPY*/\nINIT_SMTP_SOCKET:                                                       /*COPY*/\n  sm = SOCKET(\"INITIALIZE\",\"SMTP01\")       /* Init RXSOCKET API       *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"INITIALIZE\", sm          /*COPY*/\n  sm = SOCKET(\"SOCKET\",\"AF_INET\",\"STREAM\") /* Init IP4 TCP Socket     *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"SOCKET\", sm              /*COPY*/\n       ELSE _sid = WORD(sm,2)                                           /*COPY*/\n  sm = SOCKET(\"GETHOSTNAME\")               /* Get HOSTNAME            *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETHOSTNAME\", sm         /*COPY*/\n       ELSE HOSTNAME = WORD(sm,2)                                       /*COPY*/\n  sm = SOCKET(\"GETDOMAINNAME\")             /* Get Domain              *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETDOMAINNAME\", sm       /*COPY*/\n       ELSE DOMAINNAME = WORD(sm,2)                                     /*COPY*/\n  IF ABBREV(\"DEFAULT\", SERVER) & \u00ac(DATATYPE(PORT, \"NUM\")) THEN DO       /*COPY*/\n      sm = SOCKET(\"GETSERVBYNAME\", \"SMTP\") /* Get local SMTP Port     *//*COPY*/\n         IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETSERVBYNAME\", sm  /*COPY*/\n            ELSE PORT = WORD(sm,3)                                      /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE IF ABBREV(\"DEFAULT\",PORT) THEN PORT = 25                         /*COPY*/\n                                           /* Translate to ASCII      *//*COPY*/\n  sm = SOCKET(\"SETSOCKOPT\",_sid,\"SOL_SOCKET\",\"SO_ASCII\",\"ON\")           /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"SETSOCKOPT\", sm         /*COPY*/\n                                           /* Connect to SMTP Server  *//*COPY*/\n  IF ABBREV(\"DEFAULT\", SERVER) THEN SERVER = HOSTNAME\".\"DOMAINNAME      /*COPY*/\n  sm = SOCKET(\"CONNECT\",_sid,\"AF_INET\" PORT SERVER)                     /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"CONNECT\", sm            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Connect to SMTP Server and Send SMTP Header control commands.     /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_HEADER:                                                           /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,\"HELO\" SERVER||crlf) /* Start SMTP Session *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF WORD(sm,3) \u00ac= \"220\" THEN                                     /*COPY*/\n           CALL SOCKET_ERR \"HELO\" SERVER, WORD(sm,3) sm                 /*COPY*/\n     END                                     /* Set SMTP From:        *//*COPY*/\n  PARSE VALUE em.hdr.fm WITH . \"<\" _from_ \">\" .                         /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"MAIL FROM: <\"_from_\">\"crlf)                /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF WORD(sm,3) \u00ac= \"250\" THEN                                     /*COPY*/\n           CALL SOCKET_ERR \"MAIL FROM:\", WORD(sm,3) sm                  /*COPY*/\n     END                                                                /*COPY*/\n  DO i = 1 TO em.hdr.to.0                    /* eMail TO: Addresses   *//*COPY*/\n      PARSE VALUE em.hdr.to.i WITH . \"<\" _to_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_to_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.to.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.cc.0                    /* eMail CC: Addresses   *//*COPY*/\n      PARSE VALUE em.hdr.cc.i WITH . \"<\" _cc_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_cc_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.cc.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.bc.0                    /* eMail BCC: Addresses  *//*COPY*/\n      PARSE VALUE em.hdr.bc.i WITH . \"<\" _bc_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_bc_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.bc.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                        /* End SMTP Header       *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"DATA\"||crlf)                               /*COPY*/\n  IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     sm = SOCKET(\"READ\",_sid)                                           /*COPY*/\n     IF WORDPOS(WORD(sm,3), \"250 354\") = 0 THEN                         /*COPY*/\n        CALL SOCKET_ERR \"DATA\", WORD(sm,3) sm                           /*COPY*/\n  END                                                                   /*COPY*/\n  IF em.hdr.rec \u00ac= \"\"   THEN DO              /* Start eMail Headers   *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Received:\" em.hdr.rec||crlf)          /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Date:\" dte||crlf)                     /*COPY*/\n       PARSE VALUE TIME(\"S\") WITH hh \":\" mm \":\" ss .                    /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Message-ID:\",                         /*COPY*/\n                    DATE(\"S\")||hh||mm||ss\".\"mid||EM_DOM||crlf)          /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE sm = SOCKET(\"WRITE\",_sid, \"Date:\" dte||crlf)                     /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"From:\" em.hdr.fm||crlf)                    /*COPY*/\n  IF em.hdr.rep \u00ac= \"\" THEN                                              /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid, \"Reply-to:\" em.hdr.rep  ||crlf)          /*COPY*/\n  ELSE DO i = 1 TO em.hdr.rep.0                                         /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid, \"Reply-to:\" em.hdr.rep.i||crlf)          /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.to.0                                               /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid,\"To:\" em.hdr.to.i||crlf)                  /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.cc.0                                               /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid,\"Cc:\" em.hdr.cc.i||crlf)                  /*COPY*/\n  END                                                                   /*COPY*/\n  IF em.hdr.sub \u00ac= \"\" THEN                                              /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Subject:\" em.hdr.sub||crlf)           /*COPY*/\n  IF em.hdr.com \u00ac= \"\" THEN                   /* eMail Header Comment  *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Comment:\" em.hdr.com||crlf)           /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"Importance:\" em.hdr.imp||crlf)             /*COPY*/\n                                             /* This will use MIME    *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"MIME-Version: 1.0\"crlf)                    /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"Content-Type: multipart/mixed;\",           /*COPY*/\n                            'boundary=\"'mbound'\"'crlf)                  /*COPY*/\n  IF em.hdr.ret \u00ac= \"\" THEN                   /* Return-Path           *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Return-Path:\" em.hdr.ret||crlf)       /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Send End-of-MIME indicater, SMTP End-of-Message indicator,        /*COPY*/\n      and then close SMTP session.                                      /*COPY*/\n***********************************************************************//*COPY*/\nCLOSE_eMail:                                                            /*COPY*/\n  IF (em.body.0 + em.atch.0) > 0 THEN sm =,                             /*COPY*/\n       SOCKET(\"WRITE\",_sid, crlf||\"--\"mbound\"--\"||crlf)                 /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, crlf\".\"crlf)     /* SMTP End of Message   *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF \u00ac(ABBREV(sm,\"0\")) & WORD(sm,3) = \"250\" THEN                  /*COPY*/\n             CALL SOCKET_ERR \"SENDMAIL\", sm                             /*COPY*/\n        ELSE CALL SET_MSG \"eMail Sent.\", sm,\"NO\"                        /*COPY*/\n     END                                                                /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"RSET\"crlf)                                 /*COPY*/\n  sm = SOCKET(\"READ\",_sid)                                              /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"QUIT\"crlf)      /* Complete SMTP Session *//*COPY*/\n  sm = SOCKET(\"READ\",_sid)                                              /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Close and Terminate Socket connection.                            /*COPY*/\n***********************************************************************//*COPY*/\nCLOSE_SMTP_SOCKET:                                                      /*COPY*/\n  sm = SOCKET(\"CLOSE\", _sid)                 /* Disconnect Socket     *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"CLOSE\", sm              /*COPY*/\n  sm = SOCKET(\"TERMINATE\", \"SMTP01\")         /* End RXSOCKET API      *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"TERMINATE\", sm          /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n    Report RXSOCKET Error and then fall through to CLEANUP              /*COPY*/\n***********************************************************************//*COPY*/\nSOCKET_ERR:                                                             /*COPY*/\nARG _type_, ExitError _msg_                                             /*COPY*/\n  DO eline = sigl-1 TO 1 BY -1                                          /*COPY*/\n     IF INDEX(STRIP(SOURCELINE(eline)),\"SOCKET(\") > 0 THEN LEAVE eline  /*COPY*/\n  END                                                                   /*COPY*/\n  IF eline > 1 THEN line = STRIP(SOURCELINE(eline))                     /*COPY*/\n     ELSE           line = STRIP(SOURCELINE(sigl-1))                    /*COPY*/\n  CALL SET_MSG \" Socket RC:\" ExitError, _type_ \"Error:\" _msg_, \"YES\"    /*COPY*/\n  CALL SET_MSG \"Error Line:\" eline, line, \"YES\"                         /*COPY*/\n  sm = SOCKET(\"CLOSE\", _sid)           /* Disconnect Socket           *//*COPY*/\n  sm = SOCKET(\"TERMINATE\", \"SMTP01\")   /* End RXSOCKET API            *//*COPY*/\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  *//*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    sm = SOCKET(\"CLOSE\", _sid)         /* Disconnect Socket           */\n    sm = SOCKET(\"TERMINATE\", \"SMTP01\") /* End RXSOCKET API            */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRMVS */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETMSG": {"ttr": 91, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00\\x13\\x01\\x01 \\x0f\\x01\\x17%O\\x100\\x01E\\x016\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "2001-07-19T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 325, "newlines": 310, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX takes the string passed it and turns it into an ISPF Long\n      Message. It is primarily designed to replace old Commands with\n      messages pointing to the Commands replacement and/or new location.\n\n                           --- EXAMPLE ---\nTSO <%>SETMSG <TEST(TraceOption)> short_msg, long_msg, alarm_status\nTSO <%>SETMSG -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: SETMSG\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.16\n                 AL HULSEBOSCH (TTECAH1)\n         Writen: 17MAY99\n        History: 06FEB17 - v1.35 - Update Error Handling routines.\n                 17MAY99 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG InParms                            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\n\nPARSE VALUE AnythingElse WITH short\",\" long\",\" alarm\nCALL SET_MSG STRIP(short), STRIP(long), STRIP(alarm)\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4                 /* NP-Parms match on first # chars  */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETVAR": {"ttr": 69, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x17%O\\x100\\x01q\\x01o\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 369, "newlines": 367, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO is used to set a single ISPF variable.  This\n        could be an ISPF PROFILE or SHARED pool variable.\n\n                           --- EXAMPLE ---\n<TSO> <%>SETVAR varname varvalue <LOCation> <TEST(TraceOption)>\n<TSO> <%>SETVAR -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: varname     - ISPF variable name to be updated\n             varvalue    - ISPF variable value to use in update\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                LOCATION - ISPF variable location (ASIS, PROFILE, SHARED)\n                               default: 'ASIS'\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: Can be used with SHOWVAR and ZAPVAR for debugging problems\n             related to ISPF variables.\n\nEXEC History\n\nEXEC/MACRO Name: SETVAR\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.15\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 11AUG93\n        History: 06FEB17 - v1.17 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.16 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.15 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 20JAN17 - v1.15 - Update to use VERASE when the ISPF\n                           Variable Value set to blank or NULL.\n                 18MAY95 - v1.08 - Update all REXXes to latest versions\n                           of commom routines via %CCMASS\n                 01SEP93 - v1.02 - Better messaging.\n                 11AUG93 - v1.00\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG varname varvalue InParms\n\nIF varname = '' THEN CALL INVOKE_AS_MACRO\nIF WORDPOS(varname,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF varname = '' THEN DO\n    CALL SET_MSG \"No ISPF Variable!\", \"You must provide an ISPF varariable\",\n         \"to be updated.\", \"YES\"\n    EXIT 1\nEND\n\nok='0 8'\nIF varvalue = \"\" | varvalue = \"NULL\" THEN DO\n   ADDRESS \"ISPEXEC\" \"VERASE (\"varname\")\" LOCATION\n   CALL SET_MSG varname \"Erased.\", ,\n        \"ISPF Variable '\"varname\"' ERASEd from Location '\"LOCATION\"'.\",\"NO\"\n  END\nELSE DO\n   INTERPRET varname \"= '\"varvalue\"'\"\n   ADDRESS \"ISPEXEC\" \"VPUT (\"varname\")\" LOCATION\n   CALL SET_MSG varname \"updated.\",,\n       varname \"has been set to '\"varvalue\" in Location '\"LOCATION\"'.\",\"NO\"\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n  ValidParms = \"LOCATION(ASIS) TEST(O)\"\n  MatchLength = 3                 /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0         /* Number of batch jobs submitted          */\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  UPPER varname\n  ExitError = 0\n\n  SELECT\n    WHEN ABBREV('PROFILE', LOCATION) THEN LOCATION = 'PROFILE'\n    WHEN ABBREV('SHARED', LOCATION)  THEN LOCATION = 'SHARED'\n  OTHERWISE;                              LOCATION = 'ASIS'   ; END\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n  ADDRESS \"ISREDIT\" \"MACRO (varname varvalue InParms) PROCESS\"\n  IF RC \u00ac= 0 THEN RETURN                          /* May be TSO call */\n\nRETURN\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHFT": {"ttr": 11, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x17%O\\x100\\x01T\\x01\\\\\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 340, "newlines": 348, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO SHIFTS an entire file either right or left.\n\n                           --- EXAMPLE ---\n<%>SHFT direct howmany <TEST(TraceOption)>\n<%>SHFT -H -- To display help for this ISPF Macro\n\n  Arguments: direct      - Either ')' to shift right or '(' to shift left\n             howmany     - How many characters to shift.     default: 2\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: Current EDIT file\nOther EXECS: NONE\n\nEXEC History\n\nISPF MACRO Name: SHFT\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.14\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 18JUN93\n        History: 06FEB17 - v1.16 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.15 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.14 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.06 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                 23JUN93 - v1.02 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 18JUN93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (direct howmany InParms) NOPROCESS\"\n\nIF WORDPOS(direct,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nIF WORDPOS(direct, \"( )\") = 0 THEN EXIT\nIF direct = \")\" THEN direction = 'right'; ELSE direction = 'left'\n\nok='0'\n  ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFIRST\"\n  ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLAST\"\nok='0 12'\nDO i=first TO last UNTIL RC \u00ac= 0\n   ADDRESS \"ISREDIT\" \"SHIFT\" direct i howmany\nEND\nCALL SET_MSG \"File shifted.\", STRIP(last,\"L\",\"0\"),\n             \"lines have been shifted to the\" direction \"in current file.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n                     /* Initialize and process non-positional parms   */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4                    /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWVAR": {"ttr": 71, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01&\\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x17%O\\x100\\x01{\\x01m\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.38", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 379, "newlines": 365, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF MACRO will display the current value of an ISPF\n        variable.  This variable can be in the PROFILE POOL,\n        SHARED POOL or first found (ASIS).\n\n                           --- EXAMPLE ---\n<TSO> <%>SHOWVAR varname <HEXDISP(TRUE|FALSE)> <LOCATION(ASIS|PROFILE|SHARED)>\n                 <START(...)> <TEST(TraceOption)>\n<TSO> <%>SHOWVAR -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: varname     - ISPF variable name to VGET.\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                 HEXDISP - Display in HEX format.        default: FALSE\n                LOCATION - ISPF variable location (ASIS, PROFILE, SHARED)\n                           default: 'ASIS'\n                   START - Starting point in variable string to display\n                           default: '1', i.e. first column\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: Can be used with SETVAR and ZAPVAR for debugging problems\n             related to ISPF variables.\n\nEXEC History\n\nEXEC/MACRO Name: SHOWVAR\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.19\n                 FERGUSON AL (HUL2353) from version 1.15\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 1SEP93\n        History: 06FEB17 - v1.21 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.20 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.19 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 22NOV10 - v1.15 - Add Display in HEX and Starting\n                           point support.\n                 18MAY95 - v1.04 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                  1SEP93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG varname InParms\n\nIF varname = '' THEN CALL INVOKE_AS_MACRO\nIF WORDPOS(varname,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nIF varname = '' THEN DO\n    CALL SET_MSG \"No ISPF Variable!\", \"You must provide an ISPF varariable\",\n         \"to be displayed.\", \"YES\"\n    EXIT 1\nEND\n\nok='0 8';ADDRESS \"ISPEXEC\" \"VGET (\"varname\")\" LOCATION\n\nSELECT\n  WHEN RC = 0 & HEXDISP THEN CALL SET_MSG ,,\n                  varname \"Length:\" LENGTH(VALUE(varname)),\n                 \"Value: '\"C2X(SUBSTR(VALUE(varname),START))\"'\"\nWHEN RC = 0             THEN CALL SET_MSG ,,\n                  varname \"Length:\" LENGTH(VALUE(varname)),\n                 \"Value: '\"SUBSTR(VALUE(varname),START)\"'\"\nOTHERWISE\n    CALL SET_MSG \"Variable not found.\",,\n                  varname \"is not currently defined as an ISPF variable\",\n                 \"using the\" LOCATION \"ISPF Pool.\", \"YES\"\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0        /* REXX functional values for TRUE and FALSE */\n                     /* Initialize and process non-positional parms   */\n  ValidParms = \"HEXDISP(FALSE) LOCATION(ASIS) START(1) TEST(O)\"\n  MatchLength = 3                  /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0          /* Number of batch jobs submitted          */\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  UPPER varname\n  ExitError = 0\n\n  SELECT\n    WHEN ABBREV('PROFILE', LOCATION) THEN LOCATION = 'PROFILE'\n    WHEN ABBREV('SHARED', LOCATION)  THEN LOCATION = 'SHARED'\n  OTHERWISE\n      LOCATION = 'ASIS'\n  END\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n  ADDRESS \"ISREDIT\" \"MACRO (varname InParms) NOPROCESS\"\n  IF RC \u00ac= 0 THEN RETURN                          /* May be TSO call */\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPQREXX": {"ttr": 73, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01:\\x00\\x13\\x01\\t\\x12_\\x01\\x17%O\\x100\\x01\\xc2\\x00\"\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.58", "flags": 0, "createdate": "2009-05-05T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 450, "newlines": 34, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX allocates a temporary SYSPRINT dataset for output. After\n   the allocation, the REXX calls SMPQPNL ISPF panels for entering the\n   query parameters.  And then the REXX calls the Assembler program\n   SMPQASM with the query parameters. When the SMPQASM ends, REXX\n   VIEWs the temporary dataset for query output.\n\n                           --- EXAMPLE ---\nTSO <%>SMPQREXX <TEST(TraceOption)>\nTSO <%>SMPQREXX -H -- To display help for this REXX\n\n                          --- Example 1 ---\n CSINM    ===> INST.ZOSV2R2.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> PRODUCT\n SUBENTRY ===> PRODID,PRODSUP,DESCRIPTION\n FILTER   ===>\n                          --- Example 1R --\n CSINM    ===> INST.ZOSV2R2.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> SYSMOD\n SUBENTRY ===> FMID,ENAME,DESCRIPTION,RECDATE\n FILTER   ===> RECDATE>='16271'\n                          --- Example 2  ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> ZOST113\n ENTRY    ===> SYSMOD\n SUBENTRY ===> FMID,ENAME,DESCRIPTION,INSTALLDATE\n FILTER   ===> FMID='HLE7780'&INSTALLDATE>'09083'\n                          --- Example 2F ---\n CSINM    ===> INST.FLASHER.V4R6M0.CSI\n ZONENM   ===> FLS460T\n ENTRY    ===> SRC\n SUBENTRY ===> FMID,ENAME,DESCRIPTION,INSTALLDATE\n FILTER   ===> FMID='MTFL460'&INSTALLDATE>'10130'\n                          --- Example 3  ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> HOLDDATA\n SUBENTRY ===> HOLDTYPE,HOLDREASON,HOLDDATA,HOLDFMID\n FILTER   ===> HOLDTYPE='SYSTEM'&(HOLDREASON!='DOC'&HOLDREASON!='IPL'&\n               HOLDREASON!='RESTART')&(ENAME='UA43599'|ENAME='UA44332'|\n               ENAME='UA44708'|ENAME='UA46940'|ENAME='UA46972')\n                          --- Example 4  ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> ZOST113\n ENTRY    ===> SYSMOD\n SUBENTRY ===> ENAME,INSTALLDATE,INSTALLTIME\n FILTER   ===> APPLY='YES'&SMODTYPE='USERMOD'\n                          --- Example 5  ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> FEATURE\n SUBENTRY ===> ENAME,PRODUCT,DESCRIPTION,FMID\n FILTER   ===>\n                          --- Example 6  ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> PRODUCT\n SUBENTRY ===> PRODID,PRODSUP,DESCRIPTION,VENDOR\n FILTER   ===>\n                          --- Example 7  ---\n CSINM    ===> INST.APPLDEVT.CPWR.$MPE.CSI\n ZONENM   ===> MXG400T\n ENTRY    ===> SYSMOD\n SUBENTRY ===> ENAME,INSTALLDATE\n FILTER   ===> APPLY='YES'\n                          --- Example 8  ---\n CSINM    ===> INST.FAULTA.V11R01.SMPE.CSI\n ZONENM   ===> FAT111\n ENTRY    ===> MOD\n SUBENTRY ===> LMOD\n FILTER   ===> ENAME='IDICNFDS'\n                          --- Example 9  ---\n CSINM    ===> INST.MQSERIES.V7R0.SMPE.CSI\n ZONENM   ===> MQT700\n ENTRY    ===> SYSMOD\n SUBENTRY ===> ENAME,INSTALLDATE,SOURCEID,DESCRIPTION\n FILTER   ===> INSTALLDATE>'10312'\n                          --- Example 10 ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> FEATURE\n SUBENTRY ===> ENAME,FMID,PRODUCT,RECDATE,DESCRIPTION\n FILTER   ===>\n                          --- Example 11 ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> FMIDSET\n SUBENTRY ===> ENAME,FMID\n FILTER   ===>\n                          --- Example 12 ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> GLOBAL\n ENTRY    ===> FEATURE\n SUBENTRY ===> ENAME,FMID,DESCRIPTION,PRODUCT,RECDATE\n FILTER   ===> RECDATE>'12015'\n                          --- Example 13 ---\n CSINM    ===> ZOS.V1R13.SMPE.GLOBAL.CSI\n ZONENM   ===> ZOST113\n ENTRY    ===> *\n SUBENTRY ===> *\n FILTER   ===> ENAME='FOMPDIR'\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: The CSI Specified\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: SMPQREXX\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 28SEP16\n        History: 06FEB17 - v1.41 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.40 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.39 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 28SEP16 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG InParms            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0'\n  ADDRESS \"TSO\" \"ALLOC DD(SYSPRINT) NEW REUSE UNIT(VIO)\",\n                \"TRACK SPACE(1,15) RECFM(F,B) LRECL(132)\"\n  ADDRESS \"ISPEXEC\" \"LMINIT DDNAME(SYSPRINT) DATAID(DID)\"\nok='0 8'\n  ADDRESS \"ISPEXEC\" \"VGET (csinm,zonenm,entry,subentry)\"\n  ADDRESS \"ISPEXEC\" \"VGET (filter1,filter2,filter3,filter4,filter5)\"\n\nDO FOREVER\n   ok='0';ADDRESS \"ISPEXEC\" \"ADDPOP POPLOC(F1)\"\n   ok='0 8';ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(SMPQPNL)\"\n   DISP_RC = RC\n   ok='0';ADDRESS \"ISPEXEC\" \"REMPOP\"\n   IF DISP_RC = 8 THEN LEAVE\n     ADDRESS \"ISPEXEC\" \"VPUT (csinm,zonenm,entry,subentry)\"\n     ADDRESS \"ISPEXEC\" \"VPUT (filter1,filter2,filter3,filter4,filter5)\"\n\n   x = SMPQASM(csinm,zonenm,entry,subentry,filter)\n   IF x = 8 THEN LEAVE\n   ok='0 8';ADDRESS \"ISPEXEC\" \"VIEW DATAID(\"DID\")\"\nEND\n\nok='0 8'\n  ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"DID\")\"\n  ADDRESS \"TSO\" \"FREE FI(SYSPRINT)\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STARTUP": {"ttr": 115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03N\\x00\\x13\\x01\\x023\\x8f\\x01\\x17%O\\x100\\x00\\xb6\\x00Z\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "03.78", "flags": 0, "createdate": "2002-12-04T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 182, "newlines": 90, "modlines": 0, "user": "AL-FERG"}, "text": "/*                                   REXX\n    Copy this member to your ISPF.PROFILE and update INITIALIZE_REXX\n         Function at end, as needed.\n\n    This member will be run immediately after the @SCSTART Startup\n         REXX is run. This member would be run instead of the\n         automated startup of ISPF, so include that if it is needed.\n\n    Works well in DR situation with Ed Jaffe's TSO SUB=MSTR UserMods\n         ftp://phoenixsoftware.com/pub/demo/tsomods.xmi\n\n-- HISTORY --\n   2015-10-30 - TSAZFA - v3.75 - Minor Optimization/Re-Factoring\n   2015-10-30 - TSAZFA - v3.54 - Minor Cleanup & Re-Factoring\n   2015-10-30 - TSAZFA - v3.53 - Tweaks to move things to @SCSTART\n   2015-10-12 - TSAZFA - v3.39 - Initial SCDC \"Generic\" Version\n                                     REXX                            */\n\nCALL INITIALIZE_REXX\nSELECT\n  WHEN ABBREV(MVSVAR(\"SYSNAME\"), \"DEV\") THEN CALL SETUP_FOR_DEVL\n  WHEN ABBREV(MVSVAR(\"SYSNAME\"), \"INS\") THEN CALL SETUP_FOR_TECH\nOTHERWISE;                                   CALL SETUP_FOR_PROD; END\n\nCALL SETUP_FOR_USER\nCALL GET_CURRENT_ALLOCATIONS\n        /* Setup ISPF DDs                                            */\nIF ISPLLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPLLIB\" ISPLLIB)\nIF ISPMLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPMLIB\" ISPMLIB)\nIF ISPPLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPPLIB\" ISPPLIB)\nIF ISPSLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPSLIB\" ISPSLIB)\nIF ISPTLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPTLIB\" ISPTLIB)\nIF ISPPROF \u00ac= \"\" THEN x=BPXWDYN(\"ALLOC DD(ISPPROF) DSN(\"ISPPROF\") SHR REUSE\")\nIF ISPTABL \u00ac= \"\" THEN x=BPXWDYN(\"ALLOC DD(ISPTABL) DSN(\"ISPTABL\") SHR REUSE\")\n        /* Setup TSO DDs                                             */\nIF SYSHELP \u00ac= \"\" THEN CALL UPDATE_DD(\"SYSHELP\" SYSHELP)\nIF SYSPROC \u00ac= \"\" THEN CALL UPDATE_DD(\"SYSPROC\" SYSPROC)\nIF SYSEXEC \u00ac= \"\" THEN CALL UPDATE_DD(\"SYSEXEC\" SYSEXEC)\n        /* PULL any STACKed commands to be pushed later              */\n_queue.=\"\"; _queue.0=QUEUED()\nIF _queue.0 > 0 THEN DO k=1 TO _queue.0; PULL _queue.k; END\n        /* Invoke ISPF, after Exiting from REXX.                     */\nPUSH \"ISPSTART PANEL(ISR@PRIM) NEWAPPL(ISR) SHRPROF\"\n        /* Push TSOLIB setup onto Queue                              */\nIF (TSOLIB STEPLIB) \u00ac= \"\" THEN DO         /* Use TSOLIB for APF LIBs */\n   PARSE VALUE (TSOLIB STEPLIB) WITH front \"***\" middle \"***\" back\n   PUSH \"TSOLIB ACT DSN(\"STRIP(front middle back)\")\"\nEND\nIF _queue.0 > 0 THEN DO k=1 TO _queue.0 /* Don't Start ISPF Twice! */\n   IF \u00ac(ABBREV(_queue.k, \"ISPSTART \")) THEN PUSH _queue.k\nEND\n\nEXIT\n/*---------------------------------------------------------------------*\n          Build list of currently Allocated DD Concatinations\n *---------------------------------------------------------------------*/\nGET_CURRENT_ALLOCATIONS:\n  my_DD=0; concat.=\"\"; dd_lst=\"\"\n  my_DDs=\"ISPLLIB ISPMLIB ISPPLIB ISPSLIB ISPTLIB\",\n         \"SYSHELP SYSPROC SYSEXEC STEPLIB\"\n  DO j=1 UNTIL list \u00ac= 0\n     x=BPXWDYN(\"INFO INRELNO(\"j\") INRTDDN(ddn) INRTDSN(dsn) INRTLST(list)\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"INFO\" \"DSN: '\"dsn\"' LIST:\" list)\n     IF ddn \u00ac= \"\" & WORDPOS(ddn, dd_lst)=0 THEN dd_lst=dd_lst ddn\n     SELECT\n       WHEN ddn=\"\" & \u00ac(my_DD)                 THEN ITERATE j\n       WHEN WORDPOS(ddn, my_DDs) > 0 | ddn=\"\" THEN DO\n          IF ddn \u00ac= \"\" THEN this_dd=ddn\n          my_DD=1; concat.this_dd=concat.this_dd dsn\n         END\n     OTHERWISE; my_DD=0; END\n  END\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for SCDC Development Systems\n *---------------------------------------------------------------------*/\nSETUP_FOR_DEVL:\n  NOP    /* Nothing currently changed for DEVL System                  */\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for SCDC Techie Install Systems\n *---------------------------------------------------------------------*/\nSETUP_FOR_TECH:\n  NOP    /* Nothing currently changed for INSTALL Systems              */\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for SCDC Production Systems\n *---------------------------------------------------------------------*/\nSETUP_FOR_PROD:\n  NOP    /* Nothing currently changed for PROD System                  */\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for User's Personal ISPF DSNs\n *---------------------------------------------------------------------*/\nSETUP_FOR_USER:               /* Setup existing personal ISPF DSNs     */\n  IF SYSDSN(\"ISPF.ISPLLIB\") = \"OK\" THEN IF,\n     ISPLLIB=\"\" THEN ISPLLIB=USERID()\".ISPF.ISPLLIB ***\"\n                ELSE ISPLLIB=USERID()\".ISPF.ISPLLIB\" ISPLLIB\n  IF SYSDSN(\"ISPF.ISPMLIB\") = \"OK\" THEN IF,\n     ISPMLIB=\"\" THEN ISPMLIB=USERID()\".ISPF.ISPMLIB ***\"\n                ELSE ISPMLIB=USERID()\".ISPF.ISPMLIB\" ISPMLIB\n  IF SYSDSN(\"ISPF.ISPPLIB\") = \"OK\" THEN IF,\n     ISPPLIB=\"\" THEN ISPPLIB=USERID()\".ISPF.ISPPLIB ***\"\n                ELSE ISPPLIB=USERID()\".ISPF.ISPPLIB\" ISPPLIB\n  IF SYSDSN(\"ISPF.ISPSLIB\") = \"OK\" THEN IF,\n     ISPSLIB=\"\" THEN ISPSLIB=USERID()\".ISPF.ISPSLIB ***\"\n                ELSE ISPSLIB=USERID()\".ISPF.ISPSLIB\" ISPSLIB\n  IF SYSDSN(\"ISPF.ISPTLIB\") = \"OK\" THEN IF,\n     ISPTLIB=\"\" THEN ISPTLIB=USERID()\".ISPF.PROFILE\",\n                             USERID()\".ISPF.ISPTLIB ***\"\n                ELSE ISPTLIB=USERID()\".ISPF.PROFILE\",\n                             USERID()\".ISPF.ISPTLIB\" ISPTLIB\n                              /* Setup existing personal TSO DSNs      */\n  IF SYSDSN(\"Z.EXEC\") = \"OK\"       THEN IF,\n     SYSEXEC=\"\" THEN SYSEXEC=USERID()\".Z.EXEC ***\"\n                ELSE SYSEXEC=USERID()\".Z.EXEC\" SYSEXEC\n  IF SYSDSN(\"Z.HELP\") = \"OK\"       THEN IF,\n     SYSHELP=\"\" THEN SYSHELP=USERID()\".Z.HELP ***\"\n                ELSE SYSHELP=USERID()\".Z.HELP\" SYSHELP\n  IF SYSDSN(\"Z.CLIST\") = \"OK\"      THEN IF, /* Move personal CList 1st */\n     SYSPROC=\"\" THEN SYSPROC=USERID()\".Z.CLIST ***\"\n                ELSE SYSPROC=USERID()\".Z.CLIST\" SYSPROC\n  IF SYSDSN(\"Z.LOADLIB\") = \"OK\"    THEN IF,\n     TSOLIB=\"\"  THEN TSOLIB=\"Z.LOADLIB ***\"\n                ELSE TSOLIB=\"Z.LOADLIB\" TSOLIB\n  IF SYSDSN(\"Z.TSOLIB\") = \"OK\"     THEN IF,\n     TSOLIB=\"\"  THEN TSOLIB=\"Z.TSOLIB ***\"\n                ELSE TSOLIB=\"Z.TSOLIB\" TSOLIB\nRETURN\n/*---------------------------------------------------------------------*\n                Use BPXWDYN to update DD concatinations\n *---------------------------------------------------------------------*/\nUPDATE_DD:\nARG dd_name front \"***\" back\n  DDLIST=dd_name; this_DD=dd_name; DSLIST=front concat.dd_name back\n  x=BPXWDYN(\"ALLOC DD(\"dd_name\") DSN(\"WORD(DSLIST,1)\") SHR REUSE\")\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC\" dd_name WORD(DSLIST,1))\n  DO i=2 TO WORDS(DSLIST)\n     x=BPXWDYN(\"ALLOC DD(TMP\"i\") DSN(\"WORD(DSLIST,i)\") SHR REUSE\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC TMP\"i WORD(DSLIST,i))\n     DDLIST=DDLIST\",TMP\"i\n  END\n  IF WORDS(DSLIST) > 1 THEN DO\n     x=BPXWDYN(\"CONCAT DDLIST(\"DDLIST\")\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"CONCAT\" dd_name DDLIST)\n  END\nRETURN\n/*---------------------------------------------------------------------*\n      Display BPXWDYN error information for non-zero Return Codes\n *---------------------------------------------------------------------*/\nBPXWDYN_ERR:\nPARSE ARG BPXWDYN_rc arg2 arg3\n  SAY RIGHT(arg2,7) \"of:\" arg3\n  IF BPXWDYN_rc > 0 THEN DO\n     PARSE VALUE RIGHT(D2X(BPXWDYN_rc),8,\"0\") WITH dyn_EC 5 dyn_RC .\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc \"(\"dyn_EC dyn_RC\")\"\n    END\n  ELSE DO; dyn_EC=ABS(BPXWDYN_rc); SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc; END\n  IF SYMBOL(\"S99MSG.0\")=\"VAR\" THEN DO i=1 TO S99MSG.0;SAY \"  \"S99MSG.i;END\nRETURN dyn_EC\n/*---------------------------------------------------------------------*\n    Personal setup of initial TSO/ISPF/STEPLIB/TSOLIB Concatinations\n             -- This can include Group or CBT libraries --\n    NOTE: STEPLIB & TSOLIB need to be enclosed in Single Quotes.\n *---------------------------------------------------------------------*/\nINITIALIZE_REXX:\n          /* Standard TSO DDs                                          */\n  STEPLIB=\"\"                               /* Use STEPLIB for APF LIBs */\n  SYSEXEC=\"\"\n  SYSHELP=\"\"\n  SYSPROC=\"\"\n  TSOLIB =\"\"                               /* Use TSOLIB for APF LIBs  */\n          /* ISPF Personal Table allocations                           */\n  ISPPROF=\"\"\n  ISPTABL=ISPPROF\n          /* Standard ISPF DDs                                         */\n  ISPLLIB=\"\"                                /* Use as a nonAPF TASKLIB */\n  ISPMLIB=\"\"\n  ISPPLIB=\"\"\n  ISPSLIB=\"\"\n  ISPTLIB=\"\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STUFFIT": {"ttr": 75, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x17%O\\x100\\x01[\\x01[\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 347, "newlines": 347, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO compresses the PDS you are within. It compresses\n        the current PDS when X37 errors occur to allow the saving of\n        your current Edit changes.\n\n                           --- EXAMPLE ---\n<%>STUFFIT <TEST(TraceOption)>\n<%>STUFFIT -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: The PDS your current EDIT member resides in.\nOther EXECS: NONE\n\nEXEC History\n\nISPF MACRO Name: STUFFIT (name inspired by a past available Macro)\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.15\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 17DEC93\n        History: 06FEB17 - v1.22 - Get updated version of Common Code.\n                 01FEB17 - v1.16 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.15 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.02 - Update all REXXes with current\n                           versions of commom routines via %CCMASS\n                 17DEC93 - v1.00\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) PROCESS\"\n\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0';ADDRESS \"ISREDIT\" \"(PDsName) = DATASET\"\nIF LISTDSI(\"'\"PDsName\"' DIRECTORY\") <= 4 & SYSDSORG \u00ac= \"PO\" THEN\n   CALL SET_MSG \"Can't Stuff it!\", \"STUFFIT compresses PDSs,\",\n              \"'\"PDsName\"' is a\" SYSDSORG \"dataset.\", \"YES\"\nELSE DO\n   ok='0 8'\n     ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DATASET('\"PDsName\"') ENQ(EXCLU)\"\n   IF RC = 8 THEN CALL SET_MSG \"Can't compress now!\", ZERRLM, \"YES\"\n   ELSE DO\n      ok='0'\n        ADDRESS \"ISPEXEC\" \"LMCOMP DATAID(\"id\")\"\n        ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"id\")\"\n      CALL SET_MSG \"PDS STUFFed!\", \"'\"PDsName\"' has been compressed,\",\n                   \"try to save your EDIT member now.\", \"NO\"\n   END\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4                  /* NP-Parms match on first # chars */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX\n***********************************************************************/\nCLEANUP:\n  ADDRESS \"ISPEXEC\" \"LMFREE DATAID(\"id\")\"\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       */\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TOASCII": {"ttr": 77, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x13\\x01\\x14\\x02\\x8f\\x01\\x17%O\\x100\\x00\\xf0\\x00\\xe2\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2014-01-28T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 240, "newlines": 226, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX does not require TSO to function, although it may be invoked\n      while under TSO.  This REXX will ...\n\n                           --- EXAMPLE ---\nIRXJCL TOASCII string <TEST(TraceOption)>\nTSO <%>TOASCII string <TEST(TraceOption)>\nTSO <%>TOASCII -H -- To display help for this REXX\n\n  Arguments: string      -\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files:\nOther EXECS:\n\nEXEC History\n\n REXX EXEC Name: TOASCII\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.10\n                 FERGUSON AL (HUL2353)\n         Writen: 28JAN14\n        History: 06FEB17 - v1.12 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.11 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.10 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 28JAN14 - v1.0\n\n***************************** Rexx ***********************************/\nPARSE ARG string                             /* Place arguments here */\n\nIF WORDPOS(string,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (\"O\")\nINTERPRET \"string =\" string\nstring = \"exssrv\\\"\nSAY \"Translate EBCDIC to ASCII ...\"\nx = BPXWUNIX(\"echo '\"string\"'|iconv -f IBM-1047 -t ISO8859-1\",,\"sout.\",\"serr.\")\n    _out_ = LEFT(sout.1,LENGTH(sout.1)-1)\n    SAY \"StdOut:\" _out_ \"--\" C2X(_out_)\nSAY \"... and back again!\"\nx = BPXWUNIX(\"echo '\"_out_\"'|iconv -f ISO8859-1 -t IBM-1047\",,\"sout.\",\"serr.\")\n    _out_ = LEFT(sout.1,LENGTH(sout.1)-1)\n    SAY \"StdOut:\" _out_ \"--\" C2X(_out_)\nSAY \"\"\n\nSAY \"Translate ASCII to EBCDIC ...\"\nx = BPXWUNIX(\"echo '\"string\"'|iconv -f ISO8859-1 -t IBM-1047\",,\"sout.\",\"serr.\")\n    _out_ = LEFT(sout.1,LENGTH(sout.1)-1)\n    SAY \"StdOut:\" _out_ \"--\" C2X(_out_)\nSAY \"... and back again!\"\nx = BPXWUNIX(\"echo '\"_out_\"'|iconv -f IBM-1047 -t ISO8859-1\",,\"sout.\",\"serr.\")\n    _out_ = LEFT(sout.1,LENGTH(sout.1)-1)\n    SAY \"StdOut:\" _out_ \"--\" C2X(_out_)\nSAY \"\"\n\nstring = '2D4420226E6D5C6164737263687022202D77202237526133704C346E22'x\nstring = '2D4420226578737372765C6578737263687022202D772022793763483979333522'x\nSAY \"Translate ASCII to EBCDIC ...\"\nx = BPXWUNIX(\"echo '\"string\"'|iconv -f ISO8859-1 -t IBM-1047\",,\"sout.\",\"serr.\")\n    _out_ = LEFT(sout.1,LENGTH(sout.1)-1)\n    SAY \"StdOut:\" _out_ \"--\" C2X(_out_)\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY ERRMVS  */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOVIEW": {"ttr": 79, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00\\x13\\x01\\x01\\x10\\x0f\\x01\\x17%O\\x100\\x01\\x07\\x01L\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "2001-04-10T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 263, "newlines": 332, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX takes a TSO COMMAND, traps the output and then puts you\n      into a view of that out.\n\n                           --- EXAMPLE ---\nTSO <%>TSOVIEW InParms <TEST(TraceOption)>\n                     --- EXAMPLE as ISPF Macro ---\n    <%>TSOVIEW InParms <TEST(TraceOption)>\nTSO <%>TSOVIEW -H -- To display help for this REXX\n\n  Arguments: InParms     - TSO Command to be envoked & Trapped\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: Uses STEMEDIT REXX Function from CBTTape.org\n\nEXEC History\n\n REXX EXEC Name: TSOVIEW\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.24\n                 Al Ferguson (HUL2353)\n         Writen: 10APR01\n        History: 06FEB17 - v1.37 - Get updated versions of Common Code.\n                 27DEC16 - v1.29 - Check for output before EDITting.\n                 04MAY16 - v1.24 - Convert to use CBTTape.org STEMEDIT.\n                 10APR01 - v1.00 - Uses pure ISPF REXX.\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG InParms                                  /* Place arguments here */\n\nIF InParms = ''                 THEN CALL INVOKE_AS_MACRO\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nxmsg = MSG(\"ON\"); x = OUTTRAP(\"tso_out.\")\n  ok='0 4';ADDRESS \"TSO\" InParms\nxmsg = MSG(xmsg); x = OUTTRAP(\"OFF\")\n\nIF tso_out.0 > 0 THEN CALL STEMEDIT 'VIEW','tso_out.',,,InParms\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n\n  SYSUID = USERID()\n  ExitError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */\n  ADDRESS \"ISREDIT\" \"MACRO (InParms) PROCESS\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                            /* Ignore all non-0 RCs           */\n    ZISPFRC = ExitError\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOVSORT": {"ttr": 95, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01)\\x00\\x13\\x01\\x01\\x10\\x0f\\x01\\x17%O\\x100\\x01\\x0c\\x01L\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.41", "flags": 0, "createdate": "2001-04-10T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 268, "newlines": 332, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX takes a TSO COMMAND, traps the output and then puts you\n      into a view of that out.\n\n                           --- EXAMPLE ---\nTSO <%>TSOVSORT InParms <TEST(TraceOption)>\n                     --- EXAMPLE as ISPF Macro ---\n    <%>TSOVSORT InParms <TEST(TraceOption)>\nTSO <%>TSOVSORT -H -- To display help for this REXX\n\n  Arguments: InParms     - TSO Command to be envoked & Trapped\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: Uses STEMEDIT REXX Function from CBTTape.org\n\nEXEC History\n\n REXX EXEC Name: TSOVSORT\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.23\n         Writen: 10APR01\n        History: 06FEB17 - v1.26 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.25 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.24 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 27DEC16 - v1.23 - Based on TSOVIEW v1.27.\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nARG InParms                                  /* Place arguments here */\n\nIF InParms = ''                 THEN CALL INVOKE_AS_MACRO\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nxmsg = MSG(\"ON\"); x = OUTTRAP(\"tso_out.\")\n  ok='0 4';ADDRESS \"TSO\" InParms\nxmsg = MSG(xmsg); x = OUTTRAP(\"OFF\")\n\nIF tso_out.0 > 0 THEN DO\n   x = BPXWUNIX(\"/bin/sort -n\",\"tso_out.\",\"tso_out.\")\n   CALL STEMEDIT 'VIEW','tso_out.',,,InParms\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n\n  ExitError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/**********************************************************************\n             If no arguments, was it envoked as a MACRO\n**********************************************************************/\nINVOKE_AS_MACRO:\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"\n  IF RC \u00ac= 0 THEN RETURN\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */\n  ADDRESS \"ISREDIT\" \"MACRO (InParms) PROCESS\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                            /* Ignore all non-0 RCs           */\n    ZISPFRC = ExitError\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UMODCHCK": {"ttr": 113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00\\x13\\x01\\t%\\x8f\\x01\\x17%O\\x100\\x01\\xd3\\x01\\\\\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2009-09-15T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 467, "newlines": 348, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX verifies all USERMODs are APPLYed to the appropritate SMP/E\n      TARGET and all APPLYed USERMODs are being documented.\n\nNOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\n                           --- EXAMPLE ---\nTSO <%>UMODCHCK umod_list <FAIL_RC(0|4|8)> <TEST(TraceOption)>\nTSO <%>UMODCHCK -H -- To display help for this REXX\n\n  Arguments: umod_list   - DSN to find USERMOD Control file & List In\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                 FAIL_RC - RC to return when Check Fails     default: 4\n                    TEST - Used to control traces\n\n      Files: Control file & Usermod list found in umod_list\n             SMP/E CSI identified in umod_list\nOther EXECS: NO additional REXX EXECs\n             SMPQASM external REXX Function\n\nEXEC History\n\n REXX EXEC Name: UMODCHCK\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.29\n                 FERGUSON AL (HUL2353)\n         Writen: 15SEP09\n        History: 30AUG17 - v1.47 - Remove TSO Requirement\n                 06FEB17 - v1.31 - Update Error Handling Routines\n                 08MAR12 - v1.26 - Fix check for extra USERMODs\n                           in CSI that are not in the USERMOD List. Also\n                           migrate from TSO ALLOC and FREE to BPXWDYN.\n                 15SEP09 - v1.17 - First functional version.\n                 15SEP09 - v1.00\n***************************** Rexx ***********************************/\nPARSE ARG umod_list InParms                  /* Place arguments here */\n\nIF WORDPOS(umod_list,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL READ_USERMOD_CNTL umod_list\n\napplyed.=\"\"\nDO i=1 TO WORDS(trgt_zone.0)\n   CALL CHECK_TRGT_CSI WORD(trgt_zone.0,i) global_DSN\nEND\n\nRc=MAX(CHECK_FOR_MISSING_USERMODS(),CHECK_FOR_EXTRA_USERMODS())\n\nIF Rc > 0 THEN ExitError=FAIL_RC\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-Positional parms */\n  ValidParms=\"FAIL_RC(4) TEST(O)\"\n  MatchLength=3        /* NP-Parms match on first # chars             */\n  AcceptAll=FALSE      /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname=MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Read in USERMOD Control file/list and initialize REXX\n***********************************************************************/\nREAD_USERMOD_CNTL:\nARG LstDsn . 1 LstPds . \"(\" LstMbr \")\" .\n\n  IF \u00ac(MEMBER_EXISTS(LstMbr LstPds)) THEN DO\n     CALL SET_MSG \"Invalid List DSN!\", \"'\"LstDsn\"' is not a valid\",\n                  \"USERMOD List DSN, you must provide one!\", \"YES\"\n     EXIT 12\n  END\n  x=BPXWDYN(\"ALLOC DD(USERMODS) DSN('\"LstDsn\"') SHR REUSE\")\n  ok='0';ADDRESS \"MVS\" \"EXECIO * DISKR USERMODS (STEM usermods. FINIS\"\n  x=BPXWDYN(\"FREE DD(USERMODS)\")\n\n  trgt_zone.=\"\"; check_list=\"\"\n  DO j=1 TO usermods.0\n     PARSE VALUE usermods.j WITH _1st_ _2nd_ rest\n     SELECT\n       WHEN ABBREV(_1st_, \"/*\")           THEN ITERATE j\n       WHEN ABBREV(_1st_, \"GLOBAL_CSI\")   THEN global_DSN=_2nd_\n       WHEN INDEX(trgt_zone.0, _1st_) = 0 THEN DO\n           trgt_zone.0=trgt_zone.0 _1st_\n           trgt_zone._1st_=trgt_zone._1st_ _2nd_\n           check_list=check_list _2nd_\n         END\n       WHEN INDEX(trgt_zone.0, _1st_) > 0 THEN DO\n           trgt_zone._1st_=trgt_zone._1st_ _2nd_\n           check_list=check_list _2nd_\n         END\n     OTHERWISE; NOP; END\n  END\nRETURN\n/* COPY MBREXIST */\n/********************************************************************** /*COPY*/\n   Check Member for existance in a PDS under MVS ...                    /*COPY*/\n***********************************************************************//*COPY*/\nMEMBER_EXISTS:                                                          /*COPY*/\nARG ChckMbr ChckDsn .                                                   /*COPY*/\n  _EOD_='FFFFFFFFFFFFFFFF'x                 /* End Of Directory       *//*COPY*/\n  x=BPXWDYN(\"ALLOC DD(CHCKDD) DSN(\"ChckDsn\") SHR REUSE\" ,               /*COPY*/\n              \"DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(0)\")               /*COPY*/\n    ADDRESS \"MVS\" \"EXECIO * DISKR CHCKDD (STEM dir. FINIS\"              /*COPY*/\n  x=BPXWDYN(\"FREE DD(CHCKDD)\")              /* Free file              *//*COPY*/\n  DO blk=1 TO dir.0                         /* Loop through Directory *//*COPY*/\n     i=3                                    /* Skip past used bytes   *//*COPY*/\n     DO WHILE i < C2D(LEFT(dir.blk,2))                                  /*COPY*/\n        mem=SUBSTR(dir.blk,i,8)             /* Get member name        *//*COPY*/\n        IF mem = ChckMbr THEN RETURN TRUE   /* Found, we are done     *//*COPY*/\n        IF mem = _EOD_   THEN LEAVE blk     /* We are finished        *//*COPY*/\n        ttr=C2D(SUBSTR(dir.blk,i+8,3))      /* Member TTR             *//*COPY*/\n        len=C2D(BITAND(SUBSTR(dir.blk,i+11,1),'1F'x))*2                 /*COPY*/\n        i=i+len+12                          /* Go to Next Dir Entry   *//*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN FALSE                                                            /*COPY*/\n/**********************************************************************\n      Check TARGET CSI for APPLYed USERMODs\n***********************************************************************/\nCHECK_TRGT_CSI:\nARG zonenm csinm .\n  entry   =\"SYSMOD\"\n  subentry=\"ENAME,INSTALLDATE,INSTALLTIME\"\n  filter  =\"APPLY='YES'&SMODTYPE='USERMOD'\"\n  x=BPXWDYN(\"ALLOC DD(SYSPRINT) NEW REUSE UNIT(VIO)\",\n            \"TRACKS SPACE(1,15) RECFM(F,B) LRECL(132)\")\n  x=SMPQASM(csinm,zonenm,entry,subentry,filter)\n  ok='0';ADDRESS \"MVS\" \"EXECIO * DISKR SYSPRINT (STEM smpe_rpt. FINIS\"\n  x=BPXWDYN(\"FREE DD(SYSPRINT)\")\n\n  DO j=3 TO smpe_rpt.0 UNTIL ABBREV(smpe_rpt.j, \"-----\"); NOP; END\n  DO j=j+1 TO smpe_rpt.0\n     PARSE VALUE smpe_rpt.j WITH before \": \" after .\n     SELECT\n       WHEN ABBREV(before, \"-----\" )         THEN ITERATE j\n       WHEN ABBREV(before, \"SYSMOD\")         THEN DO\n           this_sysmod=after\n           applyed.0=applyed.0 this_sysmod\n           applyed.ZONE.this_sysmod=zonenm\n         END\n       WHEN ABBREV(before, \"ZONE\")           THEN ITERATE j\n       WHEN ABBREV(before, \"   INSTALLDATE\") THEN\n           applyed.INSTALL.this_sysmod=after\n       WHEN ABBREV(before, \"   INSTALLTIME\") THEN\n           applyed.INSTALL.this_sysmod=applyed.INSTALL.this_sysmod after\n     OTHERWISE; NOP; END\n  END\nRETURN\n/**********************************************************************\n      Check USERMODS in USERMOD List that are not APPLYed\n***********************************************************************/\nCHECK_FOR_MISSING_USERMODS:\n  missing=0\n  DO i=1 TO WORDS(check_list)\n     _umod=WORD(check_list, i)\n     IF INDEX(applyed.0, _umod) > 0 THEN DO\n        SAY \"      \" _umod \"APPLYed on\" applyed.INSTALL._umod \"to\",\n                                        applyed.ZONE._umod\n        ITERATE i\n     END\n     missing=missing + 1\n     SAY \" ====>\" _umod \"was not APPLYed to any TZONE in '\"global_DSN\"'!\"\n  END\nRETURN missing\n/**********************************************************************\n      Check APPLYed USERMODS that are not in the USERMOD List\n***********************************************************************/\nCHECK_FOR_EXTRA_USERMODS:\n  extra=0\n  DO i=1 TO WORDS(applyed.0)\n     _umod=WORD(applyed.0, i)\n     IF INDEX(check_list, _umod) > 0 THEN ITERATE i\n     extra=extra+1\n     SAY \" ====>\" _umod \"was APPLYed in TZONE:\" applyed.ZONE._umod,\n         \"but is not in the USERMOD Control List!\"\n  END\nRETURN extra\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    x=BPXWDYN(\"FREE DD(USERMODS)\")\n    x=BPXWDYN(\"FREE DD(SYSPRINT)\")\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ZISPFRC=ExitError                  /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USSMAIL": {"ttr": 97, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0e\\x00\\x13\\x01\\x053o\\x01\\x17%O\\x100\\x00\\x1a\\x01l\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.14", "flags": 0, "createdate": "2005-12-02T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 26, "newlines": 364, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX Reads a pre-allocated EMAIL DD and uses the /bin/sendmail\n      command to send it via BPXWUNIX REXX-USS Command interface. Any\n      output is to the pre-allocated STDERR and STDOUT DDs.\n\nNOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\nEXEC History\n\n     Files Used: pre-allocated EMAIL DD is an SMTP Formated file\n\n REXX EXEC Name: USSMAIL\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 2.06\n                 FERGUSON AL (HUL2353)\n         Writen: 08DEC05\n        History: 12NOV12 - v2.04 - Convert BPXWUNIX Call to use\n                           STEM Variable directly.\n                 05NOV12 - v2.01 - Add check for empty input file.\n                 08DEC05 - v1.0\n***************************** Rexx ***********************************/\nADDRESS \"MVS\" \"EXECIO * DISKR EMAIL (STEM message. FINIS\"\n  IF message.0 = 0 THEN EXIT       /* Nothing to send, just exit     */\n\nx=BPXWUNIX(\"/bin/sendmail -t\",\"message.\",\"STDOUT\",\"STDERR\")\n\nEXIT x\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USSMSG": {"ttr": 99, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x13\\x01\\x17\"\\x7f\\x01\\x17%O\\x100\\x01V\\x01[\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-08-15T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 342, "newlines": 347, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is my version of IBM's SYS1.SBPXEXEC(BPXMTEXT) REXX for\n      Displaying the Text Discription of USS Return Code | Error\n      Code combination ('rrrreeee' format).\n\nNOTE: This REXX does NOT require TSO to run, it will run under IRXJCL\n\n                           --- EXAMPLE ---\nTSO <%>USSMSG UssRcEc <TEST(TraceOption)>\nTSO <%>USSMSG -H -- To display help for this REXX\n\n  Arguments: UssRcEc     - USS Return Code || Error Code string\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - REXX Trace Option              default: Off\n\n      Files: USS /bin/edcmtext support files\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: USSMSG\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 15AUG17\n        History: 15AUG17 - v1.00\n***************************** Rexx ***********************************/\nPARSE ARG UssRcEc InParms                    /* Place arguments here */\n\nIF WORDPOS(UssRcEc,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n\nIF DATATYPE(UssRcEc,\"X\") & LENGTH(UssRcEc)=8 THEN\n     CALL BPX_RC_TO_MSG_TEXT UssRcEc\nELSE CALL SET_MSG \"Invalid USS RcEc!\", \"'\"UssRcEc\"' does NOT meet the\",\n                  \"USS Return Code | Error Code Formating requirements\",,\n                  \"YES\"\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4        /* NP-Parms match on first # chars             */\n  AcceptAll=FALSE      /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname=MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY BPXRCMSG */\n/********************************************************************** /*COPY*/\n      Display Message Text for a Unix Rc || Ec combination              /*COPY*/\n***********************************************************************//*COPY*/\nBPX_RC_TO_MSG_TEXT:                                                     /*COPY*/\nARG RcEc .                                                              /*COPY*/\n  UssEnv.=\"\";UssEnv.0=2;UssEnv.1=\"_UNIX03=YES\";UssEnv.2=\"PATH=/bin\"     /*COPY*/\n  x=BPXWUNIX(\"edcmtext\" RcEc,,\"MT.\",\"SE.\",\"UssEnv.\")                    /*COPY*/\n  IF ABBREV(SYSVAR(\"SYSENV\"),\"FORE\") THEN DO                            /*COPY*/\n     IF SE.0 > 0 THEN CALL STEMEDIT \"BROWSE\",\"SE.\",,,\"STD Err:\"         /*COPY*/\n     IF MT.0 > 0 THEN CALL STEMEDIT \"BROWSE\",\"MT.\",,,\"Uss RC:\" RcEc     /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     IF SE.0 > 0 THEN DO i=1 TO SE.0; SAY \"    \" SE.i; END              /*COPY*/\n     IF MT.0 > 0 THEN DO i=1 TO MT.0; SAY \"    \" MT.i; END              /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSAMRD": {"ttr": 81, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x13\\x01\\t\\x02/\\x01\\x17%O\\x100\\x02\\xef\\x01\\xce\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2009-01-22T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 751, "newlines": 462, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to test out IGGCSI00 (the Catalog Search Interface)\n      programming. This REXX does not require TSO, i.e. it can run\n      under the IRXJCL Batch interface.\n This REXX reteives information on VSAM File via CSI and creates two\n      sets of IDCAMS Control cards:\n      DELETEME DD -- IDCAMS Delete Cards to cleanup existing DSNs\n      DEFINEME DD -- IDCAMS Define Cards to redefine new DSNs\n\n                           --- EXAMPLE ---\n<TSO> <%>VSAMRDEF DsnLevel <TEST(TraceOption)>\n<TSO> <%>VSAMRDEF -H -- To display help for this REXX\n\n  Arguments: DsnLevel    - The DSN Level to search for VSAM Datasets Under\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                 CATALOG - Catalog to do search against. default: blank\n                  FIELDS - Catalog Fields to display.\n                           default: VOLSER DEVTYP\n                    TEST - Used to control traces\n\n      Files: Input data is pulled from the System Catalog STC\n         DD  DELETEME - pre-allocated DD for IDCAMS DELETE statements\n         DD  DEFINEME - pre-allocated DD for IDCAMS DEFINE statements\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: VSAMRDEF\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.14\n                 FERGUSON AL (HUL2353)\n        Written: 22JAN09\n        History: 06FEB17 - v1.16 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.15 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.14 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 03MAR09 - v1.09 - Most VSAM Plus AIX, PATH, and\n                           Associated Names.\n                 03MAR09 - v1.06 - Most VSAM Attributes retrieved.\n                 22JAN09 - v1.00 - based off IGGCTEST REXX\n\n***************************** Rexx ***********************************/\nADDRESS \"MVS\" \"SUBCOM TSO\"                /* Is TSO available?       */\nIF RC = 0 THEN MsgStat=MSG(\"OFF\")\nARG DsnLevel InParms                      /* Place arguments here    */\n\nSELECT\n  WHEN WORDPOS(DsnLevel,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN DsnLevel = \"\"                  THEN DO\n     CALL SET_MSG \"DSN Filter needed!\",,\n          \"This needs a Dataset Name filter to find information on!\", \"YES\"\n     EXIT 4\n    END\nOTHERWISE\n    CALL INITIALIZE_THIS_REXX\nEND\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n/********************************************************************/\n/*  SET UP LOOP FOR RESUME (IF A RESUME IS NCESSARY)                */\n/********************************************************************/\nCATNAMET = ''; DNAMET   = ''\nDO UNTIL RESUME \u00ac= 'Y'\n   ok='*';ADDRESS \"LINKPGM\" \"IGGCSI00 MODRSNRC CSIFIELD DWORK\"\n   IF RC \u00ac= 0 THEN CALL DISPLAY_IGGCSI_ERROR\n\n   RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */\n   PARSE VALUE DWORK WITH CSIUSRLN +4 CSIREQLN +4 CSIUSDLN +4 CSINUMFD +2 rest\n   CSIUSRLN = C2D(CSIUSRLN)           /* Total Length of WORK AREA     */\n   CSIREQLN = C2D(CSIREQLN)           /* Minimum Required Work         */\n   CSIUSDLN = C2D(CSIUSDLN)           /* GET AMOUNT OF WORK AREA USED  */\n   CSINUMFD = C2D(CSINUMFD)           /* Number of field names +1      */\n   rest = LEFT(rest, CSIUSDLN-14)\n   /********************************************************************/\n   /*  PROCESS DATA RETURNED IN WORK AREA                              */\n   /********************************************************************/\n   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/\n      CALL PARSE_DSN\n      IF CSICTYPE = '0' THEN CATNAMET = CSICNAME\n      ELSE DO\n         _type = SET_DSN_TYPE()\n     /*  We now have NAME AND TYPE ... Get additional Info         */\n         start_at = 2*fld.0; fld_start = 1\n         lengths = SUBSTR(rest,1,start_at)\n         fld_list = SUBSTR(rest,start_at+1,CSICRETM-(start_at+4))\n         rest = SUBSTR(rest,CSICRETM-3)\n         IF DNAMET = CSICNAME THEN ITERATE; ELSE DNAMET = CSICNAME\n         DO i = 1 TO fld.0\n            fld.i.totln = C2D(SUBSTR(lengths,((i*2)-1),2))\n            fld.i.list = SUBSTR(fld_list,fld_start,fld.i.totln)\n            fld_start = fld_start + fld.i.totln\n         END\n         SELECT\n           WHEN ABBREV(_type, \"CLUS\") THEN DO\n              IF SYMBOL('_output') = \"VAR\" THEN SAY \"\"\n              _output = \"CLUSTER\" CSICNAME\n              IF LENGTH(fld.2.list) > 2 THEN DO\n                 _output = _output \"STORCLAS(\"SUBSTR(fld.2.list,3)\")\"\n                 _sms_ = TRUE\n                END\n              ELSE _sms_ = FALSE\n              IF LENGTH(fld.3.list) > 2 THEN _output = _output,\n                                       \"MGMTCLAS(\"SUBSTR(fld.3.list,3)\")\"\n              IF LENGTH(fld.4.list) > 2 THEN _output = _output,\n                                       \"DATACLAS(\"SUBSTR(fld.4.list,3)\")\"\n              IF LDS THEN _output = _output \"LIN\"\n              SAY _output\n              x = fld.15.totln/fld.15.ln\n              DO i = 1 TO x - 1\n                 SAY \"  ====>\",\n                     SUBSTR(fld.15.list,((i-1)*fld.15.ln)+1,fld.15.ln)\n              END\n              _output = \"  ====>\",\n                        SUBSTR(fld.15.list,((x-1)*fld.15.ln)+1,fld.15.ln)\n             END\n           WHEN ABBREV(_type, \"DATA\") THEN DO\n              IF _sms_ THEN _output = \"   DATA\" CSICNAME\n              ELSE DO\n                 y = SUBSTR(fld.1.list,1,fld.1.ln)\n                 DO i = 2 TO (fld.1.totln/fld.1.ln)\n                    y = y SUBSTR(fld.1.list,((i-1)*fld.1.ln)+1,fld.1.ln)\n                 END\n                 _output = \"   DATA\" CSICNAME \"VOLUMES(\"y\")\"\n              END\n              _output = _output SET_SPACOPTN(fld.5.list),\n                     || SET_ATTR1(fld.8.list) SET_ATTR2(fld.9.list),\n                     || SET_VSAMTYPE(fld.10.list),\n                       \"CISZ(\"C2D(LEFT(fld.12.list,4))\")\",\n                       \"RECSZ(\"C2D(fld.13.list) C2D(RIGHT(fld.12.list,4))\")\"\n             END\n           WHEN ABBREV(_type, \"INDE\") THEN DO\n              IF _sms_ THEN _output = \"  INDEX\" CSICNAME\n              ELSE DO\n                 y = SUBSTR(fld.1.list,1,fld.1.ln)\n                 DO i = 2 TO (fld.1.totln/fld.1.ln)\n                    y = y SUBSTR(fld.1.list,((i-1)*fld.1.ln)+1,fld.1.ln)\n                 END\n                 _output = \"  INDEX\" CSICNAME \"VOLUMES(\"y\")\"\n              END\n              _output = _output SET_SPACOPTN(fld.5.list),\n                        SET_ATTR2(fld.9.list) || SET_AMDKEY(fld.10.list),\n                       \"CISZ(\"C2D(LEFT(fld.12.list,4))\")\",\n                       \"RECSZ(\"C2D(fld.13.list) C2D(RIGHT(fld.12.list,4))\")\"\n             END\n           WHEN ABBREV(_type, \"AIX\")  THEN DO\n              SAY \"    AIX\" CSICNAME\n              x = fld.15.totln/fld.15.ln\n              DO i = 1 TO x - 1\n                 SAY \"  ====>\",\n                     SUBSTR(fld.15.list,((i-1)*fld.15.ln)+1,fld.15.ln)\n              END\n              _output = \"  ====>\",\n                        SUBSTR(fld.15.list,((x-1)*fld.15.ln)+1,fld.15.ln)\n             END\n           WHEN ABBREV(_type, \"PATH\") THEN _output = \"   PATH\" CSICNAME\n         OTHERWISE; NOP; END\n         SAY _output\n      END\n   END\nEND\n\nok='*';ADDRESS \"MVS\" \"SUBCOM TSO\"          /* Is TSO available?       */\nIF RC = 0 THEN MsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-Positional parms */\n  ValidParms = \"CATALOG() TEST(O)\",\n                \"FIELDS(VOLSER STORCLAS MGMTCLAS DATACLAS\",\n                       \"SPACOPTN PRIMSPAC SCONSPAC ATTR1 ATTR2\",\n                       \"VSAMTYPE AMDKEY AMDCIREC LRECL RGATTR NAME)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n        /* Initial variables used by IGGCSI interface                  */\n  MODRSNRC = LEFT(' ',4)              /*   CLEAR MODULE/RETURN/REASON  */\n  CSIFILTK = LEFT(STRIP(DsnLevel,\"B\",\"'\"),44) /*MOVE FILTER KEY INTO LIST */\n  CSICATNM = LEFT(CATALOG,44)         /*   CLEAR CATALOG NAME          */\n  CSIRESNM = LEFT(' ',44)             /*   CLEAR RESUME NAME           */\n  CSIDTYPS = LEFT('CGR',16)           /*   Get these entry types       */\n  CSICLDI  = 'Y'                      /*   INDICATE DATA AND INDEX     */\n  CSIRESUM = LEFT(' ',1)              /*   CLEAR RESUME FLAG           */\n  CSIS1CAT = LEFT(' ',1)              /*   INDICATE SEARCH > 1 CATALOGS*/\n  CSIOPTNS = LEFT(' ',1)              /*   CLEAR RESERVE CHARACTER     */\n  fld. = \"\"; fld.0 = WORDS(FIELDS)\n  DO i = 1 TO fld.0\n     PARSE VALUE VER_FNM(WORD(FIELDS,i)) WITH fnm fld.i.ln fld.i.ty fld.i.rp\n     fld.i.nm = LEFT(fnm, 8)\n  END\n  CSINUMEN = X2C(RIGHT(D2X(fld.0),4,'0'))\n  /********************************************************************/\n  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */\n  /********************************************************************/\n  CSIOPTS  = CSICLDI ||CSIRESUM||CSIS1CAT||CSIOPTNS\n  CSIFIELD = CSIFILTK||CSICATNM||CSIRESNM||CSIDTYPS||CSIOPTS||CSINUMEN\n  DO i = 1 TO fld.0; CSIFIELD = CSIFIELD || fld.i.nm; END\n  /********************************************************************/\n  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */\n  /********************************************************************/\n  WORKLEN = 64000 ; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))\n  DWORK = CSIUSRLN || COPIES('00'X,WORKLEN-4)\n\n  KSDS = FALSE; RRDS = FALSE; LDS = FALSE; VRRDS = FALSE\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Pull out Dataset Name information\n***********************************************************************/\nPARSE_DSN:\n  PARSE VALUE rest WITH CSICFLG  +1 CSICTYPE +1 CSICNAME +44 CSICRETM ,\n                     +2 CSICRETR +1 CSICRETN +1 rest\n  CSICFLG  = C2X(CSICFLG )\n  CSICRETM = C2D(CSICRETM)\n  CSICRETR = C2D(CSICRETR)           /* Catalog return reason code    */\n  CSICRETN = C2D(CSICRETN)           /* Catalog return code           */\nRETURN\n/**********************************************************************\n      Expand CSICTYPE Value for Dataset Type\n***********************************************************************/\nVER_FNM:\nARG fnm .\n  SELECT                      /* Validate Field name and assign len */\n    WHEN fnm = \"ACTOKEN\"  THEN DO; len = 36  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"AKEYPOS\"  THEN DO; len = 2   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"AMDCIREC\" THEN DO; len = 8   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"AMDKEY\"   THEN DO; len = 4   ; typ = \"R\" ; rep = 'N'; END\n    WHEN fnm = \"ASSOCSYM\" THEN DO; len = 45  ; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"ATTR1\"    THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"ATTR2\"    THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"BUFSIZE\"  THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"CATTR\"    THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"COMPIND\"  THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"COMUDSIZ\" THEN DO; len = 8   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"DATACLAS\" THEN DO; len = \"VL\"; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"DEVTYP\"   THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"DSCBTTR\"  THEN DO; len = 3   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"DSCRDT2\"  THEN DO; len = 4   ; typ = \"MX\"; rep = 'N'; END\n    WHEN fnm = \"DSEXDT2\"  THEN DO; len = 4   ; typ = \"MX\"; rep = 'N'; END\n    WHEN fnm = \"ENTYPE\"   THEN DO; len = 1   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"ENTNAME\"  THEN DO; len = 44  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"EXCPEXIT\" THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"FILESEQ\"  THEN DO; len = 2   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"GDGALTDT\" THEN DO; len = 4   ; typ = \"MX\"; rep = 'N'; END\n    WHEN fnm = \"GDGATTR\"  THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"GDGLIMIT\" THEN DO; len = 1   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"GENLEVEL\" THEN DO; len = 4   ; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"HARBA\"    THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"HARBADS\"  THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"HIKEYV\"   THEN DO; len = \"VL\"; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"HKRBA\"    THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"HURBA\"    THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"HURBADS\"  THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"ITYPEXT\"  THEN DO; len = 1   ; typ = \"BS\"; rep = 'Y'; END\n    WHEN fnm = \"LOGPARMS\" THEN DO; len = 1   ; typ = \"B\" ; rep = 'N'; END\n    WHEN fnm = \"LOGSTRID\" THEN DO; len = 26  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"LOKEYV\"   THEN DO; len = \"VL\"; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"LRECL\"    THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"LTBACKDT\" THEN DO; len = 8   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"MGMTCLAS\" THEN DO; len = \"VL\"; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"NAME\"     THEN DO; len = 44  ; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"NOBLKTRK\" THEN DO; len = 2   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"NOBYTAU\"  THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"NOBYTTRK\" THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"NOEXTNT\"  THEN DO; len = 1   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"NOTRKAU\"  THEN DO; len = 2   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"NVSMATTR\" THEN DO; len = 1   ; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"OPENIND\"  THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"OWNERID\"  THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"PASSATMP\" THEN DO; len = 2   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"PASSPRMT\" THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"PASSWORD\" THEN DO; len = 32  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"PHYBLKSZ\" THEN DO; len = 4   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"PRIMSPAC\" THEN DO; len = 3   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"RECVTIME\" THEN DO; len = 8   ; typ = \"B\" ; rep = 'N'; END\n    WHEN fnm = \"RECVTIMG\" THEN DO; len = 8   ; typ = \"B\" ; rep = 'N'; END\n    WHEN fnm = \"RGATTR\"   THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"RLSBWO\"   THEN DO; len = 1   ; typ = \"B\" ; rep = 'N'; END\n    WHEN fnm = \"RLSFLAGS\" THEN DO; len = 1   ; typ = \"B\" ; rep = 'N'; END\n    WHEN fnm = \"SCONSPAC\" THEN DO; len = 3   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"SECFLAGS\" THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"SPACOPTN\" THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"STORCLAS\" THEN DO; len = \"VL\"; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"STRIPCNT\" THEN DO; len =  2  ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"TYPE\"     THEN DO; len = 1   ; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"UDATASIZ\" THEN DO; len = 8   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"USVRMDUL\" THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"USERAREC\" THEN DO; len = \"VL\"; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VOLSER\"   THEN DO; len = 6   ; typ = \"CH\"; rep = 'Y'; END\n    WHEN fnm = \"VOLFLG\"   THEN DO; len = 1   ; typ = \"BS\"; rep = 'Y'; END\n    WHEN fnm = \"VSAMREUS\" THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"VSAMSTAT\" THEN DO; len = 46  ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"VSAMTYPE\" THEN DO; len = 2   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"VVRNFLGS\" THEN DO; len = 2   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"XACIFLAG\" THEN DO; len = 1   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"XHARBA\"   THEN DO; len = 8   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"XHARBADS\" THEN DO; len = 8   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"XHKRBA\"   THEN DO; len = 8   ; typ = \"F\" ; rep = 'Y'; END\n    WHEN fnm = \"XHURBADS\" THEN DO; len = 8   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"XHURBA\"   THEN DO; len = 8   ; typ = \"F\" ; rep = 'Y'; END\n /* Tape Library Entry Field Names                                        */\n    WHEN fnm = \"LCBCONID\" THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"LCBDEVTP\" THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"LCBDESCR\" THEN DO; len = 120 ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"LCBEMPTY\" THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"LCBLIBID\" THEN DO; len = 5   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"LCBLOGIC\" THEN DO; len = 1   ; typ = \"B\" ; rep = 'N'; END\n    WHEN fnm = \"LCBSCRTH\" THEN DO; len = 1020; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"LCBSLOTS\" THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"LCBTHRES\" THEN DO; len = 1020; typ = \"F\" ; rep = 'N'; END\n /* Tape Volume Entry Field Names                                         */\n    WHEN fnm = \"VCBCHKPT\" THEN DO; len = 1   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBCRDT\"  THEN DO; len = 10  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBDEVTP\" THEN DO; len = 4   ; typ = \"F\" ; rep = 'N'; END\n    WHEN fnm = \"VCBEDATE\" THEN DO; len = 10  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBERRST\" THEN DO; len = 2   ; typ = \"BS\"; rep = 'N'; END\n    WHEN fnm = \"VCBEXPDT\" THEN DO; len = 10  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBLIBNM\" THEN DO; len = 44  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBLOC\"   THEN DO; len = 1   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBMOUNT\" THEN DO; len = 10  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBOWNER\" THEN DO; len = 64  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBSGRP\"  THEN DO; len = 8   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBSHELF\" THEN DO; len = 32  ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBUATTR\" THEN DO; len = 1   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBWPROT\" THEN DO; len = 1   ; typ = \"CH\"; rep = 'N'; END\n    WHEN fnm = \"VCBWRITE\" THEN DO; len = 10  ; typ = \"CH\"; rep = 'N'; END\n  OTHERWISE\n     CALL SET_MSG ,\"Unsupported Field Name: '\"fnm\"'\",\"YES\"\n     EXIT 8\n  END\nRETURN fnm len typ rep\n/**********************************************************************\n      Determine KSDS Keys, if applicable\n***********************************************************************/\nSET_AMDKEY:\nARG AMDKEY .\nIF AMDKEY = \"\" THEN RETURN \"\"\n   ELSE RETURN \" KEYS(\"C2D(LEFT(AMDKEY,2)) C2D(RIGHT(AMDKEY,2))\")\"\n/**********************************************************************\n      Determine any additional attributes\n***********************************************************************/\nSET_ATTR1:\nARG ATTR1 .\n  IF ATTR1 = \"\" THEN RETURN \"\"; ELSE ATTR1 = X2B(C2X(ATTR1))\n  IF SUBSTR(ATTR1,1,1) THEN _attr1_ = \"SPEED\"; ELSE _attr1_ = \"\"\n  IF SUBSTR(ATTR1,3,1) THEN _attr1_ = _attr1_ \"RUS\"\n  IF SUBSTR(ATTR1,4,1) THEN _attr1_ = _attr1_ \"ERASE\"\nRETURN \"\" STRIP(_attr1_)\n/**********************************************************************\n      Determine VSAM Share options\n***********************************************************************/\nSET_ATTR2:\nARG ATTR2 .\n  IF ATTR2 = \"\" THEN RETURN \"\"; ELSE ATTR2 = X2B(C2X(ATTR2))\n  shr_rgn = SUBSTR(ATTR2,1,1) + SUBSTR(ATTR2,2,1) + 1\n  shr_sys = SUBSTR(ATTR2,3,1) + SUBSTR(ATTR2,4,1) + 1\nRETURN \"SHR(\"shr_rgn shr_sys\")\"\n/**********************************************************************\n      Determine how SPACE was allocated\n***********************************************************************/\nSET_SPACOPTN:\nARG SPACOPTN .\n  SELECT\n    WHEN SPACOPTN = '01000000'B THEN option = 'RECORDS'\n    WHEN SPACOPTN = '10000000'B THEN option = 'TRK'\n    WHEN SPACOPTN = '11000000'B THEN option = 'CYL'\n    WHEN SPACOPTN = '11111111'B THEN RETURN \"\"\n  OTHERWISE;                         option = '?????????'; END\nRETURN option\"(\"C2D(fld.6.list) C2D(fld.7.list)\")\"\n/**********************************************************************\n      Determine Alternate Index Attributes\n***********************************************************************/\nSET_RGATTR:\nARG RGATTR .\n  IF RGATTR = \"\"        THEN RETURN \"\"; ELSE RGATTR = X2B(C2X(RGATTR))\n  IF SUBSTR(RGATTR,1,1) THEN NOP /* options = \"UPGRADE\"    */\n  IF SUBSTR(RGATTR,2,1) THEN NOP /* Is and Alternate Index */\nRETURN \"\"\n/**********************************************************************\n      Determine any additional VSAM attributes\n***********************************************************************/\nSET_VSAMREUS:\nARG VSAMREUS .\n  IF VSAMREUS = \"\"        THEN RETURN \"\"; ELSE VSAMREUS = X2B(C2X(VSAMREUS))\n  IF SUBSTR(VSAMREUS,3,1) THEN options = \"RUS\"\n     ELSE                      options = \"\"\n  IF SUBSTR(VSAMREUS,4,1) THEN options = options \"ERASE\"\nRETURN STRIP(options)\n/**********************************************************************\n      Determine any additional VSAM attributes\n***********************************************************************/\nSET_VSAMTYPE:\nARG VSAMTYPE .\n  IF VSAMTYPE = \"\"         THEN RETURN \"\"\n  VSAMTYPE = X2B(C2X(VSAMTYPE)); options = \"\"\n  IF SUBSTR(VSAMTYPE, 1,1) THEN KSDS  = TRUE; ELSE KSDS  = FALSE\n  IF SUBSTR(VSAMTYPE, 7,1) THEN RRDS  = TRUE; ELSE RRDS  = FALSE\n  IF SUBSTR(VSAMTYPE, 8,1) THEN options = options \"SPND\"\n  IF SUBSTR(VSAMTYPE,15,1) THEN LDS   = TRUE; ELSE LDS   = FALSE\n  IF SUBSTR(VSAMTYPE,16,1) THEN VRRDS = TRUE; ELSE VRRDS = FALSE\nRETURN STRIP(options)\n/**********************************************************************\n      Expand CSICTYPE Value for Dataset Type\n***********************************************************************/\nSET_DSN_TYPE:\n  SELECT                   /*  ASSIGN ENTRY TYPE NAME  */\n    WHEN CSICTYPE = 'A' THEN DTYPE = 'NONVSAM '\n    WHEN CSICTYPE = 'B' THEN DTYPE = 'GDG     '\n    WHEN CSICTYPE = 'C' THEN DTYPE = 'CLUSTER '\n    WHEN CSICTYPE = 'D' THEN DTYPE = 'DATA    '\n    WHEN CSICTYPE = 'G' THEN DTYPE = 'AIX     '\n    WHEN CSICTYPE = 'H' THEN DTYPE = 'GDS     '\n    WHEN CSICTYPE = 'I' THEN DTYPE = 'INDEX   '\n    WHEN CSICTYPE = 'L' THEN DTYPE = 'TAPELIB '\n    WHEN CSICTYPE = 'R' THEN DTYPE = 'PATH    '\n    WHEN CSICTYPE = 'U' THEN DTYPE = 'UCAT    '\n    WHEN CSICTYPE = 'W' THEN DTYPE = 'TAPEVOL '\n    WHEN CSICTYPE = 'X' THEN DTYPE = 'ALIAS   '\n  OTHERWISE;                 DTYPE = '        '; END\nRETURN DTYPE\n/**********************************************************************\n      Translate Catalog entry to readable Device Type\n***********************************************************************/\nTRAN_DTYP:\nARG cat_entry .\n  cat_entry = C2X(cat_entry)\n  SELECT\n    WHEN cat_entry = '30C08003' THEN dev_type = '3400-2'\n    WHEN cat_entry = '30C08003' THEN dev_type = '3420  '\n    WHEN cat_entry = '3010200C' THEN dev_type = '3375  '\n    WHEN cat_entry = '3010200E' THEN dev_type = '3380  '\n    WHEN cat_entry = '3010200F' THEN dev_type = '3390  '\n    WHEN cat_entry = '30102004' THEN dev_type = '9345  '\n    WHEN cat_entry = '3040200A' THEN dev_type = '3340  '\n    WHEN cat_entry = '3050200B' THEN dev_type = '3350  '\n    WHEN cat_entry = '3050200D' THEN dev_type = '3330-1'\n    WHEN cat_entry = '30502007' THEN dev_type = '3205-2'\n    WHEN cat_entry = '30502009' THEN dev_type = '3330  '\n    WHEN cat_entry = '30582009' THEN dev_type = '3330V '\n    WHEN cat_entry = '32008003' THEN dev_type = '3400-5'\n    WHEN cat_entry = '32008003' THEN dev_type = '3420  '\n    WHEN cat_entry = '32108003' THEN dev_type = '3400-6'\n    WHEN cat_entry = '33008003' THEN dev_type = '3400-9'\n    WHEN cat_entry = '33308003' THEN dev_type = '3420C '\n    WHEN cat_entry = '34008003' THEN dev_type = '3430-3'\n    WHEN cat_entry = '78008080' THEN dev_type = '3480  '\n    WHEN cat_entry = '780480C1' THEN dev_type = '3490?A'\n    WHEN cat_entry = '780480C2' THEN dev_type = '3590?A'\n    WHEN cat_entry = '780480C3' THEN dev_type = '3590?B'\n    WHEN cat_entry = '78048080' THEN dev_type = '3480  '\n    WHEN cat_entry = '78048081' THEN dev_type = '3490  '\n    WHEN cat_entry = '78048083' THEN dev_type = '3590-1'\n    WHEN cat_entry = '????????' THEN dev_type = '????  '\n  OTHERWISE\n     SAY \"=====> '\"cat_entry\"'\";     dev_type = 'UNKNOW'\n  END\nRETURN dev_type\n/**********************************************************************\n      An error occured when calling IGGCSI00, dislay MODRSNRC, the\n         parms used to call it, and the WORK area returned.\n***********************************************************************/\nDISPLAY_IGGCSI_ERROR:\n  SAY  \"IGGCSI Error!  LINK RC=\"RC \"MOD=\"LEFT(MODRSNRC,2),\n       \"RSN=\"C2D(SUBSTR(MODRSNRC,3,1)) \"RC=\"C2D(SUBSTR(MODRSNRC,4,1))\n  SAY  \"_______________________ CSIFIELD ______________________\"\n  SAY  CSIFIELD\n  SAY  \"________________________ DWORK ________________________\"\n  SAY  DWORK\n  SAY  \"_______________________________________________________\"\nEXIT RC\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSAMRDEF": {"ttr": 83, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x00\\x13\\x01\\t\\x02/\\x01\\x17%O\\x100\\x03!\\x01\\xce\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "2009-01-22T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 801, "newlines": 462, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to test out IGGCSI00 (the Catalog Search Interface)\n      programming. This REXX does not require TSO, i.e. it can run\n      under the IRXJCL Batch interface.\n This REXX reteives information on VSAM File via CSI and creates two\n      sets of IDCAMS Control cards:\n      DELETEME DD -- IDCAMS Delete Cards to cleanup existing DSNs\n      DEFINEME DD -- IDCAMS Define Cards to redefine new DSNs\n\n                           --- EXAMPLE ---\n<TSO> <%>VSAMRDEF DsnLevel <TEST(TraceOption)>\n<TSO> <%>VSAMRDEF -H -- To display help for this REXX\n\n  Arguments: DsnLevel    - The DSN Level to search for VSAM Datasets Under\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                 CATALOG - Catalog to do search against. default: blank\n                    TEST - Used to control traces\n\n      Files: Input data is pulled from the System Catalog STC\n         DD  DELETEME - pre-allocated DD for IDCAMS DELETE statements\n         DD  DEFINEME - pre-allocated DD for IDCAMS DEFINE statements\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: VSAMRDEF\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.21\n                 FERGUSON AL (HUL2353)\n        Written: 22JAN09\n        History: 08AUG17 - v1.37 - Refactor to use Common IGGCSI Functions\n                 06FEB17 - v1.23 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.22 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.21 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 06MAR09 - v1.16 - All Information with TEST\n                           OUTPUT function, still not doing IDCAMS DEFs.\n                 04MAR09 - v1.13 - Mostly working with Test Output.\n                 03MAR09 - v1.09 - Most VSAM Plus AIX, PATH, and\n                           Associated Names.\n                 03MAR09 - v1.06 - Most VSAM Attributes retrieved.\n                 22JAN09 - v1.00 - based off IGGCTEST REXX\n***************************** Rexx ***********************************/\nADDRESS \"MVS\" \"SUBCOM TSO\"                /* Is TSO available?       */\nIF RC = 0 THEN MsgStat=MSG(\"OFF\")\nARG DsnLevel InParms                      /* Place arguments here    */\n\nSELECT\n  WHEN WORDPOS(DsnLevel,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN DsnLevel = \"\"                  THEN DO\n      CALL SET_MSG \"DSN Filter needed!\",,\n           \"This needs a Dataset Name filter to find information on!\", \"YES\"\n      EXIT 4\n    END\nOTHERWISE\n    CALL INITIALIZE_THIS_REXX\nEND\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\n/********************************************************************/\n/*  SET UP LOOP FOR RESUME (IF A RESUME IS NCESSARY)                */\n/********************************************************************/\nCALL INITIALIZE_IGGCSI_API\n\nCATNAMET = ''; DNAMET   = ''\nDO UNTIL RESUME \u00ac= 'Y'\n   ok='*';ADDRESS \"LINKPGM\" \"IGGCSI00 MODRSNRC CSIFIELD DWORK\"\n   IF RC \u00ac= 0 THEN CALL DISPLAY_IGGCSI_ERROR\n\n   RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */\n   PARSE VALUE DWORK WITH CSIUSRLN +4 CSIREQLN +4 CSIUSDLN +4 CSINUMFD +2 rest\n   CSIUSRLN = C2D(CSIUSRLN)           /* Total Length of WORK AREA     */\n   CSIREQLN = C2D(CSIREQLN)           /* Minimum Required Work         */\n   CSIUSDLN = C2D(CSIUSDLN)           /* GET AMOUNT OF WORK AREA USED  */\n   CSINUMFD = C2D(CSINUMFD)           /* Number of field names +1      */\n   rest = LEFT(rest, CSIUSDLN-14)\n   /********************************************************************/\n   /*  PROCESS DATA RETURNED IN WORK AREA                              */\n   /********************************************************************/\n   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/\n      CALL PARSE_DSN\n      IF CSICTYPE = '0' THEN CATNAMET = CSICNAME\n      ELSE DO\n         _type = SET_DSN_TYPE()\n                /*  We have NAME AND TYPE ... Get additional Info  */\n         _strt = 2*fld.0; fld_strt = 1; lengths = SUBSTR(rest,1,_strt)\n         fld_list = SUBSTR(rest,_strt+1,CSICRETM-(_strt+4))\n         rest = SUBSTR(rest,CSICRETM-3)\n         IF DNAMET = CSICNAME THEN ITERATE; ELSE DNAMET = CSICNAME\n         DO i = 1 TO fld.0\n            fld.i.totln = C2D(SUBSTR(lengths,((i*2)-1),2))\n            fld.i.list = SUBSTR(fld_list,fld_strt,fld.i.totln)\n            fld_strt = fld_strt + fld.i.totln\n         END\n         SELECT /*  Process appropriate VSAM component type        */\n           WHEN ABBREV(_type, \"CLUS\") THEN CALL PROCESS_CLUSTER\n           WHEN ABBREV(_type, \"DATA\") THEN CALL PROCESS_DATA\n           WHEN ABBREV(_type, \"INDE\") THEN CALL PROCESS_INDEX\n           WHEN ABBREV(_type, \"AIX\")  THEN CALL PROCESS_AIX\n           WHEN ABBREV(_type, \"PATH\") THEN CALL PROCESS_PATH\n         OTHERWISE; NOP; END\n      END\n   END\nEND\n\nCALL DO_OUTPUT\n\nok='*';ADDRESS \"MVS\" \"SUBCOM TSO\"          /* Is TSO available?       */\nIF RC = 0 THEN MsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-Positional parms */\n  ValidParms = \"CATALOG() TEST(O)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  CSIDTYPS = 'CGR'\n  FIELDS   = 'VOLSER STORCLAS MGMTCLAS DATACLAS',\n             'SPACOPTN PRIMSPAC SCONSPAC ATTR1 ATTR2',\n             'VSAMTYPE AMDKEY AMDCIREC LRECL RGATTR NAME'\n  KSDS = FALSE; RRDS = FALSE; LDS = FALSE; VRRDS = FALSE; _sms_ = FALSE\n  CLUSTERS. = \"\"; CLUSTERS.0 = 0; AIX. = \"\"; AIX.0 = 0; DS_CHAR. = \"\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY IGGINIT */\n/********************************************************************** /*COPY*/\n      Initialze the API before calling IGGCSI                           /*COPY*/\n***********************************************************************//*COPY*/\nINITIALIZE_IGGCSI_API:                                                  /*COPY*/\n  MODRSNRC = LEFT(' ',4)              /* CLEAR MODULE/RETURN/REASON   *//*COPY*/\n  CSIFILTK = LEFT(STRIP(DsnLevel,\"B\",\"'\"),44) /*MOVE FILTER INTO LIST*/ /*COPY*/\n  CSICATNM = LEFT(STRIP(CATALOG,\"B\",\"'\"),44)   /*   SET CATALOG NAME  *//*COPY*/\n  CSIRESNM = LEFT(' ',44)             /* CLEAR RESUME NAME            *//*COPY*/\n  CSIDTYPS = LEFT(CSIDTYPS,16)        /* ABCGHRUX are valid entries   *//*COPY*/\n  CSICLDI  = LEFT('Y',1)              /* INDICATE DATA AND INDEX      *//*COPY*/\n  CSIRESUM = LEFT(' ',1)              /* CLEAR RESUME FLAG            *//*COPY*/\n  IF CATALOG = \"\" THEN                /* Did we specify a catalog?    *//*COPY*/\n       CSIS1CAT = LEFT(' ',1)         /* ... No, search > 1 Catalog   *//*COPY*/\n  ELSE CSIS1CAT = LEFT('Y',1)         /* ... Yes, search that Catalog *//*COPY*/\n  CSIOPTNS = LEFT(' ',1)              /* CLEAR RESERVE CHARACTER      *//*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN WORDS(FIELDS)            = 0     THEN DO; fld.=\"\"; fld.0=0; END/*COPY*/\n    WHEN WORDS(FIELDS)            = 1     THEN CALL FLDS_WO_LENGTH      /*COPY*/\n    WHEN DATATYPE(WORD(FIELDS,2)) = \"NUM\" THEN CALL FLDS_WITH_LENGTH    /*COPY*/\n    WHEN WORD(FIELDS,2) = \"VL\"            THEN CALL FLDS_WITH_LENGTH    /*COPY*/\n  OTHERWISE;                                   CALL FLDS_WO_LENGTH ; END/*COPY*/\n  CSINUMEN = X2C(RIGHT(D2X(fld.0),4,'0'))                               /*COPY*/\n  /********************************************************************//*COPY*/\n  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      *//*COPY*/\n  /********************************************************************//*COPY*/\n  CSIOPTS  = CSICLDI ||CSIRESUM||CSIS1CAT||CSIOPTNS                     /*COPY*/\n  CSIFIELD = CSIFILTK||CSICATNM||CSIRESNM||CSIDTYPS||CSIOPTS||CSINUMEN  /*COPY*/\n  DO i = 1 TO fld.0; CSIFIELD = CSIFIELD||fld.i.nm; END                 /*COPY*/\n  /********************************************************************//*COPY*/\n  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     *//*COPY*/\n  /********************************************************************//*COPY*/\n  WORKLEN = 32768; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))            /*COPY*/\n  DWORK = CSIUSRLN||COPIES('00'X,WORKLEN-4)                             /*COPY*/\n                                                                        /*COPY*/\n  CATNAMET = ''; DNAMET = ''; dsns. = \"\"; dsns.0 = 0                    /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Process FIELDS Variable when Length is provided                   /*COPY*/\n***********************************************************************//*COPY*/\nFLDS_WITH_LENGTH:                                                       /*COPY*/\n  fld. = \"\"; fld.0 = WORDS(FIELDS)/2                                    /*COPY*/\n  DO i=1 TO WORDS(FIELDS)/2                                             /*COPY*/\n     fld.i.nm=LEFT(WORD(FIELDS,(((i-1)*2)+1)),8)                        /*COPY*/\n     fld.i.ln=WORD(FIELDS,(((i-1)*2)+2))                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Process FIELDS Variable when Length is NOT provided               /*COPY*/\n***********************************************************************//*COPY*/\nFLDS_WO_LENGTH:                                                         /*COPY*/\n  fld. = \"\"; fld.0 = WORDS(FIELDS)                                      /*COPY*/\n  DO i=1 TO fld.0                                                       /*COPY*/\n     fld.i.nm = LEFT(WORD(FIELDS,i),8)                                  /*COPY*/\n     PARSE VALUE VER_FNM(fld.i.nm) WITH fld.i.ln fld.i.ty fld.i.rp      /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY IGGFNM */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n      Verify Field Name and Set Attributes (from SYS1.MACLIB(IGGCSI))   /*COPY*/\n***********************************************************************//*COPY*/\nVER_FNM:                                                                /*COPY*/\nARG fnm .                                                               /*COPY*/\n  SELECT               /* Validate Field name and assign attributes   *//*COPY*/\n    WHEN fnm = \"ACTOKEN\"  THEN RETURN 36   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"AKEYPOS\"  THEN RETURN 2    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"AMDCIREC\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"AMDKEY\"   THEN RETURN 4    \"R\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"ASSOCSYM\" THEN RETURN 45   \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"ATTR1\"    THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"ATTR2\"    THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"BUFSIZE\"  THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"CATTR\"    THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"COMPIND\"  THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"COMUDSIZ\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"DATACLAS\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"DEVTYP\"   THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"DSCBTTR\"  THEN RETURN 3    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"DSCRDT2\"  THEN RETURN 4    \"MX\" \"N\"                     /*COPY*/\n    WHEN fnm = \"DSEXDT2\"  THEN RETURN 4    \"MX\" \"N\"                     /*COPY*/\n    WHEN fnm = \"ENTYPE\"   THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"ENTNAME\"  THEN RETURN 44   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"EXCPEXIT\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"FILESEQ\"  THEN RETURN 2    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"GDGALTDT\" THEN RETURN 4    \"MX\" \"N\"                     /*COPY*/\n    WHEN fnm = \"GDGATTR\"  THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"GDGLIMIT\" THEN RETURN 1    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"GENLEVEL\" THEN RETURN 4    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"HARBA\"    THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"HARBADS\"  THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"HIKEYV\"   THEN RETURN \"VL\" \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"HKRBA\"    THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"HURBA\"    THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"HURBADS\"  THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"ITYPEXT\"  THEN RETURN 1    \"BS\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"LOGPARMS\" THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LOGSTRID\" THEN RETURN 26   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LOKEYV\"   THEN RETURN \"VL\" \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"LRECL\"    THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LTBACKDT\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"MGMTCLAS\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"NAME\"     THEN RETURN 44   \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOBLKTRK\" THEN RETURN 2    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOBYTAU\"  THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOBYTTRK\" THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOEXTNT\"  THEN RETURN 1    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NOTRKAU\"  THEN RETURN 2    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"NVSMATTR\" THEN RETURN 1    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"OPENIND\"  THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"OWNERID\"  THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"PASSATMP\" THEN RETURN 2    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"PASSPRMT\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"PASSWORD\" THEN RETURN 32   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"PHYBLKSZ\" THEN RETURN 4    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"PRIMSPAC\" THEN RETURN 3    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RECVTIME\" THEN RETURN 8    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RECVTIMG\" THEN RETURN 8    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RGATTR\"   THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"RLSBWO\"   THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"RLSFLAGS\" THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"SCONSPAC\" THEN RETURN 3    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"SECFLAGS\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"SPACOPTN\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"STORCLAS\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"STRIPCNT\" THEN RETURN  2   \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"TYPE\"     THEN RETURN 1    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"UDATASIZ\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"USVRMDUL\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"USERAREC\" THEN RETURN \"VL\" \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VOLSER\"   THEN RETURN 6    \"CH\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"VOLFLG\"   THEN RETURN 1    \"BS\" \"Y\"                     /*COPY*/\n    WHEN fnm = \"VSAMREUS\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VSAMSTAT\" THEN RETURN 46   \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"VSAMTYPE\" THEN RETURN 2    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VVRNFLGS\" THEN RETURN 2    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"XACIFLAG\" THEN RETURN 1    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"XHARBA\"   THEN RETURN 8    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"XHARBADS\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"XHKRBA\"   THEN RETURN 8    \"F\"  \"Y\"                     /*COPY*/\n    WHEN fnm = \"XHURBADS\" THEN RETURN 8    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"XHURBA\"   THEN RETURN 8    \"F\"  \"Y\"                     /*COPY*/\n /* Tape Library Entry Field Names                                    *//*COPY*/\n    WHEN fnm = \"LCBCONID\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBDEVTP\" THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBDESCR\" THEN RETURN 120  \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBEMPTY\" THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBLIBID\" THEN RETURN 5    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBLOGIC\" THEN RETURN 1    \"B\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBSCRTH\" THEN RETURN 1020 \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBSLOTS\" THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"LCBTHRES\" THEN RETURN 1020 \"F\"  \"N\"                     /*COPY*/\n /* Tape Volume Entry Field Names                                     *//*COPY*/\n    WHEN fnm = \"VCBCHKPT\" THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBCRDT\"  THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBDEVTP\" THEN RETURN 4    \"F\"  \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBEDATE\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBERRST\" THEN RETURN 2    \"BS\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBEXPDT\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBLIBNM\" THEN RETURN 44   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBLOC\"   THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBMOUNT\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBOWNER\" THEN RETURN 64   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBSGRP\"  THEN RETURN 8    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBSHELF\" THEN RETURN 32   \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBUATTR\" THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBWPROT\" THEN RETURN 1    \"CH\" \"N\"                     /*COPY*/\n    WHEN fnm = \"VCBWRITE\" THEN RETURN 10   \"CH\" \"N\"                     /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     CALL SET_MSG ,\"Unsupported Field Name: '\"fnm\"'\",\"YES\"              /*COPY*/\n  END                                                                   /*COPY*/\nEXIT 8                                                                  /*COPY*/\n/**********************************************************************\n      Pull out Dataset Name information\n***********************************************************************/\nPARSE_DSN:\n  PARSE VALUE rest WITH CSICFLG  +1 CSICTYPE +1 CSICNAME +44 CSICRETM,\n                     +2 CSICRETR +1 CSICRETN +1 rest\n  CSICFLG  = C2X(CSICFLG )\n  CSICRETM = C2D(CSICRETM)\n  CSICRETR = C2D(CSICRETR)           /* Catalog return reason code    */\n  CSICRETN = C2D(CSICRETN)           /* Catalog return code           */\nRETURN\n/**********************************************************************\n      Determine any additional attributes\n***********************************************************************/\nSET_ATTR1:\nARG ATTR1 .\n  IF ATTR1 = \"\" THEN RETURN \"\"; ELSE ATTR1 = X2B(C2X(ATTR1))\n  IF SUBSTR(ATTR1,1,1) THEN _attr1_ = \"SPEED\"; ELSE _attr1_ = \"\"\n  IF SUBSTR(ATTR1,3,1) THEN _attr1_ = _attr1_ \"RUS\"\n  IF SUBSTR(ATTR1,4,1) THEN _attr1_ = _attr1_ \"ERASE\"\nRETURN STRIP(_attr1_)\n/**********************************************************************\n      Determine VSAM Share options\n***********************************************************************/\nSET_ATTR2:\nARG ATTR2 .\n  IF ATTR2 = \"\" THEN RETURN \"\"\n     ELSE ATTR2 = X2B(C2X(ATTR2))\n  shr_rgn = SUBSTR(ATTR2,1,1)*2 + SUBSTR(ATTR2,2,1) + 1\n  shr_sys = SUBSTR(ATTR2,3,1)*2 + SUBSTR(ATTR2,4,1) + 1\nRETURN \"SHR(\"shr_rgn shr_sys\")\"\n/**********************************************************************\n      Determine how SPACE was allocated\n***********************************************************************/\nSET_SPACOPTN:\nARG SPACOPTN .\n  SELECT\n     WHEN SPACOPTN = '01000000'B THEN option = 'RECORDS'\n     WHEN SPACOPTN = '10000000'B THEN option = 'TRK'\n     WHEN SPACOPTN = '11000000'B THEN option = 'CYL'\n     WHEN SPACOPTN = '11111111'B THEN RETURN \"\"\n  OTHERWISE;                          option = '?????????'; END\nRETURN option\"(\"C2D(fld.6.list) C2D(fld.7.list)\")\"\n/**********************************************************************\n      Determine any additional VSAM attributes\n***********************************************************************/\nSET_VSAMTYPE:\nARG VSAMTYPE .\n  IF VSAMTYPE = \"\"        THEN RETURN \"\"\n  VSAMTYPE = X2B(C2X(VSAMTYPE)); options = \"\"\n  IF SUBSTR(VSAMTYPE, 1,1) THEN KSDS  = TRUE; ELSE KSDS  = FALSE\n  IF SUBSTR(VSAMTYPE, 7,1) THEN RRDS  = TRUE; ELSE RRDS  = FALSE\n  IF SUBSTR(VSAMTYPE, 8,1) THEN options = options \"SPND\"\n  IF SUBSTR(VSAMTYPE,15,1) THEN LDS   = TRUE; ELSE LDS   = FALSE\n  IF SUBSTR(VSAMTYPE,16,1) THEN VRRDS = TRUE; ELSE VRRDS = FALSE\nRETURN options\n/**********************************************************************\n      Expand CSICTYPE Value for Dataset Type\n***********************************************************************/\nSET_DSN_TYPE:\n  SELECT                   /* ASSIGN ENTRY TYPE NAME  */\n     WHEN CSICTYPE = 'A' THEN DTYPE = 'NONVSAM '\n     WHEN CSICTYPE = 'B' THEN DTYPE = 'GDG     '\n     WHEN CSICTYPE = 'C' THEN DTYPE = 'CLUSTER '\n     WHEN CSICTYPE = 'D' THEN DTYPE = 'DATA    '\n     WHEN CSICTYPE = 'G' THEN DTYPE = 'AIX     '\n     WHEN CSICTYPE = 'H' THEN DTYPE = 'GDS     '\n     WHEN CSICTYPE = 'I' THEN DTYPE = 'INDEX   '\n     WHEN CSICTYPE = 'L' THEN DTYPE = 'TAPELIB '\n     WHEN CSICTYPE = 'R' THEN DTYPE = 'PATH    '\n     WHEN CSICTYPE = 'U' THEN DTYPE = 'UCAT    '\n     WHEN CSICTYPE = 'W' THEN DTYPE = 'TAPEVOL '\n     WHEN CSICTYPE = 'X' THEN DTYPE = 'ALIAS   '\n  OTHERWISE;                  DTYPE = '        '; END\nRETURN DTYPE\n/**********************************************************************\n      Process CSI Information about VSAM Cluster\n***********************************************************************/\nPROCESS_CLUSTER:\n  cinx = STRIP(TRANSLATE(CSICNAME,'_','.'),\"T\")\n  DS_CHAR.cinx.NAME = STRIP(CSICNAME,\"T\")\n  DS_CHAR.cinx.TYPE = STRIP(_type,\"T\")\n  cnt = CLUSTERS.0 + 1; CLUSTERS.0 = cnt\n  CLUSTERS.cnt.NAME = CSICNAME\n  CLUSTERS.cnt.RELATE.0 = fld.15.totln/fld.15.ln\n  DO i = 1 TO CLUSTERS.cnt.RELATE.0\n     CLUSTERS.cnt.RELATE.i.NAME =,\n         SUBSTR(fld.15.list,((i-1)*fld.15.ln)+1,fld.15.ln)\n  END\n IF LENGTH(fld.2.list) > 2 THEN DO\n    _sms_ = TRUE\n    IF LENGTH(fld.4.list) > 2 THEN DS_CHAR.cinx.CHAR =,\n                             \"STORCLAS(\"SUBSTR(fld.2.list,3)\")\",\n                             \"MGMTCLAS(\"SUBSTR(fld.3.list,3)\")\",\n                             \"DATACLAS(\"SUBSTR(fld.4.list,3)\")\"\n    ELSE DS_CHAR.cinx.CHAR = \"STORCLAS(\"SUBSTR(fld.2.list,3)\")\",\n                             \"MGMTCLAS(\"SUBSTR(fld.3.list,3)\")\"\n   END\n ELSE _sms_ = FALSE\n x = SET_VSAMTYPE(fld.10.list)\n IF LDS THEN DS_CHAR.cinx.INXD = \"LIN\"\nRETURN\n/**********************************************************************\n      Process CSI Information about VSAM Data portion\n***********************************************************************/\nPROCESS_DATA:\n  dsinx = STRIP(TRANSLATE(CSICNAME,'_','.'),\"T\")\n  DS_CHAR.dsinx.TYPE = STRIP(_type,\"T\")\n  IF \u00ac(_sms_) THEN DO\n     y = SUBSTR(fld.1.list,1,fld.1.ln)\n     DO i = 2 TO (fld.1.totln/fld.1.ln)\n        y = y SUBSTR(fld.1.list,((i-1)*fld.1.ln)+1,fld.1.ln)\n     END\n    DS_CHAR.dsinx.CHAR = \"VOLUMES(\"y\") \"\n  END\n  DS_CHAR.dsinx.CHAR = DS_CHAR.dsinx.CHAR || SET_SPACOPTN(fld.5.list),\n           \"CISZ(\"C2D(LEFT(fld.12.list,4))\")\",\n           \"RECSZ(\"C2D(fld.13.list) C2D(RIGHT(fld.12.list,4))\")\"\n  DS_CHAR.dsinx.ATTR = STRIP(SET_ATTR1(fld.8.list) SET_ATTR2(fld.9.list),\n                    || SET_VSAMTYPE(fld.10.list))\nRETURN\n/**********************************************************************\n      Process CSI Information about VSAM Index\n***********************************************************************/\nPROCESS_INDEX:\n  dsinx = STRIP(TRANSLATE(CSICNAME,'_','.'),\"T\")\n  DS_CHAR.dsinx.TYPE = STRIP(_type,\"T\")\n  IF \u00ac(_sms_) THEN DO\n     y = SUBSTR(fld.1.list,1,fld.1.ln)\n     DO i = 2 TO (fld.1.totln/fld.1.ln)\n        y = y SUBSTR(fld.1.list,((i-1)*fld.1.ln)+1,fld.1.ln)\n     END\n    DS_CHAR.dsinx.CHAR = \"VOLUMES(\"y\") \"\n  END\n  DS_CHAR.dsinx.CHAR = DS_CHAR.dsinx.CHAR || SET_SPACOPTN(fld.5.list),\n           \"CISZ(\"C2D(LEFT(fld.12.list,4))\")\",\n           \"RECSZ(\"C2D(fld.13.list) C2D(RIGHT(fld.12.list,4))\")\"\n  DS_CHAR.dsinx.ATTR = SET_ATTR1(fld.9.list)\n  DS_CHAR.cinx.INXD = \"IXD\"\n  DS_CHAR.cinx.KEYS = \"KEYS(\"C2D(RIGHT(fld.11.list,2)),\n                             C2D(LEFT(fld.11.list,2))\")\"\nRETURN\n/**********************************************************************\n      Process CSI Information about VSAM AIX\n***********************************************************************/\nPROCESS_AIX:\n  cnt = AIX.0 + 1; AIX.0 = cnt\n  cinx = STRIP(TRANSLATE(CSICNAME,'_','.'),\"T\")\n  DS_CHAR.cinx.NAME = STRIP(CSICNAME,\"T\")\n  DS_CHAR.cinx.TYPE = STRIP(_type,\"T\"); DS_CHAR.cinx.AIX = cnt\n  AIX.cnt.RELATE.0 = fld.15.totln/fld.15.ln\n  DO i = 1 TO AIX.cnt.RELATE.0\n     AIX.cnt.RELATE.i.NAME = SUBSTR(fld.15.list,((i-1)*fld.15.ln)+1,fld.15.ln)\n  END\n  IF SUBSTR(X2B(C2X(fld.8.list)),2,1) THEN\n       DS_CHAR.cinx.CHAR = \"UNQK\"\n  ELSE DS_CHAR.cinx.CHAR = \"NUNQK\"\n  IF SUBSTR(X2B(C2X(fld.14.list)),1,1) THEN\n       DS_CHAR.cinx.CHAR = DS_CHAR.cinx.CHAR \"UPG\"\n  ELSE DS_CHAR.cinx.CHAR = DS_CHAR.cinx.CHAR \"NUPG\"\nRETURN\n/**********************************************************************\n      Process CSI Information about VSAM Path\n***********************************************************************/\nPROCESS_PATH:\n  dsinx = STRIP(TRANSLATE(CSICNAME,'_','.'),\"T\")\n  DS_CHAR.dsinx.TYPE = STRIP(_type,\"T\")\n  DS_CHAR.dsinx.CHAR = \"PATHENTRY(\"DS_CHAR.cinx.NAME\")\"\nRETURN\n/**********************************************************************\n      Output results for testing.\n***********************************************************************/\nDO_OUTPUT:\n  DO i = 1 TO CLUSTERS.0\n     IF i > 1 THEN SAY \"\"\n     cl_dsn = CLUSTERS.i.NAME; cl_inx = STRIP(TRANSLATE(cl_dsn,'_','.'),\"T\")\n     SAY RIGHT(DS_CHAR.cl_inx.TYPE,7) cl_dsn,\n         STRIP(DS_CHAR.cl_inx.CHAR DS_CHAR.cl_inx.INXD DS_CHAR.cl_inx.KEYS)\n     DO j = 1 TO CLUSTERS.i.RELATE.0\n       cr_dsn = CLUSTERS.i.RELATE.j.NAME\n       cr_inx = STRIP(TRANSLATE(cr_dsn,'_','.'),\"T\")\n       IF DS_CHAR.cr_inx.TYPE = \"AIX\" THEN DO\n          aix_inx = DS_CHAR.cr_inx.AIX\n          DO k = 1 TO AIX.aix_inx.RELATE.0\n             ar_dsn = AIX.aix_inx.RELATE.k.NAME\n             ar_inx = STRIP(TRANSLATE(ar_dsn,'_','.'),\"T\")\n             IF ABBREV(DS_CHAR.ar_inx.TYPE,\"CLUSTER\") THEN LEAVE k\n          END\n          aix_cl = STRIP(AIX.aix_inx.RELATE.k.NAME)\n          SAY RIGHT(DS_CHAR.cr_inx.TYPE,7) cr_dsn \"RELATE(\"aix_cl\")\",\n              DS_CHAR.cr_inx.CHAR DS_CHAR.cr_inx.KEYS\n          IF DS_CHAR.cl_inx.CHAR \u00ac= \"\" THEN SAY LEFT(\"\",53)DS_CHAR.cl_inx.CHAR\n          DO k = 1 TO AIX.aix_inx.RELATE.0\n             ar_dsn = AIX.aix_inx.RELATE.k.NAME\n             ar_inx = STRIP(TRANSLATE(ar_dsn,'_','.'),\"T\")\n             SELECT\n               WHEN ABBREV(DS_CHAR.ar_inx.TYPE,\"CLUSTER\") THEN NOP\n               WHEN ABBREV(DS_CHAR.ar_inx.TYPE,\"PATH\")    THEN SAY,\n                  RIGHT(DS_CHAR.ar_inx.TYPE,7) ar_dsn DS_CHAR.ar_inx.CHAR\n             OTHERWISE\n                 SAY RIGHT(DS_CHAR.ar_inx.TYPE,7) ar_dsn,\n                     DS_CHAR.ar_inx.CHAR DS_CHAR.ar_inx.ATTR\n             END\n          END\n         END\n       ELSE SAY RIGHT(DS_CHAR.cr_inx.TYPE,7) cr_dsn,\n                DS_CHAR.cr_inx.CHAR DS_CHAR.cr_inx.ATTR\n     END\n  END\nRETURN\n/**********************************************************************\n      An error occured when calling IGGCSI00, dislay MODRSNRC, the\n         parms used to call it, and the WORK area returned.\n***********************************************************************/\nDISPLAY_IGGCSI_ERROR:\n  SAY  \"IGGCSI Error!  LINK RC=\"RC \"MOD=\"LEFT(MODRSNRC,2),\n       \"RSN=\"C2D(SUBSTR(MODRSNRC,3,1)) \"RC=\"C2D(SUBSTR(MODRSNRC,4,1))\n  SAY  \"_______________________ CSIFIELD ______________________\"\n  SAY  CSIFIELD\n  SAY  \"________________________ DWORK ________________________\"\n  SAY  DWORK\n  SAY  \"_______________________________________________________\"\nEXIT RC\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VW": {"ttr": 137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x05\\x003\\x01\\x16!\\x8f\\x01\\x17'\\x1f\\x13\\x13\\x02\\x01\\x01\\xd5\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@\"", "ispf": {"version": "02.05", "flags": 0, "createdate": "2016-08-05T00:00:00", "modifydate": "2017-09-28T13:13:33", "lines": 513, "newlines": 469, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This REXX/ISPF Macro supports full screen Point-N-Shoot. To improve\n        this functionality, assign it to a PFKey, add it as an ISPF CMD,\n        or, better yet, do both! If this is envoked as an ISPF Macro and\n        a valid dataset is not passed (via PARM or Cursor Position), it\n        will view the current DSN or member, if one is passed.\n\n   This REXX/ISPF MACRO supports multiple VIEW levels, so you may\n        VIEW a dataset from within another.\n\n   This REXX/ISPF MACRO supports member list patern matching, i.e.  If\n        it is envoked with a DSN of highlev.lowlev(AB*) it will display\n        a member list for the PDS of all members starting with AB.  If\n        it is envoked with a DSN of highlev.lowlev(AB%) it will display\n        a member list for the PDS of all members starting with AB and are\n        three characters in length.\n\n                       --- EXAMPLE as TSO CMD ---\nTSO <%>VW <dsname> <IMAcro(macro_name)> <TEST(TraceOption)> <VOLSER(volser)>,\n                   <FORMAT(blank|ASCII|UTF8)>\n                     --- EXAMPLE as ISPF Macro ---\n    <%>VW <dsname> <IMAcro(macro_name)> <TEST(TraceOption)> <VOLSER(volser)>,\n                   <FORMAT(blank|ASCII|UTF8)>\n<TSO> <%>VW -H -- To display help for this REXX/ISPF Macro\n\n  Arguments: dsname      - Dataset to View\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                  IMACRO - Initial ISPF VIEW Macro     default: ALIASMC\n                  FORMAT - Charactor encoding          default: blank\n                           blank (EBCDIC), ASCII, or UTF8\n                    TEST - Used to control traces\n                  VOLSER - Volume Serial Number to display DSNs for.\n                           default:  blank (display cataloged DSNs only)\n      Files: The EXEC VIEWs the DSN provided as an argument\nOther EXECS: None\n\nEXEC History\n\nEXEC/MACRO Name: VW\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 3.14\n                 FERGUSON AL (HUL2353) from version 3.00\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 30DEC92\n        History: 28SEP17 - v5.00 - More Point-N-Shoot Fixes.\n                 09AUG17 - v4.90 - Add support for ASCII & UTF8 formats\n                 21JUN17 - v4.82 - Cleanup point & shoot, plus add\n                           support for ZCURWID ISPF System Variable.\n                 19MAY17 - v4.77 - Keep Cursor Col & Advance Row when\n                           invoked as Macro.\n                 13MAR17 - v4.65 - More Point-N-Shoot corrections.\n                 06FEB17 - v4.50 - Fix Point-N-Shoot math.\n                 06FEB17 - v4.42 - Pick up updated version of ERRINFO\n                           Common Code routines.\n                 01FEB17 - v4.40 - Mass update for Error Handling Fixes.\n                 31JAN17 - v4.39 - Update all REXXes with latest common\n                           routines via %CCMASS\n                 26JAN17 - v4.38 - Tweak Point & Shoot logic.\n                 23NOV16 - v4.30 - Tweak Point-n-Shoot math\n                 22NOV16 - v4.15 - Rewrite of Point and shoot section to\n                           make work as an ISPF Command when not in an\n                           edit session.\n                 10AUG16 - v4.07 - More Changes to support DDs.\n                 05AUG16 - v4.03 - Add support for DDs vs DSNs\n                 04MAY16 - v3.14 - Use IBM Default Edit/View PANEL vs\n                           custom ED01 Panel.\n                 14FEB11 - v3.10 - Add point & Shoot support for USS PATHs.\n                 13MAR09 - v3.00 - Add support for USS Files\n                 24JUL96 - v1.00 - VIEW REXX EXEC/ISPF Macro based off\n                           ED REXX EXEC/ISPF Macro v2.49\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG DsName InParms\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF ABBREV('.',DsName)          THEN DO; DsName=\"\"; CALL INVOKE_AS_MACRO; END\nIF DsName = ''                 THEN EXIT\n   ELSE                             CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0 12 14 16 20'\n  ADDRESS \"ISPEXEC\" \"VIEW\" PROCESS_DSNAME(DsName) \"MACRO(\"IMACRO\")\" FORMAT\nSELECT\n  WHEN RC = 0  THEN\n    IF IsMacro THEN ADDRESS \"ISREDIT\" \"CURSOR =\"RowPos+1 CurPos\n  WHEN RC = 14 THEN CALL SET_MSG 'Dataset in USE!', DsName '--' ZERRLM\n  WHEN RC = 16 THEN CALL SET_MSG \"No Members in PDS!\", DsName '--' ZERRLM\nOTHERWISE\n   CALL SET_MSG \"Can't %VW this DSN!\", DsName '--' ZERRLM, \"YES\"\n   ExitErr=020\nEND\n\nMsgStat=MSG(MsgStat)\nEXIT ExitErr\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This INITIALIZEs any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */\n  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */\n  JName=MVSVAR(\"SYMDEF\",\"JOBNAME\")  /* Get JOB Name                   */\n  ADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL)\"\n  SELECT              /* Support ISPF 3.4/DSLIST VOLSERs              */\n    WHEN RC \u00ac= 0                   THEN NOP\n    WHEN ABBREV(\"*ALIAS\", ZDLVOL)  THEN InParms=InParms \"VOLSER()\"\n    WHEN ABBREV(DsName, \"'\"ZDLDSN) THEN InParms=InParms \"VOLSER(\"ZDLVOL\")\"\n  OTHERWISE; NOP; END\n                                    /* Initialize NonPositional parms */\n  ValidParms=\"FORMAT() IMACRO(%ALIASMC) TEST(O) VOLSER()\"\n  MatchLength=3                     /* NPParms match first # chars    */\n  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitErr=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  IF VOLSER = \"\" THEN ADDRESS \"ISPEXEC\" \"VGET (VOLSER) SHARED\"\n  response=\"\"; member=\"\"\n  IF IsMacro \u00ac= TRUE THEN IsMacro=FALSE\n\n  SELECT\n    WHEN FORMAT = \"\"            THEN NOP\n    WHEN ABBREV(\"ASCII\",FORMAT) THEN FORMAT=\"ASCII\"\n    WHEN ABBREV(\"UTF8\", FORMAT) THEN FORMAT=\"UTF8\"\n  OTHERWISE;                         FORMAT=\"\"     ; END\n\nRETURN\n/* COPY PNTNSHOT */\n/********************************************************************** /*COPY*/\n             If no arguments, was it envoked as a MACRO                 /*COPY*/\n**********************************************************************/ /*COPY*/\nINVOKE_AS_MACRO:                                                        /*COPY*/\n  ADDRESS \"MVS\" \"SUBCOM ISREDIT\"                                        /*COPY*/\n  IF RC \u00ac= 0 THEN RETURN                                                /*COPY*/\n  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"       /* ISPF errors     */ /*COPY*/\n  ADDRESS \"ISREDIT\" \"MACRO (DsName InParms) NOPROCESS\"                  /*COPY*/\n  IF RC = 0 THEN DO                                                     /*COPY*/\n     IsMacro=TRUE                                                       /*COPY*/\n     ADDRESS \"ISREDIT\" \"(PdsDsn) = DATASET\"                             /*COPY*/\n     ADDRESS \"ISREDIT\" \"(RowPos,CurPos) = CURSOR\"                       /*COPY*/\n     IF DsName = \"\" & RowPos = 1 & CurPos = 0 THEN DsName=\"'\"PdsDsn\"'\"  /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO; IsMacro=FALSE; PdsDsn=\"\"; END                                /*COPY*/\n  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/\n                                                                        /*COPY*/\n  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/\n  IF ABBREV(PDS,\"'\")           THEN PDS=STRIP(PDS,\"T\",\"'\")\"'\"           /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN DsName = \"\"           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/\n    WHEN ABBREV(DsName,\"DD:\")  THEN NOP                                 /*COPY*/\n    WHEN ABBREV(DsName,\"dd:\")  THEN NOP                                 /*COPY*/\n    WHEN POS(\"/\",DsName) > 0   THEN NOP                                 /*COPY*/\n    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"          THEN DsName=\"'\"PdsDsn\"(\"DsName\")'\"       /*COPY*/\n  OTHERWISE;                        NOP; END                            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_POINT_N_SHOOT:                                                       /*COPY*/\n  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/\n  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/\n    WHEN POS(\"/\",PdsDsn)  > 0 THEN RETURN \"'\"PdsDsn\"'\"                  /*COPY*/\n    WHEN PdsDsn \u00ac= \"\"         THEN RETURN PdsDsn                        /*COPY*/\n  OTHERWISE;                       RETURN \"\"; END                       /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/\n    WHEN POS(\"='\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"='\" word . \"'\"                        /*COPY*/\n    WHEN POS(\"DSN=\",word) > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH . \"DSN=\" word . \",\"                     /*COPY*/\n    WHEN POS(\"=\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH   \"=\" word . \",\"                        /*COPY*/\n    WHEN POS(\"''\",word)   > 0 THEN                                      /*COPY*/\n       PARSE VALUE word    WITH  \"''\" word . \"'\"                        /*COPY*/\n    WHEN ABBREV(word,'\"//')   THEN                                      /*COPY*/\n       PARSE VALUE word    WITH \"//\" word . '\"'                         /*COPY*/\n    WHEN POS(\"(\",word)    > 0 THEN                                      /*COPY*/\n       PARSE VALUE word\" \" WITH   \"(\" word . \")\"                        /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ABBREV(word,\"DD:\")                    THEN DsNme=word          /*COPY*/\n    WHEN ABBREV(word,\"dd:\")                    THEN DsNme=word          /*COPY*/\n    WHEN INDEX(word, \"/\")               > 0    THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"STRIP(word,,\"'\")\"'\") = 'MEMBER NOT FOUND' THEN       /*COPY*/\n         DsNme=\"'\"STRIP(word,,\"'\")\"'\"                                   /*COPY*/\n    WHEN SYSDSN(\"'\"PdsDsn\"(\"word\")'\")   = 'OK' THEN                     /*COPY*/\n         DsNme=\"'\"PdsDsn\"(\"word\")'\"                                     /*COPY*/\n    WHEN PdsDsn                        \u00ac= ''   THEN DO                  /*COPY*/\n         DsNme=\"'\"PdsDsn\"'\"; filter=word                                /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; DsNme = \"\"; END                                            /*COPY*/\nRETURN DsNme                                                            /*COPY*/\n/********************************************************************** /*COPY*/\n   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/\n**********************************************************************/ /*COPY*/\nGET_CURRENT_LINE:                                                       /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)\"        /*COPY*/\n  ADDRESS \"ISPEXEC\" \"VGET (ZCURDEP ZCURWID)\"                            /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC = 0 & \u00ac(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/\n    WHEN IsMacro                                THEN DO                 /*COPY*/\n       ADDRESS \"ISREDIT\" \"(Line) = LINE\" RowPos                         /*COPY*/\n       RETURN Line                                                      /*COPY*/\n      END                                                               /*COPY*/\n    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/\n         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/\n       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/\n       IF ABBREV(LstLn,\"***\")                   THEN Wdth=ZSCREENW+8    /*COPY*/\n          ELSE                                       Wdth=ZSCREENW      /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/\n       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/\n       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/\n     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/\n  END                                                                   /*COPY*/\n  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/\nRETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth),\" \",\",\")         /*COPY*/\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN RC \u00ac= 0                   THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/\n       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/\n        ELSE                           ZERRALRM='NO'                    /*COPY*/\n     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                     /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Process DsName and return ISPF Allocation Type\n***********************************************************************/\nPROCESS_DSNAME:\nPARSE ARG PDS '(' member ')' .\n  SELECT\n    WHEN ABBREV(PDS, \"DD:\")   |,\n         ABBREV(PDS, \"dd:\")   THEN DO\n       ADDRESS \"ISPEXEC\" \"LMINIT DATAID(id) DDNAME(\"SUBSTR(PDS,4)\") ENQ(SHRW)\"\n       IF member = \"\" THEN         _type_ = \"DATAID(\"id\")\"\n          ELSE                     _type_ = \"DATAID(\"id\") MEMBER(\"member\")\"\n      END\n    WHEN INDEX(PDS,\"/\") > 0   THEN _type_ = \"FILE(PDS)\"\n    WHEN INDEX(PDS,\"'\") > 0   &,\n         (member = \"\")        THEN _type_ = \"DATASET(\"STRIP(PDS,\"T\",\"'\")\"')\"\n    WHEN INDEX(PDS,\"'\") > 0   THEN\n         _type_ = \"DATASET(\"STRIP(PDS,\"T\",\"'\")\"(\"member\")')\"\n    WHEN (member = \"\")        THEN _type_ = \"DATASET(\"PDS\")\"\n  OTHERWISE;                       _type_ = \"DATASET(\"PDS\"(\"member\"))\"; END\n  IF VOLSER \u00ac= \"\" THEN _type_ = _type_ \"VOLUME(\"VOLSER\")\"\nRETURN _type_\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno=sigl                      /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults=\"\"                                                     /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults=STRIP(eresults \"NL ===>\" eresult)                   /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl=\"\"                                                         /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN POS(\"=\",srcl)             > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n             emsg='No available ERROR description.'                     /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/\n             emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                            /*COPY*/\n  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/\n  IF POS(\"IN VARIABLE SYSREASON\",emsg) > 0          THEN                /*COPY*/\n             emsg=\"SYSREASON: '\"SYSREASON\"'\"                            /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/\n     ELSE                   ExitErr=RC                                  /*COPY*/\n  erc=ExitErr           /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult.=\"\";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/\n  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/\n  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults=2 TO eresult.0                                            /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitErr                        /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XR": {"ttr": 85, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x17%O\\x100\\x01)\\x01.\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 297, "newlines": 302, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO EXCLUDEs a rows containing a string starting at the\n        current cursor possition until the end of the dataset.  Also\n        works with selected lines.  XR is the opposite of AR.\n\n                           --- EXAMPLE ---\n<%>XR xcludarg <TEST(TraceOption)>\n<%>XR -H -- To display help for this ISPF Macro\n\n  Arguments: xcludarg    - Normal ISPF EXCLUDE command arguments less\n                           leading 'X' or 'EXCLUDE' command.\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n      Files: Current EDIT dataset\nOther EXECS: none\n\nEXEC History\n\nEXEC/MACRO Name: XR - eXclude Rest\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.14\n                 ALBERT HULSEBOSCH (TTECAH1)\n         Writen: 17JUN93\n        History: 06FEB17 - v1.16 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.15 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.14 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 18MAY95 - v1.15 - Update all REXXes with latest\n                           versions of commom routines.  This was done\n                           via %CCMASS\n                  4NOV93 - v1.11 - Support added for NP-Parms and\n                           search strings with ampersands. Ampersand\n                           support psossible with a hint from Pete V.\n                           (TTECPV1)\n                 15JUL93 - v1.07 - Fix to handle single record SETs\n                 23JUN93 - v1.05 - Maintenance done to include the\n                           latest changes to many COPY members.  This\n                           maintenance done via CCMASS.\n                 17JUN93 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (xcludarg) NOPROCESS\"\nPARSE UPPER VALUE xcludarg WITH xcludarg 'TEST(' TEST ')' .\n\nCALL INITIALIZE_THIS_REXX\nIF xcludarg = '-H' THEN CALL DISPLAY_HELP\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 4 16';ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nIF RC = 0 THEN DO\n    ok='0';ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZFRANGE\"\n    ok='0';ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLRANGE\"\n    ok='0';ADDRESS \"ISREDIT\" \"RESET COMMAND\"\n  END\nELSE DO\n    ok='0';ADDRESS \"ISREDIT\" \"(first) = LINENUM .ZCSR\"\n    ok='0';ADDRESS \"ISREDIT\" \"(last)  = LINENUM .ZLAST\"\nEND\nok='0';ADDRESS \"ISREDIT\" \"LABEL\" first \"= .FLINE\"\n\nIF first \u00ac= last THEN DO\n    ok='0';ADDRESS \"ISREDIT\" \"LABEL\" last \"= .LLINE\"\n    last_label = \".LLINE\"\n  END\nELSE last_label = \".FLINE\"\n\nIF INDEX(xcludarg, '&') > 0 THEN xcludarg = AMPER_HANDLING(xcludarg)\nok='0 4 8 20';ADDRESS \"ISREDIT\" \"X\" xcludarg \".FLINE\" last_label \"ALL\"\n\nok='0 4';ADDRESS \"ISREDIT\" \"(var1,var2) = EXCLUDE_COUNTS\"\n\nsuccess = STRIP(var1,\"L\",\"0\")\nIF success = '' THEN success = '0'\nlines = STRIP(var2,\"L\",\"0\")\nIF lines = '' THEN lines = '0'\nCALL SET_MSG success \"chars excluded.\", success ,\n             \"occurances have been excluded on\" lines \"lines.\"\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0\n\n  next_line_RC = 0\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY AMPERHAN */\n/********************************************************************** /*COPY*/\n  Handle Ampersands in ISREDIT strings within Macros Assumes String     /*COPY*/\n     being processed containes an ampersand. To Ensure this use:        /*COPY*/\n  IF INDEX(string,'&') > 0 THEN string = AMPER_HANDLING(string)         /*COPY*/\n***********************************************************************//*COPY*/\nAMPER_HANDLING: PROCEDURE                                               /*COPY*/\nARG Process                                                             /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN SUBSTR(Process,1,1) = \"'\" THEN Process = STRIP(Process,\"B\",\"'\") /*COPY*/\n   WHEN SUBSTR(Process,1,1) = '\"' THEN Process = STRIP(Process,\"B\",'\"') /*COPY*/\n  OTHERWISE; NOP; END                                                   /*COPY*/\nRETURN \"X'\"C2X(Process)\"'\"                                              /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n/* COPY SETMSG */\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZSTART": {"ttr": 87, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x13\\x01\\x16!\\x7f\\x01\\x17%O\\x100\\x01\\x8e\\x01L\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2016-08-04T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 398, "newlines": 332, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX reads your personal ZSTART.INPUT file and saves it into the\n      ISPF ZSTART startup Variable.\n\n                           --- EXAMPLE ---\nTSO <%>ZSTART <TEST(TraceOption)>\nTSO <%>ZSTART -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: USERID().ZSTART.INPUT\nOther EXECS: CALLS ED (using ZSTRTMAC Initial Macro) & SHOWVAR\n\nEXEC History\n\n REXX EXEC Name: SETZSTRT\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 04AUG16\n        History: 23AUG17 - v1.29 - Refactoring & STEM VAR Math fixes.\n                 06FEB17 - v1.19 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.18 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.17 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 28SEP16 - v1.14 - Add 256 Character Length Check\n                           before saving.\n                 16AUG16 - v1.09 - First version ready for\n                           non-Techie users.\n                 04AUG16 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nPARSE ARG InParms            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL ALLOC_ZSTART.INPUT\nx = ED('ZSTART.INPUT IMACRO(ZSTRTMAC)')\n\nIF x = 0 THEN CALL PROCESS_ZSTART.INPUT\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-Positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\n  ZSTART = \"\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Check for and allocate ZSTART.INPUT file\n***********************************************************************/\nALLOC_ZSTART.INPUT:\n  IF SYSDSN(\"ZSTART.INPUT\") = \"OK\" THEN RETURN\n  ok='0'\n    ADDRESS \"TSO\" \"ALLOC DD(ZSTART) DSN(ZSTART.INPUT) NEW REUSE CATALOG\",\n           \"TRACKS SPACE(1,1) DSORG(PS) RECFM(V B) LRECL(2050) BLKSIZE(0)\"\n    ADDRESS \"TSO\" \"FREE DD(ZSTART)\"\nRETURN\n/**********************************************************************\n      Read ZSTART.INPUT file and set ZSTART ISPF Variable\n***********************************************************************/\nPROCESS_ZSTART.INPUT:\n  ok='*';ADDRESS \"TSO\" \"ALLOC DD(ZSTART) DSN(ZSTART.INPUT) SHR REUSE\"\n  IF RC = 0 THEN DO\n     ZSTART = \"\"\n     ok='0'\n        ADDRESS \"MVS\" \"EXECIO * DISKR ZSTART (STEM zstart. FINIS\"\n        ADDRESS \"TSO\" \"FREE DD(ZSTART)\"\n     SELECT\n       WHEN zstart.0 = 0                            THEN DO\n          CALL SET_MSG ,\"ZSTART.INPUT is EMPTY.\",\"NO\"\n          ZSTART=\"\"\n         END\n       WHEN zstart.0 = 1 & ABBREV(zstart.1,\"ISPF;\") THEN\n          ZSTART=STRIP(zstart.1)\n       WHEN zstart.0 = 1                            THEN\n          ZSTART=\"ISPF;\"||STRIP(zstart.1)\n       WHEN                ABBREV(zstart.1,\"ISPF;\") THEN DO\n          ZSTART=STRIP(zstart.1)\n          DO i=2 TO zstart.0; ZSTART=ZSTART||STRIP(zstart.i);END\n         END\n     OTHERWISE\n          ZSTART=\"ISPF;\"||STRIP(zstart.1)\n          DO i=2 TO zstart.0; ZSTART=ZSTART||STRIP(zstart.i);END\n     END\n     SELECT\n       WHEN LENGTH(ZSTART) > 256 THEN\n          CALL SET_MSG ,\"ISPF ZSTART Variable Max Length is 256!\",\n                        \"This change would make it:\" LENGTH(ZSTART),\"YES\"\n       WHEN ZSTART \u00ac= \"\"         THEN DO\n          ADDRESS \"ISPEXEC\" \"VPUT (ZSTART) PROFILE\"\n          CALL SHOWVAR \"ZSTART\"\n         END\n     OTHERWISE\n        ok='0 8';ADDRESS \"ISPEXEC\" \"VERASE (ZSTART) PROFILE\"\n     END\n    END\n  ELSE    CALL SET_MSG ,\"Unable to process your ZSTART.INPUT File.\",\"YES\"\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    ADDRESS \"TSO\" \"FREE DD(ZSTART)\"\n    ZISPFRC = ExitError                /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZSTRTMAC": {"ttr": 89, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x13\\x01\\x16\"\\x9f\\x01\\x17%O\\x100\\x01\\x8b\\x01N\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2016-08-16T00:00:00", "modifydate": "2017-09-11T10:30:13", "lines": 395, "newlines": 334, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n   This ISPF MACRO adds the current value of the ZSTART Variable into\n        the current file being EDITted as an ISPF NOTE.\n\n                           --- EXAMPLE ---\n<%>ZSTRTMAC <TEST(TraceOption)>\n<%>ZSTRTMAC -H -- To display help for this ISPF Macro\n\n  Arguments: InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: Currently Edited File\nOther EXECS: NONE\n\nEXEC History\n\nISPF MACRO Name: ZSTRTMAC\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 16AUG16\n        History: 23AUG17 - v1.23 - Refactoring & Handle Long Values\n                           w/o STARTs\n                 06FEB17 - v1.10 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.09 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.08 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 28SEP16 - v1.04 - Pretty up Current ZSTART Value\n                           display by breaking it on ';START's to make\n                           flow better.\n                 16AUG16 - v1.0\n***************************** Rexx ***********************************/\nMsgStat=MSG(\"OFF\")\nADDRESS \"ISREDIT\" \"MACRO (InParms) PROCESS\"\n\nIF WORDPOS(InParms, '-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE(TEST)\nok='0 12';ADDRESS \"ISREDIT\" \"UNNUMBER\"\nok='0';   ADDRESS \"ISREDIT\" \"RESET SPECIAL\"\nok='0';   ADDRESS \"ISREDIT\" \"CAPS OFF\"\n\nok='0 8';ADDRESS \"ISPEXEC\" \"VGET (ZSTART) PROFILE\"\n\nok='0'\nIF RC = 8 THEN CALL DISPLAY_NEW_ZSTART\n   ELSE        CALL DISPLAY_CURRENT_ZSTART\n\nMsgStat=MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-Positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n   Display Help for a new ISPF ZSTART Variable in EDIT NOTE Records\n***********************************************************************/\nDISPLAY_NEW_ZSTART:\n  ADDRESS \"ISREDIT\"\n     \"LINE_AFTER 0 = NOTELINE 'SWAP NEXT;                 \",\n                              \"      <=== Back to Primary Panel'\"\n     \"LINE_AFTER 0 = NOTELINE 'START MYDSNS;              \",\n                              \"      <=== DSLIST Panel of your DSNs'\"\n     \"LINE_AFTER 0 = NOTELINE 'START;A.S.DA PRE **;OWNER\" LEFT(USERID()\";\",7),\n                                    \"<=== SDSF DA Panel of your JOBs'\"\n     \"LINE_AFTER 0 = NOTELINE 'ISPF;                      \",\n                              \"      <=== ISPF Required, Primary Panel'\"\n     \"LINE_AFTER 0 = NOTELINE '\"CENTER(\"Following creates 3 screens.\",70)\"'\"\n     \"LINE_AFTER 0 = NOTELINE '\"CENTER(\"ZSTART not Defined.\",70)\"'\"\nRETURN\n/**********************************************************************\n   Display current ISPF ZSTART Variable Value as an EDIT NOTE Record\n***********************************************************************/\nDISPLAY_CURRENT_ZSTART:\n  IF LENGTH(ZSTART) <= 72 THEN\n     ADDRESS \"ISREDIT\" \"LINE_AFTER 0 = NOTELINE '\"ZSTART\"'\"\n  ELSE DO\n     NotDone=SUBSTR(ZSTART,6)\n     DO UNTIL NotDone = \"\"\n        StartPos=POS(\";START\",NotDone)\n        IF StartPos = 0 THEN StartPos=LENGTH(NotDone)\n        CALL HANDLE_LONG_LINE(SUBSTR(NotDone,1,StartPos))\n        NotDone=SUBSTR(NotDone,StartPos+1)\n     END\n     ADDRESS \"ISREDIT\" \"LINE_AFTER 0 = NOTELINE 'ISPF\"NotDone\";'\"\n  END\n  ADDRESS \"ISREDIT\" \"LINE_AFTER 0 = NOTELINE '\",\n           CENTER(\"Currently ZSTART is\" LENGTH(ZSTART),\n                  \"characters and evaluates to:\",70) \"'\"\nRETURN\n/**********************************************************************\n   Break up lines that exceed 72 Characters\n***********************************************************************/\nHANDLE_LONG_LINE:\nPARSE ARG ThisLn\n  Line.=\"\"; Line.0=0; MaxLnth=72\n  DO i=1 UNTIL ThisLn = \"\"\n     PARSE VALUE REVERSE(LEFT(ThisLn,MaxLnth)) WITH after ';' Line.i\n     IF Line.i = \"\" THEN DO; Line.i=ThisLn; ThisLn=\"\"; END\n     ELSE DO\n        Line.i=REVERSE(Line.i)\";\"\n        ThisLn=STRIP(REVERSE(after)SUBSTR(ThisLn,MaxLnth+1))\n     END\n     MaxLnth=66\n  END\n  DO i=i TO 2 BY -1\n     ADDRESS \"ISREDIT\" \"LINE_AFTER 0 = NOTELINE '\"LEFT(\"\",5) Line.i\"'\"\n  END\n  ADDRESS \"ISREDIT\" \"LINE_AFTER 0 = NOTELINE '\"Line.i\"'\"\nRETURN\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT960/CBT.V500.FILE960.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT960/CBT.V500.FILE960.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}