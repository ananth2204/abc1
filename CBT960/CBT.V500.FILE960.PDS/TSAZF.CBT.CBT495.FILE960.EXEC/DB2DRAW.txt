/***************************** REXX ***********************************
   This ISPF MACRO creates basic SQL queries by retrieving the
        description of a table. You must specify the name of the table
        or view to be queried. You can specify the type of query you
        want to compose, i.e. TYPE(SELECT), TYPE(INSERT), TYPE(LOAD),
        or TYPE(UPDATE).  If you are not running under DB2I you will
        need to specify the SSID of the DB2 subsystem, e.g. SSID(DBS1),
        SSID(DBT1), SSID(DBT2), SSID(DBP1), or SSID(DBP2).

   This ISPF MACRO is based on the DRAW Sample REXX Exec in the IBM
        DB2 for OS/390 REXX Language Support Version 5 manual.

  NOTE: DB2's ADDRESS DSNREXX interface requires the appropriate
        DB2 SDSNLOAD to be in you STEPLIB or TASKLIB Concatination.

                           --- EXAMPLE ---
<%>DB2DRAW table <LINETYPE(DATA|NOTE)> <REXX(TRUE|FALSE)> ,
                 <SSID(DB2_ssid)> <TEST(trace option)>    ,
                 <TYPE(SELECT|INSERT|UPDATE|LOAD)>
<%>DB2DRAW -H -- To display help for this ISPF Macro

  Arguments: table       - The DB2 table to DRAW
             inparms     - Non-Possitional parameters
 ----------------------------- NP-PARMS -------------------------------
                LINETYPE - Insert Draw output as DATALINEs or NOTELINEs
                           default: DATALINE
                    REXX - Use to build DSNREXX format statments
                           default: blank
                    SSID - Specifies the SSID of the DB2 subsystem
                           default: blank
                    TEST - Used to control traces
                    TYPE - The type of statement that DRAW builds
                           default: SELECT

      Files: NONE
Other EXECS: NONE

EXEC History

ISPF MACRO Name: DB2DRAW
         Author: Al Hulsebosch (HUL2353)
         Writen: 11MAY01
        History: 18FEB02 - v1.39 - Check for owner. If none then add the
                           default for that DB2 SSID.
                 04FEB02 - v1.29 - Changes to SSID Verification to
                           handle new SYSNAMEs.
                 01JUN01 - v1.26 - Improved SQL Error handling!
                 17MAY01 - v1.22 - Changes to move DB2 Error handling to
                           common routines.
                 14MAY01 - v1.18 - Add support for REXX Formated output
                           and more cleanup.
                 14MAY01 - v1.15 - Some more prettying up.
                 11MAY01 - v1.0
***************************** Rexx ***********************************/
msgstat = MSG("OFF")
ADDRESS "ISREDIT" "MACRO (table inparms) PROCESS"

CALL INITIALIZE_THIS_REXX
SELECT
  WHEN WORDPOS(table,'-h -H') > 0 THEN CALL DISPLAY_HELP
  WHEN table = ""                 THEN DO
     CALL SET_MSG "No DB2 table!","What DB2 table do you want Drawn?","YES"
     CALL DISPLAY_HELP
    END
  WHEN SSID = ""                  THEN DO
     CALL SET_MSG "No DB2 SSID!","You need to specifya DB2 SSID!","YES"
     CALL DISPLAY_HELP
    END
OTHERWISE;                              UPPER table; END
/* COPY ERRINIT */
/********************************************************************** /*COPY*/
              Initialize ERROR handling                                 /*COPY*/
***********************************************************************//*COPY*/
CALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/
SIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/
SIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/
SIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/
ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"  /* Is ISPEXEC available?       *//*COPY*/
IF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/
    ok='0';ADDRESS "ISPEXEC" "CONTROL ERRORS RETURN"  /* ISPF errors  *//*COPY*/
END                                                                     /*COPY*/
                                                                        /*COPY*/
TRACE(TEST)
ok='*';ADDRESS "ISREDIT" "(LeftBnd,RightBnd) = BOUNDS"
IF REXX THEN LeftBnd=LeftBnd + 1
   ELSE      LeftBnd=LeftBnd + 3
BndSize=RightBnd-LeftBnd
If BndSize > 68 THEN BndSize=68

SELECT     /* Based on RC From ISPF EDIT BOUNDS Command ...          */
  WHEN RC = 0  THEN DO
      ok='*';ADDRESS "ISREDIT" "(ZDest) = LINENUM .ZCSR"
      IF ZDest=0 THEN ZDest=1
    END
  WHEN RC <= 8 THEN DO /* No A or B entered */
      CALL SET_MSG 'Enter "A"/"B" line cmd',,
                   'DRAW requires an "A" or "B" line command', "YES"
      EXIT 12
    END
  WHEN RC < 20 THEN EXIT 12 /* Conflicting cmds - edit sets message  */
  WHEN RC = 20 THEN ZDest=0
OTHERWISE;          EXIT 12; END
       /* Connect to DB2 and DESCRIBE the table                      */
ok='*'
  ADDRESS "DSNREXX" "CONNECT" SSID
    IF RC > 1 & SQLCODE ¬= 0 THEN CALL DISPLAY_SQLCA
  ADDRESS "DSNREXX" "EXECSQL DESCRIBE table :table INTO :SQLDA"
    IF SQLCODE ¬= 0 THEN CALL DISPLAY_SQLCA
  ADDRESS "DSNREXX" "EXECSQL COMMIT"
  ADDRESS "DSNREXX" "DISCONNECT"
CALL DB2STEP SSID "ADD_DROP(DROP)"
  IF SQLCODE ¬= 0 THEN CALL DISPLAY_SQLCA
       /* Now figure out what to do with DESCRIBE and then do it!    */
SELECT
  WHEN ABBREV(TYPE, "S") & REXX THEN CALL DrawSELECT_REXX
  WHEN ABBREV(TYPE, "S")        THEN CALL DrawSELECT
  WHEN ABBREV(TYPE, "I") & REXX THEN CALL DrawInsert_REXX
  WHEN ABBREV(TYPE, "I")        THEN CALL DrawInsert
  WHEN ABBREV(TYPE, "U") & REXX THEN CALL DrawUpdate_REXX
  WHEN ABBREV(TYPE, "U")        THEN CALL DrawUpdate
  WHEN ABBREV(TYPE, "L")        THEN CALL DrawLoad
OTHERWISE;                           EXIT 20; END
ok='0' /* RC=0 is only acceptable RC for LINE_AFTER in DO Loop       */
DO I = Line.0 TO 1 BY -1
    InsertLine="'"LEFT(" ",LeftBnd)||Line.I"'"
    ADDRESS "ISREDIT" "LINE_AFTER" ZDest "=" LINETYPE InsertLine
END
ok='0';ADDRESS "ISREDIT" "CURSOR =" ZDest "0"

msgstat = MSG(msgstat)
EXIT EXIT_error
/***************************** REXX ***********************************
                            END of REXX
****************************** REXX ***********************************
                       Beginning of PROCEDURES
****************************** REXX ***********************************/
/**********************************************************************
     This Initializes any variables needed for this REXX
***********************************************************************/
INITIALIZE_THIS_REXX:
  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */
                       /* Initialize and process non-positional parms */
  valid_parms="LINETYPE(DATALINE) REXX() SSID() TEST(O) TYPE(SELECT)"
  match_length=4                  /* NP-Parms match on first # chars  */
  IF valid_parms ¬= '' THEN CALL DO_NP_PARMS

  no_submited=0
  SYSUID=SYSVAR("SYSUID")
  user_prefix=LEFT(SYSUID,4)
  EXIT_error=0; sql_error=0
  SYSMSGLVL1=""; SYSMSGLVL2=""
  Lower="abcdefghijklmnopqrstuvwxyz"; Upper="ABCDEFGHIJKLMNOPQRSTUVWXYZ"

  IF ABBREV(LINETYPE,"NOTE") THEN LINETYPE="NOTELINE"
     ELSE                         LINETYPE="DATALINE"

  CALL VALIDATE_DB2_SSID SSID
  IF INDEX(table, ".") = 0 THEN table=owner"."table

  IF REXX = "" THEN DO
      ADDRESS "ISREDIT" "(dsname) = DATASET"
      backwards=REVERSE(dsname)
      SELECT
        WHEN ABBREV(backwards, "XXER")    THEN REXX=TRUE
        WHEN ABBREV(backwards, "CEXE")    THEN REXX=TRUE
        WHEN ABBREV(backwards, "TSILC")   THEN REXX=TRUE
        WHEN ABBREV(backwards, "BILCPSI") THEN REXX=TRUE
        WHEN ABBREV(backwards, "CORPSYS") THEN REXX=TRUE
      OTHERWISE;                               REXX=FALSE; END
  END
  IF SSID = "" THEN DO
      ADDRESS "ISPEXEC" "VGET (DSNEOV01)"
      IF RC = 0 THEN SSID=DSNEOV01
  END
  CALL DEFINE_DB2_TYPES

RETURN
/* COPY DBSUBSYS */
/********************************************************************** /*COPY*/
    Validate the DB2 SSID, verify it is up, and then set OWNER          /*COPY*/
       Valid combinations are: DEV2 - DBS1 - NMLTEST                    /*COPY*/
                               PRD1 - DBP1 - NMLPROD                    /*COPY*/
                               TST2 - DBT1 - NMLPROD or NMLTEST         /*COPY*/
                               TST2 - DBT2 - NMLTEST                    /*COPY*/
                               TST2 - DBT3 - NMLTEST                    /*COPY*/
***********************************************************************//*COPY*/
VALIDATE_DB2_SSID:                                                      /*COPY*/
ARG SSID .                                                              /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN ABBREV(MVSVAR("SYSNAME"), "TST")   THEN IF,                    /*COPY*/
         WORDPOS(SSID,"DBT1 DBT2 DBT3") = 0 THEN DO                     /*COPY*/
       SSID = "DBT1"; OWNER = "NMLPROD"                                 /*COPY*/
     END                                                                /*COPY*/
    WHEN ABBREV(MVSVAR("SYSNAME"), "DEV")   THEN SSID = "DBS1"          /*COPY*/
  OTHERWISE;                                     SSID = "DBP1"; END     /*COPY*/
  IF CHECK_DB2(SSID "YES") ¬= 0  THEN EXIT 4                            /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN ABBREV(SSID, "DBP")     THEN OWNER = "NMLPROD"                 /*COPY*/
    WHEN ABBREV(SSID, "DBT")     &,                                     /*COPY*/
         ABBREV("NMLPROD",OWNER) THEN OWNER = "NMLPROD"                 /*COPY*/
    WHEN ABBREV(SSID, "DBT")     THEN OWNER = "NMLTEST"                 /*COPY*/
    WHEN ABBREV(SSID, "DBS")     THEN OWNER = "NMLTEST"                 /*COPY*/
  OTHERWISE;                          OWNER = "DB_ERROR"; END           /*COPY*/
RETURN SSID                                                             /*COPY*/
/* COPY CHECKDB2 */                                                     /*COPY*/
/********************************************************************** /*COPY*/
           Is DB2 Sub-System available at this time?                    /*COPY*/
**********************************************************************/ /*COPY*/
CHECK_DB2: PROCEDURE                                                    /*COPY*/
ARG SSID respond_on_fail .                                              /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM TSO"                                     /*COPY*/
  IF RC = 0 THEN IF DB2STEP(SSID "ADD_DROP(ADD)") > 0 THEN EXIT 8       /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM DSNREXX"                                 /*COPY*/
  IF RC ¬= 0 THEN x = RXSUBCOM('ADD','DSNREXX','DSNREXX')               /*COPY*/
  ok='*';ADDRESS "DSNREXX" "CONNECT" SSID                               /*COPY*/
  IF RC > 1 & ABBREV('YES', respond_on_fail, 1) THEN CALL SET_MSG,      /*COPY*/
         SSID "not up!",                                         ,      /*COPY*/
        "The DB2 Sub-System" SSID "is not up at this time!", "YES"      /*COPY*/
RETURN RC                                                               /*COPY*/
/* COPY DB2SUPP */
/* COPY DB2TYPES */                                                     /*COPY*/
/********************************************************************** /*COPY*/
   This PROCEDURE sets up definitions for the various DB2 SQL Types     /*COPY*/
***********************************************************************//*COPY*/
DEFINE_DB2_TYPES:                                                       /*COPY*/
  SQLTYPE. = "UNKNOWN TYPE"                                             /*COPY*/
  DATYPE   = 384; SQLTYPES.DATYPE   = 'DATE'                            /*COPY*/
  TITYPE   = 388; SQLTYPES.TITYPE   = 'TIME'                            /*COPY*/
  TSTYPE   = 392; SQLTYPES.TSTYPE   = 'TIMESTAMP'                       /*COPY*/
  BLOBTYP  = 404; SQLTYPES.BLOBTYP  = 'BLOB'                            /*COPY*/
  CLOBTYP  = 408; SQLTYPES.CLOBTYP  = 'CLOB'                            /*COPY*/
  DBCLTYP  = 412; SQLTYPES.DBCLTYP  = 'DBCLOB'                          /*COPY*/
  VCHTYPE  = 448; SQLTYPES.VCHTYPE  = 'VARCHAR'                         /*COPY*/
  CHTYPE   = 452; SQLTYPES.CHTYPE   = 'CHAR'                            /*COPY*/
  LVCHTYPE = 456; SQLTYPES.LVCHTYPE = 'VARCHAR'                         /*COPY*/
  VGRTYP   = 464; SQLTYPES.VGRTYP   = 'VARGRAPHIC'                      /*COPY*/
  GRTYP    = 468; SQLTYPES.GRTYP    = 'GRAPHIC'                         /*COPY*/
  LVGRTYP  = 472; SQLTYPES.LVGRTYP  = 'VARGRAPHIC'                      /*COPY*/
  FLOTYPE  = 480; SQLTYPES.FLOTYPE  = 'FLOAT'                           /*COPY*/
  DCTYPE   = 484; SQLTYPES.DCTYPE   = 'DECIMAL'                         /*COPY*/
  INTYPE   = 496; SQLTYPES.INTYPE   = 'INTEGER'                         /*COPY*/
  SMTYPE   = 500; SQLTYPES.SMTYPE   = 'SMALLINT'                        /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY ERRORDB2 */                                                     /*COPY*/
/********************************************************************** /*COPY*/
    Determine current environment and then display SQLCA accordingly    /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_SQLCA:                                                          /*COPY*/
  elineno = sigl - 1                /* Source line error occured in   *//*COPY*/
  SIGNAL OFF NOVALUE                                                    /*COPY*/
  CALL   GET_ERROR_INFO             /* Get information about error    *//*COPY*/
                                                                        /*COPY*/
  SQLERRD = SQLERRD.1","SQLERRD.2",",                                   /*COPY*/
     || SQLERRD.3","SQLERRD.4","SQLERRD.5","SQLERRD.6                   /*COPY*/
  SQLWARN = SQLWARN.0","SQLWARN.1","SQLWARN.2","SQLWARN.3",",           /*COPY*/
     || SQLWARN.4","SQLWARN.5","SQLWARN.6","SQLWARN.7",",               /*COPY*/
     || SQLWARN.8"," SQLWARN.9","SQLWARN.10                             /*COPY*/
                                                                        /*COPY*/
  IF INDEX(expandl, "DSNREXX") > 0 &,                                   /*COPY*/
     INDEX(expandl, "FROM :")  > 0 THEN DO                              /*COPY*/
      PARSE VALUE expandl WITH . "FROM :" eSQL                          /*COPY*/
      eSQL = VALUE(eSQL)                                                /*COPY*/
    END                                                                 /*COPY*/
  ELSE eSQL = "  *--- Unable to determine SQL ---*"                     /*COPY*/
                                                                        /*COPY*/
  ok='*';ADDRESS "ISREDIT" "(maclevel) = MACRO_LEVEL"                   /*COPY*/
  IF RC = 0 THEN CALL DISPLAY_SQLCA_ISREDIT                             /*COPY*/
  ELSE DO                                                               /*COPY*/
      ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                             /*COPY*/
      SELECT                                                            /*COPY*/
        WHEN RC ¬= 0                   THEN CALL DISPLAY_SQLCA_MVS      /*COPY*/
        WHEN SYSVAR('SYSENV') = 'BACK' THEN CALL DISPLAY_SQLCA_MVS      /*COPY*/
      OTHERWISE                                                         /*COPY*/
          ADDRESS "ISPEXEC" "PQUERY PANEL(ERRORDB2) AREANAME(eSQL)",    /*COPY*/
                            "WIDTH(width) DEPTH(depth)"                 /*COPY*/
          cur_ = 1; orig_eSQL = eSQL                                    /*COPY*/
          orig_ = MAX(LENGTH(orig_eSQL), width+1)                       /*COPY*/
          l_row = (orig_+width-1)%width                                 /*COPY*/
          left_ = "SQL ERROR Reporting"                                 /*COPY*/
          DO FOREVER                                                    /*COPY*/
              top_ = (cur_%width) + 1                                   /*COPY*/
              bottom_ =  MIN((top_ + depth) - 1, l_row)                 /*COPY*/
              sqltitle = OVERLAY(left_, RIGHT(top_"-"bottom_ ,          /*COPY*/
                                 "of" l_row,width-1))                   /*COPY*/
              ADDRESS "ISPEXEC" "DISPLAY PANEL(ERRORDB2)"               /*COPY*/
              display_RC = RC                                           /*COPY*/
              ADDRESS "ISPEXEC" "VGET (ZVERB ZSCROLLN)"                 /*COPY*/
              SELECT                                                    /*COPY*/
                WHEN display_RC = 8           THEN LEAVE                /*COPY*/
                WHEN ABBREV(ZVERB, "DOWN")    THEN DO                   /*COPY*/
                    cur_ = MIN(cur_ + (ZSCROLLN*width), orig_-width)    /*COPY*/
                    eSQL = SUBSTR(orig_eSQL, cur_)                      /*COPY*/
                  END                                                   /*COPY*/
                WHEN ABBREV(ZVERB, "UP")      THEN DO                   /*COPY*/
                    cur_ = MAX(cur_ - (ZSCROLLN*width), 1)              /*COPY*/
                    eSQL = SUBSTR(orig_eSQL, cur_)                      /*COPY*/
                  END                                                   /*COPY*/
              OTHERWISE; NOP; END                                       /*COPY*/
          END                                                           /*COPY*/
      END                                                               /*COPY*/
  END                                                                   /*COPY*/
        /* Done with DB2, cleanup up the connection                  */ /*COPY*/
  ok='*';ADDRESS "DSNREXX" "DISCONNECT"                                 /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM TSO"                                     /*COPY*/
  IF RC = 0 THEN CALL DB2STEP SSID "ADD_DROP(DROP)"                     /*COPY*/
  exit_rc = SQLCODE                                                     /*COPY*/
CALL CLEANUP                                                            /*COPY*/
/********************************************************************** /*COPY*/
    Display the DB2 SQLCA when under ISPF EDIT                          /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_SQLCA_ISREDIT:                                                  /*COPY*/
  x = " BAD SQL =" LEFT(eSQL,LINESIZE() - 20)                           /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = " BAD CMD =" LEFT(expandl,LINESIZE() - 20)                        /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = " SQLWARN =" SQLWARN                                              /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = " SQLERRD =" SQLERRD                                              /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = " SQLERRP =" SQLERRP                                              /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = " SQLERRM =" SQLERRM                                              /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = "SQLSTATE =" SQLSTATE                                             /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
  x = " SQLCODE =" SQLCODE                                              /*COPY*/
  ok='0 4';ADDRESS "ISREDIT" "LINE_AFTER .ZCSR = MSGLINE (x)"           /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
    Display the DB2 SQLCA when under ISPF                               /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_SQLCA_MVS:                                                      /*COPY*/
  SAY "A SQL Error in" erexx "has occured!"                             /*COPY*/
  SAY "Resulting in an DSNREXX RC of:" erc "on Line" elineno            /*COPY*/
  SAY "Line No." elineno "is '"expandl"'"                               /*COPY*/
  SAY "  --------    ----------------------------"                      /*COPY*/
  SAY "   SQLCODE = '"SQLCODE"'"                                        /*COPY*/
  SAY "  SQLSTATE = '"SQLSTATE"'"                                       /*COPY*/
  SAY "   SQLERRM = '"SQLERRM"'"                                        /*COPY*/
  SAY "   SQLERRP = '"SQLERRP"'"                                        /*COPY*/
  SAY "   SQLERRD = '"SQLERRD"'"                                        /*COPY*/
  SAY "   SQLWARN = '"SQLWARN"'"                                        /*COPY*/
  SAY "   BAD SQL =  "eSQL                                              /*COPY*/
  SAY "  --------    ----------------------------"                      /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY DISHELP */
/********************************************************************** /*COPY*/
            This PROCEDURE displays the Help information in             /*COPY*/
                 this REXX's HEADER when invoked.                       /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_HELP: PROCEDURE                                                 /*COPY*/
ARG exit_or_return .                                                    /*COPY*/
  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/
      source.i = SOURCELINE(i + 1)  /* Read in HELP from EXEC         *//*COPY*/
  END                                                                   /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                                 /*COPY*/
  IF RC ¬= 0 THEN DO   /* No ISPF, use SAY to display help            *//*COPY*/
      DO i = 1 TO i                                                     /*COPY*/
          SAY source.i                                                  /*COPY*/
      END                                                               /*COPY*/
    END                                                                 /*COPY*/
  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/
      PARSE SOURCE . . rname .      /* Get REXX EXEC name             *//*COPY*/
                                                                        /*COPY*/
      ok='0';ADDRESS "ISPEXEC" "TBCREATE RHELP02 NAMES(source) NOWRITE" /*COPY*/
      DO i = 1 TO i    /* Build HELP table to display                 *//*COPY*/
          source = source.i                                             /*COPY*/
          ADDRESS "ISPEXEC" "TBADD RHELP02"                             /*COPY*/
      END                                                               /*COPY*/
      ok='0';ADDRESS "ISPEXEC" "TBTOP RHELP02"                          /*COPY*/
      ZTDMARK = CENTER("----> END of Help <----",80)                    /*COPY*/
      ok='0 4 8';ADDRESS "ISPEXEC" "TBDISPL RHELP02 PANEL(RHELP02)"     /*COPY*/
      ok='0';ADDRESS "ISPEXEC" "TBCLOSE RHELP02"                        /*COPY*/
  END                                                                   /*COPY*/
                      /* Stay inside current EXEC or EXIT             *//*COPY*/
IF ABBREV('RETURN',exit_or_return,3) THEN RETURN                        /*COPY*/
   ELSE EXIT 0                                                          /*COPY*/
/* COPY NPPARMS */
/********************************************************************** /*COPY*/
            Initialize and process Non-Possitional Parms in a           /*COPY*/
                method similar to that of CLISTs                        /*COPY*/
    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/
          not follow any internal ')' with spaces!!                     /*COPY*/
**********************************************************************/ /*COPY*/
DO_NP_PARMS:                                                            /*COPY*/
  vp_list = valid_parms ' '; in_list = inparms ' '                      /*COPY*/
  parm_list = ''; parm_error_list = ''                                  /*COPY*/
                                                                        /*COPY*/
  DO linx = 1 TO WORDS(valid_parms) UNTIL vp_list = ''                  /*COPY*/
      PARSE VALUE vp_list WITH parm.linx '(' parm_val.linx ') ' vp_list /*COPY*/
      parm_list = parm_list STRIP(LEFT(parm.linx,match_length))         /*COPY*/
  END                                                                   /*COPY*/
  DO WHILE INDEX(in_list, '(') > 0                                      /*COPY*/
      PARSE VALUE in_list WITH parm '(' value ') ' in_list              /*COPY*/
      UPPER parm           /* Don't want to translate value to UPPER */ /*COPY*/
      parm = STRIP(parm)                                                /*COPY*/
      parm_number = WORDPOS(STRIP(LEFT(parm,match_length)), parm_list)  /*COPY*/
      IF parm_number > 0 THEN parm_val.parm_number = value              /*COPY*/
      ELSE IF INDEX(value,")") > 0 THEN                                 /*COPY*/
           parm_error_list = parm_error_list parm"("value               /*COPY*/
      ELSE parm_error_list = parm_error_list parm"("value")"            /*COPY*/
  END                                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN parm_error_list ¬= '' & accept_all = TRUE THEN                 /*COPY*/
        anything_else = STRIP(in_list) parm_error_list                  /*COPY*/
    WHEN parm_error_list ¬= ''                     THEN DO              /*COPY*/
       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/
       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/
            "'"parm_error_list"' not valid Parm(s) for" rname"!", "YES" /*COPY*/
        EXIT 8                                                          /*COPY*/
      END                                                               /*COPY*/
  OTHERWISE                                                             /*COPY*/
      anything_else = STRIP(in_list)                                    /*COPY*/
  END                                                                   /*COPY*/
  DO parm_inx = 1 TO linx                                               /*COPY*/
      SELECT                                                            /*COPY*/
        WHEN ABBREV(parm_val.parm_inx, "&")               |,            /*COPY*/
             ABBREV(parm_val.parm_inx, "*")               THEN          /*COPY*/
            INTERPRET parm.parm_inx "= '"parm_val.parm_inx"'"           /*COPY*/
        WHEN DATATYPE(parm_val.parm_inx, "NUM")           THEN          /*COPY*/
            INTERPRET parm.parm_inx "=" parm_val.parm_inx               /*COPY*/
        WHEN WORDPOS(parm_val.parm_inx, "FALSE TRUE") > 0 THEN          /*COPY*/
            INTERPRET parm.parm_inx "=" parm_val.parm_inx               /*COPY*/
        WHEN (LEFT(parm_val.parm_inx,1) = "'"             & ,           /*COPY*/
              RIGHT(parm_val.parm_inx,1) = "'")           | ,           /*COPY*/
             INDEX(parm_val.parm_inx,':') > 0             | ,           /*COPY*/
             INDEX(parm_val.parm_inx,'*') > 0             | ,           /*COPY*/
             INDEX(parm_val.parm_inx,'%') > 0             | ,           /*COPY*/
             INDEX(parm_val.parm_inx,'=') > 0             THEN          /*COPY*/
            INTERPRET parm.parm_inx "= parm_val."parm_inx               /*COPY*/
        WHEN INDEX(STRIP(parm_val.parm_inx), " ") > 0     THEN          /*COPY*/
            INTERPRET parm.parm_inx "=" parm_val.parm_inx               /*COPY*/
      OTHERWISE                                                         /*COPY*/
          ADDRESS "MVS" "SUBCOM TSO"                                    /*COPY*/
          IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE       /*COPY*/
          PARSE VALUE parm_val.parm_inx WITH PDS_name '(' rest          /*COPY*/
          SELECT                                                        /*COPY*/
            WHEN ¬(TSO_avail)                            THEN           /*COPY*/
                INTERPRET parm.parm_inx "=" parm_val.parm_inx           /*COPY*/
            WHEN SYSVAR("SYSNEST") = 'YES'               THEN           /*COPY*/
                INTERPRET parm.parm_inx "=" parm_val.parm_inx           /*COPY*/
            WHEN (INDEX(rest, ")") > 0                   &,             /*COPY*/
                 (ABBREV(rest, "+") | ABBREV(rest,"-")   |,             /*COPY*/
                  ABBREV(rest, "0)")))                   THEN           /*COPY*/
                INTERPRET parm.parm_inx "= '"parm_val.parm_inx"'"       /*COPY*/
            WHEN (LISTDSI(parm_val.parm_inx)       <= 4  | ,            /*COPY*/
                  LISTDSI("'"parm_val.parm_inx"'") <= 4  | ,            /*COPY*/
                  LISTDSI("'"PDS_name"'")          <= 4  | ,            /*COPY*/
                  LISTDSI(PDS_name)                <= 4) THEN           /*COPY*/
                INTERPRET parm.parm_inx "= parm_val."parm_inx           /*COPY*/
          OTHERWISE                                                     /*COPY*/
                INTERPRET parm.parm_inx "=" parm_val.parm_inx           /*COPY*/
          END                                                           /*COPY*/
          INTERPRET parm.parm_inx "=" parm_val.parm_inx                 /*COPY*/
      END                                                               /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY SETMSG */                                                       /*COPY*/
/********************************************************************** /*COPY*/
              Error with DSN, Use ISPF to display Error Message         /*COPY*/
***********************************************************************//*COPY*/
SET_MSG: PROCEDURE                                                      /*COPY*/
PARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM                              /*COPY*/
  IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'                   /*COPY*/
     ELSE ZERRALRM = 'NO'                                               /*COPY*/
  IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                       /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                                 /*COPY*/
  SELECT                                                                /*COPY*/
   WHEN RC ¬= 0                   THEN DO                               /*COPY*/
      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/
    END                                                                 /*COPY*/
   WHEN SYSVAR("SYSNEST") = 'YES' &,                                    /*COPY*/
        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/
      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/
    END                                                                 /*COPY*/
  OTHERWISE                                                             /*COPY*/
      ok='0';ADDRESS "ISPEXEC" "SETMSG MSG(ISRZ002)"                    /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/**********************************************************************
     Draw SELECT for a REXX EXEC Using DSNREXX
***********************************************************************/
DrawSELECT_REXX:
  Line.0=0; Line='sql_SELECT="SELECT '
  DO I=1 TO SQLDA.SQLD
      IF I > 1 THEN Line=Line', '
      Null=SQLDA.I.SQLTYPE//2
      IF LENGTH(Line SQLDA.I.SQLNAME'" ,') >= BndSize THEN DO
         L=Line.0 + 1; Line.0=L; Line.L=Line'" ,'; Line=RIGHT('"',21)
      END
      Line=Line||SQLDA.I.SQLNAME
  END I
  IF Line ¬= "" THEN DO; L=Line.0 + 1; Line.0=L; Line.L=Line'" ,'; END
  L=Line.0+1; Line.0=L; Line.L=RIGHT('"FROM',19) table '" ,'
  L=Line.0+1; Line.0=L; Line.L=RIGHT('"WHERE',19) RIGHT('"',48)
RETURN
/**********************************************************************
     Draw SELECT
***********************************************************************/
DrawSELECT:
  Line.0=0; Line="SELECT"
  DO I=1 TO SQLDA.SQLD
      IF I > 1 THEN Line=Line","
      Null=SQLDA.I.SQLTYPE//2
      IF LENGTH(Line SQLDA.I.SQLNAME",") >= BndSize THEN DO
          L=Line.0+1; Line.0=L; Line.L=Line; Line=LEFT("",6)
      END
      Line=Line SQLDA.I.SQLNAME
  END I
  IF Line ¬= "" THEN DO; L=Line.0+1; Line.0=L; Line.L=Line; END
  L=Line.0+1; Line.0=L; Line.L="  FROM" table
RETURN
/**********************************************************************
      Draw INSERT for a REXX EXEC Using DSNREXX
***********************************************************************/
DrawINSERT_REXX:
  Line.0=0; Line='sql_INSERT="INSERT INTO' table '('
  DO I=1 TO SQLDA.SQLD
      IF I > 1 THEN Line=Line', '
      IF LENGTH(Line SQLDA.I.SQLNAME'" ,') >= BndSize THEN DO
          L=Line.0+1; Line.0=L; Line.L=Line'" ,'; Line=RIGHT('"',21)
      END
      Line=Line||SQLDA.I.SQLNAME
      IF I = SQLDA.SQLD THEN Line=Line ')'
  END I
  IF Line ¬= "" THEN DO
      L=Line.0+1; Line.0=L; Line.L=Line'" ,'; Line=RIGHT('"',21)
    END
  L=Line.0+1; Line.0=L; Line.L=LEFT("",12)'"VALUES (" ,',
                              "        /* Enter values over column name   */"
  DO I=1 TO SQLDA.SQLD
      IF SQLDA.SQLD = 1 THEN Line=RIGHT('"  ',22)
         ELSE                Line=RIGHT('", ',22)
      Line=Line || Left(SQLDA.I.SQLNAME,18)'", /*'
      Type=SQLDA.I.SQLTYPE
      Null=Type//2
      IF Null THEN Type=Type - 1
      Len=SQLDA.I.SQLLEN
      SELECT
        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,
             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP ) THEN
           Type=SQLTYPES.Type"("STRIP(Len)")"
        WHEN (Type = FLOTYPE )                                THEN
           Type=SQLTYPES.Type"("STRIP((Len*4)-11) ")"
        WHEN (Type = DCTYPE )                                 THEN DO
            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION
            Scale = SQLDA.I.SQLLEN.SQLSCALE
            Type=SQLTYPES.Type"("STRIP(Prcsn)","STRIP(Scale)")"
          END
      OTHERWISE; Type=SQLTYPES.Type; END
      L=Line.0 + 1; Line.0=L
      IF Null = 0 THEN Line.L=Line LEFT(Type,12) "NOT NULL */"
         ELSE          Line.L=Line LEFT(Type,21) "*/"
  END I
  L=Line.0 + 1; Line.0=L; Line.L=RIGHT('")"',22)
RETURN
/**********************************************************************
      Draw INSERT
***********************************************************************/
DrawINSERT:
  Line.0=0; Line="INSERT INTO" table "("
  DO I=1 TO SQLDA.SQLD
      IF I > 1 THEN Line=Line","
      IF LENGTH(Line SQLDA.I.SQLNAME",") >= BndSize THEN DO
          L=Line.0+1; Line.0=L; Line.L=Line; Line=LEFT("",6)
      END
      Line=Line SQLDA.I.SQLNAME
      IF I = SQLDA.SQLD THEN Line=Line ')'
  END I
  IF Line ¬= "" THEN DO; L=Line.0+1;Line.0=L;Line.L=Line;Line=LEFT("",6); END
  L=Line.0 + 1; Line.0=L; Line.L="VALUES (",
                             " -- ENTER VALUES BELOW COLUMN NAME DATA TYPE"
  DO I=1 TO SQLDA.SQLD
      IF SQLDA.SQLD = 1 THEN Line=RIGHT('  --',11)
         ELSE                Line=RIGHT(', --',11)
      Line=Line Left(SQLDA.I.SQLNAME,18)
      Type=SQLDA.I.SQLTYPE
      Null=Type//2
      IF Null THEN Type=Type - 1
      Len=SQLDA.I.SQLLEN
      SELECT
        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,
             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP ) THEN
           Type=SQLTYPES.Type"("STRIP(Len)")"
        WHEN (Type = FLOTYPE )                                THEN
           Type=SQLTYPES.Type"("STRIP((Len*4)-11) ")"
        WHEN (Type = DCTYPE )                                 THEN DO
            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION
            Scale = SQLDA.I.SQLLEN.SQLSCALE
            Type=SQLTYPES.Type"("STRIP(Prcsn)","STRIP(Scale)")"
          END
      OTHERWISE; Type=SQLTYPES.Type; END
      L=Line.0 + 1; Line.0=L
      IF Null = 0 THEN Line.L=Line LEFT(Type,12) "NOT NULL"
         ELSE          Line.L=Line Type
  END I
  L=Line.0+1; Line.0=L; Line.L=RIGHT(")",8)
RETURN
/**********************************************************************
     Draw UPDATE for a REXX EXEC Using DSNREXX
***********************************************************************/
DrawUPDATE_REXX:
  Line.0=1; Line.1='sql_UPDATE= "UPDATE' table 'SET" ,'
  L=Line.0 + 1; Line.0=L
  Line.L=LEFT("",16) "/* Colume Name ENTER values over comment           */"
  DO I=1 TO SQLDA.SQLD
      IF I = 1 THEN Line=RIGHT('" ',19); ELSE Line=RIGHT('",',19)
      Line=Line LEFT(SQLDA.I.SQLNAME,18) "= /*"
      Type=SQLDA.I.SQLTYPE
      Null=Type//2
      IF Null THEN Type=Type - 1
      Len=SQLDA.I.SQLLEN
      SELECT
        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,
             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP) THEN
           Type=SQLTYPES.Type"("STRIP(Len)")"
        WHEN (Type = FLOTYPE )                               THEN
           Type=SQLTYPES.Type"("STRIP((Len*4)-11)")"
        WHEN (Type = DCTYPE )                                THEN DO
            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION
            Scale = SQLDA.I.SQLLEN.SQLSCALE
            Type=SQLTYPES.Type"("STRIP(Prcsn)","STRIP(Scale)")"
          END
      OTHERWISE; Type=SQLTYPES.Type; END
      L=Line.0+1; Line.0=L
      IF Null = 0 THEN Line.L=Line LEFT(Type,12) "NOT NULL */"
         ELSE          Line.L=Line LEFT(Type,21) "*/"
  END I
  L=Line.0+1; Line.0=L; Line.L=RIGHT('"WHERE',19) RIGHT('"',48)
RETURN
/**********************************************************************
     Draw UPDATE
***********************************************************************/
DrawUPDATE:
  Line.0=1; Line.1="UPDATE" table "SET"
  L=Line.0 + 1; Line.0=L
  Line.L=LEFT("",4)"-- Column Name            ENTER values over data type"
  DO I=1 TO SQLDA.SQLD
      IF I = 1 THEN Line=RIGHT("",6); ELSE Line=RIGHT(",",6)
      Line=Line LEFT(SQLDA.I.SQLNAME, 18) "="
      Type=SQLDA.I.SQLTYPE
      Null=Type//2
      IF Null THEN Type=Type - 1
      Len=SQLDA.I.SQLLEN
      SELECT
        WHEN (Type = CHTYPE |Type = VCHTYPE |Type = LVCHTYPE ,
             |Type = GRTYP  |Type = VGRTYP  |Type = LVGRTYP) THEN
           Type=SQLTYPES.Type"("STRIP(Len)")"
        WHEN (Type = FLOTYPE )                               THEN
           Type=SQLTYPES.Type"("STRIP((Len*4)-11)")"
        WHEN (Type = DCTYPE )                                THEN DO
            Prcsn = SQLDA.I.SQLLEN.SQLPRECISION
            Scale = SQLDA.I.SQLLEN.SQLSCALE
            Type=SQLTYPES.Type"("STRIP(Prcsn)","STRIP(Scale)")"
          END
      OTHERWISE; Type=SQLTYPES.Type; END
      Line=Line "--" LEFT(Type,14)
      IF Null = 0 THEN Line=Line "NOT NULL"
      L=Line.0+1; Line.0=L; Line.L=Line
  END I
  L=Line.0+1; Line.0=L; Line.L=" WHERE"
RETURN
/**********************************************************************
     Draw LOAD
***********************************************************************/
DrawLOAD:
  Line.0=1; Line.1="LOAD DATA INDDN SYSREC"
  Line.0=2; Line.2="         INTO table" table
  Line.0=3; Line.3="      -- REPLACE"
  Line.0=4; Line.4="      -- LOG  NO"
  Line.0=5; Line.5="      -- WHEN(###:###)='??????????'"
  Position=1
  DO I=1 TO SQLDA.SQLD
      IF I = 1 THEN Line=RIGHT("(",4); ELSE Line=RIGHT(",",4)
      Line=Line Left(SQLDA.I.SQLNAME,20)
      Line=Line "POSITION("RIGHT(Position,5)")"
      Type=SQLDA.I.SQLTYPE
      Null=Type//2
      IF Null THEN Type=Type - 1
      Len=SQLDA.I.SQLLEN
      SELECT
        WHEN (Type = CHTYPE|Type = GRTYP )                THEN
            Type=SQLTYPES.Type"("STRIP(Len)")"
        WHEN (Type = FLOTYPE )                            THEN
            Type=SQLTYPES.Type"("STRIP((Len*4)-11) ")"
        WHEN (Type = DCTYPE )                             THEN DO
            Prcsn=SQLDA.I.SQLLEN.SQLPRECISION
            Scale=SQLDA.I.SQLLEN.SQLSCALE
            Type=SQLTYPES.Type "EXTERNAL"
            Type=Type"("STRIP(Prcsn)","STRIP(Scale)")"
            Len=(Prcsn+2)%2
          END
        WHEN WORDPOS(Type,DATYPE TITYPE TSTYPE) > 0       THEN
            Type=SQLTYPES.Type "EXTERNAL"
      OTHERWISE; Type=SQLTYPES.Type; END
      SELECT
        WHEN WORDPOS(Type,DATYPE TITYPE TSTYPE) > 0          THEN Len=Len*2
        WHEN WORDPOS(Type,VCHTYPE LVCHTYPE VGTYPE LVGRTYP)>0 THEN Len=Len+2
      OTHERWISE; NOP; END
      Line=Line Type; L=Line.0+1; Line.0=L; Line.L=Line
      IF Null = 1 THEN DO
          Line=LEFT("",22) "NULLIF("RIGHT(Position,5)")='?'"
          L=Line.0+1; Line.0=L; Line.L=Line
      END
      Position=Position + Len + 1
  END I
  L=Line.0+1; Line.0=L; Line.L=" )"
RETURN
/**********************************************************************
            Cleanup and Exit Gracefully
***********************************************************************/
CLEANUP:
  ok='*'                               /* Ignore all non-0 RCs        */
    CALL DB2STEP SSID "ADD_DROP(DROP)"
    ADDRESS "ISPEXEC" "FTCLOSE"        /* Close File Tailoring DSN    */
    ZISPFRC=exit_error                 /* Initialize ISPF RC Variable */
    ADDRESS "ISPEXEC" "VPUT (ZISPFRC)" /* Set ISPF RC to error RC     */
EXIT exit_error                        /* Set TSO/MVS RC to error RC  */
/* COPY ERRPROC */
/********************************************************************** /*COPY*/
      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/
***********************************************************************//*COPY*/
ERROR_PROC:                                                             /*COPY*/
  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/
     IF (WORDPOS(RC, ok) > 0) | ok = '*' THEN RETURN  /* Not an ERROR *//*COPY*/
                                                                        /*COPY*/
  TRACE("O")                        /* Turn off ERROR traps et.al.    *//*COPY*/
  elineno = sigl                    /* Source line error occured in   *//*COPY*/
  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/
  SIGNAL OFF NOVALUE                                                    /*COPY*/
  CALL   OFF ERROR                                                      /*COPY*/
  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/
                                                                        /*COPY*/
  "SUBCOM ISPEXEC"                  /* Is ISPF available?             *//*COPY*/
  IF RC = 0 THEN IF SYSVAR('SYSENV') ¬= 'BACK' THEN DO UNTIL RC ¬= 0    /*COPY*/
        eresults = ""                                                   /*COPY*/
        DO QUEUED()                                                     /*COPY*/
            PARSE PULL eresult                                          /*COPY*/
            eresults = STRIP(eresults "NL ===>" eresult)                /*COPY*/
        END                                                             /*COPY*/
        ADDRESS "ISPEXEC" "DISPLAY PANEL(REXXEPNL)"                     /*COPY*/
      END                                                               /*COPY*/
    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/
  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/
                                                                        /*COPY*/
  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/
  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/
RETURN                                                                  /*COPY*/
/* COPY ERRINFO  */                                                     /*COPY*/
/********************************************************************** /*COPY*/
      Get the information about the ERROR and format it                 /*COPY*/
***********************************************************************//*COPY*/
GET_ERROR_INFO:                                                         /*COPY*/
  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/
  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/
  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/
  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/
  sourcel = STRIP(sourcel)                                              /*COPY*/
  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/
      nextl = SOURCELINE(elineno + e_i)                                 /*COPY*/
      IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)       /*COPY*/
      sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                     /*COPY*/
  END                           /* END loop to handle continued lines *//*COPY*/
  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/
      ecause  = ERRORTEXT(RC)       /* Brief description of error     *//*COPY*/
      expandl = "Can't INTERPRET source with SYNTAX errors!"            /*COPY*/
    END                                                                 /*COPY*/
  ELSE DO                                                               /*COPY*/
      ecause  = CONDITION('D')      /* Brief description of error     *//*COPY*/
      full_line = sourcel           /* Begin getting EXECuted source  *//*COPY*/
      PARSE VALUE full_line WITH srcl ';' full_line                     /*COPY*/
      IF ¬(ABBREV(STRIP(srcl),"CALL")) &,                               /*COPY*/
         ¬(ABBREV(STRIP(srcl),"SAY"))  THEN INTERPRET "evals =" srcl    /*COPY*/
          ELSE evals = ""                                               /*COPY*/
      IF DATATYPE(evals, "NUM") | evals = "" THEN evals = srcl          /*COPY*/
      expandl = evals                                                   /*COPY*/
      DO WHILE full_line ¬= ''      /* loop to handle ';' in source   *//*COPY*/
          PARSE VALUE full_line WITH srcl ';' full_line                 /*COPY*/
          IF ¬(ABBREV(STRIP(srcl),"CALL")) THEN INTERPRET "evals =" srcl/*COPY*/
              ELSE evals = ""                                           /*COPY*/
          IF DATATYPE(evals, "NUM") | evals = "" THEN evals = srcl      /*COPY*/
          expandl = expandl ';' evals                                   /*COPY*/
      END                                                               /*COPY*/
  END                                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR'      THEN           /*COPY*/
         emsg = ZERRLM                                                  /*COPY*/
    WHEN SYMBOL('SYSMSGLVL1') = 'VAR' & SYSMSGLVL1 ¬= "" THEN           /*COPY*/
         IF SYMBOL('SYSMSGLVL2') = 'VAR'                 THEN           /*COPY*/
              emsg = SYSMSGLVL1 "--" SYSMSGLVL2                         /*COPY*/
         ELSE emsg = SYSMSGLVL1                                         /*COPY*/
  OTHERWISE                                                             /*COPY*/
      emsg = 'No available ERROR description.'                          /*COPY*/
  END                                                                   /*COPY*/
  IF INDEX(emsg, "IN VARIABLE SYSREASON") > 0 THEN                      /*COPY*/
     QUEUE "SYSREASON: '"SYSREASON"'"                                   /*COPY*/
  IF etype = 'NOVALUE' THEN exit_error = 4   /* Set EXIT error level  *//*COPY*/
     ELSE exit_error = RC                                               /*COPY*/
  erc = exit_error      /* Get all information about error            *//*COPY*/
RETURN                                                                  /*COPY*/
/* COPY MVSERROR */                                                     /*COPY*/
/********************************************************************** /*COPY*/
                 Output ERROR information to SYSPRINT                   /*COPY*/
***********************************************************************//*COPY*/
MVS_ERROR_DISPLAY:                                                      /*COPY*/
  TRACE("O")                                                            /*COPY*/
  eresult. = "";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/
  DO eresults = 1 TO eresult.0                                          /*COPY*/
      PARSE PULL eresult.eresults                                       /*COPY*/
  END                                                                   /*COPY*/
  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/
  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/
  SAY ''                            /* Start SAYing error information *//*COPY*/
  SAY CENTER(CENTER(" An ERROR occurred in REXX '"erexx"' ",50,'*'),ls) /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY CENTER(LEFT('          Error Type:' etype,80),ls)                 /*COPY*/
  SAY CENTER(LEFT('         Error Cause:' ecause,80),ls)                /*COPY*/
  SAY CENTER(LEFT('                  RC:' erc,80),ls)                   /*COPY*/
  SAY CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)             /*COPY*/
  DO eresults = 2 TO eresult.0                                          /*COPY*/
      SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)  /*COPY*/
  END                                                                   /*COPY*/
  SAY CENTER(LEFT('         Source Line:' elineno,80),ls)               /*COPY*/
  SAY LEFT('   Error Description:' emsg,ls)                             /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY LEFT('Source line reads as:' sourcel,ls)                          /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY LEFT('  Source EXECutes as:' expandl,ls)                          /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY CENTER(CENTER("      End of ERROR Reporting     ",50,'*'),ls)     /*COPY*/
  SAY CENTER(CENTER("   Beginning of Error Handling   ",50,'*'),ls)     /*COPY*/
  SAY ''                                                                /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/
   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/
   the first one found.  So, a REXX specific version of these can       /*COPY*/
   be use writen if it is placed before ERROR_PROC.                     /*COPY*/
***********************************************************************//*COPY*/
ERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/
RETURN                                                                  /*COPY*/
CLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/
  ADDRESS "ISPEXEC" "FTCLOSE"       /* CLOSE File Tailoring FILE      *//*COPY*/
  ZISPFRC = exit_error              /* SET ISPF RC to exit_error      *//*COPY*/
  ADDRESS "ISPEXEC" "VPUT (ZISPFRC)"                                    /*COPY*/
EXIT exit_error                     /* EXIT with error return code    *//*COPY*/
