/***************************** REXX ***********************************
 This REXX is used to test out IGGCSI00 (the Catalog Search Interface)
      programming. This REXX does not require TSO, i.e. it can run
      under the IRXJCL Batch interface.

NOTE: This was writen before I had access to ISPF's DSLIST Command.
      Remember to use a leading '%' under ISPF to ensure you get
      this REXX EXEC vs. ISPF's DSLIST DSN Listing Command.

                           --- EXAMPLE ---
<TSO> <%>DSLIST DsnLevel <CATALOG(CatalogName)> <TEST(TraceOption)>,
               <CSIDTYPS(TypesToDisplay)> <FIELDS(FieldsToDisplay)>,
               <CALLED(TRUE|FALSE)>
<TSO> <%>DSLIST -H -- To display help for this REXX

  Arguments: DsnLevel    - Standard SMS DSN pattern template
             InParms     - Non-Positional parameters
 ----------------------------- NP-PARMS -------------------------------
                  CALLED - Was this Called as a function? default: FALSE
                 CATALOG - Name of Catalog to search.     default: Blank
                CSIDTYPS - DSN Types to list.             default: A
                     NOTE: CSIDTYPS is not checked before use!
                           Valid entires are only 'ABCGHLRUWX'
                           A - non-VSAM data set
                           B - Generation data group
                           C - Cluster
                           G - Alternate index
                           H - Generation data set
                           L - Tape volume catalog library entry
                           R - VSAM path
                           U - User catalog connector entry
                           W - Tape volume catalog volume entry
                           X - Alias
                  FIELDS - Additional fields to display.  default: VOLSER 6
                     NOTE: FIELDS Values are not checked before use!
                     NOTE: If DEFAULT is used, list is by CSIDTYPS used
                    TEST - Used to control traces.        default: Off

      Files: Input data is pulled from the System Catalog STC
Other EXECS: NONE
      Other: This requires STEMPUSH & STEMPULL from CBTTape.org to
             use as a CALLed Function by other EXECs

EXEC History

 REXX EXEC Name: DSLIST
         Author: AL FERGUSON - TS ADM (TSAZFA) from v1.84
                 FERGUSON AL (HUL2353)
         Writen: 08NOV06
        History: 07AUG17 - v2.22 - Minor refactoring of IGG Common Code
                 06AUG17 - v2.21 - Support for FIELD Checking & Lookup
                 06FEB17 - v2.08 - Update versions of Common Code.
                 11JAN17 - v2.01 - Minor refactoring
                 21DEC16 - v1.89 - Minor refactoring
                 19OCT16 - v1.88 - Minor refactoring
                 28JUN16 - v1.86 - Minor refactoring for performace
                 14APR16 - v1.84 - Update Default Field Processing
                 05OCT11 - v1.68 - Refactor VSAMTYPE.
                           Add ENTYPE & VSAMREUS interpretation.
                 21JUN11 - v1.65 - Update support for Tape Volume
                           Catalog Library/Volume entry. Add G0000V00
                           count to GDG DEFAULT Fields.
                 09JUN11 - v1.63 - Formating for GENLEVEL & FIELD(DEBUG)
                 08JUN11 - v1.59 - Add Data Field expansions and some
                           DEFAULT Fields for some dataset types.
                 02JUN11 - v1.51 - Add conversion support for LTBACKDT,
                           RECVTIME, & RECVTIMG (TOD Format), as well
                           as GDGALTDT (in PACKED Decimal)
                 11FEB11 - v1.45 - Fix handling multiple FIELDS and the
                           translation of DSCRDT2 & DSEXDT2 FIELDS from
                           PACKED Decimal to Julian Date.
                 03FEB11 - v1.41 - Add support for using as a CALLed
                           REXX function, returning the DSList vs
                           displaying it. This returns the list using
                           the CBT STEMPUSH & STEMPOP functions.
                 01DEC09 - v1.22 - Move CSIDTYPS and FIELDS to NPPARMS
                           vs hard coded values.
                 09NOV06 - v1.08 - 1st Working version with FIELDS
                 08NOV06 - v1.00
***************************** Rexx ***********************************/
ADDRESS "MVS" "SUBCOM TSO"                /* Is TSO available?       */
IF RC = 0 THEN MsgStat=MSG("OFF")
ARG DsnLevel InParms                      /* Place arguments here    */

SELECT
  WHEN WORDPOS(DsnLevel,'-h -H')  > 0 THEN CALL DISPLAY_HELP
  WHEN DsnLevel = ""                  THEN DO
     CALL SET_MSG "DSN Filter needed!",,
          "This needs a DSN filter to find information for!", "YES"
     EXIT 4
    END
OTHERWISE; CALL INITIALIZE_THIS_REXX; END
/* COPY ERRINIT */
/********************************************************************** /*COPY*/
              Initialize ERROR handling                                 /*COPY*/
***********************************************************************//*COPY*/
CALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/
SIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/
SIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/
SIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/
ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"  /* Is ISPEXEC available?       *//*COPY*/
IF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/
   ok='0';ADDRESS "ISPEXEC" "CONTROL ERRORS RETURN"   /* ISPF errors  *//*COPY*/
END                                                                     /*COPY*/
                                                                        /*COPY*/
TRACE (TEST)
CALL SET_IGGCSI_DEFAULTS
CALL INITIALIZE_IGGCSI_API

DO UNTIL RESUME ¬= 'Y'                /*  SET UP LOOP FOR RESUME       */
   ok='*';ADDRESS "LINKPGM" "IGGCSI00 MODRSNRC CSIFIELD DWORK"
   IF RC ¬= 0 THEN CALL DISPLAY_IGGCSI_ERROR

   RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */
   PARSE VALUE DWORK WITH . +8 CSIUSDLN +4 CSINUMFD +2 rest
   rest = LEFT(rest, C2D(CSIUSDLN)-14)
   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/
      PARSE VALUE rest WITH CSICFLG  +1 CSICTYPE +1 CSICNAME +44 CSICRETM,
                         +2 CSICRETR +1 CSICRETN +1 rest
      IF CSICTYPE = '0' THEN CALL PROCESS_CATALOGS
         ELSE                CALL PROCESS_NONCATALOGS
   END
END

IF CALLED THEN RETURN STEMPUSH("dsns.")
   ELSE DO k = 1 TO dsns.0; SAY dsns.k; END

EXIT ExitError
/***************************** REXX ***********************************
                            END of REXX
****************************** REXX ***********************************
                       Beginning of PROCEDURES
****************************** REXX ***********************************/
/**********************************************************************
     This Initializes any variables needed for this REXX
***********************************************************************/
INITIALIZE_THIS_REXX:
  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */
                       /* Initialize and process non-positional parms */
  ValidParms = "CALLED(FALSE) CATALOG() CSIDTYPS(A) FIELDS() TEST(O)"
  MatchLength = 3      /* NP-Parms match on first # chars             */
  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */
  IF ValidParms ¬= '' THEN CALL DO_NP_PARMS

  SYSUID = USERID()
  ExitError = 0; SqlError = 0
  SYSMSGLVL1 = ""; SYSMSGLVL2 = ""
  Lower = "abcdefghijklmnopqrstuvwxyz"
  Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

  IF CALLED ¬= TRUE THEN CALLED = FALSE
  DEBUG = FALSE; DEFAULT = TRUE
RETURN
/* COPY DISHELP */
/********************************************************************** /*COPY*/
            This PROCEDURE displays the Help information in             /*COPY*/
                 this REXX's HEADER when invoked.                       /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_HELP: PROCEDURE                                                 /*COPY*/
ARG ExitOrReturn .                                                      /*COPY*/
  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/
     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/
  END                                                                   /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                                 /*COPY*/
  IF RC ¬= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/
  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/
     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/
     ok='0';ADDRESS "ISPEXEC" "TBCREATE RHELP02 NAMES(source) NOWRITE"  /*COPY*/
     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/
        source = source.i; ADDRESS "ISPEXEC" "TBADD RHELP02"            /*COPY*/
     END                                                                /*COPY*/
     ok='0';ADDRESS "ISPEXEC" "TBTOP RHELP02"                           /*COPY*/
     ZTDMARK = CENTER("----> END of Help <----",80)                     /*COPY*/
     ok='0 4 8';ADDRESS "ISPEXEC" "TBDISPL RHELP02 PANEL(RHELP02)"      /*COPY*/
     ok='0';ADDRESS "ISPEXEC" "TBCLOSE RHELP02"                         /*COPY*/
  END                                                                   /*COPY*/
                      /* Stay inside current EXEC or EXIT             *//*COPY*/
IF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/
   ELSE EXIT 0                                                          /*COPY*/
/* COPY NPPARMS */
/********************************************************************** /*COPY*/
            Initialize and process Non-Positional Parms in a            /*COPY*/
                method similar to that of CLISTs                        /*COPY*/
    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/
          not follow any internal ')' with spaces!!                     /*COPY*/
**********************************************************************/ /*COPY*/
DO_NP_PARMS:                                                            /*COPY*/
  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/
  ParmList = ''; ParmErrorList = ''                                     /*COPY*/
                                                                        /*COPY*/
  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/
     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/
     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/
  END                                                                   /*COPY*/
  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/
     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/
     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/
     parm = STRIP(parm)                                                 /*COPY*/
     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/
     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/
     ELSE IF INDEX(value,")") > 0 THEN                                  /*COPY*/
          ParmErrorList = ParmErrorList parm"("value                    /*COPY*/
     ELSE ParmErrorList = ParmErrorList parm"("value")"                 /*COPY*/
  END                                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN ParmErrorList ¬= '' & AcceptAll = TRUE          THEN           /*COPY*/
       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/
    WHEN ParmErrorList ¬= ''                             THEN DO        /*COPY*/
       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/
       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/
            "'"ParmErrorList"' not valid Parm(s) for" rname"!", "YES"   /*COPY*/
       EXIT 8                                                           /*COPY*/
      END                                                               /*COPY*/
  OTHERWISE                                                             /*COPY*/
      AnythingElse = STRIP(InList)                                      /*COPY*/
  END                                                                   /*COPY*/
  DO ParmInx = 1 TO linx                                                /*COPY*/
     SELECT                                                             /*COPY*/
       WHEN ABBREV(ParmVal.ParmInx, "&")                 |,             /*COPY*/
            ABBREV(ParmVal.ParmInx, "*")                 THEN           /*COPY*/
           INTERPRET parm.ParmInx "= '"ParmVal.ParmInx"'"               /*COPY*/
       WHEN DATATYPE(ParmVal.ParmInx, "NUM")             THEN           /*COPY*/
           INTERPRET parm.ParmInx "=" ParmVal.ParmInx                   /*COPY*/
       WHEN WORDPOS(ParmVal.ParmInx, "FALSE TRUE") > 0   THEN           /*COPY*/
           INTERPRET parm.ParmInx "=" ParmVal.ParmInx                   /*COPY*/
       WHEN (LEFT(ParmVal.ParmInx,1) = "'"               & ,            /*COPY*/
             RIGHT(ParmVal.ParmInx,1) = "'")             | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/
           INTERPRET parm.ParmInx "= ParmVal."ParmInx                   /*COPY*/
       WHEN INDEX(STRIP(ParmVal.ParmInx), " ") > 0       THEN           /*COPY*/
           INTERPRET parm.ParmInx "=" ParmVal.ParmInx                   /*COPY*/
     OTHERWISE                                                          /*COPY*/
        ADDRESS "MVS" "SUBCOM TSO"                                      /*COPY*/
        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/
        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/
        SELECT                                                          /*COPY*/
          WHEN ¬(TSO_avail) | PDS_name = ""              THEN           /*COPY*/
              INTERPRET parm.ParmInx "=" ParmVal.ParmInx                /*COPY*/
          WHEN SYSVAR("SYSNEST") = 'YES'                 THEN           /*COPY*/
              INTERPRET parm.ParmInx "=" ParmVal.ParmInx                /*COPY*/
          WHEN (INDEX(rest, ")") > 0                     &,             /*COPY*/
               (ABBREV(rest, "+") | ABBREV(rest,"-")     |,             /*COPY*/
                ABBREV(rest, "0)")))                     THEN           /*COPY*/
              INTERPRET parm.ParmInx "= '"ParmVal.ParmInx"'"            /*COPY*/
          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/
                LISTDSI("'"ParmVal.ParmInx"'")     <= 4  | ,            /*COPY*/
                LISTDSI("'"PDS_name"'")            <= 4  | ,            /*COPY*/
                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/
              INTERPRET parm.ParmInx "= ParmVal."ParmInx                /*COPY*/
        OTHERWISE                                                       /*COPY*/
              INTERPRET parm.ParmInx "=" ParmVal.ParmInx                /*COPY*/
        END                                                             /*COPY*/
     END                                                                /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY SETMSG */                                                       /*COPY*/
/********************************************************************** /*COPY*/
              Error with DSN, Use ISPF to display Error Message         /*COPY*/
***********************************************************************//*COPY*/
SET_MSG: PROCEDURE                                                      /*COPY*/
PARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                                 /*COPY*/
  SELECT                                                                /*COPY*/
   WHEN RC ¬= 0                   THEN DO                               /*COPY*/
      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/
    END                                                                 /*COPY*/
   WHEN SYSVAR("SYSNEST") = 'YES' &,                                    /*COPY*/
        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/
      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/
    END                                                                 /*COPY*/
  OTHERWISE                                                             /*COPY*/
      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/
         ELSE ZERRALRM = 'NO'                                           /*COPY*/
      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/
      ok='0';ADDRESS "ISPEXEC" "SETMSG MSG(ISRZ003)"                    /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/**********************************************************************
      Set various IGGCSI Defaults based on Passed Parameter
***********************************************************************/
SET_IGGCSI_DEFAULTS:
  SELECT  /* Initialize DEFAULT FIELDS Values per CSID Type           */
    WHEN CSIDTYPS = "A" & ABBREV("DEFAULT", FIELDS) THEN    /* non-VSAM       */
         FIELDS = 'VOLSER DSCRDT2 LTBACKDT'
    WHEN CSIDTYPS = "AX" & ABBREV("DEFAULT", FIELDS) THEN /* nonVSAM & Alias */
         FIELDS = 'VOLSER DSCRDT2 NAME'
    WHEN CSIDTYPS = "B" & ABBREV("DEFAULT", FIELDS) THEN    /* GDG Base       */
         FIELDS = 'GDGLIMIT GENLEVEL DSCRDT2 GDGALTDT GDGATTR'
    WHEN CSIDTYPS = "B" & ABBREV(FIELDS, "DEBUG")   THEN DO /* GDG Base       */
         FIELDS = 'GDGLIMIT DSCRDT2 GDGALTDT GDGATTR GENLEVEL'
         DEBUG = TRUE; DEFAULT = FALSE
      END
    WHEN CSIDTYPS = "C" & ABBREV("DEFAULT", FIELDS) THEN    /* VSAM Cluster   */
         FIELDS = 'ENTYPE FSDSFLAG VSAMTYPE'
    WHEN CSIDTYPS = "G" & ABBREV("DEFAULT", FIELDS) THEN    /* VSAM AIX       */
         FIELDS = 'AKEYPOS'
    WHEN CSIDTYPS = "H" & ABBREV("DEFAULT", FIELDS) THEN    /* GDG DSN        */
         FIELDS = 'VOLSER DSCRDT2 LTBACKDT'
    WHEN CSIDTYPS = "L" & ABBREV("DEFAULT", FIELDS) THEN    /* Tape Library   */
         FIELDS = 'LCBCONID'
    WHEN CSIDTYPS = "R" & ABBREV("DEFAULT", FIELDS) THEN    /* VSAM Path      */
         FIELDS = 'NAME'
    WHEN CSIDTYPS = "U" & ABBREV("DEFAULT", FIELDS) THEN    /* USER Catalog   */
         FIELDS = 'NAME'
    WHEN CSIDTYPS = "W" & ABBREV("DEFAULT", FIELDS) THEN    /* Tape Volume Ent*/
         FIELDS = 'VCBLIBNM'
    WHEN CSIDTYPS = "X" & ABBREV("DEFAULT", FIELDS) THEN    /* Alias          */
         FIELDS = 'NAME'
  OTHERWISE; DEFAULT = FALSE; END
          /* Initial variables used by IGGCSI interface (& Macro)     */
RETURN
/* COPY IGGINIT */
/********************************************************************** /*COPY*/
      Initialze the API before calling IGGCSI                           /*COPY*/
***********************************************************************//*COPY*/
INITIALIZE_IGGCSI_API:                                                  /*COPY*/
  MODRSNRC = LEFT(' ',4)              /* CLEAR MODULE/RETURN/REASON   *//*COPY*/
  CSIFILTK = LEFT(STRIP(DsnLevel,"B","'"),44) /*MOVE FILTER INTO LIST*/ /*COPY*/
  CSICATNM = LEFT(STRIP(CATALOG,"B","'"),44)   /*   SET CATALOG NAME  *//*COPY*/
  CSIRESNM = LEFT(' ',44)             /* CLEAR RESUME NAME            *//*COPY*/
  CSIDTYPS = LEFT(CSIDTYPS,16)        /* ABCGHRUX are valid entries   *//*COPY*/
  CSICLDI  = LEFT('Y',1)              /* INDICATE DATA AND INDEX      *//*COPY*/
  CSIRESUM = LEFT(' ',1)              /* CLEAR RESUME FLAG            *//*COPY*/
  IF CATALOG = "" THEN                /* Did we specify a catalog?    *//*COPY*/
       CSIS1CAT = LEFT(' ',1)         /* ... No, search > 1 Catalog   *//*COPY*/
  ELSE CSIS1CAT = LEFT('Y',1)         /* ... Yes, search that Catalog *//*COPY*/
  CSIOPTNS = LEFT(' ',1)              /* CLEAR RESERVE CHARACTER      *//*COPY*/
  SELECT                                                                /*COPY*/
    WHEN WORDS(FIELDS)            = 0     THEN DO; fld.=""; fld.0=0; END/*COPY*/
    WHEN WORDS(FIELDS)            = 1     THEN CALL FLDS_WO_LENGTH      /*COPY*/
    WHEN DATATYPE(WORD(FIELDS,2)) = "NUM" THEN CALL FLDS_WITH_LENGTH    /*COPY*/
    WHEN WORD(FIELDS,2) = "VL"            THEN CALL FLDS_WITH_LENGTH    /*COPY*/
  OTHERWISE;                                   CALL FLDS_WO_LENGTH ; END/*COPY*/
  CSINUMEN = X2C(RIGHT(D2X(fld.0),4,'0'))                               /*COPY*/
  /********************************************************************//*COPY*/
  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      *//*COPY*/
  /********************************************************************//*COPY*/
  CSIOPTS  = CSICLDI ||CSIRESUM||CSIS1CAT||CSIOPTNS                     /*COPY*/
  CSIFIELD = CSIFILTK||CSICATNM||CSIRESNM||CSIDTYPS||CSIOPTS||CSINUMEN  /*COPY*/
  DO i = 1 TO fld.0; CSIFIELD = CSIFIELD||fld.i.nm; END                 /*COPY*/
  /********************************************************************//*COPY*/
  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     *//*COPY*/
  /********************************************************************//*COPY*/
  WORKLEN = 32768; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))            /*COPY*/
  DWORK = CSIUSRLN||COPIES('00'X,WORKLEN-4)                             /*COPY*/
                                                                        /*COPY*/
  CATNAMET = ''; DNAMET = ''; dsns. = ""; dsns.0 = 0                    /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
      Process FIELDS Variable when Length is provided                   /*COPY*/
***********************************************************************//*COPY*/
FLDS_WITH_LENGTH:                                                       /*COPY*/
  fld. = ""; fld.0 = WORDS(FIELDS)/2                                    /*COPY*/
  DO i=1 TO WORDS(FIELDS)/2                                             /*COPY*/
     fld.i.nm=LEFT(WORD(FIELDS,(((i-1)*2)+1)),8)                        /*COPY*/
     fld.i.ln=WORD(FIELDS,(((i-1)*2)+2))                                /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
      Process FIELDS Variable when Length is NOT provided               /*COPY*/
***********************************************************************//*COPY*/
FLDS_WO_LENGTH:                                                         /*COPY*/
  fld. = ""; fld.0 = WORDS(FIELDS)                                      /*COPY*/
  DO i=1 TO fld.0                                                       /*COPY*/
     fld.i.nm = LEFT(WORD(FIELDS,i),8)                                  /*COPY*/
     PARSE VALUE VER_FNM(fld.i.nm) WITH fld.i.ln fld.i.ty fld.i.rp      /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY IGGFNM */                                                       /*COPY*/
/********************************************************************** /*COPY*/
      Verify Field Name and Set Attributes (from SYS1.MACLIB(IGGCSI))   /*COPY*/
***********************************************************************//*COPY*/
VER_FNM:                                                                /*COPY*/
ARG fnm .                                                               /*COPY*/
  SELECT               /* Validate Field name and assign attributes   *//*COPY*/
    WHEN fnm = "ACTOKEN"  THEN RETURN 36   "CH" "N"                     /*COPY*/
    WHEN fnm = "AKEYPOS"  THEN RETURN 2    "F"  "N"                     /*COPY*/
    WHEN fnm = "AMDCIREC" THEN RETURN 8    "F"  "N"                     /*COPY*/
    WHEN fnm = "AMDKEY"   THEN RETURN 4    "R"  "N"                     /*COPY*/
    WHEN fnm = "ASSOCSYM" THEN RETURN 45   "CH" "Y"                     /*COPY*/
    WHEN fnm = "ATTR1"    THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "ATTR2"    THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "BUFSIZE"  THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "CATTR"    THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "COMPIND"  THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "COMUDSIZ" THEN RETURN 8    "F"  "N"                     /*COPY*/
    WHEN fnm = "DATACLAS" THEN RETURN "VL" "CH" "N"                     /*COPY*/
    WHEN fnm = "DEVTYP"   THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "DSCBTTR"  THEN RETURN 3    "F"  "Y"                     /*COPY*/
    WHEN fnm = "DSCRDT2"  THEN RETURN 4    "MX" "N"                     /*COPY*/
    WHEN fnm = "DSEXDT2"  THEN RETURN 4    "MX" "N"                     /*COPY*/
    WHEN fnm = "ENTYPE"   THEN RETURN 1    "CH" "N"                     /*COPY*/
    WHEN fnm = "ENTNAME"  THEN RETURN 44   "CH" "N"                     /*COPY*/
    WHEN fnm = "EXCPEXIT" THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "FILESEQ"  THEN RETURN 2    "F"  "Y"                     /*COPY*/
    WHEN fnm = "GDGALTDT" THEN RETURN 4    "MX" "N"                     /*COPY*/
    WHEN fnm = "GDGATTR"  THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "GDGLIMIT" THEN RETURN 1    "F"  "N"                     /*COPY*/
    WHEN fnm = "GENLEVEL" THEN RETURN 4    "CH" "Y"                     /*COPY*/
    WHEN fnm = "HARBA"    THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "HARBADS"  THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "HIKEYV"   THEN RETURN "VL" "CH" "Y"                     /*COPY*/
    WHEN fnm = "HKRBA"    THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "HURBA"    THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "HURBADS"  THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "ITYPEXT"  THEN RETURN 1    "BS" "Y"                     /*COPY*/
    WHEN fnm = "LOGPARMS" THEN RETURN 1    "B"  "N"                     /*COPY*/
    WHEN fnm = "LOGSTRID" THEN RETURN 26   "CH" "N"                     /*COPY*/
    WHEN fnm = "LOKEYV"   THEN RETURN "VL" "CH" "Y"                     /*COPY*/
    WHEN fnm = "LRECL"    THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "LTBACKDT" THEN RETURN 8    "F"  "N"                     /*COPY*/
    WHEN fnm = "MGMTCLAS" THEN RETURN "VL" "CH" "N"                     /*COPY*/
    WHEN fnm = "NAME"     THEN RETURN 44   "CH" "Y"                     /*COPY*/
    WHEN fnm = "NOBLKTRK" THEN RETURN 2    "F"  "Y"                     /*COPY*/
    WHEN fnm = "NOBYTAU"  THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "NOBYTTRK" THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "NOEXTNT"  THEN RETURN 1    "F"  "Y"                     /*COPY*/
    WHEN fnm = "NOTRKAU"  THEN RETURN 2    "F"  "Y"                     /*COPY*/
    WHEN fnm = "NVSMATTR" THEN RETURN 1    "CH" "Y"                     /*COPY*/
    WHEN fnm = "OPENIND"  THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "OWNERID"  THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "PASSATMP" THEN RETURN 2    "F"  "N"                     /*COPY*/
    WHEN fnm = "PASSPRMT" THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "PASSWORD" THEN RETURN 32   "CH" "N"                     /*COPY*/
    WHEN fnm = "PHYBLKSZ" THEN RETURN 4    "F"  "Y"                     /*COPY*/
    WHEN fnm = "PRIMSPAC" THEN RETURN 3    "F"  "N"                     /*COPY*/
    WHEN fnm = "RECVTIME" THEN RETURN 8    "B"  "N"                     /*COPY*/
    WHEN fnm = "RECVTIMG" THEN RETURN 8    "B"  "N"                     /*COPY*/
    WHEN fnm = "RGATTR"   THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "RLSBWO"   THEN RETURN 1    "B"  "N"                     /*COPY*/
    WHEN fnm = "RLSFLAGS" THEN RETURN 1    "B"  "N"                     /*COPY*/
    WHEN fnm = "SCONSPAC" THEN RETURN 3    "F"  "N"                     /*COPY*/
    WHEN fnm = "SECFLAGS" THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "SPACOPTN" THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "STORCLAS" THEN RETURN "VL" "CH" "N"                     /*COPY*/
    WHEN fnm = "STRIPCNT" THEN RETURN  2   "F"  "N"                     /*COPY*/
    WHEN fnm = "TYPE"     THEN RETURN 1    "CH" "Y"                     /*COPY*/
    WHEN fnm = "UDATASIZ" THEN RETURN 8    "F"  "N"                     /*COPY*/
    WHEN fnm = "USVRMDUL" THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "USERAREC" THEN RETURN "VL" "CH" "N"                     /*COPY*/
    WHEN fnm = "VOLSER"   THEN RETURN 6    "CH" "Y"                     /*COPY*/
    WHEN fnm = "VOLFLG"   THEN RETURN 1    "BS" "Y"                     /*COPY*/
    WHEN fnm = "VSAMREUS" THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "VSAMSTAT" THEN RETURN 46   "F"  "N"                     /*COPY*/
    WHEN fnm = "VSAMTYPE" THEN RETURN 2    "BS" "N"                     /*COPY*/
    WHEN fnm = "VVRNFLGS" THEN RETURN 2    "BS" "N"                     /*COPY*/
    WHEN fnm = "XACIFLAG" THEN RETURN 1    "BS" "N"                     /*COPY*/
    WHEN fnm = "XHARBA"   THEN RETURN 8    "F"  "Y"                     /*COPY*/
    WHEN fnm = "XHARBADS" THEN RETURN 8    "F"  "N"                     /*COPY*/
    WHEN fnm = "XHKRBA"   THEN RETURN 8    "F"  "Y"                     /*COPY*/
    WHEN fnm = "XHURBADS" THEN RETURN 8    "F"  "N"                     /*COPY*/
    WHEN fnm = "XHURBA"   THEN RETURN 8    "F"  "Y"                     /*COPY*/
 /* Tape Library Entry Field Names                                    *//*COPY*/
    WHEN fnm = "LCBCONID" THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "LCBDEVTP" THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "LCBDESCR" THEN RETURN 120  "CH" "N"                     /*COPY*/
    WHEN fnm = "LCBEMPTY" THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "LCBLIBID" THEN RETURN 5    "CH" "N"                     /*COPY*/
    WHEN fnm = "LCBLOGIC" THEN RETURN 1    "B"  "N"                     /*COPY*/
    WHEN fnm = "LCBSCRTH" THEN RETURN 1020 "F"  "N"                     /*COPY*/
    WHEN fnm = "LCBSLOTS" THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "LCBTHRES" THEN RETURN 1020 "F"  "N"                     /*COPY*/
 /* Tape Volume Entry Field Names                                     *//*COPY*/
    WHEN fnm = "VCBCHKPT" THEN RETURN 1    "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBCRDT"  THEN RETURN 10   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBDEVTP" THEN RETURN 4    "F"  "N"                     /*COPY*/
    WHEN fnm = "VCBEDATE" THEN RETURN 10   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBERRST" THEN RETURN 2    "BS" "N"                     /*COPY*/
    WHEN fnm = "VCBEXPDT" THEN RETURN 10   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBLIBNM" THEN RETURN 44   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBLOC"   THEN RETURN 1    "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBMOUNT" THEN RETURN 10   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBOWNER" THEN RETURN 64   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBSGRP"  THEN RETURN 8    "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBSHELF" THEN RETURN 32   "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBUATTR" THEN RETURN 1    "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBWPROT" THEN RETURN 1    "CH" "N"                     /*COPY*/
    WHEN fnm = "VCBWRITE" THEN RETURN 10   "CH" "N"                     /*COPY*/
  OTHERWISE                                                             /*COPY*/
     CALL SET_MSG ,"Unsupported Field Name: '"fnm"'","YES"              /*COPY*/
  END                                                                   /*COPY*/
EXIT 8                                                                  /*COPY*/
/**********************************************************************
      Expand CSICTYPE Value for Dataset Type
***********************************************************************/
SET_DSN_TYPE:
  SELECT                           /* ASSIGN ENTRY TYPE NAME          */
    WHEN CSICTYPE = 'A' THEN DTYPE = 'NONVSAM '
    WHEN CSICTYPE = 'X' THEN DTYPE = 'ALIAS   '
    WHEN CSICTYPE = 'U' THEN DTYPE = 'UCAT    '
    WHEN CSICTYPE = 'H' THEN DTYPE = 'GDS     '
    WHEN CSICTYPE = 'B' THEN DTYPE = 'GDG     '
    WHEN CSICTYPE = 'C' THEN DTYPE = 'CLUSTER '
    WHEN CSICTYPE = 'D' THEN DTYPE = 'DATA    '
    WHEN CSICTYPE = 'I' THEN DTYPE = 'INDEX   '
    WHEN CSICTYPE = 'R' THEN DTYPE = 'PATH    '
    WHEN CSICTYPE = 'G' THEN DTYPE = 'AIX     '
    WHEN CSICTYPE = 'L' THEN DTYPE = 'TAPELIB '
    WHEN CSICTYPE = 'W' THEN DTYPE = 'TAPEVOL '
  OTHERWISE;                 DTYPE = '        '; END
RETURN
/**********************************************************************
      Check for and process Fields in non-viewable format
***********************************************************************/
PROCESS_FIELDS:
  SELECT    /* Handle the translation of FIELDS          */
    WHEN WORDPOS(fld.i.nm, "DSCRDT2 DSEXDT2 GDGALTDT")   > 0 THEN DO
        IF C2X(fld.i.lst) = 'FFFFFFFF' THEN fld.i.lst = "?????????"
        ELSE DO
           PARSE VALUE C2X(fld.i.lst) WITH yy 3 jjj 6 . 7 cent .
           fld.i.lst = VALUE(19 + cent) || yy || jjj
        END
      END
    WHEN WORDPOS(fld.i.nm, "LTBACKDT RECVTIME RECVTIMG") > 0 THEN DO
        TUNITS = C2X(fld.i.lst)
        IF TUNITS ¬= 'FFFFFFFFFFFFFFFF' THEN DO /* Convert TimeStamp */
           TIMESTAMP = LEFT('',26)
           ok='0';ADDRESS "LINKPGM" "BLSUXTOD TUNITS TIMESTAMP"
           fld.i.lst = TIMESTAMP
          END
        ELSE fld.i.lst = LEFT(fld.i.nm '- Unknown',26)
      END
    WHEN WORDPOS(fld.i.nm, "GDGLIMIT")                   > 0 THEN
        fld.i.lst = RIGHT(C2D(fld.i.lst),3)
    WHEN WORDPOS(fld.i.nm, "GENLEVEL") > 0 & DEFAULT         THEN
        fld.i.lst = RIGHT(fld.i.totln%4,3)
    WHEN WORDPOS(fld.i.nm, "GENLEVEL")                   > 0 THEN DO
        PARSE VALUE fld.i.lst WITH _list_ 5 fld.i.lst
        DO WHILE fld.i.lst ¬= ""
           PARSE VALUE fld.i.lst WITH _level_ 5 fld.i.lst
           _list_ = _list_ _level_
        END
        fld.i.lst = RIGHT(fld.i.totln%4,3) "Levels" _list_
      END
    WHEN WORDPOS(fld.i.nm, "GDGATTR")                    > 0 THEN DO
       SELECT
         WHEN fld.i.lst = '40'x THEN fld.i.lst = "DEL Oldest -     SCRATCH"
         WHEN fld.i.lst = '80'x THEN fld.i.lst = "Delete All - NoScratch"
         WHEN fld.i.lst = 'C0'x THEN fld.i.lst = "Delete All -     SCRATCH"
       OTHERWISE;                    fld.i.lst = "DEL Oldest - NoScratch";END
      END
    WHEN WORDPOS(fld.i.nm, "ENTYPE")                     > 0 THEN DO
       SELECT
         WHEN fld.i.lst = 'C'   THEN fld.i.lst = LEFT("Cluster",9)
         WHEN fld.i.lst = 'D'   THEN fld.i.lst = LEFT("Data",9)
         WHEN fld.i.lst = 'I'   THEN fld.i.lst = LEFT("Index",9)
         WHEN fld.i.lst = 'G'   THEN fld.i.lst = LEFT("Alt-Index",9)
         WHEN fld.i.lst = 'R'   THEN fld.i.lst = LEFT("VSAM-Path",9)
         WHEN fld.i.lst = 'A'   THEN fld.i.lst = LEFT("Non-VSAM",9)
       OTHERWISE; NOP; END
       IF fld.i.lst = "Cluster" THEN is_Clust = TRUE
      END
    WHEN WORDPOS(fld.i.nm, "FSDSFLAG")                   > 0 THEN DO
       IF fld.i.lst = '80'x      THEN is_zFS   = TRUE
       fld.i.lst = ""
      END
    WHEN WORDPOS(fld.i.nm, "NAME")                       > 0 &,
         WORDS(fld.i.lst) > 1                                THEN DO
       _list_ = STRIP(WORD(fld.i.lst,1))
       DO _w_ = 2 TO WORDS(fld.i.lst)
          _list_ = _list_ STRIP(WORD(fld.i.lst,_w_))
       END
       fld.i.lst = _list_
      END
    WHEN WORDPOS(fld.i.nm, "VSAMTYPE") > 0 & is_zFS          THEN
       fld.i.lst = "zFS Linear"
    WHEN WORDPOS(fld.i.nm, "VSAMTYPE") > 0 & is_Clust        THEN DO
       PARSE VALUE fld.i.lst WITH byte1 2 byte2
       SELECT
         WHEN BITAND(byte1,'80'x) > '00'x &,
              BITAND(byte2,'80'x)>'00'x THEN fld.i.lst = "KSDS Unique"
         WHEN BITAND(byte1,'80'x)>'00'x THEN fld.i.lst = "KSDS non-Unique"
         WHEN BITAND(byte2,'04'x)='00'x THEN fld.i.lst = "Linear"
       OTHERWISE;                            fld.i.lst = ""; END
       IF BITAND(byte1,'20'x)    ='00'x THEN fld.i.lst = fld.i.lst "Imbed"
       IF BITAND(byte1,'10'x)    ='00'x THEN fld.i.lst = fld.i.lst "Replicate"
       IF BITAND(byte1,'04'x)    ='00'x THEN fld.i.lst = fld.i.lst "KeyRanged"
      END
    WHEN WORDPOS(fld.i.nm, "VSAMTYPE") > 0                   THEN
       fld.i.lst = ""
    WHEN WORDPOS(fld.i.nm, "VSAMREUS")                   > 0 THEN DO
       PARSE VALUE fld.i.lst WITH byte1 2 byte2
       IF BITAND(byte1,'80'x)    >'00'x THEN fld.i.lst = "Discrete Profile"
          ELSE                               fld.i.lst = ""
       IF BITAND(byte1,'40'x)    >'00'x THEN fld.i.lst = fld.i.lst "Index"
       IF BITAND(byte1,'20'x)    >'00'x THEN fld.i.lst = fld.i.lst "Reusable"
       IF BITAND(byte1,'10'x)    >'00'x THEN fld.i.lst = fld.i.lst "Erase"
       IF BITAND(byte1,'02'x)    >'00'x THEN fld.i.lst = fld.i.lst "SwapSpace"
       IF BITAND(byte1,'01'x)    >'00'x THEN fld.i.lst = fld.i.lst "PageSpace"
      END
  OTHERWISE; NOP; END
RETURN
/**********************************************************************
      Processing CATALOG information, output the CATALOG header
***********************************************************************/
PROCESS_CATALOGS:
  IF CSICNAME ¬= CATNAMET & CSICFLG = '00'x THEN DO
     IF dsns.0 > 0 THEN DO; k=1+dsns.0; dsns.0=k ; dsns.k=''; END
     k = 1+dsns.0; dsns.0 = k
     dsns.k = "Catalog" Strip(CSICNAME) "of code type" C2X(CSICFLG),
              "with RC="C2D(CSICRETR) "and RSN="C2D(CSICRETN)
  END
  CATNAMET = CSICNAME
RETURN
/**********************************************************************
      We now have NAME AND TYPE ... Get the rest of the Info
***********************************************************************/
PROCESS_NONCATALOGS:
  is_zFS = FALSE; is_Clust = FALSE
  CSICRETM = C2D(CSICRETM)
  start_at = 2*fld.0; fld_start = 1
  lengths  = SUBSTR(rest,1,start_at)
  fld_list = SUBSTR(rest,start_at+1,CSICRETM-(start_at+4))
  rest     = SUBSTR(rest,CSICRETM-3)
  IF DNAMET = CSICNAME THEN ITERATE; ELSE DNAMET = CSICNAME
  k = 1+dsns.0; dsns.0 = k; dsns.k = LEFT('',3) CSICNAME
  DO i = 1 TO fld.0
     fld.i.totln = C2D(SUBSTR(lengths,((i*2)-1),2))
     fld.i.lst   = SUBSTR(fld_list,fld_start,fld.i.totln)
     CALL PROCESS_FIELDS
     dsns.k      = dsns.k fld.i.lst
     fld_start   = fld_start + fld.i.totln
  END
RETURN
/**********************************************************************
      An error occured calling IGGCSI00; Display RC, MODRSNRC, the
         PARMs used in CALL, and the Returned WORK area.
***********************************************************************/
DISPLAY_IGGCSI_ERROR:
  SAY  "IGGCSI Error!  LINK RC="RC "MOD="LEFT(MODRSNRC,2),
       "RSN="C2D(SUBSTR(MODRSNRC,3,1)) "RC="C2D(SUBSTR(MODRSNRC,4,1))
  SAY  "_______________________ CSIFIELD ______________________"
  SAY  CSIFIELD
  SAY  "________________________ DWORK ________________________"
  SAY  DWORK
  SAY  "_______________________________________________________"
EXIT RC
/* COPY ERRPROC */
/********************************************************************** /*COPY*/
      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/
***********************************************************************//*COPY*/
ERROR_PROC:                                                             /*COPY*/
  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/
     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/
                                                                        /*COPY*/
  TRACE("O")                        /* Turn off ERROR traps et.al.    *//*COPY*/
  elineno = sigl                    /* Source line error occured in   *//*COPY*/
  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/
  SIGNAL OFF NOVALUE                                                    /*COPY*/
  CALL   OFF ERROR                                                      /*COPY*/
  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/
                                                                        /*COPY*/
  "SUBCOM ISPEXEC"                  /* Is ISPF available?             *//*COPY*/
  IF RC = 0 THEN IF SYSVAR('SYSENV') ¬= 'BACK' THEN DO UNTIL RC ¬= 0    /*COPY*/
        eresults = ""                                                   /*COPY*/
        DO QUEUED()                                                     /*COPY*/
           PARSE PULL eresult                                           /*COPY*/
           eresults = STRIP(eresults "NL ===>" eresult)                 /*COPY*/
        END                                                             /*COPY*/
        ADDRESS "ISPEXEC" "DISPLAY PANEL(REXXEPNL)"                     /*COPY*/
      END                                                               /*COPY*/
    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/
  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/
                                                                        /*COPY*/
  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/
  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/
RETURN                                                                  /*COPY*/
/* COPY ERRINFO  */                                                     /*COPY*/
/********************************************************************** /*COPY*/
      Get the information about the ERROR and format it                 /*COPY*/
***********************************************************************//*COPY*/
GET_ERROR_INFO:                                                         /*COPY*/
  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/
  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/
  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/
  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/
  sourcel = STRIP(sourcel)                                              /*COPY*/
  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/
     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/
     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/
     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/
  END                           /* END loop to handle continued lines *//*COPY*/
  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/
     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/
     expandl = "Can't INTERPRET source with SYNTAX errors!"             /*COPY*/
    END                                                                 /*COPY*/
  ELSE DO                                                               /*COPY*/
     Lst = "ADDRESS CALL INTERPRET SAY"                                 /*COPY*/
     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/
     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/
     expandl = ""                                                       /*COPY*/
     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/
        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/
        SELECT                                                          /*COPY*/
          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/
          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/
          WHEN INDEX(srcl,"=")           > 1        THEN evals=srcl     /*COPY*/
        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/
        IF DATATYPE(evals, "NUM")                   THEN evals=srcl     /*COPY*/
        expandl = expandl';' evals                                      /*COPY*/
     END                                                                /*COPY*/
     expandl = STRIP(STRIP(expandl,"L",";"))                            /*COPY*/
  END                                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/
          emsg = ZERRLM                                                 /*COPY*/
    WHEN SYMBOL('SYSMSGLVL1') ¬= 'VAR'              THEN                /*COPY*/
          emsg = 'No available ERROR description.'                      /*COPY*/
    WHEN SYSMSGLVL1 = ""                            THEN                /*COPY*/
          emsg = 'No available ERROR description.'                      /*COPY*/
  OTHERWISE                                                             /*COPY*/
     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/
          emsg = SYSMSGLVL1 "--" SYSMSGLVL2                             /*COPY*/
     ELSE emsg = SYSMSGLVL1                                             /*COPY*/
  END                                                                   /*COPY*/
  IF INDEX(emsg, "IN VARIABLE SYSREASON") > 0       THEN                /*COPY*/
          emsg = "SYSREASON: '"SYSREASON"'"                             /*COPY*/
  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/
     ELSE ExitError = RC                                                /*COPY*/
  erc = ExitError       /* Get all information about error            *//*COPY*/
RETURN                                                                  /*COPY*/
/* COPY MVSERROR */                                                     /*COPY*/
/********************************************************************** /*COPY*/
                 Output ERROR information to SYSPRINT                   /*COPY*/
***********************************************************************//*COPY*/
MVS_ERROR_DISPLAY:                                                      /*COPY*/
  eresult. = "";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/
  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/
  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/
  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/
  SAY ''                            /* Start SAYing error information *//*COPY*/
  SAY  CENTER(CENTER(" An ERROR occurred in REXX '"erexx"' ",50,'*'),ls)/*COPY*/
  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/
  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/
  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/
  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/
  DO eresults = 2 TO eresult.0                                          /*COPY*/
     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/
  END                                                                   /*COPY*/
  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/
  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/
  SAY CENTER(CENTER("      End of ERROR Reporting     ",50,'*'),ls)     /*COPY*/
  SAY CENTER(CENTER("   Beginning of Error Handling   ",50,'*'),ls)     /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/
   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/
   the first one found.  So, a REXX specific version of these can       /*COPY*/
   be use writen if it is placed before ERROR_PROC.                     /*COPY*/
***********************************************************************//*COPY*/
ERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/
RETURN                                                                  /*COPY*/
CLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/
  ADDRESS "ISPEXEC" "FTCLOSE"       /* CLOSE File Tailoring FILE      *//*COPY*/
  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/
  ADDRESS "ISPEXEC" "VPUT (ZISPFRC)"                                    /*COPY*/
EXIT ExitError                      /* EXIT with error return code    *//*COPY*/
