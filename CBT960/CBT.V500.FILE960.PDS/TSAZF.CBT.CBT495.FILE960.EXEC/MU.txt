/***************************** REXX ***********************************
   This REXX/ISPF MACRO dices, it slices, it does Julian Fries; So order
        before midnight tonight and receive this handy dandy utility
        REXX absolutely free... oops, wrong comercial.

   This REXX/ISPF Macro supports full screen Point-N-Shoot. To improve
        this functionality, assign it to a PFKey, add it as an ISPF CMD,
        or, better yet, do both!

   This REXX/ISPF Macro is a combination for the ISPF option 3.4 'M'
        (PDS Maintenance) selection for PDSs, ISPF option 3.3 (Member
        Copy/Move), and many other useful utilities for PDS members.

   MU will also accept ISPF Macros as line commands.  You must proceed the
        macro with a '%' (or '!' if is is compiled) to indicate it is an
        ISPF Macro.  If the macro finishes with a RC <= 1 you will be
        returned to the member list.  If the RC > 1 you will be placed
        in an EDIT session on the member the macro was being applied
        against.

   Valid line options:
            ALIAS: 'a A'        -- Create ALIAS for specified member
            ALLOC: 'aa AL'      -- Allocate member to DD
           BROWSE: 'b B'        -- Browse member
            CLIST: 'cl'         -- EXECUTE the member as a CLIST
             COPY: 'c C'        -- Copy member to a PDS
           DELETE: 'd D'        -- Delete member from PDS
             EDIT: 'e s E S /'  -- Edit member
             EXEC: 'exec'       -- EXECUTE the member as a REXX
        EXEC View: 'exv'        -- EXECUTE the member using TSOVIES
             HELP: 'h H -h -H'  -- Display MU help
       MAKE ALIAS: 'ma MA'      -- Make an ALIAS to the specified name
             MOVE: 'm M'        -- Move member to a PDS
     NEXT VERSION: 'n N'        -- Update member stats incrementing version
            PRINT: 'p P'        -- Print member using RPRINT saved info
           RENAME: 'r R'        -- Rename member
           SUBMIT: 'j J'        -- Submit the current member
            TOUCH: 't T'        -- Update Changed and ID info for member
             VIEW: 'v V'        -- View member
          EXCLUDE: 'x X'        -- Excludes the Current Member from the list
     Xmit Receive: 'xr XR'      -- TSO XMIT Receive the selected Member
        Xmit Send: 'xs XS'      -- TSO XMIT Send the selected Member
       ISPF Macro: all else     -- Invoke the ISPF Macro against member
   Additional options from member list command line:
             COMPRess           -- Compress current PDS and refresh member list
             NP-PARMS           -- As defined below
             REFresh            -- Refresh current PDS member list
             RESet              -- Reset current member list
             TSO COMMANDs       -- As normal, but leading 'TSO ' not required

                           --- EXAMPLE ---
TSO <%>MU DsName NP_PARMS       -- As a TSO REXX
    <%>MU DsName NP_PARMS       -- AS an ISPF Macro

 NP-PARMS: <COMpress(N|Y)> <IMAcro(macro_name)> <MEMbers(mem_filter)>,
           <NOData(N|Y)> <SYSuid(7_char_stamp> <TESt(TraceOption)>
           <VOLser(dsn_volser)> <EXTended(YES|NO)>
                   <FORMAT(blank|ASCII|UTF8)>
                           blank (EBCDIC), ASCII, or UTF8
<TSO> <%>MU -H -- To display help for this REXX/ISPF Macro

  Arguments: DsName      - PDS to %MU, with or without member filter.
             InParms     - Non-Positional  parameters
             --- NP-PARMs can also be entered from the ---
             --- MEMBER LIST OPTION ===> line.         ---
 ----------------------------- NP-PARMS -------------------------------
                  ALWAYS - Use copy information on copy panel, N or Y.
                           Usually set via copy or move panel.
                           default: N
                COMPRESS - Compress current DsName, N or Y.
                           default: N
                EXTENDED - Use ISPF Extended Member Statistics, YES or NO.
                           default: YES
                  FORMAT - Charactor encoding          default: blank
                  IMACRO - Initial ISPF EDIT Macro
                           default: ALIASMC
                 MEMBERS - Member template to filter member list
                           default: *
                  NODATA - Blank member statistics when "TOUCHed", Y or N
                           default: N
                  PROMPT - Confirm member deletes, TRUE or FALSE
                           NP-Parm supported but currently not used.
                           default: TRUE
                  SYSUID - 7 Character "ID" to use for ID when a member is
                           "TOUCHed", "NEXT VERSIONed", and as ID in "XMIT"
                           default: Current RACF ID
                  VOLSER - Volume Serial Number to display DSNs for.
                           default: ZDLVOL
                    TEST - Used to control traces

      Files: Current and target PDSs
Other EXECS: ALIASMC & MACREPM Edit Macros
             CREC CList to all XR (TSO RECEIVE) command to work.

EXEC History

EXEC/MACRO Name: MU
         Author: AL FERGUSON - TS ADM (TSAZFA) from version 5.10
                 Al Ferguson (HUL2353) from version 1.00
                 ALBERT HULSEBOSCH (TTECAH1)
         Writen: 01APR93
        History: 28SEP17 - v7.05 - More Point-N-Shoot Fixes.
                 18SEP17 - v7.02 - Refactoring
                 12SEP17 - v6.57 - Fixes to TSO RECEIVE under ISPF REXX.
                 12SEP17 - v6.42 - Blank out EXTENDED when not 'YES'
                 29AUG17 - v6.34 - Better handle LMMDISP OPTION(PUT)
                           Failures. Fix RECEIVE to run under REXX.
                 09AUG17 - v6.20 - Add support for ASCII & UTF8 formats
                 21JUN17 - v6.10 - Cleanup point & shoot, plus add
                           support for ZCURWID ISPF System Variable.
                 19MAY17 - v6.06 - Keep Cursor Col & Advance Row when
                           invoked as Macro.
                 02MAY17 - v6.02 - Minor Refactoring
                 02MAY17 - v6.00 - Add support for MACREPM RepParm
                           Parameter
                 13MAR17 - v5.96 - More Point-N-Shoot corrections.
                 01MAR17 - v5.81 - Fixes to XMIT to support multiple
                           members in selection.
                 28FEB17 - v5.59 - Re-enamble Xmit Send & Receive.
                 06FEB17 - v5.55 - Fix Point-N-Shoot math, again.
                 06FEB17 - v5.47 - Pick up updated version of ERRINFO
                           Common Code routines.
                 01FEB17 - v5.45 - Mass update for Error Handling Fixes.
                 31JAN17 - v5.44 - Update all REXXes with latest
                           common routines via %CCMASS
                 26JAN17 - v5.44 - Tweak Point & Shoot logic.
                 23NOV16 - v5.36 - Tweak Point-n-Shoot math
                 22NOV16 - v5.28 - Rewrite of Point and shoot section
                           to make work as an ISPF Command when not in
                           an edit session.
                 10AUG16 - v5.19 - Changes to support use of DDs.
                 04MAY16 - v5.10 - Use IBM Default Edit/View PANEL vs
                           custom ED01 Panel.
                 16OCT13 - v5.00 - Updates to Macro support, MU now
                           behaves like ISPF's Member command (all
                           non-line commands are treated as ISPF Macros
                           or Member Commands
                 14FEB11 - v4.49 - Add point & Shoot against USS PATHs.
                 08SEP10 - v4.46 - Support Extended Statistics with TOUCH
                 09APR10 - v4.41 - Initial 'J - SUBMIT' option support,
                           similar to the ISPF Member List option.
                 03DEC02 - v4.04 - Support for 'EX - EXEC' Line option.
                 31MAR00 - v4.00 - Added MAKE ALIAS line command.
                 17SEP98 - v3.99 - Fix problems with bad INITIAL
                           Macro during VIEWs.
                 18JUL96 - v3.90 - Add support for ISPF Viewing
                 16JUL96 - v3.88 - Display correct message from TSO
                           RENAME-ALIAS command failure.
                 16JUL96 - v3.85 - Have LMMDISP use PANEL ISRUDSM,
                           same panel as used be 3.4 functions.
                 29APR96 - v3.79 - Support for VOLSER specific DSNs
                 03JAN96 - v3.65 - Edit Recovery Checking and Support.
                 26DEC95 - v3.57 - Enhanced '=' logic in Copy/Move window.
                 20DEC95 - v3.55 - Added REFresh option to rebuild the
                           current memberlist.
                 13OCT95 - v3.49 - Changes to rename function to handle
                           renaming a member to an already existing
                           member name.
                 04OCT95 - v3.48 - Update standard routines and take
                           advantage of new ones.  Fix to Macro
                           invocation to work with member patern for
                           current EDIT PDS.
                 27SEP95 - v3.38 - Minor Fix to RENAME option.
                 13SEP95 - v3.35 - Fixed COMPRESS_IT Messaging and ZCMD
                           to clear COMMAND line of COMPRess option
                           after compress completed.
                 17AUG95 - v3.34 - Update RENAME PROCEDURE to
                           handle failed RENAME attemps.
                 11AUG95 - v3.26 - Miscellaneous cleanup and tuning
                 18MAY95 - v3.22 - Update all REXXes with latest commom
                           routines via %CCMASS
                 24AUG94 - v3.19 - Fix to handle LMMADDs to browsed
                           members of a PDS which are not on the current
                           list (but are in the PDS).
                 19JUL94 - v3.17 - Added a 'CONTROL DISPLAY LOCK'
                           when doing a COMPRESS.
                 03MAR94 - v3.00 - Support for EDing or BRing PS
                           DSORGed DSNs.
                 18NOV93 - v2.99 - Support added for PDF commands like
                           'SUB' via use of the '&' prefix
                 12NOV93 - v2.99 - Now accepts ISPF Macro's as line
                           commands.
                 11NOV93 - v2.99 - Restructuring and modifications,
                           including 9 columns for line commands, in
                           preperation for supporting ISPF Macros from
                           line command.
                 21OCT93 - v2.86 - Refresh member list after a
                           compress is done and support for RESET option.
                 12OCT93 - v2.80 - Warning message added for BROWSE
                           of a non-existent member.
                 31AUG93 - v2.74 - Prompting to confirm member
                           deletes has been added.
                 13AUG93 - v2.68 - Fix to point and shot routine
                           and support for COMPRESS command line option
                           from member list panel.
                 15JUL93 - v2.57 - Fix of XMIT option to work with other
                           USERIDs and PDS members.  Removal of '%' from
                           RPRINT references to allow use of compiled
                           version of of RPRINT link edited into
                           compiled version of MU.
                 30JUN93 - v2.48 - More little errors, improved & more
                           relevent messages, support for IMACRO
                           (initial EDIT Macro) NP-Parm.
                 23JUN93 - v2.38 - Numerous tweeks, new versions of
                           standar modules, re-design of NP-PARM support
                           for the OPTION ===> line, et. al.
                 23JUN93 - v2.26 - Add support for DSN compression.
                 22JUN93 - v2.18 - Support added for NODATA NP-PARM
                           being entered from the MEMBER LIST OPTION
                           line.  Also, TOUCH fixes when there is no
                           ver mod level.
                 15JUN93 - v2.10 - Support for DSNs & SYSUIDs entered on
                           command line
                 14JUN93 - v2.03 - Minor fixed and NEXT support
                 09JUN93 - v1.40 - XMIT support added
                 26MAY93 - v1.30 - Minor fixes and enhancements
                 30APR93 - v1.20 - Print support, better error handling
                           better ISPF messaging, point and shoot, & TOUCH
                 29APR93 - v1.10 - Added Copy, Delete, Move, and
                           Rename support.
                 01APR93 - v1.00
***************************** Rexx ***********************************/
MsgStat=MSG("OFF")
PARSE ARG DsName InParms

IF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP
IF ABBREV('.',DsName)          THEN DO; DsName=""; CALL INVOKE_AS_MACRO; END
IF DsName = ''                 THEN DO
   CALL SET_MSG "%MU What?", "%MU requires a Dataset Name!", "YES"
   EXIT 1
  END
ELSE                                CALL INITIALIZE_THIS_REXX
/* COPY ERRINIT */
/********************************************************************** /*COPY*/
              Initialize ERROR handling                                 /*COPY*/
***********************************************************************//*COPY*/
CALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/
SIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/
SIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/
SIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/
ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"  /* Is ISPEXEC available?       *//*COPY*/
IF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/
   ok='0';ADDRESS "ISPEXEC" "CONTROL ERRORS RETURN"   /* ISPF errors  *//*COPY*/
END                                                                     /*COPY*/
                                                                        /*COPY*/
TRACE(TEST)
CALL CHECK_AND_INIT
DO dummy = 1           /* Until CREATE_MEMLIST() RCs > 0              */
   IF CREATE_MEMLIST() > 0 THEN LEAVE dummy
   MemFunc.=0          /* Re-initialize all function count variables  */
   IF ZCMD   ¬= '' THEN IF PROCESS_ZCMD() = 'RESET' THEN ITERATE
   IF ZLLCMD ¬= '' THEN DO WHILE RC = 0
      IF ZLLCMD = '=' THEN ZLLCMD=LastCommand
      IF LINE_COMMANDS(ZLLCMD ZLMEMBER ZLUDATA) > 4 THEN LEAVE
      LastCommand=ZLLCMD
      ok='0 4 8'       /* Acceptable RCs for LMMDISP below            */
        ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(GET) STATS(YES)"
   END
   IF MemFunc.xmited     > 1 THEN CALL DO_XMIT_IT
   IF MemFunc.processed > 1 THEN CALL SET_ISPF_MSG
END
ok='0';ADDRESS "ISPEXEC" "LMCLOSE DATAID("id")"
ok='0';ADDRESS "ISPEXEC" "LMFREE  DATAID("id")"
IF sameid ¬= '' THEN ADDRESS "ISPEXEC" "LMFREE  DATAID("sameid")"

IF IsMacro THEN DO; ok='0 12';ADDRESS "ISREDIT" "CURSOR ="RowPos+1 CurPos; END

MsgStat=MSG(MsgStat)
EXIT ExitErr
/***************************** REXX ***********************************
                            END of REXX
****************************** REXX ***********************************
                       Beginning of PROCEDURES
****************************** REXX ***********************************/
/**********************************************************************
     This Initializes any variables needed for this REXX
***********************************************************************/
INITIALIZE_THIS_REXX:
  TRUE=1; FALSE=0                   /* Setvalues for TRUE and FALSE   */
  PARSE SOURCE . . RName . RDsn .   /* Get REXX Name & EXEC Dsn       */
  JName=MVSVAR("SYMDEF","JOBNAME")  /* Get JOB Name                   */
  ADDRESS "ISPEXEC" "VGET (ZDLDSN ZDLVOL)"
  SELECT              /* Support ISPF 3.4/DSLIST VOLSERs              */
    WHEN RC ¬= 0                   THEN VOLSER=""
    WHEN ABBREV("*ALIAS", ZDLVOL)  THEN VOLSER=""
    WHEN ABBREV(DsName, "'"ZDLDSN) THEN VOLSER=ZDLVOL
  OTHERWISE;                            VOLSER=""; END
                                    /* Initialize NonPositional parms */
  ValidParms="ALWAYS(N) COMPRESS(N) FORMAT() IMACRO(%ALIASMC) MEMBERS()",
             "NODATA(N) PROMPT(TRUE) SYSUID(USERID()) TEST(O)" ,
             "VOLSER("VOLSER") EXTENDED(YES)"
  MatchLength=3                     /* NPParms match first # chars    */
  AcceptAll=FALSE                   /* Pass un-recognized NPParms?    */
  IF ValidParms ¬= '' THEN CALL DO_NP_PARMS

  ExitErr=0; it_rc=0
  SYSMSGLVL1=""; SYSMSGLVL2=""

  IF PROMPT ¬= FALSE THEN PROMPT=TRUE
  IF AnythingElse ¬= '' THEN DO
     PARSE VALUE STRIP(AnythingElse) WITH pds_name '(' filter ')' .
     SELECT
       WHEN LEFT(pds_name,1)  = "'"  THEN DsName="'"STRIP(pds_name,,"'")"'"
       WHEN SYSDSN(pds_name) ¬= "OK" THEN filter=pds_name
     OTHERWISE;                           DsName="'"SYSUID'.'pds_name"'"; END
     IF MEMBERS = '' THEN member=filter; ELSE member=MEMBERS
    END
  ELSE DO
     PARSE VALUE DsName WITH DsName '(' member ')' .
     IF LEFT(DsName,1) = "'" THEN DsName="'"STRIP(DsName,,"'")"'"
     IF member = ''          THEN member=MEMBERS
  END

  UPPER DsName NODATA
  LnCmds='A AL B C CL D E EXEC EXV H J M MA N P R S T V X XR XS / % ! &'
  LastCommand='*'
  second_half="is not a valid Copy/Move destination."
  sameid=''; dest=''
  MemFunc.processed=0; MemFunc.compressed=0

  AbbrevParms=LEFT(WORD(ValidParms,1), MatchLength)
  DO i=2 TO WORDS(ValidParms)
     AbbrevParms=AbbrevParms LEFT(WORD(ValidParms,i), MatchLength)
  END
  IF IsMacro ¬= TRUE THEN IsMacro=FALSE
  SELECT
    WHEN FORMAT = ""            THEN NOP
    WHEN ABBREV("ASCII",FORMAT) THEN FORMAT="ASCII"
    WHEN ABBREV("UTF8", FORMAT) THEN FORMAT="UTF8"
  OTHERWISE;                         FORMAT=""     ; END

RETURN
/* COPY PNTNSHOT */
/********************************************************************** /*COPY*/
             If no arguments, was it envoked as a MACRO                 /*COPY*/
**********************************************************************/ /*COPY*/
INVOKE_AS_MACRO:                                                        /*COPY*/
  ADDRESS "MVS" "SUBCOM ISREDIT"                                        /*COPY*/
  IF RC ¬= 0 THEN RETURN                                                /*COPY*/
  TRUE=1; FALSE=0; null=X2C('00')                                       /*COPY*/
  ADDRESS "ISPEXEC" "CONTROL ERRORS RETURN"       /* ISPF errors     */ /*COPY*/
  ADDRESS "ISREDIT" "MACRO (DsName InParms) NOPROCESS"                  /*COPY*/
  IF RC = 0 THEN DO                                                     /*COPY*/
     IsMacro=TRUE                                                       /*COPY*/
     ADDRESS "ISREDIT" "(PdsDsn) = DATASET"                             /*COPY*/
     ADDRESS "ISREDIT" "(RowPos,CurPos) = CURSOR"                       /*COPY*/
     IF DsName = "" & RowPos = 1 & CurPos = 0 THEN DsName="'"PdsDsn"'"  /*COPY*/
    END                                                                 /*COPY*/
  ELSE DO; IsMacro=FALSE; PdsDsn=""; END                                /*COPY*/
  IF WORDPOS(DsName,'-h -H')>0 THEN CALL DISPLAY_HELP                   /*COPY*/
                                                                        /*COPY*/
  PARSE VALUE DsName WITH PDS '(' member ')' .                          /*COPY*/
  IF ABBREV(PDS,"'")           THEN PDS=STRIP(PDS,"T","'")"'"           /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN DsName = ""           THEN DsName=DO_POINT_N_SHOOT()           /*COPY*/
    WHEN ABBREV(DsName,"DD:")  THEN NOP                                 /*COPY*/
    WHEN ABBREV(DsName,"dd:")  THEN NOP                                 /*COPY*/
    WHEN POS("/",DsName) > 0   THEN NOP                                 /*COPY*/
    WHEN SYSDSN(PDS) = 'OK'    THEN NOP                                 /*COPY*/
    WHEN PdsDsn ¬= ""          THEN DsName="'"PdsDsn"("DsName")'"       /*COPY*/
  OTHERWISE;                        NOP; END                            /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
     Use Point-n-Shoot to Read dataset from screen                      /*COPY*/
**********************************************************************/ /*COPY*/
DO_POINT_N_SHOOT:                                                       /*COPY*/
  PARSE VALUE GET_CURRENT_LINE() WITH ln (null) .                       /*COPY*/
  DO i=1 TO WORDS(ln) UNTIL WORDINDEX(ln,i)>CurPos; NOP; END            /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN i                > 0 THEN word=WORD(ln,i-1)                    /*COPY*/
    WHEN POS("/",PdsDsn)  > 0 THEN RETURN "'"PdsDsn"'"                  /*COPY*/
    WHEN PdsDsn ¬= ""         THEN RETURN PdsDsn                        /*COPY*/
  OTHERWISE;                       RETURN ""; END                       /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN SYSDSN(word) = 'OK'  THEN RETURN word                          /*COPY*/
    WHEN POS("='",word)   > 0 THEN                                      /*COPY*/
       PARSE VALUE word    WITH  "='" word . "'"                        /*COPY*/
    WHEN POS("DSN=",word) > 0 THEN                                      /*COPY*/
       PARSE VALUE word    WITH . "DSN=" word . ","                     /*COPY*/
    WHEN POS("=",word)    > 0 THEN                                      /*COPY*/
       PARSE VALUE word    WITH   "=" word . ","                        /*COPY*/
    WHEN POS("''",word)   > 0 THEN                                      /*COPY*/
       PARSE VALUE word    WITH  "''" word . "'"                        /*COPY*/
    WHEN ABBREV(word,'"//')   THEN                                      /*COPY*/
       PARSE VALUE word    WITH "//" word . '"'                         /*COPY*/
    WHEN POS("(",word)    > 0 THEN                                      /*COPY*/
       PARSE VALUE word" " WITH   "(" word . ")"                        /*COPY*/
  OTHERWISE; NOP; END                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN ABBREV(word,"DD:")                    THEN DsNme=word          /*COPY*/
    WHEN ABBREV(word,"dd:")                    THEN DsNme=word          /*COPY*/
    WHEN INDEX(word, "/")               > 0    THEN DsNme=word          /*COPY*/
    WHEN SYSDSN(word)                   = 'OK' THEN DsNme=word          /*COPY*/
    WHEN SYSDSN(word)     = 'MEMBER NOT FOUND' THEN DsNme=word          /*COPY*/
    WHEN SYSDSN("'"STRIP(word,,"'")"'") = 'OK' THEN                     /*COPY*/
         DsNme="'"STRIP(word,,"'")"'"                                   /*COPY*/
    WHEN SYSDSN("'"STRIP(word,,"'")"'") = 'MEMBER NOT FOUND' THEN       /*COPY*/
         DsNme="'"STRIP(word,,"'")"'"                                   /*COPY*/
    WHEN SYSDSN("'"PdsDsn"("word")'")   = 'OK' THEN                     /*COPY*/
         DsNme="'"PdsDsn"("word")'"                                     /*COPY*/
    WHEN PdsDsn                        ¬= ''   THEN DO                  /*COPY*/
         DsNme="'"PdsDsn"'"; filter=word                                /*COPY*/
      END                                                               /*COPY*/
  OTHERWISE; DsNme = ""; END                                            /*COPY*/
RETURN DsNme                                                            /*COPY*/
/********************************************************************** /*COPY*/
   Use Current Screen Stream & Cursor Possition to get Current Line     /*COPY*/
**********************************************************************/ /*COPY*/
GET_CURRENT_LINE:                                                       /*COPY*/
  ADDRESS "ISPEXEC" "VGET (ZSCREENC ZSCREEND ZSCREENI ZSCREENW)"        /*COPY*/
  ADDRESS "ISPEXEC" "VGET (ZCURDEP ZCURWID)"                            /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN RC = 0 & ¬(IsMacro)                    THEN Wdth=ZCURWID       /*COPY*/
    WHEN IsMacro                                THEN DO                 /*COPY*/
       ADDRESS "ISREDIT" "(Line) = LINE" RowPos                         /*COPY*/
       RETURN Line                                                      /*COPY*/
      END                                                               /*COPY*/
    WHEN POS('* BOTTOM OF DATA *',ZSCREENI) > 0 |,                      /*COPY*/
         POS('* Bottom of Data *',ZSCREENI) > 0 THEN DO                 /*COPY*/
       LstLn=SUBSTR(ZSCREENI,(LENGTH(ZSCREENI)-(ZSCREENW+4)))           /*COPY*/
       IF ABBREV(LstLn,"***")                   THEN Wdth=ZSCREENW+8    /*COPY*/
          ELSE                                       Wdth=ZSCREENW      /*COPY*/
      END                                                               /*COPY*/
  OTHERWISE                                                             /*COPY*/
     Lngth=LENGTH(ZSCREENI)                                             /*COPY*/
     SELECT                                                             /*COPY*/
       WHEN (Lngth/ZSCREENW)   = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/
       WHEN (Lngth%ZSCREENW)+1 = ZSCREEND       THEN Wdth=ZSCREENW      /*COPY*/
       WHEN (Lngth//ZSCREEND)  = 0              THEN Wdth=Lngth%ZSCREEND/*COPY*/
       WHEN (Lngth//88)        = 0              THEN Wdth=88            /*COPY*/
     OTHERWISE; Wdth=MIN(88,ZSCREENW); END                              /*COPY*/
  END                                                                   /*COPY*/
  CurPos=(ZSCREENC//Wdth)+1; RowPos=(ZSCREENC%Wdth)                     /*COPY*/
RETURN TRANSLATE(SUBSTR(ZSCREENI,(RowPos*Wdth)+1,Wdth)," ",",")         /*COPY*/
/* COPY DISHELP */
/********************************************************************** /*COPY*/
            This PROCEDURE displays the Help information in             /*COPY*/
                 this REXX's HEADER when invoked.                       /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_HELP: PROCEDURE                                                 /*COPY*/
ARG ExitOrReturn .                                                      /*COPY*/
  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/
     source.i=SOURCELINE(i+1)       /* Read in HELP from EXEC         *//*COPY*/
  END                                                                   /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                                 /*COPY*/
  IF RC ¬= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/
  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/
     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/
     ok='0';ADDRESS "ISPEXEC" "TBCREATE RHELP02 NAMES(source) NOWRITE"  /*COPY*/
     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/
        source=source.i; ADDRESS "ISPEXEC" "TBADD RHELP02"              /*COPY*/
     END                                                                /*COPY*/
     ok='0';ADDRESS "ISPEXEC" "TBTOP RHELP02"                           /*COPY*/
     ZTDMARK=CENTER("----> END of Help <----",80)                       /*COPY*/
     ok='0 4 8';ADDRESS "ISPEXEC" "TBDISPL RHELP02 PANEL(RHELP02)"      /*COPY*/
     ok='0';ADDRESS "ISPEXEC" "TBCLOSE RHELP02"                         /*COPY*/
  END                                                                   /*COPY*/
                      /* Stay inside current EXEC or EXIT             *//*COPY*/
IF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/
   ELSE EXIT 0                                                          /*COPY*/
/* COPY NPPARMS */
/********************************************************************** /*COPY*/
            Initialize and process Non-Positional Parms in a            /*COPY*/
                method similar to that of CLISTs                        /*COPY*/
    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/
          not follow any internal ')' with spaces!!                     /*COPY*/
**********************************************************************/ /*COPY*/
DO_NP_PARMS:                                                            /*COPY*/
  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/
                                                                        /*COPY*/
  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/
     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/
     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/
  END                                                                   /*COPY*/
  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/
     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/
     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/
     parm=STRIP(parm)                                                   /*COPY*/
     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/
     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/
     ELSE IF INDEX(value,")") > 0 THEN                                  /*COPY*/
          ParmErrorList=ParmErrorList parm"("value                      /*COPY*/
     ELSE ParmErrorList=ParmErrorList parm"("value")"                   /*COPY*/
  END                                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN ParmErrorList ¬= '' & AcceptAll = TRUE          THEN           /*COPY*/
       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/
    WHEN ParmErrorList ¬= ''                             THEN DO        /*COPY*/
       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/
       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/
            "'"ParmErrorList"' not valid Parm(s) for" rname"!", "YES"   /*COPY*/
       EXIT 8                                                           /*COPY*/
      END                                                               /*COPY*/
  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/
  DO ParmInx=1 TO linx                                                  /*COPY*/
     SELECT                                                             /*COPY*/
       WHEN ABBREV(ParmVal.ParmInx, "&")                 |,             /*COPY*/
            ABBREV(ParmVal.ParmInx, "*")                 THEN           /*COPY*/
           INTERPRET parm.ParmInx "= '"ParmVal.ParmInx"'"               /*COPY*/
       WHEN DATATYPE(ParmVal.ParmInx, "NUM")             THEN           /*COPY*/
           INTERPRET parm.ParmInx "=" ParmVal.ParmInx                   /*COPY*/
       WHEN WORDPOS(ParmVal.ParmInx, "FALSE TRUE") > 0   THEN           /*COPY*/
           INTERPRET parm.ParmInx "=" ParmVal.ParmInx                   /*COPY*/
       WHEN (LEFT(ParmVal.ParmInx,1) = "'"               & ,            /*COPY*/
             RIGHT(ParmVal.ParmInx,1) = "'")             | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/
            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/
           INTERPRET parm.ParmInx "= ParmVal."ParmInx                   /*COPY*/
       WHEN INDEX(STRIP(ParmVal.ParmInx), " ") > 0       THEN           /*COPY*/
           INTERPRET parm.ParmInx "=" ParmVal.ParmInx                   /*COPY*/
     OTHERWISE                                                          /*COPY*/
        ADDRESS "MVS" "SUBCOM TSO"                                      /*COPY*/
        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/
        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/
        SELECT                                                          /*COPY*/
          WHEN ¬(TSO_avail) | PDS_name = ""              THEN           /*COPY*/
              INTERPRET parm.ParmInx "=" ParmVal.ParmInx                /*COPY*/
          WHEN SYSVAR("SYSNEST") = 'YES'                 THEN           /*COPY*/
              INTERPRET parm.ParmInx "=" ParmVal.ParmInx                /*COPY*/
          WHEN (INDEX(rest, ")") > 0                     &,             /*COPY*/
               (ABBREV(rest, "+") | ABBREV(rest,"-")     |,             /*COPY*/
                ABBREV(rest, "0)")))                     THEN           /*COPY*/
              INTERPRET parm.ParmInx "= '"ParmVal.ParmInx"'"            /*COPY*/
          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/
                LISTDSI("'"ParmVal.ParmInx"'")     <= 4  | ,            /*COPY*/
                LISTDSI("'"PDS_name"'")            <= 4  | ,            /*COPY*/
                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/
              INTERPRET parm.ParmInx "= ParmVal."ParmInx                /*COPY*/
        OTHERWISE                                                       /*COPY*/
              INTERPRET parm.ParmInx "=" ParmVal.ParmInx                /*COPY*/
        END                                                             /*COPY*/
     END                                                                /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY SETMSG */                                                       /*COPY*/
/********************************************************************** /*COPY*/
              Error with DSN, Use ISPF to display Error Message         /*COPY*/
***********************************************************************//*COPY*/
SET_MSG: PROCEDURE                                                      /*COPY*/
PARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/
  ok='*';ADDRESS "MVS" "SUBCOM ISPEXEC"                                 /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN RC ¬= 0                   THEN DO                              /*COPY*/
       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/
      END                                                               /*COPY*/
    WHEN SYSVAR("SYSNEST") = 'YES' THEN DO                              /*COPY*/
       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/
      END                                                               /*COPY*/
    WHEN SYSVAR('SYSENV') = 'BACK' THEN DO                              /*COPY*/
       SAY ''; SAY ZERRSM; SAY ZERRLM; SAY ''                           /*COPY*/
      END                                                               /*COPY*/
  OTHERWISE                                                             /*COPY*/
     IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                   /*COPY*/
        ELSE                           ZERRALRM='NO'                    /*COPY*/
     IF ZERRHM = ''               THEN ZERRHM='ISR2MACR'                /*COPY*/
     ok='0';ADDRESS "ISPEXEC" "SETMSG MSG(ISRZ003)"                     /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/* COPY DISPMSG */
/********************************************************************** /*COPY*/
           Use ISPF CONTROL DISPLAY LOCK to give user STATUS            /*COPY*/
                 during a long running portion of REXX                  /*COPY*/
***********************************************************************//*COPY*/
DISPLAY_MSG:                                                            /*COPY*/
PARSE ARG ZERRLM, ZERRALRM .                                            /*COPY*/
  ZERRSM=""; ZERRHM="ISR2MACR"           /* Initialize ISRZ002 Fields *//*COPY*/
  IF ABBREV('YES',ZERRALRM,1)  THEN ZERRALRM='YES'                      /*COPY*/
     ELSE                           ZERRALRM='NO'                       /*COPY*/
  IF SYSVAR('SYSENV') = 'BACK' THEN SAY ZERRLM                          /*COPY*/
  ELSE DO                                                               /*COPY*/
     ok='*';ADDRESS "ISPEXEC" "CONTROL DISPLAY LOCK"                    /*COPY*/
            ADDRESS "ISPEXEC" "DISPLAY MSG(ISRZ002)"                    /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/**********************************************************************
      Verify we are dealing with a PDS, COMPRESS it if requested,
      and open the PDS for member list processing
***********************************************************************/
CHECK_AND_INIT:
  x=PROCESS_DSNAME(DsName)
  IF RC = 8 THEN DO
     ok='*';ADDRESS "ISPEXEC" "EDIT DATASET("DsName") MACRO("IMACRO")",
                              "VOLUME("VOLSER")" FORMAT
     SELECT
       WHEN RC = 0  |,
            RC = 4  THEN NOP
       WHEN RC = 14 THEN CALL SET_MSG 'Dataset in USE!', DsName '--' ZERRLM
       WHEN RC = 16 THEN CALL SET_MSG "No Members in PDS!", DsName '--' ZERRLM
     OTHERWISE
        ADDRESS "ISPEXEC" "BROWSE DATASET("DsName") VOLUME("VOLSER")"
        IF RC = 20 THEN DO
           CALL SET_MSG "Can't %MU", DsName '--' ZERRLM, "YES"
           ExitErr=21
        END
     END
     EXIT ExitErr
  END
  IF ABBREV('YES',COMPRESS) THEN CALL COMPRESS_IT

  ok='0';ADDRESS "ISPEXEC" "LMOPEN DATAID("id") OPTION(INPUT)"
RETURN
/**********************************************************************
      Process DsName and DO Appropriate LMINIT
***********************************************************************/
PROCESS_DSNAME:
PARSE ARG _dsn_ .
  ok='0 8'
  SELECT
    WHEN ABBREV(_dsn_, "DD:") | ABBREV(_dsn_, "dd:") THEN
      ADDRESS "ISPEXEC" "LMINIT DATAID(id) DDNAME("SUBSTR(_dsn_,4)") ENQ(SHRW)"
    WHEN VOLSER ¬= ""                                THEN
      ADDRESS "ISPEXEC" "LMINIT DATASET("_dsn_") DATAID(id) ENQ(SHRW)",
                        "VOLUME("VOLSER")"
  OTHERWISE
      ADDRESS "ISPEXEC" "LMINIT DATASET("_dsn_") DATAID(id) ENQ(SHRW)"
  END
RETURN member
/**********************************************************************
    Create member list for display
***********************************************************************/
CREATE_MEMLIST:
  ok='0 4 8'
    ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(DISPLAY) PANEL(ISRUDSM)",
                      "FIELD(9) STATS(YES) MEMBER("member") COMMANDS(ANY)"
  IF RC = 4 THEN DO
      SELECT
        WHEN member = ''         THEN disp_pds=DsName
        WHEN ABBREV(DsName, "'") THEN
          disp_pds=STRIP(DsName,"T","'")"("member")'"
      OTHERWISE
          disp_pds=DsName"("member")"
      END
      CALL SET_MSG "No members to %MU!", "No members in" disp_pds, 'YES'
  END
RETURN RC
/**********************************************************************
    Process non-blank command lines
***********************************************************************/
PROCESS_ZCMD:
  CommandLine=ZCMD; ResetDone=''
  PARSE VALUE ZCMD WITH command cl_member cl_data .
  ZCMD='';ok='0';ADDRESS "ISPEXEC" "VPUT (ZCMD)"
  SELECT
    WHEN ABBREV('COMPRESS',command,3) THEN DO
       it_rc=COMPRESS_IT()        /* compress current PDS    */
                                  /* refresh PDS Member List */
       ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(FREE)"
       ResetDone='RESET'
      END
    WHEN ABBREV('REFRESH',command,3)  THEN DO
       ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(FREE)"
       ResetDone='RESET'; ZCMD=""
       MemFunc.processed=MemFunc.processed+1
       CALL SET_MSG , DsName "member list refreshed.", "NO"
      END
    WHEN WORDPOS(command, 'H -H') > 0 THEN CALL DISPLAY_HELP('RETURN')
    WHEN INDEX(command, '(') > 0      THEN DO
       PARSE VALUE command WITH NpParm "(" value ")" .
       NpParmNo=WORDPOS(LEFT(NpParm,3),AbbrevParms)
       SELECT
         WHEN NpParmNo > 0 THEN DO
            NpParm=WORD(ValidParms, NpParmNo)
            PARSE VALUE NpParm WITH NpParm "(" .
            SIGNAL OFF NOVALUE
            IF ABBREV(NpParm, "PRO") THEN DO
               PROMPT=value
               IF PROMPT ¬= FALSE THEN PROMPT=TRUE
              END
            ELSE INTERPRET NpParm '= value'
            TRACE(TEST)
            SIGNAL ON  NOVALUE NAME ERROR_PROC
           END
         WHEN SYSDSN(NpParm)='OK' | SYSDSN(NpParm"'")='OK' THEN DO
            ok='0';ADDRESS "TSO" "MU" CommandLine
           END
       OTHERWISE  /* It must be a TSO command!? */
           ok='*';ADDRESS "TSO" CommandLine
           IF RC > 4 | RC < 0 THEN CALL BAD_CMD command
       END
      END
    WHEN SYSDSN(CommandLine) = 'OK' THEN DO
       ok='0';ADDRESS "TSO" "MU" CommandLine
      END
  OTHERWISE  /* It must be a Line command!? */
      lc_rc=LINE_COMMANDS(command cl_member cl_data)
      IF RC > 4 | RC < 0 THEN CALL BAD_CMD command
  END
  CommandLine=''
RETURN ResetDone
/**********************************************************************
    Process Line Commands from member list
***********************************************************************/
LINE_COMMANDS:
ARG LnCmd MbrNme LnData .
  SELECT
    WHEN LnCmd='A'                  THEN it_rc=ALIAS_IT()
    WHEN LnCmd='AL'                 THEN it_rc=ALLOC_IT()
    WHEN LnCmd='B'                  THEN it_rc=BROWSE_IT()
    WHEN LnCmd='C'                  THEN it_rc=COPY_IT()
    WHEN LnCmd='CL'                 THEN it_rc=EXEC_IT("CLIST")
    WHEN LnCmd='CLV'                THEN it_rc=EXEC_VIEW_IT("CLIST")
    WHEN LnCmd='D'                  THEN it_rc=DELETE_IT()
    WHEN WORDPOS(LnCmd,'E S /') > 0 THEN it_rc=EDIT_IT()
    WHEN LnCmd='EXEC'               THEN it_rc=EXEC_IT("EXEC")
    WHEN LnCmd='EXV'                THEN it_rc=EXEC_VIEW_IT("EXEC")
    WHEN WORDPOS(LnCmd,'H -H')  > 0 THEN CALL DISPLAY_HELP('RETURN')
    WHEN LnCmd='J'                  THEN it_rc=SUBMIT_IT()
    WHEN LnCmd='M'                  THEN it_rc=MOVE_IT()
    WHEN LnCmd='MA'                 THEN it_rc=MAKE_ALIAS()
    WHEN LnCmd='N'                  THEN it_rc=NEXT_VERSION()
    WHEN LnCmd='P'                  THEN it_rc=PRINT_IT()
    WHEN LnCmd='R'                  THEN it_rc=RENAME_IT()
    WHEN LnCmd='T'                  THEN it_rc=TOUCH_IT()
    WHEN LnCmd='V'                  THEN it_rc=VIEW_IT()
    WHEN LnCmd='X'                  THEN it_rc=EXCLUDE_IT()
    WHEN LnCmd='XR'                 THEN it_rc=XMITREC_IT()
    WHEN LnCmd='XS'                 THEN it_rc=XMIT_IT()
  OTHERWISE;                             it_rc=MACRO_IT(); END
RETURN it_rc
/**********************************************************************
    Create an ALIAS of the specified member
***********************************************************************/
ALIAS_IT:
  IF ABBREV(LnData,'*') | LnData = '' THEN DO
     CALL SET_MSG "ALIAS to what?", "No ALIAS name given for" MbrNme,
                  "to create ALIAS for!", "YES"
     RETURN 1
  END

  IF ABBREV(DsName, "'") THEN DO
     OldNme=STRIP(DsName,"T","'")"("MbrNme")'"
     NewNme=STRIP(DsName,"T","'")"("LnData")'"
    END
  ELSE DO
     OldNme=DsName"("MbrNme")"
     NewNme=DsName"("LnData")"
  END

  CALL DO_ALIAS
RETURN 0
/**********************************************************************
    ALLOC the member to the specified DD
***********************************************************************/
ALLOC_IT:
  IF LEFT(LnData,1) = '*' | LnData = '' THEN DO
     CALL SET_MSG "ALLOC to what DD?", "No ALLOC DD given for" MbrNme,
                  "to use in ALLOCating!", "YES"
     RETURN 1
  END

  ok='0'
  IF ABBREV(DsName, "'") THEN
       ADDRESS "TSO" "ALLOC DD("LnData") SHR REUSE",
                          "DSN("STRIP(DsName,"T","'")"("MbrNme")')"
  ELSE ADDRESS "TSO" "ALLOC DD("LnData") SHR REUSE",
                          "DSN("DsName"("MbrNme"))"
  MemFunc.processed=MemFunc.processed+1
  MemFunc.alloced=MemFunc.alloced+1
  ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*ALLOCed)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*ALLOCed)"
  END
RETURN 0
/**********************************************************************
    Create an the specified member name an ALIAS
***********************************************************************/
MAKE_ALIAS:
  IF LEFT(LnData,1) = '*' | LnData = '' THEN DO
     CALL SET_MSG "MAKE ALIAS of what?", "No original name given for",
                  MbrNme "to create ALIAS from!", "YES"
     RETURN 1
  END

  IF ABBREV(DsName, "'") THEN DO
     NewNme=STRIP(DsName,"T","'")"("MbrNme")'"
     OldNme=STRIP(DsName,"T","'")"("LnData")'"
    END
  ELSE DO
     NewNme=DsName"("MbrNme")"
     OldNme=DsName"("LnData")"
  END

  CALL DO_ALIAS
RETURN 0
/**********************************************************************
    Invoke ISPF ALIAS Command to create a member ALIAS
***********************************************************************/
DO_ALIAS:
  xmsg=MSG("ON"); x=OUTTRAP("ALIAS.",2)
  ok='0 12';ADDRESS "TSO" "RENAME" OldNme NewNme "ALIAS"
  xmsg=MSG(xmsg); x=OUTTRAP("OFF")
  ALIAS_RC=RC

  SELECT
    WHEN ALIAS_RC = 0                   THEN DO
        MemFunc.processed=MemFunc.processed+1
        MemFunc.alias=MemFunc.alias+1
        ok='0 8'
        ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                          "MEMBER("MbrNme") ZLUDATA(*Alias)"
        IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                "MEMBER("MbrNme") ZLUDATA(*Alias)"
        ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD) MEMBER("LnData")"
        IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                                          "MEMBER("LnData")"
      END
    WHEN MbrNme = LnData                 THEN DO
        CALL SET_MSG "Not a new name!", "You can't ALIAS a member to the",
                     "same name?!?!?!", "YES"
      END
    WHEN WORDPOS(ALIAS_RC, "12") ¬= 0 THEN CALL SET_MSG , ALIAS.1 ALIAS.2, "YES"
  OTHERWISE; NOP; END
RETURN 0
/**********************************************************************
    Browse member in current %MU member list
***********************************************************************/
BROWSE_IT:
  ok='0 12 14 20';ADDRESS "ISPEXEC" "BROWSE DATAID("id") MEMBER("MbrNme")"
  SELECT
    WHEN RC = 12 THEN DO
        CALL SET_MSG "ERROR on" STRIP(MbrNme)"!", "An ERROR occured while",
                     "BROWSEing" STRIP(MbrNme) "--" ZERRLM, 'YES'
        ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                       "MEMBER("MbrNme") ZLUDATA(*BRError)"
      END
    WHEN RC >= 14 THEN CALL SET_MSG STRIP(MbrNme) "not found!",,
        "No member" STRIP(MbrNme) "found --" ZERRLM, 'YES'
  OTHERWISE
      MemFunc.processed=MemFunc.processed+1
      MemFunc.browsed=MemFunc.browsed+1
      ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*Browsed)"
      IF RC = 8 THEN DO      /* New member to ADD to member list      */
          ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                           "MEMBER("MbrNme") ZLUDATA(*Browsed)"
      END
  END
RETURN 0
/**********************************************************************
    Compress the PDS %MU is currently being envoked on
***********************************************************************/
COMPRESS_IT:
  IF LEFT(DsName,1) ¬= "'" THEN dsnname=USERID()"."DsName
     ELSE dsnname=STRIP(DsName,"B","'")
  UPPER dsnname

  ok='0';ADDRESS "ISPEXEC" "LMDINIT LISTID(profile) LEVEL("dsnname")"
  ok='0';ADDRESS "ISPEXEC" "LMDLIST LISTID("profile") OPTION(LIST)",
                           "DATASET(dsnname) STATS(YES)"
  ok='0';ADDRESS "ISPEXEC" "LMDLIST LISTID("profile") OPTION(FREE)"
  trks=STRIP(ZDLSIZE); exts=STRIP(ZDLEXT); used=ZDLUSED

  ok='0 8';ADDRESS "ISPEXEC" "LMINIT DATAID(profid) DATASET("DsName")",
                             "ENQ(EXCLU) VOLUME("VOLSER")"
  IF RC = 8 THEN DO
      CALL SET_MSG "Can't compress now!", ZERRLM, 'YES'
      RETURN 1
  END
  CALL DISPLAY_MSG "Doing a compress of" dsnname "at this time!", "NO"
  ok='*';ADDRESS "ISPEXEC" "LMCOMP DATAID("profid")"
  COMP_RC=RC
  ok='0';ADDRESS "ISPEXEC" "LMFREE DATAID("profid")"

  ok='0';ADDRESS "ISPEXEC" "LMDINIT LISTID(profile) LEVEL("dsnname")"
  ok='0';ADDRESS "ISPEXEC" "LMDLIST LISTID("profile") OPTION(LIST)",
                           "DATASET(dsnname) STATS(YES)"
  ok='0';ADDRESS "ISPEXEC" "LMDLIST LISTID("profile") OPTION(FREE)"

  COMPRESS='NO';ZCMD=""
  IF COMP_RC = 0 THEN DO
     freed=STRIP(used - ZDLUSED); freed_trks=trks*freed/100
     MemFunc.processed=MemFunc.processed+1
     MemFunc.compressed=MemFunc.compressed+1
     CALL SET_MSG , "'"dsnname"' compressed freeing",
                    freed"% of" trks "TRKS, i.e." freed_trks "TRKS."
    END
  ELSE CALL SET_MSG , ZERRLM, "NO"
RETURN 0
/**********************************************************************
    Copy member in current %MU member list
***********************************************************************/
COPY_IT:
  option='Copying:'
  SELECT
    WHEN LEFT(ALWAYS,1) = 'Y' & dest ¬ = '' THEN CALL DO_COPY
    WHEN GET_C_M_INFO() THEN CALL DO_COPY
  OTHERWISE; NOP; END
RETURN 0
/**********************************************************************
    Process an ENDEVOR Batch GENERATE
***********************************************************************/
GENERATE_IT:
  sub_RC=""
RETURN sub_RC
/**********************************************************************
    Get Copy/Move info, i.e. dest. PDS, new name, replace option, etc.
***********************************************************************/
GET_C_M_INFO:
  IF LEFT(DsName,1) = "'" THEN
       origmem=STRIP(DsName,"T","'") || "(" || STRIP(MbrNme) || ")'"
  ELSE origmem=DsName || "(" || STRIP(MbrNme) || ")"
  IF LnData = '' | LEFT(LnData,1) = '*' THEN newname=MbrNme
     ELSE                                    newname=LnData

  destattr='INTENS(LOW)'
  ok='0 8';ADDRESS "ISPEXEC" "DISPLAY PANEL(MU01)"
  IF RC = 8 THEN RETURN FALSE

  IF INDEX(dest,"=") > 0 | INDEX(dest,"+") > 0 THEN DO
    SELECT
        WHEN   STRIP(dest) = "=" THEN dest=DsName
        WHEN ABBREV(dest,"+")    &,
             ABBREV(DsName,"'") THEN
             dest=STRIP(DsName,"T","'")"."SUBSTR(dest,2)"'"
        WHEN RIGHT(dest,1) = "+" &,
             ABBREV(DsName,"'") THEN
             dest="'"STRIP(dest,"T","+")"."STRIP(DsName,"L","'")
        WHEN ABBREV(dest,"+")    THEN dest=DsName"."SUBSTR(dest,2)
        WHEN RIGHT(dest,1) = "+" THEN dest=STRIP(dest,"T","+")"."DsName
        WHEN ABBREV(dest,"=")    THEN DO
            dest=STRIP(dest,"L","=")
            temp=STRIP(dest,"T",".")
            hlq=REVERSE(DsName)
            DO qual_count=1
                PARSE VALUE hlq WITH . "." hlq
                IF INDEX(temp, ".") = 0 THEN LEAVE qual_count
                PARSE VALUE temp WITH . "." temp
            END
            IF hlq = "" THEN PARSE VALUE DsName WITH hlq "." .
               ELSE          hlq=REVERSE(hlq)
            IF LEFT(hlq,1) = "'" THEN dest=hlq"."STRIP(dest)"'"
               ELSE                   dest=hlq"."STRIP(dest)
          END
        WHEN RIGHT(dest,1) = "=" THEN DO
            dest=STRIP(dest,"T","=")
            temp=STRIP(dest,"T",".")
            llq=DsName
            DO qual_count=1
                PARSE VALUE llq WITH . "." llq
                IF INDEX(temp, ".") = 0 THEN LEAVE qual_count
                PARSE VALUE temp WITH . "." temp
            END
            IF llq = "" THEN DO
                PARSE VALUE REVERSE(DsName) WITH llq "." .
                llq=REVERSE(llq)
            END
            IF RIGHT(llq,1) = "'" THEN dest="'"STRIP(dest)"."llq
               ELSE                    dest=STRIP(dest)"."llq
          END
      OTHERWISE; NOP; END
    END
  ELSE IF ABBREV(dest, "'") THEN dest=STRIP(dest,"T","'")"'"
  DO WHILE SYSDSN(dest) ¬= 'OK'
      destattr='INTENS(HIGH)'
      CALL SET_MSG "Invalid Dataset Name!", dest second_half
      ok='0 8';ADDRESS "ISPEXEC" "DISPLAY PANEL(MU01) CURSOR(dest)"
      IF RC = 8 THEN RETURN FALSE
      IF dest = "=" THEN dest=DsName
      ELSE IF ABBREV(dest, "'") THEN dest=STRIP(dest,"T","'")"'"
  END

  IF replike = 'Y' THEN REPLACE='REPLACE'; ELSE REPLACE=''
  ok='0';ADDRESS "ISPEXEC" "LMINIT DATASET("dest") DATAID(trgtid) ENQ(SHRW)"
                   /*      "VOLUME("trgVOL")" */
RETURN TRUE
/**********************************************************************
            Copy Member Logic
***********************************************************************/
DO_COPY:
  IF LnData = '' | LEFT(LnData,1) = '*' THEN
       x=COPY_MEMBER(MbrNme MbrNme)
  ELSE x=COPY_MEMBER(LnData MbrNme)
  IF x = 0 THEN DO
      MemFunc.processed=MemFunc.processed+1
      MemFunc.copied=MemFunc.copied+1
      ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                                 "MEMBER("MbrNme") ZLUDATA(*Copied)"
      IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                        "MEMBER("to_member") ZLUDATA(*Copied)"
  END
RETURN
/**********************************************************************
            Copy Member to a new PDS
***********************************************************************/
COPY_MEMBER:
ARG to_member fm_member .
  ok='0 4 8 12'
  ADDRESS "ISPEXEC" "LMCOPY FROMID("id") FROMMEM("fm_member")",
                    "TODATAID("trgtid") TOMEM("to_member") TRUNC" REPLACE
  success=RC; IF RC ¬= 0 THEN excuse=ZERRLM
  IF LEFT(ALWAYS,1) ¬= 'Y' THEN DO
      ok='0';ADDRESS "ISPEXEC" "LMFREE  DATAID("trgtid")"
      trgtid=''
  END
  IF success = 0 & (DsName = dest | DsName = "'"SYSUID"."dest"'") THEN DO
      ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                       "MEMBER("to_member") ZLUDATA(*NewCopy)"
      IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                                        "MEMBER("to_member") ZLUDATA(*NewCopy)"
  END
  IF MemFunc.processed > 0 THEN RETURN success
  SELECT
    WHEN success = 0  THEN CALL SET_MSG fm_member "copied.", "Member" ,
                           fm_member "copied to" dest, 'NO'
    WHEN success <= 8 THEN CALL SET_MSG ,"Couldn't copy" fm_member".",
                           fm_member "--" excuse, "YES"
  OTHERWISE
      CALL SET_MSG "No COPY done!?", excuse
  END
RETURN success
/**********************************************************************
    Delete member in current %MU member list
***********************************************************************/
DELETE_IT:
  IF PROMPT THEN sure=DELETE_QUERY()
     ELSE        sure=TRUE
  IF sure THEN DO
      ADDRESS "ISPEXEC" "LMINIT DATASET("DsName")",
                        "DATAID(sameid) ENQ(SHRW) VOLUME("VOLSER")"
      ADDRESS "ISPEXEC" "LMOPEN DATAID("sameid") OPTION(OUTPUT)"
      ADDRESS "ISPEXEC" "LMMDEL DATAID("sameid") MEMBER("MbrNme")"
      IF RC = 0 THEN DO
          MemFunc.processed=MemFunc.processed+1
          MemFunc.deleted=MemFunc.deleted+1
      END
      ADDRESS "ISPEXEC" "LMCLOSE DATAID("sameid")"
      ADDRESS "ISPEXEC" "LMFREE  DATAID("sameid")"
      sameid=''
      ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                         "MEMBER("MbrNme") ZLUDATA(*Deleted)"
      IF RC ¬= 0 THEN DO
         ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                        "MEMBER("MbrNme") ZLUDATA(*Deleted)"
      END
  END
RETURN 0
/**********************************************************************
            Delete member from current %MU PDS
***********************************************************************/
DELETE_QUERY:
  ZCFDSN=DsName; ZCFMEM=ZLMEMBER
  ok='0';ADDRESS "ISPEXEC" "ADDPOP"
  ok='0 8';ADDRESS "ISPEXEC" "DISPLAY PANEL(ISRUDELC)"
  display_RC=RC
  ok='0';ADDRESS "ISPEXEC" "REMPOP"

  SELECT
    WHEN display_RC > 0 THEN RETURN FALSE
    WHEN ZMEMCOV ¬= ""  THEN PROMPT=FALSE
  OTHERWISE; NOP ;END
RETURN TRUE
/**********************************************************************
            EDIT member from current %MU PDS
***********************************************************************/
EDIT_IT:
  CALL CHECK_EDIT_RECOVERY
  ok='*';ADDRESS "ISPEXEC" "EDIT DATAID("id") MEMBER("MbrNme")",
                           "MACRO("IMACRO")" FORMAT
  IF RC > 4 THEN DO
      CALL SET_MSG "ERROR on" STRIP(MbrNme)"!", "An ERROR occured while",
                   "EDITing" STRIP(MbrNme) "--" ZERRLM, 'YES'
      ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*EDError)"
    END
  ELSE DO
      MemFunc.processed=MemFunc.processed+1
      MemFunc.edited=MemFunc.edited+1
      IF RC = 0 THEN UserData='*Edited'
         ELSE        UserData='*Browsed'
      ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                       "MEMBER("MbrNme") ZLUDATA("UserData")"
      IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                        "MEMBER("MbrNme") ZLUDATA("UserData")"
  END
RETURN 0
/**********************************************************************
    eXclude a member from the current member List
***********************************************************************/
EXCLUDE_IT:
  MemFunc.processed=MemFunc.processed+1
  MemFunc.xcluded=MemFunc.xcluded+1
  ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(DELETE)",
                           "MEMBER("MbrNme")"
RETURN 0
/**********************************************************************
            EXEC the member from current %MU PDS
***********************************************************************/
EXEC_IT:
ARG Type .
  IF LnData||ZCMD ¬= "" THEN Parm="'"LnData||ZCMD"' PROMPT" Type
     ELSE                    Parm="PROMPT" Type
  ADDRESS "TSO" "NEWSTACK"; y=MSG("OFF")
    ok='*';ADDRESS "TSO" "EXEC '"STRIP(DsName,"B","'")"("MbrNme")'" Parm
  y=MSG(y); ADDRESS "TSO" "DELSTACK"

  CALL SET_MSG "EXEC RC="RC, "EXECing of '"MbrNme"' completed with RC="RC
  ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                             "MEMBER("MbrNme") ZLUDATA(*EXECed)"
  IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                    "MEMBER("MbrNme") ZLUDATA(*EXECed)"
RETURN TRUE
/**********************************************************************
            EXEC the member from current %MU PDS
***********************************************************************/
EXEC_VIEW_IT:
ARG Type .
  IF LnData||ZCMD ¬= "" THEN Parm="'"LnData||ZCMD"' PROMPT" Type
     ELSE                    Parm="PROMPT" Type

  CALL TSOVIEW "EXEC '"STRIP(DsName,"B","'")"("MbrNme")'" Parm

  CALL SET_MSG "EXEC View RC="RC,,
       "EXecute & Viewing of '"MbrNme"' completed with RC="RC
  ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                             "MEMBER("MbrNme") ZLUDATA(*EXECed)"
  IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                    "MEMBER("MbrNme") ZLUDATA(*EXECed)"
RETURN TRUE
/* COPY CHECKER */
/********************************************************************** /*COPY*/
        Check for pending EDIT Recovery and process accordingly         /*COPY*/
***********************************************************************//*COPY*/
CHECK_EDIT_RECOVERY:                                                    /*COPY*/
  DO FOREVER                                                            /*COPY*/
      ok='0 4';ADDRESS "ISPEXEC" "EDREC QUERY"                          /*COPY*/
      IF RC = 0  THEN LEAVE                                             /*COPY*/
      ELSE DO            /* Display standard PDF EDIT Recovery Screen *//*COPY*/
          ok='0 8';ADDRESS "ISPEXEC" "DISPLAY PANEL(ISREDM02)"          /*COPY*/
          SELECT                                                        /*COPY*/
            WHEN ABBREV(ZEDCMD, "C") THEN DO                            /*COPY*/
                ok='0';ADDRESS "ISPEXEC" "EDREC CANCEL"                 /*COPY*/
              END                                                       /*COPY*/
            WHEN ABBREV(ZEDCMD, "D") | RC = 8 THEN DO                   /*COPY*/
                ok='0';ADDRESS "ISPEXEC" "EDREC DEFER"                  /*COPY*/
              END                                                       /*COPY*/
          OTHERWISE                                                     /*COPY*/
              ok='0 4 20';ADDRESS "ISPEXEC" "EDREC PROCESS"             /*COPY*/
              IF RC = 20 THEN DO                                        /*COPY*/
                  ok='*';ADDRESS "ISPEXEC" "EDREC CANCEL"               /*COPY*/
              END                                                       /*COPY*/
          END                                                           /*COPY*/
      END                                                               /*COPY*/
  END                                                                   /*COPY*/
RETURN                                                                  /*COPY*/
/**********************************************************************
    Process Macro against a member
***********************************************************************/
MACRO_IT:
  IF LEFT(LnCmd, 1) = '&' THEN RepMac=SUBSTR(LnCmd,2)
     ELSE                      RepMac=RIGHT(LnCmd,8)
  RepParm=""
              /* VPUT Macro to be invoked by MACREPM */
  ok='0'; ADDRESS "ISPEXEC" "VPUT (RepMac RepParm TEST) SHARED"

  ok='*';ADDRESS "ISPEXEC" "EDIT DATAID("id") MEMBER("MbrNme") MACRO(MACREPM)"
  IF RC > 4 THEN DO
      CALL SET_MSG "ERROR on" STRIP(MbrNme)"!", "An ERROR occured while",
                   "EDITing" STRIP(MbrNme) "--" ZERRLM, 'YES'
      ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*MacErr)"
    END
  ELSE DO
      MemFunc.processed=MemFunc.processed+1
      MemFunc.edited=MemFunc.macroed+1

      IF RC = 0 THEN UserData='*MEDITED'; ELSE UserData='*MBrowse'
      ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                       "MEMBER("MbrNme") ZLUDATA("UserData")"
      IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                        "MEMBER("MbrNme") ZLUDATA("UserData")"
  END
RETURN 0
/**********************************************************************
    Move member in current %MU member list
***********************************************************************/
MOVE_IT:
  option=' Moving:'
  SELECT
    WHEN LEFT(ALWAYS,1) = 'Y' THEN CALL DO_MOVE
    WHEN GET_C_M_INFO() THEN CALL DO_MOVE
  OTHERWISE; NOP; END
RETURN 0
/**********************************************************************
            Move Member Logic
***********************************************************************/
DO_MOVE:
  IF LnData = '' | LEFT(LnData,1) = '*' THEN
       x=MOVE_MEMBER(MbrNme MbrNme)
  ELSE x=MOVE_MEMBER(LnData MbrNme)
  IF x = 0 THEN DO
      MemFunc.processed=MemFunc.processed+1
      MemFunc.moved=MemFunc.moved+1
      ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                                 "MEMBER("MbrNme") ZLUDATA(*Moved)"
      IF RC ¬= 0 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                        "MEMBER("MbrNme") ZLUDATA(*Moved)"
  END
RETURN
/**********************************************************************
            Move Member to a new PDS
***********************************************************************/
MOVE_MEMBER:
ARG to_member fm_member .
  ok='0 4 8 12'
    ADDRESS "ISPEXEC" "LMMOVE FROMID("id") FROMMEM("fm_member")",
                      "TODATAID("trgtid") TOMEM("to_member") TRUNC" REPLACE
  success=RC; IF RC ¬= 0 THEN excuse=ZERRLM
  IF LEFT(ALWAYS,1) ¬= 'Y' THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMFREE  DATAID("trgtid")"
     trgtid=''
  END
  IF success = 0 & (DsName = dest | DsName = "'"SYSUID"."dest"'") THEN DO
     ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                                "MEMBER("to_member") ZLUDATA(*NewCopy)"
     IF RC = 8 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                                      "MEMBER("to_member") ZLUDATA(*NewCopy)"
  END
  IF MemFunc.processed > 0 THEN RETURN success
  SELECT
    WHEN success  = 0 THEN CALL SET_MSG fm_member "moved.", "Member" ,
                           fm_member "moved to" dest, 'NO'
    WHEN success <= 8 THEN CALL SET_MSG "Couldn't move" fm_member".",,
                           fm_member "--" excuse
  OTHERWISE
      CALL SET_MSG "No MOVE done!?", excuse
  END
RETURN success
/**********************************************************************
            Next Version, Modified Date/Time, and Userid
***********************************************************************/
NEXT_VERSION:
  IF ZLVERS='' THEN ZLVERS=1
  ADDRESS "ISPEXEC" "LMMSTATS DATAID("id") MEMBER("MbrNme")",
                    "MODDATE("DATE('O')") MODTIME("TIME('N')")",
                    "VERSION("ZLVERS+1") MODLEVEL(0)",
                    "USER("STRIP(LEFT(SYSUID,7))")"
  IF RC = 0 THEN DO
      MemFunc.processed=MemFunc.processed+1
      MemFunc.nexted=MemFunc.nexted+1
  END
  ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*NextVer)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*NextVer)"
  END
RETURN 0
/**********************************************************************
    Print member in current %MU member list
***********************************************************************/
PRINT_IT:
  IF LEFT(DsName,1) ¬= "'" THEN FullDsn=DsName"("STRIP(MbrNme)")"
     ELSE FullDsn=STRIP(DsName,"T","'")"("STRIP(MbrNme)")'"
  IF ABBREV(ZLUDATA,"*") THEN
       ADDRESS "TSO" "RPRINT DSN("FullDsn")"
  ELSE ADDRESS "TSO" "RPRINT DSN("FullDsn")" ZLUDATA
  MemFunc.processed=MemFunc.processed+1
  MemFunc.printed=MemFunc.printed+1
  ok='0 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                   "MEMBER("MbrNme") ZLUDATA(*Printed)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*Printed)"
  END
RETURN 0
/**********************************************************************
    Rename member in current %MU member list
***********************************************************************/
RENAME_IT:
  IF LEFT(LnData,1) = '*' | LnData = '' THEN DO
      CALL SET_MSG "Rename to what?", "No new name given for" MbrNme,
                   "to be renamed to!", "YES"
      RETURN 1
  END

  ADDRESS "ISPEXEC" "LMINIT DATASET("DsName") DATAID(sameid) ENQ(SHRW)",
                    "VOLUME("VOLSER")"
  ADDRESS "ISPEXEC" "LMOPEN DATAID("sameid") OPTION(OUTPUT)"
  ok='0 4 12';ADDRESS "ISPEXEC" "LMMREN DATAID("sameid") MEMBER("MbrNme")",
                    "NEWNAME("LnData")"
  rename_RC = RC

  ok='0';ADDRESS "ISPEXEC" "LMCLOSE DATAID("sameid")"
  ADDRESS "ISPEXEC" "LMFREE  DATAID("sameid")"
  sameid = ''

  SELECT
    WHEN rename_RC = 0                   THEN DO
        MemFunc.processed=MemFunc.processed+1
        MemFunc.renamed=MemFunc.renamed+1
        ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                          "MEMBER("MbrNme") ZLUDATA(*ReNamed)"
        ok='0 8'
          ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD) MEMBER("LnData")"
          IF RC = 8 THEN ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                                           "MEMBER("LnData")"
      END
    WHEN MbrNme = LnData                 THEN DO
        CALL SET_MSG "Not a new name!", "You can't RENAME a member to the",
                     "same name?!?!?!", "YES"
      END
    WHEN WORDPOS(rename_RC, "4 12") ¬= 0 THEN CALL SET_MSG , ZERRLM, "YES"
  OTHERWISE; NOP; END
RETURN 0
/**********************************************************************
    Sumbit the member in current %MU member list
***********************************************************************/
SUBMIT_IT:
  IF LEFT(DsName,1) ¬= "'" THEN
       FullDsn = DsName"("STRIP(MbrNme)")"
  ELSE FullDsn = STRIP(DsName,"T","'")"("STRIP(MbrNme)")'"

  MsgStat=MSG("ON");   x = OUTTRAP("X.")
    ADDRESS "TSO" "SUBMIT ("FullDsn")"
  x = OUTTRAP("OFF"); MsgStat=MSG(MsgStat)

  ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*Submit)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*Submit)"
  END
  MemFunc.submit    =MemFunc.submit+1
  IF MemFunc.submit_msgs = 0 THEN DO
      MemFunc.submit_msgs = X.1
      CALL SET_MSG , X.1, "NO"
    END
  ELSE MemFunc.submit_msgs = MemFunc.submit_msgs X.1
  MemFunc.processed=MemFunc.processed+1
RETURN 0
/**********************************************************************
            Touch Version, Modified Date/Time, and Userid
***********************************************************************/
TOUCH_IT:
  IF ABBREV('YES',NODATA)     THEN
     ADDRESS "ISPEXEC" "LMMSTATS DATAID("id") MEMBER("MbrNme") DELETE"
  ELSE DO
      IF ZLVERS = ''          THEN DO; ZLVERS = 1; ZLMOD = -1; END
      IF ZLMOD = 99           THEN DO; ZLVERS=ZLVERS+1; ZLMOD=-1; END
      IF ABBREV(EXTENDED,"Y") THEN EXTENDED="YES"; ELSE EXTENDED=""
      ADDRESS "ISPEXEC" "LMMSTATS DATAID("id") MEMBER("MbrNme")",
                        "MODDATE("DATE('O')") MODTIME("TIME('N')")",
                        "VERSION("ZLVERS") MODLEVEL("ZLMOD+1")",
                        "USER("STRIP(LEFT(SYSUID,7))") EXT("EXTENDED")"
  END
  IF RC = 0 THEN DO
      MemFunc.processed=MemFunc.processed+1
      MemFunc.touched=MemFunc.touched+1
  END
  ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*Touched)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*Touched)"
  END
RETURN 0
/**********************************************************************
    View member in current %MU member list
***********************************************************************/
VIEW_IT:
  ok='*';ADDRESS "ISPEXEC" "VIEW DATAID("id") MEMBER("MbrNme")",
                           "MACRO("IMACRO")" FORMAT
  SELECT
    WHEN RC = 12 THEN DO
        CALL SET_MSG "ERROR on" STRIP(MbrNme)"!", "An ERROR occured while",
                     "VIEWing" STRIP(MbrNme) "--" ZERRLM, 'YES'
        ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                       "MEMBER("MbrNme") ZLUDATA(*BRError)"
      END
    WHEN RC >= 14 THEN CALL SET_MSG STRIP(MbrNme) "not found!",,
        "No member" STRIP(MbrNme) "found --" ZERRLM, 'YES'
  OTHERWISE
      MemFunc.processed=MemFunc.processed+1
      MemFunc.viewed=MemFunc.viewed+1
      ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                         "MEMBER("MbrNme") ZLUDATA(*Viewed)"
      IF RC ¬= 0 THEN DO      /* New member to ADD to member list      */
         ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                        "MEMBER("MbrNme") ZLUDATA(*Viewed)"
      END
  END
RETURN 0
/**********************************************************************
    Setup to Transmit member(s) to a dataset
***********************************************************************/
XMIT_IT:
  MemFunc.xmit_mems=STRIP(STRIP(MemFunc.xmit_mems MbrNme,"L","0"))
  MemFunc.processed=MemFunc.processed+1
  MemFunc.xmited=MemFunc.xmited+1
  ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                               "MEMBER("MbrNme") ZLUDATA(*Xmited)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*Xmited)"
  END
RETURN 0
/**********************************************************************
    Transmit member(s) to a Dataset
***********************************************************************/
DO_XMIT_IT:
  IF ABBREV(DsName,"'") THEN OutDsn=STRIP(DsName,"T","'")".XMIT'"
     ELSE                    OutDsn=DsName".XMIT"
  ADDRESS "TSO" "NEWSTACK"
    ADDRESS "TSO" "XMIT JES2."SYSUID "DSN("DsName") OUTDSN("OutDsn")",
                  "NOLOG NONOTIFY MEMBERS("MemFunc.xmit_mems")"
  ADDRESS "TSO" "DELSTACK"
RETURN 0
/**********************************************************************
    Receive a XMIT Datasets member
***********************************************************************/
XMITREC_IT:
  IF ABBREV(DsName,"'") THEN DO
     RecDsn=STRIP(DsName,"T","'"); OutDsn=RecDsn"."MbrNme"'"
     RecDsn=RecDsn"("MbrNme")'"
    END
  ELSE DO
     RecDsn=DsName"("MbrNme")";    OutDsn=DsName"."MbrNme
  END
  ok='*'
  x=PROMPT("ON"); y=MSG("OFF"); ADDRESS "TSO" "NEWSTACK"
    QUEUE "DSN("OutDsn") SYSOUT(0)"
    QUEUE ""
    ADDRESS "TSO" "RECEIVE INDSN("RecDsn") NONAMES"
    IF RC = 12 THEN ADDRESS "TSO" "RECEIVE INDSN("RecDsn") NONAMES"
  ADDRESS "TSO" "DELSTACK"; y=MSG(y); x=PROMPT(x)

  MemFunc.processed=MemFunc.processed+1
  MemFunc.xmitreced=MemFunc.xmitreced+1
  ok='0 4 8';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(PUT)",
                     "MEMBER("MbrNme") ZLUDATA(*RECed)"
  IF RC ¬= 0 THEN DO
     ok='0';ADDRESS "ISPEXEC" "LMMDISP DATAID("id") OPTION(ADD)",
                    "MEMBER("MbrNme") ZLUDATA(*RECed)"
  END
RETURN 0
/**********************************************************************
    Set ISPF messages appropriately
***********************************************************************/
SET_ISPF_MSG:
  lmsg=''
  IF MemFunc.submit > 0      THEN lmsg=MemFunc.submit_msgs
  IF MemFunc.alias > 0       THEN lmsg=MemFunc.alias "-- member(s) ALIASed"
  IF MemFunc.alloced > 0     THEN lmsg=MemFunc.alloced "-- member(s)    ALLOCed"
  IF MemFunc.browsed > 0     THEN lmsg=MemFunc.browsed "-- member(s)    Browsed"
  IF MemFunc.compressed > 0 THEN lmsg=lmsg MemFunc.compressed ,
                                       "-- member(s) Compressed"
  IF MemFunc.copied > 0      THEN lmsg=lmsg MemFunc.copied,
                                       "-- member(s) Copied"
  IF MemFunc.deleted > 0     THEN lmsg=lmsg MemFunc.deleted,
                                       "-- member(s) Deleted"
  IF MemFunc.edited > 0      THEN lmsg=lmsg MemFunc.edited,
                                       "-- member(s) Edited"
  IF MemFunc.macroed > 0     THEN lmsg=lmsg MemFunc.macroed,
                                       "-- member(s) Macroed"
  IF MemFunc.moved > 0       THEN lmsg=lmsg MemFunc.moved "-- member(s) Moved"
  IF MemFunc.nexted > 0      THEN  msg=lmsg MemFunc.nexted,
                                       "-- member(s) Nexted"
  IF MemFunc.printed > 0     THEN lmsg=lmsg MemFunc.printed,
                                       "-- member(s) Printed"
  IF MemFunc.renamed > 0     THEN lmsg=lmsg MemFunc.renamed,
                                       "-- member(s) ReNamed"
  IF MemFunc.touched > 0     THEN lmsg=lmsg MemFunc.touched,
                                       "-- member(s) Touched"
  IF MemFunc.viewed > 0      THEN lmsg=MemFunc.viewed "-- member(s) Viewed"
  IF MemFunc.xcluded > 0     THEN lmsg=lmsg MemFunc.xcluded,
                                       "-- member(s) eXcluded"
  IF MemFunc.xmited > 0      THEN lmsg=lmsg MemFunc.xmited,
                                       "-- member(s) SENT"
  IF MemFunc.xmitreced > 0   THEN lmsg=lmsg MemFunc.xmitreced,
                                       "-- member(s) RECed"
  IF MemFunc.non > 0         THEN lmsg=lmsg MemFunc.non,
                                       "-- UN-supported command(s)"
  IF MemFunc.submit > 0      THEN
       CALL SET_MSG , lmsg, 'NO'
  ELSE CALL SET_MSG MemFunc.processed "member(s) processed.", lmsg, 'NO'
RETURN
/**********************************************************************
            Line command which is not currently handled
***********************************************************************/
BAD_CMD:
ARG bad_cmd .
  MemFunc.non=MemFunc.non+1
  it_rc=0
  MemFunc.processed=MemFunc.processed+1
  IF MemFunc.processed = 1 THEN CALL SET_MSG "UN-supported line option!",,
     "'"bad_cmd"' not a supported line option by %MU at this time!"
RETURN
/**********************************************************************
            Cleanup and Exit Gracefully
***********************************************************************/
CLEANUP:
  ok='*'
    ADDRESS "TSO" "DELSTACK"; y=MSG(y); x=PROMPT(x)
    ADDRESS "ISPEXEC" "LMCLOSE DATAID("id")"
    ADDRESS "ISPEXEC" "LMCLOSE DATAID("sameid")"
    ADDRESS "ISPEXEC" "LMCLOSE DATAID("trgtid")"
    ADDRESS "ISPEXEC" "LMFREE  DATAID("profid")"
    ADDRESS "ISPEXEC" "LMFREE  DATAID("id")"
    ADDRESS "ISPEXEC" "LMFREE  DATAID("sameid")"
    ADDRESS "ISPEXEC" "LMFREE  DATAID("trgtid")"
EXIT ExitErr                        /* EXIT with error return code    */
/* COPY ERRPROC */
/********************************************************************** /*COPY*/
      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/
***********************************************************************//*COPY*/
ERROR_PROC:                                                             /*COPY*/
  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/
     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/
                                                                        /*COPY*/
  TRACE("O")                        /* Turn off ERROR traps et.al.    *//*COPY*/
  elineno=sigl                      /* Source line error occured in   *//*COPY*/
  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/
  SIGNAL OFF NOVALUE                                                    /*COPY*/
  CALL   OFF ERROR                                                      /*COPY*/
  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/
                                                                        /*COPY*/
  "SUBCOM ISPEXEC"                  /* Is ISPF available?             *//*COPY*/
  IF RC = 0 THEN IF SYSVAR('SYSENV') ¬= 'BACK' THEN DO UNTIL RC ¬= 0    /*COPY*/
        eresults=""                                                     /*COPY*/
        DO QUEUED()                                                     /*COPY*/
           PARSE PULL eresult                                           /*COPY*/
           eresults=STRIP(eresults "NL ===>" eresult)                   /*COPY*/
        END                                                             /*COPY*/
        ADDRESS "ISPEXEC" "DISPLAY PANEL(REXXEPNL)"                     /*COPY*/
      END                                                               /*COPY*/
    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/
  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/
                                                                        /*COPY*/
  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/
  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/
RETURN                                                                  /*COPY*/
/* COPY ERRINFO  */                                                     /*COPY*/
/********************************************************************** /*COPY*/
      Get the information about the ERROR and format it                 /*COPY*/
***********************************************************************//*COPY*/
GET_ERROR_INFO:                                                         /*COPY*/
  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/
  etype=CONDITION('C')              /* Condition causing error        *//*COPY*/
  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/
  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/
  sourcel=STRIP(sourcel)                                                /*COPY*/
  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/
     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/
     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/
     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/
  END                           /* END loop to handle continued lines *//*COPY*/
  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/
     ecause=ERRORTEXT(RC)          /* Brief description of error     */ /*COPY*/
     expandl="Can't INTERPRET source with SYNTAX errors!"               /*COPY*/
    END                                                                 /*COPY*/
  ELSE DO                                                               /*COPY*/
     Lst="ADDRESS CALL INTERPRET SAY"                                   /*COPY*/
     ecause=CONDITION('D')          /* Brief description of error     *//*COPY*/
     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/
     expandl=""                                                         /*COPY*/
     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/
        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/
        SELECT                                                          /*COPY*/
          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/
          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/
          WHEN POS("=",srcl)             > 1        THEN evals=srcl     /*COPY*/
        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/
        IF DATATYPE(evals, "NUM")                   THEN evals=srcl     /*COPY*/
        expandl=expandl';' evals                                        /*COPY*/
     END                                                                /*COPY*/
     expandl=STRIP(STRIP(expandl,"L",";"))                              /*COPY*/
  END                                                                   /*COPY*/
  SELECT                                                                /*COPY*/
    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN emsg=ZERRLM    /*COPY*/
    WHEN SYMBOL('SYSMSGLVL1') ¬= 'VAR'              THEN                /*COPY*/
             emsg='No available ERROR description.'                     /*COPY*/
    WHEN SYSMSGLVL1 = ""                            THEN                /*COPY*/
             emsg='No available ERROR description.'                     /*COPY*/
    WHEN SYMBOL('SYSMSGLVL2') = 'VAR'               THEN                /*COPY*/
             emsg=SYSMSGLVL1 "--" SYSMSGLVL2                            /*COPY*/
  OTHERWISE; emsg=SYSMSGLVL1; END                                       /*COPY*/
  IF POS("IN VARIABLE SYSREASON",emsg) > 0          THEN                /*COPY*/
             emsg="SYSREASON: '"SYSREASON"'"                            /*COPY*/
  IF etype = 'NOVALUE' THEN ExitErr=4        /* Set EXIT error level  *//*COPY*/
     ELSE                   ExitErr=RC                                  /*COPY*/
  erc=ExitErr           /* Get all information about error            *//*COPY*/
RETURN                                                                  /*COPY*/
/* COPY MVSERROR */                                                     /*COPY*/
/********************************************************************** /*COPY*/
                 Output ERROR information to SYSPRINT                   /*COPY*/
***********************************************************************//*COPY*/
MVS_ERROR_DISPLAY:                                                      /*COPY*/
  eresult.="";eresult.0=QUEUED() /* Get info currently on STACK       *//*COPY*/
  DO eresult=1 TO eresult.0; PARSE PULL eresult.eresult; END            /*COPY*/
  ls=LINESIZE()                     /* How wide is the display?       *//*COPY*/
  IF ls <= 80 THEN ls2=ls; ELSE ls2=ls-30                               /*COPY*/
  SAY ''                            /* Start SAYing error information *//*COPY*/
  SAY  CENTER(CENTER(" An ERROR occurred in REXX '"erexx"' ",50,'*'),ls)/*COPY*/
  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/
  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/
  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/
  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/
  DO eresults=2 TO eresult.0                                            /*COPY*/
     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/
  END                                                                   /*COPY*/
  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/
  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/
  SAY ''                                                                /*COPY*/
  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/
  SAY CENTER(CENTER("      End of ERROR Reporting     ",50,'*'),ls)     /*COPY*/
  SAY CENTER(CENTER("   Beginning of Error Handling   ",50,'*'),ls)     /*COPY*/
RETURN                                                                  /*COPY*/
/********************************************************************** /*COPY*/
        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/
   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/
   the first one found.  So, a REXX specific version of these can       /*COPY*/
   be use writen if it is placed before ERROR_PROC.                     /*COPY*/
***********************************************************************//*COPY*/
ERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/
RETURN                                                                  /*COPY*/
CLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/
  ADDRESS "ISPEXEC" "FTCLOSE"       /* CLOSE File Tailoring FILE      *//*COPY*/
  ZISPFRC=ExitErr                   /* SET ISPF RC to ExitErr         *//*COPY*/
  ADDRESS "ISPEXEC" "VPUT (ZISPFRC)"                                    /*COPY*/
EXIT ExitErr                        /* EXIT with error return code    *//*COPY*/
