{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012514000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE636.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE636.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x0b'", "DS1TRBAL": "b'on'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x92\\x00\\x02\\x04\\x92\\x00\\x04\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04=\\x00\\x00\\x01\\x03\\x16o\\x01\\x03\\x16o\\x18Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf1@@@'", "ispf": {"version": "04.61", "flags": 0, "createdate": "2003-06-15T00:00:00", "modifydate": "2003-06-15T18:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-461"}, "text": "REGULAR CBT TAPE - VERSION 461    FILE:  636\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT461.FILE636\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    3120    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 263 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/15/03    18:59:10    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE636": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04=\\x00\\x00\\x01\\x03\\x16o\\x01\\x03\\x16o\\x18X\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf1@@@'", "ispf": {"version": "04.61", "flags": 0, "createdate": "2003-06-15T00:00:00", "modifydate": "2003-06-15T18:58:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT-461"}, "text": "//***FILE 636 is a REXX to execute TSO commands in a very general   *   FILE 636\n//*           manner, against a list of datasets.  A description    *   FILE 636\n//*           of how the WCOMMAND exec works, follows below.        *   FILE 636\n//*                                                                 *   FILE 636\n//*      Description of the WCOMMAND REXX EXEC.                     *   FILE 636\n//*                                                                 *   FILE 636\n//*         This REXX attempts to execute any TSO command           *   FILE 636\n//*      against any (LISTCAT LEV( )) level of files.  It can       *   FILE 636\n//*      also select certain files from the designated level        *   FILE 636\n//*      with another string required to be a part of the file      *   FILE 636\n//*      name in its lower levels.                                  *   FILE 636\n//*                                                                 *   FILE 636\n//*         The inputs are:  First, the level of the files to be    *   FILE 636\n//*      operated on by the command.  The second argument is the    *   FILE 636\n//*      TSO command with a single '*' in it which will be          *   FILE 636\n//*      replaced with the designated file names.  The command      *   FILE 636\n//*      entered should be enclosed in quotes, and either single    *   FILE 636\n//*      or double quotes may be used depending on the user's       *   FILE 636\n//*      whim or the existing quotes within the command.            *   FILE 636\n//*                                                                 *   FILE 636\n//*         The third argument is the other string to               *   FILE 636\n//*      be looked for in the file names for them to be used        *   FILE 636\n//*      in the command.  If there is no selection desired          *   FILE 636\n//*      among files within the level, an * may be used for         *   FILE 636\n//*      this argument.  The final and optional argument may        *   FILE 636\n//*      be EXEC in order to execute the commands.  If this is      *   FILE 636\n//*      not used, the commands will only be listed.  The           *   FILE 636\n//*      program tries to avoid executing commands without the      *   FILE 636\n//*      user taking due caution because it can create havoc        *   FILE 636\n//*      with a system, so please be careful trying to use it.      *   FILE 636\n//*                                                                 *   FILE 636\n//*   Below are sample command lines:                               *   FILE 636\n//*                                                                 *   FILE 636\n//*      WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" *                      *   FILE 636\n//*       (does LISTC ENT('IBMUSER.*') ALL in all cases - dry run)  *   FILE 636\n//*                                                                 *   FILE 636\n//*      WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" string                 *   FILE 636\n//*       (does LISTC ENT('IBMUSER.*') ALL only w/string in         *   FILE 636\n//*        low level qualifiers - dry run)                          *   FILE 636\n//*                                                                 *   FILE 636\n//*      WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" * EXEC                 *   FILE 636\n//*       (same as above - actually executes the commands)          *   FILE 636\n//*                                                                 *   FILE 636\n//*      WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" string EXEC            *   FILE 636\n//*       (same as above - actually executes the commands)          *   FILE 636\n//*                                                                 *   FILE 636\n//*      WCOMMAND SYSTEMS.DUMP 'DEL *' DMP00                        *   FILE 636\n//*       (does DEL 'SYSTEMS.DUMP.*' where the string DMP00 is      *   FILE 636\n//*        in the low level qualifiers - dry run)                   *   FILE 636\n//*                                                                 *   FILE 636\n//*      WCOMMAND SYSTEMS.DUMP 'DEL *' DMP00 EXEC                   *   FILE 636\n//*       (does DEL 'SYSTEMS.DUMP.*' where the string DMP00 is      *   FILE 636\n//*        in the low level qualifiers - executes the commands)     *   FILE 636\n//*                                                                 *   FILE 636\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WCOMMAND": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00F\\x01\\x03\\x16/\\x01\\x03\\x16o\\x18\\x15\\x00\\xc5\\x00N\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2003-06-11T00:00:00", "modifydate": "2003-06-15T18:15:46", "lines": 197, "newlines": 78, "modlines": 0, "user": "SBGOLOB"}, "text": "/*BEGIN ==================== REXX ===================================*/\n/*                                                                   */\n/*      This REXX attempts to execute any command with any level of  */\n/*   files.  It can also select certain files from the designated    */\n/*   level with another string required to be a part of the file     */\n/*   name.  The inputs are first, the level of the files to be       */\n/*   operated on by the command.  The second argument is the command */\n/*   with a single '*' in it which will be replaced with the         */\n/*   designated file names.  The command entered should be enclosed  */\n/*   in quotes, and either single or double quotes may be used       */\n/*   depending on the users whim or the existing quotes within the   */\n/*   command.  The third argument is the other string to be looked   */\n/*   for in the file names for them to be used in the command.  If   */\n/*   there is no selection desired among files within the level, an  */\n/*   * may be used for this argument.  The final and optional        */\n/*   argument may be EXEC in order to execute the commands.  If this */\n/*   is not used, the commands will only be listed.  The program     */\n/*   tries to avoid executing commands without the user taking due   */\n/*   caution because it can create havoc with a system, so please be */\n/*   careful trying to use it.                                       */\n/*                                                                   */\n/*      Below are sample command lines:                              */\n/*   WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" *                           */\n/*   WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" LIST                        */\n/*   WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" * EXEC                      */\n/*   WCOMMAND IBMUSER \"LISTC ENT(*) ALL\" LIST EXEC                   */\n/*   WCOMMAND SYSTEMS.DUMP 'DEL *' DMP00                             */\n/*                                                                   */\n/*END ====================== REXX ===================================*/\n\n/* Get any possible argument                                         */\nparse upper arg input\n\n/* The command line must have something or else we lecture the guy   */\nif length(input) = 0 then do\n\n/* Search for start of comment                                       */\n  do i = 1 to sourceline()\n    if '/*BEGIN' = left(sourceline(i),7) then leave\n    end\n\n/* If we're at end of program, report and quit                       */\n  if i > sourceline() then do\n    say ' '\n    say \"There are no comments in this program, so they aren't printed.\"\n    exit\n    end\n\n/* Else print them out while searching for end                       */\n  do j = i + 1 to sourceline()\n    if '/*END' = left(sourceline(j),5) then leave\n    s = strip(sourceline(j),'l')\n    l = pos('/*',s)\n    if l > 0 then k = pos('*/',s)\n    else do\n      l = -1\n      k = length(s) + 3\n      end\n    if k < 1 then k = length(s) + 3\n    say substr(s,l+2,k-3)\n    end\n  exit\n  end\n\n/* Use the first argument eneterd as the input file level            */\nparse var input lev input\nlenlev = length(lev)\n\n/* Second argument if present is the command to be executed else ask */\ndo while length(input) = 0\n  say 'Enter the command to be executed'\n  parse upper pull input\n  end\n\n/* Get whatever the user wants to be executed without blanks         */\ninput = strip(input,'B')\n\n/* First check for quotes, either single or double                   */\nif ( left(input,1) = '\"' ) | ( left(input,1) = \"'\" ) then do\n\n/* Then look for the closing auote                                   */\n  quote = left(input,1)\n  i = pos(quote,substr(input,2))\n  if i = 0 then do\n    say 'There was no trailing quote for the command, so quit now.'\n    exit 4\n    end\n  com = substr(input,2,i-1)\n  input = strip(substr(input,i+2),'B')\n  end\n\n/* If no quotes we must have an error so quit now ( can't have a * ) */\nelse do\n  say 'The entered command must be enclosed in quotes to contain a *.'\n  exit 4\n  end\n\n/* Now make the wildcard command by first finding the *              */\ni = pos('*',com)\nif i = 0 then do\n  say 'The command is not recognized with a wildcard so this will end.'\n  exit 4\n  end\n\n/* Set up the starting chars in the command ( before the * )         */\nif i > 1 then first = substr(com,1,i-1)\nelse first = ''\n\n/* Now the trailing chars in the command ( after the * )             */\nif length(com) = i then last = ''\nelse last = substr(com,i+1)\n\n/* Now show the command to be executed with the files found          */\nsay ' The command to be executed is:'\nsay first || '***' || last\n\n/* Now ask for the auxiliary defining file name string               */\ndo while length(input) = 0\n  say \"Enter string of files to be operated upon '*' for none.\"\n  parse upper pull input\n  end\n\n/* Get whatever the user wants to be used to pick out files or '*'   */\nparse var input match input\nif match = '*' then lmatch = 0\nelse lmatch = 1\n\n/* Set up the default for the execution variable                     */\nexec = 0\n\n/* Now check for optional arguments and process them all             */\ndo while length(input) > 0\n  parse var input opt input\n\n/* Right now EXEC is the only one recognized so it is easy           */\n  if opt = 'EXEC' then exec = 1\n\n/* Say we  don't recognize the argument and leave                    */\n  else do\n    say 'Unrecognized optional argument.'\n    exit 4\n    end\n\n  end\n\n/* Report on the status of the execution of the command              */\nif exec = 0 then say 'This will be a list only run.'\nelse do\n  say 'This run is for real, break out if this is not desired.'\n  say 'Please type enter if you are willing to suffer the consequences.'\n  parse pull ans\n  end\n\n/* Set the outtrap capture and issue the LISTC to get file names     */\ncmd = 'listc lev('lev')'\nx = outtrap('line.','*')\ncmd\nx = outtrap('OFF')\n\n/* If there were no files with the req'd name, we're done            */\nif pos('NOT FOUND',line.1) > 0 then do\n  say 'There was no return from the command:' cmd\n  exit 4\n  end\n\n/* Let the user know how many lines were returned                    */\nsay 'There were' line.0 'lines returned from the command.'\n\n/* Initialize command count                                          */\nocmd = 0\n\n/* Now go ahead and process all the files listed                     */\ndo i = 1 to line.0\n\n/* Make sure the vevel name is on this line                          */\n  x = pos(lev,line.i)\n  if x > 1 then do\n    orig = substr(line.i,x)\n\n/* If we are supposed to check for another match, do it else go on   */\n    if ( lmatch = 0 ) | ( pos(match,orig) > 0 ) then do\n\n/* Make the command and print it out in any case                     */\n      cmd = first || \"'\"orig\"'\" || last\n      say cmd\n      ocmd = ocmd + 1\n\n/* If we are supposed to execute the command do it now               */\n      if exec > 0 then cmd\n      end\n    end\n  end\n\n/* Say how many commands were executed in all                        */\nsay ''\nsay 'There were' ocmd 'commands generated.'\n\n", "mimetype": "text/x-pascal", "datatype": "ebcdic", "extension": ".p"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT636/FILE636.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT636", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}