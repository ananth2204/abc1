{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012757000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1116934, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE776.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1116934, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1116934, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE776.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x13\\x05'", "DS1TRBAL": "b'\\x88D'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05K\\x00\\x00\\x05L\\x00\\x04\\x00\\x14'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00Q\\x01\\x19!O\\x01\\x19!O\\x14\\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-08-02T00:00:00", "modifydate": "2019-08-02T14:14:51", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  776\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE776\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 21 MEMBERS COUNTED; CUMULATIVE SIZE IS 10,448 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/02/19    14:14:51    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x075/\\x01\\x075/\\t&\\x00+\\x00+\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-12-18T00:00:00", "modifydate": "2007-12-18T09:26:47", "lines": 43, "newlines": 43, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    RECV390 modificationns\nFrom:       \"hofmann_e@arcor.de\" <hofmann_e@arcor.de>\nDate:       Sun, 09 Dec 2007 16:00:45 +0100\nTo:         sbgolob@cbttape.org\n\nHello Sam,\n\nThis is my modified version of RECV390 dated 2007-04-07. Changes\nare documented below.  I've tried to comment all changes and\nmodifications in the source and also to preserve the structure of\nthe logic and code.  The intention of my changes was to get a\ncomplete command line tool handling XMIT-files.  So the changes\nare most driven from my point of view.  The source is compiled on\nwin32 with mingw.  I didn't test the changes on Linux until now,\nbut this should work too.  I named my modifications Version 1.1.5.\nNext Version should be V2, when a major rewrite, addressing the\nrestructuration of the code towards a more c-like code is done.\n\nPlease feel free to distribute my changes.  I cover my changes\nunder the existing licence of RECV390.  The modifications\ndescribed therefore don't change the Licence of RECV390 in any\nway.\n\nps.: Sorry for my English, but this is not my native tonque.\n\nD:\\home\\develop\\recv390\\notes\\recv390 +about\n\nCopyright 2000, 2001, Enhanced Software Services, Inc.\nV1R1M4 - doc & license at http://ensose.com/recv390.html\nCopyright 2007, V1R1M5 - Open Source, Edgar Hofmann. hofmann_e@arcor.de.\neho 20071207: Embedded XMIT\neho 20071206: Path spcification\neho 20071205: Binary Extract\neho 20071204: Alias Processing\neho 20071202: Single Member Extract\neho 20071130: Multi-Segment Control Records\n\n\nWith kind regards\n\nEdgar Hofmann\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x009\\x01\\x08\\x05\\x1f\\x01\\x08\\x05\\x1f\\x11'\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-02-20T00:00:00", "modifydate": "2008-02-20T11:27:39", "lines": 31, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    RECV390 modifications V1R1M6\nFrom:       \"hofmann_e@arcor.de\" <hofmann_e@arcor.de>\nDate:       Mon, 28 Jan 2008 18:52:18 +0100\nTo:         sbgolob@cbttape.org\n\nHi Sam,\n\nI have built a new level of RECV390. I have corrected some typos\nand restructured the documentation. I also found another bug in\nRECV390 and fixed it. I named it \" Bug Fix Zero-Bytes Trailer\nBlocks IEBCOPY\". The error was discovered when I tried to use\nRECV390 module to expand CBT776.zip.  The Level of this pac is\nnow V1R1M6. Please process the new level into the CBT updates.\n\nThanks Edgar\n\n$recv390 +about\nCopyright 2000, 2001, Enhanced Software Services, Inc.\nV1R1M4 - doc & license at http://ensose.com/recv390.html\nCopyright 2007, V1R1M6 - Open Source, Edgar Hofmann. hofmann_e@arcor.de.\neho V1R1M6 20071227: Default Extension .ASC\neho V1R1M6 20071227: Bug Fix Zero-Bytes Trailer Blocks IEBCOPY\neho V1R1M5 20071207: Embedded XMIT\neho V1R1M5 20071206: Path Specification\neho V1R1M5 20071205: Binary Extract\neho V1R1M5 20071204: Alias Processing\neho V1R1M5 20071202: Single Member Extract\neho V1R1M5 20071130: Multi-Segment Control Records\n\nrecv390-080128.zip\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE3": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x14\\x01\\x17\\x00/\\x01\\x17\\x00/!V\\x00!\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd9\\xc7\\xf1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T21:56:14", "lines": 33, "newlines": 20, "modlines": 0, "user": "SYSPRG1"}, "text": "Subject:    RECV390 New Functions\nFrom:       \"hofmann_e@arcor.de\" <hofmann_e@arcor.de>\nDate:       Mon, 02 Jan 2017 16:00:45 +0100\nTo:         sbgolob@cbttape.org\n\nHello Sam,\n\nthis is a complete rework of the RECV390 stuff, which I have\nreleased in 2007. I have split the functionality of RECV390\ninto two modules named XMCLIST and XMCUTIL. XMCLIST deals with\nthe XMIT-format and IEBCOPY UNLOAD data. XMCUTIL provides some\nconversion functions.\n\nWith XMCLIST and XMCUTIL, all RECV390 functions can be replaced.\n\n- XMCLIST and XMCUTIL work as a TSO Command Processsor or as a x86 cmdline\n          Program.  Ports working:  - MVS38, OS390, z/OS\n                                    - Linux (x86,...)\n                                    - WIN32/64 with MINGW\n\n- XMCLIST handles PO and POE unloaded datasets\n- XMCLIST handles all source devicetypes 3390, 3380, ...\n- XMCLIST avoids Errors of RECV390, XMITMANAGER and others, dealing with short\n          blocks: IEBCOPY UNLOAD of variable blocked shorter than Netdata\n                  Block Length.\n\n- XMCUTIL decodes Fixed and Variable Formats.\n\nWith kind regards\n\nEdgar Hofmann\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE4": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x19!O\\x01\\x19!O\\x14\\x04\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-02T00:00:00", "modifydate": "2019-08-02T14:04:01", "lines": 16, "newlines": 16, "modlines": 0, "user": "SBGOLOB"}, "text": "Note about EPUTL from Sam Golob:\n\nEPUTL is a (re-entrant) program which is used in combination with\na macro called APUT, that allows you to easily convert a TSO command\nusing TPUT output (not trappable) to PUTLINE output (trappable).\n\nThere was a flaw in the EPUTL coding, where the GETMAIN did not\nexactly match the FREEMAIN.  In the GETMAIN, we had to insert a\nparameter of SP=0, to ensure that the FREEMAIN, which specified\nSP=0, would not be a mismatch.  Most of the time, this is not a\nproblem, but we found a case where the calling program somehow\nmessed up the subpool number which the GETMAIN used.  This caused\na mismatch when FREEMAIN tried to free that storage and the result\nas a S30A-14 abend.  We just fixed it by putting SP=0 into the\nGETMAIN.  We have added EPUTL source here, and assembly JCL.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@DCUSER": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x00/\\x01\\x17\\x00/\\x17)\\x02\\xb7\\x02\\xb7\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T17:29:00", "lines": 695, "newlines": 695, "modlines": 0, "user": "E1226"}, "text": "#ifndef __DCUSER\n#define __DCUSER /* Prevent multiple includes */\n/*+--------------------------------------------------------------------<bod>+*/\n/*!sys:           llq: h                                                    !*/\n/*!ver: 5.3.17    (c): eho                                                  !*/\n/*!-------------------------------------------------------------------------!*/\n/*!desc: common user functions                                              !*/\n/*              sysprint()                                                  !*/\n/*              zzopen()                                                    !*/\n/*              zzgoptv()                                                   !*/\n/*              zzgoptk()                                                   !*/\n/*              zza2e()                                                     !*/\n/*              zze2a()                                                     !*/\n/*              zzsprintf()                                                 !*/\n/*              zzc2d()                                                     !*/\n/*              zzbcd2i()                                                   !*/\n/*              zzispfdate()                                                !*/\n/*              zzstrupr()                                                  !*/\n/*              zzmemmem()                                                  !*/\n/*              zzmemrmem()                                                 !*/\n/*!-------------------------------------------------------------------------!*/\n/*!run: X86 MVS MVS38 MVS43                                                 !*/\n/*!-------------------------------------------------------------------------!*/\n/*!e1226   16/12/28     5.3.17 zzgoptv with = and del                       !*/\n/*!e1226   16/09/17     5.3.16 zzgoptv with = and del                       !*/\n/*!e1226   16/08/18     5.3.14 all defined MVS                              !*/\n/*!e1226   16/08/03     5.02 zzbcd2i zzispdate                              !*/\n/*!e1226   16/07/20     5.01 sysprint() with *NO option                     !*/\n/*!e1226   16/07/20     5.01 zzc2d                                          !*/\n/*!e1226   16/07/20     5.01 zzsprintf                                      !*/\n/*+--------------------------------------------------------------------<eod>+*/\n\n/**0000***********************************************************************/\n/* common defs & structs                                                     */\n/* - derived from hercules dasdblks.h                                        */\n/**0000***********************************************************************/\ntypedef unsigned char  BYTE;\ntypedef unsigned char  HWORD\u00dd2\u00a8;\ntypedef unsigned char  FWORD\u00dd4\u00a8;\n\nstruct COPYR1 {                         /* IEBCOPY header record 1   */\n        BYTE    uldfmt;                 /* Unload format             */\n        BYTE    hdrid\u00dd3\u00a8;               /* Header identifier         */\n        HWORD   ds1dsorg;               /* Dataset organization      */\n        HWORD   ds1blkl;                /* Block size                */\n        HWORD   ds1lrecl;               /* Logical record length     */\n        BYTE    ds1recfm;               /* Record format             */\n        BYTE    ds1keyl;                /* Key length                */\n        BYTE    ds1optcd;               /* Option codes              */\n        BYTE    ds1smsfg;               /* SMS indicators            */\n        HWORD   uldblksz;               /* Block size of container   */\n                                        /* Start of DEVTYPE fields   */\n        FWORD   ucbtype;                /* Original device type      */\n        FWORD   maxblksz;               /* Maximum block size        */\n        HWORD   cyls;                   /* Number of cylinders       */\n        HWORD   heads;                  /* Number of tracks/cylinder */\n        HWORD   tracklen;               /* Track length              */\n        HWORD   overhead;               /* Block overhead            */\n        BYTE    keyovhead;              /* Keyed block overhead      */\n        BYTE    devflags;               /* Flags                     */\n        HWORD   tolerance;              /* Tolerance factor          */\n                                        /* End of DEVTYPE fields     */\n        HWORD   hdrcount;               /* Number of header records\n                                           (if zero, then 2 headers) */\n        BYTE    resv1;                  /* Reserved                  */\n        BYTE    ds1refd\u00dd3\u00a8;             /* Last reference date       */\n        BYTE    ds1scext\u00dd3\u00a8;            /* Secondary space extension */\n        BYTE    ds1scalo\u00dd4\u00a8;            /* Secondary allocation      */\n        BYTE    ds1lstar\u00dd3\u00a8;            /* Last track used TTR       */\n        HWORD   ds1trbal;               /* Last track balance        */\n        HWORD   resv2;                  /* Reserved                  */\n};\n/**0010***********************************************************************/\n/* sysprint()                                                                */\n/* write out message.                                                        */\n/*  - *NO.. as 1st arg suppresses prefix procname                            */\n/*  - always adds a lineend                                                  */\n/*  - LINUX:                                                                 */\n/*     user responsibility to provide a sufficient buffer                    */\n/* - MVSxx                                                                   */\n/*     max length is 255 incl. optional prefix. cut the end                  */\n/*     EPUTL (CBT-Tape). Writes to DD SYSPRINT. (trappable)                  */\n/* - global: __ZZPROC                                                        */\n/*---------------------------------------------------------------------------*/\nvoid sysprint(char *msg, ...) {\n\n  char tbuf\u00dd256\u00a8 = \"\";\n  int  tl;\n  char *p;\n\n  if (!memcmp(msg,\"*NO\",3)) {\n    va_list args;\n    va_start (args, msg);\n    p = va_arg (args, char *);\n\n    #if defined(MVS) || defined(MVS38) || defined(MVS43)\n    vsnprintf(tbuf,255,p,args);\n    tl = strlen(tbuf);\n    EPUTL(tbuf,tl);\n    #else\n    vfprintf(stderr,p,args);\n    fprintf(stderr,\"\\n\");\n    #endif\n\n    va_end (args);\n  }\n  else {\n    va_list args;\n    va_start (args, msg);\n\n    #if defined(MVS) || defined(MVS38) || defined(MVS43)\n    sprintf(tbuf,\"%-8.8s: \",__ZZPROC);\n    vsnprintf(tbuf+10,255-10,msg,args);\n    tl = strlen(tbuf);\n    EPUTL(tbuf,tl);\n    #else\n    fprintf(stderr,\"%-8.8s: \",__ZZPROC);\n    vfprintf (stderr,msg, args);\n    fprintf(stderr,\"\\n\");\n    #endif\n\n    va_end (args);\n  }\n\n  return;\n}\n/**0020***********************************************************************/\n/* zzopen:                                                                   */\n/*---------------------------------------------------------------------------*/\nFILE * zzopen(char *name,char *fopt, ...) {\n\n  FILE *fh;\n  char buf\u00dd256\u00a8;\n  char tbuf\u00dd256\u00a8;\n  char dsn\u00dd60\u00a8;\n  char ddn\u00dd9\u00a8;\n\n  va_list args;\n  va_start (args,fopt);\n  vsprintf (buf,fopt,args);\n  va_end (args);\n\n  #if defined(MVS) || defined(MVS38) || defined(MVS43)\n  if (!memcmp(buf+strlen(buf)-2,\"DD\",2)) sprintf(dsn,\"//DDN:%s\",name);\n  else                                   sprintf(dsn,\"//DSN:%s\",name);\n\n  fh = fopen(dsn,buf);\n  //  printf(\"zzopen: (%d) (%s) (%s)\\n\",fh,dsn,buf);\n  //  __get_tmpddn(name,ddn);\n  #else\n                                  // additional options don't bother '\n  fh = fopen(name,buf);\n  //  printf(\">> %d %s %s\\n\",fh,name,buf);\n  #endif\n\n  return fh;\n}\n/**0030***********************************************************************/\n/* zzgoptv()                                                                 */\n/* get opt value                                                             */\n/* rc=0 not found                                                            */\n/* rc=1     found                                                            */\n/*   -- delim\u00dd0\u00a8 is start                                                    */\n/*   -- delim\u00dd1\u00a8 is end   (optional)                                         */\n/* format: mem=member1                                                       */\n/*         mem='member1 member2'       !! bash gcc getopt hk                 */\n/*---------------------------------------------------------------------------*/\nint zzgoptv(char *key,char *dlm,char *src,char *tgt,int tl) {\n\n  int i,j,of,ln;\n  char b;\n  char wbuf\u00dd255\u00a8;\n  char kbuf\u00dd255\u00a8;\n\n  of = strlen(key);\n  ln = strlen(src);\n\n  strncpy(wbuf,src,255-1);\n  for (i=0;i<ln;i++) wbuf\u00ddi\u00a8 = toupper(wbuf\u00ddi\u00a8);\n  strncpy(kbuf,key,255-2);\n\n  kbuf\u00ddof\u00a8   = dlm\u00dd0\u00a8;\n  kbuf\u00ddof+1\u00a8 = 0x0;\n  if (memcmp(kbuf,wbuf,of)) return 0;\n/*\n  j = 0; b = 0;\n  for (i=of+0;i < ln; i++) {\n    if (j >= tl) break;\n    if      (src\u00ddi\u00a8 == dlm\u00dd0\u00a8)          { b++; tgt\u00ddj\u00a8 = src\u00ddi\u00a8; j++; }\n    else if (src\u00ddi\u00a8 == dlm\u00dd1\u00a8 && b > 0) { b--; tgt\u00ddj\u00a8 = src\u00ddi\u00a8; j++; }\n    else if (src\u00ddi\u00a8 == dlm\u00dd1\u00a8 && b ==0) break;\n    else                                {      tgt\u00ddj\u00a8 = src\u00ddi\u00a8; j++; }\n  }\n*/\n  j = 0; b = 0;\n  for (i=of+0;i < ln; i++) {\n    tgt\u00ddj\u00a8 = src\u00ddi\u00a8; j++;\n  }\n\n\n  fprintf(stderr,\"SRC:%s* DLM:%s* OF:%d KEY:%s* VAL:%s*\\n\",src,dlm,of,key,tgt);\n\n  return 1;\n}\n/**0040***********************************************************************/\n/* zzgoptk()                                                                 */\n/* get opt keyonly                                                           */\n/* rc=0 not found                                                            */\n/* rc=1     found                                                            */\n/*---------------------------------------------------------------------------*/\nint zzgoptk(char *key,char *src) {\n\n  int i,j,of,ln;\n  char b;\n  char wbuf\u00dd255\u00a8;\n\n  of = strlen(key);\n  ln = strlen(src);\n  if (of != ln) return 0;\n\n  strncpy(wbuf,src,255);\n\n  for (i=0;i<ln;i++) wbuf\u00ddi\u00a8 = toupper(wbuf\u00ddi\u00a8);\n  if (memcmp(key,wbuf,of)) return 0;\n\n  return 1;\n}\n/*****************************************************************************/\n/* DCSTRUCM                                                                  */\n/*   compare string upper (insensitive)                                      */\n/*****************************************************************************/\nstatic int dcstrucm (const char *str1, const char *str2) {\n\n  int k,l1,l2;\n\n  l1 = strlen(str1);\n  l2 = strlen(str2);\n  if (l1 != l2) return 1;\n\n  for (k = 0; k < l1; k++) {\n    if ((str1\u00ddk\u00a8 | 32) != (str2\u00ddk\u00a8 | 32))\n    break;\n  }\n  if (k != l1) return 1;\n\n  return 0;\n}\n/*****************************************************************************/\n/* DCTOKEN                                                                   */\n/*   1: string                                                               */\n/*   2: value                                                                */\n/*   3: search                                                               */\n/*   rc: 0   key not found (value is UNDETERMINED !!)                        */\n/*   rc: > 0 key found. rc is TOKEN NUMBER                                   */\n/*****************************************************************************/\nint dctoken(char *in,char *out,char *kmatch) {\n\n  int kno = 0;\n  int prc = 0;\n  int i;\n  int ix;\n  int k;\n  unsigned char   cc;\n  unsigned char   cd;\n  unsigned char   cx;                       // control bracket pairs inside\n  unsigned char   aa   = 'O';\n  unsigned char   nn   = 'K';\n  //                                        /* this is stable for asc & ebc */\n  #if defined X86\n  unsigned char   dd\u00dd\u00a8 = {0x22,0x28,0x27,0x0};  // \"('   /* ' */\n  #endif\n  #if defined MVS\n  unsigned char   dd\u00dd\u00a8 = {0x7F,0x4D,0x7D,0x0};  // \"('   /* ' */\n  #endif\n\n  ix = strlen(in);\n  k  = 0;\n  cd = ' ';\n\n  for (i = 0; i <= ix; i++) {\n    cc = in\u00ddi\u00a8;\n    if (i == ix) cc = ' ';   // force last key/value decision\n    /******************************************************************/\n    /* OUTSIDE                                                        */\n    /******************************************************************/\n    if (aa == 'O') {\n                        /* delim string start. is a value             */\n      if (strchr(dd,cc)) {\n        aa = 'I';\n        if (cc == '(') cd = ')';\n        else           cd = cc;\n        nn = 'V';\n        cx = 0;\n      }\n                        /* spc outside. nothing happens               */\n      else if (cc == ' ') {\n      }\n                        /* equal outside means next is a VALUE        */\n      else if (cc == '=') {\n        nn = 'V';\n        cx = 0;\n      }\n                        /* spc delimited string starts. Maybe V or K  */\n      else {\n        if (nn == 'K' && prc) {\n          if (!dcstrucm(kmatch,out)) out\u00dd0\u00a8 = 0x0;   // delete old str if kyonly\n  //      printf(\"DCTOKEN: %d I<%s> O<%s> M<%s>\\n\",prc,in,out,kmatch);\n          return prc;\n        }\n        aa = 'I';\n        cd = ' ';\n        //                                  /* this is a key                */\n        out\u00ddk\u00a8   = cc;\n        out\u00ddk+1\u00a8 = 0x0;\n        k++;\n      }\n    }\n    /******************************************************************/\n    /* INSIDE                                                         */\n    /******************************************************************/\n    else {\n                        /* spacedelim string. spc stops and next is V */\n      if (cd == ' ' && strchr(dd,cc)) {\n        k = 0;\n        /* do closing for cd & cd_space */\n        if (nn == 'K') kno++;\n        if (nn == 'K' && !dcstrucm(kmatch,out)) prc = kno;\n\n                               /* now a new delim string              */\n        aa = 'I';\n        if (cc == '(') cd = ')';\n        else           cd = cc;\n        nn = 'V';\n        cx = 0;\n      }\n                        /* spacedelim string. = stops and next is V   */\n      else if (cd == ' ' && cc == '=') {\n        aa = 'O';\n        k  = 0;\n        cd = ' ';\n        /* do closing for cd & cd_space */\n        if (nn == 'K') kno++;\n        if (nn == 'K' && !dcstrucm(kmatch,out)) prc = kno;\n\n        nn = 'V';\n        cx = 0;\n      }\n      //                /* Brackets inside String UP                  */\n      else if (cc == '(') {\n        cx++;\n        out\u00ddk\u00a8   = cc;\n        out\u00ddk+1\u00a8 = 0x0;\n        k++;\n      }\n      //                /* Brackets inside string DOWN (CLOSE)        */\n      else if (cc == ')' && cx > 0 ) {\n        cx--;\n        out\u00ddk\u00a8   = cc;\n        out\u00ddk+1\u00a8 = 0x0;\n        k++;\n      }\n                        /* delimited string. delim stops. nxt MUST KEY*/\n      else if (cc == cd) {\n        aa = 'O';\n        k  = 0;\n        cd = ' ';\n        /* do closing for cd & cd_space */\n        if (nn == 'K') kno++;\n        if (nn == 'K' && !dcstrucm(kmatch,out)) prc = kno;\n\n        nn = 'K';\n      }\n                        /* inside string. go on                       */\n      else {\n        if (nn == 'K' && prc) {\n          if (!dcstrucm(kmatch,out)) out\u00dd0\u00a8 = 0x0;   // delete old str if kyonly\n  //      printf(\"DCTOKEN: %d I<%s> O<%s> M<%s>\\n\",prc,in,out,kmatch);\n          return prc;\n        }\n        out\u00ddk\u00a8   = cc;\n        out\u00ddk+1\u00a8 = 0x0;\n        k++;\n      }\n    }\n  }\n\n  if (!dcstrucm(kmatch,out)) out\u00dd0\u00a8 = 0x0;   // delete old str if kyonly\n//printf(\"DCTOKEN: %d I<%s> O<%s> M<%s>\\n\",prc,in,out,kmatch);\n  return (prc);\n}\n/*****************************************************************************/\n/* DCPRMKYO                                                                  */\n/*   parameter keyonly                                                       */\n/*   arg 1: parm to search on                                                */\n/*   arg 2: default                                                          */\n/*   arg 3: alternate                                                        */\n/*   prc: 0 not found                                                        */\n/*   prc: 1 last fit for primary   (superseeds alternate                     */\n/*   prc: 2 last fit for alternate (superseeds default)                      */\n/*****************************************************************************/\nint dcprmkyo(char *p,char *key1,char *key2) {\n\n  int prc = 0;\n  int r1,r2;\n  char out\u00dd200\u00a8;\n\n  r1 = dctoken(p,out,key1);\n  r2 = dctoken(p,out,key2);\n\n  if (r1 > r2   )        prc = 1;\n  else if (r2 > r1   )   prc = 2;\n  else                   prc = 0;\n\nreturn(prc);\n}\n/*****************************************************************************/\n/* DCPRMKVL                                                                   /\n/*   parameter value for key                                                  /\n/*   arg 1: parm to search on                                                 /\n/*   arg 2: key                                                               /\n/*   arg 3: default value                                                     /\n/*   arg 4: output                                                            /\n/*   prc: 0 not found                                                         /\n/*   prc: other: found value for key                                          /\n/*****************************************************************************/\nint dcprmkvl(char *p,char *key,char *def,char *val) {\n\n  int prc = 0;\n  int rc;\n  char out\u00dd200\u00a8;\n\n  rc = dctoken(p,out,key);\n\n\n  if (rc == 0 ) {\n    strcpy(val,def);\n    prc = 0;\n  }\n  else {\n    strcpy(val,out);\n    prc = rc;\n  }\n\nreturn(prc);\n}\n/**0050***********************************************************************/\n/* zza2e                                                                     */\n/*  convert string to ebcdic                                                 */\n/*---------------------------------------------------------------------------*/\nvoid zza2e(void *in,int l) {\n\n  char *p;\n  int i;\n  unsigned char oc,nc;\n\n  static unsigned char ta2e \u00dd\u00a8 = {\n                                             /*    \u00a8+0 +1 +2 +3 +4 +5 +6 +7 */\n    0x00,0x01,0x02,0x03,0x37,0x2D,0x2E,0x2F, /* 00 \u00a8                        */\n    0x16,0x05,0x25,0x0B,0x0C,0x0D,0x0E,0x0F, /* 00 \u00a8                        */\n    0x10,0x11,0x12,0x13,0x3C,0x3D,0x32,0x26, /* 10 \u00a8                        */\n    0x18,0x19,0x3F,0x27,0x1C,0x1D,0x1E,0x1F, /* 18 \u00a8                        */\n    0x40,0x5A,0x7F,0x7B,0x5B,0x6C,0x50,0x7D, /* 20 \u00a8SP                      */\n    0x4D,0x5D,0x5C,0x4E,0x6B,0x60,0x4B,0x61, /* 28 \u00a8                        */\n    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7, /* 30 \u00a8 0  1  2  3  4  5  6  7 */\n    0xF8,0xF9,0x7A,0x5E,0x4C,0x7E,0x6E,0x6F, /* 38 \u00a8 8  9                   */\n    0x7C,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7, /* 40 \u00a8    A  B  C  D  E  F  G */\n    0xC8,0xC9,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6, /* 48 \u00a8 H  I  J  K  L  M  N  O */\n    0xD7,0xD8,0xD9,0xE2,0xE3,0xE4,0xE5,0xE6, /* 50 \u00a8 P  Q  R  S  T  U  V  W */\n    0xE7,0xE8,0xE9,0xAD,0xE0,0xBD,0x9A,0x6D, /* 58 \u00a8 X  Y  Z                */\n    0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87, /* 60 \u00a8    a  b  c  d  e  f  g */\n    0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96, /* 68 \u00a8 h  i  j  k  l  m  n  o */\n    0x97,0x98,0x99,0xA2,0xA3,0xA4,0xA5,0xA6, /* 70 \u00a8 p  q  r  s  t  u  v  w */\n    0xA7,0xA8,0xA9,0xC0,0x4F,0xD0,0x5F,0x07, /* 78 \u00a8 x  y  z                */\n    0x20,0x21,0x22,0x23,0x24,0x15,0x06,0x17, /* 80 \u00a8                        */\n    0x28,0x29,0x2A,0x2B,0x2C,0x09,0x0A,0x1B, /* 88 \u00a8                        */\n    0x30,0x31,0x1A,0x33,0x34,0x35,0x36,0x08, /* 90 \u00a8                        */\n    0x38,0x39,0x3A,0x3B,0x04,0x14,0x3E,0xE1, /* 98 \u00a8                        */\n    0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48, /* a0 \u00a8                        */\n    0x49,0x51,0x52,0x53,0x54,0x55,0x56,0x57, /* a8 \u00a8                        */\n    0x58,0x59,0x62,0x63,0x64,0x65,0x66,0x67, /* b0 \u00a8                        */\n    0x68,0x69,0x70,0x71,0x72,0x73,0x74,0x75, /* b8 \u00a8                        */\n    0x76,0x77,0x78,0x80,0x8A,0x8B,0x8C,0x8D, /* c0 \u00a8                        */\n    0x8E,0x8F,0x90,0x6A,0x9B,0x9C,0x9D,0x9E, /* c8 \u00a8                        */\n    0x9F,0xA0,0xAA,0xAB,0xAC,0x4A,0xAE,0xAF, /* d0 \u00a8                        */\n    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7, /* d8 \u00a8                        */\n    0xB8,0xB9,0xBA,0xBB,0xBC,0xA1,0xBE,0xBF, /* e0 \u00a8                        */\n    0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xDA,0xDB, /* e8 \u00a8                        */\n    0xDC,0xDD,0xDE,0xDF,0xEA,0xEB,0xEC,0xED, /* f0 \u00a8                        */\n    0xEE,0xEF,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF, /* f8 \u00a8                        */\n  };\n\n  for (i = 0;i<l;i++) {\n    p = &((char *)in)\u00ddi\u00a8;\n    oc = *p;\n    nc = ta2e\u00ddoc\u00a8;\n    ((unsigned char *)in)\u00ddi\u00a8 = nc;\n  }\n\n  return;\n}\n/**0060***********************************************************************/\n/* zze2a:                                                                    */\n/*  convert string to ascii                                                  */\n/*---------------------------------------------------------------------------*/\nvoid zze2a(void *in,int l) {\n\n  char *p;\n  int i;\n  unsigned char oc,nc;\n\n  int te2a\u00dd256\u00a8= {\n                                             /*    \u00a8+0 +1 +2 +3 +4 +5 +6 +7 */\n    0x00,0x01,0x02,0x03,0x9C,0x09,0x86,0x7F, /* 00 \u00a8                        */\n    0x97,0x8D,0x8E,0x0B,0x0C,0x0D,0x0E,0x0F, /* 00 \u00a8                        */\n    0x10,0x11,0x12,0x13,0x9D,0x85,0x08,0x87, /* 10 \u00a8                        */\n    0x18,0x19,0x92,0x8F,0x1C,0x1D,0x1E,0x1F, /* 18 \u00a8                        */\n    0x80,0x81,0x82,0x83,0x84,0x0A,0x17,0x1B, /* 20 \u00a8                        */\n    0x88,0x89,0x8A,0x8B,0x8C,0x05,0x06,0x07, /* 28 \u00a8                        */\n    0x90,0x91,0x16,0x93,0x94,0x95,0x96,0x04, /* 30 \u00a8                        */\n    0x98,0x99,0x9A,0x9B,0x14,0x15,0x9E,0x1A, /* 38 \u00a8                        */\n    0x20,0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6, /* 40 \u00a8SP                      */\n    0xA7,0xA8,0xD5,0x2E,0x3C,0x28,0x2B,0x7C, /* 48 \u00a8                        */\n    0x26,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, /* 50 \u00a8                        */\n    0xB0,0xB1,0x21,0x24,0x2A,0x29,0x3B,0x7E, /* 58 \u00a8                        */\n    0x2D,0x2F,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7, /* 60 \u00a8                        */\n    0xB8,0xB9,0xCB,0x2C,0x25,0x5F,0x3E,0x3F, /* 68 \u00a8                        */\n    0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1, /* 70 \u00a8                        */\n    0xC2,0x60,0x3A,0x23,0x40,0x27,0x3D,0x22, /* 78 \u00a8                        */\n    0xC3,0x61,0x62,0x63,0x64,0x65,0x66,0x67, /* 80 \u00a8    a  b  c  d  e  f  g */\n    0x68,0x69,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9, /* 88 \u00a8 h  i                   */\n    0xCA,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70, /* 90 \u00a8    j  k  l  m  n  o  p */\n    0x71,0x72,0x5E,0xCC,0xCD,0xCE,0xCF,0xD0, /* 98 \u00a8 q  r                   */\n    0xD1,0xE5,0x73,0x74,0x75,0x76,0x77,0x78, /* a0 \u00a8       s  t  u  v  w  x */\n    0x79,0x7A,0xD2,0xD3,0xD4,0x5B,0xD6,0xD7, /* a8 \u00a8 y  z                   */\n    0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, /* b0 \u00a8                        */\n    0xE0,0xE1,0xE2,0xE3,0xE4,0x5D,0xE6,0xE7, /* b8 \u00a8                        */\n    0x7B,0x41,0x42,0x43,0x44,0x45,0x46,0x47, /* c0 \u00a8    A  B  C  D  E  F  G */\n    0x48,0x49,0xE8,0xE9,0xEA,0xEB,0xEC,0xED, /* c8 \u00a8 H  I                   */\n    0x7D,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50, /* d0 \u00a8    J  K  L  M  N  O  P */\n    0x51,0x52,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3, /* d8 \u00a8 Q  R                   */\n    0x5C,0x9F,0x53,0x54,0x55,0x56,0x57,0x58, /* e0 \u00a8       S  T  U  V  W  X */\n    0x59,0x5A,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9, /* e8 \u00a8 Y  Z                   */\n    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37, /* f0 \u00a8 0  1  2  3  4  5  6  7 */\n    0x38,0x39,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF, /* f8 \u00a8 8  9                   */\n  };\n\n  for (i = 0;i<l;i++) {\n    p = &((char *)in)\u00ddi\u00a8;\n    oc = *p;\n    nc = te2a\u00ddoc\u00a8;\n    ((unsigned char *)in)\u00ddi\u00a8 = nc;\n  }\n\n  return;\n}\n/**0070***********************************************************************/\n/* zzsprintf()                                                               */\n/*   combined strcat & sprintf                                               */\n/*---------------------------------------------------------------------------*/\nvoid zzsprintf(char *pbuf,char *msg, ...) {\n\n  int i;\n  char *p;\n\n  va_list args;\n  va_start (args, msg);\n  i = strlen(pbuf);\n  p = pbuf+i;\n\n  vsprintf (p,msg, args);\n  va_end (args);\n\n  return;\n}\n/**0080***********************************************************************/\n/* zzc2d()                                                                   */\n/* - convert character bytes to integer (decimal)                            */\n/*---------------------------------------------------------------------------*/\nint zzc2d(unsigned char *p, int len) {\n\n  int            bin =0, i;\n  unsigned char  one;\n\n  for (i=0; i<len;i++) {\n    one = * (unsigned char *) p;\n    bin = (bin * 256) + (int) one;\n    p++;\n  }\n\n  return bin;\n}\n/**0090***********************************************************************/\n/* zzbcd2i()                                                                 */\n/* - BCD convert packed decimal bytes to integer                             */\n/* - 12345C -> int 12345                                                     */\n/*---------------------------------------------------------------------------*/\nint zzbcd2i(unsigned char *pd,int len) {\n\n  int i,j, n1;\n  unsigned int num;\n\n  j=1;\n  num = 0;\n  for (i=len-1;i>=0;i--) {\n    n1 = (i%2) ? pd\u00ddi/2\u00a8 % 16 : pd\u00ddi/2\u00a8 / 16;\n    num += n1*j;\n    j *= 10;\n  }\n  return num;\n}\n/**0100***********************************************************************/\n/* zzispfdate()                                                              */\n/*   0X YY DD DF --> YYYYMMDD                                                */\n/*   mmdd                                                                    */\n/*---------------------------------------------------------------------------*/\nint zzispfdate(int yyyy,int ddd) {\n\n  int i,j,k,rc = 0;\n  int mm\u00dd12\u00a8 = {31,29,31,30,31,30,31,31,30,31,30,31};\n\n  if (yyyy%4)       mm\u00dd1\u00a8 = 28;\n  if (!(yyyy%400))  mm\u00dd1\u00a8 = 28;\n\n  j = 0;\n  for (i=0;j+mm\u00ddi\u00a8< ddd;i++) {\n    j = j + mm\u00ddi\u00a8;\n  }\n\n  i = i + 1;\n  j = ddd -j;\n\n  return i*100+j;\n}\n/**0110***********************************************************************/\n/* zzstrupr()                                                                */\n/*   local strupr                                                            */\n/*****************************************************************************/\nvoid zzstrupr(char *str) {\n\n  int i;\n\n  for (i=0;str\u00ddi\u00a8 != 0x0;i++) str\u00ddi\u00a8 = toupper(str\u00ddi\u00a8);\n\n  return;\n}\n/**0120***********************************************************************/\n/* zzmemmem()                                                                */\n/*   search byte array                                                       */\n/*   hitchhiked from GNU                                                     */\n/*****************************************************************************/\nvoid *zzmemmem (const void *hs, size_t hs_len,const void *nee,size_t nee_len) {\n\n  const char *begin;\n  const char *const last_possible = (const char *) hs + hs_len - nee_len;\n\n  if (nee_len == 0)\n    /* The first occurrence of the empty string is deemed to occur at\n       the beginning of the string.  */\n    return (void *) hs;\n\n  /* Sanity check, otherwise the loop might search through the whole\n     memory.  */\n  if (hs_len < nee_len)\n    return NULL;\n\n  for (begin = (const char *) hs; begin <= last_possible; ++begin)\n    if (begin\u00dd0\u00a8 == ((const char *) nee)\u00dd0\u00a8 &&\n   !memcmp ((const void *) &begin\u00dd1\u00a8,\n       (const void *) ((const char *) nee + 1),\n       nee_len - 1))\n      return (void *) begin;\n\n  return NULL;\n}\n/**0130***********************************************************************/\n/* zzmemrmem()                                                               */\n/*   search byte array LAST OCCURENCE                                        */\n/*****************************************************************************/\nint zzmemrmem (const void *hs, size_t hs_len,const void *nee,size_t nee_len) {\n\n  int j = 0;\n  const unsigned char *pp;\n\n  while (1) {\n    pp = zzmemmem(hs,hs_len,nee,nee_len);\n    if (!pp) break;\n    hs_len = hs_len - (pp-(const unsigned char *)hs) -1;\n    j = pp - (const unsigned char *)hs;\n    pp++;\n  }\n\n return j;\n}\n#endif\n/**eoc ***********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE776": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00F\\x01\\x19!O\\x01\\x19!O\\x14\\x14\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-08-02T00:00:00", "modifydate": "2019-08-02T14:14:46", "lines": 21, "newlines": 21, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 776 is from Edgar Hoffmann and contains a zip file of     *   FILE 776\n//*           his version of RECV390 to run on a PC.  Since the     *   FILE 776\n//*           sources of his C program are not meant to be run      *   FILE 776\n//*           on an MVS machine, unless specially prepared, I have  *   FILE 776\n//*           instead left his submission unchanged, as a zip file  *   FILE 776\n//*           which was folded into FB, LRECL=80 format for         *   FILE 776\n//*           inclusion in this collection.  To use this file,      *   FILE 776\n//*           you have to download the RECV390 member, which is     *   FILE 776\n//*           a zip file, to a PC, and unzip it there.  Then you    *   FILE 776\n//*           can compile the C code, or use the included           *   FILE 776\n//*           executable.  Sorry for the non-MVS-ness.  We're in    *   FILE 776\n//*           a new age !!  See member $$NOTE1 for further info.    *   FILE 776\n//*                                                                 *   FILE 776\n//*           email:  \"hofmann_e@arcor.de\" <hofmann_e@arcor.de>     *   FILE 776\n//*                                                                 *   FILE 776\n//*       This file has been revised by its author as of January    *   FILE 776\n//*       2017.  Please see member $$NOTE3 for more detail.         *   FILE 776\n//*                                                                 *   FILE 776\n//*       The EPUTL object deck needed to be fixed, so its source   *   FILE 776\n//*       and assmebly JCL has been newly included.  (SBG)          *   FILE 776\n//*                                                                 *   FILE 776\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EPUTL": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x15\\x01\\x19!O\\x01\\x19!O\\x13V\\x00\\t\\x00\\t\\x00\\x00\\xd5\\xc5\\xe6\\xd6\\xc2\\xd1@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-08-02T00:00:00", "modifydate": "2019-08-02T13:56:15", "lines": 9, "newlines": 9, "modlines": 0, "user": "NEWOBJ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "EPUTLJCL": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x009\\x01\\x054\\x7f\\x01\\x19!O\\x14\\t\\x00\\x12\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd6\\xc2\\xd1@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2005-12-13T00:00:00", "modifydate": "2019-08-02T14:09:39", "lines": 18, "newlines": 28, "modlines": 0, "user": "ASMOBJ"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(EPUTLSRC)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=SHR,DSN=SBGOLOB.OBJECT(EPUTL)\n//*\n//\n//SYSLIN  DD DSN=SBGOLOB.OBJECT,DISP=(NEW,CATLG,DELETE),UNIT=3390,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200,OPTCD=C),VOL=SER=DATA01,\n//  SPACE=(TRK,(90,30,89))               /*FREE TRK=80,FREE DIR=82*/\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EPUTLOLD": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x00/\\x01\\x17\\x00/!\\x07\\x00\\t\\x00\\t\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T21:07:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "E1226"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "EPUTLSRC": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00Q\\x01\\x185/\\x01\\x19!O\\x129\\x00\\xcb\\x00\\xcb\\x00\\x01\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2018-12-18T00:00:00", "modifydate": "2019-08-02T12:39:51", "lines": 203, "newlines": 203, "modlines": 1, "user": "SOURCE"}, "text": "EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCC037": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x17\\x00/\\x01\\x17\\x00/\\x18\\t\\x002\\x002\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T18:09:09", "lines": 50, "newlines": 50, "modlines": 0, "user": "E1226"}, "text": "//JCC      PROC MEM=DUMMY1,\n//         SDSN=DUMMY2\n//*------------------------------------------------------------\n//** JCC COMPILE\n//** object code -o\n//** assembler   \"\"\n//*------------------------------------------------------------\n//JCCC     EXEC PGM=JCC,\n//   PARM='-o -z28000 -fcode= //DDN:JCCINPUT -I//DDN:JCCINCL'\n//STEPLIB  DD   DISP=SHR,DSN=SDBDC.MVS38J.JCC.LOAD\n//*CCINCL  DD   DISP=SHR,DSN=SDBDC.MVS38J.PRODINC\n//JCCINCL  DD   DISP=SHR,DSN=SDBDC.MVS38J.JCC.UINCPRE\n//         DD   DISP=SHR,DSN=SDBDC.MVS38J.JCC.INCLUDE\n//JCCINCS  DD   DISP=SHR,DSN=&SDSN\n//JCCINPUT DD   DISP=SHR,DSN=&SDSN(&MEM)\n//JCCOASM  DD DISP=(,PASS),DSN=&&TEMP2,               **  80 FB\n//            UNIT=VIO,SPACE=(TRK,(60,60)),           ** OBJECT\n//            DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//JCCOUTPT DD   SYSOUT=*\n//STDOUT   DD   SYSOUT=*\n//*------------------------------------------------------------\n//** JCC OBJ CODE & ASSEMBLER\n//*------------------------------------------------------------\n//*CCA     EXEC  PGM=IEBGENER,COND=(0,NE,JCCC)\n//*YSPRINT DD SYSOUT=*\n//*YSUT1   DD DISP=(OLD,PASS),DSN=&&TEMP2\n//*YSUT2   DD SYSOUT=*\n//*YSIN    DD DUMMY\n//*------------------------------------------------------------\n//** JCC PRELINK\n//*------------------------------------------------------------\n//JCCP     EXEC PGM=PRELINK,COND=(0,NE,JCCC),\n//    PARM='-s //DDN:L //DDN:O //DDN:I'\n//STEPLIB  DD   DISP=SHR,DSN=SDBDC.MVS38J.JCC.LOAD\n//STDOUT   DD SYSOUT=*\n//L        DD DISP=SHR,DSN=SDBDC.MVS38J.JCC.LIB\n//I        DD DISP=(OLD,PASS),DSN=&&TEMP2\n//O        DD DISP=(,PASS),DSN=&&TEMP3,               **  80 FB\n//            UNIT=VIO,SPACE=(TRK,(60,60)),           ** OBJECT\n//            DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//*------------------------------------------------------------\n//** MVS LINK\n//*------------------------------------------------------------\n//LINK   EXEC PGM=IEWL,COND=(0,NE),\n//    PARM='MAP,LIST,XREF,NORENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SDBDC.MVS38J.JCC.LIB\n//SYSLMOD  DD DISP=SHR,DSN=DUMMY(&MEM)\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&TEMP3\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(60,60))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "README03": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x00/\\x01\\x17\\x00/!\\x07\\x01*\\x01*\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T21:07:00", "lines": 298, "newlines": 298, "modlines": 0, "user": "E1226"}, "text": "OVERVIEW\n========\n\nThis is an updated version of my package, dealing with XMIT-Files on\ndifferent platforms.\n\nWith XMCLIST and XMCUTIL, all RECV390 functions can be replaced.\n\n- XMCLIST and XMCUTIL work as a TSO Command Processsor or as a x86 cmdline\n          Program.  Ports working:  - MVS38, OS390, z/OS\n                                    - Linux (x86,...)\n                                    - WIN32/64 with MINGW\n\n- XMCLIST handles PO and POE unloaded datasets\n- XMCLIST handles all source devicetypes 3390, 3380, ...\n- XMCLIST avoids Errors of RECV390, XMITMANAGER and others, dealing with short\n          blocks: IEBCOPY UNLOAD of variable blocked shorter than Netdata\n                  Block Length.\n\n- XMCUTIL decodes Fixed and Variable Formats.\n\n\nCONTENTS\n========\n\n    @DCUSER      common header\n    EPUTL        c wrapper EPUTL (object code)\n    JCC037       compile jclproc\n    README03     this one\n    SAMPINFO     Sample Output for XMCLIST of a XMIT-File\n    X86ZIP       binaries WIN32 for XMCLIST and XMCUTIL\n    XMCLIST      source\n    XMCLIST$     compile jcl\n    XMCLOAD      load modules XMCLIST XMCUTIL (xmitted)\n    XMCUTIL      source\n    XMCUTIL$     compile jcl\n\n    RECV390      old code, but still works. with some errors in RECFM=V or U\n\nMORE DETAILS\n============\n\nXMCLIST\n-------\n\nXMCLIST provides infos from a XMIT-Datasets. No need to use TSO TRANSMIT\n        Command to extract the whole XMIT-Dataset. Infos like Creation Date etc.\n        of the XMIT-Dataset, DCB-Infos of the covered IEBCOPY UNLOADed Dataset,\n        Directory ...\n\n          - Lists contents about INMR* Records\n          - Lists contents of the IEBCOPY UNLOAD\n            -- COPYR1 Info. DCB\n            -- COPYR2 Info. Extents\n            -- Directory Contents\n            -- Base Member Alias Resolution\n\nXMCLIST optional extracts a single member of the XMIT-contents. The format is\n        raw. No conversion is done. For RECFM=V contents Block-Descriptors and\n        Reord-Descriptors are kept. Optional the IEBCOPY Unload infos\n        (Parameter CCHHR) are preserved too. This maybe helpful to reconstruct\n        Load-Module contents.\n\nExample Invocation:\n\n TSO:\n         XMCLIST MY.RECV390.XMI NODIR MEM(MYMEM) ODS(MY.MYMEM.BIN)\n\n        shows no directory list, and extracts MYMEM\n                to a sequential file MY.MYMEM.BIN\n\n        - DDNAMES are allowed and prefixed with DD: . E.g. DD:MYDD\n        - Quotes are tolerated, but not honored. So a dsn needs to be\n          fully qualified in all cases.\n\n        - ODS(MY.*.BIN)\n          would substitute / expand to ODS(MY.MYMEM.BIN)\n\n X86:\n         $ xmclist my.recv390.bin --nodir --mem(mymem) --ods(my.mymem.bin)\n\n        - omitting --ods would write to stdout\n\nXMCUTIL\n-------\n\nXMCUTIL is a simple c module to convert raw input from XMCLIST to some desired,\n        readable outputs.\n\n TSO:\n         XMCUTIL MY.MYMEM.BIN RECFM=F LRECL=80 ASCII UNBLOCK +\n                          ODS(MY.RECV390.SOURCE(MYMEM))\n\n X86:\n         $ xmcutil my.meymem.bin --recfm=F --lrecl=80 \\\n                                      --ascii --unblock --ods=mymem.txt\n\n\nFAQs\n====\n\n1. Show Info from a XMIT-Dataset\n--------------------------------\n\n         $ xmclist my.recv390.bin\n\n         for Output see SAMPINFO\n\n2a. How to extract a complete XMIT-Dataset (X86) ?\n--------------------------------------------------\n\n         This is a Linux shell-script for extracting all members of a unloaded\n         PO-Dataset and to convert it to ASCII and LF (trailing spaces per line\n         truncated).\n\n<code>\n  #!/bin/sh\n  xmclist $1 2>&1 | grep '^ ' |\n    awk '{print \"xmclist '$1' --noinfo --nomsg --mem=\\x27\"$1\"\\x27 | \\\n    xmcutil - recfm=F --lrecl=80 --ascii --unblock --replace --ods=\"$1\".asc\"}' |\n  sh\n</code>\n\n  - be aware, the first $1 is the first pos parm for the shell script the name\n    of the XMIT-Dataset. The second (and third) $1 is the first field\n    for awk print, this is a MEMBERNAME\n\n  - grep gets all lines of output (stderr and stdout) with ONE LEADING SPACE.\n    This is the Membername\n\n\n  - the sample is also provided in X86ZIP\n\n2b. How to extract a complete XMIT-Dataset (MVS) ?\n--------------------------------------------------\n\n         just use TSO RECEIVE ...\n\n3a.  How to extract a single member from a XMIT-Dataset (MVS)\n-------------------------------------------------------------\n\n<jcl>\n  //S1      EXEC PGM=IKJEFT01\n  //STEPLIB   DD DISP=SHR,DSN=SDBDC.MVS38J.LOAD\n  //SYSPRINT DD SYSOUT=*\n  //SYSTSPRT DD SYSOUT=*\n  //DD1      DD SYSOUT=*,DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n  //SYSTSIN  DD *\n    XMCLIST SDBDC.GCC32380.XMI mem(GCCJCL) ODS(DD:DD1) replace\n</jcl>\n\n   - if no ODS() is specified, the output is routed to STDOUT DD\n   - specifiy prefix dd: if you route to a Statement.\n     For DD:  a REPLACE option is mandatory !!\n   - you need to specify a complete DCB for the Output to achieve\n     expected results.\n\n   Remark: No Error is reported, if the DD not exist. Coding\n           a DSN will report open errors.\n\n3b.  How to extract a single mem from a XMIT-Dataset (MVS) with orig RECFM(VB)\n------------------------------------------------------------------------------\n\n    This needs a little bit more effort, because we need to interpret\n    BDWs and RDWs.\n\n<jcl>\n  //S1      EXEC PGM=IKJEFT01\n  //STEPLIB   DD DISP=SHR,DSN=SDBDC.MVS38J.LOAD\n  //SYSPRINT DD SYSOUT=*\n  //DD1      DD  DISP=(,PASS),DSN=&TEMP,\n  //         UNIT=VIO,\n  //         DCB=(LRECL=80,RECFM=FB,BLKSIZE=6400)\n  //DD2      DD SYSOUT=*,\n  //         DCB=(LRECL=80,RECFM=FB,BLKSIZE=6400)\n  //STDOUT   DD SYSOUT=*\n  //SYSTSPRT DD SYSOUT=*\n  //SYSTSIN  DD *\n    XMCLIST SDBDC.JCC.INCLUDE.XMI MEM($$$DOC) ODS(DD:DD1) REPLACE\n    XMCUTIL DD:DD1 RECFM(V) LRECL(80) PAD ODS(DD:DD2) REPLACE\n</jcl>\n\n   - extract member raw to a &TEMP dataset. The DCB-Attributes DD1 do not\n     matter, because we read binary.\n   - use XMCUTIL to read RECFM(V) and resolve the BDSs and RDWs. Use PAD to\n     write the desired fixed length Record.  Add a complete DCB for the Output\n     to achieve expected results.\n   - DD2 may be the final permanent Dataset.\n\n   Remark: This is the only usecase, where XMCUTIL makes sense in MVS. All\n           other conversions can be done with wellknown DCB-keywords in MVS.\n\n4, The stuff with pipes and standard streams\n---------------------------------------------\n\n    in MVS TSO pipes are not implemented in the way we know from X86. So the\n    stdout, stderr have limited use. Following Rules apply for MVS:\n\n    - standard streams are in MVS-source not completely disabled,\n      but I didn't a comprehensive testing with this streams.\n\n      If you need them in a special use case, alloc them:\n\n      -- alloc STDIN  DD\n      -- alloc STDOUT DD\n      -- alloc STDERR DD\n\n     Messages for XMCUTIL & XMCLIST always go to SYSTSPRT\n     (purpose of EPUTL, PUTLINE see CBT-Tape).\n\n    - X86 allows for both XMCLIST & XMCUTIL stdout (--ods parm omitted).\n    - X86 uses stderr for Messages and Infos\n    - X86 allows stdin for XMCUTIL (hyphen - as first (positional) parm).\n     This allows concatentions of XMCLIST and XMCUTIL\n     (see sample shell script above).\n\n1. Where to find parameter descriptions for XMCLIST and XMCUTIL\n---------------------------------------------------------------\n\nTSO:\n    XMCLIST HELP\n    ...\n    XMCUTIL HELP\n\nX85:\n    $ xmclist --help\n    ...\n    $ xmcutil --help\n\nRECOMPILE NOTES\n===============\n\nAs mentioned before, the source of the programs is highly portable between\nthe different platforms.\n\nMVS\n---\n\n#define MVS\n#define MVS43\n\nThe provided load modules are compiled with Jason Winters C Compiler\nunder MVS 3.8. This means AMODE 24, RMODE 24. Compiling on newer MVS, OS390\nor z/OS enables other AMODE and RMODEs.\n\nCompiling with other compilers like GCCMVS or vendor compilers should not be\nan effort, as the programs don't deal with system specifics.\n\nLinux\n-----\n\n#define LINUX\n#define X86\n\nNo binaries provided. As I assume, that on Linux platforms in most cases\nGCC is installed and working. Compile yourself.\n\nNo MAKEFILEs necessary (@dcuser.h needs to be in the current directory):\n\n$ gcc xmclist.c -o xmclist\n$ gcc xmcutil.c -o xmcutil\n\nWindows\n-------\n\n#define LINUX\n#define X86\n\nI've provided compiled binaries with MINGW under WIN32. Although not\ncomprehensive tested, they seem to work. This is my only support for\nWindows, because I have no access to other Win C Compilers and WIN OS.\n\nCREDITS & HISTORY\n=================\n\nMost used for dealing with XMIT-Datasets is XMITMANAGER. It is a WIN32 Binary\n(I've found no source) and very reliable for RECFM=F. But it is interactive,\nno cmdline is possible. Other RECFM are dumped only raw and possible incomplete\n(See discussion RECV390 and above). No native port for LINUX and MVS exist.\n\nYears ago I've started to use Jim Morrisons X86 port. I published a modified\nversion of RECV390 in 2007, corrected some logic errors. But I stopped\nmaintaining this code and started with a new code base, when I identified\nnew requirements, like having a MVS port, which would be hard to implement\nin the existing code.\n\nSpecial thanks to the guys and their findings, which helped me to understand\nthe logics and caveats around the IEBCOPY UNLOAD and NETDATA (XMIT) format.\nTo mention here among others, David Alcocks \"UnXMIT information exchange\",\nKen Tomiaks works, Greg Price REVIEW package, which gives a lot of deep\nknowledge dealing with PDS.\n\nCOPYRIGHT\n=========\n\nThe current GNU Public Licence applies to this work. If there any license\nquestions about this work, please contact the author.\n                 -- ** --\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECV390": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x08\\x05\\x1f\\x01\\x08\\x05\\x1f\\x11\"\\x05\\xd3\\x05\\xd3\\x00\\x00\\xc5\\xc4\\xc7\\xc1\\xd9@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2008-02-20T00:00:00", "modifydate": "2008-02-20T11:22:00", "lines": 1491, "newlines": 1491, "modlines": 0, "user": "EDGAR"}, "mimetype": "application/zip", "datatype": "binary", "extension": ".zip"}, "SAMPINFO": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x006\\x01\\x17\\x00/\\x01\\x17\\x00/\\x18I\\x003\\x00'\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T18:49:36", "lines": 51, "newlines": 39, "modlines": 0, "user": "E1226"}, "text": "XMC0001I Options specified:\n+  P1         : SYSW.M38K.CBT999.INST(XMCLOAD) ODS(SYSW.M38K.CBT999.INST(S(S\n+  NOMSG      : 0\n+  NOINFO     : 0 Superseeds all other Info Settings.\n+  - NOINMR   : 0 INMR Tokens resolved.\n+  - NOIEBC   : 0 COPYR1 & COPYR2 Infos.\n+  - NODIR    : 0 Member with Attributes / Stats.\n+  - NOBASE   : 0 Resolve Basemen for ISPF Aliasses.\n+  ODS / ODIR : SYSW.M38K.CBT999.INST(SAMPINFO)\n+  MEMBER     :\n+  REPLACE    : 0\n+  EATTR      : 0\n+  CCHHR      : 0\n-INMR01   (0x0042) INMLRECL: 80 (0x50)\n-INMR01   (0x1011) INMFNODE: ORIGNODE (0xD6D9C9C7D5D6C4C5)\n-INMR01   (0x1012) INMFUID : ORIGUID (0xD6D9C9C7E4C9C4)\n-INMR01   (0x1001) INMTNODE: DESTNODE (0xC4C5E2E3D5D6C4C5)\n-INMR01   (0x1002) INMTUID : DESTUID (0xC4C5E2E3E4C9C4)\n-INMR01   (0x1024) INMFTIME: 20170102172219 (0xF2F0F1F7F0F1F0F2F1F7F2F2F1F9)\n-INMR01   (0x102f) INMNUMF : 1 (0x01)\n-INMR02-1 (0x1028) INMUTILN: IEBCOPY (0xC9C5C2C3D6D7E8)\n-INMR02-1 (0x102c) INMSIZE : 2939300 (0x002CD9A4)\n-INMR02-1 (0x003c) INMDSORG: PO (0x0200)\n-INMR02-1 (0x8012) INMTYPE : NONE (0x00)\n-INMR02-1 (0x0042) INMLRECL: 256 (0x00000100)\n-INMR02-1 (0x0030) INMBLKSZ: 18432 (0x00004800)\n-INMR02-1 (0x0049) INMRECFM: U(0xC000)\n-INMR02-1 (0x000c) INMDIR  : 10 (0x00000A)\n-INMR02-1 (0x0002) INMDSNAM: SYSW.M38K.CBT999.LOAD\n-INMR02-1 (0x1028) INMUTILN: INMCOPY (0xC9D5D4C3D6D7E8)\n-INMR02-1 (0x102c) INMSIZE : 2939300 (0x002CD9A4)\n-INMR02-1 (0x003c) INMDSORG: PS (0x4000)\n-INMR02-1 (0x0042) INMLRECL: 18448 (0x00004810)\n-INMR02-1 (0x0030) INMBLKSZ: 18452 (0x00004814)\n-INMR02-1 (0x0049) INMRECFM: VS(0x4802)\n-INMR03   (0x102c) INMSIZE : 2939300 (0x002CD9A4)\n-INMR03   (0x003c) INMDSORG: PS (0x4000)\n-INMR03   (0x0042) INMLRECL: 256 (0x0100)\n-INMR03   (0x0049) INMRECFM: (0x0001)\nXMC0014I Signature is 00 ca6d0f\nXMC0015I Unload Dataset is a PDS\n-IEBCOPY  COPYR1 DSORG:    PO\n-IEBCOPY  COPYR1 BLKSIZE:  18432\n-IEBCOPY  COPYR1 LRECL:    00256\n-IEBCOPY  COPYR1 RECFM:    U\n-IEBCOPY  COPYR1 DEVTAB:   Type 3390 Trk/Cyl 15\n-IEBCOPY  COPYR2  Extent 00 CCx.HHx: 0433.000D 0437.0002 TTs: 0000 TTp: 0031 Len\n XMCLIST  - 00000c 0276E8 ........ AC0 FO EP0      .. .. .. .. .. .. AM24 RM24\n XMCUTIL  - 000407 0218B0 ........ AC0 FO EP0      .. .. .. .. .. .. AM24 RM24\nXMC0017I No Member specified for EXTRACT.\nReturncode (0).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMCLIST": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x17\\x00/\\x01\\x17\\x00/\\x17S\\x073\\x07C\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T17:53:19", "lines": 1843, "newlines": 1859, "modlines": 0, "user": "E1226"}, "text": "/*+---------------------------------------------------------------------<bod>+*/\n/*!sys: SINM      llq: SOURCE                                                !*/\n/*!ver: 0.1.26    (c): E1226                                                 !*/\n/*!--------------------------------------------------------------------------!*/\n/*!desc: XMC XMIT Information Tool                                           !*/\n/*!desc: record c segments and optional raw extract of a po mem              !*/\n/*!--------------------------------------------------------------------------!*/\n/*!E1226   16/12/26     0.1.26 EATTR and stdout                              !*/\n/*!E1226   16/12/25     0.1.25 restructured blocks                           !*/\n/*!E1226   16/10/13     0.1.24 allow raw blocks if --cchhr                   !*/\n/*!E1226   16/10/09     0.1.23 correct RECFM=U                               !*/\n/*!E1226   16/09/30     0.1.22 message formatting                            !*/\n/*!E1226   16/09/25     0.1.21 integrated common parm parsing                !*/\n/*!E1226   16/09/17     0.1.20 os independent --replace                      !*/\n/*!E1226   16/09/17     0.1.16 po / poe single mem extract full test ok      !*/\n/*!E1226   16/09/17     0.1.15 do_directory review poe                       !*/\n/*!E1226   16/09/17     0.1.14 do_directory review                           !*/\n/*!E1226   16/09/17     0.1.14 do_copyr2 rework                              !*/\n/*!E1226   16/09/16     0.1.13 do_copyr1 rework                              !*/\n/*!E1226   16/08/15     0.0.59 fwrite to stdout                              !*/\n/*!E1226   16/08/15     0.0.58 Extract HEX with all devt ok                  !*/\n/*!E1226   16/08/13     0.0.50 conversion TTR CCHHR                          !*/\n/*!E1226   16/08/11     0.0.43 EXTENT Infos COPYR2                           !*/\n/*!E1226   16/08/07     0.0.38 DEVTYPE DASD                                  !*/\n/*!E1226   16/08/06     0.0.36 dd: //dd: open                                !*/\n/*!E1226   16/08/05     0.0.34 ispf alias processing                         !*/\n/*!E1226   16/08/02     load format                                          !*/\n/*!E1226   16/07/31     ssi format                                           !*/\n/*!E1226   16/07/31     basic alias preocessing (non-u) regress MVS          !*/\n/*!E1226   16/07/31     ispf dir ordered date                                !*/\n/*!E1226   16/07/30     ispf dir julian date w/o alias                       !*/\n/*!E1226   16/07/19     zzsprintf                                            !*/\n/*!E1226   16/07/17     working version with multi member tested also regress!*/\n/*!E1226   16/07/13     real block w/o segment len & desc                    !*/\n/*+---------------------------------------------------------------------<eod>+*/\n// #define X86\n// #define LINUX\n   #define MVS\n   #define MVS43\n\nchar *procname;\n#define __ZZPROC \"xmclist\"\n#define __ZZVER \"0.1.26\"\n\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#if defined X86\n#include \"@dcuser.h\"   /* mine */\n#endif\n#if defined MVS\n#include \"@dcuser\"     /* mine */\n#endif\n\n#define __BUILD __ZZPROC\" (c) eho 2011/2016 Version \"__ZZVER\"  Build \" \\\n        __DATE__\" \"__TIME__\n//                                     /* build a POSIX comaptible parm env  */\n//                                     /* parm keys are always upper case    */\n//                                     /* parm values remain sensitive       */\n#define PARMKEYU\n#if defined X86\n#define GPP    \"--\"\n#define GDM    \"??\" //\n#define GEQ    \"=\"  // keyvalue =\n#define GWBL 4096\n#define G1   512\n#endif\n\n#if defined MVS\n#define GPP    \"\"\n#define GDM    \"()\" //\n#define GEQ    \"\"   // keyvalue = not applicable\n#define GWBL 4096\n#define G1   60\n#endif\n                                // IEBCOPY COPYR1\n//pedef struct COPYR1 GGCOPYR1;\n\nchar ggdsnx \u00ddG1+1\u00a8= \"\";          // XMI File\nchar ggodsn \u00ddG1+1\u00a8= \"\";          // Output DSN for Extract\nchar ggmem  \u00dd9\u00a8   = \"\";          // Extract Member\nint  ggrep        = 0;           // replace output flag\nint  ggverb       = 0;           // verbose output\n//\nint  ggnoin       = 0;           // no infos\nint  ggnoim       = 0;           // no inmr\nint  ggnoie       = 0;           // no copyr1, copyr2\nint  ggnodi       = 0;           // no dir\nint  ggnoba       = 0;           // no basemen for alias\nint  ggnocc       = 0;           // no cchh info\nint  ggnomsg      = 0;           // no msg\nint  ggcchhr      = 0;           // default no cchhr\nint  ggeattr      = 0;           // default no eattr\n\nint  ggoffp       = 0;           // offset in file previous\nint  ggoffc       = 0;           // offset in file current\nint  ggdbx        = 0;           // counter data record\nchar ggrecfm\u00dd8\u00a8   = \"\";          // Record Format String\n#if defined X86\n#define ZZXE2A(a,b) zze2a(a,b)\n#else\n#define ZZXE2A(a,b)\n#endif\n//                                     /* extent  struct                     */\n  static unsigned char ggmbbcchhrs\u00dd9\u00a8 =\n           {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n  static unsigned char ggmbbcchhrp\u00dd9\u00a8 =\n           {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n//                                     /* extent  struct                     */\nFILE *ggfo;\n//                                     /* extent  struct                     */\nstruct         {\n  unsigned int  ccs;\n  unsigned int  hhs;\n  unsigned int  ccp;\n  unsigned int  hhp;\n  unsigned int  tts;                   /* tt start                           */\n  unsigned int  ttp;                   /* tt hi                              */\n} gext\u00dd16\u00a8;\nunsigned int gextx = 0;\n\n//                                     /* devtype struct                     */\n#define GGDEVX 8\nstruct devtype {\n  unsigned int  no;\n  unsigned int  trk;\n  char name\u00dd5\u00a8;\n} ggdevt\u00ddGGDEVX\u00a8 = {0x00,00,\"CCDA\",   // current calced device attributes\n                    0x08,19,\"3330\",\n                    0x09,19,\"3330\",\n                    0x0a,12,\"3340\",\n                    0x0b,30,\"3350\",\n                    0x0c,12,\"3375\",\n                    0x0e,15,\"3380\",\n                    0x0f,15,\"3390\"};\n\nunsigned int ggdevtx;                  /* current device                     */\n//                                     /* ttr - mem struct                   */\nstruct ggttr{\n  int ttr;\n  int cchhr;\n  char mem\u00dd9\u00a8;\n  int cc;\n  int hh;\n  int rec;\n  int ext;\n} ggttr;\n//                                     /* ttr - member                       */\nstruct ggttr *ggpm;\nchar *ggrm;\nint ggpml,ggpmc=0,ggpmx=0;\n#define ggpmI 100\n//                                     /* ttr - alias                        */\nstruct ggttr *ggpa;\nchar *ggra;\nint ggpal,ggpac=0,ggpax=0;\n#define ggpaI 30\n//                                     /* ttr - mem struct                   */\n/*****************************************************************************/\n/* F U N C T I O N S  COMMON                                                 */\n/*****************************************************************************/\n/**0200***********************************************************************/\n/* do_msg()                                                                  */\n/* - common message formatting and suppression                               */\n/*****************************************************************************/\nint do_msg(int rc,char *msg, ...) {\n\n  char tbuf\u00dd256\u00a8 = \"\";\n\n  va_list args;\n  if (ggnomsg) return (rc);\n  va_start (args, msg);\n\n  vsnprintf(tbuf+0,256-0,msg,args);\n  sysprint(\"*NO\",tbuf);\n\n  va_end (args);\n  return (rc);\n}\n/**0110***********************************************************************/\n/* ttrcomp()                                                                 */\n/*   sort condition                                                          */\n/*****************************************************************************/\nint ttrcomp(const void * a, const void * b)\n{\n  return ( *(int*)a - *(int*)b );\n}\n/**0120***********************************************************************/\n/* xxstrip()                                                                 */\n/*   strip quotes                                                            */\n/*****************************************************************************/\n int  xxstrip(char *buf, char *quote) {\n\n  int i,j,l;\n\n  j = 0;\n  l = strlen(buf);\n  for (i=0;i<l;i++) {\n    if (buf\u00ddi\u00a8 != quote\u00dd0\u00a8) {buf\u00ddj\u00a8 = buf\u00ddi\u00a8; j++;}\n    else buf\u00ddj\u00a8 = 0x00;\n  }\n  return strlen(buf);\n}\n/**0130***********************************************************************/\n/* xxopen()                                                                  */\n/*   open a file                                                             */\n/*****************************************************************************/\nFILE * xxopen(char *fname,char *fopts) {\n\n  FILE *fh;\n  unsigned char opts\u00dd30\u00a8;\n\n  #if defined X86\n  fh = 0; fh = zzopen(fname,fopts);\n  #else\n  zzstrupr(fname);\n  fh = 0;\n\n//printf(\"** fname: (%s) (%s) **\\n\",fname,fopts);\n\n  if      (!memcmp(fname,\"DD:\",3)) {\n    sprintf(opts,\"%s,DD\",fopts);\n    fh = zzopen(fname+3,opts);\n//  printf(\"xxopen: (%d) (%s) (%s) **\\n\",fh,fname,opts);\n  }\n  else if (!memcmp(fname,\"//DDN:\",6)) {\n    sprintf(opts,\"%s,DD\",fopts);\n    fh = zzopen(fname+6,opts);\n//  printf(\"xxopen: (%d) (%s) (%s) **\\n\",fh,fname,opts);\n  }\n  else fh = zzopen(fname,fopts);\n  #endif\n\n  return fh;\n}\n/**0208***********************************************************************/\n/* do_eattr()                                                                */\n/* - dump extented attributes                                                */\n/*****************************************************************************/\nint do_eattr(unsigned char *sbuf,int ln) {\n\n  int i,j,k,m,rc=0,prc=0;char *prn=\"do_eattr\";     /* commons               */\n\n  #define MB 16\n\n  char lbuf\u00ddMB*3+MB+20\u00a8;\n  char abuf\u00ddMB+1\u00a8;\n  unsigned char c;\n  char *pp;\n  /***************************************************************************/\n  sysprint(\"*NO\",\"XMU0002I Dump of unloaded Attributes for %s:\",ggmem);\n\n  j = 0;\n  sprintf(lbuf,\"+ %06X: \",0);\n  memset(abuf,0x0,MB);\n\n  for (i=0;i<ln;i++) {\n    c = sbuf\u00ddi\u00a8;\n    zzsprintf(lbuf,\"%02.2X\",c);\n    abuf\u00ddj\u00a8 = sbuf\u00ddi\u00a8;\n    j++;\n    if (j%4 == 0) zzsprintf(lbuf,\" \");\n\n    if (j>=MB) {\n      zze2a(abuf,MB);\n      for (k=0;k<MB;k++) if (abuf\u00ddk\u00a8 < 32 || abuf\u00ddk\u00a8 > 128) abuf\u00ddk\u00a8 = '.';\n      abuf\u00ddMB\u00a8 = 0x0;\n      zzsprintf(lbuf,\"!%s!\" ,abuf);\n      sysprint(\"*NO\",lbuf);\n      j = 0;\n      sprintf(lbuf,\"+ %06X: \",i+1);\n      memset(abuf,0x0,MB);\n    }\n  }\n\n  if (j>0) {\n    for (k=j;k<MB;k++) {\n      zzsprintf(lbuf,\"%02.2X\",0xFF);\n      j++;\n      if (j%4 == 0) zzsprintf(lbuf,\" \");\n    }\n    zze2a(abuf,MB);\n    for (k=0;k<MB;k++) if (abuf\u00ddk\u00a8 < 32 || abuf\u00ddk\u00a8 > 128) abuf\u00ddk\u00a8 = '.';\n    abuf\u00ddMB\u00a8 = 0x0;\n    zzsprintf(lbuf,\"!%s!\" ,abuf);\n    sysprint(\"*NO\",lbuf);\n  }\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0208***********************************************************************/\n/* do_copen()                                                                */\n/* - conditional open                                                        */\n/*****************************************************************************/\nFILE * do_copen(char *fname) {\n\n  static FILE *fo;\n\n  int i,j,k,m,rc=0,prc=0;char *prn=\"do_copen\";      /* commons               */\n\n  if (!fname\u00dd0\u00a8) goto EE;               /* no filename procided              */\n  /***************************************************************************/\n  if (!ggrep) {\n    fo = xxopen(fname,\"rb\");\n    if (fo) {\n      prc=do_msg(8,\"XMU0302E Replace not specified for %s.\",fname);\n      fclose(fo);\n      fo = NULL;\n      goto EE;\n    } // >> else no open file\n  }\n\n  // ***************                /* here we can open safe write   */\n  fo = xxopen(fname,\"wb\");\n  if (!fo) {\n    prc=do_msg(8,\"XMU0303E Open Failed Output %s.\",fname);\n    fo = NULL;\n    goto EE;\n  }\n  /***************************************************************************/\n  EE:\n  return (fo);\n}\n/**0210***********************************************************************/\n/* do_mbbcchhr()                                                             */\n/*****************************************************************************/\nint  do_mbbcchhr(char *mem,unsigned char *s, unsigned char *p) {\n\n  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */\n//int ccw,ttw,rrw;\n  char wb\u00dd100\u00a8 = \"\";\n//char wc\u00dd100\u00a8 = \"\";\n  unsigned char rmem\u00dd9\u00a8;\n  /***************************************************************************/\n  sprintf(rmem,\"%-8.8s\",mem);\n\n  s\u00dd0\u00a8 = 0; s\u00dd1\u00a8 = 0xFF;\n  s\u00dd2\u00a8 = 0; s\u00dd3\u00a8 = 0;\n  s\u00dd4\u00a8 = 0; s\u00dd5\u00a8 = 0;\n  s\u00dd6\u00a8 = 0; s\u00dd7\u00a8 = 0;\n  s\u00dd8\u00a8 = 0;\n\n  memcpy(p,s,9);\n\n  for (i=0;i<ggpmx;i++) {\n    if (!memcmp(ggpm\u00ddi\u00a8.mem,rmem,8)) {\n      s\u00dd0\u00a8 = 0; s\u00dd1\u00a8 = ggpm\u00ddi\u00a8.ext;\n      s\u00dd2\u00a8 = 0; s\u00dd3\u00a8 = 0;\n      s\u00dd4\u00a8 = ggpm\u00ddi\u00a8.cc/256; s\u00dd5\u00a8 = ggpm\u00ddi\u00a8.cc%256;\n      s\u00dd6\u00a8 = ggpm\u00ddi\u00a8.hh/256; s\u00dd7\u00a8 = ggpm\u00ddi\u00a8.hh%256;\n      s\u00dd8\u00a8 = ggpm\u00ddi\u00a8.rec;\n\n      break;\n    }\n  }\n//sprintf(wb,\" S \");\n//for(j=0;j<9;j++) zzsprintf(wb,\" %02x\",s\u00ddj\u00a8);\n//sysprint(\"<%s> %d %d\",wb,i,ggpmx);\n\n  //                                       /* member not found S:0xFF P:0xFF */\n  if (s\u00dd1\u00a8 == 0xFF) return s\u00dd1\u00a8;\n  //                                       /* last mem. no i++ S:0xnn P:0xFF */\n  if (i == ggpmx-1)  return 0;\n  //                                       /* start of nxt mem S:0xnn P:0xoo */\n  i++;\n  p\u00dd0\u00a8 = 0; p\u00dd1\u00a8 = ggpm\u00ddi\u00a8.ext;\n  p\u00dd2\u00a8 = 0; p\u00dd3\u00a8 = 0;\n  p\u00dd4\u00a8 = ggpm\u00ddi\u00a8.cc/256; p\u00dd5\u00a8 = ggpm\u00ddi\u00a8.cc%256;\n  p\u00dd6\u00a8 = ggpm\u00ddi\u00a8.hh/256; p\u00dd7\u00a8 = ggpm\u00ddi\u00a8.hh%256;\n  p\u00dd8\u00a8 = ggpm\u00ddi\u00a8.rec;\n\n//sprintf(wb,\" P \");\n//for(j=0;j<9;j++) zzsprintf(wb,\" %02x\",p\u00ddj\u00a8);\n//sysprint(\"<%s> %d %d\",wb,i,ggpmx);\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0220***********************************************************************/\n/* do_cchh()                                                                 */\n/*****************************************************************************/\nint  do_cchh(int ttr, int *cc,int *hh, int *rec) {\n\n  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */\n  int ccw,ttw,rrw;\n  /***************************************************************************/\n  *rec = ttr % 256;\n  *hh  = ttr / 256;\n\n  prc = 99;\n\n  for(i=0;i<16;i++) {\n    if (*hh > gext\u00ddi\u00a8.ttp)  continue;\n\n    rrw = ggdevt\u00ddggdevtx\u00a8.trk;\n    ttw = *hh - gext\u00ddi\u00a8.tts;\n\n    ttw =  gext\u00ddi\u00a8.ccs * rrw + gext\u00ddi\u00a8.hhs + ttw;\n\n    *cc  =  ttw / rrw;\n    *hh  =  ttw % rrw;\n    prc = i;\n    break;\n  }\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0230***********************************************************************/\n/* do_basemem()                                                              */\n/*---------------------------------------------------------------------------*/\n/* F:  sysprint                                                              */\n/* F:  zzc2d                                                                 */\n/* F:  zzsprintf                                                             */\n/* M:  ZZXE2A                                                                */\n/* G:  ggpaI                                                                 */\n/* G:  ggra                                                                  */\n/* G:  ggpa                                                                  */\n/* G:  ggpax                                                                 */\n/* G:  ggpm                                                                  */\n/* G:  ggpmx                                                                 */\n/*****************************************************************************/\nint  do_basemem() {\n\n  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */\n  /***************************************************************************/\n  m = 0;\n  for (i=0;i<ggpax;i++) {\n    k = 0;\n    for (j=m;j<ggpmx;j++) {\n      if (ggpa\u00ddi\u00a8.ttr == ggpm\u00ddj\u00a8.ttr) {\n        sysprint(\"*NO\",\"-ALIAS   %s basemem %s\",ggpa\u00ddi\u00a8.mem,ggpm\u00ddj\u00a8.mem);\n        k = 1; m = j;\n        break;\n      }\n    }\n    if (!k) sysprint(\"*NO\",\"-ALIAS   %s basemem %s\",ggpa\u00ddi\u00a8.mem,\"**NONE**\");\n  }\n  prc = 234;\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0240***********************************************************************/\n/* do_loadstat()                                                             */\n/* - SYS1.MODGEN(IHAPDS)                                                     */\n/* - MVS Program Management: Advanced Facilities                             */\n/* - format load                                                             */\n/*      -reset -1 for PDS2INDC (len & count TTR)                             */\n/*---------------------------------------------------------------------------*/\n/* M:  ZZXE2A                                                                */\n/* F:  zzc2d                                                                 */\n/* F:  zzsprintf                                                             */\n/*****************************************************************************/\nint  do_loadstat(unsigned char *sbuf, unsigned char *lbuf) {\n\n  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */\n\n  unsigned char wbuf\u00dd20\u00a8;\n  int len;\n  unsigned char *p1;\n  unsigned char *p2;\n  unsigned char xl = 0x0;\n\n  unsigned int  size = 0;\n  unsigned char alias\u00dd9\u00a8 = \"........\";\n  unsigned char ac\u00dd4\u00a8 = \"...\";\n  unsigned char dcfo\u00dd3\u00a8 = \"..\";\n  unsigned char ep0\u00dd4\u00a8 = \"...\";\n                 //\n  unsigned char ol\u00dd3\u00a8 = \"..\";\n  unsigned char sc\u00dd3\u00a8 = \"..\";\n  unsigned char pg\u00dd3\u00a8 = \"..\";\n  unsigned char rf\u00dd3\u00a8 = \"..\";\n  unsigned char rn\u00dd3\u00a8 = \"..\";\n  unsigned char ru\u00dd3\u00a8 = \"..\";\n                //\n  unsigned char am\u00dd5\u00a8 = \"..\";\n  unsigned char rm\u00dd5\u00a8 = \"..\";\n                //\n  unsigned int  ssi = 0;\n\n  /***************************************************************************/\n  p1 = sbuf-12;\n  len = sbuf\u00dd-1\u00a8;\n  len = (len & 0x1F)*2;\n\n//  for (i=-1;i<len;i++) { zzsprintf(lbuf,\" %02x\",sbuf\u00ddi\u00a8); }\n\n                                    /* EXTENSION: Type   Stor Loc  Test LDec */\n                                    /*            SCTR   0x80 0x14 0x04   20 */\n                                    /*            ALIAS  0x40 0x0B 0x80   11 */\n                                    /*            SSI    0x20 0x1E 0x10   30 */\n                                    /*            APF    0x10 0x1E 0x08   30 */\n                                    /*            LPO    0x08 0x1E 0x40   30 */\n                                            /* SCTR                          */\n  m = zzc2d(p1+20,1); if (m & 0x04) xl = xl | 0x80;\n  m = zzc2d(p1+11,1); if (m & 0x80) xl = xl | 0x40;\n  m = zzc2d(p1+30,1); if (m & 0x10) xl = xl | 0x20;\n  m = zzc2d(p1+30,1); if (m & 0x08) xl = xl | 0x10;\n  m = zzc2d(p1+30,1); if (m & 0x40) xl = xl | 0x08;\n\n//  zzsprintf(lbuf,\" (%02X)\",xl);\n//  zzsprintf(lbuf,\"\\nL:%d\",len);\n  //                                        /* ** PDS offset 0x16 ** 22      */\n                                            /* SIZE in HEX                   */\n  size = zzc2d(p1+22,3);\n  //                                        /* ** PDS offset 0x14 ** 20      */\n  m = zzc2d(p1+20,1);\n  if (m & 0x80) strcpy(rn,\"RN\");            /* ATTR 1  Bit 0  Reentrant      */\n  if (m & 0x40) strcpy(ru,\"RU\");            /* ATTR 1  Bit 1  Reusable       */\n  if (m & 0x08) strcpy(ol,\"OL\");            /* ATTR 1  Bit 4  LoadOnly       */\n  if (m & 0x04) strcpy(ol,\"SC\");            /* ATTR 1  Bit 5  Scatter        */\n  //                                        /* ** PDS offset 0x15 ** 21      */\n  m = zzc2d(p1+21,1);\n  if (m & 0x80) strcpy(dcfo,\"FO\");          /* ATTR 2  Bit 1  DC/FO          */\n  else          strcpy(dcfo,\"DC\");          /* ATTR 2  Bit 1  DC/FO          */\n\n  if (m & 0x20) strcpy(ep0,\"EP0\");          /* ATTR 2  Bit 2  EP0 zero       */\n  else {\n    n = zzc2d(p1+27,3);\n    sprintf(ep0,\"EP%06X\",n);\n  }\n  if (m & 0x01) strcpy(rf,\"RF\");            /* ATTR 2  Bit 7  Refresh        */\n  //                                        /* ** PDS offset 0x1E ** 30      */\n  m = zzc2d(p1+30,1);\n  if (m & 0x20) strcpy(pg,\"PG\");            /* 2FTBO 1 Bit 2  Page Boundary  */\n\n  //                                        /* ** PDS offset 0x1F ** 31      */\n  m = zzc2d(p1+31,1);\n  if (m & 0x10) strcpy(rm,\"RANY\");          /* 2FTBO 2 Bit 3  RMODE          */\n  else          strcpy(rm,\"RM24\");          /* 2FTBO 2 Bit 3  AMODE          */\n\n  if ((m & 0x03)== 0x00) strcpy(am,\"AM24\"); /* 2FTBO 2 Bit 67 AMODE          */\n  if ((m & 0x03)== 0x02) strcpy(am,\"AM31\"); /* 2FTBO 2 Bit 67 AMODE          */\n  if ((m & 0x03)== 0x01) strcpy(am,\"AM64\"); /* 2FTBO 2 Bit 67 AMODE          */\n  if ((m & 0x03)== 0x03) strcpy(am,\"AANY\"); /* 2FTBO 2 Bit 67 AMODE          */\n  /***************************************************************************/\n  //                                        /* ** PDS offset 0x21 ** 33      */\n  p2 = p1+33;                               // Start of sections\n  //\n  //                                        /* SKIP SCATTER                  */\n  if (xl & 0x80) k = zzc2d(p2,2);           /* len of SCATTER section        */\n  else         k = 0;\n  p2 = p2 +k;\n  //                                        /* IF ALIAS                      */\n  //                                        /* len of ALIAS section is 11    */\n  if (xl & 0x40) {\n    memcpy(alias,p2+3,8); ZZXE2A(alias,8);\n    p2 = p2 +11;\n  }\n  //                                        /* IF SSI                        */\n  //                                        /* len of SSI is 4 or 5 HW Bound */\n    wbuf\u00dd0\u00a8 = 0x0;\n  if (xl & 0x20) {\n    if ( (p2-p1)%2) p2++;\n    sprintf(wbuf,\"SSI:\");\n    for (i=0;i<4;i++) zzsprintf(wbuf,\"%02x\",(p2+i)\u00dd0\u00a8);\n    p2 = p2 +4;\n  }\n  //                                        /* IF APF                        */\n  //                                        /* b0:len b1:code. We consier onl*/\n  //                                        /* one byte                      */\n  if (xl & 0x10) {\n    m = zzc2d((p2+1),1);\n    sprintf(ac,\"AC%1.1d\",m);\n  }\n\n  n = p2-p1;\n\n  zzsprintf(lbuf,\" %06X %-8.8s %-3.3s %2.2s %-8.8s\"\n                  \" %2s %2s %2s %2s %2s %2s\"\n                  \" %4s %4s %s\"\n                  \"\",\n                    size,alias,ac,dcfo,ep0,\n                    ol,sc,pg,rf,rn,ru,\n                    am,rm,wbuf);\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0250***********************************************************************/\n/* do_ssistat()                                                              */\n/* - format not load ssi                                                     */\n/*---------------------------------------------------------------------------*/\n/* F:  zzbcd2i                                                               */\n/* F:  zzsprintf                                                             */\n/*****************************************************************************/\nint  do_ssistat(unsigned char *sbuf, unsigned char *lbuf) {\n\n  int i,j,k,m,rc=0,prc=0;                           /* commons               */\n\n  unsigned char wbuf\u00dd10\u00a8;\n  /***************************************************************************/\n  k = zzbcd2i(sbuf+0,8);\n  zzsprintf(lbuf,\" SSI:%08d\",k);\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0260***********************************************************************/\n/* do_ispfstat()                                                             */\n/* - format ispf statistics available                                        */\n/*---------------------------------------------------------------------------*/\n/* M:  ZZXE2A                                                                */\n/* F:  zzc2d                                                                 */\n/* F:  zzbcd2i                                                               */\n/* F:  zzispfdate                                                            */\n/* F:  zzsprintf                                                             */\n/*****************************************************************************/\nint  do_ispfstat(unsigned char *sbuf, unsigned char *lbuf) {\n\n  int i,j,k,m,rc=0,prc=0;                           /* commons               */\n\n  unsigned char wbuf\u00dd10\u00a8;\n  /***************************************************************************/\n  j = zzc2d(sbuf+0,1);\n  zzsprintf(lbuf,\" %02.2d\",j);\n  j = zzc2d(sbuf+1,1);\n  zzsprintf(lbuf,\".%02.2d\",j);\n  //***************                        /* Change DATE                    */\n  k = zzbcd2i(sbuf+4,2);\n  if (k == 0) k = zzbcd2i(sbuf+5,2) + 1900;\n  else        k = zzbcd2i(sbuf+5,2) + 2000;\n  j = zzbcd2i(sbuf+6,3);\n\n  m = zzispfdate(k,j);\n  j = m % 100;\n  m = m / 100;\n  zzsprintf(lbuf,\" %04d.%02d.%02d\",k,m,j);\n  //***************                        /* CREATE DATE                    */\n  k = zzbcd2i(sbuf+8,2);\n  if (k == 0) k = zzbcd2i(sbuf+9,2) + 1900;\n  else        k = zzbcd2i(sbuf+9,2) + 2000;\n  j = zzbcd2i(sbuf+10,3);\n\n  m = zzispfdate(k,j);\n  j = m % 100;\n  m = m / 100;\n  zzsprintf(lbuf,\" %04d.%02d.%02d\",k,m,j);\n  //***************                        /* Change Time                    */\n  j = (sbuf+12)\u00dd0\u00a8;\n  zzsprintf(lbuf,\" %2x\",j);\n  j = (sbuf+13)\u00dd0\u00a8;\n  zzsprintf(lbuf,\":%02x\",j);\n                                           /* SIZE lines                     */\n  j = zzc2d(sbuf+14,2);\n  zzsprintf(lbuf,\" %5d\",j);\n                                           /* INIT lines                     */\n  j = zzc2d(sbuf+16,2);\n  zzsprintf(lbuf,\" %5d\",j);\n                                           /* MOD  lines                     */\n  j = zzc2d(sbuf+18,2);\n  zzsprintf(lbuf,\" %5d\",j);\n                                           /* ID                             */\n  memcpy(wbuf,sbuf+20,8); ZZXE2A(wbuf,8);\n  zzsprintf(lbuf,\" %8.8s\",wbuf);\n\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0270***********************************************************************/\n/* do_directory()                                                            */\n/*  00  08          00 00 00 00 00 00 00 00            dirblock start        */\n/*  08  02          00 08                                                    */\n/*  10  02          01 00                              dirblock len          */\n/*  12  08          C3 C9 F4 F2 C1 40 40 40                                  */\n/*  20  02          00 E0                              sum bytes dire recs   */\n/*  22  ...         ...                                first entry           */\n/*  ------------------------------------------------------------------------ */\n/*                  20 + 224                           first entry           */\n/*---------------------------------------------------------------------------*/\n/* RC: 200     getmain error                                                 */\n/* RC: 1       EODir                                                         */\n/* F:  do_loadstat                                                           */\n/* F:  do_ssistat                                                            */\n/* M:  do_ispfstat                                                           */\n/* F:  sysprint                                                              */\n/* F:  zzc2d                                                                 */\n/* F:  zzsprintf                                                             */\n/* M:  ZZXE2A                                                                */\n/* G:  ggpaI                                                                 */\n/* G:  ggra                                                                  */\n/* G:  ggpa                                                                  */\n/* G:  ggpac                                                                 */\n/* G:  ggpal                                                                 */\n/* G:  ggpax                                                                 */\n/* G:  ggpmI                                                                 */\n/* G:  ggrm                                                                  */\n/* G:  ggpm                                                                  */\n/* G:  ggpmc                                                                 */\n/* G:  ggpml                                                                 */\n/* G:  ggpmx                                                                 */\n/* G:  ggttr                                                                 */\n/* G:  ggrecfm                                                               */\n/*****************************************************************************/\nint  do_directory(unsigned char *sbuf, int blen) {\n\n  int i,j,k,m,rc=0,prc=0; char *prn=\"do_directory\";  /* commons               */\n//int i,ip,j,k,m,ss,rc=0,prc=0;                      /* commons               */\n  int q,r,s;\n\n  unsigned char  *lbuf;\n  unsigned char  *abuf;\n  unsigned char  ep;\n  unsigned char  as\u00dd2\u00a8;\n  unsigned char  *p1, *p2;\n  unsigned char  himem\u00dd\u00a8 = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};\n  unsigned char  alias = 0;\n\n  if (ggnodi == 1) prc=do_msg(0,\"XMC0016I Info DIRECTORY Output suppressed.\");\n  if (ggnodi) {ggnodi++;}\n  /***************************************************************************/\n  lbuf=malloc(1024);\n  if (!lbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n  abuf=malloc(1024);\n  if (!abuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n\n  i = 0;\n  m = 276;\n  while (i < blen) {\n    if ((i+m) > blen) m = blen - i;\n    else              m = 276;\n\n    p1 = sbuf+i+20;\n\n    q = zzc2d(p1,2);\n    sprintf(lbuf,\"%2d :\",q);\n    p1 = p1+2;\n    p2 = p1+q-2;\n\n    while (p1 < p2) {\n      //sprintf(lbuf,\"%d %d:\",p1,p2);\n      lbuf\u00dd0\u00a8 = 0x0;\n      //                                   /*  0  0  8 member name       */\n      memcpy(abuf,p1,8);\n      //                                   /*  ebcdic FFFFFFFFFFFFFFFF   */\n      if (!memcmp(abuf,himem,8)) {\n        prc=1;\n        goto EE;\n      }\n      abuf\u00dd8\u00a8 = 0x0;ZZXE2A(abuf,8);\n      //                                   /*  0 11  1 alias flag        */\n      s = zzc2d((p1+8+3),1);\n      s = (s & 0x80);\n      //                                   /*  8  -  - offset            */\n      p1 = p1+8;\n      //                                   /*  8  8  3 ttr               */\n      //                                   /* 11  -  - offset            */\n      r = zzc2d(p1,3);\n      p1 = p1+3;\n//                                         /* RECFM U basemem in record  */\n//                                         /* ISPF aliasses comp with ttr*/\n//                                         /* we need memttr vector for  */\n//                                         /* extract also for recfm U   */\n//   if (ggrecfm == 'U') {\n//      if (s) {zzsprintf(lbuf,\" %8s A\",abuf); ggpax++;}\n//      else   {zzsprintf(lbuf,\" %8s -\",abuf); ggpmx++;}\n//    }\n//    else  {\n        if (s) {\n          lbuf\u00dd0\u00a8 = 0x0;\n          ggpac = ggpac+sizeof(ggttr);\n          if (ggpac > ggpal) {\n            ggpal = ggpal + sizeof(ggttr)*ggpaI;\n            ggra = realloc(ggra,ggpal);\n          }\n          ggpa = (struct ggttr*)(ggra+ggpac-sizeof(ggttr));\n          ggpa->ttr = r;\n          memcpy(ggpa->mem,abuf,8); ggpa->mem\u00dd8\u00a8 = 0x0;\n          ggpax++;\n\n          zzsprintf(lbuf,\" %8s A\",abuf);\n        }\n        else {\n          ggpmc = ggpmc+sizeof(ggttr);\n          if (ggpmc > ggpml) {\n            ggpml = ggpml + sizeof(ggttr)*ggpmI;\n            ggrm = realloc(ggrm,ggpml);\n          }\n          ggpm = (struct ggttr*)(ggrm+ggpmc-sizeof(ggttr));\n          ggpm->ttr = r;\n          memcpy(ggpm->mem,abuf,8); ggpm->mem\u00dd8\u00a8 = 0x0;\n          ggpmx++;\n\n          zzsprintf(lbuf,\" %8s -\",abuf);\n        }\n//    }\n//                                         /* TTR END       ************ */\n//                                         /* print TTR     ************ */\n      zzsprintf(lbuf,\" %06x\",r);\n//                                         /* 11 11  1 ttr               */\n//                                         /* 12  -  - offset            */\n      s = zzc2d(p1,1);\n      s = (s & 0x1F)*2;\n      p1 = p1+1;\n\n      if (ggrecfm\u00dd0\u00a8 == 'U') {\n        do_loadstat(p1,lbuf);\n      }\n      else if (s == 4)    do_ssistat(p1,lbuf);\n      else if (s == 30)   do_ispfstat(p1,lbuf);\n//                                         /*  s  -  - offset            */\n      p1 = p1+s;\n\n      if (!ggnodi) sysprint(\"*NO\",lbuf);\n    }\n    i = i + 276;\n  }\n  /***************************************************************************/\n  EE:\n  if (abuf) free(abuf);\n  if (lbuf) free(lbuf);\n  return (prc);\n}\n/**0280***********************************************************************/\n/* do_copyr1()                                                               */\n/* - COPYR2 gather extent info                                               */\n/* - Kenneth Tomiak, Danal Estes, Dave Alcock                                */\n/* - DFSMSdfp Utilities                                                      */\n/* - dasdblks.h                                                              */\n/* - DEVTYPE                                                                 */\n/* - kretrecv.rexx                                                           */\n/* > is it a pds ?                                                           */\n/* > recfm                                                                   */\n/* > devicetype                                                              */\n/*---------------------------------------------------------------------------*/\n/* RC: 8       not a PDS/PDSE                                                */\n/* F:  sysprint                                                              */\n/* F:  zzc2d                                                                 */\n/* F:  zzsprintf                                                             */\n/* G:  ggrecfm                                                               */\n/* G:  GGDEVX                                                                */\n/* G:  ggdevt                                                                */\n/* G:  ggdevtx                                                               */\n/* G:  COPYR1 struct                                                         */\n/*****************************************************************************/\nint  do_copyr1(unsigned char *sbuf, int blen) {\n\n  int i,j,k,m,rc=0,prc=0; char *prn=\"do_copyr1\";    /* commons               */\n  unsigned char  *lbuf = 0x0;\n  unsigned char  *cpfx = \"-IEBCOPY  COPYR1 \";\n\n  struct COPYR1 *pp;\n  unsigned int w,u,ss=0;\n  /***************************************************************************/\n  //                                                /* we suppress all COPYR1*/\n  //                                                /* but give a message 1st*/\n  //                                                /* WORK CONTINUES        */\n  if (ggnoie == 1) prc=do_msg(0,\"XMC0016I Info COPYR1 Output suppressed.\");\n  if (ggnoie) {ss=1; ggnoie++;}\n  /***************************************************************************/\n  lbuf=malloc(1024);\n  if (!lbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n\n  pp = (struct COPYR1*)sbuf;\n  //                                           /* header FWORD               */\n  u = pp->uldfmt;\n  w = zzc2d(pp->hdrid,3);\n  strcpy(lbuf,cpfx);\n  //                                           /* Give Info about Input DSN  */\n  prc=do_msg(0,\"XMC0014I Signature is %02x %06x\",pp->uldfmt,\n                                          zzc2d(pp->hdrid,3));\n  if (w != 0xca6d0f) {\n     prc=do_msg(8,\"XMC0230E Not a Unloaded PDS or PDSE Dataset.\"); goto EE;}\n  if (u == 1) do_msg(0,\"XMC0015I Unload Dataset is a PDSE\");\n  if (u == 0) do_msg(0,\"XMC0015I Unload Dataset is a PDS\");\n  //                                           /* opt: DSORG                 */\n  strcpy(lbuf,cpfx); zzsprintf(lbuf,\"DSORG:    \");\n  u = zzc2d(pp->ds1dsorg,2);\n  if (u& 0x8000) zzsprintf(lbuf,\"ISAM\");\n  if (u& 0x4000) zzsprintf(lbuf,\"PS\");\n  if (u& 0x2000) zzsprintf(lbuf,\"DA\");\n  if (u& 0x0200) zzsprintf(lbuf,\"PO\");\n  if (u& 0x0001) zzsprintf(lbuf,\"U\");\n  if (!ss) sysprint(\"*NO\",lbuf);\n  //                                           /* opt: BLKSIZE               */\n  strcpy(lbuf,cpfx); zzsprintf(lbuf,\"BLKSIZE:  \");\n  u = zzc2d(pp->ds1blkl,2); zzsprintf(lbuf,\"%5.5d\",u);\n  if (!ss) sysprint(\"*NO\",lbuf);\n  //                                           /* opt: LRECL                 */\n  strcpy(lbuf,cpfx); zzsprintf(lbuf,\"LRECL:    \");\n  u = zzc2d(pp->ds1lrecl,2); zzsprintf(lbuf,\"%5.5d\",u);\n  if (!ss) sysprint(\"*NO\",lbuf);\n  //                                           /* opt: RECFM                 */\n  strcpy(lbuf,cpfx); zzsprintf(lbuf,\"RECFM:    \");\n  u = pp->ds1recfm;\n\n  k = strlen(lbuf);\n  if ((u& 0xC0) == 0xC0) zzsprintf(lbuf,\"U\");\n  else if (u& 0x80)      zzsprintf(lbuf,\"F\");\n  else if (u& 0x40)      zzsprintf(lbuf,\"V\");\n  else                   zzsprintf(lbuf,\"?\");\n  if (u& 0x10)           zzsprintf(lbuf,\"B\");\n  if (u& 0x20)           zzsprintf(lbuf,\"T\");\n  if (u& 0x08)           zzsprintf(lbuf,\"S\");\n  if (u& 0x04)           zzsprintf(lbuf,\"A\");\n  if (u& 0x02)           zzsprintf(lbuf,\"M\");\n  strncpy(ggrecfm,lbuf+k,6);\n\n  if (!ss) sysprint(\"*NO\",lbuf);\n  //                                           /* DEVTAB                     */\n  u = zzc2d(pp->ucbtype+3,1);\n  ggdevtx = 0;\n  for (i=0;i<GGDEVX;i++) {\n    if (ggdevt\u00ddi\u00a8.no == u) {ggdevtx = i; break; }\n  }\n\n  w = zzc2d(pp->heads,2);\n  if (!ggdevtx) ggdevt\u00ddggdevtx\u00a8.trk = w;\n\n  strcpy(lbuf,cpfx); zzsprintf(lbuf,\"DEVTAB:   \");\n  zzsprintf(lbuf,\"Type %s Trk/Cyl %d\",ggdevt\u00ddggdevtx\u00a8.name,ggdevt\u00ddggdevtx\u00a8.trk);\n  if (!ss) sysprint(\"*NO\",lbuf);\n  /***************************************************************************/\n  EE:\n  if (lbuf) free(lbuf);\n  return (prc);\n}\n/**0290***********************************************************************/\n/* do_copyr2()                                                               */\n/* - COPYR2 gather extent info                                               */\n/* - Kenneth Tomiak, Danal Estes, Dave Alcock                                */\n/* - DFSMSdfp Utilities                                                      */\n/*---------------------------------------------------------------------------*/\n/* RC: 200     getmain error                                                 */\n/* F:  sysprint                                                              */\n/* F:  zzc2d                                                                 */\n/* F:  zzsprintf                                                             */\n/* G:  gext                                                                  */\n/* G:  ggdevt                                                                */\n/* G:  ggdevtx                                                               */\n/*****************************************************************************/\nint  do_copyr2(unsigned char *sbuf, int blen) {\n\n  int i,j,k,m,n,q,rc=0,prc=0; char *prn=\"do_copyr2\";/* commons               */\n  int cs,cp;\n\n  unsigned char  *lbuf;\n  unsigned char  *cpfx = \"-IEBCOPY  COPYR2 \";\n\n  if (ggnoie >  1) prc=do_msg(0,\"XMC0016I Info COPYR2 Output suppressed.\");\n  /***************************************************************************/\n  lbuf=malloc(1024);\n  if (!lbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n\n  cs = 0;\n  for(i=0;i<16;i++) {\n    strcpy(lbuf,cpfx);\n    zzsprintf(lbuf,\" Extent %02d CCx.HHx:\",i);\n    k = 22+(i*16);\n\n    m = zzc2d(sbuf+k+0,2);   gext\u00ddi\u00a8.ccs = m;\n    m = zzc2d(sbuf+k+2,2);   gext\u00ddi\u00a8.hhs = m;\n    m = zzc2d(sbuf+k+4,2);   gext\u00ddi\u00a8.ccp = m;\n    m = zzc2d(sbuf+k+6,2);   gext\u00ddi\u00a8.hhp = m;\n\n    zzsprintf(lbuf,\" %04X\",gext\u00ddi\u00a8.ccs);\n    zzsprintf(lbuf,\".%04X\",gext\u00ddi\u00a8.hhs);\n    zzsprintf(lbuf,\" %04X\",gext\u00ddi\u00a8.ccp);\n    zzsprintf(lbuf,\".%04X\",gext\u00ddi\u00a8.hhp);\n\n    m = gext\u00ddi\u00a8.ccs * ggdevt\u00ddggdevtx\u00a8.trk + gext\u00ddi\u00a8.hhs;\n    n = gext\u00ddi\u00a8.ccp * ggdevt\u00ddggdevtx\u00a8.trk + gext\u00ddi\u00a8.hhp;\n\n    q = n-m;\n    cp = q + cs;\n    //                                    /* test stop instead of start      */\n    //                                    /* PDSE starts always at 0000.0000 */\n    if (gext\u00ddi\u00a8.ccp || gext\u00ddi\u00a8.hhp) {\n      gext\u00ddi\u00a8.tts = cs;\n      gext\u00ddi\u00a8.ttp = cp;\n      cs = cs+q+1;\n\n      zzsprintf(lbuf,\" TTs: %04X TTp: %04X Len: %5d Trks\",\n               gext\u00ddi\u00a8.tts,gext\u00ddi\u00a8.ttp,q+1);\n      if (!ggnoie) sysprint(\"*NO\",lbuf);\n    }\n  }\n  /***************************************************************************/\n  EE:\n  if (lbuf) free(lbuf);\n  return (prc);\n}\n/**0300***********************************************************************/\n/* do_ftxtunit()                                                             */\n/* - format INMR textunits                                                   */\n/*---------------------------------------------------------------------------*/\n/* RC: 200     getmain error                                                 */\n/* F:  sysprint                                                              */\n/* F:  zzc2d                                                                 */\n/* F:  zzsprintf                                                             */\n/* M:  ZZXE2A                                                                */\n/*****************************************************************************/\nint  do_ftxtunit(char *inmr, int fno, unsigned char *tp , int tlen) {\n\n  #define TUL 31\n\n  struct TUNITS {\n    int no;\n    char name\u00dd9\u00a8;\n    unsigned char format;\n  } tunits\u00ddTUL\u00a8 = {\n      { 0x0001, \"INMDDNAM\", 'C'},\n      { 0x0002, \"INMDSNAM\", 'C'},\n      { 0x0003, \"INMMEMBR\", 'C'},\n      { 0x000B, \"INMSECND\", 'X'},\n      { 0x000C, \"INMDIR  \", 'D'},\n      { 0x0022, \"INMEXPDT\", 'D'},\n      { 0x0028, \"INMTERM \", 'X'},\n      { 0x0030, \"INMBLKSZ\", 'D'},\n      { 0x003C, \"INMDSORG\", 'X'},\n      { 0x0042, \"INMLRECL\", 'D'},\n      { 0x0049, \"INMRECFM\", 'X'},\n      { 0x1001, \"INMTNODE\", 'C'},\n      { 0x1002, \"INMTUID \", 'C'},\n      { 0x1011, \"INMFNODE\", 'C'},\n      { 0x1012, \"INMFUID \", 'C'},\n      { 0x1020, \"INMLREF \", 'X'},\n      { 0x1021, \"INMLCHG \", 'X'},\n      { 0x1022, \"INMCREAT\", 'X'},\n      { 0x1023, \"INMFVERS\", 'X'},\n      { 0x1024, \"INMFTIME\", 'C'},\n      { 0x1025, \"INMTTIME\", 'X'},\n      { 0x1026, \"INMFACK \", 'X'},\n      { 0x1027, \"INMERRCD\", 'X'},\n      { 0x1028, \"INMUTILN\", 'C'},\n      { 0x1029, \"INMUSERP\", 'X'},\n      { 0x102A, \"INMRECCT\", 'X'},\n      { 0x102C, \"INMSIZE \", 'D'},\n      { 0x102F, \"INMNUMF \", 'D'},\n      { 0x8012, \"INMTYPE \", 'X'},\n      { 0x8018, \"INMLSIZE\", 'D'},\n      { 0x8028, \"INMEATTR\", 'X'}\n   };\n  /***************************************************************************/\n  int i,j,k,m,rc=0,prc=0; char *prn=\"do_ftxtunit\";  /* commons               */\n\n  unsigned short key;\n  unsigned short len;\n  unsigned short cnt;\n  unsigned char  lhead\u00dd100\u00a8;\n  unsigned int   val;\n  unsigned int   tt;\n  unsigned char  *pbuf;\n  unsigned char  *lbuf;\n           int   ip;\n  /***************************************************************************/\n  pbuf=malloc(1024);\n  if (!pbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n  lbuf=malloc(1024);\n  if (!lbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n  //                               /* prepare a newline                       */\n  pbuf\u00dd0\u00a8 = 0x0;\n  i = 0;\n  while (i < tlen) {\n    key  = zzc2d(tp+i,2); i+=2;\n    cnt  = zzc2d(tp+i,2); i+=2;\n\n    for (k=0;k<TUL;k++) {\n      if (key == tunits\u00ddk\u00a8.no ) {\n        if (fno) zzsprintf(pbuf,\"-%6.6s-%d \",inmr,fno);\n        else     zzsprintf(pbuf,\"-%6.6s   \",inmr);\n\n        sprintf(lhead,\"(0x%4.4x) %8.8s: \",tunits\u00ddk\u00a8.no,tunits\u00ddk\u00a8.name);\n        zzsprintf(pbuf,\"%s\",lhead);\n        break;\n      }\n    }\n\n    for (k=0;k<cnt;k++) {\n      len = zzc2d(tp+i,2); i+=2;\n\n      memcpy(lbuf,tp+i,len); lbuf\u00ddlen\u00a8 = 0x0;\n      //                              /* save pos */\n      ip = i;\n      i+=len;\n\n      for (m=0;m<TUL;m++) {\n        if (tunits\u00ddm\u00a8.no == key) {\n          /****                     format DSNAME ****************************/\n                                    /* - no hex print                        */\n          if (tunits\u00ddm\u00a8.no == 0x0002) {\n            ZZXE2A(lbuf,len);\n\n            if (k < cnt-1)   zzsprintf(pbuf,\"%s.\",lbuf);\n            else {\n              zzsprintf(pbuf,\"%s\",lbuf);\n              sysprint(\"*NOPREFIX\",pbuf);       // NL writeout this line\n              //                    /* prepare a newline                     */\n              pbuf\u00dd0\u00a8 = 0x0;\n            }\n          }\n          /****                     format MEMBERS ***************************/\n          else if (tunits\u00ddm\u00a8.no == 0x0003) {\n            ZZXE2A(lbuf,len);\n           if (k > 0) {\n              zzsprintf(pbuf,\"-%6.6s-%d \",inmr,fno);\n              zzsprintf(pbuf,\"%s\",lhead);\n            }\n\n            zzsprintf(pbuf,\"%-8.8s \",lbuf);\n\n          }\n          /****                     format DSORG *****************************/\n          else if (tunits\u00ddm\u00a8.no == 0x003C) {\n            val = zzc2d(lbuf,len);\n            switch (val) {\n              case 0x0008: zzsprintf(pbuf,\"VS \"); break;\n              case 0x0200: zzsprintf(pbuf,\"PO \"); break;\n              case 0x4000: zzsprintf(pbuf,\"PS \"); break;\n              default:     zzsprintf(pbuf,\"NONE \"); break;\n            }\n          }\n          /****                     format RECFM *****************************/\n          else if (tunits\u00ddm\u00a8.no == 0x0049) {\n            val = zzc2d(lbuf,len);\n\n            if      (val & 0x8000 && val & 0x4000) zzsprintf(pbuf,\"U\");\n            else if (val & 0x8000)                 zzsprintf(pbuf,\"F\");\n            else if (val & 0x4000)                 zzsprintf(pbuf,\"V\");\n\n            if      (val & 0x1000)                 zzsprintf(pbuf,\"B\");\n            if      (val & 0x2000)                 zzsprintf(pbuf,\"T\");\n\n            if      (val & 0x0800)                 zzsprintf(pbuf,\"S\");\n            if      (val & 0x0400)                 zzsprintf(pbuf,\"A\");\n            if      (val & 0x0200)                 zzsprintf(pbuf,\"M\");\n\n            if      (val & 0x0002)                 ;\n            if      (val & 0x0001)                 ;\n\n          }\n          /****                     format TYPE  *****************************/\n          else if (tunits\u00ddm\u00a8.no == 0x8012) {\n            val = zzc2d(lbuf,len);\n            switch (val) {\n              case 0x80: zzsprintf(pbuf,\"DATALIB \"); break;\n              case 0x40: zzsprintf(pbuf,\"PROGLIB \"); break;\n              case 0x04: zzsprintf(pbuf,\"EXTENDED \"); break;\n              case 0x01: zzsprintf(pbuf,\"LARGE \"); break;\n              default:   zzsprintf(pbuf,\"NONE \"); break;\n            }\n          }\n          /****                     format CNT=1 CHAR ************************/\n          else if (tunits\u00ddm\u00a8.format == 'C') {\n            ZZXE2A(lbuf,len);\n            zzsprintf(pbuf,\"%s \",lbuf);\n          }\n          /****                     format CNT=1 DEC *************************/\n          else if (tunits\u00ddm\u00a8.format == 'D') {\n            val = zzc2d(lbuf,len);\n            zzsprintf(pbuf,\"%d \",val);\n          }\n          break;\n        }\n        /****                       format CNT=1 DEC *************************/\n      }\n                                         /* we need do refresh contents      */\n      if (tunits\u00ddm\u00a8.no == 0x0002) ;\n      else {\n        memcpy(lbuf,tp+ip,len); lbuf\u00ddlen\u00a8 = 0x0;\n        zzsprintf(pbuf,\"(0x\");\n        for (m=0;m<len;m++) zzsprintf(pbuf,\"%2.2X\",lbuf\u00ddm\u00a8);\n\n        zzsprintf(pbuf,\")\");\n        sysprint(\"*NOPREFIX\",pbuf);      // NL writeout this line\n        pbuf\u00dd0\u00a8 = 0x0;                   // prepare a newline\n      }\n                                         /* TU end                           */\n    }\n    if (cnt == 0) {\n      zzsprintf(pbuf,\" \");\n      sysprint(\"*NOPREFIX\",pbuf);       // NL writeout this line\n      pbuf\u00dd0\u00a8 = 0x0;                    // prepare a newline\n    }\n  }\n  /***************************************************************************/\n  EE:\n  if (pbuf) free(pbuf);\n  if (lbuf) free(lbuf);\n  return (prc);\n}\n/**0310***********************************************************************/\n/* do_txtunit()                                                              */\n/*   - decode text units. break up tokens                                    */\n/*     uu-uu ll-ll cc-cc                                                     */\n/*---------------------------------------------------------------------------*/\n/* RC: 200     getmain error                                                 */\n/* F:  do_ftxtunit                                                           */\n/* F:  zzc2d                                                                 */\n/* M:  ZZXE2A                                                                */\n/* G:  ggnoim                                                                */\n/*****************************************************************************/\nint  do_txtunit(unsigned char *rbuf,int blen ) {\n\n  int i,j,k,rc=0,prc=0;                             /* commons               */\n\n  unsigned short key,len,cnt;\n  unsigned int   fno = 0;\n  unsigned char  inmr\u00dd6\u00a8;\n  unsigned int   tlen;\n  unsigned char  *p;\n  /***************************************************************************/\n  //                                                /* we suppress all INMR  */\n  //                                                /* but give a message 1st*/\n  if (ggnoim == 1) prc=do_msg(0,\"XMC0016I Info INMR Tokens suppressed.\");\n  if (ggnoim) ggnoim++;\n  if (ggnoim) goto EE;\n\n  memcpy(inmr,rbuf,6); ZZXE2A(inmr,6);\n\n  if (!memcmp(\"INMR02\",inmr,6)) { fno = zzc2d(rbuf+6,4); i = 10; }\n  else                          { i = 6;}\n\n  while (i < blen) {\n    p = rbuf+i;\n    key  = zzc2d(rbuf+i,2); i+=2;\n    cnt  = zzc2d(rbuf+i,2); i+=2;\n    tlen = 4;\n\n    for (k=0;k<cnt;k++) {\n      len = zzc2d(rbuf+i,2); i+=2;\n      tlen =tlen + 2 + len;\n      i+=len;\n    }\n\n    prc = do_ftxtunit(inmr,fno,p,tlen);\n  }\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0320***********************************************************************/\n/* do_segments()                                                             */\n/*   - build segments to one block, drop leading two bytes of the segments.  */\n/*     block.                                                                */\n/*     0x80    segment start                                                 */\n/*     0x40    segment end                                                   */\n/*     0x00    segment middle                                                */\n/*     0x20    control record                                                */\n/*---------------------------------------------------------------------------*/\n/* RC: 12      getmain error                                                 */\n/* RC: 5       lenbyte lt 2. this means a zero or neagtive read              */\n/* RC: 4       lenbyte is zero. mostly an non XMI dataset                    */\n/* RC: 3       buffer overflow. more segments for a block than 32K. see 201  */\n/* RC: 2       maybe xmi. but this are trailer spaces beyond IMR006          */\n/* G:  goffc                                                                 */\n/* G:  goffp                                                                 */\n/*****************************************************************************/\nint  do_segments(FILE *fx, char *rbuf,int *blen,int bmax, int *btype) {\n\n  int i,k,j,rc=0,prc=0;                             /* commons               */\n\n  unsigned char sl = 0;\n  unsigned char st = 0;\n  int lp;\n  /***************************************************************************/\n  lp = 0;\n  ggoffp = ggoffc;\n\n  while (1) {\n    sl      = fgetc(fx);\n    st      = fgetc(fx);\n    //                                              /* read a ZERO length    */\n    if (sl<=0) {prc=do_msg(4,\"XMC0204S Read a ZERO record length\");goto EE;}\n    //                                              /* buffer overflow       */\n    if (lp +(sl-2) > bmax)\n               {prc=do_msg(4,\"XMC0203S Buffer Overflow.\"); goto EE;}\n    ggoffc = ggoffc + 2;\n\n    //                                              /* avoid negtive read    */\n    if ((sl-2)<=0)\n               {prc=do_msg(5,\"XMC0205S Negative Read Encountered.\"); goto EE;}\n    rc = fread(rbuf+lp,1,sl-2,fx);\n    //                                              /* read beyond EOF       */\n    if (rc < sl-2)\n               {prc=do_msg(2,\"XMC0202W Read Beyond EOF.\"); goto EE;}\n    lp = lp +rc;\n    ggoffc = ggoffc +rc;\n    *blen = lp;\n\n    if ((st & 0x20)) *btype = 1;                    /* Controlblock          */\n    else             *btype = 0;                    /* Controlblock          */\n    if ((st & 0x40)) return 0;                      /* EOB 0x40              */\n  }\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0340***********************************************************************/\n/* do_datafirstb()                                                           */\n/*   - work todo after directory is done.                                    */\n/*     -- sort directory                                                     */\n/*     -- write basemem list                                                 */\n/*---------------------------------------------------------------------------*/\n/* F:  do_basemem                                                            */\n/* F:  do_cchh                                                               */\n/* F:  do_mbbcchhr                                                           */\n/* F:  do_msg                                                                */\n/* F:  ttrcomp                                                               */\n/* G:  ggdbx                                                                 */\n/* G:  ggdsnx                                                                */\n/* G:  ggmem                                                                 */\n/* G:  ggnoba                                                                */\n/* G:  ggnoin                                                                */\n/* G:  ggpa                                                                  */\n/* G:  ggpa                                                                  */\n/* G:  ggpax                                                                 */\n/* G:  ggpm                                                                  */\n/* G:  ggpmbbcchhrs                                                          */\n/* G:  ggpmbbcchhrp                                                          */\n/* G:  ggpmx                                                                 */\n/* G:  ggra                                                                  */\n/* G:  ggrm                                                                  */\n/* G:  ggttr                                                                 */\n/*****************************************************************************/\nint  do_datafirstb() {\n\n  int i,j,k,m,ss,rc=0,prc=0;char *prn=\"do_datafirstb\"; /* commons            */\n\n  int cc,hh,rec;                                   /* cchhr                  */\n  /***************************************************************************/\n  //                                        /* SORT ONLY for ALIAS or        */\n  //                                        /*               EXTRACT         */\n  if (ggpax > 0 || ggmem\u00dd0\u00a8 != 0x0) {\n    ggpa = (struct ggttr*)ggra;\n    ggpm = (struct ggttr*)ggrm;\n    qsort (ggpa, ggpax, sizeof(ggttr), ttrcomp);\n    qsort (ggpm, ggpmx, sizeof(ggttr), ttrcomp);\n  }\n  //                                        /* write BASEMEM-List            */\n  //                                        /* if alias exist                */\n  if (ggpax > 0) {\n    ss = ggnoin + ggnoba;\n    if (ss) prc=do_msg(0,\"XMC0016I Info ALIAS Basemem suppressed.\");\n    else do_basemem();\n  }\n  //                                        /* if member EXTRACT             */\n  //                                        /* CCHHR for all Members         */\n  //                                        /* due we need end of contents   */\n  if (ggmem\u00dd0\u00a8 != 0x0) {\n    ggpm = (struct ggttr*)ggrm;\n    for (i=0;i<ggpmx;i++) {\n      rc = do_cchh(ggpm\u00ddi\u00a8.ttr,&cc,&hh,&rec);\n      ggpm\u00ddi\u00a8.cc = cc;\n      ggpm\u00ddi\u00a8.hh = hh;\n      ggpm\u00ddi\u00a8.rec= rec;\n      ggpm\u00ddi\u00a8.ext= rc;\n    }\n    //                                      /* search start  and stop        */\n    //                                      /* if we specified a member but  */\n    //                                      /* the member is NOT FOUND, we   */\n    //                                      /* stop here.                    */\n    if (ggmem\u00dd0\u00a8 != 0x0 ) {\n      rc = do_mbbcchhr(ggmem,ggmbbcchhrs,ggmbbcchhrp);\n      if (rc > 0) {\n        prc=do_msg(8,\"XMC0018E Member %s not found for EXTRACT.\",\n                        ggmem);\n        goto EE;\n      }\n    }\n  }\n  /***************************************************************************/\n  EE:\n  return (prc);\n}\n/**0340***********************************************************************/\n/* do_datablock()                                                            */\n/*   - write a datablock                                                     */\n/*---------------------------------------------------------------------------*/\n/*   RC: 8 Error FILE                                                        */\n/*   RC: 2 END OF MEMBER                                                     */\n/*---------------------------------------------------------------------------*/\n/*****************************************************************************/\nint  do_datablock(unsigned char *sbuf,int blen,int *dbl,int *swext) {\n\n  int i,j,k,m,ss,rc=0,prc=0;char *prn=\"do_datablock\";  /* commons            */\n\n  char igw\u00dd\u00a8 = {0xC9,0xC7,0xE6,0xC6,0xC1,0xC8,0xD9,0x40,0x00,0x00};\n  #define IGWL 10\n\n  int rlen;\n\n  static int olen = 0;\n  /***************************************************************************/\n  //                                    /* be aware that we write            */\n  //                                    /* 0-Byte blocks if --cchhr          */\n  //                                    /* this was a recv390 error          */\n  //                                    /* in orig .                         */\n  //  sysprint(\"%d %d %d\",*swext,*dbl,blen );\n//  for (i=0;i<9;i++) fprintf(stderr,\"%2.2X \",sbuf\u00ddi\u00a8); fprintf(stderr,\"\\n\");\n\n\n  //                                    /* omit byte 0 for pdse compare      */\n  //                                    /* FIRST BLOCK ****************      */\n  if (!memcmp(ggmbbcchhrs+1,sbuf+1,8)) {\n    *swext = 1;\n    rlen = blen;\n    if (ggcchhr != 1) j = 12;\n    else              j = 0;\n\n    if (!ggfo) {\n      prc=do_msg(0,\"XMC0011I Found Member %s.\",ggmem);\n      /***********************************************************************/\n      //                                /* open & determine output direction */\n      //                                /* if persistent file. THEN ERROR    */\n      ggfo = do_copen(ggodsn);\n      if (ggodsn\u00dd0\u00a8 && !ggfo) {\n         prc = 8; goto EE;\n       }\n      //                                /* if fo is now NULL we assume stdout*/\n      //                                /* no implicit correct to 1. we must */\n      //                                /* assure TSO DD SYSPRINT            */\n\n      if (!ggfo) prc=do_msg(0,\"XMU0004I Output Destination is stdout.\");\n      else       prc=do_msg(0,\"XMU0005I Output File is %s.\",ggodsn);\n      //                                /* assure TSO DD SYSPRINT            */\n      if (!ggfo) ggfo = stdout;\n      /***********************************************************************/\n    }\n    //                                  /* sfor EATTR: dump & write          */\n    if (rlen-j > 0) {\n      rc = memcmp(sbuf+12,igw,IGWL);\n      if (!rc &&  ggeattr) do_eattr(sbuf+12,rlen-12);\n      if (!rc && !ggeattr) {\n        prc=do_msg(0,\"XMU0007I EATTR skipped at Pos %d.\",olen);goto EE;\n      }\n    }\n\n//  fwrite(\"*F***************\",10,1,ggfo);\n    fwrite(sbuf+j,rlen-j,1,ggfo);\n    olen = olen + rlen - j ;\n  }\n  //                                    /* LAST  BLOCK ****************      */\n  else if (!memcmp(ggmbbcchhrp+1,sbuf+1,8)) {\n    prc=do_msg(0,\"XMC0018I Member %s extracted to %s (%d Bytes).\",\n                 ggmem,ggodsn,olen);\n    prc = 2;    /* END OF MEMBER */\n    goto EE;\n  }\n  //                                    /* OTHER BLOCKS ***************      */\n  else if (*swext) {\n    rlen = blen;\n    if (ggcchhr != 1) j = 12;\n    else              j =  0;\n\n    //                                  /* sfor EATTR: dump & write          */\n    if (ggeattr & rlen-j > 0) {\n      rc = memcmp(sbuf+12,igw,IGWL);\n      if (!rc)  {\n        do_eattr(sbuf+12,rlen-12);\n        // goto EE;\n      }\n    //if (!rc){prc=do_msg(0,\"XMU0007I EATTR skipped at Pos %d.\",olen);goto EE;}\n    }\n\n//  fwrite(\"*L***************\",10,1,ggfo);\n    fwrite(sbuf+j,rlen-j,1,ggfo);\n    olen = olen + rlen - j ;\n  }\n  ggdbx++;\n  /***************************************************************************/\n  EE:\n//  sysprint (\"RC %d\",prc);\n  return (prc);\n}\n/**0330***********************************************************************/\n/* do_blocks()                                                               */\n/*   - retrieve all blocks from a dataset. combine segments to a complete    */\n/*   - control flow of blocks                                                */\n/*---------------------------------------------------------------------------*/\n/* F:  do_copyr1                                                             */\n/* F:  do_copyr2                                                             */\n/* F:  do_directory                                                          */\n/* F:  do_mbbcchhr                                                           */\n/* F:  do_msg1                                                               */\n/* F:  do_segments                                                           */\n/* F:  do_txtunit                                                            */\n/* F:  do_datafirstb                                                         */\n/* F:  do_datablock                                                          */\n/* F:  xxopen                                                                */\n/* F:  zzc2d                                                                 */\n/* G:  ggdbx                                                                 */\n/* G:  ggdsnx                                                                */\n/* G:  ggmem                                                                 */\n/* G:  ggodsn                                                                */\n/* G:  ggpa                                                                  */\n/* G:  ggpax                                                                 */\n/* G:  ggpm                                                                  */\n/* G:  ggpm                                                                  */\n/* G:  ggrm                                                                  */\n/* G:  ggttr                                                                 */\n/* M:  ZZXE2A                                                                */\n/*****************************************************************************/\nint  do_blocks() {\n\n  int i,j,k,m,ss,rc=0,prc=0;char *prn=\"do_blocks\";  /* commons               */\n\n  FILE *fx = NULL;                                  /*                       */\n  unsigned char *sbuf = NULL;                       /* read buffer           */\n  unsigned char *lbuf = NULL;                       /* work buffer           */\n  unsigned char wbuf\u00dd9\u00a8;\n\n  int blen=0,bmax=32*1024+12,btype=0;              /* this is 32K max blksiz */\n\n  unsigned int n;\n           int dbl = 0;\n  int swext = 0,rlen=0,dirdone=0;                  /* cchhr                  */\n  /***************************************************************************/\n  sbuf=malloc(bmax);\n  if (!sbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n  lbuf=malloc(1024);\n  if (!lbuf) {prc=do_msg(12,\"XMC0200S Malloc Error %s.\",prn);goto EE;}\n\n  fx = xxopen(ggdsnx,\"rb\");\n  if (!fx) {prc=do_msg(8,\"XMC0210E Open Failed Input %s.\",ggdsnx); goto EE;}\n  //#########################################################################*/\n  while (1) {\n    rc = do_segments(fx,sbuf,&blen,bmax,&btype);\n    if (rc >2) {prc = rc; goto EE;}\n\n\n    memcpy(lbuf,sbuf,6); ZZXE2A(lbuf,6);\n    //*************************                                              */\n    //* INMR BLOCK                                                           */\n    //*************************                                              */\n    if (!memcmp(lbuf,\"INMR\",4)) {\n      prc = do_txtunit(sbuf,blen);\n      if (prc) {goto EE;}\n    }\n    //*************************                                              */\n    //* IEBCOPY COPYR1 BLOCK - first datablock                               */\n    //*************************                                              */\n    else if (ggdbx == 0) {\n      prc = do_copyr1(sbuf,blen);\n      if (prc) {goto EE;}\n      ggdbx++;\n    }\n    //*************************                                              */\n    //* IEBCOPY COPYR2 BLOCK - second datablock                              */\n    //*************************                                              */\n    else if (ggdbx == 1) {\n      prc = do_copyr2(sbuf,blen);\n      if (prc) {goto EE;}\n      ggdbx++;\n    }\n    //*************************                                              */\n    //* ALL DIRECTORY BLOCKS - 0x00 00 00 00 00 00 00 00                     */\n    //*************************                                              */\n    else if  (zzc2d(sbuf,8) == 0 && dirdone == 0) {\n      rc = do_directory(sbuf,blen);\n      if (rc==1) dirdone=1;\n      if (rc> 1) {prc=rc;goto EE;}\n      ggdbx++;\n    }\n    //************************************************************************/\n    //* ALL OHTER DATA BLOCKS  is IEBCOPY UNLOAD ...                         */\n    else {\n      if (!dbl) rc = do_datafirstb();\n      //=====================================================================*/\n      //* ALL   UNLOAD BLOCK - dbl<1 & dbl>0                                 */\n      dbl++;\n      //                                    /* we stop here, if no member    */\n      //                                    /* specified,avoiding read blocks*/\n      //                                    /* go Out and Term Program       */\n      //                                    /* there is nothing to stay      */\n      if (!ggmem\u00dd0\u00a8) {\n        prc=do_msg(0,\"XMC0017I No Member specified for EXTRACT.\");\n        goto EE;\n      }\n/*\n      k = 0;\n      m = blen;\n      rc = do_datablock(sbuf+k,m,&dbl,&swext);\n      if (rc) goto EE;\n*/\n\n\n      k = 0;\n      while (k < blen){\n        m = zzc2d(sbuf+k+10,2) + 12;\n\n//     for (i=0;i<12;i++) fprintf(stderr,\"%2.2X \",(sbuf+k)\u00ddi\u00a8);\n//     fprintf(stderr,\"L: %d  DBX: %d BM: %d BK %d  ***\\n\",blen,dbl,m,k);\n\n        rc = do_datablock(sbuf+k,m,&dbl,&swext);\n        if (rc) {\n          prc =rc; goto EE;\n        }\n        k = k + m;\n      }\n\n    }\n    if (!memcmp(lbuf,\"INMR06\",6)) {prc = 0; goto EE;}\n    //                                           /* we are disappointed      */\n    if (rc == 2) {prc=do_msg(2,\"XMC0209W Read beyond EOF\");  goto EE; }\n  }\n  /***************************************************************************/\n  EE:\n  if (fx)     fclose(fx);\n  if (ggfo)     fclose(ggfo);\n  if (sbuf)   free(sbuf);\n  if (lbuf)   free(lbuf);\n  return (prc);\n}\n/**0910***********************************************************************/\n/* showopts()                                                                */\n/* write out options                                                         */\n/*****************************************************************************/\n void showopts() {\n\n  do_msg(0,\"XMC0001I Options specified:\");\n  do_msg(0,\"+  P1         : %s\",ggdsnx);\n  do_msg(0,\"+  NOMSG      : %d\",ggnomsg);\n  do_msg(0,\"+  NOINFO     : %d Superseeds all other Info Settings.\",ggnoin);\n  do_msg(0,\"+  - NOINMR   : %d INMR Tokens resolved.\",ggnoim);\n  do_msg(0,\"+  - NOIEBC   : %d COPYR1 & COPYR2 Infos.\",ggnoie);\n  do_msg(0,\"+  - NODIR    : %d Member with Attributes / Stats.\",ggnodi);\n  do_msg(0,\"+  - NOBASE   : %d Resolve Basemen for ISPF Aliasses.\",ggnoba);\n  do_msg(0,\"+  ODS / ODIR : %s\",ggodsn);\n  do_msg(0,\"+  MEMBER     : %s\",ggmem);\n  do_msg(0,\"+  REPLACE    : %d\",ggrep);\n  do_msg(0,\"+  EATTR      : %d\",ggeattr);\n  do_msg(0,\"+  CCHHR      : %d\",ggcchhr);\n\n  return;\n}\n/**0920***********************************************************************/\n/* showhelp()                                                                */\n/* write out help                                                            */\n/*****************************************************************************/\nvoid showhelp() {\n\n  int i;\n  char *p\u00dd\u00a8 = {\n   \"XMCLIST pos1 < opts >                                                   \"\n  ,\"                                                                        \"\n  ,\"  where opts are:                                                       \"\n  ,\"       pos1:         xmit dataset. A file in NETDATA format, covering   \"\n  ,\"                     one unloaded PO or PO Extended Dataset.            \"\n  ,\"                     AKA: XMI-File.                                     \"\n  ,\"                                                                        \"\n  ,\"       opts:         optional parameters.                               \"\n  ,\"                                                                        \"\n  ,\"         --noinmr    Suppression of all NETDATA Information             \"\n  ,\"         --noiebc    Suppression of all IEBCOPY Unload Information      \"\n  ,\"         --nodir     Don`t show Directory Information                   \"\n  ,\"         --nobase    Don`t show Resolution of ISPF-Alias to BaseMem.    \"\n  ,\"                                                                        \"\n  ,\"         --noinfo    Suppress ALL Information. See above.               \"\n  ,\"         --nomsg     Don`t write Messages                               \"\n  ,\"                                                                        \"\n  ,\"         --mem=member  Member to search for and to extract. The output  \"\n  ,\"                       is raw. No translation occurs. Block- and Record-\"\n  ,\"                       Descriptors are kept.                            \"\n  ,\"                                                                        \"\n  ,\"                       Alias: member=                                   \"\n  ,\"                                                                        \"\n  ,\"         --ods=mem.bin Output-Path & filename for Extract.              \"\n  ,\"                       - if not specified, then output goes to          \"\n  ,\"                         stdout on X86-Platforms                        \"\n  ,\"                                                                        \"\n  ,\"                       - for MVS a valid Dataset-Name must be specified.\"\n  ,\"                         No Auto-Creation (DYNALLOC) is done. While     \"\n  ,\"                         Specification of a Member in a existing PO is  \"\n  ,\"                         allowed.                                       \"\n  ,\"                         As this is a raw output, it is user            \"\n  ,\"                         responsibility to adjust the output DCB.       \"\n  ,\"                                                                        \"\n  ,\"                       Alias: odir=                                     \"\n  ,\"                       Alias: outdataset=                               \"\n  ,\"                                                                        \"\n  ,\"         --replace     Force Overwrite of existing File.                \"\n  ,\"                                                                        \"\n  ,\"         --cchhr       write cchhr with Output.                         \"\n  ,\"                                                                        \"\n  ,\"         --eattr       dump Extended Attributes PO Extended             \"\n  ,\"                                                                        \"\n  ,\"                                                                        \"\n  ,\"  Remarks:                                                              \"\n  ,\"                                                                        \"\n  ,\"   While X86-Platform resembles POSIX Standard for Parameter Processing,\"\n  ,\"   Options specified in MVS (here TSO) rely to TSO Parsing.             \"\n  ,\"                                                                        \"\n  ,\"   X86:                                                                 \"\n  ,\"    $ xmclist my.recv390.xmi --nodir --mem=mymem --ods=./tmp/mymem.bin  \"\n  ,\"                                                                        \"\n  ,\"        shows no directory list, and extracts MYMEM                     \"\n  ,\"        to the file mymem.bin                                           \"\n  ,\"                                                                        \"\n  ,\"                                                                        \"\n  ,\"   TSO:                                                                 \"\n  ,\"        XMCLIST MY.RECV390.XMI NODIR MEM(MYMEM) ODS(MY.MYMEM.BIN)       \"\n  ,\"                                                                        \"\n  ,\"        shows no directory list, and extracts MYMEM                     \"\n  ,\"        to a sequential file MY.MYMEM.BIN                               \"\n  ,\"                                                                        \"\n  ,\"        - DDNAMES are allowed and prefixed with DD: . E.g. DD:MYDD      \"\n  ,\"        - Quotes are tolerated, but not honored. So a dsn needs to be   \"\n  ,\"          fully qualified in all cases.                                 \"\n  ,\"                                                                        \"\n  ,\"                                                                        \"\n  ,__BUILD\n  ,0x0\n  };\n\n  for (i=0;p\u00ddi\u00a8 != 0x0; i++) sysprint(\"*NO\",\"%s\",p\u00ddi\u00a8);\n\n  return;\n}\n/*****************************************************************************/\n/* M A I N                                                                   */\n/*                                                                           */\n/*---------------------------------------------------------------------------*/\n/* RC: 200     getmain error                                                 */\n/* F:  sysprint                                                              */\n/* F:  zzgoptk                                                               */\n/* F:  zzgoptv                                                               */\n/* F:  zzsprintf                                                             */\n/* G:  GPP                                                                   */\n/* G:  GDM                                                                   */\n/* G:  G1                                                                    */\n/* G:  procname                                                              */\n/* G:  ggverb                                                                */\n/* G:  ggrep                                                                 */\n/* G:  ggodsn                                                                */\n/* G:  ggmem                                                                 */\n/* G:  ggdsnx                                                                */\n/* G:  ggpaI                                                                 */\n/* G:  ggpmI                                                                 */\n/* G:  ggpal                                                                 */\n/* G:  ggra                                                                  */\n/* G:  ggpml                                                                 */\n/* G:  ggrm                                                                  */\n/* G:  ggttr                                                                 */\n/*****************************************************************************/\nint  main(int argc, char ** argv) {\n\n  int rc,prc = 0;\n  int i,j,k,m;\n  char abuf\u00dd255\u00a8 = \"\";\n  char lbuf\u00dd60\u00a8;\n\n  #define CBL  1024\n  #define OBL  1024\n\n  char *cbuf,*obuf;\n  /***************************************************************************/\n  cbuf=malloc(CBL); if (!cbuf) {rc=200;goto EE;}\n  obuf=malloc(OBL); if (!obuf) {rc=200;goto EE;}\n\n  procname = argv\u00dd0\u00a8;\n\n\n  /* AGRUMENTS                                                               */\n  //                                   /* (2) HELP & VERSION                 */\n  cbuf\u00dd0\u00a8 = 0x0;\n  for (i=1;i<argc;i++) {\n    if ( (strlen(cbuf) + strlen(argv\u00ddi\u00a8)) +1 > CBL) break;\n    strcat(cbuf,argv\u00ddi\u00a8); strcat(cbuf,\" \");\n  }\n  #if defined MVS\n  zzstrupr(cbuf);\n  #endif\n  rc = dcprmkyo(cbuf,GPP\"HELP\",GPP\"NOHELP\");\n  if (rc == 1) {showhelp(); prc = 0     ; goto EE;}\n  rc = dcprmkyo(cbuf,GPP\"VERSION\",GPP\"NOVERSION\");\n  if (rc == 1) {prc = do_msg(0,__BUILD); goto EE;}\n  //***************************************************************************\n  //                                   /* (1) positional arg first           */\n  if (argc > 1) strncpy(ggdsnx,argv\u00dd1\u00a8,G1);\n  //                                   /* all other are optional and handled */\n  //                                   /* in a cmdstring                     */\n  //                                   /* (3) KEY ONLY PARMS                 */\n  rc = dcprmkyo(cbuf,GPP\"INFO\",GPP\"NOINFO\");   if (rc == 2) ggnoin = 1;\n  rc = dcprmkyo(cbuf,GPP\"INMR\",GPP\"NOINMR\");   if (rc == 2) ggnoim = 1;\n  rc = dcprmkyo(cbuf,GPP\"IEBC\",GPP\"NOIEBC\");   if (rc == 2) ggnoie = 1;\n  rc = dcprmkyo(cbuf,GPP\"DIR\" ,GPP\"NODIR\" );   if (rc == 2) ggnodi = 1;\n  rc = dcprmkyo(cbuf,GPP\"BASE\",GPP\"NOBASE\");   if (rc == 2) ggnoba = 1;\n  rc = dcprmkyo(cbuf,GPP\"MSG\" ,GPP\"NOMSG\" );   if (rc == 2) ggnomsg= 1;\n  rc = dcprmkyo(cbuf,GPP\"CCHHR\" ,GPP\"NOCCHHR\" );   if (rc == 1) ggcchhr= 1;\n  rc = dcprmkyo(cbuf,GPP\"EATTR\" ,GPP\"NOEATTR\" );   if (rc == 1) ggeattr= 1;\n  rc = dcprmkyo(cbuf,GPP\"REPLACE\" ,GPP\"NOREPLACE\" ); if (rc == 1) ggrep= 1;\n  //                                   /* (4) KEY VALUE PARMS                */\n  rc = dcprmkvl(cbuf,GPP\"MEMBER\",\"X\",obuf); if (rc) strncpy(ggmem,obuf,8);\n  rc = dcprmkvl(cbuf,GPP\"MEM\",\"X\",obuf);    if (rc) strncpy(ggmem,obuf,8);\n  rc = dcprmkvl(cbuf,GPP\"ODS\",\"\",obuf);     if (rc) strncpy(ggodsn,obuf,G1);\n  rc = dcprmkvl(cbuf,GPP\"ODIR\",\"\",obuf);    if (rc) strncpy(ggodsn,obuf,G1);\n  rc = dcprmkvl(cbuf,GPP\"OUTDATASET\",\"\",obuf);if (rc) strncpy(ggodsn,obuf,G1);\n  //                                   /* format / validate values           */\n\n  j = 0; obuf\u00dd0\u00a8 = 0x0;\n  for (i=0;i<strlen(ggodsn);i++) {\n    if (ggodsn\u00ddi\u00a8 == '*') {\n      strcat(obuf,ggmem);\n      j = j + strlen(ggmem);\n    }\n    else {\n      obuf\u00ddj\u00a8 = ggodsn\u00ddi\u00a8;\n      j++;\n    }\n    obuf\u00ddj\u00a8 = 0x0;\n  }\n  strcpy(ggodsn,obuf);\n\n  if (ggnoin) {\n    ggnoim= 1;\n    ggnoie= 1;\n    ggnodi= 1;\n    ggnoba= 1;\n  }\n\n  zzstrupr(ggmem);\n  #if defined MVS\n  zzstrupr(ggdsnx);   xxstrip(ggdsnx,\"'\");//' '\n  zzstrupr(ggodsn);   xxstrip(ggodsn,\"'\");//' '\n  #endif\n\n  if (!ggnomsg) showopts();\n  //                                  /* Always Alloc for TTR           */\n  ggpal = sizeof(ggttr)*ggpaI;\n  ggra  =malloc(ggpal); if (!ggra) {rc=200; prc=rc; goto EE;}\n  ggpml = sizeof(ggttr)*ggpmI;\n  ggrm  =malloc(ggpml); if (!ggrm) {rc=200; prc=rc; goto EE;}\n  //                                  /* Here we handle the important   */\n  //                                  /* things                         */\n  rc = do_blocks();\n  prc = rc;\n  /***************************************************************************/\n  EE:\n  if (ggra) free(ggra);\n  if (ggrm) free(ggrm);\n  prc=do_msg(prc,\"Returncode (%d).\",prc);\n  return (prc);\n\n}\n/* eoc ***********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMCLIST$": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x166O\\x01\\x166O \\x10\\x00\\x17\\x00\\x17\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-29T00:00:00", "modifydate": "2016-12-29T20:10:33", "lines": 23, "newlines": 23, "modlines": 0, "user": "E1226"}, "text": "//XMCLIST$ JOB SDBDC,,CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1),\n//             REGION=4096K,NOTIFY=E1226,USER=E1226\n//*+-----------------------------------------------------<BOD>+\n//*|SYS: SINM   LLQ: CNTL                                     |\n//*|VER: 1.0       (C): SYSPRG1                               |\n//*|----------------------------------------------------------|\n//*|DESC: COMPILE XMCLIST                                     |\n//*|DEP:                         SDBDC.MVS38J.PROCLIB(JCC037) |\n//*|----------------------------------------------------------|\n//*|SYSPRG1   12/11/17     NEUERSTELLUNG                      |\n//*+-----------------------------------------------------<EOD>+\n//***************************************************************\n//S010     EXEC JCC037,SDSN='SYSW.M38K.CBT999.INST',MEM='XMCLIST'\n//LINK.SYSLMOD DD DISP=SHR,DSN=SDBDC.MVS38J.LOAD(XMCLIST)\n//***************************************************************\n//RUNPGM  EXEC PGM=IKJEFT01,REGION=4096K\n//STEPLIB   DD DISP=SHR,DSN=SDBDC.MVS38J.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//STDERR   DD SYSOUT=*\n//STDOUT   DD SYSOUT=*\n//SYSTSIN  DD *\n  XMCLIST HELP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XMCLOAD": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x00/\\x01\\x17\\x00/!\\x07\\x0f\\x9f\\x0f\\x9f\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T21:07:00", "lines": 3999, "newlines": 3999, "modlines": 0, "user": "E1226"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMCUTIL": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x00/\\x01\\x17\\x00/\\x17)\\x01\\xea\\x01\\xea\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T17:29:00", "lines": 490, "newlines": 490, "modlines": 0, "user": "E1226"}, "text": "/*+---------------------------------------------------------------------<bod>+*/\n/*!sys: SINM      llq: SOURCE                                                !*/\n/*!ver: 0.1.18    (c): E1226                                                 !*/\n/*!--------------------------------------------------------------------------!*/\n/*!desc: XMC decode different File Formats                                   !*/\n/*!--------------------------------------------------------------------------!*/\n/*!arg: see below                                                            !*/\n/*!run: TSO / X86                                                            !*/\n/*!--------------------------------------------------------------------------!*/\n/*!E1226   28/12/16     0.1.18 RECFM=V    reworked                           !*/\n/*!E1226   28/12/16     0.1.17 RECFM=F    reworked IGWFAHR EATTR both out    !*/\n/*!E1226   23/12/16     0.1.16 RECFM=F    reworked                           !*/\n/*!E1226   20/12/16     0.1.15 RECFM=U    reworked                           !*/\n/*!E1226   20/10/16     0.1.14 IGWFAHR                                       !*/\n/*!E1226   03/10/16     0.1.13 RECFM=U                                       !*/\n/*!E1226   03/10/16     0.1.13 RECFM=F                                       !*/\n/*!E1226   03/10/16     0.1.13 EATTR                                         !*/\n/*!E1226   03/10/16     0.1.11 parm processing complete                      !*/\n/*!E1226   02/10/16     0.1.10 parm processing complete                      !*/\n/*!E1226   02/10/16     new mod creation                                     !*/\n/*+---------------------------------------------------------------------<eod>+*/\n// #define X86\n// #define LINUX\n   #define MVS\n   #define MVS43\n\n#define __ZZPROC \"xmcutil\"\n#define __ZZVER \"0.1.18\"\n\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#if defined X86\n#include \"@dcuser.h\"   /* mine */\n#endif\n#if defined MVS\n#include \"@dcuser\"     /* mine */\n#endif\n\n#define __BUILD __ZZPROC\" (c) eho 2016 Version \"__ZZVER\"  Build \" \\\n        __DATE__\" \"__TIME__\n//                                     /* build a POSIX comaptible parm env  */\n//                                     /* parm keys are always upper case    */\n//                                     /* parm values remain sensitive       */\n#define PARMKEYU\n#if defined X86\n#define GPP    \"--\"\n#define GDM    \"??\" //\n#define GEQ    \"=\"  // keyvalue =\n#define GWBL 4096\n#define G1   512\n#endif\n#if defined MVS\n#define GPP    \"\"\n#define GDM    \"()\" //\n#define GEQ    \"\"   // keyvalue = not applicable\n#define GWBL 4096\n#define G1   60\n#endif\n//\nchar ggdsni \u00ddG1+1\u00a8= \"\";          // XMI File\nchar ggdsno \u00ddG1+1\u00a8= \"\";          // Output DSN for Extract\n//\nint  ggnomsg      = 0;           // no msg\nint  ggcode       = 0;           // ascii / ebcdic conv\nint  ggunblock    = 0;           // strip trailing ascii spaces\nint  ggpad        = 0;           // add spaces to end of line\nint  ggrep        = 0;           // replace output flag\nunsigned char ggrecfm = 'F';     // recfm\nint  gglrecl      = 80;          // lrecl\n//************\n//                               /* Macro Ascii Convert                      */\n#if defined X86\n#define ZZXE2A(a,b) zze2a(a,b)\n#else\n#define ZZXE2A(a,b)\n#endif\n//\n/*****************************************************************************/\n/* F U N C T I O N S  COMMON                                                 */\n/**0110***********************************************************************/\n/* xxopen()                                                                  */\n/*   open a file                                                             */\n/*****************************************************************************/\nFILE * xxopen(char *fname,char *fopts) {\n\n  FILE *fh;\n  unsigned char opts\u00dd30\u00a8;\n\n  #if defined X86\n  fh = 0; fh = zzopen(fname,fopts);\n  #else\n  zzstrupr(fname);\n  fh = NULL;\n\n//printf(\"** fname: (%s) (%s) **\\n\",fname,fopts);\n\n  if      (!memcmp(fname,\"DD:\",3)) {\n    sprintf(opts,\"%s,DD\",fopts);\n    fh = zzopen(fname+3,opts);\n//  printf(\"xxopen: (%d) (%s) (%s) **\\n\",fh,fname,opts);\n  }\n  else if (!memcmp(fname,\"//DDN:\",6)) {\n    sprintf(opts,\"%s,DD\",fopts);\n    fh = zzopen(fname+6,opts);\n//  printf(\"xxopen: (%d) (%s) (%s) **\\n\",fh,fname,opts);\n  }\n  else fh = zzopen(fname,fopts);\n  #endif\n\n  return fh;\n}\n/**0120***********************************************************************/\n/* xxstrip()                                                                 */\n/*   strip quotes                                                            */\n/*****************************************************************************/\n int  xxstrip(char *buf, char *quote) {\n  int i,j,l;\n  j = 0;\n  l = strlen(buf);\n  for (i=0;i<l;i++) {\n    if (buf\u00ddi\u00a8 != quote\u00dd0\u00a8) {buf\u00ddj\u00a8 = buf\u00ddi\u00a8; j++;}\n    else buf\u00ddj\u00a8 = 0x00;\n  }\n  return strlen(buf);\n}\n/**0200***********************************************************************/\n/* do_msg()                                                                  */\n/* - common message formatting and suppression                               */\n/*****************************************************************************/\nint do_msg(int rc,char *msg, ...) {\n\n  char tbuf\u00dd256\u00a8 = \"\";\n\n  va_list args;\n  if (ggnomsg) return (rc);\n  va_start (args, msg);\n\n  vsnprintf(tbuf+0,256-0,msg,args);\n  sysprint(\"*NO\",tbuf);\n\n  va_end (args);\n  return (rc);\n}\n/**0210***********************************************************************/\n/* do_copen()                                                                */\n/* - conditional open                                                        */\n/*****************************************************************************/\nFILE * do_copen(char *fname) {\n\n  static FILE *fo;\n\n  int i,j,k,m,rc=0,prc=0;char *prn=\"do_copen\";      /* commons               */\n\n  if (!fname\u00dd0\u00a8) goto EE;               /* no filename procided              */\n  /***************************************************************************/\n  if (!ggrep) {\n    fo = xxopen(ggdsno,\"rb\");\n    if (fo) {\n      prc=do_msg(8,\"XMU0302E Replace not specified for %s.\",ggdsno);\n      fclose(fo);\n      fo = NULL;\n      goto EE;\n    } // >> else no open file\n  }\n\n  // ***************                /* here we can open safe write   */\n  fo = xxopen(ggdsno,\"wb\");\n  if (!fo) {\n    prc=do_msg(8,\"XMU0303E Open Failed Output %s.\",ggdsno);\n    fo = NULL;\n    goto EE;\n  }\n  /***************************************************************************/\n  EE:\n  return (fo);\n}\n/**0220***********************************************************************/\n/* do_blocks()                                                               */\n/* - work with file contents                                                 */\n/*****************************************************************************/\nint do_blocks() {\n\n  int i,j,k,m,n,q,rc=0,prc=0;char *prn=\"do_blocks\"; /* commons               */\n\n  FILE *fi = NULL;                                  /*                       */\n  FILE *fo = NULL;                                  /*                       */\n  FILE *fhi;\n  FILE *fho;\n\n  #define BS   32760                                /* BS*3 > MBUF !!        */\n  #define MBUF 400                                  /* MBUF GT IGWL          */\n  int bsz = 0, mbuf= 0, bszx =0;\n\n  char *sbuf = NULL;\n  char *pbuf = NULL;\n  char sin = 0;                                     /* flag sysin read       */\n\n  char igw\u00dd\u00a8 = {0xC9,0xC7,0xE6,0xC6,0xC1,0xC8,0xD9,0x40,0x00,0x00,0x00,0x2C};\n  #define IGWL 12\n  char *sp = 0; char *pp;\n  int fl, sl, wl;                                   /* file length, eapos    */\n  unsigned char c;\n  int bi,bo,bx;\n  int bb, br;\n  /***************************************************************************/\n  //                                  /* Normalize Buffers to lrecl          */\n  bsz  = (BS / gglrecl) * gglrecl;\n  mbuf = (MBUF / gglrecl) * gglrecl; if (mbuf < MBUF) mbuf = mbuf + gglrecl;\n  bszx = bsz + mbuf;\n\n  sbuf=malloc(bszx);\n  if (!sbuf) {prc=do_msg(12,\"XMU0200S Malloc Error %s.\",prn);goto EE;}\n  pbuf=malloc(bszx);\n  if (!pbuf) {prc=do_msg(12,\"XMU0200S Malloc Error %s.\",prn);goto EE;}\n\n  if (ggdsni\u00dd0\u00a8 == '-' && ggdsni\u00dd1\u00a8 == 0x00) sin = 1;\n\n\n  if (!sin) {\n    fi = xxopen(ggdsni,\"rb\");\n    if (!fi) {prc=do_msg(8,\"XMU0301E Open Failed Input (%s).\",ggdsni);goto EE;}\n    fhi = fi;\n  }\n  else fhi = stdin;\n  /***************************************************************************/\n  //                                  /* open & determine output direction   */\n  fo = do_copen(ggdsno);\n  if (ggdsno\u00dd0\u00a8 && !fo) {prc = 8; goto EE; }\n  //                                  /* if fo is now NULL we assume stdout  */\n  //                                  /* no implicit correct to 1. we must   */\n  //                                  /* assure TSO DD SYSPRINT              */\n  if (!fo) prc=do_msg(0,\"XMU0004I Output Destination is stdout.\");\n  else     prc=do_msg(0,\"XMU0005I Output File is %s.\",ggdsno);\n  //                                  /* assure TSO DD SYSPRINT              */\n  if (!fo) fho = stdout;\n  else     fho = fo;\n  /***************************************************************************/\n  //                                  /* RECFM=U (we do it for raw)          */\n  if (ggrecfm == 'U') {\n    bi = gglrecl;\n    if (bsz < bi) bi = bsz;\n    bo = 0;\n\n    while (1) {\n      rc = fread(pbuf,1,bsz,fhi);\n      if (!rc) break;\n\n      for (i=0;i<rc;i=i+bi) {\n        if (rc-i < bi) bi = rc - i;\n        m = fwrite(pbuf+i,1,bi,fho);\n        bo = bo + m;\n      }\n    }\n    bx = bo;\n  }\n  /***************************************************************************/\n  //                                  /* RECFM=F                             */\n  if (ggrecfm == 'F') {\n    bi = gglrecl;\n    bo = 0;\n    bx = 0;\n\n    while (1) {\n      rc = fread(pbuf,1,bsz,fhi);\n      if (!rc) break;\n\n      for (i=0;i<rc;i=i+bi) {\n        if (rc-i < bi) bi = rc - i;\n\n        if (ggcode) zze2a(pbuf+i,bi);\n\n        q = bi;\n        if (ggunblock) {\n                                               /* we are ascii here          */\n          for (j=bi-1;j>=0;j--) if ((pbuf+i)\u00ddj\u00a8 != 0x20) break;\n          j++;\n          q = j;\n        }\n\n        m  = fwrite(pbuf+i,1,q,fho);\n        bx = bx + m;\n\n        if (ggunblock) {fwrite(\"\\n\",1,1,fho); bx++;}\n        bo = bo + bi;\n      }\n    }\n  }\n  /***************************************************************************/\n  //                                  /* RECFM=V                             */\n  if (ggrecfm == 'V') {\n    bi = gglrecl;\n    bo = 0;\n    bx = 0;\n\n    while (1) {\n      rc = fread(pbuf,1,4,fhi); if (!rc) break;\n      bb = zzc2d(pbuf,2);\n//    sysprint(\"Block %d\",bb);\n      if (!bb) break;\n      rc = fread(pbuf,1,bb-4,fhi); if (!rc) break;\n      bo = bo+rc+4;\n\n      i = 0;\n      while (i < bb-4) {\n        br = zzc2d(pbuf+i,2);\n//      sysprint(\"Record %d\",br);\n        if (ggcode) zze2a(pbuf+i+4,br-4);\n        if (!ggpad) {\n          rc = fwrite(pbuf+i+4,1,br-4,fho);\n          bx = bx + rc;\n\n          if (ggunblock) {fwrite(\"\\n\",1,1,fho); bx++;}\n        }\n        else {\n          memset(sbuf,' ',gglrecl);\n          memcpy(sbuf,pbuf+i+4,br-4);\n          rc = fwrite(sbuf,1,gglrecl,fho);\n          bx = bx + rc;\n        }\n        i = i + br;\n      }\n    }\n  }\n  /***************************************************************************/\n  prc=do_msg(0,\"XMU0006I Wrote %d Bytes (unblocked %d).\",bo,bx);\n  /***************************************************************************/\n  EE:\n  if (sbuf)   free(sbuf);\n  if (fi)     fclose(fi);\n  if (fo)     fclose(fo);\n  return (prc);\n}\n/**0910***********************************************************************/\n/* showopts()                                                                */\n/* write out options                                                         */\n/*****************************************************************************/\n void showopts() {\n\n  do_msg(0,\"XMU0001I Options specified:\");\n  do_msg(0,\"+  P1         : %s\",ggdsni);\n  do_msg(0,\"+  NOMSG      : %d\",ggnomsg);\n  do_msg(0,\"+  ASCII      : %d\",ggcode);\n  do_msg(0,\"+  REPLACE    : %d\",ggrep);\n  do_msg(0,\"+  LRECL      : %d\",gglrecl);\n  do_msg(0,\"+  UNBLOCK    : %d\",ggunblock);\n  do_msg(0,\"+  PAD          %d\",ggpad);\n  do_msg(0,\"+  RECFM      : %c\",ggrecfm);\n  do_msg(0,\"+  ODS        : %s\",ggdsno);\n\n  return;\n}\n/**0920***********************************************************************/\n/* showhelp()                                                                */\n/* write out help                                                            */\n/*****************************************************************************/\nvoid showhelp() {\n\n  int i;\n  char *p\u00dd\u00a8 = {\n   \"XMCUTIL pos1 < opts >                                                   \"\n  ,\"                                                                        \"\n  ,\"  where opts are:                                                       \"\n  ,\"       pos1:         a single unloaded member or dataset expanded with  \"\n  ,\"                     XMCLIST.                                           \"\n  ,\"                 -   hyphen for stdin                                   \"\n  ,\"                                                                        \"\n  ,\"       opts:         optional parameters.                               \"\n  ,\"                                                                        \"\n  ,\"         --nomsg     Suppress messages                                  \"\n  ,\"         --ascii     Convert to ASCII                                   \"\n  ,\"         --unblock   strip trailing spaces of record (add CRLF)         \"\n  ,\"         --vpad      pad trailing spaces to the record (RECFM(V) only)  \"\n  ,\"         --replace   Clopper output                                     \"\n  ,\"         --lrecl=    Input LRECL. Default 80                            \"\n  ,\"         --recfm=    Input RECFM. Default U                             \"\n  ,\"         --ods=      Named Output File. Default is stdout               \"\n  ,\"                                                                        \"\n  ,\"  for TSO --key(value) should be KEY(VALUE)                             \"\n  ,\"                                                                        \"\n  ,__BUILD\n  ,0x0\n  };\n\n  for (i=0;p\u00ddi\u00a8 != 0x0; i++) sysprint(\"*NO\",\"%s\",p\u00ddi\u00a8);\n\n  return;\n}\n/*****************************************************************************/\n/* M A I N                                                                   */\n/*   - retrieve all blocks from a dataset. combine segments to a complete    */\n/*   - control flow of blocks                                                */\n/*   xmcutil mem.bin --lrecl=80 --recfm=f --ascii --unblock                  */\n/*---------------------------------------------------------------------------*/\n/* G:  gginfile   string                                                     */\n/* G:  ggnomsg    switch                                                     */\n/* G:  ggcode     switch                                                     */\n/* G:  ggeattr    switch                                                     */\n/* G:  ggunblock  switch                                                     */\n/* G:  gglrecl    int                                                        */\n/* G:  ggrecfm    char                                                       */\n/* G:  ggeattr    switch                                                     */\n/*****************************************************************************/\nint  main(int argc, char ** argv) {\n\n  int rc,prc = 0;\n  int i,j,k,m;\n  char abuf\u00dd255\u00a8 = \"\";\n  char lbuf\u00dd60\u00a8;\n\n  #define CBL 1025\n\n  char *cbuf,*obuf;\n  /***************************************************************************/\n  cbuf=malloc(CBL); if (!cbuf) {rc=200;goto EE;}\n  obuf=malloc(CBL); if (!obuf) {rc=200;goto EE;}\n\n  //**************************************************************************/\n  //*                                  /* Validation                         */\n  //                                   /* (2) HELP & VERSION                 */\n  cbuf\u00dd0\u00a8 = 0x0;\n  for (i=1;i<argc;i++) {\n    if ( (strlen(cbuf) + strlen(argv\u00ddi\u00a8)) +1 > CBL) break;\n    strcat(cbuf,argv\u00ddi\u00a8); strcat(cbuf,\" \");\n  }\n  #if defined MVS\n  zzstrupr(cbuf);\n  #endif\n  rc = dcprmkyo(cbuf,GPP\"HELP\",GPP\"NOHELP\");\n  if (rc == 1) {showhelp(); prc = 0     ; goto EE;}\n  rc = dcprmkyo(cbuf,GPP\"VERSION\",GPP\"NOVERSION\");\n  if (rc == 1) {prc = do_msg(0,__BUILD); goto EE;}\n  //***************************************************************************\n  //                                   /* (1) positional arg first           */\n  if (argc > 1) strncpy(ggdsni,argv\u00dd1\u00a8,G1);\n  //                                   /* all other are optional and handled */\n  //                                   /* in a cmdstring                     */\n  //                                   /* (3) KEY ONLY PARMS                 */\n  rc = dcprmkyo(cbuf,GPP\"MSG\"    ,GPP\"NOMSG\");      if (rc == 2) ggnomsg = 1;\n  rc = dcprmkyo(cbuf,GPP\"ASCII\"  ,GPP\"EBCDIC\");     if (rc == 1) ggcode  = 1;\n  rc = dcprmkyo(cbuf,GPP\"UNBLOCK\",GPP\"BLOCK\");      if (rc == 1) ggunblock= 1;\n  rc = dcprmkyo(cbuf,GPP\"PAD\"    ,GPP\"NOPAD\");      if (rc == 1) ggpad    = 1;\n  rc = dcprmkyo(cbuf,GPP\"REPLACE\",GPP\"NOREPLACE\" ); if (rc == 1) ggrep   = 1;\n  //                                   /* (4) KEY VALUE PARMS                */\n  rc = dcprmkvl(cbuf,GPP\"LRECL\",\"80\",obuf);\n  if (rc) {\n    gglrecl= atoi(obuf);\n    if (gglrecl < 80)    gglrecl = 80;\n    if (gglrecl > 32760) gglrecl = 32760;\n  }\n\n  rc = dcprmkvl(cbuf,GPP\"RECFM\",\"F\",obuf);\n  if (rc) {\n    ggrecfm = toupper(obuf\u00dd0\u00a8);\n    if (ggrecfm != 'V' && ggrecfm != 'F' && ggrecfm != 'U' ) ggrecfm = 'F';\n  }\n\n if (ggrecfm != 'V' && ggpad ) {\n   prc=do_msg(0,\"XMU0008W PAD w/o RECFM(V) makes mo sense.\");\n   ggpad = 0;\n }\n // if (ggrecfm == 'U') gglrecl = 0;\n\n  rc = dcprmkvl(cbuf,GPP\"ODS\",\"\",obuf);       if (rc) strncpy(ggdsno,obuf,G1);\n  rc = dcprmkvl(cbuf,GPP\"ODIR\",\"\",obuf);      if (rc) strncpy(ggdsno,obuf,G1);\n  rc = dcprmkvl(cbuf,GPP\"OUTDATASET\",\"\",obuf);if (rc) strncpy(ggdsno,obuf,G1);\n\n  #if defined MVS\n  strupr(ggdsni);     xxstrip(ggdsni,\"'\");//'\n  strupr(ggdsno);     xxstrip(ggdsno,\"'\");//'\n  #endif\n  //**************************************************************************/\n  //*                                  /* Validation                         */\n\n  if (!ggnomsg) showopts();\n  //                                  /* Always Alloc for TTR                */\n  rc = do_blocks();\n  prc = rc;\n  /***************************************************************************/\n  EE:\n  if (obuf) free(obuf);\n  if (cbuf) free(cbuf);\n  prc=do_msg(prc,\"Returncode (%d).\",prc);\n  return (prc);\n\n}\n/* eoc ***********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMCUTIL$": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00D\\x01\\x166O\\x01\\x166O \\x10\\x00\\x17\\x00\\x17\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-12-29T00:00:00", "modifydate": "2016-12-29T20:10:44", "lines": 23, "newlines": 23, "modlines": 0, "user": "E1226"}, "text": "//XMCUTIL$ JOB SDBDC,,CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1),\n//             REGION=4096K,NOTIFY=E1226,USER=E1226\n//*+-----------------------------------------------------<BOD>+\n//*|SYS: SINM   LLQ: CNTL                                     |\n//*|VER: 1.0       (C): SYSPRG1                               |\n//*|----------------------------------------------------------|\n//*|DESC: COMPILE XMCUTIL                                     |\n//*|DEP:                         SDBDC.MVS38J.PROCLIB(JCC037) |\n//*|----------------------------------------------------------|\n//*|SYSPRG1   12/11/17     NEUERSTELLUNG                      |\n//*+-----------------------------------------------------<EOD>+\n//***************************************************************\n//S010     EXEC JCC037,SDSN='SYSW.M38K.CBT999.INST',MEM='XMCUTIL'\n//LINK.SYSLMOD DD DISP=SHR,DSN=SDBDC.MVS38J.LOAD(XMCUTIL)\n//***************************************************************\n//RUNPGM  EXEC PGM=IKJEFT01,REGION=4096K\n//STEPLIB   DD DISP=SHR,DSN=SDBDC.MVS38J.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//STDERR   DD SYSOUT=*\n//STDOUT   DD SYSOUT=*\n//SYSTSIN  DD *\n  XMCUTIL HELP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "X86ZIP": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x00/\\x01\\x17\\x00/!\\x07\\x04B\\x04B\\x00\\x00\\xc5\\xf1\\xf2\\xf2\\xf6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-02T00:00:00", "modifydate": "2017-01-02T21:07:00", "lines": 1090, "newlines": 1090, "modlines": 0, "user": "E1226"}, "mimetype": "application/zip", "datatype": "binary", "extension": ".zip"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT776/FILE776.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT776", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}