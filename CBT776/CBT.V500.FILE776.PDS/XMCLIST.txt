/*+---------------------------------------------------------------------<bod>+*/
/*!sys: SINM      llq: SOURCE                                                !*/
/*!ver: 0.1.26    (c): E1226                                                 !*/
/*!--------------------------------------------------------------------------!*/
/*!desc: XMC XMIT Information Tool                                           !*/
/*!desc: record c segments and optional raw extract of a po mem              !*/
/*!--------------------------------------------------------------------------!*/
/*!E1226   16/12/26     0.1.26 EATTR and stdout                              !*/
/*!E1226   16/12/25     0.1.25 restructured blocks                           !*/
/*!E1226   16/10/13     0.1.24 allow raw blocks if --cchhr                   !*/
/*!E1226   16/10/09     0.1.23 correct RECFM=U                               !*/
/*!E1226   16/09/30     0.1.22 message formatting                            !*/
/*!E1226   16/09/25     0.1.21 integrated common parm parsing                !*/
/*!E1226   16/09/17     0.1.20 os independent --replace                      !*/
/*!E1226   16/09/17     0.1.16 po / poe single mem extract full test ok      !*/
/*!E1226   16/09/17     0.1.15 do_directory review poe                       !*/
/*!E1226   16/09/17     0.1.14 do_directory review                           !*/
/*!E1226   16/09/17     0.1.14 do_copyr2 rework                              !*/
/*!E1226   16/09/16     0.1.13 do_copyr1 rework                              !*/
/*!E1226   16/08/15     0.0.59 fwrite to stdout                              !*/
/*!E1226   16/08/15     0.0.58 Extract HEX with all devt ok                  !*/
/*!E1226   16/08/13     0.0.50 conversion TTR CCHHR                          !*/
/*!E1226   16/08/11     0.0.43 EXTENT Infos COPYR2                           !*/
/*!E1226   16/08/07     0.0.38 DEVTYPE DASD                                  !*/
/*!E1226   16/08/06     0.0.36 dd: //dd: open                                !*/
/*!E1226   16/08/05     0.0.34 ispf alias processing                         !*/
/*!E1226   16/08/02     load format                                          !*/
/*!E1226   16/07/31     ssi format                                           !*/
/*!E1226   16/07/31     basic alias preocessing (non-u) regress MVS          !*/
/*!E1226   16/07/31     ispf dir ordered date                                !*/
/*!E1226   16/07/30     ispf dir julian date w/o alias                       !*/
/*!E1226   16/07/19     zzsprintf                                            !*/
/*!E1226   16/07/17     working version with multi member tested also regress!*/
/*!E1226   16/07/13     real block w/o segment len & desc                    !*/
/*+---------------------------------------------------------------------<eod>+*/
// #define X86
// #define LINUX
   #define MVS
   #define MVS43

char *procname;
#define __ZZPROC "xmclist"
#define __ZZVER "0.1.26"

#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#if defined X86
#include "@dcuser.h"   /* mine */
#endif
#if defined MVS
#include "@dcuser"     /* mine */
#endif

#define __BUILD __ZZPROC" (c) eho 2011/2016 Version "__ZZVER"  Build " \
        __DATE__" "__TIME__
//                                     /* build a POSIX comaptible parm env  */
//                                     /* parm keys are always upper case    */
//                                     /* parm values remain sensitive       */
#define PARMKEYU
#if defined X86
#define GPP    "--"
#define GDM    "??" //
#define GEQ    "="  // keyvalue =
#define GWBL 4096
#define G1   512
#endif

#if defined MVS
#define GPP    ""
#define GDM    "()" //
#define GEQ    ""   // keyvalue = not applicable
#define GWBL 4096
#define G1   60
#endif
                                // IEBCOPY COPYR1
//pedef struct COPYR1 GGCOPYR1;

char ggdsnx ÝG1+1¨= "";          // XMI File
char ggodsn ÝG1+1¨= "";          // Output DSN for Extract
char ggmem  Ý9¨   = "";          // Extract Member
int  ggrep        = 0;           // replace output flag
int  ggverb       = 0;           // verbose output
//
int  ggnoin       = 0;           // no infos
int  ggnoim       = 0;           // no inmr
int  ggnoie       = 0;           // no copyr1, copyr2
int  ggnodi       = 0;           // no dir
int  ggnoba       = 0;           // no basemen for alias
int  ggnocc       = 0;           // no cchh info
int  ggnomsg      = 0;           // no msg
int  ggcchhr      = 0;           // default no cchhr
int  ggeattr      = 0;           // default no eattr

int  ggoffp       = 0;           // offset in file previous
int  ggoffc       = 0;           // offset in file current
int  ggdbx        = 0;           // counter data record
char ggrecfmÝ8¨   = "";          // Record Format String
#if defined X86
#define ZZXE2A(a,b) zze2a(a,b)
#else
#define ZZXE2A(a,b)
#endif
//                                     /* extent  struct                     */
  static unsigned char ggmbbcchhrsÝ9¨ =
           {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  static unsigned char ggmbbcchhrpÝ9¨ =
           {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
//                                     /* extent  struct                     */
FILE *ggfo;
//                                     /* extent  struct                     */
struct         {
  unsigned int  ccs;
  unsigned int  hhs;
  unsigned int  ccp;
  unsigned int  hhp;
  unsigned int  tts;                   /* tt start                           */
  unsigned int  ttp;                   /* tt hi                              */
} gextÝ16¨;
unsigned int gextx = 0;

//                                     /* devtype struct                     */
#define GGDEVX 8
struct devtype {
  unsigned int  no;
  unsigned int  trk;
  char nameÝ5¨;
} ggdevtÝGGDEVX¨ = {0x00,00,"CCDA",   // current calced device attributes
                    0x08,19,"3330",
                    0x09,19,"3330",
                    0x0a,12,"3340",
                    0x0b,30,"3350",
                    0x0c,12,"3375",
                    0x0e,15,"3380",
                    0x0f,15,"3390"};

unsigned int ggdevtx;                  /* current device                     */
//                                     /* ttr - mem struct                   */
struct ggttr{
  int ttr;
  int cchhr;
  char memÝ9¨;
  int cc;
  int hh;
  int rec;
  int ext;
} ggttr;
//                                     /* ttr - member                       */
struct ggttr *ggpm;
char *ggrm;
int ggpml,ggpmc=0,ggpmx=0;
#define ggpmI 100
//                                     /* ttr - alias                        */
struct ggttr *ggpa;
char *ggra;
int ggpal,ggpac=0,ggpax=0;
#define ggpaI 30
//                                     /* ttr - mem struct                   */
/*****************************************************************************/
/* F U N C T I O N S  COMMON                                                 */
/*****************************************************************************/
/**0200***********************************************************************/
/* do_msg()                                                                  */
/* - common message formatting and suppression                               */
/*****************************************************************************/
int do_msg(int rc,char *msg, ...) {

  char tbufÝ256¨ = "";

  va_list args;
  if (ggnomsg) return (rc);
  va_start (args, msg);

  vsnprintf(tbuf+0,256-0,msg,args);
  sysprint("*NO",tbuf);

  va_end (args);
  return (rc);
}
/**0110***********************************************************************/
/* ttrcomp()                                                                 */
/*   sort condition                                                          */
/*****************************************************************************/
int ttrcomp(const void * a, const void * b)
{
  return ( *(int*)a - *(int*)b );
}
/**0120***********************************************************************/
/* xxstrip()                                                                 */
/*   strip quotes                                                            */
/*****************************************************************************/
 int  xxstrip(char *buf, char *quote) {

  int i,j,l;

  j = 0;
  l = strlen(buf);
  for (i=0;i<l;i++) {
    if (bufÝi¨ != quoteÝ0¨) {bufÝj¨ = bufÝi¨; j++;}
    else bufÝj¨ = 0x00;
  }
  return strlen(buf);
}
/**0130***********************************************************************/
/* xxopen()                                                                  */
/*   open a file                                                             */
/*****************************************************************************/
FILE * xxopen(char *fname,char *fopts) {

  FILE *fh;
  unsigned char optsÝ30¨;

  #if defined X86
  fh = 0; fh = zzopen(fname,fopts);
  #else
  zzstrupr(fname);
  fh = 0;

//printf("** fname: (%s) (%s) **\n",fname,fopts);

  if      (!memcmp(fname,"DD:",3)) {
    sprintf(opts,"%s,DD",fopts);
    fh = zzopen(fname+3,opts);
//  printf("xxopen: (%d) (%s) (%s) **\n",fh,fname,opts);
  }
  else if (!memcmp(fname,"//DDN:",6)) {
    sprintf(opts,"%s,DD",fopts);
    fh = zzopen(fname+6,opts);
//  printf("xxopen: (%d) (%s) (%s) **\n",fh,fname,opts);
  }
  else fh = zzopen(fname,fopts);
  #endif

  return fh;
}
/**0208***********************************************************************/
/* do_eattr()                                                                */
/* - dump extented attributes                                                */
/*****************************************************************************/
int do_eattr(unsigned char *sbuf,int ln) {

  int i,j,k,m,rc=0,prc=0;char *prn="do_eattr";     /* commons               */

  #define MB 16

  char lbufÝMB*3+MB+20¨;
  char abufÝMB+1¨;
  unsigned char c;
  char *pp;
  /***************************************************************************/
  sysprint("*NO","XMU0002I Dump of unloaded Attributes for %s:",ggmem);

  j = 0;
  sprintf(lbuf,"+ %06X: ",0);
  memset(abuf,0x0,MB);

  for (i=0;i<ln;i++) {
    c = sbufÝi¨;
    zzsprintf(lbuf,"%02.2X",c);
    abufÝj¨ = sbufÝi¨;
    j++;
    if (j%4 == 0) zzsprintf(lbuf," ");

    if (j>=MB) {
      zze2a(abuf,MB);
      for (k=0;k<MB;k++) if (abufÝk¨ < 32 || abufÝk¨ > 128) abufÝk¨ = '.';
      abufÝMB¨ = 0x0;
      zzsprintf(lbuf,"!%s!" ,abuf);
      sysprint("*NO",lbuf);
      j = 0;
      sprintf(lbuf,"+ %06X: ",i+1);
      memset(abuf,0x0,MB);
    }
  }

  if (j>0) {
    for (k=j;k<MB;k++) {
      zzsprintf(lbuf,"%02.2X",0xFF);
      j++;
      if (j%4 == 0) zzsprintf(lbuf," ");
    }
    zze2a(abuf,MB);
    for (k=0;k<MB;k++) if (abufÝk¨ < 32 || abufÝk¨ > 128) abufÝk¨ = '.';
    abufÝMB¨ = 0x0;
    zzsprintf(lbuf,"!%s!" ,abuf);
    sysprint("*NO",lbuf);
  }
  /***************************************************************************/
  EE:
  return (prc);
}
/**0208***********************************************************************/
/* do_copen()                                                                */
/* - conditional open                                                        */
/*****************************************************************************/
FILE * do_copen(char *fname) {

  static FILE *fo;

  int i,j,k,m,rc=0,prc=0;char *prn="do_copen";      /* commons               */

  if (!fnameÝ0¨) goto EE;               /* no filename procided              */
  /***************************************************************************/
  if (!ggrep) {
    fo = xxopen(fname,"rb");
    if (fo) {
      prc=do_msg(8,"XMU0302E Replace not specified for %s.",fname);
      fclose(fo);
      fo = NULL;
      goto EE;
    } // >> else no open file
  }

  // ***************                /* here we can open safe write   */
  fo = xxopen(fname,"wb");
  if (!fo) {
    prc=do_msg(8,"XMU0303E Open Failed Output %s.",fname);
    fo = NULL;
    goto EE;
  }
  /***************************************************************************/
  EE:
  return (fo);
}
/**0210***********************************************************************/
/* do_mbbcchhr()                                                             */
/*****************************************************************************/
int  do_mbbcchhr(char *mem,unsigned char *s, unsigned char *p) {

  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */
//int ccw,ttw,rrw;
  char wbÝ100¨ = "";
//char wcÝ100¨ = "";
  unsigned char rmemÝ9¨;
  /***************************************************************************/
  sprintf(rmem,"%-8.8s",mem);

  sÝ0¨ = 0; sÝ1¨ = 0xFF;
  sÝ2¨ = 0; sÝ3¨ = 0;
  sÝ4¨ = 0; sÝ5¨ = 0;
  sÝ6¨ = 0; sÝ7¨ = 0;
  sÝ8¨ = 0;

  memcpy(p,s,9);

  for (i=0;i<ggpmx;i++) {
    if (!memcmp(ggpmÝi¨.mem,rmem,8)) {
      sÝ0¨ = 0; sÝ1¨ = ggpmÝi¨.ext;
      sÝ2¨ = 0; sÝ3¨ = 0;
      sÝ4¨ = ggpmÝi¨.cc/256; sÝ5¨ = ggpmÝi¨.cc%256;
      sÝ6¨ = ggpmÝi¨.hh/256; sÝ7¨ = ggpmÝi¨.hh%256;
      sÝ8¨ = ggpmÝi¨.rec;

      break;
    }
  }
//sprintf(wb," S ");
//for(j=0;j<9;j++) zzsprintf(wb," %02x",sÝj¨);
//sysprint("<%s> %d %d",wb,i,ggpmx);

  //                                       /* member not found S:0xFF P:0xFF */
  if (sÝ1¨ == 0xFF) return sÝ1¨;
  //                                       /* last mem. no i++ S:0xnn P:0xFF */
  if (i == ggpmx-1)  return 0;
  //                                       /* start of nxt mem S:0xnn P:0xoo */
  i++;
  pÝ0¨ = 0; pÝ1¨ = ggpmÝi¨.ext;
  pÝ2¨ = 0; pÝ3¨ = 0;
  pÝ4¨ = ggpmÝi¨.cc/256; pÝ5¨ = ggpmÝi¨.cc%256;
  pÝ6¨ = ggpmÝi¨.hh/256; pÝ7¨ = ggpmÝi¨.hh%256;
  pÝ8¨ = ggpmÝi¨.rec;

//sprintf(wb," P ");
//for(j=0;j<9;j++) zzsprintf(wb," %02x",pÝj¨);
//sysprint("<%s> %d %d",wb,i,ggpmx);
  /***************************************************************************/
  EE:
  return (prc);
}
/**0220***********************************************************************/
/* do_cchh()                                                                 */
/*****************************************************************************/
int  do_cchh(int ttr, int *cc,int *hh, int *rec) {

  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */
  int ccw,ttw,rrw;
  /***************************************************************************/
  *rec = ttr % 256;
  *hh  = ttr / 256;

  prc = 99;

  for(i=0;i<16;i++) {
    if (*hh > gextÝi¨.ttp)  continue;

    rrw = ggdevtÝggdevtx¨.trk;
    ttw = *hh - gextÝi¨.tts;

    ttw =  gextÝi¨.ccs * rrw + gextÝi¨.hhs + ttw;

    *cc  =  ttw / rrw;
    *hh  =  ttw % rrw;
    prc = i;
    break;
  }
  /***************************************************************************/
  EE:
  return (prc);
}
/**0230***********************************************************************/
/* do_basemem()                                                              */
/*---------------------------------------------------------------------------*/
/* F:  sysprint                                                              */
/* F:  zzc2d                                                                 */
/* F:  zzsprintf                                                             */
/* M:  ZZXE2A                                                                */
/* G:  ggpaI                                                                 */
/* G:  ggra                                                                  */
/* G:  ggpa                                                                  */
/* G:  ggpax                                                                 */
/* G:  ggpm                                                                  */
/* G:  ggpmx                                                                 */
/*****************************************************************************/
int  do_basemem() {

  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */
  /***************************************************************************/
  m = 0;
  for (i=0;i<ggpax;i++) {
    k = 0;
    for (j=m;j<ggpmx;j++) {
      if (ggpaÝi¨.ttr == ggpmÝj¨.ttr) {
        sysprint("*NO","-ALIAS   %s basemem %s",ggpaÝi¨.mem,ggpmÝj¨.mem);
        k = 1; m = j;
        break;
      }
    }
    if (!k) sysprint("*NO","-ALIAS   %s basemem %s",ggpaÝi¨.mem,"**NONE**");
  }
  prc = 234;
  /***************************************************************************/
  EE:
  return (prc);
}
/**0240***********************************************************************/
/* do_loadstat()                                                             */
/* - SYS1.MODGEN(IHAPDS)                                                     */
/* - MVS Program Management: Advanced Facilities                             */
/* - format load                                                             */
/*      -reset -1 for PDS2INDC (len & count TTR)                             */
/*---------------------------------------------------------------------------*/
/* M:  ZZXE2A                                                                */
/* F:  zzc2d                                                                 */
/* F:  zzsprintf                                                             */
/*****************************************************************************/
int  do_loadstat(unsigned char *sbuf, unsigned char *lbuf) {

  int i,j,k,m,n,rc=0,prc=0;                         /* commons               */

  unsigned char wbufÝ20¨;
  int len;
  unsigned char *p1;
  unsigned char *p2;
  unsigned char xl = 0x0;

  unsigned int  size = 0;
  unsigned char aliasÝ9¨ = "........";
  unsigned char acÝ4¨ = "...";
  unsigned char dcfoÝ3¨ = "..";
  unsigned char ep0Ý4¨ = "...";
                 //
  unsigned char olÝ3¨ = "..";
  unsigned char scÝ3¨ = "..";
  unsigned char pgÝ3¨ = "..";
  unsigned char rfÝ3¨ = "..";
  unsigned char rnÝ3¨ = "..";
  unsigned char ruÝ3¨ = "..";
                //
  unsigned char amÝ5¨ = "..";
  unsigned char rmÝ5¨ = "..";
                //
  unsigned int  ssi = 0;

  /***************************************************************************/
  p1 = sbuf-12;
  len = sbufÝ-1¨;
  len = (len & 0x1F)*2;

//  for (i=-1;i<len;i++) { zzsprintf(lbuf," %02x",sbufÝi¨); }

                                    /* EXTENSION: Type   Stor Loc  Test LDec */
                                    /*            SCTR   0x80 0x14 0x04   20 */
                                    /*            ALIAS  0x40 0x0B 0x80   11 */
                                    /*            SSI    0x20 0x1E 0x10   30 */
                                    /*            APF    0x10 0x1E 0x08   30 */
                                    /*            LPO    0x08 0x1E 0x40   30 */
                                            /* SCTR                          */
  m = zzc2d(p1+20,1); if (m & 0x04) xl = xl | 0x80;
  m = zzc2d(p1+11,1); if (m & 0x80) xl = xl | 0x40;
  m = zzc2d(p1+30,1); if (m & 0x10) xl = xl | 0x20;
  m = zzc2d(p1+30,1); if (m & 0x08) xl = xl | 0x10;
  m = zzc2d(p1+30,1); if (m & 0x40) xl = xl | 0x08;

//  zzsprintf(lbuf," (%02X)",xl);
//  zzsprintf(lbuf,"\nL:%d",len);
  //                                        /* ** PDS offset 0x16 ** 22      */
                                            /* SIZE in HEX                   */
  size = zzc2d(p1+22,3);
  //                                        /* ** PDS offset 0x14 ** 20      */
  m = zzc2d(p1+20,1);
  if (m & 0x80) strcpy(rn,"RN");            /* ATTR 1  Bit 0  Reentrant      */
  if (m & 0x40) strcpy(ru,"RU");            /* ATTR 1  Bit 1  Reusable       */
  if (m & 0x08) strcpy(ol,"OL");            /* ATTR 1  Bit 4  LoadOnly       */
  if (m & 0x04) strcpy(ol,"SC");            /* ATTR 1  Bit 5  Scatter        */
  //                                        /* ** PDS offset 0x15 ** 21      */
  m = zzc2d(p1+21,1);
  if (m & 0x80) strcpy(dcfo,"FO");          /* ATTR 2  Bit 1  DC/FO          */
  else          strcpy(dcfo,"DC");          /* ATTR 2  Bit 1  DC/FO          */

  if (m & 0x20) strcpy(ep0,"EP0");          /* ATTR 2  Bit 2  EP0 zero       */
  else {
    n = zzc2d(p1+27,3);
    sprintf(ep0,"EP%06X",n);
  }
  if (m & 0x01) strcpy(rf,"RF");            /* ATTR 2  Bit 7  Refresh        */
  //                                        /* ** PDS offset 0x1E ** 30      */
  m = zzc2d(p1+30,1);
  if (m & 0x20) strcpy(pg,"PG");            /* 2FTBO 1 Bit 2  Page Boundary  */

  //                                        /* ** PDS offset 0x1F ** 31      */
  m = zzc2d(p1+31,1);
  if (m & 0x10) strcpy(rm,"RANY");          /* 2FTBO 2 Bit 3  RMODE          */
  else          strcpy(rm,"RM24");          /* 2FTBO 2 Bit 3  AMODE          */

  if ((m & 0x03)== 0x00) strcpy(am,"AM24"); /* 2FTBO 2 Bit 67 AMODE          */
  if ((m & 0x03)== 0x02) strcpy(am,"AM31"); /* 2FTBO 2 Bit 67 AMODE          */
  if ((m & 0x03)== 0x01) strcpy(am,"AM64"); /* 2FTBO 2 Bit 67 AMODE          */
  if ((m & 0x03)== 0x03) strcpy(am,"AANY"); /* 2FTBO 2 Bit 67 AMODE          */
  /***************************************************************************/
  //                                        /* ** PDS offset 0x21 ** 33      */
  p2 = p1+33;                               // Start of sections
  //
  //                                        /* SKIP SCATTER                  */
  if (xl & 0x80) k = zzc2d(p2,2);           /* len of SCATTER section        */
  else         k = 0;
  p2 = p2 +k;
  //                                        /* IF ALIAS                      */
  //                                        /* len of ALIAS section is 11    */
  if (xl & 0x40) {
    memcpy(alias,p2+3,8); ZZXE2A(alias,8);
    p2 = p2 +11;
  }
  //                                        /* IF SSI                        */
  //                                        /* len of SSI is 4 or 5 HW Bound */
    wbufÝ0¨ = 0x0;
  if (xl & 0x20) {
    if ( (p2-p1)%2) p2++;
    sprintf(wbuf,"SSI:");
    for (i=0;i<4;i++) zzsprintf(wbuf,"%02x",(p2+i)Ý0¨);
    p2 = p2 +4;
  }
  //                                        /* IF APF                        */
  //                                        /* b0:len b1:code. We consier onl*/
  //                                        /* one byte                      */
  if (xl & 0x10) {
    m = zzc2d((p2+1),1);
    sprintf(ac,"AC%1.1d",m);
  }

  n = p2-p1;

  zzsprintf(lbuf," %06X %-8.8s %-3.3s %2.2s %-8.8s"
                  " %2s %2s %2s %2s %2s %2s"
                  " %4s %4s %s"
                  "",
                    size,alias,ac,dcfo,ep0,
                    ol,sc,pg,rf,rn,ru,
                    am,rm,wbuf);
  /***************************************************************************/
  EE:
  return (prc);
}
/**0250***********************************************************************/
/* do_ssistat()                                                              */
/* - format not load ssi                                                     */
/*---------------------------------------------------------------------------*/
/* F:  zzbcd2i                                                               */
/* F:  zzsprintf                                                             */
/*****************************************************************************/
int  do_ssistat(unsigned char *sbuf, unsigned char *lbuf) {

  int i,j,k,m,rc=0,prc=0;                           /* commons               */

  unsigned char wbufÝ10¨;
  /***************************************************************************/
  k = zzbcd2i(sbuf+0,8);
  zzsprintf(lbuf," SSI:%08d",k);
  /***************************************************************************/
  EE:
  return (prc);
}
/**0260***********************************************************************/
/* do_ispfstat()                                                             */
/* - format ispf statistics available                                        */
/*---------------------------------------------------------------------------*/
/* M:  ZZXE2A                                                                */
/* F:  zzc2d                                                                 */
/* F:  zzbcd2i                                                               */
/* F:  zzispfdate                                                            */
/* F:  zzsprintf                                                             */
/*****************************************************************************/
int  do_ispfstat(unsigned char *sbuf, unsigned char *lbuf) {

  int i,j,k,m,rc=0,prc=0;                           /* commons               */

  unsigned char wbufÝ10¨;
  /***************************************************************************/
  j = zzc2d(sbuf+0,1);
  zzsprintf(lbuf," %02.2d",j);
  j = zzc2d(sbuf+1,1);
  zzsprintf(lbuf,".%02.2d",j);
  //***************                        /* Change DATE                    */
  k = zzbcd2i(sbuf+4,2);
  if (k == 0) k = zzbcd2i(sbuf+5,2) + 1900;
  else        k = zzbcd2i(sbuf+5,2) + 2000;
  j = zzbcd2i(sbuf+6,3);

  m = zzispfdate(k,j);
  j = m % 100;
  m = m / 100;
  zzsprintf(lbuf," %04d.%02d.%02d",k,m,j);
  //***************                        /* CREATE DATE                    */
  k = zzbcd2i(sbuf+8,2);
  if (k == 0) k = zzbcd2i(sbuf+9,2) + 1900;
  else        k = zzbcd2i(sbuf+9,2) + 2000;
  j = zzbcd2i(sbuf+10,3);

  m = zzispfdate(k,j);
  j = m % 100;
  m = m / 100;
  zzsprintf(lbuf," %04d.%02d.%02d",k,m,j);
  //***************                        /* Change Time                    */
  j = (sbuf+12)Ý0¨;
  zzsprintf(lbuf," %2x",j);
  j = (sbuf+13)Ý0¨;
  zzsprintf(lbuf,":%02x",j);
                                           /* SIZE lines                     */
  j = zzc2d(sbuf+14,2);
  zzsprintf(lbuf," %5d",j);
                                           /* INIT lines                     */
  j = zzc2d(sbuf+16,2);
  zzsprintf(lbuf," %5d",j);
                                           /* MOD  lines                     */
  j = zzc2d(sbuf+18,2);
  zzsprintf(lbuf," %5d",j);
                                           /* ID                             */
  memcpy(wbuf,sbuf+20,8); ZZXE2A(wbuf,8);
  zzsprintf(lbuf," %8.8s",wbuf);

  /***************************************************************************/
  EE:
  return (prc);
}
/**0270***********************************************************************/
/* do_directory()                                                            */
/*  00  08          00 00 00 00 00 00 00 00            dirblock start        */
/*  08  02          00 08                                                    */
/*  10  02          01 00                              dirblock len          */
/*  12  08          C3 C9 F4 F2 C1 40 40 40                                  */
/*  20  02          00 E0                              sum bytes dire recs   */
/*  22  ...         ...                                first entry           */
/*  ------------------------------------------------------------------------ */
/*                  20 + 224                           first entry           */
/*---------------------------------------------------------------------------*/
/* RC: 200     getmain error                                                 */
/* RC: 1       EODir                                                         */
/* F:  do_loadstat                                                           */
/* F:  do_ssistat                                                            */
/* M:  do_ispfstat                                                           */
/* F:  sysprint                                                              */
/* F:  zzc2d                                                                 */
/* F:  zzsprintf                                                             */
/* M:  ZZXE2A                                                                */
/* G:  ggpaI                                                                 */
/* G:  ggra                                                                  */
/* G:  ggpa                                                                  */
/* G:  ggpac                                                                 */
/* G:  ggpal                                                                 */
/* G:  ggpax                                                                 */
/* G:  ggpmI                                                                 */
/* G:  ggrm                                                                  */
/* G:  ggpm                                                                  */
/* G:  ggpmc                                                                 */
/* G:  ggpml                                                                 */
/* G:  ggpmx                                                                 */
/* G:  ggttr                                                                 */
/* G:  ggrecfm                                                               */
/*****************************************************************************/
int  do_directory(unsigned char *sbuf, int blen) {

  int i,j,k,m,rc=0,prc=0; char *prn="do_directory";  /* commons               */
//int i,ip,j,k,m,ss,rc=0,prc=0;                      /* commons               */
  int q,r,s;

  unsigned char  *lbuf;
  unsigned char  *abuf;
  unsigned char  ep;
  unsigned char  asÝ2¨;
  unsigned char  *p1, *p2;
  unsigned char  himemÝ¨ = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
  unsigned char  alias = 0;

  if (ggnodi == 1) prc=do_msg(0,"XMC0016I Info DIRECTORY Output suppressed.");
  if (ggnodi) {ggnodi++;}
  /***************************************************************************/
  lbuf=malloc(1024);
  if (!lbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}
  abuf=malloc(1024);
  if (!abuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}

  i = 0;
  m = 276;
  while (i < blen) {
    if ((i+m) > blen) m = blen - i;
    else              m = 276;

    p1 = sbuf+i+20;

    q = zzc2d(p1,2);
    sprintf(lbuf,"%2d :",q);
    p1 = p1+2;
    p2 = p1+q-2;

    while (p1 < p2) {
      //sprintf(lbuf,"%d %d:",p1,p2);
      lbufÝ0¨ = 0x0;
      //                                   /*  0  0  8 member name       */
      memcpy(abuf,p1,8);
      //                                   /*  ebcdic FFFFFFFFFFFFFFFF   */
      if (!memcmp(abuf,himem,8)) {
        prc=1;
        goto EE;
      }
      abufÝ8¨ = 0x0;ZZXE2A(abuf,8);
      //                                   /*  0 11  1 alias flag        */
      s = zzc2d((p1+8+3),1);
      s = (s & 0x80);
      //                                   /*  8  -  - offset            */
      p1 = p1+8;
      //                                   /*  8  8  3 ttr               */
      //                                   /* 11  -  - offset            */
      r = zzc2d(p1,3);
      p1 = p1+3;
//                                         /* RECFM U basemem in record  */
//                                         /* ISPF aliasses comp with ttr*/
//                                         /* we need memttr vector for  */
//                                         /* extract also for recfm U   */
//   if (ggrecfm == 'U') {
//      if (s) {zzsprintf(lbuf," %8s A",abuf); ggpax++;}
//      else   {zzsprintf(lbuf," %8s -",abuf); ggpmx++;}
//    }
//    else  {
        if (s) {
          lbufÝ0¨ = 0x0;
          ggpac = ggpac+sizeof(ggttr);
          if (ggpac > ggpal) {
            ggpal = ggpal + sizeof(ggttr)*ggpaI;
            ggra = realloc(ggra,ggpal);
          }
          ggpa = (struct ggttr*)(ggra+ggpac-sizeof(ggttr));
          ggpa->ttr = r;
          memcpy(ggpa->mem,abuf,8); ggpa->memÝ8¨ = 0x0;
          ggpax++;

          zzsprintf(lbuf," %8s A",abuf);
        }
        else {
          ggpmc = ggpmc+sizeof(ggttr);
          if (ggpmc > ggpml) {
            ggpml = ggpml + sizeof(ggttr)*ggpmI;
            ggrm = realloc(ggrm,ggpml);
          }
          ggpm = (struct ggttr*)(ggrm+ggpmc-sizeof(ggttr));
          ggpm->ttr = r;
          memcpy(ggpm->mem,abuf,8); ggpm->memÝ8¨ = 0x0;
          ggpmx++;

          zzsprintf(lbuf," %8s -",abuf);
        }
//    }
//                                         /* TTR END       ************ */
//                                         /* print TTR     ************ */
      zzsprintf(lbuf," %06x",r);
//                                         /* 11 11  1 ttr               */
//                                         /* 12  -  - offset            */
      s = zzc2d(p1,1);
      s = (s & 0x1F)*2;
      p1 = p1+1;

      if (ggrecfmÝ0¨ == 'U') {
        do_loadstat(p1,lbuf);
      }
      else if (s == 4)    do_ssistat(p1,lbuf);
      else if (s == 30)   do_ispfstat(p1,lbuf);
//                                         /*  s  -  - offset            */
      p1 = p1+s;

      if (!ggnodi) sysprint("*NO",lbuf);
    }
    i = i + 276;
  }
  /***************************************************************************/
  EE:
  if (abuf) free(abuf);
  if (lbuf) free(lbuf);
  return (prc);
}
/**0280***********************************************************************/
/* do_copyr1()                                                               */
/* - COPYR2 gather extent info                                               */
/* - Kenneth Tomiak, Danal Estes, Dave Alcock                                */
/* - DFSMSdfp Utilities                                                      */
/* - dasdblks.h                                                              */
/* - DEVTYPE                                                                 */
/* - kretrecv.rexx                                                           */
/* > is it a pds ?                                                           */
/* > recfm                                                                   */
/* > devicetype                                                              */
/*---------------------------------------------------------------------------*/
/* RC: 8       not a PDS/PDSE                                                */
/* F:  sysprint                                                              */
/* F:  zzc2d                                                                 */
/* F:  zzsprintf                                                             */
/* G:  ggrecfm                                                               */
/* G:  GGDEVX                                                                */
/* G:  ggdevt                                                                */
/* G:  ggdevtx                                                               */
/* G:  COPYR1 struct                                                         */
/*****************************************************************************/
int  do_copyr1(unsigned char *sbuf, int blen) {

  int i,j,k,m,rc=0,prc=0; char *prn="do_copyr1";    /* commons               */
  unsigned char  *lbuf = 0x0;
  unsigned char  *cpfx = "-IEBCOPY  COPYR1 ";

  struct COPYR1 *pp;
  unsigned int w,u,ss=0;
  /***************************************************************************/
  //                                                /* we suppress all COPYR1*/
  //                                                /* but give a message 1st*/
  //                                                /* WORK CONTINUES        */
  if (ggnoie == 1) prc=do_msg(0,"XMC0016I Info COPYR1 Output suppressed.");
  if (ggnoie) {ss=1; ggnoie++;}
  /***************************************************************************/
  lbuf=malloc(1024);
  if (!lbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}

  pp = (struct COPYR1*)sbuf;
  //                                           /* header FWORD               */
  u = pp->uldfmt;
  w = zzc2d(pp->hdrid,3);
  strcpy(lbuf,cpfx);
  //                                           /* Give Info about Input DSN  */
  prc=do_msg(0,"XMC0014I Signature is %02x %06x",pp->uldfmt,
                                          zzc2d(pp->hdrid,3));
  if (w != 0xca6d0f) {
     prc=do_msg(8,"XMC0230E Not a Unloaded PDS or PDSE Dataset."); goto EE;}
  if (u == 1) do_msg(0,"XMC0015I Unload Dataset is a PDSE");
  if (u == 0) do_msg(0,"XMC0015I Unload Dataset is a PDS");
  //                                           /* opt: DSORG                 */
  strcpy(lbuf,cpfx); zzsprintf(lbuf,"DSORG:    ");
  u = zzc2d(pp->ds1dsorg,2);
  if (u& 0x8000) zzsprintf(lbuf,"ISAM");
  if (u& 0x4000) zzsprintf(lbuf,"PS");
  if (u& 0x2000) zzsprintf(lbuf,"DA");
  if (u& 0x0200) zzsprintf(lbuf,"PO");
  if (u& 0x0001) zzsprintf(lbuf,"U");
  if (!ss) sysprint("*NO",lbuf);
  //                                           /* opt: BLKSIZE               */
  strcpy(lbuf,cpfx); zzsprintf(lbuf,"BLKSIZE:  ");
  u = zzc2d(pp->ds1blkl,2); zzsprintf(lbuf,"%5.5d",u);
  if (!ss) sysprint("*NO",lbuf);
  //                                           /* opt: LRECL                 */
  strcpy(lbuf,cpfx); zzsprintf(lbuf,"LRECL:    ");
  u = zzc2d(pp->ds1lrecl,2); zzsprintf(lbuf,"%5.5d",u);
  if (!ss) sysprint("*NO",lbuf);
  //                                           /* opt: RECFM                 */
  strcpy(lbuf,cpfx); zzsprintf(lbuf,"RECFM:    ");
  u = pp->ds1recfm;

  k = strlen(lbuf);
  if ((u& 0xC0) == 0xC0) zzsprintf(lbuf,"U");
  else if (u& 0x80)      zzsprintf(lbuf,"F");
  else if (u& 0x40)      zzsprintf(lbuf,"V");
  else                   zzsprintf(lbuf,"?");
  if (u& 0x10)           zzsprintf(lbuf,"B");
  if (u& 0x20)           zzsprintf(lbuf,"T");
  if (u& 0x08)           zzsprintf(lbuf,"S");
  if (u& 0x04)           zzsprintf(lbuf,"A");
  if (u& 0x02)           zzsprintf(lbuf,"M");
  strncpy(ggrecfm,lbuf+k,6);

  if (!ss) sysprint("*NO",lbuf);
  //                                           /* DEVTAB                     */
  u = zzc2d(pp->ucbtype+3,1);
  ggdevtx = 0;
  for (i=0;i<GGDEVX;i++) {
    if (ggdevtÝi¨.no == u) {ggdevtx = i; break; }
  }

  w = zzc2d(pp->heads,2);
  if (!ggdevtx) ggdevtÝggdevtx¨.trk = w;

  strcpy(lbuf,cpfx); zzsprintf(lbuf,"DEVTAB:   ");
  zzsprintf(lbuf,"Type %s Trk/Cyl %d",ggdevtÝggdevtx¨.name,ggdevtÝggdevtx¨.trk);
  if (!ss) sysprint("*NO",lbuf);
  /***************************************************************************/
  EE:
  if (lbuf) free(lbuf);
  return (prc);
}
/**0290***********************************************************************/
/* do_copyr2()                                                               */
/* - COPYR2 gather extent info                                               */
/* - Kenneth Tomiak, Danal Estes, Dave Alcock                                */
/* - DFSMSdfp Utilities                                                      */
/*---------------------------------------------------------------------------*/
/* RC: 200     getmain error                                                 */
/* F:  sysprint                                                              */
/* F:  zzc2d                                                                 */
/* F:  zzsprintf                                                             */
/* G:  gext                                                                  */
/* G:  ggdevt                                                                */
/* G:  ggdevtx                                                               */
/*****************************************************************************/
int  do_copyr2(unsigned char *sbuf, int blen) {

  int i,j,k,m,n,q,rc=0,prc=0; char *prn="do_copyr2";/* commons               */
  int cs,cp;

  unsigned char  *lbuf;
  unsigned char  *cpfx = "-IEBCOPY  COPYR2 ";

  if (ggnoie >  1) prc=do_msg(0,"XMC0016I Info COPYR2 Output suppressed.");
  /***************************************************************************/
  lbuf=malloc(1024);
  if (!lbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}

  cs = 0;
  for(i=0;i<16;i++) {
    strcpy(lbuf,cpfx);
    zzsprintf(lbuf," Extent %02d CCx.HHx:",i);
    k = 22+(i*16);

    m = zzc2d(sbuf+k+0,2);   gextÝi¨.ccs = m;
    m = zzc2d(sbuf+k+2,2);   gextÝi¨.hhs = m;
    m = zzc2d(sbuf+k+4,2);   gextÝi¨.ccp = m;
    m = zzc2d(sbuf+k+6,2);   gextÝi¨.hhp = m;

    zzsprintf(lbuf," %04X",gextÝi¨.ccs);
    zzsprintf(lbuf,".%04X",gextÝi¨.hhs);
    zzsprintf(lbuf," %04X",gextÝi¨.ccp);
    zzsprintf(lbuf,".%04X",gextÝi¨.hhp);

    m = gextÝi¨.ccs * ggdevtÝggdevtx¨.trk + gextÝi¨.hhs;
    n = gextÝi¨.ccp * ggdevtÝggdevtx¨.trk + gextÝi¨.hhp;

    q = n-m;
    cp = q + cs;
    //                                    /* test stop instead of start      */
    //                                    /* PDSE starts always at 0000.0000 */
    if (gextÝi¨.ccp || gextÝi¨.hhp) {
      gextÝi¨.tts = cs;
      gextÝi¨.ttp = cp;
      cs = cs+q+1;

      zzsprintf(lbuf," TTs: %04X TTp: %04X Len: %5d Trks",
               gextÝi¨.tts,gextÝi¨.ttp,q+1);
      if (!ggnoie) sysprint("*NO",lbuf);
    }
  }
  /***************************************************************************/
  EE:
  if (lbuf) free(lbuf);
  return (prc);
}
/**0300***********************************************************************/
/* do_ftxtunit()                                                             */
/* - format INMR textunits                                                   */
/*---------------------------------------------------------------------------*/
/* RC: 200     getmain error                                                 */
/* F:  sysprint                                                              */
/* F:  zzc2d                                                                 */
/* F:  zzsprintf                                                             */
/* M:  ZZXE2A                                                                */
/*****************************************************************************/
int  do_ftxtunit(char *inmr, int fno, unsigned char *tp , int tlen) {

  #define TUL 31

  struct TUNITS {
    int no;
    char nameÝ9¨;
    unsigned char format;
  } tunitsÝTUL¨ = {
      { 0x0001, "INMDDNAM", 'C'},
      { 0x0002, "INMDSNAM", 'C'},
      { 0x0003, "INMMEMBR", 'C'},
      { 0x000B, "INMSECND", 'X'},
      { 0x000C, "INMDIR  ", 'D'},
      { 0x0022, "INMEXPDT", 'D'},
      { 0x0028, "INMTERM ", 'X'},
      { 0x0030, "INMBLKSZ", 'D'},
      { 0x003C, "INMDSORG", 'X'},
      { 0x0042, "INMLRECL", 'D'},
      { 0x0049, "INMRECFM", 'X'},
      { 0x1001, "INMTNODE", 'C'},
      { 0x1002, "INMTUID ", 'C'},
      { 0x1011, "INMFNODE", 'C'},
      { 0x1012, "INMFUID ", 'C'},
      { 0x1020, "INMLREF ", 'X'},
      { 0x1021, "INMLCHG ", 'X'},
      { 0x1022, "INMCREAT", 'X'},
      { 0x1023, "INMFVERS", 'X'},
      { 0x1024, "INMFTIME", 'C'},
      { 0x1025, "INMTTIME", 'X'},
      { 0x1026, "INMFACK ", 'X'},
      { 0x1027, "INMERRCD", 'X'},
      { 0x1028, "INMUTILN", 'C'},
      { 0x1029, "INMUSERP", 'X'},
      { 0x102A, "INMRECCT", 'X'},
      { 0x102C, "INMSIZE ", 'D'},
      { 0x102F, "INMNUMF ", 'D'},
      { 0x8012, "INMTYPE ", 'X'},
      { 0x8018, "INMLSIZE", 'D'},
      { 0x8028, "INMEATTR", 'X'}
   };
  /***************************************************************************/
  int i,j,k,m,rc=0,prc=0; char *prn="do_ftxtunit";  /* commons               */

  unsigned short key;
  unsigned short len;
  unsigned short cnt;
  unsigned char  lheadÝ100¨;
  unsigned int   val;
  unsigned int   tt;
  unsigned char  *pbuf;
  unsigned char  *lbuf;
           int   ip;
  /***************************************************************************/
  pbuf=malloc(1024);
  if (!pbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}
  lbuf=malloc(1024);
  if (!lbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}
  //                               /* prepare a newline                       */
  pbufÝ0¨ = 0x0;
  i = 0;
  while (i < tlen) {
    key  = zzc2d(tp+i,2); i+=2;
    cnt  = zzc2d(tp+i,2); i+=2;

    for (k=0;k<TUL;k++) {
      if (key == tunitsÝk¨.no ) {
        if (fno) zzsprintf(pbuf,"-%6.6s-%d ",inmr,fno);
        else     zzsprintf(pbuf,"-%6.6s   ",inmr);

        sprintf(lhead,"(0x%4.4x) %8.8s: ",tunitsÝk¨.no,tunitsÝk¨.name);
        zzsprintf(pbuf,"%s",lhead);
        break;
      }
    }

    for (k=0;k<cnt;k++) {
      len = zzc2d(tp+i,2); i+=2;

      memcpy(lbuf,tp+i,len); lbufÝlen¨ = 0x0;
      //                              /* save pos */
      ip = i;
      i+=len;

      for (m=0;m<TUL;m++) {
        if (tunitsÝm¨.no == key) {
          /****                     format DSNAME ****************************/
                                    /* - no hex print                        */
          if (tunitsÝm¨.no == 0x0002) {
            ZZXE2A(lbuf,len);

            if (k < cnt-1)   zzsprintf(pbuf,"%s.",lbuf);
            else {
              zzsprintf(pbuf,"%s",lbuf);
              sysprint("*NOPREFIX",pbuf);       // NL writeout this line
              //                    /* prepare a newline                     */
              pbufÝ0¨ = 0x0;
            }
          }
          /****                     format MEMBERS ***************************/
          else if (tunitsÝm¨.no == 0x0003) {
            ZZXE2A(lbuf,len);
           if (k > 0) {
              zzsprintf(pbuf,"-%6.6s-%d ",inmr,fno);
              zzsprintf(pbuf,"%s",lhead);
            }

            zzsprintf(pbuf,"%-8.8s ",lbuf);

          }
          /****                     format DSORG *****************************/
          else if (tunitsÝm¨.no == 0x003C) {
            val = zzc2d(lbuf,len);
            switch (val) {
              case 0x0008: zzsprintf(pbuf,"VS "); break;
              case 0x0200: zzsprintf(pbuf,"PO "); break;
              case 0x4000: zzsprintf(pbuf,"PS "); break;
              default:     zzsprintf(pbuf,"NONE "); break;
            }
          }
          /****                     format RECFM *****************************/
          else if (tunitsÝm¨.no == 0x0049) {
            val = zzc2d(lbuf,len);

            if      (val & 0x8000 && val & 0x4000) zzsprintf(pbuf,"U");
            else if (val & 0x8000)                 zzsprintf(pbuf,"F");
            else if (val & 0x4000)                 zzsprintf(pbuf,"V");

            if      (val & 0x1000)                 zzsprintf(pbuf,"B");
            if      (val & 0x2000)                 zzsprintf(pbuf,"T");

            if      (val & 0x0800)                 zzsprintf(pbuf,"S");
            if      (val & 0x0400)                 zzsprintf(pbuf,"A");
            if      (val & 0x0200)                 zzsprintf(pbuf,"M");

            if      (val & 0x0002)                 ;
            if      (val & 0x0001)                 ;

          }
          /****                     format TYPE  *****************************/
          else if (tunitsÝm¨.no == 0x8012) {
            val = zzc2d(lbuf,len);
            switch (val) {
              case 0x80: zzsprintf(pbuf,"DATALIB "); break;
              case 0x40: zzsprintf(pbuf,"PROGLIB "); break;
              case 0x04: zzsprintf(pbuf,"EXTENDED "); break;
              case 0x01: zzsprintf(pbuf,"LARGE "); break;
              default:   zzsprintf(pbuf,"NONE "); break;
            }
          }
          /****                     format CNT=1 CHAR ************************/
          else if (tunitsÝm¨.format == 'C') {
            ZZXE2A(lbuf,len);
            zzsprintf(pbuf,"%s ",lbuf);
          }
          /****                     format CNT=1 DEC *************************/
          else if (tunitsÝm¨.format == 'D') {
            val = zzc2d(lbuf,len);
            zzsprintf(pbuf,"%d ",val);
          }
          break;
        }
        /****                       format CNT=1 DEC *************************/
      }
                                         /* we need do refresh contents      */
      if (tunitsÝm¨.no == 0x0002) ;
      else {
        memcpy(lbuf,tp+ip,len); lbufÝlen¨ = 0x0;
        zzsprintf(pbuf,"(0x");
        for (m=0;m<len;m++) zzsprintf(pbuf,"%2.2X",lbufÝm¨);

        zzsprintf(pbuf,")");
        sysprint("*NOPREFIX",pbuf);      // NL writeout this line
        pbufÝ0¨ = 0x0;                   // prepare a newline
      }
                                         /* TU end                           */
    }
    if (cnt == 0) {
      zzsprintf(pbuf," ");
      sysprint("*NOPREFIX",pbuf);       // NL writeout this line
      pbufÝ0¨ = 0x0;                    // prepare a newline
    }
  }
  /***************************************************************************/
  EE:
  if (pbuf) free(pbuf);
  if (lbuf) free(lbuf);
  return (prc);
}
/**0310***********************************************************************/
/* do_txtunit()                                                              */
/*   - decode text units. break up tokens                                    */
/*     uu-uu ll-ll cc-cc                                                     */
/*---------------------------------------------------------------------------*/
/* RC: 200     getmain error                                                 */
/* F:  do_ftxtunit                                                           */
/* F:  zzc2d                                                                 */
/* M:  ZZXE2A                                                                */
/* G:  ggnoim                                                                */
/*****************************************************************************/
int  do_txtunit(unsigned char *rbuf,int blen ) {

  int i,j,k,rc=0,prc=0;                             /* commons               */

  unsigned short key,len,cnt;
  unsigned int   fno = 0;
  unsigned char  inmrÝ6¨;
  unsigned int   tlen;
  unsigned char  *p;
  /***************************************************************************/
  //                                                /* we suppress all INMR  */
  //                                                /* but give a message 1st*/
  if (ggnoim == 1) prc=do_msg(0,"XMC0016I Info INMR Tokens suppressed.");
  if (ggnoim) ggnoim++;
  if (ggnoim) goto EE;

  memcpy(inmr,rbuf,6); ZZXE2A(inmr,6);

  if (!memcmp("INMR02",inmr,6)) { fno = zzc2d(rbuf+6,4); i = 10; }
  else                          { i = 6;}

  while (i < blen) {
    p = rbuf+i;
    key  = zzc2d(rbuf+i,2); i+=2;
    cnt  = zzc2d(rbuf+i,2); i+=2;
    tlen = 4;

    for (k=0;k<cnt;k++) {
      len = zzc2d(rbuf+i,2); i+=2;
      tlen =tlen + 2 + len;
      i+=len;
    }

    prc = do_ftxtunit(inmr,fno,p,tlen);
  }
  /***************************************************************************/
  EE:
  return (prc);
}
/**0320***********************************************************************/
/* do_segments()                                                             */
/*   - build segments to one block, drop leading two bytes of the segments.  */
/*     block.                                                                */
/*     0x80    segment start                                                 */
/*     0x40    segment end                                                   */
/*     0x00    segment middle                                                */
/*     0x20    control record                                                */
/*---------------------------------------------------------------------------*/
/* RC: 12      getmain error                                                 */
/* RC: 5       lenbyte lt 2. this means a zero or neagtive read              */
/* RC: 4       lenbyte is zero. mostly an non XMI dataset                    */
/* RC: 3       buffer overflow. more segments for a block than 32K. see 201  */
/* RC: 2       maybe xmi. but this are trailer spaces beyond IMR006          */
/* G:  goffc                                                                 */
/* G:  goffp                                                                 */
/*****************************************************************************/
int  do_segments(FILE *fx, char *rbuf,int *blen,int bmax, int *btype) {

  int i,k,j,rc=0,prc=0;                             /* commons               */

  unsigned char sl = 0;
  unsigned char st = 0;
  int lp;
  /***************************************************************************/
  lp = 0;
  ggoffp = ggoffc;

  while (1) {
    sl      = fgetc(fx);
    st      = fgetc(fx);
    //                                              /* read a ZERO length    */
    if (sl<=0) {prc=do_msg(4,"XMC0204S Read a ZERO record length");goto EE;}
    //                                              /* buffer overflow       */
    if (lp +(sl-2) > bmax)
               {prc=do_msg(4,"XMC0203S Buffer Overflow."); goto EE;}
    ggoffc = ggoffc + 2;

    //                                              /* avoid negtive read    */
    if ((sl-2)<=0)
               {prc=do_msg(5,"XMC0205S Negative Read Encountered."); goto EE;}
    rc = fread(rbuf+lp,1,sl-2,fx);
    //                                              /* read beyond EOF       */
    if (rc < sl-2)
               {prc=do_msg(2,"XMC0202W Read Beyond EOF."); goto EE;}
    lp = lp +rc;
    ggoffc = ggoffc +rc;
    *blen = lp;

    if ((st & 0x20)) *btype = 1;                    /* Controlblock          */
    else             *btype = 0;                    /* Controlblock          */
    if ((st & 0x40)) return 0;                      /* EOB 0x40              */
  }
  /***************************************************************************/
  EE:
  return (prc);
}
/**0340***********************************************************************/
/* do_datafirstb()                                                           */
/*   - work todo after directory is done.                                    */
/*     -- sort directory                                                     */
/*     -- write basemem list                                                 */
/*---------------------------------------------------------------------------*/
/* F:  do_basemem                                                            */
/* F:  do_cchh                                                               */
/* F:  do_mbbcchhr                                                           */
/* F:  do_msg                                                                */
/* F:  ttrcomp                                                               */
/* G:  ggdbx                                                                 */
/* G:  ggdsnx                                                                */
/* G:  ggmem                                                                 */
/* G:  ggnoba                                                                */
/* G:  ggnoin                                                                */
/* G:  ggpa                                                                  */
/* G:  ggpa                                                                  */
/* G:  ggpax                                                                 */
/* G:  ggpm                                                                  */
/* G:  ggpmbbcchhrs                                                          */
/* G:  ggpmbbcchhrp                                                          */
/* G:  ggpmx                                                                 */
/* G:  ggra                                                                  */
/* G:  ggrm                                                                  */
/* G:  ggttr                                                                 */
/*****************************************************************************/
int  do_datafirstb() {

  int i,j,k,m,ss,rc=0,prc=0;char *prn="do_datafirstb"; /* commons            */

  int cc,hh,rec;                                   /* cchhr                  */
  /***************************************************************************/
  //                                        /* SORT ONLY for ALIAS or        */
  //                                        /*               EXTRACT         */
  if (ggpax > 0 || ggmemÝ0¨ != 0x0) {
    ggpa = (struct ggttr*)ggra;
    ggpm = (struct ggttr*)ggrm;
    qsort (ggpa, ggpax, sizeof(ggttr), ttrcomp);
    qsort (ggpm, ggpmx, sizeof(ggttr), ttrcomp);
  }
  //                                        /* write BASEMEM-List            */
  //                                        /* if alias exist                */
  if (ggpax > 0) {
    ss = ggnoin + ggnoba;
    if (ss) prc=do_msg(0,"XMC0016I Info ALIAS Basemem suppressed.");
    else do_basemem();
  }
  //                                        /* if member EXTRACT             */
  //                                        /* CCHHR for all Members         */
  //                                        /* due we need end of contents   */
  if (ggmemÝ0¨ != 0x0) {
    ggpm = (struct ggttr*)ggrm;
    for (i=0;i<ggpmx;i++) {
      rc = do_cchh(ggpmÝi¨.ttr,&cc,&hh,&rec);
      ggpmÝi¨.cc = cc;
      ggpmÝi¨.hh = hh;
      ggpmÝi¨.rec= rec;
      ggpmÝi¨.ext= rc;
    }
    //                                      /* search start  and stop        */
    //                                      /* if we specified a member but  */
    //                                      /* the member is NOT FOUND, we   */
    //                                      /* stop here.                    */
    if (ggmemÝ0¨ != 0x0 ) {
      rc = do_mbbcchhr(ggmem,ggmbbcchhrs,ggmbbcchhrp);
      if (rc > 0) {
        prc=do_msg(8,"XMC0018E Member %s not found for EXTRACT.",
                        ggmem);
        goto EE;
      }
    }
  }
  /***************************************************************************/
  EE:
  return (prc);
}
/**0340***********************************************************************/
/* do_datablock()                                                            */
/*   - write a datablock                                                     */
/*---------------------------------------------------------------------------*/
/*   RC: 8 Error FILE                                                        */
/*   RC: 2 END OF MEMBER                                                     */
/*---------------------------------------------------------------------------*/
/*****************************************************************************/
int  do_datablock(unsigned char *sbuf,int blen,int *dbl,int *swext) {

  int i,j,k,m,ss,rc=0,prc=0;char *prn="do_datablock";  /* commons            */

  char igwÝ¨ = {0xC9,0xC7,0xE6,0xC6,0xC1,0xC8,0xD9,0x40,0x00,0x00};
  #define IGWL 10

  int rlen;

  static int olen = 0;
  /***************************************************************************/
  //                                    /* be aware that we write            */
  //                                    /* 0-Byte blocks if --cchhr          */
  //                                    /* this was a recv390 error          */
  //                                    /* in orig .                         */
  //  sysprint("%d %d %d",*swext,*dbl,blen );
//  for (i=0;i<9;i++) fprintf(stderr,"%2.2X ",sbufÝi¨); fprintf(stderr,"\n");


  //                                    /* omit byte 0 for pdse compare      */
  //                                    /* FIRST BLOCK ****************      */
  if (!memcmp(ggmbbcchhrs+1,sbuf+1,8)) {
    *swext = 1;
    rlen = blen;
    if (ggcchhr != 1) j = 12;
    else              j = 0;

    if (!ggfo) {
      prc=do_msg(0,"XMC0011I Found Member %s.",ggmem);
      /***********************************************************************/
      //                                /* open & determine output direction */
      //                                /* if persistent file. THEN ERROR    */
      ggfo = do_copen(ggodsn);
      if (ggodsnÝ0¨ && !ggfo) {
         prc = 8; goto EE;
       }
      //                                /* if fo is now NULL we assume stdout*/
      //                                /* no implicit correct to 1. we must */
      //                                /* assure TSO DD SYSPRINT            */

      if (!ggfo) prc=do_msg(0,"XMU0004I Output Destination is stdout.");
      else       prc=do_msg(0,"XMU0005I Output File is %s.",ggodsn);
      //                                /* assure TSO DD SYSPRINT            */
      if (!ggfo) ggfo = stdout;
      /***********************************************************************/
    }
    //                                  /* sfor EATTR: dump & write          */
    if (rlen-j > 0) {
      rc = memcmp(sbuf+12,igw,IGWL);
      if (!rc &&  ggeattr) do_eattr(sbuf+12,rlen-12);
      if (!rc && !ggeattr) {
        prc=do_msg(0,"XMU0007I EATTR skipped at Pos %d.",olen);goto EE;
      }
    }

//  fwrite("*F***************",10,1,ggfo);
    fwrite(sbuf+j,rlen-j,1,ggfo);
    olen = olen + rlen - j ;
  }
  //                                    /* LAST  BLOCK ****************      */
  else if (!memcmp(ggmbbcchhrp+1,sbuf+1,8)) {
    prc=do_msg(0,"XMC0018I Member %s extracted to %s (%d Bytes).",
                 ggmem,ggodsn,olen);
    prc = 2;    /* END OF MEMBER */
    goto EE;
  }
  //                                    /* OTHER BLOCKS ***************      */
  else if (*swext) {
    rlen = blen;
    if (ggcchhr != 1) j = 12;
    else              j =  0;

    //                                  /* sfor EATTR: dump & write          */
    if (ggeattr & rlen-j > 0) {
      rc = memcmp(sbuf+12,igw,IGWL);
      if (!rc)  {
        do_eattr(sbuf+12,rlen-12);
        // goto EE;
      }
    //if (!rc){prc=do_msg(0,"XMU0007I EATTR skipped at Pos %d.",olen);goto EE;}
    }

//  fwrite("*L***************",10,1,ggfo);
    fwrite(sbuf+j,rlen-j,1,ggfo);
    olen = olen + rlen - j ;
  }
  ggdbx++;
  /***************************************************************************/
  EE:
//  sysprint ("RC %d",prc);
  return (prc);
}
/**0330***********************************************************************/
/* do_blocks()                                                               */
/*   - retrieve all blocks from a dataset. combine segments to a complete    */
/*   - control flow of blocks                                                */
/*---------------------------------------------------------------------------*/
/* F:  do_copyr1                                                             */
/* F:  do_copyr2                                                             */
/* F:  do_directory                                                          */
/* F:  do_mbbcchhr                                                           */
/* F:  do_msg1                                                               */
/* F:  do_segments                                                           */
/* F:  do_txtunit                                                            */
/* F:  do_datafirstb                                                         */
/* F:  do_datablock                                                          */
/* F:  xxopen                                                                */
/* F:  zzc2d                                                                 */
/* G:  ggdbx                                                                 */
/* G:  ggdsnx                                                                */
/* G:  ggmem                                                                 */
/* G:  ggodsn                                                                */
/* G:  ggpa                                                                  */
/* G:  ggpax                                                                 */
/* G:  ggpm                                                                  */
/* G:  ggpm                                                                  */
/* G:  ggrm                                                                  */
/* G:  ggttr                                                                 */
/* M:  ZZXE2A                                                                */
/*****************************************************************************/
int  do_blocks() {

  int i,j,k,m,ss,rc=0,prc=0;char *prn="do_blocks";  /* commons               */

  FILE *fx = NULL;                                  /*                       */
  unsigned char *sbuf = NULL;                       /* read buffer           */
  unsigned char *lbuf = NULL;                       /* work buffer           */
  unsigned char wbufÝ9¨;

  int blen=0,bmax=32*1024+12,btype=0;              /* this is 32K max blksiz */

  unsigned int n;
           int dbl = 0;
  int swext = 0,rlen=0,dirdone=0;                  /* cchhr                  */
  /***************************************************************************/
  sbuf=malloc(bmax);
  if (!sbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}
  lbuf=malloc(1024);
  if (!lbuf) {prc=do_msg(12,"XMC0200S Malloc Error %s.",prn);goto EE;}

  fx = xxopen(ggdsnx,"rb");
  if (!fx) {prc=do_msg(8,"XMC0210E Open Failed Input %s.",ggdsnx); goto EE;}
  //#########################################################################*/
  while (1) {
    rc = do_segments(fx,sbuf,&blen,bmax,&btype);
    if (rc >2) {prc = rc; goto EE;}


    memcpy(lbuf,sbuf,6); ZZXE2A(lbuf,6);
    //*************************                                              */
    //* INMR BLOCK                                                           */
    //*************************                                              */
    if (!memcmp(lbuf,"INMR",4)) {
      prc = do_txtunit(sbuf,blen);
      if (prc) {goto EE;}
    }
    //*************************                                              */
    //* IEBCOPY COPYR1 BLOCK - first datablock                               */
    //*************************                                              */
    else if (ggdbx == 0) {
      prc = do_copyr1(sbuf,blen);
      if (prc) {goto EE;}
      ggdbx++;
    }
    //*************************                                              */
    //* IEBCOPY COPYR2 BLOCK - second datablock                              */
    //*************************                                              */
    else if (ggdbx == 1) {
      prc = do_copyr2(sbuf,blen);
      if (prc) {goto EE;}
      ggdbx++;
    }
    //*************************                                              */
    //* ALL DIRECTORY BLOCKS - 0x00 00 00 00 00 00 00 00                     */
    //*************************                                              */
    else if  (zzc2d(sbuf,8) == 0 && dirdone == 0) {
      rc = do_directory(sbuf,blen);
      if (rc==1) dirdone=1;
      if (rc> 1) {prc=rc;goto EE;}
      ggdbx++;
    }
    //************************************************************************/
    //* ALL OHTER DATA BLOCKS  is IEBCOPY UNLOAD ...                         */
    else {
      if (!dbl) rc = do_datafirstb();
      //=====================================================================*/
      //* ALL   UNLOAD BLOCK - dbl<1 & dbl>0                                 */
      dbl++;
      //                                    /* we stop here, if no member    */
      //                                    /* specified,avoiding read blocks*/
      //                                    /* go Out and Term Program       */
      //                                    /* there is nothing to stay      */
      if (!ggmemÝ0¨) {
        prc=do_msg(0,"XMC0017I No Member specified for EXTRACT.");
        goto EE;
      }
/*
      k = 0;
      m = blen;
      rc = do_datablock(sbuf+k,m,&dbl,&swext);
      if (rc) goto EE;
*/


      k = 0;
      while (k < blen){
        m = zzc2d(sbuf+k+10,2) + 12;

//     for (i=0;i<12;i++) fprintf(stderr,"%2.2X ",(sbuf+k)Ýi¨);
//     fprintf(stderr,"L: %d  DBX: %d BM: %d BK %d  ***\n",blen,dbl,m,k);

        rc = do_datablock(sbuf+k,m,&dbl,&swext);
        if (rc) {
          prc =rc; goto EE;
        }
        k = k + m;
      }

    }
    if (!memcmp(lbuf,"INMR06",6)) {prc = 0; goto EE;}
    //                                           /* we are disappointed      */
    if (rc == 2) {prc=do_msg(2,"XMC0209W Read beyond EOF");  goto EE; }
  }
  /***************************************************************************/
  EE:
  if (fx)     fclose(fx);
  if (ggfo)     fclose(ggfo);
  if (sbuf)   free(sbuf);
  if (lbuf)   free(lbuf);
  return (prc);
}
/**0910***********************************************************************/
/* showopts()                                                                */
/* write out options                                                         */
/*****************************************************************************/
 void showopts() {

  do_msg(0,"XMC0001I Options specified:");
  do_msg(0,"+  P1         : %s",ggdsnx);
  do_msg(0,"+  NOMSG      : %d",ggnomsg);
  do_msg(0,"+  NOINFO     : %d Superseeds all other Info Settings.",ggnoin);
  do_msg(0,"+  - NOINMR   : %d INMR Tokens resolved.",ggnoim);
  do_msg(0,"+  - NOIEBC   : %d COPYR1 & COPYR2 Infos.",ggnoie);
  do_msg(0,"+  - NODIR    : %d Member with Attributes / Stats.",ggnodi);
  do_msg(0,"+  - NOBASE   : %d Resolve Basemen for ISPF Aliasses.",ggnoba);
  do_msg(0,"+  ODS / ODIR : %s",ggodsn);
  do_msg(0,"+  MEMBER     : %s",ggmem);
  do_msg(0,"+  REPLACE    : %d",ggrep);
  do_msg(0,"+  EATTR      : %d",ggeattr);
  do_msg(0,"+  CCHHR      : %d",ggcchhr);

  return;
}
/**0920***********************************************************************/
/* showhelp()                                                                */
/* write out help                                                            */
/*****************************************************************************/
void showhelp() {

  int i;
  char *pÝ¨ = {
   "XMCLIST pos1 < opts >                                                   "
  ,"                                                                        "
  ,"  where opts are:                                                       "
  ,"       pos1:         xmit dataset. A file in NETDATA format, covering   "
  ,"                     one unloaded PO or PO Extended Dataset.            "
  ,"                     AKA: XMI-File.                                     "
  ,"                                                                        "
  ,"       opts:         optional parameters.                               "
  ,"                                                                        "
  ,"         --noinmr    Suppression of all NETDATA Information             "
  ,"         --noiebc    Suppression of all IEBCOPY Unload Information      "
  ,"         --nodir     Don`t show Directory Information                   "
  ,"         --nobase    Don`t show Resolution of ISPF-Alias to BaseMem.    "
  ,"                                                                        "
  ,"         --noinfo    Suppress ALL Information. See above.               "
  ,"         --nomsg     Don`t write Messages                               "
  ,"                                                                        "
  ,"         --mem=member  Member to search for and to extract. The output  "
  ,"                       is raw. No translation occurs. Block- and Record-"
  ,"                       Descriptors are kept.                            "
  ,"                                                                        "
  ,"                       Alias: member=                                   "
  ,"                                                                        "
  ,"         --ods=mem.bin Output-Path & filename for Extract.              "
  ,"                       - if not specified, then output goes to          "
  ,"                         stdout on X86-Platforms                        "
  ,"                                                                        "
  ,"                       - for MVS a valid Dataset-Name must be specified."
  ,"                         No Auto-Creation (DYNALLOC) is done. While     "
  ,"                         Specification of a Member in a existing PO is  "
  ,"                         allowed.                                       "
  ,"                         As this is a raw output, it is user            "
  ,"                         responsibility to adjust the output DCB.       "
  ,"                                                                        "
  ,"                       Alias: odir=                                     "
  ,"                       Alias: outdataset=                               "
  ,"                                                                        "
  ,"         --replace     Force Overwrite of existing File.                "
  ,"                                                                        "
  ,"         --cchhr       write cchhr with Output.                         "
  ,"                                                                        "
  ,"         --eattr       dump Extended Attributes PO Extended             "
  ,"                                                                        "
  ,"                                                                        "
  ,"  Remarks:                                                              "
  ,"                                                                        "
  ,"   While X86-Platform resembles POSIX Standard for Parameter Processing,"
  ,"   Options specified in MVS (here TSO) rely to TSO Parsing.             "
  ,"                                                                        "
  ,"   X86:                                                                 "
  ,"    $ xmclist my.recv390.xmi --nodir --mem=mymem --ods=./tmp/mymem.bin  "
  ,"                                                                        "
  ,"        shows no directory list, and extracts MYMEM                     "
  ,"        to the file mymem.bin                                           "
  ,"                                                                        "
  ,"                                                                        "
  ,"   TSO:                                                                 "
  ,"        XMCLIST MY.RECV390.XMI NODIR MEM(MYMEM) ODS(MY.MYMEM.BIN)       "
  ,"                                                                        "
  ,"        shows no directory list, and extracts MYMEM                     "
  ,"        to a sequential file MY.MYMEM.BIN                               "
  ,"                                                                        "
  ,"        - DDNAMES are allowed and prefixed with DD: . E.g. DD:MYDD      "
  ,"        - Quotes are tolerated, but not honored. So a dsn needs to be   "
  ,"          fully qualified in all cases.                                 "
  ,"                                                                        "
  ,"                                                                        "
  ,__BUILD
  ,0x0
  };

  for (i=0;pÝi¨ != 0x0; i++) sysprint("*NO","%s",pÝi¨);

  return;
}
/*****************************************************************************/
/* M A I N                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* RC: 200     getmain error                                                 */
/* F:  sysprint                                                              */
/* F:  zzgoptk                                                               */
/* F:  zzgoptv                                                               */
/* F:  zzsprintf                                                             */
/* G:  GPP                                                                   */
/* G:  GDM                                                                   */
/* G:  G1                                                                    */
/* G:  procname                                                              */
/* G:  ggverb                                                                */
/* G:  ggrep                                                                 */
/* G:  ggodsn                                                                */
/* G:  ggmem                                                                 */
/* G:  ggdsnx                                                                */
/* G:  ggpaI                                                                 */
/* G:  ggpmI                                                                 */
/* G:  ggpal                                                                 */
/* G:  ggra                                                                  */
/* G:  ggpml                                                                 */
/* G:  ggrm                                                                  */
/* G:  ggttr                                                                 */
/*****************************************************************************/
int  main(int argc, char ** argv) {

  int rc,prc = 0;
  int i,j,k,m;
  char abufÝ255¨ = "";
  char lbufÝ60¨;

  #define CBL  1024
  #define OBL  1024

  char *cbuf,*obuf;
  /***************************************************************************/
  cbuf=malloc(CBL); if (!cbuf) {rc=200;goto EE;}
  obuf=malloc(OBL); if (!obuf) {rc=200;goto EE;}

  procname = argvÝ0¨;


  /* AGRUMENTS                                                               */
  //                                   /* (2) HELP & VERSION                 */
  cbufÝ0¨ = 0x0;
  for (i=1;i<argc;i++) {
    if ( (strlen(cbuf) + strlen(argvÝi¨)) +1 > CBL) break;
    strcat(cbuf,argvÝi¨); strcat(cbuf," ");
  }
  #if defined MVS
  zzstrupr(cbuf);
  #endif
  rc = dcprmkyo(cbuf,GPP"HELP",GPP"NOHELP");
  if (rc == 1) {showhelp(); prc = 0     ; goto EE;}
  rc = dcprmkyo(cbuf,GPP"VERSION",GPP"NOVERSION");
  if (rc == 1) {prc = do_msg(0,__BUILD); goto EE;}
  //***************************************************************************
  //                                   /* (1) positional arg first           */
  if (argc > 1) strncpy(ggdsnx,argvÝ1¨,G1);
  //                                   /* all other are optional and handled */
  //                                   /* in a cmdstring                     */
  //                                   /* (3) KEY ONLY PARMS                 */
  rc = dcprmkyo(cbuf,GPP"INFO",GPP"NOINFO");   if (rc == 2) ggnoin = 1;
  rc = dcprmkyo(cbuf,GPP"INMR",GPP"NOINMR");   if (rc == 2) ggnoim = 1;
  rc = dcprmkyo(cbuf,GPP"IEBC",GPP"NOIEBC");   if (rc == 2) ggnoie = 1;
  rc = dcprmkyo(cbuf,GPP"DIR" ,GPP"NODIR" );   if (rc == 2) ggnodi = 1;
  rc = dcprmkyo(cbuf,GPP"BASE",GPP"NOBASE");   if (rc == 2) ggnoba = 1;
  rc = dcprmkyo(cbuf,GPP"MSG" ,GPP"NOMSG" );   if (rc == 2) ggnomsg= 1;
  rc = dcprmkyo(cbuf,GPP"CCHHR" ,GPP"NOCCHHR" );   if (rc == 1) ggcchhr= 1;
  rc = dcprmkyo(cbuf,GPP"EATTR" ,GPP"NOEATTR" );   if (rc == 1) ggeattr= 1;
  rc = dcprmkyo(cbuf,GPP"REPLACE" ,GPP"NOREPLACE" ); if (rc == 1) ggrep= 1;
  //                                   /* (4) KEY VALUE PARMS                */
  rc = dcprmkvl(cbuf,GPP"MEMBER","X",obuf); if (rc) strncpy(ggmem,obuf,8);
  rc = dcprmkvl(cbuf,GPP"MEM","X",obuf);    if (rc) strncpy(ggmem,obuf,8);
  rc = dcprmkvl(cbuf,GPP"ODS","",obuf);     if (rc) strncpy(ggodsn,obuf,G1);
  rc = dcprmkvl(cbuf,GPP"ODIR","",obuf);    if (rc) strncpy(ggodsn,obuf,G1);
  rc = dcprmkvl(cbuf,GPP"OUTDATASET","",obuf);if (rc) strncpy(ggodsn,obuf,G1);
  //                                   /* format / validate values           */

  j = 0; obufÝ0¨ = 0x0;
  for (i=0;i<strlen(ggodsn);i++) {
    if (ggodsnÝi¨ == '*') {
      strcat(obuf,ggmem);
      j = j + strlen(ggmem);
    }
    else {
      obufÝj¨ = ggodsnÝi¨;
      j++;
    }
    obufÝj¨ = 0x0;
  }
  strcpy(ggodsn,obuf);

  if (ggnoin) {
    ggnoim= 1;
    ggnoie= 1;
    ggnodi= 1;
    ggnoba= 1;
  }

  zzstrupr(ggmem);
  #if defined MVS
  zzstrupr(ggdsnx);   xxstrip(ggdsnx,"'");//' '
  zzstrupr(ggodsn);   xxstrip(ggodsn,"'");//' '
  #endif

  if (!ggnomsg) showopts();
  //                                  /* Always Alloc for TTR           */
  ggpal = sizeof(ggttr)*ggpaI;
  ggra  =malloc(ggpal); if (!ggra) {rc=200; prc=rc; goto EE;}
  ggpml = sizeof(ggttr)*ggpmI;
  ggrm  =malloc(ggpml); if (!ggrm) {rc=200; prc=rc; goto EE;}
  //                                  /* Here we handle the important   */
  //                                  /* things                         */
  rc = do_blocks();
  prc = rc;
  /***************************************************************************/
  EE:
  if (ggra) free(ggra);
  if (ggrm) free(ggrm);
  prc=do_msg(prc,"Returncode (%d).",prc);
  return (prc);

}
/* eoc ***********************************************************************/
