{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012649000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1528436, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE720.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE720.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x19\\x0c'", "DS1TRBAL": "b'[\\xe8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xf6\\x00\\x02\\x04\\xf7\\x00\\x0c\\x00\\x1a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x18/\\x01\\x05\\x18/\\x13(\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-07-01T00:00:00", "modifydate": "2005-07-01T13:28:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-469"}, "text": "REGULAR CBT TAPE - VERSION 469    FILE:  720\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT469.FILE720\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 53 MEMBERS COUNTED; CUMULATIVE SIZE IS 13,930 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/01/05    13:28:02    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DIR": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xd0\\x00\\xd0\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 208, "newlines": 208, "modlines": 0, "user": "WHS"}, "text": "$DIR     - This directory member. Contact me if you require further\n           documentation for some of this code\n           whsweeney@sscmainframe.com\n\nALEXCMDS - APF authorized program that uses SVC 34 to issue commands,\n           STIMER to issue WAITs, WTOs (rollable and highlighted),\n           search Address Space Control Block (ASCB), invoke a REXX\n           EXEC using the IRXJCL program, and perform simple scheduling\n           using the JES2 $TA command\n\nALEXTDAT - Program used by ALEXCMDS to resolve Date and Day information\n           Assemble and link it first, and then include it when linking\n           ALEXCMDS.\n\nALEXT00  - ISPF Message table used by the AutoOps application. Copy\n           member to an ISPMLIB concatenated data set, or LIBDEF to this\n           PDS\n\nALXEXCOM - All purpose REXX utility program that uses the IRXEXCOM\n           feature of REXX to STORE and FETCH variables. Program is\n           invoked by any of the ALEX REXX functions that require\n           access to variables from/to REXX\n\nALXPEXH1 - ISPF Help Panel used by the AutoOps application. Copy\n           member to an ISPPLIB concatenated data set, or LIBDEF to this\n           PDS\n\nALXPEXH2 - ISPF Help Panel used by the AutoOps application. Copy\n           member to an ISPPLIB concatenated data set, or LIBDEF to this\n           PDS\n\nALXPEXT  - ISPF Panel used by the AutoOps application. Copy\n           member to an ISPPLIB concatenated data set, or LIBDEF to this\n           PDS\n\nALXRCONC - REXX function to ALLOCATE and CONCATENATE datasets in a\n           TSO session\n\nALXRDASD - REXX function that performs a UCBSCAN of all DASD or Tape,\n           and returns the information into compound REXX variables\n\nALXRDDIR - REXX function to return the directory contents of a PDS as\n           compound REXX variables\n\nALXRDOZE - REXX function to SLEEP/WAIT for a period of time\n\nALXRFNDM - REXX function to find a member in a PDS\n\nALXREXT  - ISPF REXX EXEC used by the AutoOps application. Copy\n           member to a SYSPROC or SYSEXEC data set\n\nALXRFNDS - REXX function to find a load module in the system LPALST or\n           LNKLST concatenation of datasets\n\nALXRGETM - REXX function to read a member of a PDS dataset into REXX\n           compound variables\n\nALXRPDSC - REXX function to SCRATCH, RENAME or assign an ALIAS to a\n           member of a PDS. ALIAS does not work with PDS-E files\n\nALXRQSCN - REXX function that uses GQSCAN to determine if any enqueues\n           exist for data sets, and return the data set, owner and the\n           waiter as compound REXX variables\n\nALXRWRTM - REXX function to write a member of a PDS dataset from REXX\n           compound variables\n\nALXRWTO  - REXX function to issue a WTO\n\nALXRWTOR - REXX function to issue a WTOR and return the reply\n\nASMLAOPS - JCL to Assemble and Link MSGTABLE to IEAVMXIT\n\nASMLTABL - JCL to Assemble and Link MSGTABLE to IEAVMXIT, and then\n           refresh IEAVMXIT with new messages\nASMLVMXT - JCL to Assemble and Link changes to IEAVMXIT\n\nCATCLEAN - Old Assembler program that is provided as an example. It was\n           written in MVS/SP, and it does the following: EXCP read\n           of the VTOC, use of SVC 26 for Catalog function, read an\n           ICF Catalog as a VSAM KSDS, and use SVC 99 dynamic allocation\n\nCBR3750I - REXX EXEC sample that is placed in the SYSEXEC file defined\n           in the OPSAUTO Started Task JCL. Entry must be defined in\n           the MSGTABLE AutoOps member to be used by the IEAVMXIT exit\n\nCLEANPDS - Assembler program to compare two PDS files, and delete\n           members that are duplicate. Good for cleaning up old Linklist\n           libraries, when vendor put all products in one library\n\nCOPYISPF - REXX EXEC that uses supplied Assembler REXX functions to\n           copy PDS members and change the ISPF statistics. It is what\n           was used to create this PDS with the squirrely CREATED and\n           CHANGED dates (day I was born, and end of day if and when I\n           turn 75)\n\nCOUTCPCM - Assembler program to issue VM CP commands (DIAGNOSE command)\n           Good when running as a guest under VM, and you want to issue\n           CP commands\n\nCOUTLOGC - Assembler program to create the next file on a multi-file\n           tape. As an example, used when wanting to stack monthly\n           SMF data on the same tape.\n\nDASDBOX  - REXX EXEC that used the ALXRDASD REXX function to provide\n           output of all defined DASD volumes in a BOX format. Uses\n           a call to IDCAMS, and the DCOLLECT command to get the free\n           space information. You must add IDCAMS to the IKJTSOxx member\n           in PARMLIB, under AUTHPGM, in order to issue the CALL.\n\nEZACICSE - Assembler CICS security exit for the TCP/IP Listener. I\n           included it because I remember trying to find a sample when\n           I had to write it\n\nE0016    - REXX EXEC sample that is placed in the SYSEXEC file defined\n           in the OPSAUTO Started Task JCL. This EXEC was used to\n           track OAM messages issued by the VTS, and if a problem is\n           identified, then the Operator's are told to use the 'Phone\n           Home' feature of the VTS. EXEC is invoked because of the\n           CBR3750I message, and is invoked from the CBR3750I EXEC\n\nE0017    - REXX EXEC sample that is placed in the SYSEXEC file defined\n           in the OPSAUTO Started Task JCL. This EXEC was used to\n           track OAM messages issued by the VTS. EXEC is invoked because\n           of CBR3750I message, and is invoked from the CBR3750I EXEC\n\nIEAVMXIT - WTO/WTOR exit that will process all MVS messages that are\n           defined for automation in the MSGTABLE entry\n\nINRECXIT - Assembler Network Print Facility (NPF) input record exit\n           for inserting HP PCL in the print stream. NPF was free from\n           IBM, so if you are using it, the exit might help\n\nLCB      - REXX EXEC that can be executed from ISPF 3.4 data set list,\n           to issue an IDCAMS LISTCAT and return the information in\n           an ISPF Browse session. EXEC includes the code to display\n           the last modified TIMESTAMP as something you can read\n\nMESSAGE  - Assembler MACRO used to build MSGTABLE used by IEAVMXIT.\n           Macro is located in SYS2.ISPF.LOCAL.MACLIB\n\nMSGTABLE - Assembler table created by the ISPF/REXX AutoOps interface,\n           and contains all of the messages to be processed by IEAVMXIT\n\nMSGTABLE - Assembler Table used by AutoOps application. It is built\n           using the supplied ISPF/REXX panels and EXECs included in\n           this PDS. It currently contains sample entries that should\n           be removed when you are ready to use it.\n\nOPSAUTO  - JCL PROC used by the AutoOps application and invoked as\n           an MVS START command from the IEAVMXIT\n\nPDSPCLOD - PC REXX EXEC to take the output from PDSUNLDV program and\n           place the members in a directory on your PC\n\nPDSRELDV - Assembler program to rebuild a PDS from the PDSUNLDV program.\n\nPDSUNLDV - Assembler program to create a sequential file from an FB\n           or VB PDS, for unloading from the mainframe. Use PDSPCLOD\n           REXX EXEC on your Personal Computer to unload the members\n           into a directory (you can download REGINA if you want to\n           run REXX on your PC). Does not retain the ISPF STATs info.\n\nSSCLKPDS - Assembler program that allows the SSCUCPDS program to issue\n           Multiple change commands. The name of the SSCUCPDS program\n           is contained in this program, so if you change it, you must\n           change it in this program as well.\n\nSSCUCPDS - Assembler program written in 1984 to perform mass edits of\n           multiple PDS or sequential files. Originally used as a\n           migration tool for doing massive changes to libraries with\n           JCL. Program only works on RECFM FB, LRECL 80 files, because\n           it maintains the integrity of column 72 within the code.\n           The default is to show you what the changes would look like\n           before actually changing the files. Once satisfied, specify\n           PARM=CHGE to perform the change. Program also has a\n           parameter function to SCAN PDS files, without doing any\n           changes. SSCLKPDS program was written later, so that\n           multiple change input control cards could be supplied.\n\nSYSURDR  - Assembler program that will allow you to build and submit\n           a job from the Operator Console. Program issues WTORs, and\n           when complete, submits the job for execution. I saw this\n           done on DOS/VSE and thought it was a good idea if the\n           network was done. REXX using the ALXRWTOR assembler\n           function would be easier to maintain, but I figured I'd\n           include this program.\n\nSUBTTIME - REXX EXEC that will take two date/time fields as input\n           arguments, and calculate the time difference. Found it\n           useful in AutoOps when making a decision on the frequency\n           of an occurrence\n\nTAPESTCK - Assembler program that was originally written to convert\n           from 3480 tape to 3590 tape. Program will stack the input\n           files on to the output tape, and build the necessary IDCAMS\n           DELETE/DEFINE control cards to recatalog the input files to\n           the new media. Also builds CA1 SCRATCH control cards, if you\n           need them. Will support 64k blocks.\n\nVARYOFF  - REXX EXEC that uses ALXRDASD REXX function and input control\n           cards to vary selected DASD offline at IPL time. Allows you\n           to specify selection criteria\n\nVARYOFFJ - Started Task JCL for invoking VARYOFF EXEC\n\nVARYOFFP - Control card input to VARYOFF EXEC\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE720": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x18/\\x01\\x05\\x18/\\x13\"\\x01\\n\\x01\\n\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-07-01T00:00:00", "modifydate": "2005-07-01T13:22:00", "lines": 266, "newlines": 266, "modlines": 0, "user": "CBT-469"}, "text": "//***FILE 720 is from Bill Sweeney and contains a large collection  *   FILE 720\n//*           of utilities.  Please see the member called $DIR      *   FILE 720\n//*           for an explanation of the contents of each program.   *   FILE 720\n//*                                                                 *   FILE 720\n//*           email:  whsweeney@sscmainframe.com                    *   FILE 720\n//*                                                                 *   FILE 720\n//*     $DIR     - This directory member. Contact me if you         *   FILE 720\n//*                require further documentation for some of        *   FILE 720\n//*                this code: whsweeney@sscmainframe.com            *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALEXCMDS - APF authorized program that uses SVC 34 to       *   FILE 720\n//*                issue commands, STIMER to issue WAITs, WTOs      *   FILE 720\n//*                (rollable and highlighted), search Address       *   FILE 720\n//*                Space Control Block (ASCB), invoke a REXX        *   FILE 720\n//*                EXEC using the IRXJCL program, and perform       *   FILE 720\n//*                simple scheduling using the JES2 $TA command     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALEXTDAT - Program used by ALEXCMDS to resolve Date and     *   FILE 720\n//*                Day information Assemble and link it first,      *   FILE 720\n//*                and then include it when linking ALEXCMDS.       *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALEXT00  - ISPF Message table used by the AutoOps           *   FILE 720\n//*                application. Copy member to an ISPMLIB           *   FILE 720\n//*                concatenated data set, or LIBDEF to this PDS     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXEXCOM - All purpose REXX utility program that uses       *   FILE 720\n//*                the IRXEXCOM feature of REXX to STORE and        *   FILE 720\n//*                FETCH variables. Program is invoked by any       *   FILE 720\n//*                of the ALEX REXX functions that require          *   FILE 720\n//*                access to variables from/to REXX                 *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXPEXH1 - ISPF Help Panel used by the AutoOps              *   FILE 720\n//*                application. Copy member to an ISPPLIB           *   FILE 720\n//*                concatenated data set, or LIBDEF to this PDS     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXPEXH2 - ISPF Help Panel used by the AutoOps              *   FILE 720\n//*                application. Copy member to an ISPPLIB           *   FILE 720\n//*                concatenated data set, or LIBDEF to this PDS     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXPEXT  - ISPF Panel used by the AutoOps application.      *   FILE 720\n//*                Copy member to an ISPPLIB concatenated data      *   FILE 720\n//*                set, or LIBDEF to this PDS                       *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRCONC - REXX function to ALLOCATE and CONCATENATE        *   FILE 720\n//*                datasets in a TSO session                        *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRDASD - REXX function that performs a UCBSCAN of all     *   FILE 720\n//*                DASD or Tape, and returns the information        *   FILE 720\n//*                into compound REXX variables                     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRDDIR - REXX function to return the directory            *   FILE 720\n//*                contents of a PDS as compound REXX variables     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRDOZE - REXX function to SLEEP/WAIT for a period of      *   FILE 720\n//*                time                                             *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRFNDM - REXX function to find a member in a PDS          *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXREXT  - ISPF REXX EXEC used by the AutoOps               *   FILE 720\n//*                application. Copy member to a SYSPROC or         *   FILE 720\n//*                SYSEXEC data set                                 *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRFNDS - REXX function to find a load module in the       *   FILE 720\n//*                system LPALST or LNKLST concatenation of         *   FILE 720\n//*                datasets                                         *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRGETM - REXX function to read a member of a PDS          *   FILE 720\n//*                dataset into REXX compound variables             *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRPDSC - REXX function to SCRATCH, RENAME or assign       *   FILE 720\n//*                an ALIAS to a member of a PDS. ALIAS does        *   FILE 720\n//*                not work with PDS-E files                        *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRQSCN - REXX function that uses GQSCAN to determine      *   FILE 720\n//*                if any enqueues exist for data sets, and         *   FILE 720\n//*                return the data set, owner and the waiter as     *   FILE 720\n//*                compound REXX variables                          *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRWRTM - REXX function to write a member of a PDS         *   FILE 720\n//*                dataset from REXX compound variables             *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRWTO  - REXX function to issue a WTO                     *   FILE 720\n//*                                                                 *   FILE 720\n//*     ALXRWTOR - REXX function to issue a WTOR and return the     *   FILE 720\n//*                reply                                            *   FILE 720\n//*                                                                 *   FILE 720\n//*     ASMLAOPS - JCL to Assemble and Link MSGTABLE to IEAVMXIT    *   FILE 720\n//*                                                                 *   FILE 720\n//*     ASMLTABL - JCL to Assemble and Link MSGTABLE to             *   FILE 720\n//*                IEAVMXIT, and then refresh IEAVMXIT with new     *   FILE 720\n//*                messages                                         *   FILE 720\n//*                                                                 *   FILE 720\n//*     ASMLVMXT - JCL to Assemble and Link changes to IEAVMXIT     *   FILE 720\n//*                                                                 *   FILE 720\n//*     CATCLEAN - Old Assembler program that is provided as an     *   FILE 720\n//*                example. It was written in MVS/SP, and it        *   FILE 720\n//*                does the following: EXCP read of the VTOC,       *   FILE 720\n//*                use of SVC 26 for Catalog function, read an      *   FILE 720\n//*                ICF Catalog as a VSAM KSDS, and use SVC 99       *   FILE 720\n//*                dynamic allocation                               *   FILE 720\n//*                                                                 *   FILE 720\n//*     CBR3750I - REXX EXEC sample that is placed in the           *   FILE 720\n//*                SYSEXEC file defined in the OPSAUTO Started      *   FILE 720\n//*                Task JCL. Entry must be defined in the           *   FILE 720\n//*                MSGTABLE AutoOps member to be used by the        *   FILE 720\n//*                IEAVMXIT exit                                    *   FILE 720\n//*                                                                 *   FILE 720\n//*     CLEANPDS - Assembler program to compare two PDS files,      *   FILE 720\n//*                and delete members that are duplicate. Good      *   FILE 720\n//*                for cleaning up old Linklist libraries, when     *   FILE 720\n//*                vendor put all products in one library           *   FILE 720\n//*                                                                 *   FILE 720\n//*     COPYISPF - REXX EXEC that uses supplied Assembler REXX      *   FILE 720\n//*                functions to copy PDS members and change the     *   FILE 720\n//*                ISPF statistics. It is what was used to          *   FILE 720\n//*                create this PDS with the squirrely CREATED       *   FILE 720\n//*                and CHANGED dates (day I was born, and end       *   FILE 720\n//*                of day if and when I turn 75)                    *   FILE 720\n//*                                                                 *   FILE 720\n//*     COUTCPCM - Assembler program to issue VM CP commands        *   FILE 720\n//*                (DIAGNOSE command) Good when running as a        *   FILE 720\n//*                guest under VM, and you want to issue CP         *   FILE 720\n//*                commands                                         *   FILE 720\n//*                                                                 *   FILE 720\n//*     COUTLOGC - Assembler program to create the next file on     *   FILE 720\n//*                a multi-file tape. As an example, used when      *   FILE 720\n//*                wanting to stack monthly SMF data on the         *   FILE 720\n//*                same tape.                                       *   FILE 720\n//*                                                                 *   FILE 720\n//*     DASDBOX  - REXX EXEC that used the ALXRDASD REXX            *   FILE 720\n//*                function to provide output of all defined        *   FILE 720\n//*                DASD volumes in a BOX format. Uses a call to     *   FILE 720\n//*                IDCAMS, and the DCOLLECT command to get the      *   FILE 720\n//*                free space information. You must add IDCAMS      *   FILE 720\n//*                to the IKJTSOxx member in PARMLIB, under         *   FILE 720\n//*                AUTHPGM, in order to issue the CALL.             *   FILE 720\n//*                                                                 *   FILE 720\n//*     EZACICSE - Assembler CICS security exit for the TCP/IP      *   FILE 720\n//*                Listener. I included it because I remember       *   FILE 720\n//*                trying to find a sample when I had to write      *   FILE 720\n//*                it                                               *   FILE 720\n//*                                                                 *   FILE 720\n//*     E0016    - REXX EXEC sample that is placed in the           *   FILE 720\n//*                SYSEXEC file defined in the OPSAUTO Started      *   FILE 720\n//*                Task JCL. This EXEC was used to track OAM        *   FILE 720\n//*                messages issued by the VTS, and if a problem     *   FILE 720\n//*                is identified, then the Operator's are told      *   FILE 720\n//*                to use the 'Phone Home' feature of the VTS.      *   FILE 720\n//*                EXEC is invoked because of the CBR3750I          *   FILE 720\n//*                message, and is invoked from the CBR3750I        *   FILE 720\n//*                EXEC                                             *   FILE 720\n//*                                                                 *   FILE 720\n//*     E0017    - REXX EXEC sample that is placed in the           *   FILE 720\n//*                SYSEXEC file defined in the OPSAUTO Started      *   FILE 720\n//*                Task JCL. This EXEC was used to track OAM        *   FILE 720\n//*                messages issued by the VTS. EXEC is invoked      *   FILE 720\n//*                because of CBR3750I message, and is invoked      *   FILE 720\n//*                from the CBR3750I EXEC                           *   FILE 720\n//*                                                                 *   FILE 720\n//*     IEAVMXIT - WTO/WTOR exit that will process all MVS          *   FILE 720\n//*                messages that are defined for automation in      *   FILE 720\n//*                the MSGTABLE entry                               *   FILE 720\n//*                                                                 *   FILE 720\n//*     INRECXIT - Assembler Network Print Facility (NPF) input     *   FILE 720\n//*                record exit for inserting HP PCL in the print    *   FILE 720\n//*                stream. NPF was free from IBM, so if you are     *   FILE 720\n//*                using it, the exit might help                    *   FILE 720\n//*                                                                 *   FILE 720\n//*     LCB      - REXX EXEC that can be executed from ISPF 3.4     *   FILE 720\n//*                data set list, to issue an IDCAMS LISTCAT        *   FILE 720\n//*                and return the information in an ISPF Browse     *   FILE 720\n//*                session. EXEC includes the code to display       *   FILE 720\n//*                the last modified TIMESTAMP as something you     *   FILE 720\n//*                can read                                         *   FILE 720\n//*                                                                 *   FILE 720\n//*     MESSAGE  - Assembler MACRO used to build MSGTABLE used      *   FILE 720\n//*                by IEAVMXIT.  Macro is located in                *   FILE 720\n//*                SYS2.ISPF.LOCAL.MACLIB                           *   FILE 720\n//*                                                                 *   FILE 720\n//*     MSGTABLE - Assembler table created by the ISPF/REXX         *   FILE 720\n//*                AutoOps interface, and contains all of the       *   FILE 720\n//*                messages to be processed by IEAVMXIT             *   FILE 720\n//*                                                                 *   FILE 720\n//*     MSGTABLE - Assembler Table used by AutoOps application.     *   FILE 720\n//*                It is built using the supplied ISPF/REXX         *   FILE 720\n//*                panels and EXECs included in this PDS. It        *   FILE 720\n//*                currently contains sample entries that           *   FILE 720\n//*                should be removed when you are ready to use      *   FILE 720\n//*                it.                                              *   FILE 720\n//*                                                                 *   FILE 720\n//*     OPSAUTO  - JCL PROC used by the AutoOps application and     *   FILE 720\n//*                invoked as an MVS START command from the         *   FILE 720\n//*                IEAVMXIT                                         *   FILE 720\n//*                                                                 *   FILE 720\n//*     PDSPCLOD - PC REXX EXEC to take the output from PDSUNLDV    *   FILE 720\n//*                program and place the members in a directory     *   FILE 720\n//*                on your PC                                       *   FILE 720\n//*                                                                 *   FILE 720\n//*     PDSRELDV - Assembler program to rebuild a PDS from the      *   FILE 720\n//*                PDSUNLDV program.                                *   FILE 720\n//*                                                                 *   FILE 720\n//*     PDSUNLDV - Assembler program to create a sequential         *   FILE 720\n//*                file from an FB or VB PDS, for unloading         *   FILE 720\n//*                from the mainframe. Use PDSPCLOD REXX EXEC       *   FILE 720\n//*                on your Personal Computer to unload the          *   FILE 720\n//*                members into a directory (you can download       *   FILE 720\n//*                REGINA if you want to run REXX on your PC).      *   FILE 720\n//*                Does not retain the ISPF STATs info.             *   FILE 720\n//*                                                                 *   FILE 720\n//*     SSCLKPDS - Assembler program that allows the SSCUCPDS       *   FILE 720\n//*                program to issue Multiple change commands.       *   FILE 720\n//*                The name of the SSCUCPDS program is              *   FILE 720\n//*                contained in this program, so if you change      *   FILE 720\n//*                it, you must change it in this program as        *   FILE 720\n//*                well.                                            *   FILE 720\n//*                                                                 *   FILE 720\n//*     SSCUCPDS - Assembler program written in 1984 to perform     *   FILE 720\n//*                mass edits of multiple PDS or sequential         *   FILE 720\n//*                files. Originally used as a migration tool       *   FILE 720\n//*                for doing massive changes to libraries with      *   FILE 720\n//*                JCL. Program only works on RECFM FB, LRECL 80    *   FILE 720\n//*                files, because it maintains the integrity of     *   FILE 720\n//*                column 72 within the code.  The default is to    *   FILE 720\n//*                show you what the changes would look like        *   FILE 720\n//*                before actually changing the files. Once         *   FILE 720\n//*                satisfied, specify PARM=CHGE to perform the      *   FILE 720\n//*                change. Program also has a parameter function    *   FILE 720\n//*                to SCAN PDS files, without doing any changes.    *   FILE 720\n//*                SSCLKPDS program was written later, so that      *   FILE 720\n//*                multiple change input control cards could be     *   FILE 720\n//*                supplied.                                        *   FILE 720\n//*                                                                 *   FILE 720\n//*     SYSURDR  - Assembler program that will allow you to         *   FILE 720\n//*                build and submit a job from the Operator         *   FILE 720\n//*                Console. Program issues WTORs, and when          *   FILE 720\n//*                complete, submits the job for execution. I       *   FILE 720\n//*                saw this done on DOS/VSE and thought it was      *   FILE 720\n//*                a good idea if the network was done. REXX        *   FILE 720\n//*                using the ALXRWTOR assembler function would      *   FILE 720\n//*                be easier to maintain, but I figured I'd         *   FILE 720\n//*                include this program.                            *   FILE 720\n//*                                                                 *   FILE 720\n//*     SUBTTIME - REXX EXEC that will take two date/time           *   FILE 720\n//*                fields as input arguments, and calculate the     *   FILE 720\n//*                time difference. Found it useful in AutoOps      *   FILE 720\n//*                when making a decision on the frequency of       *   FILE 720\n//*                an occurrence                                    *   FILE 720\n//*                                                                 *   FILE 720\n//*     TAPESTCK - Assembler program that was originally written    *   FILE 720\n//*                to convert from 3480 tape to 3590 tape.          *   FILE 720\n//*                Program will stack the input files on to the     *   FILE 720\n//*                output tape, and build the necessary IDCAMS      *   FILE 720\n//*                DELETE/DEFINE control cards to recatalog the     *   FILE 720\n//*                input files to the new media.  Also builds       *   FILE 720\n//*                CA1 SCRATCH control cards, if you need them.     *   FILE 720\n//*                Will support 64k blocks.                         *   FILE 720\n//*                                                                 *   FILE 720\n//*     VARYOFF  - REXX EXEC that uses ALXRDASD REXX function       *   FILE 720\n//*                and input control cards to vary selected         *   FILE 720\n//*                DASD offline at IPL time. Allows you to          *   FILE 720\n//*                specify selection criteria                       *   FILE 720\n//*                                                                 *   FILE 720\n//*     VARYOFFJ - Started Task JCL for invoking VARYOFF EXEC       *   FILE 720\n//*                                                                 *   FILE 720\n//*     VARYOFFP - Control card input to VARYOFF EXEC               *   FILE 720\n//*                                                                 *   FILE 720\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALEXCMDS": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x02\\xd0\\x02\\xd0\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 720, "newlines": 720, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'ALEXCMDS - PROGRAM TO PERFORM OPERATOR FUNCTIONS'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 31                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  *** APF AUTHORIZED ***                           *\n*                  LINK WITH ALEXTDAT TO SUPPORT DATE PROCESSING    *\n*                                                                   *\n* DESCRIPTION -                                                     *\n*                                                                   *\n*  PROGRAM TO PASS MVS COMMANDS THROUGH AN SVC 34.                  *\n*     SVC 34 IS ISSUED IN PSW KEY 0, WHICH IS SET BY THE 'MODESET'  *\n*  MACRO. ONCE THE SVC 34 IS FINISHED THE PSW KEY MUST BE RESET TO  *\n*  THE PROBLEM PROGRAM STATE USING THE 'MODESET' MACRO AGAIN. INPUT *\n*  IS PROVIDED BY THE DDNAME 'CMDIN' FOR BOTH THE VERIFICATION AND  *\n*  THE ACTUAL COMMANDS.                                             *\n*     SPECIAL FUNCTIONS ARE ALSO INCLUDED AND MUST SPECIFY THE      *\n*  ACTION IN COLUMN 1 OR ELSE IT WILL BE TREATED AS A COMMAND.      *\n*                                                                   *\n*********************************************************************\nALEXCMDS CSECT\n* CHANGE TO 31 BIT PROCESSING   WHS 6/16/04\nALEXCMDS AMODE 31\nALEXCMDS RMODE 24\n         PRINT ON,NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n****************************************************************\n*  SAVE LOGIC AND ENTRY SETUP OF PROGRAM.                      *\n****************************************************************\n         STM   R14,R12,12(R13)     SAVE IN CALLERS SAVEAREA\n         LR    R12,R15\n         LA    R6,2048(R12)\n         LA    R6,2048(R6)\n         USING ALEXCMDS,R12,R6\n         LA    R3,STORAGE_SIZE     GET THE SIZE OF OUR STORAGE\n         GETMAIN R,LV=(3)\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)           SAVE OUR SAVERAREA\n         ST    R13,4(R1)           SAVE THEIR SAVEAREA\n         LR    R13,R1              LOAD OURS\n         USING STORAGE,R13\n         LA    R1,PARMLIST         SAVE THE ADDRESS\n         ST    R1,PARM_ADDRESS\n         LA    R1,PARM_ADDRESS\n         ICM   R15,15,ALEXTDAT\n         BZ    OPENFILE\n*        L     R15,ALEXTDAT\n         BALR  R14,R15\n***********************\n*  VERIFY A HOLIDAY DD STATEMENT EXIST BEFORE TRYING TO OPEN\n         RDJFCB HOLIDAY\n         LTR   R15,R15           DID THEY EVEN SPECIFY A HOLIDAY FILE\n         BNZ   OPENFILE          NO, THEN DO NOT TRY TO OPEN\n         OPEN  (HOLIDAY,INPUT),MODE=31\n         TM    HOLIDAY+48,X'10'  GOOD OPEN\n         BZ    OPENFILE          NO, THEN JUST GO AROUN\nLOOPHOL  GET   HOLIDAY\n         CLI   0(R1),C'*'        IS THIS A COMMENT\n         BE    LOOPHOL           YES, THEN GET NEXT RECORD\n         CLC   DATE(8),0(R1)       COMPARE THE DATES\n         BNE   LOOPHOL           NO, THEN READ NEXT\n         OI    FLAG,X'02'        YES, THEN SET FLAG AND CONTINUE\nEODHOL   CLOSE (HOLIDAY),MODE=31\n***********************\nOPENFILE EQU   *\n         OPEN  (CMDIN,INPUT),MODE=31\n         TM    CMDIN+48,X'10'      WAS OPEN SUCCESSFUL\n         BO    GETAREC             YES, THEN CONTINUE\n         WTO   'CMDIN DDNAME NOT OPENED. NO COMMANDS.',ROUTCDE=2\n         MVI   RETCODE+3,X'10'        EXIT WITH RC 16\n         B     FREESTOR               EXIT WITH OTHER THAN 0 RC\n         EJECT\n**********************************************************************\n* WE WILL PROCESS THE COMMANDS THEMSELVES NOW. THE END OF THE RECORD *\n* WILL BE CHECKED UNTIL THE FIRST NON-BLANK IS FOUND. COMMAND WILL   *\n* THEN BE MOVED TO THE COMMAND AREA OF SVC 34.                       *\n**********************************************************************\nGETAREC  GET   CMDIN               GET A RECORD\n         CLI   0(R1),C'*'          IS THIS STATEMENT A COMMENT\n         BE    GETAREC             YES, THEN GO NEXT RECORD\n         LR    R9,R1\n         TM    FLAG,X'01'          IS THIS A CONTINUATION\n         BZ    NOT_CONTINUE\n         NI    FLAG,X'FE'          RESET CONTINUATION\n         LA    R15,70(R9)          INCREMENT OA\n         CLI   71(R9),C'C'         TWO CONTINUATIONS NOT ALLOWED\n         BE    BADCONT\nLOOPCONT CLI   0(R15),C' '         IS IT A NON-BLANK\n         BNE   ENDCONT             YES, THEN GET OUT OF LOOP\n         BCTR  R15,0               NO, DECREMENT R15 AND TRY AGAIN\n         CR    R9,R15\n         BL    LOOPCONT\n         B     BAD_COMMAND\nENDCONT  LH    R14,LENGTH_INPUT    LENGTH\n         LA    R2,INPUT_RECORD\n         LA    R2,0(R2,R14)        INCR PAST THE FIRST PART OF RECORD\n         SR    R15,R9\n         EX    R15,MOVE_COMMANDC   MVC  0(0,R2),0(R9)\n         LA    R15,1(R14,R15)      ADD THE TWO LENGTHS\n         STH   R15,LENGTH_INPUT    SAVE IT\n         B     CONTINUE\n*************************************************************\nNOT_CONTINUE   EQU  *\n         MVC   FUNCTION_BYTE(1),0(R9)    SAVE THE FUNCTION BYTE\n         MVI   INPUT_RECORD,C' '         CLEAR THESE TWO AREAS\n         MVC   INPUT_RECORD+1(141),INPUT_RECORD  TO BLANKS BEFORE WE\n         MVC   COMMAND_TEXT(126),INPUT_RECORD    WE START\n         TRT   0(40,R9),NBLANK\n         BZ    GETAREC\n         LA    R15,70(R9)          POINT TO 71ST BYTE OF RECORD\n         CLI   71(R9),C'C'         IS THIS A CONTINUATIONS\n         BE    ENDCMD              YES, THEN MOVE IT ALL\nLOOPIT   CLI   0(R15),C' '         IS IT A NON-BLANK\n         BNE   ENDCMD              YES, THEN GET OUT OF LOOP\n         BCTR  R15,0               NO, DECREMENT R15 AND TRY AGAIN\n         CR    R1,R15              JUST MAKE SURE THERE WILL BE DATA\n         BL    LOOPIT              YES, THEN KEEP LOOKING\n         B     BAD_COMMAND         IF WE GOT HERE THEN JUST EXIT\nENDCMD   SR    R15,R1\n         EX    R15,MOVE_RECORD     MVC  INPUT_RECORD(0),0(R1)\n         LA    R15,1(R15)          INCR FOR EXECUTE\n         STH   R15,LENGTH_INPUT    SAVE THE LENGTH\n         CLI   71(R9),C'C'         IS IT A CONTINUATION\n         BNE   CONTINUE            SEE IF CONTINUATION\n         OI    FLAG,X'01'          FLAG FOR CONTINUATION\n         B     GETAREC             READ THE NEXT RECORD\n*************************************************************\nCONTINUE EQU   *\n         LA    R9,INPUT_RECORD     POINT TO BEGINNING OR RECORD\n         CLI   FUNCTION_BYTE,C'+'  DO WE WANT TO ISSUE A ROLL MSG\n         BE    ITSWTO              YES, THEN PROCESS WTO\n         CLI   FUNCTION_BYTE,C'@'  DO WE WANT TO ISSUE A NO ROLL MSG\n         BNE   DOCMDS              NO, THEN GO DO COMMANDS\n*************************************************************\nITSWTO   LH    R15,LENGTH_INPUT\n         BCTR  R15,0               REMOVE ONE FOR WTO CHAR, 1ST BYTE\n         CH    R15,HW126           MAKE SURE NOT TOO LONG\n         BNH   OKWTOLNG\n         LH    R15,HW126           IF TOO LONG THEN DECREMENT\nOKWTOLNG STH   R15,WTO_LENGTH      SAVE THE LENGTH\n         BCTR  R15,0               REMOVE ONE MORE FOR MOVE\n         EX    R15,MOVE_WTO        MVC  COMMAND_TEXT(0),1(R9)\n         LA    R4,WTO_LENGTH       ADDRESS FOR WTO\n         CLI   0(R9),C'+'          CHECK AGAIN FOR TYPE OF WTO\n         BNE   NOROLL\n         WTO   TEXT=((4))\n         B     GETAREC\nNOROLL   EQU   *\n         WTO   TEXT=((4)),DESC=11\n         B     GETAREC\n*************************************************************\nDOCMDS   CLI   FUNCTION_BYTE,C'#'  DO WE WANT TO ISSUE A WAIT (STIMER)\n         BE    DOWAIT              YES, THEN GO ISSUE STIMER\n         CLI   FUNCTION_BYTE,C'?'  DO WE WANT TO REPLY TO A WTOR\n         BE    REPLYTO             YES, THEN GO FIND MESSAGE\n         CLI   FUNCTION_BYTE,C'%'  DO WE WANT TO SEE A TASK ACTIVE\n         BE    DOSTOP              YES, THEN SEARCH ACTIVE ASCB\n         CLI   FUNCTION_BYTE,C'='  DO WE WANT TO CHECK THE TIME FOR JES\n         BE    DOAUTO              YES, THEN GO LOOK AT AUTOMATIC CMD\n         CLI   FUNCTION_BYTE,C'/'  DO WE WANT TO EXECUTE A REXX EXEC\n         BE    DOREXX              YES, THEN GO LOOK AT AUTOMATIC CMD\nISSUECMD LH    R15,LENGTH_INPUT\n         CH    R15,HW126           MAKE SURE NOT TOO LONG\n         BNH   OKCMDLNG\n         LH    R15,HW126           IF TOO LONG THEN DECREMENT\nOKCMDLNG BCTR  R15,0               REMOVE ONE MORE FOR MOVE\n         EX    R15,MOVE_COMMAND    MVC  COMMAND_TEXT(0),INPUT_RECORD\n         LA    R15,5(R15)          INCR FOR EX AND TWO HW'S\n         XC    WTO_LENGTH(2),WTO_LENGTH  CLEAR TO ZERO\n         STH   R15,MVS_COMMAND     SAVE THE LENGTH\n*******************************************************************\n*   IN ORDER TO ISSUE AN SVC 34 THE PSW KEY MUST BE 0 AND BE IN   *\n*  THE SUPERVISOR STATE. AFTER SVC IS ISSUED RETURN TO PROPER KEY *\n*  AND MODE.                                                      *\n*******************************************************************\n         MODESET MF=(E,SUPRMOD)\n         LA    R1,MVS_COMMAND          GET ADDRESS IN R1\n         SR    R0,R0               CLEAR R0\n         SVC   34                  ISSUE SVC\n         MODESET MF=(E,PROBMOD)\n         B     GETAREC             GET ANOTHER RECORD\n*************************************************************\n*  PROCESS A REXX EXEC HERE                                 *\n*************************************************************\nDOREXX   LH    R15,LENGTH_INPUT\n         BCTR  R15,0               REMOVE ONE FOR REXX /, 1ST BYTE\n         STH   R15,WTO_LENGTH      SAVE THE LENGTH\n         CLI   1(R9),C' '          MAKE SURE 2ND BYTE IS EXEC NAME\n         BE    BAD_COMMAND         IF BLANK, THEN JUST GIVE UP\n         TRT   1(9,R9),BLANK       MAKE SURE 8 OR LESS CHARACTERS\n         BZ    BAD_COMMAND         NO, THEN IT IS BAD\n         BCTR  R15,0               REMOVE ONE MORE FOR MOVE\n         EX    R15,MOVE_WTO        MVC  COMMAND_TEXT(0),1(R9)\n         LA    R4,WTO_LENGTH       ADDRESS FOR WTO\n         ICM   R15,15,ADDRESS_IRXJCL\n         BNZ   CALL_IRXJCL\n         LOAD  EP=IRXJCL,ERRET=NOREXX\n         ST    R0,ADDRESS_IRXJCL\n         LR    R15,R0\nCALL_IRXJCL    EQU  *\n* COMMENT OUT CODE TO SET 31 BIT     WHS  6/16/04\n*        LA    R14,SET31CALL     GET ADDRESS FOR BR AND SET MASK\n*        ICM   R14,8,=X'80'      TURN ON HI ORDER BIT\n*        BSM   R0,R14            SET TO 31 BIT MODE\nSET31CALL EQU  *\n         CALL  (15),((4)),VL\n*        LA    R14,GETAREC       GET ADDRESS FOR BR AND SET MASK\n*        ICM   R14,8,=X'00'      TURN ON HI ORDER BIT\n*        BSM   R0,R14            SET BACK TO 24 BIT MODE\n         B     GETAREC           RETURN   WHS  6/16/04\n*************************************************************\n*  ISSUE STIMER HERE            COMMAND R9 BEGINNING        *\n*************************************************************\nDOWAIT   LA    R10,1(R9)          POINT TO BYTE AFTER #\nFINDWAIT TRT   0(7,R10),NBLANK    FIND FIRST NON BLANK\n         BZ    BAD_COMMAND\nFOUNDWT  CLC   0(5,R1),=C'WAIT='  VERIFY VALID COMMAND SYNTAX\n         BNE   BAD_COMMAND        NO, THEN TAKE DEFAULT VALUE\n         LA    R10,5(R1)          POINT TO FIRST CHARACTER\n         LR    R15,R10            SAVE THE LOCATION FOR SUBTRACT\n         SR    R15,R9             GET RID OF BEGINNING\n         LH    R11,LENGTH_INPUT   GET THE OVERALL LENGTH\n         SR    R11,R15            GET THE REMAINING LENGTH\n         LTR   R11,R11            SEE IF ZERO LENGTH\n         BNP   DOSTIMER\n         CH    R11,HW3            THIS IS THE MAXIMUM WAIT\n         BH    SETMAX             IF GT THEN SET MAX WAIT\n         BCTR  R11,0              DECR ONCE FOR EX\n         EX    R11,TRTNUMBR        VERIFY NUMERIC\n         BNZ   BAD_COMMAND         NO, THEN DO NOT LET GET S0C7\n         A     R11,=F'112'        THIS WILL ADD X'70' FOR L1 OF PACK\n         EX    R11,PACKTIME           MOVE IN THE TIME\n         CVB   R15,DOUBLE_WORD         AND CONVERT TO BINARY\n         MH    R15,HW100             MULTIPLY FOR BINARY TIME\n         ST    R15,BINARY          SAVE FOR STIMER\n         B     DOSTIMER           ISSUE STIMER\nSETMAX   MVC   BINARY(4),=F'60000' YES, SET UPPER LIMIT VALUE\nDOSTIMER EQU   *\n         STIMER WAIT,,BINTVL=BINARY\n         B     GETAREC              GET NEXT RECORD\n****************************************************************\n****************************************************************\nREPLYTO  LA    R11,1(R9)             POINT TO BYTE PAST ?\n* DIFFERENT ERROR MESSAGE\n*        MVC   WTOREPLY+8(30),0(R9)   STORE THIS FOR INVALID MSG\n         TRT   0(8,R11),NBLANK       LOOK FOR BEGINNING\n         BZ    BAD_COMMAND           IF BAD TELL AND GET NEXT\n         CLC   0(2,R1),=C'M='        BEGINNING OF MESSAGE FIELD\n         BNE   BAD_COMMAND           IF NOT THERE THEN FORGET IT\n         LA    R11,2(R1)             POINT TO ACTUAL MESSAGE\n         TRT   0(12,R11),SEMICOL     FIND DELIMITER, MSG MAX OF 12\n         BZ    BAD_COMMAND           12 OR GT THEN ERROR\n         SR    R1,R11                 GET LENGTH\n         BCTR  R1,0                  DECR FOR EXECUTE INSTR\n         STH   R1,MSGID_COMPARE     SAVE FOR LATER COMPARE\n         EX    R1,MOVEMSG           MVC REPMSGID(0),0(R11)\n         LA    R11,2(R1,R11)        POINT TO REPLY AREA\n         CLC   0(2,R11),=C'R='      REPLY FORMAT BEGINNING\n         BNE   BAD_COMMAND          NO, THEN TELL HIM TO FORGET IT\n         LA    R11,2(R11)           POINT TO FIRST BYTE OF REPLY\n         LH    R1,LENGTH_INPUT      GERT THE LENGTH IN REG1\n         LA    R1,INPUT_RECORD(R1)  POINT TO END OF DATA\n         BCTR  R1,0                 BACK UP ONE BYTE\n         CLI   0(R11),X'7D'         ENCLOSED IN SINGLE QUOTES\n         BNE   ENDREPLY             NO, SUBTRACT LENGTH\n         LA    R11,1(R11)           INCREMENT ONE PAST\n         CLI   0(R1),X'7D'          VERIFY THAT LAST BYTE IS QUOTE\n         BNE   BAD_COMMAND          NOT FOUND, THEN JUST EXIT\n         BCTR  R1,0                 DECR ONE MORE FOR TIC MARK\nENDREPLY SR    R1,R11               GET LENGTH OF REPLY\n*DECRREP1 BCTR  R1,0                DON'T DECR\n         MVI   COMMAND_TEXT,C' '    BLANK OUT COMMAND\n         MVC   COMMAND_TEXT(125),COMMAND_TEXT    CLEAR IT\n         EX    R1,MVEREPLY         MVC  COMMAND_TEXT+5(0),0(R11)\n         LA    R15,11(R1)          GET LENGTH OF COMMAND IN R15\n         STH   R15,MVS_COMMAND         SAVE IT\n         XC    WTO_LENGTH(2),WTO_LENGTH\n         L     R2,16              CVT\n         USING CVT,R2\n         L     R3,CVTCUCB         UCMBASE\n         USING UCM,R3\n         LH    R4,UCMCTID         CONSOLE ADDRESS SPACE\n         STH   R4,CONSASID        SAVE THE CONSOLE ADDR SPACE ID\n         LR    R4,R3              RESET R4\n         SH    R4,=H'4'           GO BACK 4 SPACES\n         L     R4,0(R4)           UCM PREFIX\n         USING UCMPRFX,R4\n         L     R14,UCMMCENT       ADDRESS OF UCM FOR MASTER CONSOLE\n         USING UCMLIST,R14\n         XR    R15,R15            CLEAR R15 FOR INSERT\n         IC    R15,UCMID          GET ID OF MASTER CONSOLE\n         STH   R15,MASTCONS       SAVE IT FOR LATER\n         L     R15,UCMASCB        GET ASCB OF COMMTASK ADDRESS SPACE\n         ST    R15,COMMASCB       AND PUT IT AWAY\n         DROP  R2,R14\n         MODESET MF=(E,SUPRMOD)\n         ESAR  R2                 GET SECONDARY ADDRESS SPACE\n         ST    R2,SASID           STORE IT AWAY FOR LATER\n         AXSET AX=ONE             GET AUTHORIZATION ANYWHERE\n         LH    R2,CONSASID        LOAD UP ASID OF CONSOLE ADDRESS SPACE\n         SSAR  R2\n*                                 MODE (CONSOLE ASID)\n         L     R11,COMMASCB       GET ASCB OF COMM TASK\n         ST    R9,R9SAVE          SAVE REGISTER 9 FOR RELOAD\n         LR    R9,R13             TEMPORARILY ADDRESS R13 STORAGE\n         DROP  R13\n         USING STORAGE,R9\n         LA    R13,LOCKSAVE       LOAD UP SAVEAREA FOR LOCK\nGETLOCK  SETLOCK OBTAIN,TYPE=CML,ASCB=(11),REGS=USE,MODE=UNCOND,       X\n               RELATED=(CONASCB,RELLOCK)\n* ADDED 31 BIT ADDRESSING MODE FOR MVS/ESA 4.3\n* COMMENTED IT OUT BECAUSE IT'S ALL 31BIT   WHS  6/16/04\nREPLYIT  EQU   *\n*        LA    R14,SET31BIT      GET ADDRESS FOR BR AND SET MASK\n*        ICM   R14,8,=X'80'      TURN ON HI ORDER BIT\n*        BSM   R0,R14            SET TO 31 BIT MODE\n* WE WILL SEARCH THE CHAIN OF ORE ELEMENTS, LOOKING FOR ONE WITH A\n* WQE TO MATCH WHAT WE WANT.\nSET31BIT L     R4,UCMRPYQ         LOAD ADDRESS OF FIRST ORE ENTRY\n*        LA    R4,0(R4)           ** CLEAR HIGH ORDER BYTE **\n         LTR   R4,R4              IF NO OUTSTANDING WTORS\n         BZ    FINMSG             THEN GET TO END OF LOOP\n         LA    R7,20              OTHERWISE, ASSUME AT MOST 20.\n         USING OREF,R4\nORELOOP  DS    0H\n         L     R5,ORERWQE         GET ASSOCIATED WQE\n         USING WQE,R5             ADDRESS IT\n********************************************************************\n********************************************************************\n* HERE WE KNOW WE ARE LOOKING FOR MESSAGE TEXT\n********************************************************************\nLOOKMSG  DS    0H\n         LA    R10,70            MAX LENGTH IN R10\n         SLR   R15,R15           CLEAR FOR MOVE CHAR PRIMARY\n         LA    R11,MSG           ADDRESS MESSAGE AREA\n         LA    R8,WQETXT+4       ADDRESS MESSAGE\n         MVCP  0(R10,R11),0(R8),R15     MOVE IN 70 BYTES OF MSG\n         LH    R1,MSGID_COMPARE   RELOAD VALUE\n         EX    R1,COMPMSG         CLC  REPMSGID(0),0(R11)\n         BE    GOTMSG             GOT THE MESSAGE\nTRYNEXT  DS    0H\n         L     R4,ORELKP          TRY NEXT ORE\n*        LA    R4,0(R4)           ** CLEAR HIGH ORDER BYTE **\n         LTR   R4,R4              IS THERE ANYTHING THERE\n         BZ    FINMSG             NO, THEN WE ARE FINISHED\n         BCT   R7,ORELOOP         SEARCH NO MORE THAN 20\n         B     FINMSG             AND GET OUT OF CROSS MEM LOOP\nGOTMSG   DS    0H\n         MVI   COMMAND_TEXT,C'R'  MOVE IN REPLY COMMAND\n         MVC   COMMAND_TEXT+2(2),OREID AND ID FROM OPER REQ ELEMENT\n         MVI   COMMAND_TEXT+4,C',' AND DELIMETER R XX,\n         OI    FLAG,X'80'         SET FLAG FOR REPLY\nFINMSG   EQU   *\n* COMMENTED OUT   WHS   6/16/04\n*        LA    R14,SET24BIT      GET ADDRESS FOR RETURN BSM\n*        N     R14,=X'7FFFFFFF'  TURN OFF HI ORDER BIT\n*        BSM   R0,R14            SET TO 31 BIT MODE\nSET24BIT L     R2,SASID                  GET BACK ID OF SAVED ASID\n         SSAR  R2\n         L     R11,COMMASCB       GET ASCB OF COMM TASK\nRELLOCK  SETLOCK RELEASE,TYPE=CML,ASCB=(11),                           X\n               RELATED=(CONASCB,GETLOCK)\n         LR    R13,R9\n         L     R9,R9SAVE\n         DROP  R9\n         USING STORAGE,R13\n*********************************************************8\n*  ISSUE REPLY\n         TM    FLAG,X'80'          DID WE WANT TO ISSUE A REPLY\n         BZ    SETPROB             NO, THEN GO BACK TO PROBLEM STATE\n         NI    FLAG,X'7F'          RESET FLAG\n         LA    R1,MVS_COMMAND      GET ADDRESS IN R1\n         LA    R1,0(R1)            CLEAR HI-ORDER BYTE\n         SR    R0,R0               CLEAR R0\n         SVC   34                  ISSUE SVC\nSETPROB  EQU   *\n         DROP  R3,R4,R5\n         MODESET MF=(E,PROBMOD)\n         B     GETAREC\n*************************************************************\n*  SEARCH ACTIVE ASCB TO FIND JOB                         * *\n*************************************************************\nDOSTOP   LA    R10,1(R9)          POINT TO BYTE AFTER #\n         TRT   0(8,R10),NBLANK    FIND FIRST NON BLANK\n         BZ    GETAREC            NO, THEN JUST READ NEXT RECORD\nFOUNDSP  CLC   0(5,R1),=C'STOP=' VERIFY VALID COMMAND SYNTAX\n         BE    GOTSTOP           YES, THEN CONTINUE\n         CLC   0(5,R1),=C'STRT=' VERIFY VALID COMMAND SYNTAX\n         BNE   GETAREC            NO, THEN LEAVE ALONE\n         OI    FLAG,X'08'         SET FOR ISSUING CMDS\nGOTSTOP  LA    R10,5(R1)          POINT TO FIRST CHARACTER\nSTOPSEMI TRT   0(9,R10),SEMICOL   SEE IF DELIMETER\n         BZ    STOPBLNK           WILL NOT PROCESS\n         OI    FLAG,X'40'         SET FLAG TO SAY DATA AFTER STOP\n         LA    R11,1(R1)          POINT TO BYTE PAST\n         B     GOTLSTJ            BRANCH AROUND\nSTOPBLNK TRT   0(9,R10),BLANK     FIND BLANK AFTER STOP\n         BZ    GETAREC            NO, THEN JUST FORGET IT\nGOTLSTJ  SLR   R1,R10             GET LENGTH IN R1\n         LTR   R1,R1              IS LENGTH ZERO\n         BZ    GETAREC            YES, THEN JUST FORGET THIS\n         BCTR  R1,0               DECREMENT FOR MOVE\n         MVC   JOBNAME(8),BLANKS  BLANK IT OUT TO START CLEAN\n         EX    R1,MVEJOB          MOVE IN JOB NAME TO SEARCH ASCB\n         TM    FLAG,X'40'         IS THERE AN ACTION IN THIS COMMAND\n         BZ    GOTHRUAS           NO, THEN GO SEARCH ASCB\n         LR    R10,R11            SAVE R11 FOR LATER\n         LA    R1,70              GET OVERALL LENGTH TO PARSE\n         SLR   R11,R9             GET LENGTH IN R11\n         SLR   R1,R11             AND NOW LENGTH OF COMMAND OR WTO\n         LR    R3,R1              SAVE IN R3 FOR LENGTH\n         LA    R11,70(R9)         POINT R11 TO END OF CONTROL CARD\n         LR    R9,R10             READDR R9 TO BEGGINING OF CMD OR WTO\nGOTHRUAS L     R15,16             CVT ADDRESS\n         USING CVT,R15\n         L     R15,CVTASVT         ASVT (ADDR SPACE VECTOR TABLE)\n         DROP  R15\n         USING ASVT,R15\n         L     R5,ASVTSTRT         SIZE OF START/SASI QUEUE\n         L     R1,ASVTNONR         SIZE OF NON-REUSABLE QUEUE\n         AR    R5,R1               COMBINE\n         L     R1,ASVTMAXI         MAXUSER\n         AR    R5,R1               TOTAL IS LOOP THRU ASVT\n         LA    R14,ASVTFRST       POINTER FIRST ENTRY\nLOOPASVT ICM   R1,15,0(R14)      LOAD UP ASCB ADDRESS OR NEXT ASVT\n         BC    13,INCRASVT       BIF HI ORDER ZERO AND REST 0\n         L     R15,176(R1)       LOAD POINTER TO JOB NAME\n         LTR   R15,R15           ANYTHINGTHERE\n         BZ    INCRASVT          NO, THEN GET NEXT ADDRESS\n         CLC   0(8,R15),=C'INIT    '  IS IT A BATCH JOB\n         BNE   COMPJOBN          NO, THEN COMPARE WHERE IT IS\n         L     R15,172(R1)       GET ADDRESS OF BATCH JOBNAME\n         LTR   R15,R15           ANYTHING ACTIVE IN THIS INITIATOR\n         BZ    INCRASVT          NO, THEN GET NEXT ONE\nCOMPJOBN CLC   JOBNAME(8),0(R15) IS THIS OUR JOB\n         BE    GOTASID           YES, THEN STOP LOOKING\nINCRASVT LA    R14,4(R14)        POINT TO NEXT ADDRESS\n         BCT   R5,LOOPASVT       LOOP THRU ALL ADDRESSES\nASIDCMD  TM    FLAG,X'40'           DO WE HAVE AN ACTION TO PERFORM\n         BZ    GETAREC              NO, THEN JUST GET NEXT RECORD\n         NI    FLAG,X'BF'           RESET 40\n         TM    FLAG,X'08'           WAS THIS A STRT=\n         BZ    SEEIF_WTOSTOP        NO, THEN CHECK IF WTO TO ISSUE\n         NI    FLAG,X'F7'           RESET FLAG AND GO BACK\n         B     GETAREC              GET NEXT RECORD\nSEEIF_WTOSTOP  EQU  *\n* FIRST CHECK TO SEE IF THEY WANT TO WAIT A LITTLE BIT\n         LR    R14,R9\n         LA    R15,INPUT_RECORD    POINT TO BEGINNING\n         LH    R2,LENGTH_INPUT     GET INITIAL LENGTH OF DATA\n         SR    R14,R15             REMOVE THE BEGINNING\n         SR    R2,R14              AND TAKE AWAY FROM OVERALL\n         STH   R2,LENGTH_INPUT     SAVE IT BACK\n         CLI   0(R9),C'#'          DID WE WANT TO WAIT ?\n         BE    DOWAIT              YES, THEN GO PROCESS WAIT\n         CLI   0(R9),C'+'          DO WE WANT TO ISSUE A ROLL MSG\n         BE    ITSWTO              YES, THEN GO DO THE WTO\n         CLI   0(R9),C'@'          DO WE WANT TO ROLL THE MESSAGE\n         BE    ITSWTO              YES, THEN GO DO THE WTO\n         CLI   0(R9),C'/'          DO WE WANT TO EXECUTE A REXX EXEC\n         BE    DOREXX              YES, THEN GO EXECUTE IT\n         B     ISSUECMD             NO, THEN ISSUE CMD FOR STOP\nGOTASID  TM    FLAG,X'40'     DID WE HAVE A ; FOR TAKING AN ACTION\n         BZ    NOSTOP         NO, THEN SET RC TO 12 AND CONTINUE\n         NI    FLAG,X'BF'     RESET THIS FLAG\n         TM    FLAG,X'08'     WAS THIS A STRT= REQUEST\n         BZ    GETAREC        NO, THEN JUST GET NEXT RECORD\n         NI    FLAG,X'F7'          RESET FLAG\n* WE ARE GOING TO CHECK TO SEE IF THEY WANTED TO WAIT LONGER\n         LR    R14,R9\n         LA    R15,INPUT_RECORD    POINT TO BEGINNING\n         LH    R2,LENGTH_INPUT     GET INITIAL LENGTH OF DATA\n         SR    R14,R15             REMOVE THE BEGINNING\n         SR    R2,R14              AND TAKE AWAY FROM OVERALL\n         STH   R2,LENGTH_INPUT     SAVE IT BACK\n         CLI   0(R9),C'#'          DID WE WANT TO WAIT ?\n         BE    DOWAIT              YES, THEN GO PROCESS WAIT\n         CLI   0(R9),C'+'          DO WE WANT TO ISSUE A ROLL MSG\n         BE    ITSWTO              YES, THEN SET IT TO ROLL\n         CLI   0(R9),C'@'          DO WE WANT TO ROLL THE MESSAGE\n         BE    ITSWTO              NO, THEN JUST ISSUE COMMAND\n         B     ISSUECMD\n* NOSTOP WAS OLD CODE TO SET RC 12 IF NO ACTION AND STOP WAS\n* REQUESTED. LEFT IT IN, BUT DID NOT EXIT PROGRAM\nNOSTOP   MVI   RETCODE+3,X'0C'\n         NI    FLAG,X'F7'          RESET FLAG JUST IN CASE\n         B     GETAREC\n*************************************************************\n*  PROCESS JES2 AUTOMATIC COMMAND TO SEE IF TIME HAS PAST * *\n*************************************************************\nDOAUTO   TRT   1(60,R9),AUTOTABL     LOOK FOR $ OR ,\n         BZ    GETAREC                NOTHING, THEN GET NEXT RECORD\n         CLC   0(3,R1),=C'$TA'        IS THIS AN AUTOMATIC COMMAND\n         BNE   GETAREC                NO, THEN DO NOT ISSUE\n         LR    R14,R1                 SAVE LOCATION COUNTER\n         BCTR  R14,0                  DECREMENT OFF ONE\n         LA    R15,3(R1)              INCREMENT PAST PART OF CMD\n         TRT   0(8,R15),AUTOTABL      LOOK FOR COMMA\n         BZ    GETAREC                NOT FOUND THEN JUST READ NEXT REC\n         CLC   1(2,R1),=C'T='         DID THEY SPECIFY A TIME\n         BNE   GETAREC                NOT SURE, THEN JUST GET OUT\n         CLC   3(5,R1),=C'HH.MM'      DO THEY WANT NEXT HOUR VALUE\n         BNE   VERIFY_TIME            NO, THEN SEE IF TIME PAST\n         MVC   3(5,R1),HOURNEXT       MOVE IN NEXT HOUR VALUE\n         B     BLANK_SIGN             AND GO AROUND\nVERIFY_TIME    EQU  *\n         CLC   3(5,R1),HOUR           COMPARE OUR TIMES\n         BL    GETAREC                IF LT CURRENT TIME THEN FORGET\nBLANK_SIGN     EQU  *\n         MVI   0(R9),C' '             BLANK OUT = SIGN\n         CR    R9,R14                 SEE IF ANY DISTANCE BETWEEN $TA\n         BE    ISSUECMD               NO, THEN JUST ISSUE COMMAND\n         SR    R14,R9                 GET LENGTH TO CLEAR\n         BCTR  R14,0                  ONE MORE FOR EXECUTE\n         EX    R14,COMPARE_BLANKDAY   SEE IF ALL BLANKS ANYWAY\n         BE    ISSUECMD               YES, THEN JUST GO ISSUE CMD\n         CLC   1(5,R9),=C'EVERY'      SHOULD IT BE DONE EVERY DAY\n         BE    OKAY_TOISSUE           YES, THEN GO ISSUE IT\n         CLC   1(5,R9),=C'FIRST'      SHOULD IT BE DONE FIRST OF MONTH\n         BNE   VERIFY_LAST            NO, THEN CHECK LAST OF MONTH\n         CLC   DD(2),=C'01'           IT IS THE FIRST\n         BNE   GETAREC                NO, THEN GET NEXT RECORD\n         B     OKAY_TOISSUE           YES, THEN GO ISSUE IT\nVERIFY_LAST    EQU  *\n         CLC   1(4,R9),=C'LAST'       SHOULD IT BE DONE LAST OF MONTH\n         BNE   LOAD_WEEK              NO, THEN GET THE WEEKDAY\n         CLI   LASTDAY,C'Y'           DID WE SAY IT WAS LAST OF MONTH\n         BNE   GETAREC                NO, THEN GET NEXT RECORD\n         B     OKAY_TOISSUE           YES, THEN GO ISSUE IT\nLOAD_WEEK SLR  R1,R1                  CLEAR REG1 FOR INSERT\n         IC    R1,DAY_NUMBER          GET VALUE OF WEEKDAY HERE\n         LA    R1,1(R9,R1)            INCREMENT TO LOCATION\n         CLI   0(R1),C'H'             EVEN ISSUE ON A HOLIDAY\n         BE    OKAY_TOISSUE           YES, THEN GO ISSUE IT\n         CLI   0(R1),C' '             IS IT NON-BLANK\n         BE    GETAREC                NO, THEN DO NEXT COMMAND\n         TM    FLAG,X'02'             IS IT A HOLIDAY\n         BO    GETAREC                YES,THEN DO NEXT COMMAND\nOKAY_TOISSUE   EQU    *\n         EX    R14,BLANKDAY           BLANK OUT DATE PORTION OF CMD\n         B     ISSUECMD               AND ALLOW CMD TO BE ISSUED\n*************************************************************\nEODAD    CLOSE (CMDIN),MODE=31     CLOSE INPUT FILE AND\nFREESTOR EQU   *\n         L     R4,RETCODE\n         L     R0,GETMAIN_LENGTH\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=(0)\nRETURN   LR    R15,R4                LOAD UP OVERALL RETURN CODE\n         L     R14,12(R13)\n         LM    R0,R9,20(R13)\n         BR    R14\n         EJECT\n*************************************************************\n*  ANY PROBLEMS ENCOUNTERED SET  HERE.                      *\n*************************************************************\nNOREXX        EQU  *\n         WTO   'UNABLE TO LOAD REXX INTERFACE PROGRAM, IRXJCL'\n         B    BUILDBAD\nBADCONT       EQU  *\n         WTO   'CONTINUATION NOT ALLOWED ON MORE THAN ONE STATEMENT'\n         B    BUILDBAD\nBAD_COMMAND   EQU  *\n         WTO   'INVALID COMMAND FORMAT; VERIFY COMMAND.'\nBUILDBAD LH    R15,LENGTH_INPUT\n         CH    R15,HW126\n         BNH   DECRBAD\n         LH    R15,HW126\nDECRBAD  STH   R15,WTO_LENGTH\n         BCTR  R15,0\n         EX    R15,MOVE_COMMAND\n         LA    R4,WTO_LENGTH\n         WTO   TEXT=((4))\n         MVI   RETCODE+3,X'10'\n         B     EODAD\n*************************************************************\nCMDIN    DCB   DDNAME=CMDIN,MACRF=GL,DCBE=CMDINE,DSORG=PS\nHOLIDAY  DCB   DDNAME=HOLIDAY,MACRF=GL,DCBE=HOLIDAYE,DSORG=PS,         X\n               EXLST=JFCBLIST\nCMDINE   DCBE  RMODE31=BUFF,EODAD=EODAD\nHOLIDAYE DCBE  RMODE31=BUFF,EODAD=EODHOL\nJFCBLIST DS    0F\n         DC    X'87',AL3(JFCBAREA)\nJFCBAREA DC    176C' '\nALEXTDAT DC    V(ALEXTDAT)\nBINARY   DC    F'500'\nSUPRMOD  MODESET MODE=SUP,KEY=ZERO,MF=L\nPROBMOD  MODESET KEY=NZERO,MODE=PROB,MF=L\nMVEJOB   MVC   JOBNAME(0),0(R10)\nMOVE_WTO MVC   COMMAND_TEXT(0),1(R9)\nMOVE_RECORD     MVC  INPUT_RECORD(0),0(R1)\nMOVE_COMMANDC   MVC  0(0,R2),0(R9)\nMOVE_COMMAND    MVC  COMMAND_TEXT(0),0(R9)\nPACKTIME PACK  DOUBLE_WORD(0),0(0,R10)\nTRTNUMBR TRT   0(0,R10),NUMTABL\n**********************************************************8\nONE      DC    H'1'\nHW3      DC    H'3'\nHW100    DC    H'100'\nHW126    DC    H'126'\nMOVEMSG  MVC   REPMSGID(0),0(R11)\nMVEREPLY MVC   COMMAND_TEXT+5(0),0(R11)\nCOMPARE_BLANKDAY CLC   1(0,R9),BLANKS\nBLANKDAY MVC   1(0,R9),BLANKS\nCOMPMSG  CLC   REPMSGID(0),0(R11)    IS THIS THE CORRECT MSGID\nMSGIDLN  DC    X'00'\nREPMSGID DC    CL12' '\nREPLYNUM DC    CL2' '\nBLANKS   DC    CL16' '\n*************************************************************\n         LTORG\nSEMICOL  DC    256X'00'\n         ORG   SEMICOL+C';'\n         DC    X'FF'\n         ORG\nBLANK    DC    256X'00'\n         ORG   BLANK+C' '\n         DC    X'FF'\n         ORG\nNBLANK   DC    256X'FF'\n         ORG   NBLANK+C' '\n         DC    X'00'\n         ORG\nNUMTABL  DC    256X'FF'\n         ORG   NUMTABL+C'0'\n         DC    10X'00'\n         ORG\nAUTOTABL DC  256X'00'\n         ORG AUTOTABL+C'$'\n         DC  X'FF'\n         ORG AUTOTABL+C','\n         DC  X'FF'\n         ORG\n***********************\nSTORAGE  DSECT\nSAVEAREA          DS   18F\nDOUBLE_WORD       DS   D\nGETMAIN_LENGTH    DS   F\nRETCODE  DS    F\nLOCKSAVE DS    6F            SAVE AREA FOR SETLOCK\nR9SAVE   DS    F             SAVE R9 FOR R13 FOR SETLOCK\nSASID    DS    F\nCONSASID DS    H\nEXITRC   DS    H\nCOMMASCB DS    F\nMASTCONS DS    H\nPARM_ADDRESS      DS   F\nADDRESS_IRXJCL    DS   F\nMSGID_COMPARE     DS   H\nMVS_COMMAND       DS   H\nWTO_LENGTH        DS   H\nCOMMAND_TEXT      DS   CL126\nLENGTH_INPUT      DS   H\nINPUT_RECORD      DS   CL142\nMSG      DS    CL80\nJOBNAME  DS    CL8\nFLAG     DS    X\nFUNCTION_BYTE  DS  X\n**\n*\nPARMLIST        EQU   *\nHOUR            DS    CL2\n                DS    C\nMINUTE          DS    CL2\n                DS    C\nSECOND          DS    CL2\nHOURNEXT        DS    CL5\nDATE            EQU   *\nMM              DS    CL2\n                DS    C\nDD              DS    CL2\n                DS    C\nYY              DS    CL2\nJULIAN_DAY      DS    CL3\nDAY_NUMBER      DS    X\nLASTDAY         DS    C\nDAY_WEEK        DS    CL9\nMONTH           DS    CL9\nYEAR            DS    CL4\n*\nSTORAGE_SIZE      EQU  *-SAVEAREA\n*\n         SPACE 1\n         CVT   DSECT=YES\n         IHAASVT DSECT=YES,LIST=YES\n         IHAORE\nUCM      DSECT\n         IEECUCM\n         IHAWQE\n         IHAPSA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALEXTDAT": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01\\x1f\\x01\\x1f\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 287, "newlines": 287, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'ALEXTDAT - PROGRAM TO PROCESS DATE INFORMATION'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 31                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  NOT APF AUTHORIZED                               *\n*                  LINKED WITH ALEXCMDS TO SUPPORT DATE PROCESSING  *\n*                                                                   *\n*  FUNCTION - PROGRAM IS INVOKED TO GENERATE RELATIVE DATE, TIME,  *\n*             MONTH, DAY, YEAR, DAY OF WEEK INFORMATION.           *\n*                                                                  *\n*   REGISTER USAGE                                                 *\n*   R1  - PARAMETER LIST ADDRESS                                   *\n*   R12 - FIRST BASE REGISTER                                      *\n*   R11 - ADDRESSABILITY TO DSECT                                  *\n*   R0-R10,R14-R15 - VARIOUS WORK REGISTER UTILIZATION             *\n*                                                                  *\n*   LINKAGE ATTRIBUTES - AMODE 31, RMODE 24, REENTRANT             *\n********************************************************************\nALEXTDAT CSECT\nALEXTDAT AMODE 31\nALEXTDAT RMODE 24\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE EQU 20\n         EJECT\n****************************************************************\n*  SAVE LOGIC AND ENTRY SETUP OF PROGRAM.                      *\n****************************************************************\n         STM   R14,R12,12(R13)     SAVE IN CALLERS SAVEAREA\n         LR    R12,R15\n         USING ALEXTDAT,R12\n*        LR    R6,R1              LOAD UP THE PARAMETER LIST\n         L     R6,0(R1)           LOAD UP THE PARAMETER LIST\n         USING PARMLIST,R6\nGOOD_FUNCTION  EQU   *\n         LA    R3,STORAGE_SIZE     GET THE SIZE OF OUR STORAGE\n         GETMAIN RC,LV=(3)\n         LTR   R15,R15             SEE IF VALID GETMAIN\n         BZ    GOOD_STORAGE        YES, THEN CONTINUE MACDUFF\n         LA    R15,NO_STORAGE      LOAD UP PREDETERMINED RC\n         B     RETURN2             AND GET OUT\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)           SAVE OUR SAVERAREA\n         ST    R13,4(R1)           SAVE THEIR SAVEAREA\n         LR    R13,R1              LOAD OURS\n         USING STORAGE,R13\n****************************************************************\n*  THE DATE AND TIME WILL BE PROCESSED HERE. THE TIME WILL BE  *\n* EDITED TO COMPARE AGAINST THE TIME IN A JES2 AUTOMATIC CMD   *\n* AND THE DATE WILL BE PROCESSED FOR DAY OF WEEK AND CURRENT   *\n* DATE.                                                        *\n****************************************************************\nGETTIME  LA    R1,2(0,0)           LOAD REG1 FOR TIME SVC\n         SVC   11                  ISSUE SVC FOR TIME\n         ST    R0,TIMEFW           STORE ADJUSTED TIME\n*\n         STCM  R0,8,TIMEHOUR       GET THE HOUR IN THIS FIELD\n         TR    TIMEHOUR(1),NEXTHOUR  INCR TO NEXT HOUR\n         MVC   AUTOHOUR(6),HOURMASK  MOVE IN THE MASK\n         ED    AUTOHOUR(3),TIMEHOUR  EDIT THE HOUR\n         MVC   HOURNEXT(5),AUTOHOUR+1  MOVE IT IN TO END USER\n*\n         MVC   HOLDTIME(9),TIMEMASK\n         ED    HOLDTIME(9),TIMEFW     EDIT TIME INTO HEADER FIELD\n         CLI   HOLDTIME+1,C' '          HI ORDER BLANK\n         BNE   MOVETIME              NO, THEN LEAVE ALONE\n         MVI   HOLDTIME+1,C'0'      MOVE IN A ZERO FOR HDR TIME AS WELL\nMOVETIME MVC   HOUR(8),HOLDTIME+1\nDODATE   LTR   R1,R1              IS THERE EVEN A DATE\n         BZ    FREESTOR           YES, THEN GO AROUND\nGOTDATE  ST    R1,DOUBLE_WORD+4     SAVE THE DATE FROM SYSTEM\n         UNPK  JULIAN_DAY(3),DOUBLE_WORD+6(2)\n         OI    JULIAN_DAY+2,X'F0'\n         MVC   TWO_YEAR(3),YEARMASK\n         MVC   YEAR(2),=C'19'       MOVE IN 19 AS CENTURY\n         CLI   DOUBLE_WORD+4,X'00'  IS IT 19 AS THE CENTURY\n         BE    NOT20\n         MVC   YEAR(2),=C'20'       MOVE IN 20 AS CENTURY\nNOT20    ED    TWO_YEAR(3),DOUBLE_WORD+5 EDIT THE YEAR\n         MVC   YEAR+2(2),TWO_YEAR+1 MOVE IN REMAINDER OF YEAR\n         CLI   YEAR+2,C' '          SEE IF IT IS BLANK\n         BNE   SETYY                NO, THEN GO AROUND\n         MVI   YEAR+2,C'0'          SET TO ZERO\nSETYY    MVC   YY(2),YEAR+2         SET IT HERE ALSO\n         MVI   MM+2,C'/'            SET DELIMETERS\n         MVI   DD+2,C'/'\nCHKLPYR  TM    DOUBLE_WORD+5,X'01'  IS THIS A LEAP YEAR\n         BO    GETYEAR              ODD, THEN JUST GO AROUND\n         TM    DOUBLE_WORD+5,X'12'  HOW ABOUT LEAP YEAR NOW\n         BM    GETYEAR              MIXED, THEN NOT LEAP YEAR\n         MVI   PFEB,29              SET TO 29 DAYS\n         EJECT\nGETYEAR  SLR   R11,R11             CLEAR FOR CENTURY\n         SLR   R10,R10             AND YEAR\n         ICM   R11,8,=X'F0'          MOVE IN SIGN BITS FOR YEAR\n         IC    R10,DOUBLE_WORD+5     MOVE IN YEAR\n         ICM   R10,2,=X'19'          MOVE IN 20TH CENTURY\n         CLI   DOUBLE_WORD+4,X'00'   IS IT 19\n         BE    SHIFT_SIGN            YES, THEN SHIFT IN SIGN\n         ICM   R10,2,=X'20'          MOVE IN 21ST CENTURY\nSHIFT_SIGN     EQU   *\n         SLDL  R10,4                 MOVE IN THE SIGN\n         XC    DOUBLE_WORD(6),DOUBLE_WORD SET TO ZERO FIRST 6 BYTES\n         SLR   R0,R0                 START WITH ZERO\n         CVB   R1,DOUBLE_WORD        GET DDDF CONVERTED TO BINARY\n         LA    R2,YEARTABL-3          START AT -2 INTO TABLE\n         SLR   R14,R14               CLEAR R14 FOR MONTH COUNT\n         SPACE 1\nGETDAY   SLR   R1,R0                 SUBTRACT NUMBER OF DAYS IN MONTH\n         LA    R2,3(,R2)             POSITION TO NEXT ENTRY\n         IC    R0,0(,R2)             GET NUMBER OF DAYS IN MONTH\n         LA    R14,1(R14)            INCREMENT THE MONTH COUNT\n         CLR   R0,R1                 COMPARE THE TO SEE IF DONE\n         BL    GETDAY                IF LT STILL NOT FINISHED\n         MVC   MM(2),1(R2)           SAVE EBCDIC MONTH\nCHECK_LAST     EQU  *\n         CR    R1,R0                 SEE IF LAST DAY OF MONTH\n         BNE   CONVERT_DAY\n         MVI   LASTDAY,C'Y'          FLAG TO SAY LAST DAY\nCONVERT_DAY    EQU    *\n         CVD   R1,DOUBLE_WORD         GET THE DAY\n         UNPK  DD(2),DOUBLE_WORD+6(2)\n         OI    DD+1,X'F0'             SIGN BIT\n         ST    R10,DOUBLE_WORD+4      GET THE YEAR BACK IN\n         CVB   R10,DOUBLE_WORD        CONVERT TO BINARY\n*              GET DAY OF WEEK\n*\n*\n*                 OUTPUT - DAY_NUMBER\n*\n*              N = D + 2M + 3(M+1)/5 + Y + Y/4 - Y/100 + Y/400 + 2\n*\n*                 WHERE M = 3-14 (JAN,FEB ARE 13,14 OF Y-1)\n*\n*                 N/7 LEAVES REMAINDER 0-6, 0 INDICATING SATURDAY\n*\nTOWEEK   LR    R15,R10             GET YEAR FROM EARLIER\n         CH    R14,=H'2'           JAN OR FEB?\n         BH    WEEKMMOK\n         BE    WEEKFEB\n         LA    R14,13              SET M=13\n         B     WEEKYMIN\nWEEKFEB  LA    R14,14              SET M=14\nWEEKYMIN BCTR  R15,0               SET Y = Y-1\nWEEKMMOK LR    R0,R14              COPY M\n         ALR   R0,R0               GET 2M\n         ALR   R1,R0               SET N = N + 2M\n         LR    R0,R15              SAVE REDEFINED Y\n         SPACE\n         LA    R14,1(,R14)         GET M+1\n         MH    R14,=H'3'           GET 3(M+1)\n         SRDL  R14,32              SHIFT INTO R15, ZERO R14\n         D     R14,=F'5'           GET 3(M+1)/5 IN R15\n         ALR   R1,R15              SET N = N + 3(M+1)/5\n         SPACE\n         LR    R15,R0              GET Y\n         ALR   R1,R15              SET N = N + Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'4'           GET Y/4\n         ALR   R1,R15              SET N = N + Y/4\n         SPACE\n         LR    R15,R0              GET Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'100'         GET Y/100\n         SLR   R1,R15              SET N = N - Y/100\n         SPACE\n         LR    R15,R0              GET Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'400'         GET Y/400\n         ALR   R1,R15              SET N = N + Y/400\n         LA    R15,2               GET 2\n         ALR   R1,R15              SET N = N + 2\n         SLR   R0,R0               ZERO R0\n         D     R0,=F'7'            SET N = N/7\n         STC   R0,DAY_NUMBER       SAVE REMAINDER\n*  GO AHEAD AND MOVE IN THE DAY OF THE WEEK                       ED\n         LR    R1,R0\n         MH    R1,HW9\n         LA    R14,WEEKDAYS(R1)    POINT TO NAME\n         MVC   DAY_WEEK(9),0(R14)     MOVE NAME\n         PACK  DOUBLE_WORD(8),MM(2)\n         CVB   R14,DOUBLE_WORD\n         BCTR  R14,0\n         MH    R14,HW9\n         LA    R15,MONTH_TABLE\n         LA    R15,0(R14,R15)\n         MVC   MONTH(9),0(R15)\nFREESTOR EQU   *\n         L     R0,GETMAIN_LENGTH\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=(0)\nRETURN1  LR    R15,R4\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n***********************\nHW9      DC    H'9'\nTIMEMASK DC    X'4021204B20204B2020'\nYEARTABL DC    AL1(31),CL2'01',AL1(28),CL2'02'\n         DC    AL1(31),CL2'03',AL1(30),CL2'04'\n         DC    AL1(31),CL2'05',AL1(30),CL2'06'\n         DC    AL1(31),CL2'07',AL1(31),CL2'08'\n         DC    AL1(30),CL2'09',AL1(31),CL2'10'\n         DC    AL1(30),CL2'11',AL1(31),CL2'12'\nPFEB     EQU   YEARTABL+3\nMONTH_TABLE  EQU  *\n         DC  CL9'JANUARY '\n         DC  CL9'FEBRUARY'\n         DC  CL9'MARCH '\n         DC  CL9'APRIL '\n         DC  CL9'MAY '\n         DC  CL9'JUNE '\n         DC  CL9'JULY '\n         DC  CL9'AUGUST '\n         DC  CL9'SEPTEMBER'\n         DC  CL9'OCTOBER '\n         DC  CL9'NOVEMBER '\n         DC  CL9'DECEMBER '\nWEEKDAYS DC    CL36'SATURDAY SUNDAY   MONDAY   TUESDAY  '\n         DC    CL27'WEDNESDAYTHURSDAY FRIDAY   '\nYEARMASK DC    X'402120'        MASK FOR YEAR\nHOURMASK DC    X'F02120',CL3'.00'   MASK FOR HOUR AND 0'S\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nNEXTHOUR DC    X'01020304050607080910000000000000'\n         DC    X'11121314151617181920000000000000'\n         DC    X'2122232400'\n         LTORG\nSTORAGE  DSECT\nSAVEAREA          DS   18F\nDOUBLE_WORD       DS   D\nGETMAIN_LENGTH    DS   F\nTIMEFW            DS   F\nTIMEHOUR          DS   X\nAUTOHOUR          DS   CL6\nHOLDTIME          DS   CL9\nTWO_YEAR          DS   CL3\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n*\nPARMLIST DSECT\nHOUR            DS    CL2\n                DS    C\nMINUTE          DS    CL2\n                DS    C\nSECOND          DS    CL2\nHOURNEXT        DS    CL5\nMM              DS    CL2\n                DS    C\nDD              DS    CL2\n                DS    C\nYY              DS    CL2\nJULIAN_DAY      DS    CL3\nDAY_NUMBER      DS    X\nLASTDAY         DS    C\nDAY_WEEK        DS    CL9\nMONTH           DS    CL9\nYEAR            DS    CL4\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALEXT00": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x12\\x00\\x12\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 18, "newlines": 18, "modlines": 0, "user": "WHS"}, "text": "ALEXT001                                        .TYPE=ACTION\n'The Message ID is required. Specify up to 20 character MSGID'\nALEXT002                                        .TYPE=ACTION\n'The FUNCTION is required and must be REPLY, COMMAND, EXEC or HIGHLITE'\nALEXT003                                        .TYPE=ACTION\n'If the FUNCTION specified is REPLY then you must supply a Reply'\nALEXT004                                        .TYPE=ACTION\n'If the FUNCTION specified is COMMAND then you must supply a Command'\nALEXT005                                        .TYPE=ACTION\n'SELECT and JOBNAME values cannot be the same. Use Y for one desired.'\nALEXT006                                        .TYPE=ACTION\n'If SELECT is specified then Y or N are the only values allowed.'\nALEXT007                                        .TYPE=ACTION\n'If JOBNAME is specified then Y or N are the only values allowed.'\nALEXT008                                        .TYPE=ACTION\n'If Multi-Line specified then Y or N are the only values allowed'\nALEXT009                                        .TYPE=ACTION\n'If Function Highlite, then Y or N are the only values allowed for Red'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALXEXCOM": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xb9\\x00\\xb9\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 185, "newlines": 185, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'ALXEXCOM - PROGRAM TO PROCESS REXX  VARIABLES'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 31                                    *\n*                  RMODE ANY                                        *\n*                  NON-REENTRANT                                    *\n*                  NOT APF AUTHORIZED                               *\n*                                                                   *\n*  FUNCTION - PROGRAM IS INVOKED TO FETCH OR STORE REXX VARIABLES   *\n*             PASSED IN A PARAMETER LIST. TSO/E REXX PGM IRXEXCOM   *\n*             INVOKED TO PROCESS VARIABLE IN PARAMETER INFORMATION. *\n*                                                                   *\n*   REGISTER USAGE                                                  *\n*   R1  - PARAMETER LIST ADDRESS                                    *\n*   R12 - FIRST BASE REGISTER                                       *\n*   R11 - ADDRESSABILITY TO DSECT                                   *\n*   R0-R10,R14-R15 - VARIOUS WORK REGISTER UTILIZATION              *\n*                                                                   *\n*********************************************************************\nALXEXCOM CSECT\nALXEXCOM AMODE 31\nALXEXCOM RMODE ANY\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE   EQU   20\nBAD_FUNCTION EQU   24\n         EJECT\n****************************************************************\n*  SAVE LOGIC AND ENTRY SETUP OF PROGRAM.                      *\n****************************************************************\n         STM   R14,R12,12(R13)     SAVE IN CALLERS SAVEAREA\n         LR    R12,R15\n         USING ALXEXCOM,R12\n*        LR    R11,R1              LOAD UP THE PARAMETER LIST\n         L     R11,0(R1)           LOAD UP THE PARAMETER LIST\n         USING PARMLIST,R11\n         CLC   FUNCTION(5),FETCH_KW  VERIFY GOOD FUNCTION\n         BE    GOOD_FUNCTION         YES, THEN GO AROUND\n         CLC   FUNCTION(5),STORE_KW  VERIFY GOOD FUNCTION\n         BE    GOOD_FUNCTION         YES, THEN GO AROUNT\n         LA    R15,BAD_FUNCTION    LOAD UP PREDETERMINED RC\n         B     RETURN2             AND GET OUT\nGOOD_FUNCTION  EQU   *\n         L     R3,VARIABLE_COUNT   GET THE COUNT\n         SLL   R3,5                MULTIPLY BY 32 FOR SHVBLOCK\n         LA    R2,STORAGE_SIZE     GET THE SIZE OF OUR STORAGE\n         AR    R3,R2               TOTAL FOR GETMAIN\n         GETMAIN RC,LV=(3)\n         LTR   R15,R15             SEE IF VALID GETMAIN\n         BZ    GOOD_STORAGE        YES, THEN CONTINUE MACDUFF\n         LA    R15,NO_STORAGE      LOAD UP PREDETERMINED RC\n         B     RETURN2             AND GET OUT\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)           SAVE OUR SAVERAREA\n         ST    R13,4(R1)           SAVE THEIR SAVEAREA\n         LR    R13,R1              LOAD OURS\n         USING STORAGE,R13\n         LA    R10,0(R2,R13)        ADDRESS TO THE SHVBLOCK\n         ST    R10,SHVBLOCK_ADDRESS SAVE THIS LOCATION\n         USING SHVBLOCK,R10         LET R10 ADDRESS THE SHV BLOCKS\n         ST    R3,GETMAIN_LENGTH    SAVE THIS FOR FREEMAIN\n*******************************************************************\n*  WE ARE NOW GOING TO LOOP THROUGH THE VARIABLE PARAMETER LIST,  *\n* INITIALIZE THE SHVBLOCKS, LOAD THE IRXEXCOM PROGRAM AND THEN    *\n* CALL IT, THE RETURN CODE WILL BE SAVED IN THE PARAMETER LIST    *\n* FIELD AS WELL AS IN REGISTER 15.                                *\n*******************************************************************\n*        L     R4,VARIABLE_FIELDS   GET THIS LOCATION FOR 1ST VARIABLE\n         LA    R4,VARIABLE_FIELDS   GET THIS LOCATION FOR 1ST VARIABLE\n         L     R3,VARIABLE_COUNT    RELOAD THE COUNT\nLOOPINIT XC    0(32,R10),0(R10)     MAKE SURE THE 32 BYTES ARE ZERO\n         MVC   SHVCODE(1),FUNCTION  MOVE IN F FOR FETCH OR S FOR STORE\n         ICM   R15,15,0(R4)         MOVE IN VARIABLE NAME LENGTH\n         STCM  R15,15,SHVNAML       SAVE THE LENGTH\n         LA    R5,4(R4)             GET THE ADDRESS OF VARIABLE NAME\n         ST    R5,SHVNAMA           MOVE IN ADDRESS OF VARIABLE NAME\n         LA    R4,4(R4,R15)         INCREMENT PAST VARIABLE NAME\n         ICM   R15,15,0(R4)         MOVE IN VARIABLE NAME LENGTH\n         STCM  R15,15,SHVVALL       SAVE THE LENGTH OF VARIABLE DATA\n         LA    R5,4(R4)             GET THE ADDRESS OF VARIABLE DATA\n         ST    R5,SHVVALA           MOVE IN ADDRESS OF VARIABLE DATA\n         CLI   SHVCODE,SHVFETCH     SEE IF FETCH\n         BNE   ITSSTORE             NO, THEN DO NOT UPDATE BUFFER\n         STCM  R15,15,SHVBUFL       SAVE THE LENGTH OF VARIABLE DATA\n*  I MOVED ITSSTORE UP ONE LINE\nITSSTORE LA    R4,4(R4,R15)         INCREMENT PAST VARIABLE NAME\n         CH    R3,HW1               IS THIS THE LAST TIME THROUGH\n         BE    FALL_THROUGH         YES, THEN JUST GET OUT\n         LA    R15,32(R10)          INCREMENT TO NEXT SHV\n         ST    R15,SHVNEXT          SAVE THIS LOCATION IN CURRENT\n         LR    R10,R15              AND UPDATE TO NEXT SHV BLOCK\n         BCT   R3,LOOPINIT          LOOP THROUGH UNTIL DONE\nFALL_THROUGH   EQU   *              GET LOCATION POINTER\n         L     R10,SHVBLOCK_ADDRESS         RELOAD REGISTER 10 TO INIT\n         LOAD  EP=IRXEXCOM\n         LR    R15,R0\n         SLR   R0,R0\n         MVC   CALLSTOR(CALLLEN),CALLXCOM\n         CALL  (15),(REXXPGM,PARM2,PARM2,(10)),VL,MF=(E,CALLSTOR)\n         ST    R15,RETURN_CODE\n         LR    R5,R15                SAVE THIS FOR LATER RELOAD\n         CLC   FUNCTION(5),FETCH_KW  SEE IF THIS WAS A FETCH REQUEST\n         BNE   FREESTOR              NO, THEN FINISH UP AND GO HOME\n*******************************************************************\n*  IF THIS WAS A FETCH FUNCTION THEN WE HAVE TO LOOP BACK THRU    *\n* AND UPDATE THE LENGTH FIELDS FOR THE FETCHED VARIABLES. THE     *\n* FIRST TWO BYTES OF THE VARIABLE DATA LENGTH FIELD WILL BE       *\n* USED TO STORE THE LENGTHS RETURNED FROM IRXEXCOM.               *\n*******************************************************************\n*        L     R4,VARIABLE_FIELDS   GET THIS LOCATION FOR 1ST VARIABLE\n         LA    R4,VARIABLE_FIELDS   GET THIS LOCATION FOR 1ST VARIABLE\n         L     R3,VARIABLE_COUNT    RELOAD THE COUNT\n         L     R10,SHVBLOCK_ADDRESS RELOAD REGISTER 10 TO INIT\nLOOP_FETCH     EQU    *\n         ICM   R15,15,0(R4)         MOVE IN VARIABLE NAME LENGTH\n         LA    R4,4(R4,R15)         INCREMENT PAST VARIABLE NAME\n         ICM   R15,15,0(R4)         LOAD THE LENGTH FOR INCREMENT\n         L     R14,SHVVALL          LOAD THE LENGTH OF VARIABLE READ\n         STCM  R14,3,0(R4)          SAVE THE VARIABLE NAME LENGTH\n         LA    R4,4(R4,R15)         INCREMENT PAST VARIABLE NAME\n         LA    R10,32(R10)          INCREMENT TO NEXT SHV\n         BCT   R3,LOOP_FETCH        LOOP THROUGH UNTIL DONE\n**\n*******************************************\n*  LET'S FINISH IT UP AND GO HOME BOYS    *\n*******************************************\nFREESTOR EQU   *\n         L     R0,GETMAIN_LENGTH\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=(0)\nRETURN1  LR    R15,R5\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nREXXPGM  DC    CL8'IRXEXCOM'\nPARM2    DC    F'0'\nHW1      DC    H'1'\nFETCH_KW DC    CL8'FETCH '\nSTORE_KW DC    CL8'STORE '\nCALLXCOM CALL ,(*,*,*,*),VL,MF=L\nCALLLEN  EQU  *-CALLXCOM\n         LTORG\nSTORAGE  DSECT\nSAVEAREA          DS   18F\nSHVBLOCK_ADDRESS  DS   F\nGETMAIN_LENGTH    DS   F\nCALLSTOR          CALL ,(*,*,*,*),VL,MF=L\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n*\nPARMLIST DSECT\nFUNCTION        DS    CL8\nVARIABLE_COUNT  DS    F\nRETURN_CODE     DS    F\n*  THIS PORTION WILL ADDRESS ALL VARIABLES WITH THE PROPER VALUES\nVARIABLE_FIELDS DS    F\n         IRXSHVB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXPEXH1": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00$\\x00$\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 36, "newlines": 36, "modlines": 0, "user": "WHS"}, "text": ")ATTR\n  @ TYPE(TEXT) INTENS(LOW) COLOR(YELLOW)\n)BODY\n@--------------------    Automated Operations     ------------------\n+\n+     xxxxx   is taking advantage of the WTO exit IEAVMXIT to process\n+   WTO/WTOR messages generated on the OS/390  system. Rather than modifying\n+   the exit every time a new message must be added the exit was written to\n+   be table driven. The use of these ISPF Panels and a REXX EXEC will\n+   allow you to add new messages to the table used by IEAVMXIT.\n+\n+     The six  Functions available are: REPLY (which allows you to reply\n+   to an outstanding WTOR), COMMAND (which allows you to issue a command\n+   to MVS), EXEC (which takes the message and invokes a REXX EXEC to\n+   process the specified MSGID), HIGHLITE (which takes the message and sets to\n    not roll and color Red), SUPPRESS (which will suppress the message from\n    both SYSLOG and consoles), or EVENT (which takes the message and invokes\n+   REXX EXEC $E to process). Remember, if the EXEC Function is selected then\n+   someone must create a REXX EXEC in SYS2.ISPF.AUTOOPS.REXX with the same\n+   name as the MSGID. The EXEC will be executed and as much of the\n+   message that can fit within the 100 byte Parameter limit will be passed to\n+   the EXEC (Actually, (100 - MSGID - 1) (subtract 3 more if a WTOR)).\n+\n+\n+\n+\n+                   (hit enter to continue or PF3 to end)\n)PROC\n  &ZCONT = ALXPEXH2\n  &ZUP = ALXPEXH1\n)END\n++\n++\n++\n++\n++  SSC, Inc.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALXPEXH2": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00 \\x00 \\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 32, "newlines": 32, "modlines": 0, "user": "WHS"}, "text": ")ATTR\n  @ TYPE(TEXT) INTENS(LOW) COLOR(YELLOW)\n)BODY\n@--------------------    Automated Operations     ------------------\n+\n+      The use of the SEARCH facility allows you to SELECT a message if\n+   argument or JOBNAME is found. This might save you from having to\n+   process the message with an EXEC.\n+\n+      The Multi-Line option must be used for WTOs that contain multiple\n+   lines, and you wish to process the subsequent lines. A specification\n+   of Y (yes) informs the exit that you wish to process a Multi-Line WTO.\n+   If you were to specify a Search argument, then the WTO line that\n+   contains the search argument will be what is presented to the EXEC.\n+   If you specify A (all), then the exit will pass all lines of WTO once\n+   it finds the search argument. If you specify Y, and no search\n+   argument, then every line of the WTO will be passed to the EXEC.\n+\n+\n+\n+\n+\n+            (hit enter or PF7 to go up or   PF3 to end)\n)PROC\n  &ZCONT = ALXPEXH1\n  &ZUP = ALXPEXH1\n)END\n++\n++\n++\n++\n++  SSC, Inc.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALXPEXT": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00@\\x00@\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 64, "newlines": 64, "modlines": 0, "user": "WHS"}, "text": ")ATTR\n  @ TYPE(TEXT) INTENS(LOW) COLOR(YELLOW)\n  $ TYPE(TEXT) INTENS(LOW) SKIP(OFF)\n  + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n  _ TYPE(INPUT)\n  ! TYPE(INPUT) CAPS(OFF)\n  # TYPE(OUTPUT) INTENS(HIGH)\n)BODY\n@------------------         Automated Operations      ------------------\n%OPTION==>_ZCMD                                                              +\n+\n+        Add WTO/WTOR Messages for Automated Operations Processing\n+\n+   Message ID  %==>_MSGID               +\n+      Enter up to 20 characters of the Message you wish to process\n+\n+   Action to Perform  %==>_FUNCTION+       Highlite RED (Y/N) %==>_R+\n+       Valid Actions are REPLY, COMMAND, EXEC, EVENT, HIGHLITE or SUPPRESS\n+\n+   Reply  %==>_REPLY                  +\n+     If Action was REPLY then specify the REPLY to the Message\n+\n+   Command  %==>_COMMAND                                       +\n+     If Action was COMMAND then specify the COMMAND to issue\n+\n+   Search Argument  %==>!SEARCH                                   +\n+        (%Single Quotes +not allowed in Search Argument; %Case sensitive+)\n+   Select if Argument Found %=>_S+   Select if Argument JOBNAME %=>_J+\n+\n+   Process Multi-Line WTO (Y/N/A) %==>_M+\n+     %PF1 - Help/Description    PF3 - End/Assemble  PF4 - Cancel/NoUpdate\n)INIT\n   &ZCMD     = &Z\n   .CURSOR   = MSGID\n   .HELP     = ALXPEXH1\n)PROC\n &CPFKEY    = .PFKEY\n VER (&MSGID,NONBLANK,MSG=ALEXT001)\n IF (&FUNCTION \u00ac= REPLY,COMMAND,EXEC,EVENT,HIGHLITE,SUPPRESS)\n   .MSG=ALEXT002\n IF (&FUNCTION = REPLY)\n   VER (&REPLY,NONBLANK,MSG=ALEXT003)\n IF (&FUNCTION = HIGHLITE)\n   IF (VER (&R,NONBLANK))\n    IF (&R \u00ac= Y,N)\n     .MSG=ALEXT009\n IF (&FUNCTION = COMMAND)\n   VER (&COMMAND,NONBLANK,MSG=ALEXT004)\n IF (VER (&SEARCH,NONBLANK))\n   IF (&S = Y AND &J = Y or &S = N and &J = N)\n     .MSG=ALEXT005\n   IF (VER (&S,NONBLANK))\n    IF (&S \u00ac= Y,N)\n     .MSG=ALEXT006\n   IF (VER (&J,NONBLANK))\n    IF (&J \u00ac= Y,N)\n     .MSG=ALEXT007\n IF (VER (&M,NONBLANK))\n  IF (&M \u00ac= Y,N,A)\n   .MSG=ALEXT008\n)END\n++\n++\n++\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALXRCONC": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x02\\x08\\x02\\x08\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 520, "newlines": 520, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL TAKE A DDNAME     *\n* AND A LIST OF DATASETS, DYNAMICALLY ALLOCATE AND CONCATENATE *\n* THEM.                                                        *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    DDNAME      = WHICH WILL CONTAIN THE DDNAME TO USE        *\n*    DSNAME      = DSNAME TO CONCATENATE; WILL OCCUR AS MANY   *\n*                  TIMES AS REQUIRED.                          *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = STORE THE STATUS OF THE ALLOCATION          *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRCONC CSECT\nALXRCONC AMODE 31\nALXRCONC RMODE 24\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\nFOUND_DSNAME   EQU  2\nCDE_MODULE     EQU  8\nLPA_LISTED     EQU  4\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRCONC,R12\n         L     R3,16(R7)\n         SLR   R5,R5\nLOOP_COUNT     EQU   *\n         CLC   0(8,R3),FFFLAG\n         BE    DONE_COUNT\n         ICM   R15,15,4(R3)\n         BZ    NOINCR_COUNT\n         LA    R5,1(R5)\nNOINCR_COUNT   EQU  *\n         LA    R3,8(R3)\n         B     LOOP_COUNT\nDONE_COUNT     EQU   *\n         BCTR  R5,0                       DECREMENT 1 FOR DDNAME VALUE\n         LR    R4,R5\n         MH    R4,HW44                    MULTIPLY BY DSNAME LENGTH\n         LA    R3,STORAGE_SIZE            GET THE LENGTH OF STORAGE\n         AR    R3,R4                      ADD THE TWO\n         GETMAIN RC,LV=(3)\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         XC    SAVEAREA+8(CLEARSTOR),SAVEAREA+8   CLEAR STORAGE\n         ST    R3,GETMAIN_LENGTH   SAVE THE STORAGE LENGTH\n***************************************************************\n* NEXT SECTION INITIALIZE THE DYNAMIC ALLOCATION STORAGE      *\n***************************************************************\n         MVC   S99PARM(LENGTH_DYNAMIC),DYNAMIC_ALLOCATION\n         LA    R15,S99AREA\n         STCM  R15,7,S99PARM+1\n         LA    R15,ALTUPTR1\n         ST    R15,POINTER\n         LA    R15,ALDSTU\n         ST    R15,ALTUPTR1\n         ST    R15,ALTUPTRC\n         LA    R15,ALDDTU\n         ST    R15,ALTUPTR1+4\n         LA    R15,ALDRTU\n         ST    R15,ALTUPTRC+4\n         LA    R15,ALDDSP\n         STCM  R15,7,ALTUPTR1+9\n         STCM  R15,7,ALTUPTRC+9\n         LA    R15,CONCATD\n         ST    R15,CONPTR\n         LA    R15,CONCATP\n         STCM  R15,7,CONPTR+5\n         LA    R15,UALDDTU\n         ST    R15,UALTUPTR\n         LA    R15,UALUNTU\n         ST    R15,UALTUPTR+4\n         LA    R15,UALDPTU\n         STCM  R15,7,UALTUPTR+9\n***************************************************************\n         STH   R5,DSNAME_COUNT     AND SAVE THE COUNT\n******************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_FUNCTION        NO, THEN DO DEFAULT\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_FUNCTION        IF NULL/ZERO THEN DO DEFAULT\n         CH    R3,HW8              VERIFY IT'S NOT TOO LONG\n         BH    BAD_FUNCTION        NO, THEN CONTINUE\n         MVC   DDNAME(8),BLANKS    BLANK OUT THE MEMBER NAME\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         EX    R3,MOVEDDN          MVC   DDNAME(0),0(R10)\n         MVC   CONDDN1(8),DDNAME  MOVE IN THE DDNAME FOR CONCAT\n****************************************************************\n*  HERE IS WHERE WE WILL MOVE THE DSNAMES FROM THE ARGUMENT    *\n* LIST INTO STORAGE.                                           *\n****************************************************************\n         LA    R3,DSNAME_TABLE     BEGINNING OF TABLE\n         LR    R14,R3              SET FOR BLANKING THE BLOCK\n         LR    R15,R4              GET THE LENGTH IN R15\n         SLR   R9,R9               CLEAR REG 9 FOR INSERT\n         ICM   R9,8,BLANKS         MOVE IN A BLANK\n         MVCL  R14,R8              BLANK OUT THE STORAGE\n         LA    R11,8(R11)          INCREMENT PAST THE DDNAME\n         LH    R2,DSNAME_COUNT     RELOAD THE COUNT\nLOOP_MOVE      EQU   *\n         CLC   0(8,R11),FFFLAG     ARE WE AT THE END\n         BE    DONE_MOVE           YES, THEN GET OUT\n         ICM   R15,15,4(R11)       LENGTH OF DSNAME IN R15\n         BZ    NOMOVE_DSNAME       ZERO, THEN NEXT ONE\n         L     R8,0(R11)           GET THE ADDRESS IN R8\n         BCTR  R15,0               DECREMENT FOR EX MOVE\n         EX    R15,TRTBLANK        TRT  0(0,R8),BLANKTBL\n         BNZ   BAD_CONTINUATION  IF BLANKS THEN ERROR\n         EX    R15,MOVE_DSNAME     MVC  0(0,R3),0(R8)\n         LA    R3,44(R3)           INCREMENT STORAGE\nNOMOVE_DSNAME  EQU  *\n         LA    R11,8(R11)\n         BCT   R2,LOOP_MOVE\nDONE_MOVE      EQU   *\n****************************************************************\n*  CHECK TO SEE IF THE DDNAME IS ALREADY ALLOCATED. YES, THEN  *\n* CONCATENATE EVERYONE. NO, THEN ALLOCATE FIRST AND CONCAT REST*\n****************************************************************\n         LA    R3,DSNAME_TABLE    REFERENCE THE BEGINNING\n         LH    R4,DSNAME_COUNT    AND RELOAD THE COUNT\n         L     R8,16              ADDR. CVT\n         L     R8,0(R8)           ADDR. TCB\n         L     R8,4(R8)           ADDR. ACTIVE TCB\n         L     R8,12(R8)          ADDR. TIOT\n         LA    R8,24(R8)          ADDR. FIRST DDNAME\n         SLR   R9,R9              CLEAR R9\nLOOPDDN  CLC   4(8,R8),DDNAME     IT THE DDNAME ALREADY ALLOCATED\n         BNE   INCRDDN            YES, THEN DO CONCATENATION\n         ST    R8,TIOT_DDNAME     SAVE THIS FOR COMPARING DSN\n         B     DO_CONCATENATE     YES, THEN DO CONCATENATION\nINCRDDN  IC    R9,0(R8)           GET LENGTH INCREMENT\n         LA    R8,0(R9,R8)        POINT R3 TO NEW DDNAME\n         CLI   0(R8),X'00'        IS IT A DDNAME FIELD\n         BNE   LOOPDDN            YES, THEN PROCESS NEXT ONE\n****************************************************************\n*  IF THE LOGIC ABOVE FALLS THROUGH TO HERE, THEN ALLOCATE AS  *\n* THE FIRST IN THE SERIES.                                     *\n****************************************************************\nALLOC_FIRST    EQU   *\n         LA    R5,S99AREA         ADDRESS SVC99 PARAMETER FIELDS\n         USING S99RB,R5\n         LR    R9,R10             GET THE COUNT IN R9 FOR LOOP\n         MVC   ALDSN(44),0(R3)    MOVE IN THE DSNAME\n         LA    R3,44(R3)          INCREMENT\n         BCTR  R4,0                AND DECREMENT\n         MVC   ALDDN(8),DDNAME    MOVE IN THE DDNAME\n         MVI   S99VERB,S99VRBAL   INDICATE ALLOCATE VERB\n*\n         LA    R1,ALTUPTR1        ADDR OF ALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP        STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM         LOAD ADDRESS OF SVC 99 PARM AREA\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         LTR   R15,R15             VERIFY RETURN CODE\n         BNZ   DYNALL_ERROR        ISSUE ERROR MESSAGE  ****+++***\n****************************************************************\n*  ALLOCATE THE DATASET TO A TEMPORARY DDNAME AND THEN         *\n* CONCATENATE IT.                                              *\n****************************************************************\nDO_CONCATENATE EQU   *\n         LTR   R4,R4              ANY REMAINING TO DO ?\n         BZ    SETRPLY_LENGTH\n         LA    R5,S99AREA         ADDRESS SVC99 PARAMETER FIELDS\n         USING S99RB,R5\n************************************\n* CHECK FOR DSN PRESENT            *\n************************************\nCOMPARE_DSNAME EQU  *\n         ICM   R1,15,TIOT_DDNAME     RELOAD FOR DSNAME COMPARE\n         BZ    LOOP_SVC99         IF NOT THERE THEN CONTINUE\n         SLR   R15,R15            CLEAR FOR INSERT\n         LR    R14,R15            CLEAR FOR INSERT\nLOOP_TIOTDSN   EQU  *\n         ICM   R14,7,12(R1)       GET THE DSNAME ADDR POINTER\n         CLC   16(44,R14),0(R3)   DSN ALREADY ALLOCATED ?\n         BE    INCR_DSNAME        YES, THEN DO THE NEXT ONE\n         IC    R15,0(R1)          GET LENGTH INCREMENT\n         LA    R1,0(R15,R1)       POINT R3 TO NEW DDNAME\n         CLI   4(R1),C' '         IS IT STILL CONCATENATED\n         BNE   LOOP_SVC99         YES, THEN PROCESS NEXT ONE\n         CLI   0(R1),X'00'        IS IT A DDNAME FIELD\n         BNE   LOOP_TIOTDSN       YES, THEN PROCESS NEXT ONE\n*\nLOOP_SVC99     EQU  *\n         MVC   ALDSN(44),0(R3)    MOVE IN THE DSNAME\n         MVI   S99VERB,S99VRBAL   INDICATE ALLOCATE VERB\n*\n         LA    R1,ALTUPTRC        ADDR OF ALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP        STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM         LOAD ADDRESS OF SVC 99 PARM AREA\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         LTR   R15,R15             VERIFY RETURN CODE\n         BNZ   DYNALL_ERROR        ISSUE ERROR MESSAGE  ****+++***\n****************************************************************\n*  CHECK TO SEE IF THE DDNAME IS ALREADY ALLOCATED. YES, THEN  *\n* CONCATENATE EVERYONE. NO, THEN ALLOCATE FIRST AND CONCAT REST*\n****************************************************************\nGOOD_ALLOC     EQU  *\nCONCAT_FILE    EQU  *\n         LA    R1,CONPTR           ADDR OF ALLOCATION TEXT UNIT PTRS\n         MVC   CONDDN2(8),ALDDNR   MOVE IN THE RETURNED DDNAME\n         MVI   S99VERB,S99VRBCC    MOVE IN CONCATENATION VERB\n         ST    R1,S99TXTPP         STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM          LOAD ADDRESS OF SVC 99 PARM AREA\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         LTR   R15,R15             VERIFY RETURN CODE\n         BZ    INCR_DSNAME         GOOD, THEN CONTINUE\n         MVC   STATUS_AREA(41),ERROR_DYNCONC\n         B     DYNALL_ERROR2       ISSUE ERROR MESSAGE  ****+++***\nINCR_DSNAME    EQU  *\n         LA    R3,44(R3)\n         BCT   R4,COMPARE_DSNAME   LOOP THROUGH AND ALLOCATE\n         SPACE 2\nSETRPLY_LENGTH EQU  *\n         LA    R8,2\n         MVC   STATUS_AREA(2),OKAY   MOVE IN OKAY\n****************************************\nSETRPLY  L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(53),STATUS_AREA\nFREESTOR EQU   *\n         LR    R1,R13\n         L     R0,GETMAIN_LENGTH\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=(0)\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_FUNCTION   EQU   *\n         MVC   STATUS_AREA(29),ERROR_FUNCTION\n         LA    R8,29\n         B     SETRPLY\nBAD_CONTINUATION EQU *\n         MVC   STATUS_AREA(47),ERROR_CONTINUATION\n         LA    R8,47\n         B     SETRPLY\nDYNALL_ERROR   EQU   *\n*        DC    H'00'\n* RESET LENGTH FROM 55 TO 41 BECAUSE INFO CODE LOOKED WEIRD\n         MVC   STATUS_AREA(41),ERROR_DYNALLOC\nDYNALL_ERROR2  EQU   *\n         LA    R8,41\n         CVD   R15,DOUBLE_WORD          LETS MAKE IT PRINTABLE\n         UNPK  STATUS_AREA+22(3),DOUBLE_WORD+6(2)\n         OI    STATUS_AREA+24,X'F0'     AND ONE MORE LA\n         UNPK  STATUS_AREA+36(5),S99ERROR(3) 1 MORE THAN FIELD SIZE\n         MVI   STATUS_AREA+40,X'40' BLANK OUT GARBAGE\n         TR    STATUS_AREA+36(4),TRTBL-240 MAKE HEX PRINTABLE TOO\n*        UNPK  STATUS_AREA+50(5),S99INFO(3) SAME WITH INFO\n*        MVI   STATUS_AREA+54,X'40'     GET A BRANK IN DER\n*        TR    STATUS_AREA+50(4),TRTBL-240 MAKE HEX PRINTABLE TOO\n         CLC   STATUS_AREA(6),ERROR_DYNCONC           WAS THIS CONCAT\n         BNE   SETRPLY                      NO, THEN JUST GET OUT\nFREEIT   MVC   UALDDNAM(8),CONDDN2 MOVE IN THE TEMP THAT FAILED\n         MVI   S99VERB,S99VRBUN    INDICATE UNALLOCATION TO BE DONE\n         LA    R1,UALTUPTR         ADDR OF UNALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP         STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM          LOAD ADDRESS OF SVC 99 PARM AREA\nUNALLOC  EQU   *\n         DYNALLOC                  PERFORM DYNAMIC UNALLOCATION\n         B     SETRPLY\n         EJECT\nMOVEDDN         MVC   DDNAME(0),0(R10)\nMOVE_DSNAME     MVC   0(0,R3),0(R8)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),STATUS_AREA\nTRTBLANK        TRT   0(0,R8),BLANKTBL\nHW4             DC    H'4'\nHW8             DC    H'8'\nHW10            DC    H'10'\nHW12            DC    H'12'\nHW44            DC    H'44'\nHW80            DC    H'80'\nHW119           DC    H'119'\nHW122           DC    H'122'\nFFFLAG   DC    8X'FF'\n******\nBLANKS          DC  CL8' '\nOKAY            DC  CL2'OK'\nERROR_FUNCTION  DC    CL29'ERROR IN SPECIFYING FUNCTION '\nERROR_CONTINUATION DC    CL47'FUNCTION ERROR; FOR CONTINUATION USE TWO X\n               COMMAS'\nERROR_DYNALLOC  DC    CL55'ALLOCATE FAILED; RC - XXX, REASON - XXXXX, IX\n               NFO - XXXXX'\nERROR_DYNCONC   DC    CL55'CONCATENATE ERR; RC - XXX, REASON - XXXXX, IX\n               NFO - XXXXX'\n*     HERE ARE THE SVC 99 PARAMETER VALUES\n         DS    0F\n********************************************************************\n* DO NOT INSERT ANYTHING IN THIS STORAGE, BECAUSE IT WILL BE MOVED *\n* TO RESOLVE REENTRANCY.                                           *\n********************************************************************\nDYNAMIC_ALLOCATION  EQU  *\nNR_S99PARM  DC    X'80',AL3(0)        ADDRESS OF SVC 99 REQUEST BLOCK\nNR_S99AREA  DC    AL1(S99RBEND-S99RB) LENGTH OF REQUEST BLOCK\nNR_VERBCDE  DC    X'00'               VERB CODE\n            DC    XL6'00'\nNR_POINTER  DC    A(0)                POINTER TO LIST OF TEXT UNIT PTRS\n            DC    XL8'00'\n            SPACE 1\nNR_ALTUPTR1 DC    A(0)                ADDR OF DSNAME TEXT UNIT\n            DC    A(0)                ADDR OF DDNAME TEXT UNIT\n            DC    X'80',AL3(0)        ADDR OF DISP TEXT UNIT\nNR_ALTUPTRC DC    A(0)                ADDR OF DSNAME TEXT UNIT\n            DC    A(0)                ADDR OF DDNAME TEXT UNIT\n            DC    X'80',AL3(0)        ADDR OF DISP TEXT UNIT\n            SPACE 1\nNR_ALDSTU   DC    X'0002'             ALLOCATION BY DSNAME\n            DC    X'0001'             ONE PARAMETER\nNR_ALDSNLNG DC    X'002C'             LENGTH OF PARAMETER\nNR_ALDSN    DC    CL44' '\n            DS    0H\nNR_ALDDTU   DC    X'0001'             DDNAME\n            DC    X'0001'             ONE PARAMETER\n            DC    X'0008'             LENGTH OF PARAMETER\nNR_ALDDN    DC    CL8' '              AREA FOR DDNAME\n            DS    0H\nNR_ALDRTU   DC    X'0055'             DDNAME\n            DC    X'0001'             ONE PARAMETER\n            DC    X'0008'             LENGTH OF PARAMETER\nNR_ALDDNR   DC    CL8' '              AREA FOR DDNAME\n            DS    0H\nNR_ALDDSP   DC    X'0004'             OVERRIDE DISPOSITION\n            DC    X'0001'             ONE PARAMETER\n            DC    X'0001'             LENGTH OF PARAMETER\n            DC    X'08'               DISPOSITION OF SHR\n            DS    0H\n***********\nNR_CONPTR   DC    A(0)\n            DC    X'80',AL3(0)\nNR_CONCATD  DC    X'0001'         CONCATENATION UNIT\n            DC    X'0002'\nNR_CONDDL1  DC    X'0008'\nNR_CONDDN1  DC    CL8' '\nNR_CONDDL2  DC    X'0008'\nNR_CONDDN2  DC    CL8' '\nNR_CONCATP  DC    X'0004'         PERMANENTLY CONCATENATED UNIT\n            DC    X'0000'\n***********\nNR_UALTUPTR DC    A(0)               ADDR OF UNALLOC DDNAME TEXT UNIT      08170\n            DC    A(0)               ADDR OF UNALLOC PERM   TEXT UNIT      08170\n            DC    X'80',AL3(0)       ADDR OF UNALLOC DISP   TEXT UNIT      08170\n            SPACE 1                                                        08180\nNR_UALDDTU  DC    X'0001'             UNALLOCATION BY DDNAME               08190\n            DC    X'0001'             ONE PARAMETER                        08200\n            DC    X'0008'             LENGTH OF PARAMETER                  08210\nNR_UALDDNAM DC    CL8' '              DDNAME TO BE UNALLOCATED             08220\n            DS    0H                                                       08230\nNR_UALUNTU  DC    X'0007'             RESET EVEN IF PERMANENT ALLOC        08190\n            DC    X'0000'             ZERO PARM                            08200\nNR_UALDPTU  DC    X'0005'             OVERRIDE DISPOSITION                 08190\n            DC    X'0001'             ONE PARAMETER                        08200\n            DC    X'0001'             LENGTH OF PARAMETER                  08210\nNR_UDISP    DC    X'08'               DISPOSITION OF KEEP                  08220\nLENGTH_DYNAMIC EQU *-DYNAMIC_ALLOCATION\n******************************************************************\n         LTORG\n         DS    0F\nTRTBL    DC    C'0123456789ABCDEF'\nBLANKTBL DC    256X'00'\n         ORG   BLANKTBL+C' '\n         DC    X'FF'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDOUBLE_WORD       DS  D\nGETMAIN_LENGTH    DS  F\nTIOT_DDNAME       DS  F\nDDNAME            DS  CL8\nSTATUS_AREA       DS  CL55\nFLAG              DS  X\nDSNAME_COUNT      DS  H\nCLEARSTOR         EQU *-SAVEAREA-8\n         DS    0F\nS99PARM  DS    X'80',AL3(S99AREA)  ADDRESS OF SVC 99 REQUEST BLOCK\nS99AREA  DS    AL1(S99RBEND-S99RB) LENGTH OF REQUEST BLOCK\nVERBCDE  DS    X'00'               VERB CODE\n         DS    XL6'00'\nPOINTER  DS    A(ALTUPTR1)         POINTER TO LIST OF TEXT UNIT PTRS\n         DS    XL8'00'\n         SPACE 1\nALTUPTR1 DS    A(ALDSTU)           ADDR OF DSNAME TEXT UNIT\n         DS    A(ALDDTU)           ADDR OF DDNAME TEXT UNIT\n         DS    X'80',AL3(ALDDSP)   ADDR OF DISP TEXT UNIT\nALTUPTRC DS    A(ALDSTU)           ADDR OF DSNAME TEXT UNIT\n         DS    A(ALDRTU)           ADDR OF DDNAME TEXT UNIT\n         DS    X'80',AL3(ALDDSP)   ADDR OF DISP TEXT UNIT\n         SPACE 1\nALDSTU   DS    X'0002'             ALLOCATION BY DSNAME\n         DS    X'0001'             ONE PARAMETER\nALDSNLNG DS    X'002C'             LENGTH OF PARAMETER\nALDSN    DS    CL44' '\n         DS    0H\nALDDTU   DS    X'0001'             DDNAME\n         DS    X'0001'             ONE PARAMETER\n         DS    X'0008'             LENGTH OF PARAMETER\nALDDN    DS    CL8' '              AREA FOR DDNAME\n         DS    0H\nALDRTU   DS    X'0055'             DDNAME\n         DS    X'0001'             ONE PARAMETER\n         DS    X'0008'             LENGTH OF PARAMETER\nALDDNR   DS    CL8' '              AREA FOR DDNAME\n         DS    0H\nALDDSP   DS    X'0004'             OVERRIDE DISPOSITION\n         DS    X'0001'             ONE PARAMETER\n         DS    X'0001'             LENGTH OF PARAMETER\n         DS    X'08'               DISPOSITION OF SHR\n         DS    0H\n***********\nCONPTR   DS    A(CONCATD)\n         DS    X'80',AL3(CONCATP)\nCONCATD  DS    X'0001'         CONCATENATION UNIT\n         DS    X'0002'\nCONDDL1  DS    X'0008'\nCONDDN1  DS    CL8' '\nCONDDL2  DS    X'0008'\nCONDDN2  DS    CL8' '\nCONCATP  DS    X'0004'         PERMANENTLY CONCATENATED UNIT\n         DS    X'0000'\n***********\nUALTUPTR DS    A(UALDDTU)         ADDR OF UNALLOC DDNAME TEXT UNIT\n         DS    A(UALUNTU)         ADDR OF UNALLOC PERM   TEXT UNIT\n         DS    X'80',AL3(UALDPTU) ADDR OF UNALLOC DISP   TEXT UNIT\n         SPACE 1\nUALDDTU  DS    X'0001'             UNALLOCATION BY DDNAME\n         DS    X'0001'             ONE PARAMETER\n         DS    X'0008'             LENGTH OF PARAMETER\nUALDDNAM DS    CL8' '              DDNAME TO BE UNALLOCATED\n         DS    0H\nUALUNTU  DS    X'0007'             RESET EVEN IF PERMANENT ALLOC\n         DS    X'0000'             ZERO PARM\nUALDPTU  DS    X'0005'             OVERRIDE DISPOSITION\n         DS    X'0001'             ONE PARAMETER\n         DS    X'0001'             LENGTH OF PARAMETER\nUDISP    DS    X'08'               DISPOSITION OF KEEP\n**************  END OF DYNAMIC ALLOCATION STORAGE\nDSNAME_TABLE      DS  0H\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n         IRXEVALB\n         IEFZB4D0\n         IEFZB4D2\n**\n**\n** (C) COPYRIGHT 1998, SSC, INC.\n**\n**  SSC, INC.\n**  13530 WILT STORE RD.\n**  LEESBURG, VA  20176\n**  (703) 777-2771    FAX (703) 777-6839\n**\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRDASD": {"ttr": 1538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01\\xca\\x01\\xca\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 458, "newlines": 458, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL READ THROUGH      *\n* THE UCB ADDRESSES AND RETURN THEM IN REXX VARIABLES          *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    VARIABLE_NAME = NAME OF THE COMPOUND VARIABLE             *\n*    COUNT    = MAXIMUM NUMBER OF MEMBERS TO LIST              *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = WHERE THIS PROGRAM WILL RETURN THE STATUS   *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRDASD CSECT\nALXRDASD AMODE 31\nALXRDASD RMODE 24\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\nYESDASD        EQU  8\nYESTAPE        EQU  4\nBYPVOL         EQU  2\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRDASD,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         ST    R7,EVALBLK_ADDRESS\n         MVC   EYECATCH(8),=C'EYECATCH'\n**************************************************************\n*  THE FIRST  PARAMETER IS THE COMPOUND VARIABLE NAME        *\n**************************************************************\nPROCESS_VARNAME EQU  *\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,4(R11)        GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_COUNT       IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW17             LENGTH 17 IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         L     R10,0(R11)          POINT TO THE ARGUMENT\n         STH   R9,VARNAME_LENGTH   SAVE THE LENGTH\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVEVARN         MVC   VARNAME(0),0(R10)\n******************************************************************\n*  THE SECOND  PARAMETER IS THE MAXIMUM NUMBER OF UCBS    TO READ*\n******************************************************************\nPROCESS_COUNT   EQU  *\n         CLC   8(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF VAR NAME\n*        BZ    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         BZ    PROCESS_TYPE        YES, THEN PROCESS THIRD PARM\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_COUNT        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE LENGTH OF REPLY IN R8\n         CH    R8,HW9999            CAN'T BE GT MAX\n         BH    BAD_PARM             YES, THEN JUST QUIT\n         STH   R8,COUNT_VALUE       SAVE THE COUNT FOR GETMAIN\n******************************************************************\n*  THE THIRD PARAMETER IS THE UCB TYPE                           *\n******************************************************************\nPROCESS_TYPE    EQU  *\n         CLC   16(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,20(R11)       GET THE LENGTH OF VAR NAME\n*        BZ    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         BZ    PROCESS_NOVOL       YES, THEN PROCESS FOURTH PARM\n         CH    R9,HW4              SEE IF LENGTH OF YES\n*        BNE   USE_DEFAULTS        NO, THEN DON'T CHECK FURTHER\n         BNE   PROCESS_NOVOL       NO, THEN PROCESS FOURTH PARM\n         L     R10,16(R11)         POINT TO THE ARGUMENT\nTRY_TAPE CLC   0(4,R10),TAPE        IS IT A TAPE\n*        BNE   USE_DEFAULTS        NO, THEN DON'T CHECK FURTHER\n         BNE   PROCESS_NOVOL       NO, THEN PROCESS FOURTH PARM\n         OI    FLAG,YESTAPE         SET THE FLAG\n******************************************************************\n*  THE FOURTH PARAMETER IS FOR BYPASSING ACCESSING VOLUME INFO   *\n******************************************************************\nPROCESS_NOVOL   EQU  *\n         CLC   24(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,28(R11)       GET THE LENGTH OF VAR NAME\n         BZ    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         CH    R9,HW5              SEE IF LENGTH OF NOVOL\n         BNE   USE_DEFAULTS        NO, THEN DON'T CHECK FURTHER\n         L     R10,24(R11)         POINT TO THE ARGUMENT\n         CLC   0(5,R10),NOVOL       DO WE BYPASS NOVOL\n         BNE   USE_DEFAULTS        NO, THEN DON'T CHECK FURTHER\n         OI    FLAG,BYPVOL          SET THE FLAG\nUSE_DEFAULTS   EQU    *\n*********************************************************************\n*                                                                   *\n*********************************************************************\n         LH   R3,COUNT_VALUE\n         LH   R5,VARNAME_LENGTH\n         LA   R5,17(R5)              INCREMENT FOR SHV BLOCK INFO\n*           VARNAME LGNTH+VARDATA LNGTH+VARDATA ADDR+ 5 (.9999)\n         CH   R3,HW1000              SEE IF LT 1000\n         BNL  LEAVEIT\n         BCTR R5,0                   TAKE ONE AWAY FOR SMALLER GETMAIN\nLEAVEIT  MH   R5,COUNT_VALUE         GET THE TOTAL GETMAIN\n         LA   R5,20(R5)              INCR PASSED BEGINNING\n         LA   R3,1(R3)               ADD ONE MORE FOR MEMBER.0\nMULTIPLY_BY8  EQU   *\n         MH   R3,HW25                MULTIPLY BY LENGTH OF UCBSTORE\nNOTBY8   AR   R5,R3                  TOTAL THE GETMAIN\n         LR   R0,R5\n         ST   R0,GETMAIN_LENGTH      SAVE THE LENGTH\n         GETMAIN RC,LV=(0)\n         LTR  R15,R15\n         BNZ   BAD_STORAGE            ISSUE MESSAGE AND GET OUT\n         ST    R1,GETMAIN_ADDRESS\n         LA    R10,20(R1)             SAVE FOR REXX SHV BLOCK DATA\n************************************************************\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVC   0(2,R14),STEM0        MOVE IN PERIOD AND ZERO\n         LA    R15,3(R15)            1 FOR EX DECR, 1 FOR . , 1 FOR 0\n         STCM  R15,15,0(R10)         SAVE THE VARIABLE NAME LENGTH\n         LA    R10,2(R14)            INCREMENT PAST STEM\n         LH    R15,HW4               LENGTH OF 4 FOR VAR DATA\n         STCM  R15,15,0(R10)         SAVE THE LENGTH\n         LA    R10,4(R10)            INCREMENT TO VAR DATA\n         ST    R10,STEM0_ADDRESS     SAVE THIS LOCATION\n         XC    0(4,R10),0(R10)       AND ZERO THE VARDATA\n         LA    R10,4(R10)            AND INCREMENT PAST IT\n         LA    R3,1                  SET FOR MEMBER.0 VARIABLE\n*************************************************************\n*   READ THROUGH THE UCBS HERE\n*.....................................................................\n*\n*   CLEAR THE UCBSCAN WORK AREA.\n*\n*.....................................................................\n*             LA  R0,SCANWORK             SET STORAGE ADDRESS\n*             LA  R1,100                  SET STORAGE LENGTH\n*             SR  R15,R15                 CLEAR SECOND OPERAND\n*             MVCL  R0,R14                CLEAR THE STORAGE\n              XC    SCANWORK(100),SCANWORK CLEAR IT THIS WAY\n              LA    R7,UCBSTOR            SETUP UP ADDRESSABILITY\n              USING UCB,R7\n*.....................................................................\n*\n*   LOOP THROUGH ALL DASD UCBS\n*\n*.....................................................................\nSCANLOOP EQU   *\n         TM    FLAG,YESTAPE\n         BO    SCANTAPE\nSCANDASD UCBSCAN COPY,                                                 X\n               WORKAREA=SCANWORK,                                      X\n               UCBAREA=UCBSTOR,                                        X\n               DEVCLASS=DASD,                                          X\n               DYNAMIC=YES,                                            X\n               DEVNCHAR=DEVNCHAR,                                      X\n               RANGE=ALL,                                              X\n               MF=(E,SCANLIST)\n         B     CHECKRC\nSCANTAPE UCBSCAN COPY,                                                 X\n               WORKAREA=SCANWORK,                                      X\n               UCBAREA=UCBSTOR,                                        X\n               DEVCLASS=TAPE,                                          X\n               RANGE=ALL,                                              X\n               DYNAMIC=YES,                                            X\n               DEVNCHAR=DEVNCHAR,                                      X\n               MF=(E,SCANLIST)\n*              DC  H'00'\n*.....................................................................\n*\n*   IF UCBSCAN RETURNED A UCB, THEN STORE IT AND CONTINUE\n*\n*.....................................................................\nCHECKRC       CH  R15,HW4            TEST RETURN CODE\n              BH  RCGT4              IF GT 4 THEN EXIT WITH ERROR\n              BE  FINISHED           RC 4 THEN COMPLETE AND STORE\n*.....................................................................\n*************************************************************\n*\n* INITIALIZE THE SHV BLOCKS AND INCREMENT THE COMPOUND VARIABLE HERE\n*\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVI   0(R14),C'.'         MOVE IN PERIOD\n         LA    R14,1(R14)           INCREMENT PAST\n         AP    COMPOUND_STEM(3),INCR_STEM(1)\n         MVC   STEM_VALUE(6),STEM_MASK  SET THE MASK\n         ED    STEM_VALUE(6),COMPOUND_STEM\n         TRT   STEM_VALUE(6),NBLNKTBL      LOOK FOR FIRST NON BLANK\n         LA    R2,STEM_VALUE+5             INCR FOR SUBTRACT\n         SLR   R2,R1               GET THE LENGTH\n         EX    R2,MOVE_STEM        MVC  0(0,R14),0(R1)\n         LA    R15,3(R2,R15)       2 FOR EX DECR, AND 1 FOR PERIOD\n         STCM  R15,15,0(R10)        SAVE THE VARIABLE NAME LENGTH\n         LA    R10,1(R2,R14)        INCREMENT PAST STEM\n***********\n         MVI   4(R10),C' '        MOVE IN BLANK\n         MVC   5(24,R10),4(R10)   BLANK OUT THE WHOLE THING\n         MVC   8(4,R10),DEVNCHAR  MOVE IN 4 CHAR UCB\n         TM    UCBSTAT,UCBONLI  SEE IF ONLINE\n         BO    ITS_ONLINE\n         MVC   4(4,R10),=C'OFF '\n         B     INCRUCBS\nITS_ONLINE     EQU   *\n         MVC   4(4,R10),=C'ON  '\n         MVC   13(6,R10),UCBVOLI    MOVE IN THE VOLSER\n         MVC   VOLSER(6),UCBVOLI\n*        LA     R4,VOLSER\n*        LA     R2,VTOCWORK\n         TM    FLAG,YESTAPE+BYPVOL  IF IT'S TAPE OR NOVOL THEN DON'T\n         BNZ   INCRUCBS                READ VTOC FOR SIZE\n*\n         OBTAIN READVTOC\n         SLR   R14,R14\n         LA    R15,VTOCWORK\n         USING IECSDSL4,R15\n*        ICM   R14,3,VTOCWORK+18\n         ICM   R14,3,DS4DSCYL\n         CVD   R14,DOUBLE_WORD    CONVERT IT\n         MVC   20(5,R10),VOLSIZE_MASK     MOVE IN THE MASK\n         ED    19(6,R10),DOUBLE_WORD+5\n         MVC   26(3,R10),=C'ENA'\n         TM    DS4VTOCI,DS4DVTOC     IS VTOC DISABLED?\n         BZ    INCRUCBS              NO, THEN GO AROUND\n         MVC   26(3,R10),=C'DIS'\n*        DC    H'00'\nINCRUCBS EQU   *\n         MVC   0(4,R10),FW25        MOVE IN LENGTH OF 25 FOR DASD INFO\n         LA    R10,29(R10)         INCREMENT PAST THE MEMBER AND LNGTH\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\n         CH    R3,COUNT_VALUE      CHECK TO SEE IF MAX HIT\n         BL    SCANLOOP            NO, THEN LOOP THRU TO NEXT ONE\n****************************************\nFINISHED EQU   *\nCHECK_ERROR   EQU  *\n         TM   FLAG,X'01'          DID AN ERROR OCCUR ??\n         BO   SETRPLY\n****************************************\nSTOREIT  L    R14,GETMAIN_ADDRESS\n         USING ALXPARM,R14\n         MVC  ALXEXCOM_FUNCTION(8),=C'STORE   '\n         ST   R3,ALXEXCOM_VARCOUNT\n         L    R15,STEM0_ADDRESS\n         BCTR R3,0\n         CVD  R3,DOUBLE_WORD           GET IT\n         ED   STEM_MASK(6),DOUBLE_WORD+5\n         MVC  0(4,R15),STEM_MASK+2\n         LA   R1,ALXEXCOM_FUNCTION     SET THE PARM FIELD UP LIKE\n         ST   R1,PARMLIST                THIS SO THAT SUBROUTINE IS\n         LA   R1,PARMLIST                ABLE TO HANDLE PARM LIKE COBOL\n         DROP R14\n         L    R15,ALXEXCOM\n         BALR R14,R15\n****\n*\n         LA    R8,2                    SET THE DEFAULT REPLY MESSAGE\n****************************************\nSETRPLY  L     R7,EVALBLK_ADDRESS\n         L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(33),STATUS_AREA\nFREESTOR EQU   *\n         ICM   R1,15,GETMAIN_ADDRESS\n         BZ    NOT_GOTTEN\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN RC,A=(1),LV=(0)\nNOT_GOTTEN     EQU  *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_PARM       EQU   *\n         MVC   STATUS_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\n*************************\nBAD_STORAGE    EQU   *\n         MVC   STATUS_AREA(33),STORAGE_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,22\n         B     FINISHED\n******************************************************\n* THIS NEXT SECTION IS ENTERED IF THE RETURN CODE IS *\n* GT FOUR                                            *\n******************************************************\nRCGT4    EQU   *\n         MVC   STATUS_AREA(33),RCGT4_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,25\n         B     FINISHED\nREADVTOC CAMLST SEARCH,VTOC,VOLSER,VTOCWORK\n*READVTOC CAMLST SEARCH,VTOC,(4),(2)\n*************************\n         EJECT\nALXEXCOM DC     V(ALXEXCOM)\nMOVEVARN        MVC   VARNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),STATUS_AREA\nMOVE_STEM       MVC   0(0,R14),0(R1)\nINITVARN        MVC   4(0,R10),VARNAME\nMOVE_VARDATA    MVC   4(0,R10),0(R5)\nPACK_COUNT      PACK  DOUBLE_WORD(0),0(0,R10)\nPACK_START      EQU PACK_COUNT\nFW25            DC  F'25'\nHW3             DC  H'3'\nHW4             DC  H'4'\nHW5             DC  H'5'\nHW17            DC  H'17'\nHW25            DC  H'25'\nHW1000          DC  H'1000'\nHW9999          DC  H'9999'\nFFFLAG          DC  8X'FF'\nCOUNT_VALUE     DC  H'1000'\nSTART_VALUE     DC  H'1'\nVARNAME_LENGTH  DC  H'6'\nVARNAME         DC  CL22'RECORD '\nSTEM0           DC  CL2'.0'\nSTEM_VALUE      DC  CL6' '\nSTEM_MASK       DC  X'402020202120'\nUNITADDR_MASK   DC  X'21202020'\nDEVNCHAR        DC  CL4' '\nVOLSIZE_MASK    DC  X'2021202020'\nCOMPOUND_STEM   DC  PL3'0'\nINCR_STEM       DC  PL1'1'\nYES             DC  CL3'YES'\nDASD            DC  CL4'DASD'\nTAPE            DC  CL4'TAPE'\nBOTH            DC  CL4'BOTH'\nNOVOL           DC  CL5'NOVOL'\nVTOC            DC  44X'04'\nVOLSER        DC CL6' '\nVTOCWORK      DS CL140\n******\n******\nBLANKS          DC  CL8' '\nSTATUS_AREA     DC  CL33'OK'\nERROR_FUNCTION  DC  CL33'ERROR IN SPECIFYING READ FUNCTION' 33\nOPEN_ERROR      DC  CL33'ERROR OPENING PDS DATASET '  25\nRCGT4_ERROR     DC  CL33'ERROR PERFORMING UCBSCAN  '  25\nSTORAGE_ERROR   DC  CL33'STORAGE REQUEST FAILED    '  22\n***********\n         LTORG\n         DS     0F\nNBLNKTBL DC     256X'FF'\n         ORG    NBLNKTBL+C' '\n         DC     X'00'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDOUBLE_WORD       DS  D\nEVALBLK_ADDRESS   DS  F\nGETMAIN_ADDRESS   DS  F\nGETMAIN_LENGTH    DS  F\nSTEM0_ADDRESS     DS  F\nFLAG              DS  X\nEYECATCH          DS  CL8\n*......................................................................\n*                                                                     .\n*  LIST FORMS OF MACROS.  THE LIST AND EXECUTE FORMS OF THESE MACROS  .\n*  ARE USED BECAUSE THIS MODULE IS REENTRANT.                         .\n*                                                                     .\n*......................................................................\nLIST_SCANSERV UCBSCAN MF=(L,SCANLIST)   LIST FORM OF UCBSCAN\nSCANSERV_END  DS 0D\nSCANWORK      DS CL100                  SCAN WORK AREA\nSCANWORK_END  DS 0D\nUCBSTOR       DS CL48                   UCB COPY STORAGE\nUCBSTOR_END   DS 0D\n***************************\n***************************\nSTORAGE_SIZE      EQU  *-SAVEAREA\n**\nALXPARM           DSECT\nPARMLIST          DS  F\nALXEXCOM_FUNCTION DS  CL8\nALXEXCOM_VARCOUNT DS  F\nALXEXCOM_RETCODE  DS  F\nALXEXCOM_STORAGE  EQU *\n         IRXEVALB\n*                                       CHANNEL PATH.\n**********************************\n*\nUCB           DSECT\n              IEFUCBOB\n              IECSDSL1 4\n              END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRDDIR": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01\\x98\\x01\\x98\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 408, "newlines": 408, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL READ A MEMBER     *\n* IN A PDS AND RETURN THE RECORDS/BLOCKS AS COMPOUND VARIABLES *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    DDNAME   = THE DDNAME TO SEARCH                           *\n*    VARIABLE_NAME = NAME OF THE COMPOUND VARIABLE             *\n*    COUNT    = MAXIMUM NUMBER OF MEMBERS TO LIST              *\n*    YES/NO   = WHETHER OR NOT TO SUPPLY USER HALFWORDS        *\n*               DEFAULT WILL BE NO                             *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = WHERE THIS PROGRAM WILL RETURN THE STATUS   *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRDDIR CSECT\nALXRDDIR AMODE 31\nALXRDDIR RMODE 24\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\nYESHWS         EQU  8\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRDDIR,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         ST    R7,EVALBLK_ADDRESS\n**************************************************************\n*  THE FIRST PARAMETER IS THE NAME OF THE DDNAME TO USE      *\n**************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,4(R11)        GET THE LENGTH OF DDNAME VALUE\n         BZ    PROCESS_VARNAME     IF 0 THEN USE DEFAULT AND GO TO NEXT\n         MVC   DIRREAD+40(8),BLANKS   BLANK OUT THE DDNAME\n         L     R10,0(R11)           POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVEDDN           MVC   DIRREAD+40(0),0(R10)\n**************************************************************\n*  THE SECOND PARAMETER IS THE COMPOUND VARIABLE NAME        *\n**************************************************************\nPROCESS_VARNAME EQU  *\n         CLC   8(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_COUNT       IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW17             LENGTH 17 IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         STH   R9,VARNAME_LENGTH   SAVE THE LENGTH\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVEVARN         MVC   VARNAME(0),0(R10)\n******************************************************************\n*  THE THIRD  PARAMETER IS THE MAXIMUM NUMBER OF MEMBERS TO READ *\n******************************************************************\nPROCESS_COUNT   EQU  *\n         CLC   16(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,20(R11)       GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_USERHWS     YES, THEN PROCESS FOURTH PARM\n         L     R10,16(R11)         POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_COUNT        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE LENGTH OF REPLY IN R8\n         CH    R8,HW9999            CAN'T BE GT MAX\n         BH    BAD_PARM             YES, THEN JUST QUIT\n         STH   R8,COUNT_VALUE       SAVE THE COUNT FOR GETMAIN\n******************************************************************\n*  THE FOURTH PARAMETER IS A YES/NO VALUE FOR USER HALFWORDS     *\n******************************************************************\nPROCESS_USERHWS EQU  *\n         CLC   24(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,28(R11)       GET THE LENGTH OF VAR NAME\n         BZ    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         CH    R9,HW3              SEE IF LENGTH OF YES\n         BNE   USE_DEFAULTS        NO, THEN DON'T CHECK FURTHER\n         L     R10,24(R11)         POINT TO THE ARGUMENT\n         CLC   0(3,R10),YES         IS IT A YES\n         BNE   USE_DEFAULTS         NO, THEN LEAVE DEFAULT\n         OI    FLAG,YESHWS          SET THE FLAG\nUSE_DEFAULTS   EQU    *\n*********************************************************************\n* THIS SECTION WILL OPEN THE FILE AND READ IN ALL THE PROGRAM       *\n* ENTRIES TO THE TABLE.                                             *\n*********************************************************************\n         LH   R3,COUNT_VALUE\n         LH   R5,VARNAME_LENGTH\n         LA   R5,17(R5)              INCREMENT FOR SHV BLOCK INFO\n*           VARNAME LGNTH+VARDATA LNGTH+VARDATA ADDR+ 5 (.9999)\n         CH   R3,HW1000              SEE IF LT 1000\n         BNL  LEAVEIT\n         BCTR R5,0                   TAKE ONE AWAY FOR SMALLER GETMAIN\nLEAVEIT  MH   R5,COUNT_VALUE         GET THE TOTAL GETMAIN\n         LA   R5,20(R5)              INCR PASSED BEGINNING\n         LA   R3,1(R3)               ADD ONE MORE FOR MEMBER.0\n         TM   FLAG,YESHWS            DO WE WANT THE DIRECTORY INFO\n         BZ   MULTIPLY_BY8           NO, THEN JUST MEMBER NAME LENGTH\n         MH   R3,HW69                MULT BY 8, BLANK, AND 60 BYTE USER\n         B    NOTBY8\nMULTIPLY_BY8  EQU   *\n         SLL  R3,3                   MULTIPLY BY EIGHT\nNOTBY8   AR   R5,R3                  TOTAL THE GETMAIN\n         LR   R0,R5\n         ST   R0,GETMAIN_LENGTH      SAVE THE LENGTH\n         GETMAIN RC,LV=(0)\n         LTR  R15,R15\n         BNZ   BAD_STORAGE            ISSUE MESSAGE AND GET OUT\n         ST    R1,GETMAIN_ADDRESS\n*        ST    R1,ALXEXCOM_STORAGE    SAVE IT HERE AS WELL FOR SHV BLKS\n         LA    R10,20(R1)             SAVE FOR REXX SHV BLOCK DATA\nOPENLIB  EQU  *\n* COMMENTED OUT THE CHANGE TO 24BIT   WHS  6/16/04\n*        LA   R14,OPENBSM\n*        ICM  R14,8,=X'00'\n*        BSM  R0,R14\nOPENBSM  EQU  *\n         OPEN (DIRREAD,INPUT),MODE=31\n         TM   DIRREAD+48,X'10'\n         BZ   BAD_OPEN\n************************************************************\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVC   0(2,R14),STEM0        MOVE IN PERIOD AND ZERO\n         LA    R15,3(R15)            1 FOR EX DECR, 1 FOR . , 1 FOR 0\n         STCM  R15,15,0(R10)         SAVE THE VARIABLE NAME LENGTH\n         LA    R10,2(R14)            INCREMENT PAST STEM\n         LH    R15,HW4               LENGTH OF 4 FOR VAR DATA\n         STCM  R15,15,0(R10)         SAVE THE LENGTH\n         LA    R10,4(R10)            INCREMENT TO VAR DATA\n         ST    R10,STEM0_ADDRESS     SAVE THIS LOCATION\n         XC    0(4,R10),0(R10)       AND ZERO THE VARDATA\n         LA    R10,4(R10)            AND INCREMENT PAST IT\n         LA    R3,1                  SET FOR MEMBER.0 VARIABLE\n*        SLR   R3,R3                 MAINTAIN THE COUNT OF VARIABLES\n         LA    R8,DIRECTORY_READ\nLOCSET   READ  DIRDECB,SF,DIRREAD,(8)\n         CHECK DIRDECB\nRDNXTDIR EQU   *\nLIST0    LR    R7,R8               R10 POINTS TO FIELD READ\n         LH    R9,0(R7)            R9 CONTAINS LENGTH OF RECORD\n         AR    R9,R7               POINT TO END OF LIST\n         LA    R7,2(R7)            ADDRESS MEMBER\nLIST1    CLC   0(8,R7),FFFLAG      IS THIS THE LAST DIRECTORY ENTRY\n         BE    DIRENDL             YES, THEN CLOSE IT AND GET TO WORK\n* INITIALIZE THE SHV BLOCKS AND INCREMENT THE COMPOUND VARIABLE HERE\n*\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVI   0(R14),C'.'         MOVE IN PERIOD\n         LA    R14,1(R14)           INCREMENT PAST\n         AP    COMPOUND_STEM(3),INCR_STEM(1)\n         MVC   STEM_VALUE(6),STEM_MASK  SET THE MASK\n         ED    STEM_VALUE(6),COMPOUND_STEM\n         TRT   STEM_VALUE(6),NBLNKTBL      LOOK FOR FIRST NON BLANK\n         LA    R2,STEM_VALUE+5             INCR FOR SUBTRACT\n         SLR   R2,R1               GET THE LENGTH\n         EX    R2,MOVE_STEM        MVC  0(0,R14),0(R1)\n         LA    R15,3(R2,R15)       2 FOR EX DECR, AND 1 FOR PERIOD\n         STCM  R15,15,0(R10)        SAVE THE VARIABLE NAME LENGTH\n         LA    R10,1(R2,R14)        INCREMENT PAST STEM\n***********\nLIST2    MVC   4(8,R10),0(R7)      MOVE IN THE MEMBER NAME\n         TM    FLAG,YESHWS         CHECK IT HERE TO SEE IF MORE THAN 8\n         BO    GETPAST             YES, THEN DO NOT SET THE NEXT VALUES\n         MVC   0(4,R10),FW8        MOVE IN LENGTH OF 8\n         LA    R10,12(R10)         INCREMENT PAST THE MEMBER AND LNGTH\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\n         CH    R3,COUNT_VALUE    CHECK TO SEE IF MAX HIT\n         BNL   DIRENDL            ELSE FINISH UP AND GET OUT\nGETPAST  IC    R14,11(R7)          GET # OF USER HALFWORDS\n         N     R14,FW31             ZERO OUT HI ORDER BITS\n         SLA   R14,1                MULTIPLY BY TWO\n         TM    FLAG,YESHWS         CHECK IT AGAIN HERE TO SEE IF SET\n         BZ    NOTHWS              NO, THEN GO AROUND THIS CODE\n         LR    R1,R14               GET THE LENGTH IN R1\n         BCTR  R1,0                 DECR FOR MOVE\n         MVI   12(R10),C' '         SET IT AS A BLANK\n         EX    R1,MOVE_DIRECTRY     MVC  13(0,R10),12(R7)\n         LA    R1,10(R1)            INCR FOR MMBR, BLANK, AND HWS\n         STCM  R1,15,0(R10)         SAVE THE LENGTH\n         LA    R10,4(R1,R10)        AND INCR THE LOCATION\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\n         CH    R3,COUNT_VALUE    CHECK TO SEE IF MAX HIT\n         BNL   DIRENDL            ELSE FINISH UP AND GET OUT\nNOTHWS   LA    R14,12(R14)          ADD THE CONSTANT SECTION TO IT\n         AR    R7,R14               AND THEN INCREMENT R10\n         CR    R7,R9                ARE WE AT THE END OF THIS READ\n         BL    LIST1                NO, THEN PROCESS THE NEXT\n         B     LOCSET              READ NEXT RECORD\n         EJECT\n******************************************************\nDIRENDL  EQU   *\n         CLOSE (DIRREAD),MODE=31    CLOSE DIRECTORY\n******************************************************\n* COMMENTED OUT 31BIT CHANGE   WHS  6/16/04\nRESET31  EQU  *\n*RESET31  LA   R14,CHECK_ERROR\n*        ICM  R14,8,=X'80'\n*        BSM  R0,R14\nCHECK_ERROR   EQU  *\n         TM   FLAG,X'01'          DID AN ERROR OCCUR ??\n         BO   SETRPLY\n****************************************\nSTOREIT  L    R14,GETMAIN_ADDRESS\n         USING ALXPARM,R14\n         MVC  ALXEXCOM_FUNCTION(8),=C'STORE   '\n         ST   R3,ALXEXCOM_VARCOUNT\n         L    R15,STEM0_ADDRESS\n         BCTR R3,0\n         CVD  R3,DOUBLE_WORD           GET IT\n         ED   STEM_MASK(6),DOUBLE_WORD+5\n         MVC  0(4,R15),STEM_MASK+2\n         LA   R1,ALXEXCOM_FUNCTION     SET THE PARM FIELD UP LIKE\n         ST   R1,PARMLIST                THIS SO THAT SUBROUTINE IS\n         LA   R1,PARMLIST                ABLE TO HANDLE PARM LIKE COBOL\n*        MVI  ALXEXCOM_RETCODE,C'Y'    TELL ALXEXCOM THAT VAR DATA\n*                                        ADDRESS IS IN THE FIELD\n         DROP R14\n         L    R15,ALXEXCOM\n         BALR R14,R15\n****\n*\n         LA    R8,2                    SET THE DEFAULT REPLY MESSAGE\n****************************************\nSETRPLY  L     R7,EVALBLK_ADDRESS\n         L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(33),STATUS_AREA\nFREESTOR EQU   *\n         ICM   R1,15,GETMAIN_ADDRESS\n         BZ    NOT_GOTTEN\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN RC,A=(1),LV=(0)\nNOT_GOTTEN     EQU  *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_PARM       EQU   *\n         MVC   STATUS_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\nBAD_OPEN       EQU   *\n         MVC   STATUS_AREA(33),OPEN_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,25\n         B     RESET31\n*************************\nBAD_STORAGE    EQU   *\n         MVC   STATUS_AREA(33),STORAGE_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,22\n         B     DIRENDL\n******************************************************\n* THIS NEXT SECTION IS ENTERED IF EODAD IS HIT OR AN *\n* I/O ERROR OCCURS                                   *\n******************************************************\nNOTDIR   EQU   *\n         MVC   STATUS_AREA(33),READ_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,25\n         B     DIRENDL\n*************************\n         EJECT\nDIRREAD  DCB    DDNAME=DIRREAD,DSORG=PS,MACRF=R,DCBE=DIRREADE,         X\n               BLKSIZE=256,LRECL=256,RECFM=F\nDIRREADE DCBE   RMODE31=BUFF,EODAD=NOTDIR\nALXEXCOM DC     V(ALXEXCOM)\nMOVEDDN         MVC   DIRREAD+40(0),0(R10)\nMOVEVARN        MVC   VARNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),STATUS_AREA\nMOVE_STEM       MVC   0(0,R14),0(R1)\nMOVE_DIRECTRY   MVC   13(0,R10),12(R7)\nINITVARN        MVC   4(0,R10),VARNAME\nMOVE_VARDATA    MVC   4(0,R10),0(R5)\nPACK_COUNT      PACK  DOUBLE_WORD(0),0(0,R10)\nPACK_START      EQU PACK_COUNT\nFW8             DC  F'8'\nFW31            DC  F'31'\nHW3             DC  H'3'\nHW4             DC  H'4'\nHW17            DC  H'17'\nHW69            DC  H'69'\nHW1000          DC  H'1000'\nHW9999          DC  H'9999'\nFFFLAG          DC  8X'FF'\nCOUNT_VALUE     DC  H'1000'\nSTART_VALUE     DC  H'1'\nVARNAME_LENGTH  DC  H'6'\nVARNAME         DC  CL22'RECORD '\nSTEM0           DC  CL2'.0'\nSTEM_VALUE      DC  CL6' '\nSTEM_MASK       DC  X'402020202120'\nCOMPOUND_STEM   DC  PL3'0'\nINCR_STEM       DC  PL1'1'\nYES             DC  CL3'YES'\n******\n******\nBLANKS          DC  CL8' '\nSTATUS_AREA     DC  CL33'OK'\nERROR_FUNCTION  DC  CL33'ERROR IN SPECIFYING READ FUNCTION' 33\nOPEN_ERROR      DC  CL33'ERROR OPENING PDS DATASET '  25\nREAD_ERROR      DC  CL33'ERROR READING PDS DATASET '  25\nSTORAGE_ERROR   DC  CL33'STORAGE REQUEST FAILED    '  22\nFLAG            DC  X'00'\n***********\n         LTORG\n         DS     0F\nNBLNKTBL DC     256X'FF'\n         ORG    NBLNKTBL+C' '\n         DC     X'00'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDOUBLE_WORD       DS  D\nEVALBLK_ADDRESS   DS  F\nGETMAIN_ADDRESS   DS  F\nGETMAIN_LENGTH    DS  F\nSTEM0_ADDRESS     DS  F\nDIRECTORY_READ    DS  256X\nRECORD_COUNT      DS  F\n***************************\nSTORAGE_SIZE      EQU  *-SAVEAREA\n**\nALXPARM           DSECT\nPARMLIST          DS  F\nALXEXCOM_FUNCTION DS  CL8\nALXEXCOM_VARCOUNT DS  F\nALXEXCOM_RETCODE  DS  F\nALXEXCOM_STORAGE  EQU *\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRDOZE": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00v\\x00v\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 118, "newlines": 118, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE ANY                                   *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL ISSUE A STIMER    *\n* MACRO TO SLEEP FOR A REQUESTED PERIOD OF TIME.               *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    TIME     = THE NUMBER OF SECONDS TO WAIT                  *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    EVDATA = A RETURN OF OKAY WHEN TIME HAS PASSED            *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK              *\n*                                                              *\n****************************************************************\nALXRDOZE CSECT\nALXRDOZE AMODE 31\nALXRDOZE RMODE ANY\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n****************************************************************\n****************************************************************\n         B     72(R15)\n         DS    17F\n         STM   R14,R12,12(R13)\n         ST    R15,8(R13)\n         ST    R13,4(R15)\n         LR    R13,R15\n         USING ALXRDOZE,R13\n         LR    R12,R1              SAVE THE PARAMETER ADDRESS\n****************************************************************\n         L     R11,16(R12)         LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    DOSTIMER            NO, THEN DO DEFAULT\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    DOSTIMER            IF NULL/ZERO THEN DO DEFAULT\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\nGOODPARM CH    R3,HW3              VERIFY NOT GT 999\n         BH    SETMAX              YES, THEN JUST SET THE MAX\n         BCTR  R3,0                DECREMENT FOR LATER EXECUTE INSTR\n         EX    R3,TRTTIME          VERIFY IT IS NUMERIC\n         BNZ   DOSTIMER            NO, THEN DO DEFAULT\n         A     R3,FW112           THIS WILL ADD X'70' FOR L1 OF PACK\n         EX    R3,PACKTIME           MOVE IN THE TIME\n         CVB   R15,DOUBLE              AND CONVERT TO BINARY\n         MH    R15,HW100             MULTIPLY FOR BINARY TIME\n         ST    R15,BINARY          SAVE FOR STIMER\n         B     DOSTIMER           ISSUE STIMER\n****************************************************************\nSETMAX   MVC   BINARY(4),FW60000  YES, SET UPPER LIMIT VALUE\nDOSTIMER EQU   *\n         STIMER WAIT,,BINTVL=BINARY\n         L     R10,20(R12)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         LA    R15,3\n         ST    R15,EVALBLOCK_EVSIZE\n         LA    R15,4\n         ST    R15,EVALBLOCK_EVLEN\n         MVC   EVALBLOCK_EVDATA(4),EVDATA\nRETURN   L     R13,4(R13)\n         LM    R14,R12,12(R13)\n         SLR   R15,R15\n         BR    R14\nPACKTIME PACK  DOUBLE(0),0(0,R10)\nTRTTIME  TRT   0(0,R10),NUMTABL\nDOUBLE   DC    D'0'\nBINARY   DC    F'500'\nFW60000  DC    F'60000'\nFW112    DC    F'112'\nNUMTABL  DC    256X'FF'\n         ORG   NUMTABL+C'0'\n         DC    XL10'00'\n         ORG\nHW100    DC    H'100'\nHW10     DC    H'10'\nHW3      DC    H'3'\nEVDATA   DC    CL4'OKAY'\nFFFLAG   DC    8X'FF'\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXREXT": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xc6\\x00\\xc6\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 198, "newlines": 198, "modlines": 0, "user": "WHS"}, "text": "/* REXX                                                      */\n/* TRACE R */\n/*************************************************************/\n/* AUTHOR - BILL SWEENEY                                     */\n/*                                                           */\n/* YOU MUST SPECIFY THE DATASET NAME WHERE THE TABLE SOURCE  */\n/* RESIDES AND WHERE THE LINK EDIT MSGTABLE TABLE AND        */\n/* IEAVMXIT MODULE RESIDE.                                   */\n\n /* THE FOLLOWING SOURCE DATASET IS WHERE THE MSGTABLE IS STORED  */\n /* THE MEMBER COULD BE ANYTHING, BUT MSGTABLE IS RECOMMENDED     */\n /* BECAUSE THE IEAVMXIT LINKS TO THE NAME MSGTABLE. WHY CHANGE IT*/\n\n TABLE_SOURCE_DSN = 'SYSX.OPSAUTO.SOURCE'\n TABLE_MEMBER = 'MSGTABLE'\n OLD_MEMBER = 'ZSGTABLE'\n\n/* \"ISPEXEC LIBDEF ISPMLIB DATASET ID('SYSX.ISPF.ISPMLIB')\" */\n\n /* THIS DATASET CONTAINS THE JCL TO ASSEMBLE THE MSGTABLE MEMBER */\n /* AND RELINK IEAVMXIT TO REPLACE THE MSGTABLE.                  */\n\n ASMHCL_TABLE_DSN = 'SYSX.OPSAUTO.SOURCE(ASMLTABL)'\n\n  SOURCE_DSN = TABLE_SOURCE_DSN'('TABLE_MEMBER')'\n  OLDSRCE_DSN = TABLE_SOURCE_DSN'('OLD_MEMBER')'\n  STAT = MSG(\"OFF\")\n\n  \"FREE F(MSGTABLE)\"\n  \"ALLOCATE F(MSGTABLE) DA('\"SOURCE_DSN\"') SHR\"\n  \"EXECIO * DISKR MSGTABLE (STEM MESSAGE. FINIS\"\n  \"FREE F(MSGTABLE,ZSGTABLE)\"\n  \"ALLOCATE F(ZSGTABLE) DA('\"OLDSRCE_DSN\"') SHR\"\n  \"EXECIO \" MESSAGE.0 \" DISKW ZSGTABLE (STEM MESSAGE. FINIS\"\n  \"FREE F(ZSGTABLE)\"\n\n  /*  LOOP  THROUGH THE TABLE AND FIND THE RANGE OF MESSAGES    */\n  /*  WHICH ARE DELIMITED BETWEEN LABEL START AND LABEL LENGTH  */\n  DO I = 1 TO MESSAGE.0\n   PARSE VAR MESSAGE.I LABEL REMAINDER\n   IF LABEL = 'START' THEN START_MESSAGE = I + 1\n   IF LABEL = 'LENGTH' THEN\n    DO\n      LAST_MESSAGE = I - 1\n      LENGTH_MESSAGE = MESSAGE.I\n    END\n  END\n\n  /*  WITH OUR RANGE ESTABLISHED WE WILL LOOP THRU THE MESSAGES */\n  /*  AND EXTRACT THE MSGID FOR COMPARISON ON DUPLICATES        */\n  MSG = 0\n\n  DO SUFFIX = START_MESSAGE TO LAST_MESSAGE\n   POS_MESSAGE = POS(' MESSAGE ',MESSAGE.SUFFIX,1)\n   POS_MSGID = POS('MSGID=',MESSAGE.SUFFIX,1)\n   IF POS_MESSAGE \u00ac= 0 & POS_MSGID \u00ac= 0 THEN\n    DO\n     POS_COMMA = POS(',',MESSAGE.SUFFIX,POS_MSGID)\n     QUOTE = SUBSTR(MESSAGE.SUFFIX,POS_MSGID+6,1)\n     IF POS_COMMA = 0 THEN\n      DO\n       SAY 'ERROR WITH MSGTABLE MESSAGES'\n       \"FREE F(MSGTABLE)\"\n       EXIT 16\n      END\n     /* SEE IF MSGID HAS SINGLE QUOTE DELIMITERS */\n     IF QUOTE = \"'\" THEN\n      DO\n       POS_ENDQUOTE = POS(\"'\",MESSAGE.SUFFIX,POS_MSGID+7)\n       MSGID_LENGTH = (POS_ENDQUOTE - POS_MSGID) - 7\n       EMSGID = SUBSTR(MESSAGE.SUFFIX,POS_MSGID+7,MSGID_LENGTH)\n      END\n     ELSE\n      DO\n       MSGID_LENGTH = (POS_COMMA - POS_MSGID) - 6\n       EMSGID = SUBSTR(MESSAGE.SUFFIX,POS_MSGID+6,MSGID_LENGTH)\n      END\n\n     MSG = MSG + 1\n     EMSGID.MSG = STRIP(EMSGID,'B',\"'\")\n    END\n  END\n\n  FIRST_MESSAGE = 'NO'         /* SET THIS AS INITIAL FLAG  */\n\n  /* WE WILL NOW DISPLAY THE PANEL AND ADD OUR NEW MESSAGES TO */\n  /* THE TABLE. WE WILL PICK AT THE LABEL LENGTH RECORD NUMBER */\n  NSFX = LAST_MESSAGE\n\n  DO 100            /* GIVE THEM AN OPPORTUNITY TO DEFINE A 100  */\n     MSGID = ' '\n     FUNCTION   = ' '\n     REPLY = ' '\n     COMMAND = ' '\n     SEARCH = ' '\n     S = ' '\n     J = ' '\n     M = ' '\n     R = ' '\n     \"ISPEXEC DISPLAY PANEL(ALXPEXT)\"\n     IF RC \u00ac= 0 THEN LEAVE\n     MATCH = 'NO'        /* SET THE FLAG BEFORE STARTING LOOP */\n\n     MSGID = STRIP(MSGID,'B',\"'\")    /* REMOVE SINGLE QUOTES IF THERE*/\n\n     IF MSG \u00ac= 0 THEN\n       DO I = 1 TO MSG\n        IF MSGID = EMSGID.I THEN MATCH = 'YES'\n       END\n\n     IF MATCH = 'YES' THEN\n      SAY 'MSGID ' MSGID 'MATCHES AN EXISTING ENTRY IN THE TABLE'\n\n        MSG = MSG + 1            /* INCREMENT THE COUNT SAVED   */\n        EMSGID.MSG = MSGID       /* SAVE THIS FOR FUTURE CHECKS */\n        MSGID = \"'\"MSGID\"'\"      /* PUT BACK THE QUOTES         */\n        FIRST_MESSAGE = 'YES'    /* SET THIS TO YES */\n        IF FUNCTION = 'REPLY' THEN COMMAND = REPLY\n        IF FUNCTION = 'EXEC' THEN COMMAND = 'S OPSAUTO'\n        IF FUNCTION = 'EVENT' THEN COMMAND = 'S OPSAUTO'\n        IF FUNCTION = 'HIGHLITE' | FUNCTION = 'SUPPRESS' THEN\n          COMMAND = 'NULL'\n        NSFX = NSFX + 1\n        MESSAGE.NSFX = '         MESSAGE MSGID='MSGID',FUNCTION='FUNCTION', '\n        MESSAGE.NSFX = LEFT(MESSAGE.NSFX,80)\n        MESSAGE.NSFX = OVERLAY('+',MESSAGE.NSFX,72,1)\n        NSFX = NSFX + 1\n        MESSAGE.NSFX = \"               COMMAND='\"COMMAND\"'\"\n        IF SEARCH \u00ac= '' | SEARCH \u00ac= ' ' THEN\n         DO\n          SEARCH = STRIP(SEARCH,'B',\"'\")\n          LENGTH_PREVIOUS = LENGTH(MESSAGE.NSFX)\n          MESSAGE.NSFX = OVERLAY(',',MESSAGE.NSFX,LENGTH_PREVIOUS+1,1)\n          MESSAGE.NSFX = OVERLAY('+',MESSAGE.NSFX,72,1)\n          IF J = 'Y' THEN          /* CHECK FOR SELECT EXCLUDE OPTION*/\n           DO\n            SELECT = 'JOBNAME'\n            UPPER SEARCH\n           END\n          ELSE\n           SELECT = 'SELECT'\n          NSFX = NSFX + 1\n          MESSAGE.NSFX = \"               SEARCH='\"SEARCH\"',\"\n          MESSAGE.NSFX = OVERLAY('+',MESSAGE.NSFX,72,1)\n          NSFX = NSFX + 1\n          MESSAGE.NSFX = \"               SELECT=\"SELECT\n         END\n        IF M = 'Y' THEN            /* CHECK FOR MULTI-LINE  */\n         DO\n          LENGTH_PREVIOUS = LENGTH(MESSAGE.NSFX)\n          MESSAGE.NSFX = OVERLAY(',',MESSAGE.NSFX,LENGTH_PREVIOUS+1,1)\n          MESSAGE.NSFX = OVERLAY('+',MESSAGE.NSFX,72,1)\n          NSFX = NSFX + 1\n          MESSAGE.NSFX = \"               MULTLINE=YES\"\n         END\n\n        IF M = 'A' THEN            /* CHECK FOR MULTI-LINE ALL*/\n         DO\n          LENGTH_PREVIOUS = LENGTH(MESSAGE.NSFX)\n          MESSAGE.NSFX = OVERLAY(',',MESSAGE.NSFX,LENGTH_PREVIOUS+1,1)\n          MESSAGE.NSFX = OVERLAY('+',MESSAGE.NSFX,72,1)\n          NSFX = NSFX + 1\n          MESSAGE.NSFX = \"               MULTLINE=ALL\"\n         END\n\n        IF R = 'Y' & FUNCTION = 'HIGHLITE' THEN  /* CHECK FOR COLOR  */\n         DO\n          LENGTH_PREVIOUS = LENGTH(MESSAGE.NSFX)\n          MESSAGE.NSFX = OVERLAY(',',MESSAGE.NSFX,LENGTH_PREVIOUS+1,1)\n          MESSAGE.NSFX = OVERLAY('+',MESSAGE.NSFX,72,1)\n          NSFX = NSFX + 1\n          MESSAGE.NSFX = \"               COLOR=RED\"\n         END\n      END\n\n   /* VERIFY THAT AT LEAST 1 MESSAGE ADDED BEFORE SUBMITTING JOB  */\n   /* TO REASSEMBLE AND LINK THE TABLE WITH IEAVMXIT              */\n\n   IF CPFKEY = 'PF12' | CPFKEY = 'PF04' THEN\n    DO\n     SAY 'PANEL INPUT CANCELLED; MSGTABLE NOT PROCESSED'\n     EXIT 4\n    END\n\n   IF FIRST_MESSAGE = 'YES' THEN\n    DO\n     NSFX = NSFX + 1\n     MESSAGE.NSFX = LENGTH_MESSAGE\n     NSFX = NSFX + 1\n     MESSAGE.NSFX = '          END'\n     \"ALLOCATE F(MSGTABLE) DA('\"SOURCE_DSN\"') SHR\"\n     \"EXECIO \" NSFX \" DISKW MSGTABLE (STEM MESSAGE. FINIS\"\n\n     \"SUBMIT '\"ASMHCL_TABLE_DSN\"'\"\n    END\n\n/* \"ISPEXEC LIBDEF ISPMLIB\" */\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALXRFNDM": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01!\\x01!\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 289, "newlines": 289, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL FIND A            *\n* MEMBER IN A CONCATENATED LIST                                *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    MEMBER      = WHICH WILL CONTAIN THE MEMBER NAME TO FIND  *\n*    SEARCH_DDNAME = THE DDNAME TO SEARCH                      *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    DSNAME_AREA = WHERE THIS PROGRAM WILL STORE THE DATASET    *\n*                 NAME OR THE KEYWORD NOT_FOUND                *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRFNDM CSECT\nALXRFNDM AMODE 31\nALXRFNDM RMODE 24\n         PRINT ON,GEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRFNDM,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n******************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_FIND            NO, THEN DO DEFAULT\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_FIND            IF NULL/ZERO THEN DO DEFAULT\n         CH    R3,HW8              VERIFY IT'S NOT TOO LONG\n         BH    BAD_FIND            NO, THEN CONTINUE\n         MVC   MEMBER(8),BLANKS    BLANK OUT THE MEMBER NAME\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         EX    R3,MOVEMMBR         MVC   MEMBER(0),0(R10)\n         LA    R4,DDNAME ADDRESS FOR TEXT OF MESSAGE\n******************************************************************\n         CLC   8(8,R11),FFFLAG     HAVE THEY SPECIFIED A DDNAME\n         BE    SET_DEFAULT         NO, THEN JUST SET TO 80 BYTES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF REPLY_LENGTH VALUE\n         BZ    SET_DEFAULT         JUST SET TO 80 BYTES\n         MVC   DDNAME(8),BLANKS    BLANK OUT THE DDNAME\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVEDDN          MVC   DDNAME(0),0(R10)\n         B     SEARCH_LOADLIB\nSET_DEFAULT    EQU    *\n         MVC   DDNAME(8),=C'LOADLIBS' SET THE DEFAULT\n****************************************************************\n*  HERE IS WHERE WE WILL USE SVC99 TO READ ALL OF THE DDNAMES  *\n* AND THEIR CORRESPONDING DATASET NAMES.                       *\n****************************************************************\nSEARCH_LOADLIB EQU   *\n         LA    R3,DSNAME_TABLE    POINT TO TABLE\n         LA    R5,S99AREA         ADDRESS SVC99 PARAMETER FIELDS\n         USING S99RB,R5\n         MVI   S99VERB,S99VRBIN   INDICATE INFORMATION TO BE GOTTEN\n         LA    R4,1               SET FIRST RELATIVE RECD COUNTER\n         SLR   R2,R2              ZERO IT OUT FOR COUNT\nLOOP_SVC99 EQU *\n*\n         LA    R1,INTUPTR         ADDR OF ALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP        STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM         LOAD ADDRESS OF SVC 99 PARM AREA\n         MVC   RTDDLNG(2),HW8     RESET DDNAME LENGTH\n         MVC   RTDSLNG(2),HW44    RESET DSNAME LENGTH\n         MVI   RTDSN,C' '         BLANK OUT DSNAME\n         MVC   RTDSN+1(43),RTDSN  BLANK OUT DSNAME\n         MVC   RTDDN(8),RTDSN     BLANK OUT DDNAME\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         LTR   R15,R15             VERIFY RETURN CODE\n         BNZ   BAD_FIND            NOT ZERO THEN ISSUE ERROR MSG\n         TM    FLAG,FOUND_DDN      HAVE WE ALREADY FOUND OUR DDN ?\n         BO    CHECK_END           YES, THEN CHECK FOR THE END\n         CLC   RTDDN(8),DDNAME     COMPARE FOR OUR DDNAME\n         BNE   SETNEXT\n         OI    FLAG,FOUND_DDN\n         B     MOVEADSN\nCHECK_END EQU  *\n         CLC   RTDDN(8),BLANKS     SEE IF CONCATENATED\n         BNE   DONEALOC            NO, THEN WE GOT OURS\nMOVEADSN MVC   0(44,R3),RTDSN      AND ALSO THE DATASET NAME\n         LA    R2,1(R2)            INCR THE COUNT\n         LA    R3,44(R3)           INCREMENT FIELD IN STORAGE\nSETNEXT  LA    R4,1(R4)            INCR RELATIVE RECORD COUNT\n         STH   R4,INRRNUM          SAVE FOR NEXT SVC99 INVOCATION\n         TM    RTRRNUM,X'80'       WAS THAT THE LAST\n         BZ    LOOP_SVC99          NO, THEN CONITNUE READING LIST\nDONEALOC LTR   R2,R2               MAKE SURE THAT WE FOUND OUR FILE\n         BZ    BAD_FIND            NO, THEN GET OUT\n         STCM  R2,3,DSNAME_COUNT   SAVE THE COUNT\n         SPACE 2\n*********************************************************************\n* THIS SECTION WILL OPEN THE FILE AND READ IN ALL THE PROGRAM       *\n* ENTRIES TO THE TABLE.                                             *\n*********************************************************************\nOPENLIB  MVC  LOADLIBS+40(8),DDNAME\n         LA   R14,OPENBSM\n         ICM  R14,8,=X'00'\n         BSM  R0,R14\nOPENBSM  EQU  *\n         OPEN LOADLIBS\n         TM   LOADLIBS+48,X'10'\n         BZ   BAD_FIND2\n         LA   R2,MEMBER_BLDL\n         BLDL LOADLIBS,(2)\n         LTR  R15,R15\n         BZ   GOTDSNAME\n         MVC  DSNAME_AREA(44),NOT_FOUND_DSN\n         B    CLOSEUP\nGOTDSNAME EQU *\n         LH   R3,DSNAME_COUNT\n         SLR  R14,R14\n         IC   R14,MEMBER+11          GET THE CONCATENATION VALUE\n         MH   R14,HW44\n         LA   R15,DSNAME_TABLE\n         LA   R15,0(R14,R15)         INCREMENT TO THE DSNAME ENTRY\n         MVC  DSNAME_AREA(44),0(R15)\nCLOSEUP  EQU  *\n         CLOSE LOADLIBS\n         LA   R14,SETRPLY\n         ICM  R14,8,=X'80'\n         BSM  R0,R14\n****************************************\nSETRPLY  L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         LH    R8,HW44\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(44),DSNAME_AREA\nFREESTOR EQU   *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_FIND       EQU   *\n         MVC   DSNAME_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\nBAD_FIND2      EQU   *\n         MVC   DSNAME_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         LA   R14,SETRPLY\n         ICM  R14,8,=X'80'\n         BSM  R0,R14\n         EJECT\nLOADLIBS DCB  DDNAME=LOADLIBS,DSORG=PO,MACRF=R,EODAD=CLOSEUP\nMOVEMMBR        MVC   MEMBER(0),0(R10)\nMOVEDDN         MVC   DDNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),DSNAME_AREA\nHW4             DC    H'4'\nHW8             DC    H'8'\nHW10            DC    H'10'\nHW12            DC    H'12'\nHW44            DC    H'44'\nHW80            DC    H'80'\nHW119           DC    H'119'\nHW122           DC    H'122'\nFFFLAG   DC    8X'FF'\n******\nMEMBER_BLDL     DC  H'1',H'12'\nMEMBER          DC  CL8' ',4X'00'\n******\nBLANKS          DC  CL8' '\nNOT_FOUND_DSN   DC  CL44'NOT_FOUND '\nERROR_FUNCTION  DC    CL33'ERROR IN SPECIFYING FIND FUNCTION'\nFLAG             DC    X'00'\n*     HERE ARE THE SVC 99 PARAMETER VALUES\n         DS    0F\nS99PARM  DC    X'80',AL3(S99AREA)  ADDRESS OF SVC 99 REQUEST BLOCK\nS99AREA  DC    AL1(S99RBEND-S99RB) LENGTH OF REQUEST BLOCK\nVERBCDE  DC    X'00'               VERB CODE\n         DC    XL6'00'\nPOINTER  DC    A(INTUPTR)          POINTER TO LIST OF TEXT UNIT PTRS\n         DC    XL8'00'\n         SPACE 1\nINTUPTR  DC    A(INRRTU)           ADDR OF RELATIVE RECORD REQUEST\n         DC    A(RTDSTU)           ADDR OF DSNAME RETURN\n         DC    A(RTDDTU)           ADDR OF DDNAME RETURN\n         DC    X'80',AL3(RTRRTU)   ADDR OF LAST RELATIVE RECD RETURN\n         SPACE 1\nRTDSTU   DC    X'0005'             ALLOCATION BY DSNAME\n         DC    X'0001'             ONE PARAMETER\nRTDSLNG  DC    X'002C'             LENGTH OF PARAMETER\nRTDSN    DC    CL44' '\n         DS    0H\nRTDDTU   DC    X'0004'             DDNAME\n         DC    X'0001'             ONE PARAMETER\nRTDDLNG  DC    X'0008'             LENGTH OF PARAMETER\nRTDDN    DC    CL8' '              AREA FOR DDNAME\n         DS    0H\nINRRTU   DC    X'000F'             RELATIVE RECORD\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0002'             LENGTH OF PARAMETER\nINRRNUM  DC    X'0001'             RELATIVE RECORD ONE\n         DS    0H\nRTRRTU   DC    X'000D'\n         DC    X'0001'\n         DC    X'0001'\nRTRRNUM  DC    X'00'\n***********\n         LTORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDDNAME            DS  CL8\nDSNAME_AREA       DS  CL44\nDSNAME_COUNT      DS  H\nDSNAME_TABLE      DS  44000X\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n         IRXEVALB\n         IEFZB4D0\n         IEFZB4D2\n**\n**\n** (C) COPYRIGHT 1997, SSC, INC.\n**\n**  SSC, INC.\n**  13530 WILT STORE RD.\n**  LEESBURG, VA  20176\n**  (703) 777-2771    FAX (703) 777-6839\n**\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRFNDS": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01&\\x01&\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 294, "newlines": 294, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL FIND A            *\n* MEMBER IN A CONCATENATED LIST                                *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    MEMBER      = WHICH WILL CONTAIN THE MEMBER NAME TO FIND  *\n*    SEARCH_DDNAME = THE DDNAME TO SEARCH                      *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    DSNAME_AREA = WHERE THIS PROGRAM WILL STORE THE DATASET    *\n*                 NAME OR THE KEYWORD NOT_FOUND                *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRFNDM CSECT\nALXRFNDM AMODE 31\nALXRFNDM RMODE 24\n         PRINT ON,GEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRFNDM,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n******************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_FIND            NO, THEN DO DEFAULT\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_FIND            IF NULL/ZERO THEN DO DEFAULT\n         CH    R3,HW8              VERIFY IT'S NOT TOO LONG\n         BH    BAD_FIND            NO, THEN CONTINUE\n         MVC   MEMBER(8),BLANKS    BLANK OUT THE MEMBER NAME\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         EX    R3,MOVEMMBR         MVC   MEMBER(0),0(R10)\n         LA    R4,DDNAME ADDRESS FOR TEXT OF MESSAGE\n******************************************************************\n         CLC   8(8,R11),FFFLAG     HAVE THEY SPECIFIED A DDNAME\n         BE    SET_DEFAULT         NO, THEN JUST SET TO 80 BYTES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF REPLY_LENGTH VALUE\n         BZ    SET_DEFAULT         JUST SET TO 80 BYTES\n         MVC   DDNAME(8),BLANKS    BLANK OUT THE DDNAME\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVEDDN          MVC   DDNAME(0),0(R10)\n         B     SEARCH_LOADLIB\nSET_DEFAULT    EQU    *\n         MVC   DDNAME(8),=C'LOADLIBS' SET THE DEFAULT\n****************************************************************\n*  HERE IS WHERE WE WILL USE SVC99 TO READ ALL OF THE DDNAMES  *\n* AND THEIR CORRESPONDING DATASET NAMES.                       *\n****************************************************************\nSEARCH_LOADLIB EQU   *\n         LA    R3,DSNAME_TABLE    POINT TO TABLE\n         LA    R5,S99AREA         ADDRESS SVC99 PARAMETER FIELDS\n         USING S99RB,R5\n         MVI   S99VERB,S99VRBIN   INDICATE INFORMATION TO BE GOTTEN\n         LA    R4,1               SET FIRST RELATIVE RECD COUNTER\n         SLR   R2,R2              ZERO IT OUT FOR COUNT\nLOOP_SVC99 EQU *\n*\n         LA    R1,INTUPTR         ADDR OF ALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP        STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM         LOAD ADDRESS OF SVC 99 PARM AREA\n         MVC   RTDDLNG(2),HW8     RESET DDNAME LENGTH\n         MVC   RTDSLNG(2),HW44    RESET DSNAME LENGTH\n         MVI   RTDSN,C' '         BLANK OUT DSNAME\n         MVC   RTDSN+1(43),RTDSN  BLANK OUT DSNAME\n         MVC   RTDDN(8),RTDSN     BLANK OUT DDNAME\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         LTR   R15,R15             VERIFY RETURN CODE\n         BNZ   BAD_FIND            NOT ZERO THEN ISSUE ERROR MSG\n         TM    FLAG,FOUND_DDN      HAVE WE ALREADY FOUND OUR DDN ?\n         BO    CHECK_END           YES, THEN CHECK FOR THE END\n         CLC   RTDDN(8),DDNAME     COMPARE FOR OUR DDNAME\n         BNE   SETNEXT\n         OI    FLAG,FOUND_DDN\n         B     MOVEADSN\nCHECK_END EQU  *\n         CLC   RTDDN(8),BLANKS     SEE IF CONCATENATED\n         BNE   DONEALOC            NO, THEN WE GOT OURS\nMOVEADSN MVC   0(44,R3),RTDSN      AND ALSO THE DATASET NAME\n         LA    R2,1(R2)            INCR THE COUNT\n         LA    R3,44(R3)           INCREMENT FIELD IN STORAGE\nSETNEXT  LA    R4,1(R4)            INCR RELATIVE RECORD COUNT\n         STH   R4,INRRNUM          SAVE FOR NEXT SVC99 INVOCATION\n         TM    RTRRNUM,X'80'       WAS THAT THE LAST\n         BZ    LOOP_SVC99          NO, THEN CONITNUE READING LIST\nDONEALOC LTR   R2,R2               MAKE SURE THAT WE FOUND OUR FILE\n         BZ    BAD_FIND            NO, THEN GET OUT\n         STCM  R2,3,DSNAME_COUNT   SAVE THE COUNT\n         SPACE 2\n*********************************************************************\n* THIS SECTION WILL OPEN THE FILE AND READ IN ALL THE PROGRAM       *\n* ENTRIES TO THE TABLE.                                             *\n*********************************************************************\nOPENLIB  MVC  LOADLIBS+40(8),DDNAME\n* COMMENTED OUT ADDRESSING CODE TO KEEP 31BIT   WHS  6/16/04\n*        LA   R14,OPENBSM\n*        ICM  R14,8,=X'00'\n*        BSM  R0,R14\nOPENBSM  EQU  *\n         OPEN (LOADLIBS,INPUT),MODE=31\n         TM   LOADLIBS+48,X'10'\n         BZ   BAD_FIND2\n         LA   R2,MEMBER_BLDL\n         BLDL LOADLIBS,(2)\n         LTR  R15,R15\n         BZ   GOTDSNAME\n         MVC  DSNAME_AREA(44),NOT_FOUND_DSN\n         B    CLOSEUP\nGOTDSNAME EQU *\n         LH   R3,DSNAME_COUNT\n         SLR  R14,R14\n         IC   R14,MEMBER+11          GET THE CONCATENATION VALUE\n         MH   R14,HW44\n         LA   R15,DSNAME_TABLE\n         LA   R15,0(R14,R15)         INCREMENT TO THE DSNAME ENTRY\n         MVC  DSNAME_AREA(44),0(R15)\nCLOSEUP  EQU  *\n         CLOSE (LOADLIBS),MODE=31\n* COMMENTED OUT ADDRESSING CODE TO KEEP 31BIT   WHS  6/16/04\n*        LA   R14,SETRPLY\n*        ICM  R14,8,=X'80'\n*        BSM  R0,R14\n****************************************\nSETRPLY  L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         LH    R8,HW44\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(44),DSNAME_AREA\nFREESTOR EQU   *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_FIND       EQU   *\n         MVC   DSNAME_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\nBAD_FIND2      EQU   *\n         MVC   DSNAME_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n* COMMENTED OUT ADDRESSING CODE TO KEEP 31BIT   WHS  6/16/04\n*        LA   R14,SETRPLY\n*        ICM  R14,8,=X'80'\n*        BSM  R0,R14\n         B    SETRPLY\n         EJECT\nLOADLIBS DCB  DDNAME=LOADLIBS,DSORG=PO,MACRF=R,DCBE=LOADLIBE\nLOADLIBE DCBE RMODE31=BUFF,EODAD=CLOSEUP\nMOVEMMBR        MVC   MEMBER(0),0(R10)\nMOVEDDN         MVC   DDNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),DSNAME_AREA\nHW4             DC    H'4'\nHW8             DC    H'8'\nHW10            DC    H'10'\nHW12            DC    H'12'\nHW44            DC    H'44'\nHW80            DC    H'80'\nHW119           DC    H'119'\nHW122           DC    H'122'\nFFFLAG   DC    8X'FF'\n******\nMEMBER_BLDL     DC  H'1',H'12'\nMEMBER          DC  CL8' ',4X'00'\n******\nBLANKS          DC  CL8' '\nNOT_FOUND_DSN   DC  CL44'NOT_FOUND '\nERROR_FUNCTION  DC    CL33'ERROR IN SPECIFYING FIND FUNCTION'\nFLAG             DC    X'00'\n*     HERE ARE THE SVC 99 PARAMETER VALUES\n         DS    0F\nS99PARM  DC    X'80',AL3(S99AREA)  ADDRESS OF SVC 99 REQUEST BLOCK\nS99AREA  DC    AL1(S99RBEND-S99RB) LENGTH OF REQUEST BLOCK\nVERBCDE  DC    X'00'               VERB CODE\n         DC    XL6'00'\nPOINTER  DC    A(INTUPTR)          POINTER TO LIST OF TEXT UNIT PTRS\n         DC    XL8'00'\n         SPACE 1\nINTUPTR  DC    A(INRRTU)           ADDR OF RELATIVE RECORD REQUEST\n         DC    A(RTDSTU)           ADDR OF DSNAME RETURN\n         DC    A(RTDDTU)           ADDR OF DDNAME RETURN\n         DC    X'80',AL3(RTRRTU)   ADDR OF LAST RELATIVE RECD RETURN\n         SPACE 1\nRTDSTU   DC    X'0005'             ALLOCATION BY DSNAME\n         DC    X'0001'             ONE PARAMETER\nRTDSLNG  DC    X'002C'             LENGTH OF PARAMETER\nRTDSN    DC    CL44' '\n         DS    0H\nRTDDTU   DC    X'0004'             DDNAME\n         DC    X'0001'             ONE PARAMETER\nRTDDLNG  DC    X'0008'             LENGTH OF PARAMETER\nRTDDN    DC    CL8' '              AREA FOR DDNAME\n         DS    0H\nINRRTU   DC    X'000F'             RELATIVE RECORD\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0002'             LENGTH OF PARAMETER\nINRRNUM  DC    X'0001'             RELATIVE RECORD ONE\n         DS    0H\nRTRRTU   DC    X'000D'\n         DC    X'0001'\n         DC    X'0001'\nRTRRNUM  DC    X'00'\n***********\n         LTORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDDNAME            DS  CL8\nDSNAME_AREA       DS  CL44\nDSNAME_COUNT      DS  H\nDSNAME_TABLE      DS  44000X\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n         IRXEVALB\n         IEFZB4D0\n         IEFZB4D2\n**\n**\n** (C) COPYRIGHT 1997, SSC, INC.\n**\n**  SSC, INC.\n**  13530 WILT STORE RD.\n**  LEESBURG, VA  20176\n**  (703) 777-2771    FAX (703) 777-6839\n**\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRGETM": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01\\xd7\\x01\\xd7\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 471, "newlines": 471, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL READ A MEMBER     *\n* IN A PDS AND RETURN THE RECORDS/BLOCKS AS COMPOUND VARIABLES *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    MEMBER   = WHICH WILL CONTAIN THE MEMBER NAME TO FIND     *\n*    DDNAME   = THE DDNAME TO SEARCH                           *\n*    VARIABLE_NAME = NAME OF THE COMPOUND VARIABLE             *\n*    COUNT    = MAXIMUM NUMBER OF RECORDS TO READ OR 'COUNT'   *\n*               KEYWORD TO COUNT TOTAL NUMBER OF RECORDS       *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = WHERE THIS PROGRAM WILL RETURN THE STATUS   *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n*                                                              *\n****************************************************************\nALXRGETM CSECT\nALXRGETM AMODE 31\nALXRGETM RMODE 24\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRGETM,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         ST    R7,EVALBLK_ADDRESS\n**************************************************************\n*  THE FIRST PARAMETER IS THE NAME OF THE MEMBER TO READ     *\n**************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_PARM            NO, THEN QUIT WITH ERROR\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_PARM            IF NULL/ZERO THEN DO DEFAULT\n         CH    R3,HW8              VERIFY IT'S NOT TOO LONG\n         BH    BAD_PARM            NO, THEN CONTINUE\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         EX    R3,MOVEMMBR         MVC   MEMBER(0),0(R10)\n**************************************************************\n*  THE SECOND PARAMETER IS THE DDNAME OF THE MEMBER TO READ  *\n**************************************************************\n         CLC   8(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF DDNAME VALUE\n         BZ    PROCESS_VARNAME     IF 0 THEN USE DEFAULT AND GO TO NEXT\n         MVC   PDSLIB+40(8),BLANKS    BLANK OUT THE DDNAME\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVEDDN          MVC   PDSLIB+40(0),0(R10)\n**************************************************************\n*  THE THIRD PARAMETER IS THE COMPOUND VARIABLE NAME         *\n**************************************************************\nPROCESS_VARNAME EQU  *\n         CLC   16(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,20(R11)       GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_COUNT       IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW17             LENGTH 17 IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         L     R10,16(R11)         POINT TO THE ARGUMENT\n         STH   R9,VARNAME_LENGTH   SAVE THE LENGTH\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVEVARN         MVC   VARNAME(0),0(R10)\n******************************************************************\n*  THE FOURTH PARAMETER IS THE MAXIMUM NUMBER OF RECORDS TO READ *\n******************************************************************\nPROCESS_COUNT   EQU  *\n         CLC   24(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,28(R11)       GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_START       IF 0 THEN USE DEFAULT AND GO TO NEXT\n         L     R10,24(R11)         POINT TO THE ARGUMENT\n         CLC   0(5,R10),=C'COUNT'   DID THEY SUPPLY COUNT KW\n         BNE   DECR9CNT             NO, THEN GO AROUND\n         OI    FLAG,X'80'           SET FLAG FOR COUNT\n         LA    R8,1                 SET COUNT TO 1\n         B     STORE_COUNT          AND GO AROUND AND STORE IT\nDECR9CNT BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_COUNT        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE LENGTH OF REPLY IN R8\n         CH    R8,HW9999            CAN'T BE GT MAX\n         BH    BAD_PARM             YES, THEN JUST QUIT\nSTORE_COUNT    EQU  *\n         STH   R8,COUNT_VALUE       SAVE THE COUNT FOR GETMAIN\n         STH   R8,UCOUNT_VALUE      SAVE COUNT FOR RECFM U ALSO\n******************************************************************\n*  THE FIFTH PARAMETER IS THE STARTING NUMBER OF WHERE TO BEGIN  *\n* READING RECORDS. THIS WOULD BE USED FOR SUBSEQUENT INVOCATION  *\n* OF THIS FUNCTION TO PICK UP WHERE IT LEFT OFF.                 *\n******************************************************************\nPROCESS_START   EQU  *\n         CLC   32(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,36(R11)       GET THE LENGTH OF VAR NAME\n         BZ    USE_DEFAULTS        IF 0 THEN WE ARE DONE\n         L     R10,32(R11)         POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_START        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE START RECORD NUMBER IN R8\n         STH   R8,START_VALUE       SAVE THE COUNT FOR READING RECORDS\nUSE_DEFAULTS   EQU    *\n*********************************************************************\n* THIS SECTION WILL OPEN THE FILE AND READ IN ALL THE PROGRAM       *\n* ENTRIES TO THE TABLE.                                             *\n*********************************************************************\nOPENLIB  EQU  *\n* COMMENTED OUT ADDRESSING CHANGE  ALL 31BIT   WHS  6/16/04\n*        LA   R14,OPENBSM\n*        ICM  R14,8,=X'00'\n*        BSM  R0,R14\nOPENBSM  EQU  *\n         OPEN (PDSLIB,(INPUT)),MODE=31\n         TM   PDSLIB+48,X'10'\n         BZ   BAD_OPEN\n         TM   PDSLIB+36,X'C0'\n         BNO  NOT_UCOUNT\n         MVC  COUNT_VALUE(2),UCOUNT_VALUE\nNOT_UCOUNT    EQU  *\n         LH   R3,COUNT_VALUE\n         LH   R5,VARNAME_LENGTH\n         LA   R5,17(R5)              INCREMENT FOR SHV BLOCK INFO\n*           VARNAME LGNTH+VARDATA LNGTH+VARDATA ADDR+ 5 (.9999)\n         CH   R3,HW1000              SEE IF LT 1000\n         BNL  LEAVEIT\n         BCTR R5,0                   TAKE ONE AWAY FOR SMALLER GETMAIN\nLEAVEIT  MH   R5,COUNT_VALUE         GET THE TOTAL GETMAIN\n         LA   R5,20(R5)              ACCOUNT FOR HEADER INFORMATION\n         TM   PDSLIB+36,X'C0'        VERIFY NOT RECFM U\n         BNO  NOTLMOD\n         MH   R3,PDSLIB+62           AND MULTIPLY BY BLKSIZE\n         B    COUNTSET               AND GO AROUND\nNOTLMOD  LA   R3,1(R3)               ADD ONE MORE FOR MEMBER.0\n         MH   R3,PDSLIB+82           MULTIPLY BY LRECL FOR MAX RECORD\nCOUNTSET LH   R0,PDSLIB+62           GET THE BLKSIZE IN HERE AS WELL\n         AR   R5,R3\n         AR   R0,R5\n         ST   R0,GETMAIN_LENGTH      SAVE THE LENGTH\n         GETMAIN RC,LV=(0)\n         LTR  R15,R15\n         BNZ   BAD_STORAGE            ISSUE MESSAGE AND GET OUT\n         ST    R1,GETMAIN_ADDRESS\n         LR    R10,R1                 SAVE FOR REXX SHV BLOCK DATA\n         LA    R8,0(R5,R10)           POINT PAST THE SHV BLOCK INFO\n         LA    R10,20(R10)            INCREMENT PASSED HEADER INFO\n         ST    R8,BLOCK_ADDRESS       SAVE THE ADDRESS\n         LA    R2,MEMBER\n         FIND  PDSLIB,(2),D\n         LTR   R15,R15\n         BNZ   NOT_FOUND\n************************************************************\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVC   0(2,R14),STEM0        MOVE IN PERIOD AND ZERO\n         LA    R15,3(R15)            1 FOR EX DECR, 1 FOR . , 1 FOR 0\n         STCM  R15,15,0(R10)         SAVE THE VARIABLE NAME LENGTH\n         LA    R10,2(R14)            INCREMENT PAST STEM\n         LH    R15,HW4               LENGTH OF 4 FOR VAR DATA\n         STCM  R15,15,0(R10)         SAVE THE LENGTH\n         LA    R10,4(R10)            INCREMENT TO VAR DATA\n         ST    R10,STEM0_ADDRESS     SAVE THIS LOCATION\n         XC    0(4,R10),0(R10)       AND ZERO THE VARDATA\n         LA    R10,4(R10)            AND INCREMENT PAST IT\n         LA    R3,1                  SET FOR MEMBER.0 VARIABLE\n*        SLR   R3,R3                 MAINTAIN THE COUNT OF VARIABLES\nLOOPREAD EQU  *\n         LH    R14,PDSLIB+62      IF IT IS RECFM U THEN NEED BLKSIZE\n         READ PDSDECB,SF,PDSLIB,(8),(14)\n         CHECK PDSDECB\n         L     R14,BLOCK_COUNT\n         LA    R14,1(R14)        INCREMENT BY ONE\n         ST    R14,BLOCK_COUNT\n         LH    R6,PDSLIB+62      BLKSIZE\n         L     R7,PDSDECB+16      IOB\n         SH    R6,14(R7)\n         SRDL  R6,32\n         LR    R9,R7             SAVE THE BLOCK SIZE READ\n         LH    R4,PDSLIB+82      LRECL\n         LR    R5,R8\n         TM    PDSLIB+36,X'80'  IS IT VARIABLE LENGTH BLOCK\n         BO    LOOPMOVE           NO, THEN PROCESS FIXED\n         LA    R5,4(R5)           ADDRESS PAST BDW\n         SH    R7,HW4             SUBTRACT THE BDW\nLOOPMOVE EQU   *\n* INITIALIZE THE SHV BLOCKS AND INCREMENT THE COMPOUND VARIABLE HERE\n*\n         TM    FLAG,X'80'          ARE WE PROCESSING COUNT ONLY\n         BO    DONT_INCRSHV        YES, THEN GO AROUND\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVI   0(R14),C'.'         MOVE IN PERIOD\n         LA    R14,1(R14)           INCREMENT PAST\n         AP    COMPOUND_STEM(3),INCR_STEM(1)\n         MVC   STEM_VALUE(6),STEM_MASK  SET THE MASK\n         ED    STEM_VALUE(6),COMPOUND_STEM\n         TRT   STEM_VALUE(6),NBLNKTBL      LOOK FOR FIRST NON BLANK\n         LA    R2,STEM_VALUE+5             INCR FOR SUBTRACT\n         SLR   R2,R1               GET THE LENGTH\n         EX    R2,MOVE_STEM        MVC  0(0,R14),0(R1)\n         LA    R15,3(R2,R15)       2 FOR EX DECR, AND 1 FOR PERIOD\n         STCM  R15,15,0(R10)        SAVE THE VARIABLE NAME LENGTH\n         LA    R10,1(R2,R14)        INCREMENT PAST STEM\n*\n*  PROCESS RECFM U BLOCKS AS INDIVIDUAL COMPOUND VARIABLES\n*\nDONT_INCRSHV   EQU  *\n         TM    PDSLIB+36,X'C0'    IS IT A LOAD MODULE\n         BNO   CHECK_VARBLE       NO, THEN PROCESS FIXED BLOCK\n         LR    R4,R9              GET THE SIZE OF THE BLOCK READ\n         B     MOVE_RECORD        AND GO PROCESS THE RECORD\n**\nCHECK_VARBLE   EQU  *\n         TM    PDSLIB+36,X'40'    IS IT VARIABLE LENGTH BLOCK\n         BZ    MOVE_RECORD        NO, THEN PROCESS FIXED BLOCK\n         SLR   R4,R4              CLEAR R4\n         ICM   R4,3,0(R5)         GET THE RDW\n         SH    R4,HW4             SUBTRACT THE RDW\n         SH    R7,HW4             AND FROM THE OVERALL SIZE\n         LA    R5,4(R5)           INCREMENT PAST THE RDW\nMOVE_RECORD    EQU  *\n         TM    FLAG,X'80'          ARE WE PROCESSING COUNT ONLY\n         BZ    DO_THE_MOVE         NO, THEN GO AROUND\n         SR    R7,R4              REMOVE THE LENGTH\n         B     ITSMOVED            YES, THEN GO AROUND\nDO_THE_MOVE    EQU   *\n         STCM  R4,15,0(R10)       MOVE IN THE VARIABLE DATA LENGTH\n         SR    R7,R4              REMOVE THE LENGTH\n         CH    R4,HW255           IS THIS TOO BIG FOR MVC\n*        DC    H'00'\n         BL    NOT_MVCL\n         LA    R14,4(R10)         POINT TO LOCATION OF VAR DATA\n         LR    R0,R5              POINT TO THE INPUT DATA\n         LR    R1,R4              GET THE LENGTH\n         LR    R15,R4             HERE ALSO\n         MVCL  R14,R0             MOVE IT IN\n         LA    R10,4(R4,R10)      GET PAST THE VARIABLE DATA\n         B     ITSMOVED           AND GO AROUND\nNOT_MVCL LR    R15,R4             GET THE LENGTH FOR DECR\n         BCTR  R15,0              DECR FOR EX  MVC\n         EX    R15,MOVE_VARDATA   MVC   4(0,R10),0(R5)\n         LA    R10,4(R4,R10)      GET PAST THE VARIABLE DATA\nITSMOVED LA    R3,1(R3)           INCREMENT THE COUNT\n         TM    FLAG,X'80'          ARE WE PROCESSING COUNT ONLY\n         BO    CHCKLOOP            YES, THEN GO AROUND\n         CH    R3,COUNT_VALUE    CHECK TO SEE IF MAX HIT\n         BNL   CLOSEUP            ELSE FINISH UP AND GET OUT\nCHCKLOOP LTR   R7,R7              SEE IF ANY MORE RECORDS LEFT\n         BZ    LOOPREAD           READ THE NEXT RECORD\n         LA    R5,0(R4,R5)        INCREMENT TO NEXT RECORD\n         B     LOOPMOVE           THEN MORE RECORDS\nCLOSEUP  EQU  *\n         CLOSE (PDSLIB),MODE=31\nRESET31  EQU  *\n*RESET31 LA   R14,CHECK_ERROR\n*        ICM  R14,8,=X'80'\n*        BSM  R0,R14\nCHECK_ERROR   EQU  *\n         TM   FLAG,X'01'          DID AN ERROR OCCUR ??\n         BO   SETRPLY\n****************************************\nSTOREIT  L    R14,GETMAIN_ADDRESS\n         USING ALXPARM,R14\n         MVC  ALXEXCOM_FUNCTION(8),=C'STORE   '\n         ST   R3,ALXEXCOM_VARCOUNT\n         TM   FLAG,X'80'          ARE WE PROCESSING COUNT ONLY\n         BZ   CONT_STORE          NO, THEN GO AROUND\n         MVC  ALXEXCOM_VARCOUNT(4),=F'1'  MOVE IN ONLY STEM.0\nCONT_STORE    EQU  *\n         L    R15,STEM0_ADDRESS\n         BCTR R3,0\n         CVD  R3,DOUBLE_WORD           GET IT\n         ED   STEM_MASK(6),DOUBLE_WORD+5\n         MVC  0(4,R15),STEM_MASK+2\n         LA   R1,ALXEXCOM_FUNCTION     SET THE PARM FIELD UP LIKE\n         ST   R1,PARMLIST                THIS SO THAT SUBROUTINE IS\n         LA   R1,PARMLIST                ABLE TO HANDLE PARM LIKE COBOL\n*        MVI  ALXEXCOM_RETCODE,C'Y'    TELL ALXEXCOM THAT VAR DATA\n*                                        ADDRESS IS IN THE FIELD\n         DROP R14\n         L    R15,ALXEXCOM\n         BALR R14,R15\n****\n*\n         LA    R8,2                    SET THE DEFAULT REPLY MESSAGE\n****************************************\nSETRPLY  L     R7,EVALBLK_ADDRESS\n         L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(33),STATUS_AREA\nFREESTOR EQU   *\n         ICM   R1,15,GETMAIN_ADDRESS\n         BZ    NOT_GOTTEN\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN RC,A=(1),LV=(0)\nNOT_GOTTEN     EQU  *\n         LR    R1,R13\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_PARM       EQU   *\n         MVC   STATUS_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\nBAD_OPEN       EQU   *\n         MVC   STATUS_AREA(33),OPEN_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,25\n         B     RESET31\n*************************\nBAD_STORAGE    EQU   *\n         MVC   STATUS_AREA(33),STORAGE_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,22\n         B     CLOSEUP\n*************************\nNOT_FOUND      EQU   *\n         MVC   STATUS_AREA(33),NOT_FOUND_MBR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,26\n         B     CLOSEUP\n*************************\n               DC  H'00'\n         EJECT\nPDSLIB   DCB    DDNAME=PDSLIB,DSORG=PO,MACRF=R,DCBE=PDSLIBE\nPDSLIBE  DCBE   RMODE31=BUFF,EODAD=CLOSEUP\nALXEXCOM DC     V(ALXEXCOM)\nMEMBER   DC     CL8' ',2F'0'\nMOVEMMBR        MVC   MEMBER(0),0(R10)\nMOVEDDN         MVC   PDSLIB+40(0),0(R10)\nMOVEVARN        MVC   VARNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),STATUS_AREA\nMOVE_STEM       MVC   0(0,R14),0(R1)\nINITVARN        MVC   4(0,R10),VARNAME\nMOVE_VARDATA    MVC   4(0,R10),0(R5)\nPACK_COUNT      PACK  DOUBLE_WORD(0),0(0,R10)\nPACK_START      EQU PACK_COUNT\nHW4             DC  H'4'\nHW8             DC  H'8'\nHW17            DC  H'17'\nHW33            DC  H'33'\nHW255           DC  H'255'\nHW1000          DC  H'1000'\nHW9999          DC  H'9999'\nFFFLAG          DC  8X'FF'\nUCOUNT_VALUE    DC  H'20'\nCOUNT_VALUE     DC  H'1000'\nSTART_VALUE     DC  H'1'\nVARNAME_LENGTH  DC  H'6'\nVARNAME         DC  CL22'RECORD '\nSTEM0           DC  CL2'.0'\nSTEM_VALUE      DC  CL6' '\nSTEM_MASK       DC  X'402020202120'\nCOMPOUND_STEM   DC  PL3'0'\nINCR_STEM       DC  PL1'1'\n******\n******\nBLANKS          DC  CL8' '\nSTATUS_AREA     DC  CL33'OK'\nERROR_FUNCTION  DC  CL33'ERROR IN SPECIFYING READ FUNCTION' 33\nOPEN_ERROR      DC  CL33'ERROR OPENING PDS DATASET '  25\nSTORAGE_ERROR   DC  CL33'STORAGE REQUEST FAILED    '  22\nNOT_FOUND_MBR   DC  CL33'MEMBER REQUESTED NOT_FOUND ' 26\nFLAG            DC  X'00'\n***********\n         LTORG\n         DS     0F\nNBLNKTBL DC     256X'FF'\n         ORG    NBLNKTBL+C' '\n         DC     X'00'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDOUBLE_WORD       DS  D\nEVALBLK_ADDRESS   DS  F\nGETMAIN_ADDRESS   DS  F\nGETMAIN_LENGTH    DS  F\nSTEM0_ADDRESS     DS  F\nBLOCK_ADDRESS     DS  F\nRECORD_COUNT      DS  F\nBLOCK_COUNT       DS  F\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n***************************\nALXPARM           DSECT\nPARMLIST          DS  F\nALXEXCOM_FUNCTION DS  CL8\nALXEXCOM_VARCOUNT DS  F\nALXEXCOM_RETCODE  DS  F\nALXEXCOM_STORAGE  EQU *\n**\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRPDSC": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01K\\x01K\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 331, "newlines": 331, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL PROCESS           *\n* REQUESTS FOR MANIPULATING A PDS                              *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    FUNCTION = SCRATCH, RENAME OR ALIAS                       *\n*    DDNAME   = THE DDNAME TO SEARCH                           *\n*    MEMBER   = THE MEMBER NAME TO PROCESS                     *\n*    MEMBER   = THE NAME FOR RENAME OR ALIAS                   *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = WHERE THIS PROGRAM WILL RETURN THE STATUS   *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRPDSC CSECT\nALXRPDSC AMODE 31\nALXRPDSC RMODE 24\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRPDSC,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         XC    FLAG(1),FLAG\n         ST    R7,EVALBLK_ADDRESS\n**************************************************************\n*  THE FIRST PARAMETER IS THE FUNCTION TO PROCESS            *\n**************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_PARM            NO, THEN QUIT WITH ERROR\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_PARM            IF NULL/ZERO THEN DO DEFAULT\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         CLC   0(7,R10),SCRATCH_KW IS THIS A SCRATCH FUNCTION\n         BNE   CHECK_RENAME        NO, THEN TRY RENAME\n         OI    FLAG,X'01'          SET A FLAG FOR NOW\n         B     SECOND_VARIABLE     GO PROCESS THE NEXT VARIABLE\nCHECK_RENAME   EQU  *\n         CLC   0(6,R10),RENAME_KW  IS THIS A RENAME FUNCTION\n         BNE   CHECK_ALIAS         NO, THEN TRY ALIAS\n         OI    FLAG,X'02'          SET A FLAG FOR NOW\n         B     SECOND_VARIABLE     GO PROCESS THE NEXT VARIABLE\nCHECK_ALIAS    EQU  *\n         CLC   0(5,R10),ALIAS_KW   IS THIS AN ALIAS FUNCTION\n         BNE   BAD_PARM            NO, THEN BAD FUNCTION\n**************************************************************\n*  THE SECOND PARAMETER IS THE DDNAME OF THE MEMBER TO READ  *\n**************************************************************\nSECOND_VARIABLE EQU  *\n         CLC   8(8,R11),FFFLAG     END OF PARM LIST\n         BE    BAD_PARM            YES, THEN THERE IS AN ERROR\n         ICM   R9,15,12(R11)       GET THE LENGTH OF DDNAME VALUE\n         BZ    THIRD_VARIABLE      IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW8              LENGTH 8  IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         MVC   PDSREAD+40(8),BLANKS   BLANK IT OUT FOR EX MOVE\n         MVC   DIRREAD+40(8),BLANKS   BLANK IT OUT FOR EX MOVE\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVEDDN          MVC   PDSREAD+40(0),0(R10)\n         MVC   DIRREAD+40(8),PDSREAD+40     AND MOVE IT IN HERE ALSO\n**************************************************************\n*  THE THIRD PARAMETER IS THE MEMBER NAME                    *\n**************************************************************\nTHIRD_VARIABLE  EQU  *\n         CLC   16(8,R11),FFFLAG     END OF PARM LIST\n         BE    BAD_PARM            YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,20(R11)       GET THE LENGTH OF VAR NAME\n         BZ    BAD_PARM            IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW8              LENGTH 17 IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         L     R10,16(R11)         POINT TO THE ARGUMENT\n         MVC   MEMBER_NAME(8),BLANKS   BLANK OUT THE MEMBER\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVEMMBR         MVC   MEMBER_NAME(0),0(R10)\n******************************************************************\n*  THE FOURTH PARAMETER IS RENAME OR ALIAS NAME                  *\n******************************************************************\nFOURTH_VARIABLE EQU  *\n         CLC   24(8,R11),FFFLAG     END OF PARM LIST\n         BE    OPENLIB             YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,28(R11)       GET THE LENGTH OF VAR NAME\n         BZ    OPENLIB             YES, USE REMAINING DEFAULT VALUES\n         TM    FLAG,X'01'          WAS THIS A SCRATCH\n         BO    BAD_PARM            YES, THEN ERROR\n         L     R10,24(R11)         POINT TO THE ARGUMENT\n         TM    FLAG,X'02'          WAS THIS A RENAME\n         BZ    MOVE_AL             NO, THEN MOVE THE ALIAS\n         MVC   RENAME_NAME(8),BLANKS     BLANK OUT THE MEMBER\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVERENM         MVC   RENAME_NAME(0),0(R10)\n         B     OPENLIB\n*\nMOVE_AL  MVC   ALIAS_NAME(8),BLANKS     BLANK OUT THE MEMBER\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVE_ALIAS       MVC   ALIAS_NAME(0),0(R10)\n*********************************************************************\n* THIS SECTION WILL OPEN THE FILE AND READ IN ALL THE PROGRAM       *\n* ENTRIES TO THE TABLE.                                             *\n*********************************************************************\nOPENLIB  EQU  *\n*        LA   R14,OPENBSM\n*        ICM  R14,8,=X'00'\n*        BSM  R0,R14\nOPENBSM  EQU  *\n         OPEN (DIRREAD,(INPUT)),MODE=31\n         TM   DIRREAD+48,X'10'\n         BZ   BAD_OPEN\n*****************************************************************\n         LA    R8,DIRECTORY_READ\nLOCSET   READ  DIRDECB,SF,DIRREAD,(8)\n         CHECK DIRDECB\n         LR    R7,R8               R10 POINTS TO FIELD READ\n         LH    R9,0(R7)            R9 CONTAINS LENGTH OF RECORD\n         AR    R9,R7               POINT TO END OF LIST\n         LA    R7,2(R7)            ADDRESS MEMBER\nLOOPMMBR CLC   0(8,R7),FFFLAG      IS THIS THE LAST DIRECTORY ENTRY\n         BE    NOTFOUND            YES, THEN CLOSE IT AND GET TO WORK\n* INITIALIZE THE SHV BLOCKS AND INCREMENT THE COMPOUND VARIABLE HERE\n*\n***********\n         CLC   0(8,R7),MEMBER_NAME COMPARE FOR OUR MEMBER\n         BE    FOUND_IT            YES, THEN WE ARE OKAY\nGETPAST  IC    R14,11(R7)          GET # OF USER HALFWORDS\n         N     R14,FW31             ZERO OUT HI ORDER BITS\n         SLA   R14,1                MULTIPLY BY TWO\n         LA    R14,12(R14)          ADD THE CONSTANT SECTION TO IT\n         AR    R7,R14               AND THEN INCREMENT R10\n         CR    R7,R9                ARE WE AT THE END OF THIS READ\n         BL    LOOPMMBR             NO, THEN PROCESS THE NEXT\n         B     LOCSET              READ NEXT RECORD\n         EJECT\n******************************************************\nFOUND_IT EQU  *\n         CLOSE (DIRREAD),MODE=31\n         OPEN (PDSREAD,(OUTPUT)),MODE=31\n         TM   PDSREAD+48,X'10'\n         BZ   BAD_OPEN\n         LA   R3,MEMBER_NAME\n         XC   MEMBER_NAME+8(8),MEMBER_NAME+8  VERIFY IT IS ZERO\n         TM   FLAG,X'01'               IS THIS A SCRATCH\n         BZ   TRY_RENAME\n         STOW PDSREAD,(3),D\n         LTR  R15,R15\n         BNZ  NOT_SCRATCHED\n         B    OKAYFUNC\nTRY_RENAME    EQU *\n         TM   FLAG,X'02'               IS THIS A SCRATCH\n         BZ   DO_ALIAS\n         MVC  MEMBER_NAME+8(8),RENAME_NAME    MOVE IT IN FOR RENAME\n         STOW PDSREAD,(3),C\n         LTR  R15,R15\n         BNZ  NOT_RENAMED\n         B    OKAYFUNC\nDO_ALIAS      EQU *\n         IC    R14,11(R7)          GET # OF USER HALFWORDS\n         N     R14,FW31             ZERO OUT HI ORDER BITS\n         SLA   R14,1                MULTIPLY BY TWO\n         LA    R14,11(R14)          ADD THE CONSTANT SECTION TO IT\n         EX    R14,MOVEDIRE         MVC  MEMBER_NAME(0),0(R7)\n         MVC  MEMBER_NAME(8),ALIAS_NAME    MOVE IT IN WITH THE TTR\n         OI   MEMBER_NAME+11,X'80'         TURN ON ALIAS BIT\n*                                 AND ADD THE ALIAS\n         STOW PDSREAD,(3),A\n         LTR  R15,R15\n         BNZ  NOT_ALIASED\nOKAYFUNC LA   R8,4\nCLOSEUP  EQU  *\n         CLOSE (PDSREAD),MODE=31\n*RESET31 LA   R14,SETRPLY\n*        ICM  R14,8,=X'80'\n*        BSM  R0,R14\n****************************************\nSETRPLY  L     R7,EVALBLK_ADDRESS\n         L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(33),STATUS_AREA\nFREESTOR EQU   *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_PARM       EQU   *\n         MVC   STATUS_AREA(33),ERROR_FUNCTION\n         LA    R8,32\n         B     SETRPLY\nBAD_OPEN       EQU   *\n         MVC   STATUS_AREA(33),OPEN_ERROR\n         LA    R8,25\n         B     SETRPLY       WAS RESET31  WHS  6/16/04\n*************************\nNOTFOUND       EQU   *\n         MVC   STATUS_AREA(33),NOT_FOUND_MBR\n         LA    R8,26\n         CLOSE (DIRREAD),MODE=31\n         B     CLOSEUP\n*************************\nNOT_SCRATCHED  EQU   *\n         MVC   STATUS_AREA(33),NOT_SCRATCH_MBR\n         LA    R8,14\n         B     CLOSEUP\n*************************\nNOT_RENAMED    EQU   *\n         MVC   STATUS_AREA(33),NOT_RENAME_MBR\n         LA    R8,13\n         B     CLOSEUP\n*************************\nNOT_ALIASED    EQU   *\n         MVC   STATUS_AREA(33),NOT_ALIAS_MBR\n         LA    R8,24\n         B     CLOSEUP\n*************************\n*************************\nDIRREAD  DCB   DDNAME=PDSUPDTE,DSORG=PS,MACRF=R,DCBE=DIRREADE,         +\n               BLKSIZE=256,LRECL=256,RECFM=F\nPDSREAD  DCB   DDNAME=PDSUPDTE,DSORG=PO,MACRF=W,DCBE=PDSREADE\nDIRREADE DCBE  RMODE31=BUFF,EODAD=NOTFOUND\nPDSREADE DCBE  RMODE31=BUFF\n         EJECT\nMOVEMMBR        MVC   MEMBER_NAME(0),0(R10)\nMOVERENM        MVC   RENAME_NAME(0),0(R10)\nMOVE_ALIAS      MVC   ALIAS_NAME(0),0(R10)\nMOVEDDN         MVC   PDSREAD+40(0),0(R10)\nMOVEDIRE        MVC   MEMBER_NAME(0),0(R7)\nFW31            DC  F'31'\nHW1             DC  H'1'\nHW8             DC  H'8'\nHW80            DC  H'80'\nFFFLAG          DC  8X'FF'\nSCRATCH_KW      DC  CL7'SCRATCH'\nRENAME_KW       DC  CL6'RENAME'\nALIAS_KW        DC  CL5'ALIAS'\n******\n******\nBLANKS          DC  CL8' '\nSTATUS_AREA     DC  CL34'OK'\nERROR_FUNCTION  DC  CL33'ERROR IN SPECIFYING THE FUNCTION'\nOPEN_ERROR      DC  CL33'ERROR OPENING PDS DATASET ' 24\nSTORAGE_ERROR   DC  CL33'STORAGE REQUEST FAILED    '\nNOT_FOUND_MBR   DC  CL33'MEMBER REQUESTED NOT FOUND '\nNOT_SCRATCH_MBR DC  CL33'SCRATCH FAILED '\nNOT_RENAME_MBR  DC  CL33'RENAME FAILED '\nNOT_ALIAS_MBR   DC  CL33'ALIAS ASSIGNMENT FAILED '\n***********\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nBLDL_COUNT        DS  H\nBLDL_LENGTH       DS  H\nMEMBER_NAME       DS  CL8,2F\n                  DS  60X\nRENAME_NAME       DS  CL8\nALIAS_NAME        DS  CL8\nGETMAIN_ADDRESS   DS  F\nEVALBLK_ADDRESS   DS  F\nGETMAIN_LENGTH    DS  F\nFLAG              DS  X\nDIRECTORY_READ    DS  256X\n*************************\nSTORAGE_SIZE      EQU  *-SAVEAREA\n**\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRQSCN": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01\\xa8\\x01\\xa8\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 424, "newlines": 424, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE ANY                                   *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL USE GQSCAN        *\n* TO DETERMINE IF ANY ENQUEUES EXIST FOR DATA SETS, AND        *\n* RETURN THE DATA SET, THE OWNER, AND THE WAITER               *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    VARIABLE_NAME = NAME OF THE COMPOUND VARIABLE             *\n*    COUNT    = MAXIMUM NUMBER OF MEMBERS TO LIST              *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = WHERE THIS PROGRAM WILL RETURN THE STATUS   *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRQSCN CSECT\nALXRQSCN AMODE 31\nALXRQSCN RMODE ANY\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\nYESDASD        EQU  8\nYESTAPE        EQU  4\nBYPVOL         EQU  2\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRQSCN,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         XC    FLAG(1),FLAG          CLEAR IT\n         ST    R7,EVALBLK_ADDRESS\n         MVC   EYECATCH(8),=C'EYECATCH'\n**************************************************************\n*  THE FIRST  PARAMETER IS THE COMPOUND VARIABLE NAME        *\n**************************************************************\nPROCESS_VARNAME EQU  *\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,4(R11)        GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_COUNT       IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW17             LENGTH 17 IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         L     R10,0(R11)          POINT TO THE ARGUMENT\n         STH   R9,VARNAME_LENGTH   SAVE THE LENGTH\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVEVARN         MVC   VARNAME(0),0(R10)\n******************************************************************\n*  THE SECOND  PARAMETER IS THE MAXIMUM NUMBER OF UCBS    TO READ*\n******************************************************************\nPROCESS_COUNT   EQU  *\n         CLC   8(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF VAR NAME\n         BZ    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_COUNT        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE LENGTH OF REPLY IN R8\n         CH    R8,HW9999            CAN'T BE GT MAX\n         BH    BAD_PARM             YES, THEN JUST QUIT\n         STH   R8,COUNT_VALUE       SAVE THE COUNT FOR GETMAIN\nUSE_DEFAULTS   EQU    *\n*********************************************************************\n*                                                                   *\n*********************************************************************\n         LH   R3,COUNT_VALUE\n         LH   R5,VARNAME_LENGTH\n         LA   R5,17(R5)              INCREMENT FOR SHV BLOCK INFO\n*           VARNAME LGNTH+VARDATA LNGTH+VARDATA ADDR+ 5 (.9999)\n         CH   R3,HW1000              SEE IF LT 1000\n         BNL  LEAVEIT\n         BCTR R5,0                   TAKE ONE AWAY FOR SMALLER GETMAIN\nLEAVEIT  MH   R5,COUNT_VALUE         GET THE TOTAL GETMAIN\n         LA   R5,20(R5)              INCR PASSED BEGINNING\n         LA   R3,1(R3)               ADD ONE MORE FOR MEMBER.0\nMULTIPLY_BY8  EQU   *\n         MH   R3,HW46                MULT LENGTH OF LONGEST FIELD\nNOTBY8   AR   R5,R3                  TOTAL THE GETMAIN\n         LR   R4,R5                  SAVE THIS\n         ST   R4,FUNCTION_LENGTH\n         L    R15,GQSTORE            GET THE LENGTH FOR GQSCAN\n         AR   R5,15                  AND INCREMENT\n         LR   R0,R5\n         ST   R0,GETMAIN_LENGTH      SAVE THE LENGTH\n         GETMAIN RC,LV=(0)\n         LTR  R15,R15\n         BNZ   BAD_STORAGE            ISSUE MESSAGE AND GET OUT\n         ST    R1,GETMAIN_ADDRESS\n         AR    R4,R1                  INCREMENT TO GQSCAN AREA\n         ST    R4,GQAREA_ADDRESS      AND SAVE THE LOCATION\n         LA    R10,20(R1)             SAVE FOR REXX SHV BLOCK DATA\n************************************************************\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVC   0(2,R14),STEM0        MOVE IN PERIOD AND ZERO\n         LA    R15,3(R15)            1 FOR EX DECR, 1 FOR . , 1 FOR 0\n         STCM  R15,15,0(R10)         SAVE THE VARIABLE NAME LENGTH\n         LA    R10,2(R14)            INCREMENT PAST STEM\n         LH    R15,HW4               LENGTH OF 4 FOR VAR DATA\n         STCM  R15,15,0(R10)         SAVE THE LENGTH\n         LA    R10,4(R10)            INCREMENT TO VAR DATA\n         ST    R10,STEM0_ADDRESS     SAVE THIS LOCATION\n         XC    0(4,R10),0(R10)       AND ZERO THE VARDATA\n         LA    R10,4(R10)            AND INCREMENT PAST IT\n         LA    R3,1                  SET FOR MEMBER.0 VARIABLE\n*************************************************************\n*   PERFORM THE GQSCAN HERE\n         L     R4,GQSTORE            GET THE SIZE IN R4\n         L     R5,GQAREA_ADDRESS     AND THE STORAGE LOCATION\n         GQSCAN AREA=((R5),(R4)),SCOPE=ALL,REQLIM=MAX,                 X\n               WAITCNT=1,XSYS=NO,RESNAME=QNAME\n*        ST    R1,RIBSLEFT\n*        DC    H'00'\n         CH    R15,HW4               WAS THERE ANY CONTENTION\n         BE    NOWAITS\n         BH    RCGT4                 EXIT WITH PROBLEM\n*\n         LR    R6,R5                 GET THIS IS IN HERE\n         USING RIB,R6\nNEWRIB   ST    R1,RIBSLEFT           SAVE THIS\n***+++++++++++++++++++ THIS IS WHERE I LEFT OFF ++++++++++++*\n*.....................................................................\n*\n*   LOOP THROUGH\n*\n*.....................................................................\nRIBLOOP EQU    *\n*              DC  H'00'\n*************************************************************\n*\n* INITIALIZE THE SHV BLOCKS AND INCREMENT THE COMPOUND VARIABLE HERE\n*\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVI   0(R14),C'.'         MOVE IN PERIOD\n         LA    R14,1(R14)           INCREMENT PAST\n         AP    COMPOUND_STEM(3),INCR_STEM(1)\n         MVC   STEM_VALUE(6),STEM_MASK  SET THE MASK\n         ED    STEM_VALUE(6),COMPOUND_STEM\n         TRT   STEM_VALUE(6),NBLNKTBL      LOOK FOR FIRST NON BLANK\n         LA    R2,STEM_VALUE+5             INCR FOR SUBTRACT\n         SLR   R2,R1               GET THE LENGTH\n         EX    R2,MOVE_STEM        MVC  0(0,R14),0(R1)\n         LA    R15,3(R2,R15)       2 FOR EX DECR, AND 1 FOR PERIOD\n         STCM  R15,15,0(R10)        SAVE THE VARIABLE NAME LENGTH\n         LA    R10,1(R2,R14)        INCREMENT PAST STEM\n***********\nMOVE_DSN EQU   *\n         TM    FLAG,X'06'             HAVE WE DONE DSN OR OWNER\n         BO    PROCESS_WAITER         YES, THEN DO WAITER\n         BM    PROCESS_OWNER          IF MIXED THEN WE HAVE DSN\n* THE NEXT 4 INSTR SET FOR OWNERS AND WAITERS\n         LA    R8,RIBEND             POINT TO START OF RIBVAR\n         AH    R8,RIBVLEN            ADD VARIABLE AREA LENGTH\n         USING RIBE,R8\n         L     R4,RIBTRIBE           GET THE COUNT IN R4\n*****************************************************************\n* THESE ARE SET FOR DSN\n         LA    R15,RIBEND             POINT TO START OF RIBVAR\n         USING RIBVAR,R15\n         MVI   4(R10),C' '        MOVE IN BLANK\n         MVC   5(47,R10),4(R10)   BLANK OUT THE WHOLE THING\n         MVC   4(4,R10),=C'DSN='  MOVE IN DSN KEYWORD\n         LH    R1,RIBVLEN         GET LENGTH OF DSN\n         BCTR  R1,0               DECR FOR EX\n         EX    R1,MOVE_RIBDSN     MVC  8(0,R10),RIBRNAME\n         B     INCR_R1LNGTH\nMOVE_RIBDSN     MVC   8(0,R10),RIBRNAME\n         DROP  R15\nINCR_R1LNGTH   EQU  *\n         LA    R1,5(R1)           LENGTH OF DSN +1 FOR EX AND +4DSN=\n         OI    FLAG,X'02'         FLAG TO SAY WE JUST DID IT\n         STCM  R1,15,0(R10)       STORE THE LENGTH\n         LA    R10,4(R1,R10)      AND INCREMENT PAST\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\n         CH    R3,COUNT_VALUE      CHECK TO SEE IF MAX HIT\n         BL    RIBLOOP             NO, THEN LOOP THRU TO NEXT ONE\n         B     FINISHED             OR QUIT IF COUNT EXCEEDED\nPROCESS_OWNER  EQU   *\n         TM    RIBESFLG,RIBESTAT   WAITING FOR RESOURCE\n         BO    MOVE_OWNER          YES, THEN PROCESS\n         OI    FLAG,X'04'          FLAG TO SAY DONE\n         B     PROCESS_WAITER\nMOVE_OWNER     EQU   *\n         MVC   4(3,R10),=C'OS='   MOVE IN OWNER AND SHARED\n         TM    RIBERFLG,RIBETYPE  IF ON THEN SHR\n         BO    MOVE_OWNER_NAME    YES, THEN CONTINUE\n         MVI   5(R10),C'E'        MOVE IN EXCLUSIVE\nMOVE_OWNER_NAME  EQU   *\n         MVC   7(8,R10),RIBEJBNM   MOVE IN THE JOB NAME\n         LA    R15,11             GET LENGTH\n         STCM  R15,15,0(R10)       STORE THE LENGTH\n         LA    R10,4(R15,R10)      AND INCREMENT PAST\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\n         CH    R3,COUNT_VALUE      CHECK TO SEE IF MAX HIT\n         BL    INCR_RIBE\n         B     FINISHED             OR QUIT IF COUNT EXCEEDED\nPROCESS_WAITER EQU   *\n         MVC   4(3,R10),=C'WS='   MOVE IN OWNER AND SHARED\n         TM    RIBERFLG,RIBETYPE  IF ON THEN SHR\n         BO    MOVE_WAITER_NAME    YES, THEN CONTINUE\n         MVI   5(R10),C'E'        MOVE IN EXCLUSIVE\nMOVE_WAITER_NAME  EQU   *\n         MVC   7(8,R10),RIBEJBNM   MOVE IN THE JOB NAME\n         LA    R15,11             GET LENGTH\n         STCM  R15,15,0(R10)       STORE THE LENGTH\n         LA    R10,4(R15,R10)      AND INCREMENT PAST\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\n         CH    R3,COUNT_VALUE      CHECK TO SEE IF MAX HIT\n         BNL   FINISHED             OR QUIT IF COUNT EXCEEDED\nINCR_RIBE LA    R8,RIBEEND\n         BCT   R4,RIBLOOP\n         XC    FLAG(1),FLAG         SET BACK TO ZERO\n         LR    R6,R8\n         L     R1,RIBSLEFT\n         BCT   R1,NEWRIB\n*        DC    H'00'\n****************************************\nFINISHED EQU   *\nCHECK_ERROR   EQU  *\n         TM   FLAG,X'01'          DID AN ERROR OCCUR ??\n         BO   SETRPLY\n****************************************\nSTOREIT  L    R14,GETMAIN_ADDRESS\n         USING ALXPARM,R14\n         MVC  ALXEXCOM_FUNCTION(8),=C'STORE   '\n         ST   R3,ALXEXCOM_VARCOUNT\n         L    R15,STEM0_ADDRESS\n         BCTR R3,0\n         CVD  R3,DOUBLE_WORD           GET IT\n         ED   STEM_MASK(6),DOUBLE_WORD+5\n         MVC  0(4,R15),STEM_MASK+2\n         LA   R1,ALXEXCOM_FUNCTION     SET THE PARM FIELD UP LIKE\n         ST   R1,PARMLIST                THIS SO THAT SUBROUTINE IS\n         LA   R1,PARMLIST                ABLE TO HANDLE PARM LIKE COBOL\n         DROP R14\n         L    R15,ALXEXCOM\n         BALR R14,R15\n****\n*\n         LA    R8,2                    SET THE DEFAULT REPLY MESSAGE\n****************************************\nSETRPLY  L     R7,EVALBLK_ADDRESS\n         L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(33),STATUS_AREA\nFREESTOR EQU   *\n         ICM   R1,15,GETMAIN_ADDRESS\n         BZ    NOT_GOTTEN\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN RC,A=(1),LV=(0)\nNOT_GOTTEN     EQU  *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_PARM       EQU   *\n         MVC   STATUS_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\n*************************\nBAD_STORAGE    EQU   *\n         MVC   STATUS_AREA(33),STORAGE_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,22\n         B     FINISHED\n******************************************************\n* THIS NEXT SECTION IS ENTERED IF THE RETURN CODE IS *\n* GT FOUR                                            *\n******************************************************\nRCGT4    EQU   *\n         MVC   STATUS_AREA(33),RCGT4_ERROR\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,25\n         B     FINISHED\n*************************\nNOWAITS  EQU   *\n         MVC   STATUS_AREA(33),NOWAITS_MSG\n         OI    FLAG,X'01'           SET FOR ERROR\n         LA    R8,25\n         B     FINISHED\n*************************\n         EJECT\nALXEXCOM DC     V(ALXEXCOM)\nFUNCTION_LENGTH DC  F'0'\nMOVEVARN        MVC   VARNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),STATUS_AREA\nMOVE_STEM       MVC   0(0,R14),0(R1)\nINITVARN        MVC   4(0,R10),VARNAME\nPACK_COUNT      PACK  DOUBLE_WORD(0),0(0,R10)\nPACK_START      EQU PACK_COUNT\nGQSTORE         DC  F'1048576'         ONE MEG\nHW4             DC  H'4'\nHW17            DC  H'17'\nHW46            DC  H'46'\nHW1000          DC  H'1000'\nHW9999          DC  H'9999'\nFFFLAG          DC  8X'FF'\nCOUNT_VALUE     DC  H'1000'\nSTART_VALUE     DC  H'1'\nVARNAME_LENGTH  DC  H'6'\nVARNAME         DC  CL22'RECORD '\nSTEM0           DC  CL2'.0'\nSTEM_VALUE      DC  CL6' '\nSTEM_MASK       DC  X'402020202120'\nCOMPOUND_STEM   DC  PL3'0'\nINCR_STEM       DC  PL1'1'\nYES             DC  CL3'YES'\nQNAME           DC  CL8'SYSDSN'\n******\n******\nBLANKS          DC  CL8' '\nSTATUS_AREA     DC  CL33'OK'\nERROR_FUNCTION  DC  CL33'ERROR IN SPECIFYING READ FUNCTION' 33\nRCGT4_ERROR     DC  CL33'ERROR PERFORMING GQSCAN  '  25\nNOWAITS_MSG     DC  CL33'RC4 NO ENQUEUE WAITS '  21\nSTORAGE_ERROR   DC  CL33'STORAGE REQUEST FAILED    '  26\n***********\n         LTORG\n         DS     0F\nNBLNKTBL DC     256X'FF'\n         ORG    NBLNKTBL+C' '\n         DC     X'00'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDOUBLE_WORD       DS  D\nEVALBLK_ADDRESS   DS  F\nGQAREA_ADDRESS    DS  F\nGETMAIN_ADDRESS   DS  F\nGETMAIN_LENGTH    DS  F\nRIBSLEFT          DS  F\nSTEM0_ADDRESS     DS  F\nFLAG              DS  X\nEYECATCH          DS  CL8\n*......................................................................\n***************************\n***************************\nSTORAGE_SIZE      EQU  *-SAVEAREA\n**\nALXPARM           DSECT\nPARMLIST          DS  F\nALXEXCOM_FUNCTION DS  CL8\nALXEXCOM_VARCOUNT DS  F\nALXEXCOM_RETCODE  DS  F\nALXEXCOM_STORAGE  EQU *\n         IRXEVALB\n*                                       CHANNEL PATH.\n**********************************\n*\n         ISGRIB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRWRTM": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x02\\x00\\x02\\x00\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 512, "newlines": 512, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE 24                                    *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL FETCH THE RECORD  *\n* VARIABLES FROM REXX AND WRITE A MEMBER TO A PDS              *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    MEMBER   = WHICH WILL CONTAIN THE MEMBER NAME TO FIND     *\n*    DDNAME   = THE DDNAME TO SEARCH                           *\n*    VARIABLE_NAME = NAME OF THE COMPOUND VARIABLE             *\n*    COUNT    = NUMBER OF RECORDS TO WRITE                     *\n*    STOW VALUE = ADD OR REP (REPLACE)                         *\n*    DIRECTORY  = IF REQUESTED, THE DIRECTORY INFO TO STORE    *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    STATUS_AREA = WHERE THIS PROGRAM WILL RETURN THE STATUS   *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRWRTM CSECT\nALXRWRTM AMODE 31\nALXRWRTM RMODE 24\n         PRINT ON,NOGEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\nFOUND_DDN      EQU  1\nREPLACE_FLAG   EQU  8\nALLDONE_FLAG   EQU  4\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRWRTM,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n         ST    R7,EVALBLK_ADDRESS\n**************************************************************\n*  THE FIRST PARAMETER IS THE NAME OF THE MEMBER TO READ     *\n**************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_PARM            NO, THEN QUIT WITH ERROR\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_PARM            IF NULL/ZERO THEN DO DEFAULT\n         CH    R3,HW8              VERIFY IT'S NOT TOO LONG\n         BH    BAD_PARM            NO, THEN CONTINUE\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         MVC   MEMBER(8),BLANKS    MOVE IN BLANKS\n         EX    R3,MOVEMMBR         MVC   MEMBER(0),0(R10)\n         XC    TTR(66),TTR         CLEAR OUT ALL DIRECTORY INFO\n**************************************************************\n*  THE SECOND PARAMETER IS THE DDNAME OF THE MEMBER TO READ  *\n**************************************************************\n         CLC   8(8,R11),FFFLAG     END OF PARM LIST\n         BE    BAD_PARM            YES, THEN NOT ENOUGH TO CONTINUE\n         ICM   R9,15,12(R11)       GET THE LENGTH OF DDNAME VALUE\n         BZ    PROCESS_VARNAME     IF 0 THEN USE DEFAULT AND GO TO NEXT\n         MVC   PDSLIB+40(8),BLANKS    BLANK OUT THE DDNAME\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVEDDN          MVC   PDSLIB+40(0),0(R10)\n**************************************************************\n*  THE THIRD PARAMETER IS THE COMPOUND VARIABLE NAME         *\n**************************************************************\nPROCESS_VARNAME EQU  *\n         CLC   16(8,R11),FFFLAG     END OF PARM LIST\n         BE    BAD_PARM            YES, THEN NOT ENOUGH TO CONTINUE\n         ICM   R9,15,20(R11)       GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_COUNT       IF 0 THEN USE DEFAULT AND GO TO NEXT\n         CH    R9,HW17             LENGTH 17 IS THE MAX\n         BH    BAD_PARM            GT JUST GET OUT\n         L     R10,16(R11)         POINT TO THE ARGUMENT\n         STH   R9,VARNAME_LENGTH   SAVE THE LENGTH\n         BCTR  R9,0                DECREMENT IT BY ONE FOR MOVE\n         EX    R9,MOVEVARN         MVC   VARNAME(0),0(R10)\n******************************************************************\n*  THE FOURTH PARAMETER IS THE NUMBER OF RECORDS TO WRITE        *\n******************************************************************\nPROCESS_COUNT   EQU  *\n         CLC   24(8,R11),FFFLAG     END OF PARM LIST\n         BE    BAD_PARM            YES, THEN NOT ENOUGH TO CONTINUE\n         ICM   R9,15,28(R11)       GET THE LENGTH OF VAR NAME\n         BZ    BAD_PARM            IF ZERO THEN GET OUT\n         L     R10,24(R11)         POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_COUNT        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE LENGTH OF REPLY IN R8\n         CH    R8,HW9999            CAN'T BE GT MAX\n         BH    BAD_PARM             YES, THEN JUST QUIT\n         LTR   R8,R8                CAN'T BE 0 OR LESS\n         BNP   BAD_PARM             YES, THEN JUST QUIT\n         STH   R8,COUNT_VALUE       SAVE THE COUNT FOR GETMAIN\n******************************************************************\n*  THE FIFTH PARAMETER IS THE STOW VALUE FOR ADDING OR REPLACING *\n* THE MEMBER.                                                    *\n******************************************************************\nPROCESS_ADDREP  EQU  *\n         CLC   32(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R9,15,36(R11)       GET THE LENGTH OF VAR NAME\n         BZ    PROCESS_DIRECTORY   IF 0 THEN WE ARE DONE\n         L     R10,32(R11)         POINT TO THE ARGUMENT\n         CH    R9,HW3              LENGTH 3 IS ALL IT CAN BE\n         BNE   BAD_PARM            GT JUST GET OUT\n         CLC   0(3,R10),ADD         SEE IF ADD\n         BE    PROCESS_DIRECTORY    YES, THEN LEAVE ALONE\n         CLC   0(3,R10),REPLACE     SEE IF REPLACE\n         BNE   BAD_PARM             NO, THEN IT IS BAD\n         OI    FLAG,REPLACE_FLAG    SET FLAG FOR STOW\n******************************************************************\n*  THE SIXTH PARAMETER WILL BE THE DIRECTORY INFORMATION TO STORE*\n* WITH THE MEMBER.                                               *\n******************************************************************\nPROCESS_DIRECTORY  EQU  *\n         CLC   40(8,R11),FFFLAG     END OF PARM LIST\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         ICM   R8,15,44(R11)       GET THE LENGTH OF VAR NAME\n         BE    USE_DEFAULTS        YES, USE REMAINING DEFAULT VALUES\n         CH    R8,HW62             CANNOT BE MORE THAN 58 BYTES\n         BH    BAD_PARM            YES, THEN GET OUT\n         L     R10,40(R11)         POINT TO THE ARGUMENT\n         LR    R15,R8              SAVE LENGTH FOR EX MOVE\n         SLR   R9,R9                CLEAR FOR SPLITTING/CHECKING R8\n         SRDL  R8,1                 SPLIT IT IN HALF FOR HW COUNT\n         LTR   R9,R9                SEE IF ODD\n         BZ    NOTODD               NO, THEN GO AROUNT\n         LA    R8,1(R8)             INCREMENT FOR ODD\nNOTODD   EQU   *\n         MVI   DIRECTORY_DATA,C' '  SET UP FIRST BLANK\n         MVC   DIRECTORY_DATA+1(57),DIRECTORY_DATA   AND BLANK IT OUT\n         BCTR  R15,0                DECREMENT FOR EX MOVE\n         EX    R15,DIRECT_MOVE      MVC DIRECTORY_DATA(0),0(R10)\n         STC   R8,HALFWORD_COUNT    AND SAVE THE HW COUNT\nUSE_DEFAULTS   EQU    *\n*********************************************************************\n* THIS SECTION WILL OPEN THE FILE, GET THE DCB ATTRIBUTES, ACQUIRE  *\n* THE REXX STORAGE, AND BUILD THE SHV BLOCKS FOR FETCH OF RECORDS   *\n*********************************************************************\nOPENLIB  EQU  *\n*        LA   R14,OPENBSM           SET THE ADDRESS FOR MODE CHANGE\n*        ICM  R14,8,=X'00'          SET HI FOR 24 BIT\n*        BSM  R0,R14                AND SET IT\nOPENBSM  EQU  *\n         OPEN (PDSLIB,(OUTPUT)),MODE=31\n         TM   PDSLIB+48,X'10'        CHECK FOR GOOD OPEN\n         BZ   BAD_OPEN               NO, THEN SEE YA\n         TM   PDSLIB+36,X'C0'        CHECK FOR RECFM U\n         BO   BAD_RECFM              YES, THEN SEE YA\n*********************************************************************\n         LH   R3,COUNT_VALUE\n         LH   R5,VARNAME_LENGTH\n         LA   R5,17(R5)              INCREMENT FOR SHV BLOCK INFO\n*           VARNAME LGNTH+VARDATA LNGTH+VARDATA ADDR+ 5 (.9999)\n         CH   R3,HW1000              SEE IF LT 1000\n         BNL  LEAVEIT\n         BCTR R5,0                   TAKE ONE AWAY FOR SMALLER GETMAIN\nLEAVEIT  MH   R5,COUNT_VALUE         GET THE TOTAL GETMAIN\n         LA   R5,20(R5)              ACCOUNT FOR HEADER INFORMATION\n         MH   R3,PDSLIB+82           MULTIPLY BY LRECL FOR MAX RECORD\nCOUNTSET LH   R0,PDSLIB+62           GET THE BLKSIZE IN HERE AS WELL\n         AR   R5,R3\n         AR   R0,R5\n         ST   R0,GETMAIN_LENGTH      SAVE THE LENGTH\n         GETMAIN RC,LV=(0)\n         LTR  R15,R15\n         BNZ   BAD_STORAGE            ISSUE MESSAGE AND GET OUT\n         ST    R1,GETMAIN_ADDRESS\n         LR    R10,R1                 SAVE FOR REXX SHV BLOCK DATA\n         LA    R8,0(R5,R10)           POINT PAST THE SHV BLOCK INFO\n         LA    R10,20(R10)            INCREMENT PASSED HEADER INFO\n         ST    R8,BLOCK_ADDRESS       SAVE THE ADDRESS\n         LH    R4,PDSLIB+82      LRECL\n         LH    R3,COUNT_VALUE         RELOAD COUNT FOR LOOP\nLOOPMOVE EQU   *\n* INITIALIZE THE SHV BLOCKS AND INCREMENT THE COMPOUND VARIABLE HERE\n*\n         LH    R15,VARNAME_LENGTH\n         BCTR  R15,0               DECR FOR EXECUTE\n         EX    R15,INITVARN        MVC  4(0,R10),VARNAME\n         LA    R14,5(R15,R10)        POINT TO LOCATION PAST NAME\n         MVI   0(R14),C'.'         MOVE IN PERIOD\n         LA    R14,1(R14)           INCREMENT PAST\n         AP    COMPOUND_STEM(3),INCR_STEM(1)\n         MVC   STEM_VALUE(6),STEM_MASK  SET THE MASK\n         ED    STEM_VALUE(6),COMPOUND_STEM\n         TRT   STEM_VALUE(6),NBLNKTBL      LOOK FOR FIRST NON BLANK\n         LA    R2,STEM_VALUE+5             INCR FOR SUBTRACT\n         SLR   R2,R1               GET THE LENGTH\n         EX    R2,MOVE_STEM        MVC  0(0,R14),0(R1)\n         LA    R15,3(R2,R15)       2 FOR EX DECR, AND 1 FOR PERIOD\n         STCM  R15,15,0(R10)        SAVE THE VARIABLE NAME LENGTH\n         LA    R10,1(R2,R14)        INCREMENT PAST STEM\nSET_RECORD     EQU  *\n         STCM  R4,15,0(R10)       MOVE IN THE VARIABLE DATA LENGTH\n         LA    R10,4(R4,R10)      GET PAST THE VARIABLE DATA\n         BCT   R3,LOOPMOVE           AND LOOP BACK THRU\n*SETTO31  LA    R14,FETCHIT\n*         ICM   R14,8,=X'80'\n*         BSM   R0,R14\n****************************************\nFETCHIT  L     R14,GETMAIN_ADDRESS\n         USING ALXPARM,R14\n         MVC   ALXEXCOM_FUNCTION(8),=C'FETCH   '\n         LH    R3,COUNT_VALUE\n         ST    R3,ALXEXCOM_VARCOUNT\n         LA    R1,ALXEXCOM_FUNCTION     SET THE PARM FIELD UP LIKE\n         ST    R1,PARMLIST                THIS SO THAT SUBROUTINE IS\n         LA    R1,PARMLIST              ABLE TO HANDLE PARM LIKE COBOL\n         LA    R10,ALXEXCOM_STORAGE     LOAD NOW FOR WRITN STORAGE\n         DROP  R14\n         L     R15,ALXEXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BZ    LOAD_COUNT              WAS SETTO24  WHS  6/16/04\n         CH    R15,HW4                 TRUNCATION ON FETCH IS OKAY\n         BNE   BAD_FETCH\n*SETTO24  LA    R14,LOAD_COUNT\n*         ICM   R14,8,=X'00'\n*         BSM   R0,R14\n****************************************\nLOAD_COUNT     EQU  *\n         LH    R11,COUNT_VALUE          GET THE LOOP COUNT\n         SLR   R7,R7                    CLEAR FOR INSERT CHARACTER\nLOOPBLOK SLR   R9,R9                    CLEAR FOR BLOCKSIZE COUNT\n         LR    R4,R8                    GET POINTER TO OUTPUT BLOCK\n         LH    R1,PDSLIB+62             GET THE BLOCK SIZE\n         TM    PDSLIB+36,X'40'          IS IT VARIABLE LENGTH BLOCK\n         BZ    CLEAR_BLOCK              NO, THEN DO NOT DECREMENT\n         SH    R1,HW4                   DECR FOR THE BDW\n         LA    R4,4(R4)                 INCREMNET PAST BDW\n         B     DONTDECR                 NO, THEN DO NOT DECREMENT\nCLEAR_BLOCK    EQU  *          BLANK OUT TO PAD FOR RECFM F\n         LR    R14,R4                  GET THE LOCATION OF BLOCK\n         LR    R15,R1                  GET THE BLKSIZE IN R15\n         SLR   R3,R3                   CLEAR FOR LENGTH\n         ICM   R3,8,BLANKS             SET FOR BLANKING\n         LR    R2,R14                  WASTE OF TIME\n         MVCL  R14,R2                  BLANK OUT THE BLOCK\nDONTDECR STH   R1,BLOCK_SIZE           SAVE THE COMPARE LENGTH\n*\nLOOPWRIT ICM   R15,15,0(R10)            GET THE LENGTH OF VARIABLE NAME\n         ST    R10,SAVE_LOCR10          SAVE FOR POSS. RELOAD AT WRITE\n         LA    R10,4(R15,R10)           AND INCREMENT TO THE VARIABLE\n         ICM   R7,3,0(R10)              GET THE ACTUAL LENGTH OF RECORD\n         BZ    BAD_FETCH                ZERO, THEN GET OUT\n*        LR    R2,R7                    SAVE THIS LENGTH FOR NOW\n         LA    R2,4(R7)                 SAVE THIS LENGTH + RDW\n         TM    PDSLIB+36,X'40'          IS IT VARIABLE LENGTH BLOCK\n         BO    ADD_BLK                  YES, THEN GO AROUND\n         LH    R2,PDSLIB+82             GET THE FB LRECL INSTEAD\nADD_BLK  LA    R15,0(R2,R9)             ADD THE TWO TOGETHER\n         CH    R15,BLOCK_SIZE           AND COMPARE TO THE BLKSIZE\n         BNL   WRITE_BLOCK              IF EQ TO OR GT THEN WRITE IT\n         AR    R9,R2                    INCREMENT THE BLOCK COUNT\n         LA    R2,4(R10)                ADDRESS THE VARIABLE DATA\n         LR    R3,R7                    AND GET THE LENGTH HERE\n         LR    R14,R4                   GET THE LOCATION POINTER\n         TM    PDSLIB+36,X'40'          IS IT VARIABLE LENGTH BLOCK\n         BZ    NO_RDW                   NO, THEN DO NOT INCREMENT\n         LA    R1,4(R7)                 INCREMENT FOR LENGTH OF RDW\n         STCM  R1,3,0(R4)               SAVE THE LENGTH IN THE RDW\n         LA    R4,0(R1,R4)              AND INCREMENT TO NEXT RECD\n         LA    R14,4(R14)               INCREMENT PAST THE RDW\n         B     CHECK_MOVE\nNO_RDW   AH    R4,PDSLIB+82             INCREMENT BY LENGTH OF LRECL\nCHECK_MOVE     EQU  *\n         CH    R7,HW256                 SEE IF TOO BIG FOR MVC\n         BNH   NOT_MVCL                 NO, THEN MOVE AS FASTER INSTR\n         LR    R15,R7                   GET THE LENGTH\n         MVCL  R14,R2                   AND MOVE THE DATA\n         B     DONEMOVE\nNOT_MVCL BCTR  R3,0                     DECR FOR EX MOVE\n         EX    R3,MOVE_RECORD           MVC  0(0,R14),0(R2)\nDONEMOVE EQU   *\n         SLR   R14,R14                  CLEAR FOR INSERT\n         ICM   R14,3,2(R10)             GET THE INITIAL LENGTH\n         LA    R10,4(R14,R10)            ** AND INCREMENT TO NEXT **\n         BCT   R11,LOOPWRIT\n         OI    FLAG,ALLDONE_FLAG       FLAG TO SAY ALL DONE\n****\nWRITE_BLOCK    EQU  *\n         SR    R4,R8                   GET THE LENGTH OF THE BLOCK\n         TM    PDSLIB+36,X'40'          IS IT VARIABLE LENGTH BLOCK\n         BZ    NO_BDW                   NO, THEN DO NOT INCREMENT\n         STCM  R4,3,0(R8)               STORE THE LENGTH IN THE BDW\nNO_BDW   EQU   *\n         LH    R5,PDSLIB+62             SAVE PERMANENT BLKSIZE\n         STH   R4,PDSLIB+62             SAVE THE BLKSIZE\n         WRITE PDSDECB,SF,PDSLIB,(8)\n         CHECK PDSDECB\n         STH   R5,PDSLIB+62             AND PUT IT BACK\n         L     R10,SAVE_LOCR10          RELOAD FOR VARIABLE NAME\n         TM    FLAG,ALLDONE_FLAG        WAS THAT THE LAST BLOCK\n         BZ    LOOPBLOK                 YES, THEN GET OUT\nSTOWIT   TM    FLAG,REPLACE_FLAG\n         BZ    ADDIT\n         STOW  PDSLIB,MEMBER,R\n         LTR   R15,R15                CHECK THE STOW\n         BNZ   BAD_STOWREP\n         B     SETREPLY\nADDIT    EQU   *\n         STOW  PDSLIB,MEMBER,A\n         LTR   R15,R15                CHECK THE STOW\n         BNZ   BAD_STOWADD\nSETREPLY LA    R8,2                    SET THE DEFAULT REPLY MESSAGE\n****\nCLOSEUP  EQU  *\n         CLOSE (PDSLIB),MODE=31\n****\n*RESET31  LA    R14,SETRPLY\n*         ICM   R14,8,=X'80'\n*         BSM   R0,R14\n*\n****************************************\nSETRPLY  L     R7,EVALBLK_ADDRESS\n         L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         MVC   EVALBLOCK_EVDATA(33),STATUS_AREA\nFREESTOR EQU   *\n         ICM   R1,15,GETMAIN_ADDRESS\n         BZ    NOT_GOTTEN\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN RC,A=(1),LV=(0)\nNOT_GOTTEN     EQU  *\n         LR    R1,R13\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_PARM       EQU   *\n         MVC   STATUS_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\nBAD_OPEN       EQU   *\n         MVC   STATUS_AREA(33),OPEN_ERROR\n         LA    R8,25\n         B     SETRPLY         WAS RESET31  WHS 6/16/04\n*************************\nBAD_STORAGE    EQU   *\n         MVC   STATUS_AREA(33),STORAGE_ERROR\n         LA    R8,22\n         B     CLOSEUP\n*************************\nBAD_RECFM      EQU   *\n         MVC   STATUS_AREA(33),RECFM_ERROR\n         LA    R8,29\n         B     CLOSEUP\n*************************\nBAD_FETCH      EQU   *\n         MVC   STATUS_AREA(33),FETCH_ERROR\n         LA    R8,30\n         B     CLOSEUP\n*************************\nBAD_STOWREP    EQU   *\n         CH    R15,HW8           SEE IF REPLACE FOR NON-EXISTENT MEM\n         BNE   BAD_STOWADD       NO, THEN JUST ISSUE BAD STOW MSG\n         MVC   STATUS_AREA(33),STOW_REPLACE\n         LA    R8,31\n         B     CLOSEUP\n*************************\nBAD_STOWADD    EQU   *\n         MVC   STATUS_AREA(33),FAILED_STOW\n         LA    R8,25\n         B     CLOSEUP\n*************************\n         EJECT\nPDSLIB   DCB    DDNAME=PDSLIB,DSORG=PO,MACRF=W,DCBE=PDSLIBE\nPDSLIBE  DCBE   RMODE31=BUFF\nALXEXCOM DC     V(ALXEXCOM)\nMOVEMMBR        MVC   MEMBER(0),0(R10)\nMOVEDDN         MVC   PDSLIB+40(0),0(R10)\nMOVEVARN        MVC   VARNAME(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),STATUS_AREA\nMOVE_STEM       MVC   0(0,R14),0(R1)\nDIRECT_MOVE     MVC   DIRECTORY_DATA(0),0(R10)\nINITVARN        MVC   4(0,R10),VARNAME\nMOVE_VARDATA    MVC   4(0,R10),0(R5)\nMOVE_RECORD     MVC   0(0,R14),0(R2)\nPACK_COUNT      PACK  DOUBLE_WORD(0),0(0,R10)\nPACK_START      EQU PACK_COUNT\nHW3             DC  H'3'\nHW4             DC  H'4'\nHW8             DC  H'8'\nHW17            DC  H'17'\nHW33            DC  H'33'\nHW62            DC  H'62'\nHW256           DC  H'256'\nHW1000          DC  H'1000'\nHW9999          DC  H'9999'\nFFFLAG          DC  8X'FF'\nCOUNT_VALUE     DC  H'00'\nSTART_VALUE     DC  H'1'\nVARNAME_LENGTH  DC  H'6'\nVARNAME         DC  CL22'RECORD '\nSTEM0           DC  CL2'.0'\nSTEM_VALUE      DC  CL6' '\nSTEM_MASK       DC  X'402020202120'\nCOMPOUND_STEM   DC  PL3'0'\nINCR_STEM       DC  PL1'1'\nADD             DC  CL3'ADD'\nREPLACE         DC  CL3'REP'\n******\n******\nBLANKS          DC  CL8' '\nSTATUS_AREA     DC  CL33'OK'\nERROR_FUNCTION  DC  CL33'ERROR IN SPECIFYING THE  FUNCTION' 33\nOPEN_ERROR      DC  CL33'ERROR OPENING PDS DATASET '  25\nSTORAGE_ERROR   DC  CL33'STORAGE REQUEST FAILED    '  22\nRECFM_ERROR     DC  CL33'RECORD FORMAT U NOT SUPPORTED ' 29\nFETCH_ERROR     DC  CL33'ERROR WITH REXX FETCH SERVICES ' 30\nSTOW_REPLACE    DC  CL33'REPLACE SPECIFIED, MEMBER ADDED ' 31\nFAILED_STOW     DC  CL33'FAILURE IN STORING MEMBER ' 25\nFLAG            DC  X'00'\n***********\n         LTORG\n         DS     0F\nNBLNKTBL DC     256X'FF'\n         ORG    NBLNKTBL+C' '\n         DC     X'00'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS  18F\nDOUBLE_WORD       DS  D\nEVALBLK_ADDRESS   DS  F\nGETMAIN_ADDRESS   DS  F\nGETMAIN_LENGTH    DS  F\nSTEM0_ADDRESS     DS  F\nBLOCK_ADDRESS     DS  F\nRECORD_COUNT      DS  F\nBLOCK_COUNT       DS  F\nSAVE_LOCR10       DS  F\nMEMBER            DS  CL8\nTTR               DS  3X\nHALFWORD_COUNT    DS  X\nDIRECTORY_DATA    DS  CL62\nBLOCK_SIZE        DS  H\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n***************************\nALXPARM           DSECT\nPARMLIST          DS  F\nALXEXCOM_FUNCTION DS  CL8\nALXEXCOM_VARCOUNT DS  F\nALXEXCOM_RETCODE  DS  F\nALXEXCOM_STORAGE  EQU *\n**\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRWTO": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x9d\\x00\\x9d\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 157, "newlines": 157, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE ANY                                   *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL ISSUE A WTO       *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    WTO  - WHICH WILL CONTAIN THE WTO  MESSAGE TO ISSUE       *\n*    DESCRIPTOR   = WHETHER IT IS A ROLL OR NO-ROLL            *\n*                   OR A NO-ROLL-RED (DESC 11)                 *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    REPLY_AREA = WE WILL PUT AN OK                            *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n****************************************************************\nALXRWTO  CSECT\nALXRWTO  AMODE 31\nALXRWTO  RMODE ANY\n         PRINT ON,GEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRWTO,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n******************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_WTO             NO, THEN DO DEFAULT\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_WTO             IF NULL/ZERO THEN JUST QUIT\n         CH    R3,HW126            VERIFY IT'S NOT TOO LONG\n         BNH   SAVELGTH            NO, THEN CONTINUE\n         LH    R3,HW126            YES, THEN LOAD UP TO 122 BYTES\nSAVELGTH STH   R3,WTO_AREA_LENGTH SAVE THE LENGTH OF WTO\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         EX    R3,MOVEWTO          MVC   WTO_AREA(0),0(R10)\n         LA    R4,WTO_AREA_LENGTH ADDRESS FOR TEXT OF MESSAGE\n******************************************************************\n         CLC   8(8,R11),FFFLAG     ARE WE AT THE END\n         BE    ISSUE_WTO           YES, THEN JUST LET IT ROLL\n         ICM   R9,15,12(R11)       GET THE LENGTH OF DESCRIPTOR\n         BZ    ISSUE_WTO           ZERO, THEN JUST LET IT ROLL\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n* WE'RE GOING TO COMPARE THE 1ST 6 CHARACTERS FOR NOROLL\n         CLC   0(6,R10),NOROLL_KW  IS THIS A NO-ROLL MESSAGE\n         BNE   ISSUE_WTO           NO, THEN JUST LET IT ROLL\n* NOW COMPARE 9 CHARACTERS TO SEE IF RED (DESC 11)\n         CLC   0(9,R10),NOROLL_KW  IS THIS A NO-ROLL MESSAGE\n         BNE   ISSUE_DESC2         NO, THEN JUST MAKE IT WHITE (2)\n         WTO   TEXT=((4)),DESC=11\n         B     SETOKAY\nISSUE_DESC2    EQU    *\n         WTO   TEXT=((4)),DESC=2\n         B     SETOKAY\nISSUE_WTO      EQU    *\n         WTO   TEXT=((4))\nSETOKAY  EQU   *\n         MVC   REPLY_AREA(2),GOOD_WTO\n         LA    R8,2\n****************************************\nSETREPLY L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         BCTR  R8,0\n         EX    R8,MOVERPLY\nFREESTOR EQU   *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBAD_WTO        EQU   *\n         MVC   REPLY_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETREPLY\n         EJECT\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),REPLY_AREA\nMOVEWTO         MVC   WTO_AREA(0),0(R10)\nHW126           DC    H'126'\nFFFLAG   DC    8X'FF'\nERROR_FUNCTION  DC    CL33'ERROR IN SPECIFYING WTO FUNCTION'\nNOROLL_KW       DC    CL9'NOROLLRED'\nROLL_KW         EQU   NOROLL_KW+2\nGOOD_WTO        DC    CL2'OK'\n         LTORG\nSTORAGE  DSECT\nSAVEAREA          DS   18F\nREPLY_AREA        DS   CL33\nWTO_AREA_LENGTH   DS   H\nWTO_AREA          DS   CL126\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALXRWTOR": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xf0\\x00\\xf0\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 240, "newlines": 240, "modlines": 0, "user": "WHS"}, "text": "****************************************************************\n* AUTHOR - BILL SWEENEY                                        *\n*     SSC, INC.                                                *\n*     WHSWEENEY@SSCMAINFRAME.COM                               *\n*     WWW.SSCMAINFRAME.COM                                     *\n* DATE - (C) COPYRIGHT 2004                                    *\n*                                                              *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL     *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR    *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.      *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS        *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.         *\n*                                                              *\n* LINKAGE INFORMATION - AMODE 31                               *\n*                  RMODE ANY                                   *\n*                  NON-REENTRANT                               *\n*                  NOT APF AUTHORIZED                          *\n*                                                              *\n* DESCRIPTION -                                                *\n*  THIS PROGRAM IS A REXX FUNCTION THAT WILL ISSUE A WTOR AND  *\n* PASS THE REPLY BACK.                                         *\n*                                                              *\n*   THE VARIABLES THAT WILL BE PASSED THROUGH REGISTER 1 ARE:  *\n*    WTOR - WHICH WILL CONTAIN THE WTOR MESSAGE TO ISSUE       *\n*    REPLY_LENGTH = THE LENGTH OF THE WTOR REPLY               *\n*    TIMER = WHETHER OR NOT TO WAKE UP AND CHECK               *\n*    TIMER_REPLY = WHAT TO PLACE AS REPLY IF TIMER EXHAUSTED   *\n*                                                              *\n*                                                              *\n*   THE VARIABLE VALUE THAT WILL BE RETURNED IS:               *\n*    REPLY_AREA = WHERE THIS PROGRAM WILL STORE THE OPERATOR   *\n*                 REPLY                                        *\n*                                                              *\n*    REGISTERS:                                                *\n*    R1 - FIVE  WORD PARAMETER LIST OF REXX VARIABLES          *\n*         WORD1 - RESERVED                                     *\n*         WORD2 - RESERVED                                     *\n*         WORD3 - RESERVED                                     *\n*         WORD4 - ADDRESS OF ARGUMENTS PASSED BY REXX          *\n*         WORD5 - ADDRESS OF THE EVALUATION BLOCK WHERE WE     *\n*                 WILL RETURN THE REPLY                        *\n*                                                              *\n*                                                              *\n****************************************************************\nALXRWTOR CSECT\nALXRWTOR AMODE 31\nALXRWTOR RMODE ANY\n         PRINT ON,GEN,NODATA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nNO_STORAGE     EQU  20\n         STM   R14,R12,12(R13)\n         LR    R7,R1               SAVE THE PARAMETER ADDRESS\n         LR    R12,R15             SET UP BASE REGISTER ADDRESS.\n         USING ALXRWTOR,R12\n         GETMAIN RC,LV=STORAGE_SIZE\n         LTR   R15,R15\n         BZ    GOOD_STORAGE\n         LA    R15,NO_STORAGE\n         B     RETURN2\nGOOD_STORAGE   EQU  *\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STORAGE,R13\n******************************************************************\n         L     R11,16(R7)          LET'S GET OUR ARGUMENT\n         CLC   0(8,R11),FFFLAG     IS THERE ANY ARGUMENT\n         BE    BAD_WTOR            NO, THEN DO DEFAULT\n         ICM   R3,15,4(R11)        GET THE LENGTH OF ARGUMENT\n         BZ    BAD_WTOR            IF NULL/ZERO THEN DO DEFAULT\n         CH    R3,HW122            VERIFY IT'S NOT TOO LONG\n         BNH   SAVELGTH            NO, THEN CONTINUE\n         LH    R3,HW122            YES, THEN LOAD UP TO 122 BYTES\nSAVELGTH STH   R3,WTOR_AREA_LENGTH SAVE THE LENGTH OF WTOR\n         BCTR  R3,0                DECREMENT FOR EXECUTE MOVE\n         L     R10,0(R11)          AND ADDRESS THE ARGUMENT\n         EX    R3,MOVEWTOR         MVC   WTOR_AREA(0),0(R10)\n         LA    R4,WTOR_AREA_LENGTH ADDRESS FOR TEXT OF MESSAGE\n******************************************************************\n         LH    R8,HW80              SET THE DEFAULT\n         CLC   8(8,R11),FFFLAG     HAVE THEY SPECIFIED A REPLY LENGTH\n         BE    ISSUE_WTOR          NO, THEN JUST SET TO 80 BYTES\n         ICM   R9,15,12(R11)       GET THE LENGTH OF REPLY_LENGTH VALUE\n         BZ    CHECK_STIMER        GO CHECK FOR STIMER\n         L     R10,8(R11)          POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         LA    R8,7                 DOUBLE_WORD LENGTH - 1 FOR EX\n         SLL   R9,28                GET IT IN THE HI-ORDER BYTE\n         SLDL  R8,4                 AND SHIFT IT TOGETHER W/ OTHER LENG\n         EX    R8,PACK_FIELD        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R8,DOUBLE_WORD       GET THE LENGTH OF REPLY IN R8\n         CH    R8,HW119             CAN'T BE GT MAX\n         BNH   CHECK_STIMER         GO AND ISSUE THE WTOR\n         LH    R8,HW119             SET THE MAX\n*        B     ISSUE_WTOR           GO AND ISSUE THE WTOR\nCHECK_STIMER   EQU  *\n         CLC   16(8,R11),FFFLAG    HAVE THEY SPECIFIED A STIMER\n         BE    ISSUE_WTOR          NO, THEN JUST SET TO 80 BYTES\n         ICM   R9,15,20(R11)       GET THE LENGTH OF STIMER VALUE\n         BZ    TIMER_REPLY         USE DEFAULT AND CHECK STIMER\n         L     R10,16(R11)         POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,TRTTIME           VERIFY IT IS NUMERIC\n         BNZ   BAD_WTOR             NO, THEN QUIT\n         A     R9,FW112             THIS WILL ADD X'70' FOR L1 OF PACK\n         EX    R9,PACK_FIELD        PACK  DOUBLE_WORD(0),0(0,R10)\n         CVB   R15,DOUBLE_WORD      GET THE LENGTH OF REPLY IN R8\n         MH    R15,HW100            MULTIPLY FOR BINARY TIME\n         ST    R15,BINARY           GO AND ISSUE THE WTOR\nTIMER_REPLY    EQU   *\n         CLC   24(8,R11),FFFLAG    HAVE THEY SPECIFIED A STIMER REPLY\n         BE    BAD_WTOR            NO, THEN SHOULD NOT GET HERE\n         ICM   R9,15,28(R11)       GET THE LENGTH OF STIMER REPLY\n         BZ    BAD_WTOR            NO, THEN SHOULD NOT BE HERE\n         OI    FLAG,X'01'          SET STIMER REPLY FLAG\n         L     R10,24(R11)         POINT TO THE ARGUMENT\n         BCTR  R9,0                 DECREMENT IT BY ONE\n         EX    R9,MOVESTMR          MVC  STIMER_REPLY(0),0(R10)\n         STH   R9,STIMER_REPLY_LNG  SAVE THE LENGTH\n*\nISSUE_WTOR     EQU    *\n         TM    FLAG,X'01'              DID WE AX FOR A STIMER\n         BZ    NO_STIMER\n         STIMER REAL,TIMEEXIT,BINTVL=BINARY\nNO_STIMER      EQU  *\n         LA    R2,REPLY_AREA\n         MVI   0(R2),C' '\n         MVC   1(118,R2),0(R2)         BLANK OUT THE WHOLE REPLY AREA\n         LA    R3,ECBADDR\n         WTOR  TEXT=((4),(2),(8),(3))\n         ST    R1,WTORDOM\n         WAIT  ECB=(3)\n         TM    FLAG,X'02'\n         BZ    SETRPLY\n         LH    R8,STIMER_REPLY_LNG\n         EX    R8,MOVE_STIMER\n         LA    R8,1(R8)\n****************************************\nSETRPLY  L     R10,20(R7)\n         L     R10,0(R10)\n         USING EVALBLOCK,R10\n         ST    R8,EVALBLOCK_EVLEN\n         LA    R14,16(R8)\n         SRDL  R14,32\n         LA    R3,8                   DIVISOR BY DOUBLE WORDS\n         DR    R14,R3                 DIVIDE IT\n         LTR   R14,R14\n         BZ    NO_INCREMENT\n         LA    R15,1(R15)\nNO_INCREMENT   EQU *\n         ST    R15,EVALBLOCK_EVSIZE\n         BCTR  R8,0\n         EX    R8,MOVERPLY\n         LA    R8,1(R8)\nFREESTOR EQU   *\n         LR    R1,R13\n         L     R13,4(R13)             SO WE CAN GET OUT OF HERE\n         FREEMAIN RC,A=(1),LV=STORAGE_SIZE\nRETURN1  SLR   R15,R15\nRETURN2  L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nTIMEEXIT EQU   *\n* I FIGURE THIS IS WHERE IT RETURNS FROM EXIT ROUTINE\n         PUSH  USING                * SAVE USING STATUS\n         DROP  ,                    * DROP ADDRESSABILITY\n         STM   R14,R12,12(R13)      SAVE THE REGISTERS\n         LR    R12,R15              GET ADDRESSABILITY\n         USING TIMEEXIT,R12\n         LA    R14,TIMERSAV              * LOAD UP ADDR\n         ST    R13,4(,R14)               * SAVE THE SAVEAREA PTR\n         ST    R14,8(,R13)               * CHAIN THE SAVEAREAS\n         LR    R13,R14                   * USE OURS\n         OI    FLAG,X'02'\n         L     R15,WTORDOM\n         DOM   MSG=(15)\n         POST  ECBADDR\n         L     R13,4(,R13)               * GET THE SAVEAREA BACK\n         LM    R14,R12,12(R13)           * GET THE REGISTERS BACK\n         BR    R14\n         POP   USING\nTIMERSAV DS    18F\nBAD_WTOR       EQU   *\n         MVC   REPLY_AREA(33),ERROR_FUNCTION\n         LA    R8,33\n         B     SETRPLY\n         EJECT\nECBADDR         DC    F'0'\nBINARY          DC    F'600'         DEFAULT 10 MINUTES\nFW112           DC    F'112'\nWTORDOM         DC    F'0'\nMOVEWTOR        MVC   WTOR_AREA(0),0(R10)\nMOVERPLY        MVC   EVALBLOCK_EVDATA(0),REPLY_AREA\nMOVESTMR        MVC   STIMER_REPLY(0),0(R10)\nMOVE_STIMER     MVC   REPLY_AREA(0),STIMER_REPLY\nPACK_FIELD      PACK  DOUBLE_WORD(0),0(0,R10)\nTRTTIME  TRT   0(0,R10),NUMTABL\nHW4             DC    H'4'\nHW10            DC    H'10'\nHW12            DC    H'12'\nHW80            DC    H'80'\nHW100           DC    H'100'\nHW119           DC    H'119'\nHW122           DC    H'122'\nFFFLAG   DC    8X'FF'\nFLAG            DC    X'0'\nERROR_FUNCTION  DC    CL33'ERROR IN SPECIFYING WTOR FUNCTION'\n         LTORG\nNUMTABL  DC    256X'FF'\n         ORG   NUMTABL+C'0'\n         DC    XL10'00'\n         ORG\nSTORAGE  DSECT\nSAVEAREA          DS   18F\nDOUBLE_WORD       DS   D\nECB_ADDRESS       DS   F\nREPLY_AREA        DS   CL119\nSTIMER_REPLY_LNG  DS   H\nSTIMER_REPLY      DS   CL119\nWTOR_AREA_LENGTH  DS   H'0'\nWTOR_AREA         DS   CL122\n**\nSTORAGE_SIZE      EQU  *-SAVEAREA\n         IRXEVALB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMLAOPS": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 30, "newlines": 30, "modlines": 0, "user": "WHS"}, "text": "//SSCWHSA JOB (ACCT),'WTO EXIT',MSGCLASS=X,CLASS=X,\n//      NOTIFY=&SYSUID,COND=(0,NE)\n//ASM1    EXEC ASMACL,PARM.C=(RENT,NODECK,OBJECT),\n//         PARM.L=(LIST,LET,NCAL,MAP,RENT)\n//C.SYSLIB   DD\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSPUNCH   DD  DUMMY,DCB=BLKSIZE=80\n//* REMEMBER TO COPY THE LATEST SOURCE CODE ENTRY FROM\n//* DATA SET YOUR SOURCE LIBRARY\n//C.SYSIN      DD  DSN=YOUR.SRCELIB(MSGTABLE),DISP=SHR\n//L.SYSLMOD    DD  DSN=YOUR.LINKLIST.LOADLIB,DISP=SHR\n//L.SYSIN    DD  *\n NAME MSGTABLE(R)\n/*\n//ASM2    EXEC ASMACL,PARM.C=(RENT,NODECK,OBJECT),\n//         PARM.L=(LIST,LET,NCAL,MAP,RENT,'AC(1)')\n//C.SYSLIB   DD\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSPUNCH   DD  DUMMY,DCB=BLKSIZE=80\n//* REMEMBER TO COPY THE LATEST SOURCE CODE ENTRY FROM\n//* DATA SET YOUR SOURCE LIBRARY\n//C.SYSIN      DD  DSN=YOUR.SRCELIB(IEAVMXIT),DISP=SHR\n//L.SYSLMOD    DD  DSN=YOUR.LINKLIST.LOADLIB,DISP=SHR\n//L.SYSIN    DD  *\n INCLUDE SYSLMOD(MSGTABLE)\n ORDER WTOEXIT\n ENTRY WTOEXIT\n NAME IEAVMXIT(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMLTABL": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00 \\x00 \\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 32, "newlines": 32, "modlines": 0, "user": "WHS"}, "text": "//SSCWHSAL JOB (ACCT),'WTO EXIT',MSGCLASS=X,CLASS=X,\n//      NOTIFY=&SYSUID,COND=(4,LT)\n//*IEAVMXIT JOB (ACCT),'WTO EXIT',CLASS=Q,MSGCLASS=Q,NOTIFY=&SYSUID,\n//*  COND=(4,LT)\n//ASM     EXEC ASMACL,PARM.C=(RENT,NODECK,OBJECT),\n//         PARM.L=(LIST,LET,NCAL,MAP,RENT,'AC(1)')\n//C.SYSLIB   DD\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=YOUR.MACLIB,DISP=SHR\n//C.SYSPUNCH   DD  DUMMY,DCB=BLKSIZE=80\n//C.SYSIN      DD  DSN=YOUR.SOURCE(MSGTABLE),DISP=SHR\n//L.SYSLMOD    DD  DSN=YOUR.LINKLIST.LOADLIB,DISP=SHR\n//L.SYSIN    DD  *\n NAME MSGTABLE(R)\n INCLUDE SYSLMOD(MSGTABLE)\n INCLUDE SYSLMOD(IEAVMXIT)\n REPLACE MSGTABLE\n ORDER WTOEXIT\n ENTRY WTOEXIT\n NAME IEAVMXIT(R)\n/*\n//STEP3        EXEC PGM=ALEXCMDS,COND=(4,LT)\n//* FOR THE UPDATE=01 CREATE A CSVLLA01 ENTRY IN PARMLIB\n//* SPECIFYING YOUR.LINKLIST.LOADLIB\n//* THIS WILL REFRESH THE LINKLIST AND THEN REFRESH IEAVMXIT\n//CMDIN        DD   *\n F LLA,UPDATE=01\n#WAIT=3\n CONTROL M,UEXIT=N\n#WAIT=3\n CONTROL M,UEXIT=Y\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMLVMXT": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x10\\x00\\x10\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 16, "newlines": 16, "modlines": 0, "user": "WHS"}, "text": "//SSCWHSAX JOB (ACCT),'WTO EXIT',MSGCLASS=X,CLASS=X,\n//      NOTIFY=&SYSUID,COND=(0,NE)\n//ASM     EXEC ASMACL,PARM.C=(RENT,NODECK,OBJECT),\n//         PARM.L=(LIST,LET,NCAL,MAP,RENT,'AC(1)')\n//C.SYSLIB   DD\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSPUNCH   DD  DUMMY,DCB=BLKSIZE=80\n//C.SYSIN      DD  DSN=YOUR.SOURCE(IEAVMXIT),DISP=SHR\n//L.SYSLMOD    DD  DSN=YOUR.LINKLIST.LOADLIB,DISP=SHR\n//L.SYSIN    DD  *\n INCLUDE SYSLMOD(MSGTABLE)\n ORDER WTOEXIT\n ENTRY WTOEXIT\n NAME IEAVMXIT(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CATCLEAN": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x07\\x9b\\x07\\x9b\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 1947, "newlines": 1947, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'CATCLEAN - ICF CATALOG AND DASD CLEANUP PROGRAM'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 24                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  *** APF AUTHORIZED ***                           *\n*                                                                   *\n*  The best reason for the way this program was written this way    *\n*  is that my boss let me do it. It was an excellent learning       *\n*  experience and he was a great boss. Thanks Rocky.                *\n*                                                                   *\n*  Description - This program is included only as an example of     *\n*                the following system functions, to include:        *\n*                access an ICF Catalog as a VSAM KSDS, perform      *\n*                Catalog functions using SVC 26, and reading DASD   *\n*                VTOCs using EXCP (up to 3380 DASD).                *\n*                Program was written in late 1980s on MVS/SP        *\n*                *** If anyone is interested in actually getting  ***\n*                *** this to work on OS/390 I do still have the   ***\n*                *** binary search routines and I will assist with***\n*                *** the EXCP for 3390 device architecture.       ***\n*                *** Better off using Catalog Search Interface    ***\n*                                                                   *\n*********************************************************************\n******************************************************************\n*  HELLO KIDS. THIS IS A LENGTHY AND VERY BORING DESCRIPTION OF  *\n* WHAT THIS VERY SIMPLE PROGRAM DOES. THE BASIC THEME IS FINDING *\n* DATASETS THAT ARE CATALOGED, BUT DO NOT EXIST ON THE VOLUME    *\n* SPECIFIED. AN ADDED ATTRACTION IS LISTING OF DATASETS THAT ARE *\n* ON THE VOLUMES, BUT ARE NOT CATALOGED. THIRD, ALIAS ENTRIES    *\n* FOR OTHER NONVSAM DATASETS ARE VERIFIED. FOR HIGH LEVEL INDEXES*\n* IN THE MASTER CATALOG, WE WILL COMPARE THEM TO OUR USERLIST    *\n* DATASET, AND IF NOT THERE ARE DELETED.                         *\n*  LET'S DISCUSS METHOD NOW. BINARY SEARCH ROUTINES WILL BE USED *\n* TO CREATE TABLES FOR THE USERLIST, NONVSAM CATALOG RECORDS,    *\n* ALIAS CATALOG RECORDS FOR OTHER NONVSAM RECORDS, AND INDIVIDUAL*\n* VTOC TABLES. SYNCHRONIZED COMPARISON WILL BE DONE WITH THE LAST*\n* VTOC AND NONVSAM TABLES, AND WHEN APPROPRIATE, CATALOG ENTRIES *\n* WILL BE UNCATALOGED. INPUT TO TABLES WILL BE GOTTEN BY READING *\n* THE MASTER CATALOG, AND ALL THE USER CATALOGS WITH ALIAS       *\n* POINTERS. ***** STEPCAT ******* MUST BE USED FOR EVERY CATALOG *\n* WE HAVE ON THE SYSTEM OR ELSE OPEN PROCESSING WILL FAIL.       *\n* DD STATEMENTS ARE NOT REQUIRED BECAUSE CATALOGS WILL BE        *\n* DYNAMICALLY ALLOCATED WHEN THEY ARE NEEDED. WHEN READING THE   *\n* CATALOGS, ENTRIES THAT PASS CHECKING WILL BE STORED IN THE     *\n* APPROPRIATE BINARY SEARCH TABLE. WHEN ALL THE CATALOGS HAVE    *\n* BEEN READ WE WILL READ ALL THE VTOCS THAT ARE REFERENCED USING *\n* EXCP.                                                          *\n*  DO BE AWARE PLEASE THAT ALL DYNAMIC ALLOCATIONS OCCUR WITH    *\n* FREE=CLOSE, SO DO NOT ATTEMPT TO REOPEN A FILE WITHOUT RE-     *\n* ALLOCATING.                                                    *\n******************************************************************\nCATCLEAN CSECT\n         PRINT ON,NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         B     72(R15)             BRANCH AROUND SAVE AREA\n         DS    17F                 SAVE AREA\n         STM   R14,R12,12(R13)     SAVE REGS\n         ST    R13,4(R15)          CHAIN SAVE AREAS\n         ST    R15,8(R13)          BACK CHAIN SAVE AREAS\n         LR    R13,R15             LOAD BASE\n         LA    R12,2048(R13)       LOAD SECOND BASE\n         LA    R12,2048(R12)       GET 1 PAGE PAST FIRST\n         USING CATCLEAN,R13,R12\n         SPACE 1\n         L     R4,0(R1)            GET ADDR OF PARMS\n         ST    R4,PARMADDR         SAVE THE ADDRESS FOR EASY AVAILABL.\n         LH    R3,0(R4)            GET LENGTH OF PARMS\n         LTR   R3,R3               SEE IF ANY PARMS AVAILABLE\n         BZ    PARMDONE            NO, THEN WE WILL NOT UNCATALOG\n         L     R10,ADOPARMS        ADDR TO PROCESS PARM SECTION\n         BALR  R14,R10             GO PROCESS\n         SPACE 2\nPARMDONE OPEN  (SYSPRIN1,(OUTPUT),SYSPRIN2,(OUTPUT))\nOPENOKU  TM    SYSPRIN1+48,X'10'    ANOTHER GOOD OPEN\n         BO    OPENOKS              WE SURE HOPE SO BOYS AND GIRLS\n         ABEND 001,DUMP\nOPENOKS  TM    SYSPRIN2+48,X'10'      HOW ABOUT THIS ONE\n         BO    READUSER             HOORAY FOR OUR SIDE\n         ABEND 001,DUMP\nREADUSER L     R10,ADOUSERL\n         BALR  R14,R10\n         EJECT\n******************************************************************\n*  IN THIS LITTLE SECTION WE'RE ACCESSING THE CVT FOR THE SYSRES *\n*  VOLSER, THE ADDRESS OF THE JSCB FOR AUTHORIZATION SETTING FOR *\n*  READING AN ICF CATALOG, AND LASTLY THE NAME OF THE MASTER CAT *\n*  IN THE CAXWA CHAIN. THE MODESET IS TO SET THE AUTHORIZATION   *\n*  BIT IN THE JSCB, BECAUSE WITHOUT YOU CANNOT READ A CATALOG AS *\n*  A VSAM DATASET.                                               *\n******************************************************************\nSETJSCB  EQU   *\n         L     R11,16                  ADDR OF CVT\n         UNPK  TEMPDSN+3(5),57(3,R11)  GET DATE FOR TEMPORARY DSNS\n         OI    TEMPDSN+7,X'F0'         FOR A DSN OF SYSYYDDD\n         L     R10,48(R11)             ADDR OF SYSRES UCB\n         MVC   SYSRES(6),28(R10)       MOVE IN SYSRES VOLSER\n         L     R10,0(R11)              ADDR OF TCB\n         L     R10,4(R10)              ADDR OF ACTIVE TCB\n         L     R10,180(R10)             ADDR OF JSCB\n         MODESET KEY=ZERO,MODE=SUP\n         OI    243(R10),X'80'        SECURITY BIT FOR READING ICFS\n         MODESET KEY=NZERO,MODE=PROB\n         L     R11,256(R11)            AMCB IN CVT\n         L     R11,20(R11)             CAXWA CHAIN\nLOOPCAX  TM    8(R11),X'04'            IS IT THE MASTER CATALOG\n         BO    GOTMSTRC                YES, THEN CONTINUE\n         L     R11,4(R11)              GET NEXT CAT ADDRESS\n         LTR   R11,R11                 END OF TABLE\n         BNZ   LOOPCAX                 CHECK NEXT\n         ABEND 004,DUMP\nGOTMSTRC MVC   CATDSN(44),52(R11)      MOVE IN MSTR CAT NAME SVC 99\n         MVC   MSTRCAT(44),52(R11)     MOVE IN MSTR CAT TO SAVE\n         EJECT\n*******************************************************************\n*  THIS GETMAIN IS FOR 53 DSCBS PER TRK ON A 3380 AT A LENGTH OF  *\n*  140 BYTES APIECE, FOR 40 USERCATALOG ENTRIES AT 45 BYTES, AND  *\n*  A 10240 BYTE BUFFERSPACE FOR READING ICF CATALOGS.             *\n*******************************************************************\n         GETMAIN EU,LV=19460,A=STRADDR1\n         L     R11,STRADDR1        LOAD R11 WITH GETMAINED STORGE ADDR\n         L     R1,=F'7420'         LENGTH OF 53 DSCBS\n         LA    R10,0(R1,R11)       INCREMENT PAST THAT STORAGE\n         ST    R10,UCATADDR        POINTER FOR UCAT STORAGE AREA\n         ST    R10,UCATPNTR        POINTER FOR UCAT THAT WON'T CHANGE\n         LA    R1,1800             LENGTH OF 40 USERCATS\n         LA    R10,0(R1,R10)       INCREMENT PAST THAT STORAGE\n         ST    R10,RECADDR         POINTER FOR VSAM BUFFER STORAGE\n         ST    R10,GETRPL+32       CHANGE ADDRESS IN RPL MACRO AS WELL\n*******************************************************************\n*  INITIALIZE THE CCWS WITH THE STORAGE LOCATIONS FROM THE        *\n*  BEGINNING OF GETMAINED STORAGE                                 *\n*******************************************************************\n         LA    R10,READCCW         POINT TO BEGIN OF CCWS TO INITIAL.\n         LA    R8,8                SIZE OF CCW\n         LA    R9,ENDCCWS          END OF READ CCWS\nLOOPINIT STCM  R11,7,1(R10)        STORE THE VIRTUAL ADDRESS\n         LA    R11,140(R11)        INCR BY DSCB SIZE\n         BXLE  R10,R8,LOOPINIT     LOOP THRU INITIALIZATION\n         LA    R1,CATENT           (50,0,51)\n         L     R15,VOPENSCH        OPEN FOR LIST OF NVSAM CAT RECS\n         BALR  R14,R15             GO AND OPEN IT\n         LTR  R1,R1                ADDR ENTRY POINT RETURNED\n         BNZ   GOODCOP             YES, THEN KEEP ON TRUCKIN\n         ABEND 005,DUMP\n**********************************************************************\n* OPEN THE BINARY SEARCH TABLES FOR NONVSAM AND ALIAS (BOTH HIGH     *\n* LEVEL ALIASES AND ALIASES FOR OTHER NONVSAM DATASETS) CATALOG      *\n* RECORDS.                                                           *\n**********************************************************************\nGOODCOP  ST    R1,CATRECD          (0,VTVOLSER)  FOR BINARY LOCATE\n         ST    R1,CATFIND          (0,1)         FOR BINARY FIND\n         LA    R1,ALIASENT         (89,0,44)\n         L     R15,VOPENSCH        OPEN FOR LIST OF ALIAS CAT RECS\n         BALR  R14,R15             GO AND OPEN IT\n         LTR  R1,R1                ADDR ENTRY POINT RETURNED\n         BNZ   GOODCOP2            YES, THEN KEEP ON TRUCKIN\n         ABEND 006,DUMP\nGOODCOP2 ST    R1,ALIASREC         (0,ALISDSNS)  FOR BINARY INSERT\n         ST    R1,ALISFIND         (0,1)         FOR BINARY FIND\n         LA    R1,HILENT           (9,0,8)\n         L     R15,VOPENSCH        OPEN FOR LIST OF HI LEVEL INDEXES\n         BALR  R14,R15             GO AND OPEN IT\n         LTR  R1,R1                ADDR ENTRY POINT RETURNED\n         BNZ   GOODCOP3            YES, THEN KEEP ON TRUCKIN\n         ABEND 006,DUMP\nGOODCOP3 ST    R1,HILRECD          (0,HILEVEL)  FOR BINARY INSERT\n         LA    R1,NVSENT           (53,0,44)\n         L     R15,VOPENSCH       OPEN FOR LIST OF NVSAM DSNS FOR DUPS\n         BALR  R14,R15             GO AND OPEN IT\n         LTR  R1,R1                ADDR ENTRY POINT RETURNED\n         BNZ   GOODCOP4            YES, THEN KEEP ON TRUCKIN\n         ABEND 006,DUMP\nGOODCOP4 ST    R1,NVSRECD          (0,NONVSAM)  FOR BINARY INSERT\n***********************************************************\n* HERE IS WHERE WE DYNAMICALLY ALLOCATE THE CATALOGS      *\n***********************************************************\nALLOCMST EQU   *\n        USING  S99RB,R11\n         LA    R11,S99AREA         SET UP SVC 99 PARM AREA BASE REG\n         MVI   S99VERB,S99VRBAL    INDICATE ALLOCATION TO BE PERFORMED\n         LA    R1,CATUPTR          ADDR OF ALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP         STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM          LOAD ADDRESS OF SVC 99 PARM AREA\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         DROP  R11\n         LTR   R15,R15             GOOD ALLOCATION ?\n         BZ    OPENACB             YES, THEN GO OPEN THAT THAR CATLG\n         ABEND 007,DUMP\nOPENACB  EQU   *\n         AP    TOTCAT1(3),PACK1(1)\n* I AM RESETTING THESE ACB FIELDS TO WHAT THEY ARE BEFORE ANY OPENS\n* BECAUSE I WILL BE REUSING THEM\n         MVI   GETACB+48,X'02'         RESET OPEN FLAG\n         XC    GETACB+49(23),GETACB+49  ZERO OUT THESE FIELDS\n         OPEN  GETACB                   OPEN THE CATALOG\nCHKOPEN  LTR   R15,R15              SEE IF VALID OPEN\n         BZ    GETLOOP               GO AND READ SOME RECORDS\n         MVC   CATOPERR+73(40),CATDSN\n         WTO   MF=(E,CATOPERR)\n         ABEND 008,DUMP\n         EJECT\n*******************************************************************\n*  WE WILL LOOP THROUGH READING EVERY RECORD FROM EVERY CATALOG   *\n*  WITH A VALID POINTER, SAVING THE ALIAS RECORDS AND NONVSAM     *\n*  DATASETS EXCLUDING THOSE BEGINNING WITH # AND FDRABR.          *\n*******************************************************************\nGETLOOP  EQU   *\n         XC    CATFLAG1(2),CATFLAG1 RESET FLAGS TO ZERO\n         XC    NVSCATA1(4),NVSCATA1    BLANK OUT THIS ADDRESS\n         GET   RPL=GETRPL               READ A CATALOG RECORD\n         LTR   R15,R15                  GOOD READ ?\n         BZ    NOTHIS                   THEN PROCESS THE LITTLE THING\n         SHOWCB RPL=GETRPL,AREA=FEEDBCK,LENGTH=4,FIELDS=FDBK\n         L     R2,FEEDBCK               PUT IT R2 FOR EASIER DUMP READ\n         ABEND 009,DUMP\nNOTHIS   L     R7,RECADDR               GET RECORD ADDRESS\n         CLI   4(R7),C'X'               IS THIS AN ALIAS RECORD\n         BNE   TRYNVSM                  NO, THEN CHECK FOR NVSAM\n         CLI   7(R7),C'U'               ALIAS TO A CATLG\n         BNE   ADDFORAL                 NO, THEN ALIAS TO A DSN ?\n         TM    FLAG,X'80'               I WANT ONLY FROM MASTER CAT\n         BO    CHECK#                   NO, THEN DON'T COUNT IT\n         AP    TOTHIL1(3),PACK1(1)      ADD 1 FOR TOTAL\n         B     CHECK#\nADDFORAL AP    TOTALIS1(3),PACK1(1)     ADD 1 FOR TOTAL\nCHECK#   CLI   9(R7),C'#'               WILL NOT PROCESS THIS\n         BE    GETLOOP                  YES, THEN READ NEXT RECORD\n         CLC   9(6,R7),=C'FDRABR'       ANOTHER VALID ALIAS\n         BE    GETLOOP                  YES, THEN NO CHECKING\n         CLI   7(R7),C'U'               IS THIS AN ALIAS TO A CATLG\n         BE    CHKMSTR                  YES, THEN CHECK FOR MASTER\n         CLI   7(R7),C'A'               ALIAS FOR A NONVSAM RECORD ?\n         BNE   GETLOOP                  YES, THEN GOOD RECORD\n         MVC   ALISDSNS(44),9(R7)       MOVE IN THE ALIAS NAME\n         MVI   ALISDSN2,C' '            MOVE IN A BLANK\n         MVC   ALISDSN2+1(43),ALISDSN2  BLANK IT OUT\n         SLR   R6,R6\n         IC    R6,60(R7)\n         SH    R6,HW02\n         LTR   R6,R6\n         BNM   NAMEAL2\n         ABEND 011,DUMP\nNAMEAL2  EX    R6,MVEADSN2\n         MVC   CATFLAG3(1),CATLGNUM+1      MOVE IN RELATIVE CAT NUMBER\n         LA    R1,ALIASREC              STORE THE ALIAS RECORD\n         L     R15,VINSRCH              VCON OF INSERT\n         BALR  R14,R15                  GO DO IT\n         LTR   R15,R15                  GOOD INSERT ?\n         BZ    GETLOOP                  YES, THEN KEEP GOING\n         OI    89(R1),X'80'             TURN ON HI-ORDER TO SAY DUP\n         MVC   DUPADSN(44),9(R7)            MOVE IN DUPLICATE NAME\n         MVC   DUPACAT1(44),CATDSN\n         LA    R1,DUPAREC               PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GETLOOP\nCHKMSTR  TM    FLAG,X'80'               ARE WE DOING THE MASTER CAT\n         BZ    GOODALIS                 YES, THEN IT IS OKAY\n         MVC   BADOWCAT(44),CATDSN      MOVE IN CATALOG NAME\n         MVC   HILEVELM(8),9(R7)         MOVE IN ALIAS\n         MVI   BADHICAT,C' '            CLEAR FIRST BYTE\n         MVC   BADHICAT+1(43),BADHICAT  BLANK OUT FIELD BEFORE MOVE\n         SLR   R4,R4                    CLEAR FOR INSERT\n         IC    R4,60(R7)                GET LENGTH OF USERCATALOG\n         SH    R4,HW02                  DECREMENT 2 FOR EXECUTE\n         EX    R4,MVEHICAT              MVC BADHICAT(0),61(R7)\n         LA    R1,BADALIAS              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GETLOOP\nGOODALIS CLC   9(3,R7),TEMPDSN         'SYS' WILL NOT BE IN USERLIST\n         BE    GOODUSER                 SO JUST CONTINUE\n         LA    R4,9(R7)                 POINT TO HI LEVEL INDEX\n         TRT   0(9,R4),PERTBLE          LOOK FOR FIRST BLANK\n         SR    R1,R4                    SUBTRACT FOR LENGTH\n         LR    R4,R1                    CALL ME FICKLE FOR THIS ONE\n         CH    R4,HW05                  MAKE SURE IT IS A USERID\n         BL    GOODUSER                 NO, THEN GO AROUND\n         CLI   9(R7),C'U'               PREFIXED WITH U\n         BE    SHORTID                  YES, THEN SHORTEN IT\n         CLI   9(R7),C'P'               OR PREFIXED WITH P\n         BE    SHORTID                  YES, THEN THE SAME THING\n         CLI   9(R7),C'F'               LAST BUT NOT LEAST F\n         BNE   MOVEAID                  IF NONE THEN STORE IT\nSHORTID  CH    R4,HW06                  LETS MAKE SURE IT'S A USERID\n         BNE   GOODUSER                 IF NOT 6 BYTES THEN NO\n         MVC   USERID(5),10(R7)         MOVE LAST 5 OF USERID\n         B     FINDUSER                 AND BRANCH AROUND\nMOVEAID  CH    R4,HW05                  LETS MAKE SURE IT'S A USERID\n         BNE   GOODUSER                 IF NOT 5 BYTES THEN NO\n         MVC   USERID(5),9(R7)          STORE USERID\nFINDUSER LA    R1,USERRECD              (0,USERID) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE USERID\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BZ    GOODUSER                 YES, THEN GET CAT NAME\n*******************************************************************\n*  HERE WE WILL LOAD UP AN ICF PARAMETER LIST REQUEST FOR SVC 26  *\n*  TO DELETE ALIAS ENTRIES THAT NO LONGER EXIST IN THE USERLIST   *\n*******************************************************************\n         OI    FLAG2,X'02'          FLAG SO NOT ADDED TO HILEVEL TBLE\n         MVC   DELADSN(8),9(R7)         MOVE IN THE HI LEVEL QUAL\n         SLR   R6,R6                    CLEAR FOR INSERT\n         IC    R6,60(R7)                GET LENGTH OF REL USERCAT\n         SH    R6,HW02                  DECREMENT 2 FOR MOVE\n******** MOVE TO PRINTLINE THE NAME OF USER CATALOG IT RELATES TO\n         EX    R6,MVEDELAL              MVC DELAREL(0),61(R7)\n         TM    FLAG2,X'10'              IS THIS A TEST RUN\n         BZ    PRTDELAL                 YES, THEN DON'T DELETE\n         MVC   ALISDSNS(8),9(R7)     MOVE ALIAS INTO 44 BYTE FIELD\n         LA    R15,ALISDSNS             GET ADDRESS FOR CAT PARM LIST\n         ST    R15,CTGENT               SAVE IT FOR SVC 26\n         MVI   CTGTYPE,C'X'             TELL HIM ALIAS RECORD TYPE\n         LA    R1,CTGPL                 LOAD UP ADDR OF CAT PARM LST\n         SVC   26                       ISSUE THE BAD BOY\n         LTR   R15,R15                  VERIFY THAT REQUEST WORKED\n         BZ    GOODALDL                 YES, THEN KEEP ON\n         CVD   R15,DOUBLE\n         UNPK  ERRCODED(3),DOUBLE+6(2)\n         OI    ERRCODED+2,X'F0'\n         MVC   ERRDDSN(5),USERID    STORE THE NAME FOR ERROR\n         OI    FLAG,X'40'               FLAG TO SAY PRINT TWICE\n         CLI   RTCODE+3,X'08'\n         BH    NORCDELA\n         MVI   RTCODE+3,X'08'           SET OVERALL RCC TO 8\nNORCDELA LA    R1,ERRDELAL              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GOODUSER\nGOODALDL AP    TOTHIL2(3),PACK1(1)      MAINTAIN CNTR OF DELETES ALSO\nPRTDELAL LA    R1,DELALDSN\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         SPACE 2\nGOODUSER SLR   R6,R6                    CLEAR FOR INSERT\n         IC    R6,60(R7)                LENGTH OF USERCAT\n         L     R3,UCATADDR              BEGINNING OF TABLE ENTRY\n         SLR   R4,R4                    CLEAR FOR INSERT\n         SLR   R5,R5                    CLEAR FOR INSERT\n         LA    R8,45                    INCREMENT VALUE OF CAT+LEN\n         LA    R9,1755(R3)               END OF TABLE\nLOOPUCAT LA    R5,1(R5)                 GET LOCATION PNTR\n         ICM   R4,1,0(R3)               GET LENGTH\n         BZ    MOVEUCAT                 IF ZERO END OF TABLE\n         CR    R4,R6                    ARE LENGTHS EQUAL\n         BNE   INCRUCAT                 NO, THEN CATS ARE NOT EQUAL\n         BCTR  R4,0                     DECREMENT FOR COMPARE\n         EX    R4,COMPUCAT                 CLC  0(0,R3),60(R7)\n         BE    STORHIL                  IF EQUAL THEN STORE HI LEVEL\nINCRUCAT BXLE  R3,R8,LOOPUCAT           LOOP THRU TABLE\n         ABEND 011,DUMP\nMOVEUCAT BCTR  R6,0                     DECR FOR EXECUTE INSTR\n         EX    R6,MVEUCAT                  MVC  0(0,R3),60(R7)\n         STH   R5,CATLGNUM               SAVE LOCATION POINTER OF CAT\n         ST    R3,ENDUCAT               SAVE ENDING ADDRESS FOR LATER\nSTORHIL  TM    FLAG2,X'02'              WAS THIS HILEVEL DELETED ?\n         BZ    STHILCT5\n         NI    FLAG2,X'FD'\n         B     GETLOOP                  READ NEXT REACORD\nSTHILCT5 STC   R5,HILCAT                MOVE IN RELATIVE CATALOG NMBER\n         MVC   HILEVEL(8),9(R7)         MOVE IN HI LEVEL QUALIFIER\n         LA    R1,HILRECD               STORE THE ALIAS RECORD\n         L     R15,VINSRCH              VCON OF INSERT\n         BALR  R14,R15                  GO DO IT\n         B     GETLOOP                  READ NEXT REACORD\n         SPACE 3\n*******************************************************************\n*  HERE IS WHERE COME TO PROCESS NONVSAM RECORDS AND OR MAINTAIN  *\n*  A COUNTER OF ALL OTHER TYPES OF CATALOG RECORDS. TOTALS ARE    *\n*  PRINTED AT END OF PGM.                                         *\n*******************************************************************\nTRYNVSM  CLI   4(R7),C'A'               IS IT A NONVSAM RECORD\n         BE    DONVSAM                  YES, THEN GO AROUND TOTALS\n         CLI   4(R7),C'B'               IS IT A GDG BASE\n         BNE   TRYCLSTR\n         AP    TOTGDG1(3),PACK1(1)     ADD 1 TO TOTAL\n         B     GETLOOP\nTRYCLSTR CLI   4(R7),C'C'               IS IT A CLUSTER\n         BNE   TRYCATLG\n         AP    TOTVSM1(3),PACK1(1)     ADD 1 TO TOTAL\n         B     GETLOOP\nTRYCATLG CLI   4(R7),C'U'               IS IT A USER CATALOG\n         BNE   GETLOOP\n         AP    TOTUCAT1(3),PACK1(1)     ADD 1 TO TOTAL\n         B     GETLOOP\nDONVSAM  AP    TOTNVS1(3),PACK1(1)     ADD 1 FOR TOTALS\n         CLI   9(R7),C'#'               WILL NOT PROCESS THIS\n         BE    GETLOOP                  YES, THEN READ NEXT RECORD\n         CLC   9(6,R7),=C'FDRABR'       ANOTHER VALID DSNAME\n         BE    GETLOOP                  YES, THEN NO CHECKING\n         TM    FLAG,X'80'              IS THIS THE MASTER CAT\n         BO    SETVLR4                  NO, THEN CONTINUE ONWARD\n         XC    HILCAT(1),HILCAT         CLEAR TO SAY MSTR CAT PNTR\n         MVC   HILEVEL(8),BLANKS     BLANK IT OUT\n         LA    R4,9(R7)              POINT TO DSNAME\n         TRT   0(9,R4),PERTBLE       LOOK FOR PERIOD\n         SLR   R1,R4                 GET LENGTH OF HI LEVEL\n         BCTR  R1,0                  DECREMENT FOR EXECUTE\n         EX    R1,MOVEHIL            MVC HILEVEL(0),0(R4)\n         LA    R1,HILRECD              LOAD UP THE QUALIFIER ADDRESS\n         L     R15,VINSRCH              VCON OF INSERT\n         BALR  R14,R15                  GO DO IT\n         SPACE 2\n*******************************************************************\n*  HERE IS ANOTHER LITTLE SECTION THAT CAN BE CONSIDERED A LITTLE *\n* CONFUSING. THIS DEALS WITH THE RECORD LAYOUT OF A NONVSAM ICF   *\n* CATALOG RECORD. IT IS VARIABLE LENGTH, AND WE ARE INTERESTED IN *\n* THE VOLUME NUMBER AFTER WE'VE GOTTEN THE DSNAME (WHICH IS IN A  *\n* FIXED LOCATION). BOTTOM LINE, IT SEEMS TO WORK SO BEAR WITH THE *\n* LOOP.                                                           *\n*******************************************************************\nSETVLR4  LA    R4,72(R7)                 POINT TO END OF SECTION\n         LA    R6,74(R7)                POINT TO DESCRIPTOR\n         LH    R5,0(R7)                 OVERALL LENGTH OF RECORD\n         LA    R5,0(R5,R7)              POINT TO END OF RECORD\n         SLR   R3,R3                    CLEAR FOR INSERT\nLOOPVARN CLI   0(R6),X'04'              IS FIRST SECTION VOLUME LIST\n         BE    DOVOLUME                 IF HERE THEN GOOD, SO STORE\nINCRNVSM ICM   R3,3,0(R4)              GET NEXT LENGTH FIELD\n         BNZ   VARLNGOK                 SHOULD NEVER BE A ZERO LENGTH\n         ABEND 012,DUMP\nVARLNGOK LA    R4,0(R3,R4)              POINT TO END OF IT\n         LA    R6,2(R4)                  SAVE POINTER FOR COMPARE\n         CR    R4,R5                     ARE WE AT THE END OF THE REC\n         BL    LOOPVARN                  NO, THEN CHECK AGAIN\n         ABEND 013,DUMP           SHOULDN'T BE HERE, BUT ...\nDOVOLUME CLC   2(6,R6),ASTRKWD          IS IT ON THE SYSRES VOL\n         BNE   NOTASTER                    NO, THEN CONTINUE\n         OI    CATFLAG1,X'01'        SET FLAG TO SAY WAS ASTERISKS\n         MVC   VTVOLSER(6),SYSRES       MOVE IN NAME BECAUSE OF SORT\n         B     MOVVTDSN                    GO MOVE IN THE DSN\nNOTASTER CLI   10(R6),X'20'            SEE IF DASD FOR FLAG\n         BE    REGVOLM                  YES, THEN GO AROUND\n         CLI   10(R6),X'80'            SEE IF TAPE\n         BNE   GETLOOP                  NO, THEN GET NEXT\n         TM    FLAG,X'80'               IF IN THE MASTERCAT NO CHECK\n         BZ    GETLOOP                  YES, THEN NO FURTHER CHECK\n******************************************************************\n*  HERE IS WHERE WE WILL UNCATALOG TAPE DSNS THAT NO LONGER HAVE *\n* A VALID POINTER FROM THE MASTER CATALOG.                       *\n******************************************************************\n         MVC   HILEVEL(8),BLANKS     BLANK IT OUT\n         LA    R4,9(R7)              POINT TO DSNAME\n         TRT   0(9,R4),PERTBLE       LOOK FOR PERIOD\n         SLR   R1,R4                 SUBTRACT FOR LENGTH OF QUALIFIER\n         BCTR  R1,0                  DECREMENT FOR MOVE\n         EX    R1,MOVEHIL            MVC HILEVEL(0),0(R4)\n         LA    R1,HILRECD               (0,HILEVEL) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE HI LEVEL QUALIFIER\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BZ    GETLOOP                  YES, THEN GOOD POINTER\n         MVC   NOPNTDSN(44),0(R4)       MOVE IN DSNAME\n         MVC   NOPNTCAT(44),CATDSN      MOVE IN NAME OF CATALOG\n         LA    R1,NOTPNTED              POINT TO OUTPUT RECORD\n         L     R15,ADOOUT1              AND SUBROUTINE TO PRINT\n         BALR  R14,R15                  GO PRINT IT YAHOO\n         MVC   UCATDSN(44),0(R4)        MOVE IN NAME OF DATASET\n         MVC   UCATVSN(6),2(R6)        MOVE IN NAME OF DATASET\n         TM    FLAG2,X'10'              IS THIS A TEST RUN\n         BZ    PRTDELNV                 YES, THEN DON'T DELETE\n         MVC   VTDSNAME(44),9(R7)        MOVE IN THE DSNAME\n         LA    R15,VTDSNAME              SAVE FOR CAT PARM LIST\n         ST    R15,CTGENT                SAVE THE ADDR\n         MVI   CTGTYPE,C'A'              TELL HIM NVSAM CAT RECORD\n         LA    R1,CTGPL                  POINT TO CAT PARM LIST\n         SVC   26                        ISSUE SVC FOR DELETE\n         LTR   R15,R15                   GOOD UPDATE\n         BZ    GOODSVCD\n         CVD   R15,DOUBLE\n         UNPK  ERRCODE(3),DOUBLE+6(2)\n         OI    ERRCODE+2,X'F0'\n         MVC   ERRUDSN(44),0(R4)     STORE THE NAME FOR ERROR\n         OI    FLAG,X'40'               FLAG TO SAY PRINT TWICE\n         CLI   RTCODE+3,X'08'\n         BH    NORCDELN\n         MVI   RTCODE+3,X'08'           SET OVERALL RCC TO 8\nNORCDELN LA    R1,ERRUNCAT              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GETLOOP\nGOODSVCD AP    TOTNVS2(3),PACK1(1)   KEEP COUNT OF THOSE UNCATLGED\nPRTDELNV LA    R1,UNCATDSN              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GETLOOP\nREGVOLM  MVC   VTVOLSER(6),2(R6)           MOVE IN VOLSER FROM RECORD\nMOVVTDSN MVC   VTDSNAME(44),9(R7)        MOVE IN THE DSNAME\n         TM    FLAG,X'80'                  IS THIS THE MASTER CATALOG\n         BZ    NOCATFG2                    YES, THEN LEAVE AT 0\n         MVC   CATFLAG2(1),CATLGNUM+1      MOVE IN RELATIVE CAT NUMBER\nNOCATFG2 LA    R1,CATRECD                  GET ADDRESS OF THE RECORD\n         L     R15,VINSRCH                 ADDR OF INSERT ROUTINE\n         BALR  R14,R15                     GO PUT AWAY\nINSNVSM  MVC   NONVSAM(44),9(R7)\n         MVC   NVSCATA1(4),UCATADDR        MOVE IN CURRENT CAT ADDRESS\n         CLI   7(R7),X'01'                 CATALOGED TO MULTIVOLUMES ?\n         BNH   ADDRINSM                    NOT GT 1 NO FLAG\n         OI    NVSFLAG1,X'80'              FLAG RECORD AS MULTIVOLUME\nADDRINSM LA    R1,NVSRECD                  GET ADDRESS OF THE RECORD\n         L     R15,VINSRCH                 ADDR OF INSERT ROUTINE\n         BALR  R14,R15                     GO PUT AWAY\n         NI    NVSFLAG1,X'7F'              RESET FLAG IF SET\n         LTR   R15,R15                     GOOD INSERT WE HOPE\n         BZ    GETLOOP                     YES, THEN READ NEXT\n         MVC   48(4,R1),UCATADDR           MOVE IN CURRENT CAT ADDRESS\n         OI    52(R1),X'01'                FLAG TO SAY DUPLICATE\n         B     GETLOOP\nCLOSEACB EQU   *\n         CLOSE GETACB                   CLOSE CATALOG\n         LTR   R15,R15                     GOT TO HAVE A GOOD CLOSE\n         BZ    GOODCLOS                    YES, THEN CONTINUE\n         ABEND 015,DUMP\n         SPACE 1\nGOODCLOS TM    FLAG,X'80'                  IS THIS THE MASTER CATLG\n         BO    NOTMSTR                    ON, THEN ALREADY DONE\nNOSYSIN  XC    CATLGNUM(2),CATLGNUM       RESET CATLG NUMBER\n         OI    FLAG,X'80'               SET FLAG FOR MSTR CAT DONE\n         L     R3,UCATADDR                POINT TO USERCAT TABLE\n         ICM   R1,15,ENDUCAT          WE HAD TO STORE AT LEAST 1 UCAT\n         BNZ   GOTVALUE                    NO ZEROES, RIGHT ?\n         ABEND 016,DUMP\nNOTMSTR  L     R3,UCATADDR                RELOAD BEGINNING NOT MSTR\n         L     R1,ENDUCAT                 AND GET THE ENDING ADDRESS\nGOTVALUE CR    R3,R1                      ARE WE AT THE END\n         BH    CATDONE                    YES, THEN WE'RE DONE HERE\n         LA    R4,45(R3)                  NO, THEN POINT TO NEXT CAT\n         ST    R4,UCATADDR                SAVE ADDR FOR LATER\n         SLR   R4,R4                      CLEAR R4 FOR INSERT CHAR\n         IC    R4,0(R3)                   GET LENGTH OF CAT + 1\n         SH    R4,HW02                    DECREMENT 2 FOR EXECUTE\n         MVI   CATDSN,C' '                LET'S BLANK OUT FIELD\n         MVC   CATDSN+1(43),CATDSN        ENTIRELY\n         EX    R4,MVECATAL                MVC  CATDSN(0),1(R3)\n         LH    R4,CATLGNUM                GET CATALOG LOCATION\n         LA    R4,1(R4)                   INCREMENT LOCATION\n         STH   R4,CATLGNUM                AND SAVE THE NUMBER\n         B     ALLOCMST                   GO AND ALLOCATE IT\nCATDONE  EQU   *\n         LA    R1,CATFIND          MAINTAIN POINTER FOR BINARY FIND\n         L     R15,VFNDSRCH               GO FIND FIRST RECORD\n         BALR  R14,R15                    IN CATALOG RECORD TABLE\n         LTR   R15,R15                    DID WE FIND IT\n         BZ    GOTCRECD           YES, THEN ONWARD CHRISTIAN SOLDIERS\n         ABEND 017,DUMP\n         SPACE 1\nGOTCRECD ST    R1,FINDADDR          SAVE THIS ADDRESS FOR LATER\n         LR    R10,R1               STORE IF FOR LATER\n         MVC   ALVOLSER(6),0(R1)    MOVE IN FOR FIRST VTOC ALLOCATE\n*******************************************************************\n*  HERE WE ARE INTERESTED IN SEARCHING THE UCB'S AND BUILDING A   *\n* BINARY SEARCH TABLE OF ALL ACTIVE DASD VOLSERS. WE WILL USE THE *\n* UCB LOOKUP TABLE TO REFERENCE ALL UCB'S ( YOU'RE SAYING WHAT    *\n* ELSE WOULD THIS MORON USE , RIGHT ? ).                          *\n*******************************************************************\nDOUCBLKP LA    R1,UCBENT            (6,0,6)\n         L     R15,VOPENSCH         ADDRESS OF OPEN SEARCH\n         BALR  R14,R15              GO DO IT\n         LTR   R1,R1                GOOD OPEN\n         BNZ   GOODUCOP             YES, AN ADDRESS THERE\n         ABEND 018,DUMP\nGOODUCOP ST    R1,UCBRECD           SAVE AT  (0,VTVOLSER)\n         L     R7,16                  CVT ADDRESS\n         L     R7,40(R7)              UCB LOOKUP ADDRESS\n         SLR   R8,R8                  CLEAR R8 FOR INSERT\n         USING UCBOB,R8\nLOOPUCB  ICM   R8,3,0(R7)             GET UCB ADDRESS\n         BZ    INCRUCB                IF 0 GO TO NEXT ENTRY\n         TM    UCBTBYT3,X'20'         IS THIS A DASD DEVICE\n         BZ    INCRUCB                NO, THEN GO TO NEXT ENTRY\n         TM    UCBSTAT,X'80'          IS THIS DEVICE ONLINE\n         BZ    INCRUCB                NO, THEN GO TO NEXT ENTRY\n         CLI   UCBVOLI,X'00'          IS A VOLSER ADDRESS PRESENT\n         BE    INCRUCB                NO, THEN GO TO NEXT ENTRY\n         MVC   VTVOLSER(6),UCBVOLI    MOVE IN THE VOLSER\n         LA    R1,UCBRECD             LOAD POINTER INTO R1\n         L     R15,VINSRCH            GET INSERT ADDR IN R15\n         BALR  R14,R15                GO INSERT INTO TABLE\n******************************************************************\n*  WE ADDED OPTCHAN WITH NEW HARDWARE CONFIG. WHICH ADDED NEW    *\n*  CHANNELS. SO WE DO NOT CARE IF INSERT RETURNS A DUPLICATE     *\n*  SO IT WAS COMMENTED OUT.                                      *\n******************************************************************\n*        LTR   R15,R15                GOOD INSERT, NO DUPS, ETC...\n*        BZ    INCRUCB                YES, THEN GET NEXT\n*        ABEND 019,DUMP\nINCRUCB  LA    R7,2(R7)               INCREMENT TO NEXT ENTRY\n         CLC   0(2,R7),=X'FFFF'       IS IT THE END OF TABLE\n         BNE   LOOPUCB                NO, THEN VERIFY NEXT ENTRY\n         DROP  R8\n         SPACE 2\nALLOCVTC NI    FLAG,X'C0'         RESET FLAG FOR SUBSEQUENT LOOPS\n         MVC   VTVOLSER(6),ALVOLSER     STORE THE VOLSER\n         LA    R1,UCBRECD              (0,VTVOLSER) LOC VOLSER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE USERID\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BZ    GOODVSN                  YES, THEN ALLOCATE VOLUME\n         OI    FLAG,X'10'           FLAG TO SAY NOT FOUND AND EOFVTOC\n         B     UNCATLG                  AND GO UNCATLG VOLUMES\n***********************************************************\n* HERE IS WHERE WE DYNAMICALLY ALLOCATE THE VTOC          *\n***********************************************************\nGOODVSN  EQU   *\n         USING S99RB,R5\n         LA    R5,S99AREA         SET UP SVC 99 PARM AREA BASE REG\n         MVI   S99VERB,S99VRBAL    INDICATE ALLOCATION TO BE PERFORMED\n         LA    R1,VTTUPTR          ADDR OF ALLOCATION TEXT UNIT PTRS\n         ST    R1,S99TXTPP         STORE IN SVC 99 REQUEST BLOCK\n         LA    R1,S99PARM          LOAD ADDRESS OF SVC 99 PARM AREA\n         SPACE 1\n         DYNALLOC                  PERFORM DYNAMIC ALLOCATION\n         DROP  R5\n         LTR   R15,R15             DID WE GET WHAT WE WANTED\n         BZ    OPENFILE         YES, THEN DON'T STAND HERE, GO TO IT\n         ABEND 020,DUMP            OH, SO SORRY COMRADE\n*******************************************************************\n*  NEXT WE ARE INTERESTED IN OPENING THE VTOC OF ANY VOLUME BY    *\n*  MOVING THE VTOC NAME INTO THE JFCBAREA, AND USING THAT DURING  *\n*  OPEN PROCESSING.                                               *\n*******************************************************************\nOPENFILE EQU   *\n         AP    TOTVOL1(3),PACK1(1)\n         RDJFCB MF=(E,OPENLIST)\n         MVI   JFCBAREA,X'04'           MOVE VTOC NAME INTO JFCB\n         MVC   JFCBAREA+1(43),JFCBAREA  REPLICATE FOR ALL 04'S\n         OI    JFCBAREA+52,X'08'        SET FLAG TO SAY NO REWRITE\n         MVI   VTOCDCB+48,X'02'         RESET OPEN FLAG\n         OPEN  TYPE=J,MF=(E,OPENLIST)\n         TM    VTOCDCB+48,X'10'         DID WE OPEN IT ?\n         BO    OPENOK                   YES, HURRAY\n         ABEND 021,DUMP\nOPENOK   EQU   *\n         L     R5,VTOCDCB+44      ADDR. OF DEB  DCBDEBA-1\n         L     R10,32(R5)         ADDR. OF UCB\n         LA    R7,5                SUPPORT 5 DEVICES\n         LA    R8,DEV3380                START WITH 3380'S IN TABLE\nLOOPDEV  CLC   0(1,R8),19(R10)        COMPARE DEVTYPES\n         BE    GOTUDEV                IF EQUAL, WE FOUND OUR GAL\n         LA    R8,5(R8)               NOT EQ THEN GO TO NEXT ENTRY\n         BCT   R7,LOOPDEV                LOOP THRU TABLE\n         ABEND 022,DUMP                  UNSUPPORTED DEVICE\nGOTUDEV  MVC   CURRTRKS(4),1(R8)   MOVE IN NUMBER OF TRKS AND DSCBS\n         MVC   VOLDEVT(4),16(R10)  MOVE IN THE DEVICE TYPE FOR SCRATCH\n         MVC   VOLVSN(6),28(R10)   AND THE VOLSER IF THERE IS A SCR\n         LA    R7,IOB              POINT TO THE I/O BLOCK\n         USING IOBSTDRD,R7\n         LA    R5,32(R5)          DEBDASD    PTR TO DASD SECTION\n         USING DEBDASD,R5\n         CLI   CURRTRKS+1,X'0F'      IS IT A 3380 ?\n         BE    SETSEEK            YES, THEN WE ARE SET TO READ\n*********************************************************************\n* THIS NEXT GAME RESETS THE SET SECTOR CCW AND BREAKS THE CCW CHAIN *\n* TO THE LENGTH OF DSCBS PER TRACK FOR WHATEVER THE DEVICE IS. THE  *\n* LOCATION IS SAVED AND RELOADED AT COMPLETION OR IF A SHORT TRACK  *\n* IS READ. THE BIG REASON FOR ALL THIS SHIFTING AND SAVING OF       *\n* POINTERS FOR THE SET SECTOR IS SO THAT WE CAN PROCESS MULTIPLE    *\n* VOLUMES WITH DIFFERENT DEVICE TYPES OR WE NEED TO READ A SHORT    *\n* TRACK.                                                            *\n*********************************************************************\n         LA    R1,READCCW          POINT TO BEGIN OF CHAIN\n         LH    R15,CURRTRKS+2      GET DSCBS/TRK\n         SLA   R15,3              MULITPLY BY 8 P/ CCW\n         LA    R15,0(R1,R15)      POINT TO SET SECTOR RECORD\n         ST    R15,CCWSVAD        SAVE THE ADDRESS OF THE CCW\n         MVC   CCWSAVE(8),0(R15)  AND SAVE THE CCW\n         MVC   0(8,R15),SETSECT   MOVE IN SET SECTOR FOR END CCW CHAIN\nSETSEEK  MVC   IOBCC(2),DEBSTRCC  SET CYLINDER NUMBER IN IOB\n         MVC   IOBHH(2),DEBSTRHH  SET TRACK NUMBER IN IOB\n         DROP  R5\nLOCSET   MVI   SECTOR,X'01'         SET INITIAL SECTOR TO 1\n         MVI   IOBR,X'01'           AND THE SAME FOR RECORD NUMBER\n         EXCP  IOB                  HERE IT IS - HI/HO HI/HO\n         WAIT  ECB=ECB              TRY NOT TO BE IMPATIENT\nREADLOOP CLI   ECB,ECBNORM          WAS IT A GOOD READ\n         BE    GOODREAD             IT WAS SO LETS GO DO MORE KIDDIES\nCKMORE   CLI   ECB,ECBPERR          PERMANENT ERROR SET FOR EOF\n         BNE   CHKEOE               NO, THEN WE'LL VERIFY END OF EXTENT\n**********************************************************************\n*** FOR ALL INTENTS AND PURPOSES I DON'T THINK THERE REALLY IS AN END\n*** OF FILE FOR A VTOC. IF WE WERE TO CALCULATE INCORRECTLY AND READ\n*** PAST THE HIGH FORMAT 1 DSCB WE WOULD HIT THE END OF EXTENT.\n***   IT SHOULD BE IN ONE CONTIGUOUS EXTENT SO I WILL NOT PROCESS\n*** MULTIPLE EXTENT VTOCS\n**********************************************************************\n         TM    IOBUSTAT,IOBUSB7   WAS IT AN END OF FILE\n         BNO   ERRCODE1           NO, THEN TREAT AS PERM ERROR\n         OI    FLAG,X'02'         SET FLAG TO SAY EOF\n         B     GOODREAD           CONSIDER IT A GOOD READ\nERRCODE1 ABEND 023,DUMP\nCHKEOE   CLI   ECB,ECBDAEA       WAS IT END OF EXTENT\n         BE    DONEVTOC          YES, THEN WE'RE DONE FOR NOW\n         ABEND 024,DUMP\nGOODREAD LH    R9,CURRTRKS+2            GET # DSCBS TO LOOP/TRK\n         LH    R8,DSCBLEFT              GET # DSCBS LEFT TO PROCESS\n         L     R11,STRADDR1             LOAD UP R11 WITH BEGIN OF READ\n         TM    FLAG,X'01'               HAVE WE PROCESSED FORMAT 4\n         BO    READF4                   YES, THEN CONTINUE ON\n         OI    FLAG,X'01'               NO, THEN SET FLAG\n         LA    R1,VTOCENT               POINT TO VTOC ENTRY\n         L     R15,VOPENSCH          AND OPEN ANOTHER BINSEARCH TABLE\n         BALR  R14,R15                  GO OPEN IT\n         LTR   R1,R1                    DID HE RETURN AN ADDRESS ?\n         BNZ   GOODVTBO                 GOOD, THEN KEEP ON\n         ABEND 025,DUMP\nGOODVTBO ST    R1,VTOCRECD              SAVE THE ADDR FOR INSERT\n         ST    R1,VTOCFIND              SAVE THE ADDR FOR FIND\n********************************************************************\n* THE FUNNY LOOKING CALCULATION HERE GETS THE HIGH FORMAT 1 DSCB,  *\n* AND THE VTOC DESCRIPTION, AND MULTIPLIES AND ADDS ALL THIS JIB-  *\n* BERISH TOGETHER TO COME UP WITH THE NUMBER OF DSCBS WE WILL READ.*\n********************************************************************\nSYSPOPEN LA    R10,44(R11)              LET R10 POINT PAST DSN OF F4\n         USING DS4,R10\n         SLR   R2,R2                    CLEAR THE FOLLOWING FOR CALCS\n         SLR   R3,R3                    AND 3\n         SLR   R4,R4                    AND 4\n         SLR   R5,R5                    AND HIM\n         ICM   R2,3,DS4HPCHR            HI ADDR OF FORMAT 1 DSCB\n         MH    R2,CURRTRKS              # TRKS PER CYL\n         ICM   R3,3,DS4HPCHR+2          PART OF SAME 5 BYTE ADDR\n         AR    R2,R3                    ADD THE 2\n         MH    R2,CURRTRKS+2            # DSCBS PER TRACK\n         IC    R4,DS4HPCHR+4            LAST BYTE OF HIGH ADDR\n         AR    R2,R4                    ADD THEM\n         ICM   R4,3,DS4VTOCE+2          VTOC EXTENT DESCRIPTION\n         MH    R4,CURRTRKS              # TRKS PER CYL\n         ICM   R5,3,DS4VTOCE+4          NEXT 2 OF SAME\n         AR    R4,R5                    ADD THEM\n         MH    R4,CURRTRKS+2            # DSCBS PER TRACK\n         SR    R2,R4                    SUBTRACT THE 2\n         LTR   R2,R2                    VERIFY SOME FORMAT 1'S EXIST\n         BNZ   LOADUPR8                 YES, THEN GO PROCESS\n         MVC   NOF1VSN(6),ALVOLSER     SAVE THE VOLSER\n         LA    R1,NOF1DSCB              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     DONEVTOC                 AND WE'RE FINISHED WITH HIM\nLOADUPR8 LR    R8,R2                    SAVE THE # OF DSCBS\n         BCTR  R9,0                     DECR FOR FORMAT 4\n         LA    R11,140(R11)             POINT TO FIRST FORMAT 1\n         DROP  R10\n         USING DS1,R11\nREADF4   CR    R9,R8                  COMPARE #DSCBS/TRK TO # LEFT\n         BNH   CONTDSNS               IF LESS THEN STILL MORE TO READ\n         LR    R9,R8                  LESS, THEN RESET THE LOOP\nCONTDSNS CLI   DS1FMTID,C'1'            IS IT A FORMAT 1 DSCB\n         BNE   LOOPDSNS               IF NOT FORMAT 1 THEN GET NEXT\n         TM    DS1DSORG+1,DS1ORGAM        IS IT VSAM\n         BO    LOOPDSNS                 IF IT IS THEN NEXT ONE\n         CLC   DS1DSNAM(6),=C'FDRABR'  IF PREFIXED WITH FDRABR\n         BE    LOOPDSNS                 THEN DO NOT WORRY ABOUT STORING\n         CLC   DS1DSNAM(8),TEMPDSN     IS THIS A TEMPORARY DATASET\n         BE    LOOPDSNS                 THEN DO NOT WORRY ABOUT STORING\n         MVC   VTDSNAME(44),DS1DSNAM    STORE THE NAME\n         DROP  R11\n         OI    FLAG2,X'01'            FLAG TO SAY WE DID ONE\n         LA    R1,VTOCRECD            LOAD UP R1 FOR INSERT OF RECORD\n         L     R15,VINSRCH              ADDR OF INSERT ROUTINE\n         BALR  R14,R15                  GO DO IT\n         LTR   R15,R15                  GOOD INSERT ?\n         BZ    LOOPDSNS                 YES, THEN DO NEXT\n         ABEND 026,DUMP\nLOOPDSNS LA    R11,140(R11)             POINT TO NEXT FORMAT 1\n         BCT   R9,READF4                LOOP THRU DSCBS\n         TM    FLAG,X'02'           NO EOF BUT EO EXTENT IS POSSIBLE\n         BO    DONEVTOC                 IF SO WE'RE FINISHED\n         SH    R8,CURRTRKS+2            SUBTR # OF DSCBS PER TRK\n         STH   R8,DSCBLEFT              STORE THE REMAINDER\n         LTR   R8,R8                    SEE IF WE'RE DONE\n         BNP   DONEVTOC                 IF MINUS OR  WE'RE DONE\n         CH    R8,CURRTRKS+2            SEE IF ENOUGH DSCBS LEFT/TRK\n         BNL   RESETTRK                 IF NOT LESS THEN LEAVE CCW'S\n         L     R15,CCWSVAD              GET OUR MODIFIED ADDR\n         LTR   R15,R15                  HAVE WE SAVE ONE YET\n         BZ    SECTADOK                 NO, THEN NO RELOAD\n         MVC   0(8,R15),CCWSAVE    MOVE BACK IN THE SAVED CCW\nSECTADOK LA    R1,READCCW          POINT TO BEGIN OF CHAIN\n         LR    R15,R8              GET DSCBS/TRK\n         SLA   R15,3              MULITPLY BY 8 P/ CCW\n         LA    R15,0(R1,R15)       POINT TO SET SECTOR RECORD\n         ST    R15,CCWSVAD        SAVE THE ADDRESS OF THE CCW\n         MVC   CCWSAVE(8),0(R15)  AND SAVE THE CCW\n         MVC   0(8,R15),SETSECT   MOVE IN SET SECTOR FOR END CCW CHAIN\nRESETTRK SLR   R3,R3                    CLEAR FOR ISERT\n         ICM   R3,3,IOBHH               RELOAD TRK LOCATION\n         LA    R3,1(R3)                 INCREMENT TRACK COUNT\n         STCM  R3,3,IOBHH               SAVE NEW TRACK ADDRESS\n         CH    R3,CURRTRKS              MAKE SURE NOT END OF CYL\n         BL    LOCSET                   IF LESS THEN STILL GOOD\n         MVC   IOBHH(2),HW00            RESET TRK TO 0\n         ICM   R3,3,IOBCC               RELOAD CYLINDER ADDR\n         LA    R3,1(R3)                 INCREMENT TO NEXT CYLINDER\n         STCM  R3,3,IOBCC               SAVE IT\n         B     LOCSET                   AND GO READ SOMRE MORE\nDONEVTOC ICM   R15,15,CCWSVAD           LET'S SEE IF WE SWITCHED\n         BZ    CLOSVTOC                 NO, THEN GO AND CLOSE\n         MVC   0(8,R15),CCWSAVE    MOVE BACK IN THE SAVED CCW\n         XC    CCWSVAD(4),CCWSVAD       CLEAR FOR NEXT CCW READ VTOCS\nCLOSVTOC CLOSE (VTOCDCB)\n         DROP  R7\n         NI    FLAG,X'FE'               RESET FORMAT 4 FLAG\n         SPACE 3\n         TM    FLAG2,X'01'          WAS AT LEAST ONE RECORD PROCESSED\n         BO    VTCRECS              YES, THEN CONTINUE\n         OI    FLAG,X'10'           TELL HIM EOF OF VTOC NO DSNS\n         B     LOADR10F\nVTCRECS  NI    FLAG2,X'FE'          RESET FLAG FOR OTHER PASSES\n         LA    R1,VTOCFIND          POINT TO FIND SEARCH FOR VTOC\n         L     R15,VFNDSRCH         AND GO FIND FIRST RECORD\n         BALR  R14,R15              GO DO IT\n         LTR   R15,R15              GOOD FIND\n         BZ    GOODVFND             YES, THEN CONTINUE\n         ABEND 027,DUMP\nGOODVFND LR    R11,R1               SAVE ADDRESS INTO R11\nLOADR10F L     R10,FINDADDR         GET SAVED ADDRESS FROM EARLIER\n         TM    FLAG,X'10'           EOF OF VTOC\n         BO    UNCATLG              YES, THEN GO UNCATLG ALL\nFCATSET  CLC   ALVOLSER(6),0(R10)          ARE THE VSNS THE SAME\n         BE    CHECKDSN                    YES, THEN GO CHECK DSNS\n         ST    R10,FINDADDR          SAVE THIS ADDRESS\n         TM    FLAG,X'10'            ARE WE AT END OF VTOC\n         BO    ALLOCVTC              YES, THEN DO NEXT ONE\n         OI    FLAG,X'04'           FLAG TO SAY VSNS NO LONGER EQ\n         B     LOOPNODS               GO SAY DSNS NOT CATLGED\nCHECKDSN CLC   0(44,R11),6(R10)       COMP THE VTOC DSN TO CAT DSNAME\n         BH    UNCATLG                IF VTOC DSN GT UNCATLG\n         BL    LOOPNODS               IF LESS THEN NOT CATLGED\n         OI    FLAG,X'20'            FLAG TO SAY EQUAL AND INCREMENT\n         B     INCRVTOC      IF EQ INCR TO NEXT VTOC REC AND COMP ALIAS\nLOOPNODS MVC   NOCATDSN(44),0(R11)         MOVE IN DSNAME\n         MVC   NOCATVSN(6),ALVOLSER       MOVE IN CURRENT VOLUME\n         AP    TOTNVS3(3),PACK1(1)      KEEP COUNT OF THIS AS WELL\n         MVC   USERID(8),BLANKS     BLANK IT OUT\n         LR    R4,R11\n         CLI   0(R4),C'U'              PREFIXED WITH U\n         BE    SHRTSCRC                 YES, THEN SHORTEN IT\n         CLI   0(R4),C'P'              PREFIXED WITH P\n         BE    SHRTSCRC                 YES, THEN SHORTEN IT\n         CLI   0(R4),C'F'               LAST BUT NOT LEAST F\n         BNE   TRTSCRHI                 IF NONE THEN TRANSL FOR HILEV\nSHRTSCRC LA    R4,1(R4)              POINT TO NEXT BYTE FOR COMPARE\nTRTSCRHI TRT   0(9,R4),PERTBLE       LOOK FOR PERIOD OR BLANK\n         SLR   R1,R4                 GET LENGTH OF HI LEVEL\n         CH    R1,HW05               SAME LENGTH AS OUR USERID\n         BNE   NCATOUT               NO, THEN DON'T SEARCH FURTHER\n         BCTR  R1,0                  DECREMENT FOR EXECUTE\n         EX    R1,MOVEUSR            MVC USERID(0),0(R4)\n         LA    R1,USERRECD              (0,USERID) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE USERID\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BNZ   NCATOUT                  NO, THEN DO NOT SCRATCH\n****************************************************************\n*  NEXT SEARCH MIGHT BE AN OVERKILL, BUT I NEED TO KNOW IF IT  *\n* WAS CATALOGED AS A MULTIVOLUME DATASET. IF YES, NO SCRATCH.  *\n****************************************************************\n         MVC   NONVSAM(44),0(R11)      MOVE IN THE DSNAME FOR SCR\n         LA    R1,NVSRECD               (0,USERID) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE THE DATASET\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BNZ   SCRATCHD                 NO, THEN SCRATCH IT\n         TM    52(R1),X'80'             WAS IT A MULTIVOLUME DATASET\n         BO    NCATOUT                  YES, THEN LEAVE ALONE\nSCRATCHD EQU   *\n         TM    FLAG2,X'04'               IS THIS A SCRATCH RUN\n         BO    DOSCRTCH                  NO, THEN JUST PRINT IT\n         MVC   NOCATSCR(21),CANDSCR       MOVE IN STATUS\n         B     NCATOUT                  AND DON'T SCRATCH IT\nDOSCRTCH EQU   *\n         SCRATCH CAMSCR\n         LTR   R15,R15                  WAS IT A GOOD SCRATCH\n         BZ    GOODSCR                  YES, THEN CONTINUE BRETHREN\n         CVD   R15,DOUBLE               MAKE RC PRINTABLE\n         UNPK  ERRCODE2(3),DOUBLE+6(2)   TAKE A GUESS WHAT THIS DOES ?\n         OI    ERRCODE2+2,X'F0'          MAKE SURE SIGN IS OKAY\n         MVC   ERRSDSN(44),0(R11)    STORE THE NAME FOR ERROR\n         OI    FLAG,X'40'               FLAG TO SAY PRINT TWICE\n         CLI   RTCODE+3,X'08'           IS OUT OVERALL RC GT 8\n         BH    NORCSCR                  YES, THEN DO NOT LOWER IT\n         MVI   RTCODE+3,X'08'           SET OVERALL RC  TO 8\nNORCSCR  LA    R1,ERRSCR                PRINT THIS RECORD\n         L     R15,ADOOUT1              GET ADDRESS OF PRINT SECTION\n         BALR  R14,R15                  GO AND PRINT IT\n         B     INCRCATF                 INCREASE CATALOG RECORD\nGOODSCR  MVC   NOCATSCR(9),SCRKWD        MOVE IN SCRATCH STATUS\n         AP    TOTNVS4(3),PACK1(1)      KEEP COUNT OF THIS AS WELL\nNCATOUT  LA    R1,NOTCAT                PRINT THIS RECORD\n         L     R15,ADOOUT2              GET ADDR OF VOLUME PRINT SECT\n         BALR  R14,R15                  GO AND PRINT IT\n         MVC   NOCATSCR(21),BLANKS    BLANK OUT FIELD\nINCRVTOC L     R1,VTOCFIND+4          GET FIND LOCATION NUMBER\n         LA    R1,1(R1)               INCREMENT TO NEXT RECORD\n         ST    R1,VTOCFIND+4          SAVE IT FOR NEXT PASS\n         LA    R1,VTOCFIND          POINT TO FIND SEARCH FOR VTOC\n         L     R15,VFNDSRCH         AND GO FIND RECORD\n         BALR  R14,R15              GO DO IT\n         LTR   R15,R15              GOOD FIND\n         BNZ   EOFVTOC              NO, THEN NO MORE RECORDS\n         LR    R11,R1               GET RECORD POINTER INTO R11\n         TM    FLAG,X'04'           DID WE RUN OUT OF VOLUME\n         BO    LOOPNODS             YES, THEN KEEP ISSUING MESSAGE\n         TM    FLAG,X'20'           WERE THEY EQUAL THEN\n         BO    INCRCATF             YES, THEN GO INCREMENT CATALOG\n         B     CHECKDSN             NO, THEN KEEP PROCESSING\nEOFVTOC  LA    R1,1                 RESET VALUE TO 1\n         ST    R1,VTOCFIND+4        AND STORE IT\n         L     R1,VTOCRECD          LOAD UP POINTER OF VTOCS FOR CLOSE\n         L     R15,VCLOSESC            GET ADDR OF CLOSE ROUTINE\n         BALR  R14,R15              GO AND CLOSE IT\n         OI    FLAG,X'10'     FLAG DONE AND LOOP THE UNCATALOGS\n         ST    R10,FINDADDR           IF NEW VOLSER, ELSE REDUNDANT\n         MVC   ALVOLSER,0(R10)        IF NEW VOLSER FOR EOFVTOC\n         TM    FLAG,X'04'             HAVE THE VOLSERS CHANGED ?\n         BO    ALLOCVTC               YES, THEN GO READ NEXT VTOC\n         TM    FLAG,X'20'             WERE THESE FOUND EQUAL  ?\n         BO    INCRCATF               YES, THEN GO READ NEXT VTOC\nUNCATLG  CLI   51(R10),X'00'         WAS THIS THE MASTER CATALOG\n         BE    GOTCATNM              YES, THEN NO HI LEVEL POINTER\n         MVC   HILEVEL(8),BLANKS     BLANK IT OUT\n         LA    R4,6(R10)             POINT TO DSNAME\n         TRT   0(9,R4),PERTBLE       LOOK FOR PERIOD\n         SLR   R1,R4                 SUBTRACT FOR LENGTH OF QUALIFIER\n         BCTR  R1,0                  DECREMENT FOR MOVE\n         EX    R1,MOVEHIL            MVC HILEVEL(0),0(R4)\n         LA    R1,HILRECD               (0,HILEVEL) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE HI LEVEL QUALIFIER\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BNZ   NOPNTMSG                 YES, THEN COMPARE CAT NUMS\n         CLC   8(1,R1),51(R10)          MAKE SURE SAME CATALOG\n         BE    GOTCATNM                 YES, THEN GO UNCATALOG\nNOPNTMSG MVC   NOPNTDSN(44),0(R4)       MOVE IN DSNAME\n         L     R4,UCATPNTR              GET STORAGE LOCATION OF CAT\n         SLR   R3,R3                    CLEAR R3\n         SLR   R5,R5                    CLEAR R3\n         ICM   R3,1,51(R10)               GET LOCATION NUMBER\n         BZ    GOTCATNM      SHOULD NOT BE 0, BUT IF IT IS THEN MSTR\n         BCTR  R3,0                     DECR 1 BECAUSE BEGINS AT 1\n         MH    R3,HW45                  MULTIPLY BY LENGTH OF ENTRY\n         LA    R4,0(R3,R4)              POINT TO CAT ENTRY\n         IC    R5,0(R4)                 GET LENGTH OF USERCAT\n         SH    R5,HW02                  DECREMENT FOR EXECUTE\n         EX    R5,MVENOPNT              MVC  NOPNTCAT(0),1(R4)\n         LA    R1,NOTPNTED              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\nGOTCATNM MVC   NONVSAM(44),6(R10)        MOVE IN DSNAME FOR LOCATE\n         LA    R1,NVSRECD               (0,NONVSAM) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE HI LEVEL QUALIFIER\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BZ    GOODNVSL\n         ABEND 028,DUMP\nGOODNVSL TM    52(R1),X'01'            DID WE FLAG THIS AS A DUPLICATE\n         BZ    SAYUNCAT\n         MVC   DUPCDSN(44),6(R10)    MOVE IN DSNAME\n         ICM   R3,15,44(R1)          GET 1ST CATALOG NAME\n         MVC   DUPCCAT1(27),0(R3)    MOVE IN CATALOG NAME\n         ICM   R3,15,48(R1)          GET 2ND CATALOG NAME\n         MVC   DUPCCAT2(28),0(R3)    MOVE IN CATALOG NAME\n         LA    R1,DUPCREC               PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     INCRCATF\nSAYUNCAT OI    50(R10),X'02'         FLAG TO SAY WE UNCATLGED IT\n         MVC   UCATVSN(6),ALVOLSER   MOVE IN THE VOLSER\n         MVC   UCATDSN(44),6(R10)    STORE THE NAME FOR UNCATLG\n         TM    FLAG2,X'10'           IS THIS A TEST RUN\n         BZ    PRNTUCAT              YES, THAT DON'T UNCATALOG\n         TM    50(R10),X'01'         WAS THIS CATALOGED TO ******\n         BZ    DOTHEUCT              NO, THEN UNCATALOG THE DSN\n         MVC   SYSRVSN(6),ALVOLSER   MOVE IN THE VOLSER\n         MVC   SYSRDSN(44),6(R10)    STORE THE NAME FOR PRINT\n         LA    R1,SYSRFILE              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     INCRCATF              AND GO AROUND\nDOTHEUCT MVC   VTDSNAME(44),6(R10)   STORE THE NAME FOR UNCATLG\n         LA    R15,VTDSNAME             GET ADDRESS FOR CAT PARM LIST\n         ST    R15,CTGENT               SAVE IT FOR SVC 26\n         L     R4,UCATPNTR              GET STORAGE LOCATION OF CAT\n         MVI   CATDSN,C' '              BLANK OUT\n         MVC   CATDSN+1(43),CATDSN       ENTIRE FIELD\n         SLR   R3,R3                    CLEAR R3\n         SLR   R5,R5                    CLEAR R3\n         ICM   R3,1,51(R10)             GET LOCATION NUMBER\n         BNZ   DECR3NM                  MAKE SURE NOT THE MSTR CAT\n         OI    CTGOPTN3,CTGSRH          TELL HIM USE THE MSTR CATALOG\n         B     SETNVST                  BR AROUND CODE FOR CATALOG\nDECR3NM  BCTR  R3,0                     DECR 1 BECAUSE BEGINS AT 1\n         MH    R3,HW45                  MULTIPLY BY LENGTH OF ENTRY\n         LA    R4,0(R3,R4)              POINT TO CAT ENTRY\n         IC    R5,0(R4)                 GET LENGTH OF USERCAT\n         SH    R5,HW02                  DECREMENT FOR EXECUTE\n         EX    R5,MVEUCATD              MVC  CATDSN(0),1(R4)\nSETNVST  MVI   CTGTYPE,C'A'             TELL HIM NVSAM RECORD TYPE\n         LA    R1,CTGPL                 LOAD UP ADDR OF CAT PARM LST\n         SVC   26                       ISSUE THE BAD BOY\n         NI    CTGOPTN3,X'FB'           TURN OFF MSTR CAT DEF\n         LTR   R15,R15\n         BZ    GOODCAM1\n         CVD   R15,DOUBLE\n         UNPK  ERRCODE(3),DOUBLE+6(2)\n         OI    ERRCODE+2,X'F0'\n         MVC   ERRUDSN(44),6(R10)    STORE THE NAME FOR ERROR\n         OI    FLAG,X'40'               FLAG TO SAY PRINT TWICE\n         CLI   RTCODE+3,X'08'\n         BH    NORCUNCT\n         MVI   RTCODE+3,X'08'           SET OVERALL RCC TO 8\nNORCUNCT LA    R1,ERRUNCAT              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     INCRCATF\nGOODCAM1 AP    TOTNVS2(3),PACK1(1)   KEEP COUNT OF THOSE UNCATLGED\nPRNTUCAT LA    R1,UNCATDSN              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\nINCRCATF NI    FLAG,X'DF'            RESET IF EQUAL FLAG\n         L     R1,CATFIND+4          INCREMENT THROUGH CAT TABLE\n         LA    R1,1(R1)              BY INCREASING TO NEXT REC NUM\n         ST    R1,CATFIND+4          SAVE THE COUNTER FOR NEXT RECORD\n         LA    R1,CATFIND            GET DATA FOR FIND ROUTINE\n         L     R15,VFNDSRCH          GET ADDRESS OF FIND ROUTINE\n         BALR  R14,R15               GO AND FIND THE NASTY RECORD\n         LR    R10,R1                LOAD LOCATION INTO R10\n         LTR   R15,R15               EOF FOR CAT DSNS\n         BNZ   EOFCAT                YES, THEN GO SET AND DECIDE\n         TM    FLAG,X'10'             DO WE HAVE END OF VTOC\n         BZ    FCATSET               NO, THEN GO COMPARE NEXT\n         CLC   ALVOLSER(6),0(R10)    HAVE THE VOLSERS CHANGED\n         BE    UNCATLG              NO, THEN KEEP UNCATALOGING\n         MVC   ALVOLSER(6),0(R10)    MOVE IN THE NEW VOLSER\n         ST    R10,FINDADDR          SAVE THIS ADDRESS\n         B     ALLOCVTC              AND GO READ ANOTHER VTOC\n*********************************************************************\n*  WE ARE NOW GOING TO BE POLITE AND CLOSE OUR BINARY SEARCH TABLES *\n*  THAT WE'RE FINISHED WITH.                                        *\n*********************************************************************\nEOFCAT   L     R1,CATRECD\n         L     R15,VCLOSESC\n         BALR  R14,R15\n         L     R1,UCBRECD\n         L     R15,VCLOSESC\n         BALR  R14,R15\n         L     R1,USERRECD                CLOSE UP THE USERLIST TABLE\n         L     R15,VCLOSESC               ADDR OF CLOSE ROUTINE\n         BALR  R14,R15                    GO DO IT BEULA\n         LA    R1,VTDSNAME            LOAD UP ADDRESS OF ALIAS\n         ST    R1,CTGENT              SAVE ADDRESS FOR DELETE REQ\n*********************************************************************\n*  NEXT TO BE PROCESSED ARE ALIAS ENTRIES FOR OTHER NONVSAM DSNAMES *\n*  NO  LONGER EXIST. IF ANY ARE FOUND THEY WILL BE UNCATALOGED.     *\n*********************************************************************\nGOTALISS NI    FLAG2,X'7F'            PLEASE RESET FLAG FOR LOOPING\n         L     R1,ALISFIND+4         GET LOCATION # NEXT ALIAS\n         LA    R1,1(R1)              INCREMENT TO POINT TO IT\n         ST    R1,ALISFIND+4         SAVE FOR NEXT RECORD\n         LA    R1,ALISFIND         MAINTAIN POINTER FOR BINARY FIND\n         L     R15,VFNDSRCH               GO FIND FIRST RECORD\n         BALR  R14,R15                    IN CATALOG RECORD TABLE\n         LTR   R15,R15                    DID WE FIND IT\n         BNZ   EOFALIAS           YES, THEN ONWARD CHRISTIAN SOLDIERS\n         LR    R9,R1               STORE IF FOR LATER\n         L     R4,UCATPNTR              GET STORAGE LOCATION OF CAT\n         SLR   R3,R3                    CLEAR R3\n         SLR   R5,R5                    CLEAR R3\n         IC    R3,88(R9)                GET LOCATION NUMBER\n         BCTR  R3,0                     DECR 1 BECAUSE BEGINS AT 1\n         MH    R3,HW45                  MULTIPLY BY LENGTH OF ENTRY\n         LA    R4,0(R3,R4)              POINT TO CAT ENTRY\n         IC    R5,0(R4)                 GET LENGTH OF USERCAT\n         SH    R5,HW02                  DECREMENT FOR EXECUTE\n         MVI   CATDSN,C' '              BLANK OUT\n         MVC   CATDSN+1(43),CATDSN       ENTIRE FIELD\n         EX    R5,MVEUCATD              MVC  CATDSN(0),1(R4)\nUNCATAL  MVC   HILEVEL(8),BLANKS     BLANK IT OUT\n         LR    R4,R9                 POINT TO DSNAME\n         TRT   0(9,R4),PERTBLE       LOOK FOR PERIOD\n         SLR   R1,R4\n         BCTR  R1,0\n         EX    R1,MOVEHIL            MVC HILEVEL(0),0(R4)\n         LA    R1,HILRECD               (0,HILEVEL) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE HI LEVEL QUALIFIER\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BNZ   NOPNTMGA                 YES, THEN COMPARE CAT NUMS\n         TM    89(R9),X'80'             DID WE FLAG AS A DUPLICATE\n         BO    DONTUCTA                 YES, THEN DONT UNCATLG\n         CLC   8(1,R1),88(R9)           MAKE SURE SAME CATALOG\n         BE    VERALEXT              YES, THEN GO VERIFY ENTRY EXISTS\nDONTUCTA OI    FLAG2,X'80'           DO NOT UNCATLG\nNOPNTMGA MVC   NOPNTDSN(44),0(R4)       MOVE IN DSNAME\n         EX    R5,MVENOPNT              MVC  NOPNTCAT(0),1(R4)\n         LA    R1,NOTPNTED              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     ALIASUNC\nVERALEXT MVC   NONVSAM(44),44(R9)        MOVE IN DSNAME FOR LOCATE\n         LA    R1,NVSRECD               (0,NONVSAM) LOC USER\n         L     R15,VLOCSRCH             GET ENTRY OF LOCATE ROUTINE\n         BALR  R14,R15                  GO LOCATE HI LEVEL QUALIFIER\n         LTR   R15,R15                  DID WE FIND IT  ?\n         BZ    GOTALISS\n         MVC   NOMTCHAL(44),0(R9)\n         LA    R1,NOMATCH               PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\nALIASUNC TM    FLAG2,X'80'           DO WE REALLY WANT TO UNCATLG IT\n         BO    GOTALISS              NO, THEN DO NEXT\n         MVC   DELADSN(44),0(R9)         MOVE IN THE ALIAS NAME\n         MVC   DELAREL(44),44(R9)        MOVE IN RELATED ENTRY NAME\n         TM    FLAG2,X'10'           IS THIS A TEST RUN\n         BZ    PRTALREC              YES, THAT JUST PRINT RECORD\n         MVC   VTDSNAME(44),0(R9)    STORE THE NAME FOR UNCATLG\n         LA    R1,CTGPL                 LOAD UP ADDR OF CAT PARM LST\n         SVC   26                       ISSUE THE BAD BOY\n         LTR   R15,R15                  VERIFY THAT REQUEST WORKED\n         BZ    GOODCAM2                 YES, THEN KEEP ON\n         CVD   R15,DOUBLE\n         UNPK  ERRCODED(3),DOUBLE+6(2)\n         OI    ERRCODED+2,X'F0'\n         MVC   ERRDDSN(44),0(R9)     STORE THE NAME FOR ERROR\n         OI    FLAG,X'40'               FLAG TO SAY PRINT TWICE\n         CLI   RTCODE+3,X'08'\n         BH    NORCDEL2\n         MVI   RTCODE+3,X'08'           SET OVERALL RCC TO 8\nNORCDEL2 LA    R1,ERRDELAL              PRINT THIS RECORD\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GOTALISS\nGOODCAM2 AP    TOTALIS2(3),PACK1(1)   KEEP COUNT OF THOSE UNCATLGED\nPRTALREC LA    R1,DELALDSN\n         L     R15,ADOOUT1\n         BALR  R14,R15\n         B     GOTALISS\nEOFALIAS L     R1,ALIASREC           LOAD UP ADDRESS FOR CLOSE\n         L     R15,VCLOSESC          LOAD ADDRESS OF CLOSE ROUTINE\n         BALR  R14,R15               GO AND CLOSE THIS TABLE\n         L     R1,HILRECD\n         L     R15,VCLOSESC\n         BALR  R14,R15\n        FREEMAIN EC,LV=19460,A=STRADDR1\n        L     R15,ATOTALS\n        BALR  R14,R15\n        CLOSE (SYSPRIN1,,SYSPRIN2)\nLOADRTCD L     R15,RTCODE\nRETURN   L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n        EJECT\nVTOCDCB  DCB   DDNAME=VTOCDCB,DSORG=PS,MACRF=E,EXLST=JFCBLIST\n         DC    5F'0'\nSYSPRIN1 DCB   DDNAME=SYSPRIN1,DSORG=PS,MACRF=PM,LRECL=121,RECFM=FBA,  X\n               BLKSIZE=12100\nSYSPRIN2 DCB   DDNAME=SYSPRIN2,DSORG=PS,MACRF=PM,LRECL=121,RECFM=FBA,  X\n               BLKSIZE=12100\nGETACB   ACB   AM=VSAM,CATALOG=NO,DDNAME=SYS00099,EXLST=ERROR,         X\n               MACRF=(KEY,NFX,NDF,SEQ,NCI,IN,NIS,NRM,NRS,NUB),         X\n               BUFSP=10240\nERROR    EXLST AM=VSAM,EODAD=CLOSEACB\nOPENLIST OPEN  (VTOCDCB,(INPUT)),MF=L\nJFCBLIST DS    0F\n         DC    X'07'\n         DC    AL3(JFCBAREA)\n         DC    X'FF'\n**********************************************************************\n* RECADDR IS NOT WHERE THE RECORD WILL BE STORED. I WILL DO A GETMAIN\n* AND STORE THE ADDRESS AT 32 PAST RPL OVERRIDING THE SPECIFICATION\n* IN THE MACRO. I WILL STORE THE ADDRESS OF THE STORAGE AT RECADDR AS\n* WELL AND USE THAT LOCATION TO PROCESS RECORDS. GET LOCATE WOULDN'T\n* WORK BECAUSE A RECORD SPANS A CONTROL INTERVAL (4400+BYTES), SO I\n* CHANGED IT TO A GET MOVE AND DID NOT WANT A WORK AREA OF 10000+BYTES\n* INSIDE MY MODULE.\nGETRPL   RPL   ACB=GETACB,AM=VSAM,AREA=RECADDR,AREALEN=10240,          X\n               OPTCD=(KEY,SEQ,ARD,FWD,SYN,NUP,MVE)\nCCW      CCW   X'23',SECTOR,X'40',1    SET SECTOR\n         CCW   X'31',IOB+35,X'40',5    SEARCH ID EQUAL\n         CCW   X'08',*-8,0,0           TIC\nREADCCW  CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\n         CCW   X'0E',0,X'60',140       READ KEY AND DATA\nENDCCWS  CCW   X'0E',0,X'60',140       READ KEY AND DATA\nSETSECT  CCW   X'22',SECTOR,0,1        READ SECTOR OF LAST RECORD READ\n*                                      AND SAVE FOR NEXT READ\nIOB     DC    10F'0'\n         ORG   IOB+0           IOBFLAG1\n         DC    B'01000010'     CMD CHAIN,RELATED REQ\n         ORG   IOB+5\n         DC    AL3(ECB)\n         ORG   IOB+17\n         DC    AL3(CCW)\n         ORG   IOB+21\n         DC    AL3(VTOCDCB)\n         ORG\nECB     DC    F'0'\nSECTOR   DC    X'00'\nCAMSCR   CAMLST SCRATCH,NONVSAM,,VOLLIST,,OVRD\nCTGPL    DS    0D\n*\nCTGOPTN1 DC    X'06'    CTGNAME CTGCNAME\nCTGOPTN2 DC    X'00'\nCTGOPTN3 DC    X'83'    CTGNUM CTGAM0 CTGCMS\nCTGSRH   EQU   X'04'    MASTER CATALOG ONLY\nCTGOPTN4 DC    X'01'    CTGICFOR\n*** NEXT FIELD WILL BE RESET IF OTHER THEN USERIDS ARE TO BE DELETED\nCTGENT   DC    A(ALISDSNS)  ADDRESS OF ALIAS NAME FOR DELETE\nCTGCAT   DC    A(CATDSN)  ADDRESS OF CATALOG NAME\nCTGWKA   DC    A(0)     ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DC    X'18'    DELETE FUNCTION\n         DC    X'00'          RESERVED\n*\n*** NEXT FIELD WILL BE RESET IF OTHER THEN ALIASES ARE TO BE DELETED\nCTGTYPE  DC    C'X'     ALIAS CATALOG RECORD DEFAULT\nCTGNOFLD DC    X'00'          NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DC    XL2'00'        FEEDBACK AREA\nCTGFBFLG DC    X'00'          FLAGS (SUPERLOCATE)\n         DC    X'00'          RESERVED\nCTGJSCB  DC    A(0)           ADDRESS OF JSCB\n******** END OF CATALOG PARAMETER LIST FOR SVC 26\nVOLLIST  DC    H'1'\nVOLDEVT  DC    X'00000000'          UPDATE WITH DEVICE TYPE\nVOLVSN   DC    CL6' '               VOLUME SERIAL # WHERE DSN LIVES\n         DC    H'0'                 SCRATCH STATUS CODE\n         DS    0H\nCOMPUCAT CLC   0(0,R3),60(R7)\nMOVEHIL  MVC   HILEVEL(0),0(R4)\nMOVEUSR  MVC   USERID(0),0(R4)\nMVEADSN2 MVC   ALISDSN2(0),61(R7)\nMVEUCAT  MVC   0(0,R3),60(R7)\nMVEDELAL MVC   DELAREL(0),61(R7)\nMVECATAL MVC   CATDSN(0),1(R3)\nMVEHICAT MVC   BADHICAT(0),61(R7)\nMVENOPNT MVC   NOPNTCAT(0),1(R4)\nMVEUCATD MVC   CATDSN(0),1(R4)\nHW00     DC    H'00'\nHW01     DC    H'01'\nHW02     DC    H'02'\nHW03     DC    H'03'\nHW04     DC    H'04'\nHW05     DC    H'05'\nHW06     DC    H'06'\nHW08     DC    H'08'\nHW45     DC    H'45'\n* TYPE        UCBTYP  #TRKS   #DSCBS/TRK\nDEV3380  DC    X'0E',X'000F',X'0035'\nDEV3375  DC    X'0C',X'000C',X'0033'\nDEV3350  DC    X'0B',X'001E',X'002F'\nDEV33301 DC    X'0D',X'0013',X'0027'\nDEV3330  DC    X'09',X'0013',X'0027'\nJFCBAREA DS    0F,176C\nS99PARM  DC    X'80',AL3(S99AREA)  ADDRESS OF SVC 99 REQUEST BLOCK\nS99AREA  DC    AL1(S99RBEND-S99RB) LENGTH OF REQUEST BLOCK\n         DC    X'01'               VERB CODE\n         DC    XL6'00'\n         DC    A(VTTUPTR)          POINTER TO LIST OF TEXT UNIT PTRS\n         DC    XL8'00'\n         SPACE 1\nVTTUPTR  DC    A(ALDDTU)           ADDR OF DDNAME TEXT UNIT\n         DC    A(ALVLTU)           ADDR OF VOLSER TEXT UNIT\n         DC    A(ALUNTU)           ADDR OF UNIT TEXT UNIT\n         DC    A(ALFCTU)           ADDR OF FREE CLOSE TEXT UNIT\n         DC    X'80',AL3(ALDDSP)   ADDR OF DISP TEXT UNIT\n         SPACE 1\nCATUPTR  DC    A(ALDSNTU)          ADDR OF DDNAME TEXT UNIT\n         DC    A(ALDDTU2)          ADDR OF VOLSER TEXT UNIT\n         DC    A(ALFCTU)           ADDR OF FREE CLOSE TEXT UNIT\n         DC    X'80',AL3(ALDDSP)   ADDR OF DISP TEXT UNIT\n         SPACE 1\nALDDTU   DC    X'0001'             DDNAME\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0008'             LENGTH OF PARAMETER\nALDDNAM  DC    CL8'VTOCDCB '       AREA FOR DDNAME\n         DS    0H\nALDDTU2  DC    X'0001'             DDNAME\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0008'             LENGTH OF PARAMETER\n         DC    CL8'SYS00099'       AREA FOR DDNAME\n         DS    0H\nALDSNTU  DC    X'0002'             DSNAME\n         DC    X'0001'             ONE PARAMETER\n         DC    X'002C'             LENGTH OF PARAMETER\nCATDSN   DC    CL44' '             AREA FOR DSNAME\n         DS    0H\nALVLTU   DC    X'0010'             VOLSER\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0006'             LENGTH OF PARAMETER\nALVOLSER DC    CL6'      '         AREA FOR VOLUME SERIAL NUMBER\n         DS    0H\nALUNTU   DC    X'0015'             VOLSER\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0008'             LENGTH OF PARAMETER\nALUNIT   DC    CL8'SYSALLDA'       AREA FOR DASD UNITNAME\n         DS    0H\nALFCTU   DC    X'001C'             FREE = CLOSE\n         DC    X'0000'             0 PARAMETER\n         DS    0H\nALDDSP   DC    X'0004'             OVERRIDE DISPOSITION\n         DC    X'0001'             ONE PARAMETER\n         DC    X'0001'             LENGTH OF PARAMETER\n         DC    X'08'               DISPOSITION OF SHR\n         SPACE 1\nDOUBLE   DC    D'0'             DOUBLE WORD OF 0\nRECADDR  DS    F                ADDR OF RECORD WITHIN BUFFER\nFEEDBCK  DS    F                FEEDBACK AREA FROM GET REQUEST\nSTRADDR1 DC    F'0'\nPARMADDR DC    F'0'\nUCATADDR DC    F'0'\nUCATPNTR DC    F'0'\nRTCODE   DC    F'0'\nENDUCAT  DC    F'0'\nFINDADDR DC    F'0'\nCURRTRKS DC    F'0'\nCCWSVAD  DC    F'0'\nATOTALS  DC    A(TOTALS)\nADOOUT1  DC    A(DOOUT1)\nADOOUT2  DC    A(DOOUT2)\nADOPARMS DC    A(DOPARMS)\nADOUSERL DC    A(DOUSERL)\nDSCBLEFT DC    H'0'\nCATLGNUM DC    H'00'\nMLINECNT DC    H'80'\nCCWSAVE  DC    CL8' '\n**********************************************************************\n*  DO NOT MOVE OR INSERT ANY RECORDS FROM HERE DOWN TO NEXT LINE OF  *\n*  ASTERISKS                                                         *\nALIASENT DC    A(90,0,44)                                            *\nALIASREC DC    A(0,ALISDSNS)                                         *\nHILENT   DC    A(9,0,8)                                              *\nHILRECD  DC    A(0,HILEVEL)                                          *\nCATENT   DC    A(52,0,50)                                            *\nCATRECD  DC    A(0,VTVOLSER)                                         *\nNVSENT   DC    A(53,0,44)                                            *\nNVSRECD  DC    A(0,NONVSAM)                                          *\nVTOCENT  DC    A(44,0,44)                                            *\nVTOCRECD DC    A(0,VTDSNAME)                                         *\nUSERENT  DC    A(5,0,5)                                              *\nUSERRECD DC    A(0,USERID)                                           *\nUCBENT   DC    A(6,0,6)                                              *\nUCBRECD  DC    A(0,VTVOLSER)                                         *\nCATFIND  DC    A(0,1)                                                *\nVTOCFIND DC    A(0,1)                                                *\nALISFIND DC    A(0,0)                FIRST PASS WILL SET TO 1        *\nVOPENSCH DC    V(OPENSRCH)                                           *\nVINSRCH  DC    V(INSRCH)                                             *\nVLOCSRCH DC    V(LOCSRCH)                                            *\nVFNDSRCH DC    V(FNDSRCH)                                            *\nVCLOSESC DC    V(CLOSESCH)                                           *\nFLAG     DC    X'00'                                                 *\nFLAG2    DC    X'00'                                                 *\nTEMPDSN  DC    CL8'SYS '                                             *\nUSERID   DC    CL5' '                                                *\nVTVOLSER DC    CL6' '                                                *\nVTDSNAME DC    CL44' '                                               *\nCATFLAG1 DC    X'00'                                                 *\nCATFLAG2 DC    X'00'                                                 *\nNONVSAM  DC    CL44' '                                               *\nNVSCATA1 DC    4X'00'                                                *\nNVSCATA2 DC    4X'00'                                                *\nNVSFLAG1 DC    X'00'                                                 *\nHILEVEL  DC    CL8' '                                                *\nHILCAT   DC    X'00'                                                 *\nALISDSNS DC    CL44' '                                               *\nALISDSN2 DC    CL44' '                                               *\nCATFLAG3 DC    X'00'                                                 *\nCATFLAG4 DC    X'00'                                                 *\nSRCHVSN  DC    CL6' '                                                *\nSYSRES   DC    CL6' '                                                *\nPACK1    DC    PL1'1'                                                *\nTOTCAT1  DC    PL3'0'                                                *\nTOTVOL1  DC    PL3'0'                                                *\nTOTUCAT1 DC    PL3'0'                                                *\nTOTVSM1  DC    PL3'0'                                                *\nTOTGDG1  DC    PL3'0'                                                *\nTOTNVS1  DC    PL3'0'                                                *\nTOTNVS2  DC    PL3'0'                                                *\nTOTNVS3  DC    PL3'0'                                                *\nTOTNVS4  DC    PL3'0'                                                *\nTOTALIS1 DC    PL3'0'                                                *\nTOTALIS2 DC    PL3'0'                                                *\nTOTHIL1  DC    PL3'0'                                                *\nTOTHIL2  DC    PL3'0'                                                *\nTOTNCAT1 DC    PL3'0'                                                *\nTOTUSER1 DC    PL3'0'                                                *\nTOTUSER2 DC    PL3'0'                                                *\n*        OR ELSE YOUR RESULTS WOULD BE EXTREMELY AMUSING.            *\n**********************************************************************\nMSTRCAT  DC    CL44' '\nCANDSCR  DC    CL23'CANDIDATE FOR SCRATCHED'\nSCRKWD   EQU   CANDSCR+14\nBLANKS   DC    CL40' '\nCATOPERR WTO   'CATALOG OPEN ERROR; VERIFY THAT A STEPCAT IS PRESENT FO+\n               R CATALOG                                            ', +\n               MF=L\nNOTCAT   DS    0CL121\n         DC    C' '\nNOCATDSN DC    CL44' '\n         DC    CL29' IS NOT CATALOGUED ON VOLUME '\nNOCATVSN DC    CL6' '\n         DC    CL10'. '\nNOCATSCR DC    CL31' '\nERRUNCAT DS    0CL121\n         DC    CL20' ERROR UNCATALOGING '\nUNCATKW  EQU   ERRUNCAT+7\nERRUDSN  DC    CL44' '\n         DC    CL5'; RC='\nERRCODE  DC    CL52' '\nERRDELAL DS    0CL121\n         DC    CL22' ERROR DELETING ALIAS '\nERRDDSN  DC    CL44' '\n         DC    CL5'; RC='\nERRCODED DC    CL50' '\nERRSCR   DS    0CL121\n         DC    CL18' ERROR SCRATCHING '\nERRSDSN  DC    CL44' '\n         DC    CL5'; RC='\nERRCODE2 DC    CL54' '\nDELALDSN DS    0CL121\n         DC    CL7' ALIAS '\nDELADSN  DC    CL44' '\n         DC    CL12' RELATED TO '\nDELAREL  DC    CL44' '\n         DC    CL14', WAS DELETED '\nUNCATDSN DS    0CL121\n         DC    CL5' DSN '\nUCATDSN  DC    CL44' '\n         DC    CL21' CATALOGED TO VOLUME '\nUCATVSN  DC    CL6' '\n         DC    CL45', DID NOT EXIST, AND WAS UNCATALOGED'\nSYSRFILE DS    0CL121\n         DC    CL5' DSN '\nSYSRDSN  DC    CL45' '\n         DC    CL10'ON VOLUME '\nSYSRVSN  DC    CL7' '\n         DC    CL34'NOT ON SYSRES VOLUME DEFINED WITH '\nASTRKWD  DC    CL20'******. NO UNCAT.'\nBADALIAS DS    0CL121\n         DC    CL7' ALIAS '\nHILEVELM DC    CL9' '\n         DC    CL7'IN CAT '\nBADOWCAT DC    CL45' '\n         DC    CL8'FOR CAT '\nBADHICAT DC    CL45' '\nNOTPNTED DS    0CL121\n         DC    CL15' NO POINTER TO '\nNOPNTDSN DC    CL45' '\n         DC    CL7'IN CAT '\nNOPNTCAT DC    CL34' '\nNOPNTSTT DC    CL20' '\nNOMATCH  DS    0CL121\n         DC    CL45' NO MATCHING NONVSAM DATASET ENTRY FOR ALIAS '\nNOMTCHAL DC    CL44' '\n         DC    CL32'; ALIAS WILL BE UNCATALOGED.'\nNOF1DSCB DS    0CL121\n         DC    CL8' VOLUME '\nNOF1VSN  DC    CL7' '\n         DC    CL106'HAS NO FOMRAT 1 DSCBS ON IT. PLEASE VERIFY.'\nDUPCREC  DS    0CL121\n         DC    CL15' DUPLICATE DSN '\nDUPCDSN  DC    CL44' '\n         DC    CL7'IN CAT '\nDUPCCAT1 DC    CL27' '\n         DC    CL5' AND '\nDUPCCAT2 DC    CL28' '\nDUPAREC  DS    0CL121\n         DC    CL7' ALIAS '\nDUPADSN  DC    CL44' '\n         DC    CL7'IN CAT '\nDUPACAT1 DC    CL44' '\n         DC    CL15'IS A DUPLICATE.'\n         LTORG\n         DS    0F\nPERTBLE  DC    256X'00'\n         ORG   PERTBLE+C' '\n         DC    X'FF'\n         ORG   PERTBLE+C'.'\n         DC    X'FF'\n         ORG\n         EJECT\n******************************************************************\n*  THIS SECTION WILL BE CONCERNED WITH PROCESSING OUR PARM       *\n* VALUES.                                                        *\n******************************************************************\n         USING DOPARMS,R10\nDOPARMS  ST    R14,PARMR14\n         LA    R4,2(R4)            POINT TO PARMS\nLOOPTHRU TM    FLAG2,X'40'         HAVE WE DONE UNCAT\n         BO    TRYSCR\n         CLC   0(5,R4),UNCATKW     IS IT UNCAT\n         BNE   TRYSCR              NO, THEN TRY SCR PARM\n         OI    FLAG2,X'10'         FLAG TO SAY UNCAT RUN\n         LA    R4,6(R4)            INCREMENT PAST UNCAT AND COMMA\n         SH    R3,HW06             DECREMENT COUNTER\n         LTR   R3,R3               IF PLUS CONTINUE\n         BNP   PARMRET             IF 0 OR - THEN FINISHED\nTRYSCR   TM    FLAG2,X'08'         HAVE WE DONE SCR PARM YET\n         BO    TRYLNEC\n         CLC   0(3,R4),SCRKWD      IS IT SCRATCH\n         BNE   TRYLNEC             NO, THEN TRY TRY LINE COUNT\n         OI    FLAG2,X'04'         FLAG TO SAY SCRATCH RUN\n         LA    R4,4(R4)            INCREMENT PAST SCRTH AND COMMA\n         SH    R3,HW04             DECREMENT COUNTER\n         LTR   R3,R3               IF PLUS CONTINUE\n         BNP   PARMRET             IF 0 OR - THEN FINISHED\n         B     LOOPTHRU            NO, THEN LOOP THRU\nTRYLNEC  TM    FLAG2,X'20'         HAVE WE PROCESSED LINECNT YET\n         BO    INVALPRM            YES, THEN WE ARE CONFUSED, BYE\n         CLC   0(8,R4),=C'LINECNT='    IS THIS OUR LINE COUNT\n         BNE   INVALPRM             NO, THEN SOME INVALID PARM\n         OI    FLAG2,X'20'          FLAG TO SAY WE GOT IT\n         SH    R3,HW08              DECREMENT 8 FOR WHAT WE HAVE\n         LTR   R3,R3                ANYTHING LEFT IN R3\n         BNP   INVALPRM             THEY ARE WRONG THEN\n         LA    R4,8(R4)             POINT PAST = SIGN\n         CLI   1(R4),C'0'           IS SECOND DIGIT 0 OR GT\n         BNL   TWODIGIT             YES, THEN WE HAVE 2 DIGITS\n         CLI   0(R4),C'0'           MUST BE 0 OR HIGHER\n         BL    INVALPRM             NO, THEN INVALID PARM\n         PACK  DOUBLE(8),0(1,R4)   YES, THEN JUST PACK THE ONE\n         SH    R3,HW02              DECRMENT 2, 1 FOR COMMA\n         LA    R4,2(R4)             POINT PAST\n         B     STORLNE              STORE THE NUMBER\nTWODIGIT CLI   0(R4),C'0'           MUST BE 0 OR HIGHER\n         BL    INVALPRM             NO, THEN INVALID PARM\n         PACK  DOUBLE(8),0(2,R4)    GO AHEAD AND MAKE PACKED\n         LA    R4,3(R4)             POINT PAST FIELD\n         SH    R3,HW03              DECR 3, 1 FOR COMMA\nSTORLNE  CVB   R15,DOUBLE           CONVERT IT TO BINARY\n         CH    R15,HW08             HAS TO BE GREATER THAN 8\n         BNH   INVALPRM             NO, THEN GIVE YO-YO MSG\n         STH   R15,MLINECNT         STORE IN LINE COUNT FIELD\n         LTR   R3,R3                DO WE HAVE ANY PARMS LEFT\n         BNP   PARMDONE             NO, THEN QUIT\n         B     LOOPTHRU             GO LOOK FOR UNCAT THEN\nINVALPRM EQU   *\n         WTO   'INVALID PARAMETER; PARMS ARE UNCAT, SCR, AND OR LINECNT+\n               =9 THROUGH 99'\n         MVI   RTCODE+3,X'10'            MOVE IN RETURN CODE OF 16\n         B     RETURN                    JUST QUIT IF PARMS BAD\nPARMRET  L     R14,PARMR14\n         BR    R14\nPARMR14  DS    F\n         LTORG\n         DROP  R10\n******************************************************************\n*  THIS SECTION WILL PREPARE A BINARY SEARCH TABLE FOR THE       *\n* USERLIST, AND THEN FILL IT WITH VALID USERLIST ID'S            *\n******************************************************************\n         USING DOUSERL,R10\nDOUSERL  ST    R14,RETDUSER\n         LA    R1,USERENT           (5,0,5)\n         L     R15,VOPENSCH         ADDRESS OF OPEN SEARCH\n         BALR  R14,R15              GO DO IT\n         LTR   R1,R1                GOOD OPEN\n         BNZ   GOODUOP              YES, AN ADDRESS THERE\n         ABEND 002,DUMP\nGOODUOP  ST    R1,USERRECD          SAVE AT  (0,USERID)\n         OPEN  USERLIST\n         TM    USERLIST+48,X'10'    GOOD OPEN\n         BO    LOOPUSER                   THEN CONTINUE TO NEXT\n         ABEND 001,DUMP\nLOOPUSER GET   USERLIST\n         CLI   79(R1),C'1'            IS THIS A VALID USER\n         BNE   LOOPUSER               NO, THEN NO TABLE ENTRY\n         AP    TOTUSER1(3),PACK1(1)   MAINTAIN COUNTER\n         MVC   USERID(5),40(R1)       MOVE USERID INTO RECORD ENTRY\n         LA    R1,USERRECD            LOAD POINTER INTO R1\n         L     R15,VINSRCH            GET INSERT ADDR IN R15\n         BALR  R14,R15                GO INSERT INTO TABLE\n         LTR   R15,R15                GOOD INSERT, NO DUPS, ETC...\n         BZ    LOOPUSER               YES, THEN GET NEXT\n         ABEND 003,DUMP\nEODUSER  CLOSE USERLIST\n         L     R14,RETDUSER\n         BR    R14\nUSERLIST DCB   DDNAME=USERLIST,DSORG=PS,MACRF=GL,EODAD=EODUSER\nRETDUSER DC    F'0'\n         LTORG\n         DROP  R10\n         EJECT\n******************************************************************\n*  THIS IS OUR HANDSOMELY PRODUCED OUTPUT SECTION. REGISTERS ARE *\n* SAVED ON ENTRY AND THEN RESTORED AT DEPARTURE.                 *\n******************************************************************\n         USING DOOUT1,R15\nDOOUT1   STM   R2,R14,OUTSAVE1    SAVE THE REGS\n         LR    R10,R15\n         LA    R11,2048(R10)\n         LA    R11,2048(R11)\n         LR    R9,R1              SAVE THE PRINT LINE ADDRESS\n         DROP  R15\n         USING DOOUT1,R10,R11\n         TM    OUTFLAG,X'01'      IS THIS THE FIRST PASS THRU\n         BO    GETLNCT            NO, THEN GO AROUND\n         OI    OUTFLAG,X'01'      SET IT\n******************************************************************\n*  THIS NEXT SECTION WILL BE USED TO PRINT A SUMMARY OF THIS PRO-*\n*  GRAM TO INCLUDE PARM VALUES, AND A DESCRIPTION.               *\n******************************************************************\n         L     R2,PARMADDR\n         LH    R3,0(R2)\n         LTR   R3,R3\n         BZ    NOPARMV\n         BCTR  R3,0\n         EX    R3,MVEPARM\nNOPARMV  EQU   *\n         LA    R2,HDRLNE1\n         LA    R5,ENDLIST\n         LA    R4,121\nPRTPRM   EQU   *\n         PUT   SYSPRIN1,(2)\n         BXLE  R2,R4,PRTPRM\nDATEMOVE MVC   DATE+7(2),TEMPDSN+3  MOVE IN JULIAN DATE\n         MVC   DATE+10(3),TEMPDSN+5 AND THE REST OF IT\n         TM    FLAG2,X'10'        IS THIS AN UNCATALOG RUN\n         BZ    GETLNCT            NO, THE LEAVE MESSAGE LINE ALONE\n         MVC   TESTRUN(40),BLANKS BLANK OUT STATEMENT\nGETLNCT  LH    R2,LINECNT1        RELOAD LINE COUNT\n         LTR   R2,R2              ARE WE AT TOP OF PAGE\n         BNZ   OMVEOUT            NO, THEN DON'T PRINT HEADERS\n         LA    R2,6(R2)           INCREMENT COUNTER\n         PUT   SYSPRIN1,HEADER1A\n         PUT   SYSPRIN1,HEADER1B\n         MVI   0(R9),C'-'         DO A TRIPLE SPACE\nOMVEOUT  EQU   *\n         PUT   SYSPRIN1,(9)\n         TM    FLAG,X'40'         ARE WE PRINTING AN ERROR MSG\n         BZ    SETTOONE           NO, THEN JUST CONTINUE\n         MVI   0(R9),C'+'         SUPPRESS SKIPPING\n         PUT   SYSPRIN1,(9)\n         NI    FLAG,X'BF'         RESET FLAG\nSETTOONE MVI   0(R9),C' '         RESET TO SINGLE SPACE\nINCROUT  LA    R2,1(R2)           EITHER WAY INCREMENT COUNTER\n         CH    R2,MLINECNT        ARE WE AT THE MAX LINECNT\n         BL    GOBACK             NO, THEN SAVE R2 COUNTER AS IS\n         SLR   R2,R2              YES, RESET TO 0\nGOBACK   STH   R2,LINECNT1        STORE EITHER 0 OR COUNT\n         LM    R2,R14,OUTSAVE1    RESTORE REGS\n         BR    R14                RETURN TO NIMH\nOUTSAVE1 DS    13F\nMVEPARM  MVC   PARMSIN(0),2(R2)\nLINECNT1 DC    H'00'\nOUTFLAG  DC    H'00'\nHEADER1A DC    CL121'1       PGM-CATCLEAN          DCEC CATALOG AND VOL+\n               UME MAINTENANCE PROGRAM '\n         ORG   HEADER1A+90\nDATE     DC    CL13'DATE - XX.XXX'\n         ORG\nHEADER1B DC    CL121'0       ICF CATALOG NONVSAM AND ALIAS ENTRY SECTIO'\n               N '\n         ORG   HEADER1B+75\nTESTRUN  DC    CL40'** TEST RUN, NO PHYSICAL ACTION TAKEN **'\n         ORG\nHDRLNE1  DC    CL121'1   ICF CATALOG AND DASD VOLUME MAINTENANCE PROGRA+\n               M '\nHDRLNE2  DC    CL46'-   PARAMETER VALUES IN EFFECT FOR THIS RUN - '\nPARMSIN  DC    CL75' '\nBEGLIST  EQU   *\n DC CL121'-**********  EXECUTION  PARM  VALUES  **********************'\n DC CL121' *                                                         *'\n DC CL121' *  UNCAT... UNCATALOG INVALID NONVSAM AND ALIAS ENTRIES   *'\n DC CL121' *  SCR..... SCRATCH NON-CATALOGED NONVSAM DATASETS        *'\n DC CL121' *  LINECNT= KEYWORD PARAMETER TO SPECIFY LINES PER PAGE   *'\n DC CL121' *           (DEFAULT 80, MAXIMUM 99, MINIMUM 9)           *'\n DC CL121' *                                                         *'\n DC CL121' **********  PROGRAM DESCRIPTION      **********************'\n DC CL121' *                                                         *'\n DC CL121' *    THIS PROGRAM WILL READ THE MASTER CATALOG AND BUILD  *'\n DC CL121' *  A TABLE OF NONVSAM DATASETS, ALIASES, AND USERCATALOGS *'\n DC CL121' *  WITH VALID POINTERS TO EACH. USERCATALOGS WITH POINTERS*'\n DC CL121' *  WILL BE READ AND THEIR NONVSAM AND ALIAS ENTRIES WILL  *'\n DC CL121' *  ALSO BE STORED IN TABLES. AFTER ALL CATALOGS ARE READ  *'\n DC CL121' *  THE NONVSAM TABLES WILL BE INCREMENTED THROUGH AND THE *'\n DC CL121' *  VOLUMES THEY RESIDE ON WILL HAVE THE VTOCS READ. IF A  *'\n DC CL121' *  DATASET IS CATALOGED BUT NOT ON A VOLUME, IT WILL BE   *'\n DC CL121' *  UNCATALOGED (IF THE PARM WAS REQUESTED), OR LISTED FOR *'\n DC CL121' *  INFORMATION PURPOSES. IF A DATASET IS CATALOGED TO TAPE*'\n DC CL121' *  WITH NO VALID POINTER IT WILL BE UNCATALOGED (IF RE-   *'\n DC CL121' *  QUESTED) OR LISTED. IF THE DATASET EXISTS ON A DASD    *'\n DC CL121' *  VOLUME BUT IS NOT CATALOGED THEN IT WILL BE SCRATCHED  *'\n DC CL121' *  (IF PARM WAS REQUESTED AND HIGH LEVEL QUALIFIER IS IN  *'\n DC CL121' *  USERLIST), AND OR LISTED FOR INFORMATION. HIGH LEVEL   *'\n DC CL121' *  ALIAS ENTRIES THAT ARE IN THE MASTER CATALOG BUT ARE   *'\n DC CL121' *  NO LONGER VALID IN THE USERLIST WILL BE DELETED .      *'\n DC CL121' *  ALIAS ENTRIES FOR OTHER NONVSAM DATASETS WILL BE       *'\n DC CL121' *  VERIFIED AND UNCATALOGED IF NO VALID POINTER EXISTS   .*'\nENDLIST  EQU   *\n DC CL121' ***********************************************************'\n         LTORG\n         DROP  R10,R11\n         EJECT\n******************************************************************\n*  NEXT SECTION IS HERE TO PRINT THE RECORDS PRODUCED FOR DSNAMES*\n*  THAT ARE NOT CATALOGED AND MAY OR MAY NOT BE ELIGIBLE FOR     *\n*  SCRATCHING.                                                   *\n******************************************************************\n         USING DOOUT2,R15\nDOOUT2   STM   R2,R14,OUTSAVE2    SAVE THE REGS\n         LR    R10,R15            WILL USE AS ADDR. REG\n         LR    R9,R1              SAVE THE PRINT LINE ADDRESS\n         DROP  R15\n         USING DOOUT2,R10\nGETLNCT2 LH    R2,LINECNT2        RELOAD LINE COUNT\n         LTR   R2,R2              ARE WE AT TOP OF PAGE\n         BNZ   OMVEOUT2           NO, THEN DON'T PRINT HEADERS\n         LA    R2,3(R2)           INCREMENT COUNTER\n         PUT   SYSPRIN2,HEADER2A\n         MVI   0(R9),C'-'         DO A TRIPLE SPACE\nOMVEOUT2 EQU   *\n         PUT   SYSPRIN2,(9)\n         MVI   0(R9),C' '         RESET TO SINGLE SPACE\nINCROUT2 LA    R2,1(R2)           EITHER WAY INCREMENT COUNTER\n         CH    R2,MLINECNT        ARE WE AT THE MAX LINECNT\n         BL    GOBACK2            NO, THEN SAVE R2 COUNTER AS IS\n         SLR   R2,R2              YES, RESET TO 0\nGOBACK2  STH   R2,LINECNT2        STORE EITHER 0 OR COUNT\n         LM    R2,R14,OUTSAVE2    RESTORE REGS\n         BR    R14                RETURN TO NIMH\nOUTSAVE2 DS    13F\nLINECNT2 DC    H'00'\nHEADER2A DC    CL121'1       PGM-CATCLEAN          DCEC CATALOG AND VOL+\n               UME MAINTENANCE PROGRAM - VOLUME ERROR LISTING SECTION'\n         LTORG\n         DROP  R10\n******************************************************************\n*  HERE IS WHERE OUR HANDSOME TOTALS ARE CALCULATED AND PRINTED  *\n*  AS IF THIS WERE SOME SILLY ASS APPLICATION PROGRAM ALL NEAT   *\n*  AND IN ORDER. IT'S ALL FOR SHOW, BUT HEY, I LIKED IT.         *\n******************************************************************\n         USING TOTALS,R15\nTOTALS   STM   R2,R14,TOTSAVE     SAVE THE REGS\n         LR    R10,R15\n         DROP  R15\n         USING TOTALS,R10\n         PUT   SYSPRIN2,TOTHDR\n         LA    R9,TOTCAT1          POINT TO FIRST ENTRY IN TABLE\n         LA    R8,5                LOOP COUNT\n         LA    R7,TOTLCAT          POINT TO FIRST ENTRY IN OUTPUT\nLOOPTOTS MVC   30(6,R7),MASK       MOVE MASK TO PRINT LINE\n         ED    30(6,R7),0(R9)      EDIT IN THE PACKED TOTAL FOR PRINT\n         PUT   SYSPRIN2,(7)\n         LA    R9,3(R9)            INCREMENT TO NEXT TOTAL\n         LA    R7,121(R7)          INCREMENT TO NEXT PRINT LINE\n         BCT   R8,LOOPTOTS         LOOP TIL ALL DONE\n*  NEXT IS A HANDSOME LITTLE HEADER\n         PUT   SYSPRIN2,BEFAFT\n         PUT   SYSPRIN2,UNDSCRE\n         ED    NUMNVSB(6),TOTNVS1    EDIT # NVSAM BEFORE PROCESSING\n         SP    TOTNVS1(3),TOTNVS2    SUBTRACT # UNCATALOGED\n         ED    NUMNVSA(6),TOTNVS1    EDIT # NVSAM AFTER PROC. THEN PRT\n         PUT   SYSPRIN2,TOTLNVSM\n         ED    NUMHILB(6),TOTHIL1    EDIT # HILEVEL INDX BEF PROC\n         TM    FLAG2,X'10'                  IS THIS AN UNCATLG RUN\n         BZ    NOSUBHI               YES, THEN DON\"T SUBTRACT\n         SP    TOTHIL1(3),TOTHIL2    SUBTRACT # DELETED\nNOSUBHI  ED    NUMHILA(6),TOTHIL1    EDIT IN AFTER NUMBER AND PRINT\n         PUT   SYSPRIN2,TOTLHIL\n         ED    NUMALISB(6),TOTALIS1     EDIT # ALIASES BEFORE PROC\n         SP    TOTALIS1(3),TOTALIS2     SUBTRACT # UNCATALOGED\n         ED    NUMALISA(6),TOTALIS1     EDIT IN AFTER PROC # AND PRT\n         PUT   SYSPRIN2,TOTLALIS\n         ED    NUMNCTB(6),TOTNVS3      EDIT # DSNS NOT CAT\n         SP    TOTNVS3(3),TOTNVS4      SUBTRACT # SCRATCHED\n         ED    NUMNCTA(6),TOTNVS3      EDIT # AFTER PROCESSING AND PRT\n         PUT   SYSPRIN2,TOTLNCAT\n         LM    R2,R14,TOTSAVE         GO BACK TO KANSAS\n         BR    R14\nTOTSAVE  DS    13F\nMASK     DC    X'402020202021'\nTOTHDR   DC    CL121'1            TOTALS FOR CATCLEAN PROGRAM '\nTOTLCAT  DC    CL121'-   # OF CATALOGS PROCESSED - '\nTOTLVOL  DC    CL121'    # OF VOLUMES PROCESSED  - '\nTOTLUCAT DC    CL121'    # OF USER CATALOGS      - '\nTOTLCLST DC    CL121'    # OF VSAM CLUSTERS      - '\nTOTLGDG  DC    CL121'    # OF GDG BASES          - '\nBEFAFT   DC    CL121'-                              BEFORE PROCESSING  +\n                   AFTER PROCESSING '\nUNDSCRE  DC    CL121'+                              ______ __________  +\n                   _____ __________ '\nTOTLNVSM DC    CL121'0   # OF NON VSAM DATASETS  - '\n         ORG   TOTLNVSM+36\nNUMNVSB  DC    X'402020202120'\n         ORG   TOTLNVSM+58\nNUMNVSA  DC    X'402020202120'\n         ORG\nTOTLHIL  DC    CL121'    # OF HI-LEVEL INDEXES   - '\n         ORG   TOTLHIL+36\nNUMHILB  DC    X'402020202120'\n         ORG   TOTLHIL+58\nNUMHILA  DC    X'402020202120'\n         ORG\nTOTLALIS DC    CL121'    # OF DATASET ALIASES    - '\n         ORG   TOTLALIS+36\nNUMALISB DC    X'402020202120'\n         ORG   TOTLALIS+58\nNUMALISA DC    X'402020202120'\n         ORG\nTOTLNCAT DC    CL121'    # OF DSNS NOT CATALOGED - '\n         ORG   TOTLNCAT+36\nNUMNCTB  DC    X'402020202120'\n         ORG   TOTLNCAT+58\nNUMNCTA  DC    X'402020202120'\n         ORG\n         EJECT\n***************************************************************\n*  DEB  DSECT                                                 *\n***************************************************************\n*        IEZDEB\nDEBBASIC DSECT\n         ORG   DEBBASIC+16\nDEBNMEXT DS    X\n         ORG   DEBBASIC+32\nDEBDASD  DS    0D\n         ORG   DEBDASD+6\nDEBSTRCC DS    H\nDEBSTRHH DS    H\n*  IOB  DSECT                                                 *\n***************************************************************\n*        IEZIOB\nIOBSTDRD DSECT\nIOBFLAG1 DS    X\n         ORG   IOBSTDRD+3\nIOBSENS1 DS    X\nIOBS1B4  EQU   X'08',1\n         ORG   IOBSTDRD+5\nIOBECBPB DS    AL3\n         ORG   IOBSTDRD+12\nIOBUSTAT DS    X\nIOBUSB7  EQU   X'01',1\nIOBCSTAT DS    X\nIOBCSB1  EQU   X'40',1\n         ORG   IOBSTDRD+17\nIOBSTRTB DS    AL3\n         ORG   IOBSTDRD+21\nIOBDCBPB DS    AL3\n         ORG   IOBSTDRD+32\nIOBSEEK  DS    0D\n         ORG   IOBSEEK\nIOBM     DS    X\nIOBBB    DS    XL2\nIOBCC    DS    XL2\nIOBHH    DS    XL2\nIOBR     DS    X\n*        DCBD\nIHADCB   DSECT\n         ORG   IHADCB+5\nDCBFDAD  DS    CL8\n         ORG   IHADCB+18\nDCBTRBAL DS    H\n         ORG   IHADCB+45\nDCBDEBA  DS    AL3\n*        IHAECB\nIHAECB   DSECT\nECBCC    DS    X\n         DS    XL3\nECBNORM  EQU   X'7F',1\nECBPERR  EQU   X'41',1\nECBDAEA  EQU   X'42',1\n         IEFZB4D0\n         IEFZB4D2\nDS1      DSECT\n         IECSDSL1 (1)\nDS4      DSECT\n         IECSDSL1 (4)\n         IEFUCBOB\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBR3750I": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x18\\x00\\x18\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 24, "newlines": 24, "modlines": 0, "user": "WHS"}, "text": "/* REXX    */\n/* TRACE R */\n/* CBR3570I -- GENERAL MESSAGE FROM OAM                   */\n/* THIS PROGRAM RUNS WHEN A VTS IMPORT OR EXPORT STARTS   */\nARG MESSAGE\n\n\nSELECT\n\n  WHEN POS(' E0016 ',MESSAGE) > 0 THEN\n   CALL E0016\n\n  WHEN POS(' E0017 ',MESSAGE) > 0 THEN\n   CALL E0017\n\n\n  OTHERWISE\n    NOP  /* SHOULD NEVER GET HERE */\n\n  END\n\n\nEXIT\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLEANPDS": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xdd\\x00\\xdd\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 221, "newlines": 221, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'CLEANPDS - Program to cleanup duplicate PDS Members'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 24                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  NOT APF AUTHORIZED                               *\n*                                                                   *\n*  Description - Program will compare the members of two PDS data   *\n*                sets, and if PARM=DELETE is specified, it will     *\n*                delete the duplicate members in the PDSDELET DD    *\n*                statement. Without the PARM field it will report   *\n*                on the duplicate members without deleting.         *\n*                I originally wrote this because  vendor PDS files  *\n*                were being merged into a single large PDS, which   *\n*                was then placed in the LINKLIST. It caused problems*\n*                when you upgraded to a new release and wanted to   *\n*                get rid of the prior release.                      *\n*                                                                   *\n*********************************************************************\n*  DATE   - MARCH 1995                                             *\n*                                                                  *\n*  //SSCWHSPD JOB (SY0044,T,BATCH),'PROGRAMMER  ',CLASS=A,         *\n*  //  MSGCLASS=T,NOTIFY=&SYSUID                                   *\n*  //* Run without PARM=DELETE to see report and not delete members*\n*  //STEP1    EXEC PGM=CLEANPDS,REGION=0M,PARM=DELETE              *\n*  //STEPLIB  DD  DSN=your.loadlib,DISP=SHR                        *\n*  //OUTFILE  DD  SYSOUT=*                                         *\n*  //PDSINFIL DD  DISP=SHR,DSN=good.linklist.library               *\n*  //PDSDELET DD  DISP=SHR,DSN=old.linklist.library                *\n*                                                                  *\n*                                                                  *\n********************************************************************\nCLEANPDS CSECT\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRC4      EQU   4\nRC8      EQU   8\nRC16     EQU   16\n               EJECT\n****************************************************************\n*  SAVE LOGIC TO CONSERVE ON REGISTERS. R13 IS USED AS BOTH    *\n*  THE BASE REGISTER AND THE POINTER TO THE 18 WORD SAVE AREA. *\n****************************************************************\n         B     72(R15)             BRANCH AROUND THE SAVE AREA\n         DS    17F                 THIS AND THE PRIOR BR ARE 18F SAVE\n         STM   R14,R12,12(R13)     SAVE IN CALLERS SAVEAREA\n         ST    R13,4(R15)          SAVE IN OUR SAVE AREA\n         ST    R15,8(R13)          STORE OUR SAVE AREA ADDR IN THEIRS\n         LR    R13,R15             SET UP AS SAVE AND BASE REG\n         USING CLEANPDS,R13\n         L     R2,0(R1)               GET PARM ADDR\n         LH    R3,0(R2)               GET LENGTH\n         LTR   R3,R3                  ANY PARM SUPPLIED\n         BZ    NOPARM\n         CLC   2(6,R2),=C'DELETE'     IS THIS A DELETE RUN\n         BNE   NOPARM\n         OI    FLAG,X'01'             FLAG TO SAY DELETE RUN\n**************************************\n*  LETS GO AHEAD AND ACQUIRE STORAGE *\n**************************************\nNOPARM   LH   R0,HW256\n         L    R5,MEMBER_LENGTH\n         AR   R0,R5\n         ST   R0,GETMAIN_LENGTH  SAVE THIS LENGTH FOR LATER\n         GETMAIN R,LV=(0)\nGET_STORAGE ST  R1,GETMAIN_ADDRESS SAVE THE STORAGE ADDRESS\n         LR   R7,R1\n         LA   R11,256(R7)\n         ST   R11,MEMBER_ADDRESS\n*******************************************************************\nOPENDIR  EQU   *\n         OPEN  (DIRREAD)           OPEN PDS TO READ DIRECTORY\n         TM    DIRREAD+48,X'10'    OPEN SUCCESSFUL\n         BO    OPENOK              NO, THEN QUIT\n         WTO   'UNABLE TO OPEN DIRECTORY FOR INPUT MEMBERS'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK   EQU   *\n         SLR   R3,R3\nLOCSET   READ  DIRDECB,SF,DIRREAD,(7)\n         CHECK DIRDECB\nRDNXTDIR EQU   *\nLIST0    LR    R10,R7              R10 POINTS TO FIELD READ\n         LH    R9,0(R10)           R9 CONTAINS LENGTH OF RECORD\n         AR    R9,R10              POINT TO END OF LIST\n         LA    R10,2(R10)          ADDRESS MEMBER\nLIST1    CLC   0(8,R10),FFFLAG     IS THIS THE LAST DIRECTORY ENTRY\n         BE    DIRENDL             YES, THEN CLOSE IT AND GET TO WORK\nLIST2    MVC   0(8,R11),0(R10)    MOVE IN MMBR NAME,TTR, AND ALIAS BIT\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\nINCRMBRA LA    R11,8(R11)         INCR. INPUT MEMBER LIST\nGETPAST  IC    R14,11(R10)          GET # OF USER HALFWORDS\n         N     R14,FW31             ZERO OUT HI ORDER BITS\n         SLA   R14,1                MULTIPLY BY TWO\n         LA    R14,12(R14)          ADD THE CONSTANT SECTION TO IT\n         AR    R10,R14             AND THEN INCREMENT R10\n         CR    R10,R9              ARE WE AT THE END OF THIS READ\n         BL    LIST1               NO, THEN PROCESS THE NEXT\n         B     LOCSET              READ NEXT RECORD\n         EJECT\n******************************************************\n* THIS NEXT SECTION IS ENTERED IF EODAD IS HIT OR AN *\n* I/O ERROR OCCURS                                   *\n******************************************************\nNOTDIR   EQU   *\n         CLOSE DIRREAD             CLOSE DIRECTORY\n         WTO   'DIRECTORY SHOULD NOT HAVE REACHED EODAD'\n         MVI   RETCODE+3,RC8\n         B     FREE_STORAGE\n*******************************************************************\n* WE HAVE FINISHED A GOOD READING OF THE DIRECTORY AND WILL CLOSE *\n* IT, VERIFY IT HAS MEMBERS AND THEN PROCESS THE PDS              *\n*******************************************************************\nDIRENDL  MVC   0(8,R11),FFFLAG    FLAG END OF MEMBER LIST\n         CLOSE DIRREAD             CLOSE DIRECTORY\n         L     R11,MEMBER_ADDRESS  RELOAD R11 POINTER\n         LTR   R3,R3              VERIFY THAT AT LEAST 1 MEMBER EXIST\n         BNZ   OPENFILE           YES, THEN GO AND PROCESS\n         WTO   'NO MEMBERS IN PDS; FORGET IT'\n         MVI   RETCODE+3,RC8\n         B     FREE_STORAGE\n***********************************************\n*   OPEN THE PDS AND PROCESS THE MEMBER LIST  *\n***********************************************\nOPENFILE OPEN  (PDSDELET,(OUTPUT),OUTFILE,(OUTPUT))\n         TM    PDSDELET+48,X'10'  GOOD OPEN ??\n         BO    OPENOK2            YES, THEN CONTINUE EUROK\n         WTO   'UNABLE TO OPEN PDSDELET FILE FOR PROCESSING'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK2  EQU   *\n         TM    OUTFILE+48,X'10'  GOOD OPEN ??\n         BO    LOOPFIND           YES, THEN CONTINUE EUROK\n         WTO   'UNABLE TO OPEN OUTFILE FILE FOR OUTPUT'\n         MVI   RETCODE+3,RC16\n         CLOSE PDSDELET\n         B     FREE_STORAGE\nLOOPFIND EQU   *\n         MVC   MEMBER(8),0(R11)\n         MVC   MEMBER_DELETED(8),0(R11)\n         FIND  PDSDELET,MEMBER,D\n         LTR   R15,R15\n         BNZ   INCR_MEMBER\nGOODFIND EQU   *\n         TM    FLAG,X'01'\n         BZ    NO_DELETE\n*              *\n         STOW  PDSDELET,MEMBER,D\n         LTR   R15,R15\n         BZ    GOOD_DELETE\n         MVC   MEMBER_STATUS(46),DELETE_FAILED\n         B     NO_DELETE\nGOOD_DELETE  MVC   MEMBER_STATUS(46),DELETE_GOOD\nNO_DELETE EQU  *\n         PUT   OUTFILE,OUTRECD\nINCR_MEMBER    LA  R11,8(R11)\n         BCT   R3,LOOPFIND\n         CLOSE (PDSDELET,,OUTFILE)\n********************************************************************\n*   CLEANUP   TO GO HOME                                           *\n********************************************************************\nFREE_STORAGE   EQU  *\n         L     R1,GETMAIN_ADDRESS\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN R,LV=(0),A=(1)\nEXIT     L     R15,RETCODE\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nDIRREAD  DCB   MACRF=R,DSORG=PS,DDNAME=PDSINFIL,EODAD=NOTDIR,          X\n               BLKSIZE=256,LRECL=256,RECFM=F\nPDSDELET DCB   DDNAME=PDSDELET,MACRF=(R,W),DSORG=PO\nOUTFILE  DCB   DDNAME=OUTFILE,MACRF=PM,DSORG=PS,LRECL=80\nDOUBLE_WORD  DC    D'0'\nGETMAIN_ADDRESS DC F'0'\nGETMAIN_LENGTH  DC F'0'\nMEMBER_ADDRESS DC F'0'\nMEMBER_LENGTH  DC F'400000'\nRETCODE  DC    F'0'\nFW31     DC    F'31'\nMEMBER   DC    CL8' ',2F'0'\nHW1      DC    H'1'\nHW256    DC    H'256'\nHW32760  DC    H'32760'\nFFFLAG   DC    8X'FF'\nFLAG     DC    X'00'\nOUTRECD  DS    0CL80\n         DC    CL9'  MEMBER '\nMEMBER_DELETED DC    CL9' '\nMEMBER_STATUS  DC    CL62'FOUND, BUT NOT DELETED BECAUSE OF PARM VALUE'\nDELETE_GOOD    DC    CL46'SUCCESSFULLY DELETED FROM PDSDELET FILE'\nDELETE_FAILED  DC    CL46'NOT DELETED BECAUSE OF STOW ERROR'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYISPF": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x007\\x007\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 55, "newlines": 55, "modlines": 0, "user": "WHS"}, "text": "/*               REXX                                             */\n/* trace r */\n   \"FREE F(INFILE,OUTFILE)\"\n   \"ALLOC F(INFILE) DA('SYSWHS.JCL.CNTL') SHR\"\n   IF RC > 0 then\n    exit 12\n   \"ALLOC F(OUTFILE) DA('SYSWHS.JCL.CNTL2') SHR\"\n   IF RC > 0 then\n    exit 16\n\n   /*  ISPF Statistics record layout       */\n    version  = '01'x\n    level    = '00'x\n    unk      = '00'x\n    seconds  = '59'x             /* SS                    */\n    created  = '0104217F'x       /* 0YYYDDDF  e.g. 2004274*/\n    modified = '0104217F'x       /* 0YYYDDDF  e.g. 2004274*/\n    time     = '0512'x           /* HHMM                  */\n    current_count = '0000'x\n    create_count  = '0000'x\n    modified_count  = '0000'x\n    userid   = left('SYSCN1',10)    /* 8 char userid and 2 blanks */\n    dir = version||level||unk||seconds||created||modified||time||,\n          current_count||create_count||modified_count||userid\n  /*      1       5       9      13  15  17  19  21   */\n/*dir = '010000600104275F0104275F2461FFFFFFFF0000E6C8E240404040404040'X*/\n/*dir = '010000590029274F0115274F2461FFFFFFFF0000E6C8E240404040404040'X*/\n\n DIR_OK = ALXRDDIR('INFILE','MEMBER',1200)\n IF DIR_OK \u00ac= 'OK' THEN\n  DO\n   SAY 'UNABLE TO READ DIRECTORY;' DIR_OK\n   EXIT 12\n  END\n\n\n  /* Count is set to 2500 records. If larger, increase count */\n  DO I = 1 TO MEMBER.0\n   READ_OK = ALXRGETM(member.i,'INFILE','RECORD',2500)\n   IF READ_OK \u00ac= 'OK' THEN\n     SAY 'UNABLE TO READ MEMBER 'member.i';' READ_OK\n   ELSE\n    do\n     /* Get record count  */\n     count = right(d2c(record.0),2,'0'x)\n     dir   = overlay(count,dir,15,2)      /* overlay records in mem  */\n     dir   = overlay(count,dir,17,2)      /* overlay created records */\n     WRITE_OK = ALXRWRTM(member.i,'OUTFILE','RECORD',record.0,,DIR)\n    END\n  END\n\n\n    \"FREE F(INFILE,OUTFILE)\"\n EXIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COUTCPCM": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00s\\x00s\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 115, "newlines": 115, "modlines": 0, "user": "WHS"}, "text": "********************************************************************\n* AUTHOR - BILL SWEENEY                                            *\n*     SSC, INC.                                                    *\n*     WHSWEENEY@SSCMAINFRAME.COM                                   *\n*     WWW.SSCMAINFRAME.COM                                         *\n* DATE - (C) COPYRIGHT 2004                                        *\n*                                                                  *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL         *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR        *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.          *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS            *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.             *\n*                                                                  *\n* LINKAGE INFORMATION - AMODE 24                                   *\n*                  RMODE 24                                        *\n*                  NON-REENTRANT                                   *\n*                  *** APF AUTHORIZED ***                          *\n*                                                                  *\n* DESCRIPTION -                                                    *\n* THIS PROGRAM WILL ALLOW YOU TO ENTER UP TO 100 CP COMMANDS WHILE *\n* MVS   RUNS AS A GUEST UNDER VM. IT USES THE FACILITIES OF THE    *\n* DIAGNOSE INSTRUCTION AND READS THE COMMANDS AS SYSIN INPUT.      *\n********************************************************************\nCOUTCPCM CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         B     72(R15)                    SAVE LOGIC\n         DS    17F\n         STM   R14,R12,12(R13)\n         ST    R13,4(R15)\n         ST    R15,8(R13)\n         LR    R13,R15\n         USING COUTCPCM,R13\n********************************************************************\n* GET TWO PAGES OF STORAGE FOR UP TO 100 80 BYTE RECORDS.          *\n********************************************************************\n         GETMAIN EU,LV=8196,A=STRADDR1\n         L     R12,STRADDR1           LET R12 POINT TO STORAGE\n         OPEN  SYSIN\n         TM    SYSIN+48,X'10'         GOOD OPEN OF SYSIN\n         BO    GOODOPEN               YES, THEN CONTINUE\n         ABEND 400\nGOODOPEN LA    R11,100                SET A LIMIT OF 100 MEMBERS\n         SLR   R6,R6                  CLEAR R6 FOR USE AS COUNTER\nREADNEXT GET   SYSIN,(12)             READ A REACORD\n         LA    R12,80(R12)            POINT TO NEXT POSITION\n         LA    R6,1(R6)               KEEP TRACK OF HOW MANY READ\n         BCT   R11,READNEXT           DO UP TO 100 COMMANDS\nEODGET   CLOSE SYSIN                  CLOSE HIM\n         LTR   R6,R6                  WERE THERE ANY COMMANDS\n         BZ    FREESTOR               NO, THEN JUST QUIT\n*********************************************************************\n* SORRY FOR THE MODESET PEOPLE BUT WE NEED TO ISSUE PRIVELEGED      *\n* INSTRUCTIONS, SO WE WILL TRY TO BE QUICK, AND ONLY SET IT ONCE.   *\n*********************************************************************\n         MODESET MODE=SUP,KEY=ZERO\n         STIDP DOUBLE           STORE CPUID\n         CLI   DOUBLE,X'FF'     IF FIRST CHARACTER FF THEN UNDER VM\n         BNE   CHGMODE          NO, THEN DO NOT DIAGNOSE\n         L     R12,STRADDR1     R12 POINT BACK TO FIRST RECORD\nENDREC   LA    R11,70(R12)      POINT TO END OF COMMAND RECORD\n         LA    R9,71            TOTAL LENGTH OF 71\nLOOPEND  CLI   0(R11),C' '      IS IT A NON BLANK OR LESS ENTRY ?\n         BH    GOTEND           IF GT THEN WE GOT END OF RECORD\n         BCTR  R11,0            NO, DECREMENT R11 BY 1\n         BCT   R9,LOOPEND       LOOP THRU RECORD\n         B     NEXTREC          IF WE FALL THRU THEN NO CMD TO ISSUE\nGOTEND   SR    R11,R12          GET LENGTH OF COMMAND-1 INTO R11\n********************************************************************\n* PLEASE DO NOT LET THIS NEXT MOVE CONFUSE YOU, BUT WHEN TRYING TO *\n* ISSUE A DIAGNOSE INSTR THAT DOES A LOAD REAL ADDR (LRA) TO       *\n* GETMAINED STORAGE NOTHING HAPPENS. I THEREFORE TOOK THE COMMAND  *\n* AND MOVED IT INTO STORAGE LOCATED WITHIN THE BOUNDS OF THIS      *\n* PROGRAM. GO FIGURE.                                              *\n********************************************************************\n         EX    R11,MVCVMCM      MVC  VMCMD(0),O(R120\nVERDEV   LRA   R8,VMCMD         LOAD R8 WITH REAL ADDR OF CMD\n         LA    R10,1(R11)       GET THE LENGTH IN R10\n         DC    X'838A0008'      ISSUE DIAGNOSE COMMAND\n*\n*  WAIT ONESEC CPU BETWEEN COMMANDS\n*\n         STIMER WAIT,,BINTVL=ONESEC\nNEXTREC  LA    R12,80(R12)       POINT TO NEXT RECORD\n         BCT   R6,ENDREC         LOOP THRU TIL DONE\nCHGMODE  EQU   *\n         MODESET MODE=PROB,KEY=NZERO\nFREESTOR EQU   *\n         FREEMAIN EC,LV=8196,A=STRADDR1\nRETURN   EQU   *\n         L     R13,4(R13)\n         LM    R14,R12,12(R13)\n         SLR   R15,R15          CLEAR R15 TO SHOW GOOD RC\n         BR    R14\nSYSIN    DCB   DDNAME=SYSIN,MACRF=GM,EODAD=EODGET,DSORG=PS\nMVCVMCM  MVC   VMCMD(0),0(R12)\nDOUBLE   DC    D'0'\nONESEC   DC    F'100'\nSTRADDR1 DC    F'0'\nVMCMD    DC    CL71' '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COUTLOGC": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xd1\\x00\\xd1\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 209, "newlines": 209, "modlines": 0, "user": "WHS"}, "text": "********************************************************************\n* AUTHOR - BILL SWEENEY                                            *\n*     SSC, INC.                                                    *\n*     WHSWEENEY@SSCMAINFRAME.COM                                   *\n*     WWW.SSCMAINFRAME.COM                                         *\n* DATE - (C) COPYRIGHT 2004                                        *\n*                                                                  *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL         *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR        *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.          *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS            *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.             *\n*                                                                  *\n* LINKAGE INFORMATION - AMODE 31                                   *\n*                  RMODE 24                                        *\n*                  NON-REENTRANT                                   *\n*                  NOT APF AUTHORIZED                              *\n*                                                                  *\n* PROGRAM - PROGRAM TO CREATE TAPE MULTI-FILE GDGS                 *\n* DESCRIPTION - THIS PROGRAM WILL READ THE GDG NAME OF THE LOGFILE *\n*          DD STATEMENT, LOCATE THE PREVIOUS GDG, GET THE TAPE     *\n*          VOLSER AND FILESEQ # OF THE PREVIOUS GDG AND UPDATE THE *\n*          THE LOGFILE JFCB TO USE THE SAME TAPE AND NEXT FILESEQ# *\n*          PROGRAM IS BEING USED TO OFFLOAD WEEKLY SYSLOG DATA AND *\n*          CREATE MONTHLY GDGS FOR SMF.                            *\n********************************************************************\nCOUTLOGC CSECT\n         PRINT ON,NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRC16     EQU   16\n         B     72(R15)             BRANCH AROUND SAVE AREA\n         DS    17F                 SAVE AREA\n         STM   R14,R12,12(R13)     SAVE REGS\n         ST    R13,4(R15)          CHAIN SAVE AREAS\n         ST    R15,8(R13)          BACK CHAIN SAVE AREAS\n         LR    R13,R15             LOAD BASE\n         USING COUTLOGC,R13\n         SPACE 1\n         L     R3,0(R1)            GET ADDR OF PARMS\n         LH    R5,0(R3)            GET LENGTH OF PARMS\n         LTR   R5,R5               ARE THERE ANY PARMS\n         BZ    OPENOKS             NO, THEN GO AROUND\n         CH    R5,=H'3'            MAKE SURE NOT BIGGER THAN 3 DIGITS\n         BNH   DECRR5              NO, THEN JUST GO AROUND\n         WTO   'PARM FILE COUNT CANNOT EXCEED THREE DIGITS'\n         MVI   RTCODE+3,X'10'      MOVE IN RC 16\n         B     RETURN              AND QUIT\nDECRR5   BCTR  R5,0                DECREMENT FOR EXECUTE FOR PACK L2\n         LA    R4,1                GET LEGNTH OF 2 FOR PACK L1\n         SLL   R5,28               SHIFT UP TO HALF BYTE POSITION\n         SLDL  R4,4                THEN SHIFT INTO R4\n         EX    R4,PACKIT           PACK DOUBLE+6(0),2(R3)\n         CVB   R6,DOUBLE           CONVERT IT ALL TO BINARY\n         STH   R6,FILECNT          AND SAVE FOR LATER COMPARE\nOPENOKS  EQU   *\n         SLR   R9,R9               CLEAR R9 FOR FILECOUNT\n*******************************************************************\n*  WE ARE GOING TO GET A BLOCK OF STORAGE BIG ENUF FOR OUR I/O,   *\n* AND THEN WE ARE GOING TO GET THE FILESEQ # AND VOLSER OF THE    *\n* GDG FILE TO BE USED.                                            *\n*******************************************************************\n         GETMAIN EC,LV=32760,A=STRADDR1\n         LTR   R15,R15             HOPEFULLY WE GOT THE STORAGE\n         BNZ   NOLOD15             NO, THEN QUIT AND USE THAT AS RC\nSAVESTR  L     R11,STRADDR1        LOAD R11 WITH GETMAINED STORGE ADDR\n         RDJFCB MF=(E,OPENLIST)\n         LTR  R15,R15              CHECK IF GOOD READ\n         BZ   GOODRDJF             IF, NOT THEN DEFAULT TO SCR FILE1\n         ABEND 001,DUMP            JUST QUIT\nGOODRDJF MVC  WORKDSN(44),JFCBAREA     MOVE IN THE DSNAME FOR LOCATE\n         LA   R15,WORKDSN+43        POINT TO END OF DSNAME\n         LA   R14,44                MAX LENGTH OF DSNAME\nLOOP_WORKDSN  CLI 0(R15),C' '       LOOK FOR LAST CHARACTER\n         BNE  GOT_DSNEND            IF NOT BLANK THEN FOUND IT\n         BCTR R15,0                    DECR COUNT\n         BCT  R14,LOOP_WORKDSN         LOOP THRU NAME\n         B    BADDSN                   GO ABEND\nGOT_DSNEND    SH  R15,=H'8'            SUBTRACT TO LOCATE GDG\n         CLC  0(2,R15),=C'.G'          IS IT A VALID GDG\n         BE   PACKDSN                  LOOKS GOOD THEN CONTINUE\nBADDSN   ABEND 002,DUMP                JUST ABEND\nPACKDSN  PACK DOUBLE(8),2(4,R15)       PACK THE GDG VALUE\n         SP   DOUBLE(8),PACK1(1)       SUBTRACT ONE\n         UNPK GDGVALUE(5),DOUBLE+5(3)  UNPACK IT\n         OI   GDGVALUE+4,X'F0'         TURN ON SIGN BITS\n         MVC  2(4,R15),GDGVALUE+1      MOVE IN THE DECRMENTED VALUE\n         LOCATE BIGCAM\n         LTR  R15,R15                  DOES THIS GDG EXIST\n         BNZ  SCRATCH                  NO, THEN THE +1 IS FIRST GDG\n         LH   R9,WORKFILE              STORE THE CURRENT FILE SEQ#\n         CH   R9,FILECNT           COMPARE TO FILE COUNT LIMIT\n         BNL  SCRATCH              IF GT OR EQ TO THEN JUST USE A SCR\n         CLI  VOLCOUNT+1,X'01'       IS VOLUME COUNT GT 1\n         BH   SCRATCH                  THEN USE A NEW SCRATCH\n         MVC  VOLSER(6),WORKVOL        MOVE IN THE VOLSER\nSCRATCH  EQU  *\n         OPEN DISKFILE\n         TM   DISKFILE+48,X'10'     WAS IT A GOOD OPEN\n         BO   OKOPEN                YES, THEN KEEP GOING\n         WTO  'UNABLE TO OPEN DISKFILE DDNAME'\n         MVI  RTCODE+3,RC16         MOVE IN RETURN CODE 16\n         B    RETURN                FORGET IT AND QUIT\nOKOPEN   EQU  *\n* SET THE OUTPUT DCB ATTRIBUTES FROM INPUT DISK FILE\n         MVC  LOGFILE+62(2),DISKFILE+62           SET THE BLOCKSIZE\n         MVC  LOGFILE+82(2),DISKFILE+82           AND THE LRECL\n         MVC  LOGFILE+36(1),DISKFILE+36           AND THE RECFM\n         CLI  VOLSER,C' '              DO WE WANT A SCRATCH FILE\n         BE   OPENOUT                  YES, THEN DO NOT RESET JFCB\n         CLI  DEVTYPE+2,X'20'          IS THIS A DASD DATASET\n         BE   OPENOUT                  YES, THEN DO NOT RESET JFCB\n**************************************************************\n*  OPEN TYPE J WILL USE THE MODIFIED JFCB TO OPEN THE OUTPUT *\n* FILE WITH THE TAPE VOLSER AND THE INCREMENTED FILE SEQUENCE*\n* NUMBER.                                                    *\n**************************************************************\nGOODRDJ2 LA   R9,1(R9)             INCR TO NEXT FILESEQ #\n         STH  R9,JFCBAREA+68           STORE THE CURRENT FILE SEQ#\n         MVC  JFCBAREA+118(6),VOLSER        MOVE IN VOLSER\n         OI   JFCBAREA+76,X'80'        FLAG FOR RE-WRITE OF JFCB\n         OPEN TYPE=J,MF=(E,OPENLIST)\n         B    CHKOUT              BR AROUND AND CHECK OPEN\nOPENOUT  OPEN (LOGFILE,(OUTPUT))\nCHKOUT   TM   LOGFILE+48,X'10'        GOOD OPEN ?\n         BO   READNXT               HURRAY FOR OUR SIDE\n         ABEND 003,DUMP\n*******************************************************************\n*  NEXT SECTION READS A BLOCK FROM THE DISK FILE, GETS THE PROPER *\n* LENGTH AND WRITES IT TO TAPE FILE.                              *\n*******************************************************************\nREADNXT  EQU  *\n         READ DISKDECB,SF,DISKFILE,(11)\n         CHECK DISKDECB\n         LH   R4,DISKFILE+62            GET BLKSIZE\n         L    R5,DISKDECB+16            IOB ADDR\n         SH   R4,14(R5)                 LENGTH OF BLOCK READ\n         LH   R3,LOGFILE+62         GET BLKSIZE IN CASE OF SHORT BLK\n         STH  R4,LOGFILE+62          BLKSIZE OF BLK JUST READ\n         OI    FLAG,X'01'            FLAG TO SAY AT LEAST READ 1 BLK\n         WRITE OUTDECB,SF,LOGFILE,(11)\n         CHECK OUTDECB\n         STH   R3,LOGFILE+62         PUT BACK THE OLD BLKSIZE\n         B    READNXT                LOOP TIL END OF FILE\nEOFILE   CLOSE DISKFILE\n         CLOSE (LOGFILE)\n         FREEMAIN EC,LV=32760,A=STRADDR1\n         TM    FLAG,X'01'            DID WE AT LEAST READ ONE BLK\n         BZ    RETURN                NO, THEN JUST QUIT\n****************************************************************\n*  THE FOLLOWING TWO MACROS WILL OPEN THE FILE FOR OUTPUT, THUS*\n*  RESETTING THE EOF MARKER TO THE BEGINNING OF THE FILE , OR  *\n*  CLEARING IT. THE CLOSE JUST CLEANS IT ALL UP SO WE CAN GO   *\n*  HOME.                                                       *\n****************************************************************\n         OPEN  (DISKFIL2,(OUTPUT))\n         CLOSE DISKFIL2\nRETURN   L     R15,RTCODE\nNOLOD15  L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n        EJECT\nDISKFILE DCB   DDNAME=DISKFILE,DSORG=PS,MACRF=R,                       X\n               EODAD=EOFILE\nDISKFIL2 DCB   DDNAME=DISKFILE,DSORG=PS,MACRF=W\nLOGFILE  DCB   DDNAME=LOGFILE,DSORG=PS,MACRF=W,                        X\n               EXLST=JFCBLIST\nOPENLIST OPEN  (LOGFILE,(OUTPUT)),MF=L\nJFCBLIST DS    0F\n         DC    X'07'\n         DC    AL3(JFCBAREA)\n         DC    X'FF'\nJFCBAREA DS    0F,176C\nDOUBLE   DC    D'0'\nSTRADDR1 DC    F'0'\nRTCODE   DC    F'0'\nFILECNT  DC    H'52'\nPACKIT   PACK  DOUBLE+6(0),2(0,R3)\nBIGCAM   CAMLST NAME,WORKDSN,,WORKAREA\nGDGVALUE DC    CL5' '\nPACK1    DC    PL1'1'\nVOLSER   DC    CL6' '\nFLAG     DC    X'00'\n         LTORG\nWORKDSN  DC   CL44' '\n         DS   0F\nWORKAREA DC   256X'00'\n         ORG  WORKAREA\nVOLCOUNT DS   H\nDEVTYPE  DS   4X\nWORKVOL  DS   CL6\nWORKFILE DS   H\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DASDBOX": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01}\\x01}\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 381, "newlines": 381, "modlines": 0, "user": "WHS"}, "text": "/* REXX  EXEC TO PROCESS DASD AND CREATE A LIST IN BOXES       */\n/* TRACE RESULTS */\n/* Arguments are VOLUME to sort by volume, or STORAGE to sort  */\n/* by Storage Group and volume, or default sorted by unit addr */\n  parse upper arg sort_criteria\n  NUMERIC DIGITS 16\n  stat = msg('off')\n \"FREE F(OUT)\"\n\n OFFL_COUNT = 0\n MOD3_COUNT = 0\n MOD9_COUNT = 0\n HYP1_COUNT = 0\n HYP2_COUNT = 0\n MISC_COUNT = 0\n MISC_TOTAL = 0\n\n  HDRRECD.1 = '1      DASD  System-'MVSVAR(SYSNAME),\n               '('subword(MVSVAR('SYSOPSYS'),1,2)')  ' date('u') ' ' time()\n  HDRRECD.2 = ' '\n  select\n   when sort_criteria = 'VOLUME' then\n    HDRRECD.2 = '                              Sorted by Volume'\n   when sort_criteria = 'STORAGE' then\n    HDRRECD.2 = '                     Sorted by Storage Group and Volume'\n   otherwise nop\n  end\n\n  /* This requires the Assembler REXX function  ALXRDASD  */\n  SCAN_OK = ALXRDASD('DASDREC')\n IF SCAN_OK \u00ac= 'OK' THEN\n  DO\n   SAY SCAN_OK\n   EXIT 12\n  END\n  if sort_criteria = 'VOLUME' then\n   call sort_dasdrec\n\n  /* Make sure that IDCAMS is authorized to be called in IKJTSOxx */\n  /* by defining it in the AUTHPGM section                        */\n  call process_dcollect\n\n count = 0              /* outrecd. counter           */\n page_count = 0         /* page  counter              */\n\n/* Table consists of eight columns of DASD volumes in eight rows, */\n/* at 64 addresses per page. A channel in the channel field, 2nd  */\n/* byte of UCB, will also drive creation of a new page            */\n call build_table          /* Build the first box table  */\n\n do dd = 1 to dasdrec.0\n  IF WORD(DASDREC.DD,1) = 'ON' THEN\n   CALL PROCESS_VOLUME\n end\n\n  if sort_criteria = 'STORAGE' then\n   call sort_dcollect\n\n /* Loop through DASD volumes and fill the boxes   */\n DO I = 1 TO DASDREC.0\n  if i = 1 then\n   current_channel = SUBSTR(word(dasdrec.1,2),2,1)\n\n/*IF WORD(DASDREC.I,1) = 'ON' THEN\n   CALL PROCESS_VOLUME */\n\n  PARSE VAR DASDREC.I STATUS UCB VSN SIZE IX STOREGRP FREE RMNDR\n  FREE = FREE'% fr'\n  CHANNEL = SUBSTR(UCB,2,1)\n  CALL PROCESS_COUNT\n\n  if channel \u00ac= current_channel & sort_criteria \u00ac= 'VOLUME' &,\n     channel \u00ac= current_channel & sort_criteria \u00ac= 'STORAGE' then\n   do\n    current_channel = channel\n    call write_table             /* Write table and build another  */\n   end\n\n  call build_box               /* Go and write info for this disk */\n\n END\n\n if row > 2 & row < 44 then\n  call write_table\n/*  trace results */\n call process_total\n\n \"ALLOC F(OUT) SYSOUT(X) RECFM(F A) LRECL(121)\"\n\n  total_begin = 52\n/*say page_count   count */\n  do xx = 1 to page_count\n   outrecd.total_begin = totrecord.1\n   next = total_begin + 1\n   outrecd.next = totrecord.2\n   total_begin = total_begin + 53\n  end\n  \"EXECIO\" COUNT \"DISKW OUT (STEM outrecd. FINIS)\"\n  \"FREE F(OUT)\"\n\nEXIT\n\n/*******************************************************/\nPROCESS_DCOLLECT:\n/* trace r */\n \"free f(sysin,sysprint)\"\n/* \"ALLOC F(SYSPRINT) SYSOUT(X)\" */\n \"ALLOC F(SYSPRINT) DSN('NULLFILE') SHR REUSE\"\n/*  \"ALLOC F(SYSPRINT) DA(SYSPRINT) SHR REUSE\" */\n \"ALLOC F(SYSIN) NEW LRECL(80) REUSE\"\n QUEUE ' DCOLLECT VOLUMES(*) OUTFILE(OUTDS) NODATAINFO'\n QUEUE ''\n \"EXECIO * DISKW SYSIN (FINIS\"\n\n \"ALLOC F(OUTDS) NEW LRECL(264) RECFM(V B) REUSE\"\n \"CALL *(IDCAMS)\"\n \"EXECIO * DISKR OUTDS (STEM DC. FINIS\"\n \"FREE F(OUTDS)\"\nRETURN\n\n/*******************************************************/\nPROCESS_VOLUME:\n VOLUME = WORD(DASDREC.DD,3)\n DO X = 1 TO DC.0\n  IF SUBSTR(DC.X,25,6) = VOLUME THEN\n   DO\n    STORE_GRP = SUBSTR(DC.X,83,8)\n    IF STORE_GRP = '        ' THEN\n     STORE_GRP = 'NON_SMS  '\n    PCT_FREE  = C2D(SUBSTR(DC.X,36,1))\n    DASDREC.DD = DASDREC.DD LEFT(STORE_GRP,8) PCT_FREE\n    return\n   END\n END\nRETURN\n\n/*******************************************************/\nPROCESS_COUNT:\n SELECT\n   WHEN STATUS = 'OFF'  THEN\n    DO\n     OFFL_COUNT = OFFL_COUNT + 1\n     TYPE = 'OFFLINE'\n     VSN = ' '\n    END\n   WHEN SIZE = '3340' | SIZE = '3339'  THEN\n    DO\n     MOD3_COUNT = MOD3_COUNT + 1\n     TYPE = 'MODEL3'\n    END\n   WHEN SIZE = '10020'  THEN\n    DO\n     MOD9_COUNT = MOD9_COUNT + 1\n     TYPE = 'MODEL9'\n    END\n   WHEN SIZE = '501' THEN\n    DO\n     HYP1_COUNT = HYP1_COUNT + 1\n     TYPE = 'HYPER1'\n    END\n   WHEN SIZE = '521' THEN\n    DO\n     HYP2_COUNT = HYP2_COUNT + 1\n     TYPE = 'HYPER2'\n    END\n   OTHERWISE\n    DO\n     MISC_COUNT = MISC_COUNT + 1\n     MISC_TOTAL = MISC_TOTAL + SIZE\n     TYPE = SIZE\n    END\n  END\n RETURN\n\n/*******************************************************/\nwrite_table:\n\n count = count + 1\n outrecd.count = hdrrecd.1 '  Page -' page_count\n count = count + 1\n outrecd.count = hdrrecd.2\n\n do wr = 1 to tsfx\n  count = count + 1\n  outrecd.count = table.wr\n end\n\n count = count + 1\n outrecd.count = ' '   /* this will be Total Record  1  */\n count = count + 1\n outrecd.count = ' '   /* this will be Total Record  2  */\n\n call build_table\nreturn\n\n/*******************************************************/\nbuild_table:\n\n page_count = page_count + 1\n\nL1=' ________ ________ ________ ________ ________ ________ ________ ________ '\nL2='|        |        |        |        |        |        |        |        |'\nL3='|________|________|________|________|________|________|________|________|'\n\n col = 6         /* Set the starting location column pointer */\n row = 2         /* Set the starting location row pointer    */\n\n tsfx = 1\n\n TABLE.tsfx = ' ' L1\n DO T = 1 TO 8\n  DO TT = 1 TO 5\n   tsfx = tsfx + 1\n   TABLE.tsfx = ' ' L2\n  END\n  tsfx = tsfx + 1\n  TABLE.tsfx = ' ' L3\n END\n\nreturn\n\n/*******************************************************/\nbuild_box:\n\n START_COL1 = col\n START_COL2 = col - 1\n START_COL3 = col - 2      /*GET THE STORAGE GRP NAME IN 1ST COL*/\n START_COL4 = col - 1\n START_COL5 = col - 1\n START_ROW  = ROW\n START_ROW2 = START_ROW + 1\n START_ROW3 = START_ROW + 2\n START_ROW4 = START_ROW + 3\n START_ROW5 = START_ROW + 4\n\n TABLE.START_ROW = OVERLAY(UCB,TABLE.START_ROW,START_COL1)\n TABLE.START_ROW2 = OVERLAY(VSN,TABLE.START_ROW2,START_COL2)\n TABLE.START_ROW3 = OVERLAY(STOREGRP,TABLE.START_ROW3,START_COL3)\n TABLE.START_ROW4 = OVERLAY(TYPE,TABLE.START_ROW4,START_COL4)\n IF STATUS = 'ON' THEN\n  TABLE.START_ROW5 = OVERLAY(FREE,TABLE.START_ROW5,START_COL5)\n\n col = col + 9         /* Increment to next box column  */\n if col > 69 then      /* If GT 69 then start new row   */\n  do\n   col = 6             /* Reset to first box            */\n   row = row + 6       /* Increment to next row         */\n   if row > 44 then    /* If row is GT then new page    */\n    call write_table   /* Go and build                  */\n  end\n return\n\n/*******************************************************/\nprocess_total:\n  TOTAL_SIZE = (MOD3_COUNT * 2.838) + (MOD9_COUNT * 8.514),\n               + (HYP1_COUNT * .424) + (HYP2_COUNT * .441),\n               + (MISC_TOTAL * .0008)\n  TOTRECORD.1 = '0  TOTAL OF' FORMAT(TOTAL_SIZE,,2)'GB  ',\n                MOD3_COUNT' 3390-3(2.838GB) AND',\n                MOD9_COUNT' 3390-9(8.514GB) AND'\n  TOTRECORD.2 = '                        ',\n                HYP2_COUNT' HYPER2(.441GB)  AND',\n                HYP1_COUNT' HYPER1(.424GB)'\n\nreturn\n\n/*******************************************************/\nSORT_DASDREC:\n call convert_hex\n DO S = 1 TO dasdrec.0\n  Y = S + 1\n  DO Z = Y TO dasdrec.0\n   select\n\n    when WORD(dasdrec.S,1) = 'OFF' & WORD(dasdrec.Z,1) = 'ON' then\n     DO\n      HOLD = dasdrec.S\n      dasdrec.S = dasdrec.Z\n      dasdrec.Z = HOLD\n     END\n\n    when WORD(dasdrec.S,1) = 'ON' & WORD(dasdrec.Z,1) = 'ON' then\n     DO\n      if WORD(dasdrec.S,3) > WORD(dasdrec.Z,3) then\n       do\n        HOLD = dasdrec.S\n        dasdrec.S = dasdrec.Z\n        dasdrec.Z = HOLD\n       END\n     END\n\n\n    when WORD(dasdrec.S,1) = 'OFF' & WORD(dasdrec.z,1) = 'OFF' then\n     DO\n      if WORD(dasdrec.S,2) > WORD(dasdrec.Z,2) then\n       do\n        HOLD = dasdrec.S\n        dasdrec.S = dasdrec.Z\n        dasdrec.Z = HOLD\n       END\n     END\n\n    otherwise nop\n   END\n  END\n END\n call convert_back\nRETURN\n\n\n/*******************************************************/\nSORT_DCOLLECT:\n call convert_hex\n DO S = 1 TO dasdrec.0\n  Y = S + 1\n  DO Z = Y TO dasdrec.0\n   select\n\n    when WORD(dasdrec.S,1) = 'OFF' & WORD(dasdrec.Z,1) = 'ON' then\n     DO\n      HOLD = dasdrec.S\n      dasdrec.S = dasdrec.Z\n      dasdrec.Z = HOLD\n     END\n\n    when WORD(dasdrec.S,1) = 'ON' & WORD(dasdrec.Z,1) = 'ON' then\n     DO\n      select\n       when WORD(dasdrec.S,6) > WORD(dasdrec.Z,6) then\n        do\n         HOLD = dasdrec.S\n         dasdrec.S = dasdrec.Z\n         dasdrec.Z = HOLD\n        END\n       when WORD(dasdrec.S,6) = WORD(dasdrec.Z,6) then\n        do\n         if WORD(dasdrec.S,3) > WORD(dasdrec.Z,3) then\n          do\n           HOLD = dasdrec.S\n           dasdrec.S = dasdrec.Z\n           dasdrec.Z = HOLD\n          END\n        END\n       otherwise nop\n      end\n     END\n\n\n    when WORD(dasdrec.S,1) = 'OFF' & WORD(dasdrec.z,1) = 'OFF' then\n     DO\n      if WORD(dasdrec.S,2) > WORD(dasdrec.Z,2) then\n       do\n        HOLD = dasdrec.S\n        dasdrec.S = dasdrec.Z\n        dasdrec.Z = HOLD\n       END\n     END\n\n    otherwise nop\n   END\n  END\n END\n call convert_back\nRETURN\n\n/*******************************************************/\nconvert_hex:\n\n do xx = 1 to dasdrec.0\n  dasdrec.xx = word(dasdrec.xx,1) x2d(word(dasdrec.xx,2)) subword(dasdrec.xx,3)\n end\nreturn\n\n/*******************************************************/\nconvert_back:\n\n do xx = 1 to dasdrec.0\n  dasdrec.xx = word(dasdrec.xx,1) right(d2x(word(dasdrec.xx,2)),4,0),\n  subword(dasdrec.xx,3)\n end\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EZACICSE": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00f\\x00f\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 102, "newlines": 102, "modlines": 0, "user": "WHS"}, "text": "         TITLE 'EZACICSE - CICS Sockets Listener Exit'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 31                                    *\n*                  RMODE 24                                         *\n*                  REENTRANT                                        *\n*                  CICS Command Level                               *\n*                                                                   *\n*  DESCRIPTION - CICS Listener security exit. CICS Command Level    *\n*                Assembler.                                         *\n*                                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n***********************************************************************\n         DFHEISTG\nCOMPTR   EQU   4                   POINTER TO COMMAREA\nRESP_1   DS    F\nRESP_2   DS    F\nJOBNAME  DS    CL8\nEZACICSE CSECT\n*\n*        THE LENGTH OF THE \"COMMAREA\" IS TESTED. IF ZERO, WHICH IT\n*        SHOULDN'T BE, THEN WE'LL EXIT; OTHERWISE, PROCESS.\n*\n         LH    COMPTR,EIBCALEN     HAS A COMMAREA BEEN RETURNED?\n         LTR   COMPTR,COMPTR\n         BZ    RETURN              ...NO, THEN JUST EXIT\n*\n*\n         L     COMPTR,DFHEICAP     GET ADRESSABILITY TO COMMAREA\n         USING EXITDATA,COMPTR\n*\n         MVI   CLIENT_SWITCH2,C'1'    CICS LISTENER SENDS MSG TO CLIENT\n*\n         EXEC  CICS INQUIRE SYSTEM JOBNAME(JOBNAME)                    X\n               RESP(RESP_1) RESP2(RESP_2)\n*\n         CLC   JOBNAME(8),PRODCICS\n         BNE   CHECK_IPDEVL\n         CLC   CLIENT_IPADDRESS(4),PROD_SERVER_IPADDRESS\n         BNE   FAILIT\n         B     CHECK_TRANS\nCHECK_IPDEVL   EQU  *\n         CLC   CLIENT_IPADDRESS(4),DEVL_SERVER_IPADDRESS\n* The next 2 instructions were to test their production IP address\n*  Commented out for production implementation  WHS  23 May 2001\n*        BE    CHECK_TRANS\n*        CLC   CLIENT_IPADDRESS(4),PROD_SERVER_IPADDRESS\n         BNE   FAILIT\nCHECK_TRANS    EQU  *\n*  We're going to verify all four bytes\n         CLC   CLIENT_TRANSACTION(4),SERVER_TRANSACTION\n*        CLC   CLIENT_TRANSACTION(3),SERVER_TRANSACTION\n         BNE   FAILIT\n         MVI   CLIENT_SWITCH,C'1'     PERMIT THE TRANSACTION\n         MVC   CLIENT_TERMID(4),SERVER_TERMID\n         B     RETURN\n*\nFAILIT   MVI   CLIENT_SWITCH,C'0'     DO NOT PERMIT THE TRANSACTION\n*\n*        THE PROGRAM TERMINATES BY RETURNING TO CICS.\n*\nRETURN   EQU  *\n         EXEC CICS RETURN\n*\nPRODCICS               DC   CL8'PRODCICS'\n* I changed these IP addresses to distribute this source\n* Have them match what you are doing\nPROD_SERVER_IPADDRESS  DC   X'64646464'          100.100.100.100\nDEVL_SERVER_IPADDRESS  DC   X'64646465'          100.100.100.101\n* Next IP was used to test application talking w/in OS/390\n*WDEVL_IPADDRESS   DC   X'64646466'          100.100.100.102\nSERVER_TRANSACTION DC  CL4'ZLIS'            TRANSACTION\nSERVER_TERMID     DC   CL4'ZZZZ'            PICKED ONE FOR NOW\n*\n         LTORG\nEXITDATA DSECT\nCLIENT_TRANSACTION    DS  CL4\nCLIENT_DATAAREA       DS  CL40\nCLIENT_ACTION         DS  CL2\nCLIENT_INTERVALCNTL   DS  CL6\nCLIENT_ADDRESS        DS  H\nCLIENT_PORT           DS  H\nCLIENT_IPADDRESS      DS  F\nCLIENT_SWITCH         DS  X\nCLIENT_SWITCH2        DS  X\nCLIENT_TERMID         DS  CL4\nCLIENT_SOCKET_DESC    DS  H\nCLIENT_USERID         DS  CL8\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E0016": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00r\\x00r\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 114, "newlines": 114, "modlines": 0, "user": "WHS"}, "text": "/* REXX */\n/*  TRACE R */\n arg message\n\n /* This EXEC was written to process the following message. It      */\n /* tracks the time difference and count of E0016 messages, and     */\n /* when it hits six (50 minutes), it will ask the Operator to      */\n /* use the VTS CALL HOME feature on the Library Manager.           */\n /*MSG = 'CBR3750I MESSAGE FROM LIBRARY VTSLIB  : E0016 COPYING ',  */\n /*      ' LOGICAL EXPORT VOLUMES FROM CACHE TO STACKED VOLUMES.'   */\n\n /* Record consists of message as 1st word (i.e. E0016 or E0017),   */\n /* followed by the date, time and count. When returned record has  */\n /* E0016, then the current date/time is subtracted from the saved  */\n /* date/time in the record, and the difference is checked. If less */\n /* than 15 minutes, count is updated and record written back.      */\n\n /* See if record exists in file  */\n\n OK = SAVEVGET('E0016')\n\n /* No, then create  file  */\n IF OK = 8 THEN\n  DO\n   E0016 = 'E0016' DATE('S') TIME('N') 1\n   SAVEVPUT('E0016')\n  END\n\n ELSE\n\n  DO\n   TIMEDIFF = SUBTTIME(WORD(E0016,2),WORD(E0016,3),DATE('S'),TIME('N'))\n   select\n\n    when word(E0016,1) = 'E0017' then\n     do\n      E0016 = 'E0016' DATE('S') TIME('N') 1\n      ok = savevput('E0016')\n     end\n\n    when word(timediff,2) = 'minutes' & word(timediff,1) < 15 &,\n         word(E0016,4) > 4 then\n     do\n      E0016 = 'E0016' DATE('S') TIME('N') -3    /* Give more  */\n      ok = savevput('E0016')\n      call contact_systems\n     end\n\n    when word(timediff,2) = 'minutes' & word(timediff,1) < 15 &,\n         word(E0016,4) < 5 then\n     do\n      E0016 = 'E0016' DATE('S') TIME('N')  (word(e0016,4)+1)\n      ok = savevput('E0016')\n     end\n\n    otherwise\n     do\n      E0016 = 'E0016' DATE('S') TIME('N') 1\n      ok = savevput('E0016')\n     end\n    end\n   end\n\nEXIT\n/*******************************************************************/\nSAVEVGET:\n\n ARG VAL1\n STAT = MSG(\"OFF\")\n DSN = 'SYSX.OPSAUTO.SAVEVAR.'VAL1\n \"FREE F(SAVEVAR)\"\n \"ALLOC F(SAVEVAR) DA('\"DSN\"') SHR\"\n IF RC > 0 THEN\n  RETURN 8\n \"EXECIO * DISKR SAVEVAR (STEM SAVEVGET. FINIS\"\n  \"FREE F(SAVEVAR)\"\n  INTERPRET VAL1 '= SAVEVGET.1'\n  STAT = MSG(\"ON\")\n RETURN 0\n\n/*******************************************************************/\nSAVEVPUT:\n\n ARG VAL1\n STAT = MSG(\"OFF\")\n DSN = 'SYSX.OPSAUTO.SAVEVAR.'VAL1\n \"FREE F(SAVEVAR)\"\n\"ALLOC F(SAVEVAR) DA('\"DSN\"') SHR\"\n IF RC > 0 THEN\n  DO\n\"ALLOC F(SAVEVAR) DA('\"DSN\"') SPA(1 1)\",\n   \"TRACKS RECFM(V B) LRECL(255) BLKSIZE(27920)\",\n   \"VOL(OSPSYS) REUS\"\n   IF RC > 0 THEN\n   DO\n    SAY 'UNABLE TO CREATE SAVEVAR DATASET ' DSN\n    STAT = MSG(\"ON\")\n    RETURN 8\n   END\n END\n  QUEUE VALUE(VAL1)\n  QUEUE ''\n  \"EXECIO * DISKW SAVEVAR (FINIS\"\n  \"FREE F(SAVEVAR)\"\n  STAT = MSG(\"ON\")\n  RETURN 0\n  /*******************************************************************/\n\ncontact_systems:\n\n msg1 = 'ATL001 Problem with the VTS Export Process. Select Call Home'\n        ' from VTS, and report as Subsystem Problem'\n ok = ALXRWTO(msg1,'NOROLL')\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E0017": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x003\\x003\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 51, "newlines": 51, "modlines": 0, "user": "WHS"}, "text": "/* REXX */\n/*  TRACE R */\n arg message\n\n /* Just write record             */\n\n E0016 = 'E0017' DATE('S') TIME('N') 1\n SAVEVPUT('E0016')\n\nEXIT\n/*******************************************************************/\nSAVEVGET:\n\n ARG VAL1\n STAT = MSG(\"OFF\")\n DSN = 'SYSX.OPSAUTO.SAVEVAR.'VAL1\n \"FREE F(SAVEVAR)\"\n \"ALLOC F(SAVEVAR) DA('\"DSN\"') SHR\"\n IF RC > 0 THEN\n  RETURN 8\n \"EXECIO * DISKR SAVEVAR (STEM SAVEVGET. FINIS\"\n  \"FREE F(SAVEVAR)\"\n  INTERPRET VAL1 '= SAVEVGET.1'\n  STAT = MSG(\"ON\")\n RETURN 0\n\nSAVEVPUT:\n\n ARG VAL1\n STAT = MSG(\"OFF\")\n DSN = 'SYSX.OPSAUTO.SAVEVAR.'VAL1\n \"FREE F(SAVEVAR)\"\n\"ALLOC F(SAVEVAR) DA('\"DSN\"') SHR\"\n IF RC > 0 THEN\n  DO\n\"ALLOC F(SAVEVAR) DA('\"DSN\"') SPA(1 1)\",\n   \"TRACKS RECFM(V B) LRECL(255) BLKSIZE(27920)\",\n   \"VOL(OSPSYS) REUS\"\n   IF RC > 0 THEN\n   DO\n    SAY 'UNABLE TO CREATE SAVEVAR DATASET ' DSN\n    STAT = MSG(\"ON\")\n    RETURN 8\n   END\n END\n  QUEUE VALUE(VAL1)\n  QUEUE ''\n  \"EXECIO * DISKW SAVEVAR (FINIS\"\n  \"FREE F(SAVEVAR)\"\n  STAT = MSG(\"ON\")\n  RETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEAVMXIT": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x02\\x13\\x02\\x13\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 531, "newlines": 531, "modlines": 0, "user": "WHS"}, "text": " TITLE 'WTOEXIT - TO PROCESS MANY TYPES OF MESSAGES'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 31                                    *\n*                  RMODE ANY                                        *\n*                  NON-REENTRANT                                    *\n*                  *** APF AUTHORIZED *** NOT SURE IF NECESSARY     *\n*                                                                   *\n* DESCRIPTION - CATCHALL WTO EXIT USED BY AUTOOPS SYSTEM            *\n*********************************************************************\nWTOEXIT  CSECT\nWTOEXIT  AMODE 31                      31-BIT ADDRESSING\nWTOEXIT  RMODE ANY                     31-BIT RESIDENCE\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2                       MESSAGE ATTRIBUTES\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5                       BEGINING OF LIST\nR6       EQU   6                       COUNTER\nR7       EQU   7                       END OF LIST\nR8       EQU   8                       WORK REGISTER\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11                      POINTER TO GETMAINED AREA\nR12      EQU   12                      BASE REGISTER\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSPINPRVT EQU   230\nCOMMAND_FLAG    EQU  X'01'\nREPLY_FLAG      EQU  X'02'\nEXEC_FLAG       EQU  X'04'\nEVENT_FLAG      EQU  X'08'\nSEARCH_FLAG     EQU  X'10'\nJOBNAME_FLAG    EQU  X'20'\nMULTI_LINE_FLAG EQU  X'40'\nHIGHLIGHT_FLAG  EQU  X'80'\n* SECOND FLAG BYTE IN MESSAGE\nCOLOR_RED       EQU  X'01'\nMULTI_LINE_ALL  EQU  X'02'\nSUPPRESS_FLAG   EQU  X'04'\n         EJECT\n         STM   R14,R12,12(R13)         SAVE REGISTERS\n         LR    R12,R15\n         USING WTOEXIT,R12                 REGISTER\n         L     R9,0(R1)                ADRESSIBILITY TO\n         USING CTXT,R9                      WORK AREA\n*\n*  BEFORE ACQUIRING STORAGE WE ARE GOING TO VERIFY THAT IT IS ONE\n* OF OUR MESSAGES\n*\n         L    R10,CTXTTXPJ              ADDRESSIBILITY\n         USING CTXTATTR,R10                 TO MSG ATTRIBUTES\n         LA   R4,CTXTTMSG\n         USING MSGTEXT,R4\n****************************************\n         TM   CTXTBNPF,CTXTHABD        ALREADY BEEN DISPLAYED\n         BO   RETURN2\n****************************************\n         LA   R6,1                     SET TO MESSAGE NUMBER ONE\n         L    R5,MSGLOAD               GET THE ADDRESS OF THE TABLE\n         LH   R11,0(R5)                GET THE LENGTH OF THE TABLE\n         LA   R11,0(R11,R5)            POINT TO END OF TABLE\n         LA   R5,2(R5)                 INCREMENT PAST THE LENGTH\n         SLR  R1,R1                    CLEAR R1 FOR INSERT\n         LR   R3,R1                    AND R3 AS WELL\nLOOPMSG  ICM  R1,3,0(R5)               GET ENTRY LENGTH\n         IC   R3,2(R5)                 GET THE MSGID LENGTH\n         BCTR R3,0                     DECREMENT FOR EX INSTR\n         EX   R3,CLCMSGID              CLC  MSGID(0),3(R5)\n         BE   GOT_MESSAGE              YES THEN GO PROCESS\nRETURN_LOOPMSG EQU  *\n         LA   R5,0(R1,R5)              NO, INCREMENT TO NEXT ENTRY\n         LA   R6,1(R6)                 INCR TO NEXT MESSAGE NUMBER\n         CR   R5,R11                   ARE WE AT THE END OF MESSAGES\n         BL   LOOPMSG                  NO, THEN DO THE NEXT ONE\n         B    RETURN2                  WE DON'T HAVE THE MESSAGE\nGOT_MESSAGE   EQU  *\n         LR   R8,R5                    SAVE IF WE WANT TO COME BACK\n         LR   R7,R1                    SAVE IF WE WANT TO COME BACK\n         LA   R5,4(R3,R5)              INCR PAST 2 LENGTHS, MSGID\n         TM   0(R5),MULTI_LINE_FLAG    IS THIS A MULTI LINE REQUEST\n         BZ   CHECK_SEARCH             NO, THEN GO AROUND\n         OI   CTXTRFB1,CTXTRPML        SET FLAG TO PROCESS MULTI LINE\nCHECK_SEARCH  EQU  *\n         TM   0(R5),SEARCH_FLAG        IS THERE A SEARCH ARGUMENT\n         BZ   GET_STORAGE              NO, THEN JUST ACQUIRE STORAGE\n         TM   0(R5),JOBNAME_FLAG       IS THERE A JOBNAME CHECK\n         BZ   CHECK_MULTI              NO, THEN CHECK FOR MULTI-LINE\n         SLR  R3,R3                    CLEAR FOR INSERT\n         IC   R3,2(R5)                 GET THE COMMAND LENGTH IN R3\n         LA   R2,3(R3,R5)              INCR PAST FUNCTION AND COMMAND\n         IC   R3,0(R2)                 GET THE SEARCH LENGTH IN R3\n         CLC  CTXTJBNM(8),1(R2)        COMPARE THE JOBNAME\n         BE   RELOAD_MESSAGE            YES, CONTINUE PROCESSING\n         LR   R5,R8                    RELOAD\n         LR   R1,R7                    RELOAD\n         SLR  R3,R3                    CLEAR\n         B    RETURN_LOOPMSG\n*\nCHECK_MULTI   EQU  *\n         TM   0(R5),MULTI_LINE_FLAG    IS THIS A MULTI LINE REQUEST\n         BZ   NOTMULTI\n         ICM  R1,15,CTXTTXPN           IS THIS A SUBSEQUENT LINE\n         BZ   NOTMULTI                 NO, THEN JUST CONTINUE\n         TM   1(R5),MULTI_LINE_ALL     HAVE WE FLAGGED IT FOR ALL\n         BO   NOTMULTI                 YES, THEN CHECK 1ST MSG FOR ARG\n         LR   R10,R1                   GET SUBSEQUENT MSG ADDRESS.\n         LA   R4,CTXTTMSG              AND RELOAD R4 AS WELL\n         LH   R15,CTXTTLEN             LOAD THE LENGTH HERE\n         SLR  R3,R3                    AND CLEAR THE MESSAGE ID\n         B    GOTMULTI                 AND GO AROUND\n**\n*  FURTHER FILTERING CRITERIA FOR SELECTING A MESSAGE FOR\n* PROCESSING\n*\nNOTMULTI LH   R15,CTXTTLEN             GET THE MESSAGE LENGTH IN R15\n         SR   R15,R3                   MINUS THE MESSAGE ID\nGOTMULTI LA   R14,MSGID                GET THE MSGID IN R14\n         LA   R14,1(R3,R14)            INCREMENT PAST THE MSGID\n         IC   R3,2(R5)                 GET THE COMMAND LENGTH IN R3\n         LA   R2,3(R3,R5)              INCR PAST FUNCTION AND COMMAND\n         IC   R3,0(R2)                 GET THE SEARCH LENGTH IN R3\n         CR   R15,R3                   SEE IF ENOUGH OF MESSAGE LEFT\n         BNL  CONT_SEARCH1             LONG ENOUGH, CONTINUE\n         LR   R5,R8                    RELOAD\n         LR   R1,R7                    RELOAD\n         SLR  R3,R3                    CLEAR\n         B    RETURN_LOOPMSG\nCONT_SEARCH1  EQU  *\n         SR   R15,R3                   AND SUBSTRACT THAT ALSO\n         BCTR R3,0                     DECREMENT FOR EXECUTE\nLOOP_SEARCH   EQU   *\n         EX   R3,CLCSERCH              CLC   0(0,R14),1(R2)\n         BE   RELOAD_MESSAGE           YES, THEN WE FOUND IT\n         LA   R14,1(R14)               INCREMENT FOR MESSAGE\n         BCT  R15,LOOP_SEARCH          LOOP THROUGH\n         LR   R5,R8                    RELOAD\n         LR   R1,R7                    RELOAD\n         SLR  R3,R3                    CLEAR\n         B    RETURN_LOOPMSG\nRELOAD_MESSAGE EQU  *\n         L    R10,CTXTTXPJ              RELOAD IN CASE OF MULTI LINE\n         LA   R4,CTXTTMSG               HERE ALSO\n*\n*   OBTAIN DYNAMIC STORAGE BELOW 16-MEG LINE FOR MGCRE MACRO AND\n*   SAVE AREA.\n*\nGET_STORAGE   EQU  *\n* REMOVED THE REQUEST FOR SUBPOOL 230 BECAUSE IT GOT AN 878-10 ABEND\n* EVERY ONCE IN A WHILE                     WHS  2/27/97\n* PUT IT BACK TO SUBPOOL 230                WHS  2003\n*        GETMAIN RC,LV=DATAEND,LOC=BELOW\n         GETMAIN RC,LV=DATAEND,SP=SPINPRVT\n         LTR  R15,R15                  CHECK IF GOOD GETMAIN\n         BZ   LOADR11                  NO, LEAVE\n         WTO  'ALWTO01 GETMAIN FAILED FOR IEAVMXIT. CONTACT SYSTEMS',  X\n               ROUTCDE=2\n         B    RETURN2                  NO, LEAVE\nLOADR11  LR   R11,R1                   POINTER TO GETMAINED AREA\n         USING DATAAREA,R11            ADDRESSIBILITY TO GETMAINED AREA\n         ST   R13,SAVEAREA+4           BACKWARD POINTER\n         LA   R15,SAVEAREA             ADDRESS OF SAVE AREA\n         ST   R15,8(R13)               FORWARD POINTER\n         LR   R13,R15                  R13 NOW STANDARD SAVE AREA\n*\n*   WE ARE GOING TO SEE IF THIS MESSAGE IS BEING ISSUED EXECESSIVELY\n*   WITHIN A PARTICULAR TIME PERIOD. IF IT IS BEING ISSUED WITHIN\n*   THAT TIME PERIOD WE WILL NOT PROCESS IT          WHS 12/03/03\n         TM    1(R5),SUPPRESS_FLAG     DO THEY WANT TO SUPPRESS MSG\n         BO    DO_SUPPRESS             YES, THEN BYPASS AND PROCESS\n         TM    0(R5),REPLY_FLAG         IS THIS A WTOR REQUEST\n         BO    CLEAR_COMMAND            YES, THEN GO AROUND\n         TM    0(R5),MULTI_LINE_FLAG    IS THIS A MULTI LINE REQUEST\n         BO    CLEAR_COMMAND            YES, THEN GO AROUND\nCONTINUE_STORE EQU  *\n         XC    TIMEDATE(16),TIMEDATE   CLEAR THE TIME\n         TIME  DEC,TIMEDATE,LINKAGE=SYSTEM\n         L     R2,CTXTCWKP              LOAD ADDR OF COMMON AREA\n         USING CTXTCDAM,R2\n         CLM   R6,3,0(R2)               COMPARE THE MESSAGE NUMBER\n         BNE   STORE_CURRENT_MESSAGE    DIFFERENT, THEN SAVE NEW 1\n         CLC   TIMEDATE+8(4),CTXTCUDA+4 COMPARE THE DATE\n         BNE   STORE_CURRENT_MESSAGE    DIFFERENT, THEN PROCESS\n         SLR   R14,R14                  CLEAR FOR INSERT\n         SLR   R15,R15                  SAME HERE\n         ICM   R14,7,CTXTCUDA           LOAD HHMMSS FROM PREVIOUS\n         ICM   R15,7,TIMEDATE           LOAD HHMMSS FROM CURRENT TIME\n         SR    R15,R14                  SUBTRACT FOR TIME DIFFERENCE\n         LTR   R15,R15                  FIRST, SEE IF MINUS\n         BM    STORE_CURRENT_MESSAGE    IF ITS MINUS THEN STORE IT\n         CH    R15,HW3                  START W/ 3 SECOND DIFFERENCE\n         BNH   RETURN                   NO, THEN QUIT\nSTORE_CURRENT_MESSAGE  EQU *\n         STCM  R6,3,0(R2)              SAVE MESSAGE NUM IN USER AREA\n         MVC   CTXTCUDA(4),TIMEDATE    SAVE THE TIME\n         MVC   CTXTCUDA+(4),TIMEDATE+8 SAVE THE DATE\n         DROP  R2\n********************************************************************\n*\nCLEAR_COMMAND EQU  *\n         MVI  COMMAND,C' '             WANT TO BLANK THIS OUT BEFORE\n         MVC  COMMAND+1(255),COMMAND   CLEAR ALL 256 BYTES\n*   R5 POSITIONED AT THE FUNCTION, OF WHICH THERE ARE 3,\n*   COMMAND, REPLY AND EXEC. WE WILL BRANCH TO THE APPROPRIATE FUNCTION\n         TM   0(R5),REPLY_FLAG         IS IT A WTOR ?\n         BO   DOREPLY                  YES, THEN GO PROCESS\n         TM   0(R5),EXEC_FLAG          IS IT AN EXEC TO PROCESS\n         BO   DOEXEC                   YES, THEN HOP TO IT\n         TM   0(R5),EVENT_FLAG         IS IT AN EVENT TO PROCESS\n         BO   DOEXEC                   YES, THEN PROCESS WITH EXEC\n         TM   0(R5),HIGHLIGHT_FLAG     IS IT AN EVENT TO PROCESS\n         BO   DOHIGHLIGHT              YES, THEN PROCESS HIGHLIGHT\n         TM   0(R5),COMMAND_FLAG       IS IT A COMMAND TO PASS\n         BO   DO_COMMAND               YES, THEN PROCESS COMMAND\n         B    RETURN                   NO, THEN JUST GET OUT\n* THIS SECTION WAS ADDED BECAUSE OF MVS COMMANDS THAT ARE TRAPPED\n* AND ARE NOT VALID COMMANDS. REGARDLESS OF ORIGINATION, THIS WILL\n* SUPPRESS MESSAGE COMPLETELY\nDO_SUPPRESS   EQU   *\n         OI   CTXTRFB2,CTXTRDTM        DON'T DISPLAY AND DON'T LOG\n         B    RETURN                   AND GET OUT\n****\nDO_COMMAND    EQU  *                   INCREMENT PAST THE FUNCTION\n         IC   R3,2(R5)                 GET THE LENGTH TO PASS\n         LA   R7,COMMAND               ADDRESS THE COMMAND FIELD\n         STCM R3,3,0(R7)               SAVE THE LENGTH\n         BCTR R3,0                     DECR FOR EXECUTE INSTR\n         EX   R3,MOVE_COMMAND          MVC  2(0,R7),3(R5)\n         LA   R4,DYNMGCRE              ADDR THE MACRO FOR EXECUTE\n         MVC  0(CMDLEN,R4),CMDAREA     GET MGCRE MF=L TO DYNAMIC\n         SLR  R6,R6                    CLEAR FOR CONSOLE 0\n*        MGCRE TEXT=(R7),CONSID=(R6),MF=(E,(R4))\n         MGCRE TEXT=(R7),CONSID=(R6),TOKEN=CTXTTOKN,MF=(E,(R4))\n         B    RETURN                   THAT WAS EASY, NON\n*************************************************************\nDOREPLY  TM   CTXTTFB1,CTXTTFWR        VERIFY THAT THIS IS A WTOR\n         BZ   RETURN                   NO, THEN JUST QUIT\n         IC   R3,2(R5)                 GET THE LENGTH OF THE REPLY\n         BCTR R3,0                     DECR FOR EXECUTE INSTR\n         LA   R7,COMMAND               ADDRESS THE COMMAND FIELD\n         MVC  2(9,R7),REPLY_KW         INIT WITH REPLY AND BLANKS\n         LH   R8,CTXTRPYL              GET THE REPLY ID LENGTH\n         BCTR R8,0                     DECR FOR EX INSTR\n         EX   R8,MOVERYID              MVC 8(0,R7),CTXTRPYI\n         LA   R8,9(R8,R7)              INCR PAST REPLY ID FOR COMMA\n         MVI  0(R8),C','               MOVE IN A COMMA\n         EX   R3,MOVE_REPLY            MVC  1(0,R8),3(R5)\n         LA   R8,1(R3,R8)              POINT PAST REPLY\n         SLR  R8,R7                    GET THE OVERALL LENGTH\n         STCM R8,3,0(R7)               AND SAVE THE LEGNTH\n         LA   R4,DYNMGCRE              ADDR THE MACRO FOR EXECUTE\n         MVC  0(CMDLEN,R4),CMDAREA     GET MGCRE MF=L TO DYNAMIC\n         SLR  R6,R6                    CLEAR FOR CONSOLE 0\n*        MGCRE TEXT=(R7),CONSID=(R6),TOKEN=CTXTTOKN,MF=(E,(R4))\n         MGCRE TEXT=(R7),CONSID=(R6),MF=(E,(R4))\n         B    RETURN\n*************************************************************\nDOHIGHLIGHT   EQU   *\n         OI    CTXTRFB1,CTXTRCDC         CHANGE DESCRIPTOR CODE\n         L     R14,CTXTDCP               ADDR TO DESCRIPTOR DSECT\n         USING CTXTDESC,R14\n         XC    CTXTDC1(2),CTXTDC1        SET TO ZERO\n* DESCRIPTOR 02 DEFAULTS TO WHITE; WE WANT WHITE\n         MVI   CTXTDC1,CTXTDC02          CODE 02 HIGHLIGHT WHITE\n* DESCRIPTOR 11 DEFAULTS TO RED; THEY HAVE TO REQUEST RED\n*        MVI   CTXTDC2,CTXTDC11          CODE 11 HIGHLIGHT RED\n         TM    1(R5),COLOR_RED           DID THEY ASK FOR RED\n         BZ    RETURN\n*        CLC   3(3,R5),=C'RED'           DID THEY ASK FOR RED\n*        BNE   RETURN                    NO, THEN GET OUT\n         OI    CTXTERF1,CTXTEMCO         CHANGE COLOR\n         MVI   CTXTCOLR,CTXTRED          SET TO RED\n         B    RETURN\n*************************************************************\nDOEXEC   SLR  R15,R15                  CLEAR REGISTER FOR INSERT\n         IC   R15,2(R5)                GET THE LENGTH TO PASS\n         BCTR R15,0                    DECR FOR EXECUTE INSTR\n         LA   R7,COMMAND               ADDRESS COMMAND AREA\n         EX   R15,MOVE_COMMAND         MVC  2(0,R7),3(R5)\n         LA   R7,3(R7,R15)             POINT PAST WHAT WE JUST MOVED\n         MVC  0(4,R7),SYMBOLIC_PARM1   MOVE IN ,MESSAGE=\n         LA   R7,4(R7)                 AND INCREMENT PAST\n         MVI  0(R7),X'7D'              MOVE IN ' DELIMETER\n         LA   R7,1(R7)                 AND INCR PAST IT\n         LR   R0,R7                    SAVE THIS LOCATION POINTER\n         TM   0(R5),EVENT_FLAG         WAS THIS AN EVENT\n         BZ   NOT_EVENT                NO, THEN MOVE IN MSGID\n         MVC  0(3,R7),REXX_MSGID       MOVE IN THE REXX MSGID\n         LA   R7,3(R7)                 INCREMENT PAST WHAT MOVED\n*        MVC  0(7,R7),REXX_EVENT       MOVE IN THE REXX EVENT ID\n*        LA   R7,7(R7)                 INCREMENT PAST WHAT MOVED\n         B    EXECWTOR                 AND CONTINUE AROUND\n* WE ARE JUST GO TO MOVE THE PORTION OF THE MESSAGE ID THAT EXECUTES\n* THE REXX EXEC, NOT TO EXCEED 8 BYTES. REMEMBER THAT R4 ADDRESSES THE\n* BEGINNING OF THE MSGID.\nNOT_EVENT     EQU  *\n         LA   R15,7                    1 LT 8 FOR EX INSTR\n         TRT  MSGID(8),BLANKTBL        FIND THE FIRST NON-BLANK\n         BZ   MOVE_ID                  NO BLANK, THEN MOVE ALL 8\n         SLR  R1,R4                    LET'S GET THE LENGTH\n         LR   R15,R1                   GET THE LENGTH IN R15\n         BCTR R15,0                    AND DECR FOR EX INSTR\nMOVE_ID  EX   R15,MOVE_MSGID           MVC  0(0,R7),MSGID\n         LA   R7,1(R15,R7)              INCR PAST MSGID\n         MVI  0(R7),C' '               BLANK OUT AFTER MSGID\n         LA   R7,1(R7)                 AND INCREMENT PAST\nEXECWTOR TM   CTXTTFB1,CTXTTFWR        WAS THIS A WTOR\n         BZ   NOTWTOR                  NO, THEN GO AROUND\n         MVI  0(R7),C'@'               HIGHLIGHT THE REPLY ID\n         LA   R7,1(R7)                 AND INCREMENT PAST\n         LH   R8,CTXTRPYL              GET THE REPLY ID LENGTH\n         BCTR R8,0                     DECR FOR EX INSTR\n         EX   R8,MOVERYI2              MVC 0(0,R7),CTXTRPYI\n         LA   R7,1(R8,R7)              INCR PAST THE REPLY ID\n* THE PARM FIELD PASSED CANNOT EXCEED 100 BYTES. THE LENGTH OF A\n* SYMBOLIC PASSED TO THE START COMMAND CANNOT EXCEED 56 BYTES.\n* WE ARE GOING TO SPLIT IT INTO 2 SYMBOLICS, 1ST ONE IS PASSED BY\n* MSGTABLE AND WE WILL BUILD THE 2ND ONE BY REPLACING THE LAST\n* CHARACTER OF THE FIRST WITH A 2\nNOTWTOR  TM   0(R5),MULTI_LINE_FLAG    IS THIS A MULTI LINE WTO\n         BZ   NORESET\n         ICM  R1,15,CTXTTXPN           IS THIS A SUBSEQUENT LINE\n*        BZ   NOTMULTI                 NO, THEN JUST CONTINUE\n         BZ   NORESET                  NO, THEN JUST CONTINUE\n         LR   R10,R1                   GET SUBSEQUENT MSG ADDRESS.\n         LA   R4,CTXTTMSG              AND RELOAD R4 AS WELL\nNORESET  LH   R1,HW50                  FIRST PART IS 50 BYTES\n         LR   R14,R7                   GET THE CURRENT POINTER HERE\n         SLR  R14,R0                   AND SUBTRACT WHAT'S BEEN DONE\n         SLR  R1,R14                   SUBTRACT TO SEE WHAT LEFT\n         LH   R15,CTXTTLEN             GET LENGTH OF MESSAGE\n         CR   R1,R15                   SEE WHICH IS LARGER\n         BL   USEREG1                  IF R1 LESS, THEN MOVE IT IN\n         LR   R1,R15                   LOAD IT UP\nUSEREG1  BCTR R1,0                     DECR IT\n         EX   R1,MOVEMSG               MVC  0(0,R7),CTXTTMSG\n         EX   R1,TRANSMSG              TR   0(0,R7),TICTABLE\n         LA   R8,1(R1)                 SAVE THIS LENGTH FOR COMPARE\n         LA   R3,CTXTTMSG              ADDR FOR 2ND PART OF MESSAGE\n         LA   R3,1(R1,R3)               AND POINT PAST PART DONE\n         LA   R7,1(R1,R7)             POINT TO THE END OF MESSAGE\n         MVI  0(R7),X'7D'              MOVE IN ' DELIMETER\n****  LOGIC FOR M2\n         CR   R15,R8                   SEE IF ANY OF MESSAGE IS LEFT\n         BH   DO2ND                    YES, THEN KEEP GOING\n* ADDED THIS CODE TO GET JOBNAME ON SHORT MESSAGE'\n         CLI  CTXTJBNM,C' '           IS THERE A JOBNAME\n         BE   DONE2ND                  NO, THEN WE ARE DONE\n         LA   R7,1(R7)               AND INCREMENT TO THE END\n         MVC  0(4,R7),SYMBOLIC_PARM2   MOVE IN ,MESSAG2=\n         LA   R7,4(R7)                 AND INCREMENT PAST\n         MVI  0(R7),X'7D'              MOVE IN ' DELIMETER\n         LA   R7,1(R7)                 AND INCR PAST IT\n         MVC  0(3,R7),=C' J='         DELIMIT IT\n         MVC  3(8,R7),CTXTJBNM        MOVE IN JOBNAME\n         LA   R7,11(R7)               INCREMENT IT\n         MVI  0(R7),X'7D'              MOVE IN ' DELIMETER\n         B    DONE2ND                  NO, THEN WE ARE DONE\nDO2ND    LA   R7,1(R7)               AND INCREMENT TO THE END\n         MVC  0(4,R7),SYMBOLIC_PARM2   MOVE IN ,MESSAG2=\n         LA   R7,4(R7)                 AND INCREMENT PAST\n         MVI  0(R7),X'7D'              MOVE IN ' DELIMETER\n         LA   R7,1(R7)                 AND INCR PAST IT\n         LH   R1,HW49                  SECOND PART IS 49 BYTES\n         LH   R15,CTXTTLEN             GET LENGTH OF MESSAGE\n         SR   R15,R8                   SUBSTRACT 1ST PART OF MSG MOVED\n         CR   R1,R15                   SEE WHICH IS LARGER\n         BL   USEREG1A                 IF R1 LESS, THEN MOVE IT IN\n         LR   R1,R15                   LOAD IT UP\nUSEREG1A BCTR R1,0                     DECR IT\n         EX   R1,MOVEMSG2              MVC  0(0,R7),CTXTTMSG+50\n         EX   R1,TRANSMSG              TR   0(0,R7),TICTABLE\n         LA   R7,1(R1,R7)             POINT TO THE END OF MESSAGE\n**\n         CLI  CTXTJBNM,C' '           IS THERE A JOBNAME\n         BE   NO_JOBNAME              NO, THEN FORGET IT\n         CH   R1,HW38                 SEE IF ENOUGH ROOM FOR JOBNAME\n         BH   NO_JOBNAME              NO, THEN FORGET IT\n         MVC  0(3,R7),=C' J='         DELIMIT IT\n         MVC  3(8,R7),CTXTJBNM        MOVE IN JOBNAME\n         LA   R7,11(R7)               INCREMENT IT\nNO_JOBNAME    EQU  *\n         MVI  0(R7),X'7D'              MOVE IN ' DELIMETER\nDONE2ND  LA   R14,2(R7)               AND INCREMENT TO THE END\n         LA   R7,COMMAND               POINT BACK TO BEGINNING\n         LA   R15,2(R7)                POINT BACK TO BEGINNING\n         SLR  R14,R15\n         STCM R14,3,0(R7)              STORE THE LENGTH\n         LA   R4,DYNMGCRE              ADDR THE MACRO FOR EXECUTE\n         MVC  0(CMDLEN,R4),CMDAREA     GET MGCRE MF=L TO DYNAMIC\n         SLR  R6,R6                    CLEAR FOR CONSOLE 0\n*************************************************************\n*        CLC  CTXTJBNM(8),=C'MSTJCL00'\n*        BNE  GOT_ACEE\n         MVC  RACF_CMD(VERIFY_L),VERIFY\n         LA   R2,RACF_CMD\n         LA   R8,RACF_WA\n         MVC  TOKENOUT(80),TOKOUT\n         LA   R15,TOKENOUT\n         RACROUTE ,                        .CREATE ACEE                X\n               REQUEST=VERIFYX,            .CHECK USER ID AND TOKEN    X\n               TOKNOUT=(R15),              .GET THE TOKEN              X\n               RELEASE=7703,               .FMID HRF7703               X\n               USERID=USERID,              .ADDRESS OF USER ID         X\n               GROUP=GROUPID,              .ADDRESS OF USER ID         X\n               PASSWRD=PASSWORD,           .PASSWORD                   X\n               PASSCHK=NO,                 .NO PASSWORD SUPPLIED       X\n               TRUSTED=YES,                .BYPASS                     X\n               WORKA=(R8),                 .ADDRESS OF 512 BYTE WORKA  X\n               MF=(E,(R2))                 .EXECUTE\n         LA   R15,TOKENOUT\n         MGCRE TEXT=(R7),CONSID=(R6),UTOKEN=(R15),MF=(E,(R4))\n*************************************************************\nRETURN   EQU  *\n         L    R13,4(R13)\n*        FREEMAIN RC,LV=DATAEND,A=(R11)\n         FREEMAIN RC,LV=DATAEND,A=(R11),SP=SPINPRVT\nRETURN2  LM   R14,R12,12(R13)\n         BR   R14\n*\nMSGLOAD  DC   V(MSGTABLE)\n*MOVE_COMMAND   MVC  COMMAND(0),3(R5)\nMOVE_COMMAND   MVC  2(0,R7),3(R5)\nCLCMSGID       CLC  MSGID(0),3(R5)\nCLCSERCH       CLC  0(0,R14),1(R2)\nMOVERYID       MVC  8(0,R7),CTXTRPYI\nMOVE_REPLY     MVC  1(0,R8),3(R5)\nMOVE_MSGID     MVC  0(0,R7),MSGID\nMOVERYI2       MVC  0(0,R7),CTXTRPYI\nMOVEMSG        MVC  0(0,R7),CTXTTMSG\nMOVEMSG2       MVC  0(0,R7),0(R3)\nTRANSMSG       TR   0(0,R7),TICTABLE\n*\n*   DATA AREAS\n*\nHW3          DC   H'3'\nHW50         DC   H'50'\nHW49         DC   H'49'\nHW38         DC   H'38'\nSYMBOLIC_PARM1    DC  CL4',M1='\nSYMBOLIC_PARM2    DC  CL4',M2='\nREXX_EVENT        DC  CL7'$EVENT '\nREXX_MSGID        DC  CL3'$E '\nREPLY_KW          DC  CL9'REPLY  '\nPASSWORD          DS  0F\nPW_LEN            DC  X'04'\nPSWD              DC  CL4'PSWD'\nGROUPID           DS  0F\nGROUP_LEN         DC  X'08'\nRACF_GROUP        DC  CL8'STCGROUP'\nUSERID            DS  0F\nUSERID_LEN        DC  X'07'\nRACF_USERID       DC  CL7'STCUSER'\nTOKOUT            DS  0CL80\n                  DC  XL2'5001'\n                  DC  XL78'0'\n           LTORG\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nTICTABLE   DC  X'000102030405060708090A0B0C0D0E0F'  0\n           DC  X'101112131415161718191A1B1C1D1E1F'  1\n           DC  X'202122232425262728292A2B2C2D2E2F'  2\n           DC  X'303132333435363738393A3B3C3D3E3F'  3\n           DC  X'404142434445464748494A4B4C4D4E4F'  4\n           DC  X'505152535455565758595A5B5C5D5E5F'  5\n           DC  X'606162636465666768696A6B6C6D6E6F'  6\n           DC  X'707172737475767778797A7B7C7F7E7F'  7\n           DC  X'808182838485868788898A8B8C8D8E8F'  8\n           DC  X'909192939495969798999A9B9C9D9E9F'  9\n           DC  X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'  A\n           DC  X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'  B\n           DC  X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'  C\n           DC  X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'  D\n           DC  X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'  E\n           DC  X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'  F\n*\nBLANKTBL   DC  256X'00'\n           ORG BLANKTBL+C' '\n           DC  X'FF'\n           ORG\n***********************************************************************\n*                                                                     *\n*        LIST FORM OF MGCRE MACRO (STATIC)                            *\n*                                                                     *\n***********************************************************************\nUSERCMD  DS    0H\nCMDAREA  MGCRE MF=L                     LIST FORM OF MACRO\nCMDLEN   EQU   *-USERCMD                LENGTH OF MGCRE PARAMETER LIST\n***********************************************************************\nVERIFY   RACROUTE ,                                                    X\n               REQUEST=VERIFYX,            .CHECK USER ID              X\n               SESSION=COMMAND,            .CREATE ACEE                X\n               TOKNOUT=*-*,                .TOKEN ADDRESS              X\n               PASSWRD=*-*,                .ACEE ADDRESS               X\n               PASSCHK=NO,                 .CHECK PASSWORD             X\n               USERID=*-*,                 .USERID ADDRESS             X\n               GROUP=*-*,                  .GROUP  ADDRESS             X\n               RELEASE=7703,               .FMID HRF7703               X\n               TRUSTED=YES,                .                           X\n               WORKA=*-*,                  .WORK AREA ADDRESS          X\n               MF=L                        .LIST FORMAT\nVERIFY_L EQU   *-VERIFY                    .LENGTH OF VERIFY LIST\nDATAAREA DSECT\nSAVEAREA DS   18F\nDYNMGCRE DS   CL(CMDLEN)\nCOMMAND  DS   CL256\n*        ORG\nACEE_ADDRESS  DS  F\nTOKENOUT      DS  CL80\nRACF_WA  DS   CL512\nRACF_CMD DS   CL(VERIFY_L)\nTIMEDATE DS   CL16\nDATAEND  EQU  *-DATAAREA\nMSGTEXT  DSECT\nMSGID    DS   CL8\n         DS   CL92\n         IEZVX100\n         END  WTOEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INRECXIT": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01J\\x01J\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 330, "newlines": 330, "modlines": 0, "user": "WHS"}, "text": "INRECXIT TITLE 'Network Print Facility Input Record Exit'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 31                                    *\n*                  RMODE ANY                                        *\n*            --->  *** REENTRANT *** <--- Must be Reentrant         *\n*                  NOT APF AUTHORIZED                               *\n*                                                                   *\n* DESCRIPTION - Network Print Facility (NPF) Input record exit      *\n*               to place PCL in printers for IP Printing            *\n*                                                                   *\n*  Assembly - Include the TCP/IP SEZACMAC in the SYSLIB             *\n*                                                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This exit will imbed the necessary PCL in the output to print   *\n*   it nicer than what it has been printing.                        *\n*                                                                   *\n*-------------------------------------------------------------------*\nINRECXIT CSECT\nINRECXIT AMODE ANY\nINRECXIT RMODE ANY\n*              Registers           entry       INRECXIT    exit\nR0       EQU   0                   n/a         work        =entry\nR1       EQU   1                   >>IRELIST   work        =entry\nR2       EQU   2                   n/a         work        =entry\nR3       EQU   3                   n/a         work        =entry\nR4       EQU   4                   n/a         work        =entry\nR5       EQU   5                   n/a         work        =entry\nR6       EQU   6                   n/a         work        =entry\nR7       EQU   7                   n/a         work        =entry\nR8       EQU   8                   n/a         >IRXSTATD   =entry\nR9       EQU   9                   n/a         >RTDATA     =entry\nR10      EQU   10                  n/a         >IRELIST    =entry\nR11      EQU   11                  n/a         base 2      =entry\nR12      EQU   12                  n/a         base 1      =entry\nR13      EQU   13                  >callsave   >INRCSTG    =entry\nR14      EQU   14                  >return     work        =entry\nR15      EQU   15                  >INRECXIT   retcode     retcode\n         SPACE 5\n         USING INRECXIT,R15       Establish temporary base register\n         B     INRC0000           Branch around constants\n         DC    CL9'INRECXIT'      Module identifier\n         DC    CL9'&SYSDATE'      Assembly date\n         DC    CL6'&SYSTIME'      Assembly time\n         SPACE 5\nINRC0000 DS    0H\n         STM   R14,R12,12(R13)    Save caller's registers\n         LR    R12,R15            Change base registers\n         DROP  R15                Tell assembler\n         USING INRECXIT,R12\n         L     R10,0(R1)          Get address of exit parameter list\n         USING IRELIST,R10        Make exit parameter list addressable\n         L     R9,IRERTD          Get address of routing data area\n         USING RTDATA,R9          Make routing data area addressable\n         L     R8,IRESTRG         Get address of IRE static memory\n         USING IRXSTATD,R8        Make IRE static storage addressable\n         ICM   R1,15,IRXDSTGA     Get address of IRE dynamic storage\n         BNZ   INRC0020           Storage has already been allocated\n         LA    R2,INRCSTGL        Get length of program storage\n         GETMAIN RC,LV=(R2),LOC=ANY Get program storage\n         LTR   R15,R15            Did GETMAIN work?\n         BZ    INRC0010           Yes\n         WTO   'INRECXIT GETMAIN FAILED'\n         LA    R15,8              No,  show error\n         B     RET00010           Return to NPF\nINRC0010 DS    0H\n         ST    R1,IRXDSTGA        Save dynamic storage address\nINRC0020 DS    0H\n         ST    R1,8(0,R13)        Complete save area pointers\n         ST    R13,4(0,R1)\n         LR    R13,R1             Point to dynamic storage area\n         USING INRCSTG,R13        Tell assembler\n         SPACE 5\n         CLC   RTFUNCTN(4),=CL8'OPEN' Is this OPEN call?\n         BE    OPN00000           Yes\n         CLC   RTFUNCTN(3),=CL8'PUT'  Is this PUT call?\n         BE    PUT00000           Yes\n         CLC   RTFUNCTN(5),=CL8'CLOSE' Is this CLOSE call?\n         BE    CLS00000           Yes\n         CLC   RTFUNCTN(7),=CL8'RELEASE' Is this RELEASE call?\n         BE    REL00000           Yes\n         CLC   RTFUNCTN(4),=CL8'TERM' Is this TERM call?\n         BE    TRM00000           Yes\n         WTO   'INRECXIT UNKNOWN FUNCTION'\n         LA    R15,4              Bad function, show error\n         B     RET00000           Return to NPF\n         SPACE 5\n*---------------------------------------------------------------------*\n*        Process OPEN call\n*---------------------------------------------------------------------*\nOPN00000 DS    0H\n         MVI   IRXFLAG,IRXNEW     Set flag for new file\n         XR    R15,R15            Zero return code\n         B     RET00000           Go return to NPF\n*---------------------------------------------------------------------*\n*        Process PUT call\n*---------------------------------------------------------------------*\nPUT00000 DS    0H\n         TM    IRXFLAG,IRXOLD     First PUT to this file?\n         BO    PUT00020           No, pass it through\n         CLI   IRXFLAG,IRXNEW     First PUT to this file?\n         BNE   PUT00015           No, pass it through\n         OI    IRXFLAG,IRX2ND     Only look at first PUT\n         L     R2,IREBPTR\n         L     R3,IREDLEN\n         CH    R3,HW1024\n         BH    PUT00020           If greater than get out\n         LA    R14,SAVEREC\n         LR    R15,R3\n         MVCL  R14,R2\n         MVC   IRXRECL(4),IREDLEN Save this for later\n* OPTION1 is portrait, OPTION2 is Landscape,\n* OPTION3 is CICS 11 x 32 alternate printer\n* We're going to do check if VTAM and CICS1 and use Landscape\n         CLI   IRECID,C'V'        Is this VTAM application?\n         BNE   CHECK_PORTRAIT     No, then continue with options\n         L     R3,IRECPAD         Load the bind image\n* Compare first seven characters of APPLID\n         CLC   27(7,R3),=C'PRODCIC'  Is it PRODCICS\n         BE    SET_LANDSCAPE\nCHECK_PORTRAIT   EQU  *\n         CLC   RTDAOPTN(7),OPTION1  See if it is OPTION1\n         BNE   CHECK_LANDSCAPE\n         LA    R2,PCLPORT         Point to our PCL record\n         LH    R15,PCLPORT        Get the length\n         B     CHECK_VAR\nCHECK_LANDSCAPE  EQU  *\n         CLC   RTDAOPTN(7),OPTION2  See if it is OPTION2\n         BNE   SET_CICSLAND\nSET_LANDSCAPE  EQU  *\n         LA    R2,PCLLAND         Point to our PCL record\n         LH    R15,PCLLAND        Get the length\n         B     CHECK_VAR\nSET_CICSLAND   EQU  *\n         LA    R2,PCLCICS         Point to our PCL record\n         LH    R15,PCLCICS        Get the length\nCHECK_VAR      EQU  *\n         CLI   RTDARTYP,C'V'      Variable length records?\n         BE    PUT00010           Yes, continue\n         LA    R2,4(0,R2)         No, point past record descriptor\n         SH    R15,HW4\nPUT00010 DS    0H                 R2 points to carriage control\n         L     R14,IREBPTR        Get the buffer address\n         ST    R15,IREDLEN        Save the new length\n         BCTR  R15,0              Decr for move\n         EX    R15,MOVEPCL        MVC  0(0,R14),0(R2)\n         MVI   IREWFLG,X'00'      Write this record\n         MVI   IRERFLG,X'01'      Return to exit without read\n         B     CLEARR15           Go return to NPF\nPUT00015 DS    0H                 R2 points to carriage control\n         OI    IRXFLAG,IRXOLD     Set the flag\n         MVC   IREDLEN(4),IRXRECL Replace the record\n         L     R2,IREBPTR\n         L     R3,IREDLEN\n         LA    R14,SAVEREC\n         LR    R15,R3\n         MVCL  R2,R14\n***********************************************************\nPUT00020 DS    0H\n         CLI   IRECID,C'V'        Is this VTAM application?\n         BNE   WRITEIT            Yes, then we are only doing JES2\n         L     R3,IRECPAD         Load the bind image\n         CLC   27(7,R3),=C'PRODCIC'  Is it PRODCICS\n         BNE   WRITEIT\n         L     R15,IREBPTR        Load up record\n         TM    IRXFLAG,IRXTOP     Have we checked for 1st Top\n         BO    KEEP_GOING\n         CLI   4(R15),C'1'        Is it Top of Page\n         BNE   KEEP_GOING\n         OI    IRXFLAG,IRXTOP\n         MVI   4(R15),C' '\nKEEP_GOING     EQU  *\n         CLI   RTDARTYP,C'V'      Variable length records?\n         BNE   TRYFIXED\n         CLC   0(2,R15),HW5       See if length of five\n         BE    NOTWRITE\n         B     WRITEIT\nTRYFIXED L     R15,IREDLEN        Get the Length\n         CH    R15,HW1\n         BNE   WRITEIT\nNOTWRITE MVI   IREWFLG,X'01'       Set flag to not write\n         B     READNEXT\nWRITEIT  MVI   IREWFLG,X'00'      Write this record\nREADNEXT MVI   IRERFLG,X'00'      Read next record\nCLEARR15 XR    R15,R15            Zero return code\n         B     RET00000           Go return to NPF\n*---------------------------------------------------------------------*\n*        Process CLOSE call\n*---------------------------------------------------------------------*\nCLS00000 DS    0H\n         MVI   IREWFLG,X'01'      No record to write\n         MVI   IRERFLG,X'00'      Normal return from CLOSE\n         XR    R15,R15            Zero return code\n         B     RET00000\n*---------------------------------------------------------------------*\n*        Process RELEASE or TERM call\n*---------------------------------------------------------------------*\nREL00000 DS    0H\nTRM00000 DS    0H\n         LA    R2,INRCSTGL        Get length of dynamic storage\n         LR    R1,R13             Get address of dynamic storage\n         L     R13,SAVEAREA+4     Get address of caller's save area\n         FREEMAIN RU,LV=(R2),A=(R1) Free dynamic storage\n         XR    R15,R15            Zero return code\n         B     RET00010\n         SPACE 5\n*---------------------------------------------------------------------*\n*        Return to NPF\n*---------------------------------------------------------------------*\nRET00000 DS    0H                 Switch back to caller's save area\n         L     R13,SAVEAREA+4     Return to caller\nRET00010 DS    0H                 Already back to caller's save area\n         ST    R15,16(R13)        Set return code in saved R15\n         LM    R14,R12,12(R13)    Restore caller's registers\n         BSM   0,R14\n         EJECT\n*---------------------------------------------------------------------*\n*        Program constants\n*---------------------------------------------------------------------*\n         DS   0F\n* Changed l8D to l16D\n         DS   0F\nPCLLAND  DC   AL2(LENGTH_PCLL),AL2(00)\nPCLRCDL  DC   X'4027',C'E'          Reset\n         DC   X'2750',C'k3G'        CR;LF;FF\n         DC   X'2750',C'l0S'        Simplex Print\n*        DC   X'2750',C'l5H'        Feed from Paper Deck\n         DC   X'2750',C'l1O'        Landscape\n         DC   X'27',C'(8U'          Roman-8 Symbol Set\n         DC   X'27',C'(s0P'         Pri Spacing is Fixed\n         DC   X'27',C'(s13H'        13 Pitch\n*        DC   X'27',C'(s15H'        15 Pitch\n*        DC   X'27',C'(s8.5V'       Point Size is 8.5\n         DC   X'27',C'(s0S'         Pri Style is Upright\n         DC   X'27',C'(s0B'         Pri Stroke is Normal\n         DC   X'27',C'(s0T'         Pri Typeface is Line Printer\n*        DC   X'2750',C'l8D'        8 lines per inch\n*        DC   X'2750',C'l4C'        VMI is 4 OR 12 LPI\n         DC   X'2750',C'l5.2C'      VMI is 5.2\n         DC   X'2750',C'l7E'        Top Margin is 7\n         DC   X'2750',C'a4L'        Left Margin is 4\n*        DC   X'2750',C'a10L'       Left Margin is 10\n*        DC   X'2750',C'a10M'       Right Margin is 10\n         DC   X'2750',C'a0R'        Cursor Position = Row 0\nLENGTH_PCLL   EQU *-PCLLAND\n*\n         DS   0F\nPCLPORT  DC   AL2(LENGTH_PCLP),AL2(00)\nPCLRCDP  DC   X'4027',C'E'          Reset\n         DC   X'2750',C'k3G'        CR;LF;FF\n         DC   X'2750',C'l0S'        Simplex Print\n*        DC   X'2750',C'l5H'        Feed from Paper Deck\n         DC   X'2750',C'l0O'        Portrait\n         DC   X'27',C'(8U'          Roman-8 Symbol Set\n         DC   X'27',C'(s0P'         Pri Spacing is Fixed\n         DC   X'27',C'(s12H'        12 Pitch\n*        DC   X'27',C'(s8.5V'       Point Size is 8.5\n         DC   X'27',C'(s0S'         Pri Style is Upright\n         DC   X'27',C'(s0B'         Pri Stroke is Normal\n         DC   X'27',C'(s0T'         Pri Typeface is Line Printer\n         DC   X'2750',C'l8D'        8 lines per inch\n*        DC   X'2750',C'l5.2727C'   VMI is 5.2727\n         DC   X'2750',C'l7E'        Top Margin is 7\n         DC   X'2750',C'a10L'       Left Margin is 10\n*        DC   X'2750',C'a10M'       Right Margin is 10\n         DC   X'2750',C'a0R'        Cursor Position = Row 0\nLENGTH_PCLP   EQU *-PCLPORT\n*\n         DS   0F\nPCLCICS  DC   AL2(LENGTH_PCLC),AL2(00)\nPCLRCDC  DC   X'4027',C'E'          Reset\n         DC   X'2750',C'k3G'        CR;LF;FF\n         DC   X'2750',C'l0S'        Simplex Print\n*        DC   X'2750',C'l5H'        Feed from Paper Deck\n         DC   X'2750',C'l0O'        Portrait\n         DC   X'27',C'(8U'          Roman-8 Symbol Set\n         DC   X'27',C'(s0P'         Pri Spacing is Fixed\n         DC   X'27',C'(s18H'        12 Pitch\n*        DC   X'27',C'(s8.5V'       Point Size is 8.5\n         DC   X'27',C'(s0S'         Pri Style is Upright\n         DC   X'27',C'(s0B'         Pri Stroke is Normal\n         DC   X'27',C'(s0T'         Pri Typeface is Line Printer\n         DC   X'2750',C'l5.2C'      VMI is 5.2727\n         DC   X'2750',C'l10E'       Top Margin is 10\n         DC   X'2750',C'a4L'        Left Margin is 4\n         DC   X'2750',C'a0R'        Cursor Position = Row 0\nLENGTH_PCLC   EQU *-PCLCICS\nHW1      DC   H'1'\nHW4      DC   H'4'\nHW5      DC   H'5'\nHW1024   DC   H'1024'\nMOVEPCL  MVC  0(0,R14),0(R2)\nOPTION1  DC   CL7'OPTION1'\nOPTION2  DC   CL7'OPTION2'\n         LTORG\n         SPACE 5\nIRXSTATD DSECT                    16 byte static IRE storage\nIRXDSTGA DS    A                  Address of dynamic storage area\nIRXFLAG  DS    X                  File status flag\nIRXNEW   EQU   X'00'              ... first record in file\nIRX2ND   EQU   X'01'              ... second record in file\nIRXTOP   EQU   X'10'              ... found first Top of Page\nIRXOLD   EQU   X'80'              ... not first record in file\n         DS    3X                 unused\nIRXRECP  DS    F                  Pointer to First Record\nIRXRECL  DS    F                  Length of first record\n         SPACE 5\nINRCSTG  DSECT\nSAVEAREA DS    18F                Save Area\n         DS    0D                 Round up to double word boundary\nSAVEREC  DS    1024X              Make this big enough\nINRCSTGL EQU   *-INRCSTG          Length of dynamic storage area\n         SPACE 5\n         EZAPPFCD IRE=DSECT,   DSECT for input record exit parameters  X\n               RDA=DSECT       DSECT for routing data area\n         SPACE 5\n         END   ,                   End of INRECXIT  module\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LCB": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00V\\x00V\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 86, "newlines": 86, "modlines": 0, "user": "WHS"}, "text": "/*   REXX  EXEC     */\n/* TRACE RESULTS    */\n ARG LISTCAT_DSNAME\n IF LISTCAT_DSNAME = '' THEN\n   DO\n   SAY 'PLEASE ENTER THE FULL NAME OF THE DATASET YOU WISH TO LIST'\n   PULL LISTCAT_DSNAME\n   IF LISTCAT_DSNAME = '' THEN\n    DO\n     SAY 'NO DATASET NAME SPECIFIED.'\n     EXIT 4\n    END\n  END\n  LISTCAT_DSNAME = STRIP(LISTCAT_DSNAME,B,'7D'X) /* IN CASE OF QUOTES */\n\n X = OUTTRAP(\"LISTCENT.\",1000,\"CONCAT\")\n\n \"LISTC ENT('\"LISTCAT_DSNAME\"') ALL\"\n CLUSTER_LIST = LISTCENT.0\n\n X = OUTTRAP(OFF)\n\n DO I = 1 TO LISTCENT.0\n  POS_REC_UPDATED = POS('REC-UPDATED',LISTCENT.I,1)\n  POS_TIMESTAMP   = POS(\" X'\",LISTCENT.I,1)\n  IF POS_REC_UPDATED \u00ac= 0 & POS_TIMESTAMP \u00ac= 0 THEN\n   DO\n    PARSE VAR LISTCENT.I REC_UPDATED FREESPACE_CA TIMESTAMP REMAINDER\n    LAST_MODIFIED = 'LAST MODIFIED -' TIMESTMP(TIMESTAMP)\n    LENGTH_LASTMOD = LENGTH(LAST_MODIFIED)\n LISTCENT.I = OVERLAY(LAST_MODIFIED,LISTCENT.I,POS_TIMESTAMP-4,LENGTH_LASTMOD)\n   END\n/*SAY LISTCENT.I */\n END\n\"ISPEXEC LMINIT DDNAME(LCIRDR) DATAID(LCRDID) ENQ(EXCLU)\"\n LCC = RC\n IF LCC \u00ac= 0 THEN\n  DO\n   \"ALLOC F(LCIRDR) NEW REUSE DSORG(PS) LRECL(133) RECFM(V B) BLKSIZE(8000)\"\n   \"ISPEXEC LMINIT DDNAME(LCIRDR) DATAID(LCRDID) ENQ(EXCLU)\"\n    LCC = RC\n    IF LCC \u00ac= 0 THEN\n     DO\n      SAY 'RC -' LCC ZERRSMG\n      EXIT\n     END\n   END\n   \"EXECIO\" LISTCENT.0 \"DISKW LCIRDR (STEM LISTCENT. FINIS\"\n  \"ISPEXEC BROWSE DATAID(\"LCRDID\")\"\n  \"FREE F(LCIRDR)\"\n\nEXIT\n/*******************************************************************/\nTIMESTMP:\n/* TRACE RESULTS */\n ARG TIME_STAMP\n NUMERIC DIGITS 24\n TIME_STAMP = TRANSLATE(TIME_STAMP,\"\",\"'X\")\n TIME_STAMP = STRIP(TIME_STAMP,B)\n LENGTH_TIMESTAMP = LENGTH(TIME_STAMP)\n IF  LENGTH_TIMESTAMP = 16 THEN\n   TIME_STAMP = SUBSTR(TIME_STAMP,1,13)\n ELSE\n  DO\n   IF LENGTH_TIMESTAMP \u00ac= 13 THEN\n    RETURN '*** ERROR ***'\n  END\n IF TIME_STAMP = '0000000000000' THEN\n   RETURN '** NO UPDATES **'\n INTERPRET \"SET_TIME = C2D('\"TIME_STAMP\"'X)\"\n SET_SECONDS = SET_TIME % 60000000\n MOD_HOUR = (SET_SECONDS // 1440) % 60\n MOD_HOUR = RIGHT(MOD_HOUR,2,0)\n MOD_MINUTE = ( (SET_SECONDS // 1440) // 60)\n MOD_MINUTE = RIGHT(MOD_MINUTE,2,0)\n MOD_TIME = MOD_HOUR':'MOD_MINUTE\n MOD_DATE = (SET_SECONDS % 1440) + 1\n MOD_YEAR = (MOD_DATE % 1461) * 4\n MOD_DAY = (MOD_DATE // 1461)\n IF MOD_DAY % 365 = 0 THEN MOD_DAY = MOD_DAY + 1\n MOD_YEAR = (MOD_DAY % 365) + MOD_YEAR\n MOD_YEAR = RIGHT(MOD_YEAR,2,'0')\n MOD_DAY  = MOD_DAY  // 365\n MOD_DAY  = RIGHT(MOD_DAY,3,0)\n MOD_DATE = MOD_YEAR'.'MOD_DAY\n RETURN MOD_DATE MOD_TIME\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MESSAGE": {"ttr": 4874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00r\\x00r\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 114, "newlines": 114, "modlines": 0, "user": "WHS"}, "text": "         MACRO\n         MESSAGE  &MSGID=,&FUNCTION=,&COMMAND=,&SEARCH=0,&SELECT=0,    X\n               &MULTLINE=0,&COLOR=0\n         LCLA  &FUNC1,&FUNC2\n&FUNC1   SETA  0\n&FUNC2   SETA  0\n&SINGQUOT SETC  ''''\n         AIF   ('&FUNCTION' EQ 'COMMAND').CMD,                         X\n               ('&FUNCTION' EQ 'REPLY').RPLY,                          X\n               ('&FUNCTION' EQ 'EXEC').EXEC,                           X\n               ('&FUNCTION' EQ 'HIGHLITE').HILITE,                     X\n               ('&FUNCTION' EQ 'EVENT').EVNT,                          x\n               ('&FUNCTION' EQ 'SUPPRESS').SPRSS\n        MNOTE  8,'AL001 FUNCTION MUST BE COMMAND, REPLY, EVENT OR EXEC'\n         AGO    .END\n.CMD     ANOP\n&FUNC1   SETA   1\n         AGO    .CONT1\n.RPLY    ANOP\n&FUNC1   SETA   2\n         AGO    .CONT1\n.EXEC    ANOP\n&FUNC1   SETA   4\n         AGO    .CONT1\n.HILITE  ANOP\n&FUNC1   SETA   128\n         AIF   ('&COLOR' EQ 'RED').RED\n         AGO    .CONT1\n.RED     ANOP\n&FUNC2   SETA   1\n         AGO    .CONT1\n.EVNT    ANOP\n&FUNC1   SETA   8\n         AGO    .CONT1\n.SPRSS   ANOP\n&FUNC2   SETA   4\n.CONT1   ANOP\n&LMSGID  SETC  'L''MSG&SYSNDX'\n&QUOTEM  SETC  '&MSGID'(1,1)\n&LCMD    SETC  'L''CMD&SYSNDX'\n&ENTLNG  SETC  'ENTL&SYSNDX'\n&QUOTE   SETC  '&COMMAND'(1,1)\n.*\n         AIF   ('&SEARCH' EQ '0').CONT2\n&LSRCH   SETC  'L''SCH&SYSNDX'\n&SCHLNG  SETC  'SCHL&SYSNDX'\n&QUOTEL  SETC  '&SEARCH'(1,1)\n&FUNC1   SETA  &FUNC1+16\n         AIF   ('&SELECT' EQ '0').CONT2,                               X\n               ('&SELECT' EQ 'SELECT').CONT2,                          X\n               ('&SELECT' EQ 'JOBNAME').JBNME\n  MNOTE  8,'AL002 SELECT OR JOBNAME ARE THE ONLY VALID SELECT KEYWORDS'\n         AGO    .END\n.JBNME   ANOP\n&FUNC1   SETA   &FUNC1+32\n&LSRCH   SETC   '8'\n.*\n.CONT2   ANOP\n         AIF   ('&MULTLINE' EQ '0').CONT3,                             X\n               ('&MULTLINE' EQ 'NO').CONT3,                            X\n               ('&MULTLINE' EQ 'YES').MULTIL,                          X\n               ('&MULTLINE' EQ 'ALL').MULTALL\n        MNOTE  8,'AL002 YES OR NO ARE THE ONLY VALID MUTLLINE KEYWORDS'\n         AGO    .END\n.MULTIL  ANOP\n&FUNC1   SETA   &FUNC1+64\n         AGO    .CONT3\n.MULTALL ANOP\n&FUNC1   SETA   &FUNC1+64\n&FUNC2   SETA   &FUNC2+2\n.CONT3   ANOP\nENT&SYSNDX  DC    AL2(&ENTLNG)\n            DC    AL1(&LMSGID)\n            AIF   ('&QUOTEM' EQ '&SINGQUOT').NOQUOTM\nMSG&SYSNDX  DC    C'&MSGID'             MESSAGE ID\n            AGO   .ENDMSGID\n.NOQUOTM ANOP\nMSG&SYSNDX  DC    C&MSGID               MESSAGE ID\n.ENDMSGID   ANOP\n            DC    AL1(&FUNC1)           FUNCTION TO PERFORM\n            DC    AL1(&FUNC2)           RESERVED\n.*\n            DC    AL1(&LCMD)\n.*\n         AIF   ('&QUOTE' EQ '&SINGQUOT').NOQUOTE\nCMD&SYSNDX  DC    C'&COMMAND'         COMMAND, REPLY OR FIELD TO PASS\n         AGO   .ENDCMD\n.NOQUOTE ANOP\nCMD&SYSNDX  DC    C&COMMAND           COMMAND, REPLY OR FIELD TO PASS\n.*\n.*\n.ENDCMD  ANOP\n         AIF   ('&SEARCH' EQ '0').ENDSRCH,\n.*\n            DC    AL1(&LSRCH)\n.*\n         AIF   ('&QUOTEL' EQ '&SINGQUOT').NOQUOTS\n         AIF   ('&SELECT' EQ 'JOBNAME').JBNME8\nSCH&SYSNDX  DC    C'&SEARCH'          SEARCH ARGUMENT\n         AGO   .ENDSRCH\n.JBNME8  ANOP\nSCH&SYSNDX  DC    CL8'&SEARCH'          SEARCH ARGUMENT\n         AGO   .ENDSRCH\n.NOQUOTS ANOP\n         AIF   ('&SELECT' EQ 'JOBNAME').NOQJBN8\nSCH&SYSNDX  DC    C&SEARCH            SEARCH ARGUMENT\n         AGO   .ENDSRCH\n.NOQJBN8 ANOP\nSCH&SYSNDX  DC    CL8&SEARCH            SEARCH ARGUMENT\n.*\n.ENDSRCH ANOP\nENTL&SYSNDX  EQU  *-ENT&SYSNDX\n.END     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MSGTABLE": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x003\\x003\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 51, "newlines": 51, "modlines": 0, "user": "WHS"}, "text": "         PRINT ON,GEN\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* DESCRIPTION - Table built and assemble/linked by AutoOps system   *\n*               Sample entries included. When you are ready to use  *\n*               then remove ALL MESSAGE statements and use the      *\n*               ISPF/REXX interface.                                *\n*********************************************************************\nMSGTABLE CSECT\nSTART    EQU   *\n         DC    AL2(LENGTH)\n         MESSAGE MSGID='CBR3750I',FUNCTION=HIGHLITE,                   +\n               COMMAND='NULL',                                         +\n               SEARCH='service call is required',                      +\n               SELECT=SELECT,                                          +\n               COLOR=RED\n         MESSAGE MSGID='IKJ606I',FUNCTION=EXEC,                        +\n               COMMAND='S OPSAUTO'\n         MESSAGE MSGID='ICH302D',FUNCTION=EXEC,                        +\n               COMMAND='S OPSAUTO'\n         MESSAGE MSGID='$HASP373',FUNCTION=EXEC,                       +\n               COMMAND='S OPSAUTO',                                    +\n               SEARCH='PRODJOB1',                                      +\n               SELECT=JOBNAME\n         MESSAGE MSGID='IEA794I',FUNCTION=EXEC,                        +\n               COMMAND='S OPSAUTO'\n         MESSAGE MSGID='IEC070I',FUNCTION=EXEC,                        +\n               COMMAND='S OPSAUTO',                                    +\n               SEARCH='104-204',                                       +\n               SELECT=SELECT\n         MESSAGE MSGID='IEA405E',FUNCTION=EXEC,                        +\n               COMMAND='S OPSAUTO'\n         MESSAGE MSGID='IEA404A',FUNCTION=COMMAND,                     +\n               COMMAND='K M,MLIM=4500'\n         MESSAGE MSGID='$HASP183',FUNCTION=EXEC,                       +\n               COMMAND='S OPSAUTO',                                    +\n               SEARCH='HELD,',                                         +\n               SELECT=SELECT\nLENGTH   EQU   *-START\n          END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OPSAUTO": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 11, "newlines": 11, "modlines": 0, "user": "WHS"}, "text": "//OPSAUTO    PROC  M1=,M2=\n//*\n//*\n//STEP1      EXEC  PGM=IKJEFT01,DYNAMNBR=25,PARM='&M1&M2'\n//SYSPRINT   DD    SYSOUT=*\n//SYSTSPRT   DD    SYSOUT=*\n//* PDS WHERE YOU HAVE PLACED THE MESSAGE/REXX EXECS TO BE USED\n//SYSEXEC    DD    DSN=SYSX.AUTOOPS.REXX,DISP=SHR\n//SYSTSIN    DD    DUMMY\n//CMDIN      DD    UNIT=3390,SPACE=(TRK,(1,1)),DCB=(LRECL=80,\n//           BLKSIZE=800,RECFM=FB)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSPCLOD": {"ttr": 5122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 28, "newlines": 28, "modlines": 0, "user": "WHS"}, "text": "/*  REXX  */\n/* TRACE ?RESULTS */\n FLAG = 'N'     /* SET FLAG INITIALLY TO NO */\n SAY 'ENTER THE NAME OF THE INPUT FILE; E.G. C:\\CBT\\SOURCE.TXT '\n PULL INFILE\n SAY 'ENTER THE NAME OF THE OUTPUT DIRECTORY; E.G. C:\\CBT\\SOURCE\\'\n PULL OUTDIR\n  OUTFILE = ' '\n /* LINEIN(INFILE) */\n DO UNTIL DONE = 'YES'\n  PARSE VALUE LINEIN(INFILE) WITH RECORD\n  SELECT\n\n   WHEN WORD(RECORD,1) = './' & WORD(RECORD,2) = 'ENDUP' THEN\n    DONE = 'YES'\n\n   WHEN WORD(RECORD,1) = './' & WORD(RECORD,2) = 'ADD' THEN\n    DO\n     MEMBER = WORD(TRANSLATE(WORD(RECORD,3),\" \",\"=\"),2)\n     SAY 'DOING MEMBER' MEMBER\n     OUTFILE = OUTDIR||MEMBER||'.TXT'\n    END\n\n   OTHERWISE\n    WRITE = LINEOUT(OUTFILE,RECORD)\n  END\n END\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSRELDV": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xe7\\x00\\xe7\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 231, "newlines": 231, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'PDSRELDV - Program to reload a PDS Unloaded with PDSUNLDV'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 24                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  NOT APF AUTHORIZED                               *\n*                                                                   *\n*  Function  - Will take a file in PDSUNLDV or IEBUPDTE unloaded    *\n*              format and reload into a PDS.                        *\n*                                                                   *\n*  JCL       -                                                      *\n*        //JOBNAME JOB (ACCT),'PROGRAMMER   ',MSGCLASS=X,CLASS=X,   *\n*        //      NOTIFY=&SYSUID                                     *\n*        //STEP1  EXEC  PGM=PDSRELDV                                *\n*        //STEPLIB  DD  DSN=PREFIX.ISPF.LOADLIB,DISP=SHR            *\n*        //SEQINFIL DD  DSN=PREFIX.UNLDFILE.UNLOAD,DISP=SHR         *\n*        //OUTFILE  DD  DSN=PREFIX.FILE.PDS,DISP=(,CATLG),          *\n*        //     SPACE=(TRK,(9,9,40))                                *\n*        //SYSUDUMP DD  SYSOUT=*                                    *\n*                                                                   *\n*********************************************************************\nPDSRELDV CSECT\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRC4      EQU   4\nRC8      EQU   8\nRC16     EQU   16\n               EJECT\n****************************************************************\n*  SAVE LOGIC TO CONSERVE ON REGISTERS. R13 IS USED AS BOTH    *\n*  THE BASE REGISTER AND THE POINTER TO THE 18 WORD SAVE AREA. *\n****************************************************************\n         B     72(R15)             BRANCH AROUND THE SAVE AREA\n         DS    17F                 THIS AND THE PRIOR BR ARE 18F SAVE\n         STM   R14,R12,12(R13)     SAVE IN CALLERS SAVEAREA\n         ST    R13,4(R15)          SAVE IN OUR SAVE AREA\n         ST    R15,8(R13)          STORE OUR SAVE AREA ADDR IN THEIRS\n         LR    R13,R15             SET UP AS SAVE AND BASE REG\n         USING PDSRELDV,R13\n**************************************\n*  LETS GO AHEAD AND ACQUIRE STORAGE *\n**************************************\n         LH   R0,HW32760\n         ST   R0,GETMAIN_LENGTH  SAVE THIS LENGTH FOR LATER\n         GETMAIN R,LV=(0)\n         ST   R1,STRADDR1\n*******************************************************************\n***********************************************\n*   OPEN THE PDS AND PROCESS THE MEMBER LIST  *\n***********************************************\n         OPEN  (SEQINFIL)\n         TM    SEQINFIL+48,X'10'  GOOD OPEN ??\n         BO    OPENOK2            YES, THEN CONTINUE EUROK\n         WTO   'UNABLE TO OPEN SEQINFIL FILE FOR INPUT'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK2  EQU   *\n         MVC   OUTFILE+62(2),SEQINFIL+62\n         MVC   OUTFILE+82(2),SEQINFIL+82\n         MVC   OUTFILE+36(1),SEQINFIL+36\n         OPEN  (OUTFILE,(OUTPUT))\n         TM    OUTFILE+48,X'10'  GOOD OPEN ??\n         BO    SETUP_REGS         YES, THEN CONTINUE EUROK\n         WTO   'UNABLE TO OPEN OUTFILE FILE FOR OUTPUT'\n         MVI   RETCODE+3,RC16\n         CLOSE SEQINFIL\n         B     FREE_STORAGE\nSETUP_REGS     EQU   *\n         L     R12,STRADDR1\n         LH    R4,SEQINFIL+82             GET THE LRECL IN R4\nLOOPGET  EQU   *\n         GET   SEQINFIL\n         LR    R3,R1\n         LR    R9,R3\n         TM    SEQINFIL+36,X'40'          WAS IT VARIABLE LENGTH\n         BZ    CHKFIRST                   NO, THEN CONTINUE\n         LA    R9,4(R9)                   GET PAST RDW UP FRONT\nCHKFIRST CLI   ADDNAME,C' '               HAVE WE DONE THE FIRST ENTRY\n         BNE   NOTFRST                    NO, THEN CONTINUE\n         SLR   R11,R11                    TO MAINTAIN THE COUNT\n         TM    SEQINFIL+36,X'40'          WAS IT VARIABLE LENGTH\n         BZ    MOVEADD                    NO, THEN CONTINUE\n         LA    R12,4(R12)                 MOVE PAST THE BDW\n         LA    R11,4(R11)                 INCREMENT FOR THE BDW\n* MOVE IN THE NAME USING EXECUTE INSTRUCTION\n         SLR   R15,R15                    CLEAR FOR INSERT\n         ICM   R15,3,0(R3)                GET THE RDW LENGTH\n         SH    R15,HW17\n         CH    R15,HW7                    JUST VERIFY NOT TOO BIG\n         BNH   MOVEITIN\n         LH    R15,HW7                    RESET TO DEFAULT MOVE OF 8\nMOVEITIN EX    R15,MOVENAME               MVC   ADDNAME(0),12(R9)\n         B     LOOPGET\n*  THIS IS THE MOVE FOR FB OR F FILES\nMOVEADD  MVC   ADDNAME(8),12(R9)\n         B     LOOPGET\nNOTFRST  CLC   0(12,R9),ADDRECD\n         BE    WRITBLOK\n         CLC   0(10,R9),ENDRECD\n         BE    WRITBLOK\n         TM    SEQINFIL+36,X'40'          WAS IT VARIABLE LENGTH\n         BZ    NOTVB                      NO, THEN CONTINUE\n         ICM   R4,3,0(R3)                   GET THE RDW LENGTH\nNOTVB    LR    R15,R4                     LOAD THE RECORD LENGTH IN R15\n         BCTR  R15,0                      DECR 1 FOR EXECUTE\n         EX    R15,MOVERECD               MVC   0(0,R12),0(R3)\n         LA    R11,0(R4,R11)              ADD TO THE TOTAL\n         LA    R12,0(R4,R12)              AND INCREMENT THE POINTER\n         TM    SEQINFIL+36,X'40'          WAS IT VARIABLE LENGTH\n         BZ    NOTVB2                     NO, THEN CONTINUE\n         LH    R15,SEQINFIL+82            GET THE LRECL IN R15\n         LA    R15,0(R15,R11)             WILL THIS EXCEED THE BLKSIZE\n         CH    R15,SEQINFIL+62            COMPARE AGAINST THE BLKSIZE\n         BL    LOOPGET                    LT GO AHEAD AND READ ANOTHER\n         L     R14,STRADDR1               GET BEGINNING OF STORAGE\n         STH   R11,0(R14)                 STORE THE BDW\n         BH    WRITBLOK                   GT GO AHEAD AND WRITE THE BLK\nNOTVB2   CH    R11,SEQINFIL+62            COMPARE THE BLKSIZE\n         BL    LOOPGET\nWRITBLOK L     R12,STRADDR1\n         LTR   R11,R11                    IS THIS ZERO\n         BZ    STOWIT                     YES, THEN LAST RECORD\n         MVC   SAVBLKSZ(2),OUTFILE+62     SAVE THE BLOCKSIZE\n         STH   R11,OUTFILE+62             SAVE IN DCB\n         TM    SEQINFIL+36,X'40'          WAS IT VARIABLE LENGTH\n         BZ    WRITEIT                    NO, THEN CONTINUE\n         STH   R11,0(R12)                 SAVE THE BDW\nWRITEIT  EQU   *\n         WRITE OUTDECB,SF,OUTFILE,(12),(11)\n         CHECK OUTDECB\n         SLR   R11,R11                    CLEAR R11\n         MVC   OUTFILE+62(2),SAVBLKSZ     SAVE THE BLOCKSIZE\n         TM    SEQINFIL+36,X'40'          WAS IT VARIABLE LENGTH\n         BZ    DONTINCR                   NO, THEN CONTINUE\n         LA    R11,4(R11)                 INCR THIS FOR LATER\n         LA    R12,4(R12)                 SAME HERE\nDONTINCR CLC   0(12,R9),ADDRECD\n         BE    STOWIT\n         CLC   0(10,R9),ENDRECD\n         BE    STOWIT\n         TM    FLAG,X'01'\n         BZ    LOOPGET\nSTOWIT   STOW  OUTFILE,ADDNAME,A  BLKSIZE\n         LTR   R15,R15            SEE IF OK ADD\n         BZ    CONTINUE\n         MVC   BADADD+4(8),ADDNAME\n         WTO   MF=(E,BADADD)      TELL THEM IT WAS A BAD ADD\nCONTINUE TM    FLAG,X'01'         DID WE HIT EODAD\n         BO    CLOSEUP            YES, THEN GO CLOSEUP\n         CLC   0(10,R9),ENDRECD   IS IT THE LAST RECORD\n         BE    CLOSEUP            ADDRESS PAST BDW\n         SLR   R11,R11            CLEAR COUNTER HERE\n         TM    SEQINFIL+36,X'40'   WAS IT VARIABLE LENGTH\n         BZ    MOVEADD2           NO, THEN CONTINUE\n* MOVE IN THE NAME USING EXECUTE INSTRUCTION\n         MVC   ADDNAME(8),BLANKS          CLEAR THE FIELD\n         SLR   R15,R15                    CLEAR FOR INSERT\n         ICM   R15,3,0(R3)                GET THE RDW LENGTH\n         SH    R15,HW17\n         CH    R15,HW7                    JUST VERIFY NOT TOO BIG\n         BNH   MOVEITI2\n         LH    R15,HW7                    RESET TO DEFAULT MOVE OF 8\nMOVEITI2 EX    R15,MOVENAME               MVC   ADDNAME(0),12(R9)\n         B     LOOPGET                    MOVE IN THE NAME\nMOVEADD2 MVC   ADDNAME(8),12(R9)  MOVE IN THE MEMBER NAME\n         B     LOOPGET                    MOVE IN THE NAME\nEODAD    OI    FLAG,X'01'         FLAG IT, SHOULD NEVER GET HERE\n         LTR   R11,R11            CHECK TO SEE IF ANYTHING TO WRITE\n         BNZ   WRITBLOK           YES, THEN WRITE IT\n         B     STOWIT             LOOP BACK, STOW AND GET OUT\nCLOSEUP  CLOSE (SEQINFIL,,OUTFILE)\nFREE_STORAGE  EQU   *\n         L    R0,GETMAIN_LENGTH   GET THE LEGNTH\n         L    R1,STRADDR1         GET  THE LOCATION\n         FREEMAIN R,LV=(0),A=(1)\nEXIT     L     R15,RETCODE\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nSEQINFIL DCB   DDNAME=SEQINFIL,MACRF=GL,DSORG=PS,EODAD=EODAD\nOUTFILE  DCB   DDNAME=OUTFILE,MACRF=W,DSORG=PO\nDOUBLE_WORD  DC D'0'\nSTRADDR1 DC     F'0'\nGETMAIN_LENGTH  DC F'0'\nRETCODE  DC    F'0'\nMOVERECD MVC   0(0,R12),0(R3)\nMOVENAME MVC   ADDNAME(0),12(R9)\nSAVBLKSZ DC    H'0'\nHW1      DC    H'1'\nHW4      DC    H'4'\nHW17     DC    H'17'\nHW7      DC    H'7'\nHW32760  DC    H'32760'\nBLANKS   DC    CL8' '\nADDRECD  DC    CL12'./ ADD NAME='\nADDNAME  DS    0F\n         DC    CL8' ',F'00'\nENDRECD  DC    CL10'./ ENDUP '\nENDNAME  DC    CL8' '\nFLAG     DC    X'00'\nBADADD   WTO   '         WAS NOT ADDED BECAUSE IT ALREADY EXISTED.',   X\n               MF=L\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSUNLDV": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xff\\x00\\xff\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 255, "newlines": 255, "modlines": 0, "user": "WHS"}, "text": "*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 24                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  NOT APF AUTHORIZED                               *\n*                                                                   *\n* DESCRIPTION - PROGRAM TO UNLOAD A PDS TO A SEQUENTIAL FILE SO     *\n*               SO THAT IT CAN BE OFFLOADED.                        *\n*                                                                   *\n*  JCL       -                                                      *\n*        //JOBNAME JOB (ACCT),'PROGRAMMER   ',MSGCLASS=X,CLASS=X,   *\n*        //      NOTIFY=&SYSUID                                     *\n*        //STEP1  EXEC  PGM=PDSUNLDV                                *\n*        //STEPLIB  DD  DSN=PREFIX.ISPF.LOADLIB,DISP=SHR            *\n*        //PDSINFIL DD  DSN=PREFIX.YOUR.PDS,DISP=SHR                *\n*        //OUTFILE  DD  DSN=PREFIX.YOUR.UNLOAD,DISP=(,CATLG),       *\n*        //     SPACE=(TRK,(9,9),RLSE)                              *\n*        //SYSUDUMP DD  SYSOUT=*                                    *\n*                                                                   *\n*********************************************************************\nPDSUNLDV CSECT\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRC4      EQU   4\nRC8      EQU   8\nRC16     EQU   16\n               EJECT\n****************************************************************\n*  SAVE LOGIC TO CONSERVE ON REGISTERS. R13 IS USED AS BOTH    *\n*  THE BASE REGISTER AND THE POINTER TO THE 18 WORD SAVE AREA. *\n****************************************************************\n         B     72(R15)             BRANCH AROUND THE SAVE AREA\n         DS    17F                 THIS AND THE PRIOR BR ARE 18F SAVE\n         STM   R14,R12,12(R13)     SAVE IN CALLERS SAVEAREA\n         ST    R13,4(R15)          SAVE IN OUR SAVE AREA\n         ST    R15,8(R13)          STORE OUR SAVE AREA ADDR IN THEIRS\n         LR    R13,R15             SET UP AS SAVE AND BASE REG\n         LA    R12,2048(R13)       ADDR TO SECOND BASE REG\n         LA    R12,2048(R12)       FINISH THE 4096 INCR\n         USING PDSUNLD,R13,R12\n**************************************\n*  LETS GO AHEAD AND ACQUIRE STORAGE *\n**************************************\n         LH   R0,HW256\n         L    R5,MEMBER_LENGTH\n         AR   R0,R5\n         LH   R4,HW32760\n         AR   R0,R4\n         ST   R0,GETMAIN_LENGTH  SAVE THIS LENGTH FOR LATER\n         GETMAIN R,LV=(0)\nGET_STORAGE ST  R1,GETMAIN_ADDRESS SAVE THE STORAGE ADDRESS\n         LR   R7,R1\n         LA   R11,256(R7)\n         ST   R11,MEMBER_ADDRESS\n         LA   R5,0(R11,R5)\n         ST   R5,READBLOK_ADDRESS\n*******************************************************************\nOPENDIR  EQU   *\n         OPEN  (DIRREAD)           OPEN PDS TO READ DIRECTORY\n         TM    DIRREAD+48,X'10'    OPEN SUCCESSFUL\n         BO    OPENOK              NO, THEN QUIT\n         WTO   'UNABLE TO OPEN DIRECTORY'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK   EQU   *\n         SLR   R3,R3\n         LA    R11,2(R11)   POINT PAST DIRECTORY READ AND LENGTH FLD\nLOCSET   READ  DIRDECB,SF,DIRREAD,(7)\n         CHECK DIRDECB\nRDNXTDIR EQU   *\nLIST0    LR    R10,R7              R10 POINTS TO FIELD READ\n         LH    R9,0(R10)           R9 CONTAINS LENGTH OF RECORD\n         AR    R9,R10              POINT TO END OF LIST\n         LA    R10,2(R10)          ADDRESS MEMBER\nLIST1    CLC   0(8,R10),FFFLAG     IS THIS THE LAST DIRECTORY ENTRY\n         BE    DIRENDL             YES, THEN CLOSE IT AND GET TO WORK\nLIST2    MVC   0(12,R11),0(R10)    MOVE IN MMBR NAME,TTR, AND ALIAS BIT\n         LA    R3,1(R3)            INCR. COUNTER FOR MEMBERS\nINCRMBRA LA    R11,12(R11)         INCR. INPUT MEMBER LIST\nGETPAST  IC    R14,11(R10)          GET # OF USER HALFWORDS\n         N     R14,FW31             ZERO OUT HI ORDER BITS\n         SLA   R14,1                MULTIPLY BY TWO\n         LA    R14,12(R14)          ADD THE CONSTANT SECTION TO IT\n         AR    R10,R14             AND THEN INCREMENT R10\n         CR    R10,R9              ARE WE AT THE END OF THIS READ\n         BL    LIST1               NO, THEN PROCESS THE NEXT\n         B     LOCSET              READ NEXT RECORD\n         EJECT\n******************************************************\n* THIS NEXT SECTION IS ENTERED IF EODAD IS HIT OR AN *\n* I/O ERROR OCCURS                                   *\n******************************************************\nNOTDIR   EQU   *\n         CLOSE DIRREAD             CLOSE DIRECTORY\n         WTO   'DIRECTORY SHOULD NOT HAVE REACHED EODAD'\n         MVI   RETCODE+3,RC8\n         B     FREE_STORAGE\n*******************************************************************\n* WE HAVE FINISHED A GOOD READING OF THE DIRECTORY AND WILL CLOSE *\n* IT, VERIFY IT HAS MEMBERS AND THEN PROCESS THE PDS              *\n*******************************************************************\nDIRENDL  MVC   1(8,R11),FFFLAG    FLAG END OF MEMBER LIST\n         CLOSE DIRREAD             CLOSE DIRECTORY\n         L     R11,MEMBER_ADDRESS  RELOAD R11 POINTER\n         LTR   R3,R3              VERIFY THAT AT LEAST 1 MEMBER EXIST\n         BNZ   STRR3              YES, THEN GO AND SAVE IT BOB\n         WTO   'NO MEMBERS IN PDS; FORGET IT'\n         MVI   RETCODE+3,RC8\n         B     FREE_STORAGE\nSTRR3    STCM  R3,3,0(R11)          SAVE THE NUMBER OF MEMBERS FOUND\n         LA    R11,2(R11)           POINT PAST LENGTH\n***********************************************\n*   OPEN THE PDS AND PROCESS THE MEMBER LIST  *\n***********************************************\n         OPEN  PDSINFIL\n         TM    PDSINFIL+48,X'10'  GOOD OPEN ??\n         BO    OPENOK2            YES, THEN CONTINUE EUROK\n         WTO   'UNABLE TO OPEN PDSUPDT FILE FOR INPUT'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK2  EQU   *\n         MVC   OUTFILE+62(2),PDSINFIL+62\n         MVC   OUTFILE+82(2),PDSINFIL+82\n         MVC   OUTFILE+36(1),PDSINFIL+36\n         OPEN  (OUTFILE,(OUTPUT))\n         TM    OUTFILE+48,X'10'  GOOD OPEN ??\n         BO    LOOPFIND           YES, THEN CONTINUE EUROK\n         WTO   'UNABLE TO OPEN OUTFILE FILE FOR OUTPUT'\n         MVI   RETCODE+3,RC16\n         CLOSE PDSINFIL\n         B     FREE_STORAGE\nLOOPFIND EQU   *\n         FIND  PDSINFIL,(11),D\n         LTR   R15,R15\n         BZ    GOODFIND\n         ABEND 002,DUMP        JUST QUIT\nGOODFIND EQU   *\n         MVC   ADDNAME(8),0(R11)\n         TM    PDSINFIL+36,X'40'  IS IT VARIABLE LENGTH BLOCK\n         BZ    PUTFIXED           NO, THEN WRITE OUT FIXED RECORD\n         PUT   OUTFILE,ADDRECDV   YES, THEN WRITE OUT VARIABLE RECORD\n         B     LOOPREAD\nPUTFIXED EQU   *\n         PUT   OUTFILE,ADDRECD\nLOOPREAD EQU   *\n         READ  PDSDECB,SF,PDSINFIL,(5)\n         CHECK PDSDECB\n         TM    FLAG,X'01'         SEE IF RECOVERY ENTERED\n         BZ    NO_ERROR\n         MVI   FLAG,X'00'         RESET FLAG\n         B     EODAD\nNO_ERROR LH    R6,PDSINFIL+62     BLKSIZE\n         L     R7,PDSDECB+16      IOB\n         SH    R6,14(R7)\n         SRDL  R6,32\n         TM    PDSINFIL+36,X'40'  IS IT VARIABLE LENGTH BLOCK\n         BZ    SETDIVID           NO, THEN PROCESS FIXED\n         LA    R8,4(R5)           ADDRESS PAST BDW\n         B     LOOPWRIT\nSETDIVID LH    R9,PDSINFIL+82    LRECL\n         DR    R6,R9             GET THE BRANCH COUNT (ONLY GOOD IF FB)\n         LR    R8,R5\nLOOPWRIT PUT   OUTFILE,(8)\n         TM    PDSINFIL+36,X'40'  IS IT VARIABLE LENGTH BLOCK\n         BZ    ITSFIXED           NO, THEN PROCESS FIXED BLOCK\n         SLR   R15,R15            CLEAR FOR INSERT\n         ICM   R15,3,0(R8)        GET THE RDW LENGTH IN R15\n         LA    R8,0(R8,R15)       INCREMENT TO NEXT RECORD\n         SLR   R7,R15             DECR THE RDW\n         CH    R7,HW4             ACCOUNT FOR THE BDW\n         BH    LOOPWRIT           GT 4, THEN MORE RECORDS\n         B     LOOPREAD           GET THE NEX\nITSFIXED LA    R8,0(R9,R8)\n         BCT   R7,LOOPWRIT\n         B     LOOPREAD\nEODAD    LA    R11,12(R11)\n         BCT   R3,LOOPFIND        IF IT FALLS THRU THEN WE ARE DONE\n         MVC   ENDNAME(8),ADDNAME\nWRITEND  TM    PDSINFIL+36,X'40'  IS IT VARIABLE LENGTH BLOCK\n         BZ    PUTENDFB           NO, THEN WRITE OUT FIXED RECORD\n         PUT   OUTFILE,ENDRECDV   YES, THEN WRITE OUT VARIABLE RECORD\n         B     CLOSEUP\nPUTENDFB PUT   OUTFILE,ENDRECD\nCLOSEUP  EQU   *\n         CLOSE (PDSINFIL,,OUTFILE)\n********************************************************************\n*   CLEANUP   TO GO HOME                                           *\n********************************************************************\nFREE_STORAGE   EQU  *\n         L     R1,GETMAIN_ADDRESS\n         L     R0,GETMAIN_LENGTH\n         FREEMAIN R,LV=(0),A=(1)\nEXIT     L     R15,RETCODE\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nRECOVER  OI    FLAG,X'01'\n         BR    R14\nDIRREAD  DCB   MACRF=R,DSORG=PS,DDNAME=PDSINFIL,EODAD=NOTDIR,          X\n               BLKSIZE=256,LRECL=256,RECFM=F\nPDSINFIL DCB   DDNAME=PDSINFIL,MACRF=(R),DSORG=PO,EODAD=EODAD,         X\n               SYNAD=RECOVER\nOUTFILE  DCB   DDNAME=OUTFILE,MACRF=PM,DSORG=PS\nDOUBLE_WORD  DC    D'0'\nRDJFCB1  RDJFCB (PDSINFIL,),MF=L\nGETMAIN_ADDRESS DC F'0'\nGETMAIN_LENGTH  DC F'0'\nMEMBER_ADDRESS DC F'0'\nMEMBER_LENGTH  DC F'40000'\nREADBLOK_ADDRESS DC F'0'\nRETCODE  DC    F'0'\nFW31     DC    F'31'\nHW1      DC    H'1'\nHW4      DC    H'4'\nHW256    DC    H'256'\nHW32760  DC    H'32760'\nFFFLAG   DC    8X'FF'\nFLAG     DC    X'00'\nADDRECDV DC    H'24',H'00'\nADDRECD  DS    0CL80\n         DC    CL12'./ ADD NAME='\nADDNAME  DC    CL68' '\nENDRECDV DC    H'22',H'00'\nENDRECD  DS    0CL80\n         DC    CL10'./ ENDUP '\nENDNAME  DC    CL70' '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSCLKPDS": {"ttr": 5134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00U\\x00U\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 85, "newlines": 85, "modlines": 0, "user": "WHS"}, "text": "SSCLKPDS CSECT\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n* LINKAGE INFORMATION - AMODE 24                                    *\n*                  RMODE 24                                         *\n*                  NON-REENTRANT                                    *\n*                  NOT APF AUTHORIZED                               *\n*                                                                   *\n* DESCRIPTION -  THIS PROGRAM WAS WRITTEN TO ALLOW FOR THE CHANGE   *\n*                PDS PROGRAM, SSCUCPDS, TO SUPPORT MULTIPLE INPUT   *\n*                ARGUMENTS. WHATEVER YOU NAME THE MASS EDIT PDS     *\n*                PROGRAM, YOU MUST CHANGE THIS PROGRAM TO REFLECT   *\n*********************************************************************\n         PRINT ON,NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n****************************************************************\n*  SAVE LOGIC TO CONSERVE ON REGISTERS. R13 IS USED AS BOTH    *\n*  THE BASE REGISTER AND THE POINTER TO THE 18 WORD SAVE AREA. *\n****************************************************************\n         B     80(R15)\n         DS    17F\n         DC    CL8'SSCLKPDS'\n         STM   R14,R12,12(R13)\n         ST    R13,4(R15)\n         ST    R15,8(R13)\n         LR    R13,R15\n         USING SSCLKPDS,R13\n         ST    R1,PARMADDR\n         OPEN  (SYSIN)\n         TM    SYSIN+48,X'10'\n         BO    OPENOK\n         WTO   'UNABLE TO OPEN SYSIN DATASET'\n         MVI   RCODE+3,X'10'\n         B     RETURN\nOPENOK   SLR   R3,R3\n         LA    R4,RECORD\nLOOPGET  GET   SYSIN,RECORD\n         LOAD  EP=SSCUCPDS\n         LR    R15,R0\n         L     R1,PARMADDR\n         BALR  R14,R15\n         LA    R3,1(R3)\n         CH    R15,=H'4'\n         BNH   LOOPGET\n         ST    R15,RCODE\n         WTO   'BAD INPUT RECORD; OR SOMETHING LIKE THAT'\nEOD      CLOSE SYSIN\nRETURN   L     R15,RCODE\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nSYSIN   DCB    DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=EOD\n*YSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=PM,BLKSIZE=80,RECFM=F,     +\n*              LRECL=80\nRECORD   DC    CL80' '\nRCODE    DC    F'00'\nPARMADDR DC    F'00'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSCUCPDS": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x06\\xdd\\x06\\xdd\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 1757, "newlines": 1757, "modlines": 0, "user": "WHS"}, "text": "********************************************************************\n* AUTHOR - BILL SWEENEY                                            *\n*     SSC, INC.                                                    *\n*     WHSWEENEY@SSCMAINFRAME.COM                                   *\n*     WWW.SSCMAINFRAME.COM                                         *\n* DATE - (C) COPYRIGHT 2004                                        *\n*                                                                  *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL         *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR        *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.          *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS            *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.             *\n*                                                                  *\n* LINKAGE INFORMATION - AMODE 31                                   *\n*                  RMODE 24                                        *\n*                  NON-REENTRANT                                   *\n*                  NOT APF AUTHORIZED                              *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*    WRITTEN AND MODIFIED BETWEEN THE PERIODS OF AUGUST 1984 THRU  *\n*  DECEMBER 31 1984 BY BILL SWEENEY. THE EDITING GETS A BIT HAIRY  *\n*  WHEN TRYING TO MAINTAIN COLUMN 72 FROM BEING OVERWRITTEN AND    *\n*  CAUSING PROBLEMS. GOOD LUCK.                                    *\n********************************************************************\n*   THIS IS NOW 3 MAR 86 AND WE ARE GOING BACK INTO THIS PROGRAM;  *\n*  PRIOR TO THIS    WE HAD COME TO THE END OF THE TWO BASE REGISTER*\n*  LIMIT, AND A THIRD WAS OUT OF THE QUESTION. IT HAS SAT DORMANT  *\n*  TILL THEN, BUT NOW, WE HAVE REALIZED OUR IGNORANCE AND WILL USE *\n*  SOME LOCAL ADDRESSABILITY IN DIFFERENT SECTIONS OF CODE.        *\n*    ANOTHER ENHANCEMENT WAS THE REALIZATION THAT BLDL PROCESSING  *\n*  AND CERTAIN GETMAINS WERE INEFFICIENT AND PERHAPS EVEN UNNECESS-*\n*  ARY. SO, SOME GETMAINS WERE COMBINED, AND BLDL PROCESSING WILL  *\n*  BE DONE WHILE READING IN THE DIRECTORY ( MEMBER,TTR,ALIAS BIT IS*\n*  ALL WE REALLY NEEDED).                                          *\n*    PROGRAM WILL ALSO HANDLE SEQUENTIAL FILES IF THE DDNAME IS    *\n*  PREFIXED WITH 'SEQ'. THIS WAS NOTHING REALLY FANCY, JUST FLAG   *\n*  SETTING. TALKING ABOUT FLAGS, THIS PROGRAM USES THE SETTING AND *\n*  RESETTING OF FLAGS EXTENSIVELY, SO BE ADVISED OF ALL THIS CRAZY *\n*  BIT MANIPULATION.                                               *\n********************************************************************\n*  ADDED LINE COUNT PARAMETER 12 NOV 86                            *\n********************************************************************\nSSCUCPDS CSECT\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n****************************************************************\n*  SAVE LOGIC TO CONSERVE ON REGISTERS. R13 IS USED AS BOTH    *\n*  THE BASE REGISTER AND THE POINTER TO THE 18 WORD SAVE AREA. *\n****************************************************************\n         B     72(R15)\n         DS    17F\n         STM   R14,R12,12(R13)\n         ST    R13,4(R15)\n         ST    R15,8(R13)\n         LR    R13,R15\n         LA    R12,2048(R13)\n         LA    R12,2048(R12)\n         USING SSCUCPDS,R13,R12\n         L     R2,0(R1)            GET PARM ADDR\n         ST    R2,PARMADDR\n         OPEN  (ERRPRIN1,(OUTPUT))\n         TM    ERRPRIN1+48,X'10'\n         BZ    BADRETN\n**************************************************************\n*  IN THIS SECTION WE WILL BE CONCERNED WITH PROCESSING THE  *\n* PARM INFORMATION. THE ONLY PARMS AT PRESENT ARE 'CHGE' AND *\n* 'MEMB'. WITH CHGE PARM PROGRAM WILL PROCESS ENTIRE PDS     *\n* WITH USER SPECIFICATIONS, AND THEN MAKE THE CHANGES. IF    *\n* PARM IS NOT SPECIFIED NO CHANGE WILL TAKE PLACE. THE MEMB  *\n* PARM IS USED TO SELECTIVELY PROCESS MEMBERS OF A SINGLE    *\n* SPECIFIED PDS.                                             *\n**************************************************************\n*  3 MAR 86, ONE NEW PARM  IS  BEING ADDED TO THE PROGRAM,   *\n*  SCAN;                                                     *\n*  I THOUGHT TO USE BECAUSE I FOUND MYSELF USING THIS PROGRAM*\n*  TO SEARCH THROUGH PDS'S FOR A PARTICULAR ARGUMENT FOR DIS-*\n*  PLAY PURPOSES, NOT FOR EDITING IT. THIS PARM WILL CUT THE *\n*  OUTPUT IN HALF BECAUSE THERE WILL BE NO CHANGE LINE.      *\n*   ALSO, REWROTE THE APPROACH TO PARM PROCESSING; IT WILL   *\n*  GET THE JOB DONE, JUST DIFFERENTLY .                      *\n**************************************************************\nPROCPRM  LH    R3,0(R2)            GET LENGTH OF PARM FIELD\n         LTR   R3,R3               SEE IF ANYTHING THERE\n         BZ    DODDNS              ZER0, THEN NO PARM\n         LA    R2,2(R2)            ADDR. BEGIN. OF PARM FIELD\nLOOPTHRU TM    FLAG1,X'01'         THIS IS HERE FOR LOOP PROCESSING\n         BZ    SEEIFM               IF SET, THEN GO ON\n         CLI   0(R2),C'C'\n         BNE   SEEIFM\n         CLC   0(4,R2),=C'CHGE'\n         BNE   BADPARM            IF NOT CHANGE THEN BAD PARM\n         TM    FLAG2,X'01'        SEE IF SCAN  PARM WAS SPECIFIED\n         BO    MUTEXCL\nCHGEOK   NI    FLAG1,X'FE'         RESET FLAG FOR  CHANGE\n         MVC   CHGELNE+5(12),BLANKS  MOVE IN BLANKS OVER NO CHANGE\n         LA    R2,5(R2)\n         SH    R3,HW5\n         LTR   R3,R3\n         BM    DODDNS             IF NOT DONE ALLOW TO FALL THRU\nSEEIFM   TM    FLAG1,X'20'         IF PARM HAS BEEN SET THEN CHECK\n         BO    SEEIFL               NEXT IN LINE\n         CLI   0(R2),C'M'\n         BNE   SEEIFL\n         CLC   0(4,R2),=C'MEMB'\n         BNE   BADPARM\n         OI    FLAG1,X'20'        YES, THEN SET FLAG FOR SELECTIVE\n         LA    R2,5(R2)\n         SH    R3,HW5\n         LTR   R3,R3\n         BM    DODDNS\n         B     LOOPTHRU\nSEEIFL   TM    FLAG2,X'80'         IF PARM HAS BEEN SET THEN CHECK\n         BO    SEEIFD\n         CLI   0(R2),C'L'\n         BNE   SEEIFD\n         CLC   0(8,R2),=C'LINECNT='\n         BNE   BADPARM\n         OI    FLAG2,X'80'\n         SH    R3,HW8\n         LA    R2,8(R2)\n         CLI   1(R2),C'0'\n         BNL   TWODIGIT\n         PACK  DOUBLE(8),0(1,R2)\n         SH    R3,HW2\n         LA    R2,2(R2)\n         B     STORLNE\nTWODIGIT CLI   0(R2),C'0'\n         BL    BADLINE\n         PACK  DOUBLE(8),0(2,R2)\n         LA    R2,3(R2)\n         SH    R3,HW3\nSTORLNE  CVB   R15,DOUBLE\n         CH    R15,HW8\n         BNH   BADLINE\n         STH   R15,MLINECNT\n         LTR   R3,R3\n         BM    DODDNS\n         B     LOOPTHRU\nSEEIFD   TM    FLAG2,X'01'         IF PARM HAS BEEN SET THEN WE HAVE\n         BO    BADPARM              A BAD PARAMETER SOMEWHERE; QUIT\n         CLI   0(R2),C'S'\n         BNE   BADPARM\n         CLC   0(4,R2),=C'SCAN'\n         BNE   BADPARM\n         TM    FLAG1,X'01'        SEE IF CHGE PARM WAS SPECIFIED\n         BZ    MUTEXCL\n         OI    FLAG2,X'01'        YES, THEN SET FLAG FOR SELECTIVE\n         MVC   CHGELNE+5(12),BLANKS  MOVE IN BLANKS OVER NO CHANGE\n         MVC   CHNGEHD2+5(7),=C'DISPLAY'  AND DISPLAY IN HEADINGS\n         MVC   HEADER2+19(7),=C'DISPLAY'\n         MVC   PRNTLNE+105(21),BLANKS     IN BLANKS OVER MODIFIED\n         LA    R2,5(R2)\n         SH    R3,HW5\n         LTR   R3,R3\n         BP    LOOPTHRU\n**************************************************************\n*  IN THIS SECTION WE WILL READ THE DDNAMES FROM THE TIOT    *\n* AND BUILD A LIST OF ALL DDNAMES THAT BEGIN WITH PDS AND OR *\n* SEQ, AND THEN SORT THEM IN ASCENDING ORDER.                *\n**************************************************************\nDODDNS   L     R15,APRODDNS       GET ADDRESS FOR PROCESSING DDNS\n         BALR  R14,R15\n***********************************************************************\n* WE HAVE MOVED THE INPUT SECTION FOR THE ADVANATAGES OF ADDRESSABLITY*\n* AND THUS SOLVED OUR 2 BASE REGISTER LIMITATION. BIG HAND PLEASE.    *\n***********************************************************************\nNOPARM   OPEN  (SYSPRIN1,(OUTPUT))\n         TM    SYSPRIN1+48,X'10'\n         BZ    FREEDDN1\n         L     R1,4(R13)     LOAD UP CALLING ROUTINES SAVE AREA\n         CLC   72(8,R1),=C'SYSLKPDS'     SEE IF THIS PGM CALLED US\n         BNE   DOPRNTHD\n         L     R1,32(R1)     LOAD UP VALUE OF CALLERS R3\n         LTR   R1,R1\n         BNZ   DOVERSYS      IF VALUE NOT 0 THEN DO NOT PRINT HDR\nDOPRNTHD L     R15,APRNTHDR  ADDRESS OF THE HEADER PAGE OF INFORMATION\n         BALR  R14,R15         GO AND PRINT THE HEADER PAGE\nDOVERSYS L     R15,AVERSYSN    ADDRESS OF THE SYSIN RECORD PROCESSOR\n         BALR  R14,R15         GO AND READ THE RECORD AND PARSE IT\n         EJECT\n******************************************************************\n*   IN THIS NEXT SECTION WE WILL SEE DO SELECTIVE PROCESSING     *\n*  BASED ON THE MEMB PARAMETER. SYSMEM DDNAME WILL BE OPENED AND *\n*  EITHER SELECT OR EXCLUDE PROCESSING WILL BE DETERMINED. THIS  *\n*  WILL SUPPORT A 100 MEMBER NAME LIST FOR SELECTIVE PROCESSING. *\n******************************************************************\nGETSTOR2 TM    FLAG1,X'20'        WAS THE MEMB PARAMETER SPECIFIED\n         BZ    GETDSN             NO, THEN PROCESS THE DIRECTORY\n         OPEN  SYSMEM\n         TM    SYSMEM+48,X'10'     VALID OPEN OF SYSMEM\n         BZ    CLOSEPR1           JUST QUIT IF NO INPUT\nOPENOKMM EQU   *                  STORAGE FOR SELECT PROCESS. AND BLDL\n         GETMAIN R,LV=4008         GET ENOUGH STORAGE FOR 500 MBRS\n         ST    R1,STRADDR2         SAVE IT\n         LR    R10,R1             R10 ADDR. THE GETMAIN AREA\n         LR    R8,R1             R8 ADDR. GETMAIN AREA FOR MAKING IT\n         LA    R9,4008              BLANKS\n         LA    R6,BLANKS          THIS PUTS NOTHING OF VALUE IN R6\n         SLR   R7,R7              A 0 LENGTH IN R7 AND\n         ICM   R7,8,BLANKS        A BLANK IN THE HI-ORDER BYTE\n         MVCL  R8,R6              CAUSE ALL STORAGE TO BE BLANKED OUT\n         GET   SYSMEM\n         LR    R2,R1              ADDR. R2 WITH LOCATION\nGOTMMRD  LA    R7,70(R2)          POINT TO END OF RECORD FOR COMPARE\n         LA    R3,8               DATA MUST BEGIN BY COL. 8\nLOOPSMM  CLI   0(R2),C' '         CHECK FOR NON - BLANK\n         BNE   FNDTYPE            NOT BLANK THEN GO ON\n         LA    R2,1(R2)           INCR. R2 TO NEXT BYTE\n         BCT   R3,LOOPSMM         DO IT 8 TIMES\n         B     STRTCOL8           ISSUE ERROR MESSAGE FOR STARTING\nFNDTYPE  CLC   0(7,R2),=C'SELECT='   WAS SELECT SPECIFIED\n         BNE   TRYEXCL            NO, THEN TRY EXCLUDE\n         LA    R2,7(R2)           ADDRESS PASS SELECT STATEMENT\n         B     CLEARR9             CONITNUE AROUND\nTRYEXCL  CLC   0(8,R2),=C'EXCLUDE='  DID THEY AT LEAST DO EXCLUDE\n         BNE   BADINPUT           IF NOT THEN THEY'RE ASKING CRAP\n         OI    FLAG1,X'10'        SET FLAG TO SPECIFY EXCLUDE\n         LA    R2,8(R2)           POINT PAST THE EXCLUDE STATEMENT\nCLEARR9  CLI   0(R2),C' '         IF IT IS A BLANK THEN IT IS WRONG\n         BE    SYNTAXER           BYE BYE MORON\n         SLR   R9,R9              CLEAR R9 FOR 100 MMBER LIMIT CNTR\nSETREGS  LA    R3,9               MEMBER LIM + 1 ( MAX 8 + 1 )\n         LR    R8,R2              LOAD R8 WITH POINTER\nPASSMEM  CLI   0(R8),C','         SEARCH FOR DELIMETER BETWEEN MEMS\n         BE    GOTLEN             IF COMMA THEN GO\n         LA    R8,1(R8)           INCREMENT 1 MORE\n         CR    R8,R7              ARE WE AT THE END OF THE RECORD\n         BNL   GOTLEN             YES, THEN WE'VE PROCESSED LAST MEM\n         BCT   R3,PASSMEM         DO 8 TIMES PLUS ONE MORE FOR BLANK\n         CLI   0(R8),C' '         THIS BETTER BE A BLANK\n         BNE   SYNTAXER           IF NOT THEN ANOTHER MORON\n         MVC   0(8,R10),0(R2)     MOVE IN MEMBER NAME TO BLDL LIST\n         LA    R10,8(R10)         INCR R10 FOR NEXT MEMBER\n         LA    R9,1(R9)           KEEP COUNT OF MEMBER LIST\n         CH    R9,=H'501'         HAVE WE REACHED THE LIMIT YET\n         BNL   TOOMANY            IF 1 MORE THEN QUIT ON THE MORON\n         B     GETNEXT            NO, THEN DO THE NEXT ONE\nGOTLEN   SR    R8,R2       WE FOUND A COMMA, SO GET LNGTH FOR MOVE\n         BCTR  R8,0               DECR 1 FOR EX INSTR\n         EX    R8,MVEINMM         MVC   0(0,R10),0(R2)\n         LA    R10,8(R10)         INCR TO NEXT MEMBER FO BLDL LIST\n         LA    R9,1(R9)           INCR MEMBER COUNTER\n         CH    R9,=H'501'         HAVE WE SURPASSED THE LIMIT\n         BNL   TOOMANY            YES, THEN TELL THEM AND QUIT\n         LA    R2,2(R8,R2)        RE-ADDR R2 TO POINT PAST THE COMMA\n         CR    R2,R7              IF AT THE END OF OUR RECORD QUIT\n         BNL   GETNEXT            IF NOT THEN DO CHECK FOR A BLANK\n         CLI   0(R2),C' '         IS IT THE END FOR THIS RECORD\n         BNE   SETREGS            NO, THEN RESET R3 AND R8 AND DO NEXT\nGETNEXT  GET   SYSMEM\n         LR    R2,R1              LOAD R2 WITH POINTER FOR GET\n         LA    R7,70(R2)          POINT TO END OF RECORD\n         LA    R3,8               GET TO BEGIN COLUMN\nGETBEGIN CLI   0(R2),C' '         FIND A NON-BLANK\n         BNE   SETREGS            IF FOUND THEN GO PROCESS RECORD\n         LA    R2,1(R2)           INCR TO NEXT BYTE\n         BCT   R3,GETBEGIN        LOOP THRU\n         B     STRTCOL8           IF HERE THEN TELL TO START BY COL 8\nENDMEM   EQU   *\n         CLOSE SYSMEM\n         MVC   0(8,R10),FFFLAG    FLAG END OF MEMBER LIST\n         L     R10,STRADDR2       LOAD R10 WITH BEGINNING OF LIST\n         LTR   R9,R9              SEE IF ANY MEMBERS PROCESSED\n         BZ    BADINPUT           IF NOT THEN WE'RE IN TROUBLE; BYE\n         CH    R9,HW1             SEE IF ONLY ONE MEMBER SPECIFIED\n         BE    VERMFLG            YES, THEN GO AROUND THIS\n         LR    R14,R9             LOAD CNTR INTO R14\n         BCTR  R14,0              AND DECR IT ONE\n         LR    R15,R14            NOW, LOAD THIS INTO R15\n**********************************************************************\n*  AS STUPID AS IT MIGHT SEEM HERE TO MOVE IN 'Z        ', IT IS BE- *\n*  ING DONE SO THAT IF SOMEONE SPECIFIES A MEMBER MORE THEN ONCE IT  *\n*  IS NOT PROCESSED MORE THEN ONCE. BLDL WILL RETURN A PROPER ENTRY  *\n*  FOR EACH TIME YOU SPECIFIED THE MEMBER, HENCE SET AN ERRONEOUS    *\n*  MEMBER NAME THAT IS NEVER FOUND AND LET BLDL GIVE AN RC OF 4 .    *\n*  MEMBERS WILL ALSO BE SORTED IN ALPHABETICAL ORDER FOR BLDL.       *\n**********************************************************************\n         LA    R6,8(R10)          LOAD R6 WITH 8 PAST R10 FOR NEXT MEM\nCOMPMEM  CLC   0(8,R10),0(R6)     IF MEMBERS ARE EQUAL THEN MUST FLAG\n         BL    MEMINCR            IF LESS THEN WE'RE OKAY, CONTINUE\n         BH    WRKSRT             IF GREATER THEN FLIP FLOP NAMES\n         MVC   0(8,R6),=X'E9FFFFFFFFFFFFFF'  IF EQ THEN RESET NAME\n         B     MEMINCR            GO TO NEXT\nWRKSRT   MVC   WRKAREA(8),0(R10)  MOVE THIS NAME OVER\n         MVC   0(8,R10),0(R6)     AND THIS NAME INTO PLACE\n         MVC   0(8,R6),WRKAREA    AND LASTLY THIS ONE BACK IN\nMEMINCR  LA    R6,8(R6)           INCR R6 TO POINT TO NEXT MEMBER\n         BCT   R15,COMPMEM        SORT THRU THE LIST\nDECRR14  BCTR  R14,0              DECREMENT R14 FOR SORT THRU LIST\n         LTR   R14,R14            ARE WE DONE\n         BZ    VERMFLG            YES, THEN CONITUNUE\n         LR    R15,R14            NO, RELOAD R15 FOR SORT PASS\n         LA    R10,8(R10)         POINT TO NEXT MEMBER IN LIST\n         LA    R6,8(R10)          AND THE NEXT ONE AFTER HIM\n         CLC   0(8,R6),FFFLAG     ARE WE AT THE END OF THE LIST\n         BNE   COMPMEM            NO ,THEN DO IT AGAIN\nVERMFLG  TM    FLAG1,X'10'        ARE WE DOING EXCLUDE PROCESSING\n         BZ    LISTMEMS           NO, THEN GO AROUND\n         MVC   SELECTVE+3(8),=C'EXCLUDED'  YES, SET THIS IN THE OUTPUT\nLISTMEMS LR    R6,R9              WILL NOW PRINT THE MEMBER LIST\n         PUT   ERRPRIN1,SELECTVE\n         MVI   SELECTVE,C'0'      RESET CC\n         MVC   SELECTVE+1(60),BLANKS   BLANK OUT LINE\n         L     R7,STRADDR2        POINT TO BEGINNING OF LIST\n         LA    R5,SELECTVE+10     POINT TO OUTPUT RECORD\n         LA    R8,10              DO TEN PER LINE\nLISTLOOP CLC   0(8,R7),=X'E9FFFFFFFFFFFFFF'  IF IT IS A DUMMY MEMBER\n         BE    PUTSEL             THEN WE ARE AT THE END OF THE LIST\n         MVC   0(8,R5),0(R7)      IF NOT THEN MOVE NAME IN\n         LA    R5,9(R5)           INCREMENT OUTPUT LINE\nINCRLIST LA    R7,8(R7)           INCR THRU MEMBER LIST\n         BCTR  R6,0               DECR R6\n         LTR   R6,R6              HAVE WE DONE ALL THE MEMBERS YET\n         BZ    PUTSEL             YES, THEN\n         BCT   R8,LISTLOOP        WILL DO 8 PER LINE\nPUTSEL   EQU   *\n         PUT   ERRPRIN1,SELECTVE\n         LTR   R6,R6              SEE IF WE'RE DONE WITH THE MEMBERS\n         BZ    VEREFLG            YES, THEN CONTINUE\n         CLC   0(8,R7),=X'E9FFFFFFFFFFFFFF'  IF IT IS A DUMMY MEMBER\n         BE    VEREFLG            THEN WE ARE AT THE END OF THE LIST\n         LA    R5,SELECTVE+10     NO, THEN RESET POINTER TO BEGINNING\n         MVI   SELECTVE+1,C' '    WILL BLANK OUT THE ENTIRE\n         MVC   SELECTVE+2(118),SELECTVE+1   PRINT LINE\n         LA    R8,10              RESET COUNTER\n         B     LISTLOOP           GET BACK INTO LOOP\nVEREFLG  EQU   *\n         L     R6,STRADDR2\n******************************************************************\n*   HERE WE WILL READ IN THE DIRECTORY MEMBERS SO THAT WE MAY    *\n*  THEN ISSUE A BLDL MACRO. THE GETMAIN WILL SUPPORT THE PROCESS-*\n*  ING OF 50000 MEMBERS IN THE PDS. I ADDED THE GETMAIN FOR 256  *\n*  BYTES BECAUSE I NEEDED THE STORAGE BACK IN THE PROGRAM. I HAD *\n*  PASSED 2 BASE REGISTERS AND IT WAS EASIER TO ADD THE GETMAIN  *\n*  AND BUY BACK THE 256 BYTES FOR THE READ OF THE DIRECTORY.     *\n*                                                                *\n*   17 MAR 86  REALIZED THAT I WAS DOING WASTEFUL I/O BY READING *\n*  THE DIRECTORY AND THEN DOING A BLDL. ALL I NEED IS THE NAME,  *\n*  TTR, AND THE FIRST BIT OF LOCATION 12 (OFFSET 11) FOR ALIASES.*\n*    INCREASED THE GETMAIN FROM 16000 TO 131780 SO AS TO STORE AN*\n*  AN 8 BYTE MEMBER NAME, 3 BYTE TTR, 1 BYTE ALIAS SETTING, AND  *\n*  THEN READ DIRECTORY.                                          *\n******************************************************************\n*******************************************************\n*   WE WANT THE DATA SET NAME FOR THE OUTPUT.         *\n*******************************************************\nGETDSN   EQU   *\n         RDJFCB MF=(E,RDJFCB1)\n         CLC   JFCBAREA(8),=C'NULLFILE'\n         BE    DONXTPDS\n         MVC   DATASET(44),JFCBAREA   MOVE IN THE DATA SET NAME\nMVODDN   MVC   ODDNAME(8),PDSCHGE+40    MOVE IN DDNAME\n         TM    FLAG2,X'10'            SEQUENTIAL FILE PROCESSED\n         BZ    GETDSTR             NO, THEN DO NOT LOOK FOR MMBER NAME\nDOPSMEM  CLI   JFCBAREA+44,C' '\n         BNH   OPENFILE\n         LA    R14,DATASET+43     POINT TO END OF DSNAME\n         LA    R15,43                MUST BE AT LEAST ONE BYTE LONG\nLOOPJFCB CLI   0(R14),C' '        IS IT A BLANK\n         BNE   GOTEND\n         BCTR  R14,0\n         BCT   R15,LOOPJFCB   IF THIS FALLS THRU THEN WE ARE IN TROUBLE\n         L     R0,ABADJFCB\n         PUT   ERRPRIN1,(0)\n         B     DONXTPDS\nGOTEND   MVI   1(R14),C'('\n         MVC   2(8,R14),JFCBAREA+44\n         LA    R14,9(R14)\n         LA    R15,7\nLOOPJMM  CLI   0(R14),C' '\n         BNE   GOTENDM\n         BCTR  R14,0\n         BCT   R15,LOOPJMM\nGOTENDM  MVI   1(R14),C')'\n         B     OPENFILE          SO, GO AROUND\nGETDSTR  EQU   *\n         TM    FLAG2,X'20'                ADDED CHECKING\n         BO    LODADDR3                   ALREADY ACQUIRED, AROUND\n         GETMAIN EU,LV=600260,A=STRADDR3  ENOUGH STORAGE FOR 50000\n*                      MBRS+4\n         OI    FLAG2,X'20'         SET THIS TO SAY WE ACQUIRED STORAGE\nLODADDR3 L     R3,STRADDR3\n*******************************************************************\n*******************************************************************\nOPENDIR  EQU   *\n         OPEN  (DIRREAD)           OPEN PDS TO READ DIRECTORY\n         TM    DIRREAD+48,X'10'    OPEN SUCCESSFUL\n         BZ    DONXTPDS            NO, THEN QUIT\nOPENOK   EQU   *\n         L     R7,STRADDR3        LOAD VALUE INTO R11\n         SLR   R2,R2\n         LA    R11,260(R7)        POINT PAST DIRECTORY READ\nLOCSET   READ  DIRDECB,SF,DIRREAD,(7)\n         CHECK DIRDECB\nRDNXTDIR EQU   *\nLIST0    LR    R10,R7              R10 POINTS TO FIELD READ\n         LH    R9,0(R10)           R9 CONTAINS LENGTH OF RECORD\n         AR    R9,R10              POINT TO END OF LIST\n         LA    R10,2(R10)          ADDRESS MEMBER\nLIST1    CLC   0(8,R10),FFFLAG     IS THIS THE LAST DIRECTORY ENTRY\n         BNE   LIST2               NO, THEN CONTINUE\nDIRENDL  MVC   0(8,R11),FFFLAG    FLAG END OF MEMBER LIST\n         CLOSE DIRREAD             CLOSE DIRECTORY\n         NI    WRTFLAG,X'FD'      RESET FLAG\n         L     R11,STRADDR3        RELOAD R11 POINTER\n         LA    R11,256(R11)        RELOAD R11 POINTER\n         LTR   R2,R2              VERIFY THAT AT LEAST 1 MEMBER EXIST\n         BNZ   STRR2\n         PUT   ERRPRIN1,FUNNYMAN\n         B     DONXTPDS\nSTRR2    STH   R2,0(R11)          STORE TO SIMULATE A BLDL LIST\n         MVC   2(2,R11),=H'12'     LENGTH OF MEMBER ENTRY\n         LA    R11,4(R11)          INCREMENT PAST COUNT\n         TM    FLAG1,X'20'         IS THERE A MEMBER LIST\n         BZ    OPENFILE            CONTUINUE PROCESSING\n         L     R1,STRADDR2\n         FREEMAIN R,LV=4008,A=(1)\n         B     OPENFILE\nLIST2    TM    FLAG1,X'20'         IS THERE A MEMBER LIST\n         BZ    DIRMEMMV            NO EXCLUDE LIST, BR AROUND\n         TM    FLAG1,X'10'         IS THERE AN EXCLUDE LIST\n         BZ    DIRSEL              NO EXCLUDE LIST, THEN DO SELECT\nENDEXCL  CLC   0(8,R6),FFFLAG    MAKE SURE NOT AT END OF LIST\n         BE    DIRMEMMV           YES, THEN CONTINUE BLDING\nCHECKEX  CLC   0(8,R10),0(R6)     DO WE EXCLUDE THIS MEMBER\n         BL    DIRMEMMV           IF LESS MOVE IN MEMBER\n         BE    GETPAST            IF EQUAL BRANCH AROUND AND WE'LL\n*                                  INCREMENT NEXT PASS\n         LA    R6,8(R6)           IF GREATER INCR. EXCLUDE LIST\n         B     ENDEXCL            AND CONTINUE CHECKING\nDIRSEL   CLC   0(8,R6),FFFLAG     MAKE SURE NOT AT END OF LIST\n         BE    DIRENDL            YES, THEN FINISHED WITH DIRECTORY\n         CLC   0(8,R6),=X'E9FFFFFFFFFFFFFF'  IF IT IS A DUMMY MEMBER\n         BE    DIRENDL            YES, THEN FINISHED WITH DIRECTORY\nCHECKSL  CLC   0(8,R10),0(R6)     DO WE SELECT  THIS MEMBER\n         BE    INCSLNPS           IF EQUAL MOVE IN MEMBER AND INCR R6\n         BL    GETPAST            IF LESS  BRANCH AROUND\nSETRTC4  OI    WRTFLAG,X'80'      SET AS RETURN CODE NOT FOUND\n         LA    R6,8(R6)           INCREMENT THIS POINTER FOR NEXT PASS\n         B     DIRSEL             AND CONTINUE CHECKING\nINCSLNPS LA    R6,8(R6)           INCREMENT THIS POINTER FOR NEXT PASS\nDIRMEMMV EQU   *\nMVMMBRN  MVC   0(12,R11),0(R10)    MOVE IN MMBR NAME,TTR, AND ALIAS BIT\n         LA    R2,1(R2)            INCR. COUNTER FOR MEMBERS\n         LA    R11,12(R11)         INCR. INPUT MEMBER LIST\nGETPAST  IC    R14,11(R10)          GET # OF USER HALFWORDS\n         N     R14,=F'31'           ZERO OUT HI ORDER BITS\n         SLA   R14,1                MULTIPLY BY TWO\n         LA    R14,12(R14)          ADD THE CONSTANT SECTION TO IT\n         AR    R10,R14             AND THEN INCREMENT R10\n         CR    R10,R9              ARE WE AT THE END OF THIS READ\n         BL    LIST1               NO, THEN PROCESS THE NEXT\n         B     LOCSET              READ NEXT RECORD\n         EJECT\nERRCOD2  OI    OUTFLAG,X'08'      SET FLAG TO SAY WE GOT HERE\nNOTDIR   EQU   *\n         CLOSE DIRREAD             CLOSE DIRECTORY\n         TM    OUTFLAG,X'08'\n         BO    IOERROR\n         PUT   ERRPRIN1,ENDDIRD\n         B     DONXTPDS\n*****************************************************************\n*  IF NO CHANGE OPTION SPECIFIED THEN ONLY OPEN PDS FOR INPUT;  *\n*  IF CHGE OPTION IN EFFECT THEN OPEN AS UPDATE.                *\n*****************************************************************\nOPENFILE TM    FLAG1,X'01'            IS THIS A NO CHANGE RUN\n         BZ    ISSBLDL\n         OPEN  PDSCHGE            OPEN PDS UP FOR INPUT ONLY\n         TM    PDSCHGE+48,X'10'   GOOD OPEN ??\n         BO    CHKRECFM           YES, THEN CONTINUE EUROK\n         B     DONXTPDS           QUIT\nISSBLDL  OPEN  (PDSCHGE,(UPDAT))  OPEN PDS UP FOR UPDATE\n         TM    PDSCHGE+48,X'10'   GOOD OPEN ??\n         BZ    DONXTPDS           QUIT\nCHKRECFM TM    PDSCHGE+36,X'C0'  RECFM MUST NOT BE U\n         BO    BADATTR            IF RECFM U THEN SEE GET OUT\n         TM    PDSCHGE+36,X'40'    RECFM MUST NOT BE V EITHER\n         BZ    SEELRCL            IF 0 FIXED RECORD , CHECK LRECL\n         B     BADATTR            WE DO NOT DO VARIABLE EDITING\nSEELRCL  LH    R3,PDSCHGE+82      LRECL\n         CH    R3,=H'90'          AT THIS TIME WE'LL ONLY DO 90 BYTES\n         BNH   OPENOK2\n         LTR   R3,R3\n         BNZ   OPENOK2\nBADATTR  EQU   *\n         PUT   ERRPRIN1,BDLATTR\n         CLOSE PDSCHGE             CLOSE PDS\n         B     DONXTPDS\nOPENOK2  L     R9,PDSCHGE+44      ADDR. OF DEB\n         L     R9,32(R9)          ADDR. OF UCB\n         MVC   UNITNME(3),13(R9)  UNIT ADDR ( EBCDIC)\n         MVC   VOLUME(6),28(R9)   VOLUME SERIAL NUMBER\n**********************************************************************\n* I DECIDED TO INCREASE THE GETMAIN FOR READING BLOCKS OF DATA TO THE*\n* MAXIMUM VALUE. THIS WAY, THE STORAGE WILL ONLY BE ACQUIRED ONCE AND*\n* RELEASED ONCE. IT MIGHT BE WASTEFUL TO GET 32K IF I MIGHT ONLY NEED*\n* LESS THEN 1 PAGE FOR ANY BLOCKSIZE, BUT IT'S MY PROGRAM AND IF YOU *\n* DON'T LIKE IT, CHANGE IT. ALSO, IF IT IS LOAD MODULE PROCESSING AN *\n* EXTRA 12K WILL BE ACQUIRED TO STORE THE ESD ENTRIES AND CONTROL    *\n* RECORDS.                                                           *\n**********************************************************************\nGOODBLD  TM    FLAG2,X'40'     DID WE ALREADY ACQUIRE BLKSIZE STORAGE\n         BO    ISSEQH          YES, THEN GO AROUND\nGETSTR4  LH    R2,H32760          GET MAX BLKSIZE LNGTH FOR GETMAIN\n*******  LH    R2,PDSCHGE+62      GET BLKSIZE LENGTH(WHAT IT WAS)\n*                              ESD 17 BYTE ENTRIES + MULTI-BLKSIZE)\nNOLMSTR  ST    R2,LNGADDR4        SAVE LENGTH FOR FREEMAIN\n         LR    R0,R2              ADDR. R0 FOR GETMAIN\n         GETMAIN R,LV=(0)\n         ST    R1,STRADDR4        SAVE FOR FREEMAIN\n         OI    FLAG2,X'40'        SET FLAG TO SAY WE ACQUIRED STORAGE\n* NEXT LOAD IS DONE SO R10 CAN BE RELOADED ON +1 PASS PROCESSING\n* OR ELSE I WOULD HAVE DONE A QUICK  LR  R10,R1\nISSEQH   L     R10,STRADDR4       ADDR. OF GETMAIN FOR READ AN WRITE\n         TM    FLAG2,X'10'        ARE WE DOING A SEQUENTIAL FILE\n         BO    SETCLI          YES, THEN BYPASS DIRECTORY CRAP\nDOBLDL   L     R11,STRADDR3       RELOAD BEGIN. ADDR. FOR BLDL\n         LA    R11,256(R11)      INCREMENT PAST DIRECTORY READ BUFFER\n         LH    R2,0(R11)          NUMBER OF MEMBERS\n         LA    R11,4(R11)         ADDRESS OF FIRST MEMBER\nSETCLI   EQU   *\n         LR    R8,R3              GET LENGTH OF COMPARE FOR ARG.\n         SH    R8,LI1FLD          SUBTRACT THE INPUT LENGTH\n*        LA    R8,1(R8)\n         STH   R8,CLILNGTH        SAVE THIS LENGTH FOR CLI LOOP\n         TM    FLAG1,X'C0'        WERE THE ARGS EQUAL\n         BNZ   ADDRDECB           NO THEN DON'T RESET R4\nLMDLNG4  LH    R4,LI1FLD          LOAD LENGTH FOR EX MOVE INSTR.\n         BCTR  R4,0               AND OF COURSE DECREMENT FOR EX\n         EJECT\n******************************************************************\n*  WE ARE NOW AT THE BREAD AND OLEO OF THIS PROGRAM. MEMBERS ARE *\n* IN PLACE AND READY FOR THE PICKING. R9 WILL ADDR. THE DECB, R10*\n* WILL ADDR. THE BLOCKS READ, R7 WILL CONTAIN THE COUNTER FOR #  *\n* OF RECORDS, R5 AND R6 WILL ADDR. THE INDIVIDUAL RECORD THE MAJ-*\n* ORITY OF THE TIME FROM NOW ON, R11 STILL ADDRESSES THE MEMBERS *\n* AND THEIR MUCH NEEDED TTR'S, R8 CONTAINS THE COUNTER FOR COMP- *\n* ARING THRU THE RECORD, R4 IS THE LENGTH ARGUMENTS AND EVERY    *\n* THING ELSE IS WORKING. FLAGS ARE EXTREMELY IMPORTANT AND ARE   *\n* SET AND RESET ON OCCASSION. IF EVERYTHING CHECKS OUT, A BLOCK  *\n* CAN AND WILL BE UPDATED                                        *\n******************************************************************\nADDRDECB LA    R9,PDSDECB         ADDR. THE DECB FOR THE PDS\n         TM    FLAG2,X'10'        IS THIS A SEQUENTAIL FILE ?\n         BO    READNXT            IF SO THEN JUST GO READ A BLOCK\nISITALS  TM    11(R11),X'80'      IS THIS AN ALIAS ( FIRST MEMBER )\n         BO    NEXTMEM            IF SO GET NEXT MEMBER\nCHKTTR   CLI   10(R11),X'00'      IF R OF TTR IS 0\n         BE    NEXTMEM              THEN GO TO NEXT MEMBER ( 1ST MEM )\nSTRTRD   MVC   PNTTTR(3),8(R11)   MOVE TTR OF BLOCK TO TTR OF POINT\n         POINT PDSCHGE,PNTTTR              MACRO\nREADNXT  READ  (9),SF,,(10),MF=E\n         CHECK PDSDECB\n         LH    R6,PDSCHGE+62      BLKSIZE\n         L     R7,PDSDECB+16      IOB ADDR\n         SH    R6,14(R7)          LENGTH OF BLOCK READ\n         SRDL  R6,32              CLEAR R6 AND SHIFT INTO R7\n         ST    R7,WRTBLK          SAVE THE SIZE SO AS TO WRITE IT BACK\n         DR    R6,R3              DIVIDE BY LRECL\n         LR    R5,R10             ADDR. THE BEGINNING OF BLOCK READ\n         LA    R6,0(R5)           DITTO FOR R6\nLOOPCLI  LH    R8,CLILNGTH        GET LENGTH FOR COUNTER\nCLIARG   EX    R8,TRANSARG        TRT  0(0,R5),TRTTBLE\n         BZ    INCRLRCL           IF NO ARGUMENT FOUND THEN NEXT REC\n         SR    R1,R5              LETS RESET POINTER\n         SR    R8,R1              AND LETS GET THE COUNTER DOWN\n         LA    R5,0(R1,R5)        AND POINT TO ARGUMENT\nCOMPARE  CLC   0(0,R5),INFLD      LNGTH SET EARLIER. IS THIS OUR ARG ?\n         BE    PRTFIND            WE FOUND IT HOORAY\n         LTR   R8,R8              WAS IT THE LAST GOOD BYTE\n         BZ    INCRLRCL           INCR. TO NEXT RECORD\n         LA    R5,1(R5)           NO, INCR. AND KEEP CHECKING\n         BCTR  R8,0                 UNTIL THE END IS HERE\n         B     CLIARG             AND GO BACK THROUGH\n         EJECT\n****************************************************************\n*   WE HAVE FOUND OUR ARGUMENT AND WILL MAKE EVERY ATTEMPT TO  *\n*  TO REPLACE IT. THERE ARE 3 SECTIONS; ARGS THE SAME LENGTH,  *\n*  INPUT ARG LENGTH < REPLACE ARG., AND INPUT ARG. LENGTH > RE-*\n*  PLACE ARG. DUE TO THE RETENTION OF REGISTERS, REGS 1,14, AND*\n*  15 HAVE BEEN USED FOR SMALL SECTIONS OF LOGIC. BE ADVISED OF*\n*  WHEN ADDING CODE THAT COULD CLOBBER THESE REGS. FLAGS ARE   *\n*  SET AND RESET THROUGHOUT THESE SECTIONS AND ARE OF THE UT-  *\n*  MOST IMPORTANCE, SO DON'T MUCK THEM UP EITHER. THE FLAGS    *\n*  USED ARE IN THE LITERALS ; FLAG1, WRTFLAG, AND OUTFLAG.     *\n****************************************************************\nPRTFIND  OI    OUTFLAG,X'01'      THIS IS A GLOBAL BIT FOR WHETHER WE\n*                                  FOUND THE ARGUMENT FOR THE ENTIRE\n*                                  PDS. IT IS CHECKED AT EXIT.\n         TM    FLAG2,X'01'        CHECK TO SEE IF THIS IS A SCAN  RUN\n         BZ    DCHGLN             NO, THEN BRANCH AROUND\n         MVC   PRNTLNE+20(80),0(R6)  NO, THEN GET LINE OUT TO OUTPUT\n         OI    OUTFLAG,X'40'      SET THESE FLAGS TO FAKE OUT\n         OI    WRTFLAG,X'01'        THE OUTPUT SECTIONS\n         TM    FLAG1,X'08'        ARE WE DOING PER MEMBER\n         BZ    LR14RES6           THEN JUST GO AROUND\n         L     R15,MEMBPKN2       LOAD UP THE COUNT\n         BCTR  R15,0              DECREMENT FOR THIS ONE\n         ST    R15,MEMBPKN2       STORE THE COUNT\nLR14RES6 LA    R14,RESETR6        SET THIS AS THE RETURN ADDRESS\n         L     R15,ADOUTPUT       LOAD UP ADDRESS OF OUTPUT\n         BR    R15                BRANCH TO PROCESS OUTPUT\nDCHGLN   TM    OUTFLAG,X'40'      HAVE WE CHANGED THIS LINE YET ?\n         BO    HOWBIG             YES, THEN DON'T RE-WRITE INPUT LINE.\n         MVC   PRNTLNE+20(80),0(R6)  NO, THEN GET LINE OUT TO OUTPUT\n         TM    FLAG1,X'08'        ARE WE DOING PER MEMBER\n         BZ    HOWBIG              NO THEN GO AROUND        T\n         L     R15,MEMBPKN2       LOAD UP THE COUNT\n         BCTR  R15,0              DECREMENT FOR THIS ONE\n         ST    R15,MEMBPKN2       STORE THE COUNT\nHOWBIG   TM    FLAG1,X'C0'        WHAT SIZE ARE THE TWO ARGUMENTS.\n         BNZ   SMLBIG             IF NOT = LENGTH BRANCH\n         EX    R4,REPLCHG         DO STRAIGHT REPLACE WITH LNGTH IN R4\n         OI    WRTFLAG,X'01'      SET FLAG TO RE-WRITE THIS BLOCK\n         OI    OUTFLAG,X'40'      SET FLAG TO SAY WE CHANGED THIS RCD.\nCHKFLG04 TM    FLAG1,X'04'        CHANGE ONLY 1ST OCCUR. ON LINE\n         BO    INCRLRCL           YES, THEN DON'T DO ANYMORE\n         LA    R15,1(R4)          NO, GET LNGTH OF ARGS IN R15\n         SR    R8,R15             DECR. RECORD COUNTER\n         LTR   R8,R8              DID THAT PUT US AT THE END\n         BC    12,INCRLRCL        BRANCH IF 0 OR MINUS\n         LA    R5,0(R15,R5)       RESET R5 TO NEXT CHARACTER\n         B     CLIARG             GO BACK AND KEEP DOING IT\n         EJECT\nSMLBIG   TM    FLAG1,X'40'        IS THE REPLACE ARG. SHORTER\n         BZ    ITSBIG             NO, THEN IT IS LONGER\n         LH    R14,LO2FLD         GET LNGTH OF REPLACE IN R14\n         LTR   R14,R14            WAS IT A NULL ARGUMENT\n         BZ    RESET              YES, THEN GO AROUND OR OC4\nMOVSML   BCTR  R14,0              DECR FOR EX INSTR\n         EX    R14,REPLCHG        SWITCH THEM\n         LA    R14,1(R14)         THIS IS DONE IN CASE LENGTH WAS 0\nRESET    LA    R5,0(R14,R5)       POINT TO BYTE POS. AFTER ARG.\n         OI    WRTFLAG,X'01'      SET WRITE FLAG\n         OI    OUTFLAG,X'40'      SET RECORD FLAG\nSET14    LA    R14,0(R6,R3)       GET POINTER TO END OF RCD.\n         LR    R15,R14            GET VALUE IN R15\n         SH    R14,=H'9'          GET BACK TO COL. 71 TO START COMPARE\n         CR    R14,R5             IS R14 STILL POINTING PAST R5\n         BH    DECRR141           YES, THEN GET THE DIFFERENCE\n         LR    R14,R15            NO, THEN RELOAD WITH R15\nDECRR141 SR    R14,R5\n         SR    R14,R4\n         LTR   R14,R14\n         BC    12,INCRLRCL        IF THIS IS TRUE JUST FORGET IT\nDECRR142 BCTR  R14,0              DECREMENT R14\n         LA    R15,0(R5,R4)       POINT TO POSITION AFTER INPUT ARG.\n         EX    R14,SHIFTMV        MOVE OVER UNUSED INPUT ARG. FIELD\n         LR    R2,R5              SAVE THIS LOCATION FOR A RELOAD\n         LA    R5,1(R14,R5)       POINT TO END OF DATA AREA TO BLANK IT\n         LR    R15,R4             GET LENGTH OF DIFFERENCE IN R15\nDECRR152 BCTR  R15,0              DECR. FOR EX INSTR. TO BLANK OUT\n         EX    R15,SHBLK          MOVE BLANKS TO EXTRA DATA\n         TM    FLAG1,X'04'        ONE PER LINE\n         BO    INCRLRCL           IF ONLY 1 CHANGE PER LINE GET OUT\n         LH    R15,LO2FLD         RESET. GET LENGTH IN R15\n         LTR   R15,R15\n         BNZ   DECRR082\n         LA    R15,1\nDECRR082 SR    R8,R15             DECR R8 COUNTER\n         LTR   R8,R8              VERIFY REMAINING LENGTH\n         BC    12,INCRLRCL        IF 0 OR MINUS GET OUT\n         LR    R5,R2              RESET R5 TO GOOD PTR. IN RECORD\n         B     CLIARG             GO BACK TO CHECKING RECORD\n         EJECT\nITSBIG   LH    R15,LI1FLD         INPUT SHORTER SO PUT IN R15\n         LA    R15,0(R15,R5)      POINT TO END OF INPUT ARG.\n         LR    R14,R4             GET DIFFERENCE IN R14\n*  DON'T DECREMENT EX INSTR . GO ONE PAST FIELD TO COMPARE FOR BLANKS\n*        BCTR  R14,0              DECREMENT FOR COMPARE OF BLANKS\n         EX    R14,COMPBIG            CLC 0(0,R15),BLANKS\n         BNE   TRYTHIS            IF NOT BLANKS THEN WE HAVE TO HAGGLE\n         LH    R14,LO2FLD         GET LENGTH OF OUTPUT FIELD\n         BCTR  R14,0              DECREMENT FOR REPLACE\n         EX    R14,REPLCHG        CHANGE O.K, OVERLAY BLANKS W/ 1 SPARE\n         OI    WRTFLAG,X'01'      SET FLAG TO WRITE BLOCK\n         OI    OUTFLAG,X'40'      SET FLAG TO SHOW RECORD UPDATE\n         TM    FLAG1,X'04'        ONE PER LINE\n         BO    INCRLRCL           YES, THEN NO MORE THIS RECORD\n         LH    R15,LO2FLD         RESET FIELDS\n         SR    R8,R15             RESET COUNTER\n         LTR   R8,R8              HOW MUCH LENGTH LEFT\n         BC    12,INCRLRCL        NOT ENOUGH ( 0 OR - ) NEXT RCD.\n         LA    R5,0(R15,R5)       RESET POINTER IN RECORD FIELD\n         B     CLIARG             ONWARD AND UPWARD MEN\nTRYTHIS  LH    R15,LI1FLD          GET TO END OF INPUT FIELD\n         LA    R15,0(R15,R5)\n         LA    R14,0(R6,R3)        GET TO END OF RECORD\n         SH    R14,=H'9'           COLUMN 71 FOR VERIFICATION\nLOOPLNG1 CLI   0(R15),C' '         FIND FIRST BLANK AFTER INITIAL DATA\n         BE    NEXTPHSE            IF WE FIND IT GO FOR ENOUGH TO MOVE\n         LA    R15,1(R15)          KEEP INCREMENTING\n         CR    R15,R14             IF WE NOT AT COL 71 THEN\n         BL    LOOPLNG1             THEN KEEP GOING\n         B     NOGOOD              COL 71, JUST QUIT, NO SENSE\nNEXTPHSE SLR   R1,R1               NOW FIND ENOUGH BLANKS TO EFFECT MV\nLOOPLNG2 CLI   0(R15),C' '         IF IT IS NON-BLANK THEN GO OTHER\n         BNE   TRYOTHER             ROUTE AND BACKTRACK FROM COL. 71\n         LA    R1,1(R1)           INCR. R1, AND WHEN IT IS GREATER\n         CR    R1,R4                THEN R4 THEN WE HAVE THE ROOM\n         BH    MOVEUP1             GO AND MOVE IT\n         LA    R15,1(R15)          INCR. R15\n         CR    R15,R14             IF AT COL 71 THEN WE WILL QUIT\n         BL    LOOPLNG2            NO, THEN KEEP TRYING\n         B     NOGOOD              YES, FLAG AND TRY NEXT ONE\nMOVEUP1  LR    R2,R15              GET LOCATION IN R2 TO BRANCH INTO\n         LH    R14,LI1FLD          GET LENGTH OF INPUT ARG\n         LA    R14,0(R5,R14)       POINT TO AFTER INPUT ARG\n         SR    R2,R14              GET THE LENGTH IN R2 AND\n         SR    R2,R4                AND MINUS THE EXCESS BLANKS AND GO\n         B     TEMPMVE             TO THE MOVES ALREADY SET UP\nTRYOTHER LA    R15,0(R6,R3)       GET TO END OF RECORD.\n         SH    R15,=H'9'          GET TO COL 71\n         LR    R14,R15            KEEP R14 AT END, SEE HOW MANY BLANKS\n         LH    R1,LI1FLD          GET LENGTH OF INPUT FIELD\n         LA    R1,0(R5,R1)        POINT TO END OF FIELD\nLOOPLNG  CLI   0(R15),C' '        LOOK TIL NON-BLANK\n         BNE   CHKLNG             WE FOUND ONE\n         BCTR  R15,0              DECREMENT\n         CR    R15,R1             MAKE SURE R15 NOT LESS THAN R1\n         BH    LOOPLNG            KEEP LOOKING\nCHKLNG   SR    R14,R15            GET LENGTH OF # OF BLANKS\n         LR    R2,R15             SAVE POINTER FOR THE MORONS\n*        BCTR  R14,0              DO NOT DECREMENT, ALLOW USE UP TO\n*                                   COLUMN 71\n         CR    R14,R4             IS THERE ENOUGH ROOM TO SWITCH\n         BH    MOVEUP             YES, THEN MOVE IT IN THERE\nNOGOOD   TM    OUTFLAG,X'40'      HAS THIS RECORD BEEN UPDATED ?\n         BO    INCRLRCL           YES, THEN DON'T SET ERROR FLAG\n         OI    OUTFLAG,X'80'      SET FLAG FOR NOT ENOUGH ROOM\n         L     R15,ADOUTPUT\n         BALR  R14,R15            GO DO THE OUTPUT NOW\n         B     RESETR6            ON RETURN GO TO NEXT RECORD\nMOVEUP   LH    R1,LI1FLD          GET LENGTH OF INPUT FIELD\n         LA    R14,0(R5,R1)       POINT TO END OF IT\n         SR    R2,R14             GET LENGTH OF DATA TO BE MOVED\nTEMPMVE  EX    R2,MOVETEMP        MOVE IT TO TEMP HOLDING AREA\n         LH    R1,LO2FLD          GET LENGTH OF OUTPUT\n         BCTR  R1,0               DECR. THE LITTLE BUGGER\n         EX    R1,REPLCHG         MOVE IT IN OVER ALL\n         LA    R5,1(R1,R5)        RESET POINTER TO END OF FIELD\n         EX    R2,MOVEBACK        MOVE BACK THE OTHER DATA\n         OI    WRTFLAG,X'01'      SET FLAG TO WRITE\n         OI    OUTFLAG,X'40'      SET FLAG UPDATE FOR RECORD\n         TM    FLAG1,X'04'        ONE PER LINE\n         BO    INCRLRCL           IF SO WE HAVE OUR QUOTA\n         LH    R15,LO2FLD         RESET. GET LENGTH IN R15\n         SR    R8,R15             DECR. COUNTER\n         LTR   R8,R8              SEE THE LENGTH\n         BP    CLIARG             IF NOT PLUS JUST FALL THRU. (R5 OK)\n         EJECT\nINCRLRCL TM    OUTFLAG,X'40'      DID WE UPDATE THIS RECORD\n         BZ    RESETR6            NO, THEN JUST GO TO NEXT RECORD\nMVEINCHG MVC   CHGELNE+20(80),0(R6) YES, THEN MOVE TO OUTPUT\n         L     R15,ADOUTPUT\n         BALR  R14,R15            GO PROCESS THE OUTPUT\nRESETR6  LA    R6,0(R6,R3)        POINT TO NEXT RECORD\n         LR    R5,R6              RESET R5 TO BEGIN\n         TM    WRTFLAG,X'01'      DID WE UPDATE THE BLOCK\n         BZ    DECRR7             NO, THEN READ ANOTHER BLOCK\n         TM    FLAG1,X'08'        ARE WE DOING ONE PER MEMBER\n         BZ    DECRR7             WE ARE FINISHED WITH THIS MEMBER\n         L     R15,MEMBPKN2       LOAD UP THE COUNT\n         LTR   R15,R15            HAVE WE DONE ALL OF THEM\n         BC    12,EOBLK            YES, THEN GO AWAY\nDECRR7   BCT   R7,LOOPCLI         GO BACK TO RECORDS\nEOBLK    TM    WRTFLAG,X'01'      DID WE UPDATE THE BLOCK\n         BZ    READNXT            NO, THEN READ ANOTHER BLOCK\n         NI    WRTFLAG,X'FE'      RESET THIS FLAG FOR BLOCK\n         TM    FLAG1,X'01'        NO CHANGE PARM IN EFFECT\n         BZ    WRITIT             NO, THEN WRITE UPDATED BLOCK\n         TM    FLAG1,X'08'        ARE WE DOING ONCE PER MEMBER\n         BZ    READNXT            NO, THEN READ NEXT BLOCK\n         L     R15,MEMBPKN2       LOAD UP THE COUNT\n         LTR   R15,R15            SEE IF WE ARE DONE WITH THIS\n         BC    12,EODAD           YES, THEN GO TO NEXT MEMBER\n         B     READNXT            NO, STILL SOME LEFT\n**********************************************\nWRITIT   L     R5,WRTBLK          GET LENGTH OF WRITE BLOCK IN R5\n         WRITE (9),SF,,(10),(5),MF=E\n         CHECK PDSDECB\n         TM    FLAG1,X'08'        ARE WE DOING ONCE PER MEMBER\n         BZ    READNXT            NO, THEN READ NEXT BLOCK\n         L     R15,MEMBPKN2       LOAD UP THE COUNT\n         LTR   R15,R15\n         BC    12,EODAD           IF 0 OR MINUS\n         B     READNXT\nEODAD    TM    FLAG2,X'10'        WAS THIS A SEQUENTIAL FILE\n         BZ    NEXTMEM            NO, THEN INCREMENT TO NEXT MEMBER\n         NI    FLAG2,X'EF'        CLEAR OUT FLAG\n         B     CLOSIT             AND CLOSE FILE\nNEXTMEM  LA    R11,12(R11)\n         CLC   0(8,R11),FFFLAG    ARE WE AT THE END ( MY FLAG )\n         BE    CLOSIT             NO, THEN READ THE NEXT ONE IN\n         TM    11(R11),X'80'      IS THIS AN ALIAS\n         BO    NEXTMEM            IF SO GET NEXT MEMBER\nARONIN14 CLI   10(R11),X'00'      IF R OF TTR IS 0\n         BE    NEXTMEM              THEN GO TO NEXT MEMBER\n         MVC   MEMBPKN2(4),MEMBPKNM RESET THIS VALUE\n         B     STRTRD\nCLOSIT   CLOSE PDSCHGE\n         TM    OUTFLAG,X'08'      SEE IF THIS IS ENTERED FROM ERROR RTE\n         BZ    NOTIOERR           YES, THEN WE ARE FINISHED\nIOERROR  MVC   PDSEDDN(8),PDSCHGE+40\n         PUT   ERRPRIN1,PDSIOERR\n         B     DONXTPDS\nNOTIOERR TM    OUTFLAG,X'01'      SEE IF WE FOUND ANY ARGUMENT\n         BO    DONXTPDS           YES, THEN WE ARE FINISHED\n         OI    OUTFLAG,X'02'      SET A FLAG FOR OUTPUT MESSAGE\n         L     R15,ADOUTPUT\n         BALR  R14,R15            GO PRINT IT AND THEN EXIT\nDONXTPDS TM    FLAG1,X'20'       SEE IF SELECTIVE MEMB PROCESSING\n         BO    FREESTR           YES, THEN WE ARE DONE, QUIT\n         NI    OUTFLAG,X'F7'     RESET THIS FLAG IF IT WAS SET\n         L     R14,DDNADDR       NO, INCREMENT TO NEXT DDNAME\n         LA    R14,12(R14)       THIS IS NEXT IN OUR HANDSOME TABLE\n         CLI   0(R14),X'FF'      ARE WE AT THE END OF THE LIST\n         BE    FREESTR           YES, THEN FREE UP THE DIRECTORY\n         MVC   MEMBPKN2(4),MEMBPKNM RESET THIS VALUE\n         SLR   R15,R15           CLEAR R15 TO STORE ZEROS\n         STH   R15,PDSCHGE+62     RESET BLKSIZE FOR PDSCHGE DCB ONLY\n         STH   R15,DIRREAD+82     RESET LRECL SIZE TO 0 FOR DIRECTORY\n         STH   R15,PDSCHGE+82     RESET LRECL SIZE TO 0 FOR PDSCHGE\n         MVI   DIRREAD+48,X'02'   RESET OPEN FLAGS FOR DIRECTORY\n         MVI   PDSCHGE+48,X'02'   RESET OPEN FLAGS\n         MVI   PDSCHGE+36,X'00'   RESET RECORD FORMAT\n         ST    R14,DDNADDR        SAVE POINTER ADDR FOR NEXT PASS\n         MVC   DIRREAD+40(8),0(R14)  RESET DDNAME FIELD IN DIRECTORY\n         MVC   PDSCHGE+40(8),0(R14)  RESET DDNAME FIELD IN PDSCHGE\nRESTLNCT STH   R15,LINECNT        RESET LINE COUNT TO ZERO FOR NEW DSN\n         NI    OUTFLAG,X'FC'      RESET PRINT OUT FLAG\n* WE WILL SET THE DSORG FIELD HERE IF A SEQUENTIAL FILE IS FOUND\n         CLC   0(3,R14),LTRLSEQ      SEE IF SEQUENTIAL FILE ON THIS\n         BNE   GETDSN\n         MVC   PDSCHGE+26(2),=X'4000'    DSORG FOR PS FILE\n         OI    FLAG2,X'10'           ON THIS PASS\n         MVC   HDRSEQ+14(20),SEQDESC\n         B     GETDSN             GO AND VERIFY SEQUENTIAL\n********************************************************************\n*   THE BLKSIZE STORAGE (STRADDR4) SHOULD ALWAYS BE ACQUIRED, BUT  *\n*  SEEING AS I SET A FLAG WHEN I ACQUIRED IT I AM VERIFYING IT WAS *\n*  ACQUIRED AND THE FLAG WAS SET.                                  *\n********************************************************************\nFREESTR  TM    FLAG2,X'40'       SEE IF WE ACQUIRED BLKSIZE STOR.\n         BZ    FREEDIR         NO, THEN DO NOT FREE WHAT IS NOT THERE\n         L     R1,STRADDR4        LETS FREE UP TEMP. HOLDING AREA\n         L     R0,LNGADDR4\n         FREEMAIN R,LV=(0),A=(1)\nFREEDIR  TM    FLAG2,X'20'        SEE IF WE ACQUIRED DIRCETORY STOR.\n         BZ    CLOSEPRT        NO, THEN DO NOT FREE WHAT IS NOT THERE\n         FREEMAIN EC,LV=600260,A=STRADDR3\nCLOSEPRT EQU   *\n         CLOSE SYSPRIN1\nFREEDDN  L     R1,STRADDR1        LETS FREE UP TEMP. HOLDING AREA\n         L     R0,LNGADDR1        LETS FREE UP TEMP. HOLDING AREA\n         FREEMAIN R,LV=(0),A=(1)\nRETURN   CLOSE ERRPRIN1\n         TM    WRTFLAG,X'80'\n         BZ    CLEARR15\n         LA    R15,4\n         B     RELOAD13\nCLEARR15 SLR   R15,R15\nRELOAD13 L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nBADPARM  EQU   *\n         L     R0,ANGPARM\n         PUT   ERRPRIN1,(0)\n         B     BADRETN\nBADLINE  EQU   *\n         L     R0,ANGLINE\n         PUT   ERRPRIN1,(0)\n         B     BADRETN\nMUTEXCL  EQU   *\n         L     R0,AMUPARM\n         PUT   ERRPRIN1,(0)\n         B     BADRETN\nBADINPUT L     R0,ANGMINPT\n         PUT   ERRPRIN1,(0)\n         B     FREEDDNM\nSYNTAXER PUT   ERRPRIN1,SYNTAX\n         B     FREEDDNM\nTOOMANY  PUT   ERRPRIN1,OVER500\n         B     FREEDDNM\nDELIMPE  L     R0,ADELIMP1\n         PUT   ERRPRIN1,(0)\n         B     CLOSEPR1\nHEXE     L     R0,AHEXE1\n         PUT   ERRPRIN1,(0)\n         B     CLOSEPR1\nHEXODD   L     R0,AHEXODD1\n         PUT   ERRPRIN1,(0)\n         B     CLOSEPR1\nHEXPRSE  L     R0,AHEXPRS1\n         PUT   ERRPRIN1,(0)\n         B     CLOSEPR1\nSTRTCOL8 MVC   COL8DDN(7),=C'SYSMEM'\n         PUT   ERRPRIN1,COL8\nFREEDDNM L     R1,STRADDR2\n         FREEMAIN R,LV=808,A=(1)\nNOINPUT  EQU   *\nCLOSEPR1 EQU   *\n         CLOSE SYSPRIN1\nFREEDDN1 L     R1,STRADDR1        LETS FREE UP TEMP. HOLDING AREA\n         L     R0,LNGADDR1        LETS FREE UP TEMP. HOLDING AREA\n         FREEMAIN R,LV=(0),A=(1)\nBADRETN  CLOSE ERRPRIN1\n         L     R13,4(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,16\n         BR    R14\n*******************************************************************\n*  THIS NEXT LITTLE SECTION OF CODE IS TO HANDLE I/O ERRORS WHILE *\n*  PROCESSING A FILE. I AM NOT DOING ANY ERROR CHECKING, JUST AL- *\n*  LOWING IT TO GO TO THE NEXT FILE WITHOUT ABENDING. ERRCODE IS  *\n*  FOR THE PDSCHGE LABEL.                                         *\n*  WE ARE STORING THE RETURN ADDRESS FROM ERROR RECOVERY AT +25   *\n*  IN OUR SAVEAREA BECAUSE THAT IS WHERE THE SYSTEM RELOADS FROM  *\n*  TO RETURN TO OUR PROGRAM. STRANGE BUT TRUE                     *\n*******************************************************************\nERRCODE  OI    OUTFLAG,X'08'      SET FLAG TO SAY WE GOT HERE\nMVBR2    MVC   21(3,R13),AERRBR   MOVE IN ADDRESS TO RETURN AT CLOSIT\n         BR    R14\n         EJECT\nDIRREAD  DCB   MACRF=R,DSORG=PS,DDNAME=PDSCHGE,EODAD=NOTDIR,           X\n               BLKSIZE=256,RECFM=F,LRECL=256\n*              BLKSIZE=256\nPDSCHGE  DCB   DDNAME=PDSCHGE,MACRF=(R,W),DSORG=PO,EODAD=EODAD,        +\n               EXLST=JFCBLIST,SYNAD=ERRCODE\nSYSPRIN1 DCB   DDNAME=SYSPRIN1,MACRF=PM,DSORG=PS,RECFM=FBA,LRECL=133\n*              BLKSIZE=133\nERRPRIN1 DCB   DDNAME=ERRPRIN1,MACRF=PM,DSORG=PS,RECFM=FBA,LRECL=121\n*              BLKSIZE=121\nSYSMEM   DCB   DDNAME=SYSMEM,MACRF=GL,DSORG=PS,EODAD=ENDMEM\n         READ  PDSDECB,SF,PDSCHGE,MF=L\nAVERSYSN DC    A(VERSYSN)\nAPRNTHDR DC    A(PRNTHDR)\nADOUTPUT DC    A(DOOUTPUT)\nAPRODDNS DC    A(PRODDNS)\nAERRBR   DC    AL3(CLOSIT)\nAERRBR2  DC    AL3(NOTDIR)\nANGPARM  DC    A(NGPARM)\nANGLINE  DC    A(NGLINE)\nAMUPARM  DC    A(MUPARM)\nADELIMP1 DC    A(DELIMP1)\nAHEXE1   DC    A(HEXE1)\nAHEXODD1 DC    A(HEXODD1)\nAHEXPRS1 DC    A(HEXPRS1)\nANGMINPT DC    A(NGMINPT)\nABADJFCB DC    A(BADJFCB)\nDOUBLE   DC    D'0'\nMEMBPKNM DC    F'0'\nMEMBPKN2 DC    F'0'\nPARMADDR DC    F'0'\nDDNADDR  DC    F'0'\nSTRADDR1 DC    F'0'\nSTRADDR2 DC    F'0'\nSTRADD2B DC    F'0'\nEXCADDR2 DC    F'0'\nSTRADDR3 DC    F'0'\nSTRADDR4 DC    F'0'\nLNGADDR1 DC    F'8192'\nLNGADDR2 DC    F'4008'\nLNGADDR3 DC    F'47780'\nLNGADDR4 DC    F'0'\nPNTTTR   DC    F'0'\nWRTBLK   DC    F'0'\nOFFSET   DC    F'0'\nLI1FLD   DC    H'0'\nLO2FLD   DC    H'0'\nCLILNGTH DC    H'00'\nLINECNT  DC    H'00'\nMLINECNT DC    H'58'\nHW0      DC    H'0'\nHW1      DC    H'1'\nHW2      DC    H'2'\nHW3      DC    H'3'\nHW4      DC    H'4'\nHW5      DC    H'5'\nHW8      DC    H'8'\nH32760   DC    H'32760'\n*                                      AND SAVE FOR NEXT READ\nFFFLAG   DC    8X'FF'\nWRKAREA  DC    CL12' '\nTRANSARG TRT   0(0,R5),TRTTBLE\nREPLCHG  MVC   0(0,R5),OUTFLD\nSHBLK    MVC   0(0,R5),BLANKS\nSHIFTMV  MVC   0(0,R5),0(R15)\nMOVETEMP MVC   TEMPHLD(0),0(R14)\nMOVEBACK MVC   0(0,R5),TEMPHLD\nMVEINMM  MVC   0(0,R10),0(R2)\nCOMPBLK  CLC   0(0,R5),BLANKS\nCOMPBIG  CLC   0(0,R15),BLANKS\nWRTFLAG  DC    X'00'\nFLAG1    DC    X'01'\nFLAG2    DC    X'00'\nFLAG3    DC    X'00'\nOUTFLAG  DC    X'00'\nLTRLSEQ  DC    CL3'SEQ'\nTEMPHLD  DC    CL80' '\nBLANKS   DC    CL80' '\nINFLD    DC    CL80' '\nOUTFLD   DC    CL80' '\n         EJECT\nSELECTVE DC    CL121'1  SELECTED  MEMBERS WILL BE LISTED HERE : '\nCOL8     DS    0CL121\n         DC    CL45'-  PLEASE START INPUT IN COLUMN 8 FOR DDNAME '\nCOL8DDN  DC    CL76'SYSIN  '\nSYNTAX   DC    CL121'-   ERROR IN THE SYNTAX OF INPUT; SUPPLY 8 CHARACT+\n               ER MEMBER NAME SEPARATED BY COMMAS, NOT PAST COLUMN 71.'\nOVER500  DC    CL121'-   THERE IS A FIVE HUNDRED MEMBER LIMIT FOR SYSME+\n               M INPUT. DECREASE AND RERUN.'\nENDDIRD  DC    CL121'-  END OF DATA SHOULD NOT HAVE BEEN REACHED FOR DI+\n               RECTORY. UNKNOWN ERROR, CONTACT TECH SUPPORT.'\nPDSIOERR DS    0CL121\n         DC    CL36'- UNCORRECTABLE I/O ERROR ON DDNAME '\nPDSEDDN  DC    CL8' '\n     DC    CL87'. VERIFY THE DSORG AND THEN THE FILE BEFORE RERUNNING.'\nBDLATTR  DC    CL121'-  INPUT LRECL GREATER THAN 90 BYTES, OR RECFM, OR+\n                RECFM VARIABLE. SO SORRY'\nFUNNYMAN DC    CL121'-PDS HAS NO MEMBERS, NOT VERY FUNNY ON YOUR PART.'\nSEQDESC  DC    CL20'IS SEQUENTIAL  FILE '\nPRNTLNE  DC    CL105'  '\n         DC    CL28'*         MODIFIED *'\nCHGELNE  DC    CL5' '\n         DC    CL100'**NOCHANGE** '\n         DC    CL28'*     MODIFICATION *'\nHEADER1  DS    0CL133\n         DC    CL22'1     PGM-SSCUCPDS '\n         DC    CL5' DSN='\nDATASET  DC    CL54' '\n         DC    CL8' DDNAME='\nODDNAME  DC    CL8' '\n         DC    CL8' VOLUME='\nVOLUME   DC    CL6' '\n         DC    CL13'   UNIT ADDR='\nUNITNME  DC    CL3' '\n         DC    CL6' '\nCHNGEHD  DS    0CL133\n         DC    CL22'0     INPUT ARGUMENT -'\nINARGPT  DC    CL111' '\nCHNGEHD2 DS    0CL133\n         DC    CL13'      CHANGE '\nLINECHG  DC    CL30'EVERY OCCURRENCE ON A LINE IN '\nMEMBCHG  DC    CL90'EVERY LINE  ENCOUNTERED.'\nHEADER2  DS    0CL133\n         DC    CL20'-'\nHDRSEQ   DC    CL25'UPDATES FOR THE MEMBER - '\nHDRMEM   DC    CL8' '\nCSCTNME  EQU   *+2\n         DC    CL6' ARE :'\n         DC    CL74' '\nUNDERSC  DS    0CL133\n         DC    CL19'+'\nSCOREH   DC    CL41'_________________________________________'\nLMUNDSC  DC    CL73' '\n         DS    0F\nRDJFCB1  RDJFCB (PDSCHGE,),MF=L\nJFCBLIST DS    0F\n         DC    X'07'\n         DC    AL3(JFCBAREA)\n         LTORG\nJFCBAREA DS    0F\n         DC    176C' '\nTRTTBLE  DC    256X'00'\n         EJECT\n*******************************************************************\n*  THIS NEAT LITTLE SECTION WILL READ IN THE DDNAMES, BUILD A NICE*\n* TABLE OF NAMES WITH EITHER PDS OR SEQ, SORT THEM AND THEN RETURN*\n*******************************************************************\nPRODDNS  LR    R5,R15\n         USING PRODDNS,R5\n         ST    R14,DDNRET         LOAD R0 WITH LENGTH\n         L     R0,LNGADDR1        LOAD R0 WITH LENGTH\n         GETMAIN R,LV=(0)\n         ST    R1,STRADDR1        SAVE THE LOCATION ADDR. FOR FREEMAIN\n         ST    R1,DDNADDR           AND FOR PROCESSING DDNAMES\n         LR    R11,R1             GET VALUE IN R11\n         L     R3,16              ADDR. CVT\n         L     R3,0(R3)           ADDR. TCB\n         L     R3,4(R3)           ADDR. ACTIVE TCB\n         L     R3,12(R3)          ADDR. TIOT\n         LA    R3,24(R3)          ADDR. FIRST DDNAME\n         SLR   R4,R4              CLEAR R4\n         LR    R10,R4             CLEAR R10\n*  NEXT STATEMENT WAS MOVED TO ALWAYS SORT NAMES BECAUSE OF\n*  EXCP PROCESSING         WHS 87266\n*  I TOOK OUT EXCP PROCESSING BECAUSE OF WEIRD 3390 RESULTS 3/94\nLOOPDDN  CLC   4(3,R3),=C'PDS'    DOES DDNAME BEGIN WITH PDS---\n         BE    MVEDDN             YES, THEN STORE THE NAME\n         CLC   4(3,R3),LTRLSEQ    DOES DDNAME BEGIN WITH SEQ---\n         BNE   INCRDDN            NO, THEN GET NEXT ONE\n         OI    FLAG2,X'08'        SET FLAG FOR SEQUENTIAL FILE\nMVEDDN   SLR   R6,R6\n         ICM   R6,7,17(R3)        GET THE ADDRESS OF THE UCB\n         CLI   18(R6),X'20'       IS THIS A DASD DEVICE\n         BE    ITSDASD\nINVALDEV MVC   INVDEVT+4(8),4(R3) MOVE DDNAME TO MESSAGE\n         PUT   ERRPRIN1,INVDEVT\n         B     INCRDDN            AND DO NOT BOTHER WITH IT\nITSDASD  MVC   0(8,R11),4(R3)     YES, THEN UPDATE TABLE ENTRY W/NAME\nNOEXCPDD LA    R11,12(R11)         INCREMENT BY 12\n         LA    R10,1(R10)         KEEP COUNT OF NUMBER OF DDNAMES\nINCRDDN  ICM   R4,1,0(R3)         GET LENGTH INCREMENT\n         LA    R3,0(R4,R3)        POINT R3 TO NEW DDNAME\n         CLI   0(R3),X'00'        IS IT A DDNAME FIELD\n         BNE   LOOPDDN            YES, THEN PROCESS NEXT ONE\n         MVI   0(R11),X'FF'       FLAG END OF LIST\nGETDDN   L     R14,DDNADDR        RE-ADDR BEGINNING OF DDNAME LIST\n         CLI   0(R14),X'FF'       DID THEY SUPPLY ANY DDNAMES\n         BNE   VERMEMDD           YES, THEN CONTINUE, ELSE MORON MSG\n         PUT   ERRPRIN1,NOPDSDD\n         B     FREEDDN1           GO FREE UP STORAGE AND QUIT\nVERMEMDD TM    FLAG1,X'20'        ARE WE DOING MEMB PROCESSING\n         BZ    NEXTDDN            NO, THEN WE ARE OKAY\n         TM    FLAG2,X'08'        WAS A SEQUENTIAL FILE REQUESTED\n         BZ    VONEPDS            NO, THEN WE ARE STILL OKAY\n         PUT   ERRPRIN1,BADSEQ\n         B     FREEDDN1           GO FREE UP STORAGE AND QUIT\nVONEPDS  CLI  12(R14),X'FF'       MAKE SURE THAT WE FOUND A VALID DDN\n         BE    NEXTDDN            IF FF AT +8 THEN WE AT LEAST HAVE 1\n         PUT   ERRPRIN1,ONEPDST\n         B     FREEDDN1           GO FREE UP STORAGE AND QUIT\nNEXTDDN  EQU   *\n**************************************************************\n* SORT THE DDNAMES WITH ALL PDS'S FIRST THEN SEQ'S AFTER     *\n**************************************************************\n         CH    R10,HW1         SEE HOW MANY DDNAMES SPECIFIED\n         BE    NODDSRT         IF ONLY ONE FILE THEN NO SORT\n         BCTR  R10,0           DECREMENT COUNT FOR SORT\n         LR    R9,R10          AND LOAD UP R9 TO HELP WITH SORT\n         LA    R15,12(R14)      POINT TO NEXT ENTRY IN TABLE\nCOMPDDN  CLC   0(3,R14),0(R15)  COMPARE 2 ENTRIES IN THE TABLE\n         BL    DDNOKH          IF LESS THEN LEAVE ALONE\n         BH    FLIPDDN         IF GRTR THEN FLIP THEM\nFLIPDDN  MVC   WRKAREA(12),0(R14)  IF GREATER THEN SWITCH\n         MVC   0(12,R14),0(R15)    AND SWITCH\n         MVC   0(12,R15),WRKAREA   AND SWITCH\nDDNOKH   LA    R15,12(R15)       INCREMENT TABLE POINTER\n         BCT   R9,COMPDDN      AND LOOP THRU TILL ALL ARE DONE\n         BCTR  R10,0           DECREMENT SORT COUNTER\n         LTR   R10,R10         HAVE WE DONE ALL ENTRIES ?\n         BZ    REL14DD         YES, THEN GET OUT OF SORT\n         LR    R9,R10          RELOAD COUNTER INTO R9\n         LA    R14,12(R14)      INCREMENT 1ST TABLE POINTER\n         LA    R15,12(R14)      AND POINT TO NEXT ENTRY IN TABLE\n         CLI   0(R15),X'FF'    DOUBLE CHECK FOR END OF TABLE\n         BNE   COMPDDN         NOT END, THEN KEEP LOOPING\nREL14DD  L     R14,DDNADDR        RE-ADDR BEGINNING OF DDNAME LIST\nNODDSRT  MVC   DIRREAD+40(8),0(R14)  MOVE DDNAME TO DIRECTRY DCB\n         MVC   PDSCHGE+40(8),0(R14)    AND PDS DCB\nCHKSQFL  TM    FLAG2,X'08'           SEE IF SEQUENTIAL FILE REQUESTED\n         BZ    NOPARM                NO, THEN DO NOT WORRY\nLOOKSEQ  CLC   0(3,R14),LTRLSEQ      SEE IF SEQUENTIAL FILE ON THIS\n         BNE   PRORET\nSETDSRG  MVC   PDSCHGE+26(2),=X'4000'    DSORG FOR PS FILE\n         OI    FLAG2,X'10'       ON THIS PASS. SET FLAG FOR SEQ FILE\n         MVC   HDRSEQ+14(20),SEQDESC\nPRORET   L     R14,DDNRET\n         BR    R14\nDDNRET   DC    F'0'\nNOPDSDD  DC    CL121'-   IT SEEMS THAT YOU HAVE NOT SUPPLIED ANY VALID +\n               DDNAMES. PREFIX DDNAME WITH PDS OR SEQ AND RERUN.'\nINVDEVT  DC    CL121'-            DDNAME EXISTS ON A DEVICE THAT IS NOT+\n                SUPPORTED BY THIS PROGRAM. SORRY.'\nBADSEQ   DC    CL121'- YOU CAN NOT PROCESS A SEQUENTIAL DDNAME WITH THE+\n                MEMB PARAMETER. CORRECT AND RERUN.'\nONEPDST  DC    CL121'- YOU CAN ONLY PROCESS ONE PDS AT A TIME WITH THE +\n               MEMB PARAMETER. CORRECT AND RERUN.'\n         LTORG\n         DROP  R5\n******************************************************************\n         EJECT\n******************************************************************\n*  THIS IS OUR HANDSOMELY PRODUCED OUTPUT SECTION. REGISTERS ARE *\n* SAVED ON ENTRY AND THEN RESTORED AT DEPARTURE. ALL OUTPUT REC- *\n* ORDS HAVE BEEN BUILT AND WE COME HERE ONLY TO MAKE THEM A      *\n* LITTLE NEATER. WE GUESSTIMATE AT LEAST 58 -  61 LINES PER PAGE.*\n******************************************************************\n         USING DOOUTPUT,R15\nDOOUTPUT STM   R2,R14,OUTSAVE     SAVE THE REGS\n         LR    R10,R15\n         DROP  R15\n         USING DOOUTPUT,R10\nGETLNCT  LH    R2,LINECNT         RELOAD LINE COUNT\n         LTR   R2,R2              ARE WE AT TOP OF PAGE\n         BNZ   OCHKMEM            NO, THEN DON'T PRINT HEADERS\n         LA    R2,4(R2)           INCREMENT COUNTER\n         PUT   SYSPRIN1,HEADER1\n         PUT   SYSPRIN1,CHNGEHD\n         PUT   SYSPRIN1,CHNGEHD2\n         TM    OUTFLAG,X'02'      DO WE WANT A NO ARG FOUND FIELD\n         BZ    OCHKMEM            NO, THEN CONTINUE WITH NORMAL OUTPUT\n         NI    OUTFLAG,X'FC'      RESET IT FOR THE OVERALL PROCESSING\n         PUT   SYSPRIN1,NOARGFD\n         LM    R2,R14,OUTSAVE     RESTORE REGS\n         BR    R14                RETURN TO NIMH\nOCHKMEM  EQU   *\n         TM    FLAG2,X'10'        IF THIS IS A SEQUENTIAL PROCESS\n         BO    OMVEMEM            THEN DO NOT CHECK MEMBER NAMES\n         CLC   HDRMEM(8),0(R11)   SAME MEMBER NAME FOR OUTPUT\n         BE    OMVEMEM            YES, THEN DON'T SWITCH\n         MVC   HDRMEM(8),0(R11)   MOVE MEMBER NAME TO PRINT LINE\nPUTMEMS  EQU   *\n         PUT   SYSPRIN1,HEADER2\n         PUT   SYSPRIN1,UNDERSC\n         MVI   PRNTLNE,C'0'       RESET TO DOUBLE SPACE AFTER NAME\n         LA    R2,4(R2)           ADD INCR.\n         B     OMVEOUT            GO AROUND\nOMVEMEM  CH    R2,HW4             DID WE JUST PRINT THE HEADERS\n         BNE   OMVEOUT            NO, THEN DON'T REPRINT\n         PUT   SYSPRIN1,HEADER2\n         PUT   SYSPRIN1,UNDERSC\n         MVI   PRNTLNE,C'0'       DOUBLE SPACE AFTER THIS ONLY\n         LA    R2,4(R2)           INCR. LINE COUNTER\nOMVEOUT  EQU   *\n         PUT   SYSPRIN1,PRNTLNE\n         MVI   PRNTLNE,C' '       RESET ANSI TO SINGLE SPACE\n         TM    FLAG2,X'01'        SEE IF SCAN  PARM RUN ONLY  3 MAR 86\n         BO    RESETRF            YES, THEN GO AROUND         3 MAR 86\n         LA    R2,1(R2)           INCR. COUNTER\n         TM    OUTFLAG,X'80'      DID WE FLAG AS TOO BIG TO CHANGE\n         BZ    ONOERR             NO, THEN PRINT THE CHANGE\n         NI    OUTFLAG,X'7F'      RESET THE FLAG\n         PUT   SYSPRIN1,ERRLINE\n         B     INCROUT            BRANCH AROUND\nONOERR   PUT   SYSPRIN1,CHGELNE\nRESETRF  NI    OUTFLAG,X'BF'      RESET RECORD FLAG\nINCROUT  LA    R2,1(R2)           EITHER WAY INCREMENT COUNTER\n         CH    R2,MLINECNT        ARE WE AT AT LEAST 58\n         BL    GOBACK             NO, THEN SAVE R2 COUNTER AS IS\n         SLR   R2,R2              YES, RESET TO 0\nGOBACK   STH   R2,LINECNT         STORE EITHER 0 OR COUNT\n         LM    R2,R14,OUTSAVE     RESTORE REGS\n         BR    R14                RETURN TO NIMH\nOUTSAVE  DS    13F\nNOARGFD  DC    CL133'-         ****     UNABLE TO FIND ANY OCCURRENCE O+\n               F ARGUMENT SPECIFIED FOR THE ABOVE LISTED FILE   ****'\nERRLINE  DC    CL105'                    *****   UNABLE TO CHANGE THIS +\n               RECORD.   *****'\n         DC    CL28'*     MODIFICATION *'\n         LTORG\n         DROP  R10\n         EJECT\n*****************************************************************\n*  THIS IS THE INPUT SECTION WHICH WILL CONSIST OF ONLY ONE CON-*\n* TROL CARD WITH THE CHANGE AND THE NUMBER. THE FORMAT IS :     *\n*           /INPUT ARGUMENT/CHANGE/ 1 1                         *\n*  WHERE '/' ARE DELIMETERS AND ARE REQUIRED. THE INPUT ARGUMENT*\n* BECOMES THE SEARCH ARG., AND THE CHANGE REPLACES IT. THE NUM- *\n* ERIC VALUES OF '1' '1' ARE FOR NUMBER OF OCCURRENCS IN A LINE *\n* AND NUMBER OF OCCURRENCES IN A MEMBER. THE VALUE IS EITHER ONE*\n* OR ALL. IF THE SECOND '1' IS REQUESTED CODE ANYTHING IN THE   *\n* FIRST POSITION. (E.G.)  /DATA/CHANGE/ * 1                     *\n*                                                               *\n*  IF PARM SCAN  WAS SPECIFIED THEN THE INPUT ARGUMENT WILL HAVE*\n* THE FORMAT :    /DATA/ 1 1                                    *\n*   NO CHANGE ARGUMENT IS NECESSARY HERE                        *\n*****************************************************************\n         USING VERSYSN,R15\nVERSYSN  STM   R2,R14,INSAVE\n         LR    R10,R15\n         DROP  R15\n         USING VERSYSN,R10\n         RDJFCB MF=(E,RDJFCB2)\n         CLC   JFCBAREA(8),=C'NULLFILE'\n         BNE   OPENSIN\n         OI    FLAG1,X'02'        SET FLAG FOR WTOR\nASKFOR   WTOR  'SSCUCPDS -  PLEASE SUPPLY THE INPUT STATEMENT FOR THE P+\n               DS CHANGE ROUTINE OR QUIT.',REPLY,80,WTORECB,ROUTCDE=2\n         WAIT  ECB=WTORECB\n         MVI   WTORECB,X'00'\n         OC    REPLY(80),BLANKS   CAPITALIZE EVERYTHING\n         CLC   REPLY(4),=C'QUIT'  IS THIS RUN A MISTAKE\n         BE    CLOSEPRT           YES, THEN JUST QUIT\n         LA    R2,REPLY           GET THE INPUT COMMAND\n         B     GOTRCD             AND JUMP INTO THE MIDDLE OF PROCESS.\n*******************************************************************\nOPENSIN  L     R1,4(R13)     LOAD UP CALLING ROUTINES SAVE AREA\n         CLC   72(8,R1),=C'SYSLKPDS'     SEE IF THIS PGM CALLED US\n         BNE   OPENSYSN\n         L     R1,36(R1)     LOAD UP VALUE OF CALLERS R4\n         MVC   REPLY(80),0(R1)    HE ALREADY READ THE INPUT RECORD\n         LA    R2,REPLY           LOAD UP WITH VIRTUAL SYSIN RECD\n         B     GOTRCD             DO NOT PROCESS SYSIN\nOPENSYSN OPEN  SYSIN\n         TM    SYSIN+48,X'10'     VALID OPEN OF SYSIN\n         BZ    CLOSEPR1\nOPENOK3  GET   SYSIN,REPLY        GET THE ONE AND ONLY RECORD\n         LA    R2,REPLY           ADDR. R2 WITH LOCATION\nCLOSSYS  CLOSE SYSIN              CLOSE THE INPUT FILE\nGOTRCD   LA    R7,79(R2)          POINT TO END OF RECORD FOR COMPARE\n         LA    R3,8               DATA MUST BEGIN BY COL. 8\nLOOPIT   CLI   0(R2),C' '         CHECK FOR NON - BLANK\n         BNE   FRSTFLD            NOT BLANK THEN GO ON\n         LA    R2,1(R2)           INCR. R2 TO NEXT BYTE\n         BCT   R3,LOOPIT          DO IT 8 TIMES\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BNZ   TELLIT1            YES, THEN RESET AND GIVE NOTHER CHNCE\n         PUT   ERRPRIN1,COL8\n         B     CLOSEPR1           NO, THEN QUIT\nTELLIT1  EQU   *\n         WTO   'PLEASE START INPUT BY COLUMN 8.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nFRSTFLD  LR    R5,R2              LET R5 HOLD FIRST GOOD BYTE\n         LA    R2,1(R2)           INCR R2 TO NEXT POSITION\nLOOPARG2 CLC   0(1,R5),0(R2)      LETS LOOK FOR DELIMETER\n         BE    GOTFRST            WE FOUND IT HOORAY\n         LA    R2,1(R2)           INCR R2 AND KEEP LOOKING\n         CR    R2,R7              ARE WE AT THE END OF THE RECORD\n         BL    LOOPARG2           NO, THEN CONTINUE SEARCH\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    DELIMPE            NO, THEN QUIT\nTELLIT2  EQU   *\n         WTO   'DELIMETER PROBLEM, PLEASE GET IT RIGHT.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nGOTFRST  LR    R3,R2              GET ADDR. IN R3 OF 2ND DELIMETER\n         SR    R3,R5              GET LENGTH\n         BCTR  R3,0                FOR LENGTH OF FIELD\n         LTR   R3,R3              IF R3 IS ZERO , NULL INPUT ARG.\n         BNZ   SEEHEX             LET'S GO SEE IF HEX DATA\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    DELIMPE            NO, THEN QUIT\nTELLIT3  EQU   *\n         WTO   'ZERO LENGTH OF INPUT FIELD.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nSEEHEX   CLC   1(2,R5),=X'E77D'   SEE IF IN HEX FORMAT  X'\n         BNE   STORIT\n         OI    FLAG2,X'04'     SET THIS FLAG FOR NOW TO SHOW IN HEX\n         LR    R15,R2\n         BCTR  R15,0\n         CLI   0(R15),X'7D'\n         BE    GOOD1HEX\n         TM    FLAG1,X'02'\n         BZ    HEXE\nTELLIT3A EQU   *\n         WTO   'INVALID SYNTAX FOR HEX INPUT FIELD.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nGOOD1HEX LR    R14,R3\n         SH    R14,HW3\n         LTR   R14,R14            IF R14 IS ZERO , NULL INPUT ARG.\n         BNZ   SETFLDS            IF NOT THEN CONTINUE\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    HEXE               NO, THEN QUIT\nTELLIT3B EQU   *\n         WTO   'ZERO LENGTH OF HEX INPUT FIELD.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nSETFLDS  SLR   R15,R15            CLEAR R15\n         SRDL  R14,1              SHIFT OUT LO ORDER BIT FOR ODD NUM\n         LTR   R15,R15\n         BZ    LEVENM\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    HEXODD             NO, THEN QUIT\nTELLIT3C EQU   *\n         WTO   'THE NUMBER OF HEX CHARACTERS MUST BE EVEN !',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nLEVENM   LR    R3,R14             THIS IS THE TRUE LENGTH AFTER TRNSLTE\n         SLL   R14,1              PUT THE ZERO BACK IN AND PARSE IT\n         LA    R8,3(R5)           POINT TO FIRST BYTE OF HEX FIELD\nPARSLOOP CLI   0(R8),C'A'         A CUMBERSOME PARSE BUT WORKABLE\n         BL    ERRORHX\n         CLI   0(R8),C'F'\n         BNH   GOODHX\n         CLI   0(R8),C'0'\n         BL    ERRORHX\n         CLI   0(R8),C'9'\n         BNH   GOODHX\nERRORHX  TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    HEXPRSE            NO, THEN QUIT\nTELLIT3D EQU   *\n        WTO   'INVALID HEX CHARACTER; A-F OR 0-9 ARE VALID.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         B     ASKFOR             ASK AGAIN PLEASE\nGOODHX   LA    R8,1(R8)\n         BCT   R14,PARSLOOP\n         LR    R14,R3          PUT BACK LENGTH OF INPUT\n         SLL   R14,1           AND DOUBLE FOR TRUE LENGTH\n         LA    R8,3(R5)        RESET TO BEGINNING\n         BCTR  R14,0           DECREMENT FOR EXECUTE INSTR\n         LA    R15,3(R14)\n         EX    R15,MVEIARG         MOVE TO PRINT AREA AS HEX DATA\n         LA    R9,TRTABLE\n         EX    R14,TRNSHX      TR  0(0,R8),0(R9)\n         LR    R9,R3           FOR A HALF-ASS LOOP\n         LA    R1,INFLD\n         SLR   R14,R14\n         LR    R15,R14\nHALOOP   ICM   R14,1,0(R8)\n         ICM   R15,8,1(R8)\n         SLL   R15,4           CLEAR OUT THE ZERO\n         SLDL  R14,4\n         STCM  R14,1,0(R1)\n         LA    R1,1(R1)\n         LA    R8,2(R8)\n         BCT   R9,HALOOP\n         IC    R14,INFLD\n         LA    R14,TRTTBLE(R14)\n         MVC   0(1,R14),INFLD     UPDATE TRANSLATE TABLE WITH ARG\n         STH   R3,LI1FLD\n         BCTR  R3,0\n         STCM  R3,1,COMPARE+1\n         SLL   R3,1            DOUBLE IT FOR THE OUTPUT AREA\n         LA    R3,4(R3)        GET THIS FOR  X'  '\n         B     GOTHEX\nSTORIT   STH   R3,LI1FLD          STORE THE LENGTH\n         SLR   R14,R14            CLEAR R14 FOR IC\n         IC    R14,1(R5)        INSERT SEARCH BYTE\n         LA    R14,TRTTBLE(R14)   INCREMENT INTO TRANSLATE TABLE\n         MVC   0(1,R14),1(R5)  MOVE THE FIRST BYTE TO SEARCH CLI\n         BCTR  R3,0                LENGTH FOR EX MOVE\n         STCM  R3,1,COMPARE+1     MOVE THE LENGTH FOR SEARCH CLC\n         EX    R3,MVEI1FLD        MOVE INTO THE HOLDING AREA\n         EX    R3,MVEIARG         MOVE TO PRINT AREA\n*********************************************************************\n*  WE ARE ADDING IN THE LOGIC FOR SCAN  PROCESSING, BYPASS A CHANGE *\n*  ARGUMENT AND ALL THE EXCESS LENGTH PROCESSING.                   *\n*********************************************************************\nGOTHEX   EQU   *\nNODSPLY  LA    R6,INARGPT+1(R3)   ADDR PRINT AREA PAST INP ARG.\n         MVI   0(R6),C'-'\n         TM    FLAG2,X'01'        IF SCAN  PARM THEN NO CHANGE ARG\n         BO    CHCKLNG            GO TO COUNT FIELD\n         LA    R6,5(R6)           ADDR PRINT AREA PAST INP ARG.\n         MVC   0(17,R6),=C'CHANGE ARGUMENT -'\n         LA    R6,17(R6)          ADDR. R6 FOR CHANGE ARG. IN OUTPUT\n         LR    R5,R2              RE-ADDR. R5 WITH DELIM. POSITION\n         LA    R2,1(R2)            IN CASE THEY WANT NULL ARGUMENT\n         EJECT\nLOOP2ARG CLC   0(1,R5),0(R2)      LET'S FIND THE ENDING DELIMETER\n         BE    GOT2ND             WE FOUND IT, GOOD FOR US\n         LA    R2,1(R2)           INCR. AND TRY AGAIN\n         CR    R2,R7              UNLESS OF COURSE WE'VE GONE TOO FAR\n         BL    LOOP2ARG           NO, WHOO WE'LL LOOK AGAIN\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    DELIMPE            NO, THEN QUIT\nTELLIT4  EQU   *\n         WTO   'PLEASE USE AN ENDING DELIMETER.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD\n         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO\n         B     ASKFOR             ASK AGAIN PLEASE\nGOT2ND   LR    R3,R2              WE GOT THE ENDING DELIMETER\n         SR    R3,R5              GET LENGTH\n         BCTR  R3,0             WHICH OF COURSE IS -1 AFTER SUBTRACT\nSEEHEX2  CLC   1(2,R5),=X'E77D'   SEE IF IN HEX FORMAT  X'\n         BNE   STORIT2\n         OI    FLAG2,X'04'     SET THIS FLAG FOR NOW TO SHOW IN HEX\n         LR    R15,R2\n         BCTR  R15,0\n         CLI   0(R15),X'7D'\n         BE    GOOD2HEX\n         TM    FLAG1,X'02'\n         BZ    HEXE\nTELLIT4B EQU   *\n         WTO   'INVALID SYNTAX FOR HEX INPUT FIELD.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD\n         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO\n         B     ASKFOR             ASK AGAIN PLEASE\nGOOD2HEX LR    R14,R3\n         SH    R14,HW3\n         LTR   R14,R14            IF R14 IS ZERO , NULL INPUT ARG.\n         BNZ   SETFLD2            IF NOT THEN CONTINUE\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    HEXE               NO, THEN QUIT\nTELLIT4C EQU   *\n         WTO   'ZERO LENGTH OF HEX INPUT FIELD.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD\n         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO\n         B     ASKFOR             ASK AGAIN PLEASE\nSETFLD2  SLR   R15,R15            CLEAR R15\n         SRDL  R14,1              SHIFT OUT LO ORDER BIT FOR ODD NUM\n         LTR   R15,R15\n         BZ    LEVENM2\n         TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    HEXODD             NO, THEN QUIT\nTELLIT4D EQU   *\n         WTO   'THE NUMBER OF HEX CHARACTERS MUST BE EVEN !',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD\n         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO\n         B     ASKFOR             ASK AGAIN PLEASE\nLEVENM2  LR    R3,R14             THIS IS THE TRUE LENGTH AFTER TRNSLTE\n         SLL   R14,1              PUT THE ZERO BACK IN AND PARSE IT\n         LA    R8,3(R5)           POINT TO FIRST BYTE OF HEX FIELD\nPARSLOP2 CLI   0(R8),C'A'         A CUMBERSOME PARSE BUT WORKABLE\n         BL    ERRORHX2\n         CLI   0(R8),C'F'\n         BNH   GOODHX2\n         CLI   0(R8),C'0'\n         BL    ERRORHX2\n         CLI   0(R8),C'9'\n         BNH   GOODHX2\nERRORHX2 TM    FLAG1,X'02'        IS INPUT FROM A WTOR\n         BZ    HEXPRSE            NO, THEN QUIT\nTELLIT4E EQU   *\n        WTO   'INVALID HEX CHARACTER; A-F OR 0-9 ARE VALID.',ROUTCDE=11\n         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY\n         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD\n         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO\n         B     ASKFOR             ASK AGAIN PLEASE\nGOODHX2  LA    R8,1(R8)\n         BCT   R14,PARSLOP2\n         LR    R14,R3          PUT BACK LENGTH OF INPUT\n         SLL   R14,1           AND DOUBLE FOR TRUE LENGTH\n         LA    R8,3(R5)        RESET TO BEGINNING\n         BCTR  R14,0           DECREMENT FOR EXECUTE INSTR\n         LA    R15,3(R14)\n         EX    R15,MVEOARG         MOVE TO PRINT AREA AS HEX DATA\n         LA    R9,TRTABLE\n         EX    R14,TRNSHX      TR  0(0,R8),0(R9)\n         LR    R9,R3           FOR A HALF-ASS LOOP\n         LA    R1,OUTFLD\n         SLR   R14,R14\n         LR    R15,R14\nHALOOP2  ICM   R14,1,0(R8)\n         ICM   R15,8,1(R8)\n         SLL   R15,4           CLEAR OUT THE ZERO\n         SLDL  R14,4\n         STCM  R14,1,0(R1)\n         LA    R1,1(R1)\n         LA    R8,2(R8)\n         BCT   R9,HALOOP2\n         STH   R3,LO2FLD\nLNGOK    BCTR  R3,0\n         SLL   R3,1            DOUBLE IT FOR THE OUTPUT AREA\n         LA    R3,4(R3)        GET THIS FOR  X'  '\n         B     INOULN\nSTORIT2  STH   R3,LO2FLD          STORE THE LENGTH\nDECR3L2  BCTR  R3,0               DECR. FOR EX MOVE\n         EX    R3,MVEO2FLD        MOVE TO CHANGE HOLD AREA\n         EX    R3,MVEOARG         MOVE TO OUTPUT AREA\nINOULN   LA    R6,1(R3,R6)\n         MVI   0(R6),C'-'\nCHCKLNG  LA    R9,10              ARGUMENTS MUST OCCUR WITHIN 10 BYTS\n         LA    R2,1(R2)           INCR. TO NEXT POSITION\nLOOPCNT1 CLI   0(R2),C' '         FIND THE NON - BLANK\n         BNE   CHECKEM            WE GOT ONE\n         LA    R2,1(R2)           INCR. TO NEXT POSITION\n         CR    R2,R7              ARE WE AT END OF RECORD\n         BNL   SETOVRL            YES, THEN GO ON ; NO LENGTH\n         BCT   R9,LOOPCNT1        DO FIVE TIMES\n         B     SETOVRL            FIVE POSITIONS, THEN FORGET IT\nCHECKEM  CLI   0(R2),C'1'         IS IT A ONE\n         BNE   CHECK2ND         NO,THEN JUST A FILLER ( OR * FOR ALL)\n         OI    FLAG1,X'04'        SET FLAG TO DO ONLY 1 PER LINE\n         MVC   LINECHG(5),=C'FIRST'\nCHECK2ND LA    R2,1(R2)           INCR TO NEXT POSITION\nLOOPCNT2 CLI   0(R2),C' '         CHECK FOR NON-BLANK\n         BE    GET2ND             FOUND IT, THEN GO ON\n         LA    R2,1(R2)           INCR TO NEXT POSITION\n         CR    R2,R7              ARE WE AT END OF RECORD\n         BNL   SETOVRL            YES, THEN GO TO NEXT AREA\n         BCT   R9,LOOPCNT2        DO REMAINDER OF FIVE POSITIONS\n         B     SETOVRL            GO ON\nGET2ND   LA    R2,1(R2)           IS LAST ARGUMENT NUMERIC\nLOOPCNT3 CLI   0(R2),C' '         CHECK FOR NON-BLANK\n         BNE   GET3RD             FOUND IT, THEN GO ON\n         LA    R2,1(R2)           INCR TO NEXT POSITION\n         CR    R2,R7              ARE WE AT END OF RECORD\n         BNL   SETOVRL            YES, THEN GO TO NEXT AREA\n         BCT   R9,LOOPCNT3        DO REMAINDER OF FIVE POSITIONS\n         B     SETOVRL            GO ON\nGET3RD   CLI   0(R2),C'0'         IS LAST ARGUMENT NUMERIC\n         BL    SETOVRL            NO, THEN DON'T SET FLAG\n         OI    FLAG1,X'08'        SET FLAG FOR ONE UPDATE PER BLOCK\n         LA    R4,1(R2)           LOAD UP NEXT ADDR\n         LA    R15,3              MAX OF 4 NUMBERS\nLOOPMNUM CLI   0(R4),C'0'         IF LESS THAN WE ARE DONE\n         BL    DONEMNUM           GO AROUND\n         LA    R4,1(R4)\n         BCT   R15,LOOPMNUM\nDONEMNUM SR    R4,R2\n         BCTR  R4,0\n         LR    R3,R4\nMNUMPACK EX    R4,PACKMNUM           PACK PACKDBLE(4),0(0,R2)\n         CVB   R4,PACKDBLE\n         CH    R4,HW1\n         BNE   NOTFRST\n         MVC   MEMBCHG(5),=C'FIRST'\n         B     SEEIFPK0\nNOTFRST  MVC   MEMBCHG(5),BLANKS\n         EX    R3,MOVEMBCH           MVC  MEMBCHG(0),0(R2)\n         MVI   MEMBCHG+10,C'S'\nSEEIFPK0 LTR   R4,R4\n         BNZ   STORPK\n         MVI   MEMBPKNM+3,X'01'    SET TO 1\n         MVI   MEMBPKN2+3,X'01'    SET TO 1\n         B     SETOVRL\nSTORPK   ST    R4,MEMBPKNM         TO BE SAVE FOR ENTIRE PGM\nSTORPK2  ST    R4,MEMBPKN2         TO BE USED IN CALCULATIONS\n         EJECT\n******************************************************************\n*  THIS NEXT AREA IS RATHER SILLY, BUT I LIKED IT LIKE THAT. R4  *\n* WILL REMAIN A GLOBAL LENGTH FIELD THROUGHOUT THE REST OF THE   *\n* PROGRAM. IF YOU MODIFY THIS PROGRAM AND CLOBBER R4 AFTER THIS  *\n* NEXT SECTION YOUR RESULTS WILL BE AS FUNNY AS MINE WERE.       *\n*  FLAGS WILL BE SET FOR THE LENGTH FIELDS, WITH A FLAG OF X'80' *\n* SIGNIFYING THE OUTPUT ARG. IS GREATER THAN THE INPUT ARG. AND  *\n* THE DATA AREA WILL BE EXPANDED. A FLAG OF X'40' SIGNIFIES A    *\n* DECREMENT OF THE DATA AREA AFTER THE CHANGE. IF FIELDS ARE THE *\n* SAME LENGTH THEN R4 CONTAINS THE LENGTH-1 FOR THE 'EX' MOVE    *\n* INSTR.( WHICH IS SET LATER BEFORE THE ACTUAL READING OF PDS    *\n* BEGINS. IF NOT EQUAL R4 CONTAINS THE DIFFERENCE OF THE LENGTHS *\n******************************************************************\nSETOVRL  TM    FLAG2,X'01'        SEE IF SCAN  PARM    3 MAR 86\n         BO    RETIN              IF YES THEN DO NOT PROCESS\n         SLR   R4,R4              CLEAR R4\n         CLC   LI1FLD(2),LO2FLD   CHECK THE 2 LENGTH FIELDS\n         BE    RETIN              IF EQUAL THEN JUST GO ON\n         BL    EXPANDF            IF LESS THEN SET EXPAND FLAG\nDECREAS  OI    FLAG1,X'40'        SET LESS THAN FLAG\n         LH    R4,LI1FLD          GET INPUT LENGTH IN R4\nDECRFORS SH    R4,LO2FLD          GET DIFFERENCE BETWEEN BOTH\n         B     RETIN              CONTINUE\nEXPANDF  OI    FLAG1,X'80'        SET GREATER THAN FIELD\n         LH    R4,LO2FLD          GET LENGTH OF CHANGE FIELD IN R4\n         SH    R4,LI1FLD          GET DIFFERENCE BETWEEN BOTH\nRETIN    LM    R2,R3,INSAVE       DO NOT WANT TO RELOAD R4 BECAUSE\n         LM    R5,R14,INSAVE+12   THE LENGTH IS USED THROUGHOUT PGM\n         BR    R14\nSYSIN    DCB   DDNAME=SYSIN,MACRF=GM,DSORG=PS,EODAD=NOINPUT,           +\n               EXLST=JFCBLST2\nRDJFCB2  RDJFCB (SYSIN,),MF=L\nPACKDBLE DC    D'0'\nINSAVE   DS    13F\nWTORECB  DC    F'00'\nTRNSHX   TR    0(0,R8),0(R9)           R9 FOR ADDRESSABILITY\nMVEI1FLD MVC   INFLD(0),1(R5)\nMVEIARG  MVC   INARGPT(0),1(R5)\nMVEO2FLD MVC   OUTFLD(0),1(R5)\nMOVEMBCH MVC   MEMBCHG(0),0(R2)\nPACKMNUM PACK  PACKDBLE+4(4),0(0,R2)\nMVEOARG  MVC   0(0,R6),1(R5)\nREPLY    DC    CL80' '\nJFCBLST2 DS    0F\n         DC    X'07'\n         DC    AL3(JFCBAREA)\n         DC    8X'FF'\n         DS    0F\nTRTABLE  EQU   *-192\n*        BECAUSE OF THE EARLIER PARSING (A THRU F AND 0 THRU 9) THE\n*        CHARACTERS TRANSLATED WILL NOT OCCUR PRIOR TO OFFSET C0\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'000A0B0C0D0E0F000000000000000000'  C\n         DC    X'00000000000000000000000000000000'  D\n         DC    X'00000000000000000000000000000000'  E\n         DC    X'00010203040506070809000000000000'  F\n         LTORG\n         DROP  R10\n******************************************************************\n*  THIS NEXT SECTION WILL BE USED TO PRINT A SUMMARY OF THIS PRO-*\n*  GRAM TO INCLUDE PARM VALUES, DDNAMES, AND INPUT AND OUTPUT    *\n*  FILES. I JUST FIGURED I WOULD BE NICE ???                     *\n******************************************************************\n         USING PRNTHDR,R15\nPRNTHDR  STM   R2,R14,PRNSAVE\n         DROP  R15\n         LR    R10,R15\n         USING PRNTHDR,R10\n         L     R2,PARMADDR\n         LH    R3,0(R2)\n         LTR   R3,R3\n         BZ    NOPARMV\n         BCTR  R3,0\n         EX    R3,MVEPARM\nNOPARMV  EQU   *\n         PUT   SYSPRIN1,HDRLNE1\n         PUT   SYSPRIN1,HDRLNE2\n         LA    R2,BEGLIST\n         LA    R5,ENDLIST\n         LA    R4,133\nPRTPRM   EQU   *\n         PUT   SYSPRIN1,(2)\n         BXLE  R2,R4,PRTPRM\n         LM    R2,R14,PRNSAVE\n         BR    R14\nPRNSAVE  DS    13F\nMVEPARM  MVC   PARMSIN(0),2(R2)\nHDRLNE1  DC    CL133'1   PARTITIONED DATA SET DISPLAY AND EDIT UTILITY'\nHDRLNE2  DC    CL46'-   PARAMETER VALUES IN EFFECT FOR THIS RUN - '\nPARMSIN  DC    CL87' '\nBEGLIST  EQU   *\n DC CL133'-**********  EXECUTION  PARM  VALUES  **********************'\n DC CL133' *                                                         *'\n DC CL133' *  CHGE.... UPDATE THE DATA SET(S) WITH CHANGE ARGUMENT   *'\n DC CL133' *  MEMB.... SUPPLY SELECTIVE MEMBER NAMES FOR PROCESSING  *'\n DC CL133' *  SCAN.... DISPLAY ONLY OF A SEARCH ARGUMENT             *'\n DC CL133' *  LINECNT= KEYWORD PARAMETER TO SPECIFY LINES PER PAGE   *'\n DC CL133' *           (DEFAULT 61, MAXIMUM 99, MINIMUM 9)           *'\n DC CL133' *                                                         *'\n DC CL133' **********  DDNAME SPECIFICATIONS    **********************'\n DC CL133' *                                                         *'\n DC CL133' *  SYSIN....SPECIFIES THE SEARCH AND CHANGE ARGUMENTS     *'\n DC CL133' *  SYSMEM...USED WITH MEMB PARM,CONTAINS LIST OF SPECIFIC *'\n DC CL133' *           MEMBERS TO BE PROCESSED (1 PDS PER EXECUTION) *'\n DC CL133' *  PDS-----.IF DDNAME BEGINS WITH PREFIX PDS A PARTITIONED*'\n DC CL133' *           DATA SET WILL BE PROCESSED. MULTIPLE PDS----- *'\n DC CL133' *           DDNAMES CAN BE SPECIFIED.                     *'\n DC CL133' *  SEQ-----.IF DDNAME BEGINS WITH PREFIX SEQ A SEQUENTIAL *'\n DC CL133' *           DATA SET WILL BE PROCESSED. MULTIPLE SEQ----- *'\n DC CL133' *           DDNAMES CAN BE SPECIFIED.                     *'\n DC CL133' *                                                         *'\n DC CL133' *  SYSPRIN1...SPECIFIES THE INFORMATIONAL OUTPUT DDNAME   *'\n DC CL133' *  ERRPRIN1...SPECIFIES THE ERROR OUTPUT DDNAME           *'\n DC CL133' *                                                         *'\nENDLIST  EQU   *\n DC CL133' ***********************************************************'\n         DROP   R10\n         LTORG\nNGPARM   DC    CL121'-  THE CORRECT PARM VALUES ARE EITHER MEMB, CHGE, +\n               SCAN, AND OR LINECNT=. CHOOSE THE CORRECT PARMS AND RERU+\n               N.'\nNGLINE   DC    CL121'-  THE LINE COUNT IS SPECIFIED IN THE FOLLOWING FO+\n               RMAT; LINECNT=X OR LINECNT=XX, WHERE X WILL BE A NUBER B+\n               ETWEEN 9 AND 99.'\nMUPARM   DC    CL121'-  THE CHGE PARM AND THE SCAN PARM ARE MUTUALLY EX+\n               CLUSIVE. CHOOSE ONE OR THE OTHER AND RERUN.'\nDELIMP1  DC    CL121'-  DELIMETER PROBLEM, MUST USE A BEGINNING, MIDDLE+\n                OR ENDING DELIMETER, OR YOU HAVE A ZERO LENGTH INPUT FI+\n               ELD.'\nHEXE1    DC    CL121'-  PROBLEM WITH HEX INPUT; MUST BEGIN WITH THE LET+\n               TER X AND USE SINGLE QUOTES TO DELIMIT A STRING OF HEX D+\n               ATA.'\nHEXODD1  DC    CL121'-  THE NUMBER OF HEX CHARACTERS SPECIFIED IN THE S+\n               TRING MUST BE EVEN TO FORM A PROPER BYTE.'\nHEXPRS1  DC    CL121'-  THE ONLY VALID HEX CHARACTERS ARE A THRU F AND +\n               OR 0 THRU 9; YOU SHOULD KNOW THAT.'\nNGMINPT  DC    CL121'-   FIRST RECORD FOR SYSMEM INPUT MUST BEGIN WITH +\n               EITHER SELECT= OR AN EXCLUDE= STATEMENT. FIX AND RERUN'\nBADJFCB  DC    CL121'-  PROBLEM WITH DSNAME IN JFCB. CONTACT TECH SUPPO+\n               RT AND TELL THEM THIS SHOULD NEVER HAVE OCCURRED.'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBTTIME": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xb5\\x00\\xb5\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 181, "newlines": 181, "modlines": 0, "user": "WHS"}, "text": "/*  rexx  */\n/ trace r */\n\n/* Date can either by YYDDD Julian or YYYYMMDD format   */\n\n arg date1,time1,date2,time2\n\n if length(date1) = 5 then         /* See if date 5 character Julian  */\n  do\n   year1 = 20||substr(date1,1,2)\n   day1  = substr(date1,3,3)\n  end\n else\n  do\n   year1 = substr(date1,1,4)\n /* Get the date in format mm/dd/yy and then use julian function */\n   day1   = substr(date1,5,2)'/'substr(date1,7,2)'/'substr(date1,3,2)\n   day1   = julian(day1)\n   day1   = substr(day1,3,3)\n  end\n\n if length(date2) = 5 then         /* See if date 5 character Julian  */\n  do\n   year2 = 20||substr(date2,1,2)\n   day2  = substr(date2,3,3)\n  end\n else\n  do\n   year2 = substr(date2,1,4)\n /* Get the date in format mm/dd/yy and then use julian function */\n   day2   = substr(date2,5,2)'/'substr(date2,7,2)'/'substr(date2,3,2)\n   day2   = julian(day2)\n   day2   = substr(day2,3,3)\n  end\n\n year_diff = year2 - year1\n\n\n day_diff = day2 - day1\n\n parse value time1 with hh1 ':' mm1 ':' ss1\n parse value time2 with hh2 ':' mm2 ':' ss2\n hour_diff = hh2 - hh1\n minute_diff = mm2 - mm1\n second_diff = ss2 - ss1\n\n select\n  when year_diff = 0 & day_diff = 0 & hour_diff = 0 &,\n       minute_diff = 0 & second_diff = 0 then\n   return 0\n\n  when year_diff = 0 & day_diff = 0 & hour_diff = 0 &,\n       minute_diff = 0 & second_diff > 0 then\n   return second_diff 'seconds'\n\n  when year_diff = 0 & day_diff = 0 & hour_diff = 0 &,\n       minute_diff > 0  then\n   do\n    if second_diff < 0 then\n     do\n      second_diff = second_diff + 60\n      minute_diff = minute_diff - 1\n      return minute_diff 'minutes' second_diff 'seconds'\n     end\n    else\n      return minute_diff 'minutes' second_diff 'seconds'\n   end\n\n  when year_diff = 0 & day_diff = 0 & hour_diff > 0  then\n   do\n    if minute_diff < 0 then\n     do\n      minute_diff = ((hour_diff-1)*60) + ((mm2+60) - mm1)\n      return minute_diff 'minutes'\n     end\n    else\n     do\n      minute_diff = (hour_diff*60) + minute_diff\n      return minute_diff 'minutes'\n    end\n   end\n\n  when year_diff = 0 & day_diff > 0 then\n   do\n\n    if hour_diff < 0 then\n     hour_diff = ((day_diff-1)*24) + ((hh2+24) - hh1)\n    else\n     hour_diff = (day_diff*24) + hour_diff\n\n    if minute_diff < 0 then\n     do\n      hour_diff = hour_diff-1\n      minute_diff = minute_diff + 60\n      return hour_diff 'hours' minute_diff 'minutes'\n     end\n    else\n      return hour_diff 'hours' minute_diff 'minutes'\n\n   end\n\n  when year_diff > 0 0 then\n   do\n\n    days = 0\n    leap_year = year2\n    if year1//4 = 0 then\n     last_year = 366\n    else\n     last_year = 365\n    do yy = 1 to year_diff\n     leap_year = leap_year - 1\n     if leap_year//4 = 0 then\n      days = days + 366\n     else\n      days = days + 365\n    end\n      day_diff = (days - day1) + day2\n\n\n    if hour_diff < 0 then\n     do\n      day_diff = day_diff - 1\n      hour_diff = hour_diff + 1\n     end\n\n    if minute_diff < 0 then\n     do\n      hour_diff = hour_diff-1\n      minute_diff = minute_diff + 60\n      return day_diff 'days' hour_diff 'hours' minute_diff 'minutes'\n     end\n    else\n      return day_diff 'days' hour_diff 'hours' minute_diff 'minutes'\n\n   end\n\n  otherwise\n   return 'ERROR'\n\n end\n\nexit\njulian:\n arg gdate\n MONTH = SUBSTR(GDATE,1,2)\n DAY   = SUBSTR(GDATE,4,2)\n YEAR  = SUBSTR(GDATE,7,2)\n IF \\DATATYPE(MONTH,'W') | \\DATATYPE(DAY,'W') | \\DATATYPE(YEAR,'W') |,\n  MONTH < 1 & MONTH > 12 | DAY < 1 & DAY > 31 THEN\n  DO\n   SAY 'INVALID DATE PASSED. FORMAT IS MM/DD/YY, E.G.  01/01/95'\n   SAY 'CORRECT THE FORMAT AND RETRY'\n   EXIT 16\n  END\n MONTHS.  = 31\n MONTHS.2 = 28\n MONTHS.4 = 30\n MONTHS.6 = 30\n MONTHS.9 = 30\n MONTHS.11 = 30\n IF YEAR//4 = 0 THEN\n  MONTHS.2 = 29\n  MONTH = STRIP(MONTH,'L',0)     /* STRIP ANY LEADING ZEROES  */\n  IF DAY > MONTHS.MONTH THEN\n   DO\n    SAY 'THE DAY SPECIFIED IS GT THE AMOUNT FOR THAT MONTH'\n    EXIT 16\n   END\n JDAY = 0\n LOOP_MONTH = MONTH - 1\n IF MONTH > 1 THEN\n  DO I = 1 TO LOOP_MONTH\n   JDAY = JDAY + MONTHS.I\n  END\n JDAY = JDAY + DAY\n JDAY = RIGHT(JDAY,3,0)\n JDATE = YEAR||JDAY\n\n return jdate\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYSURDR": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\xb8\\x00\\xb8\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 184, "newlines": 184, "modlines": 0, "user": "WHS"}, "text": "    TITLE 'SYSURDR  - PROGRAM TO ACCEPT JCL FROM CONSOLE USING WTOR'\n*********************************************************************\n* AUTHOR - BILL SWEENEY                                             *\n*     SSC, INC.                                                     *\n*     WHSWEENEY@SSCMAINFRAME.COM                                    *\n*     WWW.SSCMAINFRAME.COM                                          *\n* DATE - (C) COPYRIGHT 2004                                         *\n*                                                                   *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL          *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR         *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.           *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS             *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.              *\n*                                                                   *\n*                                                                   *\n*  DESCRIPTION - PROGRAM WAS WRITTEN TO PROVIDE AN INTERFACE TO     *\n*                THE CONSOLE IN THE EVENT THAT THE NETWORK WAS NOT  *\n*                AVAILABLE. IT WILL ACCEPT JCL FOR A BATCH JOB      *\n*                USING WTORS. I GOT THE IDEA FROM VSE.              *\n*                                                                   *\n*  LINKAGE INFORMATION - NONE                                       *\n*********************************************************************\n*****************************************************************\n* THIS PROGRAM WILL ALLOW YOU TO SUBMIT JOBS FROM AN OPERATOR   *\n* CONSOLE BY TYPING IN THE INDIVIDUAL JCL STATEMENTS. IT ALLOWS *\n* SOME FLEXIBILITY RELATIVE TO YOUR RESPONSES, BUT NOT MUCH. IT *\n* IS ALL WTOR DRIVEN.                                           *\n*****************************************************************\nSYSURDR  CSECT\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*******************************************************************\n* SAVE LOGIC USES R13 AS BOTH THE BASE REGISTER AND SAVE AREA PTR.*\n*******************************************************************\n         B     72(R15)\n         DS    17F\n         STM   R14,R12,12(R13)\n         ST    R13,4(R15)\n         ST    R15,8(R13)\n         LR    R13,R15\n         USING SYSURDR,R13\n*******************************************************************\n* GO GET 10 PAGES OF STORAGE, BECAUSE WHO WILL TYPE MORE THAN 500 *\n* JCL STATEMENTS.                                                 *\n*******************************************************************\n         GETMAIN R,LV=40960\n         ST    R1,STRADDR1          SAVE THE ADDRESS OF STORAGE\n         LR    R11,R1               PUT IT IN R11 ALSO\n         SLR   R10,R10              CLEAR R10 TO USE A COUNTER\n*******************************************************************\n* ISSUE 2 NON-ROLLABLE WTO'S AND THE ONE WTOR TO INITIATE THIS    *\n* WONDROUS PROCESS                                                *\n*******************************************************************\n         WTO   'THE READER UTILITY IS USED TO SUBMIT BATCH JOBS WHEN NO+\n                ONLINE SYSTEM IS AVAILABLE.',ROUTCDE=2,DESC=2\n         LR     R3,R1\n         WTO   'ENTER RESTART TO START BACK AT BEGINNING, ABORT TO QUIT+\n                PROCESSING AND EXIT, OR LIST TO DISPLAY THE RECORDS ALR+\n               EADY TYPED.',ROUTCDE=2,DESC=2\n         LR     R4,R1         SAVE ADDR POINTER FOR DOM\nLOOPTHRU MVC   JCLREC(80),BLANKS     CLEAR OUT WTOREPLY AREA BEFORE\nWTOR1    WTOR  '<-- MSG #. ENTER JCL STATEMENTS TO CREATE A JOB. WHEN F+\n               INISHED ENTER // OR A NULL CARD TO SUBMIT JOB.',        +\n               JCLREC,80,ECB1,ROUTCDE=3\n         WAIT  ECB=ECB1           SIT HERE AND WAIT FOR THERE REPLY\n         XC    ECB1,ECB1          CLEAR IT FOR GENERAL PURPOSE\n         OC    JCLREC(80),BLANKS    CAPITALIZE THE WHOLE DARN THING\n         CLC   JCLREC(6),=C'ABORT '  WOULD THEY LIKE TO QUIT ?\n         BE    FREEMSG               YES, THEN GO BYE-BYE\n         CLC   JCLREC(5),=C'LIST '   WOULD THEY LIKE TO SEE THE JCL\n         BNE   CHKREST               NO, THEN CHECK IF RESTART SPEC\n         LTR   R10,R10               LET'S MAKE SURE THERE IS DATA\n         BNZ   LODDISP               YES, THEN GO SHOW THEM\n         WTO   'YOU HAVE NO RECORDS TO DISPLAY AT THIS TIME.',ROUTCDE=2\n         B     LOOPTHRU              REISSUE THE WTOR\nLODDISP  L     R9,STRADDR1          LET R9 POINT TO BEGIN AGAIN\n         LR    R8,R10                 GET CURRENT NUMBER OF RECORDS\nLOOPIT   MVC   WTOJCLD+8(80),0(R9)   MOVE RECORD INTO WTO AREA\nWTOJCLD  WTO   '                                                       +\n                                          ',ROUTCDE=2\n         LA    R9,80(R9)            POINT TO NEXT RECORD\n         BCT   R8,LOOPIT            LOOP THRU UNTIL FINISHED\n         B     LOOPTHRU             GO ISSUE WTOR AGAIN\n**********************************************************************\n* THE RESTART FUNCTION WILL START BACK AT THE BEGINNING, MAKING YOU  *\n* RETYPE ALL YOUR STATEMENTS. IF YOU DO NOT NEED TO RESTART AT THE   *\n* BEGINNING, BUT PERHAPS THE MIDDLE, THEN SUPPLY A NUMERIC VALUE     *\n* BETWEEN 1 AND 99 TO RETURN TO A PARTICULAR PLACE.                  *\n**********************************************************************\nCHKREST  CLC   JCLREC(8),=C'RESTART '   IS THIS A RESTART\n         BNE   CHKEND               NO, THEN IT MUST BE PART OF JOB\n         TRT   JCLREC+7(5),NBLANK   LOOK FOR 1ST NON-BLANK\n         BZ    RESTBEG              IF NOT FOUND THEN START AT BEGIN\n         CLI   0(R1),C'0'           MUST BE NUMERIC\n         BNL   RESTREC              YES, THEN TURN IT TO BINARY\nRESTBEG  WTO   'YOU HAVE REQUESTED A RESTART, AND YOUR NEXT STATEMENT W+\n               ILL CONSTITUTE THE BEGINNING OF THIS JOB.',ROUTCDE=2\n         L     R11,STRADDR1         POINT BACK TO BEGINNING\n         SLR   R10,R10              CLEAR COUNT TO ZERO\n         B     LOOPTHRU             START OVER\nRESTREC  CLI   1(R1),C'0'           HAVE THEY SUPPLIED TWO DIGITS\n         BL    ONENUM               NO, THEN DO JUST ONE\n         MVC   WTORECN+83(2),0(R1)  MOVE BOTH NUMBERS TO WTO AREA\n         PACK  POINTER+5(3),0(2,R1)  TURN IT INTO PACKED FIRST\n         B     CONVERT              GO CONVERT TO BINARY\nONENUM   PACK  POINTER+5(3),0(1,R1)  PACK JUST ONE BYTE\n         MVC   WTORECN+83(1),0(R1)  MOVE TO OUTPUT\n         MVI   WTORECN+84,C' '      CLEAR OUT IF ANY FROM BEFORE\nCONVERT  CVB   R9,POINTER           CONVERT TO BINRY FOR REGISTER USE\n         CR    R10,R9               COMP TO VERIFY REQUEST NOT GT R10\n         BL    WTORECN              ASKED FOR TOO HIGH, USE WHAT IN R10\n         LR     R10,R9              RELOAD VALUE\nWTORECN  WTO   'YOU HAVE REQUESTED A RESTART, AND YOUR NEXT STATEMENT W+\n               ILL BEGIN AT RECORD   .',ROUTCDE=2\n         L     R11,STRADDR1        POINT BACK TO BEGIN OF STORAGE\n         LTR   R10,R10             MAKE SURE NOT HAVE ZEROES IN IT\n         BZ    LOOPTHRU            YES, THEN START OVER AT BEGIN\n         BCTR  R10,0               DECR 1 FOR COUNTER\n         LR    R9,R10              RELOAD INTO R9\n         MH    R9,=H'80'           MULT BY RECSIZE TO INCR R11\n         LA    R11,0(R9,R11)       POINT TO STATEMENTS IN STORAGE\n         B     LOOPTHRU            LOOP BACK THRU\nCHKEND   TRT   JCLREC(80),NBLANK   LOOK FOR NULL STATEMENT\n         BZ    SUBMIT              YES, THEN SUBMIT JOB\n         MVC   0(80,R11),JCLREC    MOVE TO STORAGE AREA\n         LA    R10,1(R10)          INCR COUNTER\n         LA    R11,80(R11)         POINT TO NEXT RECORD FOR UPDATE\n         CLC   JCLREC(2),=C'//'    IS THIS A // JCL STATEMENT\n         BNE   LOOPTHRU            LOOP BACK THROUGH FOR NEXT CARD\n         TRT   JCLREC+2(78),NBLANK  LOOK FOR NON BLANK FOR EOJ\n         BNZ   LOOPTHRU             WE FOUND SOMETHING SO GET MORE\n**********************************************************************\n* WE WILL NOW OPEN THE INTERNAL READER AND SUBMIT THE JOB.           *\n**********************************************************************\nSUBMIT   OPEN  (READER,(OUTPUT))\n         TM    READER+48,X'10'      VERIFY OPEN BIT\n         BO    GOODOPEN             YES, THEN CONITNUE\n         WTO   'BAD NEWS. UNABLE TO OPEN READER DD STATEMENT'\n         ABEND  400,DUMP\nGOODOPEN L     R11,STRADDR1         POINT TO BEGINNING OF CARDS\nLOOPPUT  PUT   READER,(11)          WRITE THEM\n         LA    R11,80(R11)          INCREMENT TO NEXT RECORD\n         BCT   R10,LOOPPUT          LOOP TIL DONE\n         CLOSE READER               CLOSE\nFREEMSG  DOM   MSG=(3)              DELETE NON ROLLABLE MSGS\n         DOM   MSG=(4)              HERE ALSO\nFREESTR  L     R1,STRADDR1          LOAD UP R1 SO AS TO FREE STORAGE\n         FREEMAIN R,LV=40960,A=(1)\nRETURN   L     R13,4(R13)           RETURN LOGIC TO GO BYE-BYE\n         LM    R14,R12,12(R13)\n         SLR   R15,R15\n         BR    R14\nREADER   DCB  DDNAME=READER,MACRF=PM,DSORG=PS\nJCLREC   DC    CL80' '\nBLANKS   DC    CL80' '\nPOINTER  DC    D'0'\nECB1     DC    F'0'\nSTRADDR1 DC    F'0'\n         LTORG\n         DS    0F\nNBLANK   DC    256X'FF'\n         ORG   NBLANK+C' '\n         DC    X'00'\n         ORG\nBLANK    DC    256X'00'\n         ORG   BLANK+X'FF'\n         DC    X'00'\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPESTCK": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x01\\xa5\\x01\\xa5\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 421, "newlines": 421, "modlines": 0, "user": "WHS"}, "text": "********************************************************************    00003\n* AUTHOR - BILL SWEENEY                                            *\n*     SSC, INC.                                                    *\n*     WHSWEENEY@SSCMAINFRAME.COM                                   *\n*     WWW.SSCMAINFRAME.COM                                         *\n* DATE - (C) COPYRIGHT 2004                                        *\n*                                                                  *\n* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL         *\n*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR        *\n*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.          *\n*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS            *\n*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.             *\n*                                                                  *\n* LINKAGE INFORMATION - AMODE 24                                   *\n*                  RMODE 24                                        *\n*                  NON-REENTRANT                                   *\n*                  NOT APF AUTHORIZED                              *\n*                                                                  *\n*   FUNCTION - STACK AS MANY TAPE FILES AS WILL FIT ON ONE TAPE    *    00007\n*              FOR THE PURPOSE OF CONSOLIDATION AND SAVING ON TAPES*    00008\n*                                                                  *    00009\n*              PROGRAM EXPECTS THE INPUT FILES TO BEGIN AT DDNAME  *    00010\n*              TPEIN001 AND TO INCREASE BY ONE (E.G. 002, 003)     *    00011\n*              UNTIL A DDNAME IS NOT FOUND. THE OUTPUT FILE IS A   *    00012\n*              SINGLE DD STATEMENT THAT SHOULD SPECIFY THE PROPER  *    00013\n*              LABEL INFORMATION (E.G. LABEL=(1,SL,EXPDT=XXXXX)    *    00014\n*              WHICH WILL BE USED FOR ALL FILES. PROGRAM WILL USE  *    00015\n*              A MODIFIED JFCB TO SUPPLY THE RELATIVE OUTPUT       *    00016\n*              DATASET NAME AND THE CORRECT FILE SEQUENCE NUMBER.  *    00017\n*              PROGRAM USES A WAIT ON THE OUTPUT WRITE RATHER THAN *    00018\n*              A CHECK MACRO SO IT CAN DETERMINE WHEN THE END OF   *    00019\n*              VOLUME OCCURS. COPIED FILES WILL NEVER SPAN A VOLUME*    00020\n*              BUT WILL BE STARTED ON A NEW VOLUME BY CLOSING      *    00021\n*              EVERYTHING AND REQUESTING A SCRATCH.                *    00021\n*                                                                  *    00022\n*   FLAGS    - AT PRESENT THERE IS ONE FLAG BYTE THAT IS SET.      *    00023\n*      FLAG  - X'80' -   SET WHEN AN END OF VOLUME OCCURS          *    00026\n*      FLAG  - X'40' -   OUTPUT DATA SET NAMES SUPPLIED            *    00026\n*                                                                  *    00042\n*      REGISTERS -  R13 SAVEAREA AND FIRST BASE REG                *    00043\n*                   R11 ADDRESS GETMAINED STORAGE FOR I/O          *    00045\n*                   R10 USED FOR MAINTAINING BLOCK COUNTS          *    00045\n*                   R9  USED FOR OUTPUT FILE SEQUENCING            *    00045\n*                   R8  USED FOR DDNAME SEQUENCING                 *    00045\n*                   R2-R7 WORK REGISTERS                           *    00045\n********************************************************************    00046\nTAPESTCK CSECT\n         PRINT ON,GEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nFILE1IN  EQU    1\nFILE1OUT EQU    2\nEOV      EQU   X'80'\nRC12     EQU   12\nRC16     EQU   16\nECBNORM  EQU   X'7F'\nECBPERR  EQU   X'41'\n******************************************************************\n* NON-REENTRANT PROGRAM USING REG13 AS BOTH THE SAVEAREA POINTER *\n* AND THE ONLY BASE REGISTER.                                    *\n******************************************************************\n         B     72(R15)             BRANCH AROUND SAVE AREA\n         DS    17F                 SAVE AREA\n         STM   R14,R12,12(R13)     SAVE REGS\n         ST    R13,4(R15)          CHAIN SAVE AREAS\n         ST    R15,8(R13)          BACK CHAIN SAVE AREAS\n         LR    R13,R15             LOAD BASE\n         USING TAPESTCK,R13\n         LA   R9,1                     START OUT WITH 1,SL\n         L    R3,0(R1)                 GET THE PARM ADDRESS\n         LH   R5,0(R3)                 SEE IF ANYTHING THERE\n         LTR  R5,R5\n         BZ   GETSTOR                  NO, THEN DEFAULT TO FILE 1\n         LA   R4,7                     PACK INTO 8 BYTE FIELD\n         BCTR R5,0                     DECRMENT FOR EXECUTE\n         SLL  R5,28                    SHIFT INTO HI-ORDER\n         SLDL R4,4                     MOVE TOGETHER INTO LO-ORDER\n         EX   R4,PACKIT                PACK  DOUBLE(0),2(R3)\n         CVB  R9,DOUBLE                AND SET THE FILESEQ #\n         SPACE 1\n******************************************************\n* ACQUIRE ENOUGH STORAGE TO READ ONE BLOCK OF DATA   *\n* AND TO STORE OUTPUT DATA SETS IF SUPPLIED.         *\n******************************************************\nGETSTOR  EQU   *\n         GETMAIN EC,LV=472760,A=STRADDR1\n         LTR   R15,R15\n         BZ    CHKOUTDS\n         WTO   'UNABLE TO ACQUIRE STORAGE'\n         MVI   RETCODE+3,RC16\n         B     RETURN\n******************************************************\n* CHECK TO SEE IF OUTPUT DATA SET NAMES SUPPLIED     *\n******************************************************\nCHKOUTDS EQU   *\n         OPEN  (OUTDSNS,,SYSPRINT,(OUTPUT))\n         TM    SYSPRINT+48,X'10'\n         BO    OPENOK1\n         WTO   'UNABLE TO OPEN SYSPRINT DDNAME'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK1  TM    OUTDSNS+48,X'10'\n         BZ    GETDATE                   IF OPEN FAILED THEN CONT.\n         SLR   R6,R6                     CLEAR TO MAINTAIN COUNT\n         L     R7,STRADDR1               GET STORAGE POINTER\n         AH    R7,HW32760                INCREMENT PAST BLOCK READ\nGETOUTDS GET   OUTDSNS\n         MVC   0(44,R7),0(R1)            MOVE IN DSNAME\n         LA    R6,1(R6)                  INCR COUNT\n         LA    R7,44(R7)                 INCR STORAGE LOCATION\n         B     GETOUTDS\nEODOUTD  EQU   *\n         CLOSE OUTDSNS\n         LTR   R6,R6\n         BZ    GETDATE\n         OI    FLAG,X'40'                   SET FLAG FOR NAMES\n         L     R7,STRADDR1               GET STORAGE POINTER\n         AH    R7,HW32760                INCREMENT PAST BLOCK READ\n*        B     OPENOKS                      AND GO AROUND CODE\n******************************************************\n* GET TODAYS JULIAN DATE FOR CA1 UPDATE CNTL CARDS.  *\n******************************************************\nGETDATE  EQU   *\n         TIME  DEC\n         ST    R1,DOUBLE+4\n         ED    YEAR(3),DOUBLE+5\n         ED    DAY(4),DOUBLE+6\n         MVC   TMCEXPYR(2),YEAR+1\n         MVC   TMCEXPDY(3),DAY+1\n******************************************************************\n* OPEN FILES REDEFINE (FOR BUILDING IDCAMS DELETE/DEFINE),       *\n* UPDEXPDT (FOR BUILDING TMC UPDATE CONTROL CARDS) AND SYSPRINT  *\n* (FOR INFORMATIONAL OUTPUT).                                    *\n******************************************************************\nOPENIDCM EQU   *\n         OPEN  (REDEFINE,(OUTPUT),UPDEXPDT,(OUTPUT))\n         TM    REDEFINE+48,X'10'         CHECK FOR GOOD OPEN\n         BO    OPENOK2                   YES, THEN CONTINUE\n         WTO   'UNABLE TO OPEN REDEFINE DDNAME'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\nOPENOK2  TM    UPDEXPDT+48,X'10'\n         BO    OPENOKS\n         WTO   'UNABLE TO OPEN UPDEXPDT DDNAME'\n         MVI   RETCODE+3,RC16\n         B     FREE_STORAGE\n******************************************************************\n* R11 ADDRESSES STORAGE FOR I/O. R9 AND R8 ARE SET TO FILE 1     *\n* AND DDNAME TPEIN001 (1). DCB AND JFCB ARE RESET FOR SECOND AND *\n* SUBSEQUENT FILES SO THAT THEY CAN BE REUSED.                   *\n******************************************************************\nOPENOKS  L     R11,STRADDR1        LOAD R11 WITH GETMAINED STORGE ADDR\n         LA   R8,1                     AND DDNAME=TPEIN001\n         B    OPENTAPE                 FIRST TIME THRU LEAVE ALONE\nLOOPFIND EQU  *\nNEXTFILE MVI  TAPEIN+48,X'02'          RESET OPEN FLAG\n         XC   TAPEIN+62(2),TAPEIN+62        RESET BLKSIZE\n         XC   TAPEIN+82(2),TAPEIN+82        RESET LRECL\n         MVI  TAPEIN+36,X'00'               RESET RECFM\n         CVD  R8,DOUBLE                PACK THE CURRENT FILESEQ #\n         MVC  NEXTDDN+1(3),NEXTDDN_MASK\n         UNPK NEXTDDN(4),DOUBLE+6(2)\n         OI   NEXTDDN+3,X'F0'\n         MVC  TAPEIN+45(3),NEXTDDN+1\nOPENTAPE OPEN TAPEIN\nOPENED   TM   TAPEIN+48,X'10'          GOOD OPEN ?\n         BZ   FINISH_UP                NO, THEN WE ARE FINISHED\n* GET THE CURRENT DSNAME, MOVE IT IN TO RELATIVE FIELDS\n         RDJFCB (TAPEIN)\n         MVC  DSNAME(44),JFCBAREA\n         MVC  DEFDSN(44),JFCBAREA\n         MVC  OUTRDSN(44),JFCBAREA\n         MVC  OUTR_TAPEIN(6),JFCBAREA+118  MOVE IN THE VSN\n         MVC  OUTFILE+62(2),TAPEIN+62             SET THE BLOCKSIZE\n         MVC  OUTFILE+82(2),TAPEIN+82             AND THE LRECL\n         MVC  OUTFILE+36(1),TAPEIN+36             AND THE RECFM\n         CVD  R9,DOUBLE                PACK THE CURRENT FILESEQ #\n         MVC  FILESEQ(4),FILESEQ_MASK\n         ED   FILESEQ(4),DOUBLE+6\n         MVC  OUTR_FILESEQ(3),FILESEQ+1\nNEXTOUT  MVI  OUTFILE+48,X'02'        RESET OPEN FLAG\n         RDJFCB MF=(E,OPENLST2)\n         LTR  R15,R15\n         BZ   GOODRDJ2\n         ABEND 004,DUMP\nGOODRDJ2 STH  R9,JFCBARE2+68           STORE THE CURRENT FILE SEQ#\n         TM   FLAG,EOV                 WAS THERE AN END OF VOLUME\n         BZ   NOT_PRIVAT\n         MVC  JFCBARE2+118(6),PRIVAT   ACTUALLY BLANKS\n         NI   FLAG,255-EOV\nNOT_PRIVAT    EQU    *\n         XC   JFCBARE2+102(2),JFCBARE2+102\n         XC   JFCBARE2+104(2),JFCBARE2+104\n         MVI  JFCBARE2+100,X'00'\n         TM   FLAG,X'40'                 DID THEY SUPPLY OUTDSN\n         BZ   MOVEFROM_JFCB\n         LTR  R6,R6                      ARE THERE ANY MORE NAMES\n         BZ   MOVEFROM_JFCB              IF EXHAUSTED USE FROM INPUT\n         MVC  JFCBARE2(44),0(R7)         MOVE IN INPUT DSNAME\n         MVC  DEFDSN(44),0(R7)           AND HERE FOR CATALOG\n         LA   R7,44(R7)\n         BCTR R6,0                       DECREMENT BY ONE\n         LTR  R6,R6                      ARE THERE ANY MORE NAMES\n         BNZ  SETJFCB_FLAG\n         NI   FLAG,255-64                RESET FLAG\n         B    SETJFCB_FLAG\nMOVEFROM_JFCB EQU  *\n         MVC  JFCBARE2(44),JFCBAREA      MOVE IN INPUT DSNAME\nSETJFCB_FLAG  EQU  *\n         OI   JFCBARE2+76,X'80'        FLAG FOR RE-WRITE OF JFCB\n* THE TYPE=J AND MODE=31 KEYWORDS ARE MUTUALLY EXCLUSIVE SO THIS\n* PROGRAM CANNOT BE CHANGED TO 31BIT\n         OPEN TYPE=J,MF=(E,OPENLST2)\nCHKOUT   TM   OUTFILE+48,X'10'        GOOD OPEN ?\n         BO   GETOVSN\n         ABEND 003,DUMP\nGETOVSN  EQU  *\n         RDJFCB (OUTFILE)                GET THE CURRENT INFORMATION\n         MVC  DEFVSN(6),JFCBARE2+118     MOVE IN THE VOLUME SERIAL #\n         MVC  OUTR_TAPEOUT(6),JFCBARE2+118  MOVE IN THE VSN\n         SLR  R10,R10                    CLEAR R10 FOR BLOCK COUNT\nREADNXT  EQU  *\n         LA   R12,TAPEDECB\n*  LOOK TO PROCESS 64K BLOCKS OF DATA\n         TM   TAPEIN+36,X'C0'          IS IT RECFM U\n         BNO  PROCESS_LT32K            NO, THEN PROCESS SUPPLIED\n         L    R4,FW65535               LOAD UP LENGTH OF 64K\n         READ (12),SF,,(11),(4),MF=E\n         CHECK TAPEDECB\n         LH   R3,OUTFILE+62         GET BLKSIZE TO SAVE\n         L    R5,TAPEDECB+16            IOB ADDR\n         SLR  R2,R2\n         ICM  R2,3,14(R5)              GET THE VALUE FROM IOBCSW\n         SR   R4,R2\n         LA   R12,OUTDECB\n         WRITE (12),SF,,(11),(4),MF=E\n         WAIT  ECB=OUTDECB\n         B    CHECK_ECB\nPROCESS_LT32K EQU  *\n         READ (12),SF,,(11),MF=E\n         CHECK TAPEDECB\n         LH   R4,TAPEIN+62              GET BLKSIZE\n         L    R5,TAPEDECB+16            IOB ADDR\n         SH   R4,14(R5)\n         LH   R3,OUTFILE+62         GET BLKSIZE IN CASE OF SHORT BLK\n         STH  R4,OUTFILE+62          BLKSIZE OF BLK JUST READ\n         LA   R12,OUTDECB\n         WRITE (12),SF,,(11),MF=E\n         WAIT  ECB=OUTDECB\nCHECK_ECB      EQU  *\n         CLI   OUTDECB,ECBNORM       NORMAL COMPLETION CODE\n         BE    GOODWRIT              YES, THEN CONTINUE\n         CLI   OUTDECB,ECBPERR       SEE IF PERMANENT ERROR\n         BNE   IOERROR               NO, THEN JUST BLOW UP\n         L     R2,OUTDECB+16         GET THE IOB ADDR\n         USING IOBSTDRD,R2\n         TM    IOBUSTAT,IOBUSB7      CHECK IT\n         BO    VOLUME_DONE           YES, THEN GO CLEAN UP\n         DROP  R2\nIOERROR  WTO   'I/O ERROR OCCURRED WHILE WRITING BLOCK'\n         DC    H'00'\nGOODWRIT LA    R10,1(R10)            INCREMENT BLOCK COUNT\n         STH   R3,OUTFILE+62         PUT BACK THE OLD BLKSIZE\n         B    READNXT\nEOFILE   CLOSE TAPEIN\n         CLOSE (OUTFILE,LEAVE)\n         TM    FLAG,X'40'            DID THEY SUPPLY DATA SET NAMES\n         BO    WRITE_NO_DELETE       YES, THEN GO CATALOG\n* WANT TO SEE HERE IF THE TAPE DATASET IS EVEN CATALOGED\nDO_LOCATE EQU  *\n         LOCATE BIGCAM\n         LTR  R15,R15\n         BNZ  EXPIREIT             NOT CATALOGED, THEN GO AROUND\nCHCKVOLS CLC  OUTR_TAPEIN(6),WORKAREA+6        CATALOGED TO SAME VOL\n         BE   WRITEIT                          YES, THEN USE IDCAMS\n         MVC  NOTCAT_DSN(44),DSNAME            NO, THEN BUILD MSG\n         MVC  NOTCAT_VSN(6),OUTR_TAPEIN\n         MVC  CAT_VSN(6),WORKAREA+6            AND TELL USER\n         PUT  SYSPRINT,NOTCATLG\n         B    EXPIREIT\nWRITEIT  EQU  *\n         PUT  REDEFINE,IDCAMS_DELETE\nWRITE_NO_DELETE  EQU  *\n         PUT  REDEFINE,IDCAMS_DEFINE1\n         PUT  REDEFINE,IDCAMS_DEFINE2\n         TM    FLAG,X'40'            DID THEY SUPPLY DATA SET NAMES\n         BO   INCRREG9                     YES, THEN DO NOT EXPIRE\nEXPIREIT CLC  TMCVSN(6),OUTR_TAPEIN        SEE IF WE HAVE ALREADY DONE\n         BE   INCRREG9                     YES, THEN DO NOT REDO\n         MVC  TMCVSN(6),OUTR_TAPEIN        MOVE IN VOLSER TO EXPIRE\n         PUT  UPDEXPDT,TMC_UPDATE1\n         PUT  UPDEXPDT,TMC_UPDATE2\nINCRREG9 LA   R9,1(R9)\n         LA   R8,1(R8)\n         MVC  OUTR_BLKCNT(8),BLKCNT_MASK\n         CVD  R10,DOUBLE\n         ED   OUTR_BLKCNT(8),DOUBLE+4\n         PUT  SYSPRINT,OUTRECD\n         B    LOOPFIND\nVOLUME_DONE   EQU    *\n         BCTR R10,0                         DECREMENT THE BLOCK COUNT\n         STCM R10,3,BKSPC+6\nBKSPC    CNTRL OUTFILE,BSR,0\n         CLOSE (TAPEIN,,OUTFILE)\n         PUT  SYSPRINT,EOVRECD\n         LA   R9,1                          RESET THE FILESEQ TO 1\n         OI   FLAG,EOV\n         B    LOOPFIND\nFINISH_UP     EQU    *\n         CLOSE (REDEFINE,,UPDEXPDT,,SYSPRINT)\nFREE_STORAGE  EQU  *\n         FREEMAIN EC,LV=472760,A=STRADDR1\nRETURN   L     R15,RETCODE\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n************************************************************\n* NEXT IS THE BLOCK COUNT EXIT THAT SAYS IGNORE IF BAD     *\n************************************************************\nIGNBLK   LA    R15,4          IGNORE ERROR BLOCK COUNT\n         BR    R14\n        EJECT\nTAPEIN   DCB   DDNAME=TPEIN001,DSORG=PS,MACRF=R,                       X\n               EODAD=EOFILE,EXLST=JFCBLIST\nOUTFILE  DCB   DDNAME=OUTFILE,DSORG=PS,MACRF=WC,                       X\n               RECFM=FB,EXLST=EXITLIST\nOUTDSNS  DCB   DDNAME=OUTDSNS,DSORG=PS,MACRF=GL,EODAD=EODOUTD\nREDEFINE DCB   DDNAME=REDEFINE,DSORG=PS,MACRF=PM,LRECL=80\nUPDEXPDT DCB   DDNAME=UPDEXPDT,DSORG=PS,MACRF=PM,LRECL=80\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133\nOPENLST2 OPEN  (OUTFILE,(OUTPUT,LEAVE)),MF=L\n         READ  TAPEDECB,SF,TAPEIN,MF=L\n         WRITE OUTDECB,SF,OUTFILE,MF=L\nRETCODE  DC    F'0'\nJFCBLIST DS    0F\n         DC    X'87'\n         DC    AL3(JFCBAREA)\nEXITLIST DS    0F\n         DC    X'07'\n         DC    AL3(JFCBARE2)\n         DC    X'8B'\n         DC    AL3(IGNBLK)\nDOUBLE   DC    D'00'\nPACKIT   PACK  DOUBLE(0),2(0,R3)\nYEAR     DC    X'F02120'\nDAY      DC    X'F0212020'\nJFCBAREA DS    0F,176C\nJFCBARE2 DS    0F,176C\nSTRADDR1 DC    F'0'\nFW65535  DC    F'65535'\nBIGCAM   CAMLST NAME,DSNAME,,WORKAREA\nPRIVAT   DC    CL6' '         MAKE IT BLANKS\nHW32760  DC    H'32760'\nFLAG     DC    X'00'\nNEXTDDN_MASK   DC   X'212020'\nFILESEQ_MASK   DC   X'40202120'\nBLKCNT_MASK    DC   X'4020202020202120'\nNEXTDDN        DC   CL4'0000'\nIDCAMS_DELETE  DS   0CL80\n         DC    CL8' DELETE '\nDSNAME   DC    CL44' '\n         DC    CL28' NSCR'\nIDCAMS_DEFINE1 DS   0CL80\n         DC    CL19' DEFINE NVSAM(NAME('\nDEFDSN   DC    CL44' '\n         DC    CL17') -'\nIDCAMS_DEFINE2 DS   0CL80\n         DC    CL8' VOLUME('\nDEFVSN   DC    CL6' '\n         DC    CL22')  DEVT(3590-1) FSEQN('\nFILESEQ  DC    CL4' '\n         DC    CL40')) '\nTMC_UPDATE1    DS   0CL80\n         DC    CL4'VOL '\nTMCVSN   DC    CL6' '\n         DC    CL70',NODSN '\nTMC_UPDATE2    DS   0CL80\n         DC    CL4'REP '\n         DC    CL8'EXPDT=20'\nTMCEXPYR DC    CL2' '\n         DC    C'/'\nTMCEXPDY DC    CL65' '\nOUTRECD  DS    0CL133\n               DC    CL8'0 DSN - '\nOUTRDSN        DC    CL45' '\n               DC    CL9'TAPEIN - '\nOUTR_TAPEIN    DC    CL7' '\n               DC    CL10'TAPEOUT - '\nOUTR_TAPEOUT   DC    CL7' '\n               DC    CL12'FILESEQ # - '\nOUTR_FILESEQ   DC    CL4' '\n               DC    CL13'BLOCK COUNT -'\nOUTR_BLKCNT    DC    CL18' '\nEOVRECD        DC    CL133'0 END OF VOLUME CAUSED DURING THE FOLLOWING +\n               DATASET. NEW VOLUME WAS MOUNTED.'\nNOTCATLG       DS    0CL133\n               DC    CL8'0 DSN - '\nNOTCAT_DSN     DC    CL45' '\n               DC    CL24'NOT CATALOGED ON VOLUME-'\nNOTCAT_VSN     DC    CL6' '\n               DC    CL22'; CATALOGED ON VOLUME-'\nCAT_VSN        DC    CL28' '\n         LTORG\nWORKAREA DC    265X'00'\n         IEZIOB DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VARYOFF": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00S\\x00S\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 83, "newlines": 83, "modlines": 0, "user": "WHS"}, "text": " /* REXX EXEC  */\n /*  TRACE RESULTS */\n \"EXECIO * DISKR VOLLIST (STEM REC. FINIS)\"\n\n\n SFX = 0\n CMD_COUNT = 0\n   SCAN_OK = ALXRDASD('DASDUCB',2500,'DASD')\n IF SCAN_OK = 'OK' THEN\n  DO\n  /* THIS MUST BE A PRE-DEFINED DATA SET, WHICH IS USEFUL  */\n  /* FOR DETERMINING WHAT DASD WAS ONLINE AT IPL           */\n   \"ALLOC F(DASDONLN) DA('SYSP.DASD.ONLINE.LASTIPL') SHR\"\n   IF RC = 0 THEN\n    DO\n     OUTRECD.1 = '      ' DATE('U') ' ' TIME()\n     \"EXECIO 1 DISKW DASDONLN(STEM OUTRECD.\"\n     \"EXECIO\" DASDUCB.0 \"DISKW DASDONLN(STEM DASDUCB. FINIS\"\n     \"FREE F(DASDONLN)\"\n    END\n   DO I = 1 TO DASDUCB.0\n    IF WORD(DASDUCB.I,1) = 'ON' THEN\n     CALL PROCESS_VOLUME\n   END\n  END\n  IF SFX > 0 THEN\n   \"EXECIO\" SFX \"DISKW OUTFILE (STEM OUTREC. FINIS\"\n \"FREE F(OUTFILE)\"\n EXIT\nPROCESS_VOLUME:\n VOLUME = WORD(DASDUCB.I,3)\n UNIT = WORD(DASDUCB.I,2)\n\n F = 'N'\n DO A = 1 TO REC.0\n  SELECT\n   WHEN SUBSTR(REC.A,1,1) = '*' THEN NOP\n\n   WHEN WORD(REC.A,1) = 'KEEP' THEN\n    DO\n     SELECT\n      WHEN WORD(REC.A,1) = 'KEEP' & WORD(REC.A,2) = VOLUME THEN\n       RETURN\n      WHEN  WORDS(REC.A) > 2 THEN\n       DO\n        IF WORDS(REC.A) > 3 THEN\n         CHECK = 'IF ' WORD(REC.A,2) '=' WORD(REC.A,3) '&',\n                WORD(REC.A,4) '=' WORD(REC.A,5) 'THEN F = Y'\n        ELSE\n         CHECK = 'IF ' WORD(REC.A,2) '=' WORD(REC.A,3) 'THEN F = Y'\n        INTERPRET CHECK\n        IF F = 'Y' THEN\n         RETURN\n       END\n       OTHERWISE NOP\n     END\n    END\n   OTHERWISE\n    DO\n  IF WORDS(REC.A) > 2 THEN\n    CHECK = 'IF ' WORD(REC.A,1) '=' WORD(REC.A,2) '&',\n                  WORD(REC.A,3) '=' WORD(REC.A,4) 'THEN F = Y'\n  ELSE\n    CHECK = 'IF ' WORD(REC.A,1) '=' WORD(REC.A,2) 'THEN F = Y'\n  INTERPRET CHECK\n  IF F = 'Y' THEN\n    A = REC.0\n  END\n END\nEND\n IF F = 'Y' THEN\n  DO\n   SFX = SFX + 1\n   CMD_COUNT = CMD_COUNT + 1\n   OUTREC.SFX = ' V' UNIT',OFFLINE '  VOLUME\n   IF CMD_COUNT > 24 THEN\n    DO\n     SFX = SFX + 1\n     CMD_COUNT = 0\n     OUTREC.SFX = '#WAIT=5'\n    END\n  END\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VARYOFFJ": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 14, "newlines": 14, "modlines": 0, "user": "WHS"}, "text": "//VARYOFF   PROC M=VARYOFF\n//*\n//* THIS PROC WILL VARY OFFLINE PRODUCTION DASD\n//STEP1     EXEC PGM=IKJEFT01,DYNAMNBR=25,PARM='VARYOFF'\n//SYSPRINT  DD   SYSOUT=*\n//SYSTSPRT  DD   SYSOUT=*\n//SYSEXEC   DD   DSN=SYSX.ISPF.EXEC,DISP=SHR\n//SYSTSIN   DD   DUMMY\n//VOLLIST   DD   DSN=SYSX.PARMLIB(&M),DISP=SHR\n//OUTFILE   DD   DSN=&&TEMP,DISP=(,PASS),\n//          SPACE=(TRK,(1,1)),DCB=(LRECL=80,BLKSIZE=8000,RECFM=FB)\n//STEP2     EXEC  PGM=ALEXCMDS,COND=(0,NE)\n//SYSABEND  DD    SYSOUT=X\n//CMDIN     DD    DSN=&&TEMP,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VARYOFFP": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01U&\\x8f\\x010&\\x8f#Y\\x00\\x17\\x00\\x17\\x00\\x00\\xe6\\xc8\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2055-09-25T00:00:00", "modifydate": "2030-09-25T23:59:59", "lines": 23, "newlines": 23, "modlines": 0, "user": "WHS"}, "text": "* THIS MEMBER SUPPLIES THE COMPARE VALUES FOR VARYING OFF\n* DASD. AN ASTERISK IN COLUMN IS IGNORED BY THE\n* VARYOFF EXEC. IF THE FIRST FIELD/WORD IS  KEEP  THEN THIS VOLUME\n* WOULD FIT A CRITERIA FOR VARYING OFF, AND WE WANT IT BYPASSED\n* THE FIRST WORD/FIELD IS WHAT TO COMPARE, AND THE SECOND IS THE\n* REXX FUNCTION. THE SUBSTRING FIELD VOLUME MUST REMAIN THAT VALUE\n* BECAUSE IT IS USED BY THE VARYOFF EXEC. TWO SETS OF COMPARES CAN\n* SPECIFIED\nKEEP SYSTWK\nKEEP SYSTP1\nKEEP SYSTP2\nKEEP SYSTS1\nKEEP ACS  SUBSTR(VOLUME,1,3) T SUBSTR(VOLUME,6,1)\nKEEP TEMPT SUBSTR(VOLUME,1,5)\nKEEP OST SUBSTR(VOLUME,1,3)\nKEEP ZOST SUBSTR(VOLUME,1,4)\nNEW  SUBSTR(VOLUME,1,3)\nZOS  SUBSTR(VOLUME,1,2)\nMVS  SUBSTR(VOLUME,1,3)\nACS  SUBSTR(VOLUME,1,3)\nA31  SUBSTR(VOLUME,1,3)\nA41  SUBSTR(VOLUME,1,3)\nTEMP SUBSTR(VOLUME,1,4)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT720/FILE720.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT720", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}