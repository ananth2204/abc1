********************************************************************
* AUTHOR - BILL SWEENEY                                            *
*     SSC, INC.                                                    *
*     WHSWEENEY@SSCMAINFRAME.COM                                   *
*     WWW.SSCMAINFRAME.COM                                         *
* DATE - (C) COPYRIGHT 2004                                        *
*                                                                  *
* DISCLAIMER - IT IS THE RESPONSIBILITY OF THE INIDIVIDUAL         *
*         TO VALIDATE THAT THIS SOFTWARE WILL NOT HARM YOUR        *
*         SYSTEM. INSTALL THIS SOFTWARE AT YOUR OWN RISK.          *
*         SSC, INC. IS NOT RESPONSIBLE FOR ANY PROBLEMS            *
*         CAUSED WHILE USING THIS SOFTWARE. GOOD LUCK.             *
*                                                                  *
* LINKAGE INFORMATION - AMODE 31                                   *
*                  RMODE 24                                        *
*                  NON-REENTRANT                                   *
*                  NOT APF AUTHORIZED                              *
*                                                                  *
* DESCRIPTION -                                                    *
*                                                                  *
*    WRITTEN AND MODIFIED BETWEEN THE PERIODS OF AUGUST 1984 THRU  *
*  DECEMBER 31 1984 BY BILL SWEENEY. THE EDITING GETS A BIT HAIRY  *
*  WHEN TRYING TO MAINTAIN COLUMN 72 FROM BEING OVERWRITTEN AND    *
*  CAUSING PROBLEMS. GOOD LUCK.                                    *
********************************************************************
*   THIS IS NOW 3 MAR 86 AND WE ARE GOING BACK INTO THIS PROGRAM;  *
*  PRIOR TO THIS    WE HAD COME TO THE END OF THE TWO BASE REGISTER*
*  LIMIT, AND A THIRD WAS OUT OF THE QUESTION. IT HAS SAT DORMANT  *
*  TILL THEN, BUT NOW, WE HAVE REALIZED OUR IGNORANCE AND WILL USE *
*  SOME LOCAL ADDRESSABILITY IN DIFFERENT SECTIONS OF CODE.        *
*    ANOTHER ENHANCEMENT WAS THE REALIZATION THAT BLDL PROCESSING  *
*  AND CERTAIN GETMAINS WERE INEFFICIENT AND PERHAPS EVEN UNNECESS-*
*  ARY. SO, SOME GETMAINS WERE COMBINED, AND BLDL PROCESSING WILL  *
*  BE DONE WHILE READING IN THE DIRECTORY ( MEMBER,TTR,ALIAS BIT IS*
*  ALL WE REALLY NEEDED).                                          *
*    PROGRAM WILL ALSO HANDLE SEQUENTIAL FILES IF THE DDNAME IS    *
*  PREFIXED WITH 'SEQ'. THIS WAS NOTHING REALLY FANCY, JUST FLAG   *
*  SETTING. TALKING ABOUT FLAGS, THIS PROGRAM USES THE SETTING AND *
*  RESETTING OF FLAGS EXTENSIVELY, SO BE ADVISED OF ALL THIS CRAZY *
*  BIT MANIPULATION.                                               *
********************************************************************
*  ADDED LINE COUNT PARAMETER 12 NOV 86                            *
********************************************************************
SSCUCPDS CSECT
         PRINT ON,GEN
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
****************************************************************
*  SAVE LOGIC TO CONSERVE ON REGISTERS. R13 IS USED AS BOTH    *
*  THE BASE REGISTER AND THE POINTER TO THE 18 WORD SAVE AREA. *
****************************************************************
         B     72(R15)
         DS    17F
         STM   R14,R12,12(R13)
         ST    R13,4(R15)
         ST    R15,8(R13)
         LR    R13,R15
         LA    R12,2048(R13)
         LA    R12,2048(R12)
         USING SSCUCPDS,R13,R12
         L     R2,0(R1)            GET PARM ADDR
         ST    R2,PARMADDR
         OPEN  (ERRPRIN1,(OUTPUT))
         TM    ERRPRIN1+48,X'10'
         BZ    BADRETN
**************************************************************
*  IN THIS SECTION WE WILL BE CONCERNED WITH PROCESSING THE  *
* PARM INFORMATION. THE ONLY PARMS AT PRESENT ARE 'CHGE' AND *
* 'MEMB'. WITH CHGE PARM PROGRAM WILL PROCESS ENTIRE PDS     *
* WITH USER SPECIFICATIONS, AND THEN MAKE THE CHANGES. IF    *
* PARM IS NOT SPECIFIED NO CHANGE WILL TAKE PLACE. THE MEMB  *
* PARM IS USED TO SELECTIVELY PROCESS MEMBERS OF A SINGLE    *
* SPECIFIED PDS.                                             *
**************************************************************
*  3 MAR 86, ONE NEW PARM  IS  BEING ADDED TO THE PROGRAM,   *
*  SCAN;                                                     *
*  I THOUGHT TO USE BECAUSE I FOUND MYSELF USING THIS PROGRAM*
*  TO SEARCH THROUGH PDS'S FOR A PARTICULAR ARGUMENT FOR DIS-*
*  PLAY PURPOSES, NOT FOR EDITING IT. THIS PARM WILL CUT THE *
*  OUTPUT IN HALF BECAUSE THERE WILL BE NO CHANGE LINE.      *
*   ALSO, REWROTE THE APPROACH TO PARM PROCESSING; IT WILL   *
*  GET THE JOB DONE, JUST DIFFERENTLY .                      *
**************************************************************
PROCPRM  LH    R3,0(R2)            GET LENGTH OF PARM FIELD
         LTR   R3,R3               SEE IF ANYTHING THERE
         BZ    DODDNS              ZER0, THEN NO PARM
         LA    R2,2(R2)            ADDR. BEGIN. OF PARM FIELD
LOOPTHRU TM    FLAG1,X'01'         THIS IS HERE FOR LOOP PROCESSING
         BZ    SEEIFM               IF SET, THEN GO ON
         CLI   0(R2),C'C'
         BNE   SEEIFM
         CLC   0(4,R2),=C'CHGE'
         BNE   BADPARM            IF NOT CHANGE THEN BAD PARM
         TM    FLAG2,X'01'        SEE IF SCAN  PARM WAS SPECIFIED
         BO    MUTEXCL
CHGEOK   NI    FLAG1,X'FE'         RESET FLAG FOR  CHANGE
         MVC   CHGELNE+5(12),BLANKS  MOVE IN BLANKS OVER NO CHANGE
         LA    R2,5(R2)
         SH    R3,HW5
         LTR   R3,R3
         BM    DODDNS             IF NOT DONE ALLOW TO FALL THRU
SEEIFM   TM    FLAG1,X'20'         IF PARM HAS BEEN SET THEN CHECK
         BO    SEEIFL               NEXT IN LINE
         CLI   0(R2),C'M'
         BNE   SEEIFL
         CLC   0(4,R2),=C'MEMB'
         BNE   BADPARM
         OI    FLAG1,X'20'        YES, THEN SET FLAG FOR SELECTIVE
         LA    R2,5(R2)
         SH    R3,HW5
         LTR   R3,R3
         BM    DODDNS
         B     LOOPTHRU
SEEIFL   TM    FLAG2,X'80'         IF PARM HAS BEEN SET THEN CHECK
         BO    SEEIFD
         CLI   0(R2),C'L'
         BNE   SEEIFD
         CLC   0(8,R2),=C'LINECNT='
         BNE   BADPARM
         OI    FLAG2,X'80'
         SH    R3,HW8
         LA    R2,8(R2)
         CLI   1(R2),C'0'
         BNL   TWODIGIT
         PACK  DOUBLE(8),0(1,R2)
         SH    R3,HW2
         LA    R2,2(R2)
         B     STORLNE
TWODIGIT CLI   0(R2),C'0'
         BL    BADLINE
         PACK  DOUBLE(8),0(2,R2)
         LA    R2,3(R2)
         SH    R3,HW3
STORLNE  CVB   R15,DOUBLE
         CH    R15,HW8
         BNH   BADLINE
         STH   R15,MLINECNT
         LTR   R3,R3
         BM    DODDNS
         B     LOOPTHRU
SEEIFD   TM    FLAG2,X'01'         IF PARM HAS BEEN SET THEN WE HAVE
         BO    BADPARM              A BAD PARAMETER SOMEWHERE; QUIT
         CLI   0(R2),C'S'
         BNE   BADPARM
         CLC   0(4,R2),=C'SCAN'
         BNE   BADPARM
         TM    FLAG1,X'01'        SEE IF CHGE PARM WAS SPECIFIED
         BZ    MUTEXCL
         OI    FLAG2,X'01'        YES, THEN SET FLAG FOR SELECTIVE
         MVC   CHGELNE+5(12),BLANKS  MOVE IN BLANKS OVER NO CHANGE
         MVC   CHNGEHD2+5(7),=C'DISPLAY'  AND DISPLAY IN HEADINGS
         MVC   HEADER2+19(7),=C'DISPLAY'
         MVC   PRNTLNE+105(21),BLANKS     IN BLANKS OVER MODIFIED
         LA    R2,5(R2)
         SH    R3,HW5
         LTR   R3,R3
         BP    LOOPTHRU
**************************************************************
*  IN THIS SECTION WE WILL READ THE DDNAMES FROM THE TIOT    *
* AND BUILD A LIST OF ALL DDNAMES THAT BEGIN WITH PDS AND OR *
* SEQ, AND THEN SORT THEM IN ASCENDING ORDER.                *
**************************************************************
DODDNS   L     R15,APRODDNS       GET ADDRESS FOR PROCESSING DDNS
         BALR  R14,R15
***********************************************************************
* WE HAVE MOVED THE INPUT SECTION FOR THE ADVANATAGES OF ADDRESSABLITY*
* AND THUS SOLVED OUR 2 BASE REGISTER LIMITATION. BIG HAND PLEASE.    *
***********************************************************************
NOPARM   OPEN  (SYSPRIN1,(OUTPUT))
         TM    SYSPRIN1+48,X'10'
         BZ    FREEDDN1
         L     R1,4(R13)     LOAD UP CALLING ROUTINES SAVE AREA
         CLC   72(8,R1),=C'SYSLKPDS'     SEE IF THIS PGM CALLED US
         BNE   DOPRNTHD
         L     R1,32(R1)     LOAD UP VALUE OF CALLERS R3
         LTR   R1,R1
         BNZ   DOVERSYS      IF VALUE NOT 0 THEN DO NOT PRINT HDR
DOPRNTHD L     R15,APRNTHDR  ADDRESS OF THE HEADER PAGE OF INFORMATION
         BALR  R14,R15         GO AND PRINT THE HEADER PAGE
DOVERSYS L     R15,AVERSYSN    ADDRESS OF THE SYSIN RECORD PROCESSOR
         BALR  R14,R15         GO AND READ THE RECORD AND PARSE IT
         EJECT
******************************************************************
*   IN THIS NEXT SECTION WE WILL SEE DO SELECTIVE PROCESSING     *
*  BASED ON THE MEMB PARAMETER. SYSMEM DDNAME WILL BE OPENED AND *
*  EITHER SELECT OR EXCLUDE PROCESSING WILL BE DETERMINED. THIS  *
*  WILL SUPPORT A 100 MEMBER NAME LIST FOR SELECTIVE PROCESSING. *
******************************************************************
GETSTOR2 TM    FLAG1,X'20'        WAS THE MEMB PARAMETER SPECIFIED
         BZ    GETDSN             NO, THEN PROCESS THE DIRECTORY
         OPEN  SYSMEM
         TM    SYSMEM+48,X'10'     VALID OPEN OF SYSMEM
         BZ    CLOSEPR1           JUST QUIT IF NO INPUT
OPENOKMM EQU   *                  STORAGE FOR SELECT PROCESS. AND BLDL
         GETMAIN R,LV=4008         GET ENOUGH STORAGE FOR 500 MBRS
         ST    R1,STRADDR2         SAVE IT
         LR    R10,R1             R10 ADDR. THE GETMAIN AREA
         LR    R8,R1             R8 ADDR. GETMAIN AREA FOR MAKING IT
         LA    R9,4008              BLANKS
         LA    R6,BLANKS          THIS PUTS NOTHING OF VALUE IN R6
         SLR   R7,R7              A 0 LENGTH IN R7 AND
         ICM   R7,8,BLANKS        A BLANK IN THE HI-ORDER BYTE
         MVCL  R8,R6              CAUSE ALL STORAGE TO BE BLANKED OUT
         GET   SYSMEM
         LR    R2,R1              ADDR. R2 WITH LOCATION
GOTMMRD  LA    R7,70(R2)          POINT TO END OF RECORD FOR COMPARE
         LA    R3,8               DATA MUST BEGIN BY COL. 8
LOOPSMM  CLI   0(R2),C' '         CHECK FOR NON - BLANK
         BNE   FNDTYPE            NOT BLANK THEN GO ON
         LA    R2,1(R2)           INCR. R2 TO NEXT BYTE
         BCT   R3,LOOPSMM         DO IT 8 TIMES
         B     STRTCOL8           ISSUE ERROR MESSAGE FOR STARTING
FNDTYPE  CLC   0(7,R2),=C'SELECT='   WAS SELECT SPECIFIED
         BNE   TRYEXCL            NO, THEN TRY EXCLUDE
         LA    R2,7(R2)           ADDRESS PASS SELECT STATEMENT
         B     CLEARR9             CONITNUE AROUND
TRYEXCL  CLC   0(8,R2),=C'EXCLUDE='  DID THEY AT LEAST DO EXCLUDE
         BNE   BADINPUT           IF NOT THEN THEY'RE ASKING CRAP
         OI    FLAG1,X'10'        SET FLAG TO SPECIFY EXCLUDE
         LA    R2,8(R2)           POINT PAST THE EXCLUDE STATEMENT
CLEARR9  CLI   0(R2),C' '         IF IT IS A BLANK THEN IT IS WRONG
         BE    SYNTAXER           BYE BYE MORON
         SLR   R9,R9              CLEAR R9 FOR 100 MMBER LIMIT CNTR
SETREGS  LA    R3,9               MEMBER LIM + 1 ( MAX 8 + 1 )
         LR    R8,R2              LOAD R8 WITH POINTER
PASSMEM  CLI   0(R8),C','         SEARCH FOR DELIMETER BETWEEN MEMS
         BE    GOTLEN             IF COMMA THEN GO
         LA    R8,1(R8)           INCREMENT 1 MORE
         CR    R8,R7              ARE WE AT THE END OF THE RECORD
         BNL   GOTLEN             YES, THEN WE'VE PROCESSED LAST MEM
         BCT   R3,PASSMEM         DO 8 TIMES PLUS ONE MORE FOR BLANK
         CLI   0(R8),C' '         THIS BETTER BE A BLANK
         BNE   SYNTAXER           IF NOT THEN ANOTHER MORON
         MVC   0(8,R10),0(R2)     MOVE IN MEMBER NAME TO BLDL LIST
         LA    R10,8(R10)         INCR R10 FOR NEXT MEMBER
         LA    R9,1(R9)           KEEP COUNT OF MEMBER LIST
         CH    R9,=H'501'         HAVE WE REACHED THE LIMIT YET
         BNL   TOOMANY            IF 1 MORE THEN QUIT ON THE MORON
         B     GETNEXT            NO, THEN DO THE NEXT ONE
GOTLEN   SR    R8,R2       WE FOUND A COMMA, SO GET LNGTH FOR MOVE
         BCTR  R8,0               DECR 1 FOR EX INSTR
         EX    R8,MVEINMM         MVC   0(0,R10),0(R2)
         LA    R10,8(R10)         INCR TO NEXT MEMBER FO BLDL LIST
         LA    R9,1(R9)           INCR MEMBER COUNTER
         CH    R9,=H'501'         HAVE WE SURPASSED THE LIMIT
         BNL   TOOMANY            YES, THEN TELL THEM AND QUIT
         LA    R2,2(R8,R2)        RE-ADDR R2 TO POINT PAST THE COMMA
         CR    R2,R7              IF AT THE END OF OUR RECORD QUIT
         BNL   GETNEXT            IF NOT THEN DO CHECK FOR A BLANK
         CLI   0(R2),C' '         IS IT THE END FOR THIS RECORD
         BNE   SETREGS            NO, THEN RESET R3 AND R8 AND DO NEXT
GETNEXT  GET   SYSMEM
         LR    R2,R1              LOAD R2 WITH POINTER FOR GET
         LA    R7,70(R2)          POINT TO END OF RECORD
         LA    R3,8               GET TO BEGIN COLUMN
GETBEGIN CLI   0(R2),C' '         FIND A NON-BLANK
         BNE   SETREGS            IF FOUND THEN GO PROCESS RECORD
         LA    R2,1(R2)           INCR TO NEXT BYTE
         BCT   R3,GETBEGIN        LOOP THRU
         B     STRTCOL8           IF HERE THEN TELL TO START BY COL 8
ENDMEM   EQU   *
         CLOSE SYSMEM
         MVC   0(8,R10),FFFLAG    FLAG END OF MEMBER LIST
         L     R10,STRADDR2       LOAD R10 WITH BEGINNING OF LIST
         LTR   R9,R9              SEE IF ANY MEMBERS PROCESSED
         BZ    BADINPUT           IF NOT THEN WE'RE IN TROUBLE; BYE
         CH    R9,HW1             SEE IF ONLY ONE MEMBER SPECIFIED
         BE    VERMFLG            YES, THEN GO AROUND THIS
         LR    R14,R9             LOAD CNTR INTO R14
         BCTR  R14,0              AND DECR IT ONE
         LR    R15,R14            NOW, LOAD THIS INTO R15
**********************************************************************
*  AS STUPID AS IT MIGHT SEEM HERE TO MOVE IN 'Z        ', IT IS BE- *
*  ING DONE SO THAT IF SOMEONE SPECIFIES A MEMBER MORE THEN ONCE IT  *
*  IS NOT PROCESSED MORE THEN ONCE. BLDL WILL RETURN A PROPER ENTRY  *
*  FOR EACH TIME YOU SPECIFIED THE MEMBER, HENCE SET AN ERRONEOUS    *
*  MEMBER NAME THAT IS NEVER FOUND AND LET BLDL GIVE AN RC OF 4 .    *
*  MEMBERS WILL ALSO BE SORTED IN ALPHABETICAL ORDER FOR BLDL.       *
**********************************************************************
         LA    R6,8(R10)          LOAD R6 WITH 8 PAST R10 FOR NEXT MEM
COMPMEM  CLC   0(8,R10),0(R6)     IF MEMBERS ARE EQUAL THEN MUST FLAG
         BL    MEMINCR            IF LESS THEN WE'RE OKAY, CONTINUE
         BH    WRKSRT             IF GREATER THEN FLIP FLOP NAMES
         MVC   0(8,R6),=X'E9FFFFFFFFFFFFFF'  IF EQ THEN RESET NAME
         B     MEMINCR            GO TO NEXT
WRKSRT   MVC   WRKAREA(8),0(R10)  MOVE THIS NAME OVER
         MVC   0(8,R10),0(R6)     AND THIS NAME INTO PLACE
         MVC   0(8,R6),WRKAREA    AND LASTLY THIS ONE BACK IN
MEMINCR  LA    R6,8(R6)           INCR R6 TO POINT TO NEXT MEMBER
         BCT   R15,COMPMEM        SORT THRU THE LIST
DECRR14  BCTR  R14,0              DECREMENT R14 FOR SORT THRU LIST
         LTR   R14,R14            ARE WE DONE
         BZ    VERMFLG            YES, THEN CONITUNUE
         LR    R15,R14            NO, RELOAD R15 FOR SORT PASS
         LA    R10,8(R10)         POINT TO NEXT MEMBER IN LIST
         LA    R6,8(R10)          AND THE NEXT ONE AFTER HIM
         CLC   0(8,R6),FFFLAG     ARE WE AT THE END OF THE LIST
         BNE   COMPMEM            NO ,THEN DO IT AGAIN
VERMFLG  TM    FLAG1,X'10'        ARE WE DOING EXCLUDE PROCESSING
         BZ    LISTMEMS           NO, THEN GO AROUND
         MVC   SELECTVE+3(8),=C'EXCLUDED'  YES, SET THIS IN THE OUTPUT
LISTMEMS LR    R6,R9              WILL NOW PRINT THE MEMBER LIST
         PUT   ERRPRIN1,SELECTVE
         MVI   SELECTVE,C'0'      RESET CC
         MVC   SELECTVE+1(60),BLANKS   BLANK OUT LINE
         L     R7,STRADDR2        POINT TO BEGINNING OF LIST
         LA    R5,SELECTVE+10     POINT TO OUTPUT RECORD
         LA    R8,10              DO TEN PER LINE
LISTLOOP CLC   0(8,R7),=X'E9FFFFFFFFFFFFFF'  IF IT IS A DUMMY MEMBER
         BE    PUTSEL             THEN WE ARE AT THE END OF THE LIST
         MVC   0(8,R5),0(R7)      IF NOT THEN MOVE NAME IN
         LA    R5,9(R5)           INCREMENT OUTPUT LINE
INCRLIST LA    R7,8(R7)           INCR THRU MEMBER LIST
         BCTR  R6,0               DECR R6
         LTR   R6,R6              HAVE WE DONE ALL THE MEMBERS YET
         BZ    PUTSEL             YES, THEN
         BCT   R8,LISTLOOP        WILL DO 8 PER LINE
PUTSEL   EQU   *
         PUT   ERRPRIN1,SELECTVE
         LTR   R6,R6              SEE IF WE'RE DONE WITH THE MEMBERS
         BZ    VEREFLG            YES, THEN CONTINUE
         CLC   0(8,R7),=X'E9FFFFFFFFFFFFFF'  IF IT IS A DUMMY MEMBER
         BE    VEREFLG            THEN WE ARE AT THE END OF THE LIST
         LA    R5,SELECTVE+10     NO, THEN RESET POINTER TO BEGINNING
         MVI   SELECTVE+1,C' '    WILL BLANK OUT THE ENTIRE
         MVC   SELECTVE+2(118),SELECTVE+1   PRINT LINE
         LA    R8,10              RESET COUNTER
         B     LISTLOOP           GET BACK INTO LOOP
VEREFLG  EQU   *
         L     R6,STRADDR2
******************************************************************
*   HERE WE WILL READ IN THE DIRECTORY MEMBERS SO THAT WE MAY    *
*  THEN ISSUE A BLDL MACRO. THE GETMAIN WILL SUPPORT THE PROCESS-*
*  ING OF 50000 MEMBERS IN THE PDS. I ADDED THE GETMAIN FOR 256  *
*  BYTES BECAUSE I NEEDED THE STORAGE BACK IN THE PROGRAM. I HAD *
*  PASSED 2 BASE REGISTERS AND IT WAS EASIER TO ADD THE GETMAIN  *
*  AND BUY BACK THE 256 BYTES FOR THE READ OF THE DIRECTORY.     *
*                                                                *
*   17 MAR 86  REALIZED THAT I WAS DOING WASTEFUL I/O BY READING *
*  THE DIRECTORY AND THEN DOING A BLDL. ALL I NEED IS THE NAME,  *
*  TTR, AND THE FIRST BIT OF LOCATION 12 (OFFSET 11) FOR ALIASES.*
*    INCREASED THE GETMAIN FROM 16000 TO 131780 SO AS TO STORE AN*
*  AN 8 BYTE MEMBER NAME, 3 BYTE TTR, 1 BYTE ALIAS SETTING, AND  *
*  THEN READ DIRECTORY.                                          *
******************************************************************
*******************************************************
*   WE WANT THE DATA SET NAME FOR THE OUTPUT.         *
*******************************************************
GETDSN   EQU   *
         RDJFCB MF=(E,RDJFCB1)
         CLC   JFCBAREA(8),=C'NULLFILE'
         BE    DONXTPDS
         MVC   DATASET(44),JFCBAREA   MOVE IN THE DATA SET NAME
MVODDN   MVC   ODDNAME(8),PDSCHGE+40    MOVE IN DDNAME
         TM    FLAG2,X'10'            SEQUENTIAL FILE PROCESSED
         BZ    GETDSTR             NO, THEN DO NOT LOOK FOR MMBER NAME
DOPSMEM  CLI   JFCBAREA+44,C' '
         BNH   OPENFILE
         LA    R14,DATASET+43     POINT TO END OF DSNAME
         LA    R15,43                MUST BE AT LEAST ONE BYTE LONG
LOOPJFCB CLI   0(R14),C' '        IS IT A BLANK
         BNE   GOTEND
         BCTR  R14,0
         BCT   R15,LOOPJFCB   IF THIS FALLS THRU THEN WE ARE IN TROUBLE
         L     R0,ABADJFCB
         PUT   ERRPRIN1,(0)
         B     DONXTPDS
GOTEND   MVI   1(R14),C'('
         MVC   2(8,R14),JFCBAREA+44
         LA    R14,9(R14)
         LA    R15,7
LOOPJMM  CLI   0(R14),C' '
         BNE   GOTENDM
         BCTR  R14,0
         BCT   R15,LOOPJMM
GOTENDM  MVI   1(R14),C')'
         B     OPENFILE          SO, GO AROUND
GETDSTR  EQU   *
         TM    FLAG2,X'20'                ADDED CHECKING
         BO    LODADDR3                   ALREADY ACQUIRED, AROUND
         GETMAIN EU,LV=600260,A=STRADDR3  ENOUGH STORAGE FOR 50000
*                      MBRS+4
         OI    FLAG2,X'20'         SET THIS TO SAY WE ACQUIRED STORAGE
LODADDR3 L     R3,STRADDR3
*******************************************************************
*******************************************************************
OPENDIR  EQU   *
         OPEN  (DIRREAD)           OPEN PDS TO READ DIRECTORY
         TM    DIRREAD+48,X'10'    OPEN SUCCESSFUL
         BZ    DONXTPDS            NO, THEN QUIT
OPENOK   EQU   *
         L     R7,STRADDR3        LOAD VALUE INTO R11
         SLR   R2,R2
         LA    R11,260(R7)        POINT PAST DIRECTORY READ
LOCSET   READ  DIRDECB,SF,DIRREAD,(7)
         CHECK DIRDECB
RDNXTDIR EQU   *
LIST0    LR    R10,R7              R10 POINTS TO FIELD READ
         LH    R9,0(R10)           R9 CONTAINS LENGTH OF RECORD
         AR    R9,R10              POINT TO END OF LIST
         LA    R10,2(R10)          ADDRESS MEMBER
LIST1    CLC   0(8,R10),FFFLAG     IS THIS THE LAST DIRECTORY ENTRY
         BNE   LIST2               NO, THEN CONTINUE
DIRENDL  MVC   0(8,R11),FFFLAG    FLAG END OF MEMBER LIST
         CLOSE DIRREAD             CLOSE DIRECTORY
         NI    WRTFLAG,X'FD'      RESET FLAG
         L     R11,STRADDR3        RELOAD R11 POINTER
         LA    R11,256(R11)        RELOAD R11 POINTER
         LTR   R2,R2              VERIFY THAT AT LEAST 1 MEMBER EXIST
         BNZ   STRR2
         PUT   ERRPRIN1,FUNNYMAN
         B     DONXTPDS
STRR2    STH   R2,0(R11)          STORE TO SIMULATE A BLDL LIST
         MVC   2(2,R11),=H'12'     LENGTH OF MEMBER ENTRY
         LA    R11,4(R11)          INCREMENT PAST COUNT
         TM    FLAG1,X'20'         IS THERE A MEMBER LIST
         BZ    OPENFILE            CONTUINUE PROCESSING
         L     R1,STRADDR2
         FREEMAIN R,LV=4008,A=(1)
         B     OPENFILE
LIST2    TM    FLAG1,X'20'         IS THERE A MEMBER LIST
         BZ    DIRMEMMV            NO EXCLUDE LIST, BR AROUND
         TM    FLAG1,X'10'         IS THERE AN EXCLUDE LIST
         BZ    DIRSEL              NO EXCLUDE LIST, THEN DO SELECT
ENDEXCL  CLC   0(8,R6),FFFLAG    MAKE SURE NOT AT END OF LIST
         BE    DIRMEMMV           YES, THEN CONTINUE BLDING
CHECKEX  CLC   0(8,R10),0(R6)     DO WE EXCLUDE THIS MEMBER
         BL    DIRMEMMV           IF LESS MOVE IN MEMBER
         BE    GETPAST            IF EQUAL BRANCH AROUND AND WE'LL
*                                  INCREMENT NEXT PASS
         LA    R6,8(R6)           IF GREATER INCR. EXCLUDE LIST
         B     ENDEXCL            AND CONTINUE CHECKING
DIRSEL   CLC   0(8,R6),FFFLAG     MAKE SURE NOT AT END OF LIST
         BE    DIRENDL            YES, THEN FINISHED WITH DIRECTORY
         CLC   0(8,R6),=X'E9FFFFFFFFFFFFFF'  IF IT IS A DUMMY MEMBER
         BE    DIRENDL            YES, THEN FINISHED WITH DIRECTORY
CHECKSL  CLC   0(8,R10),0(R6)     DO WE SELECT  THIS MEMBER
         BE    INCSLNPS           IF EQUAL MOVE IN MEMBER AND INCR R6
         BL    GETPAST            IF LESS  BRANCH AROUND
SETRTC4  OI    WRTFLAG,X'80'      SET AS RETURN CODE NOT FOUND
         LA    R6,8(R6)           INCREMENT THIS POINTER FOR NEXT PASS
         B     DIRSEL             AND CONTINUE CHECKING
INCSLNPS LA    R6,8(R6)           INCREMENT THIS POINTER FOR NEXT PASS
DIRMEMMV EQU   *
MVMMBRN  MVC   0(12,R11),0(R10)    MOVE IN MMBR NAME,TTR, AND ALIAS BIT
         LA    R2,1(R2)            INCR. COUNTER FOR MEMBERS
         LA    R11,12(R11)         INCR. INPUT MEMBER LIST
GETPAST  IC    R14,11(R10)          GET # OF USER HALFWORDS
         N     R14,=F'31'           ZERO OUT HI ORDER BITS
         SLA   R14,1                MULTIPLY BY TWO
         LA    R14,12(R14)          ADD THE CONSTANT SECTION TO IT
         AR    R10,R14             AND THEN INCREMENT R10
         CR    R10,R9              ARE WE AT THE END OF THIS READ
         BL    LIST1               NO, THEN PROCESS THE NEXT
         B     LOCSET              READ NEXT RECORD
         EJECT
ERRCOD2  OI    OUTFLAG,X'08'      SET FLAG TO SAY WE GOT HERE
NOTDIR   EQU   *
         CLOSE DIRREAD             CLOSE DIRECTORY
         TM    OUTFLAG,X'08'
         BO    IOERROR
         PUT   ERRPRIN1,ENDDIRD
         B     DONXTPDS
*****************************************************************
*  IF NO CHANGE OPTION SPECIFIED THEN ONLY OPEN PDS FOR INPUT;  *
*  IF CHGE OPTION IN EFFECT THEN OPEN AS UPDATE.                *
*****************************************************************
OPENFILE TM    FLAG1,X'01'            IS THIS A NO CHANGE RUN
         BZ    ISSBLDL
         OPEN  PDSCHGE            OPEN PDS UP FOR INPUT ONLY
         TM    PDSCHGE+48,X'10'   GOOD OPEN ??
         BO    CHKRECFM           YES, THEN CONTINUE EUROK
         B     DONXTPDS           QUIT
ISSBLDL  OPEN  (PDSCHGE,(UPDAT))  OPEN PDS UP FOR UPDATE
         TM    PDSCHGE+48,X'10'   GOOD OPEN ??
         BZ    DONXTPDS           QUIT
CHKRECFM TM    PDSCHGE+36,X'C0'  RECFM MUST NOT BE U
         BO    BADATTR            IF RECFM U THEN SEE GET OUT
         TM    PDSCHGE+36,X'40'    RECFM MUST NOT BE V EITHER
         BZ    SEELRCL            IF 0 FIXED RECORD , CHECK LRECL
         B     BADATTR            WE DO NOT DO VARIABLE EDITING
SEELRCL  LH    R3,PDSCHGE+82      LRECL
         CH    R3,=H'90'          AT THIS TIME WE'LL ONLY DO 90 BYTES
         BNH   OPENOK2
         LTR   R3,R3
         BNZ   OPENOK2
BADATTR  EQU   *
         PUT   ERRPRIN1,BDLATTR
         CLOSE PDSCHGE             CLOSE PDS
         B     DONXTPDS
OPENOK2  L     R9,PDSCHGE+44      ADDR. OF DEB
         L     R9,32(R9)          ADDR. OF UCB
         MVC   UNITNME(3),13(R9)  UNIT ADDR ( EBCDIC)
         MVC   VOLUME(6),28(R9)   VOLUME SERIAL NUMBER
**********************************************************************
* I DECIDED TO INCREASE THE GETMAIN FOR READING BLOCKS OF DATA TO THE*
* MAXIMUM VALUE. THIS WAY, THE STORAGE WILL ONLY BE ACQUIRED ONCE AND*
* RELEASED ONCE. IT MIGHT BE WASTEFUL TO GET 32K IF I MIGHT ONLY NEED*
* LESS THEN 1 PAGE FOR ANY BLOCKSIZE, BUT IT'S MY PROGRAM AND IF YOU *
* DON'T LIKE IT, CHANGE IT. ALSO, IF IT IS LOAD MODULE PROCESSING AN *
* EXTRA 12K WILL BE ACQUIRED TO STORE THE ESD ENTRIES AND CONTROL    *
* RECORDS.                                                           *
**********************************************************************
GOODBLD  TM    FLAG2,X'40'     DID WE ALREADY ACQUIRE BLKSIZE STORAGE
         BO    ISSEQH          YES, THEN GO AROUND
GETSTR4  LH    R2,H32760          GET MAX BLKSIZE LNGTH FOR GETMAIN
*******  LH    R2,PDSCHGE+62      GET BLKSIZE LENGTH(WHAT IT WAS)
*                              ESD 17 BYTE ENTRIES + MULTI-BLKSIZE)
NOLMSTR  ST    R2,LNGADDR4        SAVE LENGTH FOR FREEMAIN
         LR    R0,R2              ADDR. R0 FOR GETMAIN
         GETMAIN R,LV=(0)
         ST    R1,STRADDR4        SAVE FOR FREEMAIN
         OI    FLAG2,X'40'        SET FLAG TO SAY WE ACQUIRED STORAGE
* NEXT LOAD IS DONE SO R10 CAN BE RELOADED ON +1 PASS PROCESSING
* OR ELSE I WOULD HAVE DONE A QUICK  LR  R10,R1
ISSEQH   L     R10,STRADDR4       ADDR. OF GETMAIN FOR READ AN WRITE
         TM    FLAG2,X'10'        ARE WE DOING A SEQUENTIAL FILE
         BO    SETCLI          YES, THEN BYPASS DIRECTORY CRAP
DOBLDL   L     R11,STRADDR3       RELOAD BEGIN. ADDR. FOR BLDL
         LA    R11,256(R11)      INCREMENT PAST DIRECTORY READ BUFFER
         LH    R2,0(R11)          NUMBER OF MEMBERS
         LA    R11,4(R11)         ADDRESS OF FIRST MEMBER
SETCLI   EQU   *
         LR    R8,R3              GET LENGTH OF COMPARE FOR ARG.
         SH    R8,LI1FLD          SUBTRACT THE INPUT LENGTH
*        LA    R8,1(R8)
         STH   R8,CLILNGTH        SAVE THIS LENGTH FOR CLI LOOP
         TM    FLAG1,X'C0'        WERE THE ARGS EQUAL
         BNZ   ADDRDECB           NO THEN DON'T RESET R4
LMDLNG4  LH    R4,LI1FLD          LOAD LENGTH FOR EX MOVE INSTR.
         BCTR  R4,0               AND OF COURSE DECREMENT FOR EX
         EJECT
******************************************************************
*  WE ARE NOW AT THE BREAD AND OLEO OF THIS PROGRAM. MEMBERS ARE *
* IN PLACE AND READY FOR THE PICKING. R9 WILL ADDR. THE DECB, R10*
* WILL ADDR. THE BLOCKS READ, R7 WILL CONTAIN THE COUNTER FOR #  *
* OF RECORDS, R5 AND R6 WILL ADDR. THE INDIVIDUAL RECORD THE MAJ-*
* ORITY OF THE TIME FROM NOW ON, R11 STILL ADDRESSES THE MEMBERS *
* AND THEIR MUCH NEEDED TTR'S, R8 CONTAINS THE COUNTER FOR COMP- *
* ARING THRU THE RECORD, R4 IS THE LENGTH ARGUMENTS AND EVERY    *
* THING ELSE IS WORKING. FLAGS ARE EXTREMELY IMPORTANT AND ARE   *
* SET AND RESET ON OCCASSION. IF EVERYTHING CHECKS OUT, A BLOCK  *
* CAN AND WILL BE UPDATED                                        *
******************************************************************
ADDRDECB LA    R9,PDSDECB         ADDR. THE DECB FOR THE PDS
         TM    FLAG2,X'10'        IS THIS A SEQUENTAIL FILE ?
         BO    READNXT            IF SO THEN JUST GO READ A BLOCK
ISITALS  TM    11(R11),X'80'      IS THIS AN ALIAS ( FIRST MEMBER )
         BO    NEXTMEM            IF SO GET NEXT MEMBER
CHKTTR   CLI   10(R11),X'00'      IF R OF TTR IS 0
         BE    NEXTMEM              THEN GO TO NEXT MEMBER ( 1ST MEM )
STRTRD   MVC   PNTTTR(3),8(R11)   MOVE TTR OF BLOCK TO TTR OF POINT
         POINT PDSCHGE,PNTTTR              MACRO
READNXT  READ  (9),SF,,(10),MF=E
         CHECK PDSDECB
         LH    R6,PDSCHGE+62      BLKSIZE
         L     R7,PDSDECB+16      IOB ADDR
         SH    R6,14(R7)          LENGTH OF BLOCK READ
         SRDL  R6,32              CLEAR R6 AND SHIFT INTO R7
         ST    R7,WRTBLK          SAVE THE SIZE SO AS TO WRITE IT BACK
         DR    R6,R3              DIVIDE BY LRECL
         LR    R5,R10             ADDR. THE BEGINNING OF BLOCK READ
         LA    R6,0(R5)           DITTO FOR R6
LOOPCLI  LH    R8,CLILNGTH        GET LENGTH FOR COUNTER
CLIARG   EX    R8,TRANSARG        TRT  0(0,R5),TRTTBLE
         BZ    INCRLRCL           IF NO ARGUMENT FOUND THEN NEXT REC
         SR    R1,R5              LETS RESET POINTER
         SR    R8,R1              AND LETS GET THE COUNTER DOWN
         LA    R5,0(R1,R5)        AND POINT TO ARGUMENT
COMPARE  CLC   0(0,R5),INFLD      LNGTH SET EARLIER. IS THIS OUR ARG ?
         BE    PRTFIND            WE FOUND IT HOORAY
         LTR   R8,R8              WAS IT THE LAST GOOD BYTE
         BZ    INCRLRCL           INCR. TO NEXT RECORD
         LA    R5,1(R5)           NO, INCR. AND KEEP CHECKING
         BCTR  R8,0                 UNTIL THE END IS HERE
         B     CLIARG             AND GO BACK THROUGH
         EJECT
****************************************************************
*   WE HAVE FOUND OUR ARGUMENT AND WILL MAKE EVERY ATTEMPT TO  *
*  TO REPLACE IT. THERE ARE 3 SECTIONS; ARGS THE SAME LENGTH,  *
*  INPUT ARG LENGTH < REPLACE ARG., AND INPUT ARG. LENGTH > RE-*
*  PLACE ARG. DUE TO THE RETENTION OF REGISTERS, REGS 1,14, AND*
*  15 HAVE BEEN USED FOR SMALL SECTIONS OF LOGIC. BE ADVISED OF*
*  WHEN ADDING CODE THAT COULD CLOBBER THESE REGS. FLAGS ARE   *
*  SET AND RESET THROUGHOUT THESE SECTIONS AND ARE OF THE UT-  *
*  MOST IMPORTANCE, SO DON'T MUCK THEM UP EITHER. THE FLAGS    *
*  USED ARE IN THE LITERALS ; FLAG1, WRTFLAG, AND OUTFLAG.     *
****************************************************************
PRTFIND  OI    OUTFLAG,X'01'      THIS IS A GLOBAL BIT FOR WHETHER WE
*                                  FOUND THE ARGUMENT FOR THE ENTIRE
*                                  PDS. IT IS CHECKED AT EXIT.
         TM    FLAG2,X'01'        CHECK TO SEE IF THIS IS A SCAN  RUN
         BZ    DCHGLN             NO, THEN BRANCH AROUND
         MVC   PRNTLNE+20(80),0(R6)  NO, THEN GET LINE OUT TO OUTPUT
         OI    OUTFLAG,X'40'      SET THESE FLAGS TO FAKE OUT
         OI    WRTFLAG,X'01'        THE OUTPUT SECTIONS
         TM    FLAG1,X'08'        ARE WE DOING PER MEMBER
         BZ    LR14RES6           THEN JUST GO AROUND
         L     R15,MEMBPKN2       LOAD UP THE COUNT
         BCTR  R15,0              DECREMENT FOR THIS ONE
         ST    R15,MEMBPKN2       STORE THE COUNT
LR14RES6 LA    R14,RESETR6        SET THIS AS THE RETURN ADDRESS
         L     R15,ADOUTPUT       LOAD UP ADDRESS OF OUTPUT
         BR    R15                BRANCH TO PROCESS OUTPUT
DCHGLN   TM    OUTFLAG,X'40'      HAVE WE CHANGED THIS LINE YET ?
         BO    HOWBIG             YES, THEN DON'T RE-WRITE INPUT LINE.
         MVC   PRNTLNE+20(80),0(R6)  NO, THEN GET LINE OUT TO OUTPUT
         TM    FLAG1,X'08'        ARE WE DOING PER MEMBER
         BZ    HOWBIG              NO THEN GO AROUND        T
         L     R15,MEMBPKN2       LOAD UP THE COUNT
         BCTR  R15,0              DECREMENT FOR THIS ONE
         ST    R15,MEMBPKN2       STORE THE COUNT
HOWBIG   TM    FLAG1,X'C0'        WHAT SIZE ARE THE TWO ARGUMENTS.
         BNZ   SMLBIG             IF NOT = LENGTH BRANCH
         EX    R4,REPLCHG         DO STRAIGHT REPLACE WITH LNGTH IN R4
         OI    WRTFLAG,X'01'      SET FLAG TO RE-WRITE THIS BLOCK
         OI    OUTFLAG,X'40'      SET FLAG TO SAY WE CHANGED THIS RCD.
CHKFLG04 TM    FLAG1,X'04'        CHANGE ONLY 1ST OCCUR. ON LINE
         BO    INCRLRCL           YES, THEN DON'T DO ANYMORE
         LA    R15,1(R4)          NO, GET LNGTH OF ARGS IN R15
         SR    R8,R15             DECR. RECORD COUNTER
         LTR   R8,R8              DID THAT PUT US AT THE END
         BC    12,INCRLRCL        BRANCH IF 0 OR MINUS
         LA    R5,0(R15,R5)       RESET R5 TO NEXT CHARACTER
         B     CLIARG             GO BACK AND KEEP DOING IT
         EJECT
SMLBIG   TM    FLAG1,X'40'        IS THE REPLACE ARG. SHORTER
         BZ    ITSBIG             NO, THEN IT IS LONGER
         LH    R14,LO2FLD         GET LNGTH OF REPLACE IN R14
         LTR   R14,R14            WAS IT A NULL ARGUMENT
         BZ    RESET              YES, THEN GO AROUND OR OC4
MOVSML   BCTR  R14,0              DECR FOR EX INSTR
         EX    R14,REPLCHG        SWITCH THEM
         LA    R14,1(R14)         THIS IS DONE IN CASE LENGTH WAS 0
RESET    LA    R5,0(R14,R5)       POINT TO BYTE POS. AFTER ARG.
         OI    WRTFLAG,X'01'      SET WRITE FLAG
         OI    OUTFLAG,X'40'      SET RECORD FLAG
SET14    LA    R14,0(R6,R3)       GET POINTER TO END OF RCD.
         LR    R15,R14            GET VALUE IN R15
         SH    R14,=H'9'          GET BACK TO COL. 71 TO START COMPARE
         CR    R14,R5             IS R14 STILL POINTING PAST R5
         BH    DECRR141           YES, THEN GET THE DIFFERENCE
         LR    R14,R15            NO, THEN RELOAD WITH R15
DECRR141 SR    R14,R5
         SR    R14,R4
         LTR   R14,R14
         BC    12,INCRLRCL        IF THIS IS TRUE JUST FORGET IT
DECRR142 BCTR  R14,0              DECREMENT R14
         LA    R15,0(R5,R4)       POINT TO POSITION AFTER INPUT ARG.
         EX    R14,SHIFTMV        MOVE OVER UNUSED INPUT ARG. FIELD
         LR    R2,R5              SAVE THIS LOCATION FOR A RELOAD
         LA    R5,1(R14,R5)       POINT TO END OF DATA AREA TO BLANK IT
         LR    R15,R4             GET LENGTH OF DIFFERENCE IN R15
DECRR152 BCTR  R15,0              DECR. FOR EX INSTR. TO BLANK OUT
         EX    R15,SHBLK          MOVE BLANKS TO EXTRA DATA
         TM    FLAG1,X'04'        ONE PER LINE
         BO    INCRLRCL           IF ONLY 1 CHANGE PER LINE GET OUT
         LH    R15,LO2FLD         RESET. GET LENGTH IN R15
         LTR   R15,R15
         BNZ   DECRR082
         LA    R15,1
DECRR082 SR    R8,R15             DECR R8 COUNTER
         LTR   R8,R8              VERIFY REMAINING LENGTH
         BC    12,INCRLRCL        IF 0 OR MINUS GET OUT
         LR    R5,R2              RESET R5 TO GOOD PTR. IN RECORD
         B     CLIARG             GO BACK TO CHECKING RECORD
         EJECT
ITSBIG   LH    R15,LI1FLD         INPUT SHORTER SO PUT IN R15
         LA    R15,0(R15,R5)      POINT TO END OF INPUT ARG.
         LR    R14,R4             GET DIFFERENCE IN R14
*  DON'T DECREMENT EX INSTR . GO ONE PAST FIELD TO COMPARE FOR BLANKS
*        BCTR  R14,0              DECREMENT FOR COMPARE OF BLANKS
         EX    R14,COMPBIG            CLC 0(0,R15),BLANKS
         BNE   TRYTHIS            IF NOT BLANKS THEN WE HAVE TO HAGGLE
         LH    R14,LO2FLD         GET LENGTH OF OUTPUT FIELD
         BCTR  R14,0              DECREMENT FOR REPLACE
         EX    R14,REPLCHG        CHANGE O.K, OVERLAY BLANKS W/ 1 SPARE
         OI    WRTFLAG,X'01'      SET FLAG TO WRITE BLOCK
         OI    OUTFLAG,X'40'      SET FLAG TO SHOW RECORD UPDATE
         TM    FLAG1,X'04'        ONE PER LINE
         BO    INCRLRCL           YES, THEN NO MORE THIS RECORD
         LH    R15,LO2FLD         RESET FIELDS
         SR    R8,R15             RESET COUNTER
         LTR   R8,R8              HOW MUCH LENGTH LEFT
         BC    12,INCRLRCL        NOT ENOUGH ( 0 OR - ) NEXT RCD.
         LA    R5,0(R15,R5)       RESET POINTER IN RECORD FIELD
         B     CLIARG             ONWARD AND UPWARD MEN
TRYTHIS  LH    R15,LI1FLD          GET TO END OF INPUT FIELD
         LA    R15,0(R15,R5)
         LA    R14,0(R6,R3)        GET TO END OF RECORD
         SH    R14,=H'9'           COLUMN 71 FOR VERIFICATION
LOOPLNG1 CLI   0(R15),C' '         FIND FIRST BLANK AFTER INITIAL DATA
         BE    NEXTPHSE            IF WE FIND IT GO FOR ENOUGH TO MOVE
         LA    R15,1(R15)          KEEP INCREMENTING
         CR    R15,R14             IF WE NOT AT COL 71 THEN
         BL    LOOPLNG1             THEN KEEP GOING
         B     NOGOOD              COL 71, JUST QUIT, NO SENSE
NEXTPHSE SLR   R1,R1               NOW FIND ENOUGH BLANKS TO EFFECT MV
LOOPLNG2 CLI   0(R15),C' '         IF IT IS NON-BLANK THEN GO OTHER
         BNE   TRYOTHER             ROUTE AND BACKTRACK FROM COL. 71
         LA    R1,1(R1)           INCR. R1, AND WHEN IT IS GREATER
         CR    R1,R4                THEN R4 THEN WE HAVE THE ROOM
         BH    MOVEUP1             GO AND MOVE IT
         LA    R15,1(R15)          INCR. R15
         CR    R15,R14             IF AT COL 71 THEN WE WILL QUIT
         BL    LOOPLNG2            NO, THEN KEEP TRYING
         B     NOGOOD              YES, FLAG AND TRY NEXT ONE
MOVEUP1  LR    R2,R15              GET LOCATION IN R2 TO BRANCH INTO
         LH    R14,LI1FLD          GET LENGTH OF INPUT ARG
         LA    R14,0(R5,R14)       POINT TO AFTER INPUT ARG
         SR    R2,R14              GET THE LENGTH IN R2 AND
         SR    R2,R4                AND MINUS THE EXCESS BLANKS AND GO
         B     TEMPMVE             TO THE MOVES ALREADY SET UP
TRYOTHER LA    R15,0(R6,R3)       GET TO END OF RECORD.
         SH    R15,=H'9'          GET TO COL 71
         LR    R14,R15            KEEP R14 AT END, SEE HOW MANY BLANKS
         LH    R1,LI1FLD          GET LENGTH OF INPUT FIELD
         LA    R1,0(R5,R1)        POINT TO END OF FIELD
LOOPLNG  CLI   0(R15),C' '        LOOK TIL NON-BLANK
         BNE   CHKLNG             WE FOUND ONE
         BCTR  R15,0              DECREMENT
         CR    R15,R1             MAKE SURE R15 NOT LESS THAN R1
         BH    LOOPLNG            KEEP LOOKING
CHKLNG   SR    R14,R15            GET LENGTH OF # OF BLANKS
         LR    R2,R15             SAVE POINTER FOR THE MORONS
*        BCTR  R14,0              DO NOT DECREMENT, ALLOW USE UP TO
*                                   COLUMN 71
         CR    R14,R4             IS THERE ENOUGH ROOM TO SWITCH
         BH    MOVEUP             YES, THEN MOVE IT IN THERE
NOGOOD   TM    OUTFLAG,X'40'      HAS THIS RECORD BEEN UPDATED ?
         BO    INCRLRCL           YES, THEN DON'T SET ERROR FLAG
         OI    OUTFLAG,X'80'      SET FLAG FOR NOT ENOUGH ROOM
         L     R15,ADOUTPUT
         BALR  R14,R15            GO DO THE OUTPUT NOW
         B     RESETR6            ON RETURN GO TO NEXT RECORD
MOVEUP   LH    R1,LI1FLD          GET LENGTH OF INPUT FIELD
         LA    R14,0(R5,R1)       POINT TO END OF IT
         SR    R2,R14             GET LENGTH OF DATA TO BE MOVED
TEMPMVE  EX    R2,MOVETEMP        MOVE IT TO TEMP HOLDING AREA
         LH    R1,LO2FLD          GET LENGTH OF OUTPUT
         BCTR  R1,0               DECR. THE LITTLE BUGGER
         EX    R1,REPLCHG         MOVE IT IN OVER ALL
         LA    R5,1(R1,R5)        RESET POINTER TO END OF FIELD
         EX    R2,MOVEBACK        MOVE BACK THE OTHER DATA
         OI    WRTFLAG,X'01'      SET FLAG TO WRITE
         OI    OUTFLAG,X'40'      SET FLAG UPDATE FOR RECORD
         TM    FLAG1,X'04'        ONE PER LINE
         BO    INCRLRCL           IF SO WE HAVE OUR QUOTA
         LH    R15,LO2FLD         RESET. GET LENGTH IN R15
         SR    R8,R15             DECR. COUNTER
         LTR   R8,R8              SEE THE LENGTH
         BP    CLIARG             IF NOT PLUS JUST FALL THRU. (R5 OK)
         EJECT
INCRLRCL TM    OUTFLAG,X'40'      DID WE UPDATE THIS RECORD
         BZ    RESETR6            NO, THEN JUST GO TO NEXT RECORD
MVEINCHG MVC   CHGELNE+20(80),0(R6) YES, THEN MOVE TO OUTPUT
         L     R15,ADOUTPUT
         BALR  R14,R15            GO PROCESS THE OUTPUT
RESETR6  LA    R6,0(R6,R3)        POINT TO NEXT RECORD
         LR    R5,R6              RESET R5 TO BEGIN
         TM    WRTFLAG,X'01'      DID WE UPDATE THE BLOCK
         BZ    DECRR7             NO, THEN READ ANOTHER BLOCK
         TM    FLAG1,X'08'        ARE WE DOING ONE PER MEMBER
         BZ    DECRR7             WE ARE FINISHED WITH THIS MEMBER
         L     R15,MEMBPKN2       LOAD UP THE COUNT
         LTR   R15,R15            HAVE WE DONE ALL OF THEM
         BC    12,EOBLK            YES, THEN GO AWAY
DECRR7   BCT   R7,LOOPCLI         GO BACK TO RECORDS
EOBLK    TM    WRTFLAG,X'01'      DID WE UPDATE THE BLOCK
         BZ    READNXT            NO, THEN READ ANOTHER BLOCK
         NI    WRTFLAG,X'FE'      RESET THIS FLAG FOR BLOCK
         TM    FLAG1,X'01'        NO CHANGE PARM IN EFFECT
         BZ    WRITIT             NO, THEN WRITE UPDATED BLOCK
         TM    FLAG1,X'08'        ARE WE DOING ONCE PER MEMBER
         BZ    READNXT            NO, THEN READ NEXT BLOCK
         L     R15,MEMBPKN2       LOAD UP THE COUNT
         LTR   R15,R15            SEE IF WE ARE DONE WITH THIS
         BC    12,EODAD           YES, THEN GO TO NEXT MEMBER
         B     READNXT            NO, STILL SOME LEFT
**********************************************
WRITIT   L     R5,WRTBLK          GET LENGTH OF WRITE BLOCK IN R5
         WRITE (9),SF,,(10),(5),MF=E
         CHECK PDSDECB
         TM    FLAG1,X'08'        ARE WE DOING ONCE PER MEMBER
         BZ    READNXT            NO, THEN READ NEXT BLOCK
         L     R15,MEMBPKN2       LOAD UP THE COUNT
         LTR   R15,R15
         BC    12,EODAD           IF 0 OR MINUS
         B     READNXT
EODAD    TM    FLAG2,X'10'        WAS THIS A SEQUENTIAL FILE
         BZ    NEXTMEM            NO, THEN INCREMENT TO NEXT MEMBER
         NI    FLAG2,X'EF'        CLEAR OUT FLAG
         B     CLOSIT             AND CLOSE FILE
NEXTMEM  LA    R11,12(R11)
         CLC   0(8,R11),FFFLAG    ARE WE AT THE END ( MY FLAG )
         BE    CLOSIT             NO, THEN READ THE NEXT ONE IN
         TM    11(R11),X'80'      IS THIS AN ALIAS
         BO    NEXTMEM            IF SO GET NEXT MEMBER
ARONIN14 CLI   10(R11),X'00'      IF R OF TTR IS 0
         BE    NEXTMEM              THEN GO TO NEXT MEMBER
         MVC   MEMBPKN2(4),MEMBPKNM RESET THIS VALUE
         B     STRTRD
CLOSIT   CLOSE PDSCHGE
         TM    OUTFLAG,X'08'      SEE IF THIS IS ENTERED FROM ERROR RTE
         BZ    NOTIOERR           YES, THEN WE ARE FINISHED
IOERROR  MVC   PDSEDDN(8),PDSCHGE+40
         PUT   ERRPRIN1,PDSIOERR
         B     DONXTPDS
NOTIOERR TM    OUTFLAG,X'01'      SEE IF WE FOUND ANY ARGUMENT
         BO    DONXTPDS           YES, THEN WE ARE FINISHED
         OI    OUTFLAG,X'02'      SET A FLAG FOR OUTPUT MESSAGE
         L     R15,ADOUTPUT
         BALR  R14,R15            GO PRINT IT AND THEN EXIT
DONXTPDS TM    FLAG1,X'20'       SEE IF SELECTIVE MEMB PROCESSING
         BO    FREESTR           YES, THEN WE ARE DONE, QUIT
         NI    OUTFLAG,X'F7'     RESET THIS FLAG IF IT WAS SET
         L     R14,DDNADDR       NO, INCREMENT TO NEXT DDNAME
         LA    R14,12(R14)       THIS IS NEXT IN OUR HANDSOME TABLE
         CLI   0(R14),X'FF'      ARE WE AT THE END OF THE LIST
         BE    FREESTR           YES, THEN FREE UP THE DIRECTORY
         MVC   MEMBPKN2(4),MEMBPKNM RESET THIS VALUE
         SLR   R15,R15           CLEAR R15 TO STORE ZEROS
         STH   R15,PDSCHGE+62     RESET BLKSIZE FOR PDSCHGE DCB ONLY
         STH   R15,DIRREAD+82     RESET LRECL SIZE TO 0 FOR DIRECTORY
         STH   R15,PDSCHGE+82     RESET LRECL SIZE TO 0 FOR PDSCHGE
         MVI   DIRREAD+48,X'02'   RESET OPEN FLAGS FOR DIRECTORY
         MVI   PDSCHGE+48,X'02'   RESET OPEN FLAGS
         MVI   PDSCHGE+36,X'00'   RESET RECORD FORMAT
         ST    R14,DDNADDR        SAVE POINTER ADDR FOR NEXT PASS
         MVC   DIRREAD+40(8),0(R14)  RESET DDNAME FIELD IN DIRECTORY
         MVC   PDSCHGE+40(8),0(R14)  RESET DDNAME FIELD IN PDSCHGE
RESTLNCT STH   R15,LINECNT        RESET LINE COUNT TO ZERO FOR NEW DSN
         NI    OUTFLAG,X'FC'      RESET PRINT OUT FLAG
* WE WILL SET THE DSORG FIELD HERE IF A SEQUENTIAL FILE IS FOUND
         CLC   0(3,R14),LTRLSEQ      SEE IF SEQUENTIAL FILE ON THIS
         BNE   GETDSN
         MVC   PDSCHGE+26(2),=X'4000'    DSORG FOR PS FILE
         OI    FLAG2,X'10'           ON THIS PASS
         MVC   HDRSEQ+14(20),SEQDESC
         B     GETDSN             GO AND VERIFY SEQUENTIAL
********************************************************************
*   THE BLKSIZE STORAGE (STRADDR4) SHOULD ALWAYS BE ACQUIRED, BUT  *
*  SEEING AS I SET A FLAG WHEN I ACQUIRED IT I AM VERIFYING IT WAS *
*  ACQUIRED AND THE FLAG WAS SET.                                  *
********************************************************************
FREESTR  TM    FLAG2,X'40'       SEE IF WE ACQUIRED BLKSIZE STOR.
         BZ    FREEDIR         NO, THEN DO NOT FREE WHAT IS NOT THERE
         L     R1,STRADDR4        LETS FREE UP TEMP. HOLDING AREA
         L     R0,LNGADDR4
         FREEMAIN R,LV=(0),A=(1)
FREEDIR  TM    FLAG2,X'20'        SEE IF WE ACQUIRED DIRCETORY STOR.
         BZ    CLOSEPRT        NO, THEN DO NOT FREE WHAT IS NOT THERE
         FREEMAIN EC,LV=600260,A=STRADDR3
CLOSEPRT EQU   *
         CLOSE SYSPRIN1
FREEDDN  L     R1,STRADDR1        LETS FREE UP TEMP. HOLDING AREA
         L     R0,LNGADDR1        LETS FREE UP TEMP. HOLDING AREA
         FREEMAIN R,LV=(0),A=(1)
RETURN   CLOSE ERRPRIN1
         TM    WRTFLAG,X'80'
         BZ    CLEARR15
         LA    R15,4
         B     RELOAD13
CLEARR15 SLR   R15,R15
RELOAD13 L     R13,4(R13)
         L     R14,12(R13)
         LM    R0,R12,20(R13)
         BR    R14
BADPARM  EQU   *
         L     R0,ANGPARM
         PUT   ERRPRIN1,(0)
         B     BADRETN
BADLINE  EQU   *
         L     R0,ANGLINE
         PUT   ERRPRIN1,(0)
         B     BADRETN
MUTEXCL  EQU   *
         L     R0,AMUPARM
         PUT   ERRPRIN1,(0)
         B     BADRETN
BADINPUT L     R0,ANGMINPT
         PUT   ERRPRIN1,(0)
         B     FREEDDNM
SYNTAXER PUT   ERRPRIN1,SYNTAX
         B     FREEDDNM
TOOMANY  PUT   ERRPRIN1,OVER500
         B     FREEDDNM
DELIMPE  L     R0,ADELIMP1
         PUT   ERRPRIN1,(0)
         B     CLOSEPR1
HEXE     L     R0,AHEXE1
         PUT   ERRPRIN1,(0)
         B     CLOSEPR1
HEXODD   L     R0,AHEXODD1
         PUT   ERRPRIN1,(0)
         B     CLOSEPR1
HEXPRSE  L     R0,AHEXPRS1
         PUT   ERRPRIN1,(0)
         B     CLOSEPR1
STRTCOL8 MVC   COL8DDN(7),=C'SYSMEM'
         PUT   ERRPRIN1,COL8
FREEDDNM L     R1,STRADDR2
         FREEMAIN R,LV=808,A=(1)
NOINPUT  EQU   *
CLOSEPR1 EQU   *
         CLOSE SYSPRIN1
FREEDDN1 L     R1,STRADDR1        LETS FREE UP TEMP. HOLDING AREA
         L     R0,LNGADDR1        LETS FREE UP TEMP. HOLDING AREA
         FREEMAIN R,LV=(0),A=(1)
BADRETN  CLOSE ERRPRIN1
         L     R13,4(R13)
         LM    R14,R12,12(R13)
         LA    R15,16
         BR    R14
*******************************************************************
*  THIS NEXT LITTLE SECTION OF CODE IS TO HANDLE I/O ERRORS WHILE *
*  PROCESSING A FILE. I AM NOT DOING ANY ERROR CHECKING, JUST AL- *
*  LOWING IT TO GO TO THE NEXT FILE WITHOUT ABENDING. ERRCODE IS  *
*  FOR THE PDSCHGE LABEL.                                         *
*  WE ARE STORING THE RETURN ADDRESS FROM ERROR RECOVERY AT +25   *
*  IN OUR SAVEAREA BECAUSE THAT IS WHERE THE SYSTEM RELOADS FROM  *
*  TO RETURN TO OUR PROGRAM. STRANGE BUT TRUE                     *
*******************************************************************
ERRCODE  OI    OUTFLAG,X'08'      SET FLAG TO SAY WE GOT HERE
MVBR2    MVC   21(3,R13),AERRBR   MOVE IN ADDRESS TO RETURN AT CLOSIT
         BR    R14
         EJECT
DIRREAD  DCB   MACRF=R,DSORG=PS,DDNAME=PDSCHGE,EODAD=NOTDIR,           X
               BLKSIZE=256,RECFM=F,LRECL=256
*              BLKSIZE=256
PDSCHGE  DCB   DDNAME=PDSCHGE,MACRF=(R,W),DSORG=PO,EODAD=EODAD,        +
               EXLST=JFCBLIST,SYNAD=ERRCODE
SYSPRIN1 DCB   DDNAME=SYSPRIN1,MACRF=PM,DSORG=PS,RECFM=FBA,LRECL=133
*              BLKSIZE=133
ERRPRIN1 DCB   DDNAME=ERRPRIN1,MACRF=PM,DSORG=PS,RECFM=FBA,LRECL=121
*              BLKSIZE=121
SYSMEM   DCB   DDNAME=SYSMEM,MACRF=GL,DSORG=PS,EODAD=ENDMEM
         READ  PDSDECB,SF,PDSCHGE,MF=L
AVERSYSN DC    A(VERSYSN)
APRNTHDR DC    A(PRNTHDR)
ADOUTPUT DC    A(DOOUTPUT)
APRODDNS DC    A(PRODDNS)
AERRBR   DC    AL3(CLOSIT)
AERRBR2  DC    AL3(NOTDIR)
ANGPARM  DC    A(NGPARM)
ANGLINE  DC    A(NGLINE)
AMUPARM  DC    A(MUPARM)
ADELIMP1 DC    A(DELIMP1)
AHEXE1   DC    A(HEXE1)
AHEXODD1 DC    A(HEXODD1)
AHEXPRS1 DC    A(HEXPRS1)
ANGMINPT DC    A(NGMINPT)
ABADJFCB DC    A(BADJFCB)
DOUBLE   DC    D'0'
MEMBPKNM DC    F'0'
MEMBPKN2 DC    F'0'
PARMADDR DC    F'0'
DDNADDR  DC    F'0'
STRADDR1 DC    F'0'
STRADDR2 DC    F'0'
STRADD2B DC    F'0'
EXCADDR2 DC    F'0'
STRADDR3 DC    F'0'
STRADDR4 DC    F'0'
LNGADDR1 DC    F'8192'
LNGADDR2 DC    F'4008'
LNGADDR3 DC    F'47780'
LNGADDR4 DC    F'0'
PNTTTR   DC    F'0'
WRTBLK   DC    F'0'
OFFSET   DC    F'0'
LI1FLD   DC    H'0'
LO2FLD   DC    H'0'
CLILNGTH DC    H'00'
LINECNT  DC    H'00'
MLINECNT DC    H'58'
HW0      DC    H'0'
HW1      DC    H'1'
HW2      DC    H'2'
HW3      DC    H'3'
HW4      DC    H'4'
HW5      DC    H'5'
HW8      DC    H'8'
H32760   DC    H'32760'
*                                      AND SAVE FOR NEXT READ
FFFLAG   DC    8X'FF'
WRKAREA  DC    CL12' '
TRANSARG TRT   0(0,R5),TRTTBLE
REPLCHG  MVC   0(0,R5),OUTFLD
SHBLK    MVC   0(0,R5),BLANKS
SHIFTMV  MVC   0(0,R5),0(R15)
MOVETEMP MVC   TEMPHLD(0),0(R14)
MOVEBACK MVC   0(0,R5),TEMPHLD
MVEINMM  MVC   0(0,R10),0(R2)
COMPBLK  CLC   0(0,R5),BLANKS
COMPBIG  CLC   0(0,R15),BLANKS
WRTFLAG  DC    X'00'
FLAG1    DC    X'01'
FLAG2    DC    X'00'
FLAG3    DC    X'00'
OUTFLAG  DC    X'00'
LTRLSEQ  DC    CL3'SEQ'
TEMPHLD  DC    CL80' '
BLANKS   DC    CL80' '
INFLD    DC    CL80' '
OUTFLD   DC    CL80' '
         EJECT
SELECTVE DC    CL121'1  SELECTED  MEMBERS WILL BE LISTED HERE : '
COL8     DS    0CL121
         DC    CL45'-  PLEASE START INPUT IN COLUMN 8 FOR DDNAME '
COL8DDN  DC    CL76'SYSIN  '
SYNTAX   DC    CL121'-   ERROR IN THE SYNTAX OF INPUT; SUPPLY 8 CHARACT+
               ER MEMBER NAME SEPARATED BY COMMAS, NOT PAST COLUMN 71.'
OVER500  DC    CL121'-   THERE IS A FIVE HUNDRED MEMBER LIMIT FOR SYSME+
               M INPUT. DECREASE AND RERUN.'
ENDDIRD  DC    CL121'-  END OF DATA SHOULD NOT HAVE BEEN REACHED FOR DI+
               RECTORY. UNKNOWN ERROR, CONTACT TECH SUPPORT.'
PDSIOERR DS    0CL121
         DC    CL36'- UNCORRECTABLE I/O ERROR ON DDNAME '
PDSEDDN  DC    CL8' '
     DC    CL87'. VERIFY THE DSORG AND THEN THE FILE BEFORE RERUNNING.'
BDLATTR  DC    CL121'-  INPUT LRECL GREATER THAN 90 BYTES, OR RECFM, OR+
                RECFM VARIABLE. SO SORRY'
FUNNYMAN DC    CL121'-PDS HAS NO MEMBERS, NOT VERY FUNNY ON YOUR PART.'
SEQDESC  DC    CL20'IS SEQUENTIAL  FILE '
PRNTLNE  DC    CL105'  '
         DC    CL28'*         MODIFIED *'
CHGELNE  DC    CL5' '
         DC    CL100'**NOCHANGE** '
         DC    CL28'*     MODIFICATION *'
HEADER1  DS    0CL133
         DC    CL22'1     PGM-SSCUCPDS '
         DC    CL5' DSN='
DATASET  DC    CL54' '
         DC    CL8' DDNAME='
ODDNAME  DC    CL8' '
         DC    CL8' VOLUME='
VOLUME   DC    CL6' '
         DC    CL13'   UNIT ADDR='
UNITNME  DC    CL3' '
         DC    CL6' '
CHNGEHD  DS    0CL133
         DC    CL22'0     INPUT ARGUMENT -'
INARGPT  DC    CL111' '
CHNGEHD2 DS    0CL133
         DC    CL13'      CHANGE '
LINECHG  DC    CL30'EVERY OCCURRENCE ON A LINE IN '
MEMBCHG  DC    CL90'EVERY LINE  ENCOUNTERED.'
HEADER2  DS    0CL133
         DC    CL20'-'
HDRSEQ   DC    CL25'UPDATES FOR THE MEMBER - '
HDRMEM   DC    CL8' '
CSCTNME  EQU   *+2
         DC    CL6' ARE :'
         DC    CL74' '
UNDERSC  DS    0CL133
         DC    CL19'+'
SCOREH   DC    CL41'_________________________________________'
LMUNDSC  DC    CL73' '
         DS    0F
RDJFCB1  RDJFCB (PDSCHGE,),MF=L
JFCBLIST DS    0F
         DC    X'07'
         DC    AL3(JFCBAREA)
         LTORG
JFCBAREA DS    0F
         DC    176C' '
TRTTBLE  DC    256X'00'
         EJECT
*******************************************************************
*  THIS NEAT LITTLE SECTION WILL READ IN THE DDNAMES, BUILD A NICE*
* TABLE OF NAMES WITH EITHER PDS OR SEQ, SORT THEM AND THEN RETURN*
*******************************************************************
PRODDNS  LR    R5,R15
         USING PRODDNS,R5
         ST    R14,DDNRET         LOAD R0 WITH LENGTH
         L     R0,LNGADDR1        LOAD R0 WITH LENGTH
         GETMAIN R,LV=(0)
         ST    R1,STRADDR1        SAVE THE LOCATION ADDR. FOR FREEMAIN
         ST    R1,DDNADDR           AND FOR PROCESSING DDNAMES
         LR    R11,R1             GET VALUE IN R11
         L     R3,16              ADDR. CVT
         L     R3,0(R3)           ADDR. TCB
         L     R3,4(R3)           ADDR. ACTIVE TCB
         L     R3,12(R3)          ADDR. TIOT
         LA    R3,24(R3)          ADDR. FIRST DDNAME
         SLR   R4,R4              CLEAR R4
         LR    R10,R4             CLEAR R10
*  NEXT STATEMENT WAS MOVED TO ALWAYS SORT NAMES BECAUSE OF
*  EXCP PROCESSING         WHS 87266
*  I TOOK OUT EXCP PROCESSING BECAUSE OF WEIRD 3390 RESULTS 3/94
LOOPDDN  CLC   4(3,R3),=C'PDS'    DOES DDNAME BEGIN WITH PDS---
         BE    MVEDDN             YES, THEN STORE THE NAME
         CLC   4(3,R3),LTRLSEQ    DOES DDNAME BEGIN WITH SEQ---
         BNE   INCRDDN            NO, THEN GET NEXT ONE
         OI    FLAG2,X'08'        SET FLAG FOR SEQUENTIAL FILE
MVEDDN   SLR   R6,R6
         ICM   R6,7,17(R3)        GET THE ADDRESS OF THE UCB
         CLI   18(R6),X'20'       IS THIS A DASD DEVICE
         BE    ITSDASD
INVALDEV MVC   INVDEVT+4(8),4(R3) MOVE DDNAME TO MESSAGE
         PUT   ERRPRIN1,INVDEVT
         B     INCRDDN            AND DO NOT BOTHER WITH IT
ITSDASD  MVC   0(8,R11),4(R3)     YES, THEN UPDATE TABLE ENTRY W/NAME
NOEXCPDD LA    R11,12(R11)         INCREMENT BY 12
         LA    R10,1(R10)         KEEP COUNT OF NUMBER OF DDNAMES
INCRDDN  ICM   R4,1,0(R3)         GET LENGTH INCREMENT
         LA    R3,0(R4,R3)        POINT R3 TO NEW DDNAME
         CLI   0(R3),X'00'        IS IT A DDNAME FIELD
         BNE   LOOPDDN            YES, THEN PROCESS NEXT ONE
         MVI   0(R11),X'FF'       FLAG END OF LIST
GETDDN   L     R14,DDNADDR        RE-ADDR BEGINNING OF DDNAME LIST
         CLI   0(R14),X'FF'       DID THEY SUPPLY ANY DDNAMES
         BNE   VERMEMDD           YES, THEN CONTINUE, ELSE MORON MSG
         PUT   ERRPRIN1,NOPDSDD
         B     FREEDDN1           GO FREE UP STORAGE AND QUIT
VERMEMDD TM    FLAG1,X'20'        ARE WE DOING MEMB PROCESSING
         BZ    NEXTDDN            NO, THEN WE ARE OKAY
         TM    FLAG2,X'08'        WAS A SEQUENTIAL FILE REQUESTED
         BZ    VONEPDS            NO, THEN WE ARE STILL OKAY
         PUT   ERRPRIN1,BADSEQ
         B     FREEDDN1           GO FREE UP STORAGE AND QUIT
VONEPDS  CLI  12(R14),X'FF'       MAKE SURE THAT WE FOUND A VALID DDN
         BE    NEXTDDN            IF FF AT +8 THEN WE AT LEAST HAVE 1
         PUT   ERRPRIN1,ONEPDST
         B     FREEDDN1           GO FREE UP STORAGE AND QUIT
NEXTDDN  EQU   *
**************************************************************
* SORT THE DDNAMES WITH ALL PDS'S FIRST THEN SEQ'S AFTER     *
**************************************************************
         CH    R10,HW1         SEE HOW MANY DDNAMES SPECIFIED
         BE    NODDSRT         IF ONLY ONE FILE THEN NO SORT
         BCTR  R10,0           DECREMENT COUNT FOR SORT
         LR    R9,R10          AND LOAD UP R9 TO HELP WITH SORT
         LA    R15,12(R14)      POINT TO NEXT ENTRY IN TABLE
COMPDDN  CLC   0(3,R14),0(R15)  COMPARE 2 ENTRIES IN THE TABLE
         BL    DDNOKH          IF LESS THEN LEAVE ALONE
         BH    FLIPDDN         IF GRTR THEN FLIP THEM
FLIPDDN  MVC   WRKAREA(12),0(R14)  IF GREATER THEN SWITCH
         MVC   0(12,R14),0(R15)    AND SWITCH
         MVC   0(12,R15),WRKAREA   AND SWITCH
DDNOKH   LA    R15,12(R15)       INCREMENT TABLE POINTER
         BCT   R9,COMPDDN      AND LOOP THRU TILL ALL ARE DONE
         BCTR  R10,0           DECREMENT SORT COUNTER
         LTR   R10,R10         HAVE WE DONE ALL ENTRIES ?
         BZ    REL14DD         YES, THEN GET OUT OF SORT
         LR    R9,R10          RELOAD COUNTER INTO R9
         LA    R14,12(R14)      INCREMENT 1ST TABLE POINTER
         LA    R15,12(R14)      AND POINT TO NEXT ENTRY IN TABLE
         CLI   0(R15),X'FF'    DOUBLE CHECK FOR END OF TABLE
         BNE   COMPDDN         NOT END, THEN KEEP LOOPING
REL14DD  L     R14,DDNADDR        RE-ADDR BEGINNING OF DDNAME LIST
NODDSRT  MVC   DIRREAD+40(8),0(R14)  MOVE DDNAME TO DIRECTRY DCB
         MVC   PDSCHGE+40(8),0(R14)    AND PDS DCB
CHKSQFL  TM    FLAG2,X'08'           SEE IF SEQUENTIAL FILE REQUESTED
         BZ    NOPARM                NO, THEN DO NOT WORRY
LOOKSEQ  CLC   0(3,R14),LTRLSEQ      SEE IF SEQUENTIAL FILE ON THIS
         BNE   PRORET
SETDSRG  MVC   PDSCHGE+26(2),=X'4000'    DSORG FOR PS FILE
         OI    FLAG2,X'10'       ON THIS PASS. SET FLAG FOR SEQ FILE
         MVC   HDRSEQ+14(20),SEQDESC
PRORET   L     R14,DDNRET
         BR    R14
DDNRET   DC    F'0'
NOPDSDD  DC    CL121'-   IT SEEMS THAT YOU HAVE NOT SUPPLIED ANY VALID +
               DDNAMES. PREFIX DDNAME WITH PDS OR SEQ AND RERUN.'
INVDEVT  DC    CL121'-            DDNAME EXISTS ON A DEVICE THAT IS NOT+
                SUPPORTED BY THIS PROGRAM. SORRY.'
BADSEQ   DC    CL121'- YOU CAN NOT PROCESS A SEQUENTIAL DDNAME WITH THE+
                MEMB PARAMETER. CORRECT AND RERUN.'
ONEPDST  DC    CL121'- YOU CAN ONLY PROCESS ONE PDS AT A TIME WITH THE +
               MEMB PARAMETER. CORRECT AND RERUN.'
         LTORG
         DROP  R5
******************************************************************
         EJECT
******************************************************************
*  THIS IS OUR HANDSOMELY PRODUCED OUTPUT SECTION. REGISTERS ARE *
* SAVED ON ENTRY AND THEN RESTORED AT DEPARTURE. ALL OUTPUT REC- *
* ORDS HAVE BEEN BUILT AND WE COME HERE ONLY TO MAKE THEM A      *
* LITTLE NEATER. WE GUESSTIMATE AT LEAST 58 -  61 LINES PER PAGE.*
******************************************************************
         USING DOOUTPUT,R15
DOOUTPUT STM   R2,R14,OUTSAVE     SAVE THE REGS
         LR    R10,R15
         DROP  R15
         USING DOOUTPUT,R10
GETLNCT  LH    R2,LINECNT         RELOAD LINE COUNT
         LTR   R2,R2              ARE WE AT TOP OF PAGE
         BNZ   OCHKMEM            NO, THEN DON'T PRINT HEADERS
         LA    R2,4(R2)           INCREMENT COUNTER
         PUT   SYSPRIN1,HEADER1
         PUT   SYSPRIN1,CHNGEHD
         PUT   SYSPRIN1,CHNGEHD2
         TM    OUTFLAG,X'02'      DO WE WANT A NO ARG FOUND FIELD
         BZ    OCHKMEM            NO, THEN CONTINUE WITH NORMAL OUTPUT
         NI    OUTFLAG,X'FC'      RESET IT FOR THE OVERALL PROCESSING
         PUT   SYSPRIN1,NOARGFD
         LM    R2,R14,OUTSAVE     RESTORE REGS
         BR    R14                RETURN TO NIMH
OCHKMEM  EQU   *
         TM    FLAG2,X'10'        IF THIS IS A SEQUENTIAL PROCESS
         BO    OMVEMEM            THEN DO NOT CHECK MEMBER NAMES
         CLC   HDRMEM(8),0(R11)   SAME MEMBER NAME FOR OUTPUT
         BE    OMVEMEM            YES, THEN DON'T SWITCH
         MVC   HDRMEM(8),0(R11)   MOVE MEMBER NAME TO PRINT LINE
PUTMEMS  EQU   *
         PUT   SYSPRIN1,HEADER2
         PUT   SYSPRIN1,UNDERSC
         MVI   PRNTLNE,C'0'       RESET TO DOUBLE SPACE AFTER NAME
         LA    R2,4(R2)           ADD INCR.
         B     OMVEOUT            GO AROUND
OMVEMEM  CH    R2,HW4             DID WE JUST PRINT THE HEADERS
         BNE   OMVEOUT            NO, THEN DON'T REPRINT
         PUT   SYSPRIN1,HEADER2
         PUT   SYSPRIN1,UNDERSC
         MVI   PRNTLNE,C'0'       DOUBLE SPACE AFTER THIS ONLY
         LA    R2,4(R2)           INCR. LINE COUNTER
OMVEOUT  EQU   *
         PUT   SYSPRIN1,PRNTLNE
         MVI   PRNTLNE,C' '       RESET ANSI TO SINGLE SPACE
         TM    FLAG2,X'01'        SEE IF SCAN  PARM RUN ONLY  3 MAR 86
         BO    RESETRF            YES, THEN GO AROUND         3 MAR 86
         LA    R2,1(R2)           INCR. COUNTER
         TM    OUTFLAG,X'80'      DID WE FLAG AS TOO BIG TO CHANGE
         BZ    ONOERR             NO, THEN PRINT THE CHANGE
         NI    OUTFLAG,X'7F'      RESET THE FLAG
         PUT   SYSPRIN1,ERRLINE
         B     INCROUT            BRANCH AROUND
ONOERR   PUT   SYSPRIN1,CHGELNE
RESETRF  NI    OUTFLAG,X'BF'      RESET RECORD FLAG
INCROUT  LA    R2,1(R2)           EITHER WAY INCREMENT COUNTER
         CH    R2,MLINECNT        ARE WE AT AT LEAST 58
         BL    GOBACK             NO, THEN SAVE R2 COUNTER AS IS
         SLR   R2,R2              YES, RESET TO 0
GOBACK   STH   R2,LINECNT         STORE EITHER 0 OR COUNT
         LM    R2,R14,OUTSAVE     RESTORE REGS
         BR    R14                RETURN TO NIMH
OUTSAVE  DS    13F
NOARGFD  DC    CL133'-         ****     UNABLE TO FIND ANY OCCURRENCE O+
               F ARGUMENT SPECIFIED FOR THE ABOVE LISTED FILE   ****'
ERRLINE  DC    CL105'                    *****   UNABLE TO CHANGE THIS +
               RECORD.   *****'
         DC    CL28'*     MODIFICATION *'
         LTORG
         DROP  R10
         EJECT
*****************************************************************
*  THIS IS THE INPUT SECTION WHICH WILL CONSIST OF ONLY ONE CON-*
* TROL CARD WITH THE CHANGE AND THE NUMBER. THE FORMAT IS :     *
*           /INPUT ARGUMENT/CHANGE/ 1 1                         *
*  WHERE '/' ARE DELIMETERS AND ARE REQUIRED. THE INPUT ARGUMENT*
* BECOMES THE SEARCH ARG., AND THE CHANGE REPLACES IT. THE NUM- *
* ERIC VALUES OF '1' '1' ARE FOR NUMBER OF OCCURRENCS IN A LINE *
* AND NUMBER OF OCCURRENCES IN A MEMBER. THE VALUE IS EITHER ONE*
* OR ALL. IF THE SECOND '1' IS REQUESTED CODE ANYTHING IN THE   *
* FIRST POSITION. (E.G.)  /DATA/CHANGE/ * 1                     *
*                                                               *
*  IF PARM SCAN  WAS SPECIFIED THEN THE INPUT ARGUMENT WILL HAVE*
* THE FORMAT :    /DATA/ 1 1                                    *
*   NO CHANGE ARGUMENT IS NECESSARY HERE                        *
*****************************************************************
         USING VERSYSN,R15
VERSYSN  STM   R2,R14,INSAVE
         LR    R10,R15
         DROP  R15
         USING VERSYSN,R10
         RDJFCB MF=(E,RDJFCB2)
         CLC   JFCBAREA(8),=C'NULLFILE'
         BNE   OPENSIN
         OI    FLAG1,X'02'        SET FLAG FOR WTOR
ASKFOR   WTOR  'SSCUCPDS -  PLEASE SUPPLY THE INPUT STATEMENT FOR THE P+
               DS CHANGE ROUTINE OR QUIT.',REPLY,80,WTORECB,ROUTCDE=2
         WAIT  ECB=WTORECB
         MVI   WTORECB,X'00'
         OC    REPLY(80),BLANKS   CAPITALIZE EVERYTHING
         CLC   REPLY(4),=C'QUIT'  IS THIS RUN A MISTAKE
         BE    CLOSEPRT           YES, THEN JUST QUIT
         LA    R2,REPLY           GET THE INPUT COMMAND
         B     GOTRCD             AND JUMP INTO THE MIDDLE OF PROCESS.
*******************************************************************
OPENSIN  L     R1,4(R13)     LOAD UP CALLING ROUTINES SAVE AREA
         CLC   72(8,R1),=C'SYSLKPDS'     SEE IF THIS PGM CALLED US
         BNE   OPENSYSN
         L     R1,36(R1)     LOAD UP VALUE OF CALLERS R4
         MVC   REPLY(80),0(R1)    HE ALREADY READ THE INPUT RECORD
         LA    R2,REPLY           LOAD UP WITH VIRTUAL SYSIN RECD
         B     GOTRCD             DO NOT PROCESS SYSIN
OPENSYSN OPEN  SYSIN
         TM    SYSIN+48,X'10'     VALID OPEN OF SYSIN
         BZ    CLOSEPR1
OPENOK3  GET   SYSIN,REPLY        GET THE ONE AND ONLY RECORD
         LA    R2,REPLY           ADDR. R2 WITH LOCATION
CLOSSYS  CLOSE SYSIN              CLOSE THE INPUT FILE
GOTRCD   LA    R7,79(R2)          POINT TO END OF RECORD FOR COMPARE
         LA    R3,8               DATA MUST BEGIN BY COL. 8
LOOPIT   CLI   0(R2),C' '         CHECK FOR NON - BLANK
         BNE   FRSTFLD            NOT BLANK THEN GO ON
         LA    R2,1(R2)           INCR. R2 TO NEXT BYTE
         BCT   R3,LOOPIT          DO IT 8 TIMES
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BNZ   TELLIT1            YES, THEN RESET AND GIVE NOTHER CHNCE
         PUT   ERRPRIN1,COL8
         B     CLOSEPR1           NO, THEN QUIT
TELLIT1  EQU   *
         WTO   'PLEASE START INPUT BY COLUMN 8.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
FRSTFLD  LR    R5,R2              LET R5 HOLD FIRST GOOD BYTE
         LA    R2,1(R2)           INCR R2 TO NEXT POSITION
LOOPARG2 CLC   0(1,R5),0(R2)      LETS LOOK FOR DELIMETER
         BE    GOTFRST            WE FOUND IT HOORAY
         LA    R2,1(R2)           INCR R2 AND KEEP LOOKING
         CR    R2,R7              ARE WE AT THE END OF THE RECORD
         BL    LOOPARG2           NO, THEN CONTINUE SEARCH
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    DELIMPE            NO, THEN QUIT
TELLIT2  EQU   *
         WTO   'DELIMETER PROBLEM, PLEASE GET IT RIGHT.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
GOTFRST  LR    R3,R2              GET ADDR. IN R3 OF 2ND DELIMETER
         SR    R3,R5              GET LENGTH
         BCTR  R3,0                FOR LENGTH OF FIELD
         LTR   R3,R3              IF R3 IS ZERO , NULL INPUT ARG.
         BNZ   SEEHEX             LET'S GO SEE IF HEX DATA
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    DELIMPE            NO, THEN QUIT
TELLIT3  EQU   *
         WTO   'ZERO LENGTH OF INPUT FIELD.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
SEEHEX   CLC   1(2,R5),=X'E77D'   SEE IF IN HEX FORMAT  X'
         BNE   STORIT
         OI    FLAG2,X'04'     SET THIS FLAG FOR NOW TO SHOW IN HEX
         LR    R15,R2
         BCTR  R15,0
         CLI   0(R15),X'7D'
         BE    GOOD1HEX
         TM    FLAG1,X'02'
         BZ    HEXE
TELLIT3A EQU   *
         WTO   'INVALID SYNTAX FOR HEX INPUT FIELD.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
GOOD1HEX LR    R14,R3
         SH    R14,HW3
         LTR   R14,R14            IF R14 IS ZERO , NULL INPUT ARG.
         BNZ   SETFLDS            IF NOT THEN CONTINUE
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    HEXE               NO, THEN QUIT
TELLIT3B EQU   *
         WTO   'ZERO LENGTH OF HEX INPUT FIELD.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
SETFLDS  SLR   R15,R15            CLEAR R15
         SRDL  R14,1              SHIFT OUT LO ORDER BIT FOR ODD NUM
         LTR   R15,R15
         BZ    LEVENM
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    HEXODD             NO, THEN QUIT
TELLIT3C EQU   *
         WTO   'THE NUMBER OF HEX CHARACTERS MUST BE EVEN !',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
LEVENM   LR    R3,R14             THIS IS THE TRUE LENGTH AFTER TRNSLTE
         SLL   R14,1              PUT THE ZERO BACK IN AND PARSE IT
         LA    R8,3(R5)           POINT TO FIRST BYTE OF HEX FIELD
PARSLOOP CLI   0(R8),C'A'         A CUMBERSOME PARSE BUT WORKABLE
         BL    ERRORHX
         CLI   0(R8),C'F'
         BNH   GOODHX
         CLI   0(R8),C'0'
         BL    ERRORHX
         CLI   0(R8),C'9'
         BNH   GOODHX
ERRORHX  TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    HEXPRSE            NO, THEN QUIT
TELLIT3D EQU   *
        WTO   'INVALID HEX CHARACTER; A-F OR 0-9 ARE VALID.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         B     ASKFOR             ASK AGAIN PLEASE
GOODHX   LA    R8,1(R8)
         BCT   R14,PARSLOOP
         LR    R14,R3          PUT BACK LENGTH OF INPUT
         SLL   R14,1           AND DOUBLE FOR TRUE LENGTH
         LA    R8,3(R5)        RESET TO BEGINNING
         BCTR  R14,0           DECREMENT FOR EXECUTE INSTR
         LA    R15,3(R14)
         EX    R15,MVEIARG         MOVE TO PRINT AREA AS HEX DATA
         LA    R9,TRTABLE
         EX    R14,TRNSHX      TR  0(0,R8),0(R9)
         LR    R9,R3           FOR A HALF-ASS LOOP
         LA    R1,INFLD
         SLR   R14,R14
         LR    R15,R14
HALOOP   ICM   R14,1,0(R8)
         ICM   R15,8,1(R8)
         SLL   R15,4           CLEAR OUT THE ZERO
         SLDL  R14,4
         STCM  R14,1,0(R1)
         LA    R1,1(R1)
         LA    R8,2(R8)
         BCT   R9,HALOOP
         IC    R14,INFLD
         LA    R14,TRTTBLE(R14)
         MVC   0(1,R14),INFLD     UPDATE TRANSLATE TABLE WITH ARG
         STH   R3,LI1FLD
         BCTR  R3,0
         STCM  R3,1,COMPARE+1
         SLL   R3,1            DOUBLE IT FOR THE OUTPUT AREA
         LA    R3,4(R3)        GET THIS FOR  X'  '
         B     GOTHEX
STORIT   STH   R3,LI1FLD          STORE THE LENGTH
         SLR   R14,R14            CLEAR R14 FOR IC
         IC    R14,1(R5)        INSERT SEARCH BYTE
         LA    R14,TRTTBLE(R14)   INCREMENT INTO TRANSLATE TABLE
         MVC   0(1,R14),1(R5)  MOVE THE FIRST BYTE TO SEARCH CLI
         BCTR  R3,0                LENGTH FOR EX MOVE
         STCM  R3,1,COMPARE+1     MOVE THE LENGTH FOR SEARCH CLC
         EX    R3,MVEI1FLD        MOVE INTO THE HOLDING AREA
         EX    R3,MVEIARG         MOVE TO PRINT AREA
*********************************************************************
*  WE ARE ADDING IN THE LOGIC FOR SCAN  PROCESSING, BYPASS A CHANGE *
*  ARGUMENT AND ALL THE EXCESS LENGTH PROCESSING.                   *
*********************************************************************
GOTHEX   EQU   *
NODSPLY  LA    R6,INARGPT+1(R3)   ADDR PRINT AREA PAST INP ARG.
         MVI   0(R6),C'-'
         TM    FLAG2,X'01'        IF SCAN  PARM THEN NO CHANGE ARG
         BO    CHCKLNG            GO TO COUNT FIELD
         LA    R6,5(R6)           ADDR PRINT AREA PAST INP ARG.
         MVC   0(17,R6),=C'CHANGE ARGUMENT -'
         LA    R6,17(R6)          ADDR. R6 FOR CHANGE ARG. IN OUTPUT
         LR    R5,R2              RE-ADDR. R5 WITH DELIM. POSITION
         LA    R2,1(R2)            IN CASE THEY WANT NULL ARGUMENT
         EJECT
LOOP2ARG CLC   0(1,R5),0(R2)      LET'S FIND THE ENDING DELIMETER
         BE    GOT2ND             WE FOUND IT, GOOD FOR US
         LA    R2,1(R2)           INCR. AND TRY AGAIN
         CR    R2,R7              UNLESS OF COURSE WE'VE GONE TOO FAR
         BL    LOOP2ARG           NO, WHOO WE'LL LOOK AGAIN
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    DELIMPE            NO, THEN QUIT
TELLIT4  EQU   *
         WTO   'PLEASE USE AN ENDING DELIMETER.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD
         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO
         B     ASKFOR             ASK AGAIN PLEASE
GOT2ND   LR    R3,R2              WE GOT THE ENDING DELIMETER
         SR    R3,R5              GET LENGTH
         BCTR  R3,0             WHICH OF COURSE IS -1 AFTER SUBTRACT
SEEHEX2  CLC   1(2,R5),=X'E77D'   SEE IF IN HEX FORMAT  X'
         BNE   STORIT2
         OI    FLAG2,X'04'     SET THIS FLAG FOR NOW TO SHOW IN HEX
         LR    R15,R2
         BCTR  R15,0
         CLI   0(R15),X'7D'
         BE    GOOD2HEX
         TM    FLAG1,X'02'
         BZ    HEXE
TELLIT4B EQU   *
         WTO   'INVALID SYNTAX FOR HEX INPUT FIELD.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD
         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO
         B     ASKFOR             ASK AGAIN PLEASE
GOOD2HEX LR    R14,R3
         SH    R14,HW3
         LTR   R14,R14            IF R14 IS ZERO , NULL INPUT ARG.
         BNZ   SETFLD2            IF NOT THEN CONTINUE
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    HEXE               NO, THEN QUIT
TELLIT4C EQU   *
         WTO   'ZERO LENGTH OF HEX INPUT FIELD.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD
         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO
         B     ASKFOR             ASK AGAIN PLEASE
SETFLD2  SLR   R15,R15            CLEAR R15
         SRDL  R14,1              SHIFT OUT LO ORDER BIT FOR ODD NUM
         LTR   R15,R15
         BZ    LEVENM2
         TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    HEXODD             NO, THEN QUIT
TELLIT4D EQU   *
         WTO   'THE NUMBER OF HEX CHARACTERS MUST BE EVEN !',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD
         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO
         B     ASKFOR             ASK AGAIN PLEASE
LEVENM2  LR    R3,R14             THIS IS THE TRUE LENGTH AFTER TRNSLTE
         SLL   R14,1              PUT THE ZERO BACK IN AND PARSE IT
         LA    R8,3(R5)           POINT TO FIRST BYTE OF HEX FIELD
PARSLOP2 CLI   0(R8),C'A'         A CUMBERSOME PARSE BUT WORKABLE
         BL    ERRORHX2
         CLI   0(R8),C'F'
         BNH   GOODHX2
         CLI   0(R8),C'0'
         BL    ERRORHX2
         CLI   0(R8),C'9'
         BNH   GOODHX2
ERRORHX2 TM    FLAG1,X'02'        IS INPUT FROM A WTOR
         BZ    HEXPRSE            NO, THEN QUIT
TELLIT4E EQU   *
        WTO   'INVALID HEX CHARACTER; A-F OR 0-9 ARE VALID.',ROUTCDE=11
         MVC   REPLY(80),BLANKS   CLEAR OUT THE REPLY
         MVC   INFLD(80),BLANKS   CLEAR OUT INPUT ARG. FIELD
         MVC   INARGPT(80),BLANKS CLEAR THE OUTPUT LINE ALSO
         B     ASKFOR             ASK AGAIN PLEASE
GOODHX2  LA    R8,1(R8)
         BCT   R14,PARSLOP2
         LR    R14,R3          PUT BACK LENGTH OF INPUT
         SLL   R14,1           AND DOUBLE FOR TRUE LENGTH
         LA    R8,3(R5)        RESET TO BEGINNING
         BCTR  R14,0           DECREMENT FOR EXECUTE INSTR
         LA    R15,3(R14)
         EX    R15,MVEOARG         MOVE TO PRINT AREA AS HEX DATA
         LA    R9,TRTABLE
         EX    R14,TRNSHX      TR  0(0,R8),0(R9)
         LR    R9,R3           FOR A HALF-ASS LOOP
         LA    R1,OUTFLD
         SLR   R14,R14
         LR    R15,R14
HALOOP2  ICM   R14,1,0(R8)
         ICM   R15,8,1(R8)
         SLL   R15,4           CLEAR OUT THE ZERO
         SLDL  R14,4
         STCM  R14,1,0(R1)
         LA    R1,1(R1)
         LA    R8,2(R8)
         BCT   R9,HALOOP2
         STH   R3,LO2FLD
LNGOK    BCTR  R3,0
         SLL   R3,1            DOUBLE IT FOR THE OUTPUT AREA
         LA    R3,4(R3)        GET THIS FOR  X'  '
         B     INOULN
STORIT2  STH   R3,LO2FLD          STORE THE LENGTH
DECR3L2  BCTR  R3,0               DECR. FOR EX MOVE
         EX    R3,MVEO2FLD        MOVE TO CHANGE HOLD AREA
         EX    R3,MVEOARG         MOVE TO OUTPUT AREA
INOULN   LA    R6,1(R3,R6)
         MVI   0(R6),C'-'
CHCKLNG  LA    R9,10              ARGUMENTS MUST OCCUR WITHIN 10 BYTS
         LA    R2,1(R2)           INCR. TO NEXT POSITION
LOOPCNT1 CLI   0(R2),C' '         FIND THE NON - BLANK
         BNE   CHECKEM            WE GOT ONE
         LA    R2,1(R2)           INCR. TO NEXT POSITION
         CR    R2,R7              ARE WE AT END OF RECORD
         BNL   SETOVRL            YES, THEN GO ON ; NO LENGTH
         BCT   R9,LOOPCNT1        DO FIVE TIMES
         B     SETOVRL            FIVE POSITIONS, THEN FORGET IT
CHECKEM  CLI   0(R2),C'1'         IS IT A ONE
         BNE   CHECK2ND         NO,THEN JUST A FILLER ( OR * FOR ALL)
         OI    FLAG1,X'04'        SET FLAG TO DO ONLY 1 PER LINE
         MVC   LINECHG(5),=C'FIRST'
CHECK2ND LA    R2,1(R2)           INCR TO NEXT POSITION
LOOPCNT2 CLI   0(R2),C' '         CHECK FOR NON-BLANK
         BE    GET2ND             FOUND IT, THEN GO ON
         LA    R2,1(R2)           INCR TO NEXT POSITION
         CR    R2,R7              ARE WE AT END OF RECORD
         BNL   SETOVRL            YES, THEN GO TO NEXT AREA
         BCT   R9,LOOPCNT2        DO REMAINDER OF FIVE POSITIONS
         B     SETOVRL            GO ON
GET2ND   LA    R2,1(R2)           IS LAST ARGUMENT NUMERIC
LOOPCNT3 CLI   0(R2),C' '         CHECK FOR NON-BLANK
         BNE   GET3RD             FOUND IT, THEN GO ON
         LA    R2,1(R2)           INCR TO NEXT POSITION
         CR    R2,R7              ARE WE AT END OF RECORD
         BNL   SETOVRL            YES, THEN GO TO NEXT AREA
         BCT   R9,LOOPCNT3        DO REMAINDER OF FIVE POSITIONS
         B     SETOVRL            GO ON
GET3RD   CLI   0(R2),C'0'         IS LAST ARGUMENT NUMERIC
         BL    SETOVRL            NO, THEN DON'T SET FLAG
         OI    FLAG1,X'08'        SET FLAG FOR ONE UPDATE PER BLOCK
         LA    R4,1(R2)           LOAD UP NEXT ADDR
         LA    R15,3              MAX OF 4 NUMBERS
LOOPMNUM CLI   0(R4),C'0'         IF LESS THAN WE ARE DONE
         BL    DONEMNUM           GO AROUND
         LA    R4,1(R4)
         BCT   R15,LOOPMNUM
DONEMNUM SR    R4,R2
         BCTR  R4,0
         LR    R3,R4
MNUMPACK EX    R4,PACKMNUM           PACK PACKDBLE(4),0(0,R2)
         CVB   R4,PACKDBLE
         CH    R4,HW1
         BNE   NOTFRST
         MVC   MEMBCHG(5),=C'FIRST'
         B     SEEIFPK0
NOTFRST  MVC   MEMBCHG(5),BLANKS
         EX    R3,MOVEMBCH           MVC  MEMBCHG(0),0(R2)
         MVI   MEMBCHG+10,C'S'
SEEIFPK0 LTR   R4,R4
         BNZ   STORPK
         MVI   MEMBPKNM+3,X'01'    SET TO 1
         MVI   MEMBPKN2+3,X'01'    SET TO 1
         B     SETOVRL
STORPK   ST    R4,MEMBPKNM         TO BE SAVE FOR ENTIRE PGM
STORPK2  ST    R4,MEMBPKN2         TO BE USED IN CALCULATIONS
         EJECT
******************************************************************
*  THIS NEXT AREA IS RATHER SILLY, BUT I LIKED IT LIKE THAT. R4  *
* WILL REMAIN A GLOBAL LENGTH FIELD THROUGHOUT THE REST OF THE   *
* PROGRAM. IF YOU MODIFY THIS PROGRAM AND CLOBBER R4 AFTER THIS  *
* NEXT SECTION YOUR RESULTS WILL BE AS FUNNY AS MINE WERE.       *
*  FLAGS WILL BE SET FOR THE LENGTH FIELDS, WITH A FLAG OF X'80' *
* SIGNIFYING THE OUTPUT ARG. IS GREATER THAN THE INPUT ARG. AND  *
* THE DATA AREA WILL BE EXPANDED. A FLAG OF X'40' SIGNIFIES A    *
* DECREMENT OF THE DATA AREA AFTER THE CHANGE. IF FIELDS ARE THE *
* SAME LENGTH THEN R4 CONTAINS THE LENGTH-1 FOR THE 'EX' MOVE    *
* INSTR.( WHICH IS SET LATER BEFORE THE ACTUAL READING OF PDS    *
* BEGINS. IF NOT EQUAL R4 CONTAINS THE DIFFERENCE OF THE LENGTHS *
******************************************************************
SETOVRL  TM    FLAG2,X'01'        SEE IF SCAN  PARM    3 MAR 86
         BO    RETIN              IF YES THEN DO NOT PROCESS
         SLR   R4,R4              CLEAR R4
         CLC   LI1FLD(2),LO2FLD   CHECK THE 2 LENGTH FIELDS
         BE    RETIN              IF EQUAL THEN JUST GO ON
         BL    EXPANDF            IF LESS THEN SET EXPAND FLAG
DECREAS  OI    FLAG1,X'40'        SET LESS THAN FLAG
         LH    R4,LI1FLD          GET INPUT LENGTH IN R4
DECRFORS SH    R4,LO2FLD          GET DIFFERENCE BETWEEN BOTH
         B     RETIN              CONTINUE
EXPANDF  OI    FLAG1,X'80'        SET GREATER THAN FIELD
         LH    R4,LO2FLD          GET LENGTH OF CHANGE FIELD IN R4
         SH    R4,LI1FLD          GET DIFFERENCE BETWEEN BOTH
RETIN    LM    R2,R3,INSAVE       DO NOT WANT TO RELOAD R4 BECAUSE
         LM    R5,R14,INSAVE+12   THE LENGTH IS USED THROUGHOUT PGM
         BR    R14
SYSIN    DCB   DDNAME=SYSIN,MACRF=GM,DSORG=PS,EODAD=NOINPUT,           +
               EXLST=JFCBLST2
RDJFCB2  RDJFCB (SYSIN,),MF=L
PACKDBLE DC    D'0'
INSAVE   DS    13F
WTORECB  DC    F'00'
TRNSHX   TR    0(0,R8),0(R9)           R9 FOR ADDRESSABILITY
MVEI1FLD MVC   INFLD(0),1(R5)
MVEIARG  MVC   INARGPT(0),1(R5)
MVEO2FLD MVC   OUTFLD(0),1(R5)
MOVEMBCH MVC   MEMBCHG(0),0(R2)
PACKMNUM PACK  PACKDBLE+4(4),0(0,R2)
MVEOARG  MVC   0(0,R6),1(R5)
REPLY    DC    CL80' '
JFCBLST2 DS    0F
         DC    X'07'
         DC    AL3(JFCBAREA)
         DC    8X'FF'
         DS    0F
TRTABLE  EQU   *-192
*        BECAUSE OF THE EARLIER PARSING (A THRU F AND 0 THRU 9) THE
*        CHARACTERS TRANSLATED WILL NOT OCCUR PRIOR TO OFFSET C0
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'000A0B0C0D0E0F000000000000000000'  C
         DC    X'00000000000000000000000000000000'  D
         DC    X'00000000000000000000000000000000'  E
         DC    X'00010203040506070809000000000000'  F
         LTORG
         DROP  R10
******************************************************************
*  THIS NEXT SECTION WILL BE USED TO PRINT A SUMMARY OF THIS PRO-*
*  GRAM TO INCLUDE PARM VALUES, DDNAMES, AND INPUT AND OUTPUT    *
*  FILES. I JUST FIGURED I WOULD BE NICE ???                     *
******************************************************************
         USING PRNTHDR,R15
PRNTHDR  STM   R2,R14,PRNSAVE
         DROP  R15
         LR    R10,R15
         USING PRNTHDR,R10
         L     R2,PARMADDR
         LH    R3,0(R2)
         LTR   R3,R3
         BZ    NOPARMV
         BCTR  R3,0
         EX    R3,MVEPARM
NOPARMV  EQU   *
         PUT   SYSPRIN1,HDRLNE1
         PUT   SYSPRIN1,HDRLNE2
         LA    R2,BEGLIST
         LA    R5,ENDLIST
         LA    R4,133
PRTPRM   EQU   *
         PUT   SYSPRIN1,(2)
         BXLE  R2,R4,PRTPRM
         LM    R2,R14,PRNSAVE
         BR    R14
PRNSAVE  DS    13F
MVEPARM  MVC   PARMSIN(0),2(R2)
HDRLNE1  DC    CL133'1   PARTITIONED DATA SET DISPLAY AND EDIT UTILITY'
HDRLNE2  DC    CL46'-   PARAMETER VALUES IN EFFECT FOR THIS RUN - '
PARMSIN  DC    CL87' '
BEGLIST  EQU   *
 DC CL133'-**********  EXECUTION  PARM  VALUES  **********************'
 DC CL133' *                                                         *'
 DC CL133' *  CHGE.... UPDATE THE DATA SET(S) WITH CHANGE ARGUMENT   *'
 DC CL133' *  MEMB.... SUPPLY SELECTIVE MEMBER NAMES FOR PROCESSING  *'
 DC CL133' *  SCAN.... DISPLAY ONLY OF A SEARCH ARGUMENT             *'
 DC CL133' *  LINECNT= KEYWORD PARAMETER TO SPECIFY LINES PER PAGE   *'
 DC CL133' *           (DEFAULT 61, MAXIMUM 99, MINIMUM 9)           *'
 DC CL133' *                                                         *'
 DC CL133' **********  DDNAME SPECIFICATIONS    **********************'
 DC CL133' *                                                         *'
 DC CL133' *  SYSIN....SPECIFIES THE SEARCH AND CHANGE ARGUMENTS     *'
 DC CL133' *  SYSMEM...USED WITH MEMB PARM,CONTAINS LIST OF SPECIFIC *'
 DC CL133' *           MEMBERS TO BE PROCESSED (1 PDS PER EXECUTION) *'
 DC CL133' *  PDS-----.IF DDNAME BEGINS WITH PREFIX PDS A PARTITIONED*'
 DC CL133' *           DATA SET WILL BE PROCESSED. MULTIPLE PDS----- *'
 DC CL133' *           DDNAMES CAN BE SPECIFIED.                     *'
 DC CL133' *  SEQ-----.IF DDNAME BEGINS WITH PREFIX SEQ A SEQUENTIAL *'
 DC CL133' *           DATA SET WILL BE PROCESSED. MULTIPLE SEQ----- *'
 DC CL133' *           DDNAMES CAN BE SPECIFIED.                     *'
 DC CL133' *                                                         *'
 DC CL133' *  SYSPRIN1...SPECIFIES THE INFORMATIONAL OUTPUT DDNAME   *'
 DC CL133' *  ERRPRIN1...SPECIFIES THE ERROR OUTPUT DDNAME           *'
 DC CL133' *                                                         *'
ENDLIST  EQU   *
 DC CL133' ***********************************************************'
         DROP   R10
         LTORG
NGPARM   DC    CL121'-  THE CORRECT PARM VALUES ARE EITHER MEMB, CHGE, +
               SCAN, AND OR LINECNT=. CHOOSE THE CORRECT PARMS AND RERU+
               N.'
NGLINE   DC    CL121'-  THE LINE COUNT IS SPECIFIED IN THE FOLLOWING FO+
               RMAT; LINECNT=X OR LINECNT=XX, WHERE X WILL BE A NUBER B+
               ETWEEN 9 AND 99.'
MUPARM   DC    CL121'-  THE CHGE PARM AND THE SCAN PARM ARE MUTUALLY EX+
               CLUSIVE. CHOOSE ONE OR THE OTHER AND RERUN.'
DELIMP1  DC    CL121'-  DELIMETER PROBLEM, MUST USE A BEGINNING, MIDDLE+
                OR ENDING DELIMETER, OR YOU HAVE A ZERO LENGTH INPUT FI+
               ELD.'
HEXE1    DC    CL121'-  PROBLEM WITH HEX INPUT; MUST BEGIN WITH THE LET+
               TER X AND USE SINGLE QUOTES TO DELIMIT A STRING OF HEX D+
               ATA.'
HEXODD1  DC    CL121'-  THE NUMBER OF HEX CHARACTERS SPECIFIED IN THE S+
               TRING MUST BE EVEN TO FORM A PROPER BYTE.'
HEXPRS1  DC    CL121'-  THE ONLY VALID HEX CHARACTERS ARE A THRU F AND +
               OR 0 THRU 9; YOU SHOULD KNOW THAT.'
NGMINPT  DC    CL121'-   FIRST RECORD FOR SYSMEM INPUT MUST BEGIN WITH +
               EITHER SELECT= OR AN EXCLUDE= STATEMENT. FIX AND RERUN'
BADJFCB  DC    CL121'-  PROBLEM WITH DSNAME IN JFCB. CONTACT TECH SUPPO+
               RT AND TELL THEM THIS SHOULD NEVER HAVE OCCURRED.'
         END
